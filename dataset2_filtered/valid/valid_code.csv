"int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts, bool provides_certificates) { int verify_mode = SSL_VERIFY_NONE; int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT; if (config_ != nullptr) { envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext:: TrustChainVerification verification = config_->trustChainVerification(); if (verification == envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::ACCEPT_UNTRUSTED) { verify_mode = SSL_VERIFY_PEER;                                            verify_mode_validation_context = SSL_VERIFY_PEER; } } if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) { ca_file_path_ = config_->caCertPath(); bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); bool has_crl = false; for (const X509_INFO* item : list.get()) { if (item->x509) { X509_STORE_add_cert(store, item->x509); if (ca_cert_ == nullptr) { X509_up_ref(item->x509); ca_cert_.reset(item->x509); } } if (item->crl) { X509_STORE_add_crl(store, item->crl); has_crl = true; } } if (ca_cert_ == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } if (has_crl) { X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } verify_mode = SSL_VERIFY_PEER; verify_trusted_ca_ = true; if (config_->allowExpiredCertificate()) { X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback); } } } if (config_ != nullptr && !config_->certificateRevocationList().empty()) { bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()), config_->certificateRevocationList().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load CRL from "", config_->certificateRevocationListPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); for (const X509_INFO* item : list.get()) { if (item->crl) { X509_STORE_add_crl(store, item->crl); } } X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } } const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_; if (cert_validation_config != nullptr) { if (!cert_validation_config->subjectAltNameMatchers().empty()) { for (const envoy::type::matcher::v3::StringMatcher& matcher : cert_validation_config->subjectAltNameMatchers()) { subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher)); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateHashList().empty()) { for (auto hash : cert_validation_config->verifyCertificateHashList()) { if (hash.size() == 95) { hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end()); } const auto& decoded = Hex::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid hex-encoded SHA-256 "", hash)); } verify_certificate_hash_list_.push_back(decoded); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateSpkiList().empty()) { for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) { const auto decoded = Base64::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid base64-encoded SHA-256 "", hash)); } verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end()); } verify_mode = verify_mode_validation_context; } } return verify_mode; }"
"static int rtsx_usb_ms_drv_probe(struct platform_device *pdev) { struct memstick_host *msh; struct rtsx_usb_ms *host; struct rtsx_ucr *ucr; int err; ucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent)); if (!ucr) return -ENXIO; dev_dbg(&(pdev->dev), ""Realtek USB Memstick controller found\n""); msh = memstick_alloc_host(sizeof(*host), &pdev->dev); if (!msh) return -ENOMEM; host = memstick_priv(msh); host->ucr = ucr; host->msh = msh; host->pdev = pdev; host->power_mode = MEMSTICK_POWER_OFF; platform_set_drvdata(pdev, host); mutex_init(&host->host_mutex); INIT_WORK(&host->handle_req, rtsx_usb_ms_handle_req); INIT_DELAYED_WORK(&host->poll_card, rtsx_usb_ms_poll_card); msh->request = rtsx_usb_ms_request; msh->set_param = rtsx_usb_ms_set_param; msh->caps = MEMSTICK_CAP_PAR4; pm_runtime_get_noresume(ms_dev(host)); pm_runtime_set_active(ms_dev(host)); pm_runtime_enable(ms_dev(host)); err = memstick_add_host(msh); if (err) goto err_out; pm_runtime_put(ms_dev(host)); return 0; err_out: memstick_free_host(msh); pm_runtime_disable(ms_dev(host)); pm_runtime_put_noidle(ms_dev(host)); return err; }"
"static int get_entries(struct net *net, struct arpt_get_entries __user *uptr, const int *len) { int ret; struct arpt_get_entries get; struct xt_table *t; if (*len < sizeof(get)) return -EINVAL; if (copy_from_user(&get, uptr, sizeof(get)) != 0) return -EFAULT; if (*len != sizeof(struct arpt_get_entries) + get.size) return -EINVAL; get.name[sizeof(get.name) - 1] = '\0'; t = xt_find_table_lock(net, NFPROTO_ARP, get.name); if (!IS_ERR(t)) { const struct xt_table_info *private = t->private; if (get.size == private->size) ret = copy_entries_to_user(private->size, t, uptr->entrytable); else ret = -EAGAIN; module_put(t->me); xt_table_unlock(t); } else ret = PTR_ERR(t); return ret; }"
"Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags) { int noMsg = (flags & JSI_NO_ERRMSG); if (!value) return JSI_ERROR; Jsi_Number d = Jsi_ValueToNumberInt(interp, value, 1); if (!Jsi_NumberIsFinite(d)) { if (!noMsg) Jsi_LogError(""invalid number""); return JSI_ERROR; } Jsi_ValueReset(interp,&value); Jsi_ValueMakeNumber(interp, &value, d); *n = (int)d; return JSI_OK; }"
"static proto_item * _proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb, const guint bit_offset, const gint no_of_bits, guint64 *return_value, const guint encoding) { gint     offset; guint    length; guint8   tot_no_bits; char    *bf_str; char     lbl_str[ITEM_LABEL_LENGTH]; guint64  value = 0; guint8  *bytes = NULL; size_t bytes_length = 0; proto_item        *pi; header_field_info *hf_field; const true_false_string *tfstring; PROTO_REGISTRAR_GET_NTH(hfindex, hf_field); if (hf_field->bitmask != 0) { REPORT_DISSECTOR_BUG(""Incompatible use of proto_tree_add_bits_ret_val"" "" with field '%s' (%s) with bitmask != 0"", hf_field->abbrev, hf_field->name); } if (no_of_bits == 0) { REPORT_DISSECTOR_BUG(""field %s passed to proto_tree_add_bits_ret_val() has a bit width of 0"", hf_field->abbrev); } offset = bit_offset>>3; tot_no_bits = ((bit_offset&0x7) + no_of_bits); length = (tot_no_bits + 7) >> 3; if (no_of_bits < 65) { value = tvb_get_bits64(tvb, bit_offset, no_of_bits, encoding); } else if (hf_field->type != FT_BYTES) { REPORT_DISSECTOR_BUG(""field %s passed to proto_tree_add_bits_ret_val() has a bit width of %u > 65"", hf_field->abbrev, no_of_bits); return NULL; } switch (hf_field->type) { case FT_INT8: case FT_INT16: case FT_INT24: case FT_INT32: case FT_INT40: case FT_INT48: case FT_INT56: case FT_INT64: value = ws_sign_ext64(value, no_of_bits); break; default: break; } if (return_value) { *return_value = value; } CHECK_FOR_NULL_TREE(tree); TRY_TO_FAKE_THIS_ITEM(tree, hfindex, hf_field); bf_str = decode_bits_in_field(bit_offset, no_of_bits, value); switch (hf_field->type) { case FT_BOOLEAN: tfstring = &tfs_true_false; if (hf_field->strings) tfstring = (const true_false_string *)hf_field->strings; return proto_tree_add_boolean_format(tree, hfindex, tvb, offset, length, (guint32)value, ""%s = %s: %s"", bf_str, hf_field->name, tfs_get_string(!!value, tfstring)); break; case FT_CHAR: pi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value); fill_label_char(PITEM_FINFO(pi), lbl_str); break; case FT_UINT8: case FT_UINT16: case FT_UINT24: case FT_UINT32: pi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value); fill_label_number(PITEM_FINFO(pi), lbl_str, FALSE); break; case FT_INT8: case FT_INT16: case FT_INT24: case FT_INT32: pi = proto_tree_add_int(tree, hfindex, tvb, offset, length, (gint32)value); fill_label_number(PITEM_FINFO(pi), lbl_str, TRUE); break; case FT_UINT40: case FT_UINT48: case FT_UINT56: case FT_UINT64: pi = proto_tree_add_uint64(tree, hfindex, tvb, offset, length, value); fill_label_number64(PITEM_FINFO(pi), lbl_str, FALSE); break; case FT_INT40: case FT_INT48: case FT_INT56: case FT_INT64: pi = proto_tree_add_int64(tree, hfindex, tvb, offset, length, (gint64)value); fill_label_number64(PITEM_FINFO(pi), lbl_str, TRUE); break; case FT_BYTES: bytes = tvb_get_bits_array(NULL, tvb, bit_offset, no_of_bits, &bytes_length); pi = proto_tree_add_bytes_with_length(tree, hfindex, tvb, offset, length, bytes, (gint) bytes_length); proto_item_fill_label(PITEM_FINFO(pi), lbl_str); proto_item_set_text(pi, ""%s"", lbl_str); return pi; break; default: REPORT_DISSECTOR_BUG(""field %s has type %d (%s) not handled in proto_tree_add_bits_ret_val()"", hf_field->abbrev, hf_field->type, ftype_name(hf_field->type)); return NULL; break; } proto_item_set_text(pi, ""%s = %s"", bf_str, lbl_str); return pi; }"
"int ReplaceThumbnail(const char * ThumbFileName) { FILE * ThumbnailFile; int ThumbLen, NewExifSize; Section_t * ExifSection; uchar * ThumbnailPointer; if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){ if (ThumbFileName == NULL){ return FALSE; } fprintf(stderr,""Image contains no thumbnail to replace - add is not possible\n""); return FALSE; } if (ThumbFileName){ ThumbnailFile = fopen(ThumbFileName,""rb""); if (ThumbnailFile == NULL){ noread: ErrFatal(""Could not read thumbnail file""); return FALSE; } fseek(ThumbnailFile, 0, SEEK_END); ThumbLen = ftell(ThumbnailFile); fseek(ThumbnailFile, 0, SEEK_SET); if (ThumbLen + ImageInfo.ThumbnailOffset > 0x10000-20){ ErrFatal(""Thumbnail is too large to insert into exif header""); } }else{ if (ImageInfo.ThumbnailSize == 0){ return FALSE; } ThumbLen = 0; ThumbnailFile = NULL; } ExifSection = FindSection(M_EXIF); NewExifSize = ImageInfo.ThumbnailOffset+8+ThumbLen; ExifSection->Data = (uchar *)realloc(ExifSection->Data, NewExifSize); ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8; if (ThumbnailFile){ if (fread(ThumbnailPointer, 1, ThumbLen, ThumbnailFile) != ThumbLen){ goto noread; } fclose(ThumbnailFile); } ImageInfo.ThumbnailSize = ThumbLen; Put32u(ExifSection->Data+ImageInfo.ThumbnailSizeOffset+8, ThumbLen); ExifSection->Data[0] = (uchar)(NewExifSize >> 8); ExifSection->Data[1] = (uchar)NewExifSize; ExifSection->Size = NewExifSize; return TRUE; }"
"TypedValue HHVM_FUNCTION(substr_compare, const String& main_str, const String& str, int offset, int length , bool case_insensitivity ) { int s1_len = main_str.size(); int s2_len = str.size(); if (length <= 0) { raise_warning(""The length must be greater than zero""); return make_tv<KindOfBoolean>(false); } if (offset < 0) { offset = s1_len + offset; if (offset < 0) offset = 0; } if (offset >= s1_len) { raise_warning(""The start position cannot exceed initial string length""); return make_tv<KindOfBoolean>(false); } int cmp_len = s1_len - offset; if (cmp_len < s2_len) cmp_len = s2_len; if (cmp_len > length) cmp_len = length; const char *s1 = main_str.data(); if (case_insensitivity) { return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len)); } return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len)); }"
"static int sendMessageEnet(short ptype, short paylen, const void* payload) { PNVCTL_ENET_PACKET_HEADER packet; ENetPacket* enetPacket; ENetEvent event; int err; LC_ASSERT(ServerMajorVersion >= 5); if (peer == NULL) { return 0; } packet = malloc(sizeof(*packet) + paylen); if (packet == NULL) { return 0; } packet->type = ptype; memcpy(&packet[1], payload, paylen); while ((err = serviceEnetHost(client, &event, 0)) > 0) { if (event.type == ENET_EVENT_TYPE_RECEIVE) { enet_packet_destroy(event.packet); } else if (event.type == ENET_EVENT_TYPE_DISCONNECT) { Limelog(""Control stream received disconnect event\n""); free(packet); return 0; } } if (err < 0) { Limelog(""Control stream connection failed\n""); return 0; } enetPacket = enet_packet_create(packet, sizeof(*packet) + paylen, ENET_PACKET_FLAG_RELIABLE); if (packet == NULL) { free(packet); return 0; } if (enet_peer_send(peer, 0, enetPacket) < 0) { Limelog(""Failed to send ENet control packet\n""); enet_packet_destroy(enetPacket); free(packet); return 0; } enet_host_flush(client); free(packet); return 1; }"
"void getvcol( win_T*wp, pos_T*pos, colnr_T*start, colnr_T*cursor, colnr_T*end) { colnr_Tvcol; char_u*ptr;    char_u*posptr;    char_u*line;    intincr; inthead; #ifdef FEAT_VARTABS int*vts = wp->w_buffer->b_p_vts_array; #endif intts = wp->w_buffer->b_p_ts; intc; vcol = 0; line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE); if (pos->col == MAXCOL) posptr = NULL;      else { if (*ptr == NUL) pos->col = 0; posptr = ptr + pos->col; if (has_mbyte) posptr -= (*mb_head_off)(line, posptr); } if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL) #ifdef FEAT_LINEBREAK && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri #endif ) { for (;;) { head = 0; c = *ptr; if (c == NUL) { incr = 1;break; } if (c == TAB) #ifdef FEAT_VARTABS incr = tabstop_padding(vcol, ts, vts); #else incr = ts - (vcol % ts); #endif else { if (has_mbyte) { if (enc_utf8 && c >= 0x80) incr = utf_ptr2cells(ptr); else incr = g_chartab[c] & CT_CELL_MASK; if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1 && in_win_border(wp, vcol)) { ++incr; head = 1; } } else incr = g_chartab[c] & CT_CELL_MASK; } if (posptr != NULL && ptr >= posptr) break; vcol += incr; MB_PTR_ADV(ptr); } } else { for (;;) { head = 0; incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head); if (*ptr == NUL) { incr = 1;break; } if (posptr != NULL && ptr >= posptr) break; vcol += incr; MB_PTR_ADV(ptr); } } if (start != NULL) *start = vcol + head; if (end != NULL) *end = vcol + incr - 1; if (cursor != NULL) { if (*ptr == TAB && (State & NORMAL) && !wp->w_p_list && !virtual_active() && !(VIsual_active && (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual))) ) *cursor = vcol + incr - 1;    else *cursor = vcol + head;        } }"
"static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req, const struct io_uring_sqe *sqe) __must_hold(&ctx->uring_lock) { struct io_submit_state *state; unsigned int sqe_flags; int personality, ret = 0; req->opcode = READ_ONCE(sqe->opcode); req->flags = sqe_flags = READ_ONCE(sqe->flags); req->user_data = READ_ONCE(sqe->user_data); req->file = NULL; req->fixed_rsrc_refs = NULL; req->task = current; if (unlikely(sqe_flags & ~SQE_VALID_FLAGS)) return -EINVAL; if (unlikely(req->opcode >= IORING_OP_LAST)) return -EINVAL; if (!io_check_restriction(ctx, req, sqe_flags)) return -EACCES; if ((sqe_flags & IOSQE_BUFFER_SELECT) && !io_op_defs[req->opcode].buffer_select) return -EOPNOTSUPP; if (unlikely(sqe_flags & IOSQE_IO_DRAIN)) ctx->drain_active = true; personality = READ_ONCE(sqe->personality); if (personality) { req->creds = xa_load(&ctx->personalities, personality); if (!req->creds) return -EINVAL; get_cred(req->creds); req->flags |= REQ_F_CREDS; } state = &ctx->submit_state; if (!state->plug_started && state->ios_left > 1 && io_op_defs[req->opcode].plug) { blk_start_plug(&state->plug); state->plug_started = true; } if (io_op_defs[req->opcode].needs_file) { req->file = io_file_get(ctx, req, READ_ONCE(sqe->fd), (sqe_flags & IOSQE_FIXED_FILE), 0); if (unlikely(!req->file)) ret = -EBADF; } state->ios_left--; return ret; }"
"State() : codec_saw_local_complete_(false), codec_encode_complete_(false), on_reset_stream_called_(false), is_zombie_stream_(false), successful_upgrade_(false), is_internally_destroyed_(false), is_internally_created_(false), is_tunneling_(false), decorated_propagate_(true) {}"
"static bool evtchn_2l_is_pending(const struct domain *d, evtchn_port_t port) { unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d); ASSERT(port < max_ports); return (port < max_ports && guest_test_bit(d, port, &shared_info(d, evtchn_pending))); }"
"static void candump_write_packet(wtap_rec *rec, Buffer *buf, const msg_t *msg) { static const char can_proto_name[]   = ""can-hostendian""; static const char canfd_proto_name[] = ""canfd""; ws_buffer_clean(buf); if (msg->is_fd) { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)canfd_proto_name, sizeof canfd_proto_name - 1); } else { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)can_proto_name, sizeof can_proto_name - 1); } wtap_buffer_append_epdu_end(buf); if (msg->is_fd) { canfd_frame_t canfd_frame = {0}; canfd_frame.can_id = msg->id; canfd_frame.flags  = msg->flags; canfd_frame.len    = msg->data.length; memcpy(canfd_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&canfd_frame, sizeof(canfd_frame)); } else { can_frame_t can_frame = {0}; can_frame.can_id  = msg->id; can_frame.can_dlc = msg->data.length; memcpy(can_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&can_frame, sizeof(can_frame)); } rec->rec_type       = REC_TYPE_PACKET; rec->block          = wtap_block_create(WTAP_BLOCK_PACKET); rec->presence_flags = WTAP_HAS_TS; rec->ts             = msg->ts; rec->tsprec         = WTAP_TSPREC_USEC; rec->rec_header.packet_header.caplen = (guint32)ws_buffer_length(buf); rec->rec_header.packet_header.len    = (guint32)ws_buffer_length(buf); }"
"ecma_value_t opfunc_private_set (ecma_value_t base,  ecma_value_t property,  ecma_value_t value)  { ecma_object_t *obj_p = ecma_get_object_from_value (base); ecma_string_t *prop_name_p = ecma_get_string_from_value (property); ecma_string_t *private_key_p = NULL; ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true); if (prop_p == NULL) { return ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT); } if (*prop_p & ECMA_PROPERTY_FLAG_DATA) { JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p)); if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD) { return ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE); } ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value); return ecma_copy_value (value); } ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p)); if (get_set_pair_p->setter_cp == JMEM_CP_NULL) { return ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER); } ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp); return ecma_op_function_call (setter_p, base, &value, 1); }"
"void ex_diffgetput(exarg_T *eap) { linenr_Tlnum; intcount; linenr_Toff = 0; diff_T*dp; diff_T*dprev; diff_T*dfree; intidx_cur; intidx_other; intidx_from; intidx_to; inti; intadded; char_u*p; aco_save_Taco; buf_T*buf; intstart_skip, end_skip; intnew_count; intbuf_empty; intfound_not_ma = FALSE; idx_cur = diff_buf_idx(curbuf); if (idx_cur == DB_COUNT) { emsg(_(e_current_buffer_is_not_in_diff_mode)); return; } if (*eap->arg == NUL) { for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) if (curtab->tp_diffbuf[idx_other] != curbuf && curtab->tp_diffbuf[idx_other] != NULL) { if (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[idx_other]->b_p_ma) break; found_not_ma = TRUE; } if (idx_other == DB_COUNT) { if (found_not_ma) emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable)); else emsg(_(e_no_other_buffer_in_diff_mode)); return; } for (i = idx_other + 1; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != curbuf && curtab->tp_diffbuf[i] != NULL && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma)) { emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use)); return; } } else { p = eap->arg + STRLEN(eap->arg); while (p > eap->arg && VIM_ISWHITE(p[-1])) --p; for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) ; if (eap->arg + i == p)        i = atol((char *)eap->arg); else { i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE); if (i < 0) return;} buf = buflist_findnr(i); if (buf == NULL) { semsg(_(e_cant_find_buffer_str), eap->arg); return; } if (buf == curbuf) return;idx_other = diff_buf_idx(buf); if (idx_other == DB_COUNT) { semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg); return; } } diff_busy = TRUE; if (eap->addr_count == 0) { if (eap->cmdidx == CMD_diffget && eap->line1 == curbuf->b_ml.ml_line_count && diff_check(curwin, eap->line1) == 0 && (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0)) ++eap->line2; else if (eap->line1 > 0) --eap->line1; } if (eap->cmdidx == CMD_diffget) { idx_from = idx_other; idx_to = idx_cur; } else { idx_from = idx_cur; idx_to = idx_other; aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]); } if (!curbuf->b_changed) { change_warning(0); if (diff_buf_idx(curbuf) != idx_to) { emsg(_(e_buffer_changed_unexpectedly)); goto theend; } } dprev = NULL; for (dp = curtab->tp_first_diff; dp != NULL; ) { if (dp->df_lnum[idx_cur] > eap->line2 + off) break; dfree = NULL; lnum = dp->df_lnum[idx_to]; count = dp->df_count[idx_to]; if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off && u_save(lnum - 1, lnum + count) != FAIL) { start_skip = 0; end_skip = 0; if (eap->addr_count > 0) { start_skip = eap->line1 + off - dp->df_lnum[idx_cur]; if (start_skip > 0) { if (start_skip > count) { lnum += count; count = 0; } else { count -= start_skip; lnum += start_skip; } } else start_skip = 0; end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1 - (eap->line2 + off); if (end_skip > 0) { if (idx_cur == idx_from)    { i = dp->df_count[idx_cur] - start_skip - end_skip; if (count > i) count = i; } else    { count -= end_skip; end_skip = dp->df_count[idx_from] - start_skip - count; if (end_skip < 0) end_skip = 0; } } else end_skip = 0; } buf_empty = BUFEMPTY(); added = 0; for (i = 0; i < count; ++i) { buf_empty = curbuf->b_ml.ml_line_count == 1; ml_delete(lnum); --added; } for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) { linenr_T nr; nr = dp->df_lnum[idx_from] + start_skip + i; if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count) break; p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE)); if (p != NULL) { ml_append(lnum + i - 1, p, 0, FALSE); vim_free(p); ++added; if (buf_empty && curbuf->b_ml.ml_line_count == 2) { buf_empty = FALSE; ml_delete((linenr_T)2); } } } new_count = dp->df_count[idx_to] + added; dp->df_count[idx_to] = new_count; if (start_skip == 0 && end_skip == 0) { for (i = 0; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != NULL && i != idx_from && i != idx_to && !diff_equal_entry(dp, idx_from, i)) break; if (i == DB_COUNT) { dfree = dp; dp = dp->df_next; if (dprev == NULL) curtab->tp_first_diff = dp; else dprev->df_next = dp; } } if (added != 0) { mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added); if (curwin->w_cursor.lnum >= lnum) { if (curwin->w_cursor.lnum >= lnum + count) curwin->w_cursor.lnum += added; else if (added < 0) curwin->w_cursor.lnum = lnum; } } changed_lines(lnum, 0, lnum + count, (long)added); if (dfree != NULL) { #ifdef FEAT_FOLDING diff_fold_update(dfree, idx_to); #endif vim_free(dfree); } else dp->df_count[idx_to] = new_count; if (idx_cur == idx_to) off += added; } if (dfree == NULL) { dprev = dp; dp = dp->df_next; } } if (eap->cmdidx != CMD_diffget) { if (KeyTyped) u_sync(FALSE); aucmd_restbuf(&aco); } theend: diff_busy = FALSE; if (diff_need_update) ex_diffupdate(NULL); check_cursor(); changed_line_abv_curs(); if (diff_need_update) diff_need_update = FALSE; else { diff_redraw(FALSE); apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf); } }"
"void win_new_width(win_T *wp, int width) { wp->w_width = width; wp->w_lines_valid = 0; changed_line_abv_curs_win(wp); if (p_spsc) { invalidate_botline_win(wp); if (wp == curwin) { update_topline(); curs_columns(TRUE);} } redraw_win_later(wp, UPD_NOT_VALID); wp->w_redr_status = TRUE; }"
"int xenmem_add_to_physmap(struct domain *d, struct xen_add_to_physmap *xatp, unsigned int start) { unsigned int done = 0; long rc = 0; union add_to_physmap_extra extra = {}; struct page_info *pages[16]; ASSERT(paging_mode_translate(d)); if ( xatp->space == XENMAPSPACE_gmfn_foreign ) extra.foreign_domid = DOMID_INVALID; if ( xatp->space != XENMAPSPACE_gmfn_range ) return xenmem_add_to_physmap_one(d, xatp->space, extra, xatp->idx, _gfn(xatp->gpfn)); if ( xatp->size < start ) return -EILSEQ; xatp->idx += start; xatp->gpfn += start; xatp->size -= start; if ( is_iommu_enabled(d) ) { this_cpu(iommu_dont_flush_iotlb) = 1; extra.ppage = &pages[0]; } while ( xatp->size > done ) { rc = xenmem_add_to_physmap_one(d, XENMAPSPACE_gmfn, extra, xatp->idx, _gfn(xatp->gpfn)); if ( rc < 0 ) break; xatp->idx++; xatp->gpfn++; if ( extra.ppage ) ++extra.ppage; if ( (++done > ARRAY_SIZE(pages) && extra.ppage) || (xatp->size > done && hypercall_preempt_check()) ) { rc = start + done; break; } } if ( is_iommu_enabled(d) ) { int ret; unsigned int i; this_cpu(iommu_dont_flush_iotlb) = 0; ret = iommu_iotlb_flush(d, _dfn(xatp->idx - done), done, IOMMU_FLUSHF_modified); if ( unlikely(ret) && rc >= 0 ) rc = ret; for ( i = 0; i < done; ++i ) put_page(pages[i]); ret = iommu_iotlb_flush(d, _dfn(xatp->gpfn - done), done, IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified); if ( unlikely(ret) && rc >= 0 ) rc = ret; } return rc; }"
"static int bgp_attr_check(struct peer *peer, struct attr *attr, bgp_size_t length) { uint8_t type = 0; if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag && !length) return BGP_ATTR_PARSE_PROCEED; if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) && CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))) return BGP_ATTR_PARSE_PROCEED; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN))) type = BGP_ATTR_ORIGIN; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) type = BGP_ATTR_AS_PATH; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) type = BGP_ATTR_NEXT_HOP; if (peer->sort == BGP_PEER_IBGP && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF))) type = BGP_ATTR_LOCAL_PREF; if (type) { flog_warn(EC_BGP_MISSING_ATTRIBUTE, ""%s Missing well-known attribute %s."", peer->host, lookup_msg(attr_str, type, NULL)); return BGP_ATTR_PARSE_WITHDRAW; } return BGP_ATTR_PARSE_PROCEED; }"
"GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack) { GF_TimeToSampleBox *stts = stbl->TimeToSample; if (!nb_pack) nb_pack = 1; if (stts->nb_entries) { if (stts->entries[stts->nb_entries-1].sampleDelta == duration) { stts->entries[stts->nb_entries-1].sampleCount += nb_pack; return GF_OK; } } if (stts->nb_entries==stts->alloc_size) { ALLOC_INC(stts->alloc_size); stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size); if (!stts->entries) return GF_OUT_OF_MEM; memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) ); } stts->entries[stts->nb_entries].sampleCount = nb_pack; stts->entries[stts->nb_entries].sampleDelta = duration; stts->nb_entries++; if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration; return GF_OK; }"
"pe_exports_t *pe_exports(pe_ctx_t *ctx) { if (ctx->cached_data.exports != NULL) return ctx->cached_data.exports; pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t)); if (exports == NULL) { return NULL; } exports->err = LIBPE_E_OK; const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT); if (dir == NULL) {  return exports; } const uint64_t va = dir->VirtualAddress; if (va == 0) { return exports; } uint64_t ofs; ofs = pe_rva2ofs(ctx, va); const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) { exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR; return exports; } ofs = pe_rva2ofs(ctx, exp->Name); const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, name_ptr, 1)) { exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA; return exports; } exports->name = strdup(name_ptr); const uint32_t ordinal_base = exp->Base; ofs = pe_rva2ofs(ctx, exp->AddressOfNames); const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) { exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA; return exports; } exports->functions_count = exp->NumberOfFunctions; exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t)); if (exports->functions == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions); const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames); const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals); uint64_t offsets_to_Names[exp->NumberOfFunctions]; memset(offsets_to_Names, 0, sizeof(offsets_to_Names));   for (uint32_t i=0; i < exp->NumberOfNames; i++) { uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i; uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr); if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) { break; } const uint16_t ordinal = *entry_ordinal_list; uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i; uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr); if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) { break; } const uint32_t entry_name_rva = *entry_name_list; const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva); offsets_to_Names[ordinal] = entry_name_ofs; } for (uint32_t i=0; i < exp->NumberOfFunctions; i++) { uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i; uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr); if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) { break; } const uint32_t entry_va = *entry_va_list; const uint64_t entry_name_ofs = offsets_to_Names[i]; char fname[300]; fname[0] = 0; if (entry_name_ofs != 0) { const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs); if (!pe_can_read(ctx, entry_name, 1)) { break; } const size_t fname_size = sizeof(fname); strncpy(fname, entry_name, fname_size-1); fname[fname_size - 1] = '\0'; } exports->functions[i].ordinal = ordinal_base + i; exports->functions[i].address = entry_va; exports->functions[i].name = strdup(fname); if (exports->functions[i].name == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } if (entry_va >= va && entry_va <= va + dir->Size) { const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va); const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs); if (!pe_can_read(ctx, fw_entry_name, 1)) { break; } exports->functions[i].fwd_name = strdup(fw_entry_name); if (exports->functions[i].fwd_name == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } } } return exports; }"
"void Compute(OpKernelContext* context) override { int32_t dim = context->input(0).scalar<int32_t>()(); int32_t num_results = context->input(1).scalar<int32_t>()(); int32_t skip = context->input(2).scalar<int32_t>()(); OP_REQUIRES(context, dim >= 1, errors::InvalidArgument(""dim must be at least one"")); OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim, errors::InvalidArgument(""dim must be at most "", sobol_data::kMaxSobolDim)); OP_REQUIRES(context, num_results >= 1, errors::InvalidArgument(""num_results must be at least one"")); OP_REQUIRES(context, skip >= 0, errors::InvalidArgument(""skip must be non-negative"")); OP_REQUIRES(context, num_results < std::numeric_limits<int32_t>::max() - skip, errors::InvalidArgument(""num_results+skip must be less than "", std::numeric_limits<int32_t>::max())); Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output( 0, TensorShape({num_results, dim}), &output)); auto output_flat = output->flat<T>(); const DeviceBase::CpuWorkerThreads& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); int num_threads = worker_threads.num_threads; int block_size = std::max( kMinBlockSize, static_cast<int>(std::ceil( static_cast<float>(num_results) / num_threads))); worker_threads.workers->TransformRangeConcurrently( block_size, num_results , [&dim, &skip, &output_flat](const int start, const int end) { CalculateSobolSample<T>(dim, end - start , skip, start, output_flat); }); }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi( pjmedia_rtcp_session *session,  void *buf, pj_size_t *length, const pjmedia_rtcp_fb_rpsi *rpsi) { pjmedia_rtcp_common *hdr; pj_uint8_t *p; unsigned bitlen, padlen, len; PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL); bitlen = (unsigned)rpsi->rpsi_bit_len + 16; padlen = (32 - (bitlen % 32)) % 32; len = (3 + (bitlen+padlen)/32) * 4; if (len > *length) return PJ_ETOOSMALL; hdr = (pjmedia_rtcp_common*)buf; pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr)); hdr->pt = RTCP_PSFB; hdr->count = 3;  hdr->length = pj_htons((pj_uint16_t)(len/4 - 1)); p = (pj_uint8_t*)hdr + sizeof(*hdr); *p++ = (pj_uint8_t)padlen; *p++ = rpsi->pt & 0x7F; pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8); p += rpsi->rpsi_bit_len/8; if (rpsi->rpsi_bit_len % 8) { *p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8); } if (padlen >= 8) pj_bzero(p, padlen/8); *length = len; return PJ_SUCCESS; }"
"static void xml_sax_parse_entity(GF_SAXParser *parser) { char szC[2]; char *ent_name=NULL; u32 i = 0; XML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities); char *skip_chars = "" \t\n\r""; i=0; if (ent && ent->value) ent = NULL; if (ent) skip_chars = NULL; szC[1]=0; while (parser->current_pos+i < parser->line_size) { u8 c = parser->buffer[parser->current_pos+i]; if (skip_chars && strchr(skip_chars, c)) { if (c=='\n') parser->line++; parser->current_pos++; continue; } if (!ent && (c=='%')) { parser->current_pos+=i+1; parser->sax_state = SAX_STATE_SKIP_DOCTYPE; if (ent_name) gf_free(ent_name); return; } else if (!ent && ((c=='\""') || (c=='\'')) ) { GF_SAFEALLOC(ent, XML_Entity); if (!ent) { parser->sax_state = SAX_STATE_ALLOC_ERROR; if (ent_name) gf_free(ent_name); return; } if (!ent_name) gf_dynstrcat(&ent_name, """", NULL); ent->name = ent_name; ent_name=NULL; ent->namelen = (u32) strlen(ent->name); ent->sep = c; parser->current_pos += 1+i; assert(parser->current_pos < parser->line_size); xml_sax_swap(parser); i=0; gf_list_add(parser->entities, ent); skip_chars = NULL; } else if (ent && c==ent->sep) { if (ent_name) gf_free(ent_name); xml_sax_store_text(parser, i); ent->value = xml_get_current_text(parser); if (!ent->value) ent->value = gf_strdup(""""); parser->current_pos += 1; assert(parser->current_pos < parser->line_size); xml_sax_swap(parser); parser->sax_state = SAX_STATE_SKIP_DOCTYPE; return; } else if (!ent) { szC[0] = c; gf_dynstrcat(&ent_name, szC, NULL); i++; } else { i++; } } if (ent_name) gf_free(ent_name); xml_sax_store_text(parser, i); }"
"bool XmlRpcClient::readResponse() { if (int(_response.length()) < _contentLength) { std::string buff; if ( ! XmlRpcSocket::nbRead(this->getfd(), buff, &_eof)) { XmlRpcUtil::error(""Error in XmlRpcClient::readResponse: read error (%s)."",XmlRpcSocket::getErrorMsg().c_str()); close(); return false; } _response += buff; if (int(_response.length()) < _contentLength) { if (_eof) { XmlRpcUtil::error(""Error in XmlRpcClient::readResponse: EOF while reading response""); close(); return false; } return true; } } XmlRpcUtil::log(3, ""XmlRpcClient::readResponse (read %d bytes)"", _response.length()); XmlRpcUtil::log(5, ""response:\n%s"", _response.c_str()); _connectionState = IDLE; return false;    }"
"XFontStruct *XLoadQueryFont( register Display *dpy, _Xconst char *name) { XFontStruct *font_result; register long nbytes; Font fid; xOpenFontReq *req; unsigned long seq; #ifdef USE_XF86BIGFONT XF86BigfontCodes *extcodes = _XF86BigfontCodes(dpy); #endif if (_XF86LoadQueryLocaleFont(dpy, name, &font_result, (Font *)0)) return font_result; LockDisplay(dpy); GetReq(OpenFont, req); seq = dpy->request;  nbytes = req->nbytes = (CARD16) (name ? strlen(name) : 0); req->fid = fid = XAllocID(dpy); req->length += (nbytes+3)>>2; Data (dpy, name, nbytes); font_result = NULL; #ifdef USE_XF86BIGFONT if (extcodes) { font_result = _XF86BigfontQueryFont(dpy, extcodes, fid, seq); seq = 0; } #endif if (!font_result) font_result = _XQueryFont(dpy, fid, seq); UnlockDisplay(dpy); SyncHandle(); return font_result; }"
"StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) { if (ctx->num_inputs() == 1) { return stride_; } const TensorShape stride_shape = ctx->InputShape(2); if (!TensorShapeUtils::IsVector(stride_shape)) { return errors::InvalidArgument(""stride must be a vector, not shape "", stride_shape.DebugString()); } if (stride_shape.num_elements() != num_dims()) { return errors::InvalidArgument( ""Sliding window stride field must "" ""specify "", num_dims(), "" dimensions""); } std::vector<int64_t> stride; auto status = ctx->ConstantInputAsIntVector(2, &stride); if (!status.ok()) { return status; } return stride; }"
"void XRef::add(int num, int gen, Goffset offs, bool used) { xrefLocker(); if (num >= size) { if (num >= capacity) { entries = (XRefEntry *)greallocn(entries, num + 1, sizeof(XRefEntry)); capacity = num + 1; } for (int i = size; i < num + 1; ++i) { entries[i].offset = -1; entries[i].type = xrefEntryFree; new (&entries[i].obj) Object(objNull); entries[i].flags = 0; entries[i].gen = 0; } size = num + 1; } XRefEntry *e = getEntry(num); e->gen = gen; e->obj.setToNull(); e->flags = 0; if (used) { e->type = xrefEntryUncompressed; e->offset = offs; } else { e->type = xrefEntryFree; e->offset = 0; } }"
"static int fdtv_ca_pmt(struct firedtv *fdtv, void *arg) { struct ca_msg *msg = arg; int data_pos; int data_length; int i; data_pos = 4; if (msg->msg[3] & 0x80) { data_length = 0; for (i = 0; i < (msg->msg[3] & 0x7f); i++) data_length = (data_length << 8) + msg->msg[data_pos++]; } else { data_length = msg->msg[3]; } return avc_ca_pmt(fdtv, &msg->msg[data_pos], data_length); }"
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, buffsize, col_offset, pix_offset; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) buffsize = (colsize + 1) * width; else buffsize = (rowsize + 1) * length; bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %1u bytes"", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"static char * resolveSubtable(const char *table, const char *base, const char *searchPath) { char *tableFile; static struct stat info; if (table == NULL || table[0] == '\0' || strlen(table) >= MAXSTRING * sizeof(char) * 2) return NULL; tableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2); if (base) { int k; if (strlen(base) >= MAXSTRING * sizeof(char) * 2) goto failure; strcpy(tableFile, base); k = (int)strlen(tableFile); while (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\') k--; tableFile[++k] = '\0'; if (strlen(tableFile) + strlen(table) >= MAXSTRING * sizeof(char) * 2) goto failure; strcat(tableFile, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); return tableFile; } } strcpy(tableFile, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); return tableFile; } if (searchPath[0] != '\0') { char *dir; int last; char *cp; char *searchPath_copy = strdup(searchPath); for (dir = searchPath_copy;; dir = cp + 1) { for (cp = dir; *cp != '\0' && *cp != ','; cp++) ; last = (*cp == '\0'); *cp = '\0'; if (dir == cp) dir = "".""; if (strlen(dir) + strlen(table) + 1 >= MAXSTRING * sizeof(char) * 2) { free(searchPath_copy); goto failure; } sprintf(tableFile, ""%s%c%s"", dir, DIR_SEP, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); free(searchPath_copy); return tableFile; } if (last) break; if (strlen(dir) + strlen(table) + 16 >= MAXSTRING * sizeof(char) * 2) { free(searchPath_copy); goto failure; } sprintf(tableFile, ""%s%c%s%c%s%c%s"", dir, DIR_SEP, ""liblouis"", DIR_SEP, ""tables"", DIR_SEP, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); free(searchPath_copy); return tableFile; } if (last) break; } free(searchPath_copy); } failure: free(tableFile); return NULL; }"
"static SIXELSTATUS gif_process_raster( gif_context_t  *s, gif_t          *g ) { SIXELSTATUS status = SIXEL_FALSE; unsigned char lzw_cs; signed int len, code; unsigned int first; signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear; gif_lzw *p; lzw_cs = gif_get8(s); clear = 1 << lzw_cs; first = 1; codesize = lzw_cs + 1; codemask = (1 << codesize) - 1; bits = 0; valid_bits = 0; for (code = 0; code < clear; code++) { g->codes[code].prefix = -1; g->codes[code].first = (unsigned char) code; g->codes[code].suffix = (unsigned char) code; } avail = clear + 2; oldcode = (-1); len = 0; for(;;) { if (valid_bits < codesize) { if (len == 0) { len = gif_get8(s);  if (len == 0) { return SIXEL_OK; } } --len; bits |= (signed int) gif_get8(s) << valid_bits; valid_bits += 8; } else { code = bits & codemask; bits >>= codesize; valid_bits -= codesize; if (code == clear) {   codesize = lzw_cs + 1; codemask = (1 << codesize) - 1; avail = clear + 2; oldcode = -1; first = 0; } else if (code == clear + 1) {  s->img_buffer += len; while ((len = gif_get8(s)) > 0) { s->img_buffer += len; } return SIXEL_OK; } else if (code <= avail) { if (first) { sixel_helper_set_additional_message( ""corrupt GIF (reason: no clear code).""); status = SIXEL_RUNTIME_ERROR; goto end; } if (oldcode >= 0) { if (avail < 4096) { p = &g->codes[avail++]; p->prefix = (signed short) oldcode; p->first = g->codes[oldcode].first; p->suffix = (code == avail) ? p->first : g->codes[code].first; } } else if (code == avail) { sixel_helper_set_additional_message( ""corrupt GIF (reason: illegal code in raster).""); status = SIXEL_RUNTIME_ERROR; goto end; } gif_out_code(g, (unsigned short) code); if ((avail & codemask) == 0 && avail <= 0x0FFF) { codesize++; codemask = (1 << codesize) - 1; } oldcode = code; } else { sixel_helper_set_additional_message( ""corrupt GIF (reason: illegal code in raster).""); status = SIXEL_RUNTIME_ERROR; goto end; } } } status = SIXEL_OK; end: return status; }"
"bool Tensor::FromProto(Allocator* a, const TensorProto& proto) { CHECK_NOTNULL(a); TensorBuffer* p = nullptr; if (!TensorShape::IsValid(proto.tensor_shape())) return false; if (proto.dtype() == DT_INVALID) return false; TensorShape shape(proto.tensor_shape()); const int64_t N = shape.num_elements(); if (N > 0 && proto.dtype()) { bool dtype_error = false; if (!proto.tensor_content().empty()) { const auto& content = proto.tensor_content(); CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N), dtype_error = true, dtype_error = true); } else { CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N), dtype_error = true, dtype_error = true); } if (dtype_error || p == nullptr) return false; } shape_ = shape; set_dtype(proto.dtype()); UnrefIfNonNull(buf_); buf_ = p; if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) { LogMemory::RecordTensorAllocation(""Unknown (from Proto)"", LogMemory::UNKNOWN_STEP_ID, *this); } return true; }"
"void imx_register_uart_clocks(unsigned int clk_count) { imx_enabled_uart_clocks = 0; #ifdef CONFIG_OF if (imx_keep_uart_clocks) { int i; imx_uart_clocks = kcalloc(clk_count, sizeof(struct clk *), GFP_KERNEL); if (!of_stdout) return; for (i = 0; i < clk_count; i++) { imx_uart_clocks[imx_enabled_uart_clocks] = of_clk_get(of_stdout, i); if (IS_ERR(imx_uart_clocks[imx_enabled_uart_clocks])) return; if (imx_uart_clocks[imx_enabled_uart_clocks]) clk_prepare_enable(imx_uart_clocks[imx_enabled_uart_clocks++]); } } #endif }"
"GVariant * g_variant_byteswap (GVariant *value) { GVariantTypeInfo *type_info; guint alignment; GVariant *new; type_info = g_variant_get_type_info (value); g_variant_type_info_query (type_info, &alignment, NULL); if (alignment) { GVariantSerialised serialised = { 0, }; GVariant *trusted; GBytes *bytes; trusted = g_variant_get_normal_form (value); serialised.type_info = g_variant_get_type_info (trusted); serialised.size = g_variant_get_size (trusted); serialised.data = g_malloc (serialised.size); serialised.depth = g_variant_get_depth (trusted); serialised.ordered_offsets_up_to = G_MAXSIZE;   serialised.checked_offsets_up_to = G_MAXSIZE; g_variant_store (trusted, serialised.data); g_variant_unref (trusted); g_variant_serialised_byteswap (serialised); bytes = g_bytes_new_take (serialised.data, serialised.size); new = g_variant_ref_sink (g_variant_new_from_bytes (g_variant_get_type (value), bytes, TRUE)); g_bytes_unref (bytes); } else new = g_variant_get_normal_form (value); g_assert (g_variant_is_trusted (new)); return g_steal_pointer (&new); }"
"static int tree_evaluate(X509_POLICY_TREE *tree) { int ret, i; X509_POLICY_LEVEL *curr = tree->levels + 1; const X509_POLICY_CACHE *cache; for (i = 1; i < tree->nlevel; i++, curr++) { cache = policy_cache_set(curr->cert); if (!tree_link_nodes(curr, cache)) return X509_PCY_TREE_INTERNAL; if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY) && !tree_link_any(curr, cache, tree)) return X509_PCY_TREE_INTERNAL; #ifdef OPENSSL_POLICY_DEBUG tree_print(""before tree_prune()"", tree, curr); #endif ret = tree_prune(tree, curr); if (ret != X509_PCY_TREE_VALID) return ret; } return X509_PCY_TREE_VALID; }"
"njs_typed_array_t * njs_typed_array_alloc(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_bool_t zeroing, njs_object_type_t type) { double              num; int64_t             i, length; uint32_t            element_size; uint64_t            size, offset; njs_int_t           ret; njs_value_t         *value, prop; njs_array_t         *src_array; njs_typed_array_t   *array, *src_tarray; njs_array_buffer_t  *buffer; size = 0; length = 0; offset = 0; buffer = NULL; src_array = NULL; src_tarray = NULL; element_size = njs_typed_array_element_size(type); value = njs_arg(args, nargs, 0); if (njs_is_array_buffer(value)) { buffer = njs_array_buffer(value); ret = njs_value_to_index(vm, njs_arg(args, nargs, 1), &offset); if (njs_slow_path(ret != NJS_OK)) { return NULL; } if (njs_slow_path((offset % element_size) != 0)) { njs_range_error(vm, ""start offset must be multiple of %uD"", element_size); return NULL; } if (njs_is_defined(njs_arg(args, nargs, 2))) { ret = njs_value_to_index(vm, njs_argument(args, 2), &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } } if (njs_slow_path(njs_is_detached_buffer(buffer))) { njs_type_error(vm, ""detached buffer""); return NULL; } if (njs_is_defined(njs_arg(args, nargs, 2))) { ret = njs_value_to_index(vm, njs_argument(args, 2), &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } size *= element_size; if (njs_slow_path((offset + size) > buffer->size)) { njs_range_error(vm, ""Invalid typed array length: %uL"", size); return NULL; } } else { if (njs_slow_path((buffer->size % element_size) != 0)) { njs_range_error(vm, ""byteLength of buffer must be "" ""multiple of %uD"", element_size); return NULL; } if (offset > buffer->size) { njs_range_error(vm, ""byteOffset %uL is outside the bound of "" ""the buffer"", offset); return NULL; } size = buffer->size - offset; } } else if (njs_is_typed_array(value)) { src_tarray = njs_typed_array(value); if (njs_slow_path(njs_is_detached_buffer(src_tarray->buffer))) { njs_type_error(vm, ""detached buffer""); return NULL; } size = (uint64_t) njs_typed_array_length(src_tarray) * element_size; } else if (njs_is_object(value)) { if (njs_is_fast_array(value)) { src_array = njs_array(value); length = src_array->length; } else { ret = njs_object_length(vm, value, &length); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } } size = length * element_size; } else { ret = njs_value_to_index(vm, value, &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } size *= element_size; } if (buffer == NULL) { buffer = njs_array_buffer_alloc(vm, size, zeroing); if (njs_slow_path(buffer == NULL)) { return NULL; } } array = njs_mp_zalloc(vm->mem_pool, sizeof(njs_typed_array_t)); if (njs_slow_path(array == NULL)) { goto memory_error; } array->buffer = buffer; array->offset = offset / element_size; array->byte_length = size; array->type = type; if (src_tarray != NULL) { if (type != src_tarray->type) { length = njs_typed_array_length(src_tarray); for (i = 0; i < length; i++) { njs_typed_array_prop_set(vm, array, i, njs_typed_array_prop(src_tarray, i)); } } else { memcpy(&buffer->u.u8[0], &src_tarray->buffer->u.u8[0], size); } } else if (src_array != NULL) { for (i = 0; i < length; i++) { ret = njs_value_to_number(vm, &src_array->start[i], &num); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { njs_typed_array_prop_set(vm, array, i, num); } } } else if (!njs_is_array_buffer(value) && njs_is_object(value)) { for (i = 0; i < length; i++) { ret = njs_value_property_i64(vm, value, i, &prop); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } num = NAN; if (ret == NJS_OK) { ret = njs_value_to_number(vm, &prop, &num); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } } njs_typed_array_prop_set(vm, array, i, num); } } njs_lvlhsh_init(&array->object.hash); njs_lvlhsh_init(&array->object.shared_hash); array->object.__proto__ = &vm->prototypes[type].object; array->object.type = NJS_TYPED_ARRAY; array->object.extensible = 1; array->object.fast_array = 1; return array; memory_error: njs_memory_error(vm); return NULL; }"
"int vq_getchain(struct virtio_vq_info *vq, uint16_t *pidx, struct iovec *iov, int n_iov, uint16_t *flags) { int i; u_int ndesc, n_indir; u_int idx, next; volatile struct vring_desc *vdir, *vindir, *vp; struct vmctx *ctx; struct virtio_base *base; const char *name; base = vq->base; name = base->vops->name; idx = vq->last_avail; ndesc = (uint16_t)((u_int)vq->avail->idx - idx); if (ndesc == 0) return 0; if (ndesc > vq->qsize) { pr_err(""%s: ndesc (%u) out of range, driver confused?\r\n"", name, (u_int)ndesc); return -1; } ctx = base->dev->vmctx; *pidx = next = vq->avail->ring[idx & (vq->qsize - 1)]; vq->last_avail++; for (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) { if (next >= vq->qsize) { pr_err(""%s: descriptor index %u out of range, "" ""driver confused?\r\n"", name, next); return -1; } vdir = &vq->desc[next]; if ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) { _vq_record(i, vdir, ctx, iov, n_iov, flags); i++; } else if ((base->device_caps & (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) { pr_err(""%s: descriptor has forbidden INDIRECT flag, "" ""driver confused?\r\n"", name); return -1; } else { n_indir = vdir->len / 16; if ((vdir->len & 0xf) || n_indir == 0) { pr_err(""%s: invalid indir len 0x%x, "" ""driver confused?\r\n"", name, (u_int)vdir->len); return -1; } vindir = paddr_guest2host(ctx, vdir->addr, vdir->len); next = 0; for (;;) { vp = &vindir[next]; if (vp->flags & VRING_DESC_F_INDIRECT) { pr_err(""%s: indirect desc has INDIR flag,"" "" driver confused?\r\n"", name); return -1; } _vq_record(i, vp, ctx, iov, n_iov, flags); if (++i > VQ_MAX_DESCRIPTORS) goto loopy; if ((vp->flags & VRING_DESC_F_NEXT) == 0) break; next = vp->next; if (next >= n_indir) { pr_err(""%s: invalid next %u > %u, "" ""driver confused?\r\n"", name, (u_int)next, n_indir); return -1; } } } if ((vdir->flags & VRING_DESC_F_NEXT) == 0) return i; } loopy: pr_err(""%s: descriptor loop? count > %d - driver confused?\r\n"", name, i); return -1; }"
"void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target) { while (gf_list_count(event_target->listeners)) { GF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0); gf_dom_listener_del(n, event_target); } }"
"void ex_diffgetput(exarg_T *eap) { linenr_Tlnum; intcount; linenr_Toff = 0; diff_T*dp; diff_T*dprev; diff_T*dfree; intidx_cur; intidx_other; intidx_from; intidx_to; inti; intadded; char_u*p; aco_save_Taco; buf_T*buf; intstart_skip, end_skip; intnew_count; intbuf_empty; intfound_not_ma = FALSE; idx_cur = diff_buf_idx(curbuf); if (idx_cur == DB_COUNT) { emsg(_(e_current_buffer_is_not_in_diff_mode)); return; } if (*eap->arg == NUL) { for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) if (curtab->tp_diffbuf[idx_other] != curbuf && curtab->tp_diffbuf[idx_other] != NULL) { if (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[idx_other]->b_p_ma) break; found_not_ma = TRUE; } if (idx_other == DB_COUNT) { if (found_not_ma) emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable)); else emsg(_(e_no_other_buffer_in_diff_mode)); return; } for (i = idx_other + 1; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != curbuf && curtab->tp_diffbuf[i] != NULL && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma)) { emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use)); return; } } else { p = eap->arg + STRLEN(eap->arg); while (p > eap->arg && VIM_ISWHITE(p[-1])) --p; for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) ; if (eap->arg + i == p)        i = atol((char *)eap->arg); else { i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE); if (i < 0) return;} buf = buflist_findnr(i); if (buf == NULL) { semsg(_(e_cant_find_buffer_str), eap->arg); return; } if (buf == curbuf) return;idx_other = diff_buf_idx(buf); if (idx_other == DB_COUNT) { semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg); return; } } diff_busy = TRUE; if (eap->addr_count == 0) { if (eap->cmdidx == CMD_diffget && eap->line1 == curbuf->b_ml.ml_line_count && diff_check(curwin, eap->line1) == 0 && (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0)) ++eap->line2; else if (eap->line1 > 0) --eap->line1; } if (eap->cmdidx == CMD_diffget) { idx_from = idx_other; idx_to = idx_cur; } else { idx_from = idx_cur; idx_to = idx_other; aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]); } if (!curbuf->b_changed) { change_warning(0); if (diff_buf_idx(curbuf) != idx_to) { emsg(_(e_buffer_changed_unexpectedly)); goto theend; } } dprev = NULL; for (dp = curtab->tp_first_diff; dp != NULL; ) { if (dp->df_lnum[idx_cur] > eap->line2 + off) break; dfree = NULL; lnum = dp->df_lnum[idx_to]; count = dp->df_count[idx_to]; if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off && u_save(lnum - 1, lnum + count) != FAIL) { start_skip = 0; end_skip = 0; if (eap->addr_count > 0) { start_skip = eap->line1 + off - dp->df_lnum[idx_cur]; if (start_skip > 0) { if (start_skip > count) { lnum += count; count = 0; } else { count -= start_skip; lnum += start_skip; } } else start_skip = 0; end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1 - (eap->line2 + off); if (end_skip > 0) { if (idx_cur == idx_from)    { i = dp->df_count[idx_cur] - start_skip - end_skip; if (count > i) count = i; } else    { count -= end_skip; end_skip = dp->df_count[idx_from] - start_skip - count; if (end_skip < 0) end_skip = 0; } } else end_skip = 0; } buf_empty = BUFEMPTY(); added = 0; for (i = 0; i < count; ++i) { buf_empty = curbuf->b_ml.ml_line_count == 1; ml_delete(lnum); --added; } for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) { linenr_T nr; nr = dp->df_lnum[idx_from] + start_skip + i; if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count) break; p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE)); if (p != NULL) { ml_append(lnum + i - 1, p, 0, FALSE); vim_free(p); ++added; if (buf_empty && curbuf->b_ml.ml_line_count == 2) { buf_empty = FALSE; ml_delete((linenr_T)2); } } } new_count = dp->df_count[idx_to] + added; dp->df_count[idx_to] = new_count; if (start_skip == 0 && end_skip == 0) { for (i = 0; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != NULL && i != idx_from && i != idx_to && !diff_equal_entry(dp, idx_from, i)) break; if (i == DB_COUNT) { dfree = dp; dp = dp->df_next; if (dprev == NULL) curtab->tp_first_diff = dp; else dprev->df_next = dp; } } if (added != 0) { mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added); if (curwin->w_cursor.lnum >= lnum) { if (curwin->w_cursor.lnum >= lnum + count) curwin->w_cursor.lnum += added; else if (added < 0) curwin->w_cursor.lnum = lnum; } } changed_lines(lnum, 0, lnum + count, (long)added); if (dfree != NULL) { #ifdef FEAT_FOLDING diff_fold_update(dfree, idx_to); #endif vim_free(dfree); } if (added != 0 && !valid_diff(dp)) break; if (dfree == NULL) dp->df_count[idx_to] = new_count; if (idx_cur == idx_to) off += added; } if (dfree == NULL) { dprev = dp; dp = dp->df_next; } } if (eap->cmdidx != CMD_diffget) { if (KeyTyped) u_sync(FALSE); aucmd_restbuf(&aco); } theend: diff_busy = FALSE; if (diff_need_update) ex_diffupdate(NULL); check_cursor(); changed_line_abv_curs(); if (diff_need_update) diff_need_update = FALSE; else { diff_redraw(FALSE); apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf); } }"
"void saxEndElement(const xchar *name) { int elm_ptr; xchar elm_name[ELM_NAME_LEN]; tree_node_t *nodo; EPRINTF1(""SAX.endElement(%s)\n"",name); if (state!=ST_PARSING) return; xtolower(elm_name,name,ELM_NAME_LEN); if ((elm_ptr= dtd_elm_search(elm_name))<0) { if ((elm_ptr= err_elm_desconocido(elm_name))<0) { INFORM(""elemento no encontrado\n""); return; } } for (nodo=actual_element; (nodo) && (ELM_ID(nodo)!=elm_ptr);  nodo=nodo->padre); if (!nodo) DEBUG(""cerrado elemento no abierto"") else { tree_node_t *p; for (p=actual_element; p != nodo; p=p->padre) elm_close(p); elm_close(nodo); if (!new_place_recovery_on || new_place_recovery_elm != actual_element) { actual_element= nodo->padre; } else { new_place_recovery_on = 0; actual_element = new_place_recovery_father; } if (!actual_element) state= ST_END; } }"
"int base64_encode(const void *data_in, size_t data_in_size, unsigned char *base64_out, size_t *base64_out_size) { return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, false); }"
"JsVar *jswrap_json_stringify(JsVar *v, JsVar *replacer, JsVar *space) { NOT_USED(replacer); JSONFlags flags = JSON_IGNORE_FUNCTIONS|JSON_NO_UNDEFINED|JSON_ARRAYBUFFER_AS_ARRAY|JSON_JSON_COMPATIBILE|JSON_ALLOW_TOJSON; JsVar *result = jsvNewFromEmptyString(); if (result) {    char whitespace[11] = """"; if (jsvIsUndefined(space) || jsvIsNull(space)) { } else if (jsvIsNumeric(space)) { unsigned int s = (unsigned int)jsvGetInteger(space); if (s>10) s=10; whitespace[s] = 0; while (s) whitespace[--s]=' '; } else { jsvGetString(space, whitespace, sizeof(whitespace)); } if (strlen(whitespace)) flags |= JSON_ALL_NEWLINES|JSON_PRETTY; jsfGetJSONWhitespace(v, result, flags, whitespace); } return result; }"
"static int get_gate_page(struct mm_struct *mm, unsigned long address, unsigned int gup_flags, struct vm_area_struct **vma, struct page **page) { pgd_t *pgd; p4d_t *p4d; pud_t *pud; pmd_t *pmd; pte_t *pte; int ret = -EFAULT; if (gup_flags & FOLL_WRITE) return -EFAULT; if (address > TASK_SIZE) pgd = pgd_offset_k(address); else pgd = pgd_offset_gate(mm, address); if (pgd_none(*pgd)) return -EFAULT; p4d = p4d_offset(pgd, address); if (p4d_none(*p4d)) return -EFAULT; pud = pud_offset(p4d, address); if (pud_none(*pud)) return -EFAULT; pmd = pmd_offset(pud, address); if (!pmd_present(*pmd)) return -EFAULT; VM_BUG_ON(pmd_trans_huge(*pmd)); pte = pte_offset_map(pmd, address); if (pte_none(*pte)) goto unmap; *vma = get_gate_vma(mm); if (!page) goto out; *page = vm_normal_page(*vma, address, *pte); if (!*page) { if ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte))) goto unmap; *page = pte_page(*pte); } if (unlikely(!try_get_page(*page))) { ret = -ENOMEM; goto unmap; } out: ret = 0; unmap: pte_unmap(pte); return ret; }"
"static char_u * fname_match( regmatch_T*rmp, char_u*name, intignore_case)  { char_u*match = NULL; char_u*p; if (name != NULL) { rmp->rm_ic = p_fic || ignore_case; if (vim_regexec(rmp, name, (colnr_T)0)) match = name; else { p = home_replace_save(NULL, name); if (p != NULL && vim_regexec(rmp, p, (colnr_T)0)) match = name; vim_free(p); } } return match; }"
void rose_start_heartbeat(struct sock *sk) { del_timer(&sk->sk_timer); sk->sk_timer.function = rose_heartbeat_expiry; sk->sk_timer.expires  = jiffies + 5 * HZ; add_timer(&sk->sk_timer); }
"static int route4_change(struct net *net, struct sk_buff *in_skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **arg, u32 flags, struct netlink_ext_ack *extack) { struct route4_head *head = rtnl_dereference(tp->root); struct route4_filter __rcu **fp; struct route4_filter *fold, *f1, *pfp, *f = NULL; struct route4_bucket *b; struct nlattr *opt = tca[TCA_OPTIONS]; struct nlattr *tb[TCA_ROUTE4_MAX + 1]; unsigned int h, th; int err; bool new = true; if (!handle) { NL_SET_ERR_MSG(extack, ""Creating with handle of 0 is invalid""); return -EINVAL; } if (opt == NULL) return -EINVAL; err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL); if (err < 0) return err; fold = *arg; if (fold && fold->handle != handle) return -EINVAL; err = -ENOBUFS; f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL); if (!f) goto errout; err = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE); if (err < 0) goto errout; if (fold) { f->id = fold->id; f->iif = fold->iif; f->res = fold->res; f->handle = fold->handle; f->tp = fold->tp; f->bkt = fold->bkt; new = false; } err = route4_set_parms(net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, flags, extack); if (err < 0) goto errout; h = from_hash(f->handle >> 16); fp = &f->bkt->ht[h]; for (pfp = rtnl_dereference(*fp); (f1 = rtnl_dereference(*fp)) != NULL; fp = &f1->next) if (f->handle < f1->handle) break; tcf_block_netif_keep_dst(tp->chain->block); rcu_assign_pointer(f->next, f1); rcu_assign_pointer(*fp, f); if (fold) { th = to_hash(fold->handle); h = from_hash(fold->handle >> 16); b = rtnl_dereference(head->table[th]); if (b) { fp = &b->ht[h]; for (pfp = rtnl_dereference(*fp); pfp; fp = &pfp->next, pfp = rtnl_dereference(*fp)) { if (pfp == fold) { rcu_assign_pointer(*fp, fold->next); break; } } } } route4_reset_fastmap(head); *arg = f; if (fold) { tcf_unbind_filter(tp, &fold->res); tcf_exts_get_net(&fold->exts); tcf_queue_work(&fold->rwork, route4_delete_filter_work); } return 0; errout: if (f) tcf_exts_destroy(&f->exts); kfree(f); return err; }"
"static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) { Var* var = calloc (1, sizeof (*var)); if (!var) { pe_printf (""Warning: calloc (Var)\n""); return NULL; } if ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wLength)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wLength); if ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wValueLength)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wValueLength); if ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wType)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wType); if (var->wType != 0 && var->wType != 1) { pe_printf (""Warning: check (Var wType)\n""); free_Var (var); return NULL; } var->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  if (!var->szKey) { pe_printf (""Warning: malloc (Var szKey)\n""); free_Var (var); return NULL; } if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) { pe_printf (""Warning: read (Var szKey)\n""); free_Var (var); return NULL; } *curAddr += TRANSLATION_UTF_16_LEN; if (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) { pe_printf (""Warning: check (Var szKey)\n""); free_Var (var); return NULL; } align32 (*curAddr); var->numOfValues = var->wValueLength / 4; if (!var->numOfValues) { pe_printf (""Warning: check (Var numOfValues)\n""); free_Var (var); return NULL; } var->Value = (ut32*) malloc (var->wValueLength); if (!var->Value) { pe_printf (""Warning: malloc (Var Value)\n""); free_Var (var); return NULL; } if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) { pe_printf (""Warning: read (Var Value)\n""); free_Var (var); return NULL; } *curAddr += var->wValueLength; return var; }"
"int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len) { int r; struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt; bool writeback = true; bool write_fault_to_spt; if (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len))) return 1; vcpu->arch.l1tf_flush_l1d = true; write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable; vcpu->arch.write_fault_to_shadow_pgtable = false; if (!(emulation_type & EMULTYPE_NO_DECODE)) { kvm_clear_exception_queue(vcpu); r = x86_decode_emulated_instruction(vcpu, emulation_type, insn, insn_len); if (r != EMULATION_OK)  { if ((emulation_type & EMULTYPE_TRAP_UD) || (emulation_type & EMULTYPE_TRAP_UD_FORCED)) { kvm_queue_exception(vcpu, UD_VECTOR); return 1; } if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt, emulation_type)) return 1; if (ctxt->have_exception) { WARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR || exception_type(ctxt->exception.vector) == EXCPT_TRAP); inject_emulated_exception(vcpu); return 1; } return handle_emulation_failure(vcpu, emulation_type); } } if ((emulation_type & EMULTYPE_VMWARE_GP) && !is_vmware_backdoor_opcode(ctxt)) { kvm_queue_exception_e(vcpu, GP_VECTOR, 0); return 1; } if (emulation_type & EMULTYPE_SKIP) { if (ctxt->mode != X86EMUL_MODE_PROT64) ctxt->eip = (u32)ctxt->_eip; else ctxt->eip = ctxt->_eip; if (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) { r = 1; goto writeback; } kvm_rip_write(vcpu, ctxt->eip); if (ctxt->eflags & X86_EFLAGS_RF) kvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF); return 1; } if (retry_instruction(ctxt, cr2_or_gpa, emulation_type)) return 1; if (vcpu->arch.emulate_regs_need_sync_from_vcpu) { vcpu->arch.emulate_regs_need_sync_from_vcpu = false; emulator_invalidate_register_cache(ctxt); } restart: if (emulation_type & EMULTYPE_PF) { ctxt->exception.address = cr2_or_gpa; if (vcpu->arch.mmu->root_role.direct) { ctxt->gpa_available = true; ctxt->gpa_val = cr2_or_gpa; } } else { ctxt->exception.address = 0; } r = x86_emulate_insn(ctxt); if (r == EMULATION_INTERCEPTED) return 1; if (r == EMULATION_FAILED) { if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt, emulation_type)) return 1; return handle_emulation_failure(vcpu, emulation_type); } if (ctxt->have_exception) { r = 1; if (inject_emulated_exception(vcpu)) return r; } else if (vcpu->arch.pio.count) { if (!vcpu->arch.pio.in) { vcpu->arch.pio.count = 0; } else { writeback = false; vcpu->arch.complete_userspace_io = complete_emulated_pio; } r = 0; } else if (vcpu->mmio_needed) { ++vcpu->stat.mmio_exits; if (!vcpu->mmio_is_write) writeback = false; r = 0; vcpu->arch.complete_userspace_io = complete_emulated_mmio; } else if (vcpu->arch.complete_userspace_io) { writeback = false; r = 0; } else if (r == EMULATION_RESTART) goto restart; else r = 1; writeback: if (writeback) { unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu); toggle_interruptibility(vcpu, ctxt->interruptibility); vcpu->arch.emulate_regs_need_sync_to_vcpu = false; if (!ctxt->have_exception || exception_type(ctxt->exception.vector) == EXCPT_TRAP) { kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS); if (ctxt->is_branch) kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS); kvm_rip_write(vcpu, ctxt->eip); if (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP))) r = kvm_vcpu_do_singlestep(vcpu); static_call_cond(kvm_x86_update_emulated_instruction)(vcpu); __kvm_set_rflags(vcpu, ctxt->eflags); } if (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF)) kvm_make_request(KVM_REQ_EVENT, vcpu); } else vcpu->arch.emulate_regs_need_sync_to_vcpu = true; return r; }"
"static int bgp_route_refresh_receive(struct peer *peer, bgp_size_t size) { iana_afi_t pkt_afi; afi_t afi; iana_safi_t pkt_safi; safi_t safi; struct stream *s; struct peer_af *paf; struct update_group *updgrp; struct peer *updgrp_peer; uint8_t subtype; bool force_update = false; bgp_size_t msg_length = size - (BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE); if (!CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_ADV)) { flog_err(EC_BGP_NO_CAP, ""%s [Error] BGP route refresh is not enabled"", peer->host); bgp_notify_send(peer, BGP_NOTIFY_HEADER_ERR, BGP_NOTIFY_HEADER_BAD_MESTYPE); return BGP_Stop; } if (!peer_established(peer)) { flog_err( EC_BGP_INVALID_STATUS, ""%s [Error] Route refresh packet received under status %s"", peer->host, lookup_msg(bgp_status_msg, peer->status, NULL)); bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR, bgp_fsm_error_subcode(peer->status)); return BGP_Stop; } s = peer->curr; pkt_afi = stream_getw(s); subtype = stream_getc(s); pkt_safi = stream_getc(s); if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) { zlog_info( ""%s REFRESH_REQ for unrecognized afi/safi: %s/%s - ignored"", peer->host, iana_afi2str(pkt_afi), iana_safi2str(pkt_safi)); return BGP_PACKET_NOOP; } if (size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE) { uint8_t *end; uint8_t when_to_refresh; uint8_t orf_type; uint16_t orf_len; if (subtype) { if (msg_length != 4) { zlog_err( ""%s Enhanced Route Refresh message length error"", peer->host); bgp_notify_send( peer, BGP_NOTIFY_ROUTE_REFRESH_ERR, BGP_NOTIFY_ROUTE_REFRESH_INVALID_MSG_LEN); } if (subtype > 2) zlog_err( ""%s Enhanced Route Refresh invalid subtype"", peer->host); } if (msg_length < 5) { zlog_info(""%s ORF route refresh length error"", peer->host); bgp_notify_send(peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_SUBCODE_UNSPECIFIC); return BGP_Stop; } when_to_refresh = stream_getc(s); end = stream_pnt(s) + (size - 5); while ((stream_pnt(s) + 2) < end) { orf_type = stream_getc(s); orf_len = stream_getw(s); if ((stream_pnt(s) + orf_len) > end) break;  if (orf_type == ORF_TYPE_PREFIX) { uint8_t *p_pnt = stream_pnt(s); uint8_t *p_end = stream_pnt(s) + orf_len; struct orf_prefix orfp; uint8_t common = 0; uint32_t seq; int psize; char name[BUFSIZ]; int ret = CMD_SUCCESS; if (bgp_debug_neighbor_events(peer)) { zlog_debug( ""%pBP rcvd Prefixlist ORF(%d) length %d"", peer, orf_type, orf_len); } snprintf(name, sizeof(name), ""%s.%d.%d"", peer->host, afi, safi); if (*p_pnt & ORF_COMMON_PART_REMOVE_ALL) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd Remove-All pfxlist ORF request"", peer); prefix_bgp_orf_remove_all(afi, name); break; } if (orf_len < 7) break; while (p_pnt < p_end) { int ok; memset(&orfp, 0, sizeof(orfp)); common = *p_pnt++; ok = ((uint32_t)(p_end - p_pnt) >= sizeof(uint32_t)); if (ok) { memcpy(&seq, p_pnt, sizeof(uint32_t)); p_pnt += sizeof(uint32_t); orfp.seq = ntohl(seq); } else p_pnt = p_end; if (p_pnt < p_end) orfp.ge = *p_pnt++; if (p_pnt < p_end) orfp.le = *p_pnt++; if ((ok = (p_pnt < p_end))) orfp.p.prefixlen = *p_pnt++; orfp.p.family = afi2family(afi); psize = PSIZE(orfp.p.prefixlen); if (psize > prefix_blen(&orfp.p)) { ok = 0; psize = prefix_blen(&orfp.p); } if (psize > (p_end - p_pnt)) { ok = 0; psize = p_end - p_pnt; } if (psize > 0) memcpy(&orfp.p.u.prefix, p_pnt, psize); p_pnt += psize; if (bgp_debug_neighbor_events(peer)) { char buf[INET6_BUFSIZ]; zlog_debug( ""%pBP rcvd %s %s seq %u %s/%d ge %d le %d%s"", peer, (common & ORF_COMMON_PART_REMOVE ? ""Remove"" : ""Add""), (common & ORF_COMMON_PART_DENY ? ""deny"" : ""permit""), orfp.seq, inet_ntop( orfp.p.family, &orfp.p.u.prefix, buf, INET6_BUFSIZ), orfp.p.prefixlen, orfp.ge, orfp.le, ok ? """" : "" MALFORMED""); } if (ok) ret = prefix_bgp_orf_set( name, afi, &orfp, (common & ORF_COMMON_PART_DENY ? 0 : 1), (common & ORF_COMMON_PART_REMOVE ? 0 : 1)); if (!ok || (ok && ret != CMD_SUCCESS)) { zlog_info( ""%pBP Received misformatted prefixlist ORF. Remove All pfxlist"", peer); prefix_bgp_orf_remove_all(afi, name); break; } } peer->orf_plist[afi][safi] = prefix_bgp_orf_lookup(afi, name); } stream_forward_getp(s, orf_len); } if (bgp_debug_neighbor_events(peer)) zlog_debug(""%pBP rcvd Refresh %s ORF request"", peer, when_to_refresh == REFRESH_DEFER ? ""Defer"" : ""Immediate""); if (when_to_refresh == REFRESH_DEFER) return BGP_PACKET_NOOP; } if (CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH)) UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH); paf = peer_af_find(peer, afi, safi); if (paf && paf->subgroup) { if (peer->orf_plist[afi][safi]) { updgrp = PAF_UPDGRP(paf); updgrp_peer = UPDGRP_PEER(updgrp); updgrp_peer->orf_plist[afi][safi] = peer->orf_plist[afi][safi]; } force_update = true; if (CHECK_FLAG(paf->subgroup->sflags, SUBGRP_STATUS_DEFAULT_ORIGINATE)) UNSET_FLAG(paf->subgroup->sflags, SUBGRP_STATUS_DEFAULT_ORIGINATE); } if (subtype == BGP_ROUTE_REFRESH_BORR) { if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED)) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s before EoR"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } if (peer->t_refresh_stalepath) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s, whereas BoRR already received"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_RECEIVED); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_RECEIVED); if (peer_active_nego(peer)) { SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ENHANCED_REFRESH); bgp_set_stale_route(peer, afi, safi); } if (peer_established(peer)) event_add_timer(bm->master, bgp_refresh_stalepath_timer_expire, paf, peer->bgp->stalepath_time, &peer->t_refresh_stalepath); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s, triggering timer for %u seconds"", peer, afi2str(afi), safi2str(safi), peer->bgp->stalepath_time); } else if (subtype == BGP_ROUTE_REFRESH_EORR) { if (!peer->t_refresh_stalepath) { zlog_err( ""%pBP rcvd route-refresh (EoRR) for %s/%s, whereas no BoRR received"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } EVENT_OFF(peer->t_refresh_stalepath); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_RECEIVED); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_RECEIVED); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (EoRR) for %s/%s, stopping BoRR timer"", peer, afi2str(afi), safi2str(safi)); if (peer->nsf[afi][safi]) bgp_clear_stale_route(peer, afi, safi); } else { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (REQUEST) for %s/%s"", peer, afi2str(afi), safi2str(safi)); if (CHECK_FLAG(peer->cap, PEER_CAP_ENHANCED_RR_RCV)) { if (!CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND)) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (REQUEST) for %s/%s before EoR"", peer, afi2str(afi), safi2str(safi)); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_REFRESH_PENDING); return BGP_PACKET_NOOP; } bgp_route_refresh_send(peer, afi, safi, 0, 0, 0, BGP_ROUTE_REFRESH_BORR); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP sending route-refresh (BoRR) for %s/%s"", peer, afi2str(afi), safi2str(safi)); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_SEND); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_SEND); } } bgp_announce_route(peer, afi, safi, force_update); return BGP_PACKET_NOOP; }"
"explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""num_buckets"", &num_buckets_)); int64 signed_hash_key_; OP_REQUIRES_OK(context, context->GetAttr(""hash_key"", &signed_hash_key_)); hash_key_ = static_cast<uint64>(signed_hash_key_); }"
"static unsigned int set_iommu_pte_present(unsigned long pt_mfn, unsigned long dfn, unsigned long next_mfn, int pde_level, bool iw, bool ir) { struct amd_iommu_pte *table, *pde; unsigned int flush_flags; table = map_domain_page(_mfn(pt_mfn)); pde = &table[pfn_to_pde_idx(dfn, pde_level)]; flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir); unmap_domain_page(table); return flush_flags; }"
"bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers) { for (const auto &h : headers) { if (h.first == ""Strict-Transport-Security"") { header = h.second; if (parseSTSHeader() && maxAgeFound) { expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge); return true; } } } subDomainsFound = false; return false; }"
"int fit_check_format(const void *fit, ulong size) { int ret; ret = fdt_check_header(fit); if (ret) { log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"", ret); return -ENOEXEC; } if (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) { log_debug(""Wrong FIT format: no description\n""); return -ENOMSG; } if (IMAGE_ENABLE_TIMESTAMP) { if (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) { log_debug(""Wrong FIT format: no timestamp\n""); return -ENODATA; } } if (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) { log_debug(""Wrong FIT format: no images parent node\n""); return -ENOENT; } return 0; }"
void Gobby::EditCommands::on_mark_set() { g_assert(m_current_view != NULL); GtkTextBuffer* buffer = GTK_TEXT_BUFFER(m_current_view->get_text_buffer()); m_actions.copy->set_enabled( gtk_text_buffer_get_has_selection(buffer)); if(m_current_view->get_active_user() != NULL) { m_actions.cut->set_enabled( gtk_text_buffer_get_has_selection(buffer)); } }
"static gboolean gvs_fixed_sized_maybe_is_normal (GVariantSerialised value) { if (value.size > 0) { gsize element_fixed_size; g_variant_type_info_query_element (value.type_info, NULL, &element_fixed_size); if (value.size != element_fixed_size) return FALSE; value.type_info = g_variant_type_info_element (value.type_info); value.depth++; return g_variant_serialised_is_normal (value); } return TRUE; }"
"static RAnalStructMember *parse_struct_member (const RBinDwarfDie *all_dies, const ut64 all_dies_count, ut64 curr_die_idx, RAnalStructMember *result) { r_return_val_if_fail (all_dies && result, NULL); const RBinDwarfDie *die = &all_dies[curr_die_idx]; char *name = NULL; char *type = NULL; ut64 offset = 0; ut64 size = 0; RStrBuf strbuf; r_strbuf_init (&strbuf); size_t i; for (i = 0; i < die->count; i++) { RBinDwarfAttrValue *value = &die->attr_values[i]; switch (die->attr_values[i].attr_name) { case DW_AT_name: name = strdup (value->string.content); if (!name) { goto cleanup; } break; case DW_AT_type: parse_type (all_dies, all_dies_count, value->reference, &strbuf, &size); type = r_strbuf_drain_nofree (&strbuf); if (!type || !*type) { goto cleanup; } break; case DW_AT_data_member_location: offset = value->data; break; case DW_AT_accessibility: case DW_AT_mutable: case DW_AT_data_bit_offset: break; case DW_AT_byte_size: size = value->data * CHAR_BIT; break; case DW_AT_bit_size: size = value->data; break; case DW_AT_containing_type: default: break; } } result->name = name; result->type = type; result->offset = offset; result->size = size; return result; cleanup: free (name); free (type); return NULL; }"
"void ConnectionManagerImpl::doEndStream(ActiveStream& stream) { bool reset_stream = false; if (stream.response_encoder_ != nullptr && (!stream.filter_manager_.remoteComplete() || !stream.state_.codec_saw_local_complete_)) { ENVOY_STREAM_LOG(debug, ""doEndStream() resetting stream"", stream); stream.filter_manager_.setLocalComplete(); stream.state_.codec_saw_local_complete_ = true; if (requestWasConnect(stream.request_headers_, codec_->protocol()) && (stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamConnectionFailure) || stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamConnectionTermination))) { stream.response_encoder_->getStream().resetStream(StreamResetReason::ConnectError); } else { if (stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamProtocolError)) { stream.response_encoder_->getStream().resetStream(StreamResetReason::ProtocolError); } else { stream.response_encoder_->getStream().resetStream(StreamResetReason::LocalReset); } } reset_stream = true; } if (!reset_stream) { doDeferredStreamDestroy(stream); } if (reset_stream && codec_->protocol() < Protocol::Http2) { drain_state_ = DrainState::Closing; } bool http_10_sans_cl = (codec_->protocol() == Protocol::Http10) && (!stream.response_headers_ || !stream.response_headers_->ContentLength()); bool connection_close = stream.state_.saw_connection_close_; bool request_complete = stream.filter_manager_.remoteComplete(); checkForDeferredClose(connection_close && (request_complete || http_10_sans_cl)); }"
"Status UncompressElement(const CompressedElement& compressed, std::vector<Tensor>* out) { int num_components = compressed.component_metadata_size(); out->clear(); out->reserve(num_components); std::vector<struct iovec> iov(num_components); std::vector<tstring> tensor_proto_strs; tensor_proto_strs.reserve(num_components); int64 total_size = 0; for (int i = 0; i < num_components; ++i) { const CompressedComponentMetadata& metadata = compressed.component_metadata(i); if (DataTypeCanUseMemcpy(metadata.dtype())) { out->emplace_back(metadata.dtype(), metadata.tensor_shape()); TensorBuffer* buffer = DMAHelper::buffer(&out->back()); iov[i].iov_base = buffer->data(); iov[i].iov_len = buffer->size(); } else { out->emplace_back(); tensor_proto_strs.emplace_back(); tstring& tensor_proto_str = tensor_proto_strs.back(); tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes()); iov[i].iov_base = tensor_proto_str.mdata(); iov[i].iov_len = tensor_proto_str.size(); } total_size += iov[i].iov_len; } const std::string& compressed_data = compressed.data(); size_t uncompressed_size; if (!port::Snappy_GetUncompressedLength( compressed_data.data(), compressed_data.size(), &uncompressed_size)) { return errors::Internal( ""Could not get snappy uncompressed length. Compressed data size: "", compressed_data.size()); } if (uncompressed_size != static_cast<size_t>(total_size)) { return errors::Internal( ""Uncompressed size mismatch. Snappy expects "", uncompressed_size, "" whereas the tensor metadata suggests "", total_size); } if (!port::Snappy_UncompressToIOVec(compressed_data.data(), compressed_data.size(), iov.data(), num_components)) { return errors::Internal(""Failed to perform snappy decompression.""); } int tensor_proto_strs_index = 0; for (int i = 0; i < num_components; ++i) { if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) { continue; } TensorProto tp; if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) { return errors::Internal(""Could not parse TensorProto""); } if (!out->at(i).FromProto(tp)) { return errors::Internal(""Could not parse Tensor""); } } return Status::OK(); }"
static void free_clt(struct rtrs_clt_sess *clt) { free_permits(clt); free_percpu(clt->pcpu_path); mutex_destroy(&clt->paths_ev_mutex); mutex_destroy(&clt->paths_mutex); device_unregister(&clt->dev); }
"void GPClient::onSettingsButtonClicked() { settingsDialog->setExtraArgs(settings::get(""extraArgs"", """").toString()); settingsDialog->setClientos(settings::get(""clientos"", ""Linux"").toString()); settingsDialog->show(); }"
"static int snd_ctl_elem_read(struct snd_card *card, struct snd_ctl_elem_value *control) { struct snd_kcontrol *kctl; struct snd_kcontrol_volatile *vd; unsigned int index_offset; int result; down_read(&card->controls_rwsem); kctl = snd_ctl_find_id(card, &control->id); if (kctl == NULL) { result = -ENOENT; } else { index_offset = snd_ctl_get_ioff(kctl, &control->id); vd = &kctl->vd[index_offset]; if ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) && kctl->get != NULL) { snd_ctl_build_ioff(&control->id, kctl, index_offset); result = kctl->get(kctl, control); } else result = -EPERM; } up_read(&card->controls_rwsem); return result; }"
"GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec) { GF_BitStream *bs; GF_Err e; CommandBufferItem *cbi; u32 NbPass = gf_list_count(codec->command_buffers); GF_List *nextPass = gf_list_new(); while (NbPass) { while (gf_list_count(codec->command_buffers)) { cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0); gf_list_rem(codec->command_buffers, 0); codec->current_graph = gf_node_get_graph(cbi->node); e = GF_OK; if (cbi->cb->bufferSize) { bs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ); gf_bs_set_eos_callback(bs, BM_EndOfStream, codec); e = BM_ParseCommand(codec, bs, cbi->cb->commandList); gf_bs_del(bs); } if (!e) { gf_free(cbi); continue; } while (gf_list_count(cbi->cb->commandList)) { u32 i; GF_CommandField *cf; GF_Command *com = (GF_Command *)gf_list_get(cbi->cb->commandList, 0); gf_list_rem(cbi->cb->commandList, 0); cf = (GF_CommandField *) gf_list_get(com->command_fields, 0); if (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) { for (i=0; i<gf_list_count(codec->command_buffers); i++) { CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i); if (cbi2->cb == cf->field_ptr) { gf_free(cbi2); gf_list_rem(codec->command_buffers, i); i--; } } } gf_sg_command_del(com); } gf_list_add(nextPass, cbi); } if (!gf_list_count(nextPass)) break; while (gf_list_count(nextPass)) { cbi = (CommandBufferItem *)gf_list_get(nextPass, 0); gf_list_rem(nextPass, 0); gf_list_add(codec->command_buffers, cbi); } NbPass --; if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers); codec->LastError = GF_OK; } gf_list_del(nextPass); return GF_OK; }"
"static int sampled_data_continue(i_ctx_t *i_ctx_p) { os_ptr op = osp; gs_sampled_data_enum *penum = senum; gs_function_Sd_params_t * params = (gs_function_Sd_params_t *)&penum->pfn->params; int i, j, num_out = params->n; int code = 0; byte * data_ptr; double sampled_data_value_max = (double)((1 << params->BitsPerSample) - 1); int bps = bits2bytes(params->BitsPerSample), stack_depth_adjust = 0; if (num_out + O_STACK_PAD + penum->o_stack_depth != ref_stack_count(&o_stack)) { stack_depth_adjust = ref_stack_count(&o_stack) - penum->o_stack_depth; if (stack_depth_adjust < 0) { push(-stack_depth_adjust); ifree_object(penum->pfn, ""sampled_data_continue(pfn)""); ifree_object(penum, ""sampled_data_continue((enum)""); return_error(gs_error_undefinedresult); } } data_ptr = cube_ptr_from_index(params, penum->indexes); for (i=0; i < num_out; i++) { ulong cv; double value; double rmin = params->Range[2 * i]; double rmax = params->Range[2 * i + 1]; code = real_param(op + i - num_out + 1, &value); if (code < 0) { esp -= estack_storage; return code; } if (value < rmin) value = rmin; else if (value > rmax) value = rmax; value = (value - rmin) / (rmax - rmin); cv = (int) (value * sampled_data_value_max + 0.5); for (j = 0; j < bps; j++) data_ptr[bps * i + j] = (byte)(cv >> ((bps - 1 - j) * 8)); } pop(num_out);     if (increment_cube_indexes(params, penum->indexes)) { if (stack_depth_adjust == 0) pop(O_STACK_PAD);     else pop(stack_depth_adjust - num_out); code = 0; if (esp_finish_proc != 0) code = esp_finish_proc(i_ctx_p); return code; } else { if (stack_depth_adjust) { stack_depth_adjust -= num_out; push(O_STACK_PAD - stack_depth_adjust); for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++) make_null(op - i); } } return sampled_data_sample(i_ctx_p); }"
"void WasmBinaryBuilder::visitRethrow(Rethrow* curr) { BYN_TRACE(""zz node: Rethrow\n""); curr->target = getExceptionTargetName(getU32LEB()); assert(curr->target != DELEGATE_CALLER_TARGET); curr->finalize(); }"
"void SEIUnit::deserialize(SPSUnit& sps, int orig_hrd_parameters_present_flag) { pic_struct = -1; uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen; try { int rez = NALUnit::deserialize(m_nalBuffer, nalEnd); if (rez != 0) return; uint8_t* curBuff = m_nalBuffer + 1; while (curBuff < nalEnd - 1) { int payloadType = 0; for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadType += 0xFF; if (curBuff >= nalEnd) return; payloadType += *curBuff++; if (curBuff >= nalEnd) return; int payloadSize = 0; for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadSize += 0xFF; if (curBuff >= nalEnd) return; payloadSize += *curBuff++; if (curBuff >= nalEnd) return; sei_payload(sps, payloadType, curBuff, payloadSize, orig_hrd_parameters_present_flag); m_processedMessages.insert(payloadType); curBuff += payloadSize; } } catch (BitStreamException) { LTRACE(LT_WARN, 2, ""Bad SEI detected. SEI too short""); } return; }"
"static gboolean gvs_tuple_is_normal (GVariantSerialised value) { guint offset_size; gsize offset_ptr; gsize length; gsize offset; gsize i; if G_UNLIKELY (value.data == NULL && value.size != 0) return FALSE; offset_size = gvs_get_offset_size (value.size); length = g_variant_type_info_n_members (value.type_info); offset_ptr = value.size; offset = 0; for (i = 0; i < length; i++) { const GVariantMemberInfo *member_info; GVariantSerialised child; gsize fixed_size; guint alignment; gsize end; member_info = g_variant_type_info_member_info (value.type_info, i); child.type_info = member_info->type_info; child.depth = value.depth + 1; g_variant_type_info_query (child.type_info, &alignment, &fixed_size); while (offset & alignment) { if (offset > value.size || value.data[offset] != '\0') return FALSE; offset++; } child.data = value.data + offset; switch (member_info->ending_type) { case G_VARIANT_MEMBER_ENDING_FIXED: end = offset + fixed_size; break; case G_VARIANT_MEMBER_ENDING_LAST: end = offset_ptr; break; case G_VARIANT_MEMBER_ENDING_OFFSET: if (offset_ptr < offset_size) return FALSE; offset_ptr -= offset_size; if (offset_ptr < offset) return FALSE; end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size); break; default: g_assert_not_reached (); } if (end < offset || end > offset_ptr) return FALSE; child.size = end - offset; if (child.size == 0) child.data = NULL; if (!g_variant_serialised_is_normal (child)) return FALSE; offset = end; } { gsize fixed_size; guint alignment; g_variant_type_info_query (value.type_info, &alignment, &fixed_size); if (fixed_size) { g_assert (fixed_size == value.size); g_assert (offset_ptr == value.size); if (i == 0) { if (value.data[offset++] != '\0') return FALSE; } else { while (offset & alignment) if (value.data[offset++] != '\0') return FALSE; } g_assert (offset == value.size); } } return offset_ptr == offset; }"
"static krb5_error_code get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out, const uint8_t **contents_out, size_t *clen_out, const uint8_t **remainder_out, size_t *rlen_out) { krb5_error_code ret; uint8_t o; const uint8_t *c, *p, *tag_start = asn1; size_t clen, llen, i; taginfo t; *contents_out = *remainder_out = NULL; *clen_out = *rlen_out = 0; if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; tag_out->asn1class = o & 0xC0; tag_out->construction = o & 0x20; if ((o & 0x1F) != 0x1F) { tag_out->tagnum = o & 0x1F; } else { tag_out->tagnum = 0; do { if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F); } while (o & 0x80); } if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; if (o == 0x80) { if (tag_out->construction != CONSTRUCTED) return ASN1_MISMATCH_INDEF; p = asn1; while (!(len >= 2 && p[0] == 0 && p[1] == 0)) { ret = get_tag(p, len, &t, &c, &clen, &p, &len); if (ret) return ret; } tag_out->tag_end_len = 2; *contents_out = asn1; *clen_out = p - asn1; *remainder_out = p + 2; *rlen_out = len - 2; } else if ((o & 0x80) == 0) { if (o > len) return ASN1_OVERRUN; tag_out->tag_end_len = 0; *contents_out = asn1; *clen_out = o; *remainder_out = asn1 + *clen_out; *rlen_out = len - (*remainder_out - asn1); } else { llen = o & 0x7F; if (llen > len) return ASN1_OVERRUN; if (llen > sizeof(*clen_out)) return ASN1_OVERFLOW; for (i = 0, clen = 0; i < llen; i++) clen = (clen << 8) | asn1[i]; if (clen > len - llen) return ASN1_OVERRUN; tag_out->tag_end_len = 0; *contents_out = asn1 + llen; *clen_out = clen; *remainder_out = *contents_out + clen; *rlen_out = len - (*remainder_out - asn1); } tag_out->tag_len = *contents_out - tag_start; return 0; }"
"static void headerMergeLegacySigs(Header h, Header sigh) { HeaderIterator hi; struct rpmtd_s td; hi = headerInitIterator(sigh); for (; headerNext(hi, &td); rpmtdFreeData(&td)) { switch (td.tag) { case RPMSIGTAG_SIZE: td.tag = RPMTAG_SIGSIZE; break; case RPMSIGTAG_PGP: td.tag = RPMTAG_SIGPGP; break; case RPMSIGTAG_MD5: td.tag = RPMTAG_SIGMD5; break; case RPMSIGTAG_GPG: td.tag = RPMTAG_SIGGPG; break; case RPMSIGTAG_PGP5: td.tag = RPMTAG_SIGPGP5; break; case RPMSIGTAG_PAYLOADSIZE: td.tag = RPMTAG_ARCHIVESIZE; break; case RPMSIGTAG_FILESIGNATURES: td.tag = RPMTAG_FILESIGNATURES; break; case RPMSIGTAG_FILESIGNATURELENGTH: td.tag = RPMTAG_FILESIGNATURELENGTH; break; case RPMSIGTAG_VERITYSIGNATURES: case RPMSIGTAG_VERITYSIGNATUREALGO: case RPMSIGTAG_SHA1: case RPMSIGTAG_SHA256: case RPMSIGTAG_DSA: case RPMSIGTAG_RSA: default: if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE)) continue; break; } if (!headerIsEntry(h, td.tag)) { switch (td.type) { case RPM_NULL_TYPE: continue; break; case RPM_CHAR_TYPE: case RPM_INT8_TYPE: case RPM_INT16_TYPE: case RPM_INT32_TYPE: case RPM_INT64_TYPE: if (td.count != 1) continue; break; case RPM_STRING_TYPE: case RPM_STRING_ARRAY_TYPE: case RPM_BIN_TYPE: if (td.count >= 16*1024) continue; break; case RPM_I18NSTRING_TYPE: continue; break; } (void) headerPut(h, &td, HEADERPUT_DEFAULT); } } headerFreeIterator(hi); }"
"u8 spectre_bhb_loop_affected(int scope) { u8 k = 0; static u8 max_bhb_k; if (scope == SCOPE_LOCAL_CPU) { static const struct midr_range spectre_bhb_k32_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A78), MIDR_ALL_VERSIONS(MIDR_CORTEX_A78AE), MIDR_ALL_VERSIONS(MIDR_CORTEX_A78C), MIDR_ALL_VERSIONS(MIDR_CORTEX_X1), MIDR_ALL_VERSIONS(MIDR_CORTEX_A710), MIDR_ALL_VERSIONS(MIDR_CORTEX_X2), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_N2), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_V1), {}, }; static const struct midr_range spectre_bhb_k24_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A76), MIDR_ALL_VERSIONS(MIDR_CORTEX_A77), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_N1), {}, }; static const struct midr_range spectre_bhb_k8_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A72), MIDR_ALL_VERSIONS(MIDR_CORTEX_A57), {}, }; if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k32_list)) k = 32; else if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k24_list)) k = 24; else if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k8_list)) k =  8; max_bhb_k = max(max_bhb_k, k); } else { k = max_bhb_k; } return k; }"
"void sqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb) { int inx; ST **cols = tree->_.insert.cols; dk_set_t aliases = NULL; dk_set_t new_cols = NULL, new_vals = NULL; if (!sqlc_view_is_updatable (view)) sqlc_new_error (sc->sc_cc, ""37000"", ""SQ114"", ""View %s is not updatable in insert."", tb->tb_name); tree->_.insert.table = (ST *) t_box_copy_tree ( (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table); _DO_BOX (inx, tree->_.insert.cols) { sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases); if (!ST_P (tree->_.insert.vals, SELECT_STMT)) sinv_sqlo_check_col_val (&cols[inx], &(tree->_.insert.vals->_.ins_vals.vals[inx]), &new_cols, &new_vals); } END_DO_BOX; if (new_cols) { ST ** new_cols_box = (ST **) t_alloc_box ( (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t), DV_ARRAY_OF_POINTER); ST ** new_vals_box = (ST **) t_alloc_box ( (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t), DV_ARRAY_OF_POINTER); memcpy (new_cols_box, cols, box_length (cols)); memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols)); inx = BOX_ELEMENTS (cols); DO_SET (ST *, new_col, &new_cols) { new_cols_box[inx] = new_col; new_vals_box[inx] = (ST *) new_vals->data; new_vals = new_vals->next; inx ++; } END_DO_SET (); tree->_.insert.cols = cols = new_cols_box; tree->_.insert.vals->_.ins_vals.vals = new_vals_box; } _DO_BOX (inx, tree->_.insert.cols) { if (ST_COLUMN (cols[inx], COL_DOTTED)) { ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name); cols[inx] = c; } else { sqlc_new_error (sc->sc_cc, ""37000"", ""SQ115"", ""Non-updatable column in view %s (expression or constant)"", tb->tb_name); } } END_DO_BOX; sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs); sqlc_insert (sc, tree); }"
"static void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb) { struct inquiry_data data; struct extended_inquiry_info *info = (void *) (skb->data + 1); int num_rsp = *((__u8 *) skb->data); size_t eir_len; BT_DBG(""%s num_rsp %d"", hdev->name, num_rsp); if (!num_rsp) return; if (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) return; hci_dev_lock(hdev); for (; num_rsp; num_rsp--, info++) { u32 flags; bool name_known; bacpy(&data.bdaddr, &info->bdaddr); data.pscan_rep_mode= info->pscan_rep_mode; data.pscan_period_mode= info->pscan_period_mode; data.pscan_mode= 0x00; memcpy(data.dev_class, info->dev_class, 3); data.clock_offset= info->clock_offset; data.rssi= info->rssi; data.ssp_mode= 0x01; if (hci_dev_test_flag(hdev, HCI_MGMT)) name_known = eir_get_data(info->data, sizeof(info->data), EIR_NAME_COMPLETE, NULL); else name_known = true; flags = hci_inquiry_cache_update(hdev, &data, name_known); eir_len = eir_get_length(info->data, sizeof(info->data)); mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00, info->dev_class, info->rssi, flags, info->data, eir_len, NULL, 0); } hci_dev_unlock(hdev); }"
"void luaD_shrinkstack (lua_State *L) { int inuse = stackinuse(L); int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK; if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;   if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize) luaD_reallocstack(L, goodsize, 0);   else   condmovestack(L,{},{});   luaE_shrinkCI(L);   }"
"int evtchn_send(struct domain *ld, unsigned int lport) { struct evtchn *lchn, *rchn; struct domain *rd; int            rport, ret = 0; if ( !port_is_valid(ld, lport) ) return -EINVAL; lchn = evtchn_from_port(ld, lport); spin_lock(&lchn->lock); if ( unlikely(consumer_is_xen(lchn)) ) { ret = -EINVAL; goto out; } ret = xsm_evtchn_send(XSM_HOOK, ld, lchn); if ( ret ) goto out; switch ( lchn->state ) { case ECS_INTERDOMAIN: rd    = lchn->u.interdomain.remote_dom; rport = lchn->u.interdomain.remote_port; rchn  = evtchn_from_port(rd, rport); if ( consumer_is_xen(rchn) ) xen_notification_fn(rchn)(rd->vcpu[rchn->notify_vcpu_id], rport); else evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn); break; case ECS_IPI: evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn); break; case ECS_UNBOUND: break; default: ret = -EINVAL; } out: spin_unlock(&lchn->lock); return ret; }"
"zmq::stream_engine_base_t::stream_engine_base_t ( fd_t fd_, const options_t &options_, const endpoint_uri_pair_t &endpoint_uri_pair_) : _options (options_), _inpos (NULL), _insize (0), _decoder (NULL), _outpos (NULL), _outsize (0), _encoder (NULL), _mechanism (NULL), _next_msg (NULL), _process_msg (NULL), _metadata (NULL), _input_stopped (false), _output_stopped (false), _endpoint_uri_pair (endpoint_uri_pair_), _has_handshake_timer (false), _has_ttl_timer (false), _has_timeout_timer (false), _has_heartbeat_timer (false), _peer_address (get_peer_address (fd_)), _s (fd_), _handle (static_cast<handle_t> (NULL)), _plugged (false), _handshaking (true), _io_error (false), _session (NULL), _socket (NULL) { const int rc = _tx_msg.init (); errno_assert (rc == 0); unblock_socket (_s); }"
void timeoutExpired() noexcept override { if (counter > 0 && httpSessionStats) { httpSessionStats->recordControlMsgsInInterval(counter); } counter = 0; }
"static char_u * cstrchr(char_u *s, int c) { char_u*p; intcc; if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1)) return vim_strchr(s, c); if (enc_utf8 && c > 0x80) cc = utf_fold(c); else if (MB_ISUPPER(c)) cc = MB_TOLOWER(c); else if (MB_ISLOWER(c)) cc = MB_TOUPPER(c); else return vim_strchr(s, c); if (has_mbyte) { for (p = s; *p != NUL; p += (*mb_ptr2len)(p)) { if (enc_utf8 && c > 0x80) { if (utf_fold(utf_ptr2char(p)) == cc) return p; } else if (*p == c || *p == cc) return p; } } else for (p = s; *p != NUL; ++p) if (*p == c || *p == cc) return p; return NULL; }"
static Status ValidateSavedTensors(const GraphDef& graph_def) { for (const auto& node : graph_def.node()) { TF_RETURN_IF_ERROR(ValidateNode(node)); } if (graph_def.has_library()) { const FunctionDefLibrary& library = graph_def.library(); for (const auto& function : library.function()) { for (const auto& node : function.node_def()) { TF_RETURN_IF_ERROR(ValidateNode(node)); } } } return Status::OK(); }
"GF_Err gnrm_box_dump(GF_Box *a, FILE * trace) { GF_GenericSampleEntryBox *p = (GF_GenericSampleEntryBox *)a; if (p->EntryType) { a->type = p->EntryType; if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) a->type = GF_4CC('u','k','n','w'); } gf_isom_box_dump_start(a, ""SampleDescriptionEntryBox"", trace); gf_fprintf(trace, ""DataReferenceIndex=\""%d\"" ExtensionDataSize=\""%d\"""", p->dataReferenceIndex, p->data_size); a->type = GF_ISOM_BOX_TYPE_GNRM; gnr_dump_exts(p->data, p->data_size, trace); gf_isom_box_dump_done(""SampleDescriptionEntryBox"", a, trace); return GF_OK; }"
"int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type) { struct fuse_conn *fc = get_fuse_conn(inode); const char *name; int ret; if (!fc->posix_acl || fc->no_setxattr) return -EOPNOTSUPP; if (type == ACL_TYPE_ACCESS) name = XATTR_NAME_POSIX_ACL_ACCESS; else if (type == ACL_TYPE_DEFAULT) name = XATTR_NAME_POSIX_ACL_DEFAULT; else return -EINVAL; if (acl) { size_t size = posix_acl_xattr_size(acl->a_count); void *value; if (size > PAGE_SIZE) return -E2BIG; value = kmalloc(size, GFP_KERNEL); if (!value) return -ENOMEM; ret = posix_acl_to_xattr(fc->user_ns, acl, value, size); if (ret < 0) { kfree(value); return ret; } ret = fuse_setxattr(inode, name, value, size, 0); kfree(value); } else { ret = fuse_removexattr(inode, name); } forget_all_cached_acls(inode); fuse_invalidate_attr(inode); return ret; }"
"static int dissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, rpc_call_info_value *civ) { guint32    val_follows; guint32    name_len; char   *name; proto_tree *dirlist_tree; proto_item *eitem; proto_tree *entry_tree; dirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, ""Directory Listing""); while (1) { val_follows = tvb_get_ntohl(tvb, offset); if (val_follows) { int start_off = offset; name_len = tvb_get_ntohl(tvb, offset + 12); tvb_ensure_bytes_exist(tvb, offset, 16 + name_len); name = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len); name[name_len] = '\0'; eitem = proto_tree_add_string_format( dirlist_tree, hf_nfs_name, tvb, offset, -1, name, ""Entry: %s"", name); entry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry); proto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows); offset += 4; if (entry_tree) dissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset); offset += 8; offset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL); offset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ); proto_item_set_len(eitem, offset - start_off); } else { break; } } if (dirlist_tree) { proto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows); offset += 4; offset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset); } else { offset += 8; } return offset; }"
"static int get_filter(struct sss_certmap_ctx *ctx, struct ldap_mapping_rule *parsed_mapping_rule, struct sss_cert_content *cert_content, char **filter) { struct ldap_mapping_rule_comp *comp; char *result = NULL; char *expanded = NULL; int ret; result = talloc_strdup(ctx, """"); if (result == NULL) { return ENOMEM; } for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) { if (comp->type == comp_string) { result = talloc_strdup_append(result, comp->val); } else if (comp->type == comp_template) { ret = expand_template(ctx, comp->parsed_template, cert_content, &expanded); if (ret != 0) { CM_DEBUG(ctx, ""Failed to expanded template.""); goto done; } result = talloc_strdup_append(result, expanded); talloc_free(expanded); expanded = NULL; if (result == NULL) { ret = ENOMEM; goto done; } } else { ret = EINVAL; CM_DEBUG(ctx, ""Unsupported component type.""); goto done; } } ret = 0; done: talloc_free(expanded); if (ret == 0) { *filter = result; } else { talloc_free(result); } return ret; }"
"int fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr) { int ret1 = 0, ret2 = 0, ip_len; assert(tcpedit); assert(pkthdr); assert(ip_hdr); if (pkthdr->caplen < sizeof(*ip_hdr)) { tcpedit_setwarn(tcpedit, ""caplen too small to read IPv4 header: %u"", pkthdr->caplen); return TCPEDIT_WARN; } if (ip_hdr->ip_v != 4) { tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv4 packet: got %u"", ip_hdr->ip_v); return TCPEDIT_ERROR; } if (pkthdr->caplen == pkthdr->len && (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) { ip_len = (int)ntohs(ip_hdr->ip_len); ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p, ip_len - (ip_hdr->ip_hl << 2)); if (ret1 < 0) return TCPEDIT_ERROR; } ip_len = (int)ntohs(ip_hdr->ip_len); ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len); if (ret2 < 0) return TCPEDIT_ERROR; if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN) return TCPEDIT_WARN; return TCPEDIT_OK; }"
"X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level, X509_POLICY_DATA *data, X509_POLICY_NODE *parent, X509_POLICY_TREE *tree) { X509_POLICY_NODE *node; node = OPENSSL_zalloc(sizeof(*node)); if (node == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); return NULL; } node->data = data; node->parent = parent; if (level) { if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) { if (level->anyPolicy) goto node_error; level->anyPolicy = node; } else { if (level->nodes == NULL) level->nodes = ossl_policy_node_cmp_new(); if (level->nodes == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_NODE_push(level->nodes, node)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } } if (tree) { if (tree->extra_data == NULL) tree->extra_data = sk_X509_POLICY_DATA_new_null(); if (tree->extra_data == NULL){ ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } if (parent) parent->nchild++; return node; node_error: ossl_policy_node_free(node); return NULL; }"
"static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx, struct wire_field_hdr *str_hdr, struct ntlm_buffer *buffer, size_t payload_offs, char **str) { char *in, *out = NULL; uint16_t str_len; uint32_t str_offs; size_t outlen; int ret = 0; str_len = le16toh(str_hdr->len); if (str_len == 0) goto done; str_offs = le32toh(str_hdr->offset); if ((str_offs < payload_offs) || (str_offs > buffer->length) || (str_offs + str_len > buffer->length)) { return ERR_DECODE; } in = (char *)&buffer->data[str_offs]; out = malloc(str_len * 2 + 1); if (!out) return ENOMEM; ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen); out[outlen] = '\0'; done: if (ret) { safefree(out); } *str = out; return ret; }"
"TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteEvalTensor* params, const TfLiteEvalTensor* indices, TfLiteEvalTensor* output) { switch (params->type) { case kTfLiteFloat32: return GatherNd<float, IndicesT>(params, indices, output); break; case kTfLiteInt8: return GatherNd<int8_t, IndicesT>(params, indices, output); break; default: TF_LITE_KERNEL_LOG(context, ""Params type '%s' are not supported by gather_nd."", TfLiteTypeGetName(params->type)); return kTfLiteError; } }"
"static pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory, const pjmedia_codec_info *id, pjmedia_codec **p_codec) { and_media_private_t *codec_data; pjmedia_codec *codec; int idx; pj_pool_t *pool; unsigned i; PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL); PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL); pj_mutex_lock(and_media_factory.mutex); idx = -1; for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) { pj_str_t name = pj_str((char*)and_media_codec[i].name); if ((pj_stricmp(&id->encoding_name, &name) == 0) && (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) && (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) && (and_media_codec[i].enabled)) { idx = i; break; } } if (idx == -1) { *p_codec = NULL; return PJMEDIA_CODEC_EFAILED; } pool = pjmedia_endpt_create_pool(and_media_factory.endpt, ""andmedaud%p"", 512, 512); codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec); PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM); codec->op = &and_media_op; codec->factory = factory; codec->codec_data = PJ_POOL_ZALLOC_T(pool, and_media_private_t); codec_data = (and_media_private_t*) codec->codec_data; if (!and_media_codec[idx].has_native_plc) { pj_status_t status; status = pjmedia_plc_create(pool, and_media_codec[idx].clock_rate, and_media_codec[idx].samples_per_frame, 0, &codec_data->plc); if (status != PJ_SUCCESS) { goto on_error; } } if (!and_media_codec[idx].has_native_vad) { pj_status_t status; status = pjmedia_silence_det_create(pool, and_media_codec[idx].clock_rate, and_media_codec[idx].samples_per_frame, &codec_data->vad); if (status != PJ_SUCCESS) { goto on_error; } } codec_data->pool = pool; codec_data->codec_idx = idx; create_codec(codec_data); if (!codec_data->enc || !codec_data->dec) { goto on_error; } pj_mutex_unlock(and_media_factory.mutex); *p_codec = codec; return PJ_SUCCESS; on_error: pj_mutex_unlock(and_media_factory.mutex); and_media_dealloc_codec(factory, codec); return PJMEDIA_CODEC_EFAILED; }"
bool lcTexture::Load(int Flags) { for (Image& Image : mImages) Image.ResizePow2(); mFlags = Flags; lcGetPiecesLibrary()->QueueTextureUpload(this); return true; }
"void __attribute__((cold)) dump_obj(FILE* f, obj_t* obj) { if (!obj) { fprintf(f, ""null\n""); return; } obj_ty_t type = obj->obj_ty; if (type <= OT_LAST_PRIMITIVE) { dump_primitive_obj(f, obj); fputc('\n', f); } obj_composite_t* cobj = (obj_composite_t*)(void*)obj; for (; cobj; cobj = cobj->reverse_nesting_order) { dump_composite_obj(f, cobj); } }"
"static int pci_xhci_complete_commands(struct pci_xhci_vdev *xdev) { struct xhci_trbevtrb; struct xhci_trb*trb; uint64_tcrcr; uint32_tccs; uint32_ttype; uint32_tslot; uint32_tcmderr; xdev->opregs.crcr |= XHCI_CRCR_LO_CRR; trb = xdev->opregs.cr_p; ccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS; crcr = xdev->opregs.crcr & ~0xF; while (1) { xdev->opregs.cr_p = trb; type = XHCI_TRB_3_TYPE_GET(trb->dwTrb3); if ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) != (ccs & XHCI_TRB_3_CYCLE_BIT)) break; UPRINTF(LDBG, ""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x"" "" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\r\n"", type, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3, trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs); cmderr = XHCI_TRB_ERROR_SUCCESS; evtrb.dwTrb2 = 0; evtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) | XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE); slot = 0; switch (type) { case XHCI_TRB_TYPE_LINK: if (trb->dwTrb3 & XHCI_TRB_3_TC_BIT) ccs ^= XHCI_CRCR_LO_RCS; break; case XHCI_TRB_TYPE_ENABLE_SLOT: cmderr = pci_xhci_cmd_enable_slot(xdev, &slot); break; case XHCI_TRB_TYPE_DISABLE_SLOT: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_disable_slot(xdev, slot); break; case XHCI_TRB_TYPE_ADDRESS_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_address_device(xdev, slot, trb); break; case XHCI_TRB_TYPE_CONFIGURE_EP: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_config_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_EVALUATE_CTX: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_EP: UPRINTF(LDBG, ""Reset Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_STOP_EP: UPRINTF(LDBG, ""Stop Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_SET_TR_DEQUEUE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_set_tr(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_device(xdev, slot); break; case XHCI_TRB_TYPE_FORCE_EVENT: break; case XHCI_TRB_TYPE_NEGOTIATE_BW: break; case XHCI_TRB_TYPE_SET_LATENCY_TOL: break; case XHCI_TRB_TYPE_GET_PORT_BW: break; case XHCI_TRB_TYPE_FORCE_HEADER: break; case XHCI_TRB_TYPE_NOOP_CMD: break; default: UPRINTF(LDBG, ""unsupported cmd %x\r\n"", type); break; } if (type != XHCI_TRB_TYPE_LINK) { evtrb.qwTrb0 = crcr; evtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr); evtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot); UPRINTF(LDBG, ""command 0x%x result: 0x%x\r\n"", type, cmderr); if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) { UPRINTF(LFTL, ""Failed to inject command completion event!\r\n""); return -ENAVAIL; } } trb = pci_xhci_trb_next(xdev, trb, &crcr); if (!trb) { UPRINTF(LDBG, ""Get the invalid trb in %s!\r\n"", __func__); break; } } xdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs; xdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR; return 0; }"
"static long do_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg) { const struct fb_ops *fb; struct fb_var_screeninfo var; struct fb_fix_screeninfo fix; struct fb_cmap cmap_from; struct fb_cmap_user cmap; void __user *argp = (void __user *)arg; long ret = 0; switch (cmd) { case FBIOGET_VSCREENINFO: lock_fb_info(info); var = info->var; unlock_fb_info(info); ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0; break; case FBIOPUT_VSCREENINFO: if (copy_from_user(&var, argp, sizeof(var))) return -EFAULT; console_lock(); lock_fb_info(info); ret = fb_set_var(info, &var); if (!ret) fbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL); unlock_fb_info(info); console_unlock(); if (!ret && copy_to_user(argp, &var, sizeof(var))) ret = -EFAULT; break; case FBIOGET_FSCREENINFO: lock_fb_info(info); memcpy(&fix, &info->fix, sizeof(fix)); if (info->flags & FBINFO_HIDE_SMEM_START) fix.smem_start = 0; unlock_fb_info(info); ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0; break; case FBIOPUTCMAP: if (copy_from_user(&cmap, argp, sizeof(cmap))) return -EFAULT; ret = fb_set_user_cmap(&cmap, info); break; case FBIOGETCMAP: if (copy_from_user(&cmap, argp, sizeof(cmap))) return -EFAULT; lock_fb_info(info); cmap_from = info->cmap; unlock_fb_info(info); ret = fb_cmap_to_user(&cmap_from, &cmap); break; case FBIOPAN_DISPLAY: if (copy_from_user(&var, argp, sizeof(var))) return -EFAULT; console_lock(); lock_fb_info(info); ret = fb_pan_display(info, &var); unlock_fb_info(info); console_unlock(); if (ret == 0 && copy_to_user(argp, &var, sizeof(var))) return -EFAULT; break; case FBIO_CURSOR: ret = -EINVAL; break; case FBIOGET_CON2FBMAP: ret = fbcon_get_con2fb_map_ioctl(argp); break; case FBIOPUT_CON2FBMAP: ret = fbcon_set_con2fb_map_ioctl(argp); break; case FBIOBLANK: if (arg > FB_BLANK_POWERDOWN) return -EINVAL; console_lock(); lock_fb_info(info); ret = fb_blank(info, arg); fbcon_fb_blanked(info, arg); unlock_fb_info(info); console_unlock(); break; default: lock_fb_info(info); fb = info->fbops; if (fb->fb_ioctl) ret = fb->fb_ioctl(info, cmd, arg); else ret = -ENOTTY; unlock_fb_info(info); } return ret; }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"char* url::get_pac() { int sock = -1; bool chunked = false; unsigned long int content_length = 0, status = 0; char* buffer = NULL; string request; if (m_scheme == ""file"" || m_scheme == ""pac+file"") { struct stat st; if ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0) return NULL; if (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) { buffer = new char[st.st_size+1]; memset(buffer, 0, st.st_size+1); if (read(sock, buffer, st.st_size) == 0) { delete[] buffer; buffer = NULL; } } close(sock); return buffer; } if (!get_ips(true)) return NULL; for (int i=0 ; m_ips[i] ; i++) { sock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0); if (sock < 0) continue; if (m_ips[i]->sa_family == AF_INET && !connect(sock, m_ips[i], sizeof(struct sockaddr_in))) break; else if (m_ips[i]->sa_family == AF_INET6 && !connect(sock, m_ips[i], sizeof(struct sockaddr_in6))) break; closesocket(sock); sock = -1; } if (sock < 0) return NULL; request  = ""GET "" + (m_path.size() > 0 ? m_path : ""/"") + m_query + "" HTTP/1.1\r\n""; request += ""Host: "" + m_host + ""\r\n""; request += ""Accept: "" + string(PAC_MIME_TYPE) + ""\r\n""; request += ""Connection: close\r\n""; request += ""\r\n""; if ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) { closesocket(sock); return NULL; } string line = recvline(sock); if (sscanf(line.c_str(), ""HTTP/1.%*d %lu"", &status) == 1 && status == 200) { content_length = 0; for (line = recvline(sock) ; line != ""\r"" && line != """" ; line = recvline(sock)) { if (line.find(""Content-Transfer-Encoding: chunked"") == 0 || line.find(""Transfer-Encoding: chunked"") == 0) chunked = true; else if (content_length == 0) sscanf(line.c_str(), ""Content-Length: %lu"", &content_length); } unsigned int recvd = 0; buffer = new char[PAC_MAX_SIZE]; memset(buffer, 0, PAC_MAX_SIZE); do { unsigned int chunk_length; if (chunked) { if (recvd > 0) recvline(sock); if (sscanf(recvline(sock).c_str(), ""%x"", &chunk_length) != 1 || chunk_length == 0) break; content_length += chunk_length; } if (content_length >= PAC_MAX_SIZE) break; while (content_length == 0 || recvd != content_length) { int r = recv(sock, buffer + recvd, content_length == 0 ? PAC_HTTP_BLOCK_SIZE : content_length - recvd, 0); if (r <= 0) { chunked = false; break; } recvd += r; } } while (chunked); if (content_length != 0 && string(buffer).size() != content_length) { delete[] buffer; buffer = NULL; } } shutdown(sock, SHUT_RDWR); closesocket(sock); return buffer; }"
"static FILE *RK_File(const char *agent, int *agent_id) { int i = 0; char rk_buf[OS_SIZE_1024 + 1]; while (rk_agent_ips[i] != NULL) { if (strcmp(rk_agent_ips[i], agent) == 0) { fseek(rk_agent_fps[i], 0, SEEK_SET); *agent_id = i; return (rk_agent_fps[i]); } i++; } rk_agent_ips[i] = strdup(agent); if (rk_agent_ips[i] != NULL) { snprintf(rk_buf, OS_SIZE_1024, ""%s/%s"", ROOTCHECK_DIR, agent); rk_agent_fps[i] = fopen(rk_buf, ""r+""); if (!rk_agent_fps[i]) { rk_agent_fps[i] = fopen(rk_buf, ""w""); if (rk_agent_fps[i]) { fclose(rk_agent_fps[i]); rk_agent_fps[i] = fopen(rk_buf, ""r+""); } } if (!rk_agent_fps[i]) { merror(FOPEN_ERROR, ARGV0, rk_buf, errno, strerror(errno)); free(rk_agent_ips[i]); rk_agent_ips[i] = NULL; return (NULL); } fseek(rk_agent_fps[i], 0, SEEK_SET); *agent_id = i; return (rk_agent_fps[i]); } else { merror(MEM_ERROR, ARGV0, errno, strerror(errno)); return (NULL); } return (NULL); }"
"GF_EXPORT GF_M2TS_Mux_Stream *gf_m2ts_program_stream_add(GF_M2TS_Mux_Program *program, struct __elementary_stream_ifce *ifce, u32 pid, Bool is_pcr, Bool force_pes) { GF_M2TS_Mux_Stream *stream, *st; stream = gf_m2ts_stream_new(pid); stream->ifce = ifce; stream->pid = pid; stream->program = program; if (is_pcr) program->pcr = stream; stream->loop_descriptors = gf_list_new(); stream->set_initial_disc = program->initial_disc_set; if (program->streams) { if (is_pcr) { stream->next = program->streams; program->streams = stream; } else { st = program->streams; while (st->next) st = st->next; st->next = stream; } } else { program->streams = stream; } if (program->pmt) program->pmt->table_needs_update = GF_TRUE; stream->bit_rate = ifce->bit_rate; stream->scheduling_priority = 1; stream->force_single_au = (stream->program->mux->au_pes_mode == GF_M2TS_PACK_ALL) ? GF_FALSE : GF_TRUE; switch (ifce->stream_type) { case GF_STREAM_VISUAL: stream->mpeg2_stream_id = 0xE0; stream->prevent_two_au_start_in_pes = GF_TRUE; switch (ifce->object_type_indication) { case GPAC_OTI_VIDEO_MPEG4_PART2: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG4; break; case GPAC_OTI_VIDEO_AVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_H264; stream->min_bytes_copy_from_next = 11; break; case GPAC_OTI_VIDEO_SVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_SVC; stream->min_bytes_copy_from_next = 11; gf_m2ts_stream_add_hierarchy_descriptor(stream); break; case GPAC_OTI_VIDEO_HEVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_HEVC; if (ifce->depends_on_stream) { GF_M2TS_Mux_Stream *base_st; stream->mpeg2_stream_type = GF_M2TS_VIDEO_HEVC_TEMPORAL; gf_m2ts_stream_add_hierarchy_descriptor(stream); stream->force_single_au = GF_TRUE; base_st = gf_m2ts_find_stream(program, 0, ifce->depends_on_stream); if (base_st) base_st->force_single_au = GF_TRUE; } stream->min_bytes_copy_from_next = 12; break; case GPAC_OTI_VIDEO_LHVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_SHVC; stream->min_bytes_copy_from_next = 12; gf_m2ts_stream_add_hierarchy_descriptor(stream); stream->force_single_au = GF_TRUE; break; case GPAC_OTI_VIDEO_MPEG1: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG1; break; case GPAC_OTI_VIDEO_MPEG2_SIMPLE: case GPAC_OTI_VIDEO_MPEG2_MAIN: case GPAC_OTI_VIDEO_MPEG2_SNR: case GPAC_OTI_VIDEO_MPEG2_SPATIAL: case GPAC_OTI_VIDEO_MPEG2_HIGH: case GPAC_OTI_VIDEO_MPEG2_422: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG2; break; case GPAC_OTI_IMAGE_JPEG: case GPAC_OTI_IMAGE_PNG: stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; stream->mpeg2_stream_id = 0xFA; gf_m2ts_stream_set_default_slconfig(stream); break; default: break; } break; case GF_STREAM_AUDIO: stream->force_single_au = (stream->program->mux->au_pes_mode == GF_M2TS_PACK_NONE) ? GF_TRUE : GF_FALSE; switch (ifce->object_type_indication) { case GPAC_OTI_AUDIO_MPEG1: stream->mpeg2_stream_type = GF_M2TS_AUDIO_MPEG1; break; case GPAC_OTI_AUDIO_MPEG2_PART3: stream->mpeg2_stream_type = GF_M2TS_AUDIO_MPEG2; break; case GPAC_OTI_AUDIO_AAC_MPEG4: case GPAC_OTI_AUDIO_AAC_MPEG2_MP: case GPAC_OTI_AUDIO_AAC_MPEG2_LCP: case GPAC_OTI_AUDIO_AAC_MPEG2_SSRP: stream->mpeg2_stream_type = GF_M2TS_AUDIO_LATM_AAC; stream->mpeg2_stream_type = GF_M2TS_AUDIO_AAC; if (!ifce->repeat_rate) ifce->repeat_rate = 500; break; case GPAC_OTI_AUDIO_AC3: stream->mpeg2_stream_type = GF_M2TS_AUDIO_AC3; break; } stream->mpeg2_stream_id = 0xC0; break; case GF_STREAM_OD: stream->scheduling_priority = 20; stream->mpeg2_stream_id = 0xFA; stream->table_id = GF_M2TS_TABLE_ID_MPEG4_OD; gf_m2ts_stream_set_default_slconfig(stream); if (force_pes) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; } else { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_SECTIONS; } break; case GF_STREAM_SCENE: stream->mpeg2_stream_id = 0xFA; stream->table_id = GF_M2TS_TABLE_ID_MPEG4_BIFS; gf_m2ts_stream_set_default_slconfig(stream); if (force_pes) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; } else { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_SECTIONS; } break; case GF_STREAM_TEXT: stream->mpeg2_stream_id = 0xBD; stream->mpeg2_stream_type = GF_M2TS_METADATA_PES; gf_m2ts_stream_add_metadata_pointer_descriptor(stream->program); gf_m2ts_stream_add_metadata_descriptor(stream); } if (! (ifce->caps & GF_ESI_STREAM_WITHOUT_MPEG4_SYSTEMS)) { if (program->mpeg4_signaling==GF_M2TS_MPEG4_SIGNALING_FULL) { if (stream->mpeg2_stream_type != GF_M2TS_SYSTEMS_MPEG4_SECTIONS) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; stream->mpeg2_stream_id = 0xFA; gf_m2ts_stream_set_default_slconfig(stream); } } } stream->ifce->output_ctrl = gf_m2ts_output_ctrl; stream->ifce->output_udta = stream; stream->mx = gf_mx_new(""M2TS PID""); if (ifce->timescale != 90000) { stream->ts_scale.num = 90000; stream->ts_scale.den = ifce->timescale; } return stream; }"
"CallResult<HermesValue> hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) { GCScopeMarkerRAII marker{runtime}; Handle<Callable> fn = args.dyncastArg<Callable>(0); if (LLVM_UNLIKELY(!fn)) { return runtime->raiseTypeErrorForValue( args.getArgHandle(0), "" is not a function""); } Handle<JSArray> argArray = args.dyncastArg<JSArray>(1); if (LLVM_UNLIKELY(!argArray)) { return runtime->raiseTypeError(""args must be an array""); } uint32_t len = JSArray::getLength(*argArray); bool isConstructor = args.getArgCount() == 2; MutableHandle<> thisVal{runtime}; if (isConstructor) { auto thisValRes = Callable::createThisForConstruct(fn, runtime); if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) { return ExecutionStatus::EXCEPTION; } thisVal = *thisValRes; } else { thisVal = args.getArg(2); } ScopedNativeCallFrame newFrame{ runtime, len, *fn, isConstructor, thisVal.getHermesValue()}; for (uint32_t i = 0; i < len; ++i) { newFrame->getArgRef(i) = argArray->at(runtime, i); } return isConstructor ? Callable::construct(fn, runtime, thisVal) : Callable::call(fn, runtime); }"
"void JsonApiJob::start() { addRawHeader(""OCS-APIREQUEST"", ""true""); auto query = _additionalParams; query.addQueryItem(QLatin1String(""format""), QLatin1String(""json"")); QUrl url = Utility::concatUrlPath(account()->url(), path(), query); const auto httpVerb = verbToString(); if (!_body.isEmpty()) { sendRequest(httpVerb, url, _request, _body); } else { sendRequest(httpVerb, url, _request); } AbstractNetworkJob::start(); }"
"PJ_DEF(pj_status_t) pjsip_auth_create_aka_response(  pj_pool_t *pool, const pjsip_digest_challenge *chal, const pjsip_cred_info *cred, const pj_str_t *method, pjsip_digest_credential *auth) { pj_str_t nonce_bin; int aka_version; const pj_str_t pjsip_AKAv1_MD5 = { ""AKAv1-MD5"", 9 }; const pj_str_t pjsip_AKAv2_MD5 = { ""AKAv2-MD5"", 9 }; pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac; pj_uint8_t k[PJSIP_AKA_KLEN]; pj_uint8_t op[PJSIP_AKA_OPLEN]; pj_uint8_t amf[PJSIP_AKA_AMFLEN]; pj_uint8_t res[PJSIP_AKA_RESLEN]; pj_uint8_t ck[PJSIP_AKA_CKLEN]; pj_uint8_t ik[PJSIP_AKA_IKLEN]; pj_uint8_t ak[PJSIP_AKA_AKLEN]; pj_uint8_t sqn[PJSIP_AKA_SQNLEN]; pj_uint8_t xmac[PJSIP_AKA_MACLEN]; pjsip_cred_info aka_cred; int i, len; pj_status_t status; if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, ""md5"") == 0) { pjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc, &auth->cnonce, &auth->qop, &auth->uri, &auth->realm, cred, method); return PJ_SUCCESS; } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) { aka_version = 1; } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) { aka_version = 2; } else { return PJSIP_EINVALIDALGORITHM; } nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen); nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1); status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len); nonce_bin.slen = len; if (status != PJ_SUCCESS) return PJSIP_EAUTHINNONCE; if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN) return PJSIP_EAUTHINNONCE; chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0); chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN); chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN +  PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN); pj_bzero(k, sizeof(k)); pj_bzero(op, sizeof(op)); pj_bzero(amf, sizeof(amf)); if (cred->ext.aka.k.slen) pj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen); if (cred->ext.aka.op.slen) pj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen); if (cred->ext.aka.amf.slen) pj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen); f2345(k, chal_rand, res, ck, ik, ak, op); for (i=0; i<PJSIP_AKA_SQNLEN; ++i) sqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]); f1(k, chal_rand, sqn, amf, xmac, op); if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) { return PJSIP_EAUTHINNONCE; } pj_memcpy(&aka_cred, cred, sizeof(aka_cred)); aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD; if (aka_version == 1) { aka_cred.data.ptr = (char*)res; aka_cred.data.slen = PJSIP_AKA_RESLEN; pjsip_auth_create_digest(&auth->response, &chal->nonce,  &auth->nc, &auth->cnonce, &auth->qop,  &auth->uri, &chal->realm, &aka_cred, method); } else if (aka_version == 2) { pj_str_t resikck; const pj_str_t AKAv2_Passwd = { ""http-digest-akav2-password"", 26 }; pj_uint8_t hmac_digest[16]; char tmp_buf[48]; int hmac64_len; resikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN; pj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf)); resikck.ptr = tmp_buf; pj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN); pj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN); pj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN, ck, PJSIP_AKA_CKLEN); pj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen, (const pj_uint8_t*)resikck.ptr, resikck.slen, hmac_digest); aka_cred.data.slen = hmac64_len = PJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest)); pj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf)); aka_cred.data.ptr = tmp_buf; pj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest), aka_cred.data.ptr, &len); aka_cred.data.slen = hmac64_len; pjsip_auth_create_digest(&auth->response, &chal->nonce,  &auth->nc, &auth->cnonce, &auth->qop,  &auth->uri, &chal->realm, &aka_cred, method); } else { pj_assert(!""Bug!""); return PJ_EBUG; } return PJ_SUCCESS; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& input = ctx->input(0); const float input_min_float = ctx->input(1).flat<float>()(0); const float input_max_float = ctx->input(2).flat<float>()(0); Tensor* output_min = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min)); Tensor* output_max = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max)); qint32 used_min_quantized; qint32 used_max_quantized; CalculateUsedRange(input, &used_min_quantized, &used_max_quantized); const float used_min_float = std::min( 0.0f, QuantizedToFloat(used_min_quantized, input_min_float, input_max_float)); const float used_max_float = QuantizedToFloat(used_max_quantized, input_min_float, input_max_float); output_min->flat<float>().setConstant(used_min_float); output_max->flat<float>().setConstant(used_max_float); }"
"int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = NULL; rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); int rc = 0; int fx = -1; int fc = rpmfilesFC(files); int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firstlinkfile = -1; char *tid = NULL; struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata)); struct filedata_s *firstlink = NULL; struct diriter_s di = { -1 }; rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); fi = rpmfilesIter(files, RPMFI_ITER_FWD); while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (rpmfiFFlags(fi) & RPMFILE_GHOST) fp->action = FA_SKIP; else fp->action = rpmfsGetAction(fs, fx); fp->skip = XFA_SKIPPING(fp->action); if (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi))) fp->suffix = tid; fp->fpath = fsmFsPath(fi, fp->suffix); rc = rpmfiStat(fi, 1, &fp->sb); fp->setmeta = (fp->skip == 0) && (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH); setFileState(fs, fx); fsmDebug(fp->fpath, fp->action, &fp->sb); fp->stage = FILE_PRE; } fi = rpmfiFree(fi); if (rc) goto exit; fi = fsmIter(payload, files, payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di); if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (fp->skip && firstlink && rpmfiArchiveHasContent(fi)) fp = firstlink; if (!fp->skip) { int fd = -1; if (!fp->suffix && fp != firstlink) { rc = fsmBackup(di.dirfd, fi, fp->action); } if (!rc) { rc = ensureDir(plugins, rpmfiDN(fi), 0, (fp->action == FA_CREATE), 0, &di.dirfd); } rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath, fp->sb.st_mode, fp->action); if (rc) goto setmeta;  if (!fp->suffix) { if (fp->action == FA_TOUCH) { struct stat sb; rc = fsmStat(di.dirfd, fp->fpath, 1, &sb); } else { rc = fsmVerify(di.dirfd, fp->fpath, fi); } } else { rc = RPMERR_ENOENT; } if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) { rpmlog(RPMLOG_DEBUG, ""file %s vanished unexpectedly\n"", fp->fpath); fp->action = FA_CREATE; fsmDebug(fp->fpath, fp->action, &fp->sb); } if (fp->action == FA_TOUCH) goto setmeta; if (S_ISREG(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest, &firstlink, &firstlinkfile, &fd); } } else if (S_ISDIR(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = fp->sb.st_mode; mode &= ~07777; mode |=  00700; rc = fsmMkdir(di.dirfd, fp->fpath, mode); } } else if (S_ISLNK(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath); } } else if (S_ISFIFO(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(di.dirfd, fp->fpath, 0000); } } else if (S_ISCHR(fp->sb.st_mode) || S_ISBLK(fp->sb.st_mode) || S_ISSOCK(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev); } } else { if (!IS_DEV_LOG(fp->fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } setmeta: if (!rc && fp->setmeta) { rc = fsmSetmeta(fd, di.dirfd, fp->fpath, fi, plugins, fp->action, &fp->sb, nofcaps); } if (fd != firstlinkfile) fsmClose(&fd); } if (rc) *failedFile = xstrdup(fp->fpath); else rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); fp->stage = FILE_UNPACK; } fi = fsmIterFini(fi, &di); if (!rc && fx < 0 && fx != RPMERR_ITER_END) rc = fx; fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di); while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (!fp->skip) { if (!rc) rc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd); if (!rc && fp->suffix) rc = fsmBackup(di.dirfd, fi, fp->action); if (!rc) rc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix); if (!rc) fp->stage = FILE_COMMIT; else *failedFile = xstrdup(fp->fpath); rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath, fp->sb.st_mode, fp->action, rc); } } fi = fsmIterFini(fi, &di); if (rc) { fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di); while ((fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd)) continue; if (fp->stage > FILE_NONE && !fp->skip) { (void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode); } } } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: fi = fsmIterFini(fi, &di); Fclose(payload); free(tid); for (int i = 0; i < fc; i++) free(fdata[i].fpath); free(fdata); return rc; }"
"static float vips_mask_point( VipsPoint *point, int x, int y ) { VipsMask *mask = VIPS_MASK( point );  VipsMaskClass *class = VIPS_MASK_GET_CLASS( point );  int half_width = point->width / 2; int half_height = point->height / 2; double result; if( !mask->optical ) { x = (x + half_width) % point->width; y = (y + half_height) % point->height; } x = x - half_width; y = y - half_height; if( !mask->nodc &&  x == 0 && y == 0 ) result = 1.0; else { double dx, dy; dx = (double) x / half_width; dy = (double) y / half_height; result = class->point( mask, dx, dy ); if( mask->reject ) result = 1.0 - result; } return( result );  }"
"void goto_tabpage_tp( tabpage_T*tp, inttrigger_enter_autocmds, inttrigger_leave_autocmds) { set_keep_msg(NULL, 0); if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer, trigger_leave_autocmds) == OK) { if (valid_tabpage(tp)) enter_tabpage(tp, curbuf, trigger_enter_autocmds, trigger_leave_autocmds); else enter_tabpage(curtab, curbuf, trigger_enter_autocmds, trigger_leave_autocmds); } }"
"static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) { int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj); if (len <= 0) return JSI_OK; Jsi_RC rc = JSI_OK; int clen = jsi_SizeOfArray(interp, nobj); for (i = 0; i < len && rc == JSI_OK; i++) { Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i); if (t && depth>0 && Jsi_ValueIsArray(interp, t)) rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1); else if (!Jsi_ValueIsUndef(interp, t)) Jsi_ObjArrayAdd(interp, nobj, t); if ((++n + clen)>interp->maxArrayList) return Jsi_LogError(""array size exceeded""); } return rc; }"
"PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr, pjsip_transport_type_e type, const pj_sockaddr_t *remote, int addr_len, const pjsip_tpselector *sel, pjsip_tx_data *tdata, pjsip_transport **tp) { pjsip_tpfactory *factory; pj_status_t status; TRACE_((THIS_FILE,""Acquiring transport type=%s, sel=%s remote=%s:%d"", pjsip_transport_get_type_name(type), print_tpsel_info(sel), addr_string(remote), pj_sockaddr_get_port(remote))); pj_lock_acquire(mgr->lock); if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport)  { pjsip_transport *seltp = sel->u.transport; if (seltp->key.type != type) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""Transport type in tpsel not matched"")); return PJSIP_ETPNOTSUITABLE; } if (seltp->is_destroying) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE,""Transport to be acquired is being destroyed"")); return PJ_ENOTFOUND; } pjsip_transport_add_ref(seltp); pj_lock_release(mgr->lock); *tp = seltp; TRACE_((THIS_FILE, ""Transport %s acquired"", seltp->obj_name)); return PJ_SUCCESS; } else { pjsip_transport_key key; int key_len; pjsip_transport *tp_ref = NULL; transport *tp_entry = NULL; if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { if (sel->u.listener->type != type) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""Listener type in tpsel not matched"")); return PJSIP_ETPNOTSUITABLE; } } if (!sel || sel->disable_connection_reuse == PJ_FALSE) { pj_bzero(&key, sizeof(key)); key_len = sizeof(key.type) + addr_len; key.type = type; pj_memcpy(&key.rem_addr, remote, addr_len); tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { transport *tp_iter = tp_entry; do { if (!tp_iter->tp->is_shutdown && !tp_iter->tp->is_destroying) { if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { if (tp_iter->tp->factory == sel->u.listener) { tp_ref = tp_iter->tp; break; } } else { tp_ref = tp_iter->tp; break; } } tp_iter = tp_iter->next; } while (tp_iter != tp_entry); } } if (tp_ref == NULL && (!sel || sel->disable_connection_reuse == PJ_FALSE)) { unsigned flag = pjsip_transport_get_flag_from_type(type); const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote; if (type == PJSIP_TRANSPORT_LOOP || type == PJSIP_TRANSPORT_LOOP_DGRAM) { pj_sockaddr *addr = &key.rem_addr; pj_bzero(addr, addr_len); key_len = sizeof(key.type) + addr_len; tp_entry = (transport *) pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { tp_ref = tp_entry->tp; } } else if (flag & PJSIP_TRANSPORT_DATAGRAM) { pj_sockaddr *addr = &key.rem_addr; pj_bzero(addr, addr_len); addr->addr.sa_family = remote_addr->addr.sa_family; key_len = sizeof(key.type) + addr_len; tp_entry = (transport *) pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { tp_ref = tp_entry->tp; } } } else if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener && tp_ref->factory != sel->u.listener) { tp_ref = NULL; TRACE_((THIS_FILE, ""Transport found but from different listener"")); } if (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) { pjsip_transport_add_ref(tp_ref); pj_lock_release(mgr->lock); *tp = tp_ref; TRACE_((THIS_FILE, ""Transport %s acquired"", tp_ref->obj_name)); return PJ_SUCCESS; } if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { factory = sel->u.listener; if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) { pj_lock_release(mgr->lock); PJ_LOG(3,(THIS_FILE, ""Specified factory for creating "" ""transport is not found"")); return PJ_ENOTFOUND; } } else { factory = mgr->factory_list.next; while (factory != &mgr->factory_list) { if (factory->type == type) break; factory = factory->next; } if (factory == &mgr->factory_list) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""No suitable factory was found either"")); return PJSIP_EUNSUPTRANSPORT; } } } TRACE_((THIS_FILE, ""Creating new transport from factory"")); if (factory->create_transport2) { status = factory->create_transport2(factory, mgr, mgr->endpt, (const pj_sockaddr*) remote, addr_len, tdata, tp); } else { status = factory->create_transport(factory, mgr, mgr->endpt, (const pj_sockaddr*) remote, addr_len, tp); } if (status == PJ_SUCCESS) { PJ_ASSERT_ON_FAIL(tp!=NULL, {pj_lock_release(mgr->lock); return PJ_EBUG;}); pjsip_transport_add_ref(*tp); (*tp)->factory = factory; }"
"Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) { if (t.shape() == TensorShape({})) { if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) || (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) { *out = PartialTensorShape(); return OkStatus(); } return errors::InvalidArgument( ""The only valid scalar shape tensor is the fully unknown shape "" ""specified as -1.""); } if (t.dtype() == DT_INT32) { return PartialTensorShape::MakePartialShape(t.vec<int32>().data(), t.NumElements(), out); } else if (t.dtype() == DT_INT64) { return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(), t.NumElements(), out); } return errors::InvalidArgument( ""Expected an int32 or int64 shape tensor; found "", DataTypeString(t.dtype())); }"
"Value GetValueOrCreatePlaceholder(StringRef full_name) { StringRef node_name; StringRef output_name = """"; bool is_control_dep = full_name[0] == '^'; int output_num = 0; if (is_control_dep) full_name = full_name.drop_front(); { size_t colon_sep = full_name.find_first_of(':'); if (colon_sep == StringRef::npos) { node_name = full_name; } else { node_name = full_name.take_front(colon_sep); output_name = full_name.drop_front(colon_sep + 1); } colon_sep = output_name.find_last_of(':'); if (colon_sep != StringRef::npos) { unsigned long long value; if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1), 10, value)) output_num = value; output_name = output_name.take_front(colon_sep); } } llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name]; SmallVector<Value, 1>& base_operation = op_info[""^""]; if (base_operation.empty()) { OperationState state(loc_, mlir_placeholder_); state.addAttribute(TFGraphDialect::getNameAttrKey(), builder_.getStringAttr(node_name)); state.types.push_back(placeholder_ty_); state.types.push_back(control_ty_); Operation* placeholder = builder_.create(state); base_operation.push_back(placeholder->getResult(1)); base_operation.push_back(placeholder->getResult(0)); } if (is_control_dep) return base_operation[0]; SmallVector<Value, 1>& value_info = op_info[output_name]; if (value_info.size() <= output_num) value_info.resize(output_num + 1, Value{}); if (!value_info[output_num]) { value_info[output_num] = builder_.create<GetResultOp>( loc_, base_operation[1], output_name, output_num); } return value_info[output_num]; }"
"static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12) { unsigned long exit_qualification; unsigned int port; int size; if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS)) return nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING); exit_qualification = vmcs_readl(EXIT_QUALIFICATION); port = exit_qualification >> 16; size = (exit_qualification & 7) + 1; return nested_vmx_check_io_bitmaps(vcpu, port, size); }"
"NAN_METHOD(DetectCharacterEncoding) { Nan::HandleScope scope; v8::Local<v8::Object> inputBuffer = info[0]->ToObject(); UCharsetDetector *charsetDetector; const UCharsetMatch *charsetMatch; UErrorCode errorCode = U_ZERO_ERROR; charsetDetector = ucsdet_open(&errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to open ICU charset detector.""); return; } ucsdet_setText( charsetDetector, node::Buffer::Data(inputBuffer), node::Buffer::Length(inputBuffer), &errorCode ); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to set ICU charset detector’s text.""); return; } charsetMatch = ucsdet_detect(charsetDetector, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to detect charset.""); return; } const char *charsetName = ucsdet_getName(charsetMatch, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to get name from charset match.""); return; } int32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to get confidence from charset match.""); return; } v8::Local<v8::Object> obj = Nan::New<v8::Object>(); obj->Set(Nan::New<v8::String>(""encoding"").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked()); obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence)); info.GetReturnValue().Set(obj); }"
"static int image_load_bmp(image_t *img, FILE    *fp, int     gray, int     load_data) { intinfo_size, depth, compression, colors_used, x, y, color, count, temp, align; ucharbit, byte; uchar*ptr; ucharcolormap[256][4]; getc(fp); getc(fp); read_dword(fp); read_word(fp); read_word(fp); read_dword(fp); info_size        = (int)read_dword(fp); img->width       = read_long(fp); img->height      = read_long(fp); read_word(fp); depth            = read_word(fp); compression      = (int)read_dword(fp); read_dword(fp); read_long(fp); read_long(fp); colors_used      = (int)read_dword(fp); read_dword(fp); if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0) return (-1); if (info_size > 40) { for (info_size -= 40; info_size > 0; info_size --) getc(fp); } if (colors_used == 0 && depth <= 8) colors_used = 1 << depth; else if (colors_used < 0 || colors_used > 256) return (-1); fread(colormap, (size_t)colors_used, 4, fp); img->depth = gray ? 1 : 3; if (depth <= 8 && Encryption) img->use ++; if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); if (gray && depth <= 8) { for (color = colors_used - 1; color >= 0; color --) colormap[color][0] = (colormap[color][2] * 31 + colormap[color][1] * 61 + colormap[color][0] * 8) / 100; } color = 0; count = 0; align = 0; byte  = 0; temp  = 0; for (y = img->height - 1; y >= 0; y --) { ptr = img->pixels + y * img->width * img->depth; switch (depth) { case 1 :  for (x = img->width, bit = 128; x > 0; x --) { if (bit == 128) byte = (uchar)getc(fp); if (byte & bit) { if (!gray) { *ptr++ = colormap[1][2]; *ptr++ = colormap[1][1]; } *ptr++ = colormap[1][0]; } else { if (!gray) { *ptr++ = colormap[0][2]; *ptr++ = colormap[0][1]; } *ptr++ = colormap[0][0]; } if (bit > 1) bit >>= 1; else bit = 128; } for (temp = (img->width + 7) / 8; temp & 3; temp ++) getc(fp); break; case 4 :  for (x = img->width, bit = 0xf0; x > 0; x --) { if (compression != BI_RLE4 && count == 0) { count = 2; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = ((4 - (count & 3)) / 2) & 1; } } else color = getc(fp); } count --; if (bit == 0xf0) { if (color < 0) temp = getc(fp) & 255; else temp = color; if (!gray) { *ptr++ = colormap[temp >> 4][2]; *ptr++ = colormap[temp >> 4][1]; } *ptr++ = colormap[temp >> 4][0]; bit    = 0x0f; } else { if (!gray) { *ptr++ = colormap[temp & 15][2]; *ptr++ = colormap[temp & 15][1]; } *ptr++ = colormap[temp & 15][0]; bit    = 0xf0; } } break; case 8 :  for (x = img->width; x > 0; x --) { if (compression != BI_RLE8) { count = 1; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = (2 - (count & 1)) & 1; } } else color = getc(fp); } if (color < 0) temp = getc(fp) & 255; else temp = color; count --; if (!gray) { *ptr++ = colormap[temp][2]; *ptr++ = colormap[temp][1]; } *ptr++ = colormap[temp][0]; } break; case 24 :  if (gray) { for (x = img->width; x > 0; x --) { temp = getc(fp) * 8; temp += getc(fp) * 61; temp += getc(fp) * 31; *ptr++ = (uchar)(temp / 100); } } else { for (x = img->width; x > 0; x --, ptr += 3) { ptr[2] = (uchar)getc(fp); ptr[1] = (uchar)getc(fp); ptr[0] = (uchar)getc(fp); } } for (temp = img->width * 3; temp & 3; temp ++) getc(fp); break; } } return (0); }"
"LogicalResult matchAndRewriteSortOp(OpTy op, ValueRange xys, uint64_t nx, uint64_t ny, bool isCoo, PatternRewriter &rewriter) { Location loc = op.getLoc(); SmallVector<Value> operands{constantIndex(rewriter, loc, 0), op.getN()}; for (Value v : xys) { auto mtp = getMemRefType(v); if (!mtp.isDynamicDim(0)) { auto newMtp = MemRefType::get({ShapedType::kDynamic}, mtp.getElementType()); v = rewriter.create<memref::CastOp>(loc, newMtp, v); } operands.push_back(v); } auto insertPoint = op->template getParentOfType<func::FuncOp>(); SmallString<32> funcName; FuncGeneratorType funcGenerator; uint32_t nTrailingP = 0; switch (op.getAlgorithm()) { case SparseTensorSortKind::HybridQuickSort: { funcName = kHybridQuickSortFuncNamePrefix; funcGenerator = createQuickSortFunc; nTrailingP = 1; Value pDepthLimit = rewriter.create<memref::AllocaOp>( loc, MemRefType::get({}, rewriter.getI64Type())); operands.push_back(pDepthLimit); Value lo = operands[loIdx]; Value hi = operands[hiIdx]; Value len = rewriter.create<arith::IndexCastOp>( loc, rewriter.getI64Type(), rewriter.create<arith::SubIOp>(loc, hi, lo)); Value depthLimit = rewriter.create<arith::SubIOp>( loc, constantI64(rewriter, loc, 64), rewriter.create<math::CountLeadingZerosOp>(loc, len)); depthLimit = rewriter.create<arith::ShLIOp>(loc, depthLimit, constantI64(rewriter, loc, 1)); rewriter.create<memref::StoreOp>(loc, depthLimit, pDepthLimit); break; } case SparseTensorSortKind::QuickSort: funcName = kQuickSortFuncNamePrefix; funcGenerator = createQuickSortFunc; break; case SparseTensorSortKind::InsertionSortStable: funcName = kSortStableFuncNamePrefix; funcGenerator = createSortStableFunc; break; case SparseTensorSortKind::HeapSort: funcName = kHeapSortFuncNamePrefix; funcGenerator = createHeapSortFunc; break; } FlatSymbolRefAttr func = getMangledSortHelperFunc(rewriter, insertPoint, TypeRange(), funcName, nx, ny, isCoo, operands, funcGenerator, nTrailingP); rewriter.replaceOpWithNewOp<func::CallOp>(op, func, TypeRange(), operands); return success(); }"
"static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int istart = 0, iend, n, nsiz; Jsi_Number nstart; Jsi_Obj *nobj, *obj; Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0), *end = Jsi_ValueArrayIndex(interp, args, 1); if (!start) { goto bail; } obj = _this->d.obj; n = Jsi_ObjGetLength(interp, obj); if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) { istart = (int)nstart; if (istart > n) goto done; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (n == 0) { done: Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY)); return JSI_OK; } Jsi_Number nend; iend = n-1; if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) { iend = (int) nend; if (iend >= n) iend = n; if (iend < 0) iend = (n+iend); if (iend<0) goto bail; } nsiz = iend-istart+1; if (nsiz<=0) goto done; Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { rc = Jsi_LogError(""index too large: %d"", nsiz); goto bail; } int i, m; for (m = 0, i = istart; i <= iend; i++, m++) { if (!obj->arr[i]) continue; nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]); } Jsi_ObjSetLength(interp, nobj, nsiz); Jsi_ValueMakeArrayObject(interp, ret, nobj); return JSI_OK; bail: Jsi_ValueMakeNull(interp, ret); return rc; }"
"static void error_diffuse(unsigned char     *data,       int               pos,         int               depth,       int               error,       int               numerator,   int               denominator ) { int c; data += pos * depth; c = *data + error * numerator / denominator; if (c < 0) { c = 0; } if (c >= 1 << 8) { c = (1 << 8) - 1; } *data = (unsigned char)c; }"
"static GF_Err mp4_input_ctrl(GF_ESInterface *ifce, u32 act_type, void *param) { char af_data[188]; GF_ESIMP4 *priv = (GF_ESIMP4 *)ifce->input_udta; if (!priv) return GF_BAD_PARAM; switch (act_type) { case GF_ESI_INPUT_DATA_FLUSH: { GF_ESIPacket pck; #ifndef GPAC_DISABLE_TTXT GF_List *cues = NULL; #endif if (!priv->sample) priv->sample = gf_isom_get_sample(priv->mp4, priv->track, priv->sample_number+1, NULL); if (!priv->sample) { return GF_IO_ERR; } memset(&pck, 0, sizeof(GF_ESIPacket)); pck.flags = GF_ESI_DATA_AU_START | GF_ESI_DATA_HAS_CTS; if (priv->sample->IsRAP) pck.flags |= GF_ESI_DATA_AU_RAP; pck.cts = priv->sample->DTS + priv->ts_offset; if (priv->is_repeat) pck.flags |= GF_ESI_DATA_REPEAT; if (priv->timeline_id) { Bool deactivate_temi=GF_FALSE; u64 ntp=0; u64 tc = priv->sample->DTS + priv->sample->CTS_Offset + priv->cts_dts_shift; Bool insert_temi=GF_FALSE; if (temi_disable_loop) { tc += priv->ts_offset; } if (temi_offset) { tc += ((u64) temi_offset) * ifce->timescale / 1000; } if (priv->insert_ntp) { u32 sec, frac; gf_net_get_ntp(&sec, &frac); ntp = sec; ntp <<= 32; ntp |= frac; } if (!temi_period) { if (request_temi_toggle && priv->sample->IsRAP) { temi_on = !temi_on; if (!temi_on) { deactivate_temi = GF_TRUE; } fprintf(stderr, ""Turning TEMI %st at DTS ""LLU"" (%g sec)\n"", temi_on ? ""on"" : ""off"" , priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); request_temi_toggle = GF_FALSE; } insert_temi = temi_on; } else { if (!temi_on) { if (priv->sample->IsRAP && ((priv->sample->DTS - temi_period_last_dts) >= temi_period * ifce->timescale)) { temi_on = GF_TRUE; temi_period_last_dts = priv->sample->DTS; fprintf(stderr, ""Turning TEMI on at DTS ""LLU"" (%g sec)\n"", priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); } } else { if (!temi_single_toggle && priv->sample->IsRAP && ((priv->sample->DTS - temi_period_last_dts) >= temi_period * ifce->timescale)) { temi_on = GF_FALSE; temi_period_last_dts = priv->sample->DTS; fprintf(stderr, ""Turning TEMI off at DTS ""LLU"" (%g sec)\n"", priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); deactivate_temi = GF_TRUE; } } insert_temi = temi_on; } if (insert_temi) { pck.mpeg2_af_descriptors_size = format_af_descriptor(af_data, priv->timeline_id - 1, tc, ifce->timescale, ntp, priv->temi_url, &priv->last_temi_url); pck.mpeg2_af_descriptors = af_data; } else if (deactivate_temi) { pck.mpeg2_af_descriptors_size = format_af_descriptor(af_data, priv->timeline_id - 1, 0, 0, 0, """", &priv->last_temi_url); pck.mpeg2_af_descriptors = af_data; } } if (priv->nb_repeat_last) { pck.cts += priv->nb_repeat_last*ifce->timescale * priv->image_repeat_ms / 1000; } pck.dts = pck.cts; if (priv->cts_dts_shift) { pck.cts += + priv->cts_dts_shift; pck.flags |= GF_ESI_DATA_HAS_DTS; } if (priv->sample->CTS_Offset) { pck.cts += priv->sample->CTS_Offset; pck.flags |= GF_ESI_DATA_HAS_DTS; } if (priv->sample->IsRAP && priv->dsi && priv->dsi_size) { pck.data = (char*)priv->dsi; pck.data_len = priv->dsi_size; ifce->output_ctrl(ifce, GF_ESI_OUTPUT_DATA_DISPATCH, &pck); pck.flags &= ~GF_ESI_DATA_AU_START; } pck.flags |= GF_ESI_DATA_AU_END; pck.data = priv->sample->data; pck.data_len = priv->sample->dataLength; pck.duration = gf_isom_get_sample_duration(priv->mp4, priv->track, priv->sample_number+1); #ifndef GPAC_DISABLE_TTXT if (priv->mtype==GF_ISOM_MEDIA_TEXT && priv->mstype==GF_ISOM_SUBTYPE_WVTT) { u64             start; GF_WebVTTCue    *cue; GF_List *gf_webvtt_parse_iso_cues(GF_ISOSample *iso_sample, u64 start); start = (priv->sample->DTS * 1000) / ifce->timescale; cues = gf_webvtt_parse_iso_cues(priv->sample, start); if (gf_list_count(cues)>1) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS Muxer] More than one cue in sample\n"")); } cue = (GF_WebVTTCue *)gf_list_get(cues, 0); if (cue) { pck.data = cue->text; pck.data_len = (u32)strlen(cue->text)+1; } else { pck.data = NULL; pck.data_len = 0; } } #endif ifce->output_ctrl(ifce, GF_ESI_OUTPUT_DATA_DISPATCH, &pck); GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS Muxer] Track %d: sample %d CTS %d\n"", priv->track, priv->sample_number+1, pck.cts)); #ifndef GPAC_DISABLE_VTT if (cues) { while (gf_list_count(cues)) { GF_WebVTTCue *cue = (GF_WebVTTCue *)gf_list_get(cues, 0); gf_list_rem(cues, 0); gf_webvtt_cue_del(cue); } gf_list_del(cues); cues = NULL; } #endif gf_isom_sample_del(&priv->sample); priv->sample_number++; if (!priv->source->real_time && !priv->is_repeat) { priv->source->samples_done++; gf_set_progress(""MPEG-2 TS Muxing"", priv->source->samples_done, priv->source->samples_count); } if (priv->sample_number==priv->sample_count) { if (priv->loop) { Double scale; u64 duration; scale = gf_isom_get_media_timescale(priv->mp4, priv->track); scale /= gf_isom_get_timescale(priv->mp4); duration = (u64) (gf_isom_get_duration(priv->mp4) * scale); priv->ts_offset += duration; priv->sample_number = 0; priv->is_repeat = (priv->sample_count==1) ? GF_TRUE : GF_FALSE; } else if (priv->image_repeat_ms && priv->source->nb_real_streams) { priv->nb_repeat_last++; priv->sample_number--; priv->is_repeat = GF_TRUE; } else { if (!(ifce->caps & GF_ESI_STREAM_IS_OVER)) { ifce->caps |= GF_ESI_STREAM_IS_OVER; if (priv->sample_count>1) { assert(priv->source->nb_real_streams); priv->source->nb_real_streams--; } } } } } return GF_OK; case GF_ESI_INPUT_DESTROY: if (priv->dsi) gf_free(priv->dsi); if (ifce->decoder_config) { gf_free(ifce->decoder_config); ifce->decoder_config = NULL; } gf_free(priv); ifce->input_udta = NULL; return GF_OK; default: return GF_BAD_PARAM; } }"
"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args) { struct cil_args_build *args = extra_args; struct cil_tree_node *ast = args->ast; if (ast->flavor == CIL_ROOT) { return SEPOL_OK; } args->ast = ast->parent; if (ast->flavor == CIL_TUNABLEIF) { args->tunif = NULL; } if (ast->flavor == CIL_IN) { args->in = NULL; } if (ast->flavor == CIL_MACRO) { args->macro = NULL; } if (ast->flavor == CIL_BOOLEANIF) { args->boolif = NULL; } cil_tree_children_destroy(parse_current->parent); return SEPOL_OK; }"
void gf_isom_delete_movie(GF_ISOFile *mov) { if (!mov) return; if (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap); #ifndef GPAC_DISABLE_ISOM_WRITE if (mov->editFileMap) { gf_isom_datamap_del(mov->editFileMap); } if (mov->finalName) gf_free(mov->finalName); #endif gf_isom_box_array_del(mov->TopBoxes); #ifndef GPAC_DISABLE_ISOM_FRAGMENTS gf_isom_box_array_del(mov->moof_list); if (mov->mfra) gf_isom_box_del((GF_Box*)mov->mfra); if (mov->sidx_pts_store) gf_free(mov->sidx_pts_store); if (mov->sidx_pts_next_store) gf_free(mov->sidx_pts_next_store); if (mov->main_sidx) gf_isom_box_del((GF_Box*)mov->main_sidx); if (mov->block_buffer) gf_free(mov->block_buffer); #endif if (mov->last_producer_ref_time) gf_isom_box_del((GF_Box *) mov->last_producer_ref_time); if (mov->fileName) gf_free(mov->fileName); gf_free(mov); }
"void irc_mode_channel_update (struct t_irc_server *server, struct t_irc_channel *channel, char set_flag, char chanmode, const char *argument) { char *pos_args, *str_modes, **argv, *pos, *ptr_arg; char *new_modes, *new_args, str_mode[2], *str_temp; int argc, current_arg, chanmode_found, length; if (!channel->modes) channel->modes = strdup (""+""); if (!channel->modes) return; argc = 0; argv = NULL; pos_args = strchr (channel->modes, ' '); if (pos_args) { str_modes = weechat_strndup (channel->modes, pos_args - channel->modes); if (!str_modes) return; pos_args++; while (pos_args[0] == ' ') pos_args++; argv = weechat_string_split (pos_args, "" "", NULL, WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS, 0, &argc); } else { str_modes = strdup (channel->modes); if (!str_modes) return; } new_modes = malloc (strlen (channel->modes) + 1 + 1); new_args = malloc (((pos_args) ? strlen (pos_args) : 0) + ((argument) ? 1 + strlen (argument) : 0) + 1); if (new_modes && new_args) { new_modes[0] = '\0'; new_args[0] = '\0'; current_arg = 0; chanmode_found = 0; pos = str_modes; while (pos && pos[0]) { if ((pos[0] == '+') || (pos[0] == '-')) { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); } else { ptr_arg = NULL; switch (irc_mode_get_chanmode_type (server, pos[0])) { case 'A':  case 'B':  case 'C':  ptr_arg = (current_arg < argc) ? argv[current_arg] : NULL; break; case 'D':  break; } if (ptr_arg) current_arg++; if (pos[0] == chanmode) { chanmode_found = 1; if (set_flag == '+') { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (argument) { if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, argument); } } } else { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (ptr_arg) { if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, ptr_arg); } } } pos++; } if (!chanmode_found) { if (set_flag == '+') { if (argument) { str_mode[0] = chanmode; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, argument); } else { pos = new_modes; while (pos[0] == '+') pos++; memmove (pos + 1, pos, strlen (pos) + 1); pos[0] = chanmode; } } } if (new_args[0]) { length = strlen (new_modes) + 1 + strlen (new_args) + 1; str_temp = malloc (length); if (str_temp) { snprintf (str_temp, length, ""%s %s"", new_modes, new_args); if (channel->modes) free (channel->modes); channel->modes = str_temp; } } else { if (channel->modes) free (channel->modes); channel->modes = strdup (new_modes); } } if (new_modes) free (new_modes); if (new_args) free (new_args); if (str_modes) free (str_modes); if (argv) weechat_string_free_split (argv); }"
"static void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type) { u32 count, i, coded_type; SVG_Point_Angle *p; SVG_Point *pt; Fixed *f; GF_List *l; Bool handled = GF_FALSE; coded_type = val->type; switch(transform_type) { case SVG_TRANSFORM_TRANSLATE: val->type = SVG_Transform_Translate_datatype; break; case SVG_TRANSFORM_SCALE: if (coded_type==8) handled = GF_TRUE; val->type = SVG_Transform_Scale_datatype; break; case SVG_TRANSFORM_ROTATE: if ((coded_type==8) || (coded_type==1)) handled = GF_TRUE; val->type = SVG_Transform_Rotate_datatype; break; case SVG_TRANSFORM_SKEWX: if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE; val->type = SVG_Transform_SkewX_datatype; break; case SVG_TRANSFORM_SKEWY: if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE; val->type = SVG_Transform_SkewY_datatype; break; case SVG_TRANSFORM_MATRIX: val->type = SVG_Transform_datatype; break; default: GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] unknown datatype for animate transform.\n"")); break; } if (!handled) { while (gf_list_count(val->values)) { SMIL_AnimateValue a_val; a_val.type = 0; a_val.value = gf_list_pop_back(val->values); lsr_delete_anim_value(lsr, &a_val, coded_type); } return; } count = gf_list_count(val->values); if (!count) return; if (transform_type==SVG_TRANSFORM_TRANSLATE) return; for (i=0; i<count; i++) { void *a_val = gf_list_get(val->values, i); switch (transform_type) { case SVG_TRANSFORM_ROTATE: GF_SAFEALLOC(p, SVG_Point_Angle); if (!p) return; if (coded_type==8) { l = (GF_List*)a_val; f = (Fixed*)gf_list_get(l, 0); p->angle = *f; f = (Fixed*)gf_list_get(l, 1); if (f) p->x = *f; f = (Fixed*)gf_list_get(l, 2); if (f) p->y = *f; while (gf_list_count(l)) { f = (Fixed*)gf_list_last(l); gf_list_rem_last(l); gf_free(f); } gf_list_del(l); } else if (coded_type==1) { p->angle = ((SVG_Number *)a_val)->value; gf_free(a_val); } p->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) ); gf_list_rem(val->values, i); gf_list_insert(val->values, p, i); break; case SVG_TRANSFORM_SKEWX: case SVG_TRANSFORM_SKEWY: f = (Fixed*)gf_malloc(sizeof(Fixed)); *f = ((SVG_Number *)a_val)->value; gf_free(a_val); gf_list_rem(val->values, i); gf_list_insert(val->values, f, i); break; case SVG_TRANSFORM_SCALE: pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point)); l = (GF_List*)a_val; f = (Fixed*)gf_list_get(l, 0); if (f) pt->x = *f; f = (Fixed*)gf_list_get(l, 1); if (f) pt->y = *f; else pt->y = pt->x; while (gf_list_count(l)) { f = (Fixed*)gf_list_last(l); gf_list_rem_last(l); gf_free(f); } gf_list_del(l); gf_list_rem(val->values, i); gf_list_insert(val->values, pt, i); break; default: GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[LASeR] unknown transform type %d\n"", transform_type)); break; } } }"
"static void tiffsep_initialize_device_procs(gx_device *dev) { gdev_prn_initialize_device_procs(dev); set_dev_proc(dev, open_device, tiffsep_prn_open); set_dev_proc(dev, close_device, tiffsep_prn_close); set_dev_proc(dev, map_color_rgb, tiffsep_decode_color); set_dev_proc(dev, get_params, tiffsep_get_params); set_dev_proc(dev, put_params, tiffsep_put_params); set_dev_proc(dev, get_color_mapping_procs, tiffsep_get_color_mapping_procs); set_dev_proc(dev, get_color_comp_index, tiffsep_get_color_comp_index); set_dev_proc(dev, encode_color, tiffsep_encode_color); set_dev_proc(dev, decode_color, tiffsep_decode_color); set_dev_proc(dev, update_spot_equivalent_colors, tiffsep_update_spot_equivalent_colors); set_dev_proc(dev, ret_devn_params, tiffsep_ret_devn_params); set_dev_proc(dev, dev_spec_op, tiffsep_spec_op); }"
"void isis_notif_max_area_addr_mismatch(const struct isis_circuit *circuit, uint8_t max_area_addrs, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:max-area-addresses-mismatch""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/max-area-addresses"", xpath); data = yang_data_new_uint8(xpath_arg, max_area_addrs); listnode_add(arguments, data); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_max_area_addr_mismatch, circuit, max_area_addrs, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"static char *clean_path(char *path) { char *ch; char *ch2; char *str; str = xmalloc(strlen(path)); ch = path; ch2 = str; while (true) { *ch2 = *ch; ch++; ch2++; if (!*(ch-1)) break; while (*(ch - 1) == '/' && *ch == '/') ch++; } while ((ch = strrchr(str, '/'))) { if (ch == str) break; if (!*(ch+1)) *ch = 0; else break; } return str; }"
"ssize_t P2PMessageRC2::decode(const byte* buffer, size_t size) { if (size < HEADER_LENGTH) { return dev::network::PACKET_INCOMPLETE; } m_deliveredLength = size; int32_t offset = 0; m_length = ntohl(*((uint32_t*)&buffer[offset])); if (size < m_length) { return dev::network::PACKET_INCOMPLETE; } m_cache->clear(); m_cache->insert(m_cache->end(), buffer, buffer + m_length); offset += sizeof(m_length); m_version = ntohs(*((VERSION_TYPE*)&buffer[offset])); offset += sizeof(m_version); m_protocolID = ntohl(*((PROTOCOL_ID*)&buffer[offset])); offset += sizeof(m_protocolID); m_packetType = ntohs(*((PACKET_TYPE*)&buffer[offset])); offset += sizeof(m_packetType); m_seq = ntohl(*((uint32_t*)&buffer[offset])); if (g_BCOSConfig.compressEnabled() && ((m_version & dev::eth::CompressFlag) == dev::eth::CompressFlag)) { SnappyCompress::uncompress( bytesConstRef((const byte*)(&buffer[HEADER_LENGTH]), m_length - HEADER_LENGTH), *m_buffer); m_version &= (~dev::eth::CompressFlag); } else { m_buffer->assign(&buffer[HEADER_LENGTH], &buffer[HEADER_LENGTH] + m_length - HEADER_LENGTH); } return m_length; }"
"int domain_entry_inc(struct connection *conn, struct node *node) { struct domain *d; unsigned int domid; if (!conn) return 0; domid = node->perms.p ? node->perms.p[0].id : conn->id; if (conn->transaction) { transaction_entry_inc(conn->transaction, domid); } else { d = (domid == conn->id && conn->domain) ? conn->domain : find_or_alloc_existing_domain(domid); if (d) d->nbentry++; else return ENOMEM; } return 0; }"
"void jswrap_spi_send4bit(JsVar *parent, JsVar *srcdata, int bit0, int bit1, Pin nss_pin) { NOT_USED(parent); IOEventFlags device = jsiGetDeviceFromClass(parent); if (!DEVICE_IS_SPI(device)) { jsExceptionHere(JSET_ERROR, ""SPI.send4bit only works on hardware SPI""); return; } jshSPISet16(device, true);  if (bit0==0 && bit1==0) { bit0 = 0x01; bit1 = 0x03; } bit0 = bit0 & 0x0F; bit1 = bit1 & 0x0F; if (!jshIsDeviceInitialised(device)) { JshSPIInfo inf; jshSPIInitInfo(&inf); jshSPISetup(device, &inf); } jshSPISetReceive(device, false); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, false); if (jsvIsNumeric(srcdata)) { jsspiSend4bit(device, (unsigned char)jsvGetInteger(srcdata), bit0, bit1); } else if (jsvIsIterable(srcdata)) { jshInterruptOff(); JsvIterator it; jsvIteratorNew(&it, srcdata, JSIF_EVERY_ARRAY_ELEMENT); while (jsvIteratorHasElement(&it)) { unsigned char in = (unsigned char)jsvIteratorGetIntegerValue(&it); jsspiSend4bit(device, in, bit0, bit1); jsvIteratorNext(&it); } jsvIteratorFree(&it); jshInterruptOn(); } else { jsExceptionHere(JSET_ERROR, ""Variable type %t not suited to transmit operation"", srcdata); } jshSPIWait(device);  if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, true); jshSPISet16(device, false); }"
"static int ssl_verify_cert(struct tunnel *tunnel) { int ret = -1; int cert_valid = 0; unsigned char digest[SHA256LEN]; unsigned int len; struct x509_digest *elem; char digest_str[SHA256STRLEN], *subject, *issuer; char *line; int i; X509_NAME *subj; char common_name[FIELD_SIZE + 1]; SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL); X509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle); if (cert == NULL) { log_error(""Unable to get gateway certificate.\n""); return 1; } subj = X509_get_subject_name(cert); #ifdef HAVE_X509_CHECK_HOST if (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL)) cert_valid = 1; #else if (subj && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name, FIELD_SIZE) > 0 && strncasecmp(common_name, tunnel->config->gateway_host, FIELD_SIZE) == 0) cert_valid = 1; #endif if (cert_valid && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) { log_debug(""Gateway certificate validation succeeded.\n""); ret = 0; goto free_cert; } log_debug(""Gateway certificate validation failed.\n""); if (X509_digest(cert, EVP_sha256(), digest, &len) <= 0 || len != SHA256LEN) { log_error(""Could not compute certificate sha256 digest.\n""); goto free_cert; } for (i = 0; i < SHA256LEN; i++) sprintf(&digest_str[2 * i], ""%02x"", digest[i]); digest_str[SHA256STRLEN - 1] = '\0'; for (elem = tunnel->config->cert_whitelist; elem != NULL; elem = elem->next) if (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0) break; if (elem != NULL) { log_debug(""Gateway certificate digest found in white list.\n""); ret = 0; goto free_cert; } subject = X509_NAME_oneline(subj, NULL, 0); issuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0); log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n""); log_error(""    --trusted-cert %s\n"", digest_str); log_error(""or add this line to your config file:\n""); log_error(""    trusted-cert = %s\n"", digest_str); log_error(""Gateway certificate:\n""); log_error(""    subject:\n""); for (line = strtok(subject, ""/""); line != NULL; line = strtok(NULL, ""/"")) log_error(""        %s\n"", line); log_error(""    issuer:\n""); for (line = strtok(issuer, ""/""); line != NULL; line = strtok(NULL, ""/"")) log_error(""        %s\n"", line); log_error(""    sha256 digest:\n""); log_error(""        %s\n"", digest_str); free_cert: X509_free(cert); return ret; }"
"int handle__publish(struct mosquitto *context) { uint8_t dup; int rc = 0; int rc2; uint8_t header = context->in_packet.command; int res = 0; struct mosquitto_msg_store *msg, *stored = NULL; size_t len; uint16_t slen; char *topic_mount; mosquitto_property *properties = NULL; mosquitto_property *p, *p_prev; mosquitto_property *msg_properties_last; uint32_t message_expiry_interval = 0; int topic_alias = -1; uint8_t reason_code = 0; uint16_t mid = 0; if(context->state != mosq_cs_active){ return MOSQ_ERR_PROTOCOL; } msg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store)); if(msg == NULL){ return MOSQ_ERR_NOMEM; } dup = (header & 0x08)>>3; msg->qos = (header & 0x06)>>1; if(dup == 1 && msg->qos == 0){ log__printf(NULL, MOSQ_LOG_INFO, ""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos == 3){ log__printf(NULL, MOSQ_LOG_INFO, ""Invalid QoS in PUBLISH from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos > context->max_qos){ log__printf(NULL, MOSQ_LOG_INFO, ""Too high QoS in PUBLISH from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_QOS_NOT_SUPPORTED; } msg->retain = (header & 0x01); if(msg->retain && db.config->retain_available == false){ db__msg_store_free(msg); return MOSQ_ERR_RETAIN_NOT_SUPPORTED; } if(packet__read_string(&context->in_packet, &msg->topic, &slen)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(!slen && context->protocol != mosq_p_mqtt5){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos > 0){ if(packet__read_uint16(&context->in_packet, &mid)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(mid == 0){ db__msg_store_free(msg); return MOSQ_ERR_PROTOCOL; } msg->source_mid = mid; } if(context->protocol == mosq_p_mqtt5){ rc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties); if(rc){ db__msg_store_free(msg); return rc; } p = properties; p_prev = NULL; msg->properties = NULL; msg_properties_last = NULL; while(p){ switch(p->identifier){ case MQTT_PROP_CONTENT_TYPE: case MQTT_PROP_CORRELATION_DATA: case MQTT_PROP_PAYLOAD_FORMAT_INDICATOR: case MQTT_PROP_RESPONSE_TOPIC: case MQTT_PROP_USER_PROPERTY: if(msg->properties){ msg_properties_last->next = p; msg_properties_last = p; }else{ msg->properties = p; msg_properties_last = p; } if(p_prev){ p_prev->next = p->next; p = p_prev->next; }else{ properties = p->next; p = properties; } msg_properties_last->next = NULL; break; case MQTT_PROP_TOPIC_ALIAS: topic_alias = p->value.i16; p_prev = p; p = p->next; break; case MQTT_PROP_MESSAGE_EXPIRY_INTERVAL: message_expiry_interval = p->value.i32; p_prev = p; p = p->next; break; case MQTT_PROP_SUBSCRIPTION_IDENTIFIER: p_prev = p; p = p->next; break; default: p = p->next; break; } } } mosquitto_property_free_all(&properties); if(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){ db__msg_store_free(msg); return MOSQ_ERR_TOPIC_ALIAS_INVALID; }else if(topic_alias > 0){ if(msg->topic){ rc = alias__add(context, msg->topic, (uint16_t)topic_alias); if(rc){ db__msg_store_free(msg); return rc; } }else{ rc = alias__find(context, &msg->topic, (uint16_t)topic_alias); if(rc){ db__msg_store_free(msg); return MOSQ_ERR_PROTOCOL; } } } #ifdef WITH_BRIDGE rc = bridge__remap_topic_in(context, &msg->topic); if(rc){ db__msg_store_free(msg); return rc; } #endif if(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } msg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos; G_PUB_BYTES_RECEIVED_INC(msg->payloadlen); if(context->listener && context->listener->mount_point){ len = strlen(context->listener->mount_point) + strlen(msg->topic) + 1; topic_mount = mosquitto__malloc(len+1); if(!topic_mount){ db__msg_store_free(msg); return MOSQ_ERR_NOMEM; } snprintf(topic_mount, len, ""%s%s"", context->listener->mount_point, msg->topic); topic_mount[len] = '\0'; mosquitto__free(msg->topic); msg->topic = topic_mount; } if(msg->payloadlen){ if(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_PACKET_TOO_LARGE; goto process_bad_message; } msg->payload = mosquitto__malloc(msg->payloadlen+1); if(msg->payload == NULL){ db__msg_store_free(msg); return MOSQ_ERR_NOMEM; } ((uint8_t *)msg->payload)[msg->payloadlen] = 0; if(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } } rc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE); if(rc == MOSQ_ERR_ACL_DENIED){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_NOT_AUTHORIZED; goto process_bad_message; }else if(rc != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return rc; } log__printf(NULL, MOSQ_LOG_DEBUG, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); if(!strncmp(msg->topic, ""$CONTROL/"", 9)){ #ifdef WITH_CONTROL rc = control__process(context, msg); db__msg_store_free(msg); return rc; #else reason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC; goto process_bad_message; #endif } { rc = plugin__handle_message(context, msg); if(rc == MOSQ_ERR_ACL_DENIED){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_NOT_AUTHORIZED; goto process_bad_message; }else if(rc != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return rc; } } if(msg->qos > 0){ db__message_store_find(context, msg->source_mid, &stored); } if(stored && msg->source_mid != 0 && (stored->qos != msg->qos || stored->payloadlen != msg->payloadlen || strcmp(stored->topic, msg->topic) || memcmp(stored->payload, msg->payload, msg->payloadlen) )){ log__printf(NULL, MOSQ_LOG_WARNING, ""Reused message ID %u from %s detected. Clearing from storage."", msg->source_mid, context->id); db__message_remove_incoming(context, msg->source_mid); stored = NULL; } if(!stored){ if(msg->qos == 0 || db__ready_for_flight(context, mosq_md_in, msg->qos) || db__ready_for_queue(context, msg->qos, &context->msgs_in)){ dup = 0; rc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client); if(rc) return rc; }else{ reason_code = MQTT_RC_QUOTA_EXCEEDED; goto process_bad_message; } stored = msg; msg = NULL; }else{ db__msg_store_free(msg); msg = NULL; dup = 1; } switch(stored->qos){ case 0: rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored); if(rc2 > 0) rc = 1; break; case 1: util__decrement_receive_quota(context); rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored); if(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){ if(send__puback(context, mid, 0, NULL)) rc = 1; }else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){ if(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1; }else{ rc = rc2; } break; case 2: if(dup == 0){ res = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false); }else{ res = 0; } if(!res){ if(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1; }else if(res == 1){ rc = 1; } break; } db__message_write_queued_in(context); return rc; process_bad_message: rc = 1; if(msg){ switch(msg->qos){ case 0: rc = MOSQ_ERR_SUCCESS; break; case 1: rc = send__puback(context, msg->source_mid, reason_code, NULL); break; case 2: rc = send__pubrec(context, msg->source_mid, reason_code, NULL); break; } db__msg_store_free(msg); } return rc; }"
"static int hostlist_matches_int(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *lhost, const char *shost, const struct member_list *list) { struct member *m; int matched = UNSPEC; debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH); TAILQ_FOREACH_REVERSE(m, list, member_list, entries) { matched = host_matches(parse_tree, pw, lhost, shost, m); if (matched != UNSPEC) break; } debug_return_int(matched); }"
"static char *uncompress(int16_t field_count, char *start, char *end, char *ptr, char *uncompressed, int uncomp_len, char **uncompressed_ptr) { char *uptr = *uncompressed_ptr;  debug(""count %d ptr %p end %p uptr %p"", field_count, ptr, end, uptr); while (field_count-- > 0 && ptr < end) { int dlen; int ulen; int pos; char name[NS_MAXLABEL];  uint16_t dns_type, dns_class; int comp_pos; if (!convert_label(start, end, ptr, name, NS_MAXLABEL, &pos, &comp_pos)) goto out; ulen = strlen(name); strncpy(uptr, name, uncomp_len - (uptr - uncompressed)); debug(""pos %d ulen %d left %d name %s"", pos, ulen, (int)(uncomp_len - (uptr - uncompressed)), uptr); uptr += ulen; *uptr++ = '\0'; ptr += pos; memcpy(uptr, ptr, NS_RRFIXEDSZ); dns_type = uptr[0] << 8 | uptr[1]; dns_class = uptr[2] << 8 | uptr[3]; if (dns_class != ns_c_in) goto out; ptr += NS_RRFIXEDSZ; uptr += NS_RRFIXEDSZ; if (dns_type == ns_t_cname) { if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; uptr[-2] = comp_pos << 8; uptr[-1] = comp_pos & 0xff; uptr += comp_pos; ptr += pos; } else if (dns_type == ns_t_a || dns_type == ns_t_aaaa) { dlen = uptr[-2] << 8 | uptr[-1]; if (ptr + dlen > end) { debug(""data len %d too long"", dlen); goto out; } memcpy(uptr, ptr, dlen); uptr += dlen; ptr += dlen; } else if (dns_type == ns_t_soa) { int total_len = 0; char *len_ptr; if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; total_len += comp_pos; len_ptr = &uptr[-2]; ptr += pos; uptr += comp_pos; if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; total_len += comp_pos; ptr += pos; uptr += comp_pos; memcpy(uptr, ptr, 20); uptr += 20; ptr += 20; total_len += 20; len_ptr[0] = total_len << 8; len_ptr[1] = total_len & 0xff; } *uncompressed_ptr = uptr; } return ptr; out: return NULL; }"
"void irc_server_set_prefix_modes_chars (struct t_irc_server *server, const char *prefix) { char *pos; int i, length_modes, length_chars; if (!server || !prefix) return; if (server->prefix_modes) { free (server->prefix_modes); server->prefix_modes = NULL; } if (server->prefix_chars) { free (server->prefix_chars); server->prefix_chars = NULL; } pos = strchr (prefix, ')'); if (pos) { server->prefix_modes = weechat_strndup (prefix + 1, pos - prefix - 1); if (server->prefix_modes) { pos++; length_modes = strlen (server->prefix_modes); length_chars = strlen (pos); server->prefix_chars = malloc (length_modes + 1); if (server->prefix_chars) { for (i = 0; i < length_modes; i++) { server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' '; } server->prefix_chars[length_modes] = '\0'; } else { free (server->prefix_modes); server->prefix_modes = NULL; } } } }"
"static gboolean imapx_connect_to_server (CamelIMAPXServer *is, GCancellable *cancellable, GError **error) { CamelNetworkSettings *network_settings; CamelNetworkSecurityMethod method; CamelIMAPXStore *store; CamelSettings *settings; GIOStream *connection = NULL; GIOStream *tls_stream; GSocket *socket; guint len; guchar *token; gint tok; CamelIMAPXCommand *ic; gchar *shell_command = NULL; gboolean use_shell_command; gboolean success = TRUE; gchar *host; store = camel_imapx_server_ref_store (is); settings = camel_service_ref_settings (CAMEL_SERVICE (store)); network_settings = CAMEL_NETWORK_SETTINGS (settings); host = camel_network_settings_dup_host (network_settings); method = camel_network_settings_get_security_method (network_settings); use_shell_command = camel_imapx_settings_get_use_shell_command ( CAMEL_IMAPX_SETTINGS (settings)); if (use_shell_command) shell_command = camel_imapx_settings_dup_shell_command ( CAMEL_IMAPX_SETTINGS (settings)); g_object_unref (settings); if (shell_command != NULL) { success = connect_to_server_process (is, shell_command, error); g_free (shell_command); if (success) goto connected; else goto exit; } connection = camel_network_service_connect_sync ( CAMEL_NETWORK_SERVICE (store), cancellable, error); if (connection != NULL) { GInputStream *input_stream; GOutputStream *output_stream; GError *local_error = NULL; socket = g_socket_connection_get_socket ( G_SOCKET_CONNECTION (connection)); g_socket_set_option ( socket, IPPROTO_TCP, TCP_NODELAY, 1, &local_error); if (local_error != NULL) { g_warning (""%s: %s"", G_STRFUNC, local_error->message); g_clear_error (&local_error); } g_mutex_lock (&is->priv->stream_lock); g_warn_if_fail (is->priv->connection == NULL); is->priv->connection = g_object_ref (connection); g_mutex_unlock (&is->priv->stream_lock); input_stream = g_io_stream_get_input_stream (connection); output_stream = g_io_stream_get_output_stream (connection); imapx_server_set_streams (is, input_stream, output_stream); } else { success = FALSE; goto exit; } connected: while (1) { GInputStream *input_stream; input_stream = camel_imapx_server_ref_input_stream (is); token = NULL; tok = camel_imapx_input_stream_token ( CAMEL_IMAPX_INPUT_STREAM (input_stream), &token, &len, cancellable, error); if (tok < 0) { success = FALSE; } else if (tok == '*') { success = imapx_untagged ( is, input_stream, cancellable, error); if (success) { g_object_unref (input_stream); break; } } else { camel_imapx_input_stream_ungettoken ( CAMEL_IMAPX_INPUT_STREAM (input_stream), tok, token, len); success = camel_imapx_input_stream_text ( CAMEL_IMAPX_INPUT_STREAM (input_stream), &token, cancellable, error); g_free (token); } g_object_unref (input_stream); if (!success) goto exit; } g_mutex_lock (&is->priv->stream_lock); if (!is->priv->cinfo) { g_mutex_unlock (&is->priv->stream_lock); ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, ""CAPABILITY""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to get capabilities""), cancellable, error); camel_imapx_command_unref (ic); if (!success) goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } if (method == CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) { g_mutex_lock (&is->priv->stream_lock); if (CAMEL_IMAPX_LACK_CAPABILITY (is->priv->cinfo, STARTTLS)) { g_mutex_unlock (&is->priv->stream_lock); g_set_error ( error, CAMEL_ERROR, CAMEL_ERROR_GENERIC, _(""Failed to connect to IMAP server %s in secure mode: %s""), host, _(""STARTTLS not supported"")); success = FALSE; goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_STARTTLS, ""STARTTLS""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to issue STARTTLS""), cancellable, error); if (success) { g_mutex_lock (&is->priv->stream_lock); imapx_free_capability (is->priv->cinfo); is->priv->cinfo = NULL; if (ic->status->condition == IMAPX_CAPABILITY) { is->priv->cinfo = ic->status->u.cinfo; ic->status->u.cinfo = NULL; c (is->priv->tagprefix, ""got capability flags %08x\n"", is->priv->cinfo ? is->priv->cinfo->capa : 0xFFFFFFFF); imapx_server_stash_command_arguments (is); } g_mutex_unlock (&is->priv->stream_lock); } camel_imapx_command_unref (ic); if (!success) goto exit; tls_stream = camel_network_service_starttls ( CAMEL_NETWORK_SERVICE (store), connection, error); if (tls_stream != NULL) { GInputStream *input_stream; GOutputStream *output_stream; g_mutex_lock (&is->priv->stream_lock); g_object_unref (is->priv->connection); is->priv->connection = g_object_ref (tls_stream); g_mutex_unlock (&is->priv->stream_lock); input_stream = g_io_stream_get_input_stream (tls_stream); output_stream = g_io_stream_get_output_stream (tls_stream); imapx_server_set_streams ( is, input_stream, output_stream); g_object_unref (tls_stream); } else { g_prefix_error ( error, _(""Failed to connect to IMAP server %s in secure mode: ""), host); success = FALSE; goto exit; } g_mutex_lock (&is->priv->stream_lock); if (is->priv->cinfo == NULL) { g_mutex_unlock (&is->priv->stream_lock); ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, ""CAPABILITY""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to get capabilities""), cancellable, error); camel_imapx_command_unref (ic); if (!success) goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } } exit: if (!success) { g_mutex_lock (&is->priv->stream_lock); g_clear_object (&is->priv->input_stream); g_clear_object (&is->priv->output_stream); g_clear_object (&is->priv->connection); g_clear_object (&is->priv->subprocess); if (is->priv->cinfo != NULL) { imapx_free_capability (is->priv->cinfo); is->priv->cinfo = NULL; } g_mutex_unlock (&is->priv->stream_lock); } g_free (host); g_clear_object (&connection); g_clear_object (&store); return success; }"
"static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx) { uint16_t mss; if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0) return; t->mss_ok = 1; mss = short_from(opt + *idx); *idx += (uint32_t)sizeof(uint16_t); if (t->mss > short_be(mss)) t->mss = short_be(mss); }"
"void Compile(XlaOpKernelContext* ctx) override { int64_t output_size; xla::XlaOp output_size_param = ctx->Input(""size""); StatusOr<xla::Shape> output_shape_or = ctx->builder()->GetShape(output_size_param); OP_REQUIRES_OK(ctx, output_shape_or.status()); auto output_shape_param = output_shape_or.ValueOrDie(); auto output_rank = output_shape_param.rank(); OP_REQUIRES(ctx, output_rank == 0, errors::InvalidArgument(""Shape must be rank 0 but is rank "", output_rank)); OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size)); OP_REQUIRES(ctx, output_size >= 0, errors::InvalidArgument(""size ("", output_size, "") must be non-negative"")); xla::XlaOp idx, updates, output; xla::XlaOp input = ctx->Input(0); auto input_xla_type = ctx->input_xla_type(0); xla::PrimitiveType dtype = ctx->InputXlaType(""weights""); auto zero = xla::Zero(ctx->builder(), dtype); auto one = xla::One(ctx->builder(), dtype); StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input); OP_REQUIRES_OK(ctx, input_shape_or.status()); auto input_shape = input_shape_or.ValueOrDie(); auto size = input_shape.dimensions(0); if (!size) { output = xla::Broadcast(zero, {output_size}); ctx->SetOutput(0, output); return; } auto rank = input_shape.rank(); OP_REQUIRES(ctx, rank <= 2, errors::InvalidArgument( ""Shape must be at most rank 2 but is rank "", rank)); xla::XlaOp weights = ctx->Input(2); StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights); OP_REQUIRES_OK(ctx, weights_shape_or.status()); auto weights_shape = weights_shape_or.ValueOrDie(); auto weights_size = weights_shape.dimensions(0); bool has_weights = false; if (weights_size) { has_weights = true; } xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size}); xla::ScatterDimensionNumbers scatter_dnums; scatter_dnums.set_index_vector_dim(1); scatter_dnums.add_inserted_window_dims(0); scatter_dnums.add_scatter_dims_to_operand_dims(0); if (rank == 2) { output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size}); scatter_dnums.add_inserted_window_dims(1); scatter_dnums.add_scatter_dims_to_operand_dims(1); auto i_shape = xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()}); auto i = xla::Iota(ctx->builder(), i_shape, 0); i = xla::Reshape( i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1}); auto j = xla::Reshape( input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1}); std::vector<xla::XlaOp> iotas_to_concat; iotas_to_concat.push_back(i); iotas_to_concat.push_back(j); idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1); updates = xla::Broadcast( one, {input_shape.dimensions(0) * input_shape.dimensions(1)}); output = xla::Broadcast( zero, {output_shape.dimensions(0), output_shape.dimensions(1)}); if (has_weights && !binary_output_) { weights = xla::Reshape( weights, {input_shape.dimensions(0) * input_shape.dimensions(1)}); updates = weights; } } else { input = xla::Reshape(input, {size, 1}); idx = xla::Reshape(input, {size, 1}); updates = xla::Broadcast(one, {size}); output = xla::Broadcast(zero, {output_size}); if (has_weights && !binary_output_) { updates = weights; } } xla::XlaComputation assn_computation = [&] { std::unique_ptr<xla::XlaBuilder> subb = ctx->builder()->CreateSubBuilder(""scatter_bincount""); xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {}); auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0""); auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1""); if (!binary_output_) { xla::Add(p0, p1); } return subb->BuildAndNoteError(); }(); output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums, false, false); ctx->SetOutput(0, output); }"
"static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_Obj *obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) { Jsi_ValueMakeNumber(interp, ret, 0); return JSI_OK; } obj = _this->d.obj; int argc = Jsi_ValueGetLength(interp, args); int curlen = jsi_SizeOfArray(interp, obj);     int i; for (i = 0; i < argc; ++i) { Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i); if (!ov) { Jsi_LogBug(""Arguments Error""); ov = Jsi_ValueNew(interp); } Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0); } Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj)); return JSI_OK; }"
"static int bpf_map_do_batch(const union bpf_attr *attr, union bpf_attr __user *uattr, int cmd) { struct bpf_map *map; int err, ufd; struct fd f; if (CHECK_ATTR(BPF_MAP_BATCH)) return -EINVAL; ufd = attr->batch.map_fd; f = fdget(ufd); map = __bpf_map_get(f); if (IS_ERR(map)) return PTR_ERR(map); if ((cmd == BPF_MAP_LOOKUP_BATCH || cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) { err = -EPERM; goto err_put; } if (cmd != BPF_MAP_LOOKUP_BATCH && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) { err = -EPERM; goto err_put; } if (cmd == BPF_MAP_LOOKUP_BATCH) BPF_DO_BATCH(map->ops->map_lookup_batch); else if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) BPF_DO_BATCH(map->ops->map_lookup_and_delete_batch); else if (cmd == BPF_MAP_UPDATE_BATCH) BPF_DO_BATCH(map->ops->map_update_batch); else BPF_DO_BATCH(map->ops->map_delete_batch); err_put: fdput(f); return err; }"
"INLINE LOCAL(void) h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf) { my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample; register int y, cred, cgreen, cblue; int cb, cr; register JSAMPROW outptr0, outptr1; JSAMPROW inptr00, inptr01, inptr1, inptr2; JDIMENSION col; register JSAMPLE *range_limit = cinfo->sample_range_limit; int *Crrtab = upsample->Cr_r_tab; int *Cbbtab = upsample->Cb_b_tab; JLONG *Crgtab = upsample->Cr_g_tab; JLONG *Cbgtab = upsample->Cb_g_tab; unsigned int r, g, b; JLONG rgb; SHIFT_TEMPS inptr00 = input_buf[0][in_row_group_ctr * 2]; inptr01 = input_buf[0][in_row_group_ctr * 2 + 1]; inptr1 = input_buf[1][in_row_group_ctr]; inptr2 = input_buf[2][in_row_group_ctr]; outptr0 = output_buf[0]; outptr1 = output_buf[1]; for (col = cinfo->output_width >> 1; col > 0; col--) { cb = GETJSAMPLE(*inptr1++); cr = GETJSAMPLE(*inptr2++); cred = Crrtab[cr]; cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS); cblue = Cbbtab[cb]; y  = GETJSAMPLE(*inptr00++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); y  = GETJSAMPLE(*inptr00++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b)); WRITE_TWO_PIXELS(outptr0, rgb); outptr0 += 4; y  = GETJSAMPLE(*inptr01++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); y  = GETJSAMPLE(*inptr01++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b)); WRITE_TWO_PIXELS(outptr1, rgb); outptr1 += 4; } if (cinfo->output_width & 1) { cb = GETJSAMPLE(*inptr1); cr = GETJSAMPLE(*inptr2); cred = Crrtab[cr]; cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS); cblue = Cbbtab[cb]; y  = GETJSAMPLE(*inptr00); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); *(INT16 *)outptr0 = (INT16)rgb; y  = GETJSAMPLE(*inptr01); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); *(INT16 *)outptr1 = (INT16)rgb; } }"
"static int get_info(struct net *net, void __user *user, const int *len) { char name[XT_TABLE_MAXNAMELEN]; struct xt_table *t; int ret; if (*len != sizeof(struct ipt_getinfo)) return -EINVAL; if (copy_from_user(name, user, sizeof(name)) != 0) return -EFAULT; name[XT_TABLE_MAXNAMELEN-1] = '\0'; #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_lock(AF_INET); #endif t = xt_request_find_table_lock(net, AF_INET, name); if (!IS_ERR(t)) { struct ipt_getinfo info; const struct xt_table_info *private = t->private; #ifdef CONFIG_COMPAT struct xt_table_info tmp; if (in_compat_syscall()) { ret = compat_table_info(private, &tmp); xt_compat_flush_offsets(AF_INET); private = &tmp; } #endif memset(&info, 0, sizeof(info)); info.valid_hooks = t->valid_hooks; memcpy(info.hook_entry, private->hook_entry, sizeof(info.hook_entry)); memcpy(info.underflow, private->underflow, sizeof(info.underflow)); info.num_entries = private->number; info.size = private->size; strcpy(info.name, name); if (copy_to_user(user, &info, *len) != 0) ret = -EFAULT; else ret = 0; xt_table_unlock(t); module_put(t->me); } else ret = PTR_ERR(t); #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_unlock(AF_INET); #endif return ret; }"
"int is_manager_apk(char *path) { return check_v2_signature(path, ksu_expected_size, ksu_expected_hash); }"
"static int ins_compl_add( char_u*str, intlen, char_u*fname, char_u**cptext,        typval_T*user_data UNUSED,      intcdir, intflags_arg, intadup){ compl_T*match; intdir = (cdir == 0 ? compl_direction : cdir); intflags = flags_arg; if (flags & CP_FAST) fast_breakcheck(); else ui_breakcheck(); if (got_int) return FAIL; if (len < 0) len = (int)STRLEN(str); if (compl_first_match != NULL && !adup) { match = compl_first_match; do { if (!match_at_original_text(match) && STRNCMP(match->cp_str, str, len) == 0 && match->cp_str[len] == NUL) return NOTDONE; match = match->cp_next; } while (match != NULL && !is_first_match(match)); } ins_compl_del_pum(); match = ALLOC_CLEAR_ONE(compl_T); if (match == NULL) return FAIL; match->cp_number = -1; if (flags & CP_ORIGINAL_TEXT) match->cp_number = 0; if ((match->cp_str = vim_strnsave(str, len)) == NULL) { vim_free(match); return FAIL; } if (fname != NULL && compl_curr_match != NULL && compl_curr_match->cp_fname != NULL && STRCMP(fname, compl_curr_match->cp_fname) == 0) match->cp_fname = compl_curr_match->cp_fname; else if (fname != NULL) { match->cp_fname = vim_strsave(fname); flags |= CP_FREE_FNAME; } else match->cp_fname = NULL; match->cp_flags = flags; if (cptext != NULL) { int i; for (i = 0; i < CPT_COUNT; ++i) if (cptext[i] != NULL && *cptext[i] != NUL) match->cp_text[i] = vim_strsave(cptext[i]); } #ifdef FEAT_EVAL if (user_data != NULL) match->cp_user_data = *user_data; #endif if (compl_first_match == NULL) match->cp_next = match->cp_prev = NULL; else if (dir == FORWARD) { match->cp_next = compl_curr_match->cp_next; match->cp_prev = compl_curr_match; } else    { match->cp_next = compl_curr_match; match->cp_prev = compl_curr_match->cp_prev; } if (match->cp_next) match->cp_next->cp_prev = match; if (match->cp_prev) match->cp_prev->cp_next = match; elsecompl_first_match = match; compl_curr_match = match; if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0) ins_compl_longest_match(match); return OK; }"
"void evtchn_free(struct domain *d, struct evtchn *chn) { evtchn_port_clear_pending(d, chn); chn->state          = ECS_FREE; chn->notify_vcpu_id = 0; chn->xen_consumer   = 0; xsm_evtchn_close_post(chn); }"
"static void virtio_gpio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts) { struct virtio_gpio *gpio; int i; DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n"")); virtio_gpio_is_active = false; gpio = (struct virtio_gpio *)dev->arg; if (gpio) { pthread_mutex_destroy(&gpio->mtx); gpio_irq_deinit(gpio); for (i = 0; i < gpio->nchip; i++) native_gpio_close_chip(&gpio->chips[i]); free(gpio); dev->arg = NULL; } }"
"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) { options->addOption(""--server.harden"", ""lock down REST APIs that reveal version information or server "" ""internals for non-admin users"", new BooleanParameter(&_hardenedRestApi)) .setIntroducedIn(30500); options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"", new BooleanParameter(&_enableFoxxApi), arangodb::options::makeFlags( arangodb::options::Flags::DefaultNoComponents, arangodb::options::Flags::OnCoordinator, arangodb::options::Flags::OnSingle)) .setIntroducedIn(30500); options->addOption(""--foxx.store"", ""enables Foxx store in web interface"", new BooleanParameter(&_enableFoxxStore), arangodb::options::makeFlags( arangodb::options::Flags::DefaultNoComponents, arangodb::options::Flags::OnCoordinator, arangodb::options::Flags::OnSingle)) .setIntroducedIn(30500); }"
"static void zep_print_ts(netdissect_options *ndo, const u_char *p) { int32_t i; uint32_t uf; uint32_t f; float ff; i = GET_BE_U_4(p); uf = GET_BE_U_4(p + 4); ff = (float) uf; if (ff < 0.0)            ff += FMAXINT; ff = (float) (ff / FMAXINT);  f = (uint32_t) (ff * 1000000000.0);   ND_PRINT(""%u.%09d"", i, f); if (i) { time_t seconds = i - JAN_1970; struct tm *tm; char time_buf[128]; tm = localtime(&seconds); strftime(time_buf, sizeof (time_buf), ""%Y/%m/%d %H:%M:%S"", tm); ND_PRINT("" (%s)"", time_buf); } }"
"static struct inode *ntfs_read_mft(struct inode *inode, const struct cpu_str *name, const struct MFT_REF *ref) { int err = 0; struct ntfs_inode *ni = ntfs_i(inode); struct super_block *sb = inode->i_sb; struct ntfs_sb_info *sbi = sb->s_fs_info; mode_t mode = 0; struct ATTR_STD_INFO5 *std5 = NULL; struct ATTR_LIST_ENTRY *le; struct ATTRIB *attr; bool is_match = false; bool is_root = false; bool is_dir; unsigned long ino = inode->i_ino; u32 rp_fa = 0, asize, t32; u16 roff, rsize, names = 0; const struct ATTR_FILE_NAME *fname = NULL; const struct INDEX_ROOT *root; struct REPARSE_DATA_BUFFER rp; u64 t64; struct MFT_REC *rec; struct runs_tree *run; inode->i_op = NULL; inode->i_uid = sbi->options->fs_uid; inode->i_gid = sbi->options->fs_gid; err = mi_init(&ni->mi, sbi, ino); if (err) goto out; if (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) { t64 = sbi->mft.lbo >> sbi->cluster_bits; t32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size); sbi->mft.ni = ni; init_rwsem(&ni->file.run_lock); if (!run_add_entry(&ni->file.run, 0, t64, t32, true)) { err = -ENOMEM; goto out; } } err = mi_read(&ni->mi, ino == MFT_REC_MFT); if (err) goto out; rec = ni->mi.mrec; if (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) { ; } else if (ref->seq != rec->seq) { err = -EINVAL; ntfs_err(sb, ""MFT: r=%lx, expect seq=%x instead of %x!"", ino, le16_to_cpu(ref->seq), le16_to_cpu(rec->seq)); goto out; } else if (!is_rec_inuse(rec)) { err = -EINVAL; ntfs_err(sb, ""Inode r=%x is not in use!"", (u32)ino); goto out; } if (le32_to_cpu(rec->total) != sbi->record_size) { err = -EINVAL; goto out; } if (!is_rec_base(rec)) goto Ok; is_dir = rec->flags & RECORD_FLAG_DIR; inode->i_generation = le16_to_cpu(rec->seq); le = NULL; attr = NULL; next_attr: run = NULL; err = -EINVAL; attr = ni_enum_attr_ex(ni, attr, &le, NULL); if (!attr) goto end_enum; if (le && le->vcn) { if (ino != MFT_REC_MFT || attr->type != ATTR_DATA) goto next_attr; run = &ni->file.run; asize = le32_to_cpu(attr->size); goto attr_unpack_run; } roff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off); rsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size); asize = le32_to_cpu(attr->size); if (le16_to_cpu(attr->name_off) + attr->name_len > asize) goto out; switch (attr->type) { case ATTR_STD: if (attr->non_res || asize < sizeof(struct ATTR_STD_INFO) + roff || rsize < sizeof(struct ATTR_STD_INFO)) goto out; if (std5) goto next_attr; std5 = Add2Ptr(attr, roff); #ifdef STATX_BTIME nt2kernel(std5->cr_time, &ni->i_crtime); #endif nt2kernel(std5->a_time, &inode->i_atime); nt2kernel(std5->c_time, &inode->i_ctime); nt2kernel(std5->m_time, &inode->i_mtime); ni->std_fa = std5->fa; if (asize >= sizeof(struct ATTR_STD_INFO5) + roff && rsize >= sizeof(struct ATTR_STD_INFO5)) ni->std_security_id = std5->security_id; goto next_attr; case ATTR_LIST: if (attr->name_len || le || ino == MFT_REC_LOG) goto out; err = ntfs_load_attr_list(ni, attr); if (err) goto out; le = NULL; attr = NULL; goto next_attr; case ATTR_NAME: if (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff || rsize < SIZEOF_ATTRIBUTE_FILENAME) goto out; fname = Add2Ptr(attr, roff); if (fname->type == FILE_NAME_DOS) goto next_attr; names += 1; if (name && name->len == fname->name_len && !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len, NULL, false)) is_match = true; goto next_attr; case ATTR_DATA: if (is_dir) { goto next_attr; } if (ino == MFT_REC_BADCLUST && !attr->non_res) goto next_attr; if (attr->name_len && ((ino != MFT_REC_BADCLUST || !attr->non_res || attr->name_len != ARRAY_SIZE(BAD_NAME) || memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) && (ino != MFT_REC_SECURE || !attr->non_res || attr->name_len != ARRAY_SIZE(SDS_NAME) || memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) { goto next_attr; } if (is_attr_sparsed(attr)) ni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE; else ni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE; if (is_attr_compressed(attr)) ni->std_fa |= FILE_ATTRIBUTE_COMPRESSED; else ni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED; if (is_attr_encrypted(attr)) ni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED; else ni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED; if (!attr->non_res) { ni->i_valid = inode->i_size = rsize; inode_set_bytes(inode, rsize); } mode = S_IFREG | (0777 & sbi->options->fs_fmask_inv); if (!attr->non_res) { ni->ni_flags |= NI_FLAG_RESIDENT; goto next_attr; } inode_set_bytes(inode, attr_ondisk_size(attr)); ni->i_valid = le64_to_cpu(attr->nres.valid_size); inode->i_size = le64_to_cpu(attr->nres.data_size); if (!attr->nres.alloc_size) goto next_attr; run = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run : &ni->file.run; break; case ATTR_ROOT: if (attr->non_res) goto out; root = Add2Ptr(attr, roff); is_root = true; if (attr->name_len != ARRAY_SIZE(I30_NAME) || memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME))) goto next_attr; if (root->type != ATTR_NAME || root->rule != NTFS_COLLATION_TYPE_FILENAME) goto out; if (!is_dir) goto next_attr; ni->ni_flags |= NI_FLAG_DIR; err = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30); if (err) goto out; mode = sb->s_root ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv)) : (S_IFDIR | 0777); goto next_attr; case ATTR_ALLOC: if (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) || memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME))) goto next_attr; inode->i_size = le64_to_cpu(attr->nres.data_size); ni->i_valid = le64_to_cpu(attr->nres.valid_size); inode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size)); run = &ni->dir.alloc_run; break; case ATTR_BITMAP: if (ino == MFT_REC_MFT) { if (!attr->non_res) goto out; #ifndef CONFIG_NTFS3_64BIT_CLUSTER if (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000) goto out; #endif run = &sbi->mft.bitmap.run; break; } else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) && !memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)) && attr->non_res) { run = &ni->dir.bitmap_run; break; } goto next_attr; case ATTR_REPARSE: if (attr->name_len) goto next_attr; rp_fa = ni_parse_reparse(ni, attr, &rp); switch (rp_fa) { case REPARSE_LINK: inode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer .PrintNameLength) / sizeof(u16); ni->i_valid = inode->i_size; if (ni->ni_flags & NI_FLAG_DIR) { indx_clear(&ni->dir); memset(&ni->dir, 0, sizeof(ni->dir)); ni->ni_flags &= ~NI_FLAG_DIR; } else { run_close(&ni->file.run); } mode = S_IFLNK | 0777; is_dir = false; if (attr->non_res) { run = &ni->file.run; goto attr_unpack_run; } break; case REPARSE_COMPRESSED: break; case REPARSE_DEDUPLICATED: break; } goto next_attr; case ATTR_EA_INFO: if (!attr->name_len && resident_data_ex(attr, sizeof(struct EA_INFO))) { ni->ni_flags |= NI_FLAG_EA; inode->i_mode = mode; ntfs_get_wsl_perm(inode); mode = inode->i_mode; } goto next_attr; default: goto next_attr; } attr_unpack_run: roff = le16_to_cpu(attr->nres.run_off); if (roff > asize) { err = -EINVAL; goto out; } t64 = le64_to_cpu(attr->nres.svcn); err = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn), t64, Add2Ptr(attr, roff), asize - roff); if (err < 0) goto out; err = 0; goto next_attr; end_enum: if (!std5) goto out; if (!is_match && name) { err = -ENOENT; goto out; } if (std5->fa & FILE_ATTRIBUTE_READONLY) mode &= ~0222; if (!names) { err = -EINVAL; goto out; } if (names != le16_to_cpu(rec->hard_links)) { rec->hard_links = cpu_to_le16(names); ni->mi.dirty = true; } set_nlink(inode, names); if (S_ISDIR(mode)) { ni->std_fa |= FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_dir_inode_operations; inode->i_fop = &ntfs_dir_operations; ni->i_valid = 0; } else if (S_ISLNK(mode)) { ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_link_inode_operations; inode->i_fop = NULL; inode_nohighmem(inode); } else if (S_ISREG(mode)) { ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_file_inode_operations; inode->i_fop = &ntfs_file_operations; inode->i_mapping->a_ops = is_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops; if (ino != MFT_REC_MFT) init_rwsem(&ni->file.run_lock); } else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) { inode->i_op = &ntfs_special_inode_operations; init_special_inode(inode, mode, inode->i_rdev); } else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) && fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) { inode->i_op = &ntfs_file_inode_operations; } else { err = -EINVAL; goto out; } if ((sbi->options->sys_immutable && (std5->fa & FILE_ATTRIBUTE_SYSTEM)) && !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) { inode->i_flags |= S_IMMUTABLE; } else { inode->i_flags &= ~S_IMMUTABLE; } inode->i_mode = mode; if (!(ni->ni_flags & NI_FLAG_EA)) { inode->i_flags |= S_NOSEC; } Ok: if (ino == MFT_REC_MFT && !sb->s_root) sbi->mft.ni = NULL; unlock_new_inode(inode); return inode; out: if (ino == MFT_REC_MFT && !sb->s_root) sbi->mft.ni = NULL; iget_failed(inode); return ERR_PTR(err); }"
"static inline int _write_trylock(rwlock_t *lock) { u32 cnts; preempt_disable(); cnts = atomic_read(&lock->cnts); if ( unlikely(cnts) || unlikely(atomic_cmpxchg(&lock->cnts, 0, _write_lock_val()) != 0) ) { preempt_enable(); return 0; } return 1; }"
"static int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot, uint *blk, int depth) { char *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS); int ret = 0; uint newblk; __le32 *ref = (__le32 *)buf; if (!buf) return -ENOMEM; ret = read_blk(info, *blk, buf); if (ret < 0) { quota_error(dquot->dq_sb, ""Can't read quota data block %u"", *blk); goto out_buf; } newblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]); if (depth == info->dqi_qtree_depth - 1) { ret = free_dqentry(info, dquot, newblk); newblk = 0; } else { ret = remove_tree(info, dquot, &newblk, depth+1); } if (ret >= 0 && !newblk) { int i; ref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0); for (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++) ; if (i == (info->dqi_usable_bs >> 2) && *blk != QT_TREEOFF) { put_free_dqblk(info, buf, *blk); *blk = 0; } else { ret = write_blk(info, *blk, buf); if (ret < 0) quota_error(dquot->dq_sb, ""Can't write quota tree block %u"", *blk); } } out_buf: kfree(buf); return ret; }"
"static void file_asynch_write (struct rw *rw, struct command *command, nbd_completion_callback cb) { int dummy = 0; file_synch_write (rw, slice_ptr (command->slice), command->slice.len, command->offset); if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { squashfs_dir_header_2 dirh; char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; long long start; int bytes; int dir_count, size; struct dir_ent *new_dir; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n""); dir->dir_count = 0; dir->cur_entry = 0; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 0) return dir; start = sBlk.s.directory_table_start + (*i)->start; bytes = lookup_entry(directory_table_hash, start); if(bytes == -1) EXIT_UNSQUASH(""squashfs_opendir: directory block %d not "" ""found!\n"", block_start); bytes += (*i)->offset; size = (*i)->data + bytes; while(bytes < size) { if(swap) { squashfs_dir_header_2 sdirh; memcpy(&sdirh, directory_table + bytes, sizeof(sdirh)); SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); } else memcpy(&dirh, directory_table + bytes, sizeof(dirh)); dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { if(swap) { squashfs_dir_entry_2 sdire; memcpy(&sdire, directory_table + bytes, sizeof(sdire)); SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); } else memcpy(dire, directory_table + bytes, sizeof(*dire)); bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } memcpy(dire->name, directory_table + bytes, dire->size + 1); dire->name[dire->size + 1] = '\0'; TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); if((dir->dir_count % DIR_ENT_SIZE) == 0) { new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent)); if(new_dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: "" ""realloc failed!\n""); dir->dirs = new_dir; } strcpy(dir->dirs[dir->dir_count].name, dire->name); dir->dirs[dir->dir_count].start_block = dirh.start_block; dir->dirs[dir->dir_count].offset = dire->offset; dir->dirs[dir->dir_count].type = dire->type; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: free(dir->dirs); free(dir); return NULL; }"
"static int stex_queuecommand_lck(struct scsi_cmnd *cmd) { void (*done)(struct scsi_cmnd *) = scsi_done; struct st_hba *hba; struct Scsi_Host *host; unsigned int id, lun; struct req_msg *req; u16 tag; host = cmd->device->host; id = cmd->device->id; lun = cmd->device->lun; hba = (struct st_hba *) &host->hostdata[0]; if (hba->mu_status == MU_STATE_NOCONNECT) { cmd->result = DID_NO_CONNECT; done(cmd); return 0; } if (unlikely(hba->mu_status != MU_STATE_STARTED)) return SCSI_MLQUEUE_HOST_BUSY; switch (cmd->cmnd[0]) { case MODE_SENSE_10: { static char ms10_caching_page[12] = { 0, 0x12, 0, 0, 0, 0, 0, 0, 0x8, 0xa, 0x4, 0 }; unsigned char page; page = cmd->cmnd[2] & 0x3f; if (page == 0x8 || page == 0x3f) { scsi_sg_copy_from_buffer(cmd, ms10_caching_page, sizeof(ms10_caching_page)); cmd->result = DID_OK << 16; done(cmd); } else stex_invalid_field(cmd, done); return 0; } case REPORT_LUNS: if (hba->cardtype == st_shasta || id == host->max_id - 1) { stex_invalid_field(cmd, done); return 0; } break; case TEST_UNIT_READY: if (id == host->max_id - 1) { cmd->result = DID_OK << 16; done(cmd); return 0; } break; case INQUIRY: if (lun >= host->max_lun) { cmd->result = DID_NO_CONNECT << 16; done(cmd); return 0; } if (id != host->max_id - 1) break; if (!lun && !cmd->device->channel && (cmd->cmnd[1] & INQUIRY_EVPD) == 0) { scsi_sg_copy_from_buffer(cmd, (void *)console_inq_page, sizeof(console_inq_page)); cmd->result = DID_OK << 16; done(cmd); } else stex_invalid_field(cmd, done); return 0; case PASSTHRU_CMD: if (cmd->cmnd[1] == PASSTHRU_GET_DRVVER) { struct st_drvver ver; size_t cp_len = sizeof(ver); ver.major = ST_VER_MAJOR; ver.minor = ST_VER_MINOR; ver.oem = ST_OEM; ver.build = ST_BUILD_VER; ver.signature[0] = PASSTHRU_SIGNATURE; ver.console_id = host->max_id - 1; ver.host_no = hba->host->host_no; cp_len = scsi_sg_copy_from_buffer(cmd, &ver, cp_len); if (sizeof(ver) == cp_len) cmd->result = DID_OK << 16; else cmd->result = DID_ERROR << 16; done(cmd); return 0; } break; default: break; } tag = scsi_cmd_to_rq(cmd)->tag; if (unlikely(tag >= host->can_queue)) return SCSI_MLQUEUE_HOST_BUSY; req = hba->alloc_rq(hba); req->lun = lun; req->target = id; memcpy(req->cdb, cmd->cmnd, STEX_CDB_LENGTH); if (cmd->sc_data_direction == DMA_FROM_DEVICE) req->data_dir = MSG_DATA_DIR_IN; else if (cmd->sc_data_direction == DMA_TO_DEVICE) req->data_dir = MSG_DATA_DIR_OUT; else req->data_dir = MSG_DATA_DIR_ND; hba->ccb[tag].cmd = cmd; hba->ccb[tag].sense_bufflen = SCSI_SENSE_BUFFERSIZE; hba->ccb[tag].sense_buffer = cmd->sense_buffer; if (!hba->map_sg(hba, req, &hba->ccb[tag])) { hba->ccb[tag].sg_count = 0; memset(&req->variable[0], 0, 8); } hba->send(hba, req, tag); return 0; }"
"void PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp) { if (dt_table[Elf64_Dyn::DT_NULL]) { return;      } Elf64_Dyn const *const dynp0 = dynp; unsigned ndx = 1+ 0; if (dynp) for (; ; ++ndx, ++dynp) { upx_uint64_t const d_tag = get_te64(&dynp->d_tag); if (d_tag>>32) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad Elf64_Dyn[%d].d_tag %#lx"", -1+ ndx, (long unsigned)d_tag); throwCantPack(msg); } if (d_tag < DT_NUM) { if (Elf64_Dyn::DT_NEEDED != d_tag &&  dt_table[d_tag] &&    get_te64(&dynp->d_val) != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) { char msg[50]; snprintf(msg, sizeof(msg), ""duplicate DT_%#x: [%#x] [%#x]"", (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx); throwCantPack(msg); } dt_table[d_tag] = ndx; } if (Elf64_Dyn::DT_NULL == d_tag) { break;          } } upx_dt_init = 0; if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT; else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY; else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY; unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ]; if (z_str) { strtab_end = get_te64(&dynp0[-1+ z_str].d_val); if ((u64_t)file_size <= strtab_end) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_STRSZ %#x"", strtab_end); throwCantPack(msg); } } unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB]; unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB]; if (x_sym && x_str) { upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val); upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val); unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT]; unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym) : get_te64(&dynp0[-1+ z_sym].d_val); if (sz_sym < sizeof(Elf64_Sym)) { char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_SYMENT %x"", sz_sym); throwCantPack(msg); } if (v_sym < v_str) { symnum_end = (v_str - v_sym) / sz_sym; } if (symnum_end < 1) { throwCantPack(""bad DT_SYMTAB""); } } unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); if (v_hsh && file_image) { hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH); if (!hashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_HASH %#x"", v_hsh); throwCantPack(msg); } unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; (void)chains; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!nbucket || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)          || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2                  + sizeof(*buckets)*nbucket                  + sizeof(*chains) *nbucket             )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_HASH nbucket=%#x  len=%#x"", nbucket, (v_sym - v_hsh)); throwCantPack(msg); } } unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); if (v_gsh && file_image) { gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH); if (!gashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH %#x"", v_gsh); throwCantPack(msg); } unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr; upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val); if (!n_bucket || !n_bitmask || (-1+ n_bitmask) & n_bitmask          || 8*sizeof(upx_uint64_t) <= gnu_shift          || (n_bucket>>30)          || (n_bitmask>>30) || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)                  || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4                  + sizeof(*bitmask)*n_bitmask                  + sizeof(*buckets)*n_bucket                  + sizeof(*hasharr)*n_bucket              )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx"", n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh)); throwCantPack(msg); } } unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx); if (e_shnum <= e_shstrndx &&  !(0==e_shnum && 0==e_shstrndx) ) { char msg[40]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } }"
"int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset, int max_beb_per1024, bool disable_fm) { struct ubi_device *ubi; int i, err; if (max_beb_per1024 < 0 || max_beb_per1024 > MAX_MTD_UBI_BEB_LIMIT) return -EINVAL; if (!max_beb_per1024) max_beb_per1024 = CONFIG_MTD_UBI_BEB_LIMIT; for (i = 0; i < UBI_MAX_DEVICES; i++) { ubi = ubi_devices[i]; if (ubi && mtd->index == ubi->mtd->index) { pr_err(""ubi: mtd%d is already attached to ubi%d\n"", mtd->index, i); return -EEXIST; } } if (mtd->type == MTD_UBIVOLUME) { pr_err(""ubi: refuse attaching mtd%d - it is already emulated on top of UBI\n"", mtd->index); return -EINVAL; } if (mtd->type == MTD_MLCNANDFLASH && !(mtd->flags & MTD_SLC_ON_MLC_EMULATION)) { pr_err(""ubi: refuse attaching mtd%d - MLC NAND is not supported\n"", mtd->index); return -EINVAL; } if (ubi_num == UBI_DEV_NUM_AUTO) { for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) if (!ubi_devices[ubi_num]) break; if (ubi_num == UBI_MAX_DEVICES) { pr_err(""ubi: only %d UBI devices may be created\n"", UBI_MAX_DEVICES); return -ENFILE; } } else { if (ubi_num >= UBI_MAX_DEVICES) return -EINVAL; if (ubi_devices[ubi_num]) { pr_err(""ubi: ubi%i already exists\n"", ubi_num); return -EEXIST; } } ubi = kzalloc(sizeof(struct ubi_device), GFP_KERNEL); if (!ubi) return -ENOMEM; device_initialize(&ubi->dev); ubi->dev.release = dev_release; ubi->dev.class = &ubi_class; ubi->dev.groups = ubi_dev_groups; ubi->dev.parent = &mtd->dev; ubi->mtd = mtd; ubi->ubi_num = ubi_num; ubi->vid_hdr_offset = vid_hdr_offset; ubi->autoresize_vol_id = -1; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_pool.used = ubi->fm_pool.size = 0; ubi->fm_wl_pool.used = ubi->fm_wl_pool.size = 0; ubi->fm_pool.max_size = min(((int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) / 100) * 5, UBI_FM_MAX_POOL_SIZE); ubi->fm_pool.max_size = max(ubi->fm_pool.max_size, UBI_FM_MIN_POOL_SIZE); ubi->fm_wl_pool.max_size = ubi->fm_pool.max_size / 2; ubi->fm_disabled = (!fm_autoconvert || disable_fm) ? 1 : 0; if (fm_debug) ubi_enable_dbg_chk_fastmap(ubi); if (!ubi->fm_disabled && (int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) <= UBI_FM_MAX_START) { ubi_err(ubi, ""More than %i PEBs are needed for fastmap, sorry."", UBI_FM_MAX_START); ubi->fm_disabled = 1; } ubi_msg(ubi, ""default fastmap pool size: %d"", ubi->fm_pool.max_size); ubi_msg(ubi, ""default fastmap WL pool size: %d"", ubi->fm_wl_pool.max_size); #else ubi->fm_disabled = 1; #endif mutex_init(&ubi->buf_mutex); mutex_init(&ubi->ckvol_mutex); mutex_init(&ubi->device_mutex); spin_lock_init(&ubi->volumes_lock); init_rwsem(&ubi->fm_protect); init_rwsem(&ubi->fm_eba_sem); ubi_msg(ubi, ""attaching mtd%d"", mtd->index); err = io_init(ubi, max_beb_per1024); if (err) goto out_free; err = -ENOMEM; ubi->peb_buf = vmalloc(ubi->peb_size); if (!ubi->peb_buf) goto out_free; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_size = ubi_calc_fm_size(ubi); ubi->fm_buf = vzalloc(ubi->fm_size); if (!ubi->fm_buf) goto out_free; #endif err = ubi_attach(ubi, disable_fm ? 1 : 0); if (err) { ubi_err(ubi, ""failed to attach mtd%d, error %d"", mtd->index, err); goto out_free; } if (ubi->autoresize_vol_id != -1) { err = autoresize(ubi, ubi->autoresize_vol_id); if (err) goto out_detach; } err = uif_init(ubi); if (err) goto out_detach; err = ubi_debugfs_init_dev(ubi); if (err) goto out_uif; ubi->bgt_thread = kthread_create(ubi_thread, ubi, ""%s"", ubi->bgt_name); if (IS_ERR(ubi->bgt_thread)) { err = PTR_ERR(ubi->bgt_thread); ubi_err(ubi, ""cannot spawn \""%s\"", error %d"", ubi->bgt_name, err); goto out_debugfs; } ubi_msg(ubi, ""attached mtd%d (name \""%s\"", size %llu MiB)"", mtd->index, mtd->name, ubi->flash_size >> 20); ubi_msg(ubi, ""PEB size: %d bytes (%d KiB), LEB size: %d bytes"", ubi->peb_size, ubi->peb_size >> 10, ubi->leb_size); ubi_msg(ubi, ""min./max. I/O unit sizes: %d/%d, sub-page size %d"", ubi->min_io_size, ubi->max_write_size, ubi->hdrs_min_io_size); ubi_msg(ubi, ""VID header offset: %d (aligned %d), data offset: %d"", ubi->vid_hdr_offset, ubi->vid_hdr_aloffset, ubi->leb_start); ubi_msg(ubi, ""good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d"", ubi->good_peb_count, ubi->bad_peb_count, ubi->corr_peb_count); ubi_msg(ubi, ""user volume: %d, internal volumes: %d, max. volumes count: %d"", ubi->vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT, ubi->vtbl_slots); ubi_msg(ubi, ""max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u"", ubi->max_ec, ubi->mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD, ubi->image_seq); ubi_msg(ubi, ""available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d"", ubi->avail_pebs, ubi->rsvd_pebs, ubi->beb_rsvd_pebs); spin_lock(&ubi->wl_lock); ubi->thread_enabled = 1; wake_up_process(ubi->bgt_thread); spin_unlock(&ubi->wl_lock); ubi_devices[ubi_num] = ubi; ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL); return ubi_num; out_debugfs: ubi_debugfs_exit_dev(ubi); out_uif: uif_close(ubi); out_detach: ubi_wl_close(ubi); ubi_free_all_volumes(ubi); vfree(ubi->vtbl); out_free: vfree(ubi->peb_buf); vfree(ubi->fm_buf); put_device(&ubi->dev); return err; }"
"int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType) { CDataFileReader DataFile; if(!DataFile.Open(pStorage, pFileName, StorageType)) return 0; Clean(); CMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0); if(!pItem) { return 0; } else if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION) { { CMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0); if(pItem && pItem->m_Version == 1) { if(pItem->m_Author > -1) str_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor)); if(pItem->m_MapVersion > -1) str_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion)); if(pItem->m_Credits > -1) str_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits)); if(pItem->m_License > -1) str_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense)); } } { int Start, Num; DataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num); for(int i = 0; i < Num; i++) { CMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0); char *pName = (char *)DataFile.GetData(pItem->m_ImageName); CEditorImage *pImg = new CEditorImage(m_pEditor); pImg->m_External = pItem->m_External; if(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA)) { char aBuf[IO_MAX_PATH_LENGTH]; str_format(aBuf, sizeof(aBuf),""mapres/%s.png"", pName); CEditorImage ImgInfo(m_pEditor); if(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL)) { *pImg = ImgInfo; pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION); ImgInfo.m_pData = 0; pImg->m_External = 1; } } else { pImg->m_Width = pItem->m_Width; pImg->m_Height = pItem->m_Height; pImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format; int PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4; int DataSize = pImg->m_Width * pImg->m_Height * PixelSize; void *pData = DataFile.GetData(pItem->m_ImageData); pImg->m_pData = mem_alloc(DataSize); mem_copy(pImg->m_pData, pData, DataSize); pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION); } if(pName) str_copy(pImg->m_aName, pName, 128); pImg->LoadAutoMapper(); m_lImages.add(pImg); DataFile.UnloadData(pItem->m_ImageData); DataFile.UnloadData(pItem->m_ImageName); } } { int LayersStart, LayersNum; DataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum); int Start, Num; DataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num); for(int g = 0; g < Num; g++) { CMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0); if(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION) continue; CLayerGroup *pGroup = NewGroup(); pGroup->m_ParallaxX = pGItem->m_ParallaxX; pGroup->m_ParallaxY = pGItem->m_ParallaxY; pGroup->m_OffsetX = pGItem->m_OffsetX; pGroup->m_OffsetY = pGItem->m_OffsetY; if(pGItem->m_Version >= 2) { pGroup->m_UseClipping = pGItem->m_UseClipping; pGroup->m_ClipX = pGItem->m_ClipX; pGroup->m_ClipY = pGItem->m_ClipY; pGroup->m_ClipW = pGItem->m_ClipW; pGroup->m_ClipH = pGItem->m_ClipH; } if(pGItem->m_Version >= 3) IntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName); for(int l = 0; l < pGItem->m_NumLayers; l++) { CLayer *pLayer = 0; CMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0); if(!pLayerItem) continue; if(pLayerItem->m_Type == LAYERTYPE_TILES) { CMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem; CLayerTiles *pTiles = 0; if(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME) { pTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height); MakeGameLayer(pTiles); MakeGameGroup(pGroup); } else { pTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height); pTiles->m_pEditor = m_pEditor; pTiles->m_Color = pTilemapItem->m_Color; pTiles->m_ColorEnv = pTilemapItem->m_ColorEnv; pTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset; } pLayer = pTiles; pGroup->AddLayer(pTiles); void *pData = DataFile.GetData(pTilemapItem->m_Data); pTiles->m_Image = pTilemapItem->m_Image; pTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME; if(pTilemapItem->m_Version >= 3) IntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName); if(pTilemapItem->m_Version > 3) pTiles->ExtractTiles((CTile *)pData); else mem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile)); if(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem)) { for(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++) { if(pTiles->m_pTiles[i].m_Index) pTiles->m_pTiles[i].m_Index += ENTITY_OFFSET; } } DataFile.UnloadData(pTilemapItem->m_Data); } else if(pLayerItem->m_Type == LAYERTYPE_QUADS) { CMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem; CLayerQuads *pQuads = new CLayerQuads; pQuads->m_pEditor = m_pEditor; pLayer = pQuads; pQuads->m_Image = pQuadsItem->m_Image; if(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size()) pQuads->m_Image = -1; if(pQuadsItem->m_Version >= 2) IntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName); void *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data); pGroup->AddLayer(pQuads); pQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads); mem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads); DataFile.UnloadData(pQuadsItem->m_Data); } if(pLayer) pLayer->m_Flags = pLayerItem->m_Flags; } } } { CEnvPoint *pEnvPoints = 0; { int Start, Num; DataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num); if(Num) pEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0); } int Start, Num; DataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num); for(int e = 0; e < Num; e++) { CMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0); CEnvelope *pEnv = new CEnvelope(pItem->m_Channels); pEnv->m_lPoints.set_size(pItem->m_NumPoints); for(int n = 0; n < pItem->m_NumPoints; n++) { if(pItem->m_Version >= 3) { pEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n]; } else { CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n]; mem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint)); pEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time; pEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype; for(int c = 0; c < pItem->m_Channels; c++) { pEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c]; } } } if(pItem->m_aName[0] != -1)IntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName); m_lEnvelopes.add(pEnv); if(pItem->m_Version >= 2) pEnv->m_Synchronized = pItem->m_Synchronized; } } } else return 0; return 1; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& values_tensor = ctx->input(0); const Tensor& value_range_tensor = ctx->input(1); const Tensor& nbins_tensor = ctx->input(2); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()), errors::InvalidArgument(""value_range should be a vector."")); OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2), errors::InvalidArgument( ""value_range should be a vector of 2 elements."")); OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()), errors::InvalidArgument(""nbins should be a scalar."")); const auto values = values_tensor.flat<T>(); const auto value_range = value_range_tensor.flat<T>(); const auto nbins = nbins_tensor.scalar<int32>()(); OP_REQUIRES( ctx, (value_range(0) < value_range(1)), errors::InvalidArgument(""value_range should satisfy value_range[0] < "" ""value_range[1], but got '["", value_range(0), "", "", value_range(1), ""]'"")); OP_REQUIRES( ctx, (nbins > 0), errors::InvalidArgument(""nbins should be a positive number, but got '"", nbins, ""'"")); Tensor* out_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({nbins}), &out_tensor)); auto out = out_tensor->flat<Tout>(); OP_REQUIRES_OK( ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute( ctx, values, value_range, nbins, out)); }"
"Elf32_Sym const *PackLinuxElf32::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); unsigned const *const bitmask = &gashtab[4]; unsigned const *const buckets = &bitmask[n_bitmask]; unsigned const *const hasharr = &buckets[n_bucket]; unsigned const h = gnu_hash(name); unsigned const hbit1 = 037& h; unsigned const hbit2 = 037& (h>>gnu_shift); unsigned const w = get_te32(&bitmask[(n_bitmask -1) & (h>>5)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf32_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, 0==(1u& get_te32(hp++))); } } } return 0; }"
"static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id) { struct elo_priv *priv; int ret; struct usb_device *udev; if (!hid_is_usb(hdev)) return -EINVAL; priv = kzalloc(sizeof(*priv), GFP_KERNEL); if (!priv) return -ENOMEM; INIT_DELAYED_WORK(&priv->work, elo_work); udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent)); priv->usbdev = usb_get_dev(udev); hid_set_drvdata(hdev, priv); ret = hid_parse(hdev); if (ret) { hid_err(hdev, ""parse failed\n""); goto err_free; } ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT); if (ret) { hid_err(hdev, ""hw start failed\n""); goto err_free; } if (elo_broken_firmware(priv->usbdev)) { hid_info(hdev, ""broken firmware found, installing workaround\n""); queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL); } return 0; err_free: kfree(priv); return ret; }"
"void readConf() { guarded_mutex guard(gMutexConfigure); writeLog(0, ""Reading preference settings..."", LOG_LEVEL_INFO); eraseElements(global.excludeRemarks); eraseElements(global.includeRemarks); eraseElements(global.customProxyGroups); eraseElements(global.customRulesets); try { std::string prefdata = fileGet(global.prefPath, false); if(prefdata.find(""common:"") != prefdata.npos) { YAML::Node yaml = YAML::Load(prefdata); if(yaml.size() && yaml[""common""]) return readYAMLConf(yaml); } toml::value conf = parseToml(prefdata, global.prefPath); if(!conf.is_uninitialized() && toml::find_or<int>(conf, ""version"", 0)) return readTOMLConf(conf); } catch (YAML::Exception &e) { } catch (toml::exception &e) { writeLog(0, e.what(), LOG_LEVEL_DEBUG); } INIReader ini; ini.allow_dup_section_titles = true; int retVal = ini.ParseFile(global.prefPath); if(retVal != INIREADER_EXCEPTION_NONE) { writeLog(0, ""Unable to load preference settings. Reason: "" + ini.GetLastError(), LOG_LEVEL_FATAL); return; } string_array tempArray; ini.EnterSection(""common""); ini.GetBoolIfExist(""api_mode"", global.APIMode); ini.GetIfExist(""api_access_token"", global.accessToken); ini.GetIfExist(""default_url"", global.defaultUrls); global.enableInsert = ini.Get(""enable_insert""); ini.GetIfExist(""insert_url"", global.insertUrls); ini.GetBoolIfExist(""prepend_insert_url"", global.prependInsert); if(ini.ItemPrefixExist(""exclude_remarks"")) ini.GetAll(""exclude_remarks"", global.excludeRemarks); if(ini.ItemPrefixExist(""include_remarks"")) ini.GetAll(""include_remarks"", global.includeRemarks); global.filterScript = ini.GetBool(""enable_filter"") ? ini.Get(""filter_script""): """"; ini.GetIfExist(""base_path"", global.basePath); ini.GetIfExist(""clash_rule_base"", global.clashBase); ini.GetIfExist(""surge_rule_base"", global.surgeBase); ini.GetIfExist(""surfboard_rule_base"", global.surfboardBase); ini.GetIfExist(""mellow_rule_base"", global.mellowBase); ini.GetIfExist(""quan_rule_base"", global.quanBase); ini.GetIfExist(""quanx_rule_base"", global.quanXBase); ini.GetIfExist(""loon_rule_base"", global.loonBase); ini.GetIfExist(""default_external_config"", global.defaultExtConfig); ini.GetBoolIfExist(""append_proxy_type"", global.appendType); ini.GetIfExist(""proxy_config"", global.proxyConfig); ini.GetIfExist(""proxy_ruleset"", global.proxyRuleset); ini.GetIfExist(""proxy_subscription"", global.proxySubscription); if(ini.SectionExist(""surge_external_proxy"")) { ini.EnterSection(""surge_external_proxy""); ini.GetIfExist(""surge_ssr_path"", global.surgeSSRPath); ini.GetBoolIfExist(""resolve_hostname"", global.surgeResolveHostname); } if(ini.SectionExist(""node_pref"")) { ini.EnterSection(""node_pref""); global.UDPFlag.set(ini.Get(""udp_flag"")); global.TFOFlag.set(ini.Get(""tcp_fast_open_flag"")); global.skipCertVerify.set(ini.Get(""skip_cert_verify_flag"")); global.TLS13Flag.set(ini.Get(""tls13_flag"")); ini.GetBoolIfExist(""sort_flag"", global.enableSort); global.sortScript = ini.Get(""sort_script""); ini.GetBoolIfExist(""filter_deprecated_nodes"", global.filterDeprecated); ini.GetBoolIfExist(""append_sub_userinfo"", global.appendUserinfo); ini.GetBoolIfExist(""clash_use_new_field_name"", global.clashUseNewField); ini.GetIfExist(""clash_proxies_style"", global.clashProxiesStyle); if(ini.ItemPrefixExist(""rename_node"")) { ini.GetAll(""rename_node"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""@""); safe_set_renames(configs); eraseElements(tempArray); } } if(ini.SectionExist(""userinfo"")) { ini.EnterSection(""userinfo""); if(ini.ItemPrefixExist(""stream_rule"")) { ini.GetAll(""stream_rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""|""); safe_set_streams(configs); eraseElements(tempArray); } if(ini.ItemPrefixExist(""time_rule"")) { ini.GetAll(""time_rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""|""); safe_set_times(configs); eraseElements(tempArray); } } ini.EnterSection(""managed_config""); ini.GetBoolIfExist(""write_managed_config"", global.writeManagedConfig); ini.GetIfExist(""managed_config_prefix"", global.managedConfigPrefix); ini.GetIntIfExist(""config_update_interval"", global.updateInterval); ini.GetBoolIfExist(""config_update_strict"", global.updateStrict); ini.GetIfExist(""quanx_device_id"", global.quanXDevID); ini.EnterSection(""emojis""); ini.GetBoolIfExist(""add_emoji"", global.addEmoji); ini.GetBoolIfExist(""remove_old_emoji"", global.removeEmoji); if(ini.ItemPrefixExist(""rule"")) { ini.GetAll(""rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "",""); safe_set_emojis(configs); eraseElements(tempArray); } if(ini.SectionExist(""rulesets"")) ini.EnterSection(""rulesets""); else ini.EnterSection(""ruleset""); global.enableRuleGen = ini.GetBool(""enabled""); if(global.enableRuleGen) { ini.GetBoolIfExist(""overwrite_original_rules"", global.overwriteOriginalRules); ini.GetBoolIfExist(""update_ruleset_on_request"", global.updateRulesetOnRequest); if(ini.ItemPrefixExist(""ruleset"")) { string_array vArray; ini.GetAll(""ruleset"", vArray); importItems(vArray, false); global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray); } else if(ini.ItemPrefixExist(""surge_ruleset"")) { string_array vArray; ini.GetAll(""surge_ruleset"", vArray); importItems(vArray, false); global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray); } } else { global.overwriteOriginalRules = false; global.updateRulesetOnRequest = false; } if(ini.SectionExist(""proxy_groups"")) ini.EnterSection(""proxy_groups""); else ini.EnterSection(""clash_proxy_group""); if(ini.ItemPrefixExist(""custom_proxy_group"")) { string_array vArray; ini.GetAll(""custom_proxy_group"", vArray); importItems(vArray, false); global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray); } ini.EnterSection(""template""); ini.GetIfExist(""template_path"", global.templatePath); string_multimap tempmap; ini.GetItems(tempmap); eraseElements(global.templateVars); for(auto &x : tempmap) { if(x.first == ""template_path"") continue; global.templateVars[x.first] = x.second; } global.templateVars[""managed_config_prefix""] = global.managedConfigPrefix; if(ini.SectionExist(""aliases"")) { ini.EnterSection(""aliases""); ini.GetItems(tempmap); webServer.reset_redirect(); for(auto &x : tempmap) webServer.append_redirect(x.first, x.second); } if(ini.SectionExist(""tasks"")) { string_array vArray; ini.EnterSection(""tasks""); ini.GetAll(""task"", vArray); importItems(vArray, false); global.enableCron = !vArray.empty(); global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray); refresh_schedule(); } ini.EnterSection(""server""); ini.GetIfExist(""listen"", global.listenAddress); ini.GetIntIfExist(""port"", global.listenPort); webServer.serve_file_root = ini.Get(""serve_file_root""); webServer.serve_file = !webServer.serve_file_root.empty(); ini.EnterSection(""advanced""); std::string log_level; ini.GetIfExist(""log_level"", log_level); ini.GetBoolIfExist(""print_debug_info"", global.printDbgInfo); if(global.printDbgInfo) global.logLevel = LOG_LEVEL_VERBOSE; else { switch(hash_(log_level)) { case ""warn""_hash: global.logLevel = LOG_LEVEL_WARNING; break; case ""error""_hash: global.logLevel = LOG_LEVEL_ERROR; break; case ""fatal""_hash: global.logLevel = LOG_LEVEL_FATAL; break; case ""verbose""_hash: global.logLevel = LOG_LEVEL_VERBOSE; break; case ""debug""_hash: global.logLevel = LOG_LEVEL_DEBUG; break; default: global.logLevel = LOG_LEVEL_INFO; } } ini.GetIntIfExist(""max_pending_connections"", global.maxPendingConns); ini.GetIntIfExist(""max_concurrent_threads"", global.maxConcurThreads); ini.GetNumberIfExist(""max_allowed_rulesets"", global.maxAllowedRulesets); ini.GetNumberIfExist(""max_allowed_rules"", global.maxAllowedRules); ini.GetNumberIfExist(""max_allowed_download_size"", global.maxAllowedDownloadSize); if(ini.ItemExist(""enable_cache"")) { if(ini.GetBool(""enable_cache"")) { ini.GetIntIfExist(""cache_subscription"", global.cacheSubscription); ini.GetIntIfExist(""cache_config"", global.cacheConfig); ini.GetIntIfExist(""cache_ruleset"", global.cacheRuleset); ini.GetBoolIfExist(""serve_cache_on_fetch_fail"", global.serveCacheOnFetchFail); } else { global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;             global.serveCacheOnFetchFail = false; } } ini.GetBoolIfExist(""script_clean_context"", global.scriptCleanContext); ini.GetBoolIfExist(""async_fetch_ruleset"", global.asyncFetchRuleset); ini.GetBoolIfExist(""skip_failed_links"", global.skipFailedLinks); writeLog(0, ""Read preference settings completed."", LOG_LEVEL_INFO); }"
"static int compat_copy_entries_to_user(unsigned int total_size, struct xt_table *table, void __user *userptr) { struct xt_counters *counters; const struct xt_table_info *private = table->private; void __user *pos; unsigned int size; int ret = 0; unsigned int i = 0; struct arpt_entry *iter; counters = alloc_counters(table); if (IS_ERR(counters)) return PTR_ERR(counters); pos = userptr; size = total_size; xt_entry_foreach(iter, private->entries, total_size) { ret = compat_copy_entry_to_user(iter, &pos, &size, counters, i++); if (ret != 0) break; } vfree(counters); return ret; }"
"void free_xen_event_channel(struct domain *d, int port) { BUG_ON(!port_is_valid(d, port)); evtchn_close(d, port, 0); }"
"static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct legacy_fs_context *ctx = fc->fs_private; unsigned int size = ctx->data_size; size_t len = 0; int ret; ret = vfs_parse_fs_param_source(fc, param); if (ret != -ENOPARAM) return ret; if (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS) return invalf(fc, ""VFS: Legacy: Can't mix monolithic and individual options""); switch (param->type) { case fs_value_is_string: len = 1 + param->size; fallthrough; case fs_value_is_flag: len += strlen(param->key); break; default: return invalf(fc, ""VFS: Legacy: Parameter type for '%s' not supported"", param->key); } if (len > PAGE_SIZE - 2 - size) return invalf(fc, ""VFS: Legacy: Cumulative options too large""); if (strchr(param->key, ',') || (param->type == fs_value_is_string && memchr(param->string, ',', param->size))) return invalf(fc, ""VFS: Legacy: Option '%s' contained comma"", param->key); if (!ctx->legacy_data) { ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL); if (!ctx->legacy_data) return -ENOMEM; } ctx->legacy_data[size++] = ','; len = strlen(param->key); memcpy(ctx->legacy_data + size, param->key, len); size += len; if (param->type == fs_value_is_string) { ctx->legacy_data[size++] = '='; memcpy(ctx->legacy_data + size, param->string, param->size); size += param->size; } ctx->legacy_data[size] = '\0'; ctx->data_size = size; ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS; return 0; }"
"int wl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data) { union map_entry *start; uint32_t count; struct wl_array *entries; if (i < WL_SERVER_ID_START) { entries = &map->client_entries; } else { entries = &map->server_entries; i -= WL_SERVER_ID_START; } count = entries->size / sizeof *start; if (count < i) { errno = EINVAL; return -1; } if (count == i) { if (!wl_array_add(entries, sizeof *start)) return -1; } start = entries->data; start[i].data = data; start[i].next |= (flags & 0x1) << 1; return 0; }"
"std::shared_ptr<Grammar> perform_core(const char *s, size_t n, const Rules &rules, std::string &start, Log log) { Data data; any dt = &data; auto r = g[""Grammar""].parse(s, n, dt); if (!r.ret) { if (log) { if (r.message_pos) { auto line = line_info(s, r.message_pos); log(line.first, line.second, r.message); } else { auto line = line_info(s, r.error_pos); log(line.first, line.second, ""syntax error""); } } return nullptr; } auto &grammar = *data.grammar; for (const auto &x : rules) { auto name = x.first; bool ignore = false; if (!name.empty() && name[0] == '~') { ignore = true; name.erase(0, 1); } if (!name.empty()) { auto &rule = grammar[name]; rule <= x.second; rule.name = name; rule.ignoreSemanticValue = ignore; } } bool ret = data.duplicates.empty(); for (const auto &x : data.duplicates) { if (log) { const auto &name = x.first; auto ptr = x.second; auto line = line_info(s, ptr); log(line.first, line.second, ""'"" + name + ""' is already defined.""); } } for (auto &x : grammar) { auto &rule = x.second; ReferenceChecker vis(*data.grammar, rule.params); rule.accept(vis); for (const auto &y : vis.error_s) { const auto &name = y.first; const auto ptr = y.second; if (log) { auto line = line_info(s, ptr); log(line.first, line.second, vis.error_message[name]); } ret = false; } } if (!ret) { return nullptr; } for (auto &x : grammar) { auto &rule = x.second; LinkReferences vis(*data.grammar, rule.params); rule.accept(vis); } ret = true; for (auto &x : grammar) { const auto &name = x.first; auto &rule = x.second; DetectLeftRecursion vis(name); rule.accept(vis); if (vis.error_s) { if (log) { auto line = line_info(s, vis.error_s); log(line.first, line.second, ""'"" + name + ""' is left recursive.""); } ret = false; } } if (!ret) { return nullptr; } auto &start_rule = (*data.grammar)[data.start]; { DetectInfiniteLoop vis(data.start_pos, data.start); start_rule.accept(vis); if (vis.has_error) { if (log) { auto line = line_info(s, vis.error_s); log(line.first, line.second, ""infinite loop is detected in '"" + vis.error_name + ""'.""); } return nullptr; } } if (grammar.count(WHITESPACE_DEFINITION_NAME)) { for (auto &x : grammar) { auto &rule = x.second; auto ope = rule.get_core_operator(); if (IsLiteralToken::check(*ope)) { rule <= tok(ope); } } start_rule.whitespaceOpe = wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator()); } if (grammar.count(WORD_DEFINITION_NAME)) { start_rule.wordOpe = (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator(); } for (const auto &item : data.instructions) { const auto &name = item.first; const auto &instruction = item.second; auto &rule = grammar[name]; if (instruction.type == ""precedence"") { const auto &info = any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data); if (!apply_precedence_instruction(rule, info, s, log)) { return nullptr; } } } start = data.start; return data.grammar; }"
"static int op_get_data(OggOpusFile *_of,int _nbytes){ unsigned char *buffer; int            nbytes; OP_ASSERT(_nbytes>0); buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes); nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes); OP_ASSERT(nbytes<=_nbytes); if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes); return nbytes; }"
void exit_files(struct task_struct *tsk) { struct files_struct * files = tsk->files; if (files) { task_lock(tsk); tsk->files = NULL; task_unlock(tsk); put_files_struct(files); } }
"static int rtsx_usb_ms_drv_remove(struct platform_device *pdev) { struct rtsx_usb_ms *host = platform_get_drvdata(pdev); struct memstick_host *msh = host->msh; int err; host->eject = true; cancel_work_sync(&host->handle_req); mutex_lock(&host->host_mutex); if (host->req) { dev_dbg(ms_dev(host), ""%s: Controller removed during transfer\n"", dev_name(&msh->dev)); host->req->error = -ENOMEDIUM; do { err = memstick_next_req(msh, &host->req); if (!err) host->req->error = -ENOMEDIUM; } while (!err); } mutex_unlock(&host->host_mutex); memstick_remove_host(msh); memstick_free_host(msh); if (pm_runtime_active(ms_dev(host))) pm_runtime_put(ms_dev(host)); pm_runtime_disable(ms_dev(host)); platform_set_drvdata(pdev, NULL); dev_dbg(ms_dev(host), "": Realtek USB Memstick controller has been removed\n""); return 0; }"
"static int handle_input_expect_headers(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end, const char **err_desc) { struct st_h2o_http3_server_conn_t *conn = get_conn(stream); h2o_http3_read_frame_t frame; int header_exists_map = 0, ret; uint8_t header_ack[H2O_HPACK_ENCODE_INT_MAX_LENGTH]; size_t header_ack_len; if ((ret = h2o_http3_read_frame(&frame, 0, H2O_HTTP3_STREAM_TYPE_REQUEST, src, src_end, err_desc)) != 0) return ret; if (frame.type != H2O_HTTP3_FRAME_TYPE_HEADERS) { switch (frame.type) { case H2O_HTTP3_FRAME_TYPE_DATA: return H2O_HTTP3_ERROR_FRAME_UNEXPECTED; default: break; } return 0; } stream->recvbuf.handle_input = handle_input_expect_data; if ((ret = h2o_qpack_parse_request(&stream->req.pool, get_conn(stream)->h3.qpack.dec, stream->quic->stream_id, &stream->req.input.method, &stream->req.input.scheme, &stream->req.input.authority, &stream->req.input.path, &stream->req.headers, &header_exists_map, &stream->req.content_length, NULL , header_ack, &header_ack_len, frame.payload, frame.length, err_desc)) != 0 && ret != H2O_HTTP2_ERROR_INVALID_HEADER_CHAR) return ret; if (header_ack_len != 0) h2o_http3_send_qpack_header_ack(&conn->h3, header_ack, header_ack_len); if (stream->req.input.scheme == NULL) stream->req.input.scheme = &H2O_URL_SCHEME_HTTPS; h2o_probe_log_request(&stream->req, stream->quic->stream_id); int is_connect = h2o_memis(stream->req.input.method.base, stream->req.input.method.len, H2O_STRLIT(""CONNECT"")); int expected_map = H2O_HPACK_PARSE_HEADERS_METHOD_EXISTS | H2O_HPACK_PARSE_HEADERS_AUTHORITY_EXISTS; if (!is_connect) expected_map |= H2O_HPACK_PARSE_HEADERS_SCHEME_EXISTS | H2O_HPACK_PARSE_HEADERS_PATH_EXISTS; if (header_exists_map != expected_map) { shutdown_stream(stream, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, 0); return 0; } if (ret == H2O_HTTP2_ERROR_INVALID_HEADER_CHAR) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"", *err_desc, err_desc); if (stream->req.content_length != SIZE_MAX && stream->req.content_length > conn->super.ctx->globalconf->max_request_entity_size) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_413, ""Request Entity Too Large"", ""request entity is too large"", err_desc); assert(!h2o_linklist_is_linked(&stream->scheduler.link)); if (!stream->received_priority_update) { ssize_t index; if ((index = h2o_find_header(&stream->req.headers, H2O_TOKEN_PRIORITY, -1)) != -1) { h2o_iovec_t *value = &stream->req.headers.entries[index].value; h2o_absprio_parse_priority(value->base, value->len, &stream->scheduler.priority); } } if (is_connect) { if (stream->req.content_length != SIZE_MAX) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"", ""CONNECT request cannot have request body"", err_desc); set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS, 0); stream->tunnel = h2o_mem_alloc(sizeof(*stream->tunnel)); stream->tunnel->tunnel = NULL; stream->tunnel->stream = stream; stream->tunnel->up.is_inflight = 0; stream->tunnel->up.delayed_write = (h2o_timer_t){.cb = tunnel_write_delayed}; h2o_process_request(&stream->req); return 0; } set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK, 0); return 0; }"
"int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num) { if (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) { return -1; } unsigned short value = DNS_HTTPS_T_IPV6HINT; dns_add_rr_nested_memcpy(svcparam, &value, 2); value = addr_num * DNS_RR_AAAA_LEN; dns_add_rr_nested_memcpy(svcparam, &value, 2); for (int i = 0; i < addr_num; i++) { dns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN); } return 0; }"
"Values::Field* Statement::BindParameter(const Napi::Value source, T pos) { if (source.IsString()) { std::string val = source.As<Napi::String>().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else if (OtherInstanceOf(source.As<Object>(), ""RegExp"")) { std::string val = source.ToString().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else if (source.IsNumber()) { if (OtherIsInt(source.As<Napi::Number>())) { return new Values::Integer(pos, source.As<Napi::Number>().Int32Value()); } else { return new Values::Float(pos, source.As<Napi::Number>().DoubleValue()); } } else if (source.IsBoolean()) { return new Values::Integer(pos, source.As<Napi::Boolean>().Value() ? 1 : 0); } else if (source.IsNull()) { return new Values::Null(pos); } else if (source.IsBuffer()) { Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>(); return new Values::Blob(pos, buffer.Length(), buffer.Data()); } else if (OtherInstanceOf(source.As<Object>(), ""Date"")) { return new Values::Float(pos, source.ToNumber().DoubleValue()); } else if (source.IsObject()) { std::string val = source.ToString().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else { return NULL; } }"
"static inline int compat_copy_match_to_user(struct ipt_entry_match *m, void __user **dstptr, compat_uint_t *size) { if (m->u.kernel.match->compat) return m->u.kernel.match->compat(m, dstptr, size, COMPAT_TO_USER); else return xt_compat_match(m, dstptr, size, COMPAT_TO_USER); }"
"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes) { Bool null_size_ok = GF_FALSE; GF_DefaultSampleGroupDescriptionEntry *ptr; switch (grouping_type) { case GF_ISOM_SAMPLE_GROUP_ROLL: case GF_ISOM_SAMPLE_GROUP_PROL: { GF_RollRecoveryEntry *ptr; GF_SAFEALLOC(ptr, GF_RollRecoveryEntry); if (!ptr) return NULL; ptr->roll_distance = gf_bs_read_int(bs, 16); *total_bytes = 2; return ptr; } case GF_ISOM_SAMPLE_GROUP_RAP: { GF_VisualRandomAccessEntry *ptr; GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry); if (!ptr) return NULL; ptr->num_leading_samples_known = gf_bs_read_int(bs, 1); ptr->num_leading_samples = gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SAP: { GF_SAPEntry *ptr; GF_SAFEALLOC(ptr, GF_SAPEntry); if (!ptr) return NULL; ptr->dependent_flag = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 3); ptr->SAP_type = gf_bs_read_int(bs, 4); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SYNC: { GF_SYNCEntry *ptr; GF_SAFEALLOC(ptr, GF_SYNCEntry); if (!ptr) return NULL; gf_bs_read_int(bs, 2); ptr->NALU_type = gf_bs_read_int(bs, 6); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_TELE: { GF_TemporalLevelEntry *ptr; GF_SAFEALLOC(ptr, GF_TemporalLevelEntry); if (!ptr) return NULL; ptr->level_independently_decodable = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SEIG: { GF_CENCSampleEncryptionGroupEntry *ptr; GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry); if (!ptr) return NULL; gf_bs_read_u8(bs); ptr->crypt_byte_block = gf_bs_read_int(bs, 4); ptr->skip_byte_block = gf_bs_read_int(bs, 4); ptr->IsProtected = gf_bs_read_u8(bs); ptr->Per_Sample_IV_size = gf_bs_read_u8(bs); gf_bs_read_data(bs, (char *)ptr->KID, 16); *total_bytes = 20; if ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) { ptr->constant_IV_size = gf_bs_read_u8(bs); assert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16)); gf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size); *total_bytes += 1 + ptr->constant_IV_size; } if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_OINF: { GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_oinf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_LINF: { GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_linf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_TRIF: if (! entry_size) { u32 flags = gf_bs_peek_bits(bs, 24, 0); if (flags & 0x10000) entry_size=3; else { if (flags & 0x80000) entry_size=7; else entry_size=11; if (flags & 0x200000) { u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size); entry_size += 2 + 2*nb_entries; } } GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_NALM: if (! entry_size) { u64 start = gf_bs_get_position(bs); Bool rle, large_size; u32 entry_count; gf_bs_read_int(bs, 6); large_size = gf_bs_read_int(bs, 1); rle = gf_bs_read_int(bs, 1); entry_count = gf_bs_read_int(bs, large_size ? 16 : 8); gf_bs_seek(bs, start); entry_size = 1 + large_size ? 2 : 1; entry_size += entry_count * 2; if (rle) entry_size += entry_count * (large_size ? 2 : 1); GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_TSAS: case GF_ISOM_SAMPLE_GROUP_STSA: null_size_ok = GF_TRUE; break; case GF_ISOM_SAMPLE_GROUP_TSCL: entry_size = 20; break; case GF_ISOM_SAMPLE_GROUP_LBLI: entry_size = 2; break; default: break; } if (!entry_size && !null_size_ok) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) )); return NULL; } GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry); if (!ptr) return NULL; if (entry_size) { ptr->length = entry_size; ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length); gf_bs_read_data(bs, (char *) ptr->data, ptr->length); *total_bytes = entry_size; } return ptr; }"
"void spell_suggest(int count) { char_u*line; pos_Tprev_cursor = curwin->w_cursor; char_uwcopy[MAXWLEN + 2]; char_u*p; inti; intc; suginfo_Tsug; suggest_T*stp; intmouse_used; intneed_cap; intlimit; intselected = count; intbadlen = 0; intmsg_scroll_save = msg_scroll; intwo_spell_save = curwin->w_p_spell; if (!curwin->w_p_spell) { did_set_spelllang(curwin); curwin->w_p_spell = TRUE; } if (*curwin->w_s->b_p_spl == NUL) { emsg(_(e_spell_checking_is_not_possible)); return; } if (VIsual_active) { if (curwin->w_cursor.lnum != VIsual.lnum) { vim_beep(BO_SPELL); return; } badlen = (int)curwin->w_cursor.col - (int)VIsual.col; if (badlen < 0) badlen = -badlen; else curwin->w_cursor.col = VIsual.col; ++badlen; end_visual_mode(); } else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0 || curwin->w_cursor.col > prev_cursor.col) { curwin->w_cursor = prev_cursor; line = ml_get_curline(); p = line + curwin->w_cursor.col; while (p > line && spell_iswordp_nmw(p, curwin)) MB_PTR_BACK(line, p); while (*p != NUL && !spell_iswordp_nmw(p, curwin)) MB_PTR_ADV(p); if (!spell_iswordp_nmw(p, curwin)){ beep_flush(); return; } curwin->w_cursor.col = (colnr_T)(p - line); } need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col); line = vim_strsave(ml_get_curline()); if (line == NULL) goto skip; if (sps_limit > (int)Rows - 2) limit = (int)Rows - 2; else limit = sps_limit; spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit, TRUE, need_cap, TRUE); if (sug.su_ga.ga_len == 0) msg(_(""Sorry, no suggestions"")); else if (count > 0) { if (count > sug.su_ga.ga_len) smsg(_(""Sorry, only %ld suggestions""), (long)sug.su_ga.ga_len); } else { #ifdef FEAT_RIGHTLEFT cmdmsg_rl = curwin->w_p_rl; if (cmdmsg_rl) msg_col = Columns - 1; #endif msg_start(); msg_row = Rows - 1;lines_left = Rows;vim_snprintf((char *)IObuff, IOSIZE, _(""Change \""%.*s\"" to:""), sug.su_badlen, sug.su_badptr); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl && STRNCMP(IObuff, ""Change"", 6) == 0) { vim_snprintf((char *)IObuff, IOSIZE, "":ot \""%.*s\"" egnahC"", sug.su_badlen, sug.su_badptr); } #endif msg_puts((char *)IObuff); msg_clr_eos(); msg_putchar('\n'); msg_scroll = TRUE; for (i = 0; i < sug.su_ga.ga_len; ++i) { stp = &SUG(sug.su_ga, i); vim_strncpy(wcopy, stp->st_word, MAXWLEN); if (sug.su_badlen > stp->st_orglen) vim_strncpy(wcopy + stp->st_wordlen, sug.su_badptr + stp->st_orglen, sug.su_badlen - stp->st_orglen); vim_snprintf((char *)IObuff, IOSIZE, ""%2d"", i + 1); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl) rl_mirror(IObuff); #endif msg_puts((char *)IObuff); vim_snprintf((char *)IObuff, IOSIZE, "" \""%s\"""", wcopy); msg_puts((char *)IObuff); if (sug.su_badlen < stp->st_orglen) { vim_snprintf((char *)IObuff, IOSIZE, _("" < \""%.*s\""""), stp->st_orglen, sug.su_badptr); msg_puts((char *)IObuff); } if (p_verbose > 0) { if (sps_flags & (SPS_DOUBLE | SPS_BEST)) vim_snprintf((char *)IObuff, IOSIZE, "" (%s%d - %d)"", stp->st_salscore ? ""s "" : """", stp->st_score, stp->st_altscore); else vim_snprintf((char *)IObuff, IOSIZE, "" (%d)"", stp->st_score); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl) rl_mirror(IObuff + 1); #endif msg_advance(30); msg_puts((char *)IObuff); } msg_putchar('\n'); } #ifdef FEAT_RIGHTLEFT cmdmsg_rl = FALSE; msg_col = 0; #endif selected = prompt_for_number(&mouse_used); if (mouse_used) selected -= lines_left; lines_left = Rows;msg_scroll = msg_scroll_save; } if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK) { VIM_CLEAR(repl_from); VIM_CLEAR(repl_to); stp = &SUG(sug.su_ga, selected - 1); if (sug.su_badlen > stp->st_orglen) { repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen); vim_snprintf((char *)IObuff, IOSIZE, ""%s%.*s"", stp->st_word, sug.su_badlen - stp->st_orglen, sug.su_badptr + stp->st_orglen); repl_to = vim_strsave(IObuff); } else { repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen); repl_to = vim_strsave(stp->st_word); } p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1); if (p != NULL) { c = (int)(sug.su_badptr - line); mch_memmove(p, line, c); STRCPY(p + c, stp->st_word); STRCAT(p, sug.su_badptr + stp->st_orglen); ResetRedobuff(); AppendToRedobuff((char_u *)""ciw""); AppendToRedobuffLit(p + c, stp->st_wordlen + sug.su_badlen - stp->st_orglen); AppendCharToRedobuff(ESC); ml_replace(curwin->w_cursor.lnum, p, FALSE); curwin->w_cursor.col = c; changed_bytes(curwin->w_cursor.lnum, c); } } else curwin->w_cursor = prev_cursor; spell_find_cleanup(&sug); skip: vim_free(line); curwin->w_p_spell = wo_spell_save; }"
"uchar * htmlGetText(tree_t *t) { uchar*s,*s2,*tdata = NULL,*talloc = NULL;  size_tslen,tlen; slen = 0; s    = NULL; while (t != NULL) { if (t->child) tdata = talloc = htmlGetText(t->child); else tdata = t->data; if (tdata != NULL) { tlen = strlen((char *)tdata); if (s) s2 = (uchar *)realloc(s, 1 + slen + tlen); else s2 = (uchar *)malloc(1 + tlen); if (!s2) break; s = s2; memcpy((char *)s + slen, (char *)tdata, tlen); slen += tlen; if (talloc) { free(talloc); talloc = NULL; } } t = t->next; } if (slen) s[slen] = '\0'; if (talloc) free(talloc); return (s); }"
"static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen) { struct sock *sk = sock->sk; struct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk); struct nfc_llcp_local *local; struct nfc_dev *dev; struct sockaddr_nfc_llcp llcp_addr; int len, ret = 0; if (!addr || alen < offsetofend(struct sockaddr, sa_family) || addr->sa_family != AF_NFC) return -EINVAL; pr_debug(""sk %p addr %p family %d\n"", sk, addr, addr->sa_family); memset(&llcp_addr, 0, sizeof(llcp_addr)); len = min_t(unsigned int, sizeof(llcp_addr), alen); memcpy(&llcp_addr, addr, len); if (llcp_addr.dsap != 0) return -EINVAL; lock_sock(sk); if (sk->sk_state != LLCP_CLOSED) { ret = -EBADFD; goto error; } dev = nfc_get_device(llcp_addr.dev_idx); if (dev == NULL) { ret = -ENODEV; goto error; } local = nfc_llcp_find_local(dev); if (local == NULL) { ret = -ENODEV; goto put_dev; } llcp_sock->dev = dev; llcp_sock->local = nfc_llcp_local_get(local); llcp_sock->nfc_protocol = llcp_addr.nfc_protocol; llcp_sock->service_name_len = min_t(unsigned int, llcp_addr.service_name_len, NFC_LLCP_MAX_SERVICE_NAME); llcp_sock->service_name = kmemdup(llcp_addr.service_name, llcp_sock->service_name_len, GFP_KERNEL); if (!llcp_sock->service_name) { nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; ret = -ENOMEM; goto put_dev; } llcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock); if (llcp_sock->ssap == LLCP_SAP_MAX) { nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; kfree(llcp_sock->service_name); llcp_sock->service_name = NULL; ret = -EADDRINUSE; goto put_dev; } llcp_sock->reserved_ssap = llcp_sock->ssap; nfc_llcp_sock_link(&local->sockets, sk); pr_debug(""Socket bound to SAP %d\n"", llcp_sock->ssap); sk->sk_state = LLCP_BOUND; put_dev: nfc_put_device(dev); error: release_sock(sk); return ret; }"
"static void extract_archive_thread (GSimpleAsyncResult *result, GObject            *object, GCancellable       *cancellable) { ExtractData          *extract_data; LoadData             *load_data; GHashTable           *checked_folders; GHashTable           *created_files; GHashTable           *folders_created_during_extraction; struct archive       *a; struct archive_entry *entry; int                   r; extract_data = g_simple_async_result_get_op_res_gpointer (result); load_data = LOAD_DATA (extract_data); r = create_read_object (load_data, &a); if (r != ARCHIVE_OK) { archive_read_free(a); return; } checked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL); created_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref); folders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL); fr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract); while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) { const char    *pathname; char          *fullpath; const char    *relative_path; GFile         *file; GFile         *parent; GOutputStream *ostream; const void    *buffer; size_t         buffer_size; int64_t        target_offset, actual_offset; GError        *local_error = NULL; __LA_MODE_T    filetype; if (g_cancellable_is_cancelled (cancellable)) break; pathname = archive_entry_pathname (entry); if (! extract_data_get_extraction_requested (extract_data, pathname)) { archive_read_data_skip (a); continue; } fullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (""/"", pathname, NULL); relative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths); if (relative_path == NULL) { archive_read_data_skip (a); continue; } file = g_file_get_child (extract_data->destination, relative_path); if ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL) && (extract_data->skip_older || ! extract_data->overwrite)) { GFileInfo *info; info = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "","" G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, cancellable, &local_error); if (info != NULL) { gboolean skip = FALSE; if (! extract_data->overwrite) { skip = TRUE; } else if (extract_data->skip_older) { GTimeVal modification_time; g_file_info_get_modification_time (info, &modification_time); if (archive_entry_mtime (entry) < modification_time.tv_sec) skip = TRUE; } g_object_unref (info); if (skip) { g_object_unref (file); archive_read_data_skip (a); fr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0); if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { r = ARCHIVE_EOF; break; } continue; } } else { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) { load_data->error = local_error; g_object_unref (info); break; } g_clear_error (&local_error); } } fr_archive_progress_inc_completed_files (load_data->archive, 1); parent = g_file_get_parent (file); if ((parent != NULL) && (g_hash_table_lookup (checked_folders, parent) == NULL) && ! g_file_query_exists (parent, cancellable)) { if (! _g_file_make_directory_with_parents (parent, folders_created_during_extraction, cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = local_error; else g_clear_error (&local_error); } if (load_data->error == NULL) { GFile *grandparent; grandparent = g_object_ref (parent); while (grandparent != NULL) { if (g_hash_table_lookup (checked_folders, grandparent) == NULL) g_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1)); grandparent = g_file_get_parent (grandparent); } } } g_object_unref (parent); filetype = archive_entry_filetype (entry); if (load_data->error == NULL) { const char  *linkname; linkname = archive_entry_hardlink (entry); if (linkname != NULL) { char        *link_fullpath; const char  *relative_path; GFile       *link_file; char        *oldname; char        *newname; int          r; link_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (""/"", linkname, NULL); relative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths); if (relative_path == NULL) { g_free (link_fullpath); archive_read_data_skip (a); continue; } link_file = g_file_get_child (extract_data->destination, relative_path); oldname = g_file_get_path (link_file); newname = g_file_get_path (file); if ((oldname != NULL) && (newname != NULL)) r = link (oldname, newname); else r = -1; if (r == 0) { __LA_INT64_T filesize; if (archive_entry_size_is_set (entry)) filesize = archive_entry_size (entry); else filesize = -1; if (filesize > 0) filetype = AE_IFREG;  } else { char *uri; char *msg; uri = g_file_get_uri (file); msg = g_strdup_printf (""Could not create the hard link %s"", uri); load_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg); g_free (msg); g_free (uri); } g_free (newname); g_free (oldname); g_object_unref (link_file); g_free (link_fullpath); } } if (load_data->error == NULL) { switch (filetype) { case AE_IFDIR: if (! g_file_make_directory (file, cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = g_error_copy (local_error); g_clear_error (&local_error); } if (load_data->error == NULL) g_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data)); archive_read_data_skip (a); break; case AE_IFREG: ostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error); if (ostream == NULL) break; actual_offset = 0; while ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) { gsize bytes_written; if (target_offset > actual_offset) { if (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error)) break; fr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset); actual_offset = target_offset; } if (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error)) break; actual_offset += bytes_written; fr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written); } if ((r == ARCHIVE_EOF) && (target_offset > actual_offset)) _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error); _g_object_unref (ostream); if (r != ARCHIVE_EOF) load_data->error = _g_error_new_from_archive_error (archive_error_string (a)); else g_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data)); break; case AE_IFLNK: if (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = g_error_copy (local_error); g_clear_error (&local_error); } archive_read_data_skip (a); break; default: archive_read_data_skip (a); break; } } g_object_unref (file); g_free (fullpath); if (load_data->error != NULL) break; if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { r = ARCHIVE_EOF; break; } } if (load_data->error == NULL) restore_original_file_attributes (created_files, cancellable); if ((load_data->error == NULL) && (r != ARCHIVE_EOF)) load_data->error = _g_error_new_from_archive_error (archive_error_string (a)); if (load_data->error == NULL) g_cancellable_set_error_if_cancelled (cancellable, &load_data->error); if (load_data->error != NULL) g_simple_async_result_set_from_error (result, load_data->error); g_hash_table_unref (folders_created_during_extraction); g_hash_table_unref (created_files); g_hash_table_unref (checked_folders); archive_read_free (a); extract_data_free (extract_data); }"
"json_t* find_jws(struct tang_keys_info* tki, const char* thp) { if (!tki) { return NULL; } if (thp == NULL) { json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign); if (!jws) { return NULL; } return json_incref(jws); } return find_by_thp(tki, thp); }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli( const void *buf, pj_size_t length) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; PJ_ASSERT_RETURN(buf, PJ_EINVAL); if (length < 12) return PJ_ETOOSMALL; if (hdr->pt != RTCP_PSFB || hdr->count != 1) return PJ_ENOTFOUND; return PJ_SUCCESS; }"
"int URIParser::parse(const char *str, ParsedURI& uri) { uri.state = URI_STATE_INVALID; int start_idx[URI_PART_ELEMENTS] = {0}; int end_idx[URI_PART_ELEMENTS] = {0}; int pre_state = URI_SCHEME;; int i; bool in_ipv6 = false; for (i = 0; str[i]; i++) { if (str[i] == ':') { end_idx[URI_SCHEME] = i++; break; } } if (end_idx[URI_SCHEME] == 0) return -1; if (str[i] == '/' && str[i + 1] == '/') { pre_state = URI_HOST; i += 2; if (str[i] == '[') in_ipv6= true; else start_idx[URI_USERINFO] = i; start_idx[URI_HOST] = i; } else { pre_state = URI_PATH; start_idx[URI_PATH] = i; } bool skip_path = false; if (start_idx[URI_PATH] == 0) { for (; ; i++) { switch (authority_map[(unsigned char)str[i]]) { case 0: continue; case URI_USERINFO: if (str[i + 1] == '[') in_ipv6 = true; end_idx[URI_USERINFO] = i; start_idx[URI_HOST] = i + 1; pre_state = URI_HOST; continue; case URI_HOST: if (str[i - 1] == ']') in_ipv6 = false; if (!in_ipv6) { end_idx[URI_HOST] = i; start_idx[URI_PORT] = i + 1; pre_state = URI_PORT; } continue; case URI_QUERY: end_idx[pre_state] = i; start_idx[URI_QUERY] = i + 1; pre_state = URI_QUERY; skip_path = true; continue; case URI_FRAGMENT: end_idx[pre_state] = i; start_idx[URI_FRAGMENT] = i + 1; end_idx[URI_FRAGMENT] = i + strlen(str + i); pre_state = URI_PART_ELEMENTS; skip_path = true; break; case URI_PATH: if (skip_path) continue; start_idx[URI_PATH] = i; break; case URI_PART_ELEMENTS: skip_path = true; break; } break; } } if (pre_state != URI_PART_ELEMENTS) end_idx[pre_state] = i; if (!skip_path) { pre_state = URI_PATH; for (; str[i]; i++) { if (str[i] == '?') { end_idx[URI_PATH] = i; start_idx[URI_QUERY] = i + 1; pre_state = URI_QUERY; while (str[i + 1]) { if (str[++i] == '#') break; } } if (str[i] == '#') { end_idx[pre_state] = i; start_idx[URI_FRAGMENT] = i + 1; pre_state = URI_FRAGMENT; break; } } end_idx[pre_state] = i + strlen(str + i); } for (int i = 0; i < URI_QUERY; i++) { for (int j = start_idx[i]; j < end_idx[i]; j++) { if (!valid_char[i][(unsigned char)str[j]]) return -1;} } char **dst[URI_PART_ELEMENTS] = {&uri.scheme, &uri.userinfo, &uri.host, &uri.port, &uri.query, &uri.fragment, &uri.path}; for (int i = 0; i < URI_PART_ELEMENTS; i++) { if (end_idx[i] > start_idx[i]) { size_t len = end_idx[i] - start_idx[i]; *dst[i] = (char *)realloc(*dst[i], len + 1); if (*dst[i] == NULL) { uri.state = URI_STATE_ERROR; uri.error = errno; return -1; } if (i == URI_HOST && str[start_idx[i]] == '[') { len -= 2; memcpy(*dst[i], str + start_idx[i] + 1, len); } else memcpy(*dst[i], str + start_idx[i], len); (*dst[i])[len] = '\0'; } else { free(*dst[i]); *dst[i] = NULL; } } uri.state = URI_STATE_SUCCESS; return 0; }"
"static gboolean listener_event(GIOChannel *channel, GIOCondition condition, gpointer user_data) { GDHCPClient *dhcp_client = user_data; struct sockaddr_in dst_addr = { 0 }; struct dhcp_packet packet; struct dhcpv6_packet *packet6 = NULL; uint8_t *message_type = NULL, *client_id = NULL, *option, *server_id = NULL; uint16_t option_len = 0, status = 0; uint32_t xid = 0; gpointer pkt; unsigned char buf[MAX_DHCPV6_PKT_SIZE]; uint16_t pkt_len = 0; int count; int re; if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) { dhcp_client->listener_watch = 0; return FALSE; } if (dhcp_client->listen_mode == L_NONE) return FALSE; pkt = &packet; dhcp_client->status_code = 0; if (dhcp_client->listen_mode == L2) { re = dhcp_recv_l2_packet(&packet, dhcp_client->listener_sockfd, &dst_addr); xid = packet.xid; } else if (dhcp_client->listen_mode == L3) { if (dhcp_client->type == G_DHCP_IPV6) { re = dhcpv6_recv_l3_packet(&packet6, buf, sizeof(buf), dhcp_client->listener_sockfd); if (re < 0) return TRUE; pkt_len = re; pkt = packet6; xid = packet6->transaction_id[0] << 16 | packet6->transaction_id[1] << 8 | packet6->transaction_id[2]; } else { re = dhcp_recv_l3_packet(&packet, dhcp_client->listener_sockfd); xid = packet.xid; } } else if (dhcp_client->listen_mode == L_ARP) { ipv4ll_recv_arp_packet(dhcp_client); return TRUE; } else re = -EIO; if (re < 0) return TRUE; if (!check_package_owner(dhcp_client, pkt)) return TRUE; if (dhcp_client->type == G_DHCP_IPV6) { if (!packet6) return TRUE; count = 0; client_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_CLIENTID, &option_len,&count); if (!client_id || count == 0 || option_len == 0 || memcmp(dhcp_client->duid, client_id, dhcp_client->duid_len) != 0) { debug(dhcp_client, ""client duid error, discarding msg %p/%d/%d"", client_id, option_len, count); return TRUE; } option = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_STATUS_CODE, &option_len, NULL); if (option != 0 && option_len > 0) { status = option[0]<<8 | option[1]; if (status != 0) { debug(dhcp_client, ""error code %d"", status); if (option_len > 2) { gchar *txt = g_strndup( (gchar *)&option[2], option_len - 2); debug(dhcp_client, ""error text: %s"", txt); g_free(txt); } } dhcp_client->status_code = status; } } else { message_type = dhcp_get_option(&packet, DHCP_MESSAGE_TYPE); if (!message_type) return TRUE; } debug(dhcp_client, ""received DHCP packet xid 0x%04x "" ""(current state %d)"", ntohl(xid), dhcp_client->state); switch (dhcp_client->state) { case INIT_SELECTING: if (*message_type != DHCPOFFER) return TRUE; remove_timeouts(dhcp_client); dhcp_client->timeout = 0; dhcp_client->retry_times = 0; option = dhcp_get_option(&packet, DHCP_SERVER_ID); dhcp_client->server_ip = get_be32(option); dhcp_client->requested_ip = ntohl(packet.yiaddr); dhcp_client->state = REQUESTING; dhcp_client->request_bcast = dst_addr.sin_addr.s_addr == INADDR_BROADCAST && g_hash_table_contains(dhcp_client->secs_bcast_hash, GINT_TO_POINTER(packet.secs)); debug(dhcp_client, ""init ip %s secs %hu -> broadcast flag %s"", inet_ntoa(dst_addr.sin_addr), packet.secs, dhcp_client->request_bcast ? ""on"" : ""off""); start_request(dhcp_client); return TRUE; case REBOOTING: if (dst_addr.sin_addr.s_addr == INADDR_BROADCAST) dhcp_client->request_bcast = true; else dhcp_client->request_bcast = false; debug(dhcp_client, ""ip %s -> %sadding broadcast flag"", inet_ntoa(dst_addr.sin_addr), dhcp_client->request_bcast ? """" : ""not ""); case REQUESTING: case RENEWING: case REBINDING: if (*message_type == DHCPACK) { dhcp_client->retry_times = 0; remove_timeouts(dhcp_client); dhcp_client->lease_seconds = get_lease(&packet); get_request(dhcp_client, &packet); switch_listening_mode(dhcp_client, L_NONE); g_free(dhcp_client->assigned_ip); dhcp_client->assigned_ip = get_ip(packet.yiaddr); if (dhcp_client->state == REBOOTING) { option = dhcp_get_option(&packet, DHCP_SERVER_ID); dhcp_client->server_ip = get_be32(option); } if (dhcp_client->lease_available_cb) dhcp_client->lease_available_cb(dhcp_client, dhcp_client->lease_available_data); start_bound(dhcp_client); } else if (*message_type == DHCPNAK) { dhcp_client->retry_times = 0; remove_timeouts(dhcp_client); dhcp_client->timeout = g_timeout_add_seconds_full( G_PRIORITY_HIGH, 3, restart_dhcp_timeout, dhcp_client, NULL); } break; case SOLICITATION: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; if (packet6->message != DHCPV6_REPLY && packet6->message != DHCPV6_ADVERTISE) return TRUE; count = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len,&count); if (!server_id || count != 1 || option_len == 0) { debug(dhcp_client, ""server duid error, discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; if (packet6->message == DHCPV6_REPLY) { uint8_t *rapid_commit; count = 0; option_len = 0; rapid_commit = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_RAPID_COMMIT, &option_len, &count); if (!rapid_commit || option_len != 0 || count != 1) return TRUE; } switch_listening_mode(dhcp_client, L_NONE); if (dhcp_client->status_code == 0) get_dhcpv6_request(dhcp_client, packet6, pkt_len, &dhcp_client->status_code); if (packet6->message == DHCPV6_ADVERTISE) { if (dhcp_client->advertise_cb) dhcp_client->advertise_cb(dhcp_client, dhcp_client->advertise_data); return TRUE; } if (dhcp_client->solicitation_cb) { dhcp_client->solicitation_cb(dhcp_client, dhcp_client->solicitation_data); return TRUE; } break; case REBIND: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len,&count); if (!dhcp_client->server_duid && server_id && count == 1) { dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; } case INFORMATION_REQ: case REQUEST: case RENEW: case RELEASE: case CONFIRM: case DECLINE: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; if (packet6->message != DHCPV6_REPLY) return TRUE; count = 0; option_len = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len, &count); if (!server_id || count != 1 || option_len == 0 || (dhcp_client->server_duid_len > 0 && memcmp(dhcp_client->server_duid, server_id, dhcp_client->server_duid_len) != 0)) { debug(dhcp_client, ""server duid error, discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } switch_listening_mode(dhcp_client, L_NONE); get_dhcpv6_request(dhcp_client, packet6, pkt_len, &dhcp_client->status_code); if (dhcp_client->information_req_cb) { dhcp_client->information_req_cb(dhcp_client, dhcp_client->information_req_data); return TRUE; } if (dhcp_client->request_cb) { dhcp_client->request_cb(dhcp_client, dhcp_client->request_data); return TRUE; } if (dhcp_client->renew_cb) { dhcp_client->renew_cb(dhcp_client, dhcp_client->renew_data); return TRUE; } if (dhcp_client->rebind_cb) { dhcp_client->rebind_cb(dhcp_client, dhcp_client->rebind_data); return TRUE; } if (dhcp_client->release_cb) { dhcp_client->release_cb(dhcp_client, dhcp_client->release_data); return TRUE; } if (dhcp_client->decline_cb) { dhcp_client->decline_cb(dhcp_client, dhcp_client->decline_data); return TRUE; } if (dhcp_client->confirm_cb) { count = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len, &count); if (!server_id || count != 1 || option_len == 0) { debug(dhcp_client, ""confirm server duid error, "" ""discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; dhcp_client->confirm_cb(dhcp_client, dhcp_client->confirm_data); return TRUE; } break; default: break; } debug(dhcp_client, ""processed DHCP packet (new state %d)"", dhcp_client->state); return TRUE; }"
"void init_xml_relax_ng() { VALUE nokogiri = rb_define_module(""Nokogiri""); VALUE xml = rb_define_module_under(nokogiri, ""XML""); VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema); cNokogiriXmlRelaxNG = klass; rb_define_singleton_method(klass, ""read_memory"", read_memory, 1); rb_define_singleton_method(klass, ""from_document"", from_document, 1); rb_define_private_method(klass, ""validate_document"", validate_document, 1); }"
"static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor, uint8_t *buf) { if_descriptor->bLength            = *(uint8_t *)(buf + 0); if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1); if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2); if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3); if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4); if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5); if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6); if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7); if_descriptor->iInterface         = *(uint8_t *)(buf + 8); }"
"static ogs_tlv_t *ogs_tlv_parse_block_desc(uint32_t length, void *data, uint8_t msg_mode, ogs_tlv_desc_t *desc) { uint8_t *pos = data; uint8_t *blk = data; ogs_tlv_t *root = NULL; ogs_tlv_t *prev = NULL; ogs_tlv_t *curr = NULL; root = curr = ogs_tlv_get(); ogs_assert(curr); pos = tlv_get_element_desc(curr, pos, msg_mode, desc); ogs_assert(pos); while(pos - blk < length) { prev = curr; curr = ogs_tlv_get(); ogs_assert(curr); prev->next = curr; pos = tlv_get_element_desc(curr, pos, msg_mode, desc); ogs_assert(pos); } ogs_assert(length == (pos - blk)); return root; }"
"static void * helper_thread (void *arg) { while (1) { union notify_data data; ssize_t n = __recv (netlink_socket, &data, sizeof (data), MSG_NOSIGNAL | MSG_WAITALL); if (n < NOTIFY_COOKIE_LEN) continue; if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_WOKENUP) { pthread_t th; if (__pthread_create (&th, data.attr, notification_function, &data) == 0) (void) __pthread_barrier_wait (&notify_barrier); } else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED) { __pthread_attr_destroy (data.attr); free (data.attr); } } return NULL; }"
"int parse_cmd_address(exarg_T *eap, char **errormsg, int silent) { intaddress_count = 1; linenr_Tlnum; intneed_check_cursor = FALSE; intret = FAIL; for (;;) { eap->line1 = eap->line2; eap->line2 = default_address(eap); eap->cmd = skipwhite(eap->cmd); lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent, eap->addr_count == 0, address_count++); if (eap->cmd == NULL)    goto theend; if (lnum == MAXLNUM) { if (*eap->cmd == '%')       { ++eap->cmd; switch (eap->addr_type) { case ADDR_LINES: case ADDR_OTHER: eap->line1 = 1; eap->line2 = curbuf->b_ml.ml_line_count; break; case ADDR_LOADED_BUFFERS: { buf_T*buf = firstbuf; while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_next; eap->line1 = buf->b_fnum; buf = lastbuf; while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_prev; eap->line2 = buf->b_fnum; break; } case ADDR_BUFFERS: eap->line1 = firstbuf->b_fnum; eap->line2 = lastbuf->b_fnum; break; case ADDR_WINDOWS: case ADDR_TABS: if (IS_USER_CMDIDX(eap->cmdidx)) { eap->line1 = 1; eap->line2 = eap->addr_type == ADDR_WINDOWS ? LAST_WIN_NR : LAST_TAB_NR; } else { *errormsg = _(e_invalid_range); goto theend; } break; case ADDR_TABS_RELATIVE: case ADDR_UNSIGNED: case ADDR_QUICKFIX: *errormsg = _(e_invalid_range); goto theend; case ADDR_ARGUMENTS: if (ARGCOUNT == 0) eap->line1 = eap->line2 = 0; else { eap->line1 = 1; eap->line2 = ARGCOUNT; } break; case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX eap->line1 = 1; eap->line2 = qf_get_valid_size(eap); if (eap->line2 == 0) eap->line2 = 1; #endif break; case ADDR_NONE: break; } ++eap->addr_count; } else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL) { pos_T    *fp; if (eap->addr_type != ADDR_LINES) { *errormsg = _(e_invalid_range); goto theend; } ++eap->cmd; if (!eap->skip) { fp = getmark('<', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line1 = fp->lnum; fp = getmark('>', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line2 = fp->lnum; ++eap->addr_count; } } } else eap->line2 = lnum; eap->addr_count++; if (*eap->cmd == ';') { if (!eap->skip) { curwin->w_cursor.lnum = eap->line2; if (eap->line2 > 0) check_cursor(); need_check_cursor = TRUE; } } else if (*eap->cmd != ',') break; ++eap->cmd; } if (eap->addr_count == 1) { eap->line1 = eap->line2; if (lnum == MAXLNUM) eap->addr_count = 0; } ret = OK; theend: if (need_check_cursor) check_cursor(); return ret; }"
"rdpBitmapCache* bitmap_cache_new(rdpSettings* settings) { int i; rdpBitmapCache* bitmapCache; bitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache)); if (!bitmapCache) return NULL; bitmapCache->settings = settings; bitmapCache->update = ((freerdp*)settings->instance)->update; bitmapCache->context = bitmapCache->update->context; bitmapCache->maxCells = settings->BitmapCacheV2NumCells; bitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL)); if (!bitmapCache->cells) goto fail; for (i = 0; i < (int)bitmapCache->maxCells; i++) { bitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries; bitmapCache->cells[i].entries = (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*)); if (!bitmapCache->cells[i].entries) goto fail; } return bitmapCache; fail: if (bitmapCache->cells) { for (i = 0; i < (int)bitmapCache->maxCells; i++) free(bitmapCache->cells[i].entries); } free(bitmapCache); return NULL; }"
"Status Conv2DShapeImpl(shape_inference::InferenceContext* c, bool supports_explicit_padding) { string data_format_str, filter_format_str; if (!c->GetAttr(""data_format"", &data_format_str).ok()) { data_format_str = ""NHWC""; } if (!c->GetAttr(""filter_format"", &filter_format_str).ok()) { filter_format_str = ""HWIO""; } TensorFormat data_format; if (!FormatFromString(data_format_str, &data_format)) { return errors::InvalidArgument(""Invalid data format string: "", data_format_str); } FilterTensorFormat filter_format; if (!FilterFormatFromString(filter_format_str, &filter_format)) { return errors::InvalidArgument(""Invalid filter format string: "", filter_format_str); } constexpr int num_spatial_dims = 2; const int rank = GetTensorDimsFromSpatialDims(num_spatial_dims, data_format); ShapeHandle conv_input_shape; TF_RETURN_IF_ERROR(c->WithRank(c->input(0), rank, &conv_input_shape)); TF_RETURN_IF_ERROR(CheckFormatConstraintsOnShape( data_format, conv_input_shape, ""conv_input"", c)); ShapeHandle filter_shape; TF_RETURN_IF_ERROR(c->WithRank(c->input(1), rank, &filter_shape)); TF_RETURN_IF_ERROR( CheckFormatConstraintsOnShape(data_format, filter_shape, ""filter"", c)); std::vector<int32> dilations; TF_RETURN_IF_ERROR(c->GetAttr(""dilations"", &dilations)); if (dilations.size() != 4) { return errors::InvalidArgument( ""Conv2D requires the dilation attribute to contain 4 values, but got: "", dilations.size()); } std::vector<int32> strides; TF_RETURN_IF_ERROR(c->GetAttr(""strides"", &strides)); if (strides.size() != 4) { return errors::InvalidArgument(""Conv2D on data format "", data_format_str, "" requires the stride attribute to contain"" "" 4 values, but got: "", strides.size()); } const int32_t stride_rows = GetTensorDim(strides, data_format, 'H'); const int32_t stride_cols = GetTensorDim(strides, data_format, 'W'); const int32_t dilation_rows = GetTensorDim(dilations, data_format, 'H'); const int32_t dilation_cols = GetTensorDim(dilations, data_format, 'W'); DimensionHandle batch_size_dim; DimensionHandle input_depth_dim; gtl::InlinedVector<DimensionHandle, 2> input_spatial_dims(2); TF_RETURN_IF_ERROR(DimensionsFromShape( conv_input_shape, data_format, &batch_size_dim, absl::MakeSpan(input_spatial_dims), &input_depth_dim, c)); DimensionHandle output_depth_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'O')); DimensionHandle filter_rows_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'H')); DimensionHandle filter_cols_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'W')); DimensionHandle filter_input_depth_dim; if (filter_format == FORMAT_OIHW_VECT_I) { TF_RETURN_IF_ERROR(c->Multiply( c->Dim(filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'I')), c->Dim(filter_shape, GetFilterTensorInnerInputChannelsDimIndex(rank, filter_format)), &filter_input_depth_dim)); } else { filter_input_depth_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'I')); } if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) { int64_t input_depth_value = c->Value(input_depth_dim), filter_input_depth_value = c->Value(filter_input_depth_dim); if (input_depth_value % filter_input_depth_value != 0) return errors::InvalidArgument( ""Depth of input ("", input_depth_value, "") is not a multiple of input depth of filter ("", filter_input_depth_value, "")""); if (input_depth_value != filter_input_depth_value) { int64_t num_groups = input_depth_value / filter_input_depth_value; if (c->ValueKnown(output_depth_dim)) { int64_t output_depth_value = c->Value(output_depth_dim); if (output_depth_value % num_groups != 0) return errors::InvalidArgument( ""Depth of output ("", output_depth_value, "") is not a multiple of the number of groups ("", num_groups, "")""); } } } Padding padding; TF_RETURN_IF_ERROR(c->GetAttr(""padding"", &padding)); std::vector<int64> explicit_paddings; if (supports_explicit_padding) { Status s = c->GetAttr(""explicit_paddings"", &explicit_paddings); if (!s.ok() && !errors::IsNotFound(s)) { return s; } TF_RETURN_IF_ERROR(CheckValidPadding(padding, explicit_paddings, 4, data_format)); } else { CHECK(padding != Padding::EXPLICIT);    } DimensionHandle output_rows, output_cols; int64_t pad_rows_before = -1, pad_rows_after = -1; int64_t pad_cols_before = -1, pad_cols_after = -1; if (padding == Padding::EXPLICIT) { GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_rows_before, &pad_rows_after); GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_cols_before, &pad_cols_after); } TF_RETURN_IF_ERROR(GetWindowedOutputSizeFromDimsV2( c, input_spatial_dims[0], filter_rows_dim, dilation_rows, stride_rows, padding, pad_rows_before, pad_rows_after, &output_rows)); TF_RETURN_IF_ERROR(GetWindowedOutputSizeFromDimsV2( c, input_spatial_dims[1], filter_cols_dim, dilation_cols, stride_cols, padding, pad_cols_before, pad_cols_after, &output_cols)); absl::optional<DimensionHandle> vect_size; if (data_format == FORMAT_NCHW_VECT_C) { vect_size.emplace(c->Dim(conv_input_shape, GetTensorInnerFeatureDimIndex(rank, data_format))); } ShapeHandle output_shape; TF_RETURN_IF_ERROR(ShapeFromDimensions( batch_size_dim, {output_rows, output_cols}, output_depth_dim, data_format, vect_size, c, &output_shape)); c->set_output(0, output_shape); return Status::OK(); }"
"static int processCropSelections(struct image_data *image, struct crop_mask *crop, unsigned char **read_buff_ptr, struct buffinfo seg_buffs[]) { int i; uint32_t width, length, total_width, total_length; tsize_t cropsize; unsigned char *crop_buff = NULL; unsigned char *read_buff = NULL; unsigned char *next_buff = NULL; tsize_t prev_cropsize = 0; read_buff = *read_buff_ptr; if (crop->img_mode == COMPOSITE_IMAGES) { cropsize = crop->bufftotal; crop_buff = seg_buffs[0].buffer; if (!crop_buff) crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!next_buff) { _TIFFfree(crop_buff); crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(""processCropSelections"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = cropsize; if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0) return (1); if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: image->photometric = crop->photometric; break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG: if (invertImage(image->photometric, image->spp, image->bps, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to invert colorspace for composite "" ""regions""); return (-1); } if (crop->photometric == INVERT_DATA_AND_TAG) { switch (image->photometric) { case PHOTOMETRIC_MINISWHITE: image->photometric = PHOTOMETRIC_MINISBLACK; break; case PHOTOMETRIC_MINISBLACK: image->photometric = PHOTOMETRIC_MINISWHITE; break; default: break; } } break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to mirror composite regions %s"", (crop->rotation == MIRROR_HORIZ) ? ""horizontally"" : ""vertically""); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { size_t rot_buf_size = 0; if (rotateImage(crop->rotation, image, &crop->combined_width, &crop->combined_length, &crop_buff, &rot_buf_size)) { TIFFError(""processCropSelections"", ""Failed to rotate composite regions by %"" PRIu32 "" degrees"", crop->rotation); return (-1); } seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = rot_buf_size; } } else  { total_width = total_length = 0; for (i = 0; i < crop->selections; i++) { cropsize = crop->bufftotal; crop_buff = seg_buffs[i].buffer; if (!crop_buff) crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); else { prev_cropsize = seg_buffs[i].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc( crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!next_buff) { _TIFFfree(crop_buff); crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(""processCropSelections"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = cropsize; if (extractSeparateRegion(image, crop, read_buff, crop_buff, i)) { TIFFError(""processCropSelections"", ""Unable to extract cropped region %d from image"", i); return (-1); } width = crop->regionlist[i].width; length = crop->regionlist[i].length; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: image->photometric = crop->photometric; break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG: if (invertImage(image->photometric, image->spp, image->bps, width, length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to invert colorspace for region""); return (-1); } if (crop->photometric == INVERT_DATA_AND_TAG) { switch (image->photometric) { case PHOTOMETRIC_MINISWHITE: image->photometric = PHOTOMETRIC_MINISBLACK; break; case PHOTOMETRIC_MINISBLACK: image->photometric = PHOTOMETRIC_MINISWHITE; break; default: break; } } break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror, width, length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to mirror crop region %s"", (crop->rotation == MIRROR_HORIZ) ? ""horizontally"" : ""vertically""); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { size_t rot_buf_size = 0; if (rotateImage( crop->rotation, image, &crop->regionlist[i].width, &crop->regionlist[i].length, &crop_buff, &rot_buf_size)) { TIFFError(""processCropSelections"", ""Failed to rotate crop region by %"" PRIu16 "" degrees"", crop->rotation); return (-1); } total_width += crop->regionlist[i].width; total_length += crop->regionlist[i].length; crop->combined_width = total_width; crop->combined_length = total_length; seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = rot_buf_size; } }  }      return (0); }"
void btf_dump__free(struct btf_dump *d) { int i; if (IS_ERR_OR_NULL(d)) return; free(d->type_states); if (d->cached_names) { for (i = 0; i <= d->last_id; i++) { if (d->cached_names[i]) free((void *)d->cached_names[i]); } } free(d->cached_names); free(d->emit_queue); free(d->decl_stack); hashmap__free(d->type_names); hashmap__free(d->ident_names); free(d); }
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"ResponsePtr Server::ServeStatic(RequestPtr request) { assert(request->method() == methods::kGet); if (doc_root_.empty()) { LOG_INFO(""The doc root was not specified""); return {}; } fs::path path = doc_root_ / request->url().path(); try { auto body = std::make_shared<FileBody>(path, file_chunk_size_); auto response = std::make_shared<Response>(Status::kOK); std::string extension = path.extension().string(); response->SetContentType(media_types::FromExtension(extension), """"); response->SetBody(body, true); return response; } catch (const Error& error) { LOG_ERRO(""File error: %s"", error.message().c_str()); return {}; } }"
"int vc_allocate(unsigned int currcons) { struct vt_notifier_param param; struct vc_data *vc; WARN_CONSOLE_UNLOCKED(); if (currcons >= MAX_NR_CONSOLES) return -ENXIO; if (vc_cons[currcons].d) return 0; param.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL); if (!vc) return -ENOMEM; vc_cons[currcons].d = vc; tty_port_init(&vc->port); INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK); visual_init(vc, currcons, 1); if (!*vc->vc_uni_pagedir_loc) con_set_default_unimap(vc); vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL); if (!vc->vc_screenbuf) goto err_free; if (global_cursor_default == -1) global_cursor_default = 1; vc_init(vc, vc->vc_rows, vc->vc_cols, 1); vcs_make_sysfs(currcons); atomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param); return 0; err_free: visual_deinit(vc); kfree(vc); vc_cons[currcons].d = NULL; return -ENOMEM; }"
"struct ngiflibSDL_animation * SDL_LoadAnimatedGif(const char * file) { SDL_Surface * surface; struct ngiflib_gif * gif; FILE *fgif; int err,i; u8 * pdst, * psrc; u8 * p = NULL; #ifdef NGIFLIB_NO_FILE u8 * buffer; long filesize; #endif  int image_count = 0; int image_count_max = 50; struct ngiflibSDL_animation * animation = NULL; struct ngiflib_rgb * current_palette = NULL; int current_palette_size = 0; fgif = fopen(file, ""rb""); if(fgif==NULL) return NULL; gif = (struct ngiflib_gif *)ngiflib_malloc(sizeof(struct ngiflib_gif)); #ifdef EXTRA_MALLOC_CHECK if(gif == NULL) { return NULL; } #endif  ngiflib_memset(gif, 0, sizeof(struct ngiflib_gif)); #ifdef NGIFLIB_NO_FILE fseek(fgif, 0, SEEK_END); filesize = ftell(fgif); fseek(fgif, 0, SEEK_SET); buffer = malloc(filesize); if(buffer == NULL) { GifDestroy(gif); return NULL; } fread(buffer, 1, filesize, fgif); gif->input.buffer.bytes = buffer; gif->input.buffer.count = (unsigned long)filesize; gif->mode = NGIFLIB_MODE_FROM_MEM | NGIFLIB_MODE_INDEXED; #else  gif->input.file = fgif; gif->mode = NGIFLIB_MODE_FROM_FILE | NGIFLIB_MODE_INDEXED; #ifdef NGIFLIBSDL_LOG gif->log = stdout; #endif  #endif  while((err = LoadGif(gif)) == 1) { if(animation == NULL) { animation = ngiflib_malloc(sizeof(struct ngiflibSDL_animation) + image_count_max*sizeof(struct ngiflibSDL_image)); if(animation == NULL) return NULL; } else if(image_count >= image_count_max) { image_count_max += 50; struct ngiflibSDL_animation * tmp; tmp = realloc(animation, sizeof(struct ngiflibSDL_animation) + image_count_max*sizeof(struct ngiflibSDL_image)); if(tmp == NULL) { fprintf(stderr, ""realloc() failed, cannot decode more images\n""); break; } animation = tmp; } p = gif->frbuff.p8; surface = SDL_CreateRGBSurface(SDL_SWSURFACE | SDL_SRCCOLORKEY, gif->width, gif->height, 8, 0,0,0,0); SDL_LockSurface(surface); if(gif->palette != gif->cur_img->palette) { current_palette = gif->cur_img->palette; current_palette_size = (1 << gif->cur_img->localpalbits); } else if(current_palette == NULL) { current_palette = gif->palette; current_palette_size = gif->ncolors; } for(i = 0; i < current_palette_size; i++) { surface->format->palette->colors[i].r = current_palette[i].r; surface->format->palette->colors[i].g = current_palette[i].g; surface->format->palette->colors[i].b = current_palette[i].b; } for(; i < gif->ncolors; i++) { surface->format->palette->colors[i].r = gif->palette[i].r; surface->format->palette->colors[i].g = gif->palette[i].g; surface->format->palette->colors[i].b = gif->palette[i].b; } printf(""\n""); psrc = p; pdst = surface->pixels; for(i=0; i<gif->height; i++) { ngiflib_memcpy(pdst, psrc, gif->width); pdst += surface->pitch; psrc += gif->width; } SDL_UnlockSurface(surface); animation->images[image_count].delay_time = -1; if(gif->cur_img->gce.gce_present) { animation->images[image_count].delay_time = gif->cur_img->gce.delay_time; } animation->images[image_count].surface = surface; image_count++; } fclose(fgif); #ifdef NGIFLIB_NO_FILE free(buffer); #endif  GifDestroy(gif); if(animation) animation->image_count = image_count; return animation; }"
"void SnippetContext_t::BuildExcerpt ( ExcerptQuery_t & tOptions, const CSphIndex * pIndex ) const { auto pStripper = m_tStripper.Ptr (); CSphString &sError = tOptions.m_sError; tOptions.m_dSeparators.Resize ( 0 ); if ( tOptions.m_sStripMode==""retain"" && !( tOptions.m_iLimit==0 && tOptions.m_iLimitPassages==0 && tOptions.m_iLimitWords==0 ) ) { sError = ""html_strip_mode=retain requires that all limits are zero""; return; } auto * pData = const_cast<char*> ( tOptions.m_sSource.cstr() ); CSphFixedVector<char> pBuffer { 0 }; if ( tOptions.m_uFilesMode ) { CSphAutofile tFile; CSphString sFilename; sFilename.SetSprintf ( ""%s%s"", g_sSnippetsFilePrefix.cstr(), tOptions.m_sSource.scstr() ); if ( !sFilename.IsEmpty () && tFile.Open ( sFilename.cstr(), SPH_O_READ, sError )<0 ) return; else if ( tOptions.m_sSource.IsEmpty() ) { sError.SetSprintf ( ""snippet file name is empty"" ); return; } if ( tFile.GetSize()+1>=(SphOffset_t)INT_MAX ) { sError.SetSprintf ( ""%s too big for snippet (over 2 GB)"", pData ); return; } auto iFileSize = (int)tFile.GetSize(); if ( iFileSize<0 ) return; pBuffer.Reset ( iFileSize+1 ); if ( !tFile.Read ( pBuffer.Begin(), iFileSize, sError ) ) return; pData = pBuffer.Begin(); pData[iFileSize] = '\0'; } if ( pStripper && ( tOptions.m_sStripMode==""strip"" || tOptions.m_sStripMode==""index"" ) ) pStripper->Strip ( (BYTE*)pData ); if ( tOptions.m_sStripMode!=""retain"" ) pStripper = NULL; int iDataLen = pData ? strlen ( pData ) : 0; DoHighlighting ( tOptions, pIndex->GetSettings(), m_tExtQuery, m_eExtQuerySPZ, pData, iDataLen, m_pDict, m_pTokenizer, pStripper, m_pQueryTokenizer, tOptions.m_dRes, tOptions.m_dSeparators ); }"
"void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount) { #ifdef J9_PROJECT_SPECIFIC if (trace()) traceMsg(comp(), ""PREX:      [%p] %s %s\n"", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug())); if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver()) { if (trace()) traceMsg(comp(), ""PREX:        - First arg is not receiver\n""); return; } bool  isInterface             = false; ParmInfo           tmpInfo;  tmpInfo.clear(); ParmInfo           *receiverInfo = &tmpInfo; TR::Symbol          *receiverSymbol = NULL; bool               receiverFromParm = false; int32_t            receiverParmOrdinal = -1; ParmInfo *existingInfo = NULL; TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol(); TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL; if (!resolvedMethod) { if (methodSymbol->isInterface()) { isInterface = true; } else { if (trace()) traceMsg(comp(), ""PREX:        - Unresolved\n""); return; } } TR::Node *receiver = node->getChild(node->getFirstArgumentIndex()); if (receiver->getOpCode().isLoadDirect()) { existingInfo = getSuitableParmInfo(receiver); if (!existingInfo) { if (trace()) traceMsg(comp(), ""PREX:        - No parm info for receiver\n""); return; } receiverInfo = existingInfo; receiverFromParm = true; receiverSymbol = receiver->getSymbolReference()->getSymbol(); receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal(); if (methodSymbol->isVirtual() || methodSymbol->isInterface()) { if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol()) { if (trace()) traceMsg(comp(), ""PREX:        - newInstancePrototype\n""); return; } if (trace()) traceMsg(comp(), ""PREX:        Receiver is %p incoming Parm %d parmInfo %p\n"", receiver, receiverParmOrdinal, existingInfo); } } if (receiver->getSymbolReference() && receiver->getSymbolReference()->hasKnownObjectIndex() && !comp()->isOutOfProcessCompilation() ) { if (trace()) traceMsg(comp(), ""PREX:          Receiver is obj%d\n"", receiver->getSymbolReference()->getKnownObjectIndex()); receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex()); receiverInfo->setClassIsFixed(); TR::KnownObjectTable *knot = comp()->getKnownObjectTable(); { TR::ClassTableCriticalSection setClass(comp()->fe()); receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex()))); } } if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod)) return; if (methodSymbol->isComputed()) { #ifdef J9_PROJECT_SPECIFIC if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex()) specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this); if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen()) return; #endif } else if (!isInterface && receiverInfo->classIsFixed()) { devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()); } else if (!isInterface && receiverInfo->classIsCurrentlyFinal() && comp()->ilGenRequest().details().supportsInvalidation()) { TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp()); bool canDevirtualize = true; if (comp()->getMethodHotness() == warm && classInfo && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) canDevirtualize = false; if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass())) { if (trace()) traceMsg(comp(), ""devirtualize with assumption\n""); receiverInfo->setClassIsFixed(); if (_isOutermostMethod && receiverFromParm) { receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass()); } else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo()) { TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo(); TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal); if (arg && !(arg->classIsFixed() && arg->getClass())) { arg->setClassIsFixed(receiverInfo->getClass()); } } TR_ASSERT(receiverInfo->getClass(), ""Currently final classes must have a valid class pointer""); bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass()); if (classInfo && inc) classInfo->incNumPrexAssumptions(); } } else if (receiverFromParm) { if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract()) { bool addAssumptions = false; TR_PersistentMethodInfo *callInfo = NULL; if (comp()->ilGenRequest().details().supportsInvalidation()) { addAssumptions = true; if ((comp()->getMethodHotness() == warm) && (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) && callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) addAssumptions = false; } if (addAssumptions && performTransformation(comp(), ""%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\n"", optDetailString(), node, receiverParmOrdinal, receiverSymbol)) { if (trace()) traceMsg(comp(), ""secs devirtualizing invoke on preexistent argument %d in %s\n"", receiverParmOrdinal, comp()->signature()); node->devirtualizeCall(treeTop); bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod); if (callInfo && inc) callInfo->incNumPrexAssumptions(); } } else if (receiverInfo->getClass()) { #ifdef J9_PROJECT_SPECIFIC TR::ClassTableCriticalSection processIndirectCall(comp()->fe()); TR::SymbolReference *symRef = node->getSymbolReference(); TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable(); TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol(); if (methSymbol->isInterface() || methodSymbol) { TR_ResolvedMethod * method = NULL; bool newMethod = true; TR::Recompilation *recompInfo = comp()->getRecompilationInfo(); if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp())) { } else if (methSymbol->isInterface()) { if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000) method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp()); } else { if (resolvedMethod->isAbstract()) method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp()); else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp())) { method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset()); newMethod = false; } } if (method && !method->virtualMethodIsOverridden()) { TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp()); bool addAssumptions = false; if (comp()->ilGenRequest().details().supportsInvalidation()) { addAssumptions = true; if ((comp()->getMethodHotness() == warm) && classInfo && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) addAssumptions = false; if (classInfo && addAssumptions) { TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory()); TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp()); ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses); for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext()) { if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) { addAssumptions = false; break; } } } } if (addAssumptions && performTransformation(comp(), ""%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\n"", optDetailString(), node, receiverParmOrdinal, receiverSymbol)) { if (newMethod || !method->isSameMethod(resolvedMethod)) { TR::SymbolReference *newSymRef = getSymRefTab()->findOrCreateMethodSymbol (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual); newSymRef->copyAliasSets(symRef, getSymRefTab()); int32_t offset = -1; if (methSymbol->isInterface()) offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex()); else offset = symRef->getOffset(); newSymRef->setOffset(offset); node->setSymbolReference(newSymRef); } node->devirtualizeCall(treeTop); if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK) TR::Node::recreate(treeTop->getNode(), TR::treetop); else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK) TR::Node::recreate(treeTop->getNode(), TR::NULLCHK); bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass()); if (classInfo) { classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID()); if (doInc) classInfo->incNumPrexAssumptions(); TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory()); TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp()); ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses); for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext()) { TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId(); subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID()); if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass)) subClassInfo->incNumPrexAssumptions(); } } _success = true; } else { return; } } else { return; } } #endif } } if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface) { TR::SymbolReference *symRef = node->getSymbolReference(); int32_t offset = symRef->getOffset(); TR_ResolvedMethod *originalResolvedMethod = resolvedMethod; TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass(); bool canRefine = true; if (originalClazz != receiverInfo->getClass()) { TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true); if (isInstance == TR_yes) canRefine = false; isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true); if (isInstance == TR_no) canRefine = false; } TR_ResolvedMethod *resolvedMethod = NULL; if (canRefine) resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset); if (resolvedMethod) { if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod)) { TR::SymbolReference * newSymRef = _peekingSymRefTab->findOrCreateMethodSymbol( symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual); newSymRef->copyAliasSets(symRef, _peekingSymRefTab); newSymRef->setOffset(offset); node->setSymbolReference(newSymRef); } } } #endif }"
"int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns) { struct kvm_lapic *apic; ASSERT(vcpu != NULL); apic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT); if (!apic) goto nomem; vcpu->arch.apic = apic; apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT); if (!apic->regs) { printk(KERN_ERR ""malloc apic regs error for vcpu %x\n"", vcpu->vcpu_id); goto nomem_free_apic; } apic->vcpu = vcpu; hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD); apic->lapic_timer.timer.function = apic_timer_fn; if (timer_advance_ns == -1) { apic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT; lapic_timer_advance_dynamic = true; } else { apic->lapic_timer.timer_advance_ns = timer_advance_ns; lapic_timer_advance_dynamic = false; } static_branch_inc(&apic_sw_disabled.key);  kvm_iodevice_init(&apic->dev, &apic_mmio_ops); return 0; nomem_free_apic: kfree(apic); vcpu->arch.apic = NULL; nomem: return -ENOMEM; }"
"void * ulfius_uri_logger (void * cls, const char * uri) { struct connection_info_struct * con_info = o_malloc (sizeof (struct connection_info_struct)); UNUSED(cls); if (con_info != NULL) { con_info->callback_first_iteration = 1; con_info->u_instance = NULL; u_map_init(&con_info->map_url_initial); con_info->request = o_malloc(sizeof(struct _u_request)); if (con_info->request == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info->request""); o_free(con_info); return NULL; } if (NULL == con_info->request || ulfius_init_request(con_info->request) != U_OK) { ulfius_clean_request_full(con_info->request); o_free(con_info); return NULL; } con_info->request->http_url = o_strdup(uri); if (o_strchr(uri, '?') != NULL) { con_info->request->url_path = o_strndup(uri, o_strchr(uri, '?') - uri); } else { con_info->request->url_path = o_strdup(uri); } if (con_info->request->http_url == NULL || con_info->request->url_path == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info->request->http_url or con_info->request->url_path""); ulfius_clean_request_full(con_info->request); o_free(con_info); return NULL; } con_info->max_post_param_size = 0; } else { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info""); } return con_info; }"
"int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is) { struct ext4_xattr_ibody_header *header; struct ext4_xattr_search *s = &is->s; int error; if (EXT4_I(inode)->i_extra_isize == 0) return -ENOSPC; error = ext4_xattr_set_entry(i, s, handle, inode, false ); if (error) return error; header = IHDR(inode, ext4_raw_inode(&is->iloc)); if (!IS_LAST_ENTRY(s->first)) { header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC); ext4_set_inode_state(inode, EXT4_STATE_XATTR); } else { header->h_magic = cpu_to_le32(0); ext4_clear_inode_state(inode, EXT4_STATE_XATTR); } return 0; }"
"int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags) { struct sock *sk = sock->sk; int err; if (addr_len < sizeof(uaddr->sa_family)) return -EINVAL; if (uaddr->sa_family == AF_UNSPEC) return sk->sk_prot->disconnect(sk, flags); if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) { err = sk->sk_prot->pre_connect(sk, uaddr, addr_len); if (err) return err; } if (data_race(!inet_sk(sk)->inet_num) && inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->connect(sk, uaddr, addr_len); }"
"void isis_notif_version_skew(const struct isis_circuit *circuit, uint8_t version, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:version-skew""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/protocol-version"", xpath); data = yang_data_new_uint8(xpath_arg, version); listnode_add(arguments, data); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_version_skew, circuit, version, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"static void psi_trigger_destroy(struct kref *ref) { struct psi_trigger *t = container_of(ref, struct psi_trigger, refcount); struct psi_group *group = t->group; struct task_struct *task_to_destroy = NULL; if (static_branch_likely(&psi_disabled)) return; wake_up_interruptible(&t->event_wait); mutex_lock(&group->trigger_lock); if (!list_empty(&t->node)) { struct psi_trigger *tmp; u64 period = ULLONG_MAX; list_del(&t->node); group->nr_triggers[t->state]--; if (!group->nr_triggers[t->state]) group->poll_states &= ~(1 << t->state); list_for_each_entry(tmp, &group->triggers, node) period = min(period, div_u64(tmp->win.size, UPDATES_PER_WINDOW)); group->poll_min_period = period; if (group->poll_states == 0) { group->polling_until = 0; task_to_destroy = rcu_dereference_protected( group->poll_task, lockdep_is_held(&group->trigger_lock)); rcu_assign_pointer(group->poll_task, NULL); del_timer(&group->poll_timer); } } mutex_unlock(&group->trigger_lock); synchronize_rcu(); if (task_to_destroy) { kthread_stop(task_to_destroy); } kfree(t); }"
"void *malloc_wrapper(size_t size, void *caller) { void *ptr = NULL; #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_lock(); #endif #ifdef MBED_HEAP_STATS_ENABLED malloc_stats_mutex->lock(); alloc_info_t *alloc_info = (alloc_info_t *)SUPER_MALLOC(size + sizeof(alloc_info_t)); if (alloc_info != NULL) { alloc_info->size = size; alloc_info->signature = MBED_HEAP_STATS_SIGNATURE; ptr = (void *)(alloc_info + 1); heap_stats.current_size += size; heap_stats.total_size += size; heap_stats.alloc_cnt += 1; if (heap_stats.current_size > heap_stats.max_size) { heap_stats.max_size = heap_stats.current_size; } heap_stats.overhead_size += MALLOC_HEAP_TOTAL_SIZE(MALLOC_HEADER_PTR(alloc_info)) - size; } else { heap_stats.alloc_fail_cnt += 1; } malloc_stats_mutex->unlock(); #else     ptr = SUPER_MALLOC(size); #endif #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_malloc(ptr, size, caller); mbed_mem_trace_unlock(); #endif     return ptr; }"
"static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_Obj *obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) { Jsi_ValueMakeNumber(interp, ret, 0); return JSI_OK; } obj = _this->d.obj; int argc = Jsi_ValueGetLength(interp, args); int curlen = Jsi_ObjGetLength(interp, obj); if (curlen < 0) { Jsi_ObjSetLength(interp, obj, 0); } int i; for (i = 0; i < argc; ++i) { Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i); if (!ov) { Jsi_LogBug(""Arguments Error""); ov = Jsi_ValueNew(interp); } Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0); } Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj)); return JSI_OK; }"
"int MMDB_vget_value(MMDB_entry_s *const start, MMDB_entry_data_s *const entry_data, va_list va_path) { int length = path_length(va_path); const char *path_elem; int i = 0; MAYBE_CHECK_SIZE_OVERFLOW(length, SIZE_MAX / sizeof(const char *) - 1, MMDB_INVALID_METADATA_ERROR); const char **path = malloc((length + 1) * sizeof(const char *)); if (NULL == path) { return MMDB_OUT_OF_MEMORY_ERROR; } while (NULL != (path_elem = va_arg(va_path, char *))) { path[i] = path_elem; i++; } path[i] = NULL; int status = MMDB_aget_value(start, entry_data, path); free((char **)path); return status; }"
"void native_tss_update_io_bitmap(void) { struct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw); struct thread_struct *t = &current->thread; u16 *base = &tss->x86_tss.io_bitmap_base; if (!test_thread_flag(TIF_IO_BITMAP)) { tss_invalidate_io_bitmap(tss); return; } if (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) { *base = IO_BITMAP_OFFSET_VALID_ALL; } else { struct io_bitmap *iobm = t->io_bitmap; if (tss->io_bitmap.prev_sequence != iobm->sequence) tss_copy_io_bitmap(tss, iobm); *base = IO_BITMAP_OFFSET_VALID_MAP; } refresh_tss_limit(); }"
void flash_option_bytes_init(int boot_from_dfu) { uint32_t val = 0xfffff8aa; if (boot_from_dfu){ val &= ~(1<<27);     } else { if (solo_is_locked()) { val = 0xfffff8cc; } } val &= ~(1<<26);     val &= ~(1<<25);     val &= ~(1<<24);  if (FLASH->OPTR == val) { return; } __disable_irq(); while (FLASH->SR & (1<<16)) ; flash_unlock(); if (FLASH->CR & (1<<30)) { FLASH->OPTKEYR = 0x08192A3B; FLASH->OPTKEYR = 0x4C5D6E7F; } FLASH->OPTR =val; FLASH->CR |= (1<<17); while (FLASH->SR & (1<<16)) ; flash_lock(); __enable_irq(); }
"struct xt_table *xt_register_table(struct net *net, const struct xt_table *input_table, struct xt_table_info *bootstrap, struct xt_table_info *newinfo) { int ret; struct xt_table_info *private; struct xt_table *t, *table; table = kmemdup(input_table, sizeof(struct xt_table), GFP_KERNEL); if (!table) { ret = -ENOMEM; goto out; } mutex_lock(&xt[table->af].mutex); list_for_each_entry(t, &net->xt.tables[table->af], list) { if (strcmp(t->name, table->name) == 0) { ret = -EEXIST; goto unlock; } } table->private = bootstrap; if (!xt_replace_table(table, 0, newinfo, &ret)) goto unlock; private = table->private; pr_debug(""table->private->number = %u\n"", private->number); private->initial_entries = private->number; list_add(&table->list, &net->xt.tables[table->af]); mutex_unlock(&xt[table->af].mutex); return table; unlock: mutex_unlock(&xt[table->af].mutex); kfree(table); out: return ERR_PTR(ret); }"
"static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { ut64 curAddressValue; if (!context->read_addr (context->anal, curAddress, &curAddressValue)) { return false; } bool ret = vtable_addr_in_text_section (context, curAddressValue); if (value) { *value = curAddressValue; } return ret; }"
"PIX * pixBlockconvGrayUnnormalized(PIX     *pixs, l_int32  wc, l_int32  hc) { l_int32    i, j, w, h, d, wpla, wpld, jmax; l_uint32  *linemina, *linemaxa, *lined, *dataa, *datad; PIX       *pixsb, *pixacc, *pixd; PROCNAME(""pixBlockconvGrayUnnormalized""); if (!pixs) return (PIX *)ERROR_PTR(""pixs not defined"", procName, NULL); pixGetDimensions(pixs, &w, &h, &d); if (d != 8) return (PIX *)ERROR_PTR(""pixs not 8 bpp"", procName, NULL); if (wc < 0) wc = 0; if (hc < 0) hc = 0; if (w < 2 * wc + 1 || h < 2 * hc + 1) { wc = L_MIN(wc, (w - 1) / 2); hc = L_MIN(hc, (h - 1) / 2); L_WARNING(""kernel too large; reducing!\n"", procName); L_INFO(""wc = %d, hc = %d\n"", procName, wc, hc); } if (wc == 0 && hc == 0)    return pixCopy(NULL, pixs); if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL) return (PIX *)ERROR_PTR(""pixsb not made"", procName, NULL); pixacc = pixBlockconvAccum(pixsb); pixDestroy(&pixsb); if (!pixacc) return (PIX *)ERROR_PTR(""pixacc not made"", procName, NULL); if ((pixd = pixCreate(w, h, 32)) == NULL) { pixDestroy(&pixacc); return (PIX *)ERROR_PTR(""pixd not made"", procName, NULL); } wpla = pixGetWpl(pixacc); wpld = pixGetWpl(pixd); datad = pixGetData(pixd); dataa = pixGetData(pixacc); for (i = 0; i < h; i++) { lined = datad + i * wpld; linemina = dataa + i * wpla; linemaxa = dataa + (i + 2 * hc + 1) * wpla; for (j = 0; j < w; j++) { jmax = j + 2 * wc + 1; lined[j] = linemaxa[jmax] - linemaxa[j] - linemina[jmax] + linemina[j]; } } pixDestroy(&pixacc); return pixd; }"
"static int dwc3_qcom_probe(struct platform_device *pdev) { struct device_node*np = pdev->dev.of_node; struct device*dev = &pdev->dev; struct dwc3_qcom*qcom; struct resource*res, *parent_res = NULL; intret, i; boolignore_pipe_clk; qcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL); if (!qcom) return -ENOMEM; platform_set_drvdata(pdev, qcom); qcom->dev = &pdev->dev; if (has_acpi_companion(dev)) { qcom->acpi_pdata = acpi_device_get_match_data(dev); if (!qcom->acpi_pdata) { dev_err(&pdev->dev, ""no supporting ACPI device data\n""); return -EINVAL; } } qcom->resets = devm_reset_control_array_get_optional_exclusive(dev); if (IS_ERR(qcom->resets)) { ret = PTR_ERR(qcom->resets); dev_err(&pdev->dev, ""failed to get resets, err=%d\n"", ret); return ret; } ret = reset_control_assert(qcom->resets); if (ret) { dev_err(&pdev->dev, ""failed to assert resets, err=%d\n"", ret); return ret; } usleep_range(10, 1000); ret = reset_control_deassert(qcom->resets); if (ret) { dev_err(&pdev->dev, ""failed to deassert resets, err=%d\n"", ret); goto reset_assert; } ret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np)); if (ret) { dev_err(dev, ""failed to get clocks\n""); goto reset_assert; } res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (np) { parent_res = res; } else { parent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL); if (!parent_res) return -ENOMEM; parent_res->start = res->start + qcom->acpi_pdata->qscratch_base_offset; parent_res->end = parent_res->start + qcom->acpi_pdata->qscratch_base_size; if (qcom->acpi_pdata->is_urs) { qcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev); if (!qcom->urs_usb) { dev_err(dev, ""failed to create URS USB platdev\n""); return -ENODEV; } } } qcom->qscratch_base = devm_ioremap_resource(dev, parent_res); if (IS_ERR(qcom->qscratch_base)) { ret = PTR_ERR(qcom->qscratch_base); goto clk_disable; } ret = dwc3_qcom_setup_irq(pdev); if (ret) { dev_err(dev, ""failed to setup IRQs, err=%d\n"", ret); goto clk_disable; } ignore_pipe_clk = device_property_read_bool(dev, ""qcom,select-utmi-as-pipe-clk""); if (ignore_pipe_clk) dwc3_qcom_select_utmi_clk(qcom); if (np) ret = dwc3_qcom_of_register_core(pdev); else ret = dwc3_qcom_acpi_register_core(pdev); if (ret) { dev_err(dev, ""failed to register DWC3 Core, err=%d\n"", ret); goto depopulate; } ret = dwc3_qcom_interconnect_init(qcom); if (ret) goto depopulate; qcom->mode = usb_get_dr_mode(&qcom->dwc3->dev); if (qcom->mode == USB_DR_MODE_PERIPHERAL) dwc3_qcom_vbus_override_enable(qcom, true); ret = dwc3_qcom_register_extcon(qcom); if (ret) goto interconnect_exit; device_init_wakeup(&pdev->dev, 1); qcom->is_suspended = false; pm_runtime_set_active(dev); pm_runtime_enable(dev); pm_runtime_forbid(dev); return 0; interconnect_exit: dwc3_qcom_interconnect_exit(qcom); depopulate: if (np) of_platform_depopulate(&pdev->dev); else platform_device_put(pdev); clk_disable: for (i = qcom->num_clocks - 1; i >= 0; i--) { clk_disable_unprepare(qcom->clks[i]); clk_put(qcom->clks[i]); } reset_assert: reset_control_assert(qcom->resets); return ret; }"
"void proto_register_sysdig_event(void) { static hf_register_info hf[] = { { &hf_se_cpu_id, { ""CPU ID"", ""sysdig.cpu_id"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_thread_id, { ""Thread ID"", ""sysdig.thread_id"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_event_length, { ""Event length"", ""sysdig.event_len"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_nparams, { ""Number of parameters"", ""sysdig.nparams"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_event_type, { ""Event type"", ""sysdig.event_type"", FT_UINT16, BASE_DEC, VALS(event_type_vals), 0, NULL, HFILL } }, { &hf_se_param_lens, { ""Parameter lengths"", ""sysdig.param.lens"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_se_param_len, { ""Parameter length"", ""sysdig.param.len"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ID_bytes, { ""ID"", ""sysdig.param.syscall.ID"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_action_uint32, { ""action"", ""sysdig.param.cpu_hotplug.action"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_addr_bytes, { ""addr"", ""sysdig.param.ptrace.addr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_addr_uint64, { ""addr"", ""sysdig.param.page_fault.addr"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_args_string, { ""Program arguments"", ""sysdig.param.execve.args"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_argument_uint64, { ""I/O control: argument"", ""sysdig.param.ioctl.argument"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_backlog_uint32, { ""backlog"", ""sysdig.param.listen.backlog"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cgroups_bytes, { ""cgroups"", ""sysdig.param.execve.cgroups"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_clockid_uint8, { ""clockid"", ""sysdig.param.timerfd_create.clockid"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cmd_bytes, { ""cmd"", ""sysdig.param.semctl.cmd"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_cmd_int64, { ""cmd"", ""sysdig.param.bpf.cmd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_comm_string, { ""Command"", ""sysdig.param.execve.comm"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_sys_uint64, { ""cpu_sys"", ""sysdig.param.procinfo.cpu_sys"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_uint32, { ""cpu"", ""sysdig.param.cpu_hotplug.cpu"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_usr_uint64, { ""cpu_usr"", ""sysdig.param.procinfo.cpu_usr"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cur_int64, { ""cur"", ""sysdig.param.setrlimit.cur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cwd_string, { ""Current working directory"", ""sysdig.param.execve.cwd"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_data_bytes, { ""data"", ""sysdig.param.ptrace.data"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_desc_string, { ""desc"", ""sysdig.param.notification.desc"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_description_string, { ""description"", ""sysdig.param.infra.description"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dev_string, { ""dev"", ""sysdig.param.mount.dev"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dev_uint32, { ""dev"", ""sysdig.param.openat.dev"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_dir_string, { ""dir"", ""sysdig.param.mount.dir"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dirfd_int64, { ""dirfd"", ""sysdig.param.openat.dirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_domain_bytes, { ""domain"", ""sysdig.param.socketpair.domain"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dpid_bytes, { ""dpid"", ""sysdig.param.signaldeliver.dpid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_bhardlimit_uint64, { ""dqb_bhardlimit"", ""sysdig.param.quotactl.dqb_bhardlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_bsoftlimit_uint64, { ""dqb_bsoftlimit"", ""sysdig.param.quotactl.dqb_bsoftlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_btime_bytes, { ""dqb_btime"", ""sysdig.param.quotactl.dqb_btime"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_curspace_uint64, { ""dqb_curspace"", ""sysdig.param.quotactl.dqb_curspace"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_ihardlimit_uint64, { ""dqb_ihardlimit"", ""sysdig.param.quotactl.dqb_ihardlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_isoftlimit_uint64, { ""dqb_isoftlimit"", ""sysdig.param.quotactl.dqb_isoftlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_itime_bytes, { ""dqb_itime"", ""sysdig.param.quotactl.dqb_itime"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_bgrace_bytes, { ""dqi_bgrace"", ""sysdig.param.quotactl.dqi_bgrace"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_flags_bytes, { ""dqi_flags"", ""sysdig.param.quotactl.dqi_flags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_igrace_bytes, { ""dqi_igrace"", ""sysdig.param.quotactl.dqi_igrace"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_egid_bytes, { ""egid"", ""sysdig.param.getresgid.egid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_env_string, { ""env"", ""sysdig.param.execve.env"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_error_bytes, { ""error"", ""sysdig.param.page_fault.error"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_euid_bytes, { ""euid"", ""sysdig.param.getresuid.euid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_event_data_uint64, { ""event_data"", ""sysdig.param.sysdigevent.event_data"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_event_type_uint32, { ""event_type"", ""sysdig.param.sysdigevent.event_type"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_exe_string, { ""exe"", ""sysdig.param.execve.exe"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_fd1_int64, { ""fd1"", ""sysdig.param.pipe.fd1"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd2_int64, { ""fd2"", ""sysdig.param.pipe.fd2"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_in_int64, { ""fd_in"", ""sysdig.param.splice.fd_in"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_int64, { ""fd"", ""sysdig.param.openat.fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_out_int64, { ""fd_out"", ""sysdig.param.splice.fd_out"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fdlimit_int64, { ""fdlimit"", ""sysdig.param.vfork.fdlimit"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fdlimit_uint64, { ""fdlimit"", ""sysdig.param.execve.fdlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fds_bytes, { ""fds"", ""sysdig.param.ppoll.fds"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_filename_string, { ""filename"", ""sysdig.param.execve.filename"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_flags_bytes, { ""flags"", ""sysdig.param.linkat.flags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_flags_uint32, { ""flags"", ""sysdig.param.accept.flags"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_gid_bytes, { ""gid"", ""sysdig.param.getgid.gid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_gid_uint32, { ""gid"", ""sysdig.param.vfork.gid"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_how_bytes, { ""how"", ""sysdig.param.shutdown.how"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_id_int64, { ""id"", ""sysdig.param.tracer.id"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_id_string, { ""id"", ""sysdig.param.notification.id"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_id_uint32, { ""id"", ""sysdig.param.quotactl.id"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_image_string, { ""image"", ""sysdig.param.container.image"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_in_fd_int64, { ""in_fd"", ""sysdig.param.sendfile.in_fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_initval_uint64, { ""initval"", ""sysdig.param.eventfd.initval"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ino_uint64, { ""ino"", ""sysdig.param.pipe.ino"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_interval_bytes, { ""interval"", ""sysdig.param.nanosleep.interval"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ip_uint64, { ""ip"", ""sysdig.param.page_fault.ip"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_json_string, { ""json"", ""sysdig.param.container.json"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_key_int32, { ""key"", ""sysdig.param.semget.key"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_length_uint64, { ""length"", ""sysdig.param.munmap.length"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_level_bytes, { ""level"", ""sysdig.param.getsockopt.level"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_linkdirfd_int64, { ""linkdirfd"", ""sysdig.param.symlinkat.linkdirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_linkpath_string, { ""linkpath"", ""sysdig.param.symlinkat.linkpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_loginuid_int32, { ""loginuid"", ""sysdig.param.execve.loginuid"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_mask_uint32, { ""mask"", ""sysdig.param.signalfd.mask"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_max_int64, { ""max"", ""sysdig.param.setrlimit.max"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_maxevents_bytes, { ""maxevents"", ""sysdig.param.epoll_wait.maxevents"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_mode_bytes, { ""mode"", ""sysdig.param.access.mode"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_mode_uint32, { ""mode"", ""sysdig.param.openat.mode"", FT_UINT32, BASE_OCT, NULL, 0, NULL, HFILL } }, { &hf_param_name_string, { ""name"", ""sysdig.param.openat.name"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_nativeID_uint16, { ""nativeID"", ""sysdig.param.syscall.nativeID"", FT_UINT16, BASE_DEC, VALS(nativeID_uint16_vals), 0, NULL, HFILL } }, { &hf_param_newcur_int64, { ""newcur"", ""sysdig.param.prlimit.newcur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newdir_int64, { ""newdir"", ""sysdig.param.linkat.newdir"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newdirfd_int64, { ""newdirfd"", ""sysdig.param.renameat.newdirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newmax_int64, { ""newmax"", ""sysdig.param.prlimit.newmax"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newpath_string, { ""newpath"", ""sysdig.param.linkat.newpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_next_bytes, { ""next"", ""sysdig.param.switch.next"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_nsems_int32, { ""nsems"", ""sysdig.param.semget.nsems"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_nsops_uint32, { ""nsops"", ""sysdig.param.semop.nsops"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_nstype_bytes, { ""nstype"", ""sysdig.param.setns.nstype"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_offset_uint64, { ""offset"", ""sysdig.param.sendfile.offset"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldcur_int64, { ""oldcur"", ""sysdig.param.prlimit.oldcur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_olddir_int64, { ""olddir"", ""sysdig.param.linkat.olddir"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_olddirfd_int64, { ""olddirfd"", ""sysdig.param.renameat.olddirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldmax_int64, { ""oldmax"", ""sysdig.param.prlimit.oldmax"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldpath_string, { ""oldpath"", ""sysdig.param.linkat.oldpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_op_bytes, { ""op"", ""sysdig.param.futex.op"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_op_uint64, { ""op"", ""sysdig.param.seccomp.op"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_operation_bytes, { ""operation"", ""sysdig.param.flock.operation"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_optlen_uint32, { ""optlen"", ""sysdig.param.getsockopt.optlen"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_optname_bytes, { ""optname"", ""sysdig.param.getsockopt.optname"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_out_fd_int64, { ""out_fd"", ""sysdig.param.sendfile.out_fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_path_string, { ""path"", ""sysdig.param.mkdirat.path"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_peer_uint64, { ""peer"", ""sysdig.param.socketpair.peer"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_pgft_maj_uint64, { ""pgft_maj"", ""sysdig.param.execve.pgft_maj"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pgft_min_uint64, { ""pgft_min"", ""sysdig.param.execve.pgft_min"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pgid_bytes, { ""pgid"", ""sysdig.param.setpgid.pgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_pgoffset_uint64, { ""pgoffset"", ""sysdig.param.mmap2.pgoffset"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pid_bytes, { ""pid"", ""sysdig.param.setpgid.pid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_pos_uint64, { ""pos"", ""sysdig.param.pwritev.pos"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_prot_bytes, { ""prot"", ""sysdig.param.mmap2.prot"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_proto_uint32, { ""proto"", ""sysdig.param.socketpair.proto"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ptid_bytes, { ""ptid"", ""sysdig.param.execve.ptid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_queuelen_uint32, { ""queuelen"", ""sysdig.param.accept.queuelen"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_queuemax_uint32, { ""queuemax"", ""sysdig.param.accept.queuemax"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_queuepct_uint8, { ""Accept queue per connection"", ""sysdig.param.accept.queuepct"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_quota_fmt_bytes, { ""quota_fmt"", ""sysdig.param.quotactl.quota_fmt"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_quota_fmt_out_bytes, { ""quota_fmt_out"", ""sysdig.param.quotactl.quota_fmt_out"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_quotafilepath_string, { ""quotafilepath"", ""sysdig.param.quotactl.quotafilepath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ratio_uint32, { ""ratio"", ""sysdig.param.drop.ratio"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_request_bytes, { ""request"", ""sysdig.param.ptrace.request"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_request_uint64, { ""I/O control: request"", ""sysdig.param.ioctl.request"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_res_bytes, { ""res"", ""sysdig.param.linkat.res"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_res_int64, { ""res"", ""sysdig.param.fcntl.res"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_res_or_fd_bytes, { ""res_or_fd"", ""sysdig.param.bpf.res_or_fd"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_res_uint64, { ""res"", ""sysdig.param.mmap2.res"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_resource_bytes, { ""resource"", ""sysdig.param.prlimit.resource"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_rgid_bytes, { ""rgid"", ""sysdig.param.getresgid.rgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ruid_bytes, { ""ruid"", ""sysdig.param.getresuid.ruid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_scope_string, { ""scope"", ""sysdig.param.infra.scope"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_flg_0_bytes, { ""sem_flg_0"", ""sysdig.param.semop.sem_flg_0"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_flg_1_bytes, { ""sem_flg_1"", ""sysdig.param.semop.sem_flg_1"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_num_0_uint16, { ""sem_num_0"", ""sysdig.param.semop.sem_num_0"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_num_1_uint16, { ""sem_num_1"", ""sysdig.param.semop.sem_num_1"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_op_0_int16, { ""sem_op_0"", ""sysdig.param.semop.sem_op_0"", FT_INT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_op_1_int16, { ""sem_op_1"", ""sysdig.param.semop.sem_op_1"", FT_INT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_semflg_bytes, { ""semflg"", ""sysdig.param.semget.semflg"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_semid_int32, { ""semid"", ""sysdig.param.semctl.semid"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_semnum_int32, { ""semnum"", ""sysdig.param.semctl.semnum"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sgid_bytes, { ""sgid"", ""sysdig.param.getresgid.sgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sig_bytes, { ""sig"", ""sysdig.param.signaldeliver.sig"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sigmask_bytes, { ""sigmask"", ""sysdig.param.ppoll.sigmask"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_size_uint32, { ""size"", ""sysdig.param.pwritev.size"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_size_uint64, { ""size"", ""sysdig.param.sendfile.size"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_source_string, { ""source"", ""sysdig.param.infra.source"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_source_uint64, { ""source"", ""sysdig.param.socketpair.source"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_special_string, { ""special"", ""sysdig.param.quotactl.special"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_spid_bytes, { ""spid"", ""sysdig.param.signaldeliver.spid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_status_bytes, { ""status"", ""sysdig.param.procexit.status"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_suid_bytes, { ""suid"", ""sysdig.param.getresuid.suid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_tags_bytes, { ""tags"", ""sysdig.param.tracer.tags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_target_string, { ""target"", ""sysdig.param.symlinkat.target"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_tid_bytes, { ""tid"", ""sysdig.param.execve.tid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_timeout_bytes, { ""timeout"", ""sysdig.param.ppoll.timeout"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_timeout_int64, { ""timeout"", ""sysdig.param.poll.timeout"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_tty_int32, { ""tty"", ""sysdig.param.execve.tty"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_tuple_bytes, { ""tuple"", ""sysdig.param.accept.tuple"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_bytes, { ""type"", ""sysdig.param.quotactl.type"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_string, { ""type"", ""sysdig.param.mount.type"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_uint32, { ""type"", ""sysdig.param.container.type"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_uid_bytes, { ""uid"", ""sysdig.param.getuid.uid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_uid_uint32, { ""uid"", ""sysdig.param.vfork.uid"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_val_bytes, { ""val"", ""sysdig.param.getsockopt.val"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_val_int32, { ""val"", ""sysdig.param.semctl.val"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_val_uint64, { ""val"", ""sysdig.param.futex.val"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_rss_uint32, { ""vm_rss"", ""sysdig.param.execve.vm_rss"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_size_uint32, { ""vm_size"", ""sysdig.param.execve.vm_size"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_swap_uint32, { ""vm_swap"", ""sysdig.param.execve.vm_swap"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vpid_bytes, { ""vpid"", ""sysdig.param.vfork.vpid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_vtid_bytes, { ""vtid"", ""sysdig.param.vfork.vtid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_whence_bytes, { ""whence"", ""sysdig.param.llseek.whence"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ret_bytes, { ""ret"", ""sysdig.param.procexit.ret"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_core_uint8, { ""core"", ""sysdig.param.procexit.core"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, }; static gint *ett[] = { &ett_sysdig_event, &ett_sysdig_parm_lens, &ett_sysdig_syscall }; proto_sysdig_event = proto_register_protocol(""Sysdig System Call"", ""Sysdig Event"", ""sysdig""); proto_register_field_array(proto_sysdig_event, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); register_dissector(""sysdig"", dissect_sysdig_event, proto_sysdig_event); }"
"static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size) { unsigned int i; struct hash_cell *hc; size_t len, needed = 0; struct gendisk *disk; struct dm_name_list *orig_nl, *nl, *old_nl = NULL; uint32_t *event_nr; down_write(&_hash_lock); for (i = 0; i < NUM_BUCKETS; i++) { list_for_each_entry (hc, _name_buckets + i, name_list) { needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1); needed += align_val(sizeof(uint32_t)); } } nl = orig_nl = get_result_buffer(param, param_size, &len); if (len < needed) { param->flags |= DM_BUFFER_FULL_FLAG; goto out; } param->data_size = param->data_start + needed; nl->dev = 0; for (i = 0; i < NUM_BUCKETS; i++) { list_for_each_entry (hc, _name_buckets + i, name_list) { if (old_nl) old_nl->next = (uint32_t) ((void *) nl - (void *) old_nl); disk = dm_disk(hc->md); nl->dev = huge_encode_dev(disk_devt(disk)); nl->next = 0; strcpy(nl->name, hc->name); old_nl = nl; event_nr = align_ptr(nl->name + strlen(hc->name) + 1); *event_nr = dm_get_event_nr(hc->md); nl = align_ptr(event_nr + 1); } } BUG_ON((char *)nl - (char *)orig_nl != needed); out: up_write(&_hash_lock); return 0; }"
"static void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent) { u32 i, count; count = gf_list_count(au->commands); for (i=0; i<count; i++) { u32 j, c2; GF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i); if (com->tag != GF_ODF_OD_UPDATE_TAG) continue; c2 = gf_list_count(com->objectDescriptors); for (j=0; j<c2; j++) { GF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j); GF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0); GF_MuxInfo *mux; if (!esd || (esd->tag != GF_ODF_ESD_TAG)) { if (od->URLString) { gf_fprintf(dumper->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", au->owner->ESID, od->URLString); if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing); gf_fprintf(dumper->trace, ""/>\n""); } continue; } mux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0); if (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL; gf_fprintf(dumper->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", esd->ESID); gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale); if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing); if (mux && mux->file_name) gf_fprintf(dumper->trace, "" source=\""%s\"""", mux->file_name); gf_fprintf(dumper->trace, ""/>\n""); } } gf_fprintf(dumper->trace, ""</saf:mediaUnit>\n""); }"
"int ReadJpegSections (FILE * infile, ReadMode_t ReadMode) { int a; int HaveCom = FALSE; a = fgetc(infile); if (a != 0xff || fgetc(infile) != M_SOI){ return FALSE; } ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300; ImageInfo.JfifHeader.ResolutionUnits = 1; for(;;){ int itemlen; int prev; int marker = 0; int ll,lh, got; uchar * Data; CheckSectionsAllocated(); prev = 0; for (a=0;;a++){ marker = fgetc(infile); if (marker != 0xff && prev == 0xff) break; if (marker == EOF){ ErrFatal(""Unexpected end of file""); } prev = marker; } if (a > 10){ ErrNonfatal(""Extraneous %d padding bytes before section %02X"",a-1,marker); } Sections[SectionsRead].Type = marker; lh = fgetc(infile); ll = fgetc(infile); if (lh == EOF || ll == EOF){ ErrFatal(""Unexpected end of file""); } itemlen = (lh << 8) | ll; if (itemlen < 2){ ErrFatal(""invalid marker""); } Sections[SectionsRead].Size = itemlen; Data = (uchar *)malloc(itemlen); if (Data == NULL){ ErrFatal(""Could not allocate memory""); } Sections[SectionsRead].Data = Data; Data[0] = (uchar)lh; Data[1] = (uchar)ll; got = fread(Data+2, 1, itemlen-2, infile);         if (got != itemlen-2){ ErrFatal(""Premature end of file?""); } SectionsRead += 1; switch(marker){ case M_SOS:                                   if (ReadMode & READ_IMAGE){ int cp, ep, size; cp = ftell(infile); fseek(infile, 0, SEEK_END); ep = ftell(infile); fseek(infile, cp, SEEK_SET); size = ep-cp; Data = (uchar *)malloc(size); if (Data == NULL){ ErrFatal(""could not allocate data for entire image""); } got = fread(Data, 1, size, infile); if (got != size){ ErrFatal(""could not read the rest of the image""); } CheckSectionsAllocated(); Sections[SectionsRead].Data = Data; Sections[SectionsRead].Size = size; Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER; SectionsRead ++; HaveAll = 1; } return TRUE; case M_DQT: process_DQT(Data, itemlen); break; case M_DHT:    process_DHT(Data, itemlen); break; case M_EOI:                   fprintf(stderr,""No image in jpeg!\n""); return FALSE; case M_COM:                 if (HaveCom || ((ReadMode & READ_METADATA) == 0)){ free(Sections[--SectionsRead].Data); }else{ process_COM(Data, itemlen); HaveCom = TRUE; } break; case M_JFIF: if (itemlen < 16){ fprintf(stderr,""Jfif header too short\n""); goto ignore; } if (memcmp(Data+2, ""JFIF\0"",5)){ fprintf(stderr,""Header missing JFIF marker\n""); } ImageInfo.JfifHeader.Present = TRUE; ImageInfo.JfifHeader.ResolutionUnits = Data[9]; ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11]; ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13]; if (ShowTags){ printf(""JFIF SOI marker: Units: %d "",ImageInfo.JfifHeader.ResolutionUnits); switch(ImageInfo.JfifHeader.ResolutionUnits){ case 0: printf(""(aspect ratio)""); break; case 1: printf(""(dots per inch)""); break; case 2: printf(""(dots per cm)""); break; default: printf(""(unknown)""); break; } printf(""  X-density=%d Y-density=%d\n"",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity); if (Data[14] || Data[15]){ fprintf(stderr,""Ignoring jfif header thumbnail\n""); } } ignore: free(Sections[--SectionsRead].Data); break; case M_EXIF: if (ReadMode & READ_METADATA){ if (memcmp(Data+2, ""Exif"", 4) == 0){ process_EXIF(Data, itemlen); break; }else if (memcmp(Data+2, ""http:"", 5) == 0){ Sections[SectionsRead-1].Type = M_XMP;                         if (ShowTags){ printf(""Image contains XMP section, %d bytes long\n"", itemlen); if (ShowTags){ ShowXmp(Sections[SectionsRead-1]); } } break; } } free(Sections[--SectionsRead].Data); break; case M_IPTC: if (ReadMode & READ_METADATA){ if (ShowTags){ printf(""Image contains IPTC section, %d bytes long\n"", itemlen); } }else{ free(Sections[--SectionsRead].Data); } break; case M_SOF0:  case M_SOF1:  case M_SOF2:  case M_SOF3:  case M_SOF5:  case M_SOF6:  case M_SOF7:  case M_SOF9:  case M_SOF10: case M_SOF11: case M_SOF13: case M_SOF14: case M_SOF15: if (itemlen < 8){ fprintf(stderr,""Section too short\n""); break; } process_SOFn(Data, marker); break; default: if (ShowTags){ printf(""Jpeg section marker 0x%02x size %d\n"",marker, itemlen); } break; } } return TRUE; }"
"static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data) { int rv; ssize_t size; sgwc_event_t *e = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_pfcp_node_t *node = NULL; ogs_pfcp_header_t *h = NULL; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recvfrom() failed""); ogs_pkbuf_free(pkbuf); return; } ogs_pkbuf_trim(pkbuf, size); h = (ogs_pfcp_header_t *)pkbuf->data; if (h->version > OGS_PFCP_VERSION) { ogs_pfcp_header_t rsp; ogs_error(""Not supported version[%d]"", h->version); memset(&rsp, 0, sizeof rsp); rsp.flags = (OGS_PFCP_VERSION << 5); rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE; rsp.length = htobe16(4); rsp.sqn_only = h->sqn_only; if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(pkbuf); return; } e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE); ogs_assert(e); node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from); if (!node) { node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from); ogs_assert(node); node->sock = data; pfcp_node_fsm_init(node, false); } e->pfcp_node = node; e->pkbuf = pkbuf; rv = ogs_queue_push(ogs_app()->queue, e); if (rv != OGS_OK) { ogs_error(""ogs_queue_push() failed:%d"", (int)rv); ogs_pkbuf_free(e->pkbuf); sgwc_event_free(e); } }"
"int LibRaw::ljpeg_start(struct jhead *jh, int info_only) { ushort c, tag, len; int cnt = 0; uchar data[0x10000]; const uchar *dp; memset(jh, 0, sizeof *jh); jh->restart = INT_MAX; if ((fgetc(ifp), fgetc(ifp)) != 0xd8) return 0; do { if (feof(ifp)) return 0; if (cnt++ > 1024) return 0;     if (!fread(data, 2, 2, ifp)) return 0; tag = data[0] << 8 | data[1]; len = (data[2] << 8 | data[3]) - 2; if (tag <= 0xff00) return 0; fread(data, 1, len, ifp); switch (tag) { case 0xffc3:       jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3; case 0xffc1: case 0xffc0: jh->algo = tag & 0xff; jh->bits = data[0]; jh->high = data[1] << 8 | data[2]; jh->wide = data[3] << 8 | data[4]; jh->clrs = data[5] + jh->sraw; if (len == 9 && !dng_version) getc(ifp); break; case 0xffc4:       if (info_only) break; for (dp = data; dp < data + len && !((c = *dp++) & -20);) jh->free[c] = jh->huff[c] = make_decoder_ref(&dp); break; case 0xffda:       jh->psv = data[1 + data[0] * 2]; jh->bits -= data[3 + data[0] * 2] & 15; break; case 0xffdb: FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2]; break; case 0xffdd: jh->restart = data[0] << 8 | data[1]; } } while (tag != 0xffda); if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0; if (info_only) return 1; if (!jh->huff[0]) return 0; FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c]; if (jh->sraw) { FORC(4) jh->huff[2 + c] = jh->huff[1]; FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0]; } jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4); merror(jh->row, ""ljpeg_start()""); return zero_after_ff = 1; }"
"static void uc_list(char_u *name, size_t name_len) { inti, j; intfound = FALSE; ucmd_T*cmd; intlen; intover; longa; garray_T*gap; gap = #ifdef FEAT_CMDWIN is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds : #endif &curbuf->b_ucmds; for (;;) { for (i = 0; i < gap->ga_len; ++i) { cmd = USER_CMD_GA(gap, i); a = (long)cmd->uc_argt; if (STRNCMP(name, cmd->uc_name, name_len) != 0 || message_filtered(cmd->uc_name)) continue; if (!found) msg_puts_title(_(""\n    Name              Args Address Complete    Definition"")); found = TRUE; msg_putchar('\n'); if (got_int) break; len = 4; if (a & EX_BANG) { msg_putchar('!'); --len; } if (a & EX_REGSTR) { msg_putchar('""'); --len; } if (gap != &ucmds) { msg_putchar('b'); --len; } if (a & EX_TRLBAR) { msg_putchar('|'); --len; } while (len-- > 0) msg_putchar(' '); msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D)); len = (int)STRLEN(cmd->uc_name) + 4; do { msg_putchar(' '); ++len; } while (len < 22); over = len - 22; len = 0; switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG))) { case 0:IObuff[len++] = '0'; break; case (EX_EXTRA):IObuff[len++] = '*'; break; case (EX_EXTRA|EX_NOSPC):IObuff[len++] = '?'; break; case (EX_EXTRA|EX_NEEDARG):IObuff[len++] = '+'; break; case (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break; } do { IObuff[len++] = ' '; } while (len < 5 - over); if (a & (EX_RANGE|EX_COUNT)) { if (a & EX_COUNT) { sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def); len += (int)STRLEN(IObuff + len); } else if (a & EX_DFLALL) IObuff[len++] = '%'; else if (cmd->uc_def >= 0) { sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def); len += (int)STRLEN(IObuff + len); } else IObuff[len++] = '.'; } do { IObuff[len++] = ' '; } while (len < 8 - over); for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j) if (addr_type_complete[j].expand != ADDR_LINES && addr_type_complete[j].expand == cmd->uc_addr_type) { STRCPY(IObuff + len, addr_type_complete[j].shortname); len += (int)STRLEN(IObuff + len); break; } do { IObuff[len++] = ' '; } while (len < 13 - over); for (j = 0; command_complete[j].expand != 0; ++j) if (command_complete[j].expand == cmd->uc_compl) { STRCPY(IObuff + len, command_complete[j].name); len += (int)STRLEN(IObuff + len); #ifdef FEAT_EVAL if (p_verbose > 0 && cmd->uc_compl_arg != NULL && STRLEN(cmd->uc_compl_arg) < 200) { IObuff[len] = ','; STRCPY(IObuff + len + 1, cmd->uc_compl_arg); len += (int)STRLEN(IObuff + len); } #endif break; } do { IObuff[len++] = ' '; } while (len < 25 - over); IObuff[len] = '\0'; msg_outtrans(IObuff); msg_outtrans_special(cmd->uc_rep, FALSE, name_len == 0 ? Columns - 47 : 0); #ifdef FEAT_EVAL if (p_verbose > 0) last_set_msg(cmd->uc_script_ctx); #endif out_flush(); ui_breakcheck(); if (got_int) break; } if (gap == &ucmds || i < gap->ga_len) break; gap = &ucmds; } if (!found) msg(_(""No user-defined commands found"")); }"
"void ValidateInputs(OpKernelContext* ctx, const CSRSparseMatrix& sparse_matrix, const Tensor& permutation_indices, int* batch_size, int64* num_rows) { OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value, errors::InvalidArgument( ""Asked for a CSRSparseMatrix of type "", DataTypeString(DataTypeToEnum<T>::value), "" but saw dtype: "", DataTypeString(sparse_matrix.dtype()))); const Tensor& dense_shape = sparse_matrix.dense_shape(); const int rank = dense_shape.dim_size(0); OP_REQUIRES(ctx, rank == 2 || rank == 3, errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "", ""but dense_shape has size "", rank)); const int row_dim = (rank == 2) ? 0 : 1; auto dense_shape_vec = dense_shape.vec<int64>(); *num_rows = dense_shape_vec(row_dim); const int64 num_cols = dense_shape_vec(row_dim + 1); OP_REQUIRES(ctx, *num_rows == num_cols, errors::InvalidArgument(""sparse matrix must be square; got: "", *num_rows, "" != "", num_cols)); const TensorShape& perm_shape = permutation_indices.shape(); OP_REQUIRES( ctx, perm_shape.dims() + 1 == rank, errors::InvalidArgument( ""sparse matrix must have the same rank as permutation; got: "", rank, "" != "", perm_shape.dims(), "" + 1."")); OP_REQUIRES( ctx, perm_shape.dim_size(rank - 2) == *num_rows, errors::InvalidArgument( ""permutation must have the same number of elements in each batch "" ""as the number of rows in sparse matrix; got: "", perm_shape.dim_size(rank - 2), "" != "", *num_rows)); *batch_size = sparse_matrix.batch_size(); if (*batch_size > 1) { OP_REQUIRES( ctx, perm_shape.dim_size(0) == *batch_size, errors::InvalidArgument(""permutation must have the same batch size "" ""as sparse matrix; got: "", perm_shape.dim_size(0), "" != "", *batch_size)); } }"
"static void get_over(struct SYMBOL *s) { struct VOICE_S *p_voice, *p_voice2, *p_voice3; int range, voice, voice2, voice3; static char tx_wrong_dur[] = ""Wrong duration in voice overlay""; static char txt_no_note[] = ""No note in voice overlay""; p_voice = curvoice; if (p_voice->ignore) return; if (s->abc_type == ABC_T_BAR || s->u.v_over.type == V_OVER_E)  { if (!p_voice->last_sym) { error(1, s, txt_no_note); return; } p_voice->last_sym->sflags |= S_BEAM_END; over_bar = 0; if (over_time < 0) { error(1, s, ""Erroneous end of voice overlap""); return; } if (p_voice->time != over_mxtime) error(1, s, tx_wrong_dur); curvoice = &voice_tb[over_voice]; over_mxtime = 0; over_voice = -1; over_time = -1; return; } if (s->u.v_over.type == V_OVER_S) { over_voice = p_voice - voice_tb; over_time = p_voice->time; return; } if (!p_voice->last_sym) { error(1, s, txt_no_note); return; } p_voice->last_sym->sflags |= S_BEAM_END; voice2 = s->u.v_over.voice; p_voice2 = &voice_tb[voice2]; if (parsys->voice[voice2].range < 0) { int clone; if (cfmt.abc2pscompat) { error(1, s, ""Cannot have %%%%abc2pscompat""); cfmt.abc2pscompat = 0; } clone = p_voice->clone >= 0; p_voice2->id[0] = '&'; p_voice2->id[1] = '\0'; p_voice2->second = 1; parsys->voice[voice2].second = 1; p_voice2->scale = p_voice->scale; p_voice2->octave = p_voice->octave; p_voice2->transpose = p_voice->transpose; memcpy(&p_voice2->key, &p_voice->key, sizeof p_voice2->key); memcpy(&p_voice2->ckey, &p_voice->ckey, sizeof p_voice2->ckey); memcpy(&p_voice2->okey, &p_voice->okey, sizeof p_voice2->okey); p_voice2->posit = p_voice->posit; p_voice2->staff = p_voice->staff; p_voice2->cstaff = p_voice->cstaff; p_voice2->color = p_voice->color; p_voice2->map_name = p_voice->map_name; range = parsys->voice[p_voice - voice_tb].range; for (voice = 0; voice < MAXVOICE; voice++) { if (parsys->voice[voice].range > range) parsys->voice[voice].range += clone + 1; } parsys->voice[voice2].range = range + 1; voice_link(p_voice2); if (clone) { for (voice3 = MAXVOICE; --voice3 >= 0; ) { if (parsys->voice[voice3].range < 0) break; } if (voice3 > 0) { p_voice3 = &voice_tb[voice3]; strcpy(p_voice3->id, p_voice2->id); p_voice3->second = 1; parsys->voice[voice3].second = 1; p_voice3->scale = voice_tb[p_voice->clone].scale; parsys->voice[voice3].range = range + 2; voice_link(p_voice3); p_voice2->clone = voice3; } else { error(1, s, ""Too many voices for overlay cloning""); } } } voice = p_voice - voice_tb; if (over_time < 0) { int time; over_bar = 1; over_mxtime = p_voice->time; over_voice = voice; time = p_voice2->time; for (s = p_voice->last_sym; ; s = s->prev) { if (s->type == BAR || s->time <= time) break; } over_time = s->time; } else { if (over_mxtime == 0) over_mxtime = p_voice->time; else if (p_voice->time != over_mxtime) error(1, s, tx_wrong_dur); } p_voice2->time = over_time; curvoice = p_voice2; }"
"static unsigned long get_num_dynamic_syms (Filedata * filedata) { unsigned long num_of_syms = 0; if (!do_histogram && (!do_using_dynamic || do_dyn_syms)) return num_of_syms; if (dynamic_info[DT_HASH]) { unsigned char nb[8]; unsigned char nc[8]; unsigned int hash_ent_size = 4; if ((filedata->file_header.e_machine == EM_ALPHA || filedata->file_header.e_machine == EM_S390 || filedata->file_header.e_machine == EM_S390_OLD) && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64) hash_ent_size = 8; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, dynamic_info[DT_HASH], sizeof nb + sizeof nc)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); goto no_hash; } if (fread (nb, hash_ent_size, 1, filedata->handle) != 1) { error (_(""Failed to read in number of buckets\n"")); goto no_hash; } if (fread (nc, hash_ent_size, 1, filedata->handle) != 1) { error (_(""Failed to read in number of chains\n"")); goto no_hash; } nbuckets = byte_get (nb, hash_ent_size); nchains = byte_get (nc, hash_ent_size); num_of_syms = nchains; buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size); chains  = get_dynamic_data (filedata, nchains, hash_ent_size); no_hash: if (num_of_syms == 0) { if (buckets) { free (buckets); buckets = NULL; } if (chains) { free (chains); chains = NULL; } nbuckets = 0; } } if (dynamic_info_DT_GNU_HASH) { unsigned char nb[16]; bfd_vma i, maxchain = 0xffffffff, bitmaskwords; bfd_vma buckets_vma; unsigned long hn; bfd_boolean gnu_hash_error = FALSE; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH, sizeof nb)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } if (fread (nb, 16, 1, filedata->handle) != 1) { error (_(""Failed to read in number of buckets\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } ngnubuckets = byte_get (nb, 4); gnusymidx = byte_get (nb + 4, 4); bitmaskwords = byte_get (nb + 8, 4); buckets_vma = dynamic_info_DT_GNU_HASH + 16; if (is_32bit_elf) buckets_vma += bitmaskwords * 4; else buckets_vma += bitmaskwords * 8; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma, 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4); if (gnubuckets == NULL) { gnu_hash_error = TRUE; goto no_gnu_hash; } for (i = 0; i < ngnubuckets; i++) if (gnubuckets[i] != 0) { if (gnubuckets[i] < gnusymidx) { gnu_hash_error = TRUE; return FALSE; } if (maxchain == 0xffffffff || gnubuckets[i] > maxchain) maxchain = gnubuckets[i]; } if (maxchain == 0xffffffff) { gnu_hash_error = TRUE; goto no_gnu_hash; } maxchain -= gnusymidx; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma + 4 * (ngnubuckets + maxchain), 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } do { if (fread (nb, 4, 1, filedata->handle) != 1) { error (_(""Failed to determine last chain length\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } if (maxchain + 1 == 0) { gnu_hash_error = TRUE; goto no_gnu_hash; } ++maxchain; } while ((byte_get (nb, 4) & 1) == 0); if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } gnuchains = get_dynamic_data (filedata, maxchain, 4); ngnuchains = maxchain; if (gnuchains == NULL) { gnu_hash_error = TRUE; goto no_gnu_hash; } if (dynamic_info_DT_MIPS_XHASH) { if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, (buckets_vma + 4 * (ngnubuckets + maxchain)), 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } mipsxlat = get_dynamic_data (filedata, maxchain, 4); } for (hn = 0; hn < ngnubuckets; ++hn) if (gnubuckets[hn] != 0) { bfd_vma si = gnubuckets[hn]; bfd_vma off = si - gnusymidx; do { if (dynamic_info_DT_MIPS_XHASH) { if (mipsxlat[off] >= num_of_syms) num_of_syms = mipsxlat[off] + 1; } else { if (si >= num_of_syms) num_of_syms = si + 1; } si++; } while (off < ngnuchains && (gnuchains[off++] & 1) == 0); } no_gnu_hash: if (gnu_hash_error) { if (mipsxlat) { free (mipsxlat); mipsxlat = NULL; } if (gnuchains) { free (gnuchains); gnuchains = NULL; } if (gnubuckets) { free (gnubuckets); gnubuckets = NULL; } ngnubuckets = 0; ngnuchains = 0; } } return num_of_syms; }"
"int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags) { struct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg); int ret; ret = -EBADFD; if (!io_is_uring_fops(req->file)) goto done; switch (msg->cmd) { case IORING_MSG_DATA: ret = io_msg_ring_data(req); break; case IORING_MSG_SEND_FD: ret = io_msg_send_fd(req, issue_flags); break; default: ret = -EINVAL; break; } done: if (ret < 0) req_set_fail(req); io_req_set_res(req, ret, 0); io_put_file(req->file); req->file = NULL; return IOU_OK; }"
"static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) { if ( !bcf_hdr_nsamples(h) ) return 0; static int extreme_val_warned = 0; char *r, *t; int j, l, m, g, overflow = 0; khint_t k; ks_tokaux_t aux1; vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID]; kstring_t *mem = (kstring_t*)&h->mem; fmt_aux_t fmt[MAX_N_FMT]; mem->l = 0; char *end = s->s + s->l; if ( q>=end ) { hts_log_error(""FORMAT column with no sample columns starting at %s:%""PRIhts_pos"""", bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_NCOLS; return -1; } v->n_fmt = 0; if ( p[0]=='.' && p[1]==0 )     { v->n_sample = bcf_hdr_nsamples(h); return 0; } for (j = 0, t = kstrtok(p, "":"", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) { if (j >= MAX_N_FMT) { v->errcode |= BCF_ERR_LIMITS; hts_log_error(""FORMAT column at %s:%""PRIhts_pos"" lists more identifiers than htslib can handle"", bcf_seqname_safe(h,v), v->pos+1); return -1; } *(char*)aux1.p = 0; k = kh_get(vdict, d, t); if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) { if ( t[0]=='.' && t[1]==0 ) { hts_log_error(""Invalid FORMAT tag name '.' at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } hts_log_warning(""FORMAT '%s' at %s:%""PRIhts_pos"" is not defined in the header, assuming Type=String"", t, bcf_seqname_safe(h,v), v->pos+1); kstring_t tmp = {0,0,0}; int l; ksprintf(&tmp, ""##FORMAT=<ID=%s,Number=1,Type=String,Description=\""Dummy\"">"", t); bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l); free(tmp.s); int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1; if (res < 0) bcf_hrec_destroy(hrec); if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h); k = kh_get(vdict, d, t); v->errcode = BCF_ERR_TAG_UNDEF; if (res || k == kh_end(d)) { hts_log_error(""Could not add dummy header for FORMAT '%s' at %s:%""PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } } fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0; fmt[j].key = kh_val(d, k).id; fmt[j].is_gt = !strcmp(t, ""GT""); fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT]; v->n_fmt++; } int n_sample_ori = -1; r = q + 1;      l = 0, m = g = 1, v->n_sample = 0;      while ( r<end ) { if ( h->keep_samples ) { n_sample_ori++; if ( !bit_array_test(h->keep_samples,n_sample_ori) ) { while ( *r!='\t' && r<end ) r++; if ( *r=='\t' ) { *r = 0; r++; } continue; } } j = 0;          fmt_aux_t *f = fmt; for (;;) { switch (*r) { case ',': m++; break; case '|': case '/': if (f->is_gt) g++; break; case '\t': *r = 0;  case '\0': case ':': if (f->max_m < m) f->max_m = m; if (f->max_l < l) f->max_l = l; if (f->is_gt && f->max_g < g) f->max_g = g; l = 0, m = g = 1; if ( *r==':' ) { j++; f++; if ( j>=v->n_fmt ) { hts_log_error(""Incorrect number of FORMAT fields at %s:%""PRIhts_pos"""", h->id[BCF_DT_CTG][v->rid].key, v->pos+1); v->errcode |= BCF_ERR_NCOLS; return -1; } } else goto end_for; break; } if ( r>=end ) break; r++; l++; } end_for: v->n_sample++; if ( v->n_sample == bcf_hdr_nsamples(h) ) break; r++; } for (j = 0; j < v->n_fmt; ++j) { fmt_aux_t *f = &fmt[j]; if ( !f->max_m ) f->max_m = 1;          if ((f->y>>4&0xf) == BCF_HT_STR) { f->size = f->is_gt? f->max_g << 2 : f->max_l; } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) { f->size = f->max_m << 2; } else { hts_log_error(""The format type %d at %s:%""PRIhts_pos"" is currently not supported"", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } if (align_mem(mem) < 0) { hts_log_error(""Memory allocation failure at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } f->offset = mem->l; if (v->n_sample * (uint64_t)f->size > INT_MAX) { hts_log_error(""Excessive memory required by FORMAT fields at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) { hts_log_error(""Memory allocation failure at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } mem->l += v->n_sample * f->size; } for (j = 0; j < v->n_fmt; ++j) fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset; n_sample_ori = -1; t = q + 1; m = 0;       while ( t<end ) { if ( h->keep_samples ) { n_sample_ori++; if ( !bit_array_test(h->keep_samples,n_sample_ori) ) { while ( *t && t<end ) t++; t++; continue; } } if ( m == bcf_hdr_nsamples(h) ) break; j = 0;         while ( t < end ) { fmt_aux_t *z = &fmt[j++]; if (!z->buf) { hts_log_error(""Memory allocation failure for FORMAT field type %d at %s:%""PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } if ((z->y>>4&0xf) == BCF_HT_STR) { if (z->is_gt) {                     int32_t is_phased = 0; uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m); uint32_t unreadable = 0; uint32_t max = 0; overflow = 0; for (l = 0;; ++t) { if (*t == '.') { ++t, x[l++] = is_phased; } else { char *tt = t; uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow); unreadable |= tt == t; if (max < val) max = val; x[l++] = (val + 1) << 1 | is_phased; } is_phased = (*t == '|'); if (*t != '|' && *t != '/') break; } if (overflow || max > (INT32_MAX >> 1) - 1) { hts_log_error(""Couldn't read GT data: value too large at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } if (unreadable) { hts_log_error(""Couldn't read GT data: value not a number or '.' at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } if ( !l ) x[l++] = 0;                       for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else { char *x = (char*)z->buf + z->size * (size_t)m; for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t; for (; l < z->size; ++l) x[l] = 0; } } else if ((z->y>>4&0xf) == BCF_HT_INT) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); for (l = 0;; ++t) { if (*t == '.') { x[l++] = bcf_int32_missing, ++t;                     } else { overflow = 0; char *te; long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow); if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 ) { if ( !extreme_val_warned ) { hts_log_warning(""Extreme FORMAT/%s value encountered and set to missing at %s:%""PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1); extreme_val_warned = 1; } tmp_val = bcf_int32_missing; } x[l++] = tmp_val; t = te; } if (*t != ',') break; } if ( !l ) x[l++] = bcf_int32_missing; for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else if ((z->y>>4&0xf) == BCF_HT_REAL) { float *x = (float*)(z->buf + z->size * (size_t)m); for (l = 0;; ++t) { if (*t == '.' && !isdigit_c(t[1])) { bcf_float_set_missing(x[l++]), ++t;                     } else { overflow = 0; char *te; float tmp_val = hts_str2dbl(t, &te, &overflow); if ( (te==t || overflow) && !extreme_val_warned ) { hts_log_warning(""Extreme FORMAT/%s value encountered at %s:%""PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1); extreme_val_warned = 1; } x[l++] = tmp_val; t = te; } if (*t != ',') break; } if ( !l ) bcf_float_set_missing(x[l++]);                    for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]); } else { hts_log_error(""Unknown FORMAT field type %d at %s:%""PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } if (*t == '\0') { break; } else if (*t == ':') { t++; } else { char buffer[8]; hts_log_error(""Invalid character %s in '%s' FORMAT field at %s:%""PRIhts_pos"""", hts_strprint(buffer, sizeof buffer, '\'', t, 1), h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_CHAR; return -1; } } for (; j < v->n_fmt; ++j) {             fmt_aux_t *z = &fmt[j]; if ((z->y>>4&0xf) == BCF_HT_STR) { if (z->is_gt) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); if (z->size) x[0] = bcf_int32_missing; for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else { char *x = (char*)z->buf + z->size * (size_t)m; if ( z->size ) x[0] = '.'; for (l = 1; l < z->size; ++l) x[l] = 0; } } else if ((z->y>>4&0xf) == BCF_HT_INT) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); x[0] = bcf_int32_missing; for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else if ((z->y>>4&0xf) == BCF_HT_REAL) { float *x = (float*)(z->buf + z->size * (size_t)m); bcf_float_set_missing(x[0]); for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]); } } m++; t++; } kstring_t *str = &v->indiv; int i; if (v->n_sample > 0) { for (i = 0; i < v->n_fmt; ++i) { fmt_aux_t *z = &fmt[i]; bcf_enc_int1(str, z->key); if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) { bcf_enc_size(str, z->size, BCF_BT_CHAR); kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str); } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) { bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2); } else { bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT); if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample, (float *) z->buf) != 0) { v->errcode |= BCF_ERR_LIMITS; hts_log_error(""Out of memory at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } } } } if ( v->n_sample!=bcf_hdr_nsamples(h) ) { hts_log_error(""Number of columns at %s:%""PRIhts_pos"" does not match the number of samples (%d vs %d)"", bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h)); v->errcode |= BCF_ERR_NCOLS; return -1; } if ( v->indiv.l > 0xffffffff ) { hts_log_error(""The FORMAT at %s:%""PRIhts_pos"" is too long"", bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; v->n_fmt = 0; return -1; } return 0; }"
"static void input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len) { uint16_t frame_len; uint16_t payload_len; if(data_len < 4) { LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len); return; } if(channel->rx_buffer.sdu_length == 0) { memcpy(&frame_len, &data[0], 2); payload_len = frame_len - 2; if(payload_len > BLE_L2CAP_NODE_MTU) { LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len); return; } memcpy(&channel->rx_buffer.sdu_length, &data[4], 2); memcpy(channel->rx_buffer.sdu, &data[6], payload_len); channel->rx_buffer.current_index = payload_len; } else { memcpy(&frame_len, &data[0], 2); payload_len = frame_len; if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) { LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len); return; } memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len); channel->rx_buffer.current_index += payload_len; } if((channel->rx_buffer.sdu_length > 0) && (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) { memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length); packetbuf_set_datalen(channel->rx_buffer.sdu_length); NETSTACK_NETWORK.input(); channel->rx_buffer.sdu_length = 0; channel->rx_buffer.current_index = 0; } }"
"static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) { redisContext *c = &(ac->c); redisAeEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisAeEvents*)hiredis_safe_malloc(sizeof(*e)); e->context = ac; e->loop = loop; e->fd = c->fd; e->reading = e->writing = 0; ac->ev.addRead = redisAeAddRead; ac->ev.delRead = redisAeDelRead; ac->ev.addWrite = redisAeAddWrite; ac->ev.delWrite = redisAeDelWrite; ac->ev.cleanup = redisAeCleanup; ac->ev.data = e; return REDIS_OK; }"
"bz3_state * bz3_new(s32 block_size) { if (block_size < KiB(65) || block_size > MiB(511)) { return NULL; } struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state)); if (!bz3_state) { return NULL; } bz3_state->cm_state = malloc(sizeof(state)); bz3_state->swap_buffer = malloc(bz3_bound(block_size)); bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32)); memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128)); bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32)); if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) { if (bz3_state->cm_state) free(bz3_state->cm_state); if (bz3_state->swap_buffer) free(bz3_state->swap_buffer); if (bz3_state->sais_array) free(bz3_state->sais_array); if (bz3_state->lzp_lut) free(bz3_state->lzp_lut); free(bz3_state); return NULL; } bz3_state->block_size = block_size; bz3_state->last_error = BZ3_OK; return bz3_state; }"
"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) { OpData* op_data = reinterpret_cast<OpData*>(node->user_data); int num_inputs = node->inputs->size; TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs); Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_); auto* subgraphs = this_subgraph->GetSubgraphs(); TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size()); TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size()); Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get(); Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get(); TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs); TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1); TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs); TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs); TF_LITE_ENSURE_OK( context, CopyTensorsShapeAndType( context, this_subgraph, TfLiteIntArrayView(node->inputs), cond_subgraph, cond_subgraph->inputs(), true)); TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors()); TfLiteTensor* cond_output = cond_subgraph->tensor(cond_subgraph->outputs()[0]); if (IsDynamicTensor(cond_output)) { op_data->cond_has_dynamic_output_tensors = true; } else { TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output)); } TF_LITE_ENSURE_OK( context, CopyTensorsShapeAndType( context, this_subgraph, TfLiteIntArrayView(node->inputs), body_subgraph, body_subgraph->inputs(), true)); TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors()); if (body_subgraph->HasDynamicTensors()) { op_data->body_has_dynamic_output_tensors = true; } else { for (int i = 0; i < num_inputs; ++i) { TfLiteTensor* body_input = body_subgraph->tensor(body_subgraph->inputs()[i]); TfLiteTensor* body_output = body_subgraph->tensor(body_subgraph->outputs()[i]); TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type); TF_LITE_ENSURE(context, !IsDynamicTensor(body_output)); if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) { op_data->body_has_dynamic_output_tensors = true; break; } } } for (int i = 0; i < num_inputs; ++i) { TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output)); if (op_data->body_has_dynamic_output_tensors) { SetTensorToDynamic(output); } else { TfLiteTensor* body_output = body_subgraph->tensor(body_subgraph->outputs()[i]); TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output, output_size)); } } return kTfLiteOk; }"
"static RzList  *__io_maps(RzDebug *dbg) { RzList *list = rz_list_new(); char *str = dbg->iob.system(dbg->iob.io, ""dm""); if (!str) { rz_list_free(list); return NULL; } char *ostr = str; ut64 map_start, map_end; char perm[32]; char name[512]; for (;;) { char *nl = strchr(str, '\n'); if (nl) { *nl = 0; *name = 0; *perm = 0; map_start = map_end = 0LL; if (!strncmp(str, ""sys "", 4)) { char *sp = strchr(str + 4, ' '); if (sp) { str = sp + 1; } else { str += 4; } } char *_s_ = strstr(str, "" s ""); if (_s_) { memmove(_s_, _s_ + 2, strlen(_s_)); } _s_ = strstr(str, "" ? ""); if (_s_) { memmove(_s_, _s_ + 2, strlen(_s_)); } sscanf(str, ""0x%"" PFMT64x "" - 0x%"" PFMT64x "" %s %s"", &map_start, &map_end, perm, name); if (map_end != 0LL) { RzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0); rz_list_append(list, map); } str = nl + 1; } else { break; } } free(ostr); rz_cons_reset(); return list; }"
"void proto_register_blip(void) { static hf_register_info hf[] = { { &hf_blip_message_number, { ""Message Number"", ""blip.messagenum"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_frame_flags, { ""Frame Flags"", ""blip.frameflags"", FT_UINT8, BASE_HEX | BASE_EXT_STRING, &flag_combos_ext, 0x0, NULL, HFILL } }, { &hf_blip_properties_length, { ""Properties Length"", ""blip.propslength"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_properties, { ""Properties"", ""blip.props"", FT_STRING, STR_UNICODE, NULL, 0x0, NULL, HFILL } }, { &hf_blip_message_body, { ""Message Body"", ""blip.messagebody"", FT_STRING, STR_UNICODE, NULL, 0x0, NULL, HFILL } }, { &hf_blip_ack_size, { ""ACK num bytes"", ""blip.numackbytes"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_checksum, { ""Checksum"", ""blip.checksum"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } } }; static gint *ett[] = { &ett_blip }; proto_blip = proto_register_protocol(""BLIP Couchbase Mobile"", ""BLIP"", ""blip""); proto_register_field_array(proto_blip, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); blip_handle = register_dissector(""blip"", dissect_blip, proto_blip); }"
"static int sctp_init_sock(struct sock *sk) { struct net *net = sock_net(sk); struct sctp_sock *sp; pr_debug(""%s: sk:%p\n"", __func__, sk); sp = sctp_sk(sk); switch (sk->sk_type) { case SOCK_SEQPACKET: sp->type = SCTP_SOCKET_UDP; break; case SOCK_STREAM: sp->type = SCTP_SOCKET_TCP; break; default: return -ESOCKTNOSUPPORT; } sk->sk_gso_type = SKB_GSO_SCTP; sp->default_stream = 0; sp->default_ppid = 0; sp->default_flags = 0; sp->default_context = 0; sp->default_timetolive = 0; sp->default_rcv_context = 0; sp->max_burst = net->sctp.max_burst; sp->sctp_hmac_alg = net->sctp.sctp_hmac_alg; sp->initmsg.sinit_num_ostreams   = sctp_max_outstreams; sp->initmsg.sinit_max_instreams  = sctp_max_instreams; sp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init; sp->initmsg.sinit_max_init_timeo = net->sctp.rto_max; sp->rtoinfo.srto_initial = net->sctp.rto_initial; sp->rtoinfo.srto_max     = net->sctp.rto_max; sp->rtoinfo.srto_min     = net->sctp.rto_min; sp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association; sp->assocparams.sasoc_number_peer_destinations = 0; sp->assocparams.sasoc_peer_rwnd = 0; sp->assocparams.sasoc_local_rwnd = 0; sp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life; sp->subscribe = 0; sp->hbinterval  = net->sctp.hb_interval; sp->udp_port    = htons(net->sctp.udp_port); sp->encap_port  = htons(net->sctp.encap_port); sp->pathmaxrxt  = net->sctp.max_retrans_path; sp->pf_retrans  = net->sctp.pf_retrans; sp->ps_retrans  = net->sctp.ps_retrans; sp->pf_expose   = net->sctp.pf_expose; sp->pathmtu     = 0;  sp->sackdelay   = net->sctp.sack_timeout; sp->sackfreq= 2; sp->param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE; sp->default_ss = SCTP_SS_DEFAULT; sp->disable_fragments = 0; sp->nodelay           = 0; sp->recvrcvinfo = 0; sp->recvnxtinfo = 0; sp->v4mapped          = 1; sp->autoclose         = 0; sp->user_frag         = 0; sp->adaptation_ind = 0; sp->pf = sctp_get_pf_specific(sk->sk_family); atomic_set(&sp->pd_mode, 0); skb_queue_head_init(&sp->pd_lobby); sp->frag_interleave = 0; sp->ep = sctp_endpoint_new(sk, GFP_KERNEL); if (!sp->ep) return -ENOMEM; sp->hmac = NULL; sk->sk_destruct = sctp_destruct_sock; SCTP_DBG_OBJCNT_INC(sock); local_bh_disable(); sk_sockets_allocated_inc(sk); sock_prot_inuse_add(net, sk->sk_prot, 1); if (net->sctp.default_auto_asconf) { spin_lock(&sock_net(sk)->sctp.addr_wq_lock); list_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist); sp->do_auto_asconf = 1; spin_unlock(&sock_net(sk)->sctp.addr_wq_lock); } else { sp->do_auto_asconf = 0; } local_bh_enable(); return 0; }"
"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) { RList *segments = bin->segments; if (!segments) { return NULL; } RList *entries = bin->entries; if (!entries) { return NULL; } RList *symbols = bin->symbols; if (!symbols) { return NULL; } ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16)); if (!modref) { return NULL; } r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16)); RList *relocs = r_list_newf (free); if (!relocs) { free (modref); return NULL; } RListIter *it; RBinSection *seg; int index = -1; r_list_foreach (segments, it, seg) { index++; if (!(bin->segment_entries[index].flags & RELOCINFO)) { continue; } ut32 off, start = off = seg->paddr + seg->size; ut16 length = r_buf_read_le16_at (bin->buf, off); if (!length) { continue; } off += 2; while (off < start + length * sizeof (NE_image_reloc_item)) { RBinReloc *reloc = R_NEW0 (RBinReloc); if (!reloc) { return NULL; } NE_image_reloc_item rel; r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)); reloc->paddr = seg->paddr + rel.offset; switch (rel.type) { case LOBYTE: reloc->type = R_BIN_RELOC_8; break; case SEL_16: case OFF_16: reloc->type = R_BIN_RELOC_16; break; case POI_32: case OFF_32: reloc->type = R_BIN_RELOC_32; break; case POI_48: reloc->type = R_BIN_RELOC_64; break; } ut32 offset; if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) { RBinImport *imp = R_NEW0 (RBinImport); if (!imp) { free (reloc); break; } char *name; if (rel.index > bin->ne_header->ModRefs) { name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); } else { offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; name = __read_nonnull_str_at (bin->buf, offset); } if (rel.flags & IMPORTED_ORD) { imp->ordinal = rel.func_ord; imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord)); } else { offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off; char *func = __read_nonnull_str_at (bin->buf, offset); imp->name = r_str_newf (""%s.%s"", name, func); free (func); } free (name); reloc->import = imp; } else if (rel.flags & OSFIXUP) { } else { if (strstr (seg->name, ""FIXED"")) { RBinSection *s = r_list_get_n (segments, rel.segnum - 1); if (s) { offset = s->paddr + rel.segoff; } else { offset = -1; } } else { RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1); if (entry) { offset = entry->paddr; } else { offset = -1; } } reloc->addend = offset; RBinSymbol *sym = NULL; RListIter *sit; r_list_foreach (symbols, sit, sym) { if (sym->paddr == reloc->addend) { reloc->symbol = sym; break; } } } if (rel.flags & ADDITIVE) { reloc->additive = 1; r_list_append (relocs, reloc); } else { do { r_list_append (relocs, reloc); offset = r_buf_read_le16_at (bin->buf, reloc->paddr); RBinReloc *tmp = reloc; reloc = R_NEW0 (RBinReloc); if (!reloc) { break; } *reloc = *tmp; reloc->paddr = seg->paddr + offset; } while (offset != 0xFFFF); free (reloc); } off += sizeof (NE_image_reloc_item); } } free (modref); return relocs; }"
"njs_int_t njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array, uint32_t index, njs_value_t *setval) { double              num; njs_int_t           ret; njs_array_buffer_t  *buffer; ret = njs_value_to_number(vm, setval, &num); if (njs_slow_path(ret != NJS_OK)) { return ret; } buffer = njs_typed_array_writable(vm, array); if (njs_slow_path(buffer == NULL)) { return NJS_ERROR; } njs_typed_array_prop_set(vm, array, index, num); njs_set_number(setval, num); return NJS_OK; }"
"long fuse_ioctl_common(struct file *file, unsigned int cmd, unsigned long arg, unsigned int flags) { struct inode *inode = file_inode(file); struct fuse_conn *fc = get_fuse_conn(inode); if (!fuse_allow_current_process(fc)) return -EACCES; if (is_bad_inode(inode)) return -EIO; return fuse_do_ioctl(file, cmd, arg, flags); }"
"struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *dev, enum mtk_vcodec_fw_use fw_use) { struct platform_device *fw_pdev; struct mtk_vcodec_fw *fw; enum rst_id rst_id; switch (fw_use) { case ENCODER: rst_id = VPU_RST_ENC; break; case DECODER: default: rst_id = VPU_RST_DEC; break; } fw_pdev = vpu_get_plat_device(dev->plat_dev); if (!fw_pdev) { mtk_v4l2_err(""firmware device is not ready""); return ERR_PTR(-EINVAL); } vpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id); fw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL); fw->type = VPU; fw->ops = &mtk_vcodec_vpu_msg; fw->pdev = fw_pdev; return fw; }"
"static const char* ConvertScalar(PyObject* v, Eigen::half* out) { Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v)); double v_double = PyFloat_AS_DOUBLE(as_float.get()); *out = Eigen::half(v_double); return nullptr; }"
"void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet) { if (!checkEvidenceAccess(area)) return; bool is_int = false; int idx = argv[0].toInt(&is_int); AreaData::Evidence evi = {argv[1], argv[2], argv[3]}; if (is_int && idx <= area->evidence().size() && idx >= 0) { area->replaceEvidence(idx, evi); } sendEvidenceList(area); }"
"void CExifParse::ProcessGpsInfo( const unsigned char* const DirStart, int ByteCountUnused, const unsigned char* const OffsetBase, unsigned ExifLength) { int NumDirEntries = Get16(DirStart, m_MotorolaOrder); for (int de=0;de<NumDirEntries;de++) { const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de); if (DirEntry + 12 > OffsetBase + ExifLength) { ErrNonfatal(""GPS info directory goes past end of exif"", 0, 0); return; } unsigned Tag        = Get16(DirEntry, m_MotorolaOrder); unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder); unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder); if (Format == 0 || Format > NUM_FORMATS) { ErrNonfatal(""Illegal number format %d for tag %04x"", Format, Tag); continue; } unsigned ComponentSize = BytesPerFormat[Format - 1]; unsigned ByteCount = Components * ComponentSize; const unsigned char* ValuePtr; if (ByteCount > 4) { unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder); if (OffsetVal+ByteCount > ExifLength) { ErrNonfatal(""Illegal value pointer for tag %04x"", Tag,0); continue; } ValuePtr = OffsetBase+OffsetVal; } else { ValuePtr = DirEntry+8; } switch(Tag) { case TAG_GPS_LAT_REF: m_ExifInfo->GpsLat[0] = ValuePtr[0]; m_ExifInfo->GpsLat[1] = 0; break; case TAG_GPS_LONG_REF: m_ExifInfo->GpsLong[0] = ValuePtr[0]; m_ExifInfo->GpsLong[1] = 0; break; case TAG_GPS_LAT: GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat); break; case TAG_GPS_LONG: GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong); break; case TAG_GPS_ALT_REF: if (ValuePtr[0] != 0) m_ExifInfo->GpsAlt[0] = '-'; m_ExifInfo->GpsAlt[1] = 0; break; case TAG_GPS_ALT: { char temp[18]; sprintf(temp, ""%.2fm"", static_cast<double>(ConvertAnyFormat(ValuePtr, Format))); strcat(m_ExifInfo->GpsAlt, temp); } break; } } }"
"inline bool ClientImpl::write_request(Stream &strm, Request &req, bool close_connection, Error &error) { if (close_connection) { if (!req.has_header(""Connection"")) { req.headers.emplace(""Connection"", ""close""); } } if (!req.has_header(""Host"")) { if (is_ssl()) { if (port_ == 443) { req.headers.emplace(""Host"", host_); } else { req.headers.emplace(""Host"", host_and_port_); } } else { if (port_ == 80) { req.headers.emplace(""Host"", host_); } else { req.headers.emplace(""Host"", host_and_port_); } } } if (!req.has_header(""Accept"")) { req.headers.emplace(""Accept"", ""*/*""); } #ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT if (!req.has_header(""User-Agent"")) { auto agent = std::string(""cpp-httplib/"") + CPPHTTPLIB_VERSION; req.headers.emplace(""User-Agent"", agent); } #endif if (req.body.empty()) { if (req.content_provider_) { if (!req.is_chunked_content_provider_) { if (!req.has_header(""Content-Length"")) { auto length = std::to_string(req.content_length_); req.headers.emplace(""Content-Length"", length); } } } else { if (req.method == ""POST"" || req.method == ""PUT"" || req.method == ""PATCH"") { req.headers.emplace(""Content-Length"", ""0""); } } } else { if (!req.has_header(""Content-Type"")) { req.headers.emplace(""Content-Type"", ""text/plain""); } if (!req.has_header(""Content-Length"")) { auto length = std::to_string(req.body.size()); req.headers.emplace(""Content-Length"", length); } } if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) { if (!req.has_header(""Authorization"")) { req.headers.insert(make_basic_authentication_header( basic_auth_username_, basic_auth_password_, false)); } } if (!proxy_basic_auth_username_.empty() && !proxy_basic_auth_password_.empty()) { if (!req.has_header(""Proxy-Authorization"")) { req.headers.insert(make_basic_authentication_header( proxy_basic_auth_username_, proxy_basic_auth_password_, true)); } } if (!bearer_token_auth_token_.empty()) { if (!req.has_header(""Authorization"")) { req.headers.insert(make_bearer_token_authentication_header( bearer_token_auth_token_, false)); } } if (!proxy_bearer_token_auth_token_.empty()) { if (!req.has_header(""Proxy-Authorization"")) { req.headers.insert(make_bearer_token_authentication_header( proxy_bearer_token_auth_token_, true)); } } { detail::BufferStream bstrm; const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path; bstrm.write_format(""%s %s HTTP/1.1\r\n"", req.method.c_str(), path.c_str()); detail::write_headers(bstrm, req.headers); auto &data = bstrm.get_buffer(); if (!detail::write_data(strm, data.data(), data.size())) { error = Error::Write; return false; } } if (req.body.empty()) { return write_content_with_provider(strm, req, error); } if (!detail::write_data(strm, req.body.data(), req.body.size())) { error = Error::Write; return false; } return true; }"
static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf->vma; struct udmabuf *ubuf = vma->vm_private_data; vmf->page = ubuf->pages[vmf->pgoff]; get_page(vmf->page); return 0; }
void AccountSettings::slotOpenOC() { if (_OCUrl.isValid()) QDesktopServices::openUrl(_OCUrl); }
"status_t CursorWindow::writeToParcel(Parcel* parcel) { LOG(DEBUG) << ""Writing to parcel: "" << this->toString(); if (parcel->writeString8(mName)) goto fail; if (parcel->writeUint32(mNumRows)) goto fail; if (parcel->writeUint32(mNumColumns)) goto fail; if (mAshmemFd != -1) { if (parcel->writeUint32(mSize)) goto fail; if (parcel->writeBool(true)) goto fail; if (parcel->writeDupFileDescriptor(mAshmemFd)) goto fail; } else { size_t slotsSize = mSize - mSlotsOffset; size_t compactedSize = mAllocOffset + slotsSize; compactedSize = (compactedSize + 3) & ~3; if (parcel->writeUint32(compactedSize)) goto fail; if (parcel->writeBool(false)) goto fail; void* dest = parcel->writeInplace(compactedSize); if (!dest) goto fail; memcpy(static_cast<uint8_t*>(dest), static_cast<uint8_t*>(mData), mAllocOffset); memcpy(static_cast<uint8_t*>(dest) + compactedSize - slotsSize, static_cast<uint8_t*>(mData) + mSlotsOffset, slotsSize); } return OK; fail: LOG(ERROR) << ""Failed writeToParcel""; fail_silent: return UNKNOWN_ERROR; }"
"int nbd_unlocked_opt_info (struct nbd_handle *h) { int err; nbd_completion_callback c = { .callback = go_complete, .user_data = &err }; int r = nbd_unlocked_aio_opt_info (h, &c); if (r == -1) return r; r = wait_for_option (h); if (r == 0 && err) { assert (nbd_internal_is_state_negotiating (get_next_state (h))); set_error (err, ""server replied with error to opt_info request""); return -1; } return r; }"
"void my_error_exit( j_common_ptr cinfo ) { my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err); longjmp( myerr->setjmp_buffer, 1 ); }"
"void agoo_http_init() { const char**kp = header_keys; memset(&key_cache, 0, sizeof(struct _cache)); for (; NULL != *kp; kp++) { key_set(*kp); } }"
"int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags) { uint8_t b[192]; uint8_t nchan, nord, npat, nsmp; uint16_t ntrk, comment_len; int n, pat, chan, smp, rows, todo = 0; song_note_t *note; uint16_t tmp; uint32_t tmplong; song_note_t **trackdata, *tracknote; song_sample_t *sample; slurp_read(fp, b, 3); if (memcmp(b, ""MTM"", 3) != 0) return LOAD_UNSUPPORTED; n = slurp_getc(fp); sprintf(song->tracker_id, ""MultiTracker %d.%d"", n >> 4, n & 0xf); slurp_read(fp, song->title, 20); song->title[20] = 0; slurp_read(fp, &ntrk, 2); ntrk = bswapLE16(ntrk); npat = slurp_getc(fp); nord = slurp_getc(fp) + 1; slurp_read(fp, &comment_len, 2); comment_len = bswapLE16(comment_len); nsmp = slurp_getc(fp); slurp_getc(fp);  rows = slurp_getc(fp);  if (rows != 64) todo |= 64; rows = MIN(rows, 64); nchan = slurp_getc(fp); if (slurp_eof(fp)) { return LOAD_FORMAT_ERROR; } for (n = 0; n < 32; n++) { int pan = slurp_getc(fp) & 0xf; pan = SHORT_PANNING(pan); pan *= 4; song->channels[n].panning = pan; } for (n = nchan; n < MAX_CHANNELS; n++) song->channels[n].flags = CHN_MUTE; if (nsmp > MAX_SAMPLES) { log_appendf(4, "" Warning: Too many samples""); } for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) { if (n > MAX_SAMPLES) { slurp_seek(fp, 37, SEEK_CUR); continue; } char name[23]; slurp_read(fp, name, 22); name[22] = '\0'; strcpy(sample->name, name); slurp_read(fp, &tmplong, 4); sample->length = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_start = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_end = bswapLE32(tmplong); if ((sample->loop_end - sample->loop_start) > 2) { sample->flags |= CHN_LOOP; } else { sample->loop_start = 0; sample->loop_end = 0; } song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp)); sample->volume = slurp_getc(fp); sample->volume *= 4; sample->global_volume = 64; if (slurp_getc(fp) & 1) { todo |= 16; sample->flags |= CHN_16BIT; sample->length >>= 1; sample->loop_start >>= 1; sample->loop_end >>= 1; } song->samples[n].vib_type = 0; song->samples[n].vib_rate = 0; song->samples[n].vib_depth = 0; song->samples[n].vib_speed = 0; } slurp_read(fp, song->orderlist, 128); memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord); trackdata = mem_calloc(ntrk, sizeof(song_note_t *)); for (n = 0; n < ntrk; n++) { slurp_read(fp, b, 3 * rows); trackdata[n] = mem_calloc(rows, sizeof(song_note_t)); mtm_unpack_track(b, trackdata[n], rows); } if (npat >= MAX_PATTERNS) { log_appendf(4, "" Warning: Too many patterns""); } for (pat = 0; pat <= npat; pat++) { if (pat >= MAX_PATTERNS) { slurp_seek(fp, 64, SEEK_CUR); continue; } song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32)); song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64; tracknote = trackdata[n]; for (chan = 0; chan < 32; chan++) { slurp_read(fp, &tmp, 2); tmp = bswapLE16(tmp); if (tmp == 0) { continue; } else if (tmp > ntrk) { for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); return LOAD_FORMAT_ERROR; } note = song->patterns[pat] + chan; tracknote = trackdata[tmp - 1]; for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS) *note = *tracknote; } if (rows < 32) { note = song->patterns[pat] + 64 * (rows - 1); while (note->effect || note->param) note++; note->effect = FX_PATTERNBREAK; } } for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); read_lined_message(song->message, fp, comment_len, 40); if (!(lflags & LOAD_NOSAMPLES)) { for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) { uint32_t ssize; if (song->samples[smp].length == 0) continue; ssize = csf_read_sample(song->samples + smp, (SF_LE | SF_PCMU | SF_M | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)), fp->data + fp->pos, fp->length - fp->pos); slurp_seek(fp, ssize, SEEK_CUR); } } song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX; if (todo & 64) log_appendf(2, "" TODO: test this file with other players (beats per track != 64)""); if (todo & 16) log_appendf(2, "" TODO: double check 16 bit sample loading""); return LOAD_SUCCESS; }"
"static Http2Error rcv_priority_frame(Http2ConnectionState &cstate, const Http2Frame &frame) { const Http2StreamId stream_id = frame.header().streamid; const uint32_t payload_length = frame.header().length; Http2StreamDebug(cstate.session, stream_id, ""Received PRIORITY frame""); if (cstate.get_zombie_event()) { Warning(""Priority frame for zombied session %"" PRId64, cstate.session->get_connection_id()); } if (stream_id == 0) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""priority 0 stream_id""); } if (payload_length != HTTP2_PRIORITY_LEN) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_STREAM, Http2ErrorCode::HTTP2_ERROR_FRAME_SIZE_ERROR, ""priority bad length""); } uint8_t buf[HTTP2_PRIORITY_LEN] = {0}; frame.reader()->memcpy(buf, HTTP2_PRIORITY_LEN, 0); Http2Priority priority; if (!http2_parse_priority_parameter(make_iovec(buf, HTTP2_PRIORITY_LEN), priority)) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""priority parse error""); } if (stream_id == priority.stream_dependency) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_STREAM, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""PRIORITY frame depends on itself""); } if (!Http2::stream_priority_enabled) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_NONE); } cstate.increment_received_priority_frame_count(); if (Http2::max_priority_frames_per_minute != 0 && cstate.get_received_priority_frame_count() > Http2::max_priority_frames_per_minute) { HTTP2_INCREMENT_THREAD_DYN_STAT(HTTP2_STAT_MAX_PRIORITY_FRAMES_PER_MINUTE_EXCEEDED, this_ethread()); Http2StreamDebug(cstate.session, stream_id, ""Observed too frequent priority changes: %u priority changes within a last minute"", cstate.get_received_priority_frame_count()); return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_ENHANCE_YOUR_CALM, ""recv priority too frequent priority changes""); } Http2StreamDebug(cstate.session, stream_id, ""PRIORITY - dep: %d, weight: %d, excl: %d, tree size: %d"", priority.stream_dependency, priority.weight, priority.exclusive_flag, cstate.dependency_tree->size()); Http2DependencyTree::Node *node = cstate.dependency_tree->find(stream_id); if (node != nullptr) { Http2StreamDebug(cstate.session, stream_id, ""Reprioritize""); cstate.dependency_tree->reprioritize(node, priority.stream_dependency, priority.exclusive_flag); if (is_debug_tag_set(""http2_priority"")) { std::stringstream output; cstate.dependency_tree->dump_tree(output); Debug(""http2_priority"", ""[%"" PRId64 ""] reprioritize %s"", cstate.session->get_connection_id(), output.str().c_str()); } } else { if (Http2::max_concurrent_streams_in > cstate.dependency_tree->size() - cstate.get_client_stream_count() + 1) { cstate.dependency_tree->add(priority.stream_dependency, stream_id, priority.weight, priority.exclusive_flag, nullptr); } } return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_NONE); }"
"static void naludmx_check_pid(GF_Filter *filter, GF_NALUDmxCtx *ctx, Bool force_au_flush) { u32 w, h, ew, eh; u8 *dsi, *dsi_enh; u32 dsi_size, dsi_enh_size; u32 crc_cfg, crc_cfg_enh; GF_Fraction sar; Bool has_hevc_base = GF_TRUE; Bool has_colr_info = GF_FALSE; if (ctx->analyze) { if (ctx->opid && !ctx->ps_modified) return; } else { if (!ctx->ps_modified) return; if (ctx->opid && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps))) return; } ctx->ps_modified = GF_FALSE; dsi = dsi_enh = NULL; if (ctx->notime) { ctx->cur_fps = ctx->fps; if (!ctx->cur_fps.num || !ctx->cur_fps.den) { ctx->cur_fps.num = 25000; ctx->cur_fps.den = 1000; } } if (ctx->codecid==GF_CODECID_HEVC) { naludmx_create_hevc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base); } else if (ctx->codecid==GF_CODECID_VVC) { naludmx_create_vvc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base); } else { naludmx_create_avc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar); } crc_cfg = crc_cfg_enh = 0; if (dsi) crc_cfg = gf_crc_32(dsi, dsi_size); if (dsi_enh) crc_cfg_enh = gf_crc_32(dsi_enh, dsi_enh_size); if (!ctx->analyze && (!w || !h)) { if (dsi) gf_free(dsi); if (dsi_enh) gf_free(dsi_enh); return; } if (!ctx->opid) { u32 slice_in_au = ctx->nb_slices_in_au; ctx->opid = gf_filter_pid_new(filter); naludmx_check_dur(filter, ctx); ctx->nb_slices_in_au = slice_in_au; } if ((ctx->crc_cfg == crc_cfg) && (ctx->crc_cfg_enh == crc_cfg_enh) && (ctx->width==w) && (ctx->height==h) && (ctx->sar.num * sar.den == ctx->sar.den * sar.num) ) { if (dsi) gf_free(dsi); if (dsi_enh) gf_free(dsi_enh); return; } if (force_au_flush) { naludmx_end_access_unit(ctx); } naludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE); if (!ctx->analyze && (gf_list_count(ctx->pck_queue)>1))  { GF_LOG(dsi_enh ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] xPS changed but could not flush frames before signaling state change %s\n"", ctx->log_name, dsi_enh ? ""- likely scalable xPS update"" : ""!"")); } gf_filter_pid_copy_properties(ctx->opid, ctx->ipid); if (!ctx->timescale) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL); if (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID)) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1)); ctx->width = w; ctx->height = h; ctx->sar = sar; ctx->crc_cfg = crc_cfg; ctx->crc_cfg_enh = crc_cfg_enh; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->width)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->height)); if (ew && eh) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH_MAX, & PROP_UINT( ew )); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT_MAX, & PROP_UINT( eh )); } if (ctx->sar.den) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC(ctx->sar)); else gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num)); if (ctx->explicit || !has_hevc_base) { u32 enh_cid = GF_CODECID_SVC; if (ctx->codecid==GF_CODECID_HEVC) enh_cid = GF_CODECID_LHVC; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(enh_cid)); if (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) ); } else { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid)); if (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) ); if (dsi_enh) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(dsi_enh, dsi_enh_size) ); } if (ctx->bitrate) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate)); } if ((ctx->codecid==GF_CODECID_HEVC) && gf_list_count(ctx->vps) ) { GF_Err e = naludmx_set_hevc_oinf(ctx, NULL); if (e) { GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[%s] Failed to create OINF chunk\n"", ctx->log_name)); } naludmx_set_hevc_linf(ctx); } if (ctx->duration.num) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration)); if (ctx->is_file ) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) ); } gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, ctx->interlaced ? & PROP_UINT(GF_TRUE) : NULL); if (ctx->codecid==GF_CODECID_HEVC) { HEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->sps_active_idx]; if (sps->colour_description_present_flag) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(sps->colour_primaries) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(sps->transfer_characteristic) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(sps->matrix_coeffs) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(sps->video_full_range_flag) ); has_colr_info = GF_TRUE; } } else if (ctx->codecid==GF_CODECID_VVC) { } else { if (ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui_parameters_present_flag && ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui.colour_description_present_flag) { AVC_VUI *vui = &ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(vui->colour_primaries) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(vui->transfer_characteristics) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(vui->matrix_coefficients) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(vui->video_full_range_flag) ); has_colr_info = GF_TRUE; } } if (!has_colr_info) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, NULL); } naludmx_update_clli_mdcv(ctx, GF_TRUE); naludmx_set_dolby_vision(ctx); }"
"void Compute(tensorflow::OpKernelContext* context) override { for (int ngram_width : ngram_widths_) { OP_REQUIRES( context, ngram_width > 0, errors::InvalidArgument(""ngram_widths must contain positive values"")); } const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); const int input_data_size = data->flat<tstring>().size(); const int splits_vec_size = splits_vec.size(); if (splits_vec_size > 0) { int prev_split = splits_vec(0); OP_REQUIRES(context, prev_split == 0, errors::InvalidArgument(""First split value must be 0, got "", prev_split)); for (int i = 1; i < splits_vec_size; ++i) { bool valid_splits = splits_vec(i) >= prev_split; valid_splits = valid_splits && (splits_vec(i) <= input_data_size); OP_REQUIRES(context, valid_splits, errors::InvalidArgument( ""Invalid split value "", splits_vec(i), "", must be in ["", prev_split, "", "", input_data_size, ""]"")); prev_split = splits_vec(i); } OP_REQUIRES(context, prev_split == input_data_size, errors::InvalidArgument( ""Last split value must be data size. Expected "", input_data_size, "", got "", prev_split)); } int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
"void Compute(OpKernelContext* context) override { Tensor encoded_t = context->input(0); auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>(); auto expected_class = metadata_.type_spec_proto().type_spec_class(); auto actual_class = encoded->metadata().type_spec_proto().type_spec_class(); OP_REQUIRES( context, expected_class == actual_class, errors::InvalidArgument( ""Expected a "", TypeSpecProto::TypeSpecClass_Name(expected_class), "" (based on `type_spec`), but `encoded` contains a "", TypeSpecProto::TypeSpecClass_Name(actual_class))); OpOutputList components; OP_REQUIRES_OK(context, context->output_list(""components"", &components)); int num_components = encoded->flat_components().size(); OP_REQUIRES(context, component_dtypes_.size() == num_components, errors::InvalidArgument(""Encoded value has "", num_components, "" tensor components; expected "", component_dtypes_.size(), "" components based on type_spec"")); for (int i = 0; i < component_dtypes_.size(); i++) { const Tensor& component = encoded->flat_components()[i]; OP_REQUIRES(context, component_dtypes_[i] == component.dtype(), errors::InvalidArgument(""Tensor component "", i, "" had dtype "", DataType_Name(component.dtype()), ""; expected dtype "", DataType_Name(component_dtypes_[i]))); components.set(i, component); } }"
"static Image *ReadLABELImage(const ImageInfo *image_info, ExceptionInfo *exception) { char geometry[MagickPathExtent], *label; DrawInfo *draw_info; Image *image; MagickBooleanType left_bearing, status; TypeMetric metrics; size_t height, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); if (IsEventLogging() != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); image=AcquireImage(image_info,exception); (void) ResetImagePage(image,""0x0+0+0""); if ((image->columns != 0) && (image->rows != 0)) { status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); (void) SetImageBackgroundColor(image,exception); } label=InterpretImageProperties((ImageInfo *) image_info,image, image_info->filename,exception); if (label == (char *) NULL) return(DestroyImageList(image)); (void) SetImageProperty(image,""label"",label,exception); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); width=(size_t) floor(0.5*draw_info->pointsize*strlen(label)+0.5); if (AcquireMagickResource(WidthResource,width) == MagickFalse) { label=DestroyString(label); draw_info=DestroyDrawInfo(draw_info); ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit""); } draw_info->text=ConstantString(label); (void) memset(&metrics,0,sizeof(metrics)); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); AdjustTypeMetricBounds(&metrics); if ((image->columns == 0) && (image->rows == 0)) { image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); } else if ((status != MagickFalse) && (strlen(label) > 0) && (((image->columns == 0) || (image->rows == 0)) || (fabs(image_info->pointsize) < MagickEpsilon))) { const char *option; double high, low; ssize_t n; low=1.0; option=GetImageOption(image_info,""label:max-pointsize""); if (option != (const char*) NULL) { high=StringToDouble(option,(char**) NULL); if (high < 1.0) high=1.0; high+=1.0; } else { option=GetImageOption(image_info,""label:start-pointsize""); if (option != (const char *) NULL) { draw_info->pointsize=StringToDouble(option,(char**) NULL); if (draw_info->pointsize < 1.0) draw_info->pointsize=1.0; } for (n=0; n < 32; n++, draw_info->pointsize*=2.0) { (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics, exception); if (status == MagickFalse) break; AdjustTypeMetricBounds(&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height-metrics.underline_position+ draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) || (height >= image->rows)) break; if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } if (status == MagickFalse) { label=DestroyString(label); draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } high=draw_info->pointsize; } while((high-low) > 0.5) { draw_info->pointsize=(low+high)/2.0; (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); if (status == MagickFalse) break; AdjustTypeMetricBounds(&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height-metrics.underline_position+ draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } if (status != MagickFalse) { draw_info->pointsize=floor((low+high)/2.0-0.5); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); AdjustTypeMetricBounds(&metrics); } } label=DestroyString(label); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } if (image->columns == 0) image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); if (image->columns == 0) image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+ 0.5); if (image->rows == 0) image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if (image->rows == 0) image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+ 0.5); status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image,exception) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } left_bearing=((draw_info->gravity == UndefinedGravity) || (draw_info->gravity == NorthWestGravity) || (draw_info->gravity == WestGravity) || (draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse; (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", (draw_info->direction == RightToLeftDirection ? (double) image->columns- (draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) :  (left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)), (draw_info->gravity == UndefinedGravity ?  MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0)); (void) CloneString(&draw_info->geometry,geometry); status=AnnotateImage(image,draw_info,exception); if (image_info->pointsize == 0.0) (void) FormatImageProperty(image,""label:pointsize"",""%.20g"", draw_info->pointsize); draw_info=DestroyDrawInfo(draw_info); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }"
"static inline struct file *io_file_get_fixed(struct io_ring_ctx *ctx, struct io_kiocb *req, int fd) { struct file *file; unsigned long file_ptr; if (unlikely((unsigned int)fd >= ctx->nr_user_files)) return NULL; fd = array_index_nospec(fd, ctx->nr_user_files); file_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr; file = (struct file *) (file_ptr & FFS_MASK); file_ptr &= ~FFS_MASK; req->flags |= (file_ptr << REQ_F_NOWAIT_READ_BIT); io_req_set_rsrc_node(req); return file; }"
"static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) { if (indx == NULL) { debug_print(""%s"", ""INDX structure not initialized\n""); return MOBI_INIT_FAILED; } const size_t entry_offset = indx->entries_count; const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number]; mobi_buffer_setpos(buf, idxt.offsets[curr_number]); size_t entry_number = curr_number + entry_offset; if (entry_number >= indx->total_entries_count) { debug_print(""Entry number beyond array: %zu\n"", entry_number); return MOBI_DATA_CORRUPT; } const size_t buf_maxlen = buf->maxlen; if (buf->offset + entry_length >= buf_maxlen) { debug_print(""Entry length too long: %zu\n"", entry_length); return MOBI_DATA_CORRUPT; } buf->maxlen = buf->offset + entry_length; size_t label_length = mobi_buffer_get8(buf); if (label_length > entry_length) { debug_print(""Label length too long: %zu\n"", label_length); return MOBI_DATA_CORRUPT; } char text[INDX_LABEL_SIZEMAX]; if (ordt->ordt2) { label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length); } else { label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count); } indx->entries[entry_number].label = malloc(label_length + 1); if (indx->entries[entry_number].label == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", label_length); return MOBI_MALLOC_FAILED; } strncpy(indx->entries[entry_number].label, text, label_length + 1); unsigned char *control_bytes; control_bytes = buf->data + buf->offset; mobi_buffer_seek(buf, (int) tagx->control_byte_count); indx->entries[entry_number].tags_count = 0; indx->entries[entry_number].tags = NULL; if (tagx->tags_count > 0) { typedef struct { uint8_t tag; uint8_t tag_value_count; uint32_t value_count; uint32_t value_bytes; } MOBIPtagx; MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx)); if (ptagx == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIPtagx)); return MOBI_MALLOC_FAILED; } uint32_t ptagx_count = 0; size_t len; size_t i = 0; while (i < tagx->tags_count) { if (tagx->tags[i].control_byte == 1) { control_bytes++; i++; continue; } uint32_t value = control_bytes[0] & tagx->tags[i].bitmask; if (value != 0) { uint32_t value_count = MOBI_NOTSET; uint32_t value_bytes = MOBI_NOTSET; if (value == tagx->tags[i].bitmask) { if (mobi_bitcount(tagx->tags[i].bitmask) > 1) { len = 0; value_bytes = mobi_buffer_get_varlen(buf, &len); } else { value_count = 1; } } else { uint8_t mask = tagx->tags[i].bitmask; while ((mask & 1) == 0) { mask >>= 1; value >>= 1; } value_count = value; } ptagx[ptagx_count].tag = tagx->tags[i].tag; ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count; ptagx[ptagx_count].value_count = value_count; ptagx[ptagx_count].value_bytes = value_bytes; ptagx_count++; } i++; } indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag)); if (indx->entries[entry_number].tags == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIIndexTag)); free(ptagx); return MOBI_MALLOC_FAILED; } i = 0; while (i < ptagx_count) { uint32_t tagvalues_count = 0; uint32_t tagvalues[INDX_TAGVALUES_MAX]; if (ptagx[i].value_count != MOBI_NOTSET) { size_t count = ptagx[i].value_count * ptagx[i].tag_value_count; while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) { len = 0; const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len); tagvalues[tagvalues_count++] = value_bytes; } } else { len = 0; while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) { const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len); tagvalues[tagvalues_count++] = value_bytes; } } if (tagvalues_count) { const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues); indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size); if (indx->entries[entry_number].tags[i].tagvalues == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", arr_size); free(ptagx); return MOBI_MALLOC_FAILED; } memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size); } else { indx->entries[entry_number].tags[i].tagvalues = NULL; } indx->entries[entry_number].tags[i].tagid = ptagx[i].tag; indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count; indx->entries[entry_number].tags_count++; i++; } free(ptagx); } buf->maxlen = buf_maxlen; return MOBI_SUCCESS; }"
"void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) { if (MinSize > UINT32_MAX) report_bad_alloc_error(""SmallVector capacity overflow during allocation""); size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2)); NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX)); T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T))); this->uninitialized_move(this->begin(), this->end(), NewElts); destroy_range(this->begin(), this->end()); if (!this->isSmall()) free(this->begin()); this->BeginX = NewElts; this->Capacity = NewCapacity; }"
"void Gobby::EditCommands::on_redo() { g_assert(m_current_view != NULL); gulong i_ = g_signal_connect_after(m_current_view->get_text_buffer(), ""insert-text"", G_CALLBACK(recaret_i), NULL); gulong e_ = g_signal_connect_after(m_current_view->get_text_buffer(), ""delete-range"", G_CALLBACK(recaret_e), NULL); inf_adopted_session_redo( INF_ADOPTED_SESSION(m_current_view->get_session()), INF_ADOPTED_USER(m_current_view->get_active_user()), m_current_view->get_undo_grouping().get_redo_size() ); g_signal_handler_disconnect(m_current_view->get_text_buffer(), i_); g_signal_handler_disconnect(m_current_view->get_text_buffer(), e_); if(check) { GtkTextIter check_iter; gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), &check_iter, check); gtk_text_buffer_select_range(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), &check_iter, &check_iter); gtk_text_buffer_delete_mark(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), check); check = NULL; } m_current_view->scroll_to_cursor_position(0.0); }"
"int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm, const char *dir) { char offset[40] = """", name[200] = """", path[256]; mg_http_get_var(&hm->query, ""offset"", offset, sizeof(offset)); mg_http_get_var(&hm->query, ""name"", name, sizeof(name)); if (name[0] == '\0') { mg_http_reply(c, 400, """", ""%s"", ""name required""); return -1; } else { FILE *fp; size_t oft = strtoul(offset, NULL, 0); snprintf(path, sizeof(path), ""%s%c%s"", dir, MG_DIRSEP, name); LOG(LL_DEBUG, (""%p %d bytes @ %d [%s]"", c->fd, (int) hm->body.len, (int) oft, name)); if ((fp = fopen(path, oft == 0 ? ""wb"" : ""ab"")) == NULL) { mg_http_reply(c, 400, """", ""fopen(%s): %d"", name, errno); return -2; } else { fwrite(hm->body.ptr, 1, hm->body.len, fp); fclose(fp); mg_http_reply(c, 200, """", """"); return (int) hm->body.len; } } }"
"static void binder_free_buf(struct binder_proc *proc, struct binder_thread *thread, struct binder_buffer *buffer, bool is_failure) { binder_inner_proc_lock(proc); if (buffer->transaction) { buffer->transaction->buffer = NULL; buffer->transaction = NULL; } binder_inner_proc_unlock(proc); if (buffer->async_transaction && buffer->target_node) { struct binder_node *buf_node; struct binder_work *w; buf_node = buffer->target_node; binder_node_inner_lock(buf_node); BUG_ON(!buf_node->has_async_transaction); BUG_ON(buf_node->proc != proc); w = binder_dequeue_work_head_ilocked( &buf_node->async_todo); if (!w) { buf_node->has_async_transaction = false; } else { binder_enqueue_work_ilocked( w, &proc->todo); binder_wakeup_proc_ilocked(proc); } binder_node_inner_unlock(buf_node); } trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, thread, buffer, 0, is_failure); binder_alloc_free_buf(&proc->alloc, buffer); }"
"int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb, data_exchange_cb_t cb, void *cb_context) { int rc; pr_debug(""dev_name=%s target_idx=%u skb->len=%u\n"", dev_name(&dev->dev), target_idx, skb->len); device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; kfree_skb(skb); goto error; } if (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) { if (dev->active_target->idx != target_idx) { rc = -EADDRNOTAVAIL; kfree_skb(skb); goto error; } if (dev->ops->check_presence) del_timer_sync(&dev->check_pres_timer); rc = dev->ops->im_transceive(dev, dev->active_target, skb, cb, cb_context); if (!rc && dev->ops->check_presence && !dev->shutting_down) mod_timer(&dev->check_pres_timer, jiffies + msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS)); } else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) { rc = dev->ops->tm_send(dev, skb); } else { rc = -ENOTCONN; kfree_skb(skb); goto error; } error: device_unlock(&dev->dev); return rc; }"
"ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size) { struct inode *inode = d_inode(entry); struct fuse_mount *fm = get_fuse_mount(inode); FUSE_ARGS(args); struct fuse_getxattr_in inarg; struct fuse_getxattr_out outarg; ssize_t ret; if (!fuse_allow_current_process(fm->fc)) return -EACCES; if (fm->fc->no_listxattr) return -EOPNOTSUPP; memset(&inarg, 0, sizeof(inarg)); inarg.size = size; args.opcode = FUSE_LISTXATTR; args.nodeid = get_node_id(inode); args.in_numargs = 1; args.in_args[0].size = sizeof(inarg); args.in_args[0].value = &inarg; args.out_numargs = 1; if (size) { args.out_argvar = true; args.out_args[0].size = size; args.out_args[0].value = list; } else { args.out_args[0].size = sizeof(outarg); args.out_args[0].value = &outarg; } ret = fuse_simple_request(fm, &args); if (!ret && !size) ret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX); if (ret > 0 && size) ret = fuse_verify_xattr_list(list, ret); if (ret == -ENOSYS) { fm->fc->no_listxattr = 1; ret = -EOPNOTSUPP; } return ret; }"
"static int write_msr(unsigned int reg, uint64_t val, struct x86_emulate_ctxt *ctxt) { struct vcpu *curr = current; const struct domain *currd = curr->domain; bool vpmu_msr = false; int ret; if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE ) { if ( ret == X86EMUL_EXCEPTION ) x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt); return ret; } switch ( reg ) { uint64_t temp; case MSR_FS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrfsbase(val); return X86EMUL_OKAY; case MSR_GS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrgsbase(val); return X86EMUL_OKAY; case MSR_SHADOW_GS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrgsshadow(val); curr->arch.pv.gs_base_user = val; return X86EMUL_OKAY; case MSR_EFER: if ( val != guest_efer(currd) ) break; return X86EMUL_OKAY; case MSR_K7_FID_VID_STATUS: case MSR_K7_FID_VID_CTL: case MSR_K8_PSTATE_LIMIT: case MSR_K8_PSTATE_CTRL: case MSR_K8_PSTATE_STATUS: case MSR_K8_PSTATE0: case MSR_K8_PSTATE1: case MSR_K8_PSTATE2: case MSR_K8_PSTATE3: case MSR_K8_PSTATE4: case MSR_K8_PSTATE5: case MSR_K8_PSTATE6: case MSR_K8_PSTATE7: case MSR_K8_HWCR: if ( !(boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_AMD64_NB_CFG: if ( !is_hwdom_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) || ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) ) goto invalid; if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 ) return X86EMUL_OKAY; break; case MSR_FAM10H_MMIO_CONF_BASE: if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD || boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 ) break; if ( !is_hwdom_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 ) break; if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ? temp != val : ((temp ^ val) & ~(FAM10H_MMIO_CONF_ENABLE | (FAM10H_MMIO_CONF_BUSRANGE_MASK << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) | ((u64)FAM10H_MMIO_CONF_BASE_MASK << FAM10H_MMIO_CONF_BASE_SHIFT))) ) goto invalid; if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_MISC_ENABLE: rdmsrl(reg, temp); if ( val != guest_misc_enable(temp) ) goto invalid; return X86EMUL_OKAY; case MSR_IA32_MPERF: case MSR_IA32_APERF: if ( !(boot_cpu_data.x86_vendor & (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_PERF_CTL: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_THERM_CONTROL: case MSR_IA32_ENERGY_PERF_BIAS: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7): case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3): case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2: case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL: if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL ) { vpmu_msr = true; case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5: case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3: if ( vpmu_msr || (boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) { if ( (vpmu_mode & XENPMU_MODE_ALL) && !is_hardware_domain(currd) ) return X86EMUL_OKAY; if ( vpmu_do_wrmsr(reg, val, 0) ) break; return X86EMUL_OKAY; } } default: gdprintk(XENLOG_WARNING, ""WRMSR 0x%08x val 0x%016""PRIx64"" unimplemented\n"", reg, val); break; invalid: gdprintk(XENLOG_WARNING, ""Domain attempted WRMSR 0x%08x from 0x%016""PRIx64"" to 0x%016""PRIx64""\n"", reg, temp, val); return X86EMUL_OKAY; } return X86EMUL_UNHANDLEABLE; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& indices_tensor = ctx->input(0); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(indices_tensor.shape()) || TensorShapeUtils::IsScalar(indices_tensor.shape()), errors::InvalidArgument( ""The indices can only be scalar or vector, got \"""", indices_tensor.shape().DebugString(), ""\"""")); const Tensor& dims_tensor = ctx->input(1); OP_REQUIRES( ctx, TensorShapeUtils::IsVector(dims_tensor.shape()), errors::InvalidArgument(""The indices can only be 1-D, got \"""", dims_tensor.shape().DebugString(), ""\"""")); auto dims = dims_tensor.vec<Tidx>(); Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod(); Tidx dims_prod = dims_prod_eigen(); const Tidx* indices = indices_tensor.flat<Tidx>().data(); int64 size = indices_tensor.NumElements(); bool check = std::all_of(indices, indices + size, [&](Tidx index) { return index < dims_prod; }); OP_REQUIRES(ctx, check, errors::InvalidArgument(""index is out of bound as with dims"")); Eigen::array<bool, 1> reverse({true}); Tensor strides_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<Tidx>::value, TensorShape({dims_tensor.NumElements()}), &strides_tensor)); auto strides = strides_tensor.vec<Tidx>(); strides = dims.reverse(reverse) .scan(0, Eigen::internal::ProdReducer<Tidx>(), false) .reverse(reverse); Tensor strides_shifted_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<Tidx>::value, TensorShape({dims_tensor.NumElements()}), &strides_shifted_tensor)); auto strides_shifted = strides_shifted_tensor.vec<Tidx>(); strides_shifted = dims.reverse(reverse) .scan(0, Eigen::internal::ProdReducer<Tidx>(), true) .reverse(reverse); Tensor* output_tensor = nullptr; if (TensorShapeUtils::IsScalar(indices_tensor.shape())) { OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements()}), &output_tensor)); auto output = output_tensor->vec<Tidx>(); output = output.constant(indices_tensor.scalar<Tidx>()()); output = output.binaryExpr(strides, mod_op<Tidx>()) / strides_shifted; } else { OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements(), indices_tensor.NumElements()}), &output_tensor)); auto output = output_tensor->matrix<Tidx>(); Eigen::array<Eigen::Index, 2> reshape{ {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}}; Eigen::array<Eigen::Index, 2> bcast( {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}); Eigen::array<Eigen::Index, 2> indices_reshape{ {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}}; Eigen::array<Eigen::Index, 2> indices_bcast( {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}); output = indices_tensor.vec<Tidx>() .reshape(indices_reshape) .broadcast(indices_bcast); output = output.binaryExpr(strides.reshape(reshape).broadcast(bcast), mod_op<Tidx>()) / strides_shifted.reshape(reshape).broadcast(bcast); } }"
"static int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr, int len, int flags) { struct sock *sk = sock->sk; struct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk); struct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr; struct nfc_dev *dev; struct nfc_llcp_local *local; int ret = 0; pr_debug(""sock %p sk %p flags 0x%x\n"", sock, sk, flags); if (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC) return -EINVAL; if (addr->service_name_len == 0 && addr->dsap == 0) return -EINVAL; pr_debug(""addr dev_idx=%u target_idx=%u protocol=%u\n"", addr->dev_idx, addr->target_idx, addr->nfc_protocol); lock_sock(sk); if (sk->sk_state == LLCP_CONNECTED) { ret = -EISCONN; goto error; } if (sk->sk_state == LLCP_CONNECTING) { ret = -EINPROGRESS; goto error; } dev = nfc_get_device(addr->dev_idx); if (dev == NULL) { ret = -ENODEV; goto error; } local = nfc_llcp_find_local(dev); if (local == NULL) { ret = -ENODEV; goto put_dev; } device_lock(&dev->dev); if (dev->dep_link_up == false) { ret = -ENOLINK; device_unlock(&dev->dev); goto put_dev; } device_unlock(&dev->dev); if (local->rf_mode == NFC_RF_INITIATOR && addr->target_idx != local->target_idx) { ret = -ENOLINK; goto put_dev; } llcp_sock->dev = dev; llcp_sock->local = nfc_llcp_local_get(local); llcp_sock->ssap = nfc_llcp_get_local_ssap(local); if (llcp_sock->ssap == LLCP_SAP_MAX) { ret = -ENOMEM; goto sock_llcp_put_local; } llcp_sock->reserved_ssap = llcp_sock->ssap; if (addr->service_name_len == 0) llcp_sock->dsap = addr->dsap; else llcp_sock->dsap = LLCP_SAP_SDP; llcp_sock->nfc_protocol = addr->nfc_protocol; llcp_sock->service_name_len = min_t(unsigned int, addr->service_name_len, NFC_LLCP_MAX_SERVICE_NAME); llcp_sock->service_name = kmemdup(addr->service_name, llcp_sock->service_name_len, GFP_KERNEL); if (!llcp_sock->service_name) { ret = -ENOMEM; goto sock_llcp_release; } nfc_llcp_sock_link(&local->connecting_sockets, sk); ret = nfc_llcp_send_connect(llcp_sock); if (ret) goto sock_unlink; sk->sk_state = LLCP_CONNECTING; ret = sock_wait_state(sk, LLCP_CONNECTED, sock_sndtimeo(sk, flags & O_NONBLOCK)); if (ret && ret != -EINPROGRESS) goto sock_unlink; release_sock(sk); return ret; sock_unlink: nfc_llcp_sock_unlink(&local->connecting_sockets, sk); kfree(llcp_sock->service_name); llcp_sock->service_name = NULL; sock_llcp_release: nfc_llcp_put_ssap(local, llcp_sock->ssap); sock_llcp_put_local: nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; llcp_sock->dev = NULL; put_dev: nfc_put_device(dev); error: release_sock(sk); return ret; }"
"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size, int uncompressed_size, EXRThreadData *td) { int64_t version, lo_usize, lo_size; int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size; int64_t ac_count, dc_count, ac_compression; const int dc_w = td->xsize >> 3; const int dc_h = td->ysize >> 3; GetByteContext gb, agb; int skip, ret; if (compressed_size <= 88) return AVERROR_INVALIDDATA; version = AV_RL64(src + 0); if (version != 2) return AVERROR_INVALIDDATA; lo_usize = AV_RL64(src + 8); lo_size = AV_RL64(src + 16); ac_size = AV_RL64(src + 24); dc_size = AV_RL64(src + 32); rle_csize = AV_RL64(src + 40); rle_usize = AV_RL64(src + 48); rle_raw_size = AV_RL64(src + 56); ac_count = AV_RL64(src + 64); dc_count = AV_RL64(src + 72); ac_compression = AV_RL64(src + 80); if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize) return AVERROR_INVALIDDATA; bytestream2_init(&gb, src + 88, compressed_size - 88); skip = bytestream2_get_le16(&gb); if (skip < 2) return AVERROR_INVALIDDATA; bytestream2_skip(&gb, skip - 2); if (lo_size > 0) { if (lo_usize > uncompressed_size) return AVERROR_INVALIDDATA; bytestream2_skip(&gb, lo_size); } if (ac_size > 0) { unsigned long dest_len = ac_count * 2LL; GetByteContext agb = gb; if (ac_count > 3LL * td->xsize * s->scan_lines_per_block) return AVERROR_INVALIDDATA; av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len); if (!td->ac_data) return AVERROR(ENOMEM); switch (ac_compression) { case 0: ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count); if (ret < 0) return ret; break; case 1: if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK || dest_len != ac_count * 2LL) return AVERROR_INVALIDDATA; break; default: return AVERROR_INVALIDDATA; } bytestream2_skip(&gb, ac_size); } if (dc_size > 0) { unsigned long dest_len = dc_count * 2LL; GetByteContext agb = gb; if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64) return AVERROR_INVALIDDATA; av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2); if (!td->dc_data) return AVERROR(ENOMEM); if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK || (dest_len != dc_count * 2LL)) return AVERROR_INVALIDDATA; s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len); s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len); bytestream2_skip(&gb, dc_size); } if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) { unsigned long dest_len = rle_usize; av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize); if (!td->rle_data) return AVERROR(ENOMEM); av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size); if (!td->rle_raw_data) return AVERROR(ENOMEM); if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK || (dest_len != rle_usize)) return AVERROR_INVALIDDATA; ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size); if (ret < 0) return ret; bytestream2_skip(&gb, rle_csize); } bytestream2_init(&agb, td->ac_data, ac_count * 2); for (int y = 0; y < td->ysize; y += 8) { for (int x = 0; x < td->xsize; x += 8) { memset(td->block, 0, sizeof(td->block)); for (int j = 0; j < 3; j++) { float *block = td->block[j]; const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j; uint16_t *dc = (uint16_t *)td->dc_data; union av_intfloat32 dc_val; dc_val.i = half2float(dc[idx], s->mantissatable, s->exponenttable, s->offsettable); block[0] = dc_val.f; ac_uncompress(s, &agb, block); dct_inverse(block); } { const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f; const int o = s->nb_channels == 4; float *bo = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x; float *go = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x; float *ro = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x; float *yb = td->block[0]; float *ub = td->block[1]; float *vb = td->block[2]; for (int yy = 0; yy < 8; yy++) { for (int xx = 0; xx < 8; xx++) { const int idx = xx + yy * 8; convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]); bo[xx] = to_linear(bo[xx], scale); go[xx] = to_linear(go[xx], scale); ro[xx] = to_linear(ro[xx], scale); } bo += td->xsize * s->nb_channels; go += td->xsize * s->nb_channels; ro += td->xsize * s->nb_channels; } } } } if (s->nb_channels < 4) return 0; for (int y = 0; y < td->ysize && td->rle_raw_data; y++) { uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels; uint8_t *ai0 = td->rle_raw_data + y * td->xsize; uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2; for (int x = 0; x < td->xsize; x++) { uint16_t ha = ai0[x] | (ai1[x] << 8); ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable); } } return 0; }"
"static bool bgp_attr_aigp_valid(uint8_t *pnt, int length) { uint8_t *data = pnt; uint8_t tlv_type; uint16_t tlv_length; if (length < 3) { zlog_err(""Bad AIGP attribute length (MUST be minimum 3): %u"", length); return false; } while (length) { tlv_type = *data; ptr_get_be16(data + 1, &tlv_length); (void)data; if (length < tlv_length) { zlog_err( ""Bad AIGP attribute length: %u, but TLV length: %u"", length, tlv_length); return false; } if (tlv_length < 3) { zlog_err(""Bad AIGP TLV length (MUST be minimum 3): %u"", tlv_length); return false; } if (tlv_type == BGP_AIGP_TLV_METRIC && tlv_length != BGP_AIGP_TLV_METRIC_LEN) { zlog_err(""Bad AIGP TLV (%s) length: %u"", BGP_AIGP_TLV_METRIC_DESC, tlv_length); return false; } data += tlv_length; length -= tlv_length; } return true; }"
"static gboolean dissect_cbor_byte_string(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor) { guint64  length; gint     eof_type; proto_tree *subtree; proto_item *item; item = proto_tree_add_item(cbor_tree, hf_cbor_item_byte_string, tvb, *offset, -1, ENC_NA); subtree = proto_item_add_subtree(item, ett_cbor_byte_string); proto_tree_add_item(subtree, hf_cbor_item_major_type, tvb, *offset, 1, ENC_BIG_ENDIAN); if (type_minor <= 0x17) { proto_tree_add_item(subtree, hf_cbor_item_length5, tvb, *offset, 1, ENC_BIG_ENDIAN); length = type_minor; } else { proto_tree_add_item(subtree, hf_cbor_item_length_size, tvb, *offset, 1, ENC_BIG_ENDIAN); } *offset += 1; switch (type_minor) { case 0x18: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 1, ENC_BIG_ENDIAN, &length); *offset += 1; break; case 0x19: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 2, ENC_BIG_ENDIAN, &length); *offset += 2; break; case 0x1a: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 4, ENC_BIG_ENDIAN, &length); *offset += 4; break; case 0x1b: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 8, ENC_BIG_ENDIAN, &length); *offset += 8; break; case 0x1f: proto_item_append_text(item, "": (indefinite length)""); item = proto_tree_add_item(subtree, hf_cbor_type_byte_string_indef, tvb, *offset, 1, ENC_NA); subtree = proto_item_add_subtree(item, ett_cbor_byte_string_indef); while (1) { eof_type = tvb_get_guint8(tvb, *offset); if (eof_type == 0xff) { dissect_cbor_float_simple_data(tvb, pinfo, subtree, offset, 0x1f); proto_item_set_end(item, tvb, *offset); return TRUE; } if (((eof_type & 0xe0) >> 5) != CBOR_TYPE_BYTE_STRING) { expert_add_info_format(pinfo, subtree, &ei_cbor_invalid_element, ""invalid element %i, expected byte string"", (eof_type & 0xe0) >> 5); return FALSE; } if (!dissect_cbor_byte_string(tvb, pinfo, subtree, offset, eof_type & 0x1f)) { return FALSE; } } DISSECTOR_ASSERT_NOT_REACHED(); return FALSE; default: if (type_minor > 0x17) { expert_add_info_format(pinfo, subtree, &ei_cbor_invalid_minor_type, ""invalid minor type %i in byte string"", type_minor); return FALSE; } break; } if (length > G_MAXINT32 || *offset + (gint)length < *offset) { expert_add_info_format(pinfo, subtree, &ei_cbor_too_long_length, ""the length (%"" PRIu64 "") of the byte string too long"", length); return FALSE; } proto_tree_add_item(subtree, hf_cbor_type_byte_string, tvb, *offset, (gint)length, ENC_BIG_ENDIAN|ENC_NA); *offset += (gint)length; proto_item_append_text(item, "": (%"" PRIu64 "" byte%s)"", length, plurality(length, """", ""s"")); proto_item_set_end(item, tvb, *offset); return TRUE; }"
"void normal_cmd( oparg_T*oap, inttoplevel UNUSED){ cmdarg_Tca;    intc; intctrl_w = FALSE;    intold_col = curwin->w_curswant; intneed_flushbuf = FALSE;    pos_Told_pos;    intmapped_len; static intold_mapped_len = 0; intidx; intset_prevcount = FALSE; intsave_did_cursorhold = did_cursorhold; CLEAR_FIELD(ca);    ca.oap = oap; ca.opcount = opcount; #ifdef CURSOR_SHAPE c = finish_op; #endif finish_op = (oap->op_type != OP_NOP); #ifdef CURSOR_SHAPE if (finish_op != c) { ui_cursor_shape();# ifdef FEAT_MOUSESHAPE update_mouseshape(-1); # endif } #endif may_trigger_modechanged(); if (!finish_op && !oap->regname) { ca.opcount = 0; #ifdef FEAT_EVAL set_prevcount = TRUE; #endif } if (oap->prev_opcount > 0 || oap->prev_count0 > 0) { ca.opcount = oap->prev_opcount; ca.count0 = oap->prev_count0; oap->prev_opcount = 0; oap->prev_count0 = 0; } mapped_len = typebuf_maplen(); State = MODE_NORMAL_BUSY; #ifdef USE_ON_FLY_SCROLL dont_scroll = FALSE;#endif #ifdef FEAT_EVAL if (toplevel && readbuf1_empty()) set_vcount_ca(&ca, &set_prevcount); #endif c = safe_vgetc(); LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT); if (restart_edit == 0) old_mapped_len = 0; else if (old_mapped_len || (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0)) old_mapped_len = typebuf_maplen(); if (c == NUL) c = K_ZERO; if (VIsual_active && VIsual_select && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER)) { int len; len = ins_char_typebuf(vgetc_char, vgetc_mod_mask); if (KeyTyped) ungetchars(len); if (restart_edit != 0) c = 'd'; else c = 'c'; msg_nowait = TRUE;old_mapped_len = 0;    } if (KeyTyped && !KeyStuffed) win_ensure_size(); #ifdef FEAT_CMDL_INFO need_flushbuf = add_to_showcmd(c); #endif c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w, &need_flushbuf); if (ctrl_w) { ca.nchar = c; ca.cmdchar = Ctrl_W; } else ca.cmdchar = c; idx = find_command(ca.cmdchar); if (idx < 0) { clearopbeep(oap); goto normal_end; } if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW)) { clearopbeep(oap); text_locked_msg(); goto normal_end; } if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked()) goto normal_end; if (VIsual_active) { if (km_stopsel && (nv_cmds[idx].cmd_flags & NV_STS) && !(mod_mask & MOD_MASK_SHIFT)) { end_visual_mode(); redraw_curbuf_later(INVERTED); } if (km_startsel) { if (nv_cmds[idx].cmd_flags & NV_SS) { unshift_special(&ca); idx = find_command(ca.cmdchar); if (idx < 0) { clearopbeep(oap); goto normal_end; } } else if ((nv_cmds[idx].cmd_flags & NV_SSS) && (mod_mask & MOD_MASK_SHIFT)) mod_mask &= ~MOD_MASK_SHIFT; } } #ifdef FEAT_RIGHTLEFT if (curwin->w_p_rl && KeyTyped && !KeyStuffed && (nv_cmds[idx].cmd_flags & NV_RL)) { switch (ca.cmdchar) { case 'l':    ca.cmdchar = 'h'; break; case K_RIGHT:   ca.cmdchar = K_LEFT; break; case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break; case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break; case 'h':    ca.cmdchar = 'l'; break; case K_LEFT:    ca.cmdchar = K_RIGHT; break; case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break; case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break; case '>':    ca.cmdchar = '<'; break; case '<':    ca.cmdchar = '>'; break; } idx = find_command(ca.cmdchar); } #endif if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags)) idx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf); #ifdef FEAT_CMDL_INFO if (need_flushbuf) out_flush(); #endif if (ca.cmdchar != K_IGNORE) { if (ex_normal_busy) did_cursorhold = save_did_cursorhold; else did_cursorhold = FALSE; } State = MODE_NORMAL; if (ca.nchar == ESC) { clearop(oap); if (restart_edit == 0 && goto_im()) restart_edit = 'a'; goto normal_end; } if (ca.cmdchar != K_IGNORE) { msg_didout = FALSE;    msg_col = 0; } old_pos = curwin->w_cursor; if (!VIsual_active && km_startsel) { if (nv_cmds[idx].cmd_flags & NV_SS) { start_selection(); unshift_special(&ca); idx = find_command(ca.cmdchar); } else if ((nv_cmds[idx].cmd_flags & NV_SSS) && (mod_mask & MOD_MASK_SHIFT)) { start_selection(); mod_mask &= ~MOD_MASK_SHIFT; } } ca.arg = nv_cmds[idx].cmd_arg; (nv_cmds[idx].cmd_func)(&ca); if (!finish_op && !oap->op_type && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG))) { clearop(oap); #ifdef FEAT_EVAL reset_reg_var(); #endif } if (old_mapped_len > 0) old_mapped_len = typebuf_maplen(); if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE) do_pending_operator(&ca, old_col, FALSE); if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos)) normal_cmd_wait_for_msg(); normal_end: msg_nowait = FALSE; #ifdef FEAT_EVAL if (finish_op) reset_reg_var(); #endif #ifdef CURSOR_SHAPE c = finish_op; #endif finish_op = FALSE; may_trigger_modechanged(); #ifdef CURSOR_SHAPE if (c || ca.cmdchar == 'r') { ui_cursor_shape();# ifdef FEAT_MOUSESHAPE update_mouseshape(-1); # endif } #endif #ifdef FEAT_CMDL_INFO if (oap->op_type == OP_NOP && oap->regname == 0 && ca.cmdchar != K_CURSORHOLD) clear_showcmd(); #endif checkpcmark();    vim_free(ca.searchbuf); if (has_mbyte) mb_adjust_cursor(); if (curwin->w_p_scb && toplevel) { validate_cursor();do_check_scrollbind(TRUE); } if (curwin->w_p_crb && toplevel) { validate_cursor();do_check_cursorbind(); } #ifdef FEAT_TERMINAL if (term_job_running(curbuf->b_term)) restart_edit = 0; #endif if (       oap->op_type == OP_NOP && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0) || restart_VIsual_select == 1) && !(ca.retval & CA_COMMAND_BUSY) && stuff_empty() && oap->regname == 0) { if (restart_VIsual_select == 1) { VIsual_select = TRUE; may_trigger_modechanged(); showmode(); restart_VIsual_select = 0; VIsual_select_reg = 0; } if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0) (void)edit(restart_edit, FALSE, 1L); } if (restart_VIsual_select == 2) restart_VIsual_select = 1; opcount = ca.opcount; }"
"auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> { auto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false); return std::make_unique<ReferenceHandle>(value, inherit); }"
"static void io_req_drop_files(struct io_kiocb *req) { struct io_ring_ctx *ctx = req->ctx; unsigned long flags; spin_lock_irqsave(&ctx->inflight_lock, flags); list_del(&req->inflight_entry); if (waitqueue_active(&ctx->inflight_wait)) wake_up(&ctx->inflight_wait); spin_unlock_irqrestore(&ctx->inflight_lock, flags); req->flags &= ~REQ_F_INFLIGHT; req->work.files = NULL; }"
static int packet_get_(struct buf *b) { if (packet.flagkeys) { return sshcrypto_packet_get(b); } else { return packet_get_plain_(b); } }
"void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth) { depth++; if ( depth == 1 ) visits.clear(); bool bFirst  = true  ; const size_t dirSize = 32; DataBuf  dir(dirSize); bool bPrint = option == kpsBasic || option == kpsRecursive; do { const int seekSuccess = !io.seek(start,BasicIo::beg); const long bytesRead = io.read(dir.pData_, 2); if (!seekSuccess || bytesRead == 0) { throw Error(kerCorruptedMetadata); } uint16_t   dirLength = byteSwap2(dir,0,bSwap); bool tooBig = dirLength > 500; if ( tooBig ) throw Error(kerTiffDirectoryTooLarge); if ( bFirst && bPrint ) { out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF TIFF FILE (%c%c): "",c,c) << io.path() << std::endl; if ( tooBig ) out << Internal::indent(depth) << ""dirLength = "" << dirLength << std::endl; } for ( int i = 0 ; i < dirLength ; i ++ ) { if ( visits.find(io.tell()) != visits.end()  ) {                     throw Error(kerCorruptedMetadata); } visits.insert(io.tell()); if ( bFirst && bPrint ) { out << Internal::indent(depth) << "" address |    tag                              |     "" << "" type |    count |    offset | value\n""; } bFirst = false; io.read(dir.pData_, 12); uint16_t tag    = byteSwap2(dir,0,bSwap); uint16_t type   = byteSwap2(dir,2,bSwap); uint32_t count  = byteSwap4(dir,4,bSwap); uint32_t offset = byteSwap4(dir,8,bSwap); if ( !typeValid(type) ) { std::cerr << ""invalid type in tiff structure"" << type << std::endl; start = 0;                     throw Error(kerInvalidTypeValue); } std::string sp  = """" ;  uint32_t kount  = isPrintXMP(tag,option) ? count                                 : isPrintICC(tag,option) ? count                                 : isStringType(type)     ? (count > 32 ? 32 : count)                                 : count > 5              ? 5 : count ; uint32_t pad    = isStringType(type) ? 1 : 0; uint32_t size   = isStringType(type) ? 1 : is2ByteType(type)  ? 2 : is4ByteType(type)  ? 4 : is8ByteType(type)  ? 8 : 1 ; long long allocate = (long long) size*count + pad+20; if ( allocate > (long long) io.size() ) { throw Error(kerInvalidMalloc); } DataBuf  buf((long)allocate);                  std::memset(buf.pData_, 0, buf.size_); std::memcpy(buf.pData_,dir.pData_+8,4);                  const bool bOffsetIsPointer = count*size > 4; if ( bOffsetIsPointer ) {                             size_t   restore = io.tell();                      io.seek(offset,BasicIo::beg);                      io.read(buf.pData_,count*size);                    io.seek(restore,BasicIo::beg);                 } if ( bPrint ) { const uint32_t address = start + 2 + i*12 ; const std::string offsetString = bOffsetIsPointer? Internal::stringFormat(""%10u"", offset): """"; out << Internal::indent(depth) << Internal::stringFormat(""%8u | %#06x %-28s |%10s |%9u |%10s | "" ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str()); if ( isShortType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap2(buf,k*size,bSwap); sp = "" ""; } } else if ( isLongType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap4(buf,k*size,bSwap); sp = "" ""; } } else if ( isRationalType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { uint32_t a = byteSwap4(buf,k*size+0,bSwap); uint32_t b = byteSwap4(buf,k*size+4,bSwap); out << sp << a << ""/"" << b; sp = "" ""; } } else if ( isStringType(type) ) { out << sp << Internal::binaryToString(makeSlice(buf, 0, kount)); } sp = kount == count ? """" : "" ...""; out << sp << std::endl; if ( option == kpsRecursive && (tag == 0x8769  || tag == 0x014a  || type == tiffIfd) ) { for ( size_t k = 0 ; k < count ; k++ ) { size_t   restore = io.tell(); uint32_t offset = byteSwap4(buf,k*size,bSwap); printIFDStructure(io,out,option,offset,bSwap,c,depth); io.seek(restore,BasicIo::beg); } } else if ( option == kpsRecursive && tag == 0x83bb  ) { if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) { throw Error(kerCorruptedMetadata); } const size_t restore = io.tell(); io.seek(offset, BasicIo::beg);                          std::vector<byte> bytes(count) ;                                                  const long read_bytes = io.read(&bytes[0], count); io.seek(restore, BasicIo::beg); IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth); }  else if ( option == kpsRecursive && tag == 0x927c  && count > 10) { size_t   restore = io.tell();   uint32_t jump= 10           ; byte     bytes[20]          ; const char* chars = (const char*) &bytes[0] ; io.seek(offset,BasicIo::beg);                          io.read(bytes,jump    )     ;                          bytes[jump]=0               ; if ( ::strcmp(""Nikon"",chars) == 0 ) { byte* bytes=new byte[count-jump] ;                              io.read(bytes,count-jump)        ;                              MemIo memIo(bytes,count-jump)    ;                              printTiffStructure(memIo,out,option,depth); delete[] bytes                   ;                          } else { io.seek(0,BasicIo::beg);                              printIFDStructure(io,out,option,offset,bSwap,c,depth); } io.seek(restore,BasicIo::beg);                     } } if ( isPrintXMP(tag,option) ) { buf.pData_[count]=0; out << (char*) buf.pData_; } if ( isPrintICC(tag,option) ) { out.write((const char*)buf.pData_,count); } } if ( start ) { io.read(dir.pData_, 4); start = tooBig ? 0 : byteSwap4(dir,0,bSwap); } } while (start) ; if ( bPrint ) { out << Internal::indent(depth) << ""END "" << io.path() << std::endl; } out.flush(); depth--; }"
"static int cardos_have_verifyrc_package(sc_card_t *card) { sc_apdu_t apdu; u8        rbuf[SC_MAX_APDU_BUFFER_SIZE]; int       r; const u8  *p = rbuf, *q; size_t    len, tlen = 0, ilen = 0; sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0x88); apdu.resp    = rbuf; apdu.resplen = sizeof(rbuf); apdu.lc = 0; apdu.le = 256; r = sc_transmit_apdu(card, &apdu); LOG_TEST_RET(card->ctx, r, ""APDU transmit failed""); if ((len = apdu.resplen) == 0) return 0; while (len != 0) { p = sc_asn1_find_tag(card->ctx, p, len, 0xe1, &tlen); if (p == NULL) return 0; if (card->type == SC_CARD_TYPE_CARDOS_M4_3){ q = sc_asn1_find_tag(card->ctx, p, tlen, 0x01, &ilen); if (q == NULL || ilen != 4) return 0; if (q[0] == 0x07) return 1; } else if (card->type == SC_CARD_TYPE_CARDOS_M4_4){ q = sc_asn1_find_tag(card->ctx, p, tlen, 0x03, &ilen); if (q == NULL || ilen != 4) return 0; if (q[0] == 0x02) return 1; } else{ return 0; } p   += tlen; len -= tlen + 2; } return 0; }"
"static int writeImageSections(TIFF *in, TIFF *out, struct image_data *image, struct pagedef *page, struct pageseg *sections, struct dump_opts * dump, unsigned char *src_buff, unsigned char **sect_buff_ptr) { double  hres, vres; uint32_t  i, k, width, length, sectsize; unsigned char *sect_buff = *sect_buff_ptr; hres = page->hres; vres = page->vres; k = page->cols * page->rows; if ((k < 1) || (k > MAX_SECTIONS)) { TIFFError(""writeImageSections"", ""%""PRIu32"" Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections"", k); return (-1); } for (i = 0; i < k; i++) { width  = sections[i].x2 - sections[i].x1 + 1; length = sections[i].y2 - sections[i].y1 + 1; sectsize = (uint32_t) ceil((width * image->bps + 7) / (double)8) * image->spp * length; if (createImageSection(sectsize, sect_buff_ptr)) { TIFFError(""writeImageSections"", ""Unable to allocate section buffer""); exit(EXIT_FAILURE); } sect_buff = *sect_buff_ptr; if (extractImageSection (image, &sections[i], src_buff, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to extract image sections""); exit(EXIT_FAILURE); } if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to write image section""); exit(EXIT_FAILURE); } } return (0); }"
"bool_pdfioDictSetValue( pdfio_dict_t   *dict,    const char     *key,    _pdfio_value_t *value){ _pdfio_pair_t*pair; PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", dict, key, (void *)value); if (dict->num_pairs > 0) { _pdfio_pair_tpkey; pkey.key = key; if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL) { PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n""); if (pair->value.type == PDFIO_VALTYPE_BINARY) free(pair->value.value.binary.data); pair->value = *value; return (true); } } if (dict->num_pairs >= dict->alloc_pairs) { _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t)); if (!temp) { PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n""); return (false); } dict->pairs       = temp; dict->alloc_pairs += 8; } pair = dict->pairs + dict->num_pairs; dict->num_pairs ++; pair->key   = key; pair->value = *value; if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0) qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs); #ifdef DEBUG PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs); PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict); PDFIO_DEBUG_DICT(dict); PDFIO_DEBUG(""\n""); #endif  return (true); }"
"int _gsasl_gssapi_server_step (Gsasl_session * sctx, void *mech_data, const char *input, size_t input_len, char **output, size_t *output_len) { _Gsasl_gssapi_server_state *state = mech_data; gss_buffer_desc bufdesc1, bufdesc2; OM_uint32 maj_stat, min_stat; gss_buffer_desc client_name; gss_OID mech_type; char tmp[4]; int res; *output = NULL; *output_len = 0; switch (state->step) { case 0: { gss_name_t server; const char *service; const char *hostname; if (input_len == 0) { res = GSASL_NEEDS_MORE; break; } service = gsasl_property_get (sctx, GSASL_SERVICE); if (!service) return GSASL_NO_SERVICE; hostname = gsasl_property_get (sctx, GSASL_HOSTNAME); if (!hostname) return GSASL_NO_HOSTNAME; bufdesc1.length = strlen (service) + strlen (""@"") + strlen (hostname) + 1; bufdesc1.value = malloc (bufdesc1.length); if (bufdesc1.value == NULL) return GSASL_MALLOC_ERROR; sprintf (bufdesc1.value, ""%s@%s"", service, hostname); maj_stat = gss_import_name (&min_stat, &bufdesc1, GSS_C_NT_HOSTBASED_SERVICE, &server); free (bufdesc1.value); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_IMPORT_NAME_ERROR; maj_stat = gss_acquire_cred (&min_stat, server, 0, GSS_C_NULL_OID_SET, GSS_C_ACCEPT, &state->cred, NULL, NULL); gss_release_name (&min_stat, &server); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_ACQUIRE_CRED_ERROR; } state->step++; case 1: bufdesc1.value = (void *) input; bufdesc1.length = input_len; if (state->client) { gss_release_name (&min_stat, &state->client); state->client = GSS_C_NO_NAME; } maj_stat = gss_accept_sec_context (&min_stat, &state->context, state->cred, &bufdesc1, GSS_C_NO_CHANNEL_BINDINGS, &state->client, &mech_type, &bufdesc2, NULL, NULL, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) return GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR; if (maj_stat == GSS_S_COMPLETE) state->step++; if (maj_stat == GSS_S_CONTINUE_NEEDED || bufdesc2.length > 0) { *output = malloc (bufdesc2.length); if (!*output) return GSASL_MALLOC_ERROR; memcpy (*output, bufdesc2.value, bufdesc2.length); *output_len = bufdesc2.length; } maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; if (maj_stat == GSS_S_CONTINUE_NEEDED || *output_len > 0) { res = GSASL_NEEDS_MORE; break; } case 2: memset (tmp, 0xFF, 4); tmp[0] = GSASL_QOP_AUTH; bufdesc1.length = 4; bufdesc1.value = tmp; maj_stat = gss_wrap (&min_stat, state->context, 0, GSS_C_QOP_DEFAULT, &bufdesc1, NULL, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_WRAP_ERROR; *output = malloc (bufdesc2.length); if (!*output) return GSASL_MALLOC_ERROR; memcpy (*output, bufdesc2.value, bufdesc2.length); *output_len = bufdesc2.length; maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; state->step++; res = GSASL_NEEDS_MORE; break; case 3: bufdesc1.value = (void *) input; bufdesc1.length = input_len; maj_stat = gss_unwrap (&min_stat, state->context, &bufdesc1, &bufdesc2, NULL, NULL); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_UNWRAP_ERROR; if ((((char *) bufdesc2.value)[0] & GSASL_QOP_AUTH) == 0) { maj_stat = gss_release_buffer (&min_stat, &bufdesc2); return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR; } gsasl_property_set_raw (sctx, GSASL_AUTHZID, (char *) bufdesc2.value + 4, bufdesc2.length - 4); maj_stat = gss_display_name (&min_stat, state->client, &client_name, &mech_type); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_DISPLAY_NAME_ERROR; gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME, client_name.value, client_name.length); maj_stat = gss_release_buffer (&min_stat, &client_name); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI); state->step++; break; default: res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES; break; } return res; }"
void rose_start_t1timer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); del_timer(&rose->timer); rose->timer.function = rose_timer_expiry; rose->timer.expires  = jiffies + rose->t1; add_timer(&rose->timer); }
"AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims) : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""ksize"", &ksize_)); OP_REQUIRES(ctx, ksize_.size() == num_dims(), errors::InvalidArgument(""Sliding window ksize field must "" ""specify "", num_dims(), "" dimensions"")); OP_REQUIRES_OK(ctx, ctx->GetAttr(""strides"", &stride_)); OP_REQUIRES(ctx, stride_.size() == num_dims(), errors::InvalidArgument(""Sliding window strides field must "" ""specify "", num_dims(), "" dimensions"")); OP_REQUIRES_OK(ctx, ctx->GetAttr(""padding"", &padding_)); OP_REQUIRES(ctx, padding_ != EXPLICIT, errors::Unimplemented( ""XLA does not support avgpoolgrad with explicit padding."")); OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1, errors::Unimplemented( ""Pooling is not yet supported on the batch dimension."")); string data_format; OP_REQUIRES_OK(ctx, ctx->GetAttr(""data_format"", &data_format)); OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_), errors::InvalidArgument(""Invalid data format"")); }"
"static int on_frame_recv(nghttp2_session *session, const nghttp2_frame *frame, void *user_data) { int rv; ogs_sbi_session_t *sbi_sess = user_data; ogs_sbi_server_t *server = NULL; ogs_sbi_stream_t *stream = NULL; ogs_sbi_request_t *request = NULL; ogs_assert(sbi_sess); server = sbi_sess->server; ogs_assert(server); ogs_assert(server->cb); ogs_assert(session); ogs_assert(frame); stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id); if (!stream) { if (frame->hd.type == NGHTTP2_SETTINGS) { sbi_sess->settings.max_concurrent_streams = nghttp2_session_get_remote_settings( session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS); sbi_sess->settings.enable_push = nghttp2_session_get_remote_settings( session, NGHTTP2_SETTINGS_ENABLE_PUSH); ogs_debug(""MAX_CONCURRENT_STREAMS = %d"", sbi_sess->settings.max_concurrent_streams); ogs_debug(""ENABLE_PUSH = %s"", sbi_sess->settings.enable_push ? ""TRUE"" : ""false""); } else if (frame->hd.type == NGHTTP2_GOAWAY) { rv = nghttp2_submit_goaway( session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id, NGHTTP2_NO_ERROR, NULL, 0); if (rv != 0) { ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"", rv, nghttp2_strerror(rv)); return OGS_ERROR; } session_send(sbi_sess); } return 0; } request = stream->request; ogs_assert(request); switch (frame->hd.type) { case NGHTTP2_HEADERS: if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) { const char *expect100 = ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT); if (expect100 && ogs_strcasecmp(expect100, ""100-continue"") == 0) { nghttp2_nv nva; add_header(&nva, "":status"", status_string[100]); rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, stream->stream_id, NULL, &nva, 1, NULL); if (rv != 0) { ogs_error(""nghttp2_submit_headers() failed (%d:%s)"", rv, nghttp2_strerror(rv)); nghttp2_submit_rst_stream( session, NGHTTP2_FLAG_NONE, stream->stream_id, rv); return 0; } } } OGS_GNUC_FALLTHROUGH; case NGHTTP2_DATA: if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) { ogs_debug(""[%s] %s"", request->h.method, request->h.uri); if (request->http.content_length && request->http.content) { ogs_debug(""RECEIVED: %d"", (int)request->http.content_length); ogs_debug(""%s"", request->http.content); } if (server->cb(request, stream) != OGS_OK) { ogs_warn(""server callback error""); ogs_assert(true == ogs_sbi_server_send_error(stream, OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL, ""server callback error"", NULL)); return 0; } break; } default: break; } return 0; }"
"void CalculateOutputIndexRowSplit( const RowPartitionTensor& row_split, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { INDEX_TYPE row_split_size = row_split.size(); if (row_split_size > 0) { result->reserve(row_split(row_split_size - 1)); } for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) { INDEX_TYPE row_length = row_split(i + 1) - row_split(i); INDEX_TYPE real_length = std::min(output_size, row_length); INDEX_TYPE parent_output_index_current = parent_output_index[i]; if (parent_output_index_current == -1) { real_length = 0; } for (INDEX_TYPE j = 0; j < real_length; ++j) { result->push_back(parent_output_index_current); parent_output_index_current += output_index_multiplier; } for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) { result->push_back(-1); } } if (row_split_size > 0) { DCHECK_EQ(result->size(), row_split(row_split_size - 1)); } }"
"GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs) { GF_Err e; u32 sub_type; GF_Box *a = NULL; GF_ListItemBox *ptr = (GF_ListItemBox *)s; sub_type = gf_bs_peek_bits(bs, 32, 4); if (sub_type == GF_ISOM_BOX_TYPE_DATA ) { e = gf_isom_box_parse(&a, bs); if (!e && ptr->size < a->size) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\n"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \ e = GF_ISOM_INVALID_FILE; } if (e) { if (a) gf_isom_box_del(a); return e; } ISOM_DECREASE_SIZE(ptr, a->size); if (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data); if (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) { ptr->data = (GF_DataBox *)a; if (!ptr->child_boxes) ptr->child_boxes = gf_list_new(); gf_list_add(ptr->child_boxes, ptr->data); } else { ptr->data = NULL; gf_isom_box_del(a); } } else { u64 pos = gf_bs_get_position(bs); u64 prev_size = s->size; e = gf_isom_box_array_read(s, bs, NULL); if (e==GF_OK) return GF_OK; gf_isom_box_array_del(s->child_boxes); s->child_boxes=NULL; gf_bs_seek(bs, pos); s->size = prev_size; ptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA); ptr->data->qt_style = GF_TRUE; ISOM_DECREASE_SIZE(ptr, 2); ptr->data->dataSize = gf_bs_read_u16(bs); gf_bs_read_u16(bs); ptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1)); gf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize); ptr->data->data[ptr->data->dataSize] = 0; ISOM_DECREASE_SIZE(ptr, ptr->data->dataSize); } return GF_OK; }"
"int Xasc(int modifier, char* label, char* mnemo, char* oper) { register char* s; register char r; register char delimiter; s = oper; delimiter = *s; if (delimiter != '\'' && delimiter != '\""') { error(""Bad operand syntax""); } while ((r = *++s) != delimiter) { if (r == '\\') { switch (*++s) { case 't': r = '\t'; break; case 'n': r = '\n'; break; case 'r': r = '\r'; break; case '0': r = 0; break; case '\'': case '\""': case '\\': r = *s; break; default: error(""Bad \\X character""); } } insert8(r); } if (*++s) { error(""syntax error""); } return 0; }"
"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) { MOBIIndexEntry e = indx->entries[i]; char *inflected = e.label; for (size_t j = 0; j < e.tags_count; j++) { MOBIIndexTag t = e.tags[j]; if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) { for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) { uint32_t len = t.tagvalues[k]; uint32_t offset = t.tagvalues[k + 1]; char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len); if (base == NULL) { return MOBI_MALLOC_FAILED; } MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected); free(base); if (ret != MOBI_SUCCESS) { return ret; } } } } return MOBI_SUCCESS; }"
"static int brcm_nvram_parse(struct brcm_nvram *priv) { struct device *dev = priv->dev; struct brcm_nvram_header header; uint8_t *data; size_t len; int err; memcpy_fromio(&header, priv->base, sizeof(header)); if (memcmp(header.magic, NVRAM_MAGIC, 4)) { dev_err(dev, ""Invalid NVRAM magic\n""); return -EINVAL; } len = le32_to_cpu(header.len); data = kzalloc(len, GFP_KERNEL); memcpy_fromio(data, priv->base, len); data[len - 1] = '\0'; err = brcm_nvram_add_cells(priv, data, len); if (err) { dev_err(dev, ""Failed to add cells: %d\n"", err); return err; } kfree(data); return 0; }"
"Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst, int input_index) { DataType src_out = src->output_type(output_index); DataType dst_in = dst->input_type(input_index); if (!TypesCompatible(dst_in, src_out)) { return errors::InvalidArgument( ""Input "", input_index, "" of node "", dst->name(), "" was passed "", DataTypeString(src_out), "" from "", src->name(), "":"", output_index, "" incompatible with expected "", DataTypeString(dst_in), "".""); } g_->AddEdge(src, output_index, dst, input_index); return Status::OK(); }"
"static gboolean canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize) { const TOP_ELEMENT_CONTROL *t = canonifyTable; guint32 len; for (t = canonifyTable; t->element != NULL; t++) { len = *(t->length); if (t->required && *(t->element) == NULL) return FALSE; if (*(t->element) != NULL) { if (t->addtag) { buff[(*offset)++] = t->tag; (*offset) += encode_ber_len(&buff[*offset], len, 4); } if (t->truncate) { len = 3+2*get_ber_len_size(len); } if (buffsize < *offset + len) { return FALSE; } memcpy(&buff[*offset], *(t->element), len); (*offset) += len; if (t->addtag) { *(t->element) = NULL; } } } return TRUE; }"
"static void naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_hevc_base) { #ifndef GPAC_DISABLE_HEVC u32 i, count; u8 layer_id; Bool first = GF_TRUE; Bool first_lhvc = GF_TRUE; GF_HEVCConfig *cfg; GF_HEVCConfig *hvcc; GF_HEVCConfig *lvcc; u32 max_w, max_h, max_ew, max_eh; *has_hevc_base = GF_FALSE; max_w = max_h = 0; max_ew = max_eh = 0; sar->num = sar->den = 0; hvcc = gf_odf_hevc_cfg_new(); lvcc = gf_odf_hevc_cfg_new(); hvcc->nal_unit_size = ctx->nal_length; lvcc->nal_unit_size = ctx->nal_length; lvcc->is_lhvc = GF_TRUE; count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) { *has_hevc_base = GF_TRUE; break; } } count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) { *has_hevc_base = GF_TRUE; break; } } count = gf_list_count(ctx->vps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->vps, i); HEVC_VPS *vps = &ctx->hevc_state->vps[sl->id]; if (!i) { hvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate; hvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc; hvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers; hvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting; } if (!ctx->analyze) naludmx_add_param_nalu((ctx->explicit || ! (*has_hevc_base) ) ? lvcc->param_array : hvcc->param_array, sl, GF_HEVC_NALU_VID_PARAM); } count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { Bool is_lhvc = GF_FALSE; GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); HEVC_SPS *sps = &ctx->hevc_state->sps[sl->id]; layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) *has_hevc_base = GF_TRUE; if (ctx->explicit || layer_id) { cfg = lvcc; is_lhvc = GF_TRUE; } else { cfg = hvcc; } if (first || (is_lhvc && first_lhvc) ) { cfg->configurationVersion = 1; cfg->profile_space = sps->ptl.profile_space; cfg->tier_flag = sps->ptl.tier_flag; cfg->profile_idc = sps->ptl.profile_idc; cfg->general_profile_compatibility_flags = sps->ptl.profile_compatibility_flag; cfg->progressive_source_flag = sps->ptl.general_progressive_source_flag; cfg->interlaced_source_flag = sps->ptl.general_interlaced_source_flag; cfg->non_packed_constraint_flag = sps->ptl.general_non_packed_constraint_flag; cfg->frame_only_constraint_flag = sps->ptl.general_frame_only_constraint_flag; cfg->constraint_indicator_flags = sps->ptl.general_reserved_44bits; cfg->level_idc = sps->ptl.level_idc; cfg->chromaFormat = sps->chroma_format_idc; cfg->luma_bit_depth = sps->bit_depth_luma; cfg->chroma_bit_depth = sps->bit_depth_chroma; ctx->interlaced = cfg->interlaced_source_flag ? GF_TRUE : GF_FALSE; if (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) { sar->num = sps->sar_width; sar->den = sps->sar_height; } if (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info && (sps->time_scale <= 1000*sps->num_units_in_tick) ) { ctx->cur_fps.num = sps->time_scale; ctx->cur_fps.den = sps->num_units_in_tick; if (!ctx->fps.num && ctx->dts==ctx->fps.den) ctx->dts = ctx->cur_fps.den; } ctx->fps = ctx->cur_fps; } first = GF_FALSE; if (is_lhvc) { first_lhvc = GF_FALSE; if (sps->width > max_ew) max_ew = sps->width; if (sps->height > max_eh) max_eh = sps->height; } else { if (sps->width > max_w) max_w = sps->width; if (sps->height > max_h) max_h = sps->height; } if (!ctx->analyze) naludmx_add_param_nalu(cfg->param_array, sl, GF_HEVC_NALU_SEQ_PARAM); } cfg = ctx->explicit ? lvcc : hvcc; count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) *has_hevc_base = GF_TRUE; if (!ctx->analyze) naludmx_add_param_nalu(layer_id ? lvcc->param_array : cfg->param_array, sl, GF_HEVC_NALU_PIC_PARAM); } *dsi = *dsi_enh = NULL; *dsi_size = *dsi_enh_size = 0; if (ctx->explicit || ! (*has_hevc_base) ) { naludmx_hevc_set_parall_type(ctx, lvcc); gf_odf_hevc_cfg_write(lvcc, dsi, dsi_size); *max_width = *max_enh_width = max_ew; *max_height = *max_enh_height = max_eh; } else { naludmx_hevc_set_parall_type(ctx, hvcc); gf_odf_hevc_cfg_write(hvcc, dsi, dsi_size); if (gf_list_count(lvcc->param_array) ) { naludmx_hevc_set_parall_type(ctx, lvcc); gf_odf_hevc_cfg_write(lvcc, dsi_enh, dsi_enh_size); } *max_width = max_w; *max_height = max_h; *max_enh_width = max_ew; *max_enh_height = max_eh; } count = gf_list_count(hvcc->param_array); for (i=0; i<count; i++) { GF_NALUFFParamArray *pa = gf_list_get(hvcc->param_array, i); gf_list_reset(pa->nalus); } count = gf_list_count(lvcc->param_array); for (i=0; i<count; i++) { GF_NALUFFParamArray *pa = gf_list_get(lvcc->param_array, i); gf_list_reset(pa->nalus); } gf_odf_hevc_cfg_del(hvcc); gf_odf_hevc_cfg_del(lvcc); #endif }"
"static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack) { struct net *net = sock_net(skb->sk); struct nlattr *tca[TCA_MAX + 1]; char name[IFNAMSIZ]; struct tcmsg *t; u32 protocol; u32 prio; bool prio_allocate; u32 parent; u32 chain_index; struct Qdisc *q = NULL; struct tcf_chain_info chain_info; struct tcf_chain *chain = NULL; struct tcf_block *block; struct tcf_proto *tp; unsigned long cl; void *fh; int err; int tp_created; bool rtnl_held = false; u32 flags; if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) return -EPERM; replay: tp_created = 0; err = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX, rtm_tca_policy, extack); if (err < 0) return err; t = nlmsg_data(n); protocol = TC_H_MIN(t->tcm_info); prio = TC_H_MAJ(t->tcm_info); prio_allocate = false; parent = t->tcm_parent; tp = NULL; cl = 0; block = NULL; flags = 0; if (prio == 0) { if (n->nlmsg_flags & NLM_F_CREATE) { prio = TC_H_MAKE(0x80000000U, 0U); prio_allocate = true; } else { NL_SET_ERR_MSG(extack, ""Invalid filter command with priority of zero""); return -ENOENT; } } err = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack); if (err) return err; if (tcf_proto_check_kind(tca[TCA_KIND], name)) { NL_SET_ERR_MSG(extack, ""Specified TC filter name too long""); err = -EINVAL; goto errout; } if (rtnl_held || (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) || !tcf_proto_is_unlocked(name)) { rtnl_held = true; rtnl_lock(); } err = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack); if (err) goto errout; block = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index, extack); if (IS_ERR(block)) { err = PTR_ERR(block); goto errout; } block->classid = parent; chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0; if (chain_index > TC_ACT_EXT_VAL_MASK) { NL_SET_ERR_MSG(extack, ""Specified chain index exceeds upper limit""); err = -EINVAL; goto errout; } chain = tcf_chain_get(block, chain_index, true); if (!chain) { NL_SET_ERR_MSG(extack, ""Cannot create specified filter chain""); err = -ENOMEM; goto errout; } mutex_lock(&chain->filter_chain_lock); tp = tcf_chain_tp_find(chain, &chain_info, protocol, prio, prio_allocate); if (IS_ERR(tp)) { NL_SET_ERR_MSG(extack, ""Filter with specified priority/protocol not found""); err = PTR_ERR(tp); goto errout_locked; } if (tp == NULL) { struct tcf_proto *tp_new = NULL; if (chain->flushing) { err = -EAGAIN; goto errout_locked; } if (tca[TCA_KIND] == NULL || !protocol) { NL_SET_ERR_MSG(extack, ""Filter kind and protocol must be specified""); err = -EINVAL; goto errout_locked; } if (!(n->nlmsg_flags & NLM_F_CREATE)) { NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); err = -ENOENT; goto errout_locked; } if (prio_allocate) prio = tcf_auto_prio(tcf_chain_tp_prev(chain, &chain_info)); mutex_unlock(&chain->filter_chain_lock); tp_new = tcf_proto_create(name, protocol, prio, chain, rtnl_held, extack); if (IS_ERR(tp_new)) { err = PTR_ERR(tp_new); goto errout_tp; } tp_created = 1; tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio, rtnl_held); if (IS_ERR(tp)) { err = PTR_ERR(tp); goto errout_tp; } } else { mutex_unlock(&chain->filter_chain_lock); } if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) { NL_SET_ERR_MSG(extack, ""Specified filter kind does not match existing one""); err = -EINVAL; goto errout; } fh = tp->ops->get(tp, t->tcm_handle); if (!fh) { if (!(n->nlmsg_flags & NLM_F_CREATE)) { NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); err = -ENOENT; goto errout; } } else if (n->nlmsg_flags & NLM_F_EXCL) { tfilter_put(tp, fh); NL_SET_ERR_MSG(extack, ""Filter already exists""); err = -EEXIST; goto errout; } if (chain->tmplt_ops && chain->tmplt_ops != tp->ops) { NL_SET_ERR_MSG(extack, ""Chain template is set to a different filter kind""); err = -EINVAL; goto errout; } if (!(n->nlmsg_flags & NLM_F_CREATE)) flags |= TCA_ACT_FLAGS_REPLACE; if (!rtnl_held) flags |= TCA_ACT_FLAGS_NO_RTNL; err = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh, flags, extack); if (err == 0) { tfilter_notify(net, skb, n, tp, block, q, parent, fh, RTM_NEWTFILTER, false, rtnl_held); tfilter_put(tp, fh); if (q) q->flags &= ~TCQ_F_CAN_BYPASS; } errout: if (err && tp_created) tcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL); errout_tp: if (chain) { if (tp && !IS_ERR(tp)) tcf_proto_put(tp, rtnl_held, NULL); if (!tp_created) tcf_chain_put(chain); } tcf_block_release(q, block, rtnl_held); if (rtnl_held) rtnl_unlock(); if (err == -EAGAIN) { rtnl_held = true; goto replay; } return err; errout_locked: mutex_unlock(&chain->filter_chain_lock); goto errout; }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli( const void *buf, pj_size_t length) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; PJ_ASSERT_RETURN(buf, PJ_EINVAL); PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL); if (hdr->pt != RTCP_PSFB || hdr->count != 1) return PJ_ENOTFOUND; return PJ_SUCCESS; }"
"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) { char uint32_buffer[5]; Trackage track = {0}; AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0); if (mvhdAtom != NULL) { APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom); fprintf(stdout, ""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate "" ""(*=approximate)\n"", movie_info.seconds, secsTOtime(movie_info.seconds), movie_info.simple_bitrate_calc); if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""  Presentation Creation Date (UTC):     %s\n"", APar_extract_UTC(movie_info.creation_time)); fprintf(stdout, ""  Presentation Modification Date (UTC): %s\n"", APar_extract_UTC(movie_info.modified_time)); } } AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0); if (iodsAtom != NULL) { movie_info.contains_iods = true; APar_Extract_iods_Info(isofile, iodsAtom); } if (optional_output & SHOW_TRACK_INFO) { APar_TrackLevelInfo(&track, NULL);                                 fprintf( stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks); fprintf(stdout, ""Trk  Type  Handler                    Kind  Lang  Bytes\n""); if (track.total_tracks > 0) { while (track.total_tracks > track.track_num) { track.track_num += 1; TrackInfo track_info = {0}; APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info); uint16_t more_whitespace = purge_extraneous_characters(track_info.track_hdlr_name); if (strlen(track_info.track_hdlr_name) == 0) { memcpy(track_info.track_hdlr_name, ""[none listed]"", 13); } fprintf(stdout, ""%u    %s  %s"", track.track_num, uint32tochar4(track_info.track_type, uint32_buffer), track_info.track_hdlr_name); uint16_t handler_len = strlen(track_info.track_hdlr_name); if (handler_len < 25 + more_whitespace) { for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) { fprintf(stdout, "" ""); } } fprintf(stdout, ""  %s  %s   %"" PRIu64, uint32tochar4(track_info.track_codec, uint32_buffer), track_info.unpacked_lang, track_info.sample_aggregate); if (track_info.encoder_name[0] != 0 && track_info.contains_esds) { purge_extraneous_characters(track_info.encoder_name); fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name); } if (track_info.type_of_track & DRM_PROTECTED_TRACK) { fprintf(stdout, "" (protected %s)"", uint32tochar4(track_info.protected_codec, uint32_buffer)); } fprintf(stdout, ""\n""); if (track_info.type_of_track & VIDEO_TRACK || track_info.type_of_track & AUDIO_TRACK) { APar_Print_TrackDetails(&track_info); } if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""       Creation Date (UTC):     %s\n"", APar_extract_UTC(track_info.creation_time)); fprintf(stdout, ""       Modification Date (UTC): %s\n"", APar_extract_UTC(track_info.modified_time)); } } } } }"
"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si) { s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if (pps_id > 255) return -1; si->pps = &avc->pps[pps_id]; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id]; if (!si->sps->log2_max_frame_num) return -2; avc->sps_active_idx = si->pps->sps_id; avc->pps_active_idx = pps_id; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; si->bottom_field_flag = 0; if (!si->sps->frame_mbs_only_flag) { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } if (si->slice_type % 5 == GF_AVC_TYPE_B) { gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag""); } num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1; num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1; if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) { Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag""); if (num_ref_idx_active_override_flag) { num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1""); if (si->slice_type % 5 == GF_AVC_TYPE_B) { num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1""); } } } if (si->nal_unit_type == 20 || si->nal_unit_type == 21) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n"")); assert(0); return -1; } else { ref_pic_list_modification(bs, si->slice_type); } if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP)) || (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) { pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1); } if (si->nal_ref_idc != 0) { dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE)); } if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) { gf_bs_read_ue_log(bs, ""cabac_init_idc""); } gf_bs_read_se(bs); if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) { if (si->slice_type % 5 == GF_AVC_TYPE_SP) { gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag""); } gf_bs_read_se_log(bs, ""slice_qs_delta""); } if (si->pps->deblocking_filter_control_present_flag) { if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) { gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2""); gf_bs_read_se_log(bs, ""slice_beta_offset_div2""); } } if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) { gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle""); } return 0; }"
"static void suboption(struct Curl_easy *data) { struct curl_slist *v; unsigned char temp[2048]; ssize_t bytes_written; size_t len; int err; char varname[128] = """"; char varval[128] = """"; struct TELNET *tn = data->req.p.telnet; struct connectdata *conn = data->conn; printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2); switch(CURL_SB_GET(tn)) { case CURL_TELOPT_TTYPE: len = strlen(tn->subopt_ttype) + 4 + 2; msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c%s%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE, CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE); bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; case CURL_TELOPT_XDISPLOC: len = strlen(tn->subopt_xdisploc) + 4 + 2; msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c%s%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC, CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE); bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; case CURL_TELOPT_NEW_ENVIRON: msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON, CURL_TELQUAL_IS); len = 4; for(v = tn->telnet_vars; v; v = v->next) { size_t tmplen = (strlen(v->data) + 1); if(len + tmplen < (int)sizeof(temp)-6) { if(sscanf(v->data, ""%127[^,],%127s"", varname, varval)) { msnprintf((char *)&temp[len], sizeof(temp) - len, ""%c%s%c%s"", CURL_NEW_ENV_VAR, varname, CURL_NEW_ENV_VALUE, varval); len += tmplen; } } } msnprintf((char *)&temp[len], sizeof(temp) - len, ""%c%c"", CURL_IAC, CURL_SE); len += 2; bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; } return; }"
"Function *ESTreeIRGen::genGeneratorFunction( Identifier originalName, Variable *lazyClosureAlias, ESTree::FunctionLikeNode *functionNode) { assert(functionNode && ""Function AST cannot be null""); auto *outerFn = Builder.createGeneratorFunction( originalName, Function::DefinitionKind::ES5Function, ESTree::isStrict(functionNode->strictness), nullptr); auto *innerFn = genES5Function( genAnonymousLabelName(originalName.isValid() ? originalName.str() : """"), lazyClosureAlias, functionNode, true); { FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()}; emitFunctionPrologue( functionNode, Builder.createBasicBlock(outerFn), InitES5CaptureState::Yes, DoEmitParameters::No); auto *gen = Builder.createCreateGeneratorInst(innerFn); if (!hasSimpleParams(functionNode)) { Value *next = Builder.createLoadPropertyInst(gen, ""next""); Builder.createCallInst(next, gen, {}); } emitFunctionEpilogue(gen); } return outerFn; }"
int64_t TensorByteSize(const TensorProto& t) { int64_t num_elems = TensorShape(t.tensor_shape()).num_elements(); return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype()); }
"void Compute(tensorflow::OpKernelContext* context) override { const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); const int input_data_size = data->flat<tstring>().size(); const int splits_vec_size = splits_vec.size(); if (splits_vec_size > 0) { int prev_split = splits_vec(0); OP_REQUIRES(context, prev_split == 0, errors::InvalidArgument(""First split value must be 0, got "", prev_split)); for (int i = 1; i < splits_vec_size; ++i) { bool valid_splits = splits_vec(i) >= prev_split; valid_splits = valid_splits && (splits_vec(i) <= input_data_size); OP_REQUIRES(context, valid_splits, errors::InvalidArgument( ""Invalid split value "", splits_vec(i), "", must be in ["", prev_split, "", "", input_data_size, ""]"")); prev_split = splits_vec(i); } OP_REQUIRES(context, prev_split == input_data_size, errors::InvalidArgument( ""Last split value must be data size. Expected "", input_data_size, "", got "", prev_split)); } int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
DRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data) { return (short)drwav_bytes_to_u16(data); }
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf64_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"void proto_register_bacapp(void) { static hf_register_info hf[] = { { &hf_bacapp_type, { ""APDU Type"",           ""bacapp.type"", FT_UINT8, BASE_DEC, VALS(BACnetTypeName), 0xf0, NULL, HFILL } }, { &hf_bacapp_pduflags, { ""PDU Flags"",          ""bacapp.pduflags"", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL } }, { &hf_bacapp_SEG, { ""Segmented Request"",           ""bacapp.segmented_request"", FT_BOOLEAN, 8, TFS(&segments_follow), 0x08, NULL, HFILL } }, { &hf_bacapp_MOR, { ""More Segments"",           ""bacapp.more_segments"", FT_BOOLEAN, 8, TFS(&more_follow), 0x04, ""More Segments Follow"", HFILL } }, { &hf_bacapp_SA, { ""SA"",           ""bacapp.SA"", FT_BOOLEAN, 8, TFS(&segmented_accept), 0x02, ""Segmented Response accepted"", HFILL } }, { &hf_bacapp_max_adpu_size, { ""Size of Maximum ADPU accepted"",           ""bacapp.max_adpu_size"", FT_UINT8, BASE_DEC, VALS(BACnetMaxAPDULengthAccepted), 0x0f, NULL, HFILL } }, { &hf_bacapp_response_segments, { ""Max Response Segments accepted"",           ""bacapp.response_segments"", FT_UINT8, BASE_DEC, VALS(BACnetMaxSegmentsAccepted), 0x70, NULL, HFILL } }, { &hf_bacapp_objectType, { ""Object Type"",           ""bacapp.objectType"", FT_UINT32, BASE_DEC, VALS(BACnetObjectType), 0xffc00000, NULL, HFILL } }, { &hf_bacapp_instanceNumber, { ""Instance Number"",           ""bacapp.instance_number"", FT_UINT32, BASE_DEC, NULL, 0x003fffff, NULL, HFILL } }, { &hf_BACnetPropertyIdentifier, { ""Property Identifier"", ""bacapp.property_identifier"", FT_UINT32, BASE_DEC, VALS(BACnetPropertyIdentifier), 0, NULL, HFILL } }, { &hf_BACnetVendorIdentifier, { ""Vendor Identifier"", ""bacapp.vendor_identifier"", FT_UINT16, BASE_DEC|BASE_EXT_STRING, &BACnetVendorIdentifiers_ext, 0, NULL, HFILL } }, { &hf_BACnetRestartReason, { ""Restart Reason"", ""bacapp.restart_reason"", FT_UINT8, BASE_DEC, VALS(BACnetRestartReason), 0, NULL, HFILL } }, { &hf_bacapp_invoke_id, { ""Invoke ID"",           ""bacapp.invoke_id"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_sequence_number, { ""Sequence Number"",           ""bacapp.sequence_number"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_window_size, { ""Proposed Window Size"",           ""bacapp.window_size"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_service, { ""Service Choice"",           ""bacapp.confirmed_service"", FT_UINT8, BASE_DEC, VALS(BACnetConfirmedServiceChoice), 0x00, NULL, HFILL } }, { &hf_bacapp_uservice, { ""Unconfirmed Service Choice"",           ""bacapp.unconfirmed_service"", FT_UINT8, BASE_DEC, VALS(BACnetUnconfirmedServiceChoice), 0x00, NULL, HFILL } }, { &hf_bacapp_NAK, { ""NAK"",           ""bacapp.NAK"", FT_BOOLEAN, 8, NULL, 0x02, ""negative ACK"", HFILL } }, { &hf_bacapp_SRV, { ""SRV"",           ""bacapp.SRV"", FT_BOOLEAN, 8, NULL, 0x01, ""Server"", HFILL } }, { &hf_Device_Instance_Range_Low_Limit, { ""Device Instance Range Low Limit"", ""bacapp.who_is.low_limit"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_Device_Instance_Range_High_Limit, { ""Device Instance Range High Limit"", ""bacapp.who_is.high_limit"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetRejectReason, { ""Reject Reason"",           ""bacapp.reject_reason"", FT_UINT8, BASE_DEC, VALS(BACnetRejectReason), 0x00, NULL, HFILL } }, { &hf_BACnetAbortReason, { ""Abort Reason"",           ""bacapp.abort_reason"", FT_UINT8, BASE_DEC, VALS(BACnetAbortReason), 0x00, NULL, HFILL } }, { &hf_BACnetApplicationTagNumber, { ""Application Tag Number"", ""bacapp.application_tag_number"", FT_UINT8, BASE_DEC, VALS(BACnetApplicationTagNumber), 0xF0, NULL, HFILL } }, { &hf_BACnetContextTagNumber, { ""Context Tag Number"", ""bacapp.context_tag_number"", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL } }, { &hf_BACnetExtendedTagNumber, { ""Extended Tag Number"", ""bacapp.extended_tag_number"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetNamedTag, { ""Named Tag"", ""bacapp.named_tag"", FT_UINT8, BASE_DEC, VALS(BACnetTagNames), 0x07, NULL, HFILL } }, { &hf_BACnetCharacterSet, { ""String Character Set"", ""bacapp.string_character_set"", FT_UINT8, BASE_DEC, VALS(BACnetCharacterSet), 0, NULL, HFILL } }, { &hf_BACnetCodePage, { ""Code Page"", ""bacapp.code_page"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetTagClass, { ""Tag Class"",           ""bacapp.tag_class"", FT_BOOLEAN, 8, TFS(&BACnetTagClass), 0x08, NULL, HFILL } }, { &hf_bacapp_tag_lvt, { ""Length Value Type"", ""bacapp.LVT"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_tag_ProcessId, { ""ProcessIdentifier"",           ""bacapp.processId"", FT_UINT32, BASE_DEC, NULL, 0, ""Process Identifier"", HFILL } }, { &hf_bacapp_tag_IPV4, { ""IPV4"",           ""bacapp.IPV4"", FT_IPv4, BASE_NONE, NULL, 0, ""IP-Address"", HFILL } }, { &hf_bacapp_tag_IPV6, { ""IPV6"",           ""bacapp.IPV6"", FT_IPv6, BASE_NONE, NULL, 0, ""IP-Address"", HFILL } }, { &hf_bacapp_tag_PORT, { ""Port"",           ""bacapp.Port"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_tag_mac_address_broadcast, { ""MAC-address: broadcast"",           ""bacapp.mac_address_broadcast"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_bacapp_reserved_ashrea, { ""reserved for ASHRAE"",           ""bacapp.reserved_ashrea"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_bacapp_unused_bits, { ""Unused bits"",           ""bacapp.unused_bits"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_bit, { ""bit"",           ""bacapp.bit"", FT_BOOLEAN, 8, NULL, 0, NULL, HFILL } }, { &hf_bacapp_complete_bitstring, { ""Complete bitstring"",           ""bacapp.complete_bitstring"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, {&hf_msg_fragments, { ""Message fragments"", ""bacapp.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment, { ""Message fragment"", ""bacapp.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_overlap, { ""Message fragment overlap"", ""bacapp.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_overlap_conflicts, { ""Message fragment overlapping with conflicting data"", ""bacapp.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_multiple_tails, { ""Message has multiple tail fragments"", ""bacapp.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_too_long_fragment, { ""Message fragment too long"", ""bacapp.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_error, { ""Message defragmentation error"", ""bacapp.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_count, { ""Message fragment count"", ""bacapp.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, {&hf_msg_reassembled_in, { ""Reassembled in"", ""bacapp.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_reassembled_length, { ""Reassembled BACapp length"", ""bacapp.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } } }; static gint *ett[] = { &ett_bacapp, &ett_bacapp_control, &ett_bacapp_tag, &ett_bacapp_list, &ett_bacapp_value, &ett_msg_fragment, &ett_msg_fragments }; static ei_register_info ei[] = { { &ei_bacapp_bad_length, { ""bacapp.bad_length"", PI_MALFORMED, PI_ERROR, ""Wrong length indicated"", EXPFILL }}, { &ei_bacapp_bad_tag, { ""bacapp.bad_tag"", PI_MALFORMED, PI_ERROR, ""Wrong tag found"", EXPFILL }}, { &ei_bacapp_opening_tag, { ""bacapp.bad_opening_tag"", PI_MALFORMED, PI_ERROR, ""Expected Opening Tag!"", EXPFILL }}, }; expert_module_t* expert_bacapp; proto_bacapp = proto_register_protocol(""Building Automation and Control Network APDU"", ""BACapp"", ""bacapp""); proto_register_field_array(proto_bacapp, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_bacapp = expert_register_protocol(proto_bacapp); expert_register_field_array(expert_bacapp, ei, array_length(ei)); register_dissector(""bacapp"", dissect_bacapp, proto_bacapp); reassembly_table_register(&msg_reassembly_table, &addresses_reassembly_table_functions); bacapp_dissector_table = register_dissector_table(""bacapp.vendor_identifier"", ""BACapp Vendor Identifier"", proto_bacapp, FT_UINT8, BASE_HEX); register_bacapp_stat_trees(); bacapp_tap = register_tap(""bacapp"");  }"
"static void file_asynch_read (struct rw *rw, struct command *command, nbd_completion_callback cb) { int dummy = 0; file_synch_read (rw, slice_ptr (command->slice), command->slice.len, command->offset); if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } }"
"GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize) { u32 do_flush, bytesLeft, size, nal_type; char shdr[2]; char stap_hdr; do_flush = 0; if (!nalu) do_flush = 1; else if (builder->sl_header.accessUnitStartFlag) do_flush = 1; else if (builder->bytesInPacket + nalu_size >= builder->Path_MTU) do_flush = 2; else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2; if (builder->bytesInPacket && do_flush) { builder->rtp_header.Marker = (do_flush==1) ? 1 : 0; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } if (!nalu) return GF_OK; if (!builder->bytesInPacket) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.Marker = 0; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); builder->avc_non_idr = GF_TRUE; } nal_type = nalu[0] & 0x1F; switch (nal_type) { case GF_AVC_NALU_NON_IDR_SLICE: case GF_AVC_NALU_ACCESS_UNIT: case GF_AVC_NALU_END_OF_SEQ: case GF_AVC_NALU_END_OF_STREAM: case GF_AVC_NALU_FILLER_DATA: break; default: builder->avc_non_idr = GF_FALSE; break; } if (builder->bytesInPacket+nalu_size<builder->Path_MTU) { Bool use_stap = GF_TRUE; if (IsAUEnd && !builder->bytesInPacket) use_stap = GF_FALSE; if (use_stap) { if (!builder->bytesInPacket) { stap_hdr = (nalu[0] & 0xE0) | 24; builder->OnData(builder->cbk_obj, (char *) &stap_hdr, 1, GF_FALSE); builder->bytesInPacket = 1; } shdr[0] = nalu_size>>8; shdr[1] = nalu_size&0x00ff; builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE); builder->bytesInPacket += 2; } if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, nalu_size, 0); else builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE); builder->bytesInPacket += nalu_size; if (IsAUEnd) { builder->rtp_header.Marker = 1; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } } else { u32 offset; assert(nalu_size>=builder->Path_MTU); assert(!builder->bytesInPacket); bytesLeft = nalu_size - 1; offset = 1; while (bytesLeft) { if (2 + bytesLeft > builder->Path_MTU) { size = builder->Path_MTU - 2; } else { size = bytesLeft; } shdr[0] = (nalu[0] & 0xE0) | 28; shdr[1] = (nalu[0] & 0x1F); if (offset==1) shdr[1] |= 0x80; else if (size == bytesLeft) shdr[1] |= 0x40; builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE); if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, size, offset); else builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE); offset += size; bytesLeft -= size; builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; if (bytesLeft) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); } } } return GF_OK; }"
"static int find_exif_tag(const uint8_t* exif, int  size, uint16_t query_tag, bool* out_littleEndian) { if (size < 4) { return -1; } if ((exif[0] != 'I' && exif[0] != 'M') || (exif[1] != 'I' && exif[1] != 'M')) { return -1; } bool littleEndian = (exif[0] == 'I'); assert(out_littleEndian); *out_littleEndian = littleEndian; int offset = read32(exif, size, 4, littleEndian); if (offset < 0) { return -1; } int cnt = read16(exif, size, offset, littleEndian); if (cnt < 1) { return -1; } for (int i = 0; i < cnt; i++) { int tag = read16(exif, size, offset + 2 + i * 12, littleEndian); if (tag == query_tag) { return offset + 2 + i * 12; } } return -1; }"
"int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, char **ret, JsonVariant **ret_package_metadata) { _cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 }; _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL; _cleanup_free_ char *buf = NULL; int r; assert(fd >= 0); r = dlopen_dw(); if (r < 0) return r; r = dlopen_elf(); if (r < 0) return r; r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK)); if (r < 0) return r; if (ret) { r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC)); if (r < 0) return r; } if (ret_package_metadata) { r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC)); if (r < 0) return r; } r = safe_fork_full(""(sd-parse-elf)"", (int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] }, 4, FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG, NULL); if (r < 0) { if (r == -EPROTO) {  int e, k; k = read(error_pipe[0], &e, sizeof(e)); if (k < 0 && errno != EAGAIN)  return -errno; if (k == sizeof(e)) return e;  if (k != 0) return -EIO; } return r; } if (r == 0) { if (fork_disable_dump) { r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0)); if (r < 0) goto child_fail; } r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL); if (r < 0) goto child_fail; if (buf) { r = loop_write(return_pipe[1], buf, strlen(buf), false); if (r < 0) goto child_fail; return_pipe[1] = safe_close(return_pipe[1]); } if (package_metadata) { _cleanup_fclose_ FILE *json_out = NULL; json_out = take_fdopen(&json_pipe[1], ""w""); if (!json_out) { r = -errno; goto child_fail; } json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL); } _exit(EXIT_SUCCESS); child_fail: (void) write(error_pipe[1], &r, sizeof(r)); _exit(EXIT_FAILURE); } error_pipe[1] = safe_close(error_pipe[1]); return_pipe[1] = safe_close(return_pipe[1]); json_pipe[1] = safe_close(json_pipe[1]); if (ret) { _cleanup_fclose_ FILE *in = NULL; in = take_fdopen(&return_pipe[0], ""r""); if (!in) return -errno; r = read_full_stream(in, &buf, NULL); if (r < 0) return r; } if (ret_package_metadata) { _cleanup_fclose_ FILE *json_in = NULL; json_in = take_fdopen(&json_pipe[0], ""r""); if (!json_in) return -errno; r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL); if (r < 0 && r != -ENODATA)  return r; } if (ret) *ret = TAKE_PTR(buf); if (ret_package_metadata) *ret_package_metadata = TAKE_PTR(package_metadata); return 0; }"
"ecma_collection_t * ecma_op_object_get_property_names (ecma_object_t *obj_p,  uint32_t opts)  { JERRY_ASSERT (obj_p != NULL && !ecma_is_lexical_environment (obj_p)); #if ENABLED (JERRY_ES2015_BUILTIN_PROXY) if (ECMA_OBJECT_IS_PROXY (obj_p)) { return ecma_proxy_object_own_property_keys (obj_p); } #endif  if (ecma_op_object_is_fast_array (obj_p)) { return ecma_fast_array_get_property_names (obj_p, opts); } ecma_collection_t *ret_p = ecma_new_collection (); ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection (); const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0; const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0; const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0; #if ENABLED (JERRY_ES2015) const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0; const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0; #endif  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE; const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size; JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size); memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0])); while (true) { const ecma_object_type_t type = ecma_get_object_type (obj_p); const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p); ecma_length_t string_named_properties_count = 0; ecma_length_t array_index_named_properties_count = 0; #if ENABLED (JERRY_ES2015) ecma_length_t symbol_named_properties_count = 0; #endif  ecma_collection_t *prop_names_p = ecma_new_collection (); #if ENABLED (JERRY_ES2015) if (JERRY_LIKELY (!is_symbols_only)) { #endif  if (obj_is_builtin) { if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p)) { ecma_builtin_routine_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } else { ecma_builtin_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } } else { switch (type) { case ECMA_OBJECT_TYPE_PSEUDO_ARRAY: { #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) if (ecma_object_is_typedarray (obj_p)) { ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p); } #endif  break; } case ECMA_OBJECT_TYPE_FUNCTION: { if (!is_array_indices_only) { ecma_op_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION: { if (!is_array_indices_only) { ecma_op_external_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_BOUND_FUNCTION: { if (!is_array_indices_only) { ecma_op_bound_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_CLASS: { ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p; if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL) { ecma_op_string_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_ARRAY: { ecma_op_array_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); break; } default: { JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL); break; } } } #if ENABLED (JERRY_ES2015) } #endif  ecma_value_t *buffer_p = prop_names_p->buffer_p; uint32_t lazy_prop_name_count = prop_names_p->item_count; const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size; JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size); memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0])); for (uint32_t i = 0; i < prop_names_p->item_count; i++) { ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]); if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX) { array_index_named_properties_count++; } #if ENABLED (JERRY_ES2015) else if (ecma_prop_name_is_symbol (name_p)) { symbol_named_properties_count++; } #endif  else { string_named_properties_count++; } #if ENABLED (JERRY_ES2015) JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p)); #endif  uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0) { own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); } } jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp; if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL) { ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p; uint32_t length = ext_obj_p->u.array.length; array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p); ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp); for (uint32_t i = 0; i < length; i++) { if (ecma_is_value_array_hole (values_p[i])) { continue; } ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i); uint8_t hash = (uint8_t) ecma_string_hash (index_str_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); bool is_add = true; if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0) { buffer_p = prop_names_p->buffer_p; for (uint32_t j = 0; j < prop_names_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (index_str_p, current_name_p)) { is_add = false; break; } } } if (is_add) { own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p)); } } } else { #if ENABLED (JERRY_PROPRETY_HASHMAP) if (prop_iter_cp != JMEM_CP_NULL) { ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp); if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP) { prop_iter_cp = prop_iter_p->next_property_cp; } } #endif  while (prop_iter_cp != JMEM_CP_NULL) { ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp); JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p)); for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++) { ecma_property_t *property_p = prop_iter_p->types + i; if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR) { ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p; if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT) { continue; } ecma_string_t *name_p = ecma_string_from_property_name (*property_p, prop_pair_p->names_cp[i]); if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p))) { #if ENABLED (JERRY_ES2015) bool is_symbol = ecma_prop_name_is_symbol (name_p); if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol)) { ecma_deref_ecma_string (name_p); continue; } #endif  uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); bool is_add = true; if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0) { buffer_p = prop_names_p->buffer_p; for (uint32_t j = 0; j < prop_names_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_add = false; break; } } } if (is_add) { if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX) { array_index_named_properties_count++; } else if (!is_array_indices_only) { #if ENABLED (JERRY_ES2015) if (ecma_prop_name_is_symbol (name_p)) { symbol_named_properties_count++; } else { #endif  string_named_properties_count++; #if ENABLED (JERRY_ES2015) } #endif  } else { ecma_deref_ecma_string (name_p); continue; } own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p)); } else { ecma_deref_ecma_string (name_p); } } else { JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p)); ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p)); } } } prop_iter_cp = prop_iter_p->next_property_cp; } } ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count; #if ENABLED (JERRY_ES2015) all_properties_count += symbol_named_properties_count; #endif  JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *); ecma_string_t **string_names_p = names_p + array_index_named_properties_count; #if ENABLED (JERRY_ES2015) ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count; #endif  uint32_t array_index_name_pos = 0; uint32_t string_name_pos = string_named_properties_count; uint32_t lazy_string_name_pos = 0; #if ENABLED (JERRY_ES2015) uint32_t symbol_name_pos = symbol_named_properties_count; #endif  buffer_p = prop_names_p->buffer_p; for (uint32_t i = 0; i < prop_names_p->item_count; i++) { ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]); ecma_ref_ecma_string (name_p); uint32_t index = ecma_string_get_array_index (name_p); if (index != ECMA_STRING_NOT_ARRAY_INDEX) { JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count); uint32_t insertion_pos = 0; while (insertion_pos < array_index_name_pos && index > ecma_string_get_array_index (names_p[insertion_pos])) { insertion_pos++; } if (insertion_pos == array_index_name_pos) { names_p[array_index_name_pos++] = name_p; } else { JERRY_ASSERT (insertion_pos < array_index_name_pos); JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos])); uint32_t move_pos = array_index_name_pos++; while (move_pos > insertion_pos) { names_p[move_pos] = names_p[move_pos - 1u]; move_pos--; } names_p[insertion_pos] = name_p; } } #if ENABLED (JERRY_ES2015) else if (ecma_prop_name_is_symbol (name_p)) { JERRY_ASSERT (symbol_name_pos > 0); JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count); symbol_names_p[--symbol_name_pos] = name_p; } #endif  else { JERRY_ASSERT (string_name_pos > 0); JERRY_ASSERT (string_name_pos <= string_named_properties_count); if (i < lazy_prop_name_count) { string_names_p[lazy_string_name_pos++] = name_p; } else { string_names_p[--string_name_pos] = name_p; } } } JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count); JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0); #if ENABLED (JERRY_ES2015) JERRY_ASSERT (symbol_name_pos == 0); #endif  ecma_collection_free (prop_names_p); for (uint32_t i = 0; i < all_properties_count; i++) { bool is_append = true; ecma_string_t *name_p = names_p[i]; uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0) { names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); } else { buffer_p = ret_p->buffer_p; for (uint32_t j = 0; j < ret_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_append = false; break; } } } if (is_append) { buffer_p = skipped_non_enumerable_p->buffer_p; for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_append = false; break; } } } if (is_append) { JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0); ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p)); } else { ecma_deref_ecma_string (name_p); } } JMEM_FINALIZE_LOCAL_ARRAY (names_p); if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL) { break; } obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp); } ecma_collection_free (skipped_non_enumerable_p); return ret_p; }"
static RzList *symbols(RzBinFile *bf) { if (!bf) { return NULL; } LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf); if (!bin_info_obj) { return NULL; } return bin_info_obj->symbol_list; }
"varnumber_T num_divide(varnumber_T n1, varnumber_T n2, int *failed) { varnumber_Tresult; if (n2 == 0) { if (in_vim9script()) { emsg(_(e_divide_by_zero)); if (failed != NULL) *failed = TRUE; } if (n1 == 0) result = VARNUM_MIN; else if (n1 < 0) result = -VARNUM_MAX; else result = VARNUM_MAX; } else result = n1 / n2; return result; }"
"void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n, int offset) { CharCode oldLen, i; Unicode u; char uHex[5]; int j; if (code >= mapLen) { oldLen = mapLen; mapLen = (code + 256) & ~255; map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode)); for (i = oldLen; i < mapLen; ++i) { map[i] = 0; } } if (n <= 4) { if (sscanf(uStr, ""%x"", &u) != 1) { error(-1, ""Illegal entry in ToUnicode CMap""); return; } map[code] = u + offset; } else { if (sMapLen >= sMapSize) { sMapSize = sMapSize + 16; sMap = (CharCodeToUnicodeString *) greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString)); } map[code] = 0; sMap[sMapLen].c = code; sMap[sMapLen].len = n / 4; for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) { strncpy(uHex, uStr + j*4, 4); uHex[4] = '\0'; if (sscanf(uHex, ""%x"", &sMap[sMapLen].u[j]) != 1) { error(-1, ""Illegal entry in ToUnicode CMap""); } } sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset; ++sMapLen; } }"
"int ksmbd_conn_handler_loop(void *p) { struct ksmbd_conn *conn = (struct ksmbd_conn *)p; struct ksmbd_transport *t = conn->transport; unsigned int pdu_size, max_allowed_pdu_size; char hdr_buf[4] = {0,}; int size; mutex_init(&conn->srv_mutex); __module_get(THIS_MODULE); if (t->ops->prepare && t->ops->prepare(t)) goto out; conn->last_active = jiffies; while (ksmbd_conn_alive(conn)) { if (try_to_freeze()) continue; kvfree(conn->request_buf); conn->request_buf = NULL; size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1); if (size != sizeof(hdr_buf)) break; pdu_size = get_rfc1002_len(hdr_buf); ksmbd_debug(CONN, ""RFC1002 header %u bytes\n"", pdu_size); if (ksmbd_conn_good(conn)) max_allowed_pdu_size = SMB3_MAX_MSGSIZE + conn->vals->max_write_size; else max_allowed_pdu_size = SMB3_MAX_MSGSIZE; if (pdu_size > max_allowed_pdu_size) { pr_err_ratelimited(""PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\n"", pdu_size, max_allowed_pdu_size, READ_ONCE(conn->status)); break; } if (pdu_size > MAX_STREAM_PROT_LEN) break; size = pdu_size + 4 + 1; conn->request_buf = kvmalloc(size, GFP_KERNEL); if (!conn->request_buf) break; memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf)); if (!ksmbd_smb_request(conn)) break; size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2); if (size < 0) { pr_err(""sock_read failed: %d\n"", size); break; } if (size != pdu_size) { pr_err(""PDU error. Read: %d, Expected: %d\n"", size, pdu_size); continue; } if (!default_conn_ops.process_fn) { pr_err(""No connection request callback\n""); break; } if (default_conn_ops.process_fn(conn)) { pr_err(""Cannot handle request\n""); break; } } out: ksmbd_conn_set_releasing(conn); wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0); if (IS_ENABLED(CONFIG_UNICODE)) utf8_unload(conn->um); unload_nls(conn->local_nls); if (default_conn_ops.terminate_fn) default_conn_ops.terminate_fn(conn); t->ops->disconnect(t); module_put(THIS_MODULE); return 0; }"
"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) { char *uint32_buffer = (char *)malloc(sizeof(char) * 5); Trackage track = {0}; AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0); if (mvhdAtom != NULL) { APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom); fprintf(stdout, ""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate "" ""(*=approximate)\n"", movie_info.seconds, secsTOtime(movie_info.seconds), movie_info.simple_bitrate_calc); if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""  Presentation Creation Date (UTC):     %s\n"", APar_extract_UTC(movie_info.creation_time)); fprintf(stdout, ""  Presentation Modification Date (UTC): %s\n"", APar_extract_UTC(movie_info.modified_time)); } } AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0); if (iodsAtom != NULL) { movie_info.contains_iods = true; APar_Extract_iods_Info(isofile, iodsAtom); } if (optional_output & SHOW_TRACK_INFO) { APar_TrackLevelInfo(&track, NULL);                                 fprintf( stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks); fprintf(stdout, ""Trk  Type  Handler                    Kind  Lang  Bytes\n""); if (track.total_tracks > 0) { while (track.total_tracks > track.track_num) { track.track_num += 1; TrackInfo track_info = {0}; APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info); uint16_t more_whitespace = purge_extraneous_characters(track_info.track_hdlr_name); if (strlen(track_info.track_hdlr_name) == 0) { memcpy(track_info.track_hdlr_name, ""[none listed]"", 13); } fprintf(stdout, ""%u    %s  %s"", track.track_num, uint32tochar4(track_info.track_type, uint32_buffer), track_info.track_hdlr_name); uint16_t handler_len = strlen(track_info.track_hdlr_name); if (handler_len < 25 + more_whitespace) { for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) { fprintf(stdout, "" ""); } } fprintf(stdout, ""  %s  %s   %"" PRIu64, uint32tochar4(track_info.track_codec, uint32_buffer), track_info.unpacked_lang, track_info.sample_aggregate); if (track_info.encoder_name[0] != 0 && track_info.contains_esds) { purge_extraneous_characters(track_info.encoder_name); fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name); } if (track_info.type_of_track & DRM_PROTECTED_TRACK) { fprintf(stdout, "" (protected %s)"", uint32tochar4(track_info.protected_codec, uint32_buffer)); } fprintf(stdout, ""\n""); if (track_info.type_of_track & VIDEO_TRACK || track_info.type_of_track & AUDIO_TRACK) { APar_Print_TrackDetails(&track_info); } if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""       Creation Date (UTC):     %s\n"", APar_extract_UTC(track_info.creation_time)); fprintf(stdout, ""       Modification Date (UTC): %s\n"", APar_extract_UTC(track_info.modified_time)); } } } } return; }"
"void RequestHandler::startRequest(const string& transactionId,  const string& httpMethod, const string& url, const string& body, bool verifyPeer) { RequestHandler::ConnInfo *conn; CURLMcode rc; if (0 == url.find(""tcp:      string json = ""{\""action\"": \""route\"", \""data\"": {\""uri\"": \""""; json.append(url.substr(6)); if (0 == url.find(""tcp:      else json.append("";transport=tls""); json.append(""\""}}""); DR_LOG(log_info) << ""RequestHandler::startRequest: no web callback required, sending directly to "" << url << "":"" << json.c_str() ; m_pController->httpCallRoutingComplete(transactionId, 200, json); return; } DR_LOG(log_info) << ""RequestHandler::startRequest: sending http "" << httpMethod << "": "" << url ; conn = m_pool.malloc() ; CURL* easy = NULL ; { if( m_cacheEasyHandles.empty() ) { m_cacheEasyHandles.push_back(createEasyHandle()) ; } easy = m_cacheEasyHandles.front() ; m_cacheEasyHandles.pop_front() ; DR_LOG(log_debug) << ""RequestHandler::makeRequestForRoute - after acquiring handle in thread "" <<  std::this_thread::get_id() << "" "" << dec << m_cacheEasyHandles.size() << "" handles remain in cache""; } conn->easy = easy; conn->global = &m_g; strncpy(conn->url, url.c_str(), URL_LEN) ; strncpy(conn->body, body.c_str(), HTTP_BODY_LEN); strncpy(conn->transactionId, transactionId.c_str(), TXNID_LEN); conn->hdr_list = NULL ; curl_easy_setopt(easy, CURLOPT_URL, conn->url); curl_easy_setopt(easy, CURLOPT_WRITEFUNCTION, write_cb); curl_easy_setopt(easy, CURLOPT_WRITEDATA, conn); curl_easy_setopt(easy, CURLOPT_ERRORBUFFER, conn->error); curl_easy_setopt(easy, CURLOPT_PRIVATE, conn); curl_easy_setopt(easy, CURLOPT_VERBOSE, 0L); curl_easy_setopt(easy, CURLOPT_NOPROGRESS, 1L); curl_easy_setopt(easy, CURLOPT_OPENSOCKETFUNCTION, opensocket); curl_easy_setopt(easy, CURLOPT_CLOSESOCKETFUNCTION, close_socket); if( 0 == url.find(""https:"") ) { curl_easy_setopt(easy, CURLOPT_SSL_VERIFYPEER, verifyPeer); } conn->hdr_list = curl_slist_append(conn->hdr_list, ""Accept: application/json""); if( 0 == httpMethod.compare(""POST"") ) { curl_easy_setopt(easy, CURLOPT_POSTFIELDS, conn->body); curl_easy_setopt(easy, CURLOPT_POSTFIELDSIZE, strlen(conn->body)); conn->hdr_list = curl_slist_append(conn->hdr_list, ""Content-Type: text/plain; charset=UTF-8""); } curl_easy_setopt(easy, CURLOPT_HTTPHEADER, conn->hdr_list); rc = curl_multi_add_handle(m_g.multi, conn->easy); mcode_test(""new_conn: curl_multi_add_handle"", rc); }"
"int dnn_execute_layer_conv2d(DnnOperand *operands, const int32_t *input_operand_indexes, int32_t output_operand_index, const void *parameters) { float *output; int32_t input_operand_index = input_operand_indexes[0]; int number = operands[input_operand_index].dims[0]; int height = operands[input_operand_index].dims[1]; int width = operands[input_operand_index].dims[2]; int channel = operands[input_operand_index].dims[3]; const float *input = operands[input_operand_index].data; const ConvolutionalParams *conv_params = (const ConvolutionalParams *)parameters; int radius = conv_params->kernel_size >> 1; int src_linesize = width * conv_params->input_num; int filter_linesize = conv_params->kernel_size * conv_params->input_num; int filter_size = conv_params->kernel_size * filter_linesize; int pad_size = (conv_params->padding_method == VALID) ? (conv_params->kernel_size - 1) / 2 * conv_params->dilation : 0; DnnOperand *output_operand = &operands[output_operand_index]; output_operand->dims[0] = number; output_operand->dims[1] = height - pad_size * 2; output_operand->dims[2] = width - pad_size * 2; output_operand->dims[3] = conv_params->output_num; output_operand->data_type = operands[input_operand_index].data_type; output_operand->length = calculate_operand_data_length(output_operand); output_operand->data = av_realloc(output_operand->data, output_operand->length); if (!output_operand->data) return -1; output = output_operand->data; av_assert0(channel == conv_params->input_num); for (int y = pad_size; y < height - pad_size; ++y) { for (int x = pad_size; x < width - pad_size; ++x) { for (int n_filter = 0; n_filter < conv_params->output_num; ++n_filter) { if (conv_params->has_bias) output[n_filter] = conv_params->biases[n_filter]; else output[n_filter] = 0.f; for (int ch = 0; ch < conv_params->input_num; ++ch) { for (int kernel_y = 0; kernel_y < conv_params->kernel_size; ++kernel_y) { for (int kernel_x = 0; kernel_x < conv_params->kernel_size; ++kernel_x) { float input_pel; if (conv_params->padding_method == SAME_CLAMP_TO_EDGE) { int y_pos = CLAMP_TO_EDGE(y + (kernel_y - radius) * conv_params->dilation, height); int x_pos = CLAMP_TO_EDGE(x + (kernel_x - radius) * conv_params->dilation, width); input_pel = input[y_pos * src_linesize + x_pos * conv_params->input_num + ch]; } else { int y_pos = y + (kernel_y - radius) * conv_params->dilation; int x_pos = x + (kernel_x - radius) * conv_params->dilation; input_pel = (x_pos < 0 || x_pos >= width || y_pos < 0 || y_pos >= height) ? 0.0 : input[y_pos * src_linesize + x_pos * conv_params->input_num + ch]; } output[n_filter] += input_pel * conv_params->kernel[n_filter * filter_size + kernel_y * filter_linesize + kernel_x * conv_params->input_num + ch]; } } } switch (conv_params->activation){ case RELU: output[n_filter] = FFMAX(output[n_filter], 0.0); break; case TANH: output[n_filter] = 2.0f  / (1.0f + exp(-2.0f * output[n_filter])) - 1.0f; break; case SIGMOID: output[n_filter] = 1.0f / (1.0f + exp(-output[n_filter])); break; case NONE: break; case LEAKY_RELU: output[n_filter] = FFMAX(output[n_filter], 0.0) + 0.2 * FFMIN(output[n_filter], 0.0); } } output += conv_params->output_num; } } return 0; }"
"static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) { st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR); r_buf_seek (b, addr, R_BUF_SET); module->base_of_image = r_buf_read_le64 (b); module->size_of_image = r_buf_read_le32 (b); module->check_sum = r_buf_read_le32 (b); module->time_date_stamp = r_buf_read_le32 (b); module->module_name_rva = r_buf_read_le32 (b); module->version_info.dw_signature = r_buf_read_le32 (b); module->version_info.dw_struc_version = r_buf_read_le32 (b); module->version_info.dw_file_version_ms = r_buf_read_le32 (b); module->version_info.dw_file_version_ls = r_buf_read_le32 (b); module->version_info.dw_product_version_ms = r_buf_read_le32 (b); module->version_info.dw_product_version_ls = r_buf_read_le32 (b); module->version_info.dw_file_flags_mask = r_buf_read_le32 (b); module->version_info.dw_file_flags = r_buf_read_le32 (b); module->version_info.dw_file_os = r_buf_read_le32 (b); module->version_info.dw_file_type = r_buf_read_le32 (b); module->version_info.dw_file_subtype = r_buf_read_le32 (b); module->version_info.dw_file_date_ms = r_buf_read_le32 (b); module->version_info.dw_file_date_ls = r_buf_read_le32 (b); module->cv_record.data_size = r_buf_read_le32 (b); module->cv_record.rva = r_buf_read_le32 (b); module->misc_record.data_size = r_buf_read_le32 (b); module->misc_record.rva = r_buf_read_le32 (b); module->reserved_0 = r_buf_read_le64 (b); module->reserved_1 = r_buf_read_le64 (b); r_buf_seek (b, o_addr, R_BUF_SET); }"
"struct nfs_client *nfs4_init_client(struct nfs_client *clp, const struct nfs_client_initdata *cl_init) { char buf[INET6_ADDRSTRLEN + 1]; const char *ip_addr = cl_init->ip_addr; struct nfs_client *old; int error; if (clp->cl_cons_state == NFS_CS_READY) return clp; clp->rpc_ops = &nfs_v4_clientops; if (clp->cl_minorversion != 0) __set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags); __set_bit(NFS_CS_DISCRTRY, &clp->cl_flags); __set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags); error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I); if (error == -EINVAL) error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX); if (error < 0) goto error; if (ip_addr == NULL) { struct sockaddr_storage cb_addr; struct sockaddr *sap = (struct sockaddr *)&cb_addr; error = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr)); if (error < 0) goto error; error = rpc_ntop(sap, buf, sizeof(buf)); if (error < 0) goto error; ip_addr = (const char *)buf; } strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr)); error = nfs_idmap_new(clp); if (error < 0) { dprintk(""%s: failed to create idmapper. Error = %d\n"", __func__, error); goto error; } __set_bit(NFS_CS_IDMAP, &clp->cl_res_state); error = nfs4_init_client_minor_version(clp); if (error < 0) goto error; error = nfs4_discover_server_trunking(clp, &old); if (error < 0) goto error; if (clp != old) { clp->cl_preserve_clid = true; nfs_mark_client_ready(clp, -EPERM); } clear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags); nfs_put_client(clp); return old; error: nfs_mark_client_ready(clp, error); nfs_put_client(clp); return ERR_PTR(error); }"
"void jswrap_serial_unsetup(JsVar *parent) { IOEventFlags device = jsiGetDeviceFromClass(parent); JsVar *options = jsvObjectGetChild(parent, DEVICE_OPTIONS_NAME, 0); JsVar *baud = jsvObjectGetChild(parent, USART_BAUDRATE_NAME, 0); if (options) { JshUSARTInfo inf; jsserialPopulateUSARTInfo(&inf, baud, options); if (inf.pinCK!=PIN_UNDEFINED) jshPinSetState(inf.pinCK, JSHPINSTATE_UNDEFINED); if (inf.pinCTS!=PIN_UNDEFINED) jshPinSetState(inf.pinCTS, JSHPINSTATE_UNDEFINED); if (inf.pinRX!=PIN_UNDEFINED) jshPinSetState(inf.pinRX, JSHPINSTATE_UNDEFINED); if (inf.pinTX!=PIN_UNDEFINED) jshPinSetState(inf.pinTX, JSHPINSTATE_UNDEFINED); if (!DEVICE_IS_SERIAL(device)) jsserialEventCallbackKill(parent, &inf); } jsvUnLock2(options, baud); jsvObjectRemoveChild(parent, USART_BAUDRATE_NAME); jsvObjectRemoveChild(parent, DEVICE_OPTIONS_NAME); if (DEVICE_IS_SERIAL(device)) {     jshUSARTUnSetup(device); jshSetFlowControlEnabled(device, false, PIN_UNDEFINED); } }"
"void nvkm_vmm_node_insert(struct nvkm_vmm *vmm, struct nvkm_vma *vma) { struct rb_node **ptr = &vmm->root.rb_node; struct rb_node *parent = NULL; while (*ptr) { struct nvkm_vma *this = rb_entry(*ptr, typeof(*this), tree); parent = *ptr; if (vma->addr < this->addr) ptr = &parent->rb_left; else if (vma->addr > this->addr) ptr = &parent->rb_right; else BUG(); } rb_link_node(&vma->tree, parent, ptr); rb_insert_color(&vma->tree, &vmm->root); }"
"static bool ok_jpg_decode_scan(ok_jpg_decoder *decoder) { decoder->next_restart = 0; ok_jpg_decode_restart(decoder); if (decoder->restart_intervals_remaining > 0) { decoder->restart_intervals_remaining++; } if (decoder->progressive) { void (*decode_function)(ok_jpg_decoder *decoder, ok_jpg_component *c, int16_t *block); if (decoder->scan_prev_scale > 0) { decode_function = ok_jpg_decode_block_subsequent_scan; } else { decode_function = ok_jpg_decode_block_progressive; } if (decoder->num_scan_components == 1) { ok_jpg_component *c = decoder->components + decoder->scan_components[0]; c->next_block = 0; for (int data_unit_y = 0; data_unit_y < c->blocks_v; data_unit_y++) { int16_t *block = c->blocks + (c->next_block * 64); for (int data_unit_x = 0; data_unit_x < c->blocks_h; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); decode_function(decoder, c, block); block += 64; } if (decoder->eof_found || decoder->huffman_error) { return false; } c->next_block += (size_t)(c->H * decoder->data_units_x); } } else { for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; c->next_block = 0; } for (int data_unit_y = 0; data_unit_y < decoder->data_units_y; data_unit_y++) { for (int data_unit_x = 0; data_unit_x < decoder->data_units_x; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; size_t block_index = c->next_block; for (int y = 0; y < c->V; y++) { for (int x = 0; x < c->H; x++) { decode_function(decoder, c, c->blocks + (block_index * 64)); block_index++; } block_index += (size_t)(c->H * (decoder->data_units_x - 1)); } c->next_block += c->H; } } if (decoder->eof_found || decoder->huffman_error) { return false; } for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; c->next_block += (size_t)((c->V - 1) * c->H * decoder->data_units_x); } } } } else { int16_t block[64]; for (int data_unit_y = 0; data_unit_y < decoder->data_units_y; data_unit_y++) { for (int data_unit_x = 0; data_unit_x < decoder->data_units_x; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; int offset_y = 0; for (int y = 0; y < c->V; y++) { int offset_x = 0; for (int x = 0; x < c->H; x++) { ok_jpg_decode_block(decoder, c, block); c->idct(block, c->output + offset_x + offset_y); offset_x += 8; } offset_y += C_WIDTH * 8; } } if (decoder->huffman_error) { return false; } ok_jpg_convert_data_unit(decoder, data_unit_x, data_unit_y); } if (decoder->eof_found) { return false; } } } ok_jpg_dump_bits(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; if (!c->complete) { c->complete = decoder->scan_end == 63 && decoder->scan_scale == 0; } } return true; }"
"bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize) { unsigned CurRequestSize; Init(); CurRequestSize = aRequestSize; memcpy(CurRequest,aRequest,aRequestSize); char * ClientPortPtr; char * TmpPtr; char CP[128];     char * pCP; ClientPortPtr = strstr(CurRequest,""client_port""); if (ClientPortPtr != nullptr) { TmpPtr = strstr(ClientPortPtr,""\r\n""); if (TmpPtr != nullptr) { TmpPtr[0] = 0x00; strcpy(CP,ClientPortPtr); pCP = strstr(CP,""=""); if (pCP != nullptr) { pCP++; strcpy(CP,pCP); pCP = strstr(CP,""-""); if (pCP != nullptr) { pCP[0] = 0x00; m_ClientRTPPort  = atoi(CP); m_ClientRTCPPort = m_ClientRTPPort + 1; }; }; }; }; bool parseSucceeded = false; unsigned i; for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i) { char c = CurRequest[i]; if (c == ' ' || c == '\t') { parseSucceeded = true; break; } CmdName[i] = c; } CmdName[i] = '\0'; if (!parseSucceeded) { printf(""failed to parse RTSP\n""); return false; } printf(""RTSP received %s\n"", CmdName); if (strstr(CmdName,""OPTIONS"")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else if (strstr(CmdName,""DESCRIBE"")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else if (strstr(CmdName,""SETUP"")     != nullptr) m_RtspCmdType = RTSP_SETUP; else if (strstr(CmdName,""PLAY"")      != nullptr) m_RtspCmdType = RTSP_PLAY; else if (strstr(CmdName,""TEARDOWN"")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN; if (m_RtspCmdType == RTSP_SETUP) { TmpPtr = strstr(CurRequest,""RTP/AVP/TCP""); if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false; }; unsigned j = i+1; while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\t')) ++j;     for (; (int)j < (int)(CurRequestSize-8); ++j) { if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   && (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') && (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') && (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') && CurRequest[j+4] == ':' && CurRequest[j+5] == '/') { j += 6; if (CurRequest[j] == '/') {                   ++j; unsigned uidx = 0; while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1) {                       m_URLHostPort[uidx] = CurRequest[j]; uidx++; ++j; }; } else --j; i = j; break; } } parseSucceeded = false; for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k) { if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   && CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   && CurRequest[k+4] == '/') { while (--k >= i && CurRequest[k] == ' ') {} unsigned k1 = k; while (k1 > i && CurRequest[k1] != '/') --k1; if (k - k1 + 1 > sizeof(m_URLSuffix)) return false; unsigned n = 0, k2 = k1+1; while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++]; m_URLSuffix[n] = '\0'; if (k1 - i > sizeof(m_URLPreSuffix)) return false; n = 0; k2 = i + 1; while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++]; m_URLPreSuffix[n] = '\0'; i = k + 7; parseSucceeded = true; break; } } if (!parseSucceeded) return false; parseSucceeded = false; for (j = i; (int)j < (int)(CurRequestSize-5); ++j) { if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' && CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' && CurRequest[j+4] == ':') { j += 5; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned n; for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j) { char c = CurRequest[j]; if (c == '\r' || c == '\n') { parseSucceeded = true; break; } m_CSeq[n] = c; } m_CSeq[n] = '\0'; break; } } if (!parseSucceeded) return false; for (j = i; (int)j < (int)(CurRequestSize-15); ++j) { if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  && CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  && CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  && CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  && (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') && CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' && CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' && CurRequest[j+13] == 'h' && CurRequest[j+14] == ':') { j += 15; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned num; if (sscanf(&CurRequest[j], ""%u"", &num) == 1) m_ContentLength = num; } } return true; }"
"static int nsim_bpf_map_alloc(struct netdevsim *ns, struct bpf_offloaded_map *offmap) { struct nsim_bpf_bound_map *nmap; int i, err; if (WARN_ON(offmap->map.map_type != BPF_MAP_TYPE_ARRAY && offmap->map.map_type != BPF_MAP_TYPE_HASH)) return -EINVAL; if (offmap->map.max_entries > NSIM_BPF_MAX_KEYS) return -ENOMEM; if (offmap->map.map_flags) return -EINVAL; nmap = kzalloc(sizeof(*nmap), GFP_USER); if (!nmap) return -ENOMEM; offmap->dev_priv = nmap; nmap->ns = ns; nmap->map = offmap; mutex_init(&nmap->mutex); if (offmap->map.map_type == BPF_MAP_TYPE_ARRAY) { for (i = 0; i < ARRAY_SIZE(nmap->entry); i++) { u32 *key; err = nsim_map_alloc_elem(offmap, i); if (err) goto err_free; key = nmap->entry[i].key; *key = i; } } offmap->dev_ops = &nsim_bpf_map_ops; list_add_tail(&nmap->l, &ns->nsim_dev->bpf_bound_maps); return 0; err_free: while (--i >= 0) { kfree(nmap->entry[i].key); kfree(nmap->entry[i].value); } kfree(nmap); return err; }"
"static int do_add_counters(struct net *net, sockptr_t arg, unsigned int len) { unsigned int i; struct xt_counters_info tmp; struct xt_counters *paddc; struct xt_table *t; const struct xt_table_info *private; int ret = 0; struct ip6t_entry *iter; unsigned int addend; paddc = xt_copy_counters(arg, len, &tmp); if (IS_ERR(paddc)) return PTR_ERR(paddc); t = xt_find_table_lock(net, AF_INET6, tmp.name); if (IS_ERR(t)) { ret = PTR_ERR(t); goto free; } local_bh_disable(); private = t->private; if (private->number != tmp.num_counters) { ret = -EINVAL; goto unlock_up_free; } i = 0; addend = xt_write_recseq_begin(); xt_entry_foreach(iter, private->entries, private->size) { struct xt_counters *tmp; tmp = xt_get_this_cpu_counter(&iter->counters); ADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt); ++i; } xt_write_recseq_end(addend); unlock_up_free: local_bh_enable(); xt_table_unlock(t); module_put(t->me); free: vfree(paddc); return ret; }"
"Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr, const XlaPlatformInfo& platform_info, XlaCompilationCache** cache) { if (platform_info.xla_device_metadata()) { *cache = new XlaCompilationCache( platform_info.xla_device_metadata()->client(), platform_info.xla_device_metadata()->jit_device_type()); return Status::OK(); } auto platform = se::MultiPlatformManager::PlatformWithId(platform_info.platform_id()); if (!platform.ok()) { return platform.status(); } StatusOr<xla::Compiler*> compiler_for_platform = xla::Compiler::GetForPlatform(platform.ValueOrDie()); if (!compiler_for_platform.ok()) { const Status& status = compiler_for_platform.status(); if (status.code() == error::NOT_FOUND) { return errors::Unimplemented(""Could not find compiler for platform "", platform.ValueOrDie()->Name(), "": "", status.ToString()); } } xla::LocalClientOptions client_options; client_options.set_platform(platform.ValueOrDie()); client_options.set_intra_op_parallelism_threads( device->tensorflow_cpu_worker_threads()->num_threads); string allowed_gpus = flr->config_proto()->gpu_options().visible_device_list(); TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids, ParseVisibleDeviceList(allowed_gpus)); client_options.set_allowed_devices(gpu_ids); auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options); if (!client.ok()) { return client.status(); } const XlaOpRegistry::DeviceRegistration* registration; if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(), &registration)) { return errors::InvalidArgument(""No JIT device registered for "", platform_info.device_type().type()); } *cache = new XlaCompilationCache( client.ValueOrDie(), DeviceType(registration->compilation_device_name)); return Status::OK(); }"
"static void rs_input(void) { LOG_INFO(""Received RS from ""); LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr); LOG_INFO_("" to ""); LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr); LOG_INFO_(""\n""); UIP_STAT(++uip_stat.nd6.recv); #if UIP_CONF_IPV6_CHECKS if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) { LOG_ERR(""RS received is bad\n""); goto discard; } #endif  nd6_opt_offset = UIP_ND6_RS_LEN; nd6_opt_llao = NULL; while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) { #if UIP_CONF_IPV6_CHECKS if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) { LOG_ERR(""RS received is bad\n""); goto discard; } #endif  switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) { case UIP_ND6_OPT_SLLAO: nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset); break; default: LOG_WARN(""ND option not supported in RS\n""); break; } nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3); } if(nd6_opt_llao != NULL) { #if UIP_CONF_IPV6_CHECKS if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) { LOG_ERR(""RS received is bad\n""); goto discard; } else { #endif  uip_lladdr_t lladdr_aligned; extract_lladdr_from_llao_aligned(&lladdr_aligned); if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) { uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned, 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL); } else { const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr); if(lladdr == NULL) { goto discard; } if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET], lladdr, UIP_LLADDR_LEN) != 0) { uip_ds6_nbr_t nbr_data; nbr_data = *nbr; uip_ds6_nbr_rm(nbr); nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned, 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL); nbr->reachable = nbr_data.reachable; nbr->sendns = nbr_data.sendns; nbr->nscount = nbr_data.nscount; } nbr->isrouter = 0; } #if UIP_CONF_IPV6_CHECKS } #endif  } uip_ds6_send_ra_sollicited(); discard: uipbuf_clear(); return; }"
"static void nfs_name_snoop_fh(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int fh_offset, int fh_length, gboolean hidden) { nfs_name_snoop_key_t  key; nfs_name_snoop_t     *nns = NULL; if (!pinfo->fd->flags.visited) { key.key = 0; key.fh_length = fh_length; key.fh = (const unsigned char *)tvb_get_ptr(tvb, fh_offset, fh_length); nns = (nfs_name_snoop_t *)g_hash_table_lookup(nfs_name_snoop_matched, &key); if (nns) { guint32 fhlen; guint32 *fhdata; wmem_tree_key_t fhkey[3]; fhlen = nns->fh_length; fhdata = (guint32 *)g_memdup(nns->fh, fhlen); fhkey[0].length = 1; fhkey[0].key= &fhlen; fhkey[1].length = fhlen/4; fhkey[1].key= fhdata; fhkey[2].length = 0; wmem_tree_insert32_array(nfs_name_snoop_known, &fhkey[0], nns); g_free(fhdata); if (nfs_file_name_full_snooping) { char *name = NULL, *pos = NULL; int len = 0; nfs_full_name_snoop(nns, &len, &name, &pos); if (name) { nns->full_name = name; nns->full_name_len = len; } } } } if (!nns) { guint32 fhlen; guint32 *fhdata; wmem_tree_key_t fhkey[3]; fhlen = fh_length; fhdata = (guint32 *)tvb_memdup(wmem_packet_scope(), tvb, fh_offset, fh_length); fhkey[0].length = 1; fhkey[0].key= &fhlen; fhkey[1].length = fhlen/4; fhkey[1].key= fhdata; fhkey[2].length = 0; nns = (nfs_name_snoop_t *)wmem_tree_lookup32_array(nfs_name_snoop_known, &fhkey[0]); } if (nns) { proto_item *fh_item = NULL; if (hidden) { fh_item = proto_tree_add_string(tree, hf_nfs_name, NULL, 0, 0, nns->name); PROTO_ITEM_SET_HIDDEN(fh_item); } else { fh_item = proto_tree_add_string(tree, hf_nfs_name, tvb, fh_offset, 0, nns->name); } PROTO_ITEM_SET_GENERATED(fh_item); if (nns->full_name) { if (hidden) { fh_item = proto_tree_add_string(tree, hf_nfs_full_name, NULL, 0, 0, nns->full_name); PROTO_ITEM_SET_HIDDEN(fh_item); } else { fh_item = proto_tree_add_string_format_value(tree, hf_nfs_full_name, tvb, fh_offset, 0, nns->full_name, ""%s"", nns->full_name); } PROTO_ITEM_SET_GENERATED(fh_item); } } }"
"static Uint8 * Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical) { Uint8 *map; int i; if (identical) { if (src->ncolors <= dst->ncolors) { if (src == dst || (SDL_memcmp (src->colors, dst->colors, src->ncolors * sizeof(SDL_Color)) == 0)) { *identical = 1; return (NULL); } } *identical = 0; } map = (Uint8 *) SDL_malloc(src->ncolors); if (map == NULL) { SDL_OutOfMemory(); return (NULL); } for (i = 0; i < src->ncolors; ++i) { map[i] = SDL_FindColor(dst, src->colors[i].r, src->colors[i].g, src->colors[i].b, src->colors[i].a); } return (map); }"
"int eval0_retarg( char_u*arg, typval_T*rettv, exarg_T*eap, evalarg_T*evalarg, char_u**retarg) { intret; char_u*p; char_u*expr_end; intdid_emsg_before = did_emsg; intcalled_emsg_before = called_emsg; intflags = evalarg == NULL ? 0 : evalarg->eval_flags; intcheck_for_end = retarg == NULL; intend_error = FALSE; p = skipwhite(arg); ret = eval1(&p, rettv, evalarg); expr_end = p; p = skipwhite(p); if (in_vim9script() && p > expr_end && retarg == NULL) while (*p == '#') { char_u *nl = vim_strchr(p, NL); if (nl == NULL) break; p = skipwhite(nl + 1); if (eap != NULL && *p != NUL) eap->nextcmd = p; check_for_end = FALSE; } if (ret != FAIL && check_for_end) end_error = !ends_excmd2(arg, p); if (ret == FAIL || end_error) { if (ret != FAIL) clear_tv(rettv); if (!aborting() && did_emsg == did_emsg_before && called_emsg == called_emsg_before && (flags & EVAL_CONSTANT) == 0 && (!in_vim9script() || !vim9_bad_comment(p))) { if (end_error) semsg(_(e_trailing_characters_str), p); else semsg(_(e_invalid_expression_str), arg); } if (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|') eap->nextcmd = check_nextcmd(p); return FAIL; } if (retarg != NULL) *retarg = p; else if (check_for_end && eap != NULL) set_nextcmd(eap, p); return ret; }"
"int CLua::loadfile(lua_State *ls, const char *filename, bool trusted, bool die_on_fail) { if (!ls) return -1; if (!is_path_safe(filename, trusted)) { lua_pushstring( ls, make_stringf(""invalid filename: %s"", filename).c_str()); return -1; } string file = datafile_path(filename, die_on_fail); if (file.empty()) { lua_pushstring(ls, make_stringf(""Can't find \""%s\"""", filename).c_str()); return -1; } FileLineInput f(file.c_str()); string script; while (!f.eof()) script += f.get_line() + ""\n""; return luaL_loadbuffer(ls, &script[0], script.length(), (""@"" + file).c_str()); }"
"static int loadImage(TIFF *in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr) { uint32_t i; float xres = 0.0, yres = 0.0; uint32_t nstrips = 0, ntiles = 0; uint16_t planar = 0; uint16_t bps = 0, spp = 0, res_unit = 0; uint16_t orientation = 0; uint16_t input_compression = 0, input_photometric = 0; uint16_t subsampling_horiz, subsampling_vert; uint32_t width = 0, length = 0; tmsize_t stsize = 0, tlsize = 0, buffsize = 0; tmsize_t scanlinesize = 0; uint32_t tw = 0, tl = 0;  tmsize_t tile_rowsize = 0; unsigned char *read_buff = NULL; unsigned char *new_buff = NULL; int readunit = 0; static tmsize_t prev_readsize = 0; TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp); TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar); TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); if (!TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) TIFFError(""loadImage"", ""Image lacks Photometric interpretation tag""); if (!TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)) TIFFError(""loadimage"", ""Image lacks image width tag""); if (!TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length)) TIFFError(""loadimage"", ""Image lacks image length tag""); TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres); TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres); if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit)) res_unit = RESUNIT_INCH; if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)) input_compression = COMPRESSION_NONE; #ifdef DEBUG2 char compressionid[16]; switch (input_compression) { case COMPRESSION_NONE:  strcpy(compressionid, ""None/dump""); break; case COMPRESSION_CCITTRLE:  strcpy(compressionid, ""Huffman RLE""); break; case COMPRESSION_CCITTFAX3:  strcpy(compressionid, ""Group3 Fax""); break; case COMPRESSION_CCITTFAX4:  strcpy(compressionid, ""Group4 Fax""); break; case COMPRESSION_LZW:  strcpy(compressionid, ""LZW""); break; case COMPRESSION_OJPEG:  strcpy(compressionid, ""Old Jpeg""); break; case COMPRESSION_JPEG:  strcpy(compressionid, ""New Jpeg""); break; case COMPRESSION_NEXT:  strcpy(compressionid, ""Next RLE""); break; case COMPRESSION_CCITTRLEW:  strcpy(compressionid, ""CITTRLEW""); break; case COMPRESSION_PACKBITS:  strcpy(compressionid, ""Mac Packbits""); break; case COMPRESSION_THUNDERSCAN:  strcpy(compressionid, ""Thunderscan""); break; case COMPRESSION_IT8CTPAD:  strcpy(compressionid, ""IT8 padded""); break; case COMPRESSION_IT8LW:  strcpy(compressionid, ""IT8 RLE""); break; case COMPRESSION_IT8MP:  strcpy(compressionid, ""IT8 mono""); break; case COMPRESSION_IT8BL:  strcpy(compressionid, ""IT8 lineart""); break; case COMPRESSION_PIXARFILM:  strcpy(compressionid, ""Pixar 10 bit""); break; case COMPRESSION_PIXARLOG:  strcpy(compressionid, ""Pixar 11bit""); break; case COMPRESSION_DEFLATE:  strcpy(compressionid, ""Deflate""); break; case COMPRESSION_ADOBE_DEFLATE:  strcpy(compressionid, ""Adobe deflate""); break; default: strcpy(compressionid, ""None/unknown""); break; } TIFFError(""loadImage"", ""Input compression %s"", compressionid); #endif scanlinesize = TIFFScanlineSize(in); image->bps = bps; image->spp = spp; image->planar = planar; image->width = width; image->length = length; image->xres = xres; image->yres = yres; image->res_unit = res_unit; image->compression = input_compression; image->photometric = input_photometric; #ifdef DEBUG2 char photometricid[12]; switch (input_photometric) { case PHOTOMETRIC_MINISWHITE: strcpy(photometricid, ""MinIsWhite""); break; case PHOTOMETRIC_MINISBLACK: strcpy(photometricid, ""MinIsBlack""); break; case PHOTOMETRIC_RGB: strcpy(photometricid, ""RGB""); break; case PHOTOMETRIC_PALETTE: strcpy(photometricid, ""Palette""); break; case PHOTOMETRIC_MASK: strcpy(photometricid, ""Mask""); break; case PHOTOMETRIC_SEPARATED: strcpy(photometricid, ""Separated""); break; case PHOTOMETRIC_YCBCR: strcpy(photometricid, ""YCBCR""); break; case PHOTOMETRIC_CIELAB: strcpy(photometricid, ""CIELab""); break; case PHOTOMETRIC_ICCLAB: strcpy(photometricid, ""ICCLab""); break; case PHOTOMETRIC_ITULAB: strcpy(photometricid, ""ITULab""); break; case PHOTOMETRIC_LOGL: strcpy(photometricid, ""LogL""); break; case PHOTOMETRIC_LOGLUV: strcpy(photometricid, ""LOGLuv""); break; default: strcpy(photometricid, ""Unknown""); break; } TIFFError(""loadImage"", ""Input photometric interpretation %s"", photometricid); #endif image->orientation = orientation; switch (orientation) { case 0: case ORIENTATION_TOPLEFT: image->adjustments = 0; break; case ORIENTATION_TOPRIGHT: image->adjustments = MIRROR_HORIZ; break; case ORIENTATION_BOTRIGHT: image->adjustments = ROTATECW_180; break; case ORIENTATION_BOTLEFT: image->adjustments = MIRROR_VERT; break; case ORIENTATION_LEFTTOP: image->adjustments = MIRROR_VERT | ROTATECW_90; break; case ORIENTATION_RIGHTTOP: image->adjustments = ROTATECW_90; break; case ORIENTATION_RIGHTBOT: image->adjustments = MIRROR_VERT | ROTATECW_270; break; case ORIENTATION_LEFTBOT: image->adjustments = ROTATECW_270; break; default: image->adjustments = 0; image->orientation = ORIENTATION_TOPLEFT; } if ((bps == 0) || (spp == 0)) { TIFFError(""loadImage"", ""Invalid samples per pixel (%"" PRIu16 "") or bits per sample (%"" PRIu16 "")"", spp, bps); return (-1); } if (TIFFIsTiled(in)) { readunit = TILE; tlsize = TIFFTileSize(in); ntiles = TIFFNumberOfTiles(in); TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(in, TIFFTAG_TILELENGTH, &tl); tile_rowsize = TIFFTileRowSize(in); if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0) { TIFFError(""loadImage"", ""File appears to be tiled, but the number of tiles, tile "" ""size, or tile rowsize is zero.""); exit(EXIT_FAILURE); } if (ntiles != 0 && tlsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / ntiles)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } buffsize = tlsize * ntiles; if (tl != 0 && ntiles != 0 && tile_rowsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / tl / ntiles)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } if (buffsize < (tmsize_t)(ntiles * tl * tile_rowsize)) { buffsize = ntiles * tl * tile_rowsize; #ifdef DEBUG2 TIFFError(""loadImage"", ""Tilesize %"" PRIu32 "" is too small, using ntiles * "" ""tilelength * tilerowsize %"" PRIu32, tlsize, buffsize); #endif } if (dump->infile != NULL) dump_info(dump->infile, dump->format, """", ""Tilesize: %"" TIFF_SSIZE_FORMAT "", Number of Tiles: %"" PRIu32 "", Tile row size: %"" TIFF_SSIZE_FORMAT, tlsize, ntiles, tile_rowsize); } else { tmsize_t buffsize_check; readunit = STRIP; TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); stsize = TIFFStripSize(in); nstrips = TIFFNumberOfStrips(in); if (nstrips == 0 || stsize == 0) { TIFFError(""loadImage"", ""File appears to be striped, but the number "" ""of stipes or stripe size is zero.""); exit(EXIT_FAILURE); } if (nstrips != 0 && stsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / nstrips)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } buffsize = stsize * nstrips; if ((spp != 0 && bps != 0 && width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) || (width != 0 && spp != 0 && bps != 0 && length > (tmsize_t)(TIFF_TMSIZE_T_MAX / (uint32_t)(((width * spp * bps) + 7) / 8)))) { TIFFError(""loadImage"", ""Integer overflow detected.""); exit(EXIT_FAILURE); } buffsize_check = (tmsize_t)length * (uint32_t)(((width * spp * bps) + 7) / 8); if (buffsize < buffsize_check) { buffsize = buffsize_check; #ifdef DEBUG2 TIFFError(""loadImage"", ""Stripsize %"" PRIu32 "" is too small, using imagelength * "" ""width * spp * bps / 8 = %"" PRIu32, stsize, (unsigned long)buffsize); #endif } if (dump->infile != NULL) dump_info(dump->infile, dump->format, """", ""Stripsize: %"" TIFF_SSIZE_FORMAT "", Number of Strips: %"" PRIu32 "", Rows per Strip: %"" PRIu32 "", Scanline size: %"" TIFF_SSIZE_FORMAT, stsize, nstrips, rowsperstrip, scanlinesize); } if (input_compression == COMPRESSION_JPEG) {  jpegcolormode = JPEGCOLORMODE_RGB; TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else {  if (input_photometric == PHOTOMETRIC_YCBCR) { TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsampling_horiz, &subsampling_vert); if (subsampling_horiz != 1 || subsampling_vert != 1) { TIFFError(""loadImage"", ""Can't copy/convert subsampled image with "" ""subsampling %"" PRIu16 "" horiz %"" PRIu16 "" vert"", subsampling_horiz, subsampling_vert); return (-1); } } } read_buff = *read_ptr; if (!read_buff) { if (buffsize > 0xFFFFFFFFU - 3) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } read_buff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES); } else { if (prev_readsize < buffsize) { if (buffsize > 0xFFFFFFFFU - 3) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } new_buff = _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES); if (!new_buff) { free(read_buff); read_buff = (unsigned char *)limitMalloc( buffsize + NUM_BUFF_OVERSIZE_BYTES); } else read_buff = new_buff; } } if (!read_buff) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } read_buff[buffsize] = 0; read_buff[buffsize + 1] = 0; read_buff[buffsize + 2] = 0; prev_readsize = buffsize; *read_ptr = read_buff; switch (readunit) { case STRIP: if (planar == PLANARCONFIG_CONTIG) { if (!(readContigStripsIntoBuffer(in, read_buff))) { TIFFError(""loadImage"", ""Unable to read contiguous strips into buffer""); return (-1); } } else { if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump))) { TIFFError(""loadImage"", ""Unable to read separate strips into buffer""); return (-1); } } break; case TILE: if (planar == PLANARCONFIG_CONTIG) { if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))) { TIFFError(""loadImage"", ""Unable to read contiguous tiles into buffer""); return (-1); } } else { if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))) { TIFFError(""loadImage"", ""Unable to read separate tiles into buffer""); return (-1); } } break; default: TIFFError(""loadImage"", ""Unsupported image file format""); return (-1); break; } if ((dump->infile != NULL) && (dump->level == 2)) { dump_info(dump->infile, dump->format, ""loadImage"", ""Image width %"" PRIu32 "", length %"" PRIu32 "", Raw image data, %4"" TIFF_SSIZE_FORMAT "" bytes"", width, length, buffsize); dump_info(dump->infile, dump->format, """", ""Bits per sample %"" PRIu16 "", Samples per pixel %"" PRIu16, bps, spp); if ((uint64_t)scanlinesize > 0x0ffffffffULL) { dump_info( dump->infile, dump->format, ""loadImage"", ""Attention: scanlinesize %"" PRIu64 "" is larger than UINT32_MAX.\nFollowing dump might be wrong."", (uint64_t)scanlinesize); } for (i = 0; i < length; i++) dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize, i, read_buff + (i * scanlinesize)); } return (0); }"
"static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev, struct virtio_gpu_object *bo, struct virtio_gpu_mem_entry **ents, unsigned int *nents) { bool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev); struct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo); struct scatterlist *sg; int si, ret; ret = drm_gem_shmem_pin(&bo->base); if (ret < 0) return -EINVAL; shmem->pages = drm_gem_shmem_get_sg_table(&bo->base); if (!shmem->pages) { drm_gem_shmem_unpin(&bo->base); return -EINVAL; } if (use_dma_api) { ret = dma_map_sgtable(vgdev->vdev->dev.parent, shmem->pages, DMA_TO_DEVICE, 0); if (ret) return ret; *nents = shmem->mapped = shmem->pages->nents; } else { *nents = shmem->pages->orig_nents; } *ents = kvmalloc_array(*nents, sizeof(struct virtio_gpu_mem_entry), GFP_KERNEL); if (!(*ents)) { DRM_ERROR(""failed to allocate ent list\n""); return -ENOMEM; } if (use_dma_api) { for_each_sgtable_dma_sg(shmem->pages, sg, si) { (*ents)[si].addr = cpu_to_le64(sg_dma_address(sg)); (*ents)[si].length = cpu_to_le32(sg_dma_len(sg)); (*ents)[si].padding = 0; } } else { for_each_sgtable_sg(shmem->pages, sg, si) { (*ents)[si].addr = cpu_to_le64(sg_phys(sg)); (*ents)[si].length = cpu_to_le32(sg->length); (*ents)[si].padding = 0; } } return 0; }"
"GF_EXPORT GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs) { u32 i, count; GF_VVCConfig *cfg = gf_odf_vvc_cfg_new(); gf_bs_read_int(bs, 5); cfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2); cfg->ptl_present = gf_bs_read_int(bs, 1); if (cfg->ptl_present) { s32 j; cfg->ols_idx = gf_bs_read_int(bs, 9); cfg->numTemporalLayers = gf_bs_read_int(bs, 3); cfg->constantFrameRate = gf_bs_read_int(bs, 2); cfg->chroma_format = gf_bs_read_int(bs, 2); cfg->bit_depth = 8 + gf_bs_read_int(bs, 3); gf_bs_read_int(bs, 5); gf_bs_read_int(bs, 2); cfg->num_constraint_info = gf_bs_read_int(bs, 6); cfg->general_profile_idc = gf_bs_read_int(bs, 7); cfg->general_tier_flag = gf_bs_read_int(bs, 1); cfg->general_level_idc = gf_bs_read_u8(bs); cfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1); cfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1); if (cfg->num_constraint_info) { cfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info); if (!cfg->general_constraint_info) { gf_free(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } gf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1); cfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6); } else { gf_bs_read_int(bs, 6); } cfg->ptl_sublayer_present_mask = 0; for (j=cfg->numTemporalLayers-2; j>=0; j--) { u32 val = gf_bs_read_int(bs, 1); cfg->ptl_sublayer_present_mask |= val << j; } for (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) { gf_bs_read_int(bs, 1); } for (j=cfg->numTemporalLayers-2; j>=0; j--) { if (cfg->ptl_sublayer_present_mask & (1<<j)) { cfg->sublayer_level_idc[j] = gf_bs_read_u8(bs); } } cfg->num_sub_profiles = gf_bs_read_u8(bs); if (cfg->num_sub_profiles) { cfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles); if (!cfg->sub_profiles_idc) { gf_free(cfg->general_constraint_info); gf_free(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } } for (i=0; i<cfg->num_sub_profiles; i++) { cfg->sub_profiles_idc[i] = gf_bs_read_u32(bs); } cfg->maxPictureWidth = gf_bs_read_u16(bs); cfg->maxPictureHeight = gf_bs_read_u16(bs); cfg->avgFrameRate = gf_bs_read_u16(bs); } count = gf_bs_read_int(bs, 8); for (i=0; i<count; i++) { u32 nalucount, j; Bool valid = GF_FALSE; GF_NALUFFParamArray *ar; GF_SAFEALLOC(ar, GF_NALUFFParamArray); if (!ar) { gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } ar->array_completeness = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 2); ar->type = gf_bs_read_int(bs, 5); switch (ar->type) { case GF_VVC_NALU_DEC_PARAM: case GF_VVC_NALU_OPI: case GF_VVC_NALU_VID_PARAM: case GF_VVC_NALU_SEQ_PARAM: case GF_VVC_NALU_PIC_PARAM: case GF_VVC_NALU_SEI_PREFIX: case GF_VVC_NALU_SEI_SUFFIX: valid = GF_TRUE; ar->nalus = gf_list_new(); gf_list_add(cfg->param_array, ar); break; default: GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type in vvcC - ignoring\n"", ar->nalus)); gf_free(ar); break; } if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI)) nalucount = gf_bs_read_int(bs, 16); else nalucount = 1; for (j=0; j<nalucount; j++) { GF_NALUFFParam *sl; u32 size = gf_bs_read_int(bs, 16); if ((size>gf_bs_available(bs)) || (size<2)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] Wrong param set size %d\n"", size)); gf_odf_vvc_cfg_del(cfg); return NULL; } if (!valid) { gf_bs_skip_bytes(bs, size); continue; } GF_SAFEALLOC(sl, GF_NALUFFParam ); if (!sl) { gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } sl->size = size; sl->data = (char *)gf_malloc(sizeof(char) * sl->size); if (!sl->data) { gf_free(sl); gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } gf_bs_read_data(bs, sl->data, sl->size); gf_list_add(ar->nalus, sl); } } return cfg; }"
"void luaD_callnoyield (lua_State *L, StkId func, int nResults) { incXCcalls(L); if (getCcalls(L) <= CSTACKERR)   luaE_freeCI(L); luaD_call(L, func, nResults); decXCcalls(L); }"
"static void parse_paragraph(tree_t *t, float  left, float  right, float  bottom, float  top, float  *x, float  *y, int    *page, int    needspace) { intwhitespace; tree_t*flat, *start, *end, *prev, *temp; floatwidth, height, offset, spacing, borderspace, temp_y, temp_width, temp_height; floatformat_width, image_y, image_left, image_right; intimage_page = *page; floatchar_spacing; intnum_chars; render_t*r; uchar*align, *hspace, *vspace, *link, *border; floatrgb[3]; ucharline[10240], *lineptr, *dataptr; tree_t*linetype; floatlinex, linewidth; intfirstline; DEBUG_printf((""parse_paragraph(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\n"", (void *)t, left, right, bottom, top, *x, *y, *page, needspace)); flat        = flatten_tree(t->child); image_left  = left; image_right = right; image_y     = 0; if (flat == NULL) DEBUG_puts(""parse_paragraph: flat == NULL!""); if (*y < top && needspace) *y -= _htmlSpacings[SIZE_P]; for (temp = flat, prev = NULL; temp != NULL;) { if (temp->markup == MARKUP_IMG) update_image_size(temp); if (temp->markup == MARKUP_IMG && (align = htmlGetVariable(temp, (uchar *)""ALIGN""))) { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; if (strcasecmp((char *)align, ""LEFT"") == 0) { if ((vspace = htmlGetVariable(temp, (uchar *)""VSPACE"")) != NULL) *y -= atoi((char *)vspace); if (*y < (bottom + temp->height + 2 * borderspace)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } if (borderspace > 0.0f) { if (temp->link && PSLevel == 0) memcpy(rgb, link_color, sizeof(rgb)); else { rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } new_render(*page, RENDER_BOX, image_left, *y - borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, image_left, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_left + temp->width + borderspace, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_left, *y - temp->height - 2 * borderspace, temp->width + 2 * borderspace, borderspace, rgb); } *y -= borderspace; new_render(*page, RENDER_IMAGE, image_left + borderspace, *y - temp->height, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); if (temp->link && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, image_left + borderspace, *y - temp->height, temp->width, temp->height, link); } *y -= borderspace; if (vspace != NULL) *y -= atoi((char *)vspace); image_left += temp->width + 2 * borderspace; temp_y     = *y - temp->height; image_page = *page; if (temp_y < image_y || image_y == 0) image_y = temp_y; if ((hspace = htmlGetVariable(temp, (uchar *)""HSPACE"")) != NULL) image_left += atoi((char *)hspace); if (prev != NULL) prev->next = temp->next; else flat = temp->next; free(temp); temp = prev; } else if (strcasecmp((char *)align, ""RIGHT"") == 0) { if ((vspace = htmlGetVariable(temp, (uchar *)""VSPACE"")) != NULL) *y -= atoi((char *)vspace); if (*y < (bottom + temp->height + 2 * borderspace)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } image_right -= temp->width + 2 * borderspace; image_page = *page; if (borderspace > 0.0f) { if (temp->link && PSLevel == 0) memcpy(rgb, link_color, sizeof(rgb)); else { rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } new_render(*page, RENDER_BOX, image_right, *y - borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_right + temp->width + borderspace, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace, temp->width + 2 * borderspace, borderspace, rgb); } *y -= borderspace; new_render(*page, RENDER_IMAGE, image_right + borderspace, *y - temp->height, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); if (temp->link && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, image_right + borderspace, *y - temp->height, temp->width, temp->height, link); } *y -= borderspace; if (vspace != NULL) *y -= atoi((char *)vspace); temp_y = *y - temp->height; if (temp_y < image_y || image_y == 0) image_y = temp_y; if ((hspace = htmlGetVariable(temp, (uchar *)""HSPACE"")) != NULL) image_right -= atoi((char *)hspace); if (prev != NULL) prev->next = temp->next; else flat = temp->next; free(temp); temp = prev; } } if (temp != NULL) { prev = temp; temp = temp->next; } else temp = flat; } format_width = image_right - image_left; firstline    = 1; DEBUG_printf((""format_width = %.1f\n"", format_width)); offset      = 0.0f; temp_width  = 0.0f; temp_height = 0.0f; lineptr     = NULL; linex       = 0.0f; linewidth   = 0.0f; while (flat != NULL) { start = flat; end   = flat; width = 0.0; while (flat != NULL) { temp_width = 0.0; temp       = flat; whitespace = 0; while (temp != NULL && !whitespace) { if (temp->markup == MARKUP_NONE && temp->data[0] == ' ') { if (temp == start) temp_width -= _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f; else if (temp_width > 0.0f) whitespace = 1; } else whitespace = 0; if (whitespace) break; if (temp->markup == MARKUP_IMG) { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_width += 2 * borderspace; } prev       = temp; temp       = temp->next; temp_width += prev->width; if ((temp_width >= format_width && prev->markup == MARKUP_IMG) || prev->markup == MARKUP_BR) { break; } else if (prev->markup == MARKUP_NONE) { intch = prev->data[strlen((char *)prev->data) - 1]; if (_htmlUTF8) ch = _htmlUnicode[ch]; if (ch == 173) break; } } if ((width + temp_width) <= format_width) { width += temp_width; end  = temp; flat = temp; if (prev->markup == MARKUP_BR) break; } else if (width == 0.0) { width += temp_width; end  = temp; flat = temp; break; } else break; } if (start == end) { end   = start->next; flat  = start->next; width = start->width; } for (height = 0.0, num_chars = 0, temp = prev = start; temp != end; temp = temp->next) { prev = temp; if (temp->markup == MARKUP_NONE) num_chars += strlen((char *)temp->data); if (temp->height > height) height = temp->height; } for (spacing = 0.0, temp = prev = start; temp != end; temp = temp->next) { prev = temp; if (temp->markup != MARKUP_IMG) temp_height = (float)(temp->height * _htmlSpacings[0] / _htmlSizes[0]); else { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_height = temp->height + 2 * borderspace; } if (temp_height > spacing) spacing = temp_height; } if (firstline && end != NULL && *y < (bottom + height + _htmlSpacings[t->size])) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } firstline = 0; if (height == 0.0f) height = spacing; for (temp = start; temp != end; temp = temp->next) if (temp->markup != MARKUP_A) break; if (temp != NULL && temp->markup == MARKUP_NONE && temp->data[0] == ' ') { for (dataptr = temp->data; *dataptr; dataptr ++) *dataptr = dataptr[1]; *dataptr = '\0'; temp_width = _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f; temp->width -= temp_width; num_chars --; } if (end != NULL) temp = end->prev; else temp = NULL; DEBUG_printf((""    BEFORE page=%d, y=%.1f, height=%.1f, spacing=%.1f, bottom=%.1f\n"", *page, *y, height, spacing, bottom)); if (*y < (spacing + bottom)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } *y -= height; DEBUG_printf((""    page=%d, y=%.1f, width=%.1f, height=%.1f\n"", *page, *y, width, height)); if (Verbosity) progress_update(100 - (int)(100 * (*y) / PagePrintLength)); char_spacing = 0.0f; whitespace   = 0; temp         = start; linetype     = NULL; rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; switch (t->halignment) { case ALIGN_LEFT : linex = image_left; break; case ALIGN_CENTER : linex = image_left + 0.5f * (format_width - width); break; case ALIGN_RIGHT : linex = image_right - width; break; case ALIGN_JUSTIFY : linex = image_left; if (flat != NULL && flat->prev->markup != MARKUP_BR && num_chars > 1) char_spacing = (format_width - width) / (num_chars - 1); break; } while (temp != end) { if (temp->link != NULL && PSLevel == 0 && Links && temp->markup == MARKUP_NONE) { temp->red   = (uchar)(link_color[0] * 255.0); temp->green = (uchar)(link_color[1] * 255.0); temp->blue  = (uchar)(link_color[2] * 255.0); } if (linetype != NULL && (temp->markup != MARKUP_NONE || temp->typeface != linetype->typeface || temp->style != linetype->style || temp->size != linetype->size || temp->superscript != linetype->superscript || temp->subscript != linetype->subscript || temp->red != linetype->red || temp->green != linetype->green || temp->blue != linetype->blue)) { r = new_render(*page, RENDER_TEXT, linex - linewidth, *y, linewidth, linetype->height, line); r->data.text.typeface = linetype->typeface; r->data.text.style    = linetype->style; r->data.text.size     = (float)_htmlSizes[linetype->size]; r->data.text.spacing  = char_spacing; memcpy(r->data.text.rgb, rgb, sizeof(rgb)); if (linetype->superscript) r->y += height - linetype->height; else if (linetype->subscript) r->y -= height - linetype->height; free(linetype); linetype = NULL; } if ((link = htmlGetVariable(temp, (uchar *)""ID"")) != NULL) { add_link(link, *page, (int)(*y + height)); } switch (temp->markup) { case MARKUP_A : if ((link = htmlGetVariable(temp, (uchar *)""NAME"")) != NULL) { add_link(link, *page, (int)(*y + height)); } default : temp_width = temp->width; break; case MARKUP_NONE : if (temp->data == NULL) break; if (((temp->width - right + left) > 0.001 || (temp->height - top + bottom) > 0.001)  && OverflowErrors) progress_error(HD_ERROR_CONTENT_TOO_LARGE, ""Text on page %d too large - "" ""truncation or overlapping may occur!"", *page + 1); if (linetype == NULL) { linetype  = temp; lineptr   = line; linewidth = 0.0; rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } strlcpy((char *)lineptr, (char *)temp->data, sizeof(line) - (size_t)(lineptr - line)); temp_width = temp->width + char_spacing * strlen((char *)lineptr); if (temp->underline || (temp->link && LinkStyle && PSLevel == 0)) new_render(*page, RENDER_BOX, linex, *y - 1, temp_width, 0, rgb); if (temp->strikethrough) new_render(*page, RENDER_BOX, linex, *y + temp->height * 0.25f, temp_width, 0, rgb); linewidth  += temp_width; lineptr    += strlen((char *)lineptr); if (lineptr > line && lineptr[-1] == ' ') whitespace = 1; else whitespace = 0; break; case MARKUP_IMG : if (((temp->width - right + left) > 0.001 || (temp->height - top + bottom) > 0.001) && OverflowErrors) { DEBUG_printf((""IMAGE: %.3fx%.3f > %.3fx%.3f\n"", temp->width, temp->height, right - left, top - bottom)); progress_error(HD_ERROR_CONTENT_TOO_LARGE, ""Image on page %d too large - "" ""truncation or overlapping may occur!"", *page + 1); } if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_width += 2 * borderspace; switch (temp->valignment) { case ALIGN_TOP : offset = height - temp->height - 2 * borderspace; break; case ALIGN_MIDDLE : offset = 0.5f * (height - temp->height) - borderspace; break; case ALIGN_BOTTOM : offset = 0.0f; } if (borderspace > 0.0f) { new_render(*page, RENDER_BOX, linex, *y + offset + temp->height + borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, linex, *y + offset, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, linex + temp->width + borderspace, *y + offset, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, linex, *y + offset, temp->width + 2 * borderspace, borderspace, rgb); } new_render(*page, RENDER_IMAGE, linex + borderspace, *y + offset + borderspace, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); whitespace = 0; temp_width = temp->width + 2 * borderspace; break; } if (temp->link != NULL && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, linex, *y + offset, temp->width, temp->height, link); } linex += temp_width; prev = temp; temp = temp->next; if (prev != linetype) free(prev); } if (linetype != NULL) { r = new_render(*page, RENDER_TEXT, linex - linewidth, *y, linewidth, linetype->height, line); r->data.text.typeface = linetype->typeface; r->data.text.style    = linetype->style; r->data.text.spacing  = char_spacing; r->data.text.size     = (float)_htmlSizes[linetype->size]; memcpy(r->data.text.rgb, rgb, sizeof(rgb)); if (linetype->superscript) r->y += height - linetype->height; else if (linetype->subscript) r->y -= height - linetype->height; free(linetype); } *y -= spacing - height; DEBUG_printf((""    AFTER y=%.1f, bottom=%.1f\n"", *y, bottom)); if (*y < bottom) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } if (*y < image_y || *page > image_page) { image_y      = 0.0f; image_left   = left; image_right  = right; format_width = image_right - image_left; } } *x = left; if (*y > image_y && image_y > 0.0f && image_page == *page) *y = image_y; DEBUG_printf((""LEAVING parse_paragraph(), x = %.1f, y = %.1f, page = %d, image_y = %.1f\n"", *x, *y, *page, image_y)); }"
"static int handle_rst_stream_frame(h2o_http2_conn_t *conn, h2o_http2_frame_t *frame, const char **err_desc) { h2o_http2_rst_stream_payload_t payload; h2o_http2_stream_t *stream; int ret; if ((ret = h2o_http2_decode_rst_stream_payload(&payload, frame, err_desc)) != 0) return ret; if (is_idle_stream_id(conn, frame->stream_id)) { *err_desc = ""unexpected stream id in RST_STREAM frame""; return H2O_HTTP2_ERROR_PROTOCOL; } stream = h2o_http2_conn_get_stream(conn, frame->stream_id); if (stream != NULL) { h2o_http2_stream_reset(conn, stream); } return 0; }"
"ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( asylo::system_call::kSYS_read, fd, buf, count)); }"
inline long ValueType<URational>::toLong(long n) const { ok_ = (value_.at(n).second != 0 && value_.at(n).first < LARGE_INT); if (!ok_) return 0; return value_.at(n).first / value_.at(n).second; }
"static void free_charger_irq(struct wm8350 *wm8350) { wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_HOT, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_COLD, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_FAIL, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_TO, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_END, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_START, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_3P9, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_3P1, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_2P85, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_USB_FB, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_WALL_FB, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_BAT_FB, wm8350); }"
"inline void Request::set_header(const char *key, const char *val) { headers.emplace(key, val); }"
"static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses, volatile parse_context *ctx) { pj_str_t str; ctx->last_error = PJMEDIA_SDP_EINORIGIN; if (*(scanner->curptr+1) != '=') { on_scanner_error(scanner); return; } pj_scan_advance_n(scanner, 2, SKIP_WS); pj_scan_get_until_ch(scanner, ' ', &ses->origin.user); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &str); ses->origin.id = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &str); ses->origin.version = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type); pj_scan_get_char(scanner); pj_scan_get_until_chr(scanner, "" \t\r\n"", &ses->origin.addr); pj_scan_skip_line(scanner); }"
"static int dwc3_qcom_acpi_register_core(struct platform_device *pdev) { struct dwc3_qcom*qcom = platform_get_drvdata(pdev); struct device*dev = &pdev->dev; struct resource*res, *child_res = NULL; struct platform_device*pdev_irq = qcom->urs_usb ? qcom->urs_usb : pdev; intirq; intret; qcom->dwc3 = platform_device_alloc(""dwc3"", PLATFORM_DEVID_AUTO); if (!qcom->dwc3) return -ENOMEM; qcom->dwc3->dev.parent = dev; qcom->dwc3->dev.type = dev->type; qcom->dwc3->dev.dma_mask = dev->dma_mask; qcom->dwc3->dev.dma_parms = dev->dma_parms; qcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask; child_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL); if (!child_res) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""failed to get memory resource\n""); ret = -ENODEV; goto out; } child_res[0].flags = res->flags; child_res[0].start = res->start; child_res[0].end = child_res[0].start + qcom->acpi_pdata->dwc3_core_base_size; irq = platform_get_irq(pdev_irq, 0); if (irq < 0) { ret = irq; goto out; } child_res[1].flags = IORESOURCE_IRQ; child_res[1].start = child_res[1].end = irq; ret = platform_device_add_resources(qcom->dwc3, child_res, 2); if (ret) { dev_err(&pdev->dev, ""failed to add resources\n""); goto out; } ret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode); if (ret < 0) { dev_err(&pdev->dev, ""failed to add properties\n""); goto out; } ret = platform_device_add(qcom->dwc3); if (ret) { dev_err(&pdev->dev, ""failed to add device\n""); device_remove_software_node(&qcom->dwc3->dev); } out: kfree(child_res); return ret; }"
"GF_Err url_box_read(GF_Box *s, GF_BitStream *bs) { GF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s; if (ptr->size) { ptr->location = (char*)gf_malloc((u32) ptr->size); if (! ptr->location) return GF_OUT_OF_MEM; gf_bs_read_data(bs, ptr->location, (u32)ptr->size); } return GF_OK; }"
"static int io_file_bitmap_get(struct io_ring_ctx *ctx) { struct io_file_table *table = &ctx->file_table; unsigned long nr = ctx->file_alloc_end; int ret; do { ret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint); if (ret != nr) return ret; if (table->alloc_hint == ctx->file_alloc_start) break; nr = table->alloc_hint; table->alloc_hint = ctx->file_alloc_start; } while (1); return -ENFILE; }"
"static int dvb_ca_en50221_io_release(struct inode *inode, struct file *file) { struct dvb_device *dvbdev = file->private_data; struct dvb_ca_private *ca = dvbdev->priv; int err; dprintk(""%s\n"", __func__); ca->open = 0; dvb_ca_en50221_thread_update_delay(ca); err = dvb_generic_release(inode, file); module_put(ca->pub->owner); dvb_ca_private_put(ca); return err; }"
"void * get_layer4_v6(const ipv6_hdr_t *ip6_hdr, const int l3len) { struct tcpr_ipv6_ext_hdr_base *next, *exthdr; bool done = false; uint32_t maxlen; uint8_t proto; int min_len; assert(ip6_hdr); min_len = TCPR_IPV6_H + sizeof(struct tcpr_ipv6_ext_hdr_base); if (l3len < min_len) return NULL; next = (struct tcpr_ipv6_ext_hdr_base *)((u_char *)ip6_hdr + TCPR_IPV6_H); proto = ip6_hdr->ip_nh; while (!done) { dbgx(3, ""Processing proto: 0x%hx"", (uint16_t)proto); switch (proto) { case TCPR_IPV6_NH_IPV6: dbg(3, ""recursing due to v6-in-v6""); next = get_layer4_v6((ipv6_hdr_t *)next, l3len - min_len); break; case TCPR_IPV6_NH_AH: case TCPR_IPV6_NH_ROUTING: case TCPR_IPV6_NH_DESTOPTS: case TCPR_IPV6_NH_HBH: dbgx(3, ""Going deeper due to extension header 0x%02X"", proto); maxlen = l3len - (int)((u_char *)ip6_hdr - (u_char *)next); exthdr = get_ipv6_next(next, maxlen); if (exthdr == NULL) { done = true; break; } proto = exthdr->ip_nh; next = exthdr; break; case TCPR_IPV6_NH_FRAGMENT: case TCPR_IPV6_NH_ESP: next = NULL; done = true; break; default: if (proto != ip6_hdr->ip_nh) { dbgx(3, ""Returning byte offset of this ext header: %u"",  IPV6_EXTLEN_TO_BYTES(next->ip_len)); next =  (void *)((u_char *)next + IPV6_EXTLEN_TO_BYTES(next->ip_len)); } else { dbgx(3, ""%s"", ""Returning end of IPv6 Header""); } done = true; }  }  if (!next || (u_char*)next > (u_char*)ip6_hdr + l3len) return NULL; return next; }"
"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx) { u32 pck_size; GF_FilterPacket *pck; u8 *output; gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc); if (!pck_size) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1Dmx] no frame OBU, skipping OBU\n"")); return GF_OK; } pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output); if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck); gf_filter_pck_set_cts(pck, ctx->cts); gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0); memcpy(output, ctx->state.frame_obus, pck_size); if (ctx->deps) { u8 flags = 0; flags = ( ctx->state.frame_state.key_frame) ? 2 : 1; flags <<= 2; flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2; flags <<= 2; gf_filter_pck_set_dependency_flags(pck, flags); } gf_filter_pck_send(pck); av1dmx_update_cts(ctx); gf_av1_reset_state(&ctx->state, GF_FALSE); return GF_OK; }"
"static int iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group) { int err = 0; u32 portid; struct iscsi_uevent *ev = nlmsg_data(nlh); struct iscsi_transport *transport = NULL; struct iscsi_internal *priv; struct iscsi_cls_session *session; struct iscsi_cls_conn *conn; struct iscsi_endpoint *ep = NULL; if (nlh->nlmsg_type == ISCSI_UEVENT_PATH_UPDATE) *group = ISCSI_NL_GRP_UIP; else *group = ISCSI_NL_GRP_ISCSID; priv = iscsi_if_transport_lookup(iscsi_ptr(ev->transport_handle)); if (!priv) return -EINVAL; transport = priv->iscsi_transport; if (!try_module_get(transport->owner)) return -EINVAL; portid = NETLINK_CB(skb).portid; switch (nlh->nlmsg_type) { case ISCSI_UEVENT_CREATE_SESSION: err = iscsi_if_create_session(priv, ep, ev, portid, ev->u.c_session.initial_cmdsn, ev->u.c_session.cmds_max, ev->u.c_session.queue_depth); break; case ISCSI_UEVENT_CREATE_BOUND_SESSION: ep = iscsi_lookup_endpoint(ev->u.c_bound_session.ep_handle); if (!ep) { err = -EINVAL; break; } err = iscsi_if_create_session(priv, ep, ev, portid, ev->u.c_bound_session.initial_cmdsn, ev->u.c_bound_session.cmds_max, ev->u.c_bound_session.queue_depth); break; case ISCSI_UEVENT_DESTROY_SESSION: session = iscsi_session_lookup(ev->u.d_session.sid); if (!session) err = -EINVAL; else if (iscsi_session_has_conns(ev->u.d_session.sid)) err = -EBUSY; else transport->destroy_session(session); break; case ISCSI_UEVENT_DESTROY_SESSION_ASYNC: session = iscsi_session_lookup(ev->u.d_session.sid); if (!session) err = -EINVAL; else if (iscsi_session_has_conns(ev->u.d_session.sid)) err = -EBUSY; else { unsigned long flags; spin_lock_irqsave(&sesslock, flags); list_del_init(&session->sess_list); spin_unlock_irqrestore(&sesslock, flags); queue_work(iscsi_destroy_workq, &session->destroy_work); } break; case ISCSI_UEVENT_UNBIND_SESSION: session = iscsi_session_lookup(ev->u.d_session.sid); if (session) scsi_queue_work(iscsi_session_to_shost(session), &session->unbind_work); else err = -EINVAL; break; case ISCSI_UEVENT_CREATE_CONN: err = iscsi_if_create_conn(transport, ev); break; case ISCSI_UEVENT_DESTROY_CONN: err = iscsi_if_destroy_conn(transport, ev); break; case ISCSI_UEVENT_BIND_CONN: session = iscsi_session_lookup(ev->u.b_conn.sid); conn = iscsi_conn_lookup(ev->u.b_conn.sid, ev->u.b_conn.cid); if (conn && conn->ep) iscsi_if_ep_disconnect(transport, conn->ep->id); if (!session || !conn) { err = -EINVAL; break; } mutex_lock(&conn_mutex); ev->r.retcode =transport->bind_conn(session, conn, ev->u.b_conn.transport_eph, ev->u.b_conn.is_leading); mutex_unlock(&conn_mutex); if (ev->r.retcode || !transport->ep_connect) break; ep = iscsi_lookup_endpoint(ev->u.b_conn.transport_eph); if (ep) { ep->conn = conn; mutex_lock(&conn->ep_mutex); conn->ep = ep; mutex_unlock(&conn->ep_mutex); } else iscsi_cls_conn_printk(KERN_ERR, conn, ""Could not set ep conn "" ""binding\n""); break; case ISCSI_UEVENT_SET_PARAM: err = iscsi_set_param(transport, ev); break; case ISCSI_UEVENT_START_CONN: conn = iscsi_conn_lookup(ev->u.start_conn.sid, ev->u.start_conn.cid); if (conn) { mutex_lock(&conn_mutex); ev->r.retcode = transport->start_conn(conn); if (!ev->r.retcode) conn->state = ISCSI_CONN_UP; mutex_unlock(&conn_mutex); } else err = -EINVAL; break; case ISCSI_UEVENT_STOP_CONN: conn = iscsi_conn_lookup(ev->u.stop_conn.sid, ev->u.stop_conn.cid); if (conn) iscsi_if_stop_conn(conn, ev->u.stop_conn.flag); else err = -EINVAL; break; case ISCSI_UEVENT_SEND_PDU: conn = iscsi_conn_lookup(ev->u.send_pdu.sid, ev->u.send_pdu.cid); if (conn) { mutex_lock(&conn_mutex); ev->r.retcode =transport->send_pdu(conn, (struct iscsi_hdr*)((char*)ev + sizeof(*ev)), (char*)ev + sizeof(*ev) + ev->u.send_pdu.hdr_size, ev->u.send_pdu.data_size); mutex_unlock(&conn_mutex); } else err = -EINVAL; break; case ISCSI_UEVENT_GET_STATS: err = iscsi_if_get_stats(transport, nlh); break; case ISCSI_UEVENT_TRANSPORT_EP_CONNECT: case ISCSI_UEVENT_TRANSPORT_EP_POLL: case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT: case ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST: err = iscsi_if_transport_ep(transport, ev, nlh->nlmsg_type); break; case ISCSI_UEVENT_TGT_DSCVR: err = iscsi_tgt_dscvr(transport, ev); break; case ISCSI_UEVENT_SET_HOST_PARAM: err = iscsi_set_host_param(transport, ev); break; case ISCSI_UEVENT_PATH_UPDATE: err = iscsi_set_path(transport, ev); break; case ISCSI_UEVENT_SET_IFACE_PARAMS: err = iscsi_set_iface_params(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_PING: err = iscsi_send_ping(transport, ev); break; case ISCSI_UEVENT_GET_CHAP: err = iscsi_get_chap(transport, nlh); break; case ISCSI_UEVENT_DELETE_CHAP: err = iscsi_delete_chap(transport, ev); break; case ISCSI_UEVENT_SET_FLASHNODE_PARAMS: err = iscsi_set_flashnode_param(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_NEW_FLASHNODE: err = iscsi_new_flashnode(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_DEL_FLASHNODE: err = iscsi_del_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGIN_FLASHNODE: err = iscsi_login_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGOUT_FLASHNODE: err = iscsi_logout_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGOUT_FLASHNODE_SID: err = iscsi_logout_flashnode_sid(transport, ev); break; case ISCSI_UEVENT_SET_CHAP: err = iscsi_set_chap(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_GET_HOST_STATS: err = iscsi_get_host_stats(transport, nlh); break; default: err = -ENOSYS; break; } module_put(transport->owner); return err; }"
"sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; if (avail >= addlen) return s; len = sdslen(s); sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; type = sdsReqType(newlen); if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); if (oldtype==type) { newsh = s_realloc(sh, hdrlen+newlen+1); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; }"
"static int same_leader( linenr_T lnum, int    leader1_len, char_u  *leader1_flags, int    leader2_len, char_u  *leader2_flags) { int    idx1 = 0, idx2 = 0; char_u  *p; char_u  *line1; char_u  *line2; if (leader1_len == 0) return (leader2_len == 0); if (leader1_flags != NULL) { for (p = leader1_flags; *p && *p != ':'; ++p) { if (*p == COM_FIRST) return (leader2_len == 0); if (*p == COM_END) return FALSE; if (*p == COM_START) { if (*(ml_get(lnum) + leader1_len) == NUL) return FALSE; if (leader2_flags == NULL || leader2_len == 0) return FALSE; for (p = leader2_flags; *p && *p != ':'; ++p) if (*p == COM_MIDDLE) return TRUE; return FALSE; } } } line1 = vim_strsave(ml_get(lnum)); if (line1 != NULL) { for (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1) ; line2 = ml_get(lnum + 1); for (idx2 = 0; idx2 < leader2_len; ++idx2) { if (!VIM_ISWHITE(line2[idx2])) { if (line1[idx1++] != line2[idx2]) break; } else while (VIM_ISWHITE(line1[idx1])) ++idx1; } vim_free(line1); } return (idx2 == leader2_len && idx1 == leader1_len); }"
"static bool warn_wrong_flags(const JournalFile *f, bool compatible) { const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY, supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED; const char *type = compatible ? ""compatible"" : ""incompatible""; uint32_t flags; assert(f); assert(f->header); flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags); if (flags & ~supported) { if (flags & ~any) log_debug(""Journal file %s has unknown %s flags 0x%""PRIx32, f->path, type, flags & ~any); flags = (flags & any) & ~supported; if (flags) { const char* strv[6]; size_t n = 0; _cleanup_free_ char *t = NULL; if (compatible) { if (flags & HEADER_COMPATIBLE_SEALED) strv[n++] = ""sealed""; } else { if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ) strv[n++] = ""xz-compressed""; if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4) strv[n++] = ""lz4-compressed""; if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD) strv[n++] = ""zstd-compressed""; if (flags & HEADER_INCOMPATIBLE_KEYED_HASH) strv[n++] = ""keyed-hash""; if (flags & HEADER_INCOMPATIBLE_COMPACT) strv[n++] = ""compact""; } strv[n] = NULL; assert(n < ELEMENTSOF(strv)); t = strv_join((char**) strv, "", ""); log_debug(""Journal file %s uses %s %s %s disabled at compilation time."", f->path, type, n > 1 ? ""flags"" : ""flag"", strnull(t)); } return true; } return false; }"
"static void io_req_task_queue(struct io_kiocb *req) { int ret; init_task_work(&req->task_work, io_req_task_submit); ret = io_req_task_work_add(req, &req->task_work); if (unlikely(ret)) { struct task_struct *tsk; init_task_work(&req->task_work, io_req_task_cancel); tsk = io_wq_get_task(req->ctx->io_wq); task_work_add(tsk, &req->task_work, 0); wake_up_process(tsk); } }"
"static void module_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv)) { struct ly_ctx *ctx; struct lys_node *next, *iter; unsigned int i; assert(module->ctx); ctx = module->ctx; for (i = 0; i < module->imp_size; i++) { lydict_remove(ctx, module->imp[i].prefix); lydict_remove(ctx, module->imp[i].dsc); lydict_remove(ctx, module->imp[i].ref); lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor); } free(module->imp); if (!module->type) { LY_TREE_FOR_SAFE(module->data, next, iter) { lys_node_free(iter, private_destructor, 0); } } lydict_remove(ctx, module->dsc); lydict_remove(ctx, module->ref); lydict_remove(ctx, module->org); lydict_remove(ctx, module->contact); lydict_remove(ctx, module->filepath); for (i = 0; i < module->rev_size; i++) { lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor); lydict_remove(ctx, module->rev[i].dsc); lydict_remove(ctx, module->rev[i].ref); } free(module->rev); for (i = 0; i < module->ident_size; i++) { lys_ident_free(ctx, &module->ident[i], private_destructor); } module->ident_size = 0; free(module->ident); for (i = 0; i < module->tpdf_size; i++) { lys_tpdf_free(ctx, &module->tpdf[i], private_destructor); } free(module->tpdf); lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor); for (i = 0; i < module->augment_size; i++) { lys_augment_free(ctx, &module->augment[i], private_destructor); } free(module->augment); for (i = 0; i < module->features_size; i++) { lys_feature_free(ctx, &module->features[i], private_destructor); } free(module->features); for (i = 0; i < module->deviation_size; i++) { lys_deviation_free(module, &module->deviation[i], private_destructor); } free(module->deviation); for (i = 0; i < module->extensions_size; i++) { lys_extension_free(ctx, &module->extensions[i], private_destructor); } free(module->extensions); lydict_remove(ctx, module->name); lydict_remove(ctx, module->prefix); }"
static int on_message_complete(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->process_message(); return 0; }
"int cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info) { struct member *m; int matched = UNSPEC; debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH); TAILQ_FOREACH_REVERSE(m, list, member_list, entries) { matched = cmnd_matches(parse_tree, m, runchroot, info); if (matched != UNSPEC) break; } debug_return_int(matched); }"
"ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config, const Network::DrainDecision& drain_close, Random::RandomGenerator& random_generator, Http::Context& http_context, Runtime::Loader& runtime, const LocalInfo::LocalInfo& local_info, Upstream::ClusterManager& cluster_manager, Server::OverloadManager& overload_manager, TimeSource& time_source) : config_(config), stats_(config_.stats()), conn_length_(new Stats::HistogramCompletableTimespanImpl( stats_.named_.downstream_cx_length_ms_, time_source)), drain_close_(drain_close), user_agent_(http_context.userAgentContext()), random_generator_(random_generator), runtime_(runtime), local_info_(local_info), cluster_manager_(cluster_manager), listener_stats_(config_.listenerStats()), overload_manager_(overload_manager), overload_state_(overload_manager.getThreadLocalOverloadState()), accept_new_http_stream_(overload_manager.getLoadShedPoint( ""envoy.load_shed_points.http_connection_manager_decode_headers"")), overload_stop_accepting_requests_ref_( overload_state_.getState(Server::OverloadActionNames::get().StopAcceptingRequests)), overload_disable_keepalive_ref_( overload_state_.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)), time_source_(time_source), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName( local_info_.node().id(), config_.serverName(), config_.proxyStatusConfig())), refresh_rtt_after_request_( Runtime::runtimeFeatureEnabled(""envoy.reloadable_features.refresh_rtt_after_request"")) { ENVOY_LOG_ONCE_IF( trace, accept_new_http_stream_ == nullptr, ""LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not "" ""found. Is it configured?""); }"
"void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page) { gnrc_netif_hdr_t *netif_hdr = pkt->data; gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr); gnrc_pktsnip_t *tmp; size_t orig_datagram_size = gnrc_pkt_len(pkt->next); ipv6_hdr_t *ipv6_hdr = pkt->next->data; ipv6_addr_t dst; if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) { dst = ipv6_hdr->dst;     } if ((tmp = _iphc_encode(pkt, pkt->data, netif))) { if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) && (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst, ctx) == 0)) { DEBUG(""6lo iphc minfwd: putting slack in first fragment\n""); return; } gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page); } else { gnrc_pktbuf_release(pkt); } }"
"static int extract_lladdr_from_llao_aligned(uip_lladdr_t *dest) { if(dest != NULL && nd6_opt_llao != NULL) { memcpy(dest, &nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET], UIP_LLADDR_LEN); return 1; } return 0; }"
"void cache_flush(const void *addr, unsigned int size) { unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16; const void *end = addr + size; addr -= (unsigned long)addr & (clflush_size - 1); for ( ; addr < end; addr += clflush_size ) { alternative_io(""ds; clflush %[p]"", ""data16 clflush %[p]"",  X86_FEATURE_CLFLUSHOPT, , [p] ""m"" (*(const char *)(addr))); } alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT); }"
"static XML_Bool storeRawNames(XML_Parser parser) { TAG *tag = parser->m_tagStack; while (tag) { int bufSize; int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1); char *rawNameBuf = tag->buf + nameLen; if (tag->rawName == rawNameBuf) break; bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)); if (bufSize > tag->bufEnd - tag->buf) { char *temp = (char *)REALLOC(parser, tag->buf, bufSize); if (temp == NULL) return XML_FALSE; if (tag->name.str == (XML_Char *)tag->buf) tag->name.str = (XML_Char *)temp; if (tag->name.localPart) tag->name.localPart = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf); tag->buf = temp; tag->bufEnd = temp + bufSize; rawNameBuf = temp + nameLen; } memcpy(rawNameBuf, tag->rawName, tag->rawNameLength); tag->rawName = rawNameBuf; tag = tag->parent; } return XML_TRUE; }"
"static int count(struct cstate *g, Renode *node) { int min, max, n; if (!node) return 0; switch (node->type) { default: return 1; case P_CAT: return count(g, node->x) + count(g, node->y); case P_ALT: return count(g, node->x) + count(g, node->y) + 2; case P_REP: min = node->m; max = node->n; if (min == max) n = count(g, node->x) * min; else if (max < REPINF) n = count(g, node->x) * max + (max - min); else n = count(g, node->x) * (min + 1) + 2; if (n < 0 || n > REG_MAXPROG) die(g, ""program too large""); return n; case P_PAR: return count(g, node->x) + 2; case P_PLA: return count(g, node->x) + 2; case P_NLA: return count(g, node->x) + 2; } }"
"void subtract (const hb_bit_set_invertible_t &other) { if (likely (inverted == other.inverted)) { if (unlikely (inverted)) process (hb_bitwise_lt, other); else process (hb_bitwise_gt, other);  } else { if (unlikely (inverted)) process (hb_bitwise_or, other); else process (hb_bitwise_and, other); } inverted = inverted && !other.inverted; }"
"struct posix_acl *fuse_get_acl(struct inode *inode, int type) { struct fuse_conn *fc = get_fuse_conn(inode); int size; const char *name; void *value = NULL; struct posix_acl *acl; if (!fc->posix_acl || fc->no_getxattr) return NULL; if (type == ACL_TYPE_ACCESS) name = XATTR_NAME_POSIX_ACL_ACCESS; else if (type == ACL_TYPE_DEFAULT) name = XATTR_NAME_POSIX_ACL_DEFAULT; else return ERR_PTR(-EOPNOTSUPP); value = kmalloc(PAGE_SIZE, GFP_KERNEL); if (!value) return ERR_PTR(-ENOMEM); size = fuse_getxattr(inode, name, value, PAGE_SIZE); if (size > 0) acl = posix_acl_from_xattr(fc->user_ns, value, size); else if ((size == 0) || (size == -ENODATA) || (size == -EOPNOTSUPP && fc->no_getxattr)) acl = NULL; else if (size == -ERANGE) acl = ERR_PTR(-E2BIG); else acl = ERR_PTR(size); kfree(value); return acl; }"
"GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples) { GF_SampleTableBox *stbl; GF_ChunkOffsetBox *stco; GF_SampleToChunkBox *stsc; GF_ChunkLargeOffsetBox *co64; GF_StscEntry *ent; u32 i, k, *newOff, new_chunk_idx=0; u64 *newLarge; s32 insert_idx = -1; stbl = mdia->information->sampleTable; stsc = stbl->SampleToChunk; if (!nb_pack_samples) nb_pack_samples = 1; if (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) { if (!stsc->alloc_size) stsc->alloc_size = 1; ALLOC_INC(stsc->alloc_size); stsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size); if (!stsc->entries) return GF_OUT_OF_MEM; memset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) ); } if (sampleNumber == stsc->w_lastSampleNumber + 1) { ent = &stsc->entries[stsc->nb_entries]; stsc->w_lastChunkNumber ++; ent->firstChunk = stsc->w_lastChunkNumber; if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber; new_chunk_idx = stsc->w_lastChunkNumber; stsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1; stsc->nb_entries += 1; } else { u32 cur_samp = 1; u32 samples_in_next_entry = 0; u32 next_entry_first_chunk = 1; for (i=0; i<stsc->nb_entries; i++) { u32 nb_chunks = 1; ent = &stsc->entries[i]; if (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk; for (k=0; k<nb_chunks; k++) { if ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) { insert_idx = i; if (sampleNumber>cur_samp) { samples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp); ent->samplesPerChunk = sampleNumber-cur_samp; } break; } cur_samp += ent->samplesPerChunk; next_entry_first_chunk++; } if (insert_idx>=0) break; } if (samples_in_next_entry) { memmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1)); ent = &stsc->entries[insert_idx]; stsc->entries[insert_idx+2] = *ent; stsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry; stsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1; ent = &stsc->entries[insert_idx+1]; ent->firstChunk = next_entry_first_chunk; stsc->nb_entries += 2; } else { if (insert_idx<0) { ent = &stsc->entries[stsc->nb_entries]; insert_idx = stsc->nb_entries; } else { memmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx)); ent = &stsc->entries[insert_idx+1]; } ent->firstChunk = next_entry_first_chunk; stsc->nb_entries += 1; } new_chunk_idx = next_entry_first_chunk; } ent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0; ent->sampleDescriptionIndex = StreamDescIndex; ent->samplesPerChunk = nb_pack_samples; ent->nextChunk = ent->firstChunk+1; if (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) { if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk; stbl->SampleToChunk->currentIndex = stsc->nb_entries-1; stbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber; stbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber; stbl->SampleToChunk->ghostNumber = 1; } else { for (i = insert_idx+1; i<stsc->nb_entries+1; i++) { stsc->entries[i].firstChunk++; if (i+1<stsc->nb_entries) stsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk; } } if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) { stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset; if (offset > 0xFFFFFFFF) { co64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64); if (!co64) return GF_OUT_OF_MEM; co64->nb_entries = stco->nb_entries + 1; co64->alloc_size = co64->nb_entries; co64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries); if (!co64->offsets) return GF_OUT_OF_MEM; k = 0; for (i=0; i<stco->nb_entries; i++) { if (i + 1 == new_chunk_idx) { co64->offsets[i] = offset; k = 1; } co64->offsets[i+k] = (u64) stco->offsets[i]; } if (!k) co64->offsets[co64->nb_entries - 1] = offset; gf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset); stbl->ChunkOffset = (GF_Box *) co64; } else { if (new_chunk_idx > stco->nb_entries) { if (!stco->alloc_size) stco->alloc_size = stco->nb_entries; if (stco->nb_entries == stco->alloc_size) { ALLOC_INC(stco->alloc_size); stco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size); if (!stco->offsets) return GF_OUT_OF_MEM; memset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) ); } stco->offsets[stco->nb_entries] = (u32) offset; stco->nb_entries += 1; } else { newOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1)); if (!newOff) return GF_OUT_OF_MEM; k=0; for (i=0; i<stco->nb_entries; i++) { if (i+1 == new_chunk_idx) { newOff[i] = (u32) offset; k=1; } newOff[i+k] = stco->offsets[i]; } gf_free(stco->offsets); stco->offsets = newOff; stco->nb_entries ++; stco->alloc_size = stco->nb_entries; } } } else { co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset; if (sampleNumber > co64->nb_entries) { if (!co64->alloc_size) co64->alloc_size = co64->nb_entries; if (co64->nb_entries == co64->alloc_size) { ALLOC_INC(co64->alloc_size); co64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size); if (!co64->offsets) return GF_OUT_OF_MEM; memset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) ); } co64->offsets[co64->nb_entries] = offset; co64->nb_entries += 1; } else { newLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1)); if (!newLarge) return GF_OUT_OF_MEM; k=0; for (i=0; i<co64->nb_entries; i++) { if (i+1 == new_chunk_idx) { newLarge[i] = offset; k=1; } newLarge[i+k] = co64->offsets[i]; } gf_free(co64->offsets); co64->offsets = newLarge; co64->nb_entries++; co64->alloc_size++; } } return GF_OK; }"
"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { EXRContext *s = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *picture = data; uint8_t *ptr; int i, y, ret, ymax; int planes; int out_line_size; int nb_blocks;    uint64_t start_offset_table; uint64_t start_next_scanline; PutByteContext offset_table_writer; bytestream2_init(&s->gb, avpkt->data, avpkt->size); if ((ret = decode_header(s, picture)) < 0) return ret; switch (s->pixel_type) { case EXR_FLOAT: case EXR_HALF: if (s->channel_offsets[3] >= 0) { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_GBRAPF32; } else { avctx->pix_fmt = AV_PIX_FMT_GBRAPF32; } } else { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_GBRPF32; } else { avctx->pix_fmt = AV_PIX_FMT_GRAYF32; } } break; case EXR_UINT: if (s->channel_offsets[3] >= 0) { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_RGBA64; } else { avctx->pix_fmt = AV_PIX_FMT_YA16; } } else { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_RGB48; } else { avctx->pix_fmt = AV_PIX_FMT_GRAY16; } } break; default: av_log(avctx, AV_LOG_ERROR, ""Missing channel list.\n""); return AVERROR_INVALIDDATA; } if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED) avctx->color_trc = s->apply_trc_type; switch (s->compression) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: s->scan_lines_per_block = 1; break; case EXR_PXR24: case EXR_ZIP16: s->scan_lines_per_block = 16; break; case EXR_PIZ: case EXR_B44: case EXR_B44A: s->scan_lines_per_block = 32; break; default: avpriv_report_missing_feature(avctx, ""Compression %d"", s->compression); return AVERROR_PATCHWELCOME; } if (s->xmin > s->xmax  || s->ymin > s->ymax || s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) { av_log(avctx, AV_LOG_ERROR, ""Wrong or missing size information.\n""); return AVERROR_INVALIDDATA; } if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0) return ret; s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt); if (!s->desc) return AVERROR_INVALIDDATA; if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) { planes           = s->desc->nb_components; out_line_size    = avctx->width * 4; } else { planes           = 1; out_line_size    = avctx->width * 2 * s->desc->nb_components; } if (s->is_tile) { nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) * ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize); } else {  nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) / s->scan_lines_per_block; } if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks) return AVERROR_INVALIDDATA; if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) { av_log(s->avctx, AV_LOG_DEBUG, ""recreating invalid scanline offset table\n""); start_offset_table = bytestream2_tell(&s->gb); start_next_scanline = start_offset_table + nb_blocks * 8; bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8); for (y = 0; y < nb_blocks; y++) { bytestream2_put_le64(&offset_table_writer, start_next_scanline); bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET); start_next_scanline += (bytestream2_get_le32(&s->gb) + 8); } bytestream2_seek(&s->gb, start_offset_table, SEEK_SET); } s->buf      = avpkt->data; s->buf_size = avpkt->size; for (i = 0; i < planes; i++) { ptr = picture->data[i]; for (y = 0; y < s->ymin; y++) { memset(ptr, 0, out_line_size); ptr += picture->linesize[i]; } } s->picture = picture; avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks); ymax = FFMAX(0, s->ymax + 1); for (i = 0; i < planes; i++) { ptr = picture->data[i] + (ymax * picture->linesize[i]); for (y = ymax; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += picture->linesize[i]; } } picture->pict_type = AV_PICTURE_TYPE_I; *got_frame = 1; return avpkt->size; }"
"Http::FilterTrailersStatus Context::onResponseTrailers() { if (!wasm_->onResponseTrailers_) { return Http::FilterTrailersStatus::Continue; } if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) { return Http::FilterTrailersStatus::Continue; } return Http::FilterTrailersStatus::StopIteration; }"
"static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags) { BOOL rc = FALSE; rdpContext* context = update->context; rdpPrimaryUpdate* primary = update->primary; ORDER_INFO* orderInfo = &(primary->order_info); rdpSettings* settings = context->settings; const char* orderName; if (flags & ORDER_TYPE_CHANGE) { if (Stream_GetRemainingLength(s) < 1) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) < 1""); return FALSE; } Stream_Read_UINT8(s, orderInfo->orderType);  } orderName = primary_order_string(orderInfo->orderType); if (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName)) return FALSE; if (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags, PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType])) { WLog_Print(update->log, WLOG_ERROR, ""update_read_field_flags() failed""); return FALSE; } if (flags & ORDER_BOUNDS) { if (!(flags & ORDER_ZERO_BOUNDS_DELTAS)) { if (!update_read_bounds(s, &orderInfo->bounds)) { WLog_Print(update->log, WLOG_ERROR, ""update_read_bounds() failed""); return FALSE; } } rc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds); if (!rc) return FALSE; } orderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE; if (!read_primary_order(update->log, orderName, s, orderInfo, primary)) return FALSE; switch (orderInfo->orderType) { case ORDER_TYPE_DSTBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->dstblt.bRop), gdi_rop3_code(primary->dstblt.bRop)); rc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt); } break; case ORDER_TYPE_PATBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->patblt.bRop), gdi_rop3_code(primary->patblt.bRop)); rc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt); } break; case ORDER_TYPE_SCRBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->scrblt.bRop), gdi_rop3_code(primary->scrblt.bRop)); rc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt); } break; case ORDER_TYPE_OPAQUE_RECT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect); } break; case ORDER_TYPE_DRAW_NINE_GRID: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid); } break; case ORDER_TYPE_MULTI_DSTBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop), gdi_rop3_code(primary->multi_dstblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt); } break; case ORDER_TYPE_MULTI_PATBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_patblt.bRop), gdi_rop3_code(primary->multi_patblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt); } break; case ORDER_TYPE_MULTI_SCRBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop), gdi_rop3_code(primary->multi_scrblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt); } break; case ORDER_TYPE_MULTI_OPAQUE_RECT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect); } break; case ORDER_TYPE_MULTI_DRAW_NINE_GRID: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context, &primary->multi_draw_nine_grid); } break; case ORDER_TYPE_LINE_TO: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to); } break; case ORDER_TYPE_POLYLINE: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline); } break; case ORDER_TYPE_MEMBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->memblt.bRop), gdi_rop3_code(primary->memblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt); } break; case ORDER_TYPE_MEM3BLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->mem3blt.bRop), gdi_rop3_code(primary->mem3blt.bRop)); rc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt); } break; case ORDER_TYPE_SAVE_BITMAP: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap); } break; case ORDER_TYPE_GLYPH_INDEX: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index); } break; case ORDER_TYPE_FAST_INDEX: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index); } break; case ORDER_TYPE_FAST_GLYPH: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph); } break; case ORDER_TYPE_POLYGON_SC: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc); } break; case ORDER_TYPE_POLYGON_CB: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb); } break; case ORDER_TYPE_ELLIPSE_SC: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc); } break; case ORDER_TYPE_ELLIPSE_CB: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb); } break; default: WLog_Print(update->log, WLOG_WARN, ""Primary Drawing Order %s not supported"", orderName); break; } if (!rc) { WLog_Print(update->log, WLOG_WARN, ""Primary Drawing Order %s failed"", orderName); return FALSE; } if (flags & ORDER_BOUNDS) { rc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL); } return rc; }"
"bool PackLinuxElf32::canPack() { union { unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512) fi->seek(0, SEEK_SET); fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI]; Elf32_Phdr const *phdr = phdri; note_size = 0; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); unsigned const p_offset = get_te32(&phdr->p_offset); if (1!=exetype && PT_LOAD32 == p_type) {             exetype = 1; load_va = get_te32(&phdr->p_vaddr);   unsigned const off = ~page_mask & (unsigned)load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz)); } if (PT_NOTE32 == p_type) { unsigned const x = get_te32(&phdr->p_memsz); if ( sizeof(elfout.notes) < x              ||  (sizeof(elfout.notes) < (note_size += x)) ) { throwCantPack(""PT_NOTEs too big; try '--force-execve'""); return false; } if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) {                 struct { struct Elf32_Nhdr nhdr; char name[8]; unsigned body; } note; memset(&note, 0, sizeof(note)); fi->seek(p_offset, SEEK_SET); fi->readx(&note, sizeof(note)); fi->seek(0, SEEK_SET); if (4==get_te32(&note.nhdr.descsz) &&  1==get_te32(&note.nhdr.type) &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz) &&  0==strcmp(osabi_note, (char const *)&note.name[0]) ) { osabi0 = ei_osabi;                  } } } } if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0 ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) {         unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags); if (Elf32_Ehdr::EM_ARM==e_machine &&   (EF_ARM_EABI_VER5==arm_eabi ||  EF_ARM_EABI_VER4==arm_eabi ) ) { ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX; } else { osabi0 = opt->o_unix.osabi0;          } } if (osabi0!=ei_osabi) { return false; } if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr)); phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; unsigned const sh_offset = get_te32(&sec_strndx->sh_offset); if ((u32_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#x"", sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM); if (sec_dynsym) { unsigned const sh_link = get_te32(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#x"", sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf32_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD32==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB); dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL), (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ)) ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if ( elf_find_dynamic(upx_dt_init)) { if (this->e_machine!=Elf32_Ehdr::EM_386 &&  this->e_machine!=Elf32_Ehdr::EM_MIPS &&  this->e_machine!=Elf32_Ehdr::EM_ARM) goto abandon;              if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) { if (Elf32_Ehdr::EM_ARM == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf32_Shdr const *shdr = shdri; xct_va = ~0u; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te32(&shdr->sh_addr)); } if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te32(&shdr->sh_offset); if ((u32_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf32_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf32_Dyn::DT_REL]; int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val); Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off]; unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val); Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te32(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te32(&rp->r_info); unsigned r_type = ELF32_R_TYPE(r_info); if (Elf32_Ehdr::EM_ARM == e_machine &&  R_ARM_RELATIVE == r_type) { user_init_va = get_te32(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te32(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf32_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn); Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)]; for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te32(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te32(&dynp->d_val);                              set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ); unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB); unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ); unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL); unsigned const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH); unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { unsigned const vaddr = get_te32(&phdr->p_vaddr); if (PT_NOTE32 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#x above stub"", vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = nullptr; shstrtab = nullptr; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf64_Phdr const *pload_x0(nullptr);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg, get_te64(&phdr->p_filesz)); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { upx_uint64_t sh_offset = get_te64(&shdr->sh_offset); upx_uint64_t sh_size = get_te64(&shdr->sh_size); if ((upx_uint64_t)file_size < sh_size ||  (upx_uint64_t)file_size < sh_offset || ((upx_uint64_t)file_size - sh_offset) < sh_size) { throwCantPack(""bad SHT_DYNAMIC""); } unsigned const n = sh_size / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[sh_offset]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else { throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); } abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"static int svm_cpu_init(int cpu) { struct svm_cpu_data *sd; int r; sd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL); if (!sd) return -ENOMEM; sd->cpu = cpu; r = -ENOMEM; sd->save_area = alloc_page(GFP_KERNEL); if (!sd->save_area) goto err_1; if (svm_sev_enabled()) { r = -ENOMEM; sd->sev_vmcbs = kmalloc_array(max_sev_asid + 1, sizeof(void *), GFP_KERNEL); if (!sd->sev_vmcbs) goto err_1; } per_cpu(svm_data, cpu) = sd; return 0; err_1: kfree(sd); return r; }"
"__poll_t psi_trigger_poll(void **trigger_ptr, struct file *file, poll_table *wait) { __poll_t ret = DEFAULT_POLLMASK; struct psi_trigger *t; if (static_branch_likely(&psi_disabled)) return DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI; rcu_read_lock(); t = rcu_dereference(*(void __rcu __force **)trigger_ptr); if (!t) { rcu_read_unlock(); return DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI; } kref_get(&t->refcount); rcu_read_unlock(); poll_wait(file, &t->event_wait, wait); if (cmpxchg(&t->event, 1, 0) == 1) ret |= EPOLLPRI; kref_put(&t->refcount, psi_trigger_destroy); return ret; }"
"static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len) { char *p = buf; char *end = buf+len; unsigned i; int printed; if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) { return -1; } *p++ = 'm';     *p++ = '='; pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen); p += m->desc.media.slen; *p++ = ' '; printed = pj_utoa(m->desc.port, p); p += printed; if (m->desc.port_count > 1) { *p++ = '/'; printed = pj_utoa(m->desc.port_count, p); p += printed; } *p++ = ' '; pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen); p += m->desc.transport.slen; for (i=0; i<m->desc.fmt_count; ++i) { *p++ = ' '; pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen); p += m->desc.fmt[i].slen; } *p++ = '\r'; *p++ = '\n'; if (m->conn) { printed = print_connection_info(m->conn, p, (int)(end-p)); if (printed < 0) { return -1; } p += printed; } for (i=0; i<m->bandw_count; ++i) { printed = (int)print_bandw(m->bandw[i], p, end-p); if (printed < 0) { return -1; } p += printed; } for (i=0; i<m->attr_count; ++i) { printed = (int)print_attr(m->attr[i], p, end-p); if (printed < 0) { return -1; } p += printed; } return (int)(p-buf); }"
"TfLiteStatus Prepare(KernelType kernel_type, TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); bool has_bias = node->inputs->size == 3; TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2); TF_LITE_ENSURE_EQ(context, node->outputs->size, 1); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output)); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input)); const TfLiteTensor* filter; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter)); TF_LITE_ENSURE_EQ(context, input->dims->size, 4); TF_LITE_ENSURE_EQ(context, filter->dims->size, 4); auto input_channel = input->dims->data[3]; auto filter_input_channel = filter->dims->data[3]; TF_LITE_ENSURE_EQ(context, input_channel % filter_input_channel, 0); data->groups = input_channel / filter_input_channel; TfLiteType input_type = input->type; TF_LITE_ENSURE(context, input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt16); TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type); if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0); TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0); } if (input_type == kTfLiteInt16 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); for (int i = 0; i < affine_quantization->zero_point->size; ++i) { TF_LITE_ENSURE_EQ(context, affine_quantization->zero_point->data[i], 0); } } const TfLiteTensor* bias = nullptr; TF_LITE_ENSURE(context, has_bias); if (has_bias) { TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &bias)); if (input_type == kTfLiteUInt8 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else if (input_type == kTfLiteInt16) { TF_LITE_ENSURE(context, (bias->type == kTfLiteInt32) || (bias->type == kTfLiteInt64)); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, input_type); } TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0)); } const bool is_hybrid = (input->type == kTfLiteFloat32 && (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)); if (is_hybrid && filter->type == kTfLiteInt8 && filter->quantization.type == kTfLiteAffineQuantization && filter->quantization.params && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale->size > 1) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); const float scale = affine_quantization->scale->data[0]; for (int i = 1; i < affine_quantization->scale->size; i++) { if (affine_quantization->scale->data[i] != scale) { data->is_hybrid_per_channel = true; break; } } } data->supports_multithreaded_kernel = (kernel_type == kMultithreadOptimized) && (context->recommended_num_threads != 1) && !is_hybrid && (params->dilation_width_factor == 1) && (params->dilation_height_factor == 1) && (filter->allocation_type != kTfLiteArenaRw) && !IsDynamicTensor(filter); int channels_in = filter->dims->data[3]; int channels_out = filter->dims->data[0]; int width = input->dims->data[2]; int height = input->dims->data[1]; int filter_width = filter->dims->data[2]; int filter_height = filter->dims->data[1]; int batches = input->dims->data[0]; auto padding = params->padding; int out_width, out_height; data->padding = ComputePaddingHeightWidth( params->stride_height, params->stride_width, params->dilation_height_factor, params->dilation_width_factor, height, width, filter_height, filter_width, padding, &out_height, &out_width); size_t im2col_type_size; TF_LITE_ENSURE_STATUS(GetSizeOfType(context, input->type, &im2col_type_size)); const size_t im2col_bytes = static_cast<size_t>(batches) * out_height * out_width * channels_in * filter_height * filter_width * im2col_type_size; TF_LITE_ENSURE_STATUS(AllocateTemporaryTensorsIfRequired( context, node, is_hybrid, data->is_hybrid_per_channel, kernel_type, im2col_bytes)); TF_LITE_ENSURE(context, has_bias); if (input_type != kTfLiteFloat32) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 || affine_quantization->scale->size == channels_out)); data->per_channel_output_multiplier.resize(channels_out); data->per_channel_output_shift.resize(channels_out); TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams( context, input, filter, bias, output, params->activation, &data->output_multiplier, &data->output_shift, &data->output_activation_min, &data->output_activation_max, data->per_channel_output_multiplier.data(), data->per_channel_output_shift.data(), channels_out)); } TfLiteIntArray* output_size = TfLiteIntArrayCreate(4); output_size->data[0] = batches; output_size->data[1] = out_height; output_size->data[2] = out_width; output_size->data[3] = channels_out; auto output_status = context->ResizeTensor(context, output, output_size); if (output_status != kTfLiteOk) return output_status; if (data->need_im2col) { node->temporaries->data[data->im2col_index] = data->im2col_id; TfLiteIntArray* im2col_size = TfLiteIntArrayCreate(4); auto filter_input_channel = filter->dims->data[3]; im2col_size->data[0] = output_size->data[0]; im2col_size->data[1] = output_size->data[1]; im2col_size->data[2] = output_size->data[2]; im2col_size->data[3] = filter_input_channel * filter_height * filter_width; TfLiteTensor* im2col = &context->tensors[node->temporaries->data[data->im2col_index]]; im2col->type = input->type; if (is_hybrid) { im2col->type = filter->type; } im2col->allocation_type = kTfLiteArenaRw; auto im2col_status = context->ResizeTensor(context, im2col, im2col_size); if (im2col_status != kTfLiteOk) return im2col_status; } if (data->need_hwcn_weights) { node->temporaries->data[data->hwcn_weights_index] = data->hwcn_weights_id; TfLiteIntArray* hwcn_weights_size = TfLiteIntArrayCreate(2); auto filter_input_channel = filter->dims->data[3]; hwcn_weights_size->data[0] = (filter_height * filter_width * filter_input_channel); hwcn_weights_size->data[1] = channels_out; TfLiteTensor* hwcn_weights = &context->tensors[node->temporaries->data[data->hwcn_weights_index]]; hwcn_weights->type = input_type; hwcn_weights->name = ""Conv_hwcn_weights""; hwcn_weights->allocation_type = kTfLiteArenaRwPersistent; auto hwcn_weights_status = context->ResizeTensor(context, hwcn_weights, hwcn_weights_size); if (hwcn_weights_status != kTfLiteOk) return hwcn_weights_status; data->have_weights_been_transposed = false; } if (is_hybrid) { node->temporaries->data[data->input_quantized_index] = data->input_quantized_id; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); input_quantized->type = kTfLiteInt8; input_quantized->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) { TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized, input_quantized_size)); } node->temporaries->data[data->scaling_factors_index] = data->scaling_factors_id; TfLiteTensor* scaling_factors; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors)); scaling_factors->type = kTfLiteFloat32; scaling_factors->allocation_type = kTfLiteArenaRw; TF_LITE_ENSURE(context, channels_in != 0); const int height = NumElements(input) / channels_in; int scaling_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) { TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1); scaling_factors_size->data[0] = height; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors, scaling_factors_size)); } node->temporaries->data[data->accum_scratch_index] = data->accum_scratch_id; TfLiteTensor* accum_scratch; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->accum_scratch_index, &accum_scratch)); accum_scratch->type = kTfLiteInt32; accum_scratch->allocation_type = kTfLiteArenaRw; const int scratch_width = batches * out_height * out_width; int accum_scratch_dims[2] = {channels_out, scratch_width}; if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2, accum_scratch_dims)) { TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2); accum_scratch_size->data[0] = channels_out; accum_scratch_size->data[1] = scratch_width; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch, accum_scratch_size)); } if (data->is_hybrid_per_channel) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE_EQ( context, affine_quantization->scale->size, filter->dims->data[affine_quantization->quantized_dimension]); node->temporaries->data[data->input_offset_index] = data->input_offset_id; TfLiteTensor* input_offsets; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_offset_index, &input_offsets)); input_offsets->type = kTfLiteInt32; input_offsets->allocation_type = kTfLiteArenaRw; TF_LITE_ENSURE(context, channels_in != 0); const int height = NumElements(input) / channels_in; const int input_offset_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, input_offset_dims)) { TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1); input_offsets_size->data[0] = input_offset_dims[0]; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets, input_offsets_size)); } node->temporaries->data[data->row_sums_index] = data->row_sums_id; TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); row_sums->type = kTfLiteInt32; row_sums->name = ""Conv_row_sums""; row_sums->allocation_type = kTfLiteArenaRwPersistent; const int row_sums_dims[1] = {channels_out}; if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) { TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1); row_sums_size->data[0] = row_sums_dims[0]; TF_LITE_ENSURE_OK( context, context->ResizeTensor(context, row_sums, row_sums_size)); } } } return kTfLiteOk; }"
"static UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman, int transferDir) { UINT32 EndpointAddress, PipeHandle; UINT32 TransferFlags, OutputBufferSize; const BOOL noAck = (RequestField & 0x80000000U) != 0; const UINT32 RequestId = RequestField & 0x7FFFFFFF; if (!pdev || !callback || !s || !udevman) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 12) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, PipeHandle); Stream_Read_UINT32(s, TransferFlags);  Stream_Read_UINT32(s, OutputBufferSize); EndpointAddress = (PipeHandle & 0x000000ff); return pdev->bulk_or_interrupt_transfer( pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck, OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL, urb_bulk_transfer_cb, 10000); }"
"static gchar* get_usage_page_item_string(wmem_allocator_t *pool, guint32 usage_page, guint32 id) { const char *str = NULL; switch (usage_page) { case GENERIC_DESKTOP_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals); break; case SIMULATION_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals); break; case VR_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals); break; case SPORT_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals); break; case GAME_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals); break; case GENERIC_DEVICE_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals); break; case KEYBOARD_KEYPAD_PAGE: str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals); break; case LED_PAGE: str = try_val_to_str(id, usb_hid_led_usage_page_vals); break; case BUTTON_PAGE: str = try_val_to_str(id, usb_hid_button_usage_page_vals); if (!str) str = ""Button %u""; break; case ORDINAL_PAGE: str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals); break; case TELEPHONY_PAGE: str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals); break; case CONSUMER_PAGE: str = try_val_to_str(id, usb_hid_consumer_usage_page_vals); if (!str) str = ""Instance %u""; break; case DIGITIZER_PAGE: str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals); break; case HAPTICS_PAGE: str = try_val_to_str(id, usb_hid_haptic_usage_page_vals); if (id >= 0x2001 && id <= 0x2FFF) str = ""Vendor Waveforms""; break; case PID_PAGE: str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals); break; case UNICODE_PAGE: str = ""Character U+%04X""; break; case EYE_AND_HEAD_TRACKER_PAGE: str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals); break; case ALPHANUMERIC_DISPLAY_PAGE: str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals); break; case SENSOR_PAGE: str = try_val_to_str(id, usb_hid_sensor_usage_page_vals); if (!str) str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges); break; case MEDICAL_INSTRUMENTS_PAGE: str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals); break; case BRAILLE_DISPLAY_PAGE: str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals); break; case LIGHTING_AND_ILLUMINATION_PAGE: str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals); break; case USB_MONITOR_PAGE: str = try_val_to_str(id, usb_hid_monitor_usage_page_vals); break; case USB_ENUMERATED_VALUES_PAGE: str = ""ENUM_%u""; break; case VESA_VIRTUAL_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals); break; case POWER_DEVICE_PAGE: str = try_val_to_str(id, usb_hid_power_device_usage_page_vals); break; case BATTERY_SYSTEM_PAGE: str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals); break; case BARCODE_SCANNER_PAGE: str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals); break; case WEIGHING_PAGE: str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals); break; case MSR_PAGE: str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals); break; case CAMERA_CONTROL_PAGE: str = try_val_to_str(id, usb_hid_camera_control_usage_page_vals); break; case ARCADE_PAGE: str = try_val_to_str(id, usb_hid_arcade_usage_page_vals); break; case FIDO_ALLIANCE_PAGE: str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals); break; default: if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE) str = ""Vendor""; break; } if (!str) str = ""Reserved""; return wmem_strdup_printf(pool, str, id); }"
"int relay_websocket_decode_frame (const unsigned char *buffer, unsigned long long buffer_length, unsigned char *decoded, unsigned long long *decoded_length) { unsigned long long i, index_buffer, length_frame_size, length_frame; unsigned char opcode; *decoded_length = 0; index_buffer = 0; while (index_buffer + 2 <= buffer_length) { opcode = buffer[index_buffer] & 15; if (!(buffer[index_buffer + 1] & 128)) return 0; length_frame_size = 1; length_frame = buffer[index_buffer + 1] & 127; index_buffer += 2; if ((length_frame == 126) || (length_frame == 127)) { length_frame_size = (length_frame == 126) ? 2 : 8; if (buffer_length < 1 + length_frame_size) return 0; length_frame = 0; for (i = 0; i < length_frame_size; i++) { length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8); } index_buffer += length_frame_size; } if (buffer_length < 1 + length_frame_size + 4 + length_frame) return 0; int masks[4]; for (i = 0; i < 4; i++) { masks[i] = (int)((unsigned char)buffer[index_buffer + i]); } index_buffer += 4; switch (opcode) { case WEBSOCKET_FRAME_OPCODE_PING: decoded[*decoded_length] = RELAY_CLIENT_MSG_PING; break; case WEBSOCKET_FRAME_OPCODE_CLOSE: decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE; break; default: decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD; break; } *decoded_length += 1; for (i = 0; i < length_frame; i++) { decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4]; } decoded[*decoded_length + length_frame] = '\0'; *decoded_length += length_frame + 1; index_buffer += length_frame; } return 1; }"
"static int bgp_nlri_get_labels(struct peer *peer, uint8_t *pnt, uint8_t plen, mpls_label_t *label) { uint8_t *data = pnt; uint8_t *lim = pnt + plen; uint8_t llen = 0; uint8_t label_depth = 0; for (; data < lim; data += BGP_LABEL_BYTES) { memcpy(label, data, BGP_LABEL_BYTES); llen += BGP_LABEL_BYTES; bgp_set_valid_label(label); label_depth += 1; if (bgp_is_withdraw_label(label) || label_bos(label)) break; } if (label_depth > 1) zlog_info(""%pBP rcvd UPDATE with label stack %d deep"", peer, label_depth); if (!(bgp_is_withdraw_label(label) || label_bos(label))) flog_warn( EC_BGP_INVALID_LABEL_STACK, ""%pBP rcvd UPDATE with invalid label stack - no bottom of stack"", peer); return llen; }"
"bool minimask_equal(const struct minimask *a, const struct minimask *b) { return !memcmp(a, b, sizeof *a + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))); }"
"static void nl_parse(int fd, struct nlconfig_t *config) { size_t len, size; struct nlmsghdr hdr; char *data, *current; len = read(fd, &hdr, NLMSG_HDRLEN); if (len != NLMSG_HDRLEN) bail(""invalid netlink header length %zu"", len); if (hdr.nlmsg_type == NLMSG_ERROR) bail(""failed to read netlink message""); if (hdr.nlmsg_type != INIT_MSG) bail(""unexpected msg type %d"", hdr.nlmsg_type); size = NLMSG_PAYLOAD(&hdr, 0); current = data = malloc(size); if (!data) bail(""failed to allocate %zu bytes of memory for nl_payload"", size); len = read(fd, data, size); if (len != size) bail(""failed to read netlink payload, %zu != %zu"", len, size); config->data = data; while (current < data + size) { struct nlattr *nlattr = (struct nlattr *)current; size_t payload_len = nlattr->nla_len - NLA_HDRLEN; current += NLA_HDRLEN; switch (nlattr->nla_type) { case CLONE_FLAGS_ATTR: config->cloneflags = readint32(current); break; case ROOTLESS_EUID_ATTR: config->is_rootless_euid = readint8(current); break; case OOM_SCORE_ADJ_ATTR: config->oom_score_adj = current; config->oom_score_adj_len = payload_len; break; case NS_PATHS_ATTR: config->namespaces = current; config->namespaces_len = payload_len; break; case UIDMAP_ATTR: config->uidmap = current; config->uidmap_len = payload_len; break; case GIDMAP_ATTR: config->gidmap = current; config->gidmap_len = payload_len; break; case UIDMAPPATH_ATTR: config->uidmappath = current; config->uidmappath_len = payload_len; break; case GIDMAPPATH_ATTR: config->gidmappath = current; config->gidmappath_len = payload_len; break; case SETGROUP_ATTR: config->is_setgroup = readint8(current); break; default: bail(""unknown netlink message type %d"", nlattr->nla_type); } current += NLA_ALIGN(payload_len); } }"
"int main(int argc, char** argv) { WinsockContext context; string tmpDir = GetTempDirectory(); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); LogHandler::setupStdoutLogger(); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); cxxopts::Options options(""et"", ""Remote shell for the busy and impatient""); try { options.allow_unrecognised_options(); options.positional_help(""""); options.custom_help( ""[OPTION...] [user@]host[:port]\n\n"" ""  Note that 'host' can be a hostname or ipv4 address with or without "" ""a port\n  or an ipv6 address. If the ipv6 address is abbreviated with "" "":: then it must\n  be specfied without a port (use -p,--port).""); options.add_options()                     (""h,help"", ""Print help"")              (""version"", ""Print version"")          (""u,username"", ""Username"")            (""host"", ""Remote host name"", cxxopts::value<std::string>())          (""p,port"", ""Remote machine etserver port"", cxxopts::value<int>()->default_value(""2022""))          (""c,command"", ""Run command on connect"", cxxopts::value<std::string>())          (""terminal-path"", ""Path to etterminal on server side. "" ""Use if etterminal is not on the system path."", cxxopts::value<std::string>())          (""t,tunnel"", ""Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. "" ""10080:80,10443:443, 10090-10092:8000-8002)"", cxxopts::value<std::string>())          (""r,reversetunnel"", ""Reverse Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges"", cxxopts::value<std::string>())          (""jumphost"", ""jumphost between localhost and destination"", cxxopts::value<std::string>())          (""jport"", ""Jumphost machine port"", cxxopts::value<int>()->default_value(""2022""))          (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")          (""macserver"", ""Set when connecting to an macOS server.  Sets "" ""--terminal-path=/usr/local/bin/etterminal"")          (""v,verbose"", ""Enable verbose logging"", cxxopts::value<int>()->default_value(""0""))          (""k,keepalive"", ""Client keepalive duration in seconds"", cxxopts::value<int>())                                      (""logtostdout"", ""Write log to stdout"")                       (""silent"", ""Disable logging"")                                (""N,no-terminal"", ""Do not create a terminal"")                (""f,forward-ssh-agent"", ""Forward ssh-agent socket"")          (""ssh-socket"", ""The ssh-agent socket to forward"", cxxopts::value<std::string>())          (""telemetry"", ""Allow et to anonymously send errors to guide future improvements"", cxxopts::value<bool>()->default_value(""true""))          (""serverfifo"", ""If set, communicate to etserver on the matching fifo name"", cxxopts::value<std::string>()->default_value(""""))          (""ssh-option"", ""Options to pass down to `ssh -o`"", cxxopts::value<std::vector<std::string>>()); options.parse_positional({""host""}); auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } if (result.count(""version"")) { CLOG(INFO, ""stdout"") << ""et version "" << ET_VERSION << endl; exit(0); } el::Loggers::setVerboseLevel(result[""verbose""].as<int>()); if (result.count(""silent"")) { defaultConf.setGlobally(el::ConfigurationType::Enabled, ""false""); } LogHandler::setupLogFiles(&defaultConf, tmpDir, ""etclient"", result.count(""logtostdout""), !result.count(""logtostdout"")); el::Loggers::reconfigureLogger(""default"", defaultConf); el::Helpers::setThreadName(""client-main""); el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler); GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); TelemetryService::create(result[""telemetry""].as<bool>(), tmpDir + ""/.sentry-native-et"", ""Client""); string username = """"; if (result.count(""username"")) { username = result[""username""].as<string>(); } int destinationPort = result[""port""].as<int>(); string destinationHost; if (!result.count(""host"")) { CLOG(INFO, ""stdout"") << ""Missing host to connect to"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } string host_arg = result[""host""].as<std::string>(); if (host_arg.find('@') != string::npos) { int i = host_arg.find('@'); username = host_arg.substr(0, i); host_arg = host_arg.substr(i + 1); } if (host_arg.find(':') != string::npos) { int colon_count = std::count(host_arg.begin(), host_arg.end(), ':'); if (colon_count == 1) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { if (host_arg.find(""::"") != string::npos) { } else { if (colon_count == 7) { } else if (colon_count == 8) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { CLOG(INFO, ""stdout"") << ""Invalid host positional arg: "" << result[""host""].as<std::string>() << endl; exit(1); } } } } destinationHost = host_arg; string host_alias = destinationHost; string jumphost = result.count(""jumphost"") ? result[""jumphost""].as<string>() : """"; int keepaliveDuration = result.count(""keepalive"") ? result[""keepalive""].as<int>() : MAX_CLIENT_KEEP_ALIVE_DURATION; if (keepaliveDuration < 1 || keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) { CLOG(INFO, ""stdout"") << ""Keep-alive duration must between 1 and "" << MAX_CLIENT_KEEP_ALIVE_DURATION << "" seconds"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } Options sshConfigOptions = { NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          0,             0,             0,             0,             0,             NULL,          NULL,          0,             0,             NULL       }; char* home_dir = ssh_get_user_home_dir(); const char* host_from_command = destinationHost.c_str(); ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST, destinationHost.c_str()); parse_ssh_config_file(host_from_command, &sshConfigOptions, string(home_dir) + USER_SSH_CONFIG_PATH); parse_ssh_config_file(host_from_command, &sshConfigOptions, SYSTEM_SSH_CONFIG_PATH); LOG(INFO) << ""Parsed ssh config file, connecting to "" << sshConfigOptions.host; destinationHost = string(sshConfigOptions.host); if (username.empty()) { if (sshConfigOptions.username) { username = string(sshConfigOptions.username); } else { username = string(ssh_get_local_username()); } } if (sshConfigOptions.ProxyJump && jumphost.length() == 0) { string proxyjump = string(sshConfigOptions.ProxyJump); size_t colonIndex = proxyjump.find("":""); if (colonIndex != string::npos) { string userhostpair = proxyjump.substr(0, colonIndex); size_t atIndex = userhostpair.find(""@""); if (atIndex != string::npos) { jumphost = userhostpair.substr(atIndex + 1); } } else { jumphost = proxyjump; } LOG(INFO) << ""ProxyJump found for dst in ssh config: "" << proxyjump; } bool is_jumphost = false; SocketEndpoint socketEndpoint; if (!jumphost.empty()) { is_jumphost = true; LOG(INFO) << ""Setting port to jumphost port""; socketEndpoint.set_name(jumphost); socketEndpoint.set_port(result[""jport""].as<int>()); } else { socketEndpoint.set_name(destinationHost); socketEndpoint.set_port(destinationPort); } shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler()); shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler()); if (!ping(socketEndpoint, clientSocket)) { CLOG(INFO, ""stdout"") << ""Could not reach the ET server: "" << socketEndpoint.name() << "":"" << socketEndpoint.port() << endl; exit(1); } int jport = result[""jport""].as<int>(); string serverFifo = """"; if (result[""serverfifo""].as<string>() != """") { serverFifo = result[""serverfifo""].as<string>(); } std::vector<string> ssh_options; if (result.count(""ssh-option"")) { ssh_options = result[""ssh-option""].as<std::vector<string>>(); } string etterminal_path = """"; if (result.count(""macserver"") > 0) { etterminal_path = ""/usr/local/bin/etterminal""; } if (result.count(""etterminal_path"")) { etterminal_path = result[""terminal-path""].as<string>(); } string idpasskeypair = SshSetupHandler::SetupSsh( username, destinationHost, host_alias, destinationPort, jumphost, jport, result.count(""x"") > 0, result[""verbose""].as<int>(), etterminal_path, serverFifo, ssh_options); string id = """", passkey = """"; idpasskeypair.erase(idpasskeypair.find_last_not_of("" \n\r\t"") + 1); size_t slashIndex = idpasskeypair.find(""/""); if (slashIndex == string::npos) { STFATAL << ""Invalid idPasskey id/key pair: "" << idpasskeypair; } else { id = idpasskeypair.substr(0, slashIndex); passkey = idpasskeypair.substr(slashIndex + 1); } if (passkey.length() != 32) { STFATAL << ""Invalid/missing passkey: "" << passkey << "" "" << passkey.length(); } shared_ptr<Console> console; if (!result.count(""N"")) { console.reset(new PsuedoTerminalConsole()); } bool forwardAgent = result.count(""f"") > 0; string sshSocket = """"; #ifndef WIN32 if (sshConfigOptions.identity_agent) { sshSocket = string(sshConfigOptions.identity_agent); } forwardAgent |= sshConfigOptions.forward_agent; #endif if (result.count(""ssh-socket"")) { sshSocket = result[""ssh-socket""].as<string>(); } TelemetryService::get()->logToDatadog(""Session Started"", el::Level::Info, __FILE__, __LINE__); string tunnel_arg = result.count(""tunnel"") ? result[""tunnel""].as<string>() : """"; string r_tunnel_arg = result.count(""reversetunnel"") ? result[""reversetunnel""].as<string>() : """"; TerminalClient terminalClient(clientSocket, clientPipeSocket, socketEndpoint, id, passkey, console, is_jumphost, tunnel_arg, r_tunnel_arg, forwardAgent, sshSocket, keepaliveDuration); terminalClient.run(result.count(""command"") ? result[""command""].as<string>() : """"); } catch (TunnelParseException& tpe) { handleParseException(tpe, options); } catch (cxxopts::OptionException& oe) { handleParseException(oe, options); } #ifdef WIN32 WSACleanup(); #endif TelemetryService::get()->shutdown(); TelemetryService::destroy(); el::Helpers::uninstallPreRollOutCallback(); return 0; }"
"static void credential_write_item(FILE *fp, const char *key, const char *value) { if (!value) return; fprintf(fp, ""%s=%s\n"", key, value); }"
"j9object_t    resolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags) { J9UTF8 *utf8Wrapper; j9object_t stringRef; J9ROMStringRef *romStringRef; Trc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP); romStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex]; utf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef); Trc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper)); stringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN); if (stringRef != NULL) { J9Class *clazz = J9_CLASS_FROM_CP(ramCP); J9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex]; j9object_t *stringObjectP = &ramStringRef->stringObject; J9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef); } Trc_VM_resolveStringRef_Exit(vmStruct, stringRef); return stringRef; }"
"static guint32 dissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){ guint32 tag_offset_start = offset + tag_number*4*2; guint32 tag_offset = 0, total_tag_len = 0; gint32 tag_len; while(tag_number){ proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type; guint32 offset_end, tag; const guint8* tag_str; ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA); tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value); ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); tag = tvb_get_ntohl(tvb, offset); proto_item_append_text(ti_type, "" (%s)"", val_to_str(tag, tag_vals, ""Unknown"")); proto_item_append_text(ti_tag, "": %s (%s)"", tag_str, val_to_str(tag, tag_vals, ""Unknown"")); offset += 4; proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset_end = tvb_get_letohl(tvb, offset); tag_len = offset_end - tag_offset; total_tag_len += tag_len; ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len); proto_item_append_text(ti_tag, "" (l=%u)"", tag_len); proto_item_set_generated(ti_len); offset += 4; if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){ tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset); offset_end = tag_offset + tag_len; expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length); } proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); switch(tag){ case TAG_SNI: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += tag_len; break; case TAG_VERS: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += 4; break; case TAG_SNO: proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); tag_offset += tag_len; break; case TAG_AEAD: while(offset_end - tag_offset >= 4){ proto_tree *ti_aead; ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA); proto_item_append_text(ti_aead, "" (%s)"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, ""Unknown"")); proto_item_append_text(ti_tag, "", %s"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, ""Unknown"")); tag_offset += 4; } break; case TAG_SCID: proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); tag_offset += tag_len; break; case TAG_TIME: proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN); proto_item_append_text(ti_tag, "": %u"", tvb_get_letohl(tvb, tag_offset_start + tag_offset)); tag_offset += 4; break; case TAG_ALPN: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += 4; break; case TAG_PUBS: proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN); tag_offset += 2; while(offset_end - tag_offset >= 3){ proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN); tag_offset += 3; } break; case TAG_KEXS: while(offset_end - tag_offset >= 4){ proto_tree *ti_kexs; ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA); proto_item_append_text(ti_kexs, "" (%s)"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, ""Unknown"")); proto_item_append_text(ti_tag, "", %s"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, ""Unknown"")); tag_offset += 4; } break; case TAG_NONC: proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA); tag_offset += 32; break; default: proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded, ""Dissector for FB Zero Tag"" "" %s (%s) code not implemented, Contact"" "" Wireshark developers if you want this supported"", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, ""Unknown"")); tag_offset += tag_len; break; } if(tag_offset != offset_end){ proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset); tag_offset = offset_end; } tag_number--; } return offset + total_tag_len; }"
"int fit_config_verify_required_sigs(const void *fit, int conf_noffset, const void *sig_blob) { int noffset; int sig_node; int verified = 0; int reqd_sigs = 0; bool reqd_policy_all = true; const char *reqd_mode; sig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME); if (sig_node < 0) { debug(""%s: No signature node found: %s\n"", __func__, fdt_strerror(sig_node)); return 0; } reqd_mode = fdt_getprop(sig_blob, sig_node, ""required-mode"", NULL); if (reqd_mode && !strcmp(reqd_mode, ""any"")) reqd_policy_all = false; debug(""%s: required-mode policy set to '%s'\n"", __func__, reqd_policy_all ? ""all"" : ""any""); fdt_for_each_subnode(noffset, sig_blob, sig_node) { const char *required; int ret; required = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED, NULL); if (!required || strcmp(required, ""conf"")) continue; reqd_sigs++; ret = fit_config_verify_sig(fit, conf_noffset, sig_blob, noffset); if (ret) { if (reqd_policy_all) { printf(""Failed to verify required signature '%s'\n"", fit_get_name(sig_blob, noffset, NULL)); return ret; } } else { verified++; if (!reqd_policy_all) break; } } if (reqd_sigs && !verified) { printf(""Failed to verify 'any' of the required signature(s)\n""); return -EPERM; } return 0; }"
"static ssize_t module_gzip_decompress(struct load_info *info, const void *buf, size_t size) { struct z_stream_s s = { 0 }; size_t new_size = 0; size_t gzip_hdr_len; ssize_t retval; int rc; gzip_hdr_len = module_gzip_header_len(buf, size); if (!gzip_hdr_len) { pr_err(""not a gzip compressed module\n""); return -EINVAL; } s.next_in = buf + gzip_hdr_len; s.avail_in = size - gzip_hdr_len; s.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL); if (!s.workspace) return -ENOMEM; rc = zlib_inflateInit2(&s, -MAX_WBITS); if (rc != Z_OK) { pr_err(""failed to initialize decompressor: %d\n"", rc); retval = -EINVAL; goto out; } do { struct page *page = module_get_next_page(info); if (!page) { retval = -ENOMEM; goto out_inflate_end; } s.next_out = kmap_local_page(page); s.avail_out = PAGE_SIZE; rc = zlib_inflate(&s, 0); kunmap_local(s.next_out); new_size += PAGE_SIZE - s.avail_out; } while (rc == Z_OK); if (rc != Z_STREAM_END) { pr_err(""decompression failed with status %d\n"", rc); retval = -EINVAL; goto out_inflate_end; } retval = new_size; out_inflate_end: zlib_inflateEnd(&s); out: kfree(s.workspace); return retval; }"
"static njs_object_prop_t * njs_descriptor_prop(njs_vm_t *vm, const njs_value_t *name, const njs_value_t *desc) { njs_int_t           ret; njs_bool_t          data, accessor; njs_value_t         value; njs_function_t      *getter, *setter; njs_object_prop_t   *prop; njs_lvlhsh_query_t  lhq; static const njs_value_t  get_string = njs_string(""get""); if (!njs_is_object(desc)) { njs_type_error(vm, ""property descriptor must be an object""); return NULL; } prop = njs_object_prop_alloc(vm, name, &njs_value_invalid, NJS_ATTRIBUTE_UNSET); if (njs_slow_path(prop == NULL)) { return NULL; } data = 0; accessor = 0; getter = NJS_PROP_PTR_UNSET; setter = NJS_PROP_PTR_UNSET; njs_object_property_init(&lhq, &get_string, NJS_GET_HASH); ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { if (njs_is_defined(&value) && !njs_is_function(&value)) { njs_type_error(vm, ""Getter must be a function""); return NULL; } accessor = 1; getter = njs_is_function(&value) ? njs_function(&value) : NULL; } lhq.key = njs_str_value(""set""); lhq.key_hash = NJS_SET_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { if (njs_is_defined(&value) && !njs_is_function(&value)) { njs_type_error(vm, ""Setter must be a function""); return NULL; } accessor = 1; setter = njs_is_function(&value) ? njs_function(&value) : NULL; } lhq.key = njs_str_value(""value""); lhq.key_hash = NJS_VALUE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { data = 1; njs_value_assign(njs_prop_value(prop), &value); } lhq.key = njs_str_value(""writable""); lhq.key_hash = NJS_WRITABABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { data = 1; prop->writable = njs_is_true(&value); } if (accessor && data) { njs_type_error(vm, ""Cannot both specify accessors "" ""and a value or writable attribute""); return NULL; } lhq.key = njs_str_value(""enumerable""); lhq.key_hash = NJS_ENUMERABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { prop->enumerable = njs_is_true(&value); } lhq.key = njs_str_value(""configurable""); lhq.key_hash = NJS_CONFIGURABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { prop->configurable = njs_is_true(&value); } if (accessor) { prop->type = NJS_ACCESSOR; njs_prop_getter(prop) = getter; njs_prop_setter(prop) = setter; } return prop; }"
"int nbd_unlocked_opt_go (struct nbd_handle *h) { int err; nbd_completion_callback c = { .callback = go_complete, .user_data = &err }; int r = nbd_unlocked_aio_opt_go (h, &c); if (r == -1) return r; r = wait_for_option (h); if (r == 0 && err) { assert (nbd_internal_is_state_negotiating (get_next_state (h))); set_error (err, ""server replied with error to opt_go request""); return -1; } if (r == 0) assert (nbd_internal_is_state_ready (get_next_state (h))); return r; }"
"Status FrameDecoder::ProcessDCGlobal(BitReader* br) { PROFILER_FUNC; PassesSharedState& shared = dec_state_->shared_storage; if (shared.frame_header.flags & FrameHeader::kPatches) { bool uses_extra_channels = false; JXL_RETURN_IF_ERROR(shared.image_features.patches.Decode( br, frame_dim_.xsize_padded, frame_dim_.ysize_padded, &uses_extra_channels)); if (uses_extra_channels && frame_header_.upsampling != 1) { for (size_t ecups : frame_header_.extra_channel_upsampling) { if (ecups != frame_header_.upsampling) { return JXL_FAILURE( ""Cannot use extra channels in patches if color channels are "" ""subsampled differently from extra channels""); } } } } else { shared.image_features.patches.Clear(); } shared.image_features.splines.Clear(); if (shared.frame_header.flags & FrameHeader::kSplines) { JXL_RETURN_IF_ERROR(shared.image_features.splines.Decode( br, frame_dim_.xsize * frame_dim_.ysize)); } if (shared.frame_header.flags & FrameHeader::kNoise) { JXL_RETURN_IF_ERROR(DecodeNoise(br, &shared.image_features.noise_params)); } JXL_RETURN_IF_ERROR(dec_state_->shared_storage.matrices.DecodeDC(br)); if (frame_header_.encoding == FrameEncoding::kVarDCT) { JXL_RETURN_IF_ERROR( jxl::DecodeGlobalDCInfo(br, decoded_->IsJPEG(), dec_state_, pool_)); } if (shared.frame_header.flags & FrameHeader::kSplines) { JXL_RETURN_IF_ERROR(shared.image_features.splines.InitializeDrawCache( frame_dim_.xsize, frame_dim_.ysize, dec_state_->shared->cmap)); } Status dec_status = modular_frame_decoder_.DecodeGlobalInfo( br, frame_header_, allow_partial_dc_global_); if (dec_status.IsFatalError()) return dec_status; if (dec_status) { decoded_dc_global_ = true; } return dec_status; }"
"int TIFFInitJBIG(TIFF* tif, int scheme) { (void)scheme; assert(scheme == COMPRESSION_JBIG); tif->tif_flags |= TIFF_NOBITREV; tif->tif_flags &= ~TIFF_MAPPED; tif->tif_setupdecode = JBIGSetupDecode; tif->tif_decodestrip = JBIGDecode; tif->tif_setupencode = JBIGSetupEncode; tif->tif_encodestrip = JBIGEncode; return 1; }"
"int __nla_validate(const struct nlattr *head, int len, int maxtype, const struct nla_policy *policy, unsigned int validate, struct netlink_ext_ack *extack) { return __nla_validate_parse(head, len, maxtype, policy, validate, extack, NULL); }"
"static void reg_set_min_max_inv(struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u8 opcode, bool is_jmp32) { s64 sval; if (__is_pointer_value(false, false_reg)) return; val = is_jmp32 ? (u32)val : val; sval = is_jmp32 ? (s64)(s32)val : (s64)val; switch (opcode) { case BPF_JEQ: case BPF_JNE: { struct bpf_reg_state *reg = opcode == BPF_JEQ ? true_reg : false_reg; if (is_jmp32) { u64 old_v = reg->var_off.value; u64 hi_mask = ~0xffffffffULL; reg->var_off.value = (old_v & hi_mask) | val; reg->var_off.mask &= hi_mask; } else { __mark_reg_known(reg, val); } break; } case BPF_JSET: false_reg->var_off = tnum_and(false_reg->var_off, tnum_const(~val)); if (is_power_of_2(val)) true_reg->var_off = tnum_or(true_reg->var_off, tnum_const(val)); break; case BPF_JGE: case BPF_JGT: { u64 false_umin = opcode == BPF_JGT ? val    : val + 1; u64 true_umax = opcode == BPF_JGT ? val - 1 : val; if (is_jmp32) { false_umin += gen_hi_min(false_reg->var_off); true_umax += gen_hi_max(true_reg->var_off); } false_reg->umin_value = max(false_reg->umin_value, false_umin); true_reg->umax_value = min(true_reg->umax_value, true_umax); break; } case BPF_JSGE: case BPF_JSGT: { s64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1; s64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval; if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg)) break; false_reg->smin_value = max(false_reg->smin_value, false_smin); true_reg->smax_value = min(true_reg->smax_value, true_smax); break; } case BPF_JLE: case BPF_JLT: { u64 false_umax = opcode == BPF_JLT ? val    : val - 1; u64 true_umin = opcode == BPF_JLT ? val + 1 : val; if (is_jmp32) { false_umax += gen_hi_max(false_reg->var_off); true_umin += gen_hi_min(true_reg->var_off); } false_reg->umax_value = min(false_reg->umax_value, false_umax); true_reg->umin_value = max(true_reg->umin_value, true_umin); break; } case BPF_JSLE: case BPF_JSLT: { s64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1; s64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval; if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg)) break; false_reg->smax_value = min(false_reg->smax_value, false_smax); true_reg->smin_value = max(true_reg->smin_value, true_smin); break; } default: break; } __reg_deduce_bounds(false_reg); __reg_deduce_bounds(true_reg); __reg_bound_offset(false_reg); __reg_bound_offset(true_reg); if (is_jmp32) { __reg_bound_offset32(false_reg); __reg_bound_offset32(true_reg); } __update_reg_bounds(false_reg); __update_reg_bounds(true_reg); }"
"static void gfs2_evict_inode(struct inode *inode) { struct super_block *sb = inode->i_sb; struct gfs2_sbd *sdp = sb->s_fs_info; struct gfs2_inode *ip = GFS2_I(inode); struct gfs2_holder gh; int ret; if (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr) goto out; gfs2_holder_mark_uninitialized(&gh); ret = evict_should_delete(inode, &gh); if (ret == SHOULD_DEFER_EVICTION) goto out; if (ret == SHOULD_DELETE_DINODE) ret = evict_unlinked_inode(inode); else ret = evict_linked_inode(inode); if (gfs2_rs_active(&ip->i_res)) gfs2_rs_deltree(&ip->i_res); if (gfs2_holder_initialized(&gh)) gfs2_glock_dq_uninit(&gh); if (ret && ret != GLR_TRYFAILED && ret != -EROFS) fs_warn(sdp, ""gfs2_evict_inode: %d\n"", ret); out: truncate_inode_pages_final(&inode->i_data); if (ip->i_qadata) gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0); gfs2_rs_deltree(&ip->i_res); gfs2_ordered_del_inode(ip); clear_inode(inode); gfs2_dir_hash_inval(ip); if (gfs2_holder_initialized(&ip->i_iopen_gh)) { struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl; glock_clear_object(gl, ip); gfs2_glock_hold(gl); ip->i_iopen_gh.gh_flags |= GL_NOCACHE; gfs2_glock_dq_uninit(&ip->i_iopen_gh); gfs2_glock_put_eventually(gl); } if (ip->i_gl) { glock_clear_object(ip->i_gl, ip); wait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE); gfs2_glock_add_to_lru(ip->i_gl); gfs2_glock_put_eventually(ip->i_gl); ip->i_gl = NULL; } }"
"static void slc_bump(struct slcan *sl) { struct sk_buff *skb; struct can_frame cf; int i, tmp; u32 tmpid; char *cmd = sl->rbuff; cf.can_id = 0; switch (*cmd) { case 'r': cf.can_id = CAN_RTR_FLAG; case 't': cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1; break; case 'R': cf.can_id = CAN_RTR_FLAG; case 'T': cf.can_id |= CAN_EFF_FLAG; cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1; break; default: return; } if (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid)) return; cf.can_id |= tmpid; if (cf.can_dlc >= '0' && cf.can_dlc < '9') cf.can_dlc -= '0'; else return; *(u64 *) (&cf.data) = 0;  if (!(cf.can_id & CAN_RTR_FLAG)) { for (i = 0; i < cf.can_dlc; i++) { tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] = (tmp << 4); tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] |= tmp; } } skb = dev_alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv)); if (!skb) return; skb->dev = sl->dev; skb->protocol = htons(ETH_P_CAN); skb->pkt_type = PACKET_BROADCAST; skb->ip_summed = CHECKSUM_UNNECESSARY; can_skb_reserve(skb); can_skb_prv(skb)->ifindex = sl->dev->ifindex; memcpy(skb_put(skb, sizeof(struct can_frame)), &cf, sizeof(struct can_frame)); netif_rx_ni(skb); sl->dev->stats.rx_packets++; sl->dev->stats.rx_bytes += cf.can_dlc; }"
"static void rtps_util_add_coherent_set_general_cases_case( proto_tree *tree, tvbuff_t *tvb, guint64 coherent_seq_number, coherent_set_entity_info *coherent_set_entity_info_object) { coherent_set_entity_info *register_entry; proto_tree *marked_item_tree; coherent_set_info *coherent_set_info_entry; coherent_set_key coherent_set_info_key; coherent_set_entity_info_object->coherent_set_seq_number = coherent_seq_number; register_entry = (coherent_set_entity_info*)wmem_map_lookup(coherent_set_tracking.entities_using_map, &coherent_set_entity_info_object->guid); if (!register_entry) { register_entry = (coherent_set_entity_info*)wmem_memdup(wmem_file_scope(), coherent_set_entity_info_object, sizeof(coherent_set_entity_info)); wmem_map_insert( coherent_set_tracking.entities_using_map, &register_entry->guid, register_entry); } coherent_set_info_key.guid = coherent_set_entity_info_object->guid; coherent_set_info_key.coherent_set_seq_number = coherent_seq_number; coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key); if (!coherent_set_info_entry) { coherent_set_info_entry = wmem_new0(wmem_file_scope(), coherent_set_info); coherent_set_info_entry->key = (coherent_set_key*)wmem_memdup(wmem_file_scope(), &coherent_set_info_key, sizeof(coherent_set_key)); coherent_set_info_entry->is_set = FALSE; wmem_map_insert( coherent_set_tracking.coherent_set_registry_map, coherent_set_info_entry->key, coherent_set_info_entry); } if (coherent_set_info_entry->writer_seq_number < coherent_set_entity_info_object->writer_seq_number) { coherent_set_info_entry->writer_seq_number = coherent_set_entity_info_object->writer_seq_number; } if (coherent_set_entity_info_object->coherent_set_seq_number == coherent_set_entity_info_object->writer_seq_number) { marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_start, tvb, 0, 0, coherent_seq_number); proto_item_set_generated(marked_item_tree); if (coherent_set_entity_info_object->coherent_set_seq_number > register_entry->coherent_set_seq_number && coherent_set_entity_info_object->writer_seq_number - 1 == register_entry->writer_seq_number) { coherent_set_info *previous_entry; marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, register_entry->coherent_set_seq_number); proto_item_set_generated(marked_item_tree); coherent_set_info_key.coherent_set_seq_number = register_entry->writer_seq_number; coherent_set_info_key.guid = register_entry->guid; previous_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key); if (previous_entry) { previous_entry->is_set = TRUE; } } } if (!coherent_set_info_entry->is_set) { coherent_set_info_key.coherent_set_seq_number = coherent_seq_number - 1; if (coherent_set_entity_info_object->coherent_set_seq_number == RTPS_SEQUENCENUMBER_UNKNOWN) { register_entry->coherent_set_seq_number = coherent_set_entity_info_object->coherent_set_seq_number; marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number); proto_item_set_generated(marked_item_tree); coherent_set_info_entry->is_set = TRUE; } } else if (coherent_set_info_entry->writer_seq_number == coherent_set_entity_info_object->writer_seq_number) { proto_tree *ti; ti = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number); proto_item_set_generated(ti); } coherent_set_entity_info_object->expected_coherent_set_end_writers_seq_number = coherent_set_entity_info_object->writer_seq_number + 1; *register_entry = *coherent_set_entity_info_object; }"
"static int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info) { int ret_val; struct sk_buff *ans_skb = NULL; u32 nlsze_mult = 1; void *data; u32 doi; struct nlattr *nla_a; struct nlattr *nla_b; struct cipso_v4_doi *doi_def; u32 iter; if (!info->attrs[NLBL_CIPSOV4_A_DOI]) { ret_val = -EINVAL; goto list_failure; } list_start: ans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE * nlsze_mult, GFP_KERNEL); if (ans_skb == NULL) { ret_val = -ENOMEM; goto list_failure; } data = genlmsg_put_reply(ans_skb, info, &netlbl_cipsov4_gnl_family, 0, NLBL_CIPSOV4_C_LIST); if (data == NULL) { ret_val = -ENOMEM; goto list_failure; } doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]); rcu_read_lock(); doi_def = cipso_v4_doi_getdef(doi); if (doi_def == NULL) { ret_val = -EINVAL; goto list_failure_lock; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type); if (ret_val != 0) goto list_failure_lock; nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_TAGLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_failure_lock; } for (iter = 0; iter < CIPSO_V4_TAG_MAXCNT && doi_def->tags[iter] != CIPSO_V4_TAG_INVALID; iter++) { ret_val = nla_put_u8(ans_skb, NLBL_CIPSOV4_A_TAG, doi_def->tags[iter]); if (ret_val != 0) goto list_failure_lock; } nla_nest_end(ans_skb, nla_a); switch (doi_def->type) { case CIPSO_V4_MAP_TRANS: nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSLVLLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_failure_lock; } for (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++) { if (doi_def->map.std->lvl.local[iter] == CIPSO_V4_INV_LVL) continue; nla_b = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSLVL); if (nla_b == NULL) { ret_val = -ENOMEM; goto list_retry; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSLVLLOC, iter); if (ret_val != 0) goto list_retry; ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSLVLREM, doi_def->map.std->lvl.local[iter]); if (ret_val != 0) goto list_retry; nla_nest_end(ans_skb, nla_b); } nla_nest_end(ans_skb, nla_a); nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSCATLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_retry; } for (iter = 0; iter < doi_def->map.std->cat.local_size; iter++) { if (doi_def->map.std->cat.local[iter] == CIPSO_V4_INV_CAT) continue; nla_b = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSCAT); if (nla_b == NULL) { ret_val = -ENOMEM; goto list_retry; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSCATLOC, iter); if (ret_val != 0) goto list_retry; ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSCATREM, doi_def->map.std->cat.local[iter]); if (ret_val != 0) goto list_retry; nla_nest_end(ans_skb, nla_b); } nla_nest_end(ans_skb, nla_a); break; } rcu_read_unlock(); genlmsg_end(ans_skb, data); return genlmsg_reply(ans_skb, info); list_retry: if (nlsze_mult < 4) { rcu_read_unlock(); kfree_skb(ans_skb); nlsze_mult *= 2; goto list_start; } list_failure_lock: rcu_read_unlock(); list_failure: kfree_skb(ans_skb); return ret_val; }"
"struct expr_parse_ctx *expr__ctx_new(void) { struct expr_parse_ctx *ctx; ctx = malloc(sizeof(struct expr_parse_ctx)); if (!ctx) return NULL; ctx->ids = hashmap__new(key_hash, key_equal, NULL); ctx->runtime = 0; return ctx; }"
"void gf_bifs_dec_name(GF_BitStream *bs, char *name) { u32 i = 0; while (1) { name[i] = gf_bs_read_int(bs, 8); if (!name[i]) break; i++; } }"
"static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh, int ifindex) { struct bcm_op *op, *n; list_for_each_entry_safe(op, n, ops, list) { if ((op->can_id == mh->can_id) && (op->ifindex == ifindex) && (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) { if (op->ifindex) { if (op->rx_reg_dev) { struct net_device *dev; dev = dev_get_by_index(sock_net(op->sk), op->ifindex); if (dev) { bcm_rx_unreg(dev, op); dev_put(dev); } } } else can_rx_unregister(sock_net(op->sk), NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op); list_del(&op->list); bcm_remove_op(op); return 1;  } } return 0;  }"
void UserAppsModel::openAppUrl(const QUrl &url) { QDesktopServices::openUrl(url); }
"static bool ok_csv_circular_buffer_expand(ok_csv_circular_buffer *buffer) { size_t new_capacity = buffer->capacity * 2; uint8_t *new_data = malloc(new_capacity); if (!new_data) { return false; } else { const size_t readable1 = ok_csv_circular_buffer_readable(buffer); const size_t readable2 = buffer->length - readable1; memcpy(new_data, buffer->data + buffer->start, readable1); memcpy(new_data + readable1, buffer->data, readable2); free(buffer->data); buffer->data = new_data; buffer->capacity = new_capacity; buffer->start = 0; return true; } }"
"static ssize_t smtcfb_read(struct fb_info *info, char __user *buf, size_t count, loff_t *ppos) { unsigned long p = *ppos; u32 *buffer, *dst; u32 __iomem *src; int c, i, cnt = 0, err = 0; unsigned long total_size; if (!info || !info->screen_base) return -ENODEV; if (info->state != FBINFO_STATE_RUNNING) return -EPERM; total_size = info->screen_size; if (total_size == 0) total_size = info->fix.smem_len; if (p >= total_size) return 0; if (count >= total_size) count = total_size; if (count + p > total_size) count = total_size - p; buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL); if (!buffer) return -ENOMEM; src = (u32 __iomem *)(info->screen_base + p); if (info->fbops->fb_sync) info->fbops->fb_sync(info); while (count) { c = (count > PAGE_SIZE) ? PAGE_SIZE : count; dst = buffer; for (i = c >> 2; i--;) { *dst = fb_readl(src++); *dst = big_swap(*dst); dst++; } if (c & 3) { u8 *dst8 = (u8 *)dst; u8 __iomem *src8 = (u8 __iomem *)src; for (i = c & 3; i--;) { if (i & 1) { *dst8++ = fb_readb(++src8); } else { *dst8++ = fb_readb(--src8); src8 += 2; } } src = (u32 __iomem *)src8; } if (copy_to_user(buf, buffer, c)) { err = -EFAULT; break; } *ppos += c; buf += c; cnt += c; count -= c; } kfree(buffer); return (err) ? err : cnt; }"
"static int io_close(struct io_kiocb *req, bool force_nonblock, struct io_comp_state *cs) { struct io_close *close = &req->close; int ret; if (!close->put_file) { ret = close_fd_get_file(close->fd, &close->put_file); if (ret < 0) return (ret == -ENOENT) ? -EBADF : ret; } if (close->put_file->f_op->flush && force_nonblock) { req->work.flags |= IO_WQ_WORK_NO_CANCEL; req->flags &= ~REQ_F_NOWAIT; req->flags |= REQ_F_NO_FILE_TABLE; return -EAGAIN; } ret = filp_close(close->put_file, req->work.identity->files); if (ret < 0) req_set_fail_links(req); fput(close->put_file); close->put_file = NULL; __io_req_complete(req, ret, 0, cs); return 0; }"
"void Compute(OpKernelContext* context) override { const Tensor& rhs = context->input(1); context->forward_ref_input_to_ref_output(0, 0); AllocatorAttributes attr; if (!relax_constraints_) { attr.set_gpu_compatible(true); attr.set_nic_compatible(true); } { mutex_lock l(*context->input_ref_mutex(0)); const Tensor& old_lhs = context->mutable_input(0,  true); const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape()); if (validate_shape_) { OP_REQUIRES(context, same_shape, errors::InvalidArgument( ""Assign requires shapes of both tensors to match. "" ""lhs shape= "", old_lhs.shape().DebugString(), "" rhs shape= "", rhs.shape().DebugString())); } if (old_lhs.IsInitialized() && old_lhs.shape().num_elements() == rhs.shape().num_elements()) { Tensor reshaped_old_lhs; if (same_shape) { reshaped_old_lhs = old_lhs; } else { CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape())); context->replace_ref_input(0, reshaped_old_lhs, true); } if (use_exclusive_lock_) { Copy(context, &reshaped_old_lhs, rhs); return; } } else { std::unique_ptr<Tensor> input_alias = context->forward_input( 1, OpKernelContext::Params::kNoReservation , rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr); if (input_alias != nullptr) { context->replace_ref_input(0, *input_alias,  true); return; } Tensor copy_tensor; OP_REQUIRES_OK(context, context->allocate_temp(old_lhs.dtype(), rhs.shape(), &copy_tensor, attr)); context->clear_recorded_memory(); context->replace_ref_input(0, copy_tensor,  true); if (use_exclusive_lock_) { Copy(context, &copy_tensor, rhs); return; } } } Tensor old_unlocked_lhs = context->mutable_input(0,  false); Copy(context, &old_unlocked_lhs, rhs); }"
"static void axfm(RCore *core) { RVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX); if (refs && !RVecAnalRef_empty (refs)) { RVecAnalRef_sort (refs, compare_ref); ut64 last_addr = UT64_MAX; RAnalRef *ref; R_VEC_FOREACH (refs, ref) { const bool is_first = ref->addr != last_addr; const char *name; if (is_first) { name = axtm_name (core, ref->addr); r_cons_printf (""0x%""PFMT64x"": %s\n"", ref->addr, name? name: ""?""); } name = axtm_name (core, ref->at); r_cons_printf (""  0x%""PFMT64x"": %s\n"", ref->at, name? name: ""?""); last_addr = ref->addr; } } RVecAnalRef_free (refs); }"
"PJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port( pjmedia_vid_conf *vid_conf, unsigned src_slot, unsigned sink_slot) { vconf_port *src_port, *dst_port; unsigned i, j; PJ_ASSERT_RETURN(vid_conf && src_slot<vid_conf->opt.max_slot_cnt &&  sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL); pj_mutex_lock(vid_conf->mutex); src_port = vid_conf->ports[src_slot]; dst_port = vid_conf->ports[sink_slot]; if (!src_port || !dst_port) { pj_mutex_unlock(vid_conf->mutex); return PJ_EINVAL; } for (i=0; i<src_port->listener_cnt; ++i) { if (src_port->listener_slots[i] == sink_slot) break; } for (j=0; j<dst_port->transmitter_cnt; ++j) { if (dst_port->transmitter_slots[j] == src_slot) break; } if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) { unsigned k; pj_assert(src_port->listener_cnt > 0 &&  src_port->listener_cnt < vid_conf->opt.max_slot_cnt); pj_assert(dst_port->transmitter_cnt > 0 &&  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt); for (k=0; k<dst_port->transmitter_cnt; ++k) cleanup_render_state(dst_port, k); pj_array_erase(src_port->listener_slots, sizeof(unsigned),  src_port->listener_cnt, i); pj_array_erase(dst_port->transmitter_slots, sizeof(unsigned),  dst_port->transmitter_cnt, j); --src_port->listener_cnt; --dst_port->transmitter_cnt; update_render_state(vid_conf, dst_port); --vid_conf->connect_cnt; if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) { pj_status_t status; status = pjmedia_clock_stop(vid_conf->clock); if (status != PJ_SUCCESS) { PJ_PERROR(4, (THIS_FILE, status, ""Failed to stop clock"")); return status; } } PJ_LOG(4,(THIS_FILE, ""Port %d (%.*s) stop transmitting to port %d (%.*s)"", src_slot, (int)src_port->name.slen, src_port->name.ptr, sink_slot, (int)dst_port->name.slen, dst_port->name.ptr)); } pj_mutex_unlock(vid_conf->mutex); return PJ_SUCCESS; }"
"static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt,  const pj_uint8_t *start, const pj_uint8_t *max, pj_str_t *name) { const pj_uint8_t *p; pj_status_t status; if (rec_counter > 10) { return PJLIB_UTIL_EDNSINNAMEPTR; } p = start; while (*p) { if ((*p & 0xc0) == 0xc0) { pj_uint16_t offset; pj_memcpy(&offset, p, 2); offset ^= pj_htons((pj_uint16_t)(0xc0 << 8)); offset = pj_ntohs(offset); if (offset >= max - pkt) return PJLIB_UTIL_EDNSINNAMEPTR; status = get_name(rec_counter+1, pkt, pkt + offset, max, name); if (status != PJ_SUCCESS) return status; return PJ_SUCCESS; } else { unsigned label_len = *p; if (pkt+label_len > max) return PJLIB_UTIL_EDNSINNAMEPTR; pj_memcpy(name->ptr + name->slen, p+1, label_len); name->slen += label_len; p += label_len + 1; if (*p != 0) { *(name->ptr + name->slen) = '.'; ++name->slen; } if (p >= max) return PJLIB_UTIL_EDNSINSIZE; } } return PJ_SUCCESS; }"
"static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id) { GF_List *list = NULL, *alt_list = NULL; GF_NALUFFParam *sl; u32 i, count; u32 crc = gf_crc_32(data, size); if (ctx->codecid==GF_CODECID_HEVC) { switch (ps_type) { case GF_HEVC_NALU_VID_PARAM: if (!ctx->vps) ctx->vps = gf_list_new(); list = ctx->vps; break; case GF_HEVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_HEVC_NALU_PIC_PARAM: list = ctx->pps; break; default: assert(0); return; } } else if (ctx->codecid==GF_CODECID_VVC) { switch (ps_type) { case GF_VVC_NALU_VID_PARAM: if (!ctx->vps) ctx->vps = gf_list_new(); list = ctx->vps; break; case GF_VVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_VVC_NALU_PIC_PARAM: list = ctx->pps; break; case GF_VVC_NALU_DEC_PARAM: if (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new(); list = ctx->vvc_dci; break; case GF_VVC_NALU_APS_PREFIX: if (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new(); list = ctx->vvc_aps_pre; break; default: assert(0); return; } } else { switch (ps_type) { case GF_AVC_NALU_SVC_SUBSEQ_PARAM: case GF_AVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_AVC_NALU_PIC_PARAM: list = ctx->pps; alt_list = ctx->pps_svc; break; case GF_AVC_NALU_SEQ_PARAM_EXT: if (!ctx->sps_ext) ctx->sps_ext = gf_list_new(); list = ctx->sps_ext; break; default: assert(0); return; } } sl = NULL; count = gf_list_count(list); for (i=0; i<count; i++) { sl = gf_list_get(list, i); if (sl->id != ps_id) { sl = NULL; continue; } if (sl->crc == crc) return; break; } if (!sl && alt_list) { count = gf_list_count(alt_list); for (i=0; i<count; i++) { sl = gf_list_get(alt_list, i); if (sl->id != ps_id) { sl = NULL; continue; } if (sl->crc == crc) return; break; } } if (sl) { sl->data = gf_realloc(sl->data, size); memcpy(sl->data, data, size); sl->size = size; sl->crc = crc; ctx->ps_modified = GF_TRUE; return; } GF_SAFEALLOC(sl, GF_NALUFFParam); if (!sl) return; sl->data = gf_malloc(sizeof(char) * size); if (!sl->data) { gf_free(sl); return; } memcpy(sl->data, data, size); sl->size = size; sl->id = ps_id; sl->crc = crc; ctx->ps_modified = GF_TRUE; gf_list_add(list, sl); }"
"void Gobby::GotoDialog::on_changed() { g_assert(m_current_view != NULL); GtkTextBuffer* buffer = GTK_TEXT_BUFFER( m_current_view->get_text_buffer()); m_entry_line->set_range(1, gtk_text_buffer_get_line_count(buffer)); }"
"GF_Err mpgviddmx_process(GF_Filter *filter) { GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter); GF_FilterPacket *pck, *dst_pck; u64 byte_offset; s64 vosh_start = -1; s64 vosh_end = -1; GF_Err e; char *data; u8 *start; u32 pck_size; s32 remain; if (!ctx->duration.num) mpgviddmx_check_dur(filter, ctx); pck = gf_filter_pid_get_packet(ctx->ipid); if (!pck) { if (gf_filter_pid_is_eos(ctx->ipid)) { mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE); if (ctx->opid) gf_filter_pid_set_eos(ctx->opid); if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = NULL; return GF_EOS; } return GF_OK; } data = (char *) gf_filter_pck_get_data(pck, &pck_size); byte_offset = gf_filter_pck_get_byte_offset(pck); start = data; remain = pck_size; if (!ctx->resume_from && ctx->timescale) { if (!ctx->notime) { u64 ts = gf_filter_pck_get_cts(pck); if (ts != GF_FILTER_NO_TS) { if (!ctx->cts || !ctx->recompute_cts) ctx->cts = ts; } ts = gf_filter_pck_get_dts(pck); if (ts != GF_FILTER_NO_TS) { if (!ctx->dts || !ctx->recompute_cts) { ctx->dts = ts; } if (!ctx->prev_dts) ctx->prev_dts = ts; else if (ctx->prev_dts != ts) { u64 diff = ts; diff -= ctx->prev_dts; if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff; else if (ctx->cur_fps.den > diff) ctx->cur_fps.den = (u32) diff; ctx->prev_dts = ts; } } } gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end); ctx->input_is_au_end = GF_FALSE; if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE; if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = pck; gf_filter_pck_ref_props(&ctx->src_pck); } if (!ctx->resume_from && ctx->hdr_store_size) { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) { ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size; ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size); if (byte_offset != GF_FILTER_NO_BO) { if (byte_offset >= ctx->hdr_store_size) byte_offset -= ctx->hdr_store_size; else byte_offset = GF_FILTER_NO_BO; } ctx->hdr_store_size += pck_size; start = data = ctx->hdr_store; remain = pck_size = ctx->hdr_store_size; } if (ctx->resume_from) { if (gf_filter_pid_would_block(ctx->opid)) return GF_OK; if (ctx->hdr_store_size) { assert(ctx->resume_from <= ctx->hdr_store_size); start = data = ctx->hdr_store + ctx->resume_from; remain = pck_size = ctx->hdr_store_size - ctx->resume_from; } else { assert(remain >= (s32) ctx->resume_from); start += ctx->resume_from; remain -= ctx->resume_from; } ctx->resume_from = 0; } if (!ctx->bs) { ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ); } else { gf_bs_reassign_buffer(ctx->bs, start, remain); } if (!ctx->vparser) { ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12); } while (remain) { Bool full_frame; u8 *pck_data; s32 current; u8 sc_type, forced_sc_type=0; Bool sc_type_forced = GF_FALSE; Bool skip_pck = GF_FALSE; u8 ftype; u32 tinc; u64 size=0; u64 fstart=0; Bool is_coded; u32 bytes_from_store = 0; u32 hdr_offset = 0; Bool copy_last_bytes = GF_FALSE; if (remain<5) { memcpy(ctx->hdr_store, start, remain); ctx->bytes_in_header = remain; break; } current = -1; if (ctx->bytes_in_header) { memcpy(ctx->hdr_store + ctx->bytes_in_header, start, MIN_HDR_STORE - ctx->bytes_in_header); current = mpgviddmx_next_start_code(ctx->hdr_store, MIN_HDR_STORE); if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  { if (ctx->opid) { dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_NONE); memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header); } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } if (current<0) current = -1; else current -= ctx->bytes_in_header; ctx->bytes_in_header = 0; } else { hdr_offset = 4 - ctx->bytes_in_header + current; bytes_from_store = ctx->bytes_in_header; ctx->bytes_in_header = 0; if (!hdr_offset) { forced_sc_type = ctx->hdr_store[current+3]; } else { forced_sc_type = start[hdr_offset-1]; } sc_type_forced = GF_TRUE; } } if (current == -1) { current = mpgviddmx_next_start_code(start, remain); if (current<0) { u8 b3, b2, b1; if (! ctx->frame_started) { GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" )); break; } size = remain; b3 = start[remain-3]; b2 = start[remain-2]; b1 = start[remain-1]; if (!b1 || !b2 || !b3) { copy_last_bytes = GF_TRUE; assert(size >= 3); size -= 3; ctx->bytes_in_header = 3; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(pck_data, start, (size_t) size); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); if (copy_last_bytes) { memcpy(ctx->hdr_store, start+remain-3, 3); } break; } } assert(current>=0); if ((vosh_start>=0) && current) { assert(remain>=current); start += current; remain -= current; current = 0; } if (!ctx->opid && current) { assert(remain>=current); start += current; remain -= current; current = 0; } if (current>0) { dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); if (bytes_from_store) { if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); } assert(bytes_from_store>=(u32) current); bytes_from_store -= current; memcpy(pck_data, ctx->hdr_store, current); } else { if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); } memcpy(pck_data, start, current); assert(remain>=current); start += current; remain -= current; current = 0; } gf_filter_pck_set_carousel_version(dst_pck, 1); mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } ctx->trash_trailer = GF_FALSE; if (remain<5) { memcpy(ctx->hdr_store, start, remain); ctx->bytes_in_header = remain; break; } if (sc_type_forced) { gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset); sc_type = forced_sc_type; } else { gf_bs_reassign_buffer(ctx->bs, start, remain); gf_bs_read_int(ctx->bs, 24); sc_type = gf_bs_read_int(ctx->bs, 8); } if (ctx->is_mpg12) { switch (sc_type) { case M2V_SEQ_START_CODE: case M2V_EXT_START_CODE: gf_bs_reassign_buffer(ctx->bs, start, remain); e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); if (e==GF_EOS) { if (vosh_start<0) vosh_start = 0; if (data == ctx->hdr_store) { memmove(ctx->hdr_store, start, remain); ctx->hdr_store_size = remain; } else { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start); ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); ctx->hdr_store_size += pck_size - (u32) vosh_start; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; } else if (e != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); } else if (ctx->dsi.width && ctx->dsi.height) { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); } break; case M2V_PIC_START_CODE: break; default: break; } } else { u8 PL; switch (sc_type) { case M4V_VOS_START_CODE: ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs); vosh_start = start - (u8 *)data; skip_pck = GF_TRUE; assert(remain>=5); start += 5; remain -= 5; break; case M4V_VOL_START_CODE: gf_bs_reassign_buffer(ctx->bs, start, remain); PL = ctx->dsi.VideoPL; e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); ctx->dsi.VideoPL = PL; if (e==GF_EOS) { if (vosh_start<0) vosh_start = 0; if (data == ctx->hdr_store) { memmove(ctx->hdr_store, start, remain); ctx->hdr_store_size = remain; } else { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start); ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); ctx->hdr_store_size += pck_size - (u32) vosh_start; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; } else if (e != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); } else { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); skip_pck = GF_TRUE; assert(remain>=(s32) obj_size); start += obj_size; remain -= obj_size; } break; case M4V_VOP_START_CODE: case M4V_GOV_START_CODE: break; case M4V_VO_START_CODE: case M4V_VISOBJ_START_CODE: default: if (vosh_start>=0) { skip_pck = GF_TRUE; assert(remain>=4); start += 4; remain -= 4; } else if (!ctx->width) { gf_bs_reassign_buffer(ctx->bs, start, remain); PL = ctx->dsi.VideoPL; e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); if (ctx->dsi.width) { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); skip_pck = GF_TRUE; assert(remain>=(s32) obj_size); start += obj_size; remain -= obj_size; } } break; } } if (skip_pck) { continue; } if (!ctx->opid) { assert(remain>=4); start += 4; remain -= 4; continue; } if (!ctx->is_playing) { ctx->resume_from = (u32) ((char *)start -  (char *)data); return GF_OK; } ctx->hdr_store_size = 0; if (ctx->in_seek) { u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num); if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) { ctx->in_seek = GF_FALSE; } } if (remain<5) continue; gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0); size = 0; e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded); if (ctx->is_mpg12 && fstart && (fstart<remain)) { if (sc_type_forced) { fstart += 4; size-=4; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) fstart, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(pck_data, start, (size_t) fstart); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); byte_offset+=fstart; } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); start += fstart; remain -= (s32) fstart; } else if (fstart && (fstart + size <= remain)) { if (sc_type_forced) { fstart += 4; size-=4; } size += fstart; } if (bytes_from_store) { size += bytes_from_store + hdr_offset; } if ((e == GF_EOS) && !ctx->input_is_au_end) { u8 b3 = start[remain-3]; u8 b2 = start[remain-2]; u8 b1 = start[remain-1]; if (!b1 || !b2 || !b3) { copy_last_bytes = GF_TRUE; assert(size >= 3); size -= 3; ctx->bytes_in_header = 3; } full_frame = GF_FALSE; } else { full_frame = GF_TRUE; } if (ftype) { if (!is_coded) { if ((ctx->forced_packed && ctx->b_frames) || ctx->vfr ) { if (ctx->vfr) { ctx->is_vfr = GF_TRUE; mpgviddmx_update_time(ctx); } else { ctx->is_packed = GF_TRUE; } if (bytes_from_store) size-= bytes_from_store + hdr_offset; assert(remain>=size); start += size; remain -= (s32) size; ctx->trash_trailer = full_frame ? GF_FALSE : GF_TRUE; continue; } } if (ftype==3) { ctx->b_frames++; ctx->nb_b++; } else { mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE); ctx->last_ref_cts = ctx->cts; if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames; ctx->b_frames = 0; if (ftype==2) ctx->nb_p++; else ctx->nb_i++; } ctx->nb_frames++; } else { full_frame = GF_FALSE; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); if (bytes_from_store) { memcpy(pck_data, ctx->hdr_store+current, bytes_from_store); assert(size >= bytes_from_store); size -= bytes_from_store; if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); } memcpy(pck_data + bytes_from_store, start, (size_t) size); } else { memcpy(pck_data, start, (size_t) size); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data); } } if (ftype) { assert(pck_data[0] == 0); assert(pck_data[1] == 0); assert(pck_data[2] == 1); gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE); gf_filter_pck_set_cts(dst_pck, ctx->cts); gf_filter_pck_set_dts(dst_pck, ctx->dts); if (ctx->input_is_au_start) { ctx->input_is_au_start = GF_FALSE; } else { gf_filter_pck_set_carousel_version(dst_pck, 1); } gf_filter_pck_set_sap(dst_pck, (ftype==1) ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE); if (ctx->cur_fps.den > 0) gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den); if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE); ctx->frame_started = GF_TRUE; mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); mpgviddmx_update_time(ctx); } else { gf_filter_pck_set_framing(dst_pck, GF_FALSE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE); mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } if (!full_frame) { if (copy_last_bytes) { memcpy(ctx->hdr_store, start+remain-3, 3); } break; } assert(remain>=size); start += size; remain -= (s32) size; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; }"
"static Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))  return Jsi_LogError(""expected array""); Jsi_Obj *obj; uint i; Jsi_RC rc = JSI_OK; Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1); func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func))  return Jsi_LogError(""expected function""); Jsi_Value *nthis = NULL; if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; Jsi_ObjListifyArray(interp, obj); int fval = 0; Jsi_Value *nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[3]; Jsi_Func *fptr = func->d.obj->d.fobj->func; int maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); if (rc != JSI_OK) break; fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if (op == 3) { if (!fval) break; } else if (fval) break; } if (rc == JSI_OK) { if (op == 1 && fval)             Jsi_ValueCopy(interp, *ret, obj->arr[i]);  else if (op == 2 || op == 3)             Jsi_ValueMakeBool(interp, ret, fval); else if (op == 4) Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1)); } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); return rc; }"
"void setup_new_exec(struct linux_binprm * bprm) { bprm->secureexec |= bprm->cap_elevated; if (bprm->secureexec) { current->pdeath_signal = 0; if (bprm->rlim_stack.rlim_cur > _STK_LIM) bprm->rlim_stack.rlim_cur = _STK_LIM; } arch_pick_mmap_layout(current->mm, &bprm->rlim_stack); current->sas_ss_sp = current->sas_ss_size = 0; if (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP || !(uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))) set_dumpable(current->mm, suid_dumpable); else set_dumpable(current->mm, SUID_DUMP_USER); arch_setup_new_exec(); perf_event_exec(); __set_task_comm(current, kbasename(bprm->filename), true); current->mm->task_size = TASK_SIZE; current->self_exec_id++; flush_signal_handlers(current, 0); }"
"static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) { uint16_t ii; size_t total_len, len; uint8_t* p; bool is_overflow = false; len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu; BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset = L2CAP_MIN_OFFSET; p = (uint8_t*)(p_buf + 1) + p_buf->offset; if (p_cmd->multi_req.variable_len) *p++ = GATT_RSP_READ_MULTI_VAR; else *p++ = GATT_RSP_READ_MULTI; p_buf->len = 1; list_t* list = NULL; const list_node_t* node = NULL; if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) list = fixed_queue_get_list(p_cmd->multi_rsp_q); for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) { tGATTS_RSP* p_rsp = NULL; if (list != NULL) { if (ii == 0) node = list_begin(list); else node = list_next(node); if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node); } if (p_rsp != NULL) { total_len = (p_buf->len + p_rsp->attr_value.len); if (p_cmd->multi_req.variable_len) { total_len += 2; } if (total_len > mtu) { len = p_rsp->attr_value.len - (total_len - mtu); is_overflow = true; VLOG(1) << StringPrintf( ""multi read overflow available len=%zu val_len=%d"", len, p_rsp->attr_value.len); } else { len = p_rsp->attr_value.len; } if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; } if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) { if (p_buf->len + len <= UINT16_MAX) { memcpy(p, p_rsp->attr_value.value, len); if (!is_overflow) p += len; p_buf->len += len; } else { p_cmd->status = GATT_NOT_FOUND; break; } } else { p_cmd->status = GATT_NOT_FOUND; break; } if (is_overflow) break; } else { p_cmd->status = GATT_NOT_FOUND; break; } }  if (p_buf->len == 0) { LOG(ERROR) << __func__ << "" nothing found!!""; p_cmd->status = GATT_NOT_FOUND; osi_free(p_buf); VLOG(1) << __func__ << ""osi_free(p_buf)""; } else if (p_cmd->p_rsp_msg != NULL) { osi_free(p_buf); } else { p_cmd->p_rsp_msg = p_buf; } }"
"static inline unsigned int xt_write_recseq_begin(void) { unsigned int addend; addend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1; __this_cpu_add(xt_recseq.sequence, addend); smp_wmb(); return addend; }"
"static void gvs_fixed_sized_maybe_serialise (GVariantSerialised        value, GVariantSerialisedFiller  gvs_filler, const gpointer           *children, gsize                     n_children) { if (n_children) { GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 }; gvs_filler (&child, children[0]); } }"
"void pjsua_init_tpselector(pjsua_transport_id tp_id, pjsip_tpselector *sel) { pjsua_transport_data *tpdata; unsigned flag; pj_bzero(sel, sizeof(*sel)); if (tp_id == PJSUA_INVALID_ID) return; pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata)); tpdata = &pjsua_var.tpdata[tp_id]; flag = pjsip_transport_get_flag_from_type(tpdata->type); if (flag & PJSIP_TRANSPORT_DATAGRAM) { sel->type = PJSIP_TPSELECTOR_TRANSPORT; sel->u.transport = tpdata->data.tp; } else { sel->type = PJSIP_TPSELECTOR_LISTENER; sel->u.listener = tpdata->data.factory; } }"
"static int get_info(struct net *net, void __user *user, const int *len) { char name[XT_TABLE_MAXNAMELEN]; struct xt_table *t; int ret; if (*len != sizeof(struct arpt_getinfo)) return -EINVAL; if (copy_from_user(name, user, sizeof(name)) != 0) return -EFAULT; name[XT_TABLE_MAXNAMELEN-1] = '\0'; #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_lock(NFPROTO_ARP); #endif t = xt_request_find_table_lock(net, NFPROTO_ARP, name); if (!IS_ERR(t)) { struct arpt_getinfo info; const struct xt_table_info *private = t->private; #ifdef CONFIG_COMPAT struct xt_table_info tmp; if (in_compat_syscall()) { ret = compat_table_info(private, &tmp); xt_compat_flush_offsets(NFPROTO_ARP); private = &tmp; } #endif memset(&info, 0, sizeof(info)); info.valid_hooks = t->valid_hooks; memcpy(info.hook_entry, private->hook_entry, sizeof(info.hook_entry)); memcpy(info.underflow, private->underflow, sizeof(info.underflow)); info.num_entries = private->number; info.size = private->size; strcpy(info.name, name); if (copy_to_user(user, &info, *len) != 0) ret = -EFAULT; else ret = 0; xt_table_unlock(t); module_put(t->me); } else ret = PTR_ERR(t); #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_unlock(NFPROTO_ARP); #endif return ret; }"
"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { const auto* params = reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input)); const TfLiteTensor* positions; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputPositions, &positions)); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); if (positions->type == kTfLiteInt32) { switch (input->type) { case kTfLiteFloat32: return Gather<float, int32_t>(*params, input, positions, output); case kTfLiteUInt8: return Gather<uint8_t, int32_t>(*params, input, positions, output); case kTfLiteInt8: return Gather<int8_t, int32_t>(*params, input, positions, output); case kTfLiteInt16: return Gather<int16_t, int32_t>(*params, input, positions, output); case kTfLiteInt32: return Gather<int32_t, int32_t>(*params, input, positions, output); case kTfLiteInt64: return Gather<int64_t, int32_t>(*params, input, positions, output); case kTfLiteBool: return Gather<bool, int32_t>(*params, input, positions, output); case kTfLiteString: return GatherStrings<int32_t>(context, input, positions, output); default: context->ReportError(context, ""Type '%s' is not supported by gather."", TfLiteTypeGetName(input->type)); return kTfLiteError; } } if (positions->type == kTfLiteInt64) { switch (input->type) { case kTfLiteFloat32: return Gather<float, int64_t>(*params, input, positions, output); case kTfLiteUInt8: return Gather<uint8_t, int64_t>(*params, input, positions, output); case kTfLiteInt8: return Gather<int8_t, int64_t>(*params, input, positions, output); case kTfLiteInt16: return Gather<int16_t, int64_t>(*params, input, positions, output); case kTfLiteInt32: return Gather<int32_t, int64_t>(*params, input, positions, output); case kTfLiteInt64: return Gather<int64_t, int64_t>(*params, input, positions, output); case kTfLiteBool: return Gather<bool, int64_t>(*params, input, positions, output); case kTfLiteString: return GatherStrings<int64_t>(context, input, positions, output); default: context->ReportError(context, ""Type '%s' is not supported by gather."", TfLiteTypeGetName(input->type)); return kTfLiteError; } } context->ReportError(context, ""Positions of type '%s' are not supported by gather."", TfLiteTypeGetName(positions->type)); return kTfLiteError; }"
"static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll, __poll_t mask, task_work_func_t func) { int ret; if (mask && !(mask & poll->events)) return 0; trace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask); list_del_init(&poll->wait.entry); req->result = mask; init_task_work(&req->task_work, func); ret = io_req_task_work_add(req, &req->task_work); if (unlikely(ret)) { struct task_struct *tsk; WRITE_ONCE(poll->canceled, true); tsk = io_wq_get_task(req->ctx->io_wq); task_work_add(tsk, &req->task_work, 0); wake_up_process(tsk); } return 1; }"
"std::string dirname(const std::string& path) { if (path == """") return "".""; std::string p = path; while (   p.length() > 1 && (p[p.length()-1] == '\\' || p[p.length()-1] == '/')) { p = p.substr(0, p.length()-1); } if (p == ""\\"" || p == ""/"") return p; if (p.length() == 2 && p[1] == ':') return p;         std::string::size_type idx = p.find_last_of(""\\/""); if (idx == std::string::npos) return "".""; if (idx == 1 && p[0] == '\\' && p[1] == '\\') return p;         p = p.substr(0, idx == 0 ? 1 : idx); while (   p.length() > 1 && (p[p.length()-1] == '\\' || p[p.length()-1] == '/')) { p = p.substr(0, p.length()-1); } return p; }"
"static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb) { if (offset > G_MAXUINT32 - value) { proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, ""Offset value too large: %u"", value); THROW(ReportedBoundsError); } return offset + value; }"
static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte) { if (!kvm_pte_valid(pte)) return PKVM_NOPAGE; return pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte)); }
"explicit ReverseSequenceOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""batch_dim"", &batch_dim_)); OP_REQUIRES_OK(context, context->GetAttr(""seq_dim"", &seq_dim_)); }"
"int arch_domain_create(struct domain *d, struct xen_domctl_createdomain *config, unsigned int flags) { bool paging_initialised = false; uint32_t emflags; int rc; INIT_PAGE_LIST_HEAD(&d->arch.relmem_list); spin_lock_init(&d->arch.e820_lock); if ( unlikely(is_idle_domain(d)) ) { static const struct arch_csw idle_csw = { .from = paravirt_ctxt_switch_from, .to   = paravirt_ctxt_switch_to, .tail = idle_loop, }; d->arch.ctxt_switch = &idle_csw; d->arch.cpuid = ZERO_BLOCK_PTR;  d->arch.msr = ZERO_BLOCK_PTR; return 0; } if ( !config ) { ASSERT_UNREACHABLE(); return -EINVAL; } if ( d->domain_id && cpu_has_amd_erratum(&boot_cpu_data, AMD_ERRATUM_121) ) { if ( !opt_allow_unsafe ) { printk(XENLOG_G_ERR ""Xen does not allow DomU creation on this CPU"" "" for security reasons.\n""); return -EPERM; } printk(XENLOG_G_WARNING ""Dom%d may compromise security on this CPU.\n"", d->domain_id); } emflags = config->arch.emulation_flags; if ( is_hardware_domain(d) && is_pv_domain(d) ) emflags |= XEN_X86_EMU_PIT; if ( emflags & ~XEN_X86_EMU_ALL ) { printk(XENLOG_G_ERR ""d%d: Invalid emulation bitmap: %#x\n"", d->domain_id, emflags); return -EINVAL; } if ( !emulation_flags_ok(d, emflags) ) { printk(XENLOG_G_ERR ""d%d: Xen does not allow %s domain creation "" ""with the current selection of emulators: %#x\n"", d->domain_id, is_hvm_domain(d) ? ""HVM"" : ""PV"", emflags); return -EOPNOTSUPP; } d->arch.emulation_flags = emflags; #ifdef CONFIG_PV32 HYPERVISOR_COMPAT_VIRT_START(d) = is_pv_domain(d) ? __HYPERVISOR_COMPAT_VIRT_START : ~0u; #endif if ( (rc = paging_domain_init(d)) != 0 ) goto fail; paging_initialised = true; if ( (rc = init_domain_cpuid_policy(d)) ) goto fail; if ( (rc = init_domain_msr_policy(d)) ) goto fail; d->arch.ioport_caps = rangeset_new(d, ""I/O Ports"", RANGESETF_prettyprint_hex); rc = -ENOMEM; if ( d->arch.ioport_caps == NULL ) goto fail; if ( (d->shared_info = alloc_xenheap_pages(0, MEMF_bits(32))) == NULL ) goto fail; clear_page(d->shared_info); share_xen_page_with_guest(virt_to_page(d->shared_info), d, SHARE_rw); if ( (rc = init_domain_irq_mapping(d)) != 0 ) goto fail; if ( (rc = iommu_domain_init(d, config->iommu_opts)) != 0 ) goto fail; psr_domain_init(d); if ( is_hvm_domain(d) ) { if ( (rc = hvm_domain_initialise(d)) != 0 ) goto fail; } else if ( is_pv_domain(d) ) { mapcache_domain_init(d); if ( (rc = pv_domain_initialise(d)) != 0 ) goto fail; } else ASSERT_UNREACHABLE();  if ( (rc = tsc_set_info(d, TSC_MODE_DEFAULT, 0, 0, 0)) != 0 ) { ASSERT_UNREACHABLE(); goto fail; } pit_init(d, cpu_khz); d->arch.x87_fip_width = cpu_has_fpu_sel ? 0 : 8; domain_cpu_policy_changed(d); d->arch.msr_relaxed = config->arch.misc_flags & XEN_X86_MSR_RELAXED; return 0; fail: d->is_dying = DOMDYING_dead; psr_domain_free(d); iommu_domain_destroy(d); cleanup_domain_irq_mapping(d); free_xenheap_page(d->shared_info); xfree(d->arch.cpuid); xfree(d->arch.msr); if ( paging_initialised ) paging_final_teardown(d); free_perdomain_mappings(d); return rc; }"
"static GF_Err shift_chunk_offsets(GF_SampleToChunkBox *stsc, GF_MediaBox *mdia, GF_Box *_stco, u64 offset, Bool force_co64, GF_Box **new_stco) { u32 j, k, l, last; GF_StscEntry *ent; for (j=0; j<stsc->nb_entries; j++) { ent = &stsc->entries[j]; if (!Media_IsSelfContained(mdia, ent->sampleDescriptionIndex)) continue; if (_stco->type == GF_ISOM_BOX_TYPE_STCO) { GF_ChunkLargeOffsetBox *new_stco64 = NULL; GF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *) _stco; last = ent->nextChunk ? ent->nextChunk : stco->nb_entries + 1; for (k = ent->firstChunk; k < last; k++) { if (new_stco64 || force_co64 || (stco->offsets[k-1] + offset > 0xFFFFFFFF)) { if (!new_stco64) { new_stco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64); if (!new_stco64) return GF_OUT_OF_MEM; new_stco64->nb_entries = stco->nb_entries; new_stco64->offsets = (u64 *) gf_malloc(new_stco64->nb_entries * sizeof(u64)); if (!new_stco64->offsets) return GF_OUT_OF_MEM; for (l = 0; l < new_stco64->nb_entries; l++) { new_stco64->offsets[l] = (u64) stco->offsets[l]; } } new_stco64->offsets[k-1] += offset; } else { stco->offsets[k-1] += (u32) offset; } } if (new_stco64) { *new_stco = (GF_Box *) new_stco64; _stco = (GF_Box *) new_stco64; new_stco64 = NULL; } } else { GF_ChunkLargeOffsetBox *stco64 = (GF_ChunkLargeOffsetBox *) _stco; last = ent->nextChunk ? ent->nextChunk : stco64->nb_entries + 1; for (k = ent->firstChunk; k < last; k++) { stco64->offsets[k-1] += offset; } } } return GF_OK; }"
"GF_EXPORT GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size) { #ifndef GPAC_DISABLE_AV_PARSERS AV1State state; u8 reserved; GF_AV1Config *cfg; if (!size) size = (u32) gf_bs_available(bs); if (!size) return NULL; cfg = gf_odf_av1_cfg_new(); gf_av1_init_state(&state); state.config = cfg; cfg->marker = gf_bs_read_int(bs, 1); cfg->version = gf_bs_read_int(bs, 7); cfg->seq_profile = gf_bs_read_int(bs, 3); cfg->seq_level_idx_0 = gf_bs_read_int(bs, 5); cfg->seq_tier_0 = gf_bs_read_int(bs, 1); cfg->high_bitdepth = gf_bs_read_int(bs, 1); cfg->twelve_bit = gf_bs_read_int(bs, 1); cfg->monochrome = gf_bs_read_int(bs, 1); cfg->chroma_subsampling_x = gf_bs_read_int(bs, 1); cfg->chroma_subsampling_y = gf_bs_read_int(bs, 1); cfg->chroma_sample_position = gf_bs_read_int(bs, 2); reserved = gf_bs_read_int(bs, 3); if (reserved != 0 || cfg->marker != 1 || cfg->version != 1) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\n"", reserved, cfg->marker, cfg->version)); gf_odf_av1_cfg_del(cfg); return NULL; } cfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1); if (cfg->initial_presentation_delay_present) { cfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4); } else { gf_bs_read_int(bs, 4); cfg->initial_presentation_delay_minus_one = 0; } size -= 4; while (size) { u64 pos, obu_size; ObuType obu_type; GF_AV1_OBUArrayEntry *a; pos = gf_bs_get_position(bs); obu_size = 0; if (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[AV1] could not parse AV1 OBU at position ""LLU"". Leaving parsing.\n"", pos)); break; } assert(obu_size == gf_bs_get_position(bs) - pos); GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] parsed AV1 OBU type=%u size=""LLU"" at position ""LLU"".\n"", obu_type, obu_size, pos)); if (!av1_is_obu_header(obu_type)) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] AV1 unexpected OBU type=%u size=""LLU"" found at position ""LLU"". Forwarding.\n"", pos)); } GF_SAFEALLOC(a, GF_AV1_OBUArrayEntry); if (!a) break; a->obu = gf_malloc((size_t)obu_size); if (!a->obu) { gf_free(a); break; } gf_bs_seek(bs, pos); gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size); a->obu_length = obu_size; a->obu_type = obu_type; gf_list_add(cfg->obu_array, a); if (size<obu_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[AV1] AV1 config misses %d bytes to fit the entire OBU\n"", obu_size - size)); break; } size -= (u32) obu_size; } gf_av1_reset_state(& state, GF_TRUE); return cfg; #else return NULL; #endif }"
"void Filter::onDownstreamEvent(Network::ConnectionEvent event) { ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(), static_cast<int>(event), upstream_ == nullptr); if (upstream_) { Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event)); if (conn_data != nullptr && conn_data->connection().state() != Network::Connection::State::Closed) { config_->drainManager().add(config_->sharedConfig(), std::move(conn_data), std::move(upstream_callbacks_), std::move(idle_timer_), read_callbacks_->upstreamHost()); } if (event != Network::ConnectionEvent::Connected) { upstream_.reset(); disableIdleTimer(); } } if (generic_conn_pool_) { if (event == Network::ConnectionEvent::LocalClose || event == Network::ConnectionEvent::RemoteClose) { generic_conn_pool_.reset(); } } }"
"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) { if (!block) { return; } QLIST_SAFE_REMOVE(block, next); uc->ram_list.mru_block = NULL; reclaim_ramblock(uc, block); }"
"GF_EXPORT GF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->avc_config) return NULL; return AVC_DuplicateConfig(entry->avc_config->config); }"
"static int RegenerateThumbnail(const char * FileName) { char ThumbnailGenCommand[PATH_MAX*2+50]; if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){ return FALSE; } sprintf(ThumbnailGenCommand, ""mogrify -thumbnail %dx%d -quality 80 \""%s\"""", RegenThumbnail, RegenThumbnail, FileName); if (system(ThumbnailGenCommand) == 0){ return ReplaceThumbnail(FileName); }else{ ErrFatal(""Unable to run 'mogrify' command""); return FALSE; } }"
"int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe) { int n; if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; } if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX; return -1; } if(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1; n = (u32) AVI->video_index[AVI->video_pos].len; *keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0; if (vidbuf == NULL) { AVI->video_pos++; return n; } gf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET); if (avi_read(AVI->fdes,vidbuf,n) != (u32) n) { AVI_errno = AVI_ERR_READ; return -1; } AVI->video_pos++; return n; }"
"static int decode_command(tvbuff_t *tvb, packet_info* pinfo, int msglen, int offset, int dst, proto_tree *pt) { guint32         cmd; guint32         context, ioctl_command; proto_tree      *ft; proto_item      *hi; gryphon_pkt_info_t *pkt_info; hi = proto_tree_add_item_ret_uint(pt, hf_gryphon_cmd, tvb, offset, 1, ENC_BIG_ENDIAN, &cmd); proto_item_set_hidden(hi); if (cmd > 0x3F) cmd += dst * 256; if (!pinfo->fd->visited) { gryphon_conversation *conv_data = get_conversation_data(pinfo); pkt_info = wmem_new0(wmem_file_scope(), gryphon_pkt_info_t); pkt_info->cmd = cmd; pkt_info->req_frame_num = pinfo->num; pkt_info->req_time = pinfo->abs_ts; wmem_list_prepend(conv_data->request_frame_data, pkt_info); p_add_proto_data(wmem_file_scope(), pinfo, proto_gryphon, (guint32)tvb_raw_offset(tvb), pkt_info); } else { pkt_info = (gryphon_pkt_info_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_gryphon, (guint32)tvb_raw_offset(tvb)); } proto_tree_add_uint(pt, hf_gryphon_command, tvb, offset, 1, cmd); proto_tree_add_item_ret_uint(pt, hf_gryphon_cmd_context, tvb, offset + 1, 1, ENC_NA, &context); if (!pinfo->fd->visited) { pkt_info->cmd_context = context; } proto_tree_add_item(pt, hf_gryphon_reserved, tvb, offset + 2, 2, ENC_NA); if (pkt_info->rsp_frame_num > 0) { proto_item* it = proto_tree_add_uint(pt, hf_gryphon_response_in, tvb, 0, 0, pkt_info->rsp_frame_num); proto_item_set_generated(it); } offset += 4; msglen -= 4; if (msglen > 0) { ft = proto_tree_add_subtree_format(pt, tvb, offset, msglen, ett_gryphon_command_data, NULL, ""Data: (%d byte%s)"", msglen, plurality(msglen, """", ""s"")); switch (cmd) { case CMD_INIT: offset = cmd_init(tvb, offset, ft); break; case CMD_EVENT_ENABLE: case CMD_EVENT_DISABLE: offset = eventnum(tvb, offset, ft); break; case CMD_SET_TIME: offset = resp_time(tvb, offset, ft); break; case CMD_CARD_SET_SPEED: offset = speed(tvb, offset, ft); break; case CMD_CARD_SET_FILTER: offset = cmd_setfilt(tvb, offset, ft); break; case CMD_CARD_GET_FILTER: offset = resp_addfilt(tvb, offset, ft); break; case CMD_CARD_TX: offset = decode_data(tvb, offset, ft); break; case CMD_CARD_ADD_FILTER: offset = cmd_addfilt(tvb, offset, ft); break; case CMD_CARD_MODIFY_FILTER: offset = cmd_modfilt(tvb, offset, ft); break; case CMD_CARD_SET_DEFAULT_FILTER: offset = dfiltmode(tvb, offset, ft); break; case CMD_CARD_SET_FILTER_MODE: offset = filtmode(tvb, offset, ft); break; case CMD_SERVER_REG: offset = cmd_register(tvb, offset, ft); break; case CMD_SERVER_SET_SORT: offset = cmd_sort(tvb, offset, ft); break; case CMD_SERVER_SET_OPT: offset = cmd_optimize(tvb, offset, ft); break; case CMD_BLM_SET_MODE: offset = blm_mode(tvb, offset, ft); break; case CMD_LDF_LIST: offset = cmd_ldf_list(tvb, offset, ft); break; case CMD_LDF_DELETE: offset = cmd_ldf_delete(tvb, offset, ft); break; case CMD_LDF_DESC: offset = cmd_ldf_desc(tvb, offset, ft); break; case CMD_LDF_UPLOAD: offset = cmd_ldf_upload(tvb, offset, ft); break; case CMD_LDF_PARSE: offset = cmd_ldf_parse(tvb, offset, ft); break; case CMD_GET_NODE_SIGNALS: offset = cmd_ldf_get_node_signals(tvb, offset, ft); break; case CMD_GET_FRAMES: offset = cmd_ldf_get_frames(tvb, offset, ft); break; case CMD_GET_FRAME_INFO: offset = cmd_ldf_get_frame_info(tvb, pinfo, offset, ft); break; case CMD_GET_SIGNAL_INFO: offset = cmd_ldf_get_signal_info(tvb, offset, ft); break; case CMD_GET_SIGNAL_DETAIL: offset = cmd_ldf_get_signal_detail(tvb, offset, ft); break; case CMD_GET_ENCODING_INFO: offset = cmd_ldf_get_encoding_info(tvb, offset, ft); break; case CMD_SAVE_SESSION: offset = cmd_ldf_save_session(tvb, offset, ft); break; case CMD_EMULATE_NODES: offset = cmd_ldf_emulate_nodes(tvb, pinfo, offset, ft); break; case CMD_START_SCHEDULE: offset = cmd_ldf_start_schedule(tvb, offset, ft); break; case CMD_RESTORE_SESSION: offset = cmd_restore_session(tvb, offset, ft); break; case CMD_CNVT_GET_VALUES: offset = cmd_cnvt_get_values(tvb, offset, ft); break; case CMD_CNVT_GET_UNITS: offset = cmd_cnvt_get_units(tvb, offset, ft); break; case CMD_CNVT_SET_VALUES: offset = cmd_cnvt_set_values(tvb, offset, ft); break; case CMD_CNVT_SAVE_SESSION: offset = cmd_ldf_save_session(tvb, offset, ft); break; case CMD_CNVT_RESTORE_SESSION: offset = cmd_restore_session(tvb, offset, ft); break; case CMD_CNVT_DESTROY_SESSION: offset = cmd_cnvt_destroy_session(tvb, offset, ft); break; case CMD_CNVT_GET_NODE_SIGNALS: offset = cmd_ldf_get_node_signals(tvb, offset, ft); break; case CMD_MSGRESP_ADD: offset = cmd_addresp(tvb, offset, pinfo, ft); break; case CMD_MSGRESP_GET: offset = resp_addresp(tvb, offset, ft); break; case CMD_MSGRESP_MODIFY: offset = cmd_modresp(tvb, offset, ft); break; case CMD_PGM_DESC: offset = cmd_desc(tvb, offset, ft); break; case CMD_PGM_UPLOAD: offset = cmd_upload(tvb, offset, ft); break; case CMD_PGM_DELETE: offset = cmd_delete(tvb, offset, ft); break; case CMD_PGM_LIST: offset = cmd_list(tvb, offset, ft); break; case CMD_PGM_START: offset = cmd_start(tvb, pinfo, offset, ft); break; case CMD_PGM_STOP: offset = resp_start(tvb, offset, ft); break; case CMD_PGM_STATUS: offset = cmd_delete(tvb, offset, ft); break; case CMD_PGM_OPTIONS: offset = cmd_options(tvb, offset, ft); break; case CMD_PGM_FILES: offset = cmd_files(tvb, offset, ft); break; case CMD_SCHED_TX: offset = cmd_sched(tvb, offset, ft); break; case CMD_SCHED_KILL_TX: offset = resp_sched(tvb, offset, ft); break; case CMD_SCHED_MSG_REPLACE: offset = cmd_sched_rep(tvb, offset, ft); break; case CMD_USDT_REGISTER: offset = cmd_usdt(tvb, offset, ft); break; case CMD_USDT_SET_FUNCTIONAL: offset = cmd_usdt(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_MULT: offset = cmd_usdt_set_stmin_mul(tvb, offset, ft); break; case CMD_USDT_REGISTER_NON_LEGACY: offset = cmd_usdt_register_non_legacy(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_FC: offset = cmd_usdt_stmin_fc(tvb, offset, ft); break; case CMD_USDT_SET_BSMAX_FC: offset = cmd_usdt_bsmax_fc(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_OVERRIDE: offset = cmd_usdt_stmin_override(tvb, offset, ft); break; case CMD_USDT_ACTIVATE_STMIN_OVERRIDE: offset = cmd_usdt_stmin_override_activate(tvb, offset, ft); break; case CMD_IOPWR_CLRLATCH: offset = cmd_bits_in(tvb, offset, ft); break; case CMD_IOPWR_SETOUT: case CMD_IOPWR_SETBIT: case CMD_IOPWR_CLRBIT: offset = cmd_bits_out(tvb, offset, ft); break; case CMD_UTIL_SET_INIT_STRATEGY: offset = cmd_init_strat(tvb, offset, ft); break; case CMD_CARD_IOCTL: ioctl_command = tvb_get_ntohl(tvb, offset); if (!pinfo->fd->visited) { pkt_info->ioctl_command = ioctl_command; } offset = cmd_ioctl(tvb, pinfo, offset, ft, ioctl_command); break; default: proto_tree_add_item(ft, hf_gryphon_data, tvb, offset, msglen, ENC_NA); offset += msglen; break; } } return offset; }"
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= sh_name                  || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrndx""); } } } Elf64_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"int main() { WEBCC_LOG_INIT("""", webcc::LOG_CONSOLE); webcc::ClientSession session; webcc::ResponsePtr r; try { r = session.Send(webcc::RequestBuilder{}. Get(""http:                     Query(""name"", Utf16ToUtf8(L""顾春庭""), true) ()); assert(r->status() == webcc::Status::kOK); } catch (const webcc::Error& error) { std::cerr << error << std::endl; return 1; } return 0; }"
"void APar_ExtractTrackDetails(char *uint32_buffer, FILE *isofile, Trackage *track, TrackInfo *track_info) { uint64_t _offset = 0; APar_TrackLevelInfo(track, ""tkhd""); if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8) == 0) { if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 11) & 1) { track_info->track_enabled = true; } track_info->creation_time = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 12); track_info->modified_time = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 16); track_info->duration = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 28); } else { track_info->creation_time = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 12); track_info->modified_time = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 20); track_info->duration = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 36); } APar_TrackLevelInfo(track, ""mdhd""); memset(uint32_buffer, 0, 5); uint16_t packed_language = APar_read16( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 28); memset(track_info->unpacked_lang, 0, 4); APar_UnpackLanguage( track_info->unpacked_lang, packed_language);  APar_TrackLevelInfo(track, ""hdlr""); memset(uint32_buffer, 0, 5); track_info->track_type = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 16); if (track_info->track_type == 0x736F756E) {     track_info->type_of_track = AUDIO_TRACK; } else if (track_info->track_type == 0x76696465) {     track_info->type_of_track = VIDEO_TRACK; } if (parsedAtoms[track->track_atom].AtomicLength > 34) { memset(track_info->track_hdlr_name, 0, 100); APar_readX(track_info->track_hdlr_name, isofile, parsedAtoms[track->track_atom].AtomicStart + 32, parsedAtoms[track->track_atom].AtomicLength - 32); } APar_TrackLevelInfo(track, ""stsd""); memset(uint32_buffer, 0, 5); track_info->track_codec = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 20); if (track_info->type_of_track & VIDEO_TRACK) {     track_info->video_width = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 32); track_info->video_height = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 34); track_info->macroblocks = (track_info->video_width / 16) * (track_info->video_height / 16); if (track_info->track_codec == 0x61766331 || track_info->track_codec == 0x64726D69) {       track_info->contains_esds = false; APar_TrackLevelInfo(track, ""avcC""); track_info->avc_version = APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8); if (track_info->avc_version == 1) { track_info->profile = APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 9); track_info->level = APar_read8( isofile, parsedAtoms[track->track_atom].AtomicStart + 11); } } else if (track_info->track_codec == 0x73323633) {       APar_TrackLevelInfo(track, ""d263""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""d263"", 4) == 0) { APar_Extract_d263_Info( uint32_buffer, isofile, track->track_atom, track_info); } } else {       APar_TrackLevelInfo(track, ""esds""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""esds"", 4) == 0) { APar_Extract_esds_Info( uint32_buffer, isofile, track->track_atom - 1, track_info);                                } else if (track_info->track_codec == 0x73323633) {         track_info->type_of_track = VIDEO_TRACK; } else if (track_info->track_codec == 0x73616D72 || track_info->track_codec == 0x73617762 || track_info->track_codec == 0x73617770 || track_info->track_codec == 0x73766D72) {         track_info->type_of_track = AUDIO_TRACK; } else { track_info->type_of_track = OTHER_TRACK;                                                        } } } else if (track_info->type_of_track & AUDIO_TRACK) { if (track_info->track_codec == 0x73616D72 || track_info->track_codec == 0x73617762 || track_info->track_codec == 0x73617770 || track_info->track_codec == 0x73766D72) {       APar_Extract_AMR_Info( uint32_buffer, isofile, track->track_atom + 2, track_info); } else if (track_info->track_codec == 0x73657663) {       APar_TrackLevelInfo(track, ""devc""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""devc"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info); } } else if (track_info->track_codec == 0x73716370) {       APar_TrackLevelInfo(track, ""dqcp""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""dqcp"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info);       } } else if (track_info->track_codec == 0x73736D76) {       APar_TrackLevelInfo(track, ""dsmv""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""dsmv"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info);       } } else { APar_Extract_esds_Info( uint32_buffer, isofile, track->track_atom, track_info); } } if ((track_info->type_of_track & AUDIO_TRACK || track_info->type_of_track & VIDEO_TRACK) && track_info->avg_bitrate == 0) { if (track_info->track_codec == 0x616C6163) {       track_info->channels = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 24); } } APar_TrackLevelInfo(track, ""stsz""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""stsz"", 4) == 0) { track_info->sample_aggregate = calcuate_sample_size(uint32_buffer, isofile, track->track_atom); } if (track_info->track_codec >= 0x64726D00 && track_info->track_codec <= 0x64726DFF) { track_info->type_of_track += DRM_PROTECTED_TRACK; APar_TrackLevelInfo(track, ""frma""); memset(uint32_buffer, 0, 5); track_info->protected_codec = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 8); } if (track_info->contains_esds) { APar_TrackLevelInfo(track, ""esds""); _offset = APar_FindValueInAtom( uint32_buffer, isofile, track->track_atom, 24, 0x01B2); if (_offset > 0 && _offset < parsedAtoms[track->track_atom].AtomicLength) { _offset += 2; memset(track_info->encoder_name, 0, parsedAtoms[track->track_atom].AtomicLength - _offset); APar_readX(track_info->encoder_name, isofile, parsedAtoms[track->track_atom].AtomicStart + _offset, parsedAtoms[track->track_atom].AtomicLength - _offset); } } return; }"
"static int parseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos) { int endPos = bufPos + totalLength; self->calledPresentationSelector.size = 0; self->callingPresentationSelector.size = 0; bool hasUserData = false; while (bufPos < endPos) { uint8_t tag = buffer[bufPos++]; int len; if (bufPos == endPos) { if (DEBUG_PRES) printf(""PRES: invalid message\n""); return -1; } bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos); if (bufPos < 0) { if (DEBUG_PRES) printf(""PRES: wrong parameter length\n""); return -1; } switch (tag) { case 0x81:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: calling-presentation-sel too large\n""); } else { self->callingPresentationSelector.size = len; int i; for (i = 0; i < len; i++) self->callingPresentationSelector.value[i] = buffer[bufPos + i]; } bufPos += len; break; case 0x82:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: called-presentation-sel too large\n""); } else { self->calledPresentationSelector.size = len; int i; for (i = 0; i < len; i++) self->calledPresentationSelector.value[i] = buffer[bufPos + i]; } bufPos += len; break; case 0x83:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: responding-presentation-sel too large\n""); } bufPos += len; break; case 0xa4:  if (DEBUG_PRES) printf(""PRES: pcd list\n""); bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos); break; case 0xa5:  bufPos += len; break; case 0x61:  if (DEBUG_PRES) printf(""PRES: user-data\n""); bufPos = parseFullyEncodedData(self, buffer, len, bufPos); if (bufPos < 0) return -1; if (self->nextPayload.size > 0) hasUserData = true; break; case 0x00:  break; default: if (DEBUG_PRES) printf(""PRES: unknown tag in normal-mode\n""); bufPos += len; break; } } if (hasUserData == false) { if (DEBUG_PRES) printf(""PRES: user-data is missing\n""); return -1; } return bufPos; }"
"static void dissect_client_player_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, guint length_remaining) { const guint8 *player_info; proto_tree_add_item(tree, hf_msmms_command_prefix1, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset += 4; proto_tree_add_item(tree, hf_msmms_command_prefix2, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset += 4; offset += 4; proto_tree_add_item_ret_string(tree, hf_msmms_command_client_player_info, tvb, offset, length_remaining-12, ENC_UTF_16|ENC_LITTLE_ENDIAN, pinfo->pool, &player_info); col_append_fstr(pinfo->cinfo, COL_INFO, "" (%s)"", format_text(pinfo->pool, (const guchar*)player_info, strlen(player_info))); }"
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr, size_t *rot_buf_size) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, col_offset, pix_offset; tmsize_t buffsize; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; if ((spp != 0 && bps != 0 && width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) || (spp != 0 && bps != 0 && length > (uint32_t)((UINT32_MAX - 7) / spp / bps))) { TIFFError(""rotateImage"", ""Integer overflow detected.""); return (-1); } rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) { if (((tmsize_t)colsize + 1) != 0 && (tmsize_t)width > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) / ((tmsize_t)colsize + 1))) { TIFFError(""rotateImage"", ""Integer overflow when calculating buffer size.""); return (-1); } buffsize = ((tmsize_t)colsize + 1) * width; } else { if (((tmsize_t)rowsize + 1) != 0 && (tmsize_t)length > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) / ((tmsize_t)rowsize + 1))) { TIFFError(""rotateImage"", ""Integer overflow when calculating buffer size.""); return (-1); } buffsize = (rowsize + 1) * length; } bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %"" TIFF_SSIZE_FORMAT "" bytes "", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); if (rot_buf_size != NULL) *rot_buf_size = buffsize; ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"static void process_COM (const uchar * Data, int length) { int ch; char Comment[MAX_COMMENT_SIZE+1]; int nch; int a; nch = 0; if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE;  for (a=2;a<length;a++){ ch = Data[a]; if (ch == '\r' && Data[a+1] == '\n') continue;  if (ch >= 32 || ch == '\n' || ch == '\t'){ Comment[nch++] = (char)ch; }else{ Comment[nch++] = '?'; } } Comment[nch] = '\0';  if (ShowTags){ printf(""COM marker comment: %s\n"",Comment); } strcpy(ImageInfo.Comments,Comment); }"
"static FT_Error tt_size_select( FT_Size   size, FT_ULong  strike_index ) { TT_Face   ttface = (TT_Face)size->face; TT_Size   ttsize = (TT_Size)size; FT_Error  error  = FT_Err_Ok; ttsize->strike_index = strike_index; if ( FT_IS_SCALABLE( size->face ) ) { FT_Select_Metrics( size->face, strike_index ); tt_size_reset( ttsize, 0 );  } else { SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt; FT_Size_Metrics*  size_metrics = &size->metrics; error = sfnt->load_strike_metrics( ttface, strike_index, size_metrics ); if ( error ) ttsize->strike_index = 0xFFFFFFFFUL; } return error; }"
"static GF_List *dasher_get_content_protection_desc(GF_DasherCtx *ctx, GF_DashStream *ds, GF_MPD_AdaptationSet *for_set) { char sCan[40]; u32 prot_scheme=0; u32 i, count; const GF_PropertyValue *p; GF_List *res = NULL; GF_BitStream *bs_r; count = gf_list_count(ctx->current_period->streams); bs_r = gf_bs_new((const char *) &count, 1, GF_BITSTREAM_READ); for (i=0; i<count; i++) { GF_MPD_Descriptor *desc; GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i); if (!a_ds->is_encrypted) continue; if (for_set) { if (a_ds->set != for_set) continue; if (!a_ds->owns_set) continue; } else if ((a_ds != ds) && (a_ds->muxed_base != ds) ) { continue; } p = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE); if (p) prot_scheme = p->value.uint; if ((prot_scheme==GF_ISOM_CENC_SCHEME) || (prot_scheme==GF_ISOM_CBC_SCHEME) || (prot_scheme==GF_ISOM_CENS_SCHEME) || (prot_scheme==GF_ISOM_CBCS_SCHEME) ) { const GF_PropertyValue *ki; u32 j, nb_pssh; GF_XMLAttribute *att; char szVal[GF_MAX_PATH]; ctx->use_cenc = GF_TRUE; ki = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_KEY_INFO); if (!ki || !ki->value.data.ptr) { continue; } if (!res) res = gf_list_new(); desc = gf_mpd_descriptor_new(NULL, ""urn:mpeg:dash:mp4protection:2011"", gf_4cc_to_str(prot_scheme)); gf_list_add(res, desc); get_canon_urn(ki->value.data.ptr + 4, sCan); att = gf_xml_dom_create_attribute(""cenc:default_KID"", sCan); if (!desc->x_attributes) desc->x_attributes = gf_list_new(); gf_list_add(desc->x_attributes, att); if (ctx->pssh <= GF_DASH_PSSH_MOOF) { continue; } p = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_PSSH); if (!p) continue; gf_bs_reassign_buffer(bs_r, p->value.data.ptr, p->value.data.size); nb_pssh = gf_bs_read_u32(bs_r); for (j=0; j<nb_pssh; j++) { u32 pssh_idx; bin128 sysID; GF_XMLNode *node; u32 version, k_count; u8 *pssh_data=NULL; u32 pssh_len, size_64; GF_BitStream *bs_w = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_bs_write_u32(bs_w, 0); gf_bs_write_u32(bs_w, GF_ISOM_BOX_TYPE_PSSH); gf_bs_read_data(bs_r, sysID, 16); version = gf_bs_read_u32(bs_r); k_count = version ? gf_bs_read_u32(bs_r) : 0; gf_bs_write_u8(bs_w, version); gf_bs_write_u24(bs_w, 0); gf_bs_write_data(bs_w, sysID, 16); if (version) { gf_bs_write_u32(bs_w, k_count); for (j=0; j<k_count; j++) { bin128 keyID; gf_bs_read_data(bs_r, keyID, 16); gf_bs_write_data(bs_w, keyID, 16); } } k_count = gf_bs_read_u32(bs_r); gf_bs_write_u32(bs_w, k_count); for (pssh_idx=0; pssh_idx<k_count; pssh_idx++) { gf_bs_write_u8(bs_w, gf_bs_read_u8(bs_r) ); } pssh_len = (u32) gf_bs_get_position(bs_w); gf_bs_seek(bs_w, 0); gf_bs_write_u32(bs_w, pssh_len); gf_bs_seek(bs_w, pssh_len); gf_bs_get_content(bs_w, &pssh_data, &pssh_len); gf_bs_del(bs_w); get_canon_urn(sysID, sCan); desc = gf_mpd_descriptor_new(NULL, NULL, NULL); desc->x_children = gf_list_new(); sprintf(szVal, ""urn:uuid:%s"", sCan); desc->scheme_id_uri = gf_strdup(szVal); desc->value = gf_strdup(get_drm_kms_name(sCan)); gf_list_add(res, desc); GF_SAFEALLOC(node, GF_XMLNode); if (node) { GF_XMLNode *pnode; node->type = GF_XML_NODE_TYPE; node->name = gf_strdup(""cenc:pssh""); node->content = gf_list_new(); gf_list_add(desc->x_children, node); GF_SAFEALLOC(pnode, GF_XMLNode); if (pnode) { pnode->type = GF_XML_TEXT_TYPE; gf_list_add(node->content, pnode); size_64 = 2*pssh_len; pnode->name = gf_malloc(size_64); if (pnode->name) { size_64 = gf_base64_encode((const char *)pssh_data, pssh_len, (char *)pnode->name, size_64); pnode->name[size_64] = 0; } } } gf_free(pssh_data); } } else { if (ctx->do_mpd) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (""[Dasher] Protection scheme %s has no official DASH mapping, using URI \""urn:gpac:dash:mp4protection:2018\""\n"", gf_4cc_to_str(prot_scheme))); } if (!res) res = gf_list_new(); desc = gf_mpd_descriptor_new(NULL, ""urn:gpac:dash:mp4protection:2018"", gf_4cc_to_str(prot_scheme)); gf_list_add(res, desc); } } gf_bs_del(bs_r); return res; }"
"int __close_fd_get_file(unsigned int fd, struct file **res) { struct files_struct *files = current->files; struct file *file; struct fdtable *fdt; spin_lock(&files->file_lock); fdt = files_fdtable(files); if (fd >= fdt->max_fds) goto out_unlock; file = fdt->fd[fd]; if (!file) goto out_unlock; rcu_assign_pointer(fdt->fd[fd], NULL); __put_unused_fd(files, fd); spin_unlock(&files->file_lock); get_file(file); *res = file; return filp_close(file, files); out_unlock: spin_unlock(&files->file_lock); *res = NULL; return -ENOENT; }"
"static UINT urbdrc_process_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 MessageId, IUDEVMAN* udevman) { UINT32 InterfaceId; UINT32 IoControlCode; UINT32 InputBufferSize; UINT32 OutputBufferSize; UINT32 RequestId; UINT32 usbd_status = USBD_STATUS_SUCCESS; wStream* out; int success = 0; URBDRC_PLUGIN* urbdrc; if (!callback || !s || !udevman || !pdev) return ERROR_INVALID_PARAMETER; urbdrc = (URBDRC_PLUGIN*)callback->plugin; if (!urbdrc) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 8) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, IoControlCode); Stream_Read_UINT32(s, InputBufferSize); if (!Stream_SafeSeek(s, InputBufferSize)) return ERROR_INVALID_DATA; if (Stream_GetRemainingLength(s) < 8ULL) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, OutputBufferSize); Stream_Read_UINT32(s, RequestId); InterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev)); out = urb_create_iocompletion(InterfaceId, MessageId, RequestId, OutputBufferSize + 4); if (!out) return ERROR_OUTOFMEMORY; switch (IoControlCode) { case IOCTL_INTERNAL_USB_SUBMIT_URB:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_SUBMIT_URB""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_SUBMIT_URB: Unchecked""); break; case IOCTL_INTERNAL_USB_RESET_PORT:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_RESET_PORT""); break; case IOCTL_INTERNAL_USB_GET_PORT_STATUS:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_GET_PORT_STATUS""); success = pdev->query_device_port_status(pdev, &usbd_status, &OutputBufferSize, Stream_Pointer(out)); if (success) { if (!Stream_SafeSeek(out, OutputBufferSize)) { Stream_Free(out, TRUE); return ERROR_INVALID_DATA; } if (pdev->isExist(pdev) == 0) Stream_Write_UINT32(out, 0); else usb_process_get_port_status(pdev, out); } break; case IOCTL_INTERNAL_USB_CYCLE_PORT:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_CYCLE_PORT""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_CYCLE_PORT: Unchecked""); break; case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: Unchecked""); break; default: WLog_Print(urbdrc->log, WLOG_DEBUG, ""urbdrc_process_io_control: unknown IoControlCode 0x%"" PRIX32 """", IoControlCode); Stream_Free(out, TRUE); return ERROR_INVALID_OPERATION; } return stream_write_and_free(callback->plugin, callback->channel, out); }"
"PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args) { DWORD accessmask, acerevision, aceflags; BOOL bAuditSuccess, bAuditFailure; PyObject *obSID; GUID ObjectTypeGuid, InheritedObjectTypeGuid; GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL; PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid; BOOL bsuccess; PSID psid; PACL psacl; PyACL *This = (PyACL *)self; psacl = This->GetACL(); PACL psacl_padded = NULL; if (addauditaccessobjectace == NULL) return PyErr_Format(PyExc_NotImplementedError, ""AddAuditAccessObjectAce not supported by this version of Windows""); if (!PyArg_ParseTuple(args, ""lllOOOii:AddAuditAccessObjectAce"", &acerevision, &aceflags, &accessmask, &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure)) return NULL; if (obObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid)) return NULL; pObjectTypeGuid = &ObjectTypeGuid; } if (obInheritedObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid)) return NULL; pInheritedObjectTypeGuid = &InheritedObjectTypeGuid; } if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (!bsuccess) { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err); unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid); psacl_padded = (ACL *)malloc(required_size); if (psacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"", required_size); ZeroMemory(psacl_padded, required_size); memcpy(psacl_padded, psacl, psacl->AclSize); psacl_padded->AclSize = required_size; bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (bsuccess) bsuccess = This->SetACL(psacl_padded); else PyWin_SetAPIError(""AddAuditAccessObjectAce""); } if (psacl_padded) free(psacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }"
"int cmnd_matches_all(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info) { const bool negated = m->negated; struct sudo_command *c; int matched = UNSPEC; struct alias *a; debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH); switch (m->type) { case ALL: c = (struct sudo_command *)m->name; if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests)) matched = negated ? DENY : ALLOW; break; case ALIAS: a = alias_get(parse_tree, m->name, CMNDALIAS); if (a != NULL) { TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) { matched = cmnd_matches_all(parse_tree, m, runchroot, info); if (matched != UNSPEC) { if (negated) matched = matched == ALLOW ? DENY : ALLOW; break; } } alias_put(a); } break; } debug_return_int(matched); }"
"bool WebContents::SendIPCMessageToFrame(bool internal, int32_t frame_id, const std::string& channel, v8::Local<v8::Value> args) { v8::Isolate* isolate = JavascriptEnvironment::GetIsolate(); blink::CloneableMessage message; if (!gin::ConvertFromV8(isolate, args, &message)) { isolate->ThrowException(v8::Exception::Error( gin::StringToV8(isolate, ""Failed to serialize arguments""))); return false; } auto frames = web_contents()->GetAllFrames(); auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) { return f->GetRoutingID() == frame_id; }); if (iter == frames.end()) return false; if (!(*iter)->IsRenderFrameLive()) return false; mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer; (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer); electron_renderer->Message(internal, channel, std::move(message), 0 ); return true; }"
"bool  XmlRpcUtil::findTag(const char* tag, std::string const& xml, int* offset) { if (*offset >= int(xml.length())) return false; size_t istart = xml.find(tag, *offset); if (istart == std::string::npos) return false; *offset = int(istart + strlen(tag)); return true; }"
static const char * markdown_anchor(const char *text) { char          *bufptr;                 static char   buffer[1024];            for (bufptr = buffer; *text && bufptr < (buffer + sizeof(buffer) - 1); text ++) { if ((*text >= '0' && *text <= '9') || (*text >= 'a' && *text <= 'z') || (*text >= 'A' && *text <= 'Z') || *text == '.' || *text == '-') *bufptr++ = (char)tolower(*text); else if (*text == ' ') *bufptr++ = '-'; } *bufptr = '\0'; return (buffer); }
"static void perf_group_detach(struct perf_event *event) { struct perf_event *leader = event->group_leader; struct perf_event *sibling, *tmp; struct perf_event_context *ctx = event->ctx; lockdep_assert_held(&ctx->lock); if (!(event->attach_state & PERF_ATTACH_GROUP)) return; event->attach_state &= ~PERF_ATTACH_GROUP; perf_put_aux_event(event); if (leader != event) { list_del_init(&event->sibling_list); event->group_leader->nr_siblings--; goto out; } list_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) { if (sibling->event_caps & PERF_EV_CAP_SIBLING) perf_remove_sibling_event(sibling); sibling->group_leader = sibling; list_del_init(&sibling->sibling_list); sibling->group_caps = event->group_caps; if (sibling->attach_state & PERF_ATTACH_CONTEXT) { add_event_to_groups(sibling, event->ctx); if (sibling->state == PERF_EVENT_STATE_ACTIVE) list_add_tail(&sibling->active_list, get_event_list(sibling)); } WARN_ON_ONCE(sibling->ctx != event->ctx); } out: for_each_sibling_event(tmp, leader) perf_event__header_size(tmp); perf_event__header_size(leader); }"
"bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const { if (!IsIdentity(node) && !IsIdentityN(node)) { return true; } if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) { return false; } if (!fetch_nodes_known_) { return false; } const NodeDef* input = node_map_->GetNode(NodeName(node.input(0))); CHECK(input != nullptr) << ""node = "" << node.name() << "" input = "" << node.input(0); if (IsVariable(*input) || IsRecv(*input)) { return false; } for (const auto& consumer : node_map_->GetOutputs(node.name())) { if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) { return false; } if (IsSwitch(*input)) { for (const string& consumer_input : consumer->input()) { if (consumer_input == AsControlDependency(node.name())) { return false; } } } } return true; }"
"static int parse_user_name(char *user_input, char **ret_username) { register char *ptr; register int index = 0; char username[PAM_MAX_RESP_SIZE]; *ret_username = NULL; bzero((void *)username, PAM_MAX_RESP_SIZE); ptr = user_input; while ((*ptr == ' ') || (*ptr == '\t')) ptr++; if (*ptr == '\0') { return (PAM_BUF_ERR); } while (*ptr != '\0') { if ((*ptr == ' ') || (*ptr == '\t')) break; else { username[index] = *ptr; index++; ptr++; } } if ((*ret_username = malloc(index + 1)) == NULL) return (PAM_BUF_ERR); (void) strcpy(*ret_username, username); return (PAM_SUCCESS); }"
"void fx_ArrayBuffer_prototype_concat(txMachine* the) { txSlot* instance = fxCheckArrayBufferInstance(the, mxThis); txSlot* arrayBuffer = instance->next; txSlot* bufferInfo = arrayBuffer->next; txInteger length = bufferInfo->value.bufferInfo.length; txInteger c = mxArgc, i = 0; txByte* address; txSlot* slot; while (i < c) { arrayBuffer = C_NULL; bufferInfo = C_NULL; slot = mxArgv(i); if (slot->kind == XS_REFERENCE_KIND) { slot = slot->value.reference->next; if (slot && (slot->kind == XS_ARRAY_BUFFER_KIND)) arrayBuffer = slot; bufferInfo = slot->next; } if (arrayBuffer)  length = fxAddChunkSizes(the, length, bufferInfo->value.bufferInfo.length); else mxTypeError(""arguments[%ld] is no ArrayBuffer instance"", i); i++; } fxConstructArrayBufferResult(the, C_NULL, length); arrayBuffer = instance->next; bufferInfo = arrayBuffer->next; address = mxResult->value.reference->next->value.arrayBuffer.address; length = bufferInfo->value.bufferInfo.length; c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length); address += length; i = 0; while (i < c) { arrayBuffer = mxArgv(i)->value.reference->next; bufferInfo = arrayBuffer->next; length = bufferInfo->value.bufferInfo.length; c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length); address += length; i++; } }"
"static bool TryParse(const char* inp, int length, TypedValue* buf, Variant& out, JSONContainerType container_type, bool is_tsimplejson) { SimpleParser parser(inp, length, buf, container_type, is_tsimplejson); bool ok = parser.parseValue(); parser.skipSpace(); if (!ok || parser.p != inp + length) { tvDecRefRange(buf, parser.top); return false; } out = Variant::attach(*--parser.top); return true; }"
"static inline void gnttab_set_map_op(struct gnttab_map_grant_ref *map, phys_addr_t addr, uint32_t flags, grant_ref_t ref, domid_t domid) { if (flags & GNTMAP_contains_pte) map->host_addr = addr; else if (xen_feature(XENFEAT_auto_translated_physmap)) map->host_addr = __pa(addr); else map->host_addr = addr; map->flags = flags; map->ref = ref; map->dom = domid; }"
"explicit FractionalMaxPoolOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_)); OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_)); OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_)); OP_REQUIRES(context, pooling_ratio_.size() == 4, errors::InvalidArgument(""pooling_ratio field must "" ""specify 4 dimensions"")); OP_REQUIRES( context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1, errors::Unimplemented(""Fractional max pooling is not yet "" ""supported on the batch nor channel dimension."")); OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_)); OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_)); OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_)); if (deterministic_) { if ((seed_ == 0) && (seed2_ == 0)) { seed_ = random::New64(); seed2_ = random::New64(); } } else { OP_REQUIRES( context, (seed_ == 0) && (seed2_ == 0), errors::InvalidArgument( ""Both seed and seed2 should be 0 if deterministic is false."")); } }"
"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) { RList *bins = r_list_newf ((RListFree)free_bin); if (!bins) { return NULL; } char *target_libs = NULL; RList *target_lib_names = NULL; int *deps = NULL; target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER""); if (target_libs) { target_lib_names = r_str_split_list (target_libs, "":"", 0); if (!target_lib_names) { r_list_free (bins); return NULL; } deps = R_NEWS0 (int, cache->hdr->imagesCount); if (!deps) { r_list_free (bins); r_list_free (target_lib_names); return NULL; } } ut32 i; for (i = 0; i < cache->n_hdr; i++) { cache_hdr_t *hdr = &cache->hdr[i]; ut64 hdr_offset = cache->hdr_offset[i]; ut32 maps_index = cache->maps_index[i]; cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset); if (!img) { goto next; } ut32 j; ut16 *depArray = NULL; cache_imgxtr_t *extras = NULL; if (target_libs) { HtPU *path_to_idx = NULL; if (cache->accel) { depArray = R_NEWS0 (ut16, cache->accel->depListCount); if (!depArray) { goto next; } if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) { goto next; } extras = read_cache_imgextra (cache->buf, hdr, cache->accel); if (!extras) { goto next; } } else { path_to_idx = create_path_to_index (cache->buf, img, hdr); } for (j = 0; j < hdr->imagesCount; j++) { bool printing = !deps[j]; char *lib_name = get_lib_name (cache->buf, &img[j]); if (!lib_name) { break; } if (strstr (lib_name, ""libobjc.A.dylib"")) { deps[j]++; } if (!r_list_find (target_lib_names, lib_name, string_contains)) { R_FREE (lib_name); continue; } if (printing) { eprintf (""FILTER: %s\n"", lib_name); } R_FREE (lib_name); deps[j]++; if (extras && depArray) { ut32 k; for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) { ut16 dep_index = depArray[k] & 0x7fff; deps[dep_index]++; char *dep_name = get_lib_name (cache->buf, &img[dep_index]); if (!dep_name) { break; } if (printing) { eprintf (""-> %s\n"", dep_name); } free (dep_name); } } else if (path_to_idx) { carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing); } } ht_pu_free (path_to_idx); R_FREE (depArray); R_FREE (extras); } for (j = 0; j < hdr->imagesCount; j++) { if (deps && !deps[j]) { continue; } ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL); if (pa == UT64_MAX) { continue; } ut8 magicbytes[4]; r_buf_read_at (cache->buf, pa, magicbytes, 4); int magic = r_read_le32 (magicbytes); switch (magic) { case MH_MAGIC_64: { char file[256]; RDyldBinImage *bin = R_NEW0 (RDyldBinImage); if (!bin) { goto next; } bin->header_at = pa; bin->hdr_offset = hdr_offset; bin->symbols_off = resolve_symbols_off (cache, pa); bin->va = img[j].address; if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) { file[255] = 0; char *last_slash = strrchr (file, '/'); if (last_slash && *last_slash) { if (last_slash > file) { char *scan = last_slash - 1; while (scan > file && *scan != '/') { scan--; } if (*scan == '/') { bin->file = strdup (scan + 1); } else { bin->file = strdup (last_slash + 1); } } else { bin->file = strdup (last_slash + 1); } } else { bin->file = strdup (file); } } r_list_append (bins, bin); break; } default: eprintf (""Unknown sub-bin\n""); break; } } next: R_FREE (depArray); R_FREE (extras); R_FREE (img); } if (r_list_empty (bins)) { r_list_free (bins); bins = NULL; } R_FREE (deps); R_FREE (target_libs); r_list_free (target_lib_names); return bins; }"
"sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols) { RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" ); OSL_ENSURE(m_pBuffer,""Buffer is NULL!""); if ( !m_pBuffer ) return sal_False; sal_Int32 nByteOffset  = 1; Reference<XPropertySet> xCol; Reference<XPropertySet> xIndex; sal_uInt16 i; ::rtl::OUString aColName; const sal_Int32 nColumnCount = m_pColumns->getCount(); ::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount); ::comphelper::UStringMixEqual aCase(isCaseSensitive()); Reference<XIndexAccess> xColumns = m_pColumns; for (i = 0; i < nColumnCount; ++i) { sal_Int32 nPos = i; if(_xCols != xColumns) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; for(nPos = 0;nPos<_xCols->getCount();++nPos) { Reference<XPropertySet> xFindCol; ::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos)); OSL_ENSURE(xFindCol.is(),""ODbaseTable::UpdateBuffer column is null!""); if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName)) break; } if (nPos >= _xCols->getCount()) continue; } ++nPos; xIndex = isUniqueByColumnName(i); aIndexedCols[i] = xIndex; if (xIndex.is()) { if(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos])) continue; else { Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY); OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!""); ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) ); OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!""); if (pIndex->Find(0,*rRow.get()[nPos])) { if ( !aColName.getLength() ) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; xCol.clear(); }                     const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_DUPLICATE_VALUE_IN_COLUMN ,""$columnname$"", aColName ) ); ::dbtools::throwGenericSQLException( sError, *this ); } } } } for (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i) { OSL_ENSURE(i < m_aPrecisions.size(),""Illegal index!""); sal_Int32 nLen = 0; sal_Int32 nType = 0; sal_Int32 nScale = 0; if ( i < m_aPrecisions.size() ) { nLen= m_aPrecisions[i]; nType= m_aTypes[i]; nScale= m_aScales[i]; } else { m_pColumns->getByIndex(i) >>= xCol; if ( xCol.is() ) { xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))>>= nLen; xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))>>= nType; xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))>>= nScale; } } bool bSetZero = false; switch (nType) { case DataType::INTEGER: case DataType::DOUBLE: case DataType::TIMESTAMP: bSetZero = true; case DataType::LONGVARBINARY: case DataType::DATE: case DataType::BIT: case DataType::LONGVARCHAR: nLen = m_aRealFieldLengths[i];  break; case DataType::DECIMAL: nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale); break;default: break; }  sal_Int32 nPos = i; if(_xCols != xColumns) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; for(nPos = 0;nPos<_xCols->getCount();++nPos) { Reference<XPropertySet> xFindCol; ::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos)); if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName)) break; } if (nPos >= _xCols->getCount()) { nByteOffset += nLen; continue; } } ++nPos; if ( !rRow.get()[nPos]->isBound() ) { nByteOffset += nLen; continue; } if (aIndexedCols[i].is()) { Reference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY); OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!""); ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) ); OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!""); if (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )pIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]); else pIndex->Insert(m_nFilePos,*rRow.get()[nPos]); } char* pData = (char *)(m_pBuffer + nByteOffset); if (rRow.get()[nPos]->getValue().isNull()) { if ( bSetZero ) memset(pData,0,nLen);            else memset(pData,' ',nLen);nByteOffset += nLen; OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!""); continue; } sal_Bool bHadError = sal_False; try { switch (nType) { case DataType::TIMESTAMP: { sal_Int32 nJulianDate = 0, nJulianTime = 0; lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue()); memcpy(pData,&nJulianDate,4); memcpy(pData+4,&nJulianTime,4); } break; case DataType::DATE: { ::com::sun::star::util::Date aDate; if(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE) aDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble()); else aDate = rRow.get()[nPos]->getValue(); char s[9]; snprintf(s, sizeof(s), ""%04d%02d%02d"", (int)aDate.Year, (int)aDate.Month, (int)aDate.Day); strncpy(pData,s,sizeof s - 1); } break; case DataType::INTEGER: { sal_Int32 nValue = rRow.get()[nPos]->getValue(); memcpy(pData,&nValue,nLen); } break; case DataType::DOUBLE: { const double d = rRow.get()[nPos]->getValue(); m_pColumns->getByIndex(i) >>= xCol; if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY))))                         { sal_Int64 nValue = 0; if ( m_aScales[i] ) nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i])); else nValue = (sal_Int64)(d); memcpy(pData,&nValue,nLen); }                         else memcpy(pData,&d,nLen); } break; case DataType::DECIMAL: { memset(pData,' ',nLen); const double n = rRow.get()[nPos]->getValue(); const ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0)); sal_Bool bValidLength  = aDefaultValue.Len() <= nLen; if ( bValidLength ) { strncpy(pData,aDefaultValue.GetBuffer(),nLen); *rRow.get()[nPos] = toDouble(aDefaultValue); } else { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes; aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", aColName)); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(nLen))); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(nScale))); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8))); const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_INVALID_COLUMN_DECIMAL_VALUE ,aStringToSubstitutes ) ); ::dbtools::throwGenericSQLException( sError, *this ); } } break; case DataType::BIT: *pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F'; break; case DataType::LONGVARBINARY: case DataType::LONGVARCHAR: { char cNext = pData[nLen]; pData[nLen] = '\0';   sal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10); pData[nLen] = cNext; if (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo)) break; ByteString aStr; ByteString aBlock(ByteString::CreateFromInt32(nBlockNo)); aStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' ); aStr += aBlock; memset(pData,' ',nLen);memcpy(pData, aStr.GetBuffer(), nLen); }break; default: { memset(pData,' ',nLen); ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() ); ::rtl::OString sEncoded; DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding ); memcpy( pData, sEncoded.getStr(), sEncoded.getLength() ); } break; } } catch( SQLException&  ) { throw; } catch ( Exception& ) { bHadError = sal_True; } if ( bHadError ) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE( xCol.is(), ""ODbaseTable::UpdateBuffer column is null!"" ); if ( xCol.is() ) xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_INVALID_COLUMN_VALUE, ""$columnname$"", aColName ) ); ::dbtools::throwGenericSQLException( sError, *this ); } nByteOffset += nLen; OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!""); } return sal_True; }"
"int romfs_dev_read(struct super_block *sb, unsigned long pos, void *buf, size_t buflen) { size_t limit; limit = romfs_maxsize(sb); if (pos >= limit) return -EIO; if (buflen > limit - pos) buflen = limit - pos; #ifdef CONFIG_ROMFS_ON_MTD if (sb->s_mtd) return romfs_mtd_read(sb, pos, buf, buflen); #endif #ifdef CONFIG_ROMFS_ON_BLOCK if (sb->s_bdev) return romfs_blk_read(sb, pos, buf, buflen); #endif return -EIO; }"
"int mailpop3_stls(mailpop3 * f) { char command[POP3_STRING_SIZE]; int r; char * response; snprintf(command, POP3_STRING_SIZE, ""STLS\r\n""); r = send_command(f, command); if (r == -1) return MAILPOP3_ERROR_STREAM; response = read_line(f); if (response == NULL) return MAILPOP3_ERROR_STREAM; r = parse_response(f, response); if (r != RESPONSE_OK) return MAILPOP3_ERROR_STLS_NOT_SUPPORTED; return MAILPOP3_NO_ERROR; }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"char * did_set_spelllang(win_T *wp) { garray_Tga; char_u*splp; char_u*region; char_uregion_cp[3]; intfilename; intregion_mask; slang_T*slang; intc; char_ulang[MAXWLEN + 1]; char_uspf_name[MAXPATHL]; intlen; char_u*p; intround; char_u*spf; char_u*use_region = NULL; intdont_use_region = FALSE; intnobreak = FALSE; inti, j; langp_T*lp, *lp2; static intrecursive = FALSE; char*ret_msg = NULL; char_u*spl_copy; bufref_Tbufref; set_bufref(&bufref, wp->w_buffer); if (recursive) return NULL; recursive = TRUE; ga_init2(&ga, sizeof(langp_T), 2); clear_midword(wp); spl_copy = vim_strsave(wp->w_s->b_p_spl); if (spl_copy == NULL) goto theend; wp->w_s->b_cjk = 0; for (splp = spl_copy; *splp != NUL; ) { copy_option_part(&splp, lang, MAXWLEN, "",""); region = NULL; len = (int)STRLEN(lang); if (!valid_spelllang(lang)) continue; if (STRCMP(lang, ""cjk"") == 0) { wp->w_s->b_cjk = 1; continue; } if (len > 4 && fnamecmp(lang + len - 4, "".spl"") == 0) { filename = TRUE; p = vim_strchr(gettail(lang), '_'); if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2]) && !ASCII_ISALPHA(p[3])) { vim_strncpy(region_cp, p + 1, 2); mch_memmove(p, p + 3, len - (p - lang) - 2); region = region_cp; } else dont_use_region = TRUE; FOR_ALL_SPELL_LANGS(slang) if (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME) break; } else { filename = FALSE; if (len > 3 && lang[len - 3] == '_') { region = lang + len - 2; len -= 3; lang[len] = NUL; } else dont_use_region = TRUE; FOR_ALL_SPELL_LANGS(slang) if (STRICMP(lang, slang->sl_name) == 0) break; } if (region != NULL) { if (use_region != NULL && STRCMP(region, use_region) != 0) dont_use_region = TRUE; use_region = region; } if (slang == NULL) { if (filename) (void)spell_load_file(lang, lang, NULL, FALSE); else { spell_load_lang(lang); if (!bufref_valid(&bufref)) { ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer); goto theend; } } } FOR_ALL_SPELL_LANGS(slang) if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME : STRICMP(lang, slang->sl_name) == 0) { region_mask = REGION_ALL; if (!filename && region != NULL) { c = find_region(slang->sl_regions, region); if (c == REGION_ALL) { if (slang->sl_add) { if (*slang->sl_regions != NUL) region_mask = 0; } else smsg(_(""Warning: region %s not supported""), region); } else region_mask = 1 << c; } if (region_mask != 0) { if (ga_grow(&ga, 1) == FAIL) { ga_clear(&ga); ret_msg = e_out_of_memory; goto theend; } LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang; LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask; ++ga.ga_len; use_midword(slang, wp); if (slang->sl_nobreak) nobreak = TRUE; } } } spf = curwin->w_s->b_p_spf; for (round = 0; round == 0 || *spf != NUL; ++round) { if (round == 0) { if (int_wordlist == NULL) continue; int_wordlist_spl(spf_name); } else { copy_option_part(&spf, spf_name, MAXPATHL - 5, "",""); STRCAT(spf_name, "".spl""); for (c = 0; c < ga.ga_len; ++c) { p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname; if (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE) == FPC_SAME) break; } if (c < ga.ga_len) continue; } FOR_ALL_SPELL_LANGS(slang) if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE) == FPC_SAME) break; if (slang == NULL) { if (round == 0) STRCPY(lang, ""internal wordlist""); else { vim_strncpy(lang, gettail(spf_name), MAXWLEN); p = vim_strchr(lang, '.'); if (p != NULL) *p = NUL;    } slang = spell_load_file(spf_name, lang, NULL, TRUE); if (slang != NULL && nobreak) slang->sl_nobreak = TRUE; } if (slang != NULL && ga_grow(&ga, 1) == OK) { region_mask = REGION_ALL; if (use_region != NULL && !dont_use_region) { c = find_region(slang->sl_regions, use_region); if (c != REGION_ALL) region_mask = 1 << c; else if (*slang->sl_regions != NUL) region_mask = 0; } if (region_mask != 0) { LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang; LANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL; LANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL; LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask; ++ga.ga_len; use_midword(slang, wp); } } } ga_clear(&wp->w_s->b_langp); wp->w_s->b_langp = ga; for (i = 0; i < ga.ga_len; ++i) { lp = LANGP_ENTRY(ga, i); if (lp->lp_slang->sl_sal.ga_len > 0) lp->lp_sallang = lp->lp_slang; else for (j = 0; j < ga.ga_len; ++j) { lp2 = LANGP_ENTRY(ga, j); if (lp2->lp_slang->sl_sal.ga_len > 0 && STRNCMP(lp->lp_slang->sl_name, lp2->lp_slang->sl_name, 2) == 0) { lp->lp_sallang = lp2->lp_slang; break; } } if (lp->lp_slang->sl_rep.ga_len > 0) lp->lp_replang = lp->lp_slang; else for (j = 0; j < ga.ga_len; ++j) { lp2 = LANGP_ENTRY(ga, j); if (lp2->lp_slang->sl_rep.ga_len > 0 && STRNCMP(lp->lp_slang->sl_name, lp2->lp_slang->sl_name, 2) == 0) { lp->lp_replang = lp2->lp_slang; break; } } } redraw_win_later(wp, UPD_NOT_VALID); theend: vim_free(spl_copy); recursive = FALSE; return ret_msg; }"
"void mrb_proc_copy(struct RProc *a, struct RProc *b) { if (a->body.irep) { return; } a->flags = b->flags; a->body = b->body; if (!MRB_PROC_CFUNC_P(a) && a->body.irep) { mrb_irep_incref(NULL, (mrb_irep*)a->body.irep); } a->upper = b->upper; a->e.env = b->e.env; }"
"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx) { u32 pck_size = 0; GF_FilterPacket *pck = NULL; u8 *output = NULL; if (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM; gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc); if (!pck_size) { GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[AV1Dmx] no frame OBU, skipping OBU\n"")); return GF_OK; } pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output); if (!pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck); gf_filter_pck_set_cts(pck, ctx->cts); gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0); memcpy(output, ctx->state.frame_obus, pck_size); if (ctx->deps) { u8 flags = 0; flags = ( ctx->state.frame_state.key_frame) ? 2 : 1; flags <<= 2; flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2; flags <<= 2; gf_filter_pck_set_dependency_flags(pck, flags); } if (ctx->state.clli_valid) { u32 crc = gf_crc_32(ctx->state.clli_data, 4); if (crc != ctx->clli_crc) { gf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4)); } } if (ctx->state.mdcv_valid) { u32 crc = gf_crc_32(ctx->state.mdcv_data, 24); if (crc != ctx->mdcv_crc) { av1dmx_set_mdcv(ctx, NULL, pck); } } gf_filter_pck_send(pck); av1dmx_update_cts(ctx); gf_av1_reset_state(&ctx->state, GF_FALSE); return GF_OK; }"
"static void nhmldump_send_frame(GF_NHMLDumpCtx *ctx, char *data, u32 data_size, GF_FilterPacket *pck) { GF_FilterPacket *dst_pck; char nhml[1024]; const GF_PropertyValue *p; u32 size; u8 *output; GF_FilterSAPType sap = gf_filter_pck_get_sap(pck); u64 dts = gf_filter_pck_get_dts(pck); u64 cts = gf_filter_pck_get_cts(pck); if (dts==GF_FILTER_NO_TS) dts = cts; if (cts==GF_FILTER_NO_TS) cts = dts; ctx->pck_num++; sprintf(nhml, ""<NHNTSample number=\""%d\"" DTS=\""""LLU""\"" dataLength=\""%d\"" "", ctx->pck_num, dts, data_size); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if (ctx->pckp || (cts != dts) ) { sprintf(nhml, ""CTSOffset=\""%d\"" "", (s32) ((s64)cts - (s64)dts)); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } if (sap==GF_FILTER_SAP_1) { sprintf(nhml, ""isRAP=\""yes\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (sap) { sprintf(nhml, ""SAPType=\""%d\"" "", sap); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (ctx->pckp) { sprintf(nhml, ""isRAP=\""no\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if ((sap==GF_FILTER_SAP_4) || (sap==GF_FILTER_SAP_4_PROL)) { s32 roll = gf_filter_pck_get_roll_info(pck); sprintf(nhml, ""SAPType=\""4\"" %s=\""%d\"" "", (sap==GF_FILTER_SAP_4_PROL) ? ""prol"" : ""roll"", roll); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } if (ctx->pckp) { u64 bo; u32 duration, idx; sprintf(nhml, ""mediaOffset=\""""LLU""\"" "", ctx->mdia_pos); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); bo = gf_filter_pck_get_byte_offset(pck); if (bo!=GF_FILTER_NO_BO) { sprintf(nhml, ""sourceByteOffset=\""""LLU""\"" "", bo); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } duration = gf_filter_pck_get_duration(pck); if (duration) { sprintf(nhml, ""duration=\""%d\"" "", duration); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = gf_filter_pck_get_carousel_version(pck); if (idx) { sprintf(nhml, ""carouselVersion=\""%d\"" "", idx); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = 0; while (1) { u32 prop_4cc; const char *prop_name; p = gf_filter_pck_enum_properties(pck, &idx, &prop_4cc, &prop_name); if (!p) break; if (prop_4cc == GF_PROP_PCK_SUBS) continue; nhmldump_pck_property(ctx, prop_4cc, prop_name, p); } } if (ctx->chksum) { if (ctx->chksum==1) { u32 crc = gf_crc_32(data, data_size); sprintf(nhml, ""crc=\""%08X\"" "", crc); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 j; u8 hash[GF_SHA1_DIGEST_SIZE]; gf_sha1_csum(data, data_size, hash); sprintf(nhml, ""sha1=\""""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); for (j=0; j<20; j++) { sprintf(nhml, ""%02X"", hash[j]); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } sprintf(nhml, "">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); p = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS); if (p) { u32 offset_in_sample = 0; Bool first_subs = GF_TRUE; if (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ); else gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size); while (gf_bs_available(ctx->bs_r)) { u32 s_flags = gf_bs_read_u32(ctx->bs_r); u32 s_size = gf_bs_read_u32(ctx->bs_r); u32 s_res = gf_bs_read_u32(ctx->bs_r); u8 s_prio = gf_bs_read_u8(ctx->bs_r); u8 s_discard = gf_bs_read_u8(ctx->bs_r); if (offset_in_sample + s_size > data_size) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""Wrong subsample info: sample size %d vs subsample offset+size %dn"", data_size, offset_in_sample + s_size)); break; } if (ctx->is_stpp && ctx->nhmlonly) { if (first_subs) { sprintf(nhml, ""<NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, s_size); sprintf(nhml, ""</NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 d_size; if (ctx->b64_buffer_size<2*s_size) { ctx->b64_buffer_size = 2 * s_size; ctx->b64_buffer = gf_realloc(ctx->b64_buffer, ctx->b64_buffer_size); } d_size = gf_base64_encode(data + offset_in_sample, s_size, ctx->b64_buffer, ctx->b64_buffer_size); ctx->b64_buffer[d_size] = 0; sprintf(nhml, ""<NHNTSubSample data=\""data:application/octet-string;base64,""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, ctx->b64_buffer, d_size); sprintf(nhml, ""\"">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } else { sprintf(nhml, ""<NHNTSubSample size=\""%d\"" flags=\""%d\"" reserved=\""%d\"" priority=\""%d\"" discard=\""%d\"" />\n"", s_size, s_flags, s_res, s_prio, s_discard); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } first_subs = GF_FALSE; } } else if (ctx->is_stpp && ctx->nhmlonly) { sprintf(nhml, ""<NHNTSubSample><![CDATA[\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, data_size); sprintf(nhml, ""]]></NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""</NHNTSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size); if (ctx->filep) { gf_fwrite(ctx->nhml_buffer, size, ctx->filep); return; } dst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output); if (dst_pck) { memcpy(output, ctx->nhml_buffer, size); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_send(dst_pck); } ctx->mdia_pos += data_size; if (ctx->opid_mdia) { dst_pck = gf_filter_pck_new_ref(ctx->opid_mdia, 0, data_size, pck); if (!dst_pck) return; gf_filter_pck_merge_properties(pck, dst_pck); gf_filter_pck_set_framing(dst_pck, ctx->first, GF_FALSE); gf_filter_pck_send(dst_pck); } }"
"njs_int_t njs_object_property(njs_vm_t *vm, njs_object_t *object, njs_lvlhsh_query_t *lhq, njs_value_t *retval) { njs_int_t          ret; njs_value_t        value; njs_object_prop_t  *prop; do { ret = njs_lvlhsh_find(&object->hash, lhq); if (njs_fast_path(ret == NJS_OK)) { goto found; } ret = njs_lvlhsh_find(&object->shared_hash, lhq); if (njs_fast_path(ret == NJS_OK)) { goto found; } object = object->__proto__; } while (object != NULL); njs_set_undefined(retval); return NJS_DECLINED; found: prop = lhq->value; if (njs_is_data_descriptor(prop)) { njs_value_assign(retval, njs_prop_value(prop)); return NJS_OK; } if (njs_prop_getter(prop) == NULL) { njs_set_undefined(retval); return NJS_OK; } njs_set_object(&value, object); return njs_function_apply(vm, njs_prop_getter(prop), &value, 1, retval); }"
"bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  ) { m_serviceHandle = CreateService( m_serviceManager,WindowsCoreFunctions::toConstWCharArray( m_name ),WindowsCoreFunctions::toConstWCharArray( displayName ),SERVICE_ALL_ACCESS,SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START,SERVICE_ERROR_NORMAL,WindowsCoreFunctions::toConstWCharArray( filePath ),nullptr,nullptr,L""Tcpip\0RpcSs\0\0"",nullptr,nullptr ); if( m_serviceHandle == nullptr ) { const auto error = GetLastError(); if( error == ERROR_SERVICE_EXISTS ) { vCritical() << qUtf8Printable( tr( ""The service \""%1\"" is already installed."" ).arg( m_name ) ); } else { vCritical() << qUtf8Printable( tr( ""The service \""%1\"" could not be installed."" ).arg( m_name ) ); } return false; } SC_ACTION serviceActions; serviceActions.Delay = 10000; serviceActions.Type = SC_ACTION_RESTART; SERVICE_FAILURE_ACTIONS serviceFailureActions; serviceFailureActions.dwResetPeriod = 0; serviceFailureActions.lpRebootMsg = nullptr; serviceFailureActions.lpCommand = nullptr; serviceFailureActions.lpsaActions = &serviceActions; serviceFailureActions.cActions = 1; ChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions ); vInfo() << qUtf8Printable( tr( ""The service \""%1\"" has been installed successfully."" ).arg( m_name ) ); return true; }"
inline int StringData::size() const { return m_len; }
"void CalculateOutputIndexValueRowID( const RowPartitionTensor& value_rowids, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { const INDEX_TYPE index_size = value_rowids.size(); result->reserve(index_size); if (index_size == 0) { return; } INDEX_TYPE current_output_column = 0; INDEX_TYPE current_value_rowid = value_rowids(0); DCHECK_LT(current_value_rowid, parent_output_index.size()); INDEX_TYPE current_output_index = parent_output_index[current_value_rowid]; result->push_back(current_output_index); for (INDEX_TYPE i = 1; i < index_size; ++i) { INDEX_TYPE next_value_rowid = value_rowids(i); if (next_value_rowid == current_value_rowid) { if (current_output_index >= 0) { ++current_output_column; if (current_output_column < output_size) { current_output_index += output_index_multiplier; } else { current_output_index = -1; } } } else { current_output_column = 0; current_value_rowid = next_value_rowid; DCHECK_LT(next_value_rowid, parent_output_index.size()); current_output_index = parent_output_index[next_value_rowid]; } result->push_back(current_output_index); } DCHECK_EQ(result->size(), value_rowids.size()); }"
"void svhandler_flash_erase_sector(void) { uint32_t sector = _param_1; if ((sector == FLASH_BOOTSTRAP_SECTOR) || (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) { return; } flash_clear_status_flags(); flash_unlock(); flash_erase_sector(sector, FLASH_CR_PROGRAM_X32); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }"
"static char** parse_attributes(const char *line, s_accumulated_attributes *attributes) { int int_value, i; char **ret; char *end_ptr; if (line == NULL) return NULL; if (!safe_start_equals(""#EXT"", line)) return NULL; if (safe_start_equals(""#EXT-X-ENDLIST"", line)) { attributes->is_playlist_ended = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); return NULL; } attributes->type = MEDIA_TYPE_UNKNOWN; ret = extract_attributes(""#EXT-X-TARGETDURATION:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32) strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->target_duration_in_seconds = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-MEDIA-SEQUENCE:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->min_media_sequence = int_value; attributes->current_media_seq = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-VERSION:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->version = int_value; } M3U8_COMPATIBILITY_VERSION(1); } return ret; } ret = extract_attributes(""#EXTINF:"", line, 2); if (ret) { M3U8_COMPATIBILITY_VERSION(1); attributes->is_media_segment = GF_TRUE; if (ret[0]) { double double_value = strtod(ret[0], &end_ptr); if (end_ptr != ret[0]) { attributes->duration_in_seconds = double_value; } if (strstr(ret[0], ""."") || (double_value > (int)double_value)) { M3U8_COMPATIBILITY_VERSION(3); } } if (ret[1]) { if (attributes->title) gf_free(attributes->title); attributes->title = gf_strdup(ret[1]); } return ret; } ret = extract_attributes(""#EXT-X-KEY:"", line, 4); if (ret) { const char *method = ""METHOD=""; const size_t method_len = strlen(method); if (safe_start_equals(method, ret[0])) { if (!strncmp(ret[0]+method_len, ""NONE"", 4)) { attributes->key_method = DRM_NONE; if (attributes->key_url) { gf_free(attributes->key_url); attributes->key_url = NULL; } } else if (!strncmp(ret[0]+method_len, ""AES-128"", 7)) { attributes->key_method = DRM_AES_128; } else if (!strncmp(ret[0]+method_len, ""SAMPLE-AES"", 10)) { attributes->key_method = DRM_CENC; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] EXT-X-KEY method not recognized.\n"")); } if (ret[1] != NULL && safe_start_equals(""URI=\"""", ret[1])) { int_value = (u32) strlen(ret[1]); if (ret[1][int_value-1] == '""') { if (attributes->key_url) gf_free(attributes->key_url); attributes->key_url = gf_strdup(&(ret[1][5])); if (attributes->key_url) { u32 klen = (u32) strlen(attributes->key_url); attributes->key_url[klen-1] = 0; } } } attributes->has_iv = GF_FALSE; if (ret[2] != NULL && safe_start_equals(""IV="", ret[2])) { char *IV = ret[2] + 3; if (!strncmp(IV, ""0x"", 2)) IV+=2; if (strlen(IV) != 32) { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] EXT-X-KEY wrong IV len\n"")); } else { for (i=0; i<16; i++) { char szV[3]; u32 v; szV[0] = IV[2*i]; szV[1] = IV[2*i + 1]; szV[2] = 0; sscanf(szV, ""%X"", &v); attributes->key_iv[i] = v; } } attributes->has_iv = GF_TRUE; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-PROGRAM-DATE-TIME:"", line, 1); if (ret) { if (ret[0]) attributes->playlist_utc_timestamp = gf_net_parse_date(ret[0]); M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-ALLOW-CACHE:"", line, 1); if (ret) { GF_LOG(GF_LOG_INFO, GF_LOG_DASH,(""[M3U8] EXT-X-ALLOW-CACHE not supported.\n"", line)); M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-PLAYLIST-TYPE"", line, 1); if (ret) { if (ret[0] && !strcmp(ret[0], ""VOD"")) attributes->is_playlist_ended = GF_TRUE; M3U8_COMPATIBILITY_VERSION(3); return ret; } ret = extract_attributes(""#EXT-X-MAP"", line, 4); if (ret) { i=0; while (ret[i] != NULL) { char *val = ret[i]; if (val[0]==':') val++; if (safe_start_equals(""URI=\"""", val)) { char *uri = val + 5; int_value = (u32) strlen(uri); if (int_value > 0 && uri[int_value-1] == '""') { if (attributes->init_url) gf_free(attributes->init_url); attributes->init_url = gf_strdup(uri); attributes->init_url[int_value-1]=0; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid URI (%s) in EXT-X-MAP\n"", val)); } } else if (safe_start_equals(""BYTERANGE=\"""", val)) { u64 begin, size; val+=10; if (sscanf(val, ""\""""LLU""@""LLU""\"""", &size, &begin) == 2) { if (size) { attributes->init_byte_range_start = begin; attributes->init_byte_range_end = begin + size - 1; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid byte range %s\n"", val)); } } } i++; } M3U8_COMPATIBILITY_VERSION(3); return ret; } ret = extract_attributes(""#EXT-X-STREAM-INF:"", line, 10); if (ret) { i = 0; attributes->is_master_playlist = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); while (ret[i] != NULL) { char *utility; if (safe_start_equals(""BANDWIDTH="", ret[i])) { utility = &(ret[i][10]); int_value = (s32) strtol(utility, &end_ptr, 10); if (end_ptr != utility) attributes->bandwidth = int_value; } else if (safe_start_equals(""PROGRAM-ID="", ret[i])) { utility = &(ret[i][11]); int_value = (s32) strtol(utility, &end_ptr, 10); if (end_ptr != utility) attributes->stream_id = int_value; } else if (safe_start_equals(""CODECS=\"""", ret[i])) { int_value = (u32) strlen(ret[i]); if (ret[i][int_value-1] == '""') { if (attributes->codecs) gf_free(attributes->codecs); attributes->codecs = gf_strdup(&(ret[i][7])); } } else if (safe_start_equals(""RESOLUTION="", ret[i])) { u32 w, h; utility = &(ret[i][11]); if ((sscanf(utility, ""%dx%d"", &w, &h)==2) || (sscanf(utility, ""%dx%d,"", &w, &h)==2)) { attributes->width = w; attributes->height = h; } M3U8_COMPATIBILITY_VERSION(2); } else if (safe_start_equals(""AUDIO="", ret[i])) { assert(attributes->type == MEDIA_TYPE_UNKNOWN); attributes->type = MEDIA_TYPE_AUDIO; if (attributes->group.audio) gf_free(attributes->group.audio); attributes->group.audio = gf_strdup(ret[i] + 6); M3U8_COMPATIBILITY_VERSION(4); } else if (safe_start_equals(""VIDEO="", ret[i])) { assert(attributes->type == MEDIA_TYPE_UNKNOWN); attributes->type = MEDIA_TYPE_VIDEO; if (attributes->group.video) gf_free(attributes->group.video); attributes->group.video = gf_strdup(ret[i] + 6); M3U8_COMPATIBILITY_VERSION(4); } i++; } if (!attributes->bandwidth) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-STREAM-INF: no BANDWIDTH found. Ignoring the line.\n"")); return NULL; } return ret; } ret = extract_attributes(""#EXT-X-DISCONTINUITY"", line, 0); if (ret) { attributes->discontinuity = 1; M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-DISCONTINUITY-SEQUENCE"", line, 0); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->discontinuity = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-BYTERANGE:"", line, 1); if (ret) { if (ret[0]) { u64 begin, size; if (sscanf(ret[0], LLU""@""LLU, &size, &begin) == 2) { if (size) { attributes->byte_range_start = begin; attributes->byte_range_end = begin + size - 1; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid byte range %s\n"", ret[0])); } } } M3U8_COMPATIBILITY_VERSION(4); return ret; } ret = extract_attributes(""#EXT-X-MEDIA:"", line, 14); if (ret) { M3U8_COMPATIBILITY_VERSION(4); attributes->is_master_playlist = GF_TRUE; i = 0; while (ret[i] != NULL) { if (safe_start_equals(""TYPE="", ret[i])) { if (!strncmp(ret[i]+5, ""AUDIO"", 5)) { attributes->type = MEDIA_TYPE_AUDIO; } else if (!strncmp(ret[i]+5, ""VIDEO"", 5)) { attributes->type = MEDIA_TYPE_VIDEO; } else if (!strncmp(ret[i]+5, ""SUBTITLES"", 9)) { attributes->type = MEDIA_TYPE_SUBTITLES; } else if (!strncmp(ret[i]+5, ""CLOSED-CAPTIONS"", 15)) { attributes->type = MEDIA_TYPE_CLOSED_CAPTIONS; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Unsupported #EXT-X-MEDIA:TYPE=%s\n"", ret[i]+5)); } } else if (safe_start_equals(""URI=\"""", ret[i])) { size_t len; if (attributes->mediaURL) gf_free(attributes->mediaURL); attributes->mediaURL = gf_strdup(ret[i]+5); len = strlen(attributes->mediaURL); if (len && (attributes->mediaURL[len-1] == '""')) { attributes->mediaURL[len-1] = '\0'; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Misformed #EXT-X-MEDIA:URI=%s. Quotes are incorrect.\n"", ret[i]+5)); } } else if (safe_start_equals(""GROUP-ID="", ret[i])) { if (attributes->type == MEDIA_TYPE_AUDIO) { if (attributes->group.audio) gf_free(attributes->group.audio); attributes->group.audio = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(AUDIO, attributes->group.audio); } else if (attributes->type == MEDIA_TYPE_VIDEO) { if (attributes->group.video) gf_free(attributes->group.video); attributes->group.video = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(VIDEO, attributes->group.video); } else if (attributes->type == MEDIA_TYPE_SUBTITLES) { if (attributes->group.subtitle) gf_free(attributes->group.subtitle); attributes->group.subtitle = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(SUBTITLES, attributes->group.subtitle); } else if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS) { if (attributes->group.closed_captions) gf_free(attributes->group.closed_captions); attributes->group.closed_captions = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(CLOSED_CAPTIONS, attributes->group.closed_captions); } else if (attributes->type == MEDIA_TYPE_UNKNOWN) { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:GROUP-ID=%s. Ignoring the line.\n"", ret[i]+9)); return NULL; } } else if (safe_start_equals(""LANGUAGE=\"""", ret[i])) { size_t len; if (attributes->language) gf_free(attributes->language); attributes->language = gf_strdup(ret[i]+9); len = strlen(attributes->language); if (len && (attributes->language[len-1] == '""')) { attributes->language[len-1] = '\0'; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Misformed #EXT-X-MEDIA:LANGUAGE=%s. Quotes are incorrect.\n"", ret[i]+5)); } } else if (safe_start_equals(""NAME="", ret[i])) { if (attributes->name) gf_free(attributes->name); attributes->name = gf_strdup(ret[i]+5+1); u32 len = (u32) strlen(attributes->name); if (len) attributes->name[len-1]=0; } else if (safe_start_equals(""DEFAULT="", ret[i])) { if (!strncmp(ret[i]+8, ""YES"", 3)) { attributes->is_default = GF_TRUE; } else if (!strncmp(ret[i]+8, ""NO"", 2)) { attributes->is_default = GF_FALSE; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:DEFAULT=%s\n"", ret[i]+8)); } } else if (safe_start_equals(""AUTOSELECT="", ret[i])) { if (!strncmp(ret[i]+11, ""YES"", 3)) { attributes->is_autoselect = GF_TRUE; } else if (!strncmp(ret[i]+11, ""NO"", 2)) { attributes->is_autoselect = GF_TRUE; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:AUTOSELECT=%s\n"", ret[i]+11)); } } else if (safe_start_equals(""CHANNELS="", ret[i])) { sscanf(ret[i] + 9, ""\""%u\"""", &attributes->channels); } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Attribute %s not supported\n"", ret[i])); } i++; } if (attributes->type == MEDIA_TYPE_UNKNOWN) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: TYPE is missing. Ignoring the line.\n"")); return NULL; } if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS && attributes->mediaURL) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: TYPE is CLOSED-CAPTIONS but URI is present. Ignoring the URI.\n"")); gf_free(attributes->mediaURL); attributes->mediaURL = NULL; } if ((attributes->type == MEDIA_TYPE_AUDIO && !attributes->group.audio) || (attributes->type == MEDIA_TYPE_VIDEO && !attributes->group.video)) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: missing GROUP-ID attribute. Ignoring the line.\n"")); return NULL; } if (!attributes->stream_id) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: no ID was computed. Check previous errors. Ignoring the line.\n"")); return NULL; } return ret; } if (!strncmp(line, ""#EXT-X-INDEPENDENT-SEGMENTS"", strlen(""#EXT-X-INDEPENDENT-SEGMENTS"") )) { attributes->independent_segments = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); return NULL; } if (!strncmp(line, ""#EXT-X-I-FRAME-STREAM-INF"", strlen(""#EXT-X-I-FRAME-STREAM-INF"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-PART-INF"", strlen(""#EXT-X-PART-INF"") )) { attributes->low_latency = GF_TRUE; return NULL; } if (!strncmp(line, ""#EXT-X-SERVER-CONTROL"", strlen(""#EXT-X-SERVER-CONTROL"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-PRELOAD-HINT"", strlen(""#EXT-X-PRELOAD-HINT"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-RENDITION-REPORT"", strlen(""#EXT-X-RENDITION-REPORT"") )) { return NULL; } GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Unsupported directive %s\n"", line)); return NULL; }"
"static struct pending_op *pending_ccc_new(struct bt_att *att, struct gatt_db_attribute *attrib, uint16_t value, uint8_t link_type) { struct pending_op *op; struct btd_device *device; device = att_get_device(att); if (!device) { error(""Unable to find device object""); return NULL; } op = new0(struct pending_op, 1); op->data.iov_base = UINT_TO_PTR(value); op->data.iov_len = sizeof(value); op->device = device; op->attrib = attrib; op->link_type = link_type; return op; }"
"void naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar) { u32 i, count; Bool first = GF_TRUE; Bool first_svc = GF_TRUE; GF_AVCConfig *cfg; GF_AVCConfig *avcc; GF_AVCConfig *svcc; u32 max_w, max_h, max_ew, max_eh; max_w = max_h = max_ew = max_eh = 0; sar->num = sar->den = 0; avcc = gf_odf_avc_cfg_new(); svcc = gf_odf_avc_cfg_new(); avcc->nal_unit_size = ctx->nal_length; svcc->nal_unit_size = ctx->nal_length; ctx->is_mvc = GF_FALSE; count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { Bool is_svc = GF_FALSE; GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); AVC_SPS *sps = &ctx->avc_state->sps[sl->id]; u32 nal_type = sl->data[0] & 0x1F; if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) { ctx->is_mvc = GF_TRUE; } if (ctx->explicit) { cfg = svcc; } else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) { cfg = svcc; is_svc = GF_TRUE; } else { cfg = avcc; } if (first || (is_svc && first_svc) ) { cfg->configurationVersion = 1; cfg->profile_compatibility = sps->prof_compat; cfg->AVCProfileIndication = sps->profile_idc; cfg->AVCLevelIndication = sps->level_idc; cfg->chroma_format = sps->chroma_format; cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8; cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8; if (!gf_avcc_use_extensions(cfg->AVCProfileIndication) && ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) ) { if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) { cfg->AVCProfileIndication = 110; } else { cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122; } } if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) { sar->num = sps->vui.par_num; sar->den = sps->vui.par_den; } ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE; if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag && (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick) ) { u8 DeltaTfiDivisorIdx; if (!sps->vui.pic_struct_present_flag) { DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag); } else { if (!ctx->avc_state->sei.pic_timing.pic_struct) DeltaTfiDivisorIdx = 2; else if (ctx->avc_state->sei.pic_timing.pic_struct == 8) DeltaTfiDivisorIdx = 6; else DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2; } if (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) { ctx->cur_fps.num = 2 * sps->vui.time_scale; ctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx; if (!ctx->fps.num && ctx->dts==ctx->fps.den) ctx->dts = ctx->cur_fps.den; } if (! sps->vui.fixed_frame_rate_flag) GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", ctx->log_name)); } ctx->fps = ctx->cur_fps; } first = GF_FALSE; if (is_svc) { first_svc = GF_FALSE; if (sps->width > max_ew) max_ew = sps->width; if (sps->height > max_eh) max_eh = sps->height; } else { if (sps->width > max_w) max_w = sps->width; if (sps->height > max_h) max_h = sps->height; } if (!ctx->analyze) gf_list_add(cfg->sequenceParameterSets, sl); } cfg = ctx->explicit ? svcc : avcc; count = gf_list_count(ctx->sps_ext); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i); if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new(); if (!ctx->analyze) gf_list_add(cfg->sequenceParameterSetExtensions, sl); } cfg = ctx->explicit ? svcc : avcc; count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); if (!ctx->analyze) gf_list_add(cfg->pictureParameterSets, sl); } cfg = svcc; count = gf_list_count(ctx->pps_svc); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i); if (!ctx->analyze) gf_list_add(cfg->pictureParameterSets, sl); } *dsi = *dsi_enh = NULL; *dsi_size = *dsi_enh_size = 0; if (ctx->explicit) { gf_odf_avc_cfg_write(svcc, dsi, dsi_size); } else { gf_odf_avc_cfg_write(avcc, dsi, dsi_size); if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) { gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size); } } gf_list_reset(avcc->sequenceParameterSets); gf_list_reset(avcc->sequenceParameterSetExtensions); gf_list_reset(avcc->pictureParameterSets); gf_list_reset(svcc->sequenceParameterSets); gf_list_reset(svcc->sequenceParameterSetExtensions); gf_list_reset(svcc->pictureParameterSets); gf_odf_avc_cfg_del(avcc); gf_odf_avc_cfg_del(svcc); *max_width = max_w; *max_height = max_h; *max_enh_width = max_ew; *max_enh_height = max_eh; }"
"inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) { Eigen::IndexList<int, Eigen::type2index<1>> ret; ret.set(0, n); return ret; }"
"static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) { const char *algoname = NULL; unsigned int algolen; buffer* sigbuf = NULL; enum signkey_type keytype = signkey_type_from_signature(sigtype); TRACE((""enter send_msg_userauth_pubkey sigtype %d"", sigtype)) CHECKCLEARTOWRITE(); buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST); buf_putstring(ses.writepayload, cli_opts.username, strlen(cli_opts.username)); buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION, SSH_SERVICE_CONNECTION_LEN); buf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY, AUTH_METHOD_PUBKEY_LEN); buf_putbyte(ses.writepayload, realsign); algoname = signature_name_from_type(sigtype, &algolen); buf_putstring(ses.writepayload, algoname, algolen); buf_put_pub_key(ses.writepayload, key, keytype); if (realsign) { TRACE((""realsign"")) sigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len); buf_putbufstring(sigbuf, ses.session_id); buf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len); cli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf); buf_free(sigbuf);  } encrypt_packet(); TRACE((""leave send_msg_userauth_pubkey"")) }"
void tee_user_mem_free(void *buffer) { free(buffer); }
"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node, const TfLiteTensor* axis, const TfLiteTensor* input, int num_splits) { int axis_value = GetTensorData<int>(axis)[0]; if (axis_value < 0) { axis_value += NumDimensions(input); } TF_LITE_ENSURE(context, axis_value >= 0); TF_LITE_ENSURE(context, axis_value < NumDimensions(input)); const int input_size = SizeOfDimension(input, axis_value); TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0, ""Not an even split""); const int slice_size = input_size / num_splits; for (int i = 0; i < NumOutputs(node); ++i) { TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims); output_dims->data[axis_value] = slice_size; TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output)); TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims)); } return kTfLiteOk; }"
"static int tree_add_unmatched(X509_POLICY_LEVEL *curr, const X509_POLICY_CACHE *cache, const ASN1_OBJECT *id, X509_POLICY_NODE *node, X509_POLICY_TREE *tree) { X509_POLICY_DATA *data; if (id == NULL) id = node->data->valid_policy; if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL) return 0; data->qualifier_set = cache->anyPolicy->qualifier_set; data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS; if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) { ossl_policy_data_free(data); return 0; } return 1; }"
"static guint append_header (GString *string, const gchar *name, const gchar *value) { if (value) { g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0); g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0); g_string_append_printf (string, ""%s: %s\r\n"", name, value); } if (g_ascii_strcasecmp (""Content-Type"", name) == 0) return HEADER_CONTENT_TYPE; if (g_ascii_strcasecmp (""Cache-Control"", name) == 0) return HEADER_CACHE_CONTROL; if (g_ascii_strcasecmp (""Vary"", name) == 0) return HEADER_VARY; if (g_ascii_strcasecmp (""Content-Encoding"", name) == 0) return HEADER_CONTENT_ENCODING; if (g_ascii_strcasecmp (""X-DNS-Prefetch-Control"", name) == 0) return HEADER_DNS_PREFETCH_CONTROL; if (g_ascii_strcasecmp (""Referrer-Policy"", name) == 0) return HEADER_REFERRER_POLICY; if (g_ascii_strcasecmp (""X-Content-Type-Options"", name) == 0) return HEADER_CONTENT_TYPE_OPTIONS; if (g_ascii_strcasecmp (""Cross-Origin-Resource-Policy"", name) == 0) return HEADER_CROSS_ORIGIN_RESOURCE_POLICY; if (g_ascii_strcasecmp (""Content-Length"", name) == 0 || g_ascii_strcasecmp (""Transfer-Encoding"", name) == 0 || g_ascii_strcasecmp (""Connection"", name) == 0) { g_critical (""Don't set %s header manually. This is a programmer error."", name); } return 0; }"
"void proto_register_tipc(void) { static hf_register_info hf[] = { { &hf_tipc_msg_fragments, { ""Message fragments"", ""tipc.msg.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment, { ""Message fragment"", ""tipc.msg.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment_overlap, { ""Message fragment overlap"", ""tipc.msg.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_overlap_conflicts, { ""Message fragment overlapping with conflicting data"", ""tipc.msg.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_multiple_tails, { ""Message has multiple tail fragments"", ""tipc.msg.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_too_long_fragment, { ""Message fragment too long"", ""tipc.msg.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_error, { ""Message defragmentation error"", ""tipc.msg.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment_count, { ""Message fragment count"", ""tipc.msg.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_reassembled_in, { ""Reassembled in"", ""tipc.msg.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_reassembled_length, { ""Reassembled TIPC length"", ""tipc.msg.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_ver, { ""Version"", ""tipc.ver"", FT_UINT32, BASE_DEC, NULL, 0xe0000000, ""TIPC protocol version"", HFILL } }, { &hf_tipc_usr, { ""User"", ""tipc.usr"", FT_UINT32, BASE_DEC, VALS(tipc_user_values), 0x1e000000, ""TIPC User"", HFILL } }, { &hf_tipcv2_usr, { ""User"", ""tipc.usr"", FT_UINT32, BASE_DEC, VALS(tipcv2_user_values), 0x1e000000, ""TIPC User"", HFILL } }, { &hf_tipc_hdr_size, { ""Header size"", ""tipc.hdr_size"", FT_UINT32, BASE_DEC, NULL, 0x01e00000, ""TIPC Header size"", HFILL } }, { &hf_tipc_nonsequenced, { ""Non-sequenced"", ""tipc.non_sequenced"", FT_UINT32, BASE_DEC, NULL, 0x00100000, ""Non-sequenced Bit"", HFILL } }, { &hf_tipc_destdrop, { ""Destination Droppable"", ""tipc.destdrop"", FT_UINT32, BASE_DEC, NULL, 0x00080000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipc_unused, { ""Unused"", ""tipc.hdr_unused"", FT_UINT32, BASE_DEC, NULL, 0x000e0000, ""TIPC Unused"", HFILL } }, { &hf_tipc_msg_size, { ""Message size"", ""tipc.msg_size"", FT_UINT32, BASE_DEC, NULL, 0x0001ffff, ""TIPC Message size"", HFILL } }, { &hf_tipc_ack_link_lev_seq, { ""Acknowledged link level sequence number"", ""tipc.ack_link_lev_seq"", FT_UINT32, BASE_DEC, NULL, 0xffff0000, ""TIPC Acknowledged link level sequence number"", HFILL } }, { &hf_tipc_link_lev_seq, { ""Link level sequence number"", ""tipc.link_lev_seq"", FT_UINT32, BASE_DEC, NULL, 0x0000ffff, ""TIPC Link level sequence number"", HFILL } }, { &hf_tipc_prev_proc, { ""Previous processor"", ""tipc.prev_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Previous processor"", HFILL } }, { &hf_tipc_org_port, { ""Originating port"", ""tipc.org_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Originating port"", HFILL } }, { &hf_tipc_dst_port, { ""Destination port"", ""tipc.dst_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Destination port"", HFILL } }, { &hf_tipc_data_msg_type, { ""Message type"", ""tipc.msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_err_code, { ""Error code"", ""tipc.err_code"", FT_UINT32, BASE_DEC, VALS(tipc_error_code_values), 0x0f000000, ""TIPC Error code"", HFILL } }, { &hf_tipc_reroute_cnt, { ""Reroute counter"", ""tipc.route_cnt"", FT_UINT32, BASE_DEC, NULL, 0x00f00000, ""TIPC Reroute counter"", HFILL } }, { &hf_tipc_act_id, { ""Activity identity"", ""tipc.act_id"", FT_UINT32, BASE_DEC, NULL, 0x000fffff, ""TIPC Activity identity"", HFILL } }, { &hf_tipc_org_proc, { ""Originating processor"", ""tipc.org_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Originating processor"", HFILL } }, { &hf_tipc_dst_proc, { ""Destination processor"", ""tipc.dst_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Destination processor"", HFILL } }, { &hf_tipc_unused2, { ""Unused"", ""tipc.unused2"", FT_UINT32, BASE_DEC, NULL, 0xe0000000, ""TIPC Unused"", HFILL } }, { &hf_tipc_importance, { ""Importance"", ""tipc.importance"", FT_UINT32, BASE_DEC, NULL, 0x18000000, ""TIPC Importance"", HFILL } }, { &hf_tipc_link_selector, { ""Link selector"", ""tipc.link_selector"", FT_UINT32, BASE_DEC, NULL, 0x07000000, ""TIPC Link selector"", HFILL } }, { &hf_tipc_msg_cnt, { ""Message count"", ""tipc.imsg_cnt"", FT_UINT32, BASE_DEC, NULL, 0x00ffff00, ""TIPC Message count"", HFILL } }, { &hf_tipc_probe, { ""Probe"", ""tipc.probe"", FT_UINT32, BASE_DEC, NULL, 0x00000040, ""TIPC Probe"", HFILL } }, { &hf_tipc_bearer_id, { ""Bearer identity"", ""tipc.bearer_id"", FT_UINT32, BASE_DEC, NULL, 0x00000038, ""TIPC Bearer identity"", HFILL } }, { &hf_tipc_link_selector2, { ""Link selector"", ""tipc.link_selector"", FT_UINT32, BASE_DEC, NULL, 0x00000007, ""TIPC Link selector"", HFILL } }, { &hf_tipc_remote_addr, { ""Remote address"", ""tipc.remote_addr"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Remote address"", HFILL } }, { &hf_tipc_rm_msg_type, { ""Message type"", ""tipc.rm_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_routing_mgr_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_nd_msg_type, { ""Message type"", ""tipc.nd_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_name_dist_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_cm_msg_type, { ""Message type"", ""tipc.nd_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_cm_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_lp_msg_type, { ""Message type"", ""tipc.lp_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_link_prot_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_cng_prot_msg_type, { ""Message type"", ""tipc.cng_prot_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_cng_prot_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_sm_msg_type, { ""Message type"", ""tipc.sm_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_sm_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_unknown_msg_type, { ""Message type"", ""tipc.unknown_msg_type"", FT_UINT32, BASE_DEC, NULL, 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_seq_gap, { ""Sequence gap"", ""tipc.seq_gap"", FT_UINT32, BASE_DEC, NULL, 0x1fff0000, ""TIPC Sequence gap"", HFILL } }, { &hf_tipc_nxt_snt_pkg, { ""Next sent packet"", ""tipc.nxt_snt_pkg"", FT_UINT32, BASE_DEC, NULL, 0x0000ffff, ""TIPC Next sent packet"", HFILL } }, { &hf_tipc_unused_word, { ""Word Unused"", ""tipc.unused_word"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_bearer_name, { ""Bearer name"", ""tipc.bearer_name"", FT_STRINGZ, BASE_NONE, NULL, 0x0, ""TIPC Bearer name"", HFILL } }, { &hf_tipc_data, { ""Data"", ""tipc.data"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_no_bundle, { ""Message no. in bundle"", ""tipc.msg_no_bundle"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_changeover_protocol, { ""TIPC_CHANGEOVER_PROTOCOL"", ""tipc.changeover_protocol"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_name_dist_type, { ""Published port name type"", ""tipc.name_dist_type"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Published port name type"", HFILL } }, { &hf_tipc_name_dist_lower, { ""Lower bound of published sequence"", ""tipc.name_dist_lower"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Lower bound of published sequence"", HFILL } }, { &hf_tipc_name_dist_upper, { ""Upper bound of published sequence"", ""tipc.name_dist_upper"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Upper bound of published sequence"", HFILL } }, { &hf_tipc_name_dist_port, { ""Random number part of port identity"", ""tipc.dist_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Random number part of port identity"", HFILL } }, { &hf_tipc_name_dist_key, { ""Key (Use for verification at withdrawal)"", ""tipc.dist_key"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC key"", HFILL } }, { &hf_tipcv2_srcdrop, { ""Source Droppable"", ""tipc.srcdrop"", FT_UINT32, BASE_DEC, NULL, 0x00040000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipcv2_syn, { ""Connection request (SYN)"", ""tipc.syn"", FT_UINT32, BASE_DEC, NULL, 0x00020000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipcv2_data_msg_type, { ""Message type"", ""tipc.data_type"", FT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_bcast_mtype, { ""Message type"", ""tipcv2.bcast_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_bcast_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_bundler_mtype, { ""Message type"", ""tipcv2.bundler_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_bundler_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_link_mtype, { ""Message type"", ""tipcv2.link_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_link_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_connmgr_mtype, { ""Message type"", ""tipcv2.connmgr_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_connmgr_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_route_mtype_1_6, { ""Message type"", ""tipcv2.route_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_6), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_route_mtype_1_7, { ""Message type"", ""tipcv2.route_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_7), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_changeover_mtype, { ""Message type"", ""tipcv2.changeover_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_changeover_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_naming_mtype, { ""Message type"", ""tipcv2.naming_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_naming_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_fragmenter_mtype, { ""Message type"", ""tipcv2.fragmenter_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_fragmenter_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_neighbour_mtype, { ""Message type"", ""tipcv2.data_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_neighbour_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_errorcode, { ""Error code"", ""tipcv2.errorcode"", FT_UINT32, BASE_DEC, VALS(tipcv2_error_code_strings), 0x1e000000, NULL, HFILL } }, { &hf_tipcv2_rer_cnt, { ""Reroute Counter"", ""tipcv2.rer_cnt"", FT_UINT32, BASE_DEC, NULL, 0x01e00000, NULL, HFILL } }, { &hf_tipcv2_lookup_scope, { ""Lookup Scope"", ""tipcv2.lookup_scope"", FT_UINT32, BASE_DEC, VALS(tipcv2_lookup_scope_strings), 0x00180000, NULL, HFILL } }, { &hf_tipcv2_opt_p, { ""Options Position"", ""tipcv2.opt_p"", FT_UINT32, BASE_DEC, NULL, 0x00070000, NULL, HFILL } }, { &hf_tipcv2_broadcast_ack_no, { ""Broadcast Acknowledge Number"", ""tipcv2.broadcast_ack_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_link_level_ack_no, { ""Link Level Acknowledge Number"", ""tipcv2.link_level_ack_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_link_level_seq_no, { ""Link Level Sequence Number"", ""tipcv2.link_level_seq_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, #if 0 { &hf_tipcv2_bcast_seq_no, { ""Broadcast Sequence Number"", ""tipcv2.bcast_seq_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, #endif { &hf_tipcv2_prev_node, { ""Previous Node"", ""tipcv2.prev_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Previous Node"", HFILL } }, { &hf_tipcv2_orig_node, { ""Originating Node"", ""tipcv2.orig_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Originating Node"", HFILL } }, { &hf_tipcv2_dest_node, { ""Destination Node"", ""tipcv2.dest_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Destination Node"", HFILL } }, { &hf_tipcv2_port_name_type, { ""Port name type"", ""tipcv2.port_name_type"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, NULL, HFILL } }, { &hf_tipcv2_port_name_instance, { ""Port name instance"", ""tipcv2.port_name_instance"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, NULL, HFILL } }, { &hf_tipcv2_multicast_lower, { ""Multicast lower bound"", ""tipcv2.multicast_lower"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""Multicast port name instance lower bound"", HFILL } }, { &hf_tipcv2_multicast_upper, { ""Multicast upper bound"", ""tipcv2.multicast_upper"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""Multicast port name instance upper bound"", HFILL } }, { &hf_tipcv2_sequence_gap, { ""Sequence Gap"", ""tipcv2.seq_gap"", FT_UINT32, BASE_DEC, NULL, 0x1FFF0000, NULL, HFILL } }, { &hf_tipcv2_next_sent_broadcast, { ""Next Sent Broadcast"", ""tipcv2.next_sent_broadcast"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_fragment_number, { ""Fragment Number"", ""tipcv2.fragment_number"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_fragment_msg_number, { ""Fragment Message Number"", ""tipcv2.fragment_msg_number"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_next_sent_packet, { ""Next Sent Packet"", ""tipcv2.next_sent_packet"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_session_no, { ""Session Number"", ""tipcv2.session_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_link_prio, { ""Link Priority"", ""tipcv2.link_prio"", FT_UINT32, BASE_DEC, NULL, 0x000001F0, NULL, HFILL } }, { &hf_tipcv2_network_plane, { ""Network Plane"", ""tipcv2.network_plane"", FT_UINT32, BASE_DEC, VALS(tipcv2_networkplane_strings), 0x0000000E, NULL, HFILL } }, { &hf_tipcv2_probe, { ""Probe"", ""tipcv2.probe"", FT_UINT32, BASE_DEC, NULL, 0x00000001, NULL, HFILL } }, { &hf_tipcv2_link_tolerance, { ""Link Tolerance (ms)"", ""tipcv2.link_tolerance"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, ""Link Tolerance in ms"", HFILL } }, { &hf_tipcv2_bearer_instance, { ""Bearer Instance"", ""tipcv2.bearer_instance"", FT_STRINGZ, BASE_NONE, NULL, 0, ""Bearer instance used by the sender node for this link"", HFILL } }, { &hf_tipcv2_padding, { ""Padding"", ""tipcv2.padding"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_bearer_level_orig_addr, { ""Bearer Level Originating Address"", ""tipcv2.bearer_level_orig_addr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_cluster_address, { ""Cluster Address"", ""tipcv2.cluster_address"", FT_STRING, BASE_NONE, NULL, 0x0, ""The remote cluster concerned by the table"", HFILL } }, { &hf_tipcv2_bitmap, { ""Bitmap"", ""tipcv2.bitmap"", FT_BYTES, BASE_NONE, NULL, 0, ""Bitmap, indicating to which nodes within that cluster the sending node has direct links"", HFILL } }, { &hf_tipcv2_node_address, { ""Node Address"", ""tipcv2.node_address"", FT_STRING, BASE_NONE, NULL, 0x0, ""Which node the route addition/loss concern"", HFILL } }, { &hf_tipcv2_destination_domain, { ""Destination Domain"", ""tipcv2.destination_domain"", FT_STRING, BASE_NONE, NULL, 0x0, ""The domain to which the link request is directed"", HFILL } }, { &hf_tipcv2_network_id, { ""Network Identity"", ""tipcv2.network_id"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""The sender node's network identity"", HFILL } }, { &hf_tipcv2_bcast_tag, { ""Broadcast Tag"", ""tipcv2.bcast_tag"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_msg_count, { ""Message Count"", ""tipcv2.msg_count"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_max_packet, { ""Max Packet"", ""tipcv2.max_packet"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_transport_seq_no, { ""Transport Sequence No"", ""tipcv2.tseq_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""Transport Level Sequence Number"", HFILL } }, { &hf_tipcv2_redundant_link, { ""Redundant Link"", ""tipcv2.redundant_link"", FT_UINT32, BASE_DEC, NULL, 0x00001000, NULL, HFILL } }, { &hf_tipcv2_bearer_id, { ""Bearer identity"", ""tipcv2.bearer_id"", FT_UINT32, BASE_DEC, NULL, 0x00000e00, NULL, HFILL } }, { &hf_tipcv2_conn_mgr_msg_ack,  { ""Number of Messages Acknowledged"", ""tipcv2.conn_mgr_msg_ack"", FT_UINT32, BASE_DEC, NULL, 0xffff0000, NULL, HFILL } }, { &hf_tipcv2_minor_pv, { ""Minor protocol version"", ""tipcv2.minor_pv"", FT_UINT32, BASE_DEC, NULL, 0x00ff0000, NULL, HFILL } }, { &hf_tipcv2_node_sig, { ""Node signature"", ""tipcv2.node_sig"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_filler_mtu_discovery, { ""Filler for MTU discovery"", ""tipcv2.filler_mtu_discovery"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_vendor_specific_data, { ""Vendor specific data"", ""tipcv2.vendor_specific_data"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_options, { ""Options"", ""tipcv2.options"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_named_msg_hdr, { ""TIPC_NAMED_MSG Hdr"", ""tipc.named_msg_hdr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_port_name_type, { ""Port name type / Connection level sequence number"", ""tipc.port_name_type"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_port_name_instance, { ""Port name instance"", ""tipc.port_name_instance"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_data_fragment, { ""Data fragment"", ""tipc.data_fragment"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_message_bundle, { ""Message Bundle"", ""tipc.message_bundle"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_timestamp, { ""Timestamp"", ""tipcv2.timestamp"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""OS-dependent Timestamp"", HFILL } }, { &hf_tipcv2_item_size, { ""Item Size"", ""tipcv2.item_size"", FT_UINT32, BASE_DEC, NULL, 0xFF000000, NULL, HFILL } }, { &hf_tipcv2_network_region, { ""Network Region"", ""tipcv2.network_region"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_local_router, { ""Local Router"", ""tipcv2.local_router"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_remote_router, { ""Remote Router"", ""tipcv2.remote_router"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_dist_dist, { ""Route Distributor Dist"", ""tipcv2.dist_dist"", FT_UINT32, BASE_DEC, VALS(tipcv2_dist_dist_strings), 0x000000f0, NULL, HFILL } }, { &hf_tipcv2_dist_scope, { ""Route Distributor Scope"", ""tipcv2.dist_scope"", FT_UINT32, BASE_DEC, VALS(tipcv2_dist_scope_strings), 0x0000000f, NULL, HFILL } }, { &hf_tipcv2_name_dist_port_id_node, { ""Port Id Node"", ""tipcv2.port_id_node"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_media_id, { ""Media Id"", ""tipcv2.media_id"", FT_UINT32, BASE_DEC, NULL, 0x000000ff, NULL, HFILL } } }; static gint *ett[] = { &ett_tipc, &ett_tipc_data, &ett_tipc_msg_fragment, &ett_tipc_msg_fragments }; static ei_register_info ei[] = { { &ei_tipc_field_not_specified, { ""tipc.field_not_specified"", PI_PROTOCOL, PI_WARN, ""This field is not specified in TIPC v7"", EXPFILL }}, { &ei_tipc_invalid_bundle_size, { ""tipc.invalid_bundle_size"", PI_PROTOCOL, PI_WARN, ""Invalid message bundle size"", EXPFILL }}, }; module_t *tipc_module; expert_module_t* expert_tipc; static const enum_val_t handle_v2_as_options[] = { { ""all"",          ""ALL"",          V2_AS_ALL }, { ""tipc l.5/1.6"", ""TIPC 1.5/1.6"", V2_AS_1_6 }, { ""tipc 1.7"",     ""TIPC 1.7"",     V2_AS_1_7 }, { NULL,           NULL,           0 } }; proto_tipc = proto_register_protocol(""Transparent Inter Process Communication(TIPC)"", ""TIPC"", ""tipc""); proto_register_field_array(proto_tipc, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_tipc = expert_register_protocol(proto_tipc); expert_register_field_array(expert_tipc, ei, array_length(ei)); tipc_user_dissector = register_dissector_table(""tipc.usr"", ""TIPC user"", proto_tipc, FT_UINT8, BASE_DEC); tipc_type_dissector = register_dissector_table(""tipcv2.port_name_type"", ""TIPC port name type"", proto_tipc, FT_UINT32, BASE_DEC); tipc_heur_subdissector_list = register_heur_dissector_list(""tipc"", proto_tipc); tipc_handle = register_dissector(""tipc"", dissect_tipc, proto_tipc); reassembly_table_register(&tipc_msg_reassembly_table, &addresses_reassembly_table_functions); tipc_module = prefs_register_protocol(proto_tipc, NULL); tipc_address_type = address_type_dissector_register(""AT_TIPC"", ""TIPC Address Zone,Subnetwork,Processor"", tipc_addr_to_str_buf, tipc_addr_str_len, NULL, NULL, NULL, NULL, NULL); prefs_register_bool_preference(tipc_module, ""defragment"", ""Reassemble TIPCv1 SEGMENTATION_MANAGER datagrams"", ""Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled"", &tipc_defragment); prefs_register_bool_preference(tipc_module, ""dissect_tipc_data"", ""Dissect TIPC data"", ""Whether to try to dissect TIPC data or not"", &dissect_tipc_data); prefs_register_bool_preference(tipc_module, ""try_heuristic_first"", ""Try heuristic sub-dissectors first"", ""Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector"", &try_heuristic_first); prefs_register_enum_preference(tipc_module, ""handle_v2_as"", ""Handle version 2 as"", ""TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. \""ALL\"" shows all fields that were ever used in both versions."", &handle_v2_as, handle_v2_as_options, TRUE); prefs_register_bool_preference(tipc_module, ""desegment"", ""Reassemble TIPC-over-TCP messages spanning multiple TCP segments"", ""Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. "" ""To use this option, you must also enable \""Allow subdissectors to reassemble TCP streams\"" in the TCP protocol settings."", &tipc_tcp_desegment); }"
"int DH_check(const DH *dh, int *ret) { #ifdef FIPS_MODULE return DH_check_params(dh, ret); #else int ok = 0, r; BN_CTX *ctx = NULL; BIGNUM *t1 = NULL, *t2 = NULL; int nid = DH_get_nid((DH *)dh); *ret = 0; if (nid != NID_undef) return 1; if (!DH_check_params(dh, ret)) return 0; ctx = BN_CTX_new_ex(dh->libctx); if (ctx == NULL) goto err; BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); t2 = BN_CTX_get(ctx); if (t2 == NULL) goto err; if (dh->params.q != NULL) { if (BN_cmp(dh->params.g, BN_value_one()) <= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else if (BN_cmp(dh->params.g, dh->params.p) >= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else { if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx)) goto err; if (!BN_is_one(t1)) *ret |= DH_NOT_SUITABLE_GENERATOR; } r = BN_check_prime(dh->params.q, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_Q_NOT_PRIME; if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx)) goto err; if (!BN_is_one(t2)) *ret |= DH_CHECK_INVALID_Q_VALUE; if (dh->params.j != NULL && BN_cmp(dh->params.j, t1)) *ret |= DH_CHECK_INVALID_J_VALUE; } r = BN_check_prime(dh->params.p, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_PRIME; else if (dh->params.q == NULL) { if (!BN_rshift1(t1, dh->params.p)) goto err; r = BN_check_prime(t1, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_SAFE_PRIME; } ok = 1; err: BN_CTX_end(ctx); BN_CTX_free(ctx); return ok; #endif  }"
"int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous) { int nr, todo; s64 pos; if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; } if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX; return -1; } nr = 0;  if (bytes==0) { AVI->track[AVI->aptr].audio_posc++; AVI->track[AVI->aptr].audio_posb = 0; } *continuous = 1; while(bytes>0) { s64 ret; int left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb); if(left==0) { if(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr; AVI->track[AVI->aptr].audio_posc++; AVI->track[AVI->aptr].audio_posb = 0; *continuous = 0; continue; } if(bytes<left) todo = bytes; else todo = left; pos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb; gf_fseek(AVI->fdes, pos, SEEK_SET); if ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] XXX pos = %""LLD"", ret = %""LLD"", todo = %ld\n"", pos, ret, todo)); AVI_errno = AVI_ERR_READ; return -1; } bytes -= todo; nr    += todo; AVI->track[AVI->aptr].audio_posb += todo; } return nr; }"
"static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses, volatile parse_context *ctx) { pj_str_t str; ctx->last_error = PJMEDIA_SDP_EINTIME; if (*(scanner->curptr+1) != '=') { on_scanner_error(scanner); return; } pj_scan_advance_n(scanner, 2, SKIP_WS); pj_scan_get_until_ch(scanner, ' ', &str); ses->time.start = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_chr(scanner, "" \t\r\n"", &str); ses->time.stop = pj_strtoul(&str); pj_scan_skip_line(scanner); }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; Bool zfound=GF_FALSE; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; zfound = GF_FALSE; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) { zfound = GF_TRUE; break; } j++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; zfound = GF_FALSE; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) { zfound = GF_TRUE; break; } j++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; zfound = GF_FALSE; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; zfound = GF_FALSE; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s, const NodeDef &node) { VLOG(4) << ""Importing: "" << node.name(); OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op())); const OpDef *op_def; const OpRegistrationData *op_reg_data = nullptr; if ((op_reg_data = registry_.LookUp(node.op()))) { op_def = &op_reg_data->op_def; } else { auto it = function_op_defs_.find(node.op()); if (it == function_op_defs_.end()) return InvalidArgument(""Unable to find OpDef for "", node.op()); op_def = it->second; } state.attributes.reserve(node.attr_size() + 3); if (!node.device().empty()) { state.addAttribute(dialect_->getDeviceAttrIdentifier(), b_.getStringAttr(node.device())); } if (!node.name().empty()) { state.addAttribute(dialect_->getNameAttrIdentifier(), b_.getStringAttr(node.name())); } const auto add_full_type = [&](const FullTypeDef &full_type_def) { TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr full_type, ConvertAttribute(full_type_def, b_, dialect_)); state.addAttribute(dialect_->getFullTypeAttrIdentifier(), full_type); return ::tensorflow::OkStatus(); }; if (node.has_experimental_type()) { TF_RETURN_IF_ERROR(add_full_type(node.experimental_type())); } else if (op_reg_data && op_reg_data->type_ctor) { FullTypeDef full_type_def; TF_RETURN_IF_ERROR( tensorflow::full_type::SpecializeType(node, *op_def, full_type_def)); TF_RETURN_IF_ERROR(add_full_type(full_type_def)); } for (auto &name_attr : node.attr()) { if (name_attr.first.empty()) return InvalidArgument(""Node "", node.name(), "" has an empty attr name""); TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(name_attr.second, b_, dialect_)); state.addAttribute(name_attr.first, attr); } for (const auto &attr_def : op_def->attr()) { if (attr_def.has_default_value() && !state.attributes.get(attr_def.name())) { TF_ASSIGN_OR_RETURN( Attribute attr, ConvertAttributeValue(attr_def.default_value(), b_, dialect_)); state.addAttribute(attr_def.name(), attr); } } SmallVector<std::pair<unsigned, unsigned>> result_segments; result_segments.reserve(op_def->output_arg_size()); state.types.reserve(op_def->output_arg_size() + 1); for (const OpDef::ArgDef &def : op_def->output_arg()) { unsigned index = state.types.size(); TF_ASSIGN_OR_RETURN(unsigned size, ArgNumType(state.attributes, def, state.types)); result_segments.emplace_back(index, size); } state.types.push_back(dialect_->getControlType()); state.operands.reserve(node.input_size()); SmallVector<Value> control_operands; struct BackedgeResolution { ResultInfo *info; size_t operand_index; ResultId id; }; SmallVector<BackedgeResolution> unresolved_data_operands, unresolved_control_operands; for (const std::string &input : node.input()) { TF_ASSIGN_OR_RETURN(Result result, GetResult(s, input)); if (result.control) { if (result.info) { unresolved_control_operands.push_back(BackedgeResolution{ result.info, control_operands.size(), result.id}); } control_operands.push_back(result.control); } else { if (result.info) { unresolved_data_operands.push_back( BackedgeResolution{result.info, state.operands.size(), result.id}); } state.operands.push_back(result.data); } } unsigned num_data_operands = state.operands.size(); state.addOperands(control_operands); Operation *op = builder.create(state); for (const BackedgeResolution &r : unresolved_data_operands) { r.info->backedges.push_back( Backedge{r.id, &op->getOpOperand(r.operand_index)}); } for (const BackedgeResolution &r : unresolved_control_operands) { r.info->backedges.push_back( Backedge{r.id, &op->getOpOperand(num_data_operands + r.operand_index)}); } std::unique_ptr<ResultInfo> &info = s[node.name()]; if (!info) { info = std::make_unique<ResultInfo>(); } info->resolved = true; info->control = *std::prev(op->result_end()); info->data = op->getResults().drop_back(); for (auto it : llvm::zip(result_segments, op_def->output_arg())) { const std::pair<unsigned, unsigned> &segment = std::get<0>(it); info->outputs.emplace(std::get<1>(it).name(), info->data.slice(segment.first, segment.second)); } for (const Backedge &backedge : info->backedges) { Value value; if (backedge.id.IsControl()) { value = info->control; } else { TF_ASSIGN_OR_RETURN(value, ResolveDataResult(backedge.id, info.get())); } backedge.operand->set(value); } info->backedges.clear(); return ::tensorflow::OkStatus(); }"
"void Curl_detach_connnection(struct Curl_easy *data) { struct connectdata *conn = data->conn; if(conn) Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL); data->conn = NULL; }"
void cgroup_sk_alloc(struct sock_cgroup_data *skcd) { if (cgroup_sk_alloc_disabled) return; if (skcd->val) { cgroup_get(sock_cgroup_ptr(skcd)); return; } if (in_interrupt()) return; rcu_read_lock(); while (true) { struct css_set *cset; cset = task_css_set(current); if (likely(cgroup_tryget(cset->dfl_cgrp))) { skcd->val = (unsigned long)cset->dfl_cgrp; break; } cpu_relax(); } rcu_read_unlock(); }
Result BinaryReaderIR::EndFunctionBody(Index index) { current_func_ = nullptr; return Result::Ok; }
"void hrandfieldCommand(client *c) { long l; int withvalues = 0; robj *hash; listpackEntry ele; if (c->argc >= 3) { if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return; if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withvalues""))) { addReplyErrorObject(c,shared.syntaxerr); return; } else if (c->argc == 4) withvalues = 1; hrandfieldWithCountCommand(c, l, withvalues); return; } if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL || checkType(c,hash,OBJ_HASH)) { return; } hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL); hashReplyFromListpackEntry(c, &ele); }"
"static nxt_int_t njs_module_read(njs_vm_t *vm, int fd, nxt_str_t *text) { u_char       *p; ssize_t      n; struct stat  sb; if (fstat(fd, &sb) == -1) { goto fail; } text->length = nxt_length(NJS_MODULE_START); if (S_ISREG(sb.st_mode) && sb.st_size) { text->length += sb.st_size; } text->length += nxt_length(NJS_MODULE_END); text->start = nxt_mp_alloc(vm->mem_pool, text->length); if (text->start == NULL) { goto fail; } p = nxt_cpymem(text->start, NJS_MODULE_START, nxt_length(NJS_MODULE_START)); n = read(fd, p, sb.st_size); if (n < 0) { goto fail; } if (n != sb.st_size) { goto fail; } p += n; memcpy(p, NJS_MODULE_END, nxt_length(NJS_MODULE_END)); return NXT_OK; fail: if (text->start != NULL) { nxt_mp_free(vm->mem_pool, text->start); } return NXT_ERROR; }"
"static void write_trailer(FILE  *out, int   num_file_pages, uchar *lang) { inti, j, k, type, offset, start; page_t*page; charprefix[64], *prefptr; static const char *modes[] = { ""UseNone"", ""UseOutlines"", ""FullScreen"" }; static const char *layouts[] = { ""SinglePage"", ""OneColumn"", ""TwoColumnLeft"", ""TwoColumnRight"" }; if (PSLevel > 0) { fputs(""%%Trailer\n"", out); if (num_file_pages > 0) fprintf(out, ""%%%%Pages: %d\n"", num_file_pages); fputs(""%%EOF\n"", out); } else { root_object = pdf_start_object(out); fputs(""/Type/Catalog"", out); fprintf(out, ""/Pages %d 0 R"", pages_object); if (PDFVersion >= 12) { if (names_object) fprintf(out, ""/Names %d 0 R"", names_object); fprintf(out, ""/PageLayout/%s"", layouts[PDFPageLayout]); } if (lang) fprintf(out, ""/Lang(%s)"", (char *)lang); if (outline_object > 0) fprintf(out, ""/Outlines %d 0 R"", outline_object); switch (PDFFirstPage) { case PDF_PAGE_1 : if (TitlePage) { fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 1); break; } break; case PDF_TOC : if (TocLevels > 0) { fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 2 * chapter_outstarts[0] + 1); break; } break; case PDF_CHAPTER_1 : fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 2 * chapter_outstarts[1] + 1); break; } fprintf(out, ""/PageMode/%s"", modes[PDFPageMode]); if (PDFVersion > 12 && NumberUp == 1) { fputs(""/PageLabels<</Nums["", out); for (i = 0; i < chapter_starts[1]; i ++) { fprintf(out, ""%d<</P"", i); if (i & 1) write_string(out, (uchar *)""eltit"", 0); else write_string(out, (uchar *)""title"", 0); fputs("">>"", out); } if (TocLevels > 0 && OutputType == OUTPUT_BOOK) { type = 'r'; for (j = 0; j < 3; j ++) if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(1)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(1)""))) type = 'D'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(I)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(I)""))) type = 'R'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(a)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(a)""))) type = 'a'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(A)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(A)""))) type = 'A'; fprintf(out, ""%d<</S/%c>>"", i, type); i += chapter_ends[0] - chapter_starts[0] + 1; } for (j = 1; j <= TocDocCount; j ++) { page  = pages + chapter_starts[j]; start = chapter_starts[j] - chapter_starts[1] + 1; type  = 'D'; prefix[0] = '\0'; for (k = 0; k < 3; k ++) { if (page->header[k] && strstr((char *)page->header[k], ""PAGE"")) strlcpy(prefix, (char *)page->header[k], sizeof(prefix)); else if (page->footer[k] && strstr((char *)page->footer[k], ""PAGE"")) strlcpy(prefix, (char *)page->footer[k], sizeof(prefix)); if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(i)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(i)""))) type = 'r'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(I)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(I)""))) type = 'R'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(a)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(a)""))) type = 'a'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(A)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(A)""))) type = 'A'; if ((page->header[k] && strstr((char *)page->header[k], ""$CHAPTERPAGE"")) || (page->footer[k] && strstr((char *)page->footer[k], ""$CHAPTERPAGE""))) start = 1; } if ((prefptr = strstr(prefix, ""$PAGE"")) == NULL) prefptr = strstr(prefix, ""$CHAPTERPAGE""); fprintf(out, ""%d<</S/%c/St %d"", i, type, start); if (prefptr) { *prefptr = '\0'; fputs(""/P"", out); write_string(out, (uchar *)prefix, 0); } fputs("">>"", out); i += chapter_ends[j] - chapter_starts[j] + 1; } fputs(""]>>"", out); } pdf_end_object(out); offset = ftell(out); fputs(""xref\n"", out); fprintf(out, ""0 %d \n"", (int)num_objects + 1); fputs(""0000000000 65535 f \n"", out); for (i = 1; i <= (int)num_objects; i ++) fprintf(out, ""%010d 00000 n \n"", objects[i]); fputs(""trailer\n"", out); fputs(""<<"", out); fprintf(out, ""/Size %d"", (int)num_objects + 1); fprintf(out, ""/Root %d 0 R"", root_object); fprintf(out, ""/Info %d 0 R"", info_object); fputs(""/ID[<"", out); for (i = 0; i < 16; i ++) fprintf(out, ""%02x"", file_id[i]); fputs(""><"", out); for (i = 0; i < 16; i ++) fprintf(out, ""%02x"", file_id[i]); fputs("">]"", out); if (Encryption) fprintf(out, ""/Encrypt %d 0 R"", encrypt_object); fputs("">>\n"", out); fputs(""startxref\n"", out); fprintf(out, ""%d\n"", offset); fputs(""%%EOF\n"", out); } }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { struct squashfs_dir_header dirh; char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer; long long start; long long bytes; int dir_count, size; struct dir_ent *new_dir; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n""); dir->dir_count = 0; dir->cur_entry = 0; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 3) return dir; start = sBlk.s.directory_table_start + (*i)->start; bytes = lookup_entry(directory_table_hash, start); if(bytes == -1) EXIT_UNSQUASH(""squashfs_opendir: directory block %lld not "" ""found!\n"", start); bytes += (*i)->offset; size = (*i)->data + bytes - 3; while(bytes < size) { SQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh); dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { SQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire); bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } memcpy(dire->name, directory_table + bytes, dire->size + 1); dire->name[dire->size + 1] = '\0'; TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); if((dir->dir_count % DIR_ENT_SIZE) == 0) { new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent)); if(new_dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: "" ""realloc failed!\n""); dir->dirs = new_dir; } strcpy(dir->dirs[dir->dir_count].name, dire->name); dir->dirs[dir->dir_count].start_block = dirh.start_block; dir->dirs[dir->dir_count].offset = dire->offset; dir->dirs[dir->dir_count].type = dire->type; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: free(dir->dirs); free(dir); return NULL; }"
"static bool php_openssl_validate_iv( String piv, int iv_required_len, String& out, EVP_CIPHER_CTX* cipher_ctx, const php_openssl_cipher_mode* mode) { if (cipher_ctx == nullptr || mode == nullptr) { return false; } if (piv.size() == iv_required_len) { out = std::move(piv); return true; } if (mode->is_aead) { if (EVP_CIPHER_CTX_ctrl( cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) { raise_warning( ""Setting of IV length for AEAD mode failed, the expected length is "" ""%d bytes"", iv_required_len); return false; } out = std::move(piv); return true; } String s = String(iv_required_len, ReserveString); char* iv_new = s.mutableData(); memset(iv_new, 0, iv_required_len); if (piv.size() <= 0) { s.setSize(iv_required_len); out = std::move(s); return true; } if (piv.size() < iv_required_len) { raise_warning(""IV passed is only %d bytes long, cipher "" ""expects an IV of precisely %d bytes, padding with \\0"", piv.size(), iv_required_len); memcpy(iv_new, piv.data(), piv.size()); s.setSize(iv_required_len); out = std::move(s); return true; } raise_warning(""IV passed is %d bytes long which is longer than the %d "" ""expected by selected cipher, truncating"", piv.size(), iv_required_len); memcpy(iv_new, piv.data(), iv_required_len); s.setSize(iv_required_len); out = std::move(s); return true; }"
"GF_EXPORT GF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->mvc_config) return NULL; return AVC_DuplicateConfig(entry->mvc_config->config); }"
"static void RecalculateMasterButtons(DeviceIntPtr slave) { DeviceIntPtr dev, master; int maxbuttons = 0; if (!slave->button || IsMaster(slave)) return; master = GetMaster(slave, MASTER_POINTER); if (!master) return; for (dev = inputInfo.devices; dev; dev = dev->next) { if (IsMaster(dev) || GetMaster(dev, MASTER_ATTACHED) != master || !dev->button) continue; maxbuttons = max(maxbuttons, dev->button->numButtons); } if (master->button && master->button->numButtons != maxbuttons) { int i; DeviceChangedEvent event = { .header = ET_Internal, .type = ET_DeviceChanged, .time = GetTimeInMillis(), .deviceid = master->id, .flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE, .buttons.num_buttons = maxbuttons }; master->button->numButtons = maxbuttons; memcpy(&event.buttons.names, master->button->labels, maxbuttons * sizeof(Atom)); if (master->valuator) { event.num_valuators = master->valuator->numAxes; for (i = 0; i < event.num_valuators; i++) { event.valuators[i].min = master->valuator->axes[i].min_value; event.valuators[i].max = master->valuator->axes[i].max_value; event.valuators[i].resolution = master->valuator->axes[i].resolution; event.valuators[i].mode = master->valuator->axes[i].mode; event.valuators[i].name = master->valuator->axes[i].label; } } if (master->key) { event.keys.min_keycode = master->key->xkbInfo->desc->min_key_code; event.keys.max_keycode = master->key->xkbInfo->desc->max_key_code; } XISendDeviceChangedEvent(master, &event); } }"
"void escape(const std::string& in, std::string& out) { out.reserve(out.size() + in.size()); for (auto it = in.begin(); it != in.end(); ++it) { switch (*it) { case '&': out += ""&amp;""; break; case '<': out += ""&lt;""; break; case '>': out += ""&gt;""; break; case '""': out += ""&quot;""; break; case '\'': out += ""&#39;""; break; case '/': out += ""&#x2F;""; break; default: out += *it; break; } } }"
"static void svm_range_evict_svm_bo_worker(struct work_struct *work) { struct svm_range_bo *svm_bo; struct mm_struct *mm; int r = 0; svm_bo = container_of(work, struct svm_range_bo, eviction_work); if (!svm_bo_ref_unless_zero(svm_bo)) return;  if (mmget_not_zero(svm_bo->eviction_fence->mm)) { mm = svm_bo->eviction_fence->mm; } else { svm_range_bo_unref(svm_bo); return; } mmap_read_lock(mm); spin_lock(&svm_bo->list_lock); while (!list_empty(&svm_bo->range_list) && !r) { struct svm_range *prange = list_first_entry(&svm_bo->range_list, struct svm_range, svm_bo_list); int retries = 3; list_del_init(&prange->svm_bo_list); spin_unlock(&svm_bo->list_lock); pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", prange->svms, prange->start, prange->last); mutex_lock(&prange->migrate_mutex); do { r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_TTM_EVICTION); } while (!r && prange->actual_loc && --retries); if (!r && prange->actual_loc) pr_info_once(""Migration failed during eviction""); if (!prange->actual_loc) { mutex_lock(&prange->lock); prange->svm_bo = NULL; mutex_unlock(&prange->lock); } mutex_unlock(&prange->migrate_mutex); spin_lock(&svm_bo->list_lock); } spin_unlock(&svm_bo->list_lock); mmap_read_unlock(mm); mmput(mm); dma_fence_signal(&svm_bo->eviction_fence->base); WARN_ONCE(!r && kref_read(&svm_bo->kref) != 1, ""This was not the last reference\n""); svm_range_bo_unref(svm_bo); }"
"static Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, nsiz, i, fval, n = 0, maa = 0; Jsi_Obj *obj, *nobj; Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL; Jsi_Func *fptr = NULL; func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func))  return Jsi_LogError(""expected function""); sthis = Jsi_ValueArrayIndex(interp, args, 1); if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; curlen = Jsi_ObjGetLength(interp, obj);     if (curlen < 0) { Jsi_ObjSetLength(interp, obj, 0); } Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrCnt; if (nsiz<=0) nsiz = 1; if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { Jsi_LogError(""index too large: %d"", nsiz); rc = JSI_ERROR; goto bail; } Jsi_ValueMakeArrayObject(interp, ret, nobj); nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[4]; fptr = func->d.obj->d.fobj->func; maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < curlen; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if( JSI_OK!=rc ) { goto bail; } if (fval) { nobj->arr[n++] = obj->arr[i]; Jsi_IncrRefCount(interp, obj->arr[i]); } } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); Jsi_ObjSetLength(interp, nobj, n); return JSI_OK; bail: if (nthis) Jsi_DecrRefCount(interp, nthis); if (nrPtr) Jsi_DecrRefCount(interp, nrPtr); Jsi_ValueMakeNull(interp, ret); return rc; }"
"void DoCompute(OpKernelContext* c) { core::RefCountPtr<Var> v; OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v)); Tensor* params = v->tensor(); const Tensor& indices = c->input(1); const Tensor& updates = c->input(2); OP_REQUIRES(c, updates.dims() == 0 || updates.dims() == indices.dims() + params->dims() - 1, errors::InvalidArgument( ""Must have updates.shape = indices.shape + "" ""params.shape[1:] or updates.shape = [], got "", ""updates.shape "", updates.shape().DebugString(), "", indices.shape "", indices.shape().DebugString(), "", params.shape "", params->shape().DebugString())); const int64_t N_big = indices.NumElements(); OP_REQUIRES( c, N_big <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""indices has too many elements for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", N_big, "" > "", std::numeric_limits<Index>::max())); const Index N = static_cast<Index>(N_big); OP_REQUIRES( c, params->dim_size(0) <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""params.shape[0] too large for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", params->dim_size(0), "" > "", std::numeric_limits<Index>::max())); if (N > 0) { auto indices_flat = indices.flat<Index>(); auto params_flat = params->flat_outer_dims<T>(); if (TensorShapeUtils::IsScalar(updates.shape())) { const auto update = updates.scalar<T>(); functor::ScatterScalarFunctor<Device, T, Index, op> functor; const Index bad_i = functor(c, c->template eigen_device<Device>(), params_flat, update, indices_flat); OP_REQUIRES(c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params->dim_size(0), "")"")); } else { int64_t num_updates = updates.NumElements(); OP_REQUIRES( c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()), errors::InvalidArgument( ""The shape of indices ("", indices.shape().DebugString(), "") must be a prefix of the shape of updates ("", updates.shape().DebugString(), "")"")); auto updates_flat = updates.shaped<T, 2>({N, num_updates / N}); functor::ScatterFunctor<Device, T, Index, op> functor; const Index bad_i = functor(c, c->template eigen_device<Device>(), params_flat, updates_flat, indices_flat); OP_REQUIRES(c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params->dim_size(0), "")"")); } } }"
"static struct socket *get_raw_socket(int fd) { struct { struct sockaddr_ll sa; char  buf[MAX_ADDR_LEN]; } uaddr; int r; struct socket *sock = sockfd_lookup(fd, &r); if (!sock) return ERR_PTR(-ENOTSOCK); if (sock->sk->sk_type != SOCK_RAW) { r = -ESOCKTNOSUPPORT; goto err; } r = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0); if (r < 0) goto err; if (uaddr.sa.sll_family != AF_PACKET) { r = -EPFNOSUPPORT; goto err; } return sock; err: sockfd_put(sock); return ERR_PTR(r); }"
"static void dm1105_remove(struct pci_dev *pdev) { struct dm1105_dev *dev = pci_get_drvdata(pdev); struct dvb_adapter *dvb_adapter = &dev->dvb_adapter; struct dvb_demux *dvbdemux = &dev->demux; struct dmx_demux *dmx = &dvbdemux->dmx; dm1105_ir_exit(dev); dmx->close(dmx); dvb_net_release(&dev->dvbnet); if (dev->fe) dvb_unregister_frontend(dev->fe); dmx->disconnect_frontend(dmx); dmx->remove_frontend(dmx, &dev->mem_frontend); dmx->remove_frontend(dmx, &dev->hw_frontend); dvb_dmxdev_release(&dev->dmxdev); dvb_dmx_release(dvbdemux); dvb_unregister_adapter(dvb_adapter); i2c_del_adapter(&dev->i2c_adap); dm1105_hw_exit(dev); free_irq(pdev->irq, dev); pci_iounmap(pdev, dev->io_mem); pci_release_regions(pdev); pci_disable_device(pdev); dm1105_devcount--; kfree(dev); }"
"static int may_create_in_sticky(struct dentry * const dir, struct inode * const inode) { if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) || (!sysctl_protected_regular && S_ISREG(inode->i_mode)) || likely(!(dir->d_inode->i_mode & S_ISVTX)) || uid_eq(inode->i_uid, dir->d_inode->i_uid) || uid_eq(current_fsuid(), inode->i_uid)) return 0; if (likely(dir->d_inode->i_mode & 0002) || (dir->d_inode->i_mode & 0020 && ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) || (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) { const char *operation = S_ISFIFO(inode->i_mode) ? ""sticky_create_fifo"" : ""sticky_create_regular""; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; } return 0; }"
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr, size_t *rot_buf_size) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, buffsize, col_offset, pix_offset; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) buffsize = (colsize + 1) * width; else buffsize = (rowsize + 1) * length; bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %1u bytes"", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); if (rot_buf_size != NULL) *rot_buf_size = buffsize; ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"void Compute(OpKernelContext *ctx) override { const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t, *b_values_t, *b_shape_t; OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t)); OP_REQUIRES( ctx, TensorShapeUtils::IsMatrix(a_indices_t->shape()) && TensorShapeUtils::IsMatrix(b_indices_t->shape()), errors::InvalidArgument(""Inputs a_indices and b_indices should be "" ""matrices but received shapes: "", a_indices_t->shape().DebugString(), "", "", b_indices_t->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_values_t->shape()) && TensorShapeUtils::IsVector(b_values_t->shape()), errors::InvalidArgument( ""Inputs a_values and b_values should be vectors "" ""but received shapes: "", a_values_t->shape().DebugString(), "" and "", b_values_t->shape().DebugString())); const int64 a_nnz = a_indices_t->dim_size(0); const int64 b_nnz = b_indices_t->dim_size(0); const auto a_values = a_values_t->vec<T>(); const auto b_values = b_values_t->vec<T>(); OP_REQUIRES( ctx, a_values.size() == a_nnz && b_values.size() == b_nnz, errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz, "" non-empty input values, got "", a_values.size(), "" and "", b_values.size())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_shape_t->shape()) && TensorShapeUtils::IsVector(b_shape_t->shape()), errors::InvalidArgument( ""Input shapes should be a vector but received shapes "", a_shape_t->shape().DebugString(), "" and "", b_shape_t->shape().DebugString())); OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t), errors::InvalidArgument( ""Operands do not have the same ranks; got shapes: "", a_shape_t->SummarizeValue(10), "" and "", b_shape_t->SummarizeValue(10))); const auto a_shape = a_shape_t->flat<int64>(); const auto b_shape = b_shape_t->flat<int64>(); for (int i = 0; i < a_shape_t->NumElements(); ++i) { OP_REQUIRES(ctx, a_shape(i) == b_shape(i), errors::InvalidArgument(""Operands' shapes do not match: got "", a_shape(i), "" and "", b_shape(i), "" for dimension "", i)); } OP_REQUIRES( ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1), errors::InvalidArgument( ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1), "" and "", b_indices_t->dim_size(1), "" for the second dimension."")); const int num_dims = a_indices_t->dim_size(1); const auto a_indices_mat = a_indices_t->matrix<int64>(); const auto b_indices_mat = b_indices_t->matrix<int64>(); std::vector<T> a_augmented_values, b_augmented_values; std::vector<std::pair<bool, int64>> entries_to_copy;      UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat, b_values, b_nnz, num_dims, &a_augmented_values, &b_augmented_values, &entries_to_copy); const int64 sum_nnz = a_augmented_values.size(); Tensor *output_indices_t, *output_values_t; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}), &output_indices_t)); OP_REQUIRES_OK( ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t)); auto output_indices_mat = output_indices_t->matrix<int64>(); for (int64 i = 0; i < sum_nnz; ++i) { const bool from_a = entries_to_copy[i].first; const int64 idx = entries_to_copy[i].second; output_indices_mat.chip<0>(i) = from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx); } using UnalignedTensorMap = Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>, Eigen::Unaligned>; auto a_augmented_values_t = UnalignedTensorMap(a_augmented_values.data(), sum_nnz); auto b_augmented_values_t = UnalignedTensorMap(b_augmented_values.data(), sum_nnz); output_values_t->flat<T>().device(ctx->eigen_device<Device>()) = a_augmented_values_t.binaryExpr(b_augmented_values_t, typename Functor::func()); }"
"int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len) { int r = EMULATION_OK; struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt; init_emulate_ctxt(vcpu); if (!(emulation_type & EMULTYPE_SKIP) && kvm_vcpu_check_breakpoint(vcpu, &r)) return r; r = x86_decode_insn(ctxt, insn, insn_len, emulation_type); trace_kvm_emulate_insn_start(vcpu); ++vcpu->stat.insn_emulation; return r; }"
"static void janus_voicemail_session_free(const janus_refcount *session_ref) { janus_voicemail_session *session = janus_refcount_containerof(session_ref, janus_voicemail_session, ref); janus_refcount_decrease(&session->handle->ref); g_free(session); }"
"static int hid_bigben_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect) { struct hid_device *hid = input_get_drvdata(dev); struct bigben_device *bigben = hid_get_drvdata(hid); u8 right_motor_on; u8 left_motor_force; if (!bigben) { hid_err(hid, ""no device data\n""); return 0; } if (effect->type != FF_RUMBLE) return 0; right_motor_on   = effect->u.rumble.weak_magnitude ? 1 : 0; left_motor_force = effect->u.rumble.strong_magnitude / 256; if (right_motor_on != bigben->right_motor_on || left_motor_force != bigben->left_motor_force) { bigben->right_motor_on   = right_motor_on; bigben->left_motor_force = left_motor_force; bigben->work_ff = true; schedule_work(&bigben->worker); } return 0; }"
"ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s) { int ws_pending, nl, in_group = 0; #ifdef EXACT_ADDRESS const char *begin; #endif const char *ps; char comment[LONG_STRING], phrase[LONG_STRING]; size_t phraselen = 0, commentlen = 0; ADDRESS *cur, *last = NULL; RFC822Error = 0; last = top; while (last && last->next) last = last->next; ws_pending = is_email_wsp (*s); if ((nl = mutt_strlen (s))) nl = s[nl - 1] == '\n'; s = skip_email_wsp(s); #ifdef EXACT_ADDRESS begin = s; #endif while (*s) { if (*s == ',') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif commentlen = 0; phraselen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == '(') { if (commentlen && commentlen < sizeof (comment) - 1) comment[commentlen++] = ' '; if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '""') { if (phraselen && phraselen < sizeof (phrase) - 1) phrase[phraselen++] = ' '; if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '[') { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if (phraselen < sizeof (phrase) - 1) phrase[phraselen++] = '['; if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == ':') { cur = rfc822_new_address (); terminate_buffer (phrase, phraselen); cur->mailbox = safe_strdup (phrase); cur->group = 1; in_group = 1; if (last) last->next = cur; else top = cur; last = cur; #ifdef EXACT_ADDRESS last->val = mutt_substrdup (begin, s); #endif phraselen = 0; commentlen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == ';') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif if (last && in_group) { last->next = rfc822_new_address (); last = last->next; } in_group = 0; phraselen = 0; commentlen = 0; #ifdef EXACT_ADDRESS begin = s; #endif s++; } else if (*s == '<') { terminate_buffer (phrase, phraselen); cur = rfc822_new_address (); if (phraselen) cur->personal = safe_strdup (phrase); if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL) { rfc822_free_address (&top); rfc822_free_address (&cur); return NULL; } if (last) last->next = cur; else top = cur; last = cur; phraselen = 0; commentlen = 0; s = ps; } else { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } ws_pending = is_email_wsp(*s); s = skip_email_wsp(s); } if (phraselen) { terminate_buffer (phrase, phraselen); terminate_buffer (comment, commentlen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl); #endif return top; }"
"static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file) { enum CentralFileDirectoryHeaderOffsets { CFDHCompressionMethodOffset = 10, CFDHLocalFileHeaderIndexOffset = 42, }; enum LocalFileHeaderOffsets { LFHCompressionMethodOffset = 8, LFHCompressedSizeOffset = 18, LFHFileNameLengthOffset = 26, LFHExtraFieldLengthOffset = 28, LFHFileNameBaseOffset = 30, }; enum CompressionMethod { None = 0, Shrunk = 1, Factor1 = 2, Factor2 = 3, Factor3 = 4, Factor4 = 5, Implode = 6, Deflate = 8, EnhancedDeflate = 9, PKWareDCLImplode = 10, BZIP2 = 12, LZMA = 14, TERSE = 18, LZ77 = 19, }; u8 buffer[4]; if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4)) return false; off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2)) return false; auto compression_method = buffer[1] << 8 | buffer[0]; VERIFY(compression_method == None); if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4)) return false; off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2)) return false; off_t file_name_length = buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2)) return false; off_t extra_field_length = buffer[1] << 8 | buffer[0]; char file_name[file_name_length + 1]; if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length)) return false; file_name[file_name_length] = '\0'; if (file_name[file_name_length - 1] == '/') { if (mkdir(file_name, 0755) < 0) { perror(""mkdir""); return false; } } else { auto new_file = Core::File::construct(String { file_name }); if (!new_file->open(Core::IODevice::WriteOnly)) { fprintf(stderr, ""Can't write file %s: %s\n"", file_name, new_file->error_string()); return false; } printf("" extracting: %s\n"", file_name); u8 raw_file_contents[compressed_file_size]; if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size)) return false; if (!new_file->write(raw_file_contents, compressed_file_size)) { fprintf(stderr, ""Can't write file contents in %s: %s\n"", file_name, new_file->error_string()); return false; } if (!new_file->close()) { fprintf(stderr, ""Can't close file %s: %s\n"", file_name, new_file->error_string()); return false; } } return true; }"
"mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs) { mp_int   t; int      pa, pb, ix, iy; mp_err   err; mp_digit u; mp_word  r; mp_digit tmpx, *tmpt, *tmpy; if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST) && ((a->used + b->used + 1) < MP_WARRAY) && (MP_MIN(a->used, b->used) < MP_MAXFAST)) { return s_mp_mul_high_digs_fast(a, b, c, digs); } if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) { return err; } t.used = a->used + b->used + 1; pa = a->used; pb = b->used; for (ix = 0; ix < pa; ix++) { u = 0; tmpx = a->dp[ix]; tmpt = &(t.dp[digs]); tmpy = b->dp + (digs - ix); for (iy = digs - ix; iy < pb; iy++) { r       = (mp_word)*tmpt + ((mp_word)tmpx * (mp_word)*tmpy++) + (mp_word)u; *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK); u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT); } *tmpt = u; } mp_clamp(&t); mp_exch(&t, c); mp_clear(&t); return MP_OKAY; }"
"static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen) { struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr; struct sock *sk = sock->sk; struct llc_sock *llc = llc_sk(sk); struct llc_sap *sap; int rc = -EINVAL; lock_sock(sk); if (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr))) goto out; rc = -EAFNOSUPPORT; if (!addr->sllc_arphrd) addr->sllc_arphrd = ARPHRD_ETHER; if (unlikely(addr->sllc_family != AF_LLC || addr->sllc_arphrd != ARPHRD_ETHER)) goto out; dprintk(""%s: binding %02X\n"", __func__, addr->sllc_sap); rc = -ENODEV; rcu_read_lock(); if (sk->sk_bound_dev_if) { llc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if); if (llc->dev) { if (is_zero_ether_addr(addr->sllc_mac)) memcpy(addr->sllc_mac, llc->dev->dev_addr, IFHWADDRLEN); if (addr->sllc_arphrd != llc->dev->type || !ether_addr_equal(addr->sllc_mac, llc->dev->dev_addr)) { rc = -EINVAL; llc->dev = NULL; } } } else llc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd, addr->sllc_mac); dev_hold_track(llc->dev, &llc->dev_tracker, GFP_ATOMIC); rcu_read_unlock(); if (!llc->dev) goto out; if (!addr->sllc_sap) { rc = -EUSERS; addr->sllc_sap = llc_ui_autoport(); if (!addr->sllc_sap) goto out; } sap = llc_sap_find(addr->sllc_sap); if (!sap) { sap = llc_sap_open(addr->sllc_sap, NULL); rc = -EBUSY;  if (!sap) goto out; } else { struct llc_addr laddr, daddr; struct sock *ask; memset(&laddr, 0, sizeof(laddr)); memset(&daddr, 0, sizeof(daddr)); memcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN); laddr.lsap = addr->sllc_sap; rc = -EADDRINUSE;  ask = llc_lookup_established(sap, &daddr, &laddr); if (ask) { sock_put(ask); goto out_put; } } llc->laddr.lsap = addr->sllc_sap; memcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN); memcpy(&llc->addr, addr, sizeof(llc->addr)); llc_sap_add_socket(sap, sk); sock_reset_flag(sk, SOCK_ZAPPED); rc = 0; out_put: llc_sap_put(sap); out: release_sock(sk); return rc; }"
"void sqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res) { char tmp[10]; ST * tree = *tree_ret; switch (tree->type) { case TABLE_REF: { ST * prev = tree->_.table_ref.table; if (ST_P (prev, SELECT_STMT)) { tree->type = DERIVED_TABLE; sqlp_view_def (NULL, tree->_.table_ref.table, 0); sqlo_add_table_ref (so, tree_ret, res); return; } sqlo_add_table_ref (so, &tree->_.table_ref.table, res); if (prev != tree->_.table_ref.table) *tree_ret = tree->_.table_ref.table; break; } case TABLE_DOTTED: { ST * with_view = sqlo_with_decl (so, tree); dbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name); ST * view; if (!tb && !with_view) sqlc_error (so->so_sc->sc_cc, ""S0002"", ""No table %s"", tree->_.table.name); if (inside_view) tree->_.table.name = t_box_copy (tb->tb_name); if (!with_view) { sqlc_table_used (so->so_sc, tb); view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name); } else view = with_view; if (!view || inside_view) { remote_table_t * rt = find_remote_table (tb->tb_name, 0); t_NEW_VARZ (op_table_t, ot); ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts); ot->ot_prefix = tree->_.table.prefix; snprintf (tmp, sizeof (tmp), ""t%d"", so->so_name_ctr++); ot->ot_new_prefix = t_box_string (tmp); tree->_.table.prefix = ot->ot_new_prefix; ot->ot_table = tb; ot->ot_rds = rt ? rt->rt_rds : NULL; ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id); ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id); if (ST_P (view, PROC_TABLE)) { ot->ot_dt = view; sqlo_proc_table_cols (so, ot); ot->ot_dt = NULL; ot->ot_is_proc_view = 1; } sqlo_rls_add_condition (so, ot, res, tb); t_set_push (&so->so_tables, (void*) ot); sco_add_table (so->so_scope, ot); } else { op_table_t * ot = NULL; if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT)) sqlc_new_error (so->so_sc->sc_cc, ""42000"", ""SQ070:SECURITY"", ""Must have select privileges on view %s"", tb->tb_name); view = (ST*) t_box_copy_tree ((caddr_t) view); if (ST_P (view, UNION_ST) || ST_P (view, UNION_ALL_ST) || ST_P (view, EXCEPT_ST) || ST_P (view, EXCEPT_ALL_ST) || ST_P (view, INTERSECT_ST) || ST_P (view, INTERSECT_ALL_ST)) { view = sqlp_view_def (NULL, view, 1); view = sqlc_union_dt_wrap (view); } sqlo_scope (so, &view); if (ST_P (view, SELECT_STMT)) { ot = (op_table_t *) so->so_tables->data; ot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name; sco_add_table (so->so_scope, ot); } else { t_NEW_VARZ (op_table_t, ot2); memset (ot2, 0, sizeof (op_table_t)); ot = ot2; ot->ot_dt = view; ot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name; ot->ot_new_prefix = sqlo_new_prefix (so); ot->ot_left_sel = sqlp_union_tree_select (view); if (ST_P (view, PROC_TABLE)) { sqlo_proc_table_cols (so, ot); ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts); ot->ot_is_proc_view = 1; } sco_add_table (so->so_scope, ot); t_set_push (&so->so_tables, (void*) ot); } sqlo_rls_add_condition (so, ot, res, tb); *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix); } break; } case JOINED_TABLE: { sql_scope_t *old_sco = so->so_scope; TNEW (sql_scope_t, sco); op_table_t *right_ot, *left_ot; s_node_t *ptr; ST *j_right; dk_set_t res_jt = NULL; int is_jtc, is_natural = (tree->_.join.is_natural && (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR)); memset (sco, 0, sizeof (sql_scope_t)); sco->sco_so = so; sco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed; sco->sco_super = so->so_scope->sco_super; so->so_scope = sco; if (OJ_RIGHT == tree->_.join.type) { ST * tmp = tree->_.join.left; tree->_.join.left = tree->_.join.right; tree->_.join.right = tmp; tree->_.join.type = OJ_LEFT; } j_right = tree->_.join.left; while (ST_P (j_right, TABLE_REF)) j_right = j_right->_.table_ref.table; is_jtc = ST_P (j_right, JOINED_TABLE); if (tree->_.join.type == OJ_FULL) sco->sco_has_jt = 1; if (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL))) sco->sco_has_jt = 1; j_right = tree->_.join.right; while (ST_P (j_right, TABLE_REF)) j_right = j_right->_.table_ref.table; is_jtc = ST_P (j_right, JOINED_TABLE); if (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL))) sco->sco_has_jt = 1; sqlo_add_table_ref (so, &tree->_.join.left, res); left_ot = (op_table_t *) so->so_tables->data; sqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res); right_ot = (op_table_t *) so->so_tables->data; sqlo_natural_join_cond (so, left_ot, right_ot, tree); sqlo_scope (so, &(tree->_.join.cond)); if (J_INNER == tree->_.join.type && right_ot->ot_is_outer) t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond);  else t_st_and (&right_ot->ot_join_cond, tree->_.join.cond);  sco_merge (old_sco, sco); so->so_scope = old_sco; if (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL) right_ot->ot_is_outer = 1; else if (!sco->sco_has_jt && tree->_.join.type == J_INNER && !ST_P (left_ot->ot_dt, PROC_TABLE) && !ST_P (right_ot->ot_dt, PROC_TABLE)) { t_set_push (res, tree); break; } break; } case DERIVED_TABLE: { op_table_t * ot; sqlo_scope (so, &(tree->_.table_ref.table)); if (ST_P (tree->_.table_ref.table, SELECT_STMT)) { ot = (op_table_t *) so->so_tables->data; ot->ot_prefix = tree->_.table_ref.range; tree->_.table_ref.range = ot->ot_new_prefix; sco_add_table (so->so_scope, ot); if (ot->ot_trans) sqlo_trans_cols (so, ot); } else { op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL; t_NEW_VARZ (op_table_t, ot); ot->ot_prefix = tree->_.table_ref.range; ot->ot_dt = tree->_.table_ref.table; ot->ot_new_prefix = sqlo_new_prefix (so); tree->_.table_ref.range = ot->ot_new_prefix; if (old_ot) ot->ot_left_sel = old_ot->ot_left_sel; else ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table); if (ST_P (tree->_.table_ref.table, PROC_TABLE)) sqlo_proc_table_cols (so, ot); sco_add_table (so->so_scope, ot); t_set_push (&so->so_tables, (void*) ot); } break; } } }"
"TfLiteStatus Prepare(KernelType kernel_type, TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); bool has_bias = node->inputs->size == 3; TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2); TF_LITE_ENSURE_EQ(context, node->outputs->size, 1); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output)); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input)); const TfLiteTensor* filter; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter)); TF_LITE_ENSURE_EQ(context, input->dims->size, 4); TF_LITE_ENSURE_EQ(context, filter->dims->size, 4); TF_LITE_ENSURE_EQ(context, input->dims->data[3], filter->dims->data[3]); TfLiteType input_type = input->type; TF_LITE_ENSURE(context, input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt16); TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type); if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0); TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0); } const TfLiteTensor* bias = nullptr; TF_LITE_ENSURE(context, has_bias); if (has_bias) { TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &bias)); if (input_type == kTfLiteUInt8 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, input_type); } TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0)); } const bool is_hybrid = (input->type == kTfLiteFloat32 && (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)); if (is_hybrid && filter->type == kTfLiteInt8 && filter->quantization.type == kTfLiteAffineQuantization && filter->quantization.params && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale->size > 1) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); const float scale = affine_quantization->scale->data[0]; for (int i = 1; i < affine_quantization->scale->size; i++) { if (affine_quantization->scale->data[i] != scale) { data->is_hybrid_per_channel = true; break; } } } data->supports_multithreaded_kernel = (kernel_type == kMultithreadOptimized) && (context->recommended_num_threads != 1) && !is_hybrid && (params->dilation_width_factor == 1) && (params->dilation_height_factor == 1) && (filter->allocation_type != kTfLiteArenaRw) && !IsDynamicTensor(filter); int channels_in = filter->dims->data[3]; int channels_out = filter->dims->data[0]; int width = input->dims->data[2]; int height = input->dims->data[1]; int filter_width = filter->dims->data[2]; int filter_height = filter->dims->data[1]; int batches = input->dims->data[0]; auto padding = params->padding; int out_width, out_height; data->padding = ComputePaddingHeightWidth( params->stride_height, params->stride_width, params->dilation_height_factor, params->dilation_width_factor, height, width, filter_height, filter_width, padding, &out_height, &out_width); size_t im2col_type_size; TF_LITE_ENSURE_STATUS(GetSizeOfType(context, input->type, &im2col_type_size)); const size_t im2col_bytes = batches * out_height * out_width * channels_in * filter_height * filter_width * im2col_type_size; TF_LITE_ENSURE_STATUS(AllocateTemporaryTensorsIfRequired( context, node, is_hybrid, data->is_hybrid_per_channel, kernel_type, im2col_bytes)); TF_LITE_ENSURE(context, has_bias); if (input_type != kTfLiteFloat32) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 || affine_quantization->scale->size == channels_out)); data->per_channel_output_multiplier.resize(channels_out); data->per_channel_output_shift.resize(channels_out); TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams( context, input, filter, bias, output, params->activation, &data->output_multiplier, &data->output_shift, &data->output_activation_min, &data->output_activation_max, data->per_channel_output_multiplier.data(), data->per_channel_output_shift.data(), channels_out)); } TfLiteIntArray* output_size = TfLiteIntArrayCreate(4); output_size->data[0] = batches; output_size->data[1] = out_height; output_size->data[2] = out_width; output_size->data[3] = channels_out; auto output_status = context->ResizeTensor(context, output, output_size); if (output_status != kTfLiteOk) return output_status; if (data->need_im2col) { node->temporaries->data[data->im2col_index] = data->im2col_id; TfLiteIntArray* im2col_size = TfLiteIntArrayCreate(4); int input_depth = input->dims->data[3]; im2col_size->data[0] = output_size->data[0]; im2col_size->data[1] = output_size->data[1]; im2col_size->data[2] = output_size->data[2]; im2col_size->data[3] = input_depth * filter_height * filter_width; TfLiteTensor* im2col = &context->tensors[node->temporaries->data[data->im2col_index]]; im2col->type = input->type; if (is_hybrid) { im2col->type = filter->type; } im2col->allocation_type = kTfLiteArenaRw; auto im2col_status = context->ResizeTensor(context, im2col, im2col_size); if (im2col_status != kTfLiteOk) return im2col_status; } if (data->need_hwcn_weights) { node->temporaries->data[data->hwcn_weights_index] = data->hwcn_weights_id; TfLiteIntArray* hwcn_weights_size = TfLiteIntArrayCreate(2); int input_depth = input->dims->data[3]; hwcn_weights_size->data[0] = (filter_height * filter_width * input_depth); hwcn_weights_size->data[1] = channels_out; TfLiteTensor* hwcn_weights = &context->tensors[node->temporaries->data[data->hwcn_weights_index]]; hwcn_weights->type = input_type; hwcn_weights->allocation_type = kTfLiteArenaRwPersistent; auto hwcn_weights_status = context->ResizeTensor(context, hwcn_weights, hwcn_weights_size); if (hwcn_weights_status != kTfLiteOk) return hwcn_weights_status; data->have_weights_been_transposed = false; } if (is_hybrid) { node->temporaries->data[data->input_quantized_index] = data->input_quantized_id; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); input_quantized->type = kTfLiteInt8; input_quantized->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) { TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized, input_quantized_size)); } node->temporaries->data[data->scaling_factors_index] = data->scaling_factors_id; TfLiteTensor* scaling_factors; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors)); scaling_factors->type = kTfLiteFloat32; scaling_factors->allocation_type = kTfLiteArenaRw; const int height = NumElements(input) / channels_in; int scaling_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) { TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1); scaling_factors_size->data[0] = height; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors, scaling_factors_size)); } node->temporaries->data[data->accum_scratch_index] = data->accum_scratch_id; TfLiteTensor* accum_scratch; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->accum_scratch_index, &accum_scratch)); accum_scratch->type = kTfLiteInt32; accum_scratch->allocation_type = kTfLiteArenaRw; const int scratch_width = batches * out_height * out_width; int accum_scratch_dims[2] = {channels_out, scratch_width}; if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2, accum_scratch_dims)) { TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2); accum_scratch_size->data[0] = channels_out; accum_scratch_size->data[1] = scratch_width; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch, accum_scratch_size)); } if (data->is_hybrid_per_channel) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE_EQ( context, affine_quantization->scale->size, filter->dims->data[affine_quantization->quantized_dimension]); node->temporaries->data[data->input_offset_index] = data->input_offset_id; TfLiteTensor* input_offsets; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_offset_index, &input_offsets)); input_offsets->type = kTfLiteInt32; input_offsets->allocation_type = kTfLiteArenaRw; const int height = NumElements(input) / channels_in; const int input_offset_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, input_offset_dims)) { TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1); input_offsets_size->data[0] = input_offset_dims[0]; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets, input_offsets_size)); } node->temporaries->data[data->row_sums_index] = data->row_sums_id; TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); row_sums->type = kTfLiteInt32; row_sums->allocation_type = kTfLiteArenaRwPersistent; const int row_sums_dims[1] = {channels_out}; if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) { TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1); row_sums_size->data[0] = row_sums_dims[0]; TF_LITE_ENSURE_OK( context, context->ResizeTensor(context, row_sums, row_sums_size)); } } } return kTfLiteOk; }"
"MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) { MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size); if (buf == NULL) { debug_print(""%s\n"", ""Memory allocation failed""); return MOBI_MALLOC_FAILED; } char huff_magic[5]; mobi_buffer_getstring(huff_magic, buf, 4); const size_t header_length = mobi_buffer_get32(buf); if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) { debug_print(""HUFF wrong magic: %s\n"", huff_magic); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } const size_t data1_offset = mobi_buffer_get32(buf); const size_t data2_offset = mobi_buffer_get32(buf); mobi_buffer_setpos(buf, data1_offset); if (buf->offset + (256 * 4) > buf->maxlen) { debug_print(""%s"", ""HUFF data1 too short\n""); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } for (int i = 0; i < 256; i++) { huffcdic->table1[i] = mobi_buffer_get32(buf); } mobi_buffer_setpos(buf, data2_offset); if (buf->offset + (64 * 4) > buf->maxlen) { debug_print(""%s"", ""HUFF data2 too short\n""); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } huffcdic->mincode_table[0] = 0; huffcdic->maxcode_table[0] = 0xFFFFFFFF; for (int i = 1; i < 33; i++) { const uint32_t mincode = mobi_buffer_get32(buf); const uint32_t maxcode = mobi_buffer_get32(buf); huffcdic->mincode_table[i] =  mincode << (32 - i); huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1; } mobi_buffer_free_null(buf); return MOBI_SUCCESS; }"
"static int dissect_kafka_bytes_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_bytes_offset, int *p_bytes_length, gboolean *p_invalid) { gint64     val; guint      len; proto_item *pi; *p_invalid = FALSE; len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG); if (len == 0) { pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_varint); len = 5; val = 0; } else if (val > 0) { proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_NA); } else if (val == 0) { proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<EMPTY>""); } else if (val == -1) { proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<NULL>""); val = 0; } else { pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_bytes_length); val = 0; *p_invalid = TRUE; } if (p_bytes_offset != NULL) { *p_bytes_offset = offset+len; } if (p_bytes_length != NULL) { *p_bytes_length = (gint)val; } return offset+len+(gint)val; }"
"void Compute(OpKernelContext* context) override { typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>> ConstEigenMatrixMap; typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> EigenDoubleMatrixMap; const Tensor& orig_input_tensor_shape = context->input(0); OP_REQUIRES(context, orig_input_tensor_shape.dims() == 1 && orig_input_tensor_shape.NumElements() == 4, errors::InvalidArgument(""original input tensor shape must be"" ""1-dimensional and 4 elements"")); const Tensor& out_backprop = context->input(1); const Tensor& row_seq_tensor = context->input(2); const Tensor& col_seq_tensor = context->input(3); const int64_t out_batch = out_backprop.dim_size(0); const int64_t out_rows = out_backprop.dim_size(1); const int64_t out_cols = out_backprop.dim_size(2); const int64_t out_depth = out_backprop.dim_size(3); OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", row_seq_tensor must have at least "", out_rows + 1, "" elements, but got "", row_seq_tensor.NumElements())); OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", col_seq_tensor must have at least "", out_cols + 1, "" elements, but got "", col_seq_tensor.NumElements())); auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>(); auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>(); auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>(); const int64_t in_batch = orig_input_tensor_shape_flat(0); const int64_t in_rows = orig_input_tensor_shape_flat(1); const int64_t in_cols = orig_input_tensor_shape_flat(2); const int64_t in_depth = orig_input_tensor_shape_flat(3); OP_REQUIRES( context, in_batch != 0, errors::InvalidArgument(""Batch dimension of input must not be 0"")); OP_REQUIRES( context, in_rows != 0, errors::InvalidArgument(""Rows dimension of input must not be 0"")); OP_REQUIRES( context, in_cols != 0, errors::InvalidArgument(""Columns dimension of input must not be 0"")); OP_REQUIRES( context, in_depth != 0, errors::InvalidArgument(""Depth dimension of input must not be 0"")); constexpr int tensor_in_and_out_dims = 4; TensorShape in_shape; for (auto i = 0; i < tensor_in_and_out_dims; ++i) { in_shape.AddDim(orig_input_tensor_shape_flat(i)); } Tensor in_backprop_tensor_temp; OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp( {0}, DataTypeToEnum<double>::v(), in_shape, &in_backprop_tensor_temp)); in_backprop_tensor_temp.flat<double>().setZero(); EigenDoubleMatrixMap in_backprop_tensor_temp_mat( in_backprop_tensor_temp.flat<double>().data(), in_depth, in_cols * in_rows * in_batch); ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(), out_depth, out_cols * out_rows * out_batch); const int64_t in_max_row_index = in_rows - 1; const int64_t in_max_col_index = in_cols - 1; for (int64_t b = 0; b < out_batch; ++b) { for (int64_t r = 0; r < out_rows; ++r) { const int64_t in_row_start = row_seq_tensor_flat(r); int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1) : row_seq_tensor_flat(r + 1) - 1; in_row_end = std::min(in_row_end, in_max_row_index); for (int64_t c = 0; c < out_cols; ++c) { const int64_t in_col_start = col_seq_tensor_flat(c); int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1) : col_seq_tensor_flat(c + 1) - 1; in_col_end = std::min(in_col_end, in_max_col_index); const int64_t num_elements_in_pooling_cell = (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1); const int64_t out_index = (b * out_rows + r) * out_cols + c; for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) { for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) { const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c; for (int64_t d = 0; d < out_depth; ++d) { const double out_backprop_element = static_cast<double>( out_backprop_mat.coeffRef(d, out_index)); double& in_backprop_ref = in_backprop_tensor_temp_mat.coeffRef(d, in_index); in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell; } } } } } } Tensor* in_backprop_tensor = nullptr; OP_REQUIRES_OK(context, context->forward_input_or_allocate_output( {0}, 0, in_shape, &in_backprop_tensor)); auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>(); auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>(); for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) { in_backprop_tensor_flat(i) = static_cast<T>(in_backprop_tensor_temp_flat(i)); } }"
"bool SDP_AddAttribute(uint32_t handle, uint16_t attr_id, uint8_t attr_type, uint32_t attr_len, uint8_t* p_val) { uint16_t xx, yy, zz; tSDP_RECORD* p_rec = &sdp_cb.server_db.record[0]; if (sdp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) { if ((attr_type == UINT_DESC_TYPE) || (attr_type == TWO_COMP_INT_DESC_TYPE) || (attr_type == UUID_DESC_TYPE) || (attr_type == DATA_ELE_SEQ_DESC_TYPE) || (attr_type == DATA_ELE_ALT_DESC_TYPE)) { uint8_t num_array[400]; uint32_t len = (attr_len > 200) ? 200 : attr_len; num_array[0] = '\0'; for (uint32_t i = 0; i < len; i++) { snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"", (uint8_t)(p_val[i])); } SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%s"", handle, attr_id, attr_type, attr_len, p_val, num_array); } else if (attr_type == BOOLEAN_DESC_TYPE) { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%d"", handle, attr_id, attr_type, attr_len, p_val, *p_val); } else if ((attr_type == TEXT_STR_DESC_TYPE) || (attr_type == URL_DESC_TYPE)) { if (p_val[attr_len - 1] == '\0') { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%s"", handle, attr_id, attr_type, attr_len, p_val, (char*)p_val); } else { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p"", handle, attr_id, attr_type, attr_len, p_val); } } else { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p"", handle, attr_id, attr_type, attr_len, p_val); } } for (zz = 0; zz < sdp_cb.server_db.num_records; zz++, p_rec++) { if (p_rec->record_handle == handle) { tSDP_ATTRIBUTE* p_attr = &p_rec->attribute[0]; for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++) { if (p_attr->id == attr_id) { SDP_DeleteAttribute(handle, attr_id); break; } if (p_attr->id > attr_id) break; } if (p_rec->num_attributes == SDP_MAX_REC_ATTR) return (false); if (xx == p_rec->num_attributes) p_attr = &p_rec->attribute[p_rec->num_attributes]; else { for (yy = p_rec->num_attributes; yy > xx; yy--) p_rec->attribute[yy] = p_rec->attribute[yy - 1]; } p_attr->id = attr_id; p_attr->type = attr_type; p_attr->len = attr_len; if (p_rec->free_pad_ptr + attr_len >= SDP_MAX_PAD_LEN) { if (attr_type == TEXT_STR_DESC_TYPE) { SDP_TRACE_WARNING( ""SDP_AddAttribute: attr_len:%d too long. truncate to (%d)"", attr_len, SDP_MAX_PAD_LEN - p_rec->free_pad_ptr); attr_len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr; p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr - 1] = '\0'; } else attr_len = 0; } if ((attr_len > 0) && (p_val != 0)) { p_attr->len = attr_len; memcpy(&p_rec->attr_pad[p_rec->free_pad_ptr], p_val, (size_t)attr_len); p_attr->value_ptr = &p_rec->attr_pad[p_rec->free_pad_ptr]; p_rec->free_pad_ptr += attr_len; } else if ((attr_len == 0 && p_attr->len != 0) ||  p_val == 0) { SDP_TRACE_ERROR( ""SDP_AddAttribute fail, length exceed maximum: ID %d: attr_len:%d "", attr_id, attr_len); p_attr->id = p_attr->type = p_attr->len = 0; return (false); } p_rec->num_attributes++; return (true); } } return (false); }"
"void display_dollar(colnr_T col) { colnr_T save_col; if (!redrawing()) return; cursor_off(); save_col = curwin->w_cursor.col; curwin->w_cursor.col = col; if (has_mbyte) { char_u *p; p = ml_get_curline(); curwin->w_cursor.col -= (*mb_head_off)(p, p + col); } curs_columns(FALSE);        if (curwin->w_wcol < curwin->w_width) { edit_putchar('$', FALSE); dollar_vcol = curwin->w_virtcol; } curwin->w_cursor.col = save_col; }"
"packet_t * capture_packet_reasm_ip(capture_info_t *capinfo, const struct pcap_pkthdr *header, u_char *packet, uint32_t *size, uint32_t *caplen) { struct ip *ip4; #ifdef USE_IPV6 struct ip6_hdr *ip6; #endif uint32_t ip_ver; uint8_t ip_proto; uint32_t ip_hl = 0; uint16_t ip_off = 0; uint16_t ip_len = 0; uint16_t ip_frag = 0; uint32_t ip_id = 0; uint16_t ip_frag_off = 0; address_t src = { }; address_t dst = { }; vector_iter_t it; packet_t *pkt; frame_t *frame; uint32_t len_data = 0; uint16_t link_hl = capinfo->link_hl; #ifdef USE_IPV6 struct ip6_frag *ip6f; #endif if (capinfo->link == DLT_EN10MB) { struct ether_header *eth = (struct ether_header *) packet; if (ntohs(eth->ether_type) == ETHERTYPE_8021Q) { link_hl += 4; } } #ifdef SLL_HDR_LEN if (capinfo->link == DLT_LINUX_SLL) { struct sll_header *sll = (struct sll_header *) packet; if (ntohs(sll->sll_protocol) == ETHERTYPE_8021Q) { link_hl += 4; } } #endif if (capinfo->link == DLT_NFLOG) { while (link_hl + 8 <= *caplen) { nflog_tlv_t *tlv = (nflog_tlv_t *) (packet + link_hl); if (!tlv) break; if (tlv->tlv_type == NFULA_PAYLOAD) { link_hl += 4; break; } if (tlv->tlv_length >= 4) { link_hl += ((tlv->tlv_length + 3) & ~3);  } } } while (*size >= sizeof(struct ip)) { ip4 = (struct ip *) (packet + link_hl); #ifdef USE_IPV6 ip6 = (struct ip6_hdr *) (packet + link_hl); #endif ip_ver = ip4->ip_v; switch (ip_ver) { case 4: ip_hl = ip4->ip_hl * 4; ip_proto = ip4->ip_p; ip_off = ntohs(ip4->ip_off); ip_len = ntohs(ip4->ip_len); ip_frag = ip_off & (IP_MF | IP_OFFMASK); ip_frag_off = (ip_frag) ? (ip_off & IP_OFFMASK) * 8 : 0; ip_id = ntohs(ip4->ip_id); inet_ntop(AF_INET, &ip4->ip_src, src.ip, sizeof(src.ip)); inet_ntop(AF_INET, &ip4->ip_dst, dst.ip, sizeof(dst.ip)); break; #ifdef USE_IPV6 case 6: ip_hl = sizeof(struct ip6_hdr); ip_proto = ip6->ip6_nxt; ip_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + ip_hl; if (ip_proto == IPPROTO_FRAGMENT) { ip_frag = 1; ip6f = (struct ip6_frag *) (packet + link_hl + ip_hl); ip_frag_off = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK); ip_id = ntohl(ip6f->ip6f_ident); } inet_ntop(AF_INET6, &ip6->ip6_src, src.ip, sizeof(src.ip)); inet_ntop(AF_INET6, &ip6->ip6_dst, dst.ip, sizeof(dst.ip)); break; #endif default: return NULL; } *caplen = link_hl + ip_len; *size = *caplen - link_hl - ip_hl; if (ip_proto == IPPROTO_IPIP) { link_hl += ip_hl; } else { break; } } if (*caplen > MAX_CAPTURE_LEN) return NULL; if (ip_frag == 0) { pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id); packet_add_frame(pkt, header, packet); return pkt; } it = vector_iterator(capinfo->ip_reasm); while ((pkt = vector_iterator_next(&it))) { if (addressport_equals(pkt->src, src) && addressport_equals(pkt->dst, dst) && pkt->ip_id == ip_id) { break; } } if (pkt) { packet_add_frame(pkt, header, packet); } else { pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id); packet_add_frame(pkt, header, packet); vector_append(capinfo->ip_reasm, pkt); } pkt->ip_cap_len += ip_len - ip_hl; #ifdef USE_IPV6 if (ip_ver == 6 && ip_frag) { pkt->ip_cap_len -= sizeof(struct ip6_frag); } #endif if (ip_ver == 4 && (ip_off & IP_MF) == 0) { pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl; } #ifdef USE_IPV6 if (ip_ver == 6 && ip_frag && (ip6f->ip6f_offlg & htons(0x01)) == 0) { pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl - sizeof(struct ip6_frag); } #endif if (pkt->ip_cap_len == pkt->ip_exp_len) { it = vector_iterator(pkt->frames); while ((frame = vector_iterator_next(&it))) { switch (ip_ver) { case 4: { struct ip *frame_ip = (struct ip *) (frame->data + link_hl); len_data += ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4; break; } #ifdef USE_IPV6 case 6: { struct ip6_hdr *frame_ip6 = (struct ip6_hdr *) (frame->data + link_hl); len_data += ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen); break; } #endif default: break; } } if (len_data > MAX_CAPTURE_LEN) return NULL; memset(packet, 0, link_hl + ip_hl + len_data); it = vector_iterator(pkt->frames); while ((frame = vector_iterator_next(&it))) { switch (ip_ver) { case 4: { struct ip *frame_ip = (struct ip *) (frame->data + link_hl); memcpy(packet + link_hl + ip_hl + (ntohs(frame_ip->ip_off) & IP_OFFMASK) * 8, frame->data + link_hl + frame_ip->ip_hl * 4, ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4); } break; #ifdef USE_IPV6 case 6: { struct ip6_hdr *frame_ip6 = (struct ip6_hdr*)(frame->data + link_hl); struct ip6_frag *frame_ip6f = (struct ip6_frag *)(frame->data + link_hl + ip_hl); uint16_t frame_ip_frag_off = ntohs(frame_ip6f->ip6f_offlg & IP6F_OFF_MASK); memcpy(packet + link_hl + ip_hl + sizeof(struct ip6_frag) + frame_ip_frag_off, frame->data + link_hl + ip_hl + sizeof (struct ip6_frag), ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen)); pkt->proto = frame_ip6f->ip6f_nxt; } break; #endif default: break; } } *caplen = link_hl + ip_hl + len_data; #ifdef USE_IPV6 if (ip_ver == 6) { *caplen += sizeof(struct ip6_frag); } #endif *size = len_data; vector_remove(capinfo->ip_reasm, pkt); return pkt; } return NULL; }"
"int initializeControlStream(void) { stopping = 0; PltCreateEvent(&invalidateRefFramesEvent); LbqInitializeLinkedBlockingQueue(&invalidReferenceFrameTuples, 20); if (ServerMajorVersion == 3) { packetTypes = (short*)packetTypesGen3; payloadLengths = (short*)payloadLengthsGen3; preconstructedPayloads = (char**)preconstructedPayloadsGen3; } else if (ServerMajorVersion == 4) { packetTypes = (short*)packetTypesGen4; payloadLengths = (short*)payloadLengthsGen4; preconstructedPayloads = (char**)preconstructedPayloadsGen4; } else if (ServerMajorVersion == 5) { packetTypes = (short*)packetTypesGen5; payloadLengths = (short*)payloadLengthsGen5; preconstructedPayloads = (char**)preconstructedPayloadsGen5; } else { packetTypes = (short*)packetTypesGen7; payloadLengths = (short*)payloadLengthsGen7; preconstructedPayloads = (char**)preconstructedPayloadsGen7; } idrFrameRequired = 0; lastGoodFrame = 0; lastSeenFrame = 0; lossCountSinceLastReport = 0; return 0; }"
"static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n) { GF_FieldInfo info; u32 i, nb_rare, field_rare; s32 field_tag; GF_LSR_READ_INT(lsr, nb_rare, 1, ""has_rare""); if (!nb_rare) return; GF_LSR_READ_INT(lsr, nb_rare, 6, ""nbOfAttributes""); for (i=0; i<nb_rare; i++) { GF_LSR_READ_INT(lsr, field_rare, 6, ""attributeRARE""); if (field_rare==49) { u32 extID, len, j; while (1) { GF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, ""extensionID""); len = lsr_read_vluimsbf5(lsr, ""len""); if (extID==2) { GF_LSR_READ_INT(lsr, len, 2, ""nbOfAttributes""); for (j=0; j<len; j++) { GF_LSR_READ_INT(lsr, extID, 3, ""attributeRARE""); switch (extID) { case 0: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""syncMaster""); break; case 1: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, ""focusHighlight""); break; case 2: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, ""initialVisibility""); break; case 3: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""fullscreen""); break; case 4: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info); lsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, ""requiredFonts"", GF_FALSE, GF_TRUE); break; } } } else { gf_bs_read_int(lsr->bs, len); } GF_LSR_READ_INT(lsr, extID, 1, ""hasNextExtension""); if (!extID) break; } continue; } field_tag = gf_lsr_rare_type_to_attribute(field_rare); if (field_tag==-1) { return; } lsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info); if (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED; if (lsr->last_error) return; switch (field_tag) { case TAG_SVG_ATT__class: lsr_read_byte_align_string(lsr, info.far_ptr, ""class""); break; case TAG_SVG_ATT_audio_level: ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""audio-level""); break; case TAG_SVG_ATT_color: lsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, ""color""); break; case TAG_SVG_ATT_color_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""color-rendering""); break; case TAG_SVG_ATT_display: GF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, ""display""); break; case TAG_SVG_ATT_display_align: GF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, ""display-align""); break; case TAG_SVG_ATT_fill_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""fill-opacity""); break; case TAG_SVG_ATT_fill_rule: GF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, ""fill-rule""); break; case TAG_SVG_ATT_image_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""image-rendering""); break; case TAG_SVG_ATT_line_increment: lsr_read_line_increment_type(lsr, info.far_ptr, ""line-increment""); break; case TAG_SVG_ATT_pointer_events: GF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, ""pointer-events""); break; case TAG_SVG_ATT_shape_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""shape-rendering""); break; case TAG_SVG_ATT_solid_color: lsr_read_paint(lsr, info.far_ptr, ""solid-color""); break; case TAG_SVG_ATT_solid_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""solid-opacity""); break; case TAG_SVG_ATT_stop_color: lsr_read_paint(lsr, info.far_ptr, ""stop-color""); break; case TAG_SVG_ATT_stop_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stop-opacity""); break; case TAG_SVG_ATT_stroke_dasharray: { u32 j, flag; SVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr; GF_LSR_READ_INT(lsr, flag, 1, ""dashArray""); if (flag) { da->type=SVG_STROKEDASHARRAY_INHERIT; } else { da->type=SVG_STROKEDASHARRAY_ARRAY; da->array.count = lsr_read_vluimsbf5(lsr, ""len""); da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count); da->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count); if (!da->array.vals || !da->array.units) { lsr->last_error = GF_OUT_OF_MEM; return; } for (j=0; j<da->array.count; j++) { da->array.vals[j] = lsr_read_fixed_16_8(lsr, ""dash""); da->array.units[j] = 0; if (lsr->last_error) return; } } } break; case TAG_SVG_ATT_stroke_dashoffset: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""dashOffset""); break; case TAG_SVG_ATT_stroke_linecap: GF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, ""stroke-linecap""); break; case TAG_SVG_ATT_stroke_linejoin: GF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, ""stroke-linejoin""); break; case TAG_SVG_ATT_stroke_miterlimit: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""miterLimit""); break; case TAG_SVG_ATT_stroke_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stroke-opacity""); break; case TAG_SVG_ATT_stroke_width: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""strokeWidth""); break; case TAG_SVG_ATT_text_anchor: GF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, ""text-achor""); break; case TAG_SVG_ATT_text_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""text-rendering""); break; case TAG_SVG_ATT_viewport_fill: lsr_read_paint(lsr, info.far_ptr, ""viewport-fill""); break; case TAG_SVG_ATT_viewport_fill_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""viewport-fill-opacity""); break; case TAG_SVG_ATT_vector_effect: GF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, ""vector-effect""); break; case TAG_SVG_ATT_visibility: GF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, ""visibility""); break; case TAG_SVG_ATT_requiredExtensions: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredExtensions"", GF_TRUE, GF_FALSE); break; case TAG_SVG_ATT_requiredFormats: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredFormats"", GF_FALSE, GF_FALSE); break; case TAG_SVG_ATT_requiredFeatures: { u32 j, fcount = lsr_read_vluimsbf5(lsr, ""count""); for (j=0; j<fcount; j++) { u32 fval; GF_LSR_READ_INT(lsr, fval, 6, ""feature""); if (lsr->last_error) return; } } break; case TAG_SVG_ATT_systemLanguage: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""systemLanguage"", GF_FALSE, GF_FALSE); break; case TAG_XML_ATT_base: lsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, ""xml:base""); ((XMLRI*)info.far_ptr)->type = XMLRI_STRING; break; case TAG_XML_ATT_lang: lsr_read_byte_align_string(lsr, info.far_ptr, ""xml:lang""); break; case TAG_XML_ATT_space: GF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, ""xml:space""); break; case TAG_SVG_ATT_nav_next: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNext""); break; case TAG_SVG_ATT_nav_up: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorth""); break; case TAG_SVG_ATT_nav_up_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthEast""); break; case TAG_SVG_ATT_nav_up_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthWest""); break; case TAG_SVG_ATT_nav_prev: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusPrev""); break; case TAG_SVG_ATT_nav_down: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouth""); break; case TAG_SVG_ATT_nav_down_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthEast""); break; case TAG_SVG_ATT_nav_down_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthWest""); break; case TAG_SVG_ATT_nav_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusEast""); break; case TAG_SVG_ATT_focusable: GF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, ""focusable""); break; case TAG_SVG_ATT_nav_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusWest""); break; case TAG_SVG_ATT_transform: lsr_read_matrix(lsr, info.far_ptr); break; case TAG_SVG_ATT_text_decoration: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""textDecoration"", GF_FALSE, GF_FALSE); break; case TAG_SVG_ATT_font_variant: GF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, ""font-variant""); break; case TAG_SVG_ATT_font_family: { u32 flag; GF_LSR_READ_INT(lsr, flag, 1, ""isInherit""); if (flag) { ((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT; } else { char *ft; ((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE; GF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, ""fontIndex""); ft = (char*)gf_list_get(lsr->font_table, flag); if (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft); } } break; case TAG_SVG_ATT_font_size: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""fontSize""); break; case TAG_SVG_ATT_font_style: GF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, ""fontStyle""); break; case TAG_SVG_ATT_font_weight: GF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, ""fontWeight""); break; case TAG_XLINK_ATT_title: lsr_read_byte_align_string(lsr, info.far_ptr, ""xlink:title""); break; case TAG_XLINK_ATT_type: GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:type""); break; case TAG_XLINK_ATT_role: lsr_read_any_uri(lsr, info.far_ptr, ""xlink:role""); break; case TAG_XLINK_ATT_arcrole: lsr_read_any_uri(lsr, info.far_ptr, ""xlink:arcrole""); break; case TAG_XLINK_ATT_actuate: GF_LSR_READ_INT(lsr, field_rare, 2, ""xlink:actuate""); break; case TAG_XLINK_ATT_show: GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:show""); break; case TAG_SVG_ATT_end: lsr_read_smil_times(lsr, NULL, 0, info.far_ptr, ""end"", 0); break; case TAG_SVG_ATT_max: lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0); break; case TAG_SVG_ATT_min: lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0); break; } if (lsr->last_error) return; } }"
"static void dissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp) { gint        offset         = 0; gchar      *sDesc          = NULL; gint        deschasopcode  = FALSE; gboolean    haveETS        = FALSE; guint32     iBodyOffset    = 0; guint32     iBodyRemain    = 0; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RTMP""); RTMPT_DEBUG(""Dissect: frame=%u visited=%d len=%d tree=%p\n"", pinfo->num, pinfo->fd->visited, tvb_reported_length_remaining(tvb, offset), tree); col_clear(pinfo->cinfo, COL_INFO); if (tvb_reported_length_remaining(tvb, offset) < 1) return; if (tp->id <= RTMPT_ID_MAX) { if (tp->fmt < 3 && tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3 && tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) { haveETS = TRUE; } iBodyOffset = offset + tp->bhlen + tp->mhlen; iBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset); if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) { guint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset); if (newchunksize < rtmpt_max_packet_size) { wmem_tree_insert32(rconv->chunksize[cdir], tp->lastseq, GINT_TO_POINTER(newchunksize)); } } if (!PINFO_FD_VISITED(pinfo)) { if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) { guint32 soff = 0; if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) { soff = 1; } tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff); if (tp->txid != 0) { RTMPT_DEBUG(""got txid=%d\n"", tp->txid); wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num)); } } } } if (tp->id <= RTMPT_ID_MAX) { sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode); } if (tp->id>RTMPT_ID_MAX) { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); col_set_fence(pinfo->cinfo, COL_INFO); } else if (sDesc) { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", sDesc); col_set_fence(pinfo->cinfo, COL_INFO); } else { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)"")); col_set_fence(pinfo->cinfo, COL_INFO); } if (tree) { proto_tree *rtmpt_tree     = NULL; proto_tree *rtmptroot_tree = NULL; proto_item *ti; ti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA); if (tp->id > RTMPT_ID_MAX) { proto_item_append_text(ti, "" (%s)"", val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt); rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_handshake, NULL, val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); if (tp->id == RTMPT_TYPE_HANDSHAKE_1) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c0, tvb, 0, 1, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c1, tvb, 1, 1536, ENC_NA); } else if (tp->id == RTMPT_TYPE_HANDSHAKE_2) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s0, tvb, 0, 1, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s1, tvb, 1, 1536, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s2, tvb, 1537, 1536, ENC_NA); } else if (tp->id == RTMPT_TYPE_HANDSHAKE_3) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c2, tvb, 0, 1536, ENC_NA); } return; } if (sDesc && deschasopcode) { proto_item_append_text(ti, "" (%s)"", sDesc); } else if (sDesc) { proto_item_append_text(ti, "" (%s %s)"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)""), sDesc); } else { proto_item_append_text(ti, "" (%s)"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)"")); } rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt); if (tp->otherframe != 0) { proto_tree_add_uint(rtmptroot_tree, tp->isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call, tvb, offset, tp->bhlen+tp->mhlen+tp->len, tp->otherframe); } rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, tp->bhlen+tp->mhlen, ett_rtmpt_header, NULL, RTMPT_TEXT_RTMP_HEADER); if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_format, tvb, offset + 0, 1, ENC_BIG_ENDIAN); if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_csid, tvb, offset + 0, tp->bhlen, ENC_BIG_ENDIAN); if (tp->fmt <= 2) { if (tp->fmt > 0) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp_delta, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN); } else { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN); } if (haveETS) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_ets, tvb, offset + tp->bhlen + tp->mhlen - 4, 4, ENC_BIG_ENDIAN); } } if ((tp->fmt>0 && !haveETS) || tp->fmt == 3) { proto_tree_add_uint_format_value(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 0, tp->ts, ""%d (calculated)"", tp->ts); } if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_body_size, tvb, offset + tp->bhlen + 3, 3, ENC_BIG_ENDIAN); if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_typeid, tvb, offset + tp->bhlen + 6, 1, ENC_BIG_ENDIAN); if (tp->fmt <= 0) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_streamid, tvb, offset + tp->bhlen + 7, 4, ENC_LITTLE_ENDIAN); if (tp->len == 0) return; offset = iBodyOffset; rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_body, NULL, RTMPT_TEXT_RTMP_BODY); switch (tp->cmd) { case RTMPT_TYPE_CHUNK_SIZE: case RTMPT_TYPE_ABORT_MESSAGE: case RTMPT_TYPE_ACKNOWLEDGEMENT: case RTMPT_TYPE_UCM: case RTMPT_TYPE_WINDOW: case RTMPT_TYPE_PEER_BANDWIDTH: dissect_rtmpt_body_scm(tvb, offset, rtmpt_tree, tp->cmd); break; case RTMPT_TYPE_COMMAND_AMF0: case RTMPT_TYPE_DATA_AMF0: dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, FALSE); break; case RTMPT_TYPE_COMMAND_AMF3: case RTMPT_TYPE_DATA_AMF3: dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, TRUE); break; case RTMPT_TYPE_AUDIO_DATA: dissect_rtmpt_body_audio(tvb, offset, rtmpt_tree); break; case RTMPT_TYPE_VIDEO_DATA: dissect_rtmpt_body_video(tvb, offset, rtmpt_tree); break; case RTMPT_TYPE_AGGREGATE: dissect_rtmpt_body_aggregate(tvb, offset, rtmpt_tree); break; } } }"
"static int eval7( char_u**arg, typval_T*rettv, evalarg_T*evalarg, intwant_string){ intevaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); intlen; char_u*s; char_u*name_start = NULL; char_u*start_leader, *end_leader; intret = OK; char_u*alias; rettv->v_type = VAR_UNKNOWN; start_leader = *arg; if (eval_leader(arg, in_vim9script()) == FAIL) return FAIL; end_leader = *arg; if (**arg == '.' && (!isdigit(*(*arg + 1)) #ifdef FEAT_FLOAT || in_old_script(2) #endif )) { semsg(_(e_invalid_expression_str), *arg); ++*arg; return FAIL; } switch (**arg) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.':ret = eval_number(arg, rettv, evaluate, want_string); if (ret == OK && evaluate && end_leader > start_leader && rettv->v_type != VAR_BLOB) ret = eval7_leader(rettv, TRUE, start_leader, &end_leader); break; case '""':ret = eval_string(arg, rettv, evaluate); break; case '\'':ret = eval_lit_string(arg, rettv, evaluate); break; case '[':ret = eval_list(arg, rettv, evalarg, TRUE); break; case '#':if (in_vim9script()) { ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE; } else if ((*arg)[1] == '{') { ++*arg; ret = eval_dict(arg, rettv, evalarg, TRUE); } else ret = NOTDONE; break; case '{':if (in_vim9script()) ret = NOTDONE; else ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg); if (ret == NOTDONE) ret = eval_dict(arg, rettv, evalarg, FALSE); break; case '&':ret = eval_option(arg, rettv, evaluate); break; case '$':ret = eval_env_var(arg, rettv, evaluate); break; case '@':++*arg; if (evaluate) { if (in_vim9script() && IS_WHITE_OR_NUL(**arg)) semsg(_(e_syntax_error_at_str), *arg); else if (in_vim9script() && !valid_yank_reg(**arg, FALSE)) emsg_invreg(**arg); else { rettv->v_type = VAR_STRING; rettv->vval.v_string = get_reg_contents(**arg, GREG_EXPR_SRC); } } if (**arg != NUL) ++*arg; break; case '(':ret = NOTDONE; if (in_vim9script()) { ret = get_lambda_tv(arg, rettv, TRUE, evalarg); if (ret == OK && evaluate) { ufunc_T *ufunc = rettv->vval.v_partial->pt_func; if (ufunc->uf_ret_type->tt_type == VAR_VOID) ufunc->uf_ret_type = &t_unknown; if (compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL) { clear_tv(rettv); ret = FAIL; } } } if (ret == NOTDONE) { *arg = skipwhite_and_linebreak(*arg + 1, evalarg); ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); if (**arg == ')') ++*arg; else if (ret == OK) { emsg(_(e_missing_closing_paren)); clear_tv(rettv); ret = FAIL; } } break; default:ret = NOTDONE; break; } if (ret == NOTDONE) { s = *arg; len = get_name_len(arg, &alias, evaluate, TRUE); if (alias != NULL) s = alias; if (len <= 0) ret = FAIL; else { int    flags = evalarg == NULL ? 0 : evalarg->eval_flags; if (evaluate && in_vim9script() && len == 1 && *s == '_') { emsg(_(e_cannot_use_underscore_here)); ret = FAIL; } else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(') { *arg = skipwhite(*arg); ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL); } else if (flags & EVAL_CONSTANT) ret = FAIL; else if (evaluate) { if (len == 4 && in_vim9script() && STRNCMP(s, ""true"", 4) == 0) { rettv->v_type = VAR_BOOL; rettv->vval.v_number = VVAL_TRUE; ret = OK; } else if (len == 5 && in_vim9script() && STRNCMP(s, ""false"", 5) == 0) { rettv->v_type = VAR_BOOL; rettv->vval.v_number = VVAL_FALSE; ret = OK; } else if (len == 4 && in_vim9script() && STRNCMP(s, ""null"", 4) == 0) { rettv->v_type = VAR_SPECIAL; rettv->vval.v_number = VVAL_NULL; ret = OK; } else { name_start = s; ret = eval_variable(s, len, 0, rettv, NULL, EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT); } } else { check_vars(s, len); ret = OK; } } vim_free(alias); } if (ret == OK) ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE); if (ret == OK && evaluate && end_leader > start_leader) ret = eval7_leader(rettv, FALSE, start_leader, &end_leader); return ret; }"
"void CreateAudioBroadcast( bool is_public, const std::string& broadcast_name, const std::optional<bluetooth::le_audio::BroadcastCode>& broadcast_code, const std::vector<uint8_t>& public_metadata, const std::vector<uint8_t>& subgroup_quality, const std::vector<std::vector<uint8_t>>& subgroup_metadata) override { uint8_t public_features = 0; LeAudioLtvMap public_ltv; std::vector<LeAudioLtvMap> subgroup_ltvs; if (is_public) { bool is_metadata_valid; public_ltv = LeAudioLtvMap::Parse( public_metadata.data(), public_metadata.size(), is_metadata_valid); if (!is_metadata_valid) { LOG_ERROR(""Invalid metadata provided.""); return; } public_features = static_cast<uint8_t>(broadcast_code ? 1 : 0); } auto broadcast_id = available_broadcast_ids_.back(); available_broadcast_ids_.pop_back(); if (available_broadcast_ids_.size() == 0) GenerateBroadcastIds(); auto context_type = AudioContexts(LeAudioContextType::MEDIA); if (stack_config_get_interface() ->get_pts_force_le_audio_multiple_contexts_metadata()) { context_type = LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL; } for (const uint8_t quality : subgroup_quality) { if (quality == bluetooth::le_audio::QUALITY_STANDARD) { public_features |= bluetooth::le_audio::kLeAudioQualityStandard; } else if (quality == bluetooth::le_audio::QUALITY_HIGH) { public_features |= bluetooth::le_audio::kLeAudioQualityHigh; } } for (const std::vector<uint8_t>& metadata : subgroup_metadata) { bool is_metadata_valid; auto ltv = LeAudioLtvMap::Parse(metadata.data(), metadata.size(), is_metadata_valid); if (!is_metadata_valid) { LOG_ERROR(""Invalid metadata provided.""); return; } if (stack_config_get_interface() ->get_pts_force_le_audio_multiple_contexts_metadata()) { auto stream_context_vec = ltv.Find( le_audio::types::kLeAudioMetadataTypeStreamingAudioContext); if (stream_context_vec) { auto pp = stream_context_vec.value().data(); UINT16_TO_STREAM(pp, context_type.value()); } } auto stream_context_vec = ltv.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext); if (stream_context_vec) { auto pp = stream_context_vec.value().data(); STREAM_TO_UINT16(context_type.value_ref(), pp); } auto ccid_vec = ContentControlIdKeeper::GetInstance()->GetAllCcids(context_type); if (!ccid_vec.empty()) { ltv.Add(le_audio::types::kLeAudioMetadataTypeCcidList, ccid_vec); } subgroup_ltvs.push_back(ltv); } if (CodecManager::GetInstance()->GetCodecLocation() == CodecLocation::ADSP) { auto offload_config = CodecManager::GetInstance()->GetBroadcastOffloadConfig(); if (offload_config == nullptr) { LOG_ERROR(""No valid broadcast offload config""); return; } BroadcastCodecWrapper codec_config( {.coding_format = le_audio::types::kLeAudioCodingFormatLC3, .vendor_company_id = le_audio::types::kLeAudioVendorCompanyIdUndefined, .vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined}, {.num_channels = static_cast<uint8_t>(offload_config->stream_map.size()), .sample_rate = offload_config->sampling_rate, .bits_per_sample = offload_config->bits_per_sample, .data_interval_us = offload_config->frame_duration}, offload_config->codec_bitrate, offload_config->octets_per_frame); BroadcastQosConfig qos_config(offload_config->retransmission_number, offload_config->max_transport_latency); BroadcastStateMachineConfig msg = { .is_public = is_public, .broadcast_name = broadcast_name, .broadcast_id = broadcast_id, .streaming_phy = GetStreamingPhy(), .codec_wrapper = codec_config, .qos_config = qos_config, .announcement = prepareBasicAnnouncement(codec_config, subgroup_ltvs), .broadcast_code = std::move(broadcast_code)}; if (is_public) { msg.public_announcement = preparePublicAnnouncement(public_features, public_ltv); } pending_broadcasts_.push_back( std::move(BroadcastStateMachine::CreateInstance(std::move(msg)))); } else { auto codec_qos_pair = le_audio::broadcaster::getStreamConfigForContext(context_type); BroadcastStateMachineConfig msg = { .is_public = is_public, .broadcast_name = broadcast_name, .broadcast_id = broadcast_id, .streaming_phy = GetStreamingPhy(), .codec_wrapper = codec_qos_pair.first, .qos_config = codec_qos_pair.second, .announcement = prepareBasicAnnouncement(codec_qos_pair.first, subgroup_ltvs), .broadcast_code = std::move(broadcast_code)}; if (is_public) { msg.public_announcement = preparePublicAnnouncement(public_features, public_ltv); } pending_broadcasts_.push_back( std::move(BroadcastStateMachine::CreateInstance(std::move(msg)))); } LOG_INFO(""CreateAudioBroadcast""); if (!pending_broadcasts_.back()->Initialize()) { pending_broadcasts_.pop_back(); callbacks_->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid, false); } }"
"static void wsdl_soap_binding_body(sdlCtx* ctx, xmlNodePtr node, char* wsdl_soap_namespace, sdlSoapBindingFunctionBody *binding, HashTable* params) { xmlNodePtr body, trav; xmlAttrPtr tmp; trav = node->children; while (trav != NULL) { if (node_is_equal_ex(trav, ""body"", wsdl_soap_namespace)) { body = trav; tmp = get_attribute(body->properties, ""use""); if (tmp && !strncmp((char*)tmp->children->content, ""literal"", sizeof(""literal""))) { binding->use = SOAP_LITERAL; } else { binding->use = SOAP_ENCODED; } tmp = get_attribute(body->properties, ""namespace""); if (tmp) { binding->ns = estrdup((char*)tmp->children->content); } tmp = get_attribute(body->properties, ""parts""); if (tmp) { HashTable    ht; char *parts = (char*)tmp->children->content; zend_hash_init(&ht, 0, NULL, delete_parameter, 0); while (*parts) { sdlParamPtr param; int found = 0; char *end; while (*parts == ' ') ++parts; if (*parts == '\0') break; end = strchr(parts, ' '); if (end) *end = '\0'; ZEND_HASH_FOREACH_PTR(params, param) { if (param->paramName && strcmp(parts, param->paramName) == 0) { sdlParamPtr x_param; x_param = emalloc(sizeof(sdlParam)); *x_param = *param; param->paramName = NULL; zend_hash_next_index_insert_ptr(&ht, x_param); found = 1; break; } } ZEND_HASH_FOREACH_END(); if (!found) { soap_error1(E_ERROR, ""Parsing WSDL: Missing part '%s' in <message>"", parts); } parts += strlen(parts); if (end) *end = ' '; } zend_hash_destroy(params); *params = ht; } if (binding->use == SOAP_ENCODED) { tmp = get_attribute(body->properties, ""encodingStyle""); if (tmp) { if (strncmp((char*)tmp->children->content, SOAP_1_1_ENC_NAMESPACE, sizeof(SOAP_1_1_ENC_NAMESPACE)) == 0) { binding->encodingStyle = SOAP_ENCODING_1_1; } else if (strncmp((char*)tmp->children->content, SOAP_1_2_ENC_NAMESPACE, sizeof(SOAP_1_2_ENC_NAMESPACE)) == 0) { binding->encodingStyle = SOAP_ENCODING_1_2; } else { soap_error1(E_ERROR, ""Parsing WSDL: Unknown encodingStyle '%s'"", tmp->children->content); } } else { soap_error0(E_ERROR, ""Parsing WSDL: Unspecified encodingStyle""); } } } else if (node_is_equal_ex(trav, ""header"", wsdl_soap_namespace)) { sdlSoapBindingFunctionHeaderPtr h = wsdl_soap_binding_header(ctx, trav, wsdl_soap_namespace, 0); smart_str key = {0}; if (binding->headers == NULL) { binding->headers = emalloc(sizeof(HashTable)); zend_hash_init(binding->headers, 0, NULL, delete_header, 0); } if (h->ns) { smart_str_appends(&key,h->ns); smart_str_appendc(&key,':'); } smart_str_appends(&key,h->name); smart_str_0(&key); if (zend_hash_add_ptr(binding->headers, key.s, h) == NULL) { delete_header_int(h); } smart_str_free(&key); } else if (is_wsdl_element(trav) && !node_is_equal(trav,""documentation"")) { soap_error1(E_ERROR, ""Parsing WSDL: Unexpected WSDL element <%s>"", trav->name); } trav = trav->next; } }"
"static void build_lswitch_destination_lookup_bmcast(struct ovn_datapath *od, struct hmap *lflows, struct ds *actions, const struct shash *meter_groups) { if (od->nbs) { ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110, ""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"", ""handle_svc_check(inport);""); struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw; if (mcast_sw_info->enabled) { ds_clear(actions); ds_put_cstr(actions, ""igmp;""); ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100, ""igmp"", ds_cstr(actions), copp_meter_get(COPP_IGMP, od->nbs->copp, meter_groups)); ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100, ""mldv1 || mldv2"", ds_cstr(actions), copp_meter_get(COPP_IGMP, od->nbs->copp, meter_groups)); ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85, ""ip4.mcast && ip4.dst == 224.0.0.0/24"", ""outport = \""""MC_FLOOD_L2""\""; output;""); ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85, ""ip6.mcast_flood"", ""outport = \""""MC_FLOOD""\""; output;""); if (!mcast_sw_info->flood_unregistered) { ds_clear(actions); if (mcast_sw_info->flood_relay) { ds_put_cstr(actions, ""clone { "" ""outport = \""""MC_MROUTER_FLOOD""\""; "" ""output; "" ""}; ""); } if (mcast_sw_info->flood_static) { ds_put_cstr(actions, ""outport =\""""MC_STATIC""\""; output;""); } if (!mcast_sw_info->flood_relay && !mcast_sw_info->flood_static) { ds_put_cstr(actions, debug_drop_action()); } ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80, ""ip4.mcast || ip6.mcast"", ds_cstr(actions)); } } ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, ""eth.mcast"", ""outport = \""""MC_FLOOD""\""; output;""); } }"
static void cil_reset_perm(struct cil_perm *perm) { cil_reset_classperms_list(perm->classperms); }
"static void tcp_internal_pacing(struct sock *sk, const struct sk_buff *skb) { u64 len_ns; u32 rate; if (!tcp_needs_internal_pacing(sk)) return; rate = sk->sk_pacing_rate; if (!rate || rate == ~0U) return; len_ns = (u64)skb->len * NSEC_PER_SEC; do_div(len_ns, rate); hrtimer_start(&tcp_sk(sk)->pacing_timer, ktime_add_ns(ktime_get(), len_ns), HRTIMER_MODE_ABS_PINNED_SOFT); sock_hold(sk); }"
"static void vgacon_restore_screen(struct vc_data *c) { c->vc_origin = c->vc_visible_origin; vgacon_scrollback_cur->save = 0; if (!vga_is_gfx && !vgacon_scrollback_cur->restore) { scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf, c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size); vgacon_scrollback_cur->restore = 1; vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt; } }"
"static int vmx_check_intercept(struct kvm_vcpu *vcpu, struct x86_instruction_info *info, enum x86_intercept_stage stage) { struct vmcs12 *vmcs12 = get_vmcs12(vcpu); struct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt; if (info->intercept == x86_intercept_rdtscp && !nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) { ctxt->exception.vector = UD_VECTOR; ctxt->exception.error_code_valid = false; return X86EMUL_PROPAGATE_FAULT; } return X86EMUL_CONTINUE; }"
"static void initOpensslLocks(void) { unsigned ii, nlocks; if (CRYPTO_get_locking_callback() != NULL) { return; } nlocks = CRYPTO_num_locks(); ossl_locks = hiredis_safe_malloc(sizeof(*ossl_locks) * nlocks); for (ii = 0; ii < nlocks; ii++) { sslLockInit(ossl_locks + ii); } CRYPTO_set_locking_callback(opensslDoLock); }"
"static int hugetlb_sysctl_handler_common(bool obey_mempolicy, struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos) { struct hstate *h = &default_hstate; unsigned long tmp = h->max_huge_pages; int ret; if (!hugepages_supported()) return -EOPNOTSUPP; table->data = &tmp; table->maxlen = sizeof(unsigned long); ret = proc_doulongvec_minmax(table, write, buffer, length, ppos); if (ret) goto out; if (write) ret = __nr_hugepages_store_common(obey_mempolicy, h, NUMA_NO_NODE, tmp, *length); out: return ret; }"
"ret_t cherokee_validator_parse_basic (cherokee_validator_t *validator, char *str, cuint_t str_len) { char              *colon; cherokee_buffer_t  auth = CHEROKEE_BUF_INIT; cherokee_buffer_add (&auth, str, str_len); cherokee_buffer_decode_base64 (&auth); colon = strchr (auth.buf, ':'); if (colon == NULL) goto error; cherokee_buffer_add (&validator->user, auth.buf, colon - auth.buf); cherokee_buffer_add (&validator->passwd, colon+1, auth.len  - ((colon+1) - auth.buf)); TRACE (ENTRIES, ""Parse basic auth got user=%s, passwd=%s\n"", validator->user.buf, validator->passwd.buf); cherokee_buffer_mrproper (&auth); return ret_ok; error: cherokee_buffer_mrproper (&auth); return ret_error; }"
"static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size) { struct l2cap_conf_rsp *rsp = data; void *ptr = rsp->data; void *endptr = data + data_size; void *req = chan->conf_req; int len = chan->conf_len; int type, hint, olen; unsigned long val; struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC }; struct l2cap_conf_efs efs; u8 remote_efs = 0; u16 mtu = L2CAP_DEFAULT_MTU; u16 result = L2CAP_CONF_SUCCESS; u16 size; BT_DBG(""chan %p"", chan); while (len >= L2CAP_CONF_OPT_SIZE) { len -= l2cap_get_conf_opt(&req, &type, &olen, &val); if (len < 0) break; hint  = type & L2CAP_CONF_HINT; type &= L2CAP_CONF_MASK; switch (type) { case L2CAP_CONF_MTU: if (olen != 2) break; mtu = val; break; case L2CAP_CONF_FLUSH_TO: if (olen != 2) break; chan->flush_to = val; break; case L2CAP_CONF_QOS: break; case L2CAP_CONF_RFC: if (olen != sizeof(rfc)) break; memcpy(&rfc, (void *) val, olen); break; case L2CAP_CONF_FCS: if (olen != 1) break; if (val == L2CAP_FCS_NONE) set_bit(CONF_RECV_NO_FCS, &chan->conf_state); break; case L2CAP_CONF_EFS: if (olen != sizeof(efs)) break; remote_efs = 1; memcpy(&efs, (void *) val, olen); break; case L2CAP_CONF_EWS: if (olen != 2) break; if (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP)) return -ECONNREFUSED; set_bit(FLAG_EXT_CTRL, &chan->flags); set_bit(CONF_EWS_RECV, &chan->conf_state); chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW; chan->remote_tx_win = val; break; default: if (hint) break; result = L2CAP_CONF_UNKNOWN; l2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr); break; } } if (chan->num_conf_rsp || chan->num_conf_req > 1) goto done; switch (chan->mode) { case L2CAP_MODE_STREAMING: case L2CAP_MODE_ERTM: if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) { chan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask); break; } if (remote_efs) { if (__l2cap_efs_supported(chan->conn)) set_bit(FLAG_EFS_ENABLE, &chan->flags); else return -ECONNREFUSED; } if (chan->mode != rfc.mode) return -ECONNREFUSED; break; } done: if (chan->mode != rfc.mode) { result = L2CAP_CONF_UNACCEPT; rfc.mode = chan->mode; if (chan->num_conf_rsp == 1) return -ECONNREFUSED; l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); } if (result == L2CAP_CONF_SUCCESS) { if (mtu < L2CAP_DEFAULT_MIN_MTU) result = L2CAP_CONF_UNACCEPT; else { chan->omtu = mtu; set_bit(CONF_MTU_DONE, &chan->conf_state); } l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr); if (remote_efs) { if (chan->local_stype != L2CAP_SERV_NOTRAFIC && efs.stype != L2CAP_SERV_NOTRAFIC && efs.stype != chan->local_stype) { result = L2CAP_CONF_UNACCEPT; if (chan->num_conf_req >= 1) return -ECONNREFUSED; l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs, endptr - ptr); } else { result = L2CAP_CONF_PENDING; set_bit(CONF_LOC_CONF_PEND, &chan->conf_state); } } switch (rfc.mode) { case L2CAP_MODE_BASIC: chan->fcs = L2CAP_FCS_NONE; set_bit(CONF_MODE_DONE, &chan->conf_state); break; case L2CAP_MODE_ERTM: if (!test_bit(CONF_EWS_RECV, &chan->conf_state)) chan->remote_tx_win = rfc.txwin_size; else rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW; chan->remote_max_tx = rfc.max_transmit; size = min_t(u16, le16_to_cpu(rfc.max_pdu_size), chan->conn->mtu - L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE); rfc.max_pdu_size = cpu_to_le16(size); chan->remote_mps = size; __l2cap_set_ertm_timeouts(chan, &rfc); set_bit(CONF_MODE_DONE, &chan->conf_state); l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) { chan->remote_id = efs.id; chan->remote_stype = efs.stype; chan->remote_msdu = le16_to_cpu(efs.msdu); chan->remote_flush_to = le32_to_cpu(efs.flush_to); chan->remote_acc_lat = le32_to_cpu(efs.acc_lat); chan->remote_sdu_itime = le32_to_cpu(efs.sdu_itime); l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs, endptr - ptr); } break; case L2CAP_MODE_STREAMING: size = min_t(u16, le16_to_cpu(rfc.max_pdu_size), chan->conn->mtu - L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE); rfc.max_pdu_size = cpu_to_le16(size); chan->remote_mps = size; set_bit(CONF_MODE_DONE, &chan->conf_state); l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); break; default: result = L2CAP_CONF_UNACCEPT; memset(&rfc, 0, sizeof(rfc)); rfc.mode = chan->mode; } if (result == L2CAP_CONF_SUCCESS) set_bit(CONF_OUTPUT_DONE, &chan->conf_state); } rsp->scid   = cpu_to_le16(chan->dcid); rsp->result = cpu_to_le16(result); rsp->flags  = cpu_to_le16(0); return ptr - data; }"
"static int smb3_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct fs_parse_result result; struct smb3_fs_context *ctx = smb3_fc2context(fc); int i, opt; bool is_smb3 = !strcmp(fc->fs_type->name, ""smb3""); bool skip_parsing = false; kuid_t uid; kgid_t gid; cifs_dbg(FYI, ""CIFS: parsing cifs mount option '%s'\n"", param->key); if (param->type == fs_value_is_string && param->string[0] == 0) { if (!strcmp(""pass"", param->key) || !strcmp(""password"", param->key)) { skip_parsing = true; opt = Opt_pass; } else if (!strcmp(""user"", param->key) || !strcmp(""username"", param->key)) { skip_parsing = true; opt = Opt_user; } } if (!skip_parsing) { opt = fs_parse(fc, smb3_fs_parameters, param, &result); if (opt < 0) return ctx->sloppy ? 1 : opt; } switch (opt) { case Opt_compress: ctx->compression = UNKNOWN_TYPE; cifs_dbg(VFS, ""SMB3 compression support is experimental\n""); break; case Opt_nodfs: ctx->nodfs = 1; break; case Opt_hard: if (result.negated) { if (ctx->retry == 1) cifs_dbg(VFS, ""conflicting hard vs. soft mount options\n""); ctx->retry = 0; } else ctx->retry = 1; break; case Opt_soft: if (result.negated) ctx->retry = 1; else { if (ctx->retry == 1) cifs_dbg(VFS, ""conflicting hard vs soft mount options\n""); ctx->retry = 0; } break; case Opt_mapposix: if (result.negated) ctx->remap = false; else { ctx->remap = true; ctx->sfu_remap = false;  } break; case Opt_mapchars: if (result.negated) ctx->sfu_remap = false; else { ctx->sfu_remap = true; ctx->remap = false;  } break; case Opt_user_xattr: if (result.negated) ctx->no_xattr = 1; else ctx->no_xattr = 0; break; case Opt_forceuid: if (result.negated) ctx->override_uid = 0; else ctx->override_uid = 1; break; case Opt_forcegid: if (result.negated) ctx->override_gid = 0; else ctx->override_gid = 1; break; case Opt_perm: if (result.negated) ctx->noperm = 1; else ctx->noperm = 0; break; case Opt_dynperm: if (result.negated) ctx->dynperm = 0; else ctx->dynperm = 1; break; case Opt_sfu: if (result.negated) ctx->sfu_emul = 0; else ctx->sfu_emul = 1; break; case Opt_noblocksend: ctx->noblocksnd = 1; break; case Opt_noautotune: ctx->noautotune = 1; break; case Opt_nolease: ctx->no_lease = 1; break; case Opt_nosparse: ctx->no_sparse = 1; break; case Opt_nodelete: ctx->nodelete = 1; break; case Opt_multichannel: if (result.negated) { ctx->multichannel = false; ctx->max_channels = 1; } else { ctx->multichannel = true; if (ctx->max_channels < 2) ctx->max_channels = 2; } break; case Opt_uid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->linux_uid = uid; ctx->uid_specified = true; break; case Opt_cruid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->cred_uid = uid; ctx->cruid_specified = true; break; case Opt_backupuid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->backupuid = uid; ctx->backupuid_specified = true; break; case Opt_backupgid: gid = make_kgid(current_user_ns(), result.uint_32); if (!gid_valid(gid)) goto cifs_parse_mount_err; ctx->backupgid = gid; ctx->backupgid_specified = true; break; case Opt_gid: gid = make_kgid(current_user_ns(), result.uint_32); if (!gid_valid(gid)) goto cifs_parse_mount_err; ctx->linux_gid = gid; ctx->gid_specified = true; break; case Opt_port: ctx->port = result.uint_32; break; case Opt_file_mode: ctx->file_mode = result.uint_32; break; case Opt_dirmode: ctx->dir_mode = result.uint_32; break; case Opt_min_enc_offload: ctx->min_offload = result.uint_32; break; case Opt_blocksize: if ((result.uint_32 < CIFS_MAX_MSGSIZE) || (result.uint_32 > (4 * SMB3_DEFAULT_IOSIZE))) { cifs_errorf(fc, ""%s: Invalid blocksize\n"", __func__); goto cifs_parse_mount_err; } ctx->bsize = result.uint_32; ctx->got_bsize = true; break; case Opt_rasize: if ((result.uint_32 > (8 * SMB3_DEFAULT_IOSIZE)) || (result.uint_32 < CIFS_DEFAULT_IOSIZE)) { cifs_errorf(fc, ""%s: Invalid rasize %d vs. %d\n"", __func__, result.uint_32, SMB3_DEFAULT_IOSIZE); goto cifs_parse_mount_err; } ctx->rasize = result.uint_32; break; case Opt_rsize: ctx->rsize = result.uint_32; ctx->got_rsize = true; break; case Opt_wsize: ctx->wsize = result.uint_32; ctx->got_wsize = true; break; case Opt_acregmax: ctx->acregmax = HZ * result.uint_32; if (ctx->acregmax > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""acregmax too large\n""); goto cifs_parse_mount_err; } break; case Opt_acdirmax: ctx->acdirmax = HZ * result.uint_32; if (ctx->acdirmax > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""acdirmax too large\n""); goto cifs_parse_mount_err; } break; case Opt_actimeo: if (HZ * result.uint_32 > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""timeout too large\n""); goto cifs_parse_mount_err; } if ((ctx->acdirmax != CIFS_DEF_ACTIMEO) || (ctx->acregmax != CIFS_DEF_ACTIMEO)) { cifs_errorf(fc, ""actimeo ignored since acregmax or acdirmax specified\n""); break; } ctx->acdirmax = ctx->acregmax = HZ * result.uint_32; break; case Opt_closetimeo: ctx->closetimeo = HZ * result.uint_32; if (ctx->closetimeo > SMB3_MAX_DCLOSETIMEO) { cifs_errorf(fc, ""closetimeo too large\n""); goto cifs_parse_mount_err; } break; case Opt_echo_interval: ctx->echo_interval = result.uint_32; break; case Opt_snapshot: ctx->snapshot_time = result.uint_64; break; case Opt_max_credits: if (result.uint_32 < 20 || result.uint_32 > 60000) { cifs_errorf(fc, ""%s: Invalid max_credits value\n"", __func__); goto cifs_parse_mount_err; } ctx->max_credits = result.uint_32; break; case Opt_max_channels: if (result.uint_32 < 1 || result.uint_32 > CIFS_MAX_CHANNELS) { cifs_errorf(fc, ""%s: Invalid max_channels value, needs to be 1-%d\n"", __func__, CIFS_MAX_CHANNELS); goto cifs_parse_mount_err; } ctx->max_channels = result.uint_32; if (result.uint_32 > 1) ctx->multichannel = true; break; case Opt_max_cached_dirs: if (result.uint_32 < 1) { cifs_errorf(fc, ""%s: Invalid max_cached_dirs, needs to be 1 or more\n"", __func__); goto cifs_parse_mount_err; } ctx->max_cached_dirs = result.uint_32; break; case Opt_handletimeout: ctx->handle_timeout = result.uint_32; if (ctx->handle_timeout > SMB3_MAX_HANDLE_TIMEOUT) { cifs_errorf(fc, ""Invalid handle cache timeout, longer than 16 minutes\n""); goto cifs_parse_mount_err; } break; case Opt_source: kfree(ctx->UNC); ctx->UNC = NULL; switch (smb3_parse_devname(param->string, ctx)) { case 0: break; case -ENOMEM: cifs_errorf(fc, ""Unable to allocate memory for devname\n""); goto cifs_parse_mount_err; case -EINVAL: cifs_errorf(fc, ""Malformed UNC in devname\n""); goto cifs_parse_mount_err; default: cifs_errorf(fc, ""Unknown error parsing devname\n""); goto cifs_parse_mount_err; } ctx->source = smb3_fs_context_fullpath(ctx, '/'); if (IS_ERR(ctx->source)) { ctx->source = NULL; cifs_errorf(fc, ""OOM when copying UNC string\n""); goto cifs_parse_mount_err; } fc->source = kstrdup(ctx->source, GFP_KERNEL); if (fc->source == NULL) { cifs_errorf(fc, ""OOM when copying UNC string\n""); goto cifs_parse_mount_err; } break; case Opt_user: kfree(ctx->username); ctx->username = NULL; if (ctx->nullauth) break; if (strlen(param->string) == 0) { ctx->nullauth = 1; break; } if (strnlen(param->string, CIFS_MAX_USERNAME_LEN) > CIFS_MAX_USERNAME_LEN) { pr_warn(""username too long\n""); goto cifs_parse_mount_err; } ctx->username = kstrdup(param->string, GFP_KERNEL); if (ctx->username == NULL) { cifs_errorf(fc, ""OOM when copying username string\n""); goto cifs_parse_mount_err; } break; case Opt_pass: kfree_sensitive(ctx->password); ctx->password = NULL; if (strlen(param->string) == 0) break; ctx->password = kstrdup(param->string, GFP_KERNEL); if (ctx->password == NULL) { cifs_errorf(fc, ""OOM when copying password string\n""); goto cifs_parse_mount_err; } break; case Opt_ip: if (strlen(param->string) == 0) { ctx->got_ip = false; break; } if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr, param->string, strlen(param->string))) { pr_err(""bad ip= option (%s)\n"", param->string); goto cifs_parse_mount_err; } ctx->got_ip = true; break; case Opt_domain: if (strnlen(param->string, CIFS_MAX_DOMAINNAME_LEN) == CIFS_MAX_DOMAINNAME_LEN) { pr_warn(""domain name too long\n""); goto cifs_parse_mount_err; } kfree(ctx->domainname); ctx->domainname = kstrdup(param->string, GFP_KERNEL); if (ctx->domainname == NULL) { cifs_errorf(fc, ""OOM when copying domainname string\n""); goto cifs_parse_mount_err; } cifs_dbg(FYI, ""Domain name set\n""); break; case Opt_srcaddr: if (!cifs_convert_address( (struct sockaddr *)&ctx->srcaddr, param->string, strlen(param->string))) { pr_warn(""Could not parse srcaddr: %s\n"", param->string); goto cifs_parse_mount_err; } break; case Opt_iocharset: if (strnlen(param->string, 1024) >= 65) { pr_warn(""iocharset name too long\n""); goto cifs_parse_mount_err; } if (strncasecmp(param->string, ""default"", 7) != 0) { kfree(ctx->iocharset); ctx->iocharset = kstrdup(param->string, GFP_KERNEL); if (ctx->iocharset == NULL) { cifs_errorf(fc, ""OOM when copying iocharset string\n""); goto cifs_parse_mount_err; } } cifs_dbg(FYI, ""iocharset set to %s\n"", ctx->iocharset); break; case Opt_netbiosname: memset(ctx->source_rfc1001_name, 0x20, RFC1001_NAME_LEN); for (i = 0; i < RFC1001_NAME_LEN; i++) { if (param->string[i] == 0) break; ctx->source_rfc1001_name[i] = param->string[i]; } if (i == RFC1001_NAME_LEN && param->string[i] != 0) pr_warn(""netbiosname longer than 15 truncated\n""); break; case Opt_servern: memset(ctx->target_rfc1001_name, 0x20, RFC1001_NAME_LEN_WITH_NULL); for (i = 0; i < 15; i++) { if (param->string[i] == 0) break; ctx->target_rfc1001_name[i] = param->string[i]; } if (i == RFC1001_NAME_LEN && param->string[i] != 0) pr_warn(""server netbiosname longer than 15 truncated\n""); break; case Opt_ver: if (strncasecmp(param->string, ""1"", 1) == 0) { if (strlen(param->string) > 1) { pr_warn(""Bad mount helper ver=%s. Did you want SMB1 (CIFS) dialect and mean to type vers=1.0 instead?\n"", param->string); goto cifs_parse_mount_err; } break; } pr_warn(""Invalid mount helper version specified\n""); goto cifs_parse_mount_err; case Opt_vers: if (cifs_parse_smb_version(fc, param->string, ctx, is_smb3) != 0) goto cifs_parse_mount_err; ctx->got_version = true; break; case Opt_sec: if (cifs_parse_security_flavors(fc, param->string, ctx) != 0) goto cifs_parse_mount_err; break; case Opt_cache: if (cifs_parse_cache_flavor(fc, param->string, ctx) != 0) goto cifs_parse_mount_err; break; case Opt_witness: #ifndef CONFIG_CIFS_SWN_UPCALL cifs_errorf(fc, ""Witness support needs CONFIG_CIFS_SWN_UPCALL config option\n""); goto cifs_parse_mount_err; #endif ctx->witness = true; pr_warn_once(""Witness protocol support is experimental\n""); break; case Opt_rootfs: #ifndef CONFIG_CIFS_ROOT cifs_dbg(VFS, ""rootfs support requires CONFIG_CIFS_ROOT config option\n""); goto cifs_parse_mount_err; #endif ctx->rootfs = true; break; case Opt_posixpaths: if (result.negated) ctx->posix_paths = 0; else ctx->posix_paths = 1; break; case Opt_unix: if (result.negated) { if (ctx->linux_ext == 1) pr_warn_once(""conflicting posix mount options specified\n""); ctx->linux_ext = 0; ctx->no_linux_ext = 1; } else { if (ctx->no_linux_ext == 1) pr_warn_once(""conflicting posix mount options specified\n""); ctx->linux_ext = 1; ctx->no_linux_ext = 0; } break; case Opt_nocase: ctx->nocase = 1; break; case Opt_brl: if (result.negated) { if (ctx->file_mode == (S_IALLUGO & ~(S_ISUID | S_IXGRP))) ctx->file_mode = S_IALLUGO; ctx->nobrl =  1; } else ctx->nobrl =  0; break; case Opt_handlecache: if (result.negated) ctx->nohandlecache = 1; else ctx->nohandlecache = 0; break; case Opt_forcemandatorylock: ctx->mand_lock = 1; break; case Opt_setuids: ctx->setuids = result.negated; break; case Opt_intr: ctx->intr = !result.negated; break; case Opt_setuidfromacl: ctx->setuidfromacl = 1; break; case Opt_strictsync: ctx->nostrictsync = result.negated; break; case Opt_serverino: ctx->server_ino = !result.negated; break; case Opt_rwpidforward: ctx->rwpidforward = 1; break; case Opt_modesid: ctx->mode_ace = 1; break; case Opt_cifsacl: ctx->cifs_acl = !result.negated; break; case Opt_acl: ctx->no_psx_acl = result.negated; break; case Opt_locallease: ctx->local_lease = 1; break; case Opt_sign: ctx->sign = true; break; case Opt_ignore_signature: ctx->sign = true; ctx->ignore_signature = true; break; case Opt_seal: ctx->seal = 1; break; case Opt_noac: pr_warn(""Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n""); break; case Opt_fsc: #ifndef CONFIG_CIFS_FSCACHE cifs_errorf(fc, ""FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\n""); goto cifs_parse_mount_err; #endif ctx->fsc = true; break; case Opt_mfsymlinks: ctx->mfsymlinks = true; break; case Opt_multiuser: ctx->multiuser = true; break; case Opt_sloppy: ctx->sloppy = true; break; case Opt_nosharesock: ctx->nosharesock = true; break; case Opt_persistent: if (result.negated) { ctx->nopersistent = true; if (ctx->persistent) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } else { ctx->persistent = true; if ((ctx->nopersistent) || (ctx->resilient)) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } break; case Opt_resilient: if (result.negated) { ctx->resilient = false;  } else { ctx->resilient = true; if (ctx->persistent) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } break; case Opt_tcp_nodelay: if (result.negated) ctx->sockopt_tcp_nodelay = false; else ctx->sockopt_tcp_nodelay = true; break; case Opt_domainauto: ctx->domainauto = true; break; case Opt_rdma: ctx->rdma = true; break; } return 0; cifs_parse_mount_err: kfree_sensitive(ctx->password); return -EINVAL; }"
"void scanner_filter_arguments (parser_context_t *context_p,  scanner_context_t *scanner_context_p)  { scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p; scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p; parser_list_iterator_t literal_iterator; lexer_lit_location_t *literal_p; bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0; bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0; JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags)); if (can_eval) { if (prev_literal_pool_p != NULL) { prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL; } if (has_arguments) { literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS); } } literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL; parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while (true) { literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator); if (literal_p == NULL) { return; } if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)) { literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE; } uint8_t type = literal_p->type; const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG); if ((type & mask) != SCANNER_LITERAL_IS_ARG) { break; } } bool has_destructured_arg = false; scanner_literal_pool_t *new_literal_pool_p; new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t)); new_literal_pool_p->prev_p = literal_pool_p; scanner_context_p->active_literal_pool_p = new_literal_pool_p; *new_literal_pool_p = *literal_pool_p; parser_list_init (&new_literal_pool_p->literal_pool, sizeof (lexer_lit_location_t), (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t))); parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL) { uint8_t type = literal_p->type; if (type & SCANNER_LITERAL_IS_ARG) { if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)) { type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE; literal_p->type = type; } if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG)) { has_destructured_arg = true; if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG) { continue; } type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG; type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG; literal_p->type = type; continue; } lexer_lit_location_t *new_literal_p; new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool); *new_literal_p = *literal_p; } else if (has_arguments && scanner_literal_is_arguments (literal_p)) { new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS; if (type & SCANNER_LITERAL_NO_REG) { new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS; } } else if (prev_literal_pool_p != NULL) { lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p); type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED; literal_location_p->type |= type; } } if (has_destructured_arg) { parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL) { const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG; if ((literal_p->type & expected_flags) == expected_flags) { lexer_lit_location_t *new_literal_p; new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool); *new_literal_p = *literal_p; } } } new_literal_pool_p->prev_p = prev_literal_pool_p; parser_list_free (&literal_pool_p->literal_pool); scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t)); }"
"unsigned long move_page_tables(struct vm_area_struct *vma, unsigned long old_addr, struct vm_area_struct *new_vma, unsigned long new_addr, unsigned long len, bool need_rmap_locks) { unsigned long extent, old_end; struct mmu_notifier_range range; pmd_t *old_pmd, *new_pmd; pud_t *old_pud, *new_pud; old_end = old_addr + len; flush_cache_range(vma, old_addr, old_end); mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm, old_addr, old_end); mmu_notifier_invalidate_range_start(&range); for (; old_addr < old_end; old_addr += extent, new_addr += extent) { cond_resched(); extent = get_extent(NORMAL_PUD, old_addr, old_end, new_addr); old_pud = get_old_pud(vma->vm_mm, old_addr); if (!old_pud) continue; new_pud = alloc_new_pud(vma->vm_mm, vma, new_addr); if (!new_pud) break; if (pud_trans_huge(*old_pud) || pud_devmap(*old_pud)) { if (extent == HPAGE_PUD_SIZE) { move_pgt_entry(HPAGE_PUD, vma, old_addr, new_addr, old_pud, new_pud, need_rmap_locks); continue; } } else if (IS_ENABLED(CONFIG_HAVE_MOVE_PUD) && extent == PUD_SIZE) { if (move_pgt_entry(NORMAL_PUD, vma, old_addr, new_addr, old_pud, new_pud, need_rmap_locks)) continue; } extent = get_extent(NORMAL_PMD, old_addr, old_end, new_addr); old_pmd = get_old_pmd(vma->vm_mm, old_addr); if (!old_pmd) continue; new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr); if (!new_pmd) break; if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) { if (extent == HPAGE_PMD_SIZE && move_pgt_entry(HPAGE_PMD, vma, old_addr, new_addr, old_pmd, new_pmd, need_rmap_locks)) continue; split_huge_pmd(vma, old_pmd, old_addr); if (pmd_trans_unstable(old_pmd)) continue; } else if (IS_ENABLED(CONFIG_HAVE_MOVE_PMD) && extent == PMD_SIZE) { if (move_pgt_entry(NORMAL_PMD, vma, old_addr, new_addr, old_pmd, new_pmd, need_rmap_locks)) continue; } if (pte_alloc(new_vma->vm_mm, new_pmd)) break; move_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks); } mmu_notifier_invalidate_range_end(&range); return len + old_addr - old_end; }"
"void Compute(OpKernelContext* context) override { const Tensor& spectrogram = context->input(0); OP_REQUIRES(context, spectrogram.dims() == 3, errors::InvalidArgument(""spectrogram must be 3-dimensional"", spectrogram.shape().DebugString())); const Tensor& sample_rate_tensor = context->input(1); OP_REQUIRES(context, TensorShapeUtils::IsScalar(sample_rate_tensor.shape()), errors::InvalidArgument( ""Input sample_rate should be a scalar tensor, got "", sample_rate_tensor.shape().DebugString(), "" instead."")); const int32_t sample_rate = sample_rate_tensor.scalar<int32>()(); const int spectrogram_channels = spectrogram.dim_size(2); const int spectrogram_samples = spectrogram.dim_size(1); const int audio_channels = spectrogram.dim_size(0); Mfcc mfcc; mfcc.set_upper_frequency_limit(upper_frequency_limit_); mfcc.set_lower_frequency_limit(lower_frequency_limit_); mfcc.set_filterbank_channel_count(filterbank_channel_count_); mfcc.set_dct_coefficient_count(dct_coefficient_count_); OP_REQUIRES(context, mfcc.Initialize(spectrogram_channels, sample_rate), errors::InvalidArgument( ""Mfcc initialization failed for channel count "", spectrogram_channels, "" and sample rate "", sample_rate)); Tensor* output_tensor = nullptr; OP_REQUIRES_OK(context, context->allocate_output( 0, TensorShape({audio_channels, spectrogram_samples, dct_coefficient_count_}), &output_tensor)); const float* spectrogram_flat = spectrogram.flat<float>().data(); float* output_flat = output_tensor->flat<float>().data(); for (int audio_channel = 0; audio_channel < audio_channels; ++audio_channel) { for (int spectrogram_sample = 0; spectrogram_sample < spectrogram_samples; ++spectrogram_sample) { const float* sample_data = spectrogram_flat + (audio_channel * spectrogram_samples * spectrogram_channels) + (spectrogram_sample * spectrogram_channels); std::vector<double> mfcc_input(sample_data, sample_data + spectrogram_channels); std::vector<double> mfcc_output; mfcc.Compute(mfcc_input, &mfcc_output); DCHECK_EQ(dct_coefficient_count_, mfcc_output.size()); float* output_data = output_flat + (audio_channel * spectrogram_samples * dct_coefficient_count_) + (spectrogram_sample * dct_coefficient_count_); for (int i = 0; i < dct_coefficient_count_; ++i) { output_data[i] = mfcc_output[i]; } } } }"
static void __xen_evtchn_do_upcall(void) { struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu); int cpu = smp_processor_id(); read_lock(&evtchn_rwlock); do { vcpu_info->evtchn_upcall_pending = 0; xen_evtchn_handle_events(cpu); BUG_ON(!irqs_disabled()); virt_rmb();  } while (vcpu_info->evtchn_upcall_pending); read_unlock(&evtchn_rwlock); }
"int base64url_encode(const void *data_in, size_t data_in_size, unsigned char *base64_out, size_t *base64_out_size) { return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true); }"
"static void io_async_task_func(struct callback_head *cb) { struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work); struct async_poll *apoll = req->apoll; struct io_ring_ctx *ctx = req->ctx; trace_io_uring_task_run(req->ctx, req->opcode, req->user_data); if (io_poll_rewait(req, &apoll->poll)) { spin_unlock_irq(&ctx->completion_lock); return; } if (hash_hashed(&req->hash_node)) hash_del(&req->hash_node); io_poll_remove_double(req, apoll->double_poll); spin_unlock_irq(&ctx->completion_lock); if (!READ_ONCE(apoll->poll.canceled)) __io_req_task_submit(req); else __io_req_task_cancel(req, -ECANCELED); kfree(apoll->double_poll); kfree(apoll); }"
static inline void io_uring_files_cancel(struct files_struct *files) { if (current->io_uring && !xa_empty(&current->io_uring->xa)) __io_uring_files_cancel(files); }
"MDnsSdListener::Monitor::Monitor() { mHead = nullptr; mLiveCount = 0; mPollFds = nullptr; mPollRefs = nullptr; mPollSize = 10; socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, mCtrlSocketPair); const int rval = ::android::netdutils::threadLaunch(this); if (rval != 0) { ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-rval), -rval); } }"
"static int write_file(tree_t *t, FILE   *fp, int    col) { inti; uchar*ptr; while (t != NULL) { if (t->markup == MARKUP_NONE) { if (t->preformatted) { for (ptr = t->data; *ptr != '\0'; ptr ++) fputs((char *)iso8859(*ptr), fp); if (t->data[strlen((char *)t->data) - 1] == '\n') col = 0; else col += strlen((char *)t->data); } else { if ((col + (int)strlen((char *)t->data)) > 72 && col > 0) { putc('\n', fp); col = 0; } for (ptr = t->data; *ptr != '\0'; ptr ++) fputs((char *)iso8859(*ptr), fp); col += strlen((char *)t->data); if (col > 72) { putc('\n', fp); col = 0; } } } else if (t->markup == MARKUP_COMMENT) fprintf(fp, ""\n<!--%s-->\n"", t->data); else if (t->markup > 0) { switch (t->markup) { case MARKUP_AREA : case MARKUP_BR : case MARKUP_CENTER : case MARKUP_COMMENT : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_HEAD : case MARKUP_HR : case MARKUP_LI : case MARKUP_MAP : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TITLE : case MARKUP_TR : case MARKUP_UL : case MARKUP_DIR : case MARKUP_MENU : if (col > 0) { putc('\n', fp); col = 0; } default : break; } col += fprintf(fp, ""<%s"", _htmlMarkups[t->markup]); for (i = 0; i < t->nvars; i ++) { if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } if (col > 0) { putc(' ', fp); col ++; } if (t->vars[i].value == NULL) col += fprintf(fp, ""%s"", t->vars[i].name); else if (strchr((char *)t->vars[i].value, '\""') != NULL) col += fprintf(fp, ""%s=\'%s\'"", t->vars[i].name, t->vars[i].value); else col += fprintf(fp, ""%s=\""%s\"""", t->vars[i].name, t->vars[i].value); } putc('>', fp); col ++; if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } if (t->child != NULL) { col = write_file(t->child, fp, col); if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } col += fprintf(fp, ""</%s>"", _htmlMarkups[t->markup]); switch (t->markup) { case MARKUP_AREA : case MARKUP_BR : case MARKUP_CENTER : case MARKUP_COMMENT : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_HEAD : case MARKUP_HR : case MARKUP_LI : case MARKUP_MAP : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TITLE : case MARKUP_TR : case MARKUP_UL : case MARKUP_DIR : case MARKUP_MENU : putc('\n', fp); col = 0; default : break; } } } t = t->next; } return (col); }"
"int dissect_gquic_frame_type(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint8 len_pkn, gquic_info_data_t *gquic_info){ proto_item *ti, *ti_ft, *ti_ftflags ; proto_tree *ft_tree, *ftflags_tree; guint8 frame_type; guint8 num_ranges, num_revived, num_blocks = 0, num_timestamp; guint32 len_stream = 0, len_offset = 0, len_data = 0, len_largest_observed = 1, len_missing_packet = 1; ti_ft = proto_tree_add_item(gquic_tree, hf_gquic_frame, tvb, offset, 1, ENC_NA); ft_tree = proto_item_add_subtree(ti_ft, ett_gquic_ft); ti_ftflags = proto_tree_add_item(ft_tree, hf_gquic_frame_type, tvb, offset, 1, ENC_NA); frame_type = tvb_get_guint8(tvb, offset); proto_item_set_text(ti_ft, ""%s"", rval_to_str(frame_type, frame_type_vals, ""Unknown"")); if((frame_type & FTFLAGS_SPECIAL) == 0 && frame_type != FT_CRYPTO){  offset += 1; switch(frame_type){ case FT_PADDING:{ proto_item *ti_pad_len; guint32 pad_len = tvb_reported_length_remaining(tvb, offset); ti_pad_len = proto_tree_add_uint(ft_tree, hf_gquic_frame_type_padding_length, tvb, offset, 0, pad_len); proto_item_set_generated(ti_pad_len); proto_item_append_text(ti_ft, "" Length: %u"", pad_len); if(pad_len > 0)  proto_tree_add_item(ft_tree, hf_gquic_frame_type_padding, tvb, offset, -1, ENC_NA); offset += pad_len; } break; case FT_RST_STREAM:{ guint32 stream_id, error_code; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_rsts_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_rsts_byte_offset, tvb, offset, 8, gquic_info->encoding); offset += 8; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_rsts_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_item_append_text(ti_ft, "" Stream ID: %u, Error code: %s"", stream_id, val_to_str_ext(error_code, &rststream_error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""RST STREAM""); } break; case FT_CONNECTION_CLOSE:{ guint16 len_reason; guint32 error_code; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_cc_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_cc_reason_phrase_length, tvb, offset, 2, gquic_info->encoding); len_reason = tvb_get_guint16(tvb, offset, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_cc_reason_phrase, tvb, offset, len_reason, ENC_ASCII); offset += len_reason; proto_item_append_text(ti_ft, "" Error code: %s"", val_to_str_ext(error_code, &error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""Connection Close""); } break; case FT_GOAWAY:{ guint16 len_reason; guint32 error_code, last_good_stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_goaway_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_goaway_last_good_stream_id, tvb, offset, 4, gquic_info->encoding, &last_good_stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_goaway_reason_phrase_length, tvb, offset, 2, gquic_info->encoding); len_reason = tvb_get_guint16(tvb, offset, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_goaway_reason_phrase, tvb, offset, len_reason, ENC_ASCII); offset += len_reason; proto_item_append_text(ti_ft, "" Stream ID: %u, Error code: %s"", last_good_stream_id, val_to_str_ext(error_code, &error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""GOAWAY""); } break; case FT_WINDOW_UPDATE:{ guint32 stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_wu_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_wu_byte_offset, tvb, offset, 8, gquic_info->encoding); offset += 8; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); } break; case FT_BLOCKED:{ guint32 stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_blocked_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); } break; case FT_STOP_WAITING:{ guint8 send_entropy; if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ft_tree, hf_gquic_frame_type_sw_send_entropy, tvb, offset, 1, ENC_NA); send_entropy = tvb_get_guint8(tvb, offset); proto_item_append_text(ti_ft, "" Send Entropy: %u"", send_entropy); offset += 1; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_sw_least_unacked_delta, tvb, offset, len_pkn, gquic_info->encoding); offset += len_pkn; } break; case FT_PING:  default:  break; } } else {  guint32 stream_id, message_tag; const guint8* message_tag_str; proto_item *ti_stream; ftflags_tree = proto_item_add_subtree(ti_ftflags, ett_gquic_ftflags); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream , tvb, offset, 1, ENC_NA); if(frame_type == FT_CRYPTO) { guint64 crypto_offset, crypto_length; gint32 lenvar; DISSECTOR_ASSERT(gquic_info->version_valid && gquic_info->version >= 50); col_append_fstr(pinfo->cinfo, COL_INFO, "", CRYPTO""); offset += 1; proto_tree_add_item_ret_varint(ft_tree, hf_gquic_crypto_offset, tvb, offset, -1, ENC_VARINT_QUIC, &crypto_offset, &lenvar); offset += lenvar; proto_tree_add_item_ret_varint(ft_tree, hf_gquic_crypto_length, tvb, offset, -1, ENC_VARINT_QUIC, &crypto_length, &lenvar); offset += lenvar; proto_tree_add_item(ft_tree, hf_gquic_crypto_crypto_data, tvb, offset, (guint32)crypto_length, ENC_NA); if (gquic_info->version == 50) { message_tag = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item_ret_string(ft_tree, hf_gquic_tag, tvb, offset, 4, ENC_ASCII|ENC_NA, pinfo->pool, &message_tag_str); proto_item_append_text(ti, "" (%s)"", val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s"", val_to_str(message_tag, message_tag_vals, ""Unknown"")); offset += 4; offset = dissect_gquic_tags(tvb, pinfo, ft_tree, offset); } else {  tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, (int)crypto_length); col_set_writable(pinfo->cinfo, -1, FALSE); call_dissector_with_data(tls13_handshake_handle, next_tvb, pinfo, ft_tree, GUINT_TO_POINTER(crypto_offset)); col_set_writable(pinfo->cinfo, -1, TRUE); offset += (guint32)crypto_length; } } else if(frame_type & FTFLAGS_STREAM){  proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_f, tvb, offset, 1, ENC_NA); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_d, tvb, offset, 1, ENC_NA); if(frame_type & FTFLAGS_STREAM_D){ len_data = 2; } proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_ooo, tvb, offset, 1, ENC_NA); len_offset = get_len_offset(frame_type); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_ss, tvb, offset, 1, ENC_NA); len_stream = get_len_stream(frame_type); offset += 1; ti_stream = proto_tree_add_item_ret_uint(ft_tree, hf_gquic_stream_id, tvb, offset, len_stream, gquic_info->encoding, &stream_id); offset += len_stream; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); if(len_offset) { proto_tree_add_item(ft_tree, hf_gquic_offset, tvb, offset, len_offset, gquic_info->encoding); offset += len_offset; } if(len_data) { proto_tree_add_item(ft_tree, hf_gquic_data_len, tvb, offset, len_data, gquic_info->encoding); offset += len_data; } switch(stream_id) { case 1: {  message_tag = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item_ret_string(ft_tree, hf_gquic_tag, tvb, offset, 4, ENC_ASCII|ENC_NA, pinfo->pool, &message_tag_str); proto_item_append_text(ti_stream, "" (Reserved for (G)QUIC handshake, crypto, config updates...)""); proto_item_append_text(ti, "" (%s)"", val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); proto_item_append_text(ti_ft, "", Type: %s (%s)"", message_tag_str, val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s"", val_to_str(message_tag, message_tag_vals, ""Unknown"")); offset += 4; offset = dissect_gquic_tags(tvb, pinfo, ft_tree, offset); break; } case 3: {  tvbuff_t* tvb_h2; proto_item_append_text(ti_stream, "" (Reserved for H2 HEADERS)""); col_add_str(pinfo->cinfo, COL_INFO, ""H2""); tvb_h2 = tvb_new_subset_remaining(tvb, offset); offset += dissect_http2_pdu(tvb_h2, pinfo, ft_tree, NULL); } break; default: {  int data_len = tvb_reported_length_remaining(tvb, offset); col_add_str(pinfo->cinfo, COL_INFO, ""DATA""); proto_tree_add_item(ft_tree, hf_gquic_stream_data, tvb, offset, data_len, ENC_NA); offset += data_len; } break; } } else if (frame_type & FTFLAGS_ACK) {      proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack, tvb, offset, 1, ENC_NA); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_n, tvb, offset, 1, ENC_NA); if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_t, tvb, offset, 1, ENC_NA); } else { proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_u, tvb, offset, 1, ENC_NA); } proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_ll, tvb, offset, 1, ENC_NA); len_largest_observed = get_len_largest_observed(frame_type); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_mm, tvb, offset, 1, ENC_NA); len_missing_packet = get_len_missing_packet(frame_type); offset += 1; if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_received_entropy, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_observed, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_ack_delay_time, tvb, offset, 2, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_timestamp, tvb, offset, 1, ENC_NA); num_timestamp = tvb_get_guint8(tvb, offset); offset += 1; if(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_observed, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_first_timestamp, tvb, offset, 4, gquic_info->encoding); offset += 4; num_timestamp -= 1; while(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_observed, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_previous_timestamp, tvb, offset, 2, gquic_info->encoding); offset += 2; num_timestamp--; } } if(frame_type & FTFLAGS_ACK_N){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_ranges, tvb, offset, 1, ENC_NA); num_ranges = tvb_get_guint8(tvb, offset); offset += 1; while(num_ranges){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_missing_packet, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_range_length, tvb, offset, 1, ENC_NA); offset += 1; num_ranges--; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_revived, tvb, offset, 1, ENC_NA); num_revived = tvb_get_guint8(tvb, offset); offset += 1; while(num_revived){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_revived_packet, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; num_revived--; } } } else { proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_acked, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_acked_delta_time, tvb, offset, 2, gquic_info->encoding); offset += 2; if(frame_type & FTFLAGS_ACK_N){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_blocks, tvb, offset, 1, ENC_NA); num_blocks = tvb_get_guint8(tvb, offset); offset += 1; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_first_ack_block_length, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; while(num_blocks){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_gap_to_next_block, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_ack_block_length, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; num_blocks--; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_timestamp, tvb, offset, 1, ENC_NA); num_timestamp = tvb_get_guint8(tvb, offset); offset += 1; if(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_acked, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_largest_acked, tvb, offset, 4, gquic_info->encoding); offset += 4; num_timestamp -= 1; while(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_acked, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_previous_timestamp, tvb, offset, 2, gquic_info->encoding); offset += 2; num_timestamp--; } } } } else {  offset += 1; } } return offset; }"
"void ex_function(exarg_T *eap) { (void)define_function(eap, NULL); }"
"unsigned int sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, int *cmnd_status, int pwflag) { struct defaults_list *defs = NULL; struct sudoers_parse_tree *parse_tree = NULL; struct cmndspec *cs = NULL; struct sudo_nss *nss; struct cmnd_info info; unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST; int m, match = UNSPEC; debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER); if (pwflag) { debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback, cb_data, pwflag)); } if (!set_perms(ctx, PERM_RUNAS)) debug_return_uint(validated); TAILQ_FOREACH(nss, snl, entries) { if (nss->query(ctx, nss, ctx->user.pw) == -1) { SET(validated, VALIDATE_ERROR); break; } m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback, cb_data, &cs, &defs); if (m != UNSPEC) { match = m; parse_tree = nss->parse_tree; } if (!sudo_nss_can_continue(nss, m)) break; } if (match != UNSPEC) { if (info.cmnd_path != NULL) { free(ctx->user.cmnd); ctx->user.cmnd = info.cmnd_path; if (ctx->user.cmnd_stat != NULL) *ctx->user.cmnd_stat = info.cmnd_stat; *cmnd_status = info.status; } if (defs != NULL) (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false); if (!apply_cmndspec(ctx, cs)) SET(validated, VALIDATE_ERROR); else if (match == ALLOW) SET(validated, VALIDATE_SUCCESS); else SET(validated, VALIDATE_FAILURE); } if (!restore_perms()) SET(validated, VALIDATE_ERROR); debug_return_uint(validated); }"
static inline int32_t unzigzag32(uint32_t v) { return (int32_t)((v >> 1) ^ (~(v & 1) + 1)); }
"static inline void bss_ref_get(struct cfg80211_registered_device *rdev, struct cfg80211_internal_bss *bss) { lockdep_assert_held(&rdev->bss_lock); bss->refcount++; if (bss->pub.hidden_beacon_bss) { bss = container_of(bss->pub.hidden_beacon_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } if (bss->pub.transmitted_bss) { bss = container_of(bss->pub.transmitted_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } }"
"static int fuse_permission(struct inode *inode, int mask) { struct fuse_conn *fc = get_fuse_conn(inode); bool refreshed = false; int err = 0; if (!fuse_allow_current_process(fc)) return -EACCES; if (fc->default_permissions || ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) { struct fuse_inode *fi = get_fuse_inode(inode); u32 perm_mask = STATX_MODE | STATX_UID | STATX_GID; if (perm_mask & READ_ONCE(fi->inval_mask) || time_before64(fi->i_time, get_jiffies_64())) { refreshed = true; err = fuse_perm_getattr(inode, mask); if (err) return err; } } if (fc->default_permissions) { err = generic_permission(inode, mask); if (err == -EACCES && !refreshed) { err = fuse_perm_getattr(inode, mask); if (!err) err = generic_permission(inode, mask); } } else if (mask & (MAY_ACCESS | MAY_CHDIR)) { err = fuse_access(inode, mask); } else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) { if (!(inode->i_mode & S_IXUGO)) { if (refreshed) return -EACCES; err = fuse_perm_getattr(inode, mask); if (!err && !(inode->i_mode & S_IXUGO)) return -EACCES; } } return err; }"
void virPCIVirtualFunctionListFree(virPCIVirtualFunctionList *list) { size_t i; if (!list) return; for (i = 0; i < list->nfunctions; i++) { g_free(list->functions[i].addr); g_free(list->functions[i].ifname); } g_free(list); }
"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]) { struct netlink_ext_ack *extack = info->extack; u8 genmask = nft_genmask_next(info->net); u8 family = info->nfmsg->nfgen_family; struct nft_chain *chain = NULL; struct net *net = info->net; struct nft_table *table; struct nft_rule *rule; struct nft_ctx ctx; int err = 0; table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, NETLINK_CB(skb).portid); if (IS_ERR(table)) { NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]); return PTR_ERR(table); } if (nla[NFTA_RULE_CHAIN]) { chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask); if (IS_ERR(chain)) { if (PTR_ERR(chain) == -ENOENT && NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE) return 0; NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]); return PTR_ERR(chain); } if (nft_chain_is_bound(chain)) return -EOPNOTSUPP; } nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla); if (chain) { if (nla[NFTA_RULE_HANDLE]) { rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]); if (IS_ERR(rule)) { if (PTR_ERR(rule) == -ENOENT && NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE) return 0; NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]); return PTR_ERR(rule); } err = nft_delrule(&ctx, rule); } else if (nla[NFTA_RULE_ID]) { rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]); if (IS_ERR(rule)) { NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]); return PTR_ERR(rule); } err = nft_delrule(&ctx, rule); } else { err = nft_delrule_by_chain(&ctx); } } else { list_for_each_entry(chain, &table->chains, list) { if (!nft_is_active_next(net, chain)) continue; ctx.chain = chain; err = nft_delrule_by_chain(&ctx); if (err < 0) break; } } return err; }"
"static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath) { char tempObjectFile[SMALL_BUFFER_MAX_SIZE] = """"; char *cmd; int32_t result = 0; int32_t length = 0; uprv_strcpy(tempObjectFile, gencFilePath); tempObjectFile[uprv_strlen(tempObjectFile)-1] = 'o'; length = static_cast<int32_t>(uprv_strlen(pkgDataFlags[COMPILER]) + uprv_strlen(pkgDataFlags[LIBFLAGS]) + uprv_strlen(tempObjectFile) + uprv_strlen(gencFilePath) + BUFFER_PADDING_SIZE); cmd = (char *)uprv_malloc(sizeof(char) * length); if (cmd == NULL) { return -1; } sprintf(cmd, ""%s %s -o %s %s"", pkgDataFlags[COMPILER], pkgDataFlags[LIBFLAGS], tempObjectFile, gencFilePath); result = runCommand(cmd); uprv_free(cmd); if (result != 0) { fprintf(stderr, ""Error creating with assembly code. Failed command: %s\n"", cmd); return result; } return pkg_generateLibraryFile(targetDir, mode, tempObjectFile); }"
"int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update) { struct mosquitto_client_msg *msg; struct mosquitto_msg_data *msg_data; enum mosquitto_msg_state state = mosq_ms_invalid; int rc = 0; int i; char **dest_ids; assert(stored); if(!context) return MOSQ_ERR_INVAL; if(!context->id) return MOSQ_ERR_SUCCESS;  if(dir == mosq_md_out){ msg_data = &context->msgs_out; }else{ msg_data = &context->msgs_in; } if(context->protocol != mosq_p_mqtt5 && db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false && stored->dest_ids){ for(i=0; i<stored->dest_id_count; i++){ if(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){ mosquitto_property_free_all(&properties); return MOSQ_ERR_SUCCESS; } } } if(context->sock == INVALID_SOCKET){ if(qos == 0 && !db.config->queue_qos0_messages){ if(!context->bridge){ mosquitto_property_free_all(&properties); return 2; }else{ if(context->bridge->start_type != bst_lazy){ mosquitto_property_free_all(&properties); return 2; } } } if(context->bridge && context->bridge->clean_start_local == true){ mosquitto_property_free_all(&properties); return 2; } } if(context->sock != INVALID_SOCKET){ if(db__ready_for_flight(context, dir, qos)){ if(dir == mosq_md_out){ switch(qos){ case 0: state = mosq_ms_publish_qos0; break; case 1: state = mosq_ms_publish_qos1; break; case 2: state = mosq_ms_publish_qos2; break; } }else{ if(qos == 2){ state = mosq_ms_wait_for_pubrel; }else{ mosquitto_property_free_all(&properties); return 1; } } }else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){ state = mosq_ms_queued; rc = 2; }else{ if(context->is_dropping == false){ context->is_dropping = true; log__printf(NULL, MOSQ_LOG_NOTICE, ""Outgoing messages are being dropped for client %s."", context->id); } G_MSGS_DROPPED_INC(); mosquitto_property_free_all(&properties); return 2; } }else{ if (db__ready_for_queue(context, qos, msg_data)){ state = mosq_ms_queued; }else{ G_MSGS_DROPPED_INC(); if(context->is_dropping == false){ context->is_dropping = true; log__printf(NULL, MOSQ_LOG_NOTICE, ""Outgoing messages are being dropped for client %s."", context->id); } mosquitto_property_free_all(&properties); return 2; } } assert(state != mosq_ms_invalid); #ifdef WITH_PERSISTENCE if(state == mosq_ms_queued){ db.persistence_changes++; } #endif msg = mosquitto__malloc(sizeof(struct mosquitto_client_msg)); if(!msg) return MOSQ_ERR_NOMEM; msg->prev = NULL; msg->next = NULL; msg->store = stored; db__msg_store_ref_inc(msg->store); msg->mid = mid; msg->timestamp = db.now_s; msg->direction = dir; msg->state = state; msg->dup = false; if(qos > context->max_qos){ msg->qos = context->max_qos; }else{ msg->qos = qos; } msg->retain = retain; msg->properties = properties; if(state == mosq_ms_queued){ DL_APPEND(msg_data->queued, msg); db__msg_add_to_queued_stats(msg_data, msg); }else{ DL_APPEND(msg_data->inflight, msg); db__msg_add_to_inflight_stats(msg_data, msg); } if(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){ dest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1)); if(dest_ids){ stored->dest_ids = dest_ids; stored->dest_id_count++; stored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id); if(!stored->dest_ids[stored->dest_id_count-1]){ return MOSQ_ERR_NOMEM; } }else{ return MOSQ_ERR_NOMEM; } } #ifdef WITH_BRIDGE if(context->bridge && context->bridge->start_type == bst_lazy && context->sock == INVALID_SOCKET && context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){ context->bridge->lazy_reconnect = true; } #endif if(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){ util__decrement_send_quota(context); } if(dir == mosq_md_out && update){ rc = db__message_write_inflight_out_latest(context); if(rc) return rc; rc = db__message_write_queued_out(context); if(rc) return rc; } return rc; }"
"static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman, int transferDir) { UINT32 EndpointAddress; UINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets; UINT32 ErrorCount, OutputBufferSize; BYTE* packetDescriptorData; const BOOL noAck = (RequestField & 0x80000000U) != 0; const UINT32 RequestId = RequestField & 0x7FFFFFFF; if (!pdev || !callback || !udevman) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 20) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, PipeHandle); EndpointAddress = (PipeHandle & 0x000000ff); Stream_Read_UINT32(s, TransferFlags);    Stream_Read_UINT32(s, StartFrame);       Stream_Read_UINT32(s, NumberOfPackets);  Stream_Read_UINT32(s, ErrorCount);       if (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4) return ERROR_INVALID_DATA; packetDescriptorData = Stream_Pointer(s); Stream_Seek(s, NumberOfPackets * 12); Stream_Read_UINT32(s, OutputBufferSize); return pdev->isoch_transfer( pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame, ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL, urb_isoch_transfer_cb, 2000); }"
"static int con_install(struct tty_driver *driver, struct tty_struct *tty) { unsigned int currcons = tty->index; struct vc_data *vc; int ret; console_lock(); ret = vc_allocate(currcons); if (ret) goto unlock; vc = vc_cons[currcons].d; if (vc->port.tty) { ret = -ERESTARTSYS; goto unlock; } ret = tty_port_install(&vc->port, driver, tty); if (ret) goto unlock; tty->driver_data = vc; vc->port.tty = tty; if (!tty->winsize.ws_row && !tty->winsize.ws_col) { tty->winsize.ws_row = vc_cons[currcons].d->vc_rows; tty->winsize.ws_col = vc_cons[currcons].d->vc_cols; } if (vc->vc_utf) tty->termios.c_iflag |= IUTF8; else tty->termios.c_iflag &= ~IUTF8; unlock: console_unlock(); return ret; }"
"static int decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset) { LZ4F_decompressionContext_t lz4_ctxt = NULL; LZ4F_frameInfo_t lz4_info; LZ4F_errorCode_t rc = 0; size_t src_offset = 0, src_size = 0, dst_size = 0; guchar *decompressed_buffer = NULL; tvbuff_t *composite_tvb = NULL; int ret = 0; guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length); if (length > 7) { guint32 hdr_end = 6; if (data[4] & 0x08) { hdr_end += 8; } if (hdr_end < length) { data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff; } } rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION); if (LZ4F_isError(rc)) { goto end; } src_offset = length; rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset); if (LZ4F_isError(rc)) { goto end; } switch (lz4_info.blockSizeID) { case LZ4F_max64KB: dst_size = 1 << 16; break; case LZ4F_max256KB: dst_size = 1 << 18; break; case LZ4F_max1MB: dst_size = 1 << 20; break; case LZ4F_max4MB: dst_size = 1 << 22; break; default: goto end; } if (lz4_info.contentSize && lz4_info.contentSize < dst_size) { dst_size = (size_t)lz4_info.contentSize; } do { src_size = length - src_offset;         if (src_size == 0) { goto end; } decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size); rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size, &data[src_offset], &src_size, NULL); if (LZ4F_isError(rc)) { goto end; } if (dst_size == 0) { goto end; } if (!composite_tvb) { composite_tvb = tvb_new_composite(); } tvb_composite_append(composite_tvb, tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size)); src_offset += src_size;     } while (rc > 0); ret = 1; end: if (composite_tvb) { tvb_composite_finalize(composite_tvb); } LZ4F_freeDecompressionContext(lz4_ctxt); if (ret == 1) { *decompressed_tvb = composite_tvb; *decompressed_offset = 0; } else { col_append_str(pinfo->cinfo, COL_INFO, "" [lz4 decompression failed]""); } return ret; }"
"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba) { struct ufs_mtk_host *host = ufshcd_get_variant(hba); host->reg_va09 = regulator_get(hba->dev, ""va09""); if (!host->reg_va09) dev_info(hba->dev, ""failed to get va09""); else host->caps |= UFS_MTK_CAP_VA09_PWR_CTRL; }"
"int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct cgroup_fs_context *ctx = cgroup_fc2context(fc); struct cgroup_subsys *ss; struct fs_parse_result result; int opt, i; opt = fs_parse(fc, cgroup1_fs_parameters, param, &result); if (opt == -ENOPARAM) { int ret; ret = vfs_parse_fs_param_source(fc, param); if (ret != -ENOPARAM) return ret; for_each_subsys(ss, i) { if (strcmp(param->key, ss->legacy_name)) continue; if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i)) return invalfc(fc, ""Disabled controller '%s'"", param->key); ctx->subsys_mask |= (1 << i); return 0; } return invalfc(fc, ""Unknown subsys name '%s'"", param->key); } if (opt < 0) return opt; switch (opt) { case Opt_none: ctx->none = true; break; case Opt_all: ctx->all_ss = true; break; case Opt_noprefix: ctx->flags |= CGRP_ROOT_NOPREFIX; break; case Opt_clone_children: ctx->cpuset_clone_children = true; break; case Opt_cpuset_v2_mode: ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE; break; case Opt_xattr: ctx->flags |= CGRP_ROOT_XATTR; break; case Opt_release_agent: if (ctx->release_agent) return invalfc(fc, ""release_agent respecified""); ctx->release_agent = param->string; param->string = NULL; break; case Opt_name: if (cgroup_no_v1_named) return -ENOENT; if (!param->size) return invalfc(fc, ""Empty name""); if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1) return invalfc(fc, ""Name too long""); for (i = 0; i < param->size; i++) { char c = param->string[i]; if (isalnum(c)) continue; if ((c == '.') || (c == '-') || (c == '_')) continue; return invalfc(fc, ""Invalid name""); } if (ctx->name) return invalfc(fc, ""name respecified""); ctx->name = param->string; param->string = NULL; break; } return 0; }"
"static UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp) { DWORD DesiredAccess; DWORD SharedAccess; DWORD CreateDisposition; UINT32 PathLength; if (Stream_GetRemainingLength(irp->input) < 32) return ERROR_INVALID_DATA; Stream_Read_UINT32(irp->input, DesiredAccess);      Stream_Seek_UINT64(irp->input);                     Stream_Seek_UINT32(irp->input);                     Stream_Read_UINT32(irp->input, SharedAccess);       Stream_Read_UINT32(irp->input, CreateDisposition);  Stream_Seek_UINT32(irp->input);                     Stream_Read_UINT32(irp->input, PathLength);         if (Stream_GetRemainingLength(irp->input) < PathLength) return ERROR_INVALID_DATA; Stream_Seek(irp->input, PathLength);  assert(PathLength == 0);              #ifndef _WIN32 WLog_Print(serial->log, WLOG_DEBUG, ""DesiredAccess: 0x%"" PRIX32 "", SharedAccess: 0x%"" PRIX32 "", CreateDisposition: 0x%"" PRIX32 """", DesiredAccess, SharedAccess, CreateDisposition); DesiredAccess = GENERIC_READ | GENERIC_WRITE; SharedAccess = 0; CreateDisposition = OPEN_EXISTING; #endif serial->hComm = CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL,  CreateDisposition, 0,                                    NULL);                                                   if (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE)) { WLog_Print(serial->log, WLOG_WARN, ""CreateFile failure: %s last-error: 0x%08"" PRIX32 """", serial->device.name, GetLastError()); irp->IoStatus = STATUS_UNSUCCESSFUL; goto error_handle; } _comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId); _comm_set_permissive(serial->hComm, serial->permissive); assert(irp->FileId == 0); irp->FileId = irp->devman->id_sequence++;  irp->IoStatus = STATUS_SUCCESS; WLog_Print(serial->log, WLOG_DEBUG, ""%s (DeviceId: %"" PRIu32 "", FileId: %"" PRIu32 "") created."", serial->device.name, irp->device->id, irp->FileId); error_handle: Stream_Write_UINT32(irp->output, irp->FileId);  Stream_Write_UINT8(irp->output, 0);             return CHANNEL_RC_OK; }"
"void p_ntp_time(netdissect_options *ndo, const struct l_fixedpt *lfp) { uint32_t i; uint32_t uf; uint32_t f; double ff; i = GET_BE_U_4(lfp->int_part); uf = GET_BE_U_4(lfp->fraction); ff = uf; if (ff < 0.0) ff += FMAXINT; ff = ff / FMAXINT; f = (uint32_t)(ff * 1000000000.0); ND_PRINT(""%u.%09u"", i, f); if (i) { int64_t seconds_64bit = (int64_t)i - JAN_1970; time_t seconds; struct tm *tm; char time_buf[128]; seconds = (time_t)seconds_64bit; if (seconds != seconds_64bit) { ND_PRINT("" (unrepresentable)""); } else { tm = gmtime(&seconds); if (tm == NULL) { ND_PRINT("" (unrepresentable)""); } else { strftime(time_buf, sizeof (time_buf), ""%Y-%m-%dT%H:%M:%SZ"", tm); ND_PRINT("" (%s)"", time_buf); } } } }"
"BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize, UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat, UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth, UINT32 nDstHeight, BOOL vFlip) { BOOL cs; BOOL rle; UINT32 cll; BOOL alpha; BOOL useAlpha = FALSE; INT32 status; const BYTE* srcp; UINT32 subSize; UINT32 subWidth; UINT32 subHeight; UINT32 planeSize; INT32 rleSizes[4] = { 0, 0, 0, 0 }; UINT32 rawSizes[4]; UINT32 rawWidths[4]; UINT32 rawHeights[4]; BYTE FormatHeader; const BYTE* planes[4] = { 0 }; const UINT32 w = MIN(nSrcWidth, nDstWidth); const UINT32 h = MIN(nSrcHeight, nDstHeight); const primitives_t* prims = primitives_get(); WINPR_ASSERT(planar); WINPR_ASSERT(prims); if (nDstStep <= 0) nDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat); srcp = pSrcData; if (!pSrcData) { WLog_ERR(TAG, ""Invalid argument pSrcData=NULL""); return FALSE; } if (!pDstData) { WLog_ERR(TAG, ""Invalid argument pDstData=NULL""); return FALSE; } FormatHeader = *srcp++; cll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK); cs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE; rle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE; alpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE; DstFormat = planar_invert_format(planar, alpha, DstFormat); if (alpha) useAlpha = FreeRDPColorHasAlpha(DstFormat); if (!cll && cs) { WLog_ERR(TAG, ""Chroma subsampling requires YCoCg and does not work with RGB data""); return FALSE;  } subWidth = (nSrcWidth / 2) + (nSrcWidth % 2); subHeight = (nSrcHeight / 2) + (nSrcHeight % 2); planeSize = nSrcWidth * nSrcHeight; subSize = subWidth * subHeight; if (!cs) { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } else  { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = subSize;  rawWidths[1] = subWidth; rawHeights[1] = subHeight; rawSizes[2] = subSize;  rawWidths[2] = subWidth; rawHeights[2] = subHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } if (!rle)  { UINT32 base = planeSize * 3; if (cs) base = planeSize + planeSize / 2; if (alpha) { if ((SrcSize - (srcp - pSrcData)) < (planeSize + base)) { WLog_ERR(TAG, ""Alpha plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), (planeSize + base)); return FALSE; } planes[3] = srcp;                     planes[0] = planes[3] + rawSizes[3];  planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } else { if ((SrcSize - (srcp - pSrcData)) < base) { WLog_ERR(TAG, ""plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), base); return FALSE; } planes[0] = srcp;                     planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } } else  { if (alpha) { planes[3] = srcp; rleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData), rawWidths[3], rawHeights[3]);  if (rleSizes[3] < 0) return FALSE; planes[0] = planes[3] + rleSizes[3]; } else planes[0] = srcp; rleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData), rawWidths[0], rawHeights[0]);  if (rleSizes[0] < 0) return FALSE; planes[1] = planes[0] + rleSizes[0]; rleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData), rawWidths[1], rawHeights[1]);  if (rleSizes[1] < 1) return FALSE; planes[2] = planes[1] + rleSizes[1]; rleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData), rawWidths[2], rawHeights[2]);  if (rleSizes[2] < 1) return FALSE; } if (!cll)  { UINT32 TempFormat; BYTE* pTempData = pDstData; UINT32 nTempStep = nDstStep; UINT32 nTotalHeight = nYDst + nDstHeight; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; TempFormat = planar_invert_format(planar, alpha, TempFormat); if ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight)) { pTempData = planar->pTempData; nTempStep = planar->nTempStep; nTotalHeight = planar->maxHeight; } if (!rle)  { if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } else  { status = planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 2, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 1, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 0, vFlip);  if (status < 0) return FALSE; srcp += rleSizes[0] + rleSizes[1] + rleSizes[2]; if (useAlpha) { status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip);  } else status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip); if (status < 0) return FALSE; if (alpha) srcp += rleSizes[3]; } if (pTempData != pDstData) { if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData, TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE)) { WLog_ERR(TAG, ""planar image copy failed""); return FALSE; } } } else  { UINT32 TempFormat; BYTE* pTempData = planar->pTempData; UINT32 nTempStep = planar->nTempStep; UINT32 nTotalHeight = planar->maxHeight; BYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep]; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; if (!pTempData) { return FALSE; } if (rle)  { BYTE* rleBuffer[4] = { 0 }; rleBuffer[3] = planar->rlePlanesBuffer;   rleBuffer[0] = rleBuffer[3] + planeSize;  rleBuffer[1] = rleBuffer[0] + planeSize;  rleBuffer[2] = rleBuffer[1] + planeSize;  if (useAlpha) { status = planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3], rawWidths[3], rawHeights[3]);  if (status < 0) return FALSE; } if (alpha) srcp += rleSizes[3]; status = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0], rawWidths[0], rawHeights[0]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1], rawHeights[1]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2], rawHeights[2]);  if (status < 0) return FALSE; planes[0] = rleBuffer[0]; planes[1] = rleBuffer[1]; planes[2] = rleBuffer[2]; planes[3] = rleBuffer[3]; } { if (cs) {  if (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight, rawWidths[1], rawHeights[1], planar->deltaPlanes[0])) return FALSE; planes[1] = planar->deltaPlanes[0]; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; if (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight, rawWidths[2], rawHeights[2], planar->deltaPlanes[1])) return FALSE; planes[2] = planar->deltaPlanes[1]; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; } if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } WINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R); int rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h, cll, useAlpha); if (rc != PRIMITIVES_SUCCESS) { WLog_ERR(TAG, ""YCoCgToRGB_8u_AC4R failed with %d"", rc); return FALSE; } } WINPR_UNUSED(srcp); return TRUE; }"
"static int mwifiex_usb_recv(struct mwifiex_adapter *adapter, struct sk_buff *skb, u8 ep) { u32 recv_type; __le32 tmp; int ret; if (adapter->hs_activated) mwifiex_process_hs_config(adapter); if (skb->len < INTF_HEADER_LEN) { mwifiex_dbg(adapter, ERROR, ""%s: invalid skb->len\n"", __func__); return -1; } switch (ep) { case MWIFIEX_USB_EP_CMD_EVENT: mwifiex_dbg(adapter, EVENT, ""%s: EP_CMD_EVENT\n"", __func__); skb_copy_from_linear_data(skb, &tmp, INTF_HEADER_LEN); recv_type = le32_to_cpu(tmp); skb_pull(skb, INTF_HEADER_LEN); switch (recv_type) { case MWIFIEX_USB_TYPE_CMD: if (skb->len > MWIFIEX_SIZE_OF_CMD_BUFFER) { mwifiex_dbg(adapter, ERROR, ""CMD: skb->len too large\n""); ret = -1; goto exit_restore_skb; } else if (!adapter->curr_cmd) { mwifiex_dbg(adapter, WARN, ""CMD: no curr_cmd\n""); if (adapter->ps_state == PS_STATE_SLEEP_CFM) { mwifiex_process_sleep_confirm_resp( adapter, skb->data, skb->len); ret = 0; goto exit_restore_skb; } ret = -1; goto exit_restore_skb; } adapter->curr_cmd->resp_skb = skb; adapter->cmd_resp_received = true; break; case MWIFIEX_USB_TYPE_EVENT: if (skb->len < sizeof(u32)) { mwifiex_dbg(adapter, ERROR, ""EVENT: skb->len too small\n""); ret = -1; goto exit_restore_skb; } skb_copy_from_linear_data(skb, &tmp, sizeof(u32)); adapter->event_cause = le32_to_cpu(tmp); mwifiex_dbg(adapter, EVENT, ""event_cause %#x\n"", adapter->event_cause); if (skb->len > MAX_EVENT_SIZE) { mwifiex_dbg(adapter, ERROR, ""EVENT: event body too large\n""); ret = -1; goto exit_restore_skb; } memcpy(adapter->event_body, skb->data + MWIFIEX_EVENT_HEADER_LEN, skb->len); adapter->event_received = true; adapter->event_skb = skb; break; default: mwifiex_dbg(adapter, ERROR, ""unknown recv_type %#x\n"", recv_type); return -1; } break; case MWIFIEX_USB_EP_DATA: mwifiex_dbg(adapter, DATA, ""%s: EP_DATA\n"", __func__); if (skb->len > MWIFIEX_RX_DATA_BUF_SIZE) { mwifiex_dbg(adapter, ERROR, ""DATA: skb->len too large\n""); return -1; } skb_queue_tail(&adapter->rx_data_q, skb); adapter->data_received = true; atomic_inc(&adapter->rx_pending); break; default: mwifiex_dbg(adapter, ERROR, ""%s: unknown endport %#x\n"", __func__, ep); return -1; } return -EINPROGRESS; exit_restore_skb: skb_push(skb, INTF_HEADER_LEN); return ret; }"
"static void parser_reparse_as_common_identifier (parser_context_t *context_p,  parser_line_counter_t start_line,  parser_line_counter_t start_column)  { context_p->source_p = context_p->token.lit_location.char_p; context_p->line = start_line; context_p->column = start_column; lexer_next_token (context_p); if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL) { parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED); } lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL); }"
"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { const TfLiteTensor* params; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params)); const TfLiteTensor* indices; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices)); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); switch (indices->type) { case kTfLiteInt32: return EvalGatherNd<int32_t>(context, params, indices, output); case kTfLiteInt64: return EvalGatherNd<int64_t>(context, params, indices, output); default: context->ReportError( context, ""Indices of type '%s' are not supported by gather_nd."", TfLiteTypeGetName(indices->type)); return kTfLiteError; } }"
"static int string_scan_range(RList *list, RBinFile *bf, int min, const ut64 from, const ut64 to, int type, int raw, RBinSection *section) { RBin *bin = bf->rbin; ut8 tmp[R_STRING_SCAN_BUFFER_SIZE]; ut64 str_start, needle = from; int count = 0, i, rc, runes; int str_type = R_STRING_TYPE_DETECT; r_return_val_if_fail (bf, -1); if (type == -1) { type = R_STRING_TYPE_DETECT; } if (from == to) { return 0; } if (from > to) { eprintf (""Invalid range to find strings 0x%""PFMT64x"" .. 0x%""PFMT64x""\n"", from, to); return -1; } st64 len = (st64)(to - from); if (len < 1 || len > ST32_MAX) { eprintf (""String scan range is invalid (%""PFMT64d"" bytes)\n"", len); return -1; } ut8 *buf = calloc (len, 1); if (!buf || !min) { free (buf); return -1; } st64 vdelta = 0, pdelta = 0; RBinSection *s = NULL; bool ascii_only = false; PJ *pj = NULL; if (bf->strmode == R_MODE_JSON && !list) { pj = pj_new (); if (pj) { pj_a (pj); } } r_buf_read_at (bf->buf, from, buf, len); char *charset = r_sys_getenv (""RABIN2_CHARSET""); if (!R_STR_ISEMPTY (charset)) { RCharset *ch = r_charset_new (); if (r_charset_use (ch, charset)) { int outlen = len * 4; ut8 *out = calloc (len, 4); if (out) { int res = r_charset_encode_str (ch, out, outlen, buf, len); int i; for (i = 0; i < res; i++) { if (out[i] == '?') { out[i] = 0; } } len = res; free (buf); buf = out; } else { eprintf (""Cannot allocate\n""); } } else { eprintf (""Invalid value for RABIN2_CHARSET.\n""); } r_charset_free (ch); } free (charset); RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL; while (needle < to) { if (is_breaked && is_breaked ()) { break; } if (needle + 4 < to) { ut32 n1 = r_read_le32 (buf + needle - from); if (!n1) { needle += 4; continue; } } rc = r_utf8_decode (buf + needle - from, to - needle, NULL); if (!rc) { needle++; continue; } bool addr_aligned = !(needle % 4); if (type == R_STRING_TYPE_DETECT) { char *w = (char *)buf + needle + rc - from; if (((to - needle) > 8 + rc)) { bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]); if (is_wide32le) { if (!w[5] && !w[6] && w[7] && w[8]) { is_wide32le = false; } } if (!addr_aligned) { is_wide32le = false; } if (is_wide32le  && addr_aligned) { str_type = R_STRING_TYPE_WIDE32; } else { bool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4]; str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII; } } else { if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } else { str_type = R_STRING_TYPE_ASCII; } } } else if (type == R_STRING_TYPE_UTF8) { str_type = R_STRING_TYPE_ASCII; } else { str_type = type; } runes = 0; str_start = needle; for (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) { RRune r = {0}; if (str_type == R_STRING_TYPE_WIDE32) { rc = r_utf32le_decode (buf + needle - from, to - needle, &r); if (rc) { rc = 4; } } else if (str_type == R_STRING_TYPE_WIDE) { rc = r_utf16le_decode (buf + needle - from, to - needle, &r); if (rc == 1) { rc = 2; } } else { rc = r_utf8_decode (buf + needle - from, to - needle, &r); if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } } if (!rc || (ascii_only && r > 0x7f)) { needle++; break; } needle += rc; if (r_isprint (r) && r != '\\') { if (str_type == R_STRING_TYPE_WIDE32) { if (r == 0xff) { r = 0; } } rc = r_utf8_encode (tmp + i, r); runes++; } else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) { if ((i + 32) < sizeof (tmp) && r < 93) { tmp[i + 0] = '\\'; tmp[i + 1] = ""       abtnvfr             e  "" ""                              "" ""                              "" ""  \\""[r]; } else { break; } rc = 2; runes++; } else { break; } } tmp[i++] = '\0'; if (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) { needle -= 2; } if (runes >= min) { int j, num_blocks, *block_list; int *freq_list = NULL, expected_ascii, actual_ascii, num_chars; if (str_type == R_STRING_TYPE_ASCII) { for (j = 0; j < i; j++) { char ch = tmp[j]; if (ch != '\n' && ch != '\r' && ch != '\t') { if (!IS_PRINTABLE (tmp[j])) { continue; } } } } switch (str_type) { case R_STRING_TYPE_UTF8: case R_STRING_TYPE_WIDE: case R_STRING_TYPE_WIDE32: num_blocks = 0; block_list = r_utf_block_list ((const ut8*)tmp, i - 1, str_type == R_STRING_TYPE_WIDE? &freq_list: NULL); if (block_list) { for (j = 0; block_list[j] != -1; j++) { num_blocks++; } } if (freq_list) { num_chars = 0; actual_ascii = 0; for (j = 0; freq_list[j] != -1; j++) { num_chars += freq_list[j]; if (!block_list[j]) { actual_ascii = freq_list[j]; } } free (freq_list); expected_ascii = num_blocks ? num_chars / num_blocks : 0; if (actual_ascii > expected_ascii) { ascii_only = true; needle = str_start; free (block_list); continue; } } free (block_list); if (num_blocks > R_STRING_MAX_UNI_BLOCKS) { needle++; continue; } } RBinString *bs = R_NEW0 (RBinString); if (!bs) { break; } bs->type = str_type; bs->length = runes; bs->size = needle - str_start; bs->ordinal = count++; switch (str_type) { case R_STRING_TYPE_WIDE: if (str_start - from > 1) { const ut8 *p = buf + str_start - 2 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 2; } } break; case R_STRING_TYPE_WIDE32: if (str_start - from > 3) { const ut8 *p = buf + str_start - 4 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 4; } } break; } if (!s) { if (section) { s = section; } else if (bf->o) { s = r_bin_get_section_at (bf->o, str_start, false); } if (s) { vdelta = s->vaddr; pdelta = s->paddr; } } ut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr; bs->paddr = str_start + baddr; bs->vaddr = str_start - pdelta + vdelta + baddr; bs->string = r_str_ndup ((const char *)tmp, i); if (list) { r_list_append (list, bs); if (bf->o) { ht_up_insert (bf->o->strings_db, bs->vaddr, bs); } } else { print_string (bf, bs, raw, pj); r_bin_string_free (bs); } if (from == 0 && to == bf->size) { s = NULL; } } ascii_only = false; } free (buf); if (pj) { pj_end (pj); if (bin) { RIO *io = bin->iob.io; if (io) { io->cb_printf (""%s"", pj_string (pj)); } } pj_free (pj); } return count; }"
"void *calloc(size_t nmemb, size_t size) { return zalloc(nmemb * size); }"
int32_t calculate_operand_data_length(const DnnOperand* oprd) { return oprd->dims[0] * oprd->dims[1] * oprd->dims[2] * oprd->dims[3] * sizeof(float); }
"PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID) { BOOL bsuccess; PACL pdacl = This->GetACL(); PACL pdacl_padded = NULL; PSID psid; GUID ObjectTypeGuid, InheritedObjectTypeGuid; GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL; if (addfunc == NULL) return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname); if (obObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid)) return NULL; pObjectTypeGuid = &ObjectTypeGuid; } if (obInheritedObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid)) return NULL; pInheritedObjectTypeGuid = &InheritedObjectTypeGuid; } if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid); if (bsuccess) bsuccess = _ReorderACL(pdacl); else { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(funcname, err); unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid); pdacl_padded = (ACL *)malloc(required_size); if (pdacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size); ZeroMemory(pdacl_padded, required_size); memcpy(pdacl_padded, pdacl, pdacl->AclSize); pdacl_padded->AclSize = required_size; bsuccess = (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid); if (bsuccess) { bsuccess = _ReorderACL(pdacl_padded); if (bsuccess) bsuccess = This->SetACL(pdacl_padded); } else PyWin_SetAPIError(funcname); } if (pdacl_padded) free(pdacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }"
"static int mqtt_read_message_chunk(struct mqtt_client *client, struct buf_ctx *buf, u32_t length) { int remaining; int len; remaining = length - (buf->end - buf->cur); if (remaining <= 0) { return 0; } if (buf->end + remaining > client->rx_buf + client->rx_buf_size) { MQTT_ERR(""[CID %p]: Buffer too small to receive the message"", client); return -ENOMEM; } len = mqtt_transport_read(client, buf->end, remaining, false); if (len < 0) { MQTT_TRC(""[CID %p]: Transport read error: %d"", client, len); return len; } if (len == 0) { MQTT_TRC(""[CID %p]: Connection closed."", client); return -ENOTCONN; } client->internal.rx_buf_datalen += len; buf->end += len; if (len < remaining) { MQTT_TRC(""[CID %p]: Message partially received."", client); return -EAGAIN; } return 0; }"
"static int db__message_reconnect_reset_incoming(struct mosquitto *context) { struct mosquitto_client_msg *msg, *tmp; context->msgs_in.inflight_bytes = 0; context->msgs_in.inflight_bytes12 = 0; context->msgs_in.inflight_count = 0; context->msgs_in.inflight_count12 = 0; context->msgs_in.queued_bytes = 0; context->msgs_in.queued_bytes12 = 0; context->msgs_in.queued_count = 0; context->msgs_in.queued_count12 = 0; context->msgs_in.inflight_quota = context->msgs_in.inflight_maximum; DL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){ db__msg_add_to_inflight_stats(&context->msgs_in, msg); if(msg->qos > 0){ util__decrement_receive_quota(context); } if(msg->qos != 2){ db__message_remove_from_inflight(&context->msgs_in, msg); }else{ } } DL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){ db__msg_add_to_queued_stats(&context->msgs_in, msg); if(db__ready_for_flight(context, mosq_md_in, msg->qos)){ switch(msg->qos){ case 0: msg->state = mosq_ms_publish_qos0; break; case 1: msg->state = mosq_ms_publish_qos1; break; case 2: msg->state = mosq_ms_publish_qos2; break; } db__message_dequeue_first(context, &context->msgs_in); } } return MOSQ_ERR_SUCCESS; }"
"njs_int_t njs_array_prototype_to_string(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_index_t unused) { njs_int_t           ret; njs_value_t         value; njs_lvlhsh_query_t  lhq; static const njs_value_t  join_string = njs_string(""join""); if (njs_is_object(&args[0])) { njs_object_property_init(&lhq, &join_string, NJS_JOIN_HASH); ret = njs_object_property(vm, &args[0], &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } if (njs_is_function(&value)) { return njs_function_apply(vm, njs_function(&value), args, nargs, &vm->retval); } } return njs_object_prototype_to_string(vm, args, nargs, unused); }"
"GF_EXPORT GF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { u32 type; GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE; if (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) return GF_ISOM_HEVCTYPE_NONE; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return GF_ISOM_HEVCTYPE_NONE; type = entry->type; if (type == GF_ISOM_BOX_TYPE_ENCV) { GF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) type = sinf->original_format->data_format; } else if (type == GF_ISOM_BOX_TYPE_RESV) { if (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format; } if (type == GF_ISOM_BOX_TYPE_DVHE) { type = GF_ISOM_BOX_TYPE_HEV1; } switch (type) { case GF_ISOM_BOX_TYPE_HVC1: case GF_ISOM_BOX_TYPE_HEV1: case GF_ISOM_BOX_TYPE_HVC2: case GF_ISOM_BOX_TYPE_HEV2: case GF_ISOM_BOX_TYPE_LHV1: case GF_ISOM_BOX_TYPE_LHE1: case GF_ISOM_BOX_TYPE_HVT1: break; default: return GF_ISOM_HEVCTYPE_NONE; } if (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY; if (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC; if (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY; return GF_ISOM_HEVCTYPE_NONE; }"
"static void sess_free_buffer(struct sess_data *sess_data) { int i; for (i = 0; i < 3; i++) if (sess_data->iov[i].iov_base) memzero_explicit(sess_data->iov[i].iov_base, sess_data->iov[i].iov_len); free_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base); sess_data->buf0_type = CIFS_NO_BUFFER; kfree(sess_data->iov[2].iov_base); }"
"static intset *intsetResize(intset *is, uint32_t len) { uint32_t size = len*intrev32ifbe(is->encoding); is = zrealloc(is,sizeof(intset)+size); return is; }"
"static int dissect_ippusb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) { gint offset = 0; gint ret = 0; guint first_linelen; const guchar *first_line; gint next_offset; guint8 last; guint8 status_code; const guchar *last_chunk = NULL; struct ippusb_analysis *ippusbd = NULL; conversation_t *conv = NULL; struct ippusb_multisegment_pdu *new_msp = NULL; struct ippusb_multisegment_pdu *current_msp = NULL; struct ippusb_multisegment_pdu *previous_msp = NULL; gint reported_length = tvb_reported_length(tvb); gint captured_length = tvb_captured_length(tvb); if((conv = find_conversation_pinfo(pinfo, 0)) != NULL) { if (pinfo->num > conv->last_frame) { conv->last_frame = pinfo->num; } } else { conv = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst, ENDPOINT_TCP, pinfo->srcport, pinfo->destport, 0); } ippusbd = get_ippusb_conversation_data(conv, pinfo); first_linelen = tvb_find_line_end(tvb, offset, tvb_ensure_captured_length_remaining(tvb, offset), &next_offset, TRUE); first_line = tvb_get_ptr(tvb, offset, first_linelen); last = tvb_get_guint8(tvb, captured_length - 1); status_code = tvb_get_bits8(tvb, 3 * BITS_PER_BYTE, BITS_PER_BYTE); if(captured_length == CHUNK_LENGTH_MIN){ last_chunk = tvb_get_ptr(tvb, offset, captured_length); } if (is_http_header(first_linelen, first_line) && last == TAG_END_OF_ATTRIBUTES && status_code != PRINT_JOB && status_code != SEND_DOCUMENT) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); if (ippusb_last_pdu >= 0 && !pinfo->fd->visited) { ippusb_last_pdu = -1; } ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, tvb, pinfo, tree, TRUE, data); } else if (global_ippusb_reassemble) { if (!pinfo->fd->visited) { gboolean save_fragmented = pinfo->fragmented; pinfo->fragmented = TRUE; proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); if (is_http_header(first_linelen, first_line)) { new_msp = pdu_store(pinfo, ippusbd->multisegment_pdus, pinfo->num, TRUE, 0); new_msp->running_size = captured_length; fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), 0, captured_length, TRUE); ippusb_last_pdu = pinfo->num; } else { previous_msp = (struct ippusb_multisegment_pdu *)wmem_tree_lookup32_le(ippusbd->multisegment_pdus, ippusb_last_pdu); if (previous_msp) { previous_msp->nxtpdu = pinfo->num; new_msp = pdu_store(pinfo, ippusbd->multisegment_pdus, previous_msp->first_frame, previous_msp->is_ipp, previous_msp->document); new_msp->running_size = previous_msp->running_size + captured_length; if ((first_linelen >= strlen(""Content-Type: "") && strncmp(first_line, ""Content-Type: "", strlen(""Content-Type: "")) == 0) && (first_linelen < strlen(""Content-Type: application/ipp"") || strncmp(first_line, ""Content-Type: application/ipp"", strlen(""Content-Type: application/ipp"")) != 0)) { new_msp->is_ipp = FALSE; } if (status_code == PRINT_JOB || status_code == SEND_DOCUMENT) { new_msp->document |= MSP_HAS_DOCUMENT; } if(!(last_chunk && strncmp(last_chunk, CHUNKED_END, CHUNK_LENGTH_MIN) == 0)){ if (captured_length < reported_length && (new_msp->document & MSP_HAS_DOCUMENT)) { tvbuff_t *new_tvb = tvb_new_subset_length(tvb, 0, captured_length); fragment_add_check(&ippusb_reassembly_table, new_tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, TRUE); new_msp->document |= MSP_DOCUMENT_TRUNCATED; } else { fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, TRUE); } if (last != NEWLINE) { fragment_add_check(&ippusb_reassembly_table, return_newline_tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), new_msp->running_size, sizeof(RETURN_NEWLINE), TRUE); new_msp->running_size += sizeof(RETURN_NEWLINE); } ippusb_last_pdu = pinfo->num; } else { new_msp->finished = TRUE; ippusb_last_pdu = -1; fragment_head *head = fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, FALSE); tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, ""Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); new_msp->reassembled = TRUE; pinfo->can_desegment = 0; if(processed_tvb){ ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); col_append_fstr(pinfo->cinfo, COL_INFO, "" Reassembled Data""); } } } pinfo->fragmented = save_fragmented; } } else { gboolean save_fragmented = pinfo->fragmented; pinfo->fragmented = TRUE; current_msp = (struct ippusb_multisegment_pdu *)wmem_tree_lookup32_le(ippusbd->multisegment_pdus, pinfo->num); if(current_msp && !(current_msp->is_ipp)){ return captured_length; } if (current_msp && !current_msp->finished && current_msp->nxtpdu == 0) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); fragment_head *head; if (!current_msp->reassembled) { pinfo->fd->visited = FALSE; if (captured_length < reported_length && (current_msp->document & MSP_HAS_DOCUMENT)) { tvbuff_t *new_tvb = tvb_new_subset_length(tvb, 0, captured_length); head = fragment_add_check(&ippusb_reassembly_table, new_tvb, offset, pinfo, current_msp->first_frame, GUINT_TO_POINTER(current_msp->first_frame), current_msp->running_size - captured_length, captured_length, FALSE); current_msp->document |= MSP_DOCUMENT_TRUNCATED; } else { head = fragment_add_check(&ippusb_reassembly_table, tvb, 0, pinfo, current_msp->first_frame, GUINT_TO_POINTER(current_msp->first_frame), current_msp->running_size - captured_length, captured_length, FALSE); } pinfo->fd->visited = TRUE; current_msp->reassembled = TRUE; } else { head = fragment_get_reassembled_id(&ippusb_reassembly_table, pinfo, current_msp->first_frame); } tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, "" Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); if (processed_tvb) { pinfo->can_desegment = 0; ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); if (current_msp->document & MSP_DOCUMENT_TRUNCATED) { col_append_fstr(pinfo->cinfo, COL_INFO, "" Document Truncated""); } } } else if ((last_chunk && strncmp(last_chunk, CHUNKED_END, CHUNK_LENGTH_MIN) == 0)) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); fragment_head *head = fragment_get_reassembled_id(&ippusb_reassembly_table, pinfo, current_msp->first_frame); tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, "" Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); if (processed_tvb) { pinfo->can_desegment = 0; ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); col_append_fstr(pinfo->cinfo, COL_INFO, "" Reassembled Data""); if (current_msp->document & MSP_DOCUMENT_TRUNCATED) { col_append_fstr(pinfo->cinfo, COL_INFO, "" Document Truncated""); } } } pinfo->fragmented = save_fragmented; } } if (ret) { return tvb_captured_length(tvb); } else { return 0; } }"
"static void ok_jpg_decode2(ok_jpg_decoder *decoder) { ok_jpg *jpg = decoder->jpg; uint8_t jpg_header[2]; if (!ok_read(decoder, jpg_header, 2)) { return; } if (jpg_header[0] != 0xFF || jpg_header[1] != 0xD8) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid signature (not a JPEG file)""); return; } while (!decoder->eoi_found) { uint8_t buffer[2]; int marker; if (decoder->next_marker != 0) { marker = decoder->next_marker; decoder->next_marker = 0; } else { if (!ok_read(decoder, buffer, 2)) { return; } if (buffer[0] == 0xFF) { marker = buffer[1]; } else if (buffer[0] == 0x00 && buffer[1] == 0xFF) { if (!ok_read(decoder, buffer, 1)) { return; } marker = buffer[0]; } else { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG marker""); return; } } bool success = true; if (marker == 0xC0 || marker == 0xC1 || marker == 0xC2) { decoder->progressive = (marker == 0xC2); success = ok_jpg_read_sof(decoder); if (success && decoder->info_only) { return; } } else if (marker == 0xC4) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dht(decoder); } else if (marker >= 0xD0 && marker <= 0xD7) { decoder->next_marker = marker; ok_jpg_decode_restart_if_needed(decoder); success = ok_jpg_scan_to_next_marker(decoder); } else if (marker == 0xD9) { decoder->eoi_found = true; if (!decoder->info_only && decoder->progressive) { ok_jpg_progressive_finish(decoder); } } else if (marker == 0xDA) { if (!decoder->info_only) { success = ok_jpg_read_sos(decoder); } else { success = ok_jpg_skip_segment(decoder); if (success) { success = ok_jpg_scan_to_next_marker(decoder); } } } else if (marker == 0xDB) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dqt(decoder); } else if (marker == 0xDD) { success = ok_jpg_read_dri(decoder); } else if (marker == 0xE1) { success = ok_jpg_read_exif(decoder); } else if ((marker >= 0xE0 && marker <= 0xEF) || marker == 0xFE) { success = ok_jpg_skip_segment(decoder); } else if (marker == 0xFF) { } else { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Unsupported or corrupt JPEG""); success = false; } if (!success) { return; } } if (decoder->num_components == 0) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""SOF not found""); } else { for (int i = 0; i < decoder->num_components; i++) { if (!decoder->components[i].complete) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Missing JPEG image data""); break; } } } }"
"size_t count_in_range(size_t start, size_t len, bool value) const { VERIFY(start < m_size); VERIFY(start + len <= m_size); if (len == 0) return 0; static const u8 bitmask_first_byte[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 }; static const u8 bitmask_last_byte[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F }; size_t count; const u8* first = &m_data[start / 8]; const u8* last = &m_data[(start + len) / 8]; u8 byte = *first; byte &= bitmask_first_byte[start % 8]; if (first == last) { byte &= bitmask_last_byte[(start + len) % 8]; count = __builtin_popcount(byte); } else { count = __builtin_popcount(byte); byte = *last; byte &= bitmask_last_byte[(start + len) % 8]; count += __builtin_popcount(byte); if (++first < last) { const u32* ptr32 = (const u32*)(((FlatPtr)first + sizeof(u32) - 1) & ~(sizeof(u32) - 1)); if ((const u8*)ptr32 > last) ptr32 = (const u32*)last; while (first < (const u8*)ptr32) { count += __builtin_popcount(*first); first++; } const u32* last32 = (const u32*)((FlatPtr)last & ~(sizeof(u32) - 1)); while (ptr32 < last32) { count += __builtin_popcountl(*ptr32); ptr32++; } for (first = (const u8*)ptr32; first < last; first++) count += __builtin_popcount(*first); } } if (!value) count = len - count; return count; }"
