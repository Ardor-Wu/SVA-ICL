"static int _dwarf_internal_printlines(Dwarf_Die die, int * err_count_out, int only_line_header, Dwarf_Error * error) { Dwarf_Small *line_ptr = 0; Dwarf_Small *orig_line_ptr = 0; Dwarf_Attribute stmt_list_attr = 0; Dwarf_Attribute comp_dir_attr = 0; Dwarf_Small *comp_dir = NULL; Dwarf_Unsigned line_offset = 0; Dwarf_Half attrform = 0; Dwarf_Small* bogus_bytes_ptr = 0; Dwarf_Unsigned bogus_bytes_count = 0; Dwarf_Half address_size = 0; Dwarf_Unsigned fission_offset = 0; unsigned line_version = 0; Dwarf_Debug dbg = 0; Dwarf_CU_Context cu_context = 0; Dwarf_Line_Context line_context = 0; int resattr = DW_DLV_ERROR; int lres =    DW_DLV_ERROR; int res  =    DW_DLV_ERROR; Dwarf_Small *line_ptr_actuals  = 0; Dwarf_Small *line_ptr_end = 0; Dwarf_Small *section_start = 0; if (error != NULL) { *error = NULL; } CHECK_DIE(die, DW_DLV_ERROR); cu_context = die->di_cu_context; dbg = cu_context->cc_dbg; res = _dwarf_load_section(dbg, &dbg->de_debug_line,error); if (res != DW_DLV_OK) { return res; } if (!dbg->de_debug_line.dss_size) { return (DW_DLV_NO_ENTRY); } address_size = _dwarf_get_address_size(dbg, die); resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr, error); if (resattr != DW_DLV_OK) { return resattr; } lres = dwarf_whatform(stmt_list_attr,&attrform,error); if (lres != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return lres; } if (attrform != DW_FORM_data4 && attrform != DW_FORM_data8 && attrform != DW_FORM_sec_offset ) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD); return (DW_DLV_ERROR); } lres = dwarf_global_formref(stmt_list_attr, &line_offset, error); if (lres != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return lres; } if (line_offset >= dbg->de_debug_line.dss_size) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD); return (DW_DLV_ERROR); } section_start =  dbg->de_debug_line.dss_data; { Dwarf_Unsigned fission_size = 0; int resfis = _dwarf_get_fission_addition_die(die, DW_SECT_LINE, &fission_offset,&fission_size,error); if(resfis != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return resfis; } } orig_line_ptr = section_start + line_offset + fission_offset; line_ptr = orig_line_ptr; dwarf_dealloc(dbg, stmt_list_attr, DW_DLA_ATTR); resattr = dwarf_attr(die, DW_AT_comp_dir, &comp_dir_attr, error); if (resattr == DW_DLV_ERROR) { return resattr; } if (resattr == DW_DLV_OK) { int cres = DW_DLV_ERROR; char *cdir = 0; cres = dwarf_formstring(comp_dir_attr, &cdir, error); if (cres == DW_DLV_ERROR) { return cres; } else if (cres == DW_DLV_OK) { comp_dir = (Dwarf_Small *) cdir; } } if (resattr == DW_DLV_OK) { dwarf_dealloc(dbg, comp_dir_attr, DW_DLA_ATTR); } line_context = (Dwarf_Line_Context) _dwarf_get_alloc(dbg, DW_DLA_LINE_CONTEXT, 1); if (line_context == NULL) { _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL); return (DW_DLV_ERROR); } { Dwarf_Small *newlinep = 0; int dres = _dwarf_read_line_table_header(dbg, cu_context, section_start, line_ptr, dbg->de_debug_line.dss_size, &newlinep, line_context, &bogus_bytes_ptr, &bogus_bytes_count, error, err_count_out); if (dres == DW_DLV_ERROR) { dwarf_srclines_dealloc_b(line_context); return dres; } if (dres == DW_DLV_NO_ENTRY) { dwarf_srclines_dealloc_b(line_context); return dres; } line_ptr_end = line_context->lc_line_ptr_end; line_ptr = newlinep; if (line_context->lc_actuals_table_offset > 0) { line_ptr_actuals = line_context->lc_line_prologue_start + line_context->lc_actuals_table_offset; } } line_version = line_context->lc_version_number; line_context->lc_compilation_directory = comp_dir; if (only_line_header) { dwarf_srclines_dealloc_b(line_context); return DW_DLV_OK; } do_line_print_now(dbg,line_version,comp_dir,line_context); print_include_directory_details(dbg,line_version,line_context); print_file_entry_details(dbg,line_version,line_context); print_experimental_counts(dbg, line_version,line_context); res = print_actuals_and_locals(dbg, line_context, bogus_bytes_count,bogus_bytes_ptr, orig_line_ptr, line_ptr, section_start, line_ptr_actuals, line_ptr_end, address_size, err_count_out, error); if (res  !=  DW_DLV_OK) { return res; } return DW_DLV_OK; }"
"void jswrap_spi_write( JsVar *parent,     JsVar *args      ) { NOT_USED(parent); IOEventFlags device = jsiGetDeviceFromClass(parent); spi_sender spiSend; spi_sender_data spiSendData; if (!jsspiGetSendFunction(parent, &spiSend, &spiSendData)) return; jswrap_spi_write_data spi_write_data; spi_write_data.spiSend = spiSend; spi_write_data.spiSendData = spiSendData; Pin nss_pin = PIN_UNDEFINED; JsVarInt len = jsvGetArrayLength(args); if (len > 0) { JsVar *last = jsvGetArrayItem(args, len-1);     if (jsvIsPin(last)) { nss_pin = jshGetPinFromVar(last); jsvUnLock(jsvArrayPop(args)); } jsvUnLock(last); } if (DEVICE_IS_SPI(device)) jshSPISetReceive(device, false); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, false); jsvIterateBufferCallback(args, (jsvIterateBufferCallbackFn)jswrap_spi_write_cb, &spi_write_data); if (DEVICE_IS_SPI(device)) jshSPIWait(device); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, true); }"
"libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *spdm_context, size_t request_size, const void *request, size_t *response_size, void *response) { const spdm_get_capabilities_request_t *spdm_request; spdm_capabilities_response_t *spdm_response; libspdm_return_t status; spdm_request = request; if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) { return libspdm_responder_handle_response_state( spdm_context, spdm_request->header.request_response_code,  response_size, response); } if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0, response_size, response); } if (!libspdm_check_request_version_compatibility( spdm_context, spdm_request->header.spdm_version)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_VERSION_MISMATCH, 0, response_size, response); } if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { if (request_size < sizeof(spdm_get_capabilities_request_t)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_get_capabilities_request_t); } } else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) { if (request_size < sizeof(spdm_get_capabilities_request_t) - sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_get_capabilities_request_t) - sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size); } } else { if (request_size < sizeof(spdm_message_header_t)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_message_header_t); } } if (!libspdm_check_request_flag_compatibility( spdm_request->flags, spdm_request->header.spdm_version)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { if ((spdm_request->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) || (spdm_request->data_transfer_size > spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } if (((spdm_request->flags & SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP) == 0) && (spdm_request->data_transfer_size != spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } } libspdm_reset_message_buffer_via_request_code(spdm_context, NULL, spdm_request->header.request_response_code); LIBSPDM_ASSERT(*response_size >= sizeof(spdm_capabilities_response_t)); *response_size = sizeof(spdm_capabilities_response_t); libspdm_zero_mem(response, *response_size); spdm_response = response; spdm_response->header.spdm_version = spdm_request->header.spdm_version; spdm_response->header.request_response_code = SPDM_CAPABILITIES; spdm_response->header.param1 = 0; spdm_response->header.param2 = 0; spdm_response->ct_exponent = spdm_context->local_context.capability.ct_exponent; spdm_response->flags = spdm_context->local_context.capability.flags; spdm_response->data_transfer_size = spdm_context->local_context.capability.data_transfer_size; spdm_response->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size; if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { *response_size = sizeof(spdm_capabilities_response_t); } else { *response_size = sizeof(spdm_capabilities_response_t) - sizeof(spdm_response->data_transfer_size) - sizeof(spdm_response->max_spdm_msg_size); } status = libspdm_append_message_a(spdm_context, spdm_request, request_size); if (LIBSPDM_STATUS_IS_ERROR(status)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNSPECIFIED, 0, response_size, response); } status = libspdm_append_message_a(spdm_context, spdm_response, *response_size); if (LIBSPDM_STATUS_IS_ERROR(status)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNSPECIFIED, 0, response_size, response); } if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_11) { spdm_context->connection_info.capability.ct_exponent = spdm_request->ct_exponent; spdm_context->connection_info.capability.flags = spdm_request->flags; } else { spdm_context->connection_info.capability.ct_exponent = 0; spdm_context->connection_info.capability.flags = 0; } if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { spdm_context->connection_info.capability.data_transfer_size = spdm_request->data_transfer_size; spdm_context->connection_info.capability.max_spdm_msg_size = spdm_request->max_spdm_msg_size; } else { spdm_context->connection_info.capability.data_transfer_size = 0; spdm_context->connection_info.capability.max_spdm_msg_size = 0; } libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES); return LIBSPDM_STATUS_SUCCESS; }"
"int smb2_write(struct ksmbd_work *work) { struct smb2_write_req *req; struct smb2_write_rsp *rsp; struct ksmbd_file *fp = NULL; loff_t offset; size_t length; ssize_t nbytes; char *data_buf; bool writethrough = false; int err = 0; WORK_BUFFERS(work, req, rsp); if (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) { ksmbd_debug(SMB, ""IPC pipe write request\n""); return smb2_write_pipe(work); } if (req->Channel == SMB2_CHANNEL_RDMA_V1 || req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) { unsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset); if (req->Length != 0 || req->DataOffset != 0 || ch_offset < offsetof(struct smb2_write_req, Buffer)) { err = -EINVAL; goto out; } err = smb2_set_remote_key_for_rdma(work, (struct smb2_buffer_desc_v1 *) ((char *)req + ch_offset), req->Channel, req->WriteChannelInfoOffset, req->WriteChannelInfoLength); if (err) goto out; } if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) { ksmbd_debug(SMB, ""User does not have write permission\n""); err = -EACCES; goto out; } fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId); if (!fp) { err = -ENOENT; goto out; } if (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) { pr_err(""Not permitted to write : 0x%x\n"", fp->daccess); err = -EACCES; goto out; } offset = le64_to_cpu(req->Offset); length = le32_to_cpu(req->Length); if (length > work->conn->vals->max_write_size) { ksmbd_debug(SMB, ""limiting write size to max size(%u)\n"", work->conn->vals->max_write_size); err = -EINVAL; goto out; } if (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH) writethrough = true; if (req->Channel != SMB2_CHANNEL_RDMA_V1 && req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) { if (le16_to_cpu(req->DataOffset) == offsetof(struct smb2_write_req, Buffer)) { data_buf = (char *)&req->Buffer[0]; } else { if ((u64)le16_to_cpu(req->DataOffset) + length > get_rfc1002_len(work->request_buf)) { pr_err(""invalid write data offset %u, smb_len %u\n"", le16_to_cpu(req->DataOffset), get_rfc1002_len(work->request_buf)); err = -EINVAL; goto out; } data_buf = (char *)(((char *)&req->hdr.ProtocolId) + le16_to_cpu(req->DataOffset)); } ksmbd_debug(SMB, ""flags %u\n"", le32_to_cpu(req->Flags)); if (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH) writethrough = true; ksmbd_debug(SMB, ""filename %pd, offset %lld, len %zu\n"", fp->filp->f_path.dentry, offset, length); err = ksmbd_vfs_write(work, fp, data_buf, length, &offset, writethrough, &nbytes); if (err < 0) goto out; } else { nbytes = smb2_write_rdma_channel(work, req, fp, offset, le32_to_cpu(req->RemainingBytes), writethrough); if (nbytes < 0) { err = (int)nbytes; goto out; } } rsp->StructureSize = cpu_to_le16(17); rsp->DataOffset = 0; rsp->Reserved = 0; rsp->DataLength = cpu_to_le32(nbytes); rsp->DataRemaining = 0; rsp->Reserved2 = 0; inc_rfc1001_len(work->response_buf, 16); ksmbd_fd_put(work, fp); return 0; out: if (err == -EAGAIN) rsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT; else if (err == -ENOSPC || err == -EFBIG) rsp->hdr.Status = STATUS_DISK_FULL; else if (err == -ENOENT) rsp->hdr.Status = STATUS_FILE_CLOSED; else if (err == -EACCES) rsp->hdr.Status = STATUS_ACCESS_DENIED; else if (err == -ESHARE) rsp->hdr.Status = STATUS_SHARING_VIOLATION; else if (err == -EINVAL) rsp->hdr.Status = STATUS_INVALID_PARAMETER; else rsp->hdr.Status = STATUS_INVALID_HANDLE; smb2_set_err_rsp(work); ksmbd_fd_put(work, fp); return err; }"
"static int appinfo_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg) { Bit_Chain *str_dat = dat; Dwg_AppInfo *_obj = &dwg->appinfo; Dwg_Object *obj = NULL; int error = 0; if (!dat->chain || !dat->size) return 1; #include ""appinfo.spec"" if (_obj->version && *_obj->version) { is_teigha = memcmp (_obj->version, ""T\0e\0i\0g\0h\0a\0"", 12) == 0; LOG_TRACE (""is_teigha: %s\n"", is_teigha ? ""true"" : ""false"") } return error; }"
"static Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); int newlen, argc, istart, n, rhowmany, ilen, curlen; Jsi_Value *va, *start, *howmany; Jsi_Obj *nobj, *obj = _this->d.obj; start = Jsi_ValueArrayIndex(interp, args, 0); howmany = Jsi_ValueArrayIndex(interp, args, 1); argc = Jsi_ValueGetLength(interp, args); istart = 0; ilen = (argc>=2 ? argc - 2 : 0); n = jsi_SizeOfArray(interp, obj); curlen = n; if (!start) return JSI_OK; nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); Jsi_ValueMakeArrayObject(interp, ret, nobj); Jsi_ObjSetLength(interp, nobj, 0); Jsi_Number nstart; if (Jsi_GetNumberFromValue(interp, start, &nstart) != JSI_OK) return JSI_ERROR; istart = (int)nstart; if (istart > n) return JSI_OK; if (istart < 0) istart = (n+istart); if (istart<0) istart=0; Jsi_Number nhow; rhowmany = n-istart; if (howmany) { if (Jsi_GetNumberFromValue(interp, howmany, &nhow) != JSI_OK) return JSI_ERROR; rhowmany = (int)nhow; if (rhowmany >= (n-istart)) rhowmany = n-istart; if (rhowmany < 0) rhowmany = (n-istart); if (rhowmany<0) return JSI_OK; } if (curlen < 0) { Jsi_ObjSetLength(interp, obj, curlen=0); } Jsi_ObjListifyArray(interp, obj); if (Jsi_ObjArraySizer(interp, nobj, rhowmany)<=0) return JSI_ERROR; int i, j, m; for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++) { if (!obj->arr[i]) continue; nobj->arr[m] = obj->arr[i]; obj->arr[i] = NULL; } Jsi_ObjSetLength(interp, nobj, m); for (; rhowmany && i<curlen; i++) { obj->arr[i-rhowmany] = obj->arr[i]; obj->arr[i] = NULL; } curlen -= j; newlen = curlen + argc - (argc>=2?2:1); if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) { Jsi_ValueMakeUndef(interp, ret); return Jsi_LogError(""too long""); } if (ilen>0) { for (i = curlen-1; i>=istart; i--) { obj->arr[i+ilen] = obj->arr[i]; obj->arr[i] = NULL; } for (m=istart, i = 2; i<argc; m++,i++) { va = Jsi_ValueArrayIndex(interp, args, i); if (!va) continue; obj->arr[m] = NULL; Jsi_ValueDup2(interp, obj->arr+m, va); } } Jsi_ObjSetLength(interp, obj, newlen); return JSI_OK; }"
"int xenmem_add_to_physmap_one( struct domain *d, unsigned int space, union xen_add_to_physmap_batch_extra extra, unsigned long idx, gfn_t gfn) { mfn_t mfn = INVALID_MFN; int rc; p2m_type_t t; struct page_info *page = NULL; switch ( space ) { case XENMAPSPACE_grant_table: rc = gnttab_map_frame(d, idx, gfn, &mfn); if ( rc ) return rc; t = p2m_ram_rw; break; case XENMAPSPACE_shared_info: if ( idx != 0 ) return -EINVAL; mfn = virt_to_mfn(d->shared_info); t = p2m_ram_rw; break; case XENMAPSPACE_gmfn_foreign: { struct domain *od; p2m_type_t p2mt; od = get_pg_owner(extra.foreign_domid); if ( od == NULL ) return -ESRCH; if ( od == d ) { put_pg_owner(od); return -EINVAL; } rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od); if ( rc ) { put_pg_owner(od); return rc; } page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC); if ( !page ) { put_pg_owner(od); return -EINVAL; } if ( p2m_is_ram(p2mt) ) t = (p2mt == p2m_ram_rw) ? p2m_map_foreign_rw : p2m_map_foreign_ro; else { put_page(page); put_pg_owner(od); return -EINVAL; } mfn = page_to_mfn(page); put_pg_owner(od); break; } case XENMAPSPACE_dev_mmio: if ( extra.res0 ) return -EOPNOTSUPP; rc = map_dev_mmio_region(d, gfn, 1, _mfn(idx)); return rc; default: return -ENOSYS; } rc = guest_physmap_add_entry(d, gfn, mfn, 0, t); if ( rc && space == XENMAPSPACE_gmfn_foreign ) { ASSERT(page != NULL); put_page(page); } return rc; }"
"bool MidiFile::readTrack() { char tmp[4]; read(tmp, 4); if (memcmp(tmp, ""MTrk"", 4)) { throw(QString(""bad midifile: MTrk expected"")); } int len       = readLong();             qint64 endPos = curPos + len; status        = -1; sstatus       = -1;        click         =  0; _tracks.push_back(MidiTrack()); int port = 0; _tracks.back().setOutPort(port); _tracks.back().setOutChannel(-1); for (;;) { MidiEvent event; if (!readEvent(&event)) { return true; } if ((event.type() == ME_META) && (event.metaType() == META_EOT)) { break; } _tracks.back().insert(click, event); } if (curPos != endPos) { LOGW(""bad track len: %lld != %lld, %lld bytes too much\n"", endPos, curPos, endPos - curPos); if (curPos < endPos) { LOGW(""  skip %lld\n"", endPos - curPos); skip(endPos - curPos); } } return false; }"
"void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos) { if (!s || !s->child_boxes || !child || !pos) return; if (s->internal_flags & GF_ISOM_ORDER_FREEZE) return; s32 cur_pos = gf_list_find(s->child_boxes, child); if (cur_pos < 0) return; if (cur_pos != (s32) *pos) { gf_list_del_item(s->child_boxes, child); gf_list_insert(s->child_boxes, child, *pos); } (*pos)++; }"
"static Status ValidateSavedTensors(const GraphDef& graph_def) { for (const auto& node : graph_def.node()) { const auto node_iterator = node.attr().find(""value""); if (node_iterator != node.attr().end()) { AttrValue node_value = node_iterator->second; if (node_value.has_tensor()) { const PartialTensorShape node_shape(node_value.tensor().tensor_shape()); if (node_shape.num_elements() < 0) { return errors::FailedPrecondition( ""Saved model contains node \"""", node.name(), ""\"" (op \"""", node.op(), ""\"") which initializes from a tensor with "", node_shape.num_elements(), "" elements""); } } } else if (node.op() == ""Const"") { return errors::FailedPrecondition( ""Saved model contains node \"""", node.name(), ""\"" which is a constant tensor but no value has been provided""); } } return Status::OK(); }"
"void ext4_ext_tree_init(handle_t *handle, struct inode *inode) { struct ext4_extent_header *eh; eh = ext_inode_hdr(inode); eh->eh_depth = 0; eh->eh_entries = 0; eh->eh_magic = EXT4_EXT_MAGIC; eh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0)); ext4_mark_inode_dirty(handle, inode); }"
"int ares_parse_soa_reply(const unsigned char *abuf, int alen, struct ares_soa_reply **soa_out) { const unsigned char *aptr; long len; char *qname = NULL, *rr_name = NULL; struct ares_soa_reply *soa = NULL; int qdcount, ancount, qclass; int status, i, rr_type, rr_class, rr_len; if (alen < HFIXEDSZ) return ARES_EBADRESP; qdcount = DNS_HEADER_QDCOUNT(abuf); ancount = DNS_HEADER_ANCOUNT(abuf); if (qdcount != 1) return ARES_EBADRESP; if (ancount == 0) return ARES_EBADRESP; aptr = abuf + HFIXEDSZ; status = ares__expand_name_for_response(aptr, abuf, alen, &qname, &len); if (status != ARES_SUCCESS) goto failed_stat; aptr += len; qclass = DNS_QUESTION_TYPE(aptr); if (aptr + QFIXEDSZ > abuf + alen) goto failed; aptr += QFIXEDSZ; if (qclass == T_SOA && ancount > 1) goto failed; for (i = 0; i < ancount; i++) { rr_name = NULL; status  = ares__expand_name_for_response (aptr, abuf, alen, &rr_name, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; if ( aptr + RRFIXEDSZ > abuf + alen ) { ares_free(rr_name); status = ARES_EBADRESP; goto failed_stat; } rr_type = DNS_RR_TYPE( aptr ); rr_class = DNS_RR_CLASS( aptr ); rr_len = DNS_RR_LEN( aptr ); aptr += RRFIXEDSZ; if (aptr + rr_len > abuf + alen) { ares_free(rr_name); status = ARES_EBADRESP; goto failed_stat; } if ( rr_class == C_IN && rr_type == T_SOA ) { soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY); if (!soa) { ares_free(rr_name); status = ARES_ENOMEM; goto failed_stat; } status = ares__expand_name_for_response(aptr, abuf, alen, &soa->nsname, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; status = ares__expand_name_for_response(aptr, abuf, alen, &soa->hostmaster, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; if (aptr + 5 * 4 > abuf + alen) { ares_free(rr_name); goto failed; } soa->serial = DNS__32BIT(aptr + 0 * 4); soa->refresh = DNS__32BIT(aptr + 1 * 4); soa->retry = DNS__32BIT(aptr + 2 * 4); soa->expire = DNS__32BIT(aptr + 3 * 4); soa->minttl = DNS__32BIT(aptr + 4 * 4); ares_free(qname); ares_free(rr_name); *soa_out = soa; return ARES_SUCCESS; } aptr += rr_len; ares_free(rr_name); if (aptr > abuf + alen) goto failed_stat; } status = ARES_EBADRESP; goto failed_stat; failed: status = ARES_EBADRESP; failed_stat: if (soa) ares_free_data(soa); if (qname) ares_free(qname); return status; }"
"void Compute(OpKernelContext* context) override { const Tensor* reverse_index_map_t; const Tensor* grad_values_t; OP_REQUIRES_OK(context, context->input(""reverse_index_map"", &reverse_index_map_t)); OP_REQUIRES_OK(context, context->input(""grad_values"", &grad_values_t)); const CPUDevice& d = context->eigen_device<CPUDevice>(); OP_REQUIRES( context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()), errors::InvalidArgument(""reverse_index_map must be a vector, saw: "", reverse_index_map_t->shape().DebugString())); const auto reverse_index_map = reverse_index_map_t->vec<int64>(); const auto grad_values = grad_values_t->vec<T>(); const int64 N = reverse_index_map_t->shape().dim_size(0); const int64 N_full = grad_values_t->shape().dim_size(0); Tensor* d_values_t; OP_REQUIRES_OK(context, context->allocate_output( ""d_values"", TensorShape({N}), &d_values_t)); auto d_values = d_values_t->vec<T>(); Tensor* d_default_value_t; OP_REQUIRES_OK(context, context->allocate_output(""d_default_value"", TensorShape({}), &d_default_value_t)); T& d_default_value = d_default_value_t->scalar<T>()(); d_default_value = T(); Tensor visited_t; OP_REQUIRES_OK(context, context->allocate_temp( DT_BOOL, TensorShape({N_full}), &visited_t)); auto visited = visited_t.vec<bool>(); visited.device(d) = visited.constant(false); for (int i = 0; i < N; ++i) { d_values(i) = grad_values(reverse_index_map(i)); visited(reverse_index_map(i)) = true; } for (int j = 0; j < N_full; ++j) { if (!visited(j)) { d_default_value += grad_values(j); } } }"
"static Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, argc, nsiz; Jsi_Obj *obj, *nobj; Jsi_Value *va; obj = _this->d.obj; argc = Jsi_ValueGetLength(interp, args); curlen = jsi_SizeOfArray(interp, obj); Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrMaxSize; if (nsiz<=0) nsiz = 100; if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) return Jsi_LogError(""index too large: %d"", nsiz+1);; int i, j, m; for (i = 0; i<curlen; i++) { if (!obj->arr[i]) continue; nobj->arr[i] = NULL; Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]); } m = i; for (i = 0; i < argc; i++) { va = Jsi_ValueArrayIndex(interp, args, i); if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) { int margc = Jsi_ValueGetLength(interp, va); Jsi_Obj *mobj = va->d.obj; Jsi_ObjListifyArray(interp, mobj); if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) { rc = Jsi_LogError(""index too large: %d"", curlen); goto bail; } for (j = 0; j<margc; j++, m++) { if (!mobj->arr[j]) continue; nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]); } } else { if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) { rc = Jsi_LogError(""index too large: %d"", curlen); goto bail; } nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m++, va); } } Jsi_ObjSetLength(interp, nobj, curlen); bail: Jsi_ValueMakeArrayObject(interp, ret, nobj); return rc; }"
"int decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg) { BITCODE_RL entities_start = 0, entities_end = 0; BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0; BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities; BITCODE_RS rs2; Dwg_Object *obj = NULL; int tbl_id; int error = 0; int num_sections = 5; loglevel = dat->opts & DWG_OPTS_LOGLEVEL; #ifndef USE_WRITE fprintf(stderr, ""Cannot create pre-R13 documents with --disable-write\n""); return DWG_ERR_INTERNALERROR; #else { int i; Dwg_Header *_obj = (Dwg_Header *)&dwg->header; Bit_Chain *hdl_dat = dat; dat->byte = 0x06; #include ""header.spec"" } LOG_TRACE (""@0x%lx\n"", dat->byte);  error |= dwg_add_Document (dwg, 0); if (dwg->header.numheader_vars > 158)     num_sections += 3; if (dwg->header.numheader_vars > 160)     num_sections += 2; dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section), num_sections + 2); if (!dwg->header.section) { LOG_ERROR (""Out of memory""); return DWG_ERR_OUTOFMEM; } dwg->header.numsections = num_sections; PRE (R_2_0b) { bit_read_RC (dat);     LOG_TRACE (""zero[6]: 0 [RC 0]\n""); } SINCE (R_2_0b) { entities_start = bit_read_RL (dat); LOG_TRACE (""entities_start: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", entities_start, entities_start); entities_end = bit_read_RL (dat); LOG_TRACE (""entities_end: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", entities_end, entities_end); blocks_start = bit_read_RL (dat); LOG_TRACE (""blocks_start: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", blocks_start, blocks_start); blocks_size = bit_read_RL (dat); if (blocks_size >= 0x40000000) { LOG_TRACE (""blocks_size: 0x40000000 | "" FORMAT_RL "" [RLx]\n"", blocks_size & 0x3fffffff); } else { LOG_TRACE (""blocks_size: "" FORMAT_RL "" [RL]\n"", blocks_size); } blocks_end = bit_read_RL (dat); LOG_TRACE (""blocks_end: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", blocks_end, blocks_end); blocks_max = bit_read_RL (dat);     LOG_TRACE (""blocks_max: "" FORMAT_RLx "" [RLx]\n"", blocks_max); tbl_id = 0; dwg->header.section[0].number = 0; dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11; strcpy (dwg->header.section[0].name, ""HEADER""); LOG_INFO (""==========================================\n"") if (decode_preR13_section_hdr (""BLOCK"", SECTION_BLOCK, dat, dwg) || decode_preR13_section_hdr (""LAYER"", SECTION_LAYER, dat, dwg) || decode_preR13_section_hdr (""STYLE"", SECTION_STYLE, dat, dwg) || decode_preR13_section_hdr (""LTYPE"", SECTION_LTYPE, dat, dwg) || decode_preR13_section_hdr (""VIEW"", SECTION_VIEW, dat, dwg)) return DWG_ERR_INVALIDDWG; } LOG_TRACE (""@0x%lx\n"", dat->byte);   if (dat->size < 0x1f0)     { LOG_ERROR (""DWG too small %zu"", (size_t)dat->size) return DWG_ERR_INVALIDDWG; } LOG_INFO (""==========================================\n"") error |= decode_preR13_header_variables (dat, dwg); LOG_TRACE (""@0x%lx\n"", dat->byte); if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte + 2 >= dat->size) { LOG_ERROR (""post HEADER overflow"") return error | DWG_ERR_CRITICAL; } SINCE (R_11) { BITCODE_RS crc, crcc; BITCODE_TF r11_sentinel; crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte);     crc = bit_read_RS (dat); LOG_TRACE (""crc: %04X [RSx] from 0-0x%lx\n"", crc, dat->byte - 2); if (crc != crcc) { LOG_ERROR (""Header CRC mismatch %04X <=> %04X"", crc, crcc); error |= DWG_ERR_WRONGCRC; } r11_sentinel = bit_read_TF (dat, 16); if (!r11_sentinel) return error | DWG_ERR_INVALIDDWG; LOG_TRACE (""r11_sentinel: ""); LOG_TRACE_TF (r11_sentinel, 16)     if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16)) { LOG_ERROR (""DWG_SENTINEL_R11_HEADER_END mismatch""); error |= DWG_ERR_WRONGCRC; } free (r11_sentinel); } PRE (R_10) num_entities = dwg->header_vars.numentities; else num_entities = 0; PRE (R_2_0b) { entities_start = dat->byte; entities_end = dwg->header_vars.dwg_size; } if (dwg->header.numheader_vars > 158)     { dat->byte = 0x3ef; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""UCS"", SECTION_UCS, dat, dwg); dat->byte = 0x500; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""VPORT"", SECTION_VPORT, dat, dwg); dat->byte = 0x512; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""APPID"", SECTION_APPID, dat, dwg); dat->byte = entities_start; } if (dwg->header.numheader_vars > 160)     { dat->byte = 0x522; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""DIMSTYLE"", SECTION_DIMSTYLE, dat, dwg); dat->byte = 0x69f; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""VX"", SECTION_VX, dat, dwg); dat->byte = entities_start; } if (dat->byte != entities_start) { LOG_WARN (""@0x%lx => entities_start 0x%x"", dat->byte, entities_start); if (dat->byte < entities_start) { _DEBUG_HERE (dat->byte - entities_start) } dat->byte = entities_start; } error |= decode_preR13_entities (entities_start, entities_end, num_entities, entities_end - entities_start, 0, dat, dwg); if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte != entities_end) { LOG_WARN (""@0x%lx => entities_end 0x%x"", dat->byte, entities_end); dat->byte = entities_end; } PRE (R_2_0b) { return error; } LOG_INFO (""==========================================\n"") if (!dwg->next_hdl) dwg_set_next_hdl (dwg, 0x22); error |= decode_preR13_section (SECTION_BLOCK, dat, dwg); error |= decode_preR13_section (SECTION_LAYER, dat, dwg); error |= decode_preR13_section (SECTION_STYLE, dat, dwg); error |= decode_preR13_section (SECTION_LTYPE, dat, dwg); error |= decode_preR13_section (SECTION_VIEW, dat, dwg); #if 1 if (num_sections > 5)     { error |= decode_preR13_section (SECTION_UCS, dat, dwg); error |= decode_preR13_section (SECTION_VPORT, dat, dwg); error |= decode_preR13_section (SECTION_APPID, dat, dwg); } if (num_sections > 8)     { error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg); error |= decode_preR13_section (SECTION_VX, dat, dwg); } #endif if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte != blocks_start) { BITCODE_TF unknown; int len = blocks_start - dat->byte; LOG_WARN (""\n@0x%lx => blocks_start 0x%x"", dat->byte, blocks_start); if (dat->byte < blocks_start) { unknown = bit_read_TF (dat, len); LOG_TRACE (""unknown (%d):"", len); LOG_TRACE_TF (unknown, len); free (unknown); } dat->byte = blocks_start; } num_entities = 0; VERSION (R_11) blocks_end -= 32;   error |= decode_preR13_entities (blocks_start, blocks_end, num_entities, blocks_size & 0x3FFFFFFF, blocks_max, dat, dwg); if (error >= DWG_ERR_CRITICAL) return error; PRE (R_11) { return error; } LOG_TRACE (""AUXHEADER: @0x%lx\n"", dat->byte); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); LOG_TRACE (""?1long: 0x%x\n"", rl1); LOG_TRACE (""@0x%lx: 4 block ptrs chk\n"", dat->byte); if ((rl1 = bit_read_RL (dat)) != entities_start) { LOG_WARN (""entities_start %x/%x"", rl1, entities_start); } if ((rl1 = bit_read_RL (dat)) != entities_end) { LOG_WARN (""entities_end %x/%x"", rl1, entities_end); } if ((rl1 = bit_read_RL (dat)) != blocks_start) { LOG_WARN (""blocks_start %x/%x"", rl1, blocks_start); } if ((rl1 = bit_read_RL (dat)) != blocks_end) { LOG_WARN (""blocks_end %x/%x"", rl1, blocks_end); } LOG_TRACE (""@0x%lx\n"", dat->byte); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x\n"", rl1, rl2); rl1 = bit_read_RL (dat); LOG_TRACE (""?1long: 0x%x\n"", rl1); rl1 = blocks_end + 36 + 4 * 4 + 12;   DEBUG_HERE UNKNOWN_UNTIL (rl1); LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_chk (SECTION_BLOCK, dat, dwg); decode_preR13_section_chk (SECTION_LAYER, dat, dwg); decode_preR13_section_chk (SECTION_STYLE, dat, dwg); decode_preR13_section_chk (SECTION_LTYPE, dat, dwg); decode_preR13_section_chk (SECTION_VIEW, dat, dwg); if (num_sections > 5)     { decode_preR13_section_chk (SECTION_UCS, dat, dwg); decode_preR13_section_chk (SECTION_VPORT, dat, dwg); decode_preR13_section_chk (SECTION_APPID, dat, dwg); decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg); decode_preR13_section_chk (SECTION_VX, dat, dwg); } rl1 = bit_read_RL (dat); LOG_TRACE (""long 0x%x\n"", rl1);   if (dat->byte < dat->size) { int len = dat->size - dat->byte; BITCODE_TF unknown = bit_read_TF (dat, len); LOG_TRACE (""unknown (%d):"", len); LOG_TRACE_TF (unknown, len); free (unknown); } if (dwg->dirty_refs) dwg_resolve_objectrefs_silent (dwg); return 0; #endif }"
"static int nfqnl_mangle(void *data, int data_len, struct nf_queue_entry *e, int diff) { struct sk_buff *nskb; if (diff < 0) { if (pskb_trim(e->skb, data_len)) return -ENOMEM; } else if (diff > 0) { if (data_len > 0xFFFF) return -EINVAL; if (diff > skb_tailroom(e->skb)) { nskb = skb_copy_expand(e->skb, skb_headroom(e->skb), diff, GFP_ATOMIC); if (!nskb) return -ENOMEM; kfree_skb(e->skb); e->skb = nskb; } skb_put(e->skb, diff); } if (skb_ensure_writable(e->skb, data_len)) return -ENOMEM; skb_copy_to_linear_data(e->skb, data, data_len); e->skb->ip_summed = CHECKSUM_NONE; return 0; }"
"Datum tsl_subscription_exec(PG_FUNCTION_ARGS) { Oid save_userid; int save_sec_context; const char *subscription_cmd = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0)); int res; List *parsetree_list; ListCell *parsetree_item; if (!subscription_cmd) PG_RETURN_VOID(); if (!superuser() && !has_rolreplication(GetUserId())) ereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE), (errmsg(""must be superuser or replication role to use this function"")))); GetUserIdAndSecContext(&save_userid, &save_sec_context); SetUserIdAndSecContext(BOOTSTRAP_SUPERUSERID, save_sec_context | SECURITY_LOCAL_USERID_CHANGE); parsetree_list = pg_parse_query(subscription_cmd); foreach (parsetree_item, parsetree_list) { RawStmt *parsetree = lfirst_node(RawStmt, parsetree_item); switch (nodeTag(parsetree->stmt)) { case T_CreateSubscriptionStmt: break; case T_AlterSubscriptionStmt: break; case T_DropSubscriptionStmt: break; default: ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(""this function only accepts SUBSCRIPTION commands""))); } } if (SPI_connect() != SPI_OK_CONNECT) elog(ERROR, ""could not connect to SPI""); res = SPI_execute(subscription_cmd, false , 0 ); if (res < 0) ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""error in subscription cmd \""%s\"""", subscription_cmd)))); if ((res = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res)); SetUserIdAndSecContext(save_userid, save_sec_context); PG_RETURN_VOID(); }"
"static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data) { int len; ssize_t size; char buf[OGS_ADDRSTRLEN]; sgwu_sess_t *sess = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_gtp_header_t *gtp_h = NULL; ogs_pfcp_user_plane_report_t report; uint32_t teid; uint8_t qfi; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recv() failed""); goto cleanup; } ogs_pkbuf_trim(pkbuf, size); ogs_assert(pkbuf); ogs_assert(pkbuf->len); gtp_h = (ogs_gtp_header_t *)pkbuf->data; if (gtp_h->version != OGS_GTP_VERSION_1) { ogs_error(""[DROP] Invalid GTPU version [%d]"", gtp_h->version); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); goto cleanup; } if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) { ogs_pkbuf_t *echo_rsp; ogs_debug(""[RECV] Echo Request from [%s]"", OGS_ADDR(&from, buf)); echo_rsp = ogs_gtp_handle_echo_req(pkbuf); ogs_expect(echo_rsp); if (echo_rsp) { ssize_t sent; ogs_debug(""[SEND] Echo Response to [%s]"", OGS_ADDR(&from, buf)); sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from); if (sent < 0 || sent != echo_rsp->len) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(echo_rsp); } goto cleanup; } teid = be32toh(gtp_h->teid); ogs_debug(""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]"", gtp_h->type, OGS_ADDR(&from, buf), teid); qfi = 0; if (gtp_h->flags & OGS_GTPU_FLAGS_E) { ogs_gtp_extension_header_t *extension_header = (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN); ogs_assert(extension_header); if (extension_header->type == OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) { if (extension_header->pdu_type == OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) { ogs_debug(""   QFI [0x%x]"", extension_header->qos_flow_identifier); qfi = extension_header->qos_flow_identifier; } } } len = ogs_gtpu_header_len(pkbuf); if (len < 0) { ogs_error(""[DROP] Cannot decode GTPU packet""); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); goto cleanup; } ogs_assert(ogs_pkbuf_pull(pkbuf, len)); if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) { } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) { ogs_pfcp_far_t *far = NULL; far = ogs_pfcp_far_find_by_error_indication(pkbuf); if (far) { ogs_assert(true == ogs_pfcp_up_handle_error_indication(far, &report)); if (report.type.error_indication_report) { ogs_assert(far->sess); sess = SGWU_SESS(far->sess); ogs_assert(sess); ogs_assert(OGS_OK == sgwu_pfcp_send_session_report_request(sess, &report)); } } else { ogs_error(""[DROP] Cannot find FAR by Error-Indication""); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); } } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) { struct ip *ip_h = NULL; ogs_pfcp_object_t *pfcp_object = NULL; ogs_pfcp_sess_t *pfcp_sess = NULL; ogs_pfcp_pdr_t *pdr = NULL; ip_h = (struct ip *)pkbuf->data; ogs_assert(ip_h); pfcp_object = ogs_pfcp_object_find_by_teid(teid); if (!pfcp_object) { goto cleanup; } switch(pfcp_object->type) { case OGS_PFCP_OBJ_PDR_TYPE: pdr = (ogs_pfcp_pdr_t *)pfcp_object; ogs_assert(pdr); break; case OGS_PFCP_OBJ_SESS_TYPE: pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object; ogs_assert(pfcp_sess); ogs_list_for_each(&pfcp_sess->pdr_list, pdr) { if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS && pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION) continue; if (teid != pdr->f_teid.teid) continue; if (qfi && pdr->qfi != qfi) continue; if (ogs_list_first(&pdr->rule_list) && ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL) continue; break; } if (!pdr) { goto cleanup; } break; default: ogs_fatal(""Unknown type [%d]"", pfcp_object->type); ogs_assert_if_reached(); } ogs_assert(pdr); ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report)); if (report.type.downlink_data_report) { ogs_assert(pdr->sess); ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE); sess = SGWU_SESS(pdr->sess); ogs_assert(sess); report.downlink_data.pdr_id = pdr->id; report.downlink_data.qfi = qfi;  ogs_assert(OGS_OK == sgwu_pfcp_send_session_report_request(sess, &report)); } } else { ogs_error(""[DROP] Invalid GTPU Type [%d]"", gtp_h->type); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); } cleanup: ogs_pkbuf_free(pkbuf); }"
"u32 gf_avc_reformat_sei(u8 *buffer, u32 nal_size, Bool isobmf_rewrite, AVCState *avc) { u32 ptype, psize, hdr, var; u32 start; GF_BitStream *bs; GF_BitStream *bs_dest = NULL; u8 nhdr; Bool sei_removed = GF_FALSE; char store; hdr = buffer[0]; if ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0; if (isobmf_rewrite) bs_dest = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); bs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ); gf_bs_enable_emulation_byte_removal(bs, GF_TRUE); nhdr = gf_bs_read_int(bs, 8); if (bs_dest) gf_bs_write_int(bs_dest, nhdr, 8); while (gf_bs_available(bs)) { Bool do_copy; ptype = 0; while (1) { u8 v = gf_bs_read_int(bs, 8); ptype += v; if (v != 0xFF) break; } psize = 0; while (1) { u8 v = gf_bs_read_int(bs, 8); psize += v; if (v != 0xFF) break; } start = (u32)gf_bs_get_position(bs); do_copy = 1; if (start + psize >= nal_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] SEI user message type %d size error (%d but %d remain), keeping full SEI untouched\n"", ptype, psize, nal_size - start)); if (bs_dest) gf_bs_del(bs_dest); gf_bs_del(bs); return nal_size; } switch (ptype) { case 3:  case 10:  case 11:  case 12:  do_copy = 0; sei_removed = GF_TRUE; break; case 5:  store = buffer[start + psize]; buffer[start + psize] = 0; GF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (""[avc-h264] SEI user message %s\n"", buffer + start + 16)); buffer[start + psize] = store; break; case 6:  avc_parse_recovery_point_sei(bs, avc); break; case 1:  avc_parse_pic_timing_sei(bs, avc); break; case 0:  case 2:  case 4:  case 7:  case 8:  case 9:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  default:  break; } if (do_copy && bs_dest) { var = ptype; while (var >= 255) { gf_bs_write_int(bs_dest, 0xFF, 8); var -= 255; } gf_bs_write_int(bs_dest, var, 8); var = psize; while (var >= 255) { gf_bs_write_int(bs_dest, 0xFF, 8); var -= 255; } gf_bs_write_int(bs_dest, var, 8); gf_bs_seek(bs, start); var = psize; while (var) { gf_bs_write_u8(bs_dest, gf_bs_read_u8(bs)); var--; } } else { gf_bs_seek(bs, start); while (psize) { gf_bs_read_u8(bs); psize--; } } if (gf_bs_available(bs) <= 2) { var = gf_bs_read_int(bs, 8); if (var != 0x80) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] SEI user message has less than 2 bytes remaining but no end of sei found\n"")); } if (bs_dest) gf_bs_write_int(bs_dest, 0x80, 8); break; } } gf_bs_del(bs); if (bs_dest && sei_removed) { u8 *dst_no_epb = NULL; u32 dst_no_epb_size = 0; gf_bs_get_content(bs_dest, &dst_no_epb, &dst_no_epb_size); if (dst_no_epb) { u32 nb_bytes_add = gf_media_nalu_emulation_bytes_add_count(dst_no_epb, dst_no_epb_size); if (dst_no_epb_size + nb_bytes_add <= nal_size) nal_size = gf_media_nalu_add_emulation_bytes(buffer, dst_no_epb, dst_no_epb_size); gf_free(dst_no_epb); } } if (bs_dest) gf_bs_del(bs_dest); return nal_size; }"
"void Compute(OpKernelContext* context) override { const Tensor& x = context->input(0); const Tensor& y = context->input(1); const float min_x = context->input(2).flat<float>()(0); const float max_x = context->input(3).flat<float>()(0); const float min_y = context->input(4).flat<float>()(0); const float max_y = context->input(5).flat<float>()(0); BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape())); if (!bcast.IsValid()) { context->SetStatus(errors::InvalidArgument( ""Incompatible shapes: "", x.shape().DebugString(), "" vs. "", y.shape().DebugString())); return; } Tensor* z; OP_REQUIRES_OK(context, context->allocate_output( 0, BCast::ToShape(bcast.output_shape()), &z)); OP_REQUIRES(context, (max_x > min_x), errors::InvalidArgument(""max_x must be larger than min_x."")); OP_REQUIRES(context, (max_y > min_y), errors::InvalidArgument(""max_y must be larger than min_y."")); const T* x_data = x.flat<T>().data(); const T* y_data = y.flat<T>().data(); Toutput* z_data = z->flat<Toutput>().data(); const float smallest_min = std::min(min_x, min_y); const float largest_max = std::max(max_x, max_y); const float biggest_range = std::max(std::abs(smallest_min), std::abs(largest_max)); const float output_range = (biggest_range * (1 << 14)); const float min_z_value = -output_range; const float max_z_value = output_range; const int ndims = bcast.x_reshape().size(); if (ndims <= 1) { if (x.NumElements() == 1) { ScalarAddition<T, Toutput>(context, y_data, min_y, max_y, y.NumElements(), x_data[0], min_x, max_x, min_z_value, max_z_value, z_data); } else if (y.NumElements() == 1) { ScalarAddition<T, Toutput>(context, x_data, min_x, max_x, x.NumElements(), y_data[0], min_y, max_y, min_z_value, max_z_value, z_data); } else { VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y, max_y, x.NumElements(), min_z_value, max_z_value, z_data); } } else if (ndims == 2) { const T* vector_data; int64_t vector_num_elements; float vector_min; float vector_max; const T* tensor_data; int64_t tensor_num_elements; float tensor_min; float tensor_max; if (x.NumElements() < y.NumElements()) { vector_data = x_data; vector_num_elements = x.NumElements(); vector_min = min_x; vector_max = max_x; tensor_data = y_data; tensor_num_elements = y.NumElements(); tensor_min = min_y; tensor_max = max_y; } else { vector_data = y_data; vector_num_elements = y.NumElements(); vector_min = min_y; vector_max = max_y; tensor_data = x_data; tensor_num_elements = x.NumElements(); tensor_min = min_x; tensor_max = max_x; } OP_REQUIRES(context, vector_num_elements > 0, errors::InvalidArgument(""Must have some elements to add"")); VectorTensorAddition<T, Toutput>( vector_data, vector_min, vector_max, vector_num_elements, tensor_data, tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value, z_data); } else { LOG(INFO) << ""ndims="" << ndims; LOG(INFO) << ""bcast.x_reshape()="" << TensorShape(bcast.x_reshape()).DebugString(); LOG(INFO) << ""bcast.y_reshape()="" << TensorShape(bcast.y_reshape()).DebugString(); LOG(INFO) << ""bcast.x_bcast()="" << TensorShape(bcast.x_bcast()).DebugString(); LOG(INFO) << ""bcast.y_bcast()="" << TensorShape(bcast.y_bcast()).DebugString(); context->SetStatus(errors::Unimplemented( ""Broadcast between "", context->input(0).shape().DebugString(), "" and "", context->input(1).shape().DebugString(), "" is not supported yet."")); return; } Tensor* z_min = nullptr; OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min)); z_min->flat<float>()(0) = min_z_value; Tensor* z_max = nullptr; OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max)); z_max->flat<float>()(0) = max_z_value; }"
"void flatpak_context_merge (FlatpakContext *context, FlatpakContext *other) { GHashTableIter iter; gpointer key, value; context->shares &= ~other->shares_valid; context->shares |= other->shares; context->shares_valid |= other->shares_valid; context->sockets &= ~other->sockets_valid; context->sockets |= other->sockets; context->sockets_valid |= other->sockets_valid; context->devices &= ~other->devices_valid; context->devices |= other->devices; context->devices_valid |= other->devices_valid; context->features &= ~other->features_valid; context->features |= other->features; context->features_valid |= other->features_valid; g_hash_table_iter_init (&iter, other->env_vars); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value)); g_hash_table_iter_init (&iter, other->persistent); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->persistent, g_strdup (key), value); g_hash_table_iter_init (&iter, other->filesystems); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->filesystems, g_strdup (key), value); g_hash_table_iter_init (&iter, other->session_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->session_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->system_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->system_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->system_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->system_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->generic_policy); while (g_hash_table_iter_next (&iter, &key, &value)) { const char **policy_values = (const char **) value; int i; for (i = 0; policy_values[i] != NULL; i++) flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]); } }"
"inline bool IsAligned(const void *ptr) { return IsAlignedOn(ptr, GetAlignmentOf<T*>()); }"
"void JBIG2Stream::readTextRegionSeg(unsigned int segNum, bool imm, bool lossless, unsigned int length, unsigned int *refSegs, unsigned int nRefSegs) { std::unique_ptr<JBIG2Bitmap> bitmap; JBIG2HuffmanTable runLengthTab[36]; JBIG2HuffmanTable *symCodeTab = nullptr; const JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable; const JBIG2HuffmanTable *huffRDWTable, *huffRDHTable; const JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable; JBIG2Segment *seg; std::vector<JBIG2Segment *> codeTables; JBIG2SymbolDict *symbolDict; JBIG2Bitmap **syms; unsigned int w, h, x, y, segInfoFlags, extCombOp; unsigned int flags, huff, refine, logStrips, refCorner, transposed; unsigned int combOp, defPixel, templ; int sOffset; unsigned int huffFlags, huffFS, huffDS, huffDT; unsigned int huffRDW, huffRDH, huffRDX, huffRDY, huffRSize; unsigned int numInstances, numSyms, symCodeLen; int atx[2], aty[2]; unsigned int i, k, kk; int j = 0; if (!readULong(&w) || !readULong(&h) || !readULong(&x) || !readULong(&y) || !readUByte(&segInfoFlags)) { goto eofError; } extCombOp = segInfoFlags & 7; if (!readUWord(&flags)) { goto eofError; } huff = flags & 1; refine = (flags >> 1) & 1; logStrips = (flags >> 2) & 3; refCorner = (flags >> 4) & 3; transposed = (flags >> 6) & 1; combOp = (flags >> 7) & 3; defPixel = (flags >> 9) & 1; sOffset = (flags >> 10) & 0x1f; if (sOffset & 0x10) { sOffset |= -1 - 0x0f; } templ = (flags >> 15) & 1; huffFS = huffDS = huffDT = 0;     huffRDW = huffRDH = huffRDX = huffRDY = huffRSize = 0;     if (huff) { if (!readUWord(&huffFlags)) { goto eofError; } huffFS = huffFlags & 3; huffDS = (huffFlags >> 2) & 3; huffDT = (huffFlags >> 4) & 3; huffRDW = (huffFlags >> 6) & 3; huffRDH = (huffFlags >> 8) & 3; huffRDX = (huffFlags >> 10) & 3; huffRDY = (huffFlags >> 12) & 3; huffRSize = (huffFlags >> 14) & 1; } if (refine && templ == 0) { if (!readByte(&atx[0]) || !readByte(&aty[0]) || !readByte(&atx[1]) || !readByte(&aty[1])) { goto eofError; } } if (!readULong(&numInstances)) { goto eofError; } numSyms = 0; for (i = 0; i < nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg->getType() == jbig2SegSymbolDict) { numSyms += ((JBIG2SymbolDict *)seg)->getSize(); } else if (seg->getType() == jbig2SegCodeTable) { codeTables.push_back(seg); } } else { error(errSyntaxError, curStr->getPos(), ""Invalid segment reference in JBIG2 text region""); return; } } i = numSyms; if (i <= 1) { symCodeLen = huff ? 1 : 0; } else { --i; symCodeLen = 0; while (i > 0) { ++symCodeLen; i >>= 1; } } syms = (JBIG2Bitmap **)gmallocn_checkoverflow(numSyms, sizeof(JBIG2Bitmap *)); if (numSyms > 0 && !syms) { return; } kk = 0; for (i = 0; i < nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg->getType() == jbig2SegSymbolDict) { symbolDict = (JBIG2SymbolDict *)seg; for (k = 0; k < symbolDict->getSize(); ++k) { syms[kk++] = symbolDict->getBitmap(k); } } } } huffFSTable = huffDSTable = huffDTTable = nullptr;     huffRDWTable = huffRDHTable = nullptr;     huffRDXTable = huffRDYTable = huffRSizeTable = nullptr;     i = 0; if (huff) { if (huffFS == 0) { huffFSTable = huffTableF; } else if (huffFS == 1) { huffFSTable = huffTableG; } else { if (i >= codeTables.size()) { goto codeTableError; } huffFSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffDS == 0) { huffDSTable = huffTableH; } else if (huffDS == 1) { huffDSTable = huffTableI; } else if (huffDS == 2) { huffDSTable = huffTableJ; } else { if (i >= codeTables.size()) { goto codeTableError; } huffDSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffDT == 0) { huffDTTable = huffTableK; } else if (huffDT == 1) { huffDTTable = huffTableL; } else if (huffDT == 2) { huffDTTable = huffTableM; } else { if (i >= codeTables.size()) { goto codeTableError; } huffDTTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDW == 0) { huffRDWTable = huffTableN; } else if (huffRDW == 1) { huffRDWTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDWTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDH == 0) { huffRDHTable = huffTableN; } else if (huffRDH == 1) { huffRDHTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDHTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDX == 0) { huffRDXTable = huffTableN; } else if (huffRDX == 1) { huffRDXTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDXTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDY == 0) { huffRDYTable = huffTableN; } else if (huffRDY == 1) { huffRDYTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDYTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRSize == 0) { huffRSizeTable = huffTableA; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRSizeTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } } if (huff) { huffDecoder->reset(); for (i = 0; i < 32; ++i) { runLengthTab[i].val = i; runLengthTab[i].prefixLen = huffDecoder->readBits(4); runLengthTab[i].rangeLen = 0; } runLengthTab[32].val = 0x103; runLengthTab[32].prefixLen = huffDecoder->readBits(4); runLengthTab[32].rangeLen = 2; runLengthTab[33].val = 0x203; runLengthTab[33].prefixLen = huffDecoder->readBits(4); runLengthTab[33].rangeLen = 3; runLengthTab[34].val = 0x20b; runLengthTab[34].prefixLen = huffDecoder->readBits(4); runLengthTab[34].rangeLen = 7; runLengthTab[35].prefixLen = 0; runLengthTab[35].rangeLen = jbig2HuffmanEOT; if (!JBIG2HuffmanDecoder::buildTable(runLengthTab, 35)) { huff = false; } } if (huff) { symCodeTab = (JBIG2HuffmanTable *)gmallocn_checkoverflow(numSyms + 1, sizeof(JBIG2HuffmanTable)); if (!symCodeTab) { gfree(syms); return; } for (i = 0; i < numSyms; ++i) { symCodeTab[i].val = i; symCodeTab[i].rangeLen = 0; } i = 0; while (i < numSyms) { huffDecoder->decodeInt(&j, runLengthTab); if (j > 0x200) { for (j -= 0x200; j && i < numSyms; --j) { symCodeTab[i++].prefixLen = 0; } } else if (j > 0x100) { if (unlikely(i == 0)) { symCodeTab[i].prefixLen = 0; ++i; } for (j -= 0x100; j && i < numSyms; --j) { symCodeTab[i].prefixLen = symCodeTab[i - 1].prefixLen; ++i; } } else { symCodeTab[i++].prefixLen = j; } } symCodeTab[numSyms].prefixLen = 0; symCodeTab[numSyms].rangeLen = jbig2HuffmanEOT; if (!JBIG2HuffmanDecoder::buildTable(symCodeTab, numSyms)) { huff = false; gfree(symCodeTab); symCodeTab = nullptr; } huffDecoder->reset(); } if (!huff) { if (!resetIntStats(symCodeLen)) { gfree(syms); return; } arithDecoder->start(); } if (refine) { resetRefinementStats(templ, nullptr); } bitmap = readTextRegion(huff, refine, w, h, numInstances, logStrips, numSyms, symCodeTab, symCodeLen, syms, defPixel, combOp, transposed, refCorner, sOffset, huffFSTable, huffDSTable, huffDTTable, huffRDWTable, huffRDHTable, huffRDXTable, huffRDYTable, huffRSizeTable, templ, atx, aty); gfree(syms); if (bitmap) { if (imm) { if (pageH == 0xffffffff && y + h > curPageH) { pageBitmap->expand(y + h, pageDefPixel); } if (pageBitmap->isOk()) { pageBitmap->combine(bitmap.get(), x, y, extCombOp); } } else { bitmap->setSegNum(segNum); segments.push_back(std::move(bitmap)); } } if (huff) { gfree(symCodeTab); } return; codeTableError: error(errSyntaxError, curStr->getPos(), ""Missing code table in JBIG2 text region""); gfree(syms); return; eofError: error(errSyntaxError, curStr->getPos(), ""Unexpected EOF in JBIG2 stream""); return; }"
"static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName) { assert(dstFileName != NULL); if (!strcmp (dstFileName, stdoutmark)) { DISPLAYLEVEL(4,""Using stdout for output \n""); SET_BINARY_MODE(stdout); if (prefs->sparseFileSupport == 1) { prefs->sparseFileSupport = 0; DISPLAYLEVEL(4, ""Sparse File Support is automatically disabled on stdout ; try --sparse \n""); } return stdout; } if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) { DISPLAYLEVEL(1, ""zstd: Refusing to open an output file which will overwrite the input file \n""); return NULL; } if (prefs->sparseFileSupport == 1) { prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT; } if (UTIL_isRegularFile(dstFileName)) { FILE* const fCheck = fopen( dstFileName, ""rb"" ); if (!strcmp(dstFileName, nulmark)) { EXM_THROW(40, ""%s is unexpectedly categorized as a regular file"", dstFileName); } if (fCheck != NULL) {   fclose(fCheck); if (!prefs->overwrite) { if (g_display_prefs.displayLevel <= 1) { DISPLAY(""zstd: %s already exists; not overwritten  \n"", dstFileName); return NULL; } DISPLAY(""zstd: %s already exists; overwrite (y/N) ? "", dstFileName); {   int ch = getchar(); if ((ch!='Y') && (ch!='y')) { DISPLAY(""    not overwritten  \n""); return NULL; } while ((ch!=EOF) && (ch!='\n')) ch = getchar(); }   } FIO_remove(dstFileName); }   } {   FILE* const f = fopen( dstFileName, ""wb"" ); if (f == NULL) DISPLAYLEVEL(1, ""zstd: %s: %s\n"", dstFileName, strerror(errno)); return f; } }"
"int map_vcpu_info(struct vcpu *v, unsigned long gfn, unsigned offset) { struct domain *d = v->domain; void *mapping; vcpu_info_t *new_info; struct page_info *page; if ( offset > (PAGE_SIZE - sizeof(vcpu_info_t)) ) return -EINVAL; if ( !mfn_eq(v->vcpu_info_mfn, INVALID_MFN) ) return -EINVAL; if ( (v != current) && !(v->pause_flags & VPF_down) ) return -EINVAL; page = get_page_from_gfn(d, gfn, NULL, P2M_ALLOC); if ( !page ) return -EINVAL; if ( !get_page_type(page, PGT_writable_page) ) { put_page(page); return -EINVAL; } mapping = __map_domain_page_global(page); if ( mapping == NULL ) { put_page_and_type(page); return -ENOMEM; } new_info = (vcpu_info_t *)(mapping + offset); if ( v->vcpu_info == &dummy_vcpu_info ) { memset(new_info, 0, sizeof(*new_info)); #ifdef XEN_HAVE_PV_UPCALL_MASK __vcpu_info(v, new_info, evtchn_upcall_mask) = 1; #endif } else { memcpy(new_info, v->vcpu_info, sizeof(*new_info)); } v->vcpu_info = new_info; v->vcpu_info_mfn = page_to_mfn(page); smp_wmb(); #ifdef CONFIG_COMPAT if ( !has_32bit_shinfo(d) ) write_atomic(&new_info->native.evtchn_pending_sel, ~0); else #endif write_atomic(&vcpu_info(v, evtchn_pending_sel), ~0); vcpu_mark_events_pending(v); return 0; }"
"void ActivityListModel::triggerDefaultAction(int activityIndex) { if (activityIndex < 0 || activityIndex >= _finalList.size()) { qCWarning(lcActivity) << ""Couldn't trigger default action at index"" << activityIndex << ""/ final list size:"" << _finalList.size(); return; } const auto modelIndex = index(activityIndex); const auto path = data(modelIndex, PathRole).toUrl(); const auto activity = _finalList.at(activityIndex); if (activity._status == SyncFileItem::Conflict) { Q_ASSERT(!activity._file.isEmpty()); Q_ASSERT(!activity._folder.isEmpty()); Q_ASSERT(Utility::isConflictFile(activity._file)); const auto folder = FolderMan::instance()->folder(activity._folder); const auto conflictedRelativePath = activity._file; const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8()); const auto dir = QDir(folder->path()); const auto conflictedPath = dir.filePath(conflictedRelativePath); const auto basePath = dir.filePath(baseRelativePath); const auto baseName = QFileInfo(basePath).fileName(); if (!_currentConflictDialog.isNull()) { _currentConflictDialog->close(); } _currentConflictDialog = new ConflictDialog; _currentConflictDialog->setBaseFilename(baseName); _currentConflictDialog->setLocalVersionFilename(conflictedPath); _currentConflictDialog->setRemoteVersionFilename(basePath); _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose); connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() { folder->scheduleThisFolderSoon(); }); _currentConflictDialog->open(); ownCloudGui::raiseDialog(_currentConflictDialog); return; } if (path.isValid()) { QDesktopServices::openUrl(path); } else { const auto link = data(modelIndex, LinkRole).toUrl(); QDesktopServices::openUrl(link); } }"
"static int ptrace_setoptions(struct task_struct *child, unsigned long data) { unsigned flags; if (data & ~(unsigned long)PTRACE_O_MASK) return -EINVAL; if (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) { if (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) || !IS_ENABLED(CONFIG_SECCOMP)) return -EINVAL; if (!capable(CAP_SYS_ADMIN)) return -EPERM; if (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED || current->ptrace & PT_SUSPEND_SECCOMP) return -EPERM; } flags = child->ptrace; flags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT); flags |= (data << PT_OPT_FLAG_SHIFT); child->ptrace = flags; return 0; }"
"Status operator()(OpKernelContext* context, const Tensor& default_value_t, const Tensor& indices_t, const Tensor& values_t, const Tensor& dense_shape_t, typename AsyncOpKernel::DoneCallback done) { const int kEmptyRowIndicatorOutput = 2; const auto default_value = default_value_t.scalar<T>(); const auto indices = indices_t.matrix<Tindex>(); const auto values = values_t.vec<T>(); const auto dense_shape = dense_shape_t.vec<Tindex>(); const Tindex N = indices_t.shape().dim_size(0); const int rank = indices_t.shape().dim_size(1); const Tindex dense_rows = dense_shape(0);      DataType index_type = DataTypeToEnum<Tindex>::value; const GPUDevice& device = context->eigen_device<GPUDevice>(); se::Stream* stream = context->op_device_context()->stream(); if (!stream) return errors::Internal(""No GPU stream available.""); if (dense_rows == 0) { Tindex* output_indices; T* output_values; Tindex* reverse_index_map; TF_RETURN_IF_ERROR(AllocateOutputsExceptEmptyRowIndicator( context, N, rank, 0, &output_indices, &output_values, &reverse_index_map)); if (context->output_required(kEmptyRowIndicatorOutput)) { Tensor* unused = nullptr; TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput, TensorShape({0}), &unused)); } done(); return OkStatus(); } Tensor elements_per_row_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &elements_per_row_t)); auto elements_per_row = elements_per_row_t.flat<Tindex>(); se::DeviceMemoryBase elements_per_row_gpu_memory( elements_per_row.data(), dense_rows * sizeof(Tindex)); if (!stream ->ThenMemZero(&elements_per_row_gpu_memory, dense_rows * sizeof(Tindex)) .ok()) { return errors::Internal(""Failed to zero elements_per_row""); } Tensor rows_are_not_ordered_t; TF_RETURN_IF_ERROR(context->allocate_temp(DT_INT32, TensorShape({1}), &rows_are_not_ordered_t)); auto rows_are_not_ordered_gpu = rows_are_not_ordered_t.flat<int>(); se::DeviceMemoryBase rows_are_not_ordered_gpu_memory( rows_are_not_ordered_gpu.data(), sizeof(int)); if (!stream->ThenMemZero(&rows_are_not_ordered_gpu_memory, sizeof(int)) .ok()) { return errors::Internal(""Failed to zero rows_are_not_ordered""); } Tensor first_invalid_index_t; TF_RETURN_IF_ERROR(context->allocate_temp(DT_INT32, TensorShape({1}), &first_invalid_index_t)); auto first_invalid_index_gpu = first_invalid_index_t.flat<int>(); constexpr const int kAllIndicesValid = std::numeric_limits<int>::max(); se::DeviceMemoryBase first_invalid_index_gpu_memory( first_invalid_index_gpu.data(), sizeof(int)); if (!stream ->ThenMemset32(&first_invalid_index_gpu_memory, kAllIndicesValid, sizeof(int)) .ok()) { return errors::Internal(""Failed to initialize first_invalid_index""); } if (N > 0) { TF_RETURN_IF_ERROR(wrap_kernel_call( CountElementsPerRowKernel<Tindex>, device, N, dense_rows, rank, indices, elements_per_row, rows_are_not_ordered_gpu, first_invalid_index_gpu)); } Tensor input_row_ends_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &input_row_ends_t)); auto input_row_ends = input_row_ends_t.flat<Tindex>(); TF_RETURN_IF_ERROR(GpuInclusivePrefixSum(context, dense_rows, elements_per_row.data(), input_row_ends.data())); Tensor empty_row_indicator_t; bool* empty_row_indicator; if (context->output_required(kEmptyRowIndicatorOutput)) { Tensor* empty_row_indicator_t_ptr = nullptr; TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput, TensorShape({dense_rows}), &empty_row_indicator_t_ptr)); empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data(); } else { TF_RETURN_IF_ERROR(context->allocate_temp( DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t)); empty_row_indicator = empty_row_indicator_t.vec<bool>().data(); } TF_RETURN_IF_ERROR(wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>, device, dense_rows, elements_per_row, empty_row_indicator)); Tensor num_empty_rows_through_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &num_empty_rows_through_t)); auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>(); gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*> empty_row_indicator_cast(empty_row_indicator, {}); TF_RETURN_IF_ERROR( GpuInclusivePrefixSum(context, dense_rows, empty_row_indicator_cast, num_empty_rows_through.data())); ScratchSpace<Tindex> num_empty_rows_host(context, 1, true); if (!stream ->ThenMemcpy(num_empty_rows_host.mutable_data(), se::DeviceMemoryBase( num_empty_rows_through.data() + (dense_rows - 1), sizeof(*num_empty_rows_host.data())), sizeof(*num_empty_rows_host.data())) .ok()) { return errors::Internal(""Failed to copy num_empty_rows to host""); } ScratchSpace<int> rows_are_not_ordered_host(context, 1, true); if (!stream ->ThenMemcpy(rows_are_not_ordered_host.mutable_data(), rows_are_not_ordered_gpu_memory, sizeof(*rows_are_not_ordered_host.data())) .ok()) { return errors::Internal(""Failed to copy rows_are_not_ordered to host""); } ScratchSpace<int> first_invalid_index_host(context, 1, true); if (!stream ->ThenMemcpy(first_invalid_index_host.mutable_data(), first_invalid_index_gpu_memory, sizeof(*first_invalid_index_host.data())) .ok()) { return errors::Internal(""Failed to copy first_invalid_index to host""); } auto async_finish_computation = [this, context, kAllIndicesValid, index_type, N, rank, indices, values, default_value, dense_rows, num_empty_rows_host, rows_are_not_ordered_host, first_invalid_index_host, num_empty_rows_through_t, num_empty_rows_through, input_row_ends_t, input_row_ends, empty_row_indicator_t, empty_row_indicator, done]() -> void { DCHECK(done);   auto stream = context->op_device_context()->stream(); ScopedActivateExecutorContext scoped_activation{stream->parent()}; int first_invalid_index = *first_invalid_index_host.data(); OP_REQUIRES_ASYNC(context, first_invalid_index == kAllIndicesValid, errors::InvalidArgument(""indices("", first_invalid_index, "", 0) is invalid.""), done); Tindex num_empty_rows = *num_empty_rows_host.data(); Tindex* output_indices; T* output_values; Tindex* reverse_index_map; OP_REQUIRES_OK_ASYNC( context, AllocateOutputsExceptEmptyRowIndicator( context, N, rank, num_empty_rows, &output_indices, &output_values, &reverse_index_map), done); const GPUDevice& device = context->eigen_device<GPUDevice>(); Tindex* input_index_map = nullptr; Tensor input_index_map_t; int rows_are_not_ordered = *rows_are_not_ordered_host.data(); if (rows_are_not_ordered) { OP_REQUIRES_OK_ASYNC(context, ArgSortByRows(context, device, N, rank, dense_rows, indices, &input_index_map_t), done); input_index_map = input_index_map_t.vec<Tindex>().data(); } if (N > 0) { OP_REQUIRES_OK_ASYNC( context, wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>, device, N, dense_rows, rank, input_index_map, indices, values, num_empty_rows_through, output_indices, output_values, reverse_index_map), done); } OP_REQUIRES_OK_ASYNC( context, wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>, device, dense_rows, rank, default_value, num_empty_rows_through, input_row_ends, empty_row_indicator, output_indices, output_values), done); done(); }; context->device() ->tensorflow_accelerator_device_info() ->event_mgr->ThenExecute(stream, async_finish_computation); return OkStatus(); }"
"static void ppp_hdlc(netdissect_options *ndo, const u_char *p, int length) { u_char *b, *t, c; const u_char *s; int i, proto; const void *se; if (length <= 0) return; b = (u_char *)malloc(length); if (b == NULL) return; for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) { c = *s++; if (c == 0x7d) { if (i <= 1 || !ND_TTEST(*s)) break; i--; c = *s++ ^ 0x20; } *t++ = c; } se = ndo->ndo_snapend; ndo->ndo_snapend = t; length = t - b; if (length < 1) goto trunc; proto = *b;  switch (proto) { case PPP_IP: ip_print(ndo, b + 1, length - 1); goto cleanup; case PPP_IPV6: ip6_print(ndo, b + 1, length - 1); goto cleanup; default:  break; } if (length < 2) goto trunc; proto = EXTRACT_16BITS(b);  switch (proto) { case (PPP_ADDRESS << 8 | PPP_CONTROL):  if (length < 4) goto trunc; proto = EXTRACT_16BITS(b+2);  handle_ppp(ndo, proto, b + 4, length - 4); break; default:  handle_ppp(ndo, proto, b + 2, length - 2); break; } cleanup: ndo->ndo_snapend = se; free(b); return; trunc: ndo->ndo_snapend = se; free(b); ND_PRINT((ndo, ""[|ppp]"")); }"
"static int bigben_probe(struct hid_device *hid, const struct hid_device_id *id) { struct bigben_device *bigben; struct hid_input *hidinput; struct list_head *report_list; struct led_classdev *led; char *name; size_t name_sz; int n, error; bigben = devm_kzalloc(&hid->dev, sizeof(*bigben), GFP_KERNEL); if (!bigben) return -ENOMEM; hid_set_drvdata(hid, bigben); bigben->hid = hid; bigben->removed = false; error = hid_parse(hid); if (error) { hid_err(hid, ""parse failed\n""); return error; } error = hid_hw_start(hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF); if (error) { hid_err(hid, ""hw start failed\n""); return error; } report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list; if (list_empty(report_list)) { hid_err(hid, ""no output report found\n""); error = -ENODEV; goto error_hw_stop; } bigben->report = list_entry(report_list->next, struct hid_report, list); if (list_empty(&hid->inputs)) { hid_err(hid, ""no inputs found\n""); error = -ENODEV; goto error_hw_stop; } hidinput = list_first_entry(&hid->inputs, struct hid_input, list); set_bit(FF_RUMBLE, hidinput->input->ffbit); INIT_WORK(&bigben->worker, bigben_worker); error = input_ff_create_memless(hidinput->input, NULL, hid_bigben_play_effect); if (error) goto error_hw_stop; name_sz = strlen(dev_name(&hid->dev)) + strlen("":red:bigben#"") + 1; for (n = 0; n < NUM_LEDS; n++) { led = devm_kzalloc( &hid->dev, sizeof(struct led_classdev) + name_sz, GFP_KERNEL ); if (!led) { error = -ENOMEM; goto error_hw_stop; } name = (void *)(&led[1]); snprintf(name, name_sz, ""%s:red:bigben%d"", dev_name(&hid->dev), n + 1 ); led->name = name; led->brightness = (n == 0) ? LED_ON : LED_OFF; led->max_brightness = 1; led->brightness_get = bigben_get_led; led->brightness_set = bigben_set_led; bigben->leds[n] = led; error = devm_led_classdev_register(&hid->dev, led); if (error) goto error_hw_stop; } bigben->led_state = BIT(0); bigben->right_motor_on = 0; bigben->left_motor_force = 0; bigben->work_led = true; bigben->work_ff = true; schedule_work(&bigben->worker); hid_info(hid, ""LED and force feedback support for BigBen gamepad\n""); return 0; error_hw_stop: hid_hw_stop(hid); return error; }"
"static inline int compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd, int perm, struct console_font_op *op) { struct compat_consolefontdesc cfdarg; int i; if (copy_from_user(&cfdarg, user_cfd, sizeof(struct compat_consolefontdesc))) return -EFAULT; switch (cmd) { case PIO_FONTX: if (!perm) return -EPERM; op->op = KD_FONT_OP_SET; op->flags = KD_FONT_FLAG_OLD; op->width = 8; op->height = cfdarg.charheight; op->charcount = cfdarg.charcount; op->data = compat_ptr(cfdarg.chardata); return con_font_op(vc_cons[fg_console].d, op); case GIO_FONTX: op->op = KD_FONT_OP_GET; op->flags = KD_FONT_FLAG_OLD; op->width = 8; op->height = cfdarg.charheight; op->charcount = cfdarg.charcount; op->data = compat_ptr(cfdarg.chardata); i = con_font_op(vc_cons[fg_console].d, op); if (i) return i; cfdarg.charheight = op->height; cfdarg.charcount = op->charcount; if (copy_to_user(user_cfd, &cfdarg, sizeof(struct compat_consolefontdesc))) return -EFAULT; return 0; } return -EINVAL; }"
"int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots) { struct pipe_buffer *bufs; unsigned int head, tail, mask, n; mask = pipe->ring_size - 1; head = pipe->head; tail = pipe->tail; n = pipe_occupancy(pipe->head, pipe->tail); if (nr_slots < n) return -EBUSY; bufs = kcalloc(nr_slots, sizeof(*bufs), GFP_KERNEL_ACCOUNT | __GFP_NOWARN); if (unlikely(!bufs)) return -ENOMEM; if (n > 0) { unsigned int h = head & mask; unsigned int t = tail & mask; if (h > t) { memcpy(bufs, pipe->bufs + t, n * sizeof(struct pipe_buffer)); } else { unsigned int tsize = pipe->ring_size - t; if (h > 0) memcpy(bufs + tsize, pipe->bufs, h * sizeof(struct pipe_buffer)); memcpy(bufs, pipe->bufs + t, tsize * sizeof(struct pipe_buffer)); } } head = n; tail = 0; kfree(pipe->bufs); pipe->bufs = bufs; pipe->ring_size = nr_slots; if (pipe->max_usage > nr_slots) pipe->max_usage = nr_slots; pipe->tail = tail; pipe->head = head; wake_up_interruptible(&pipe->wr_wait); return 0; }"
"static void exif_mnote_data_pentax_load (ExifMnoteData *en, const unsigned char *buf, unsigned int buf_size) { ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en; size_t i, tcount, o, datao, base = 0; ExifShort c; if (!n || !buf || !buf_size) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); return; } datao = 6 + n->offset; if (CHECKOVERFLOW(datao, buf_size, 8)) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); return; } if (!memcmp(buf + datao, ""AOC"", 4)) { if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) { n->version = pentaxV3; n->order = EXIF_BYTE_ORDER_INTEL; } else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) { n->version = pentaxV3; n->order = EXIF_BYTE_ORDER_MOTOROLA; } else { n->version = pentaxV2; } exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Pentax maker note v%d..."", (int)n->version); datao += 4 + 2; base = MNOTE_PENTAX2_TAG_BASE; } else if (!memcmp(buf + datao, ""QVC"", 4)) { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Casio maker note v2...""); n->version = casioV2; base = MNOTE_CASIO2_TAG_BASE; datao += 4 + 2; } else { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Pentax maker note v1...""); n->version = pentaxV1; } c = exif_get_short (buf + datao, n->order); datao += 2; exif_mnote_data_pentax_clear (n); n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c); if (!n->entries) { EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", sizeof (MnotePentaxEntry) * c); return; } tcount = 0; for (i = c, o = datao; i; --i, o += 12) { size_t s; if (CHECKOVERFLOW(o,buf_size,12)) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); break; } n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base; n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order); n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order); n->entries[tcount].order      = n->order; exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnotePentax"", ""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag, mnote_pentax_tag_get_name (n->entries[tcount].tag)); if (exif_format_get_size (n->entries[tcount].format) && buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components ) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components); break; } s = exif_format_get_size (n->entries[tcount].format) * n->entries[tcount].components; n->entries[tcount].size = s; if (s) { size_t dataofs = o + 8; if (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6; if (CHECKOVERFLOW(dataofs, buf_size, s)) { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Tag data past end "" ""of buffer (%u > %u)"", (unsigned)(dataofs + s), buf_size); continue; } n->entries[tcount].data = exif_mem_alloc (en->mem, s); if (!n->entries[tcount].data) { EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", s); continue; } memcpy (n->entries[tcount].data, buf + dataofs, s); } ++tcount; } n->count = tcount; }"
"int XSetCommand ( Display *dpy, Window w, char **argv, int argc) { register int i; size_t nbytes; register char *buf, *bp; for (i = 0, nbytes = 0; i < argc; i++) { nbytes += safestrlen(argv[i]) + 1; } if ((bp = buf = Xmalloc(nbytes))) { for (i = 0; i < argc; i++) { if (argv[i]) { (void) strcpy(bp, argv[i]); bp += strlen(argv[i]) + 1; } else *bp++ = '\0'; } XChangeProperty (dpy, w, XA_WM_COMMAND, XA_STRING, 8, PropModeReplace, (unsigned char *)buf, nbytes); Xfree(buf); } return 1; }"
"static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free) { struct atm_qdisc_data *p = qdisc_priv(sch); struct atm_flow_data *flow; struct tcf_result res; int result; int ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS; pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", skb, sch, p); result = TC_ACT_OK; flow = NULL; if (TC_H_MAJ(skb->priority) != sch->handle || !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) { struct tcf_proto *fl; list_for_each_entry(flow, &p->flows, list) { fl = rcu_dereference_bh(flow->filter_list); if (fl) { result = tcf_classify(skb, NULL, fl, &res, true); if (result < 0) continue; flow = (struct atm_flow_data *)res.class; if (!flow) flow = lookup_flow(sch, res.classid); goto done; } } flow = NULL; done: ; } if (!flow) { flow = &p->link; } else { if (flow->vcc) ATM_SKB(skb)->atm_options = flow->vcc->atm_options; #ifdef CONFIG_NET_CLS_ACT switch (result) { case TC_ACT_QUEUED: case TC_ACT_STOLEN: case TC_ACT_TRAP: __qdisc_drop(skb, to_free); return NET_XMIT_SUCCESS | __NET_XMIT_STOLEN; case TC_ACT_SHOT: __qdisc_drop(skb, to_free); goto drop; case TC_ACT_RECLASSIFY: if (flow->excess) flow = flow->excess; else ATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP; break; } #endif } ret = qdisc_enqueue(skb, flow->q, to_free); if (ret != NET_XMIT_SUCCESS) { drop: __maybe_unused if (net_xmit_drop_count(ret)) { qdisc_qstats_drop(sch); if (flow) flow->qstats.drops++; } return ret; } if (flow == &p->link) { sch->q.qlen++; return NET_XMIT_SUCCESS; } tasklet_schedule(&p->task); return NET_XMIT_SUCCESS | __NET_XMIT_BYPASS; }"
"static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end) { struct vm_area_struct **insertion_point; struct vm_area_struct *tail_vma = NULL; insertion_point = (prev ? &prev->vm_next : &mm->mmap); vma->vm_prev = NULL; do { vma_rb_erase(vma, &mm->mm_rb); mm->map_count--; tail_vma = vma; vma = vma->vm_next; } while (vma && vma->vm_start < end); *insertion_point = vma; if (vma) { vma->vm_prev = prev; vma_gap_update(vma); } else mm->highest_vm_end = prev ? vm_end_gap(prev) : 0; tail_vma->vm_next = NULL; vmacache_invalidate(mm); }"
"static int dictAdd(dict *ht, void *key, void *val) { int index; dictEntry *entry; if ((index = _dictKeyIndex(ht, key)) == -1) return DICT_ERR; entry = hiredis_safe_malloc(sizeof(*entry)); entry->next = ht->table[index]; ht->table[index] = entry; dictSetHashKey(ht, entry, key); dictSetHashVal(ht, entry, val); ht->used++; return DICT_OK; }"
"int fuse_inode_uncached_io_start(struct fuse_inode *fi, struct fuse_backing *fb) { struct fuse_backing *oldfb; int err = 0; spin_lock(&fi->lock); oldfb = fuse_inode_backing(fi); if (oldfb && oldfb != fb) { err = -EBUSY; goto unlock; } if (fi->iocachectr > 0) { err = -ETXTBSY; goto unlock; } fi->iocachectr--; if (!oldfb) { oldfb = fuse_inode_backing_set(fi, fb); WARN_ON_ONCE(oldfb != NULL); } else { fuse_backing_put(fb); } unlock: spin_unlock(&fi->lock); return err; }"
"void jbd2_journal_wait_updates(journal_t *journal) { transaction_t *commit_transaction = journal->j_running_transaction; if (!commit_transaction) return; spin_lock(&commit_transaction->t_handle_lock); while (atomic_read(&commit_transaction->t_updates)) { DEFINE_WAIT(wait); prepare_to_wait(&journal->j_wait_updates, &wait, TASK_UNINTERRUPTIBLE); if (atomic_read(&commit_transaction->t_updates)) { spin_unlock(&commit_transaction->t_handle_lock); write_unlock(&journal->j_state_lock); schedule(); write_lock(&journal->j_state_lock); spin_lock(&commit_transaction->t_handle_lock); } finish_wait(&journal->j_wait_updates, &wait); } spin_unlock(&commit_transaction->t_handle_lock); }"
"BrotliContext::BrotliContext(const uint32_t chunk_size) : chunk_size_{chunk_size}, chunk_ptr_{std::make_unique<uint8_t[]>(chunk_size)}, next_in_{}, next_out_{chunk_ptr_.get()}, avail_in_{0}, avail_out_{chunk_size} {}"
"static jclass getClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags) { jclass returnValue = NULL; J9VMThread *vmThread = (J9VMThread *) env; J9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions; SunReflectCPResult result = NULL_POINTER_EXCEPTION; if (NULL != constantPoolOop) { J9Class *clazz = NULL; vmFunctions->internalEnterVMFromJNI(vmThread); result = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz); if (NULL != clazz) { returnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz)); } vmFunctions->internalExitVMToJNI(vmThread); } checkResult(env, result); return returnValue; }"
"bool rebuild_header_jpg( void ) { abytewriter* hdrw;  unsigned char  type = 0x00;     uint32_t   len  = 0;     uint32_t   hpos = 0;  hdrw = new abytewriter( 4096 ); while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) { type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0; len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0); if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) || ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) || ( type == 0xDD ) ) { uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos; hdrw->write_n( &(hdrdata[ hpos ]), to_copy); if (to_copy <  len) { for (uint32_t i = 0;i <to_copy -len;++i) { uint8_t zero = 0; hdrw->write_n(&zero, 1); } } } hpos += len; } custom_free( hdrdata ); hdrdata = hdrw->getptr_aligned(); hdrs    = hdrw->getpos(); delete( hdrw ); return true; }"
void tee_shm_free(struct tee_shm *shm) { if (shm->flags & TEE_SHM_DMA_BUF) dma_buf_put(shm->dmabuf); else tee_shm_release(shm); }
"bool Mfcc::Initialize(int input_length, double input_sample_rate) { bool initialized = mel_filterbank_.Initialize( input_length, input_sample_rate, filterbank_channel_count_, lower_frequency_limit_, upper_frequency_limit_); initialized &= dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_); initialized_ = initialized; return initialized; }"
"static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p, uint8_t ep) { int status, len; if (!dev->endpoint[EP2I(ep)].iso_started && !dev->endpoint[EP2I(ep)].iso_error) { struct usb_redir_start_iso_stream_header start_iso = { .endpoint = ep, }; int pkts_per_sec; if (dev->dev.speed == USB_SPEED_HIGH) { pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval; } else { pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval; } dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000; start_iso.pkts_per_urb = pkts_per_sec / 100; if (start_iso.pkts_per_urb < 1) { start_iso.pkts_per_urb = 1; } else if (start_iso.pkts_per_urb > 32) { start_iso.pkts_per_urb = 32; } start_iso.no_urbs = DIV_ROUND_UP( dev->endpoint[EP2I(ep)].bufpq_target_size, start_iso.pkts_per_urb); if (!(ep & USB_DIR_IN)) { start_iso.no_urbs *= 2; } if (start_iso.no_urbs > 16) { start_iso.no_urbs = 16; } usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso); usbredirparser_do_write(dev->parser); DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"", pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep); dev->endpoint[EP2I(ep)].iso_started = 1; dev->endpoint[EP2I(ep)].bufpq_prefilled = 0; dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0; } if (ep & USB_DIR_IN) { struct buf_packet *isop; if (dev->endpoint[EP2I(ep)].iso_started && !dev->endpoint[EP2I(ep)].bufpq_prefilled) { if (dev->endpoint[EP2I(ep)].bufpq_size < dev->endpoint[EP2I(ep)].bufpq_target_size) { return; } dev->endpoint[EP2I(ep)].bufpq_prefilled = 1; } isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq); if (isop == NULL) { DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"", ep, dev->endpoint[EP2I(ep)].iso_error); dev->endpoint[EP2I(ep)].bufpq_prefilled = 0; status = dev->endpoint[EP2I(ep)].iso_error; dev->endpoint[EP2I(ep)].iso_error = 0; p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS; return; } DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", ep, isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size); status = isop->status; len = isop->len; if (len > p->iov.size) { ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"", ep, len, (int)p->iov.size); len = p->iov.size; status = usb_redir_babble; } usb_packet_copy(p, isop->data, len); bufp_free(dev, isop, ep); usbredir_handle_status(dev, p, status); } else { if (dev->endpoint[EP2I(ep)].iso_started) { struct usb_redir_iso_packet_header iso_packet = { .endpoint = ep, .length = p->iov.size }; uint8_t buf[p->iov.size]; usb_packet_copy(p, buf, p->iov.size); usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet, buf, p->iov.size); usbredirparser_do_write(dev->parser); } status = dev->endpoint[EP2I(ep)].iso_error; dev->endpoint[EP2I(ep)].iso_error = 0; DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", ep, status, p->iov.size); usbredir_handle_status(dev, p, status); } }"
"static Bool latm_dmx_sync_frame_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *acfg, u32 *nb_bytes, u8 *buffer, u32 *nb_skipped) { u32 val, size; u64 pos, mux_size; if (nb_skipped) *nb_skipped = 0; if (!acfg) return 0; while (gf_bs_available(bs)>3) { val = gf_bs_read_u8(bs); if (val!=0x56) { if (nb_skipped) (*nb_skipped) ++; continue; } val = gf_bs_read_int(bs, 3); if (val != 0x07) { gf_bs_read_int(bs, 5); if (nb_skipped) (*nb_skipped) ++; continue; } mux_size = gf_bs_read_int(bs, 13); pos = gf_bs_get_position(bs); if (mux_size>gf_bs_available(bs) ) { gf_bs_seek(bs, pos-3); return GF_FALSE; } if (!gf_bs_read_int(bs, 1)) { Bool amux_version, amux_versionA; amux_version = (Bool)gf_bs_read_int(bs, 1); amux_versionA = GF_FALSE; if (amux_version) amux_versionA = (Bool)gf_bs_read_int(bs, 1); if (!amux_versionA) { u32 i, allStreamsSameTimeFraming, numProgram; if (amux_version) gf_latm_get_value(bs); allStreamsSameTimeFraming = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 6); numProgram = gf_bs_read_int(bs, 4); for (i=0; i<=numProgram; i++) { u32 j, num_lay; num_lay = gf_bs_read_int(bs, 3); for (j=0; j<=num_lay; j++) { u32 frameLengthType; Bool same_cfg = GF_FALSE; if (i || j) same_cfg = (Bool)gf_bs_read_int(bs, 1); if (!same_cfg) { if (amux_version==1) gf_latm_get_value(bs); gf_m4a_parse_config(bs, acfg, GF_FALSE); } frameLengthType = gf_bs_read_int(bs, 3); if (!frameLengthType) { gf_bs_read_int(bs, 8); if (!allStreamsSameTimeFraming) { } } else { } } } if (gf_bs_read_int(bs, 1)) { } if (gf_bs_read_int(bs, 1)) { } } } size = 0; while (1) { u32 tmp = gf_bs_read_int(bs, 8); size += tmp; if (tmp!=255) break; } if (gf_bs_available(bs) < size) { gf_bs_seek(bs, pos-3); return GF_FALSE; } if (nb_bytes) { *nb_bytes = (u32) size; } if (buffer) { gf_bs_read_data(bs, (char *) buffer, size); } else { while (size) { gf_bs_read_int(bs, 8); size--; } } gf_bs_seek(bs, pos + mux_size); if ((gf_bs_available(bs)>2) && gf_bs_peek_bits(bs, 11, 0) != 0x2B7) { gf_bs_seek(bs, pos + 1); if (nb_skipped) (*nb_skipped) ++; continue; } return GF_TRUE; } return GF_FALSE; }"
"void TEE_MACUpdate(TEE_OperationHandle operation, const void *chunk, uint32_t chunkSize) { TEE_Result res; if (operation == TEE_HANDLE_NULL || (chunk == NULL && chunkSize != 0)) TEE_Panic(0); if (operation->info.operationClass != TEE_OPERATION_MAC) TEE_Panic(0); if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) TEE_Panic(0); if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) TEE_Panic(0); res = utee_hash_update(operation->state, chunk, chunkSize); if (res != TEE_SUCCESS) TEE_Panic(res); }"
"static void analyze_regex (char *regex_arg) { if (regex_arg == NULL) { free_regexps (); return; } switch (regex_arg[0]) { case '\0': case ' ': case '\t': break; case '@': { FILE *regexfp; linebuffer regexbuf; char *regexfile = regex_arg + 1; regexfp = fopen (regexfile, ""r"" FOPEN_BINARY); if (regexfp == NULL) pfatal (regexfile); linebuffer_init (&regexbuf); while (readline_internal (&regexbuf, regexfp, regexfile) > 0) analyze_regex (regexbuf.buffer); free (regexbuf.buffer); if (fclose (regexfp) != 0) pfatal (regexfile); } break; case '{': { language *lang; char *lang_name = regex_arg + 1; char *cp; for (cp = lang_name; *cp != '}'; cp++) if (*cp == '\0') { error (""unterminated language name in regex: %s"", regex_arg); return; } *cp++ = '\0'; lang = get_language_from_langname (lang_name); if (lang == NULL) return; add_regex (cp, lang); } break; default: add_regex (regex_arg, NULL); break; } }"
"int wolfSSH_SFTP_RecvLSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) { WS_SFTP_FILEATRB atr; char* name = NULL; int   ret = WS_SUCCESS; word32 sz; word32 idx = 0; byte*  out = NULL; word32 outSz = 0; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_LSTAT""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz) { return WS_BUFFER_E; } name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (name == NULL) { return WS_MEMORY_E; } WMEMCPY(name, data + idx, sz); name[sz] = '\0'; if (wolfSSH_CleanPath(ssh, name) < 0) { WLOG(WS_LOG_SFTP, ""Unable to clean path""); if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", NULL, &outSz) != WS_SIZE_ONLY) { WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } ret = WS_FATAL_ERROR; } if (ret == WS_SUCCESS) { WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB)); if ((ret = SFTP_GetAttributes(ssh->fs, name, &atr, 1, ssh->ctx->heap)) != WS_SUCCESS) { WLOG(WS_LOG_SFTP, ""Unable to get lstat of file/directory""); if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", NULL, &outSz) != WS_SIZE_ONLY) { WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } ret = WS_BAD_FILE_E; } else { sz = SFTP_AtributesSz(ssh, &atr); outSz = sz + WOLFSSH_SFTP_HEADER; } } WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (ret != WS_SUCCESS) { if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } } else { if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr); } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }"
"int read_exif_orientation_tag(const uint8_t* exif, int size) { bool little_endian; int pos = find_exif_tag(exif, size, EXIF_TAG_ORIENTATION, &little_endian); if (pos < 0) { return DEFAULT_EXIF_ORIENTATION; } int type = read16(exif, size, pos + 2, little_endian); int count = read32(exif, size, pos + 4, little_endian); if (type == EXIF_TYPE_SHORT && count == 1) { return read16(exif, size, pos + 8, little_endian); } return DEFAULT_EXIF_ORIENTATION; }"
"int sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[]) { sudo_auth *auth; debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH); for (auth = auth_switch; auth->name; auth++) { if (auth->begin_session && !IS_DISABLED(auth)) { int status = (auth->begin_session)(ctx, pw, user_env, auth); if (status != AUTH_SUCCESS) { debug_return_int(-1); } } } debug_return_int(1); }"
"de265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps) { int vlc; nal_hrd_parameters_present_flag = get_bits(br, 1); vcl_hrd_parameters_present_flag = get_bits(br, 1); if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) { sub_pic_hrd_params_present_flag = get_bits(br, 1); if (sub_pic_hrd_params_present_flag) { tick_divisor_minus2 = get_bits(br, 8); du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5); sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1); dpb_output_delay_du_length_minus1 = get_bits(br, 5); } bit_rate_scale = get_bits(br, 4); cpb_size_scale = get_bits(br, 4); if (sub_pic_hrd_params_present_flag) { cpb_size_du_scale = get_bits(br, 4); } initial_cpb_removal_delay_length_minus1 = get_bits(br, 5); au_cpb_removal_delay_length_minus1 = get_bits(br, 5); dpb_output_delay_length_minus1 = get_bits(br, 5); } int  i, j, nalOrVcl; for (i = 0; i < sps->sps_max_sub_layers; i++) { fixed_pic_rate_general_flag[i] = get_bits(br, 1); if (!fixed_pic_rate_general_flag[i]) { fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1); } else { fixed_pic_rate_within_cvs_flag[i] = true; } low_delay_hrd_flag[i] = 0;    cpb_cnt_minus1[i] = 0;     if (fixed_pic_rate_within_cvs_flag[i]) { READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0); } else { low_delay_hrd_flag[i] = get_bits(br, 1); } if (!low_delay_hrd_flag[i]) { READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0); } for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++) { if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) || ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag)) { for (j = 0; j <= cpb_cnt_minus1[i]; j++) { READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0); READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0); if (sub_pic_hrd_params_present_flag) { READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0); READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0); } cbr_flag[i][j][nalOrVcl] = get_bits(br, 1); } } } } return DE265_OK; }"
"static ssize_t rbd_config_info_show(struct device *dev, struct device_attribute *attr, char *buf) { struct rbd_device *rbd_dev = dev_to_rbd_dev(dev); return sprintf(buf, ""%s\n"", rbd_dev->config_info); }"
"void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif Q_D(QPaintEngineEx); if (path.isEmpty()) return; if (!d->strokeHandler) { d->strokeHandler = new StrokeHandler(path.elementCount()+4); d->stroker.setMoveToHook(qpaintengineex_moveTo); d->stroker.setLineToHook(qpaintengineex_lineTo); d->stroker.setCubicToHook(qpaintengineex_cubicTo); } QRectF clipRect; QPen pen = inPen; if (pen.style() > Qt::SolidLine) { QRectF cpRect = path.controlPointRect(); const QTransform &xf = state()->matrix; if (pen.isCosmetic()) { clipRect = d->exDeviceRect; cpRect.translate(xf.dx(), xf.dy()); } else { clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect)); } QRectF extentRect = cpRect & clipRect; qreal extent = qMax(extentRect.width(), extentRect.height()); qreal patternLength = 0; const QList<qreal> pattern = pen.dashPattern(); const int patternSize = qMin(pattern.size(), 32); for (int i = 0; i < patternSize; i++) patternLength += qMax(pattern.at(i), qreal(0)); if (pen.widthF()) patternLength *= pen.widthF(); if (qFuzzyIsNull(patternLength)) { pen.setStyle(Qt::NoPen); } else if (extent / patternLength > 10000) { pen.setStyle(Qt::SolidLine); QColor color(pen.color()); color.setAlpha(color.alpha() / 2); pen.setColor(color); } } if (!qpen_fast_equals(pen, d->strokerPen)) { d->strokerPen = pen; d->stroker.setJoinStyle(pen.joinStyle()); d->stroker.setCapStyle(pen.capStyle()); d->stroker.setMiterLimit(pen.miterLimit()); qreal penWidth = pen.widthF(); if (penWidth == 0) d->stroker.setStrokeWidth(1); else d->stroker.setStrokeWidth(penWidth); Qt::PenStyle style = pen.style(); if (style == Qt::SolidLine) { d->activeStroker = &d->stroker; } else if (style == Qt::NoPen) { d->activeStroker = nullptr; } else { d->dasher.setDashPattern(pen.dashPattern()); d->dasher.setDashOffset(pen.dashOffset()); d->activeStroker = &d->dasher; } } if (!d->activeStroker) { return; } if (!clipRect.isNull()) d->activeStroker->setClipRect(clipRect); if (d->activeStroker == &d->stroker) d->stroker.setForceOpen(path.hasExplicitOpen()); const QPainterPath::ElementType *types = path.elements(); const qreal *points = path.points(); int pointCount = path.elementCount(); const qreal *lastPoint = points + (pointCount<<1); d->strokeHandler->types.reset(); d->strokeHandler->pts.reset(); uint flags = QVectorPath::WindingFill; if (path.elementCount() > 2) flags |= QVectorPath::NonConvexShapeMask; if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin) flags |= QVectorPath::CurvedShapeMask; if (!pen.isCosmetic()) { d->activeStroker->setCurveThresholdFromTransform(state()->matrix); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: d->activeStroker->moveTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::LineToElement: d->activeStroker->lineTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::CurveToElement: d->activeStroker->cubicTo(points[0], points[1], points[2], points[3], points[4], points[5]); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; default: break; } } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } else { d->activeStroker->moveTo(points[0], points[1]); points += 2; while (points < lastPoint) { d->activeStroker->lineTo(points[0], points[1]); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } d->activeStroker->end(); if (!d->strokeHandler->types.size())             return; QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); fill(strokePath, pen.brush()); } else { if (state()->matrix.type() >= QTransform::TxProject) { QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath()); d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform()); } else { d->activeStroker->setCurveThresholdFromTransform(QTransform()); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->moveTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::LineToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::CurveToElement: { QPointF c1 = ((const QPointF *) points)[0] * state()->matrix; QPointF c2 = ((const QPointF *) points)[1] * state()->matrix; QPointF e =  ((const QPointF *) points)[2] * state()->matrix; d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y()); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; } default: break; } } if (path.hasImplicitClose()) { QPointF pt = * ((const QPointF *) path.points()) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); } } else { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->moveTo(p.x(), p.y()); points += 2; while (points < lastPoint) { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->lineTo(p.x(), p.y()); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(p.x(), p.y()); } d->activeStroker->end(); } QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); QTransform xform = state()->matrix; state()->matrix = QTransform(); transformChanged(); QBrush brush = pen.brush(); if (qbrush_style(brush) != Qt::SolidPattern) brush.setTransform(brush.transform() * xform); fill(strokePath, brush); state()->matrix = xform; transformChanged(); } }"
"Status KernelAndDeviceOp::Run( ScopedStepContainer* step_container, const EagerKernelArgs& inputs, std::vector<EagerKernelRet>* outputs, CancellationManager* cancellation_manager, const absl::optional<EagerRemoteFunctionParams>& remote_func_params) { OpKernelContext::Params params; params.device = device_; params.frame_iter = FrameAndIter(0, 0); params.inputs = inputs.GetTensorValues(); params.op_kernel = kernel_.get(); params.resource_manager = device_->resource_manager(); params.input_alloc_attrs = &input_alloc_attrs_; params.output_attr_array = output_alloc_attrs_.data(); params.function_library = flr_; params.slice_reader_cache = &slice_reader_cache_; params.rendezvous = rendezvous_; OpExecutionState* op_execution_state = nullptr; CancellationManager default_cancellation_manager; if (cancellation_manager) { params.cancellation_manager = cancellation_manager; } else if (kernel_->is_deferred()) { op_execution_state = new OpExecutionState; params.cancellation_manager = &op_execution_state->cancellation_manager; params.inc_num_deferred_ops_function = [op_execution_state]() { op_execution_state->Ref(); }; params.dec_num_deferred_ops_function = [op_execution_state]() { op_execution_state->Unref(); }; } else { params.cancellation_manager = &default_cancellation_manager; } params.log_memory = log_memory_; params.runner = get_runner(); params.step_container = step_container == nullptr ? &step_container_ : step_container; auto step_container_cleanup = gtl::MakeCleanup([step_container, this] { if (step_container == nullptr) { this->step_container_.CleanUp(); } }); params.collective_executor = collective_executor_ ? collective_executor_->get() : nullptr; OpKernelContext context(&params); { port::ScopedFlushDenormal flush; port::ScopedSetRound round(FE_TONEAREST); profiler::AnnotatedTraceMe activity( [&] { return kernel_->TraceString(context, false); }, profiler::TraceMeLevel::kInfo); device_->Compute(kernel_.get(), &context); } if (op_execution_state != nullptr) { op_execution_state->Unref(); } if (!context.status().ok()) return context.status(); if (outputs != nullptr) { outputs->clear(); for (int i = 0; i < context.num_outputs(); ++i) { outputs->push_back(Tensor(*context.mutable_output(i))); } } return Status::OK(); }"
"static void evtchn_fifo_handle_events(unsigned cpu) { __evtchn_fifo_handle_events(cpu, false); }"
"DiskInfo get_disk_info(void) { FILE *mounts; char procline[1024]; char *mount, *device, *type, *mode, *other; float thispct, max=0.0; double dtotal=0.0, dfree=0.0; DiskInfo di; di.total = 0; di.free = 0; mounts = fopen(MOUNTS,""r""); if (!mounts) { return di; } while ( fgets(procline, sizeof(procline), mounts) ) { device = procline; mount = index(procline, ' '); if (mount == NULL) continue; *mount++ = '\0'; type = index(mount, ' '); if (type == NULL) continue; *type++ = '\0'; mode = index(type, ' '); if (mode == NULL) continue; *mode++ = '\0'; other = index(mode, ' '); if (other != NULL) *other = '\0'; if (!strncmp(mode, ""ro"", 2)) continue; if (remote_mount(device, type)) continue; if (strncmp(device, ""/dev/"", 5) != 0 && strncmp(device, ""/dev2/"", 6) != 0) continue; thispct = device_space(mount, device, &dtotal, &dfree); if (!max || max<thispct) max = thispct; } fclose(mounts); DFcleanup(); di.total = dtotal / 1000; di.free = dfree / 1000; return di; }"
"static Jsi_RC jsi_ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); int flags = 0, i, curlen, hasopt = 0; Jsi_Value *v, *arg = NULL; SortInfo si = {}; si.interp = interp; Jsi_Obj *obj = _this->d.obj; curlen = obj->arrCnt; if (curlen <= 1) { goto done; } arg = Jsi_ValueArrayIndex(interp, args, 0); if (arg) { if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) { if (Jsi_OptionsProcess(interp, jsi_ArraySortOptions, &si, arg, 0) < 0) return JSI_ERROR; hasopt = 1; switch (si.mode) { case 1: flags |= JSI_SORT_DESCEND; break; case 2: flags |= JSI_SORT_DICT; break; case 3: flags |= JSI_SORT_NOCASE; break; } } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION)) si.compare = arg; else  return Jsi_LogError(""expected object or function""); } si.flags = flags; Jsi_ObjListifyArray(interp, obj); #ifdef NO_QSORT_R curSortInfo = &si; qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd); #else qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si); #endif if (interp->deleting) { #ifdef NO_QSORT_R curSortInfo = NULL; #endif return JSI_ERROR; } if (si.unique) { int n, diff = 1, dupCnt=0; for (n=0, i=1; i<(int)obj->arrCnt; i++) { if (obj->arr[n] == obj->arr[i]) diff = 1; else #ifdef NO_QSORT_R diff = SortSubCmd(&obj->arr[n], &obj->arr[i]); #else #ifdef __WIN32 diff = SortSubCmd(&si, &obj->arr[n], &obj->arr[i]); #else diff = SortSubCmd(&obj->arr[n], &obj->arr[i], &si); #endif #endif if (diff) { n++; if (n!=i) obj->arr[n] = obj->arr[i]; } else { dupCnt++; if (obj->arr[i]) Jsi_DecrRefCount(interp, obj->arr[i]); obj->arr[i] = 0; } } obj->arrCnt -= dupCnt; } #ifdef NO_QSORT_R curSortInfo = NULL; #endif if (hasopt) Jsi_OptionsFree(interp, jsi_ArraySortOptions, &si, 0); done: v = Jsi_ValueMakeObject(interp, NULL, obj); Jsi_ValueReplace(interp, ret, v); return JSI_OK; }"
"void *malloc_wrapper(struct _reent *r, size_t size, void *caller) { void *ptr = NULL; #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_lock(); #endif #ifdef MBED_HEAP_STATS_ENABLED malloc_stats_mutex->lock(); alloc_info_t *alloc_info = (alloc_info_t *)__real__malloc_r(r, size + sizeof(alloc_info_t)); if (alloc_info != NULL) { alloc_info->size = size; alloc_info->signature = MBED_HEAP_STATS_SIGNATURE; ptr = (void *)(alloc_info + 1); heap_stats.current_size += size; heap_stats.total_size += size; heap_stats.alloc_cnt += 1; if (heap_stats.current_size > heap_stats.max_size) { heap_stats.max_size = heap_stats.current_size; } heap_stats.overhead_size += MALLOC_HEAP_TOTAL_SIZE(MALLOC_HEADER_PTR(alloc_info)) - size; } else { heap_stats.alloc_fail_cnt += 1; } malloc_stats_mutex->unlock(); #else     ptr = __real__malloc_r(r, size); #endif #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_malloc(ptr, size, caller); mbed_mem_trace_unlock(); #endif     return ptr; }"
"int jlink_init(void) { void *so; unsigned int i; for (i = 0; i < NELEM(jlink_so_name); i++) { so = dlopen(jlink_so_name[i], RTLD_LAZY); if (so) break; } if (!so) return -EIO; jlink.emu_selectbyusbsn = dlsym(so, ""JLINK_EMU_SelectByUSBSN""); jlink.open = dlsym(so, ""JLINK_Open""); jlink.execcommand = dlsym(so, ""JLINK_ExecCommand""); jlink.tif_select = dlsym(so, ""JLINK_TIF_Select""); jlink.setspeed = dlsym(so, ""JLINK_SetSpeed""); jlink.connect = dlsym(so, ""JLINK_Connect""); jlink.getsn = dlsym(so, ""JLINK_GetSN""); jlink.emu_getproductname = dlsym(so, ""JLINK_EMU_GetProductName""); jlink.rtterminal_control = dlsym(so, ""JLINK_RTTERMINAL_Control""); jlink.rtterminal_read = dlsym(so, ""JLINK_RTTERMINAL_Read""); if (!jlink.emu_selectbyusbsn || !jlink.open || !jlink.execcommand || !jlink.tif_select || !jlink.setspeed || !jlink.connect || !jlink.getsn || !jlink.emu_getproductname || !jlink.rtterminal_control || !jlink.rtterminal_read) { dlclose(so); return -EIO; } dlclose(so); return 0; }"
"int PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta) { for (int j = 0; abs_symbol_names[j][0]; ++j) { unsigned st_name = get_te32(&sym->st_name); if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) { sym->st_value += delta; return 1; } } return 0; }"
"static int setupStream(PRTSP_MESSAGE response, char* target, int* error) { RTSP_MESSAGE request; int ret; char* transportValue; *error = -1; ret = initializeRtspRequest(&request, ""SETUP"", target); if (ret != 0) { if (hasSessionId) { if (!addOption(&request, ""Session"", sessionIdString)) { ret = 0; goto FreeMessage; } } if (ServerMajorVersion >= 6) { transportValue = ""unicast;X-GS-ClientPort=50000-50001""; } else { transportValue = "" ""; } if (addOption(&request, ""Transport"", transportValue) && addOption(&request, ""If-Modified-Since"", ""Thu, 01 Jan 1970 00:00:00 GMT"")) { ret = transactRtspMessage(&request, response, 0, error); } else { ret = 0; } FreeMessage: freeMessage(&request); } return ret; }"
"static int bprm_execve(struct linux_binprm *bprm, int fd, struct filename *filename, int flags) { struct file *file; struct files_struct *displaced; int retval; retval = unshare_files(&displaced); if (retval) return retval; retval = prepare_bprm_creds(bprm); if (retval) goto out_files; check_unsafe_exec(bprm); current->in_execve = 1; file = do_open_execat(fd, filename, flags); retval = PTR_ERR(file); if (IS_ERR(file)) goto out_unmark; sched_exec(); bprm->file = file; if (bprm->fdpath && close_on_exec(fd, rcu_dereference_raw(current->files->fdt))) bprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE; retval = security_bprm_creds_for_exec(bprm); if (retval) goto out; retval = exec_binprm(bprm); if (retval < 0) goto out; current->fs->in_exec = 0; current->in_execve = 0; rseq_execve(current); acct_update_integrals(current); task_numa_free(current, false); if (displaced) put_files_struct(displaced); return retval; out: if (bprm->point_of_no_return && !fatal_signal_pending(current)) force_sigsegv(SIGSEGV); out_unmark: current->fs->in_exec = 0; current->in_execve = 0; out_files: if (displaced) reset_files_struct(displaced); return retval; }"
"NAN_METHOD(TxnWrap::putString) { return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void { CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data); }, [](MDB_val &data) -> void { delete[] (uint16_t*)data.mv_data; }); }"
"explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""signed_input"", &signed_input_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_bits"", &num_bits_)); OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63), errors::InvalidArgument(""num_bits is out of range: "", num_bits_, "" with signed_input_ "", signed_input_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""range_given"", &range_given_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_min"", &input_min_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_max"", &input_max_)); if (range_given_) { OP_REQUIRES( ctx, input_min_ <= input_max_, errors::InvalidArgument(""Invalid range: input_min "", input_min_, "" > input_max "", input_max_)); } }"
bool ksmbd_smb_request(struct ksmbd_conn *conn) { return conn->request_buf[0] == 0; }
"void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd, unsigned long address, bool freeze, struct page *page) { spinlock_t *ptl; struct mmu_notifier_range range; mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm, address & HPAGE_PMD_MASK, (address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE); mmu_notifier_invalidate_range_start(&range); ptl = pmd_lock(vma->vm_mm, pmd); VM_BUG_ON(freeze && !page); if (page && page != pmd_page(*pmd)) goto out; if (pmd_trans_huge(*pmd)) { page = pmd_page(*pmd); if (PageMlocked(page)) clear_page_mlock(page); } else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd))) goto out; __split_huge_pmd_locked(vma, pmd, range.start, freeze); out: spin_unlock(ptl); mmu_notifier_invalidate_range_only_end(&range); }"
"void ddl_add_col (query_instance_t * qi, const char *table, caddr_t * col, int if_not_exists) { caddr_t err; static query_t *add_col_proc; client_connection_t *cli = qi->qi_client; dbe_column_t *col_ref; dbe_table_t *tb = qi_name_to_table (qi, table); if (!add_col_proc) add_col_proc = sql_compile_static (""DB.DBA.add_col (?, ?,?)"", bootstrap_cli, &err, SQLC_DEFAULT); if (!tb) sqlr_new_error (""42S02"", ""SQ018"", ""No table %s."", table); sql_error_if_remote_table (tb); col_ref = tb_name_to_column (tb, col[0]); if (col_ref && if_not_exists) return; AS_DBA (qi, err = qr_rec_exec (add_col_proc, cli, NULL, qi, NULL, 3, "":0"", (0 == strcmp (tb->tb_name, ""DB.DBA.SYS_TRIGGERS"")) ? ""SYS_TRIGGERS"" : tb->tb_name, QRP_STR, "":1"", col[0], QRP_STR, "":2"", box_copy_tree ((caddr_t) col), QRP_RAW)); if (err != SQL_SUCCESS) { QI_POISON_TRX (qi); sqlr_resignal (err); } }"
"static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd, struct xcopy_op *xop, unsigned char *p, unsigned short tdll, sense_reason_t *sense_ret) { struct se_device *local_dev = se_cmd->se_dev; unsigned char *desc = p; int offset = tdll % XCOPY_TARGET_DESC_LEN, rc; unsigned short cscd_index = 0; unsigned short start = 0; *sense_ret = TCM_INVALID_PARAMETER_LIST; if (offset != 0) { pr_err(""XCOPY target descriptor list length is not"" "" multiple of %d\n"", XCOPY_TARGET_DESC_LEN); *sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE; return -EINVAL; } if (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) { pr_err(""XCOPY target descriptor supports a maximum"" "" two src/dest descriptors, tdll: %hu too large..\n"", tdll); *sense_ret = TCM_TOO_MANY_TARGET_DESCS; return -EINVAL; } memset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN); target_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]); while (start < tdll) { switch (desc[0]) { case 0xe4: rc = target_xcopy_parse_tiddesc_e4(se_cmd, xop, &desc[0], cscd_index); if (rc != 0) goto out; start += XCOPY_TARGET_DESC_LEN; desc += XCOPY_TARGET_DESC_LEN; cscd_index++; break; default: pr_err(""XCOPY unsupported descriptor type code:"" "" 0x%02x\n"", desc[0]); *sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE; goto out; } } switch (xop->op_origin) { case XCOL_SOURCE_RECV_OP: rc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn, &xop->dst_dev); break; case XCOL_DEST_RECV_OP: rc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn, &xop->src_dev); break; default: pr_err(""XCOPY CSCD descriptor IDs not found in CSCD list - "" ""stdi: %hu dtdi: %hu\n"", xop->stdi, xop->dtdi); rc = -EINVAL; break; } if (rc < 0) { *sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE; goto out; } pr_debug(""XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n"", xop->src_dev, &xop->src_tid_wwn[0]); pr_debug(""XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\n"", xop->dst_dev, &xop->dst_tid_wwn[0]); return cscd_index; out: return -EINVAL; }"
"static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs) { struct pfkey_sock *pfk = pfkey_sk(sk); struct sk_buff *supp_skb; if (hdr->sadb_msg_satype > SADB_SATYPE_MAX) return -EINVAL; if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) { if (pfk->registered&(1<<hdr->sadb_msg_satype)) return -EEXIST; pfk->registered |= (1<<hdr->sadb_msg_satype); } xfrm_probe_algs(); supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO); if (!supp_skb) { if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) pfk->registered &= ~(1<<hdr->sadb_msg_satype); return -ENOBUFS; } pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)); return 0; }"
"TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode, unsigned long key1, unsigned long key2, uint32_t *state) { TEE_Result res; struct tee_cryp_state *cs; struct tee_ta_session *sess; struct tee_obj *o1 = NULL; struct tee_obj *o2 = NULL; struct user_ta_ctx *utc; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; utc = to_user_ta_ctx(sess->ctx); if (key1 != 0) { res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1); if (res != TEE_SUCCESS) return res; if (o1->busy) return TEE_ERROR_BAD_PARAMETERS; res = tee_svc_cryp_check_key_type(o1, algo, mode); if (res != TEE_SUCCESS) return res; } if (key2 != 0) { res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2); if (res != TEE_SUCCESS) return res; if (o2->busy) return TEE_ERROR_BAD_PARAMETERS; res = tee_svc_cryp_check_key_type(o2, algo, mode); if (res != TEE_SUCCESS) return res; } cs = calloc(1, sizeof(struct tee_cryp_state)); if (!cs) return TEE_ERROR_OUT_OF_MEMORY; TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link); cs->algo = algo; cs->mode = mode; switch (TEE_ALG_GET_CLASS(algo)) { case TEE_OPERATION_CIPHER: if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) || (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_cipher_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_AE: if (key1 == 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { } break; case TEE_OPERATION_MAC: if (key1 == 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_mac_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_DIGEST: if (key1 != 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_hash_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_ASYMMETRIC_CIPHER: case TEE_OPERATION_ASYMMETRIC_SIGNATURE: if (key1 == 0 || key2 != 0) res = TEE_ERROR_BAD_PARAMETERS; break; case TEE_OPERATION_KEY_DERIVATION: if (key1 == 0 || key2 != 0) res = TEE_ERROR_BAD_PARAMETERS; break; default: res = TEE_ERROR_NOT_SUPPORTED; break; } if (res != TEE_SUCCESS) goto out; res = tee_svc_copy_kaddr_to_uref(state, cs); if (res != TEE_SUCCESS) goto out; if (o1 != NULL) { o1->busy = true; cs->key1 = (vaddr_t)o1; } if (o2 != NULL) { o2->busy = true; cs->key2 = (vaddr_t)o2; } out: if (res != TEE_SUCCESS) cryp_state_free(utc, cs); return res; }"
"int cmnd_matches(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info) { struct alias *a; struct sudo_command *c; int rc, matched = UNSPEC; debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH); switch (m->type) { case ALL: case COMMAND: c = (struct sudo_command *)m->name; if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests)) matched = m->negated ? DENY : ALLOW; break; case ALIAS: a = alias_get(parse_tree, m->name, CMNDALIAS); if (a != NULL) { rc = cmndlist_matches(parse_tree, &a->members, runchroot, info); if (rc != UNSPEC) { if (m->negated) { matched = rc == ALLOW ? DENY : ALLOW; } else { matched = rc; } } alias_put(a); } break; } debug_return_int(matched); }"
static inline int z_vrfy_gpio_get_pending_int(struct device *dev) { return z_impl_gpio_get_pending_int((struct device *)dev); }
"tcpr_dir_t macinstring(const char *macstring, const u_char *mac) { char *tok = NULL, *tempstr, *ourstring; u_char tempmac[6]; int len = 6, ret = TCPR_DIR_S2C; ourstring = safe_strdup(macstring); memset(&tempmac[0], 0, sizeof(tempmac)); tempstr = strtok_r(ourstring, "","", &tok); if (strlen(tempstr)) { mac2hex(tempstr, tempmac, len); if (memcmp(mac, tempmac, len) == 0) { dbgx(3, ""Packet matches: "" MAC_FORMAT "" sending out primary.\n"", MAC_STR(tempmac)); ret = TCPR_DIR_C2S; goto EXIT_MACINSTRING; } } else { goto EXIT_MACINSTRING; } while ((tempstr = strtok_r(NULL, "","", &tok)) != NULL) { mac2hex(tempstr, tempmac, len); if (memcmp(mac, tempmac, len) == 0) { ret = TCPR_DIR_C2S; dbgx(3, ""Packet matches: "" MAC_FORMAT "" sending out primary.\n"", MAC_STR(tempmac)); goto EXIT_MACINSTRING; } } EXIT_MACINSTRING: safe_free(ourstring); #ifdef DEBUG if (ret == TCPR_DIR_S2C) dbg(3, ""Packet doesn't match any MAC addresses sending out secondary.\n""); #endif return ret; }"
"static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) { st64 res = 0; int i; for (i = 0; i < n; i++) { int j; int m = 1; int tsize = 2; bool bigendian = true; for (j = 0; fmt[j]; j++) { switch (fmt[j]) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (m == 1) { m = r_num_get (NULL, &fmt[j]); } continue; case 's': tsize = 2; bigendian = false; break; case 'S': tsize = 2; bigendian = true; break; case 'i': tsize = 4; bigendian = false; break; case 'I': tsize = 4; bigendian = true; break; case 'l': tsize = 8; bigendian = false; break; case 'L': tsize = 8; bigendian = true; break; case 'c': tsize = 1; bigendian = false; break; default: return -1; } int k; for (k = 0; k < m; k++) { ut8 tmp[sizeof (ut64)]; ut8 d1; ut16 d2; ut32 d3; ut64 d4; st64 r = r_buf_read (src, tmp, tsize); if (r < tsize) { return -1; } switch (tsize) { case 1: d1 = r_read_ble8 (tmp); r = r_buf_write (dst, (ut8 *)&d1, 1); break; case 2: d2 = r_read_ble16 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d2, 2); break; case 4: d3 = r_read_ble32 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d3, 4); break; case 8: d4 = r_read_ble64 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d4, 8); break; } if (r < 0) { return -1; } res += r; } m = 1; } } return res; }"
"static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))  return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int istart = 0, iend, n, nsiz; Jsi_Number nstart = 0, nend = 0;     Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1), *end = Jsi_ValueArrayIndex(interp, args, 2); Jsi_Obj *obj = _this->d.obj; n = jsi_SizeOfArray(interp, obj); if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (n == 0) { goto bail; } iend = n-1; if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) { iend = (int) nend; if (iend >= n) iend = n-1; if (iend < 0) iend = (n+iend); if (iend<0) goto bail; } nsiz = iend-istart+1; if (nsiz<=0) goto bail; int i; for (i = istart; i <= iend; i++) { if (obj->arr[i]) Jsi_ValueCopy(interp, obj->arr[i], value); else obj->arr[i] = Jsi_ValueDup(interp, value); } bail: if (_this != *ret) Jsi_ValueMove(interp, *ret, _this); return rc; }"
"static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des) { char *link_name = NULL; int res; link_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1); link_name[file_hdr->c_filesize] = '\0'; tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize); tape_skip_padding(in_file_des, file_hdr->c_filesize); res = symlink(link_name, file_hdr->c_name); if (res < 0) { fprintf(stderr, ""%s: symlink %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); free(link_name); return; } if ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0) && errno != EPERM) { fprintf(stderr, ""%s: lchown %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); } free(link_name); }"
"void SFS_ArrayDeref(ScriptParser *parser) { if (parser->codec->LastError) return; SFS_Expression(parser); SFS_AddString(parser, ""[""); SFS_CompoundExpression(parser); SFS_AddString(parser, ""]""); }"
"void Server_message(Server *self, char * format, ...) { if (self->verbosity & 2) { char buffer[256]; va_list args; va_start (args, format); vsprintf (buffer, format, args); va_end (args); PySys_WriteStdout(""Pyo message: %s"", buffer); } }"
"static response vg_lookup(lvmetad_state *s, request r) { struct dm_config_tree *cft; struct dm_config_node *metadata, *n; struct vg_info *info; response res = { 0 }; const char *uuid = daemon_request_str(r, ""uuid"", NULL); const char *name = daemon_request_str(r, ""name"", NULL); int count = 0; buffer_init( &res.buffer ); if (!uuid && !name) { ERROR(s, ""vg_lookup with no uuid or name""); return reply_unknown(""VG not found""); } else if (!uuid || !name) { DEBUGLOG(s, ""vg_lookup vgid %s name %s needs lookup"", uuid ?: ""none"", name ?: ""none""); if (name && !uuid) uuid = dm_hash_lookup_with_count(s->vgname_to_vgid, name, &count); else if (uuid && !name) name = dm_hash_lookup(s->vgid_to_vgname, uuid); if (name && uuid && (count > 1)) { DEBUGLOG(s, ""vg_lookup name %s vgid %s found %d vgids"", name, uuid, count); return daemon_reply_simple(""multiple"", ""reason = %s"", ""Multiple VGs found with same name"", NULL); } if (!uuid || !name) return reply_unknown(""VG not found""); } else { char *name_lookup = dm_hash_lookup(s->vgid_to_vgname, uuid); char *uuid_lookup = dm_hash_lookup_with_val(s->vgname_to_vgid, name, uuid, strlen(uuid) + 1); if (!name_lookup || !uuid_lookup) { ERROR(s, ""vg_lookup vgid %s name %s found incomplete mapping uuid %s name %s"", uuid, name, uuid_lookup ?: ""none"", name_lookup ?: ""none""); return reply_unknown(""VG mapping incomplete""); } else if (strcmp(name_lookup, name) || strcmp(uuid_lookup, uuid)) { ERROR(s, ""vg_lookup vgid %s name %s found inconsistent mapping uuid %s name %s"", uuid, name, uuid_lookup, name_lookup); return reply_unknown(""VG mapping inconsistent""); } } DEBUGLOG(s, ""vg_lookup vgid %s name %s"", uuid ?: ""none"", name ?: ""none""); cft = dm_hash_lookup(s->vgid_to_metadata, uuid); if (!cft || !cft->root) { return reply_unknown(""UUID not found""); } metadata = cft->root; if (!(res.cft = dm_config_create())) goto nomem_un; if (!(res.cft->root = n = dm_config_create_node(res.cft, ""response""))) goto nomem_un; if (!(n->v = dm_config_create_value(cft))) goto nomem_un; n->parent = res.cft->root; n->v->type = DM_CFG_STRING; n->v->v.str = ""OK""; if (!(n = n->sib = dm_config_create_node(res.cft, ""name""))) goto nomem_un; if (!(n->v = dm_config_create_value(res.cft))) goto nomem_un; n->parent = res.cft->root; n->v->type = DM_CFG_STRING; n->v->v.str = name; if (!(n = n->sib = dm_config_clone_node(res.cft, metadata, 1))) goto nomem_un; n->parent = res.cft->root; if (!update_pv_status(s, res.cft, n)) goto nomem; chain_outdated_pvs(s, uuid, res.cft, n); if (s->flags & GLFL_INVALID) add_last_node(res.cft, ""global_invalid""); info = dm_hash_lookup(s->vgid_to_info, uuid); if (info && (info->flags & VGFL_INVALID)) { if (!add_last_node(res.cft, ""vg_invalid"")) goto nomem; } return res; nomem_un: nomem: reply_fail(""out of memory""); ERROR(s, ""vg_lookup vgid %s name %s out of memory."", uuid ?: ""none"", name ?: ""none""); ERROR(s, ""lvmetad could not be updated and is aborting.""); exit(EXIT_FAILURE); }"
"static bool perf_event_validate_size(struct perf_event *event) { __perf_event_read_size(event, event->group_leader->nr_siblings + 1); __perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ); perf_event__id_header_size(event); if (event->read_size + event->header_size + event->id_header_size + sizeof(struct perf_event_header) >= 16*1024) return false; return true; }"
"static Uint8 * Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod, SDL_PixelFormat * dst) { Uint8 *map; int i; int bpp; SDL_Palette *pal = src->palette; bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel); map = (Uint8 *) SDL_malloc(pal->ncolors * bpp); if (map == NULL) { SDL_OutOfMemory(); return (NULL); } for (i = 0; i < pal->ncolors; ++i) { Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255); Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255); Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255); Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255); ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A); } return (map); }"
"Handle<JSObject> createHermesInternalObject( Runtime &runtime, const JSLibFlags &flags) { namespace P = Predefined; Handle<JSObject> intern = runtime.makeHandle(JSObject::create(runtime)); GCScope gcScope{runtime}; DefinePropertyFlags constantDPF = DefinePropertyFlags::getDefaultNewPropertyFlags(); constantDPF.enumerable = 0; constantDPF.writable = 0; constantDPF.configurable = 0; auto defineInternMethod = [&](Predefined::Str symID, NativeFunctionPtr func, uint8_t count = 0) { (void)defineMethod( runtime, intern, Predefined::getSymbolID(symID), nullptr , func, count, constantDPF); }; auto defineInternMethodAndSymbol = [&](const char *name, NativeFunctionPtr func, uint8_t count = 0) { ASCIIRef ref = createASCIIRef(name); Handle<SymbolID> symHandle = runtime.ignoreAllocationFailure( runtime.getIdentifierTable().getSymbolHandle(runtime, ref)); (void)defineMethod( runtime, intern, *symHandle, nullptr , func, count, constantDPF); }; (void)defineInternMethodAndSymbol; auto propRes = JSObject::getNamed_RJS( runtime.makeHandle<JSObject>(runtime.stringPrototype), runtime, Predefined::getSymbolID(Predefined::concat)); assert( propRes != ExecutionStatus::EXCEPTION && !(*propRes)->isUndefined() && ""Failed to get String.prototype.concat.""); auto putRes = JSObject::defineOwnProperty( intern, runtime, Predefined::getSymbolID(Predefined::concat), constantDPF, runtime.makeHandle(std::move(*propRes))); assert( putRes != ExecutionStatus::EXCEPTION && *putRes && ""Failed to set HermesInternal.concat.""); (void)putRes; defineInternMethod(P::hasPromise, hermesInternalHasPromise); defineInternMethod(P::enqueueJob, hermesInternalEnqueueJob); defineInternMethod( P::setPromiseRejectionTrackingHook, hermesInternalSetPromiseRejectionTrackingHook); defineInternMethod( P::enablePromiseRejectionTracker, hermesInternalEnablePromiseRejectionTracker); defineInternMethod(P::useEngineQueue, hermesInternalUseEngineQueue); #ifdef HERMES_ENABLE_FUZZILLI defineInternMethod(P::fuzzilli, hermesInternalFuzzilli); #endif if (!flags.enableHermesInternal) { JSObject::preventExtensions(*intern); return intern; } defineInternMethod(P::getEpilogues, hermesInternalGetEpilogues); defineInternMethod( P::getInstrumentedStats, hermesInternalGetInstrumentedStats); defineInternMethod( P::getRuntimeProperties, hermesInternalGetRuntimeProperties); defineInternMethod(P::ttiReached, hermesInternalTTIReached); defineInternMethod(P::ttrcReached, hermesInternalTTRCReached); defineInternMethod(P::getFunctionLocation, hermesInternalGetFunctionLocation); if (flags.enableHermesInternalTestMethods) { defineInternMethod( P::detachArrayBuffer, hermesInternalDetachArrayBuffer, 1); defineInternMethod(P::getWeakSize, hermesInternalGetWeakSize); defineInternMethod( P::copyDataProperties, hermesBuiltinCopyDataProperties, 3); defineInternMethodAndSymbol(""isProxy"", hermesInternalIsProxy); defineInternMethod(P::drainJobs, hermesInternalDrainJobs); } #ifdef HERMESVM_EXCEPTION_ON_OOM defineInternMethodAndSymbol(""getCallStack"", hermesInternalGetCallStack, 0); #endif  JSObject::preventExtensions(*intern); return intern; }"
"void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity, size_t TSize) { if (MinCapacity > UINT32_MAX) report_bad_alloc_error(""SmallVector capacity overflow during allocation""); size_t NewCapacity = 2 * capacity() + 1;   NewCapacity = std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX)); void *NewElts; if (BeginX == FirstEl) { NewElts = safe_malloc(NewCapacity * TSize); memcpy(NewElts, this->BeginX, size() * TSize); } else { NewElts = safe_realloc(this->BeginX, NewCapacity * TSize); } this->BeginX = NewElts; this->Capacity = NewCapacity; }"
"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf) { DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         int     outlen = sizeof(Jp2BoxHeader) ;         int      inlen = sizeof(Jp2BoxHeader) ;         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_; int32_t       length = getLong((byte*)&pBox->length, bigEndian); int32_t       count  = sizeof (Jp2BoxHeader); char*         p      = (char*) boxBuf.pData_; bool          bWroteColor = false ; while ( count < length || !bWroteColor ) { Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ; Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox)); Jp2BoxHeader   newBox =  subBox; if ( count < length ) { subBox.length = getLong((byte*)&subBox.length, bigEndian); subBox.type   = getLong((byte*)&subBox.type  , bigEndian); #ifdef EXIV2_DEBUG_MESSAGES std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl; #endif count        += subBox.length; newBox.type   = subBox.type; } else { subBox.length=0; newBox.type = kJp2BoxTypeColorHeader; count = length; } int32_t newlen = subBox.length; if ( newBox.type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined() ) { const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid""; uint32_t    psize = 15; newlen            = sizeof(newBox) + psize ; ul2Data((byte*)&newBox.length,psize      ,bigEndian); ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)); ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         ); } else { const char* pad   = ""\x02\x00\x00""; uint32_t    psize = 3; newlen            = sizeof(newBox) + psize + iccProfile_.size_; ul2Data((byte*)&newBox.length,newlen,bigEndian); ul2Data((byte*)&newBox.type,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  ); ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           ); ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_); } } else { ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length); } outlen += newlen; inlen  += subBox.length; } outBuf.alloc(outlen); ::memcpy(outBuf.pData_,output.pData_,outlen); pBox   = (Jp2BoxHeader*) outBuf.pData_; ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian); ul2Data((byte*)&pBox->length,outlen,bigEndian); }"
"static int var_files_tmp_contents_generate(modsec_rec *msr, msre_var *var, msre_rule *rule, apr_table_t *vartab, apr_pool_t *mptmp) { multipart_part **parts = NULL; int i, count = 0; if (msr->mpd == NULL) return 0; parts = (multipart_part **)msr->mpd->parts->elts; for (i = 0; i < msr->mpd->parts->nelts; i++) { if ((parts[i]->type == MULTIPART_FILE) && (parts[i]->tmp_file_name != NULL)) { int match = 0; if (var->param == NULL) { match = 1; } else { if (var->param_data != NULL) { char *my_error_msg = NULL; if (!(msc_regexec((msc_regex_t *)var->param_data, parts[i]->name, strlen(parts[i]->name), &my_error_msg) == PCRE_ERROR_NOMATCH))  { match = 1; } } else { if (strcasecmp(parts[i]->name, var->param) == 0) { match = 1; } } } if (match) { char buf[1024]; FILE *file; size_t nread; char *full_content = NULL; size_t total_lenght = 0; msre_var *rvar = NULL; file = fopen(parts[i]->tmp_file_name, ""r""); if (file == NULL) { continue; } while ((nread = fread(buf, 1, 1023, file)) > 0) {    total_lenght += nread; buf[nread] = '\0'; if (full_content == NULL) { full_content = apr_psprintf(mptmp, ""%s"", buf); } else { full_content = apr_psprintf(mptmp, ""%s%s"", full_content, buf); } } fclose(file); rvar = apr_pmemdup(mptmp, var, sizeof(msre_var)); rvar->value = full_content; rvar->value_len = total_lenght; rvar->name = apr_psprintf(mptmp, ""FILES_TMP_CONTENT:%s"", log_escape_nq(mptmp, parts[i]->name)); apr_table_addn(vartab, rvar->name, (void *)rvar); count++; } } } return count; }"
"void vhost_backend_cleanup(struct virtio_net *dev) { if (dev->mem) { free_mem_region(dev); rte_free(dev->mem); dev->mem = NULL; } free(dev->guest_pages); dev->guest_pages = NULL; if (dev->log_addr) { munmap((void *)(uintptr_t)dev->log_addr, dev->log_size); dev->log_addr = 0; } if (dev->slave_req_fd >= 0) { close(dev->slave_req_fd); dev->slave_req_fd = -1; } if (dev->postcopy_ufd >= 0) { close(dev->postcopy_ufd); dev->postcopy_ufd = -1; } dev->postcopy_listening = 0; }"
"static gboolean blf_read_apptextmessage(blf_params_t *params, int *err, gchar **err_info, gint64 block_start, gint64 data_start, gint64 object_length, guint64 timestamp _U_) { blf_apptext_t            apptextheader; if (object_length < (data_start - block_start) + (int)sizeof(apptextheader)) { *err = WTAP_ERR_BAD_FILE; *err_info = ws_strdup_printf(""blf: APP_TEXT: not enough bytes for apptext header in object""); ws_debug(""not enough bytes for apptext header in object""); return FALSE; } if (!blf_read_bytes(params, data_start, &apptextheader, sizeof(apptextheader), err, err_info)) { ws_debug(""not enough bytes for apptext header in file""); return FALSE; } fix_endianness_blf_apptext_header(&apptextheader); if (apptextheader.source != BLF_APPTEXT_CHANNEL) { return TRUE; } gchar *text = g_try_malloc0((gsize)apptextheader.textLength); if (!blf_read_bytes(params, data_start + sizeof(apptextheader), text, apptextheader.textLength, err, err_info)) { ws_debug(""not enough bytes for apptext text in file""); g_free(text); return FALSE; } gchar **tokens = g_strsplit_set(text, "";"", -1); if ( tokens == NULL || tokens[0] == NULL || tokens[1] == NULL) { if (tokens != NULL) { g_strfreev(tokens); } g_free(text); return TRUE; } guint32 channel = (apptextheader.reservedAppText1 >> 8) & 0xff; int pkt_encap; switch ((apptextheader.reservedAppText1 >> 16) & 0xff) { case BLF_BUSTYPE_CAN: pkt_encap = WTAP_ENCAP_SOCKETCAN; break; case BLF_BUSTYPE_FLEXRAY: pkt_encap = WTAP_ENCAP_FLEXRAY; break; case BLF_BUSTYPE_LIN: pkt_encap = WTAP_ENCAP_LIN; break; case BLF_BUSTYPE_ETHERNET: pkt_encap = WTAP_ENCAP_ETHERNET; break; case BLF_BUSTYPE_WLAN: pkt_encap = WTAP_ENCAP_IEEE_802_11; break; default: pkt_encap = 0xffffffff; } blf_lookup_interface(params, pkt_encap, channel, tokens[1]); g_strfreev(tokens); g_free(text); return TRUE; }"
"static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer) { struct bfq_data *bfqd = container_of(timer, struct bfq_data, idle_slice_timer); struct bfq_queue *bfqq = bfqd->in_service_queue; if (bfqq) bfq_idle_slice_timer_body(bfqq); return HRTIMER_NORESTART; }"
"struct bignum *crypto_bignum_allocate(size_t size_bits) { size_t sz = mpa_StaticVarSizeInU32(size_bits) *sizeof(uint32_t); struct mpa_numbase_struct *bn = calloc(1, sz); if (!bn) return NULL; bn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t); return (struct bignum *)bn; }"
"inline void BinaryBroadcastFiveFold(const ArithmeticParams& unswitched_params, const RuntimeShape& unswitched_input1_shape, const T* unswitched_input1_data, const RuntimeShape& unswitched_input2_shape, const T* unswitched_input2_data, const RuntimeShape& output_shape, T* output_data, ElementwiseF elementwise_f, ScalarBroadcastF scalar_broadcast_f) { ArithmeticParams switched_params = unswitched_params; switched_params.input1_offset = unswitched_params.input2_offset; switched_params.input1_multiplier = unswitched_params.input2_multiplier; switched_params.input1_shift = unswitched_params.input2_shift; switched_params.input2_offset = unswitched_params.input1_offset; switched_params.input2_multiplier = unswitched_params.input1_multiplier; switched_params.input2_shift = unswitched_params.input1_shift; const bool use_unswitched = unswitched_params.broadcast_category == tflite::BroadcastableOpCategory::kFirstInputBroadcastsFast; const ArithmeticParams& params = use_unswitched ? unswitched_params : switched_params; const T* input1_data = use_unswitched ? unswitched_input1_data : unswitched_input2_data; const T* input2_data = use_unswitched ? unswitched_input2_data : unswitched_input1_data; T* output_data_ptr = output_data; const T* input1_data_ptr = input1_data; const T* input2_data_reset = input2_data; int y0 = params.broadcast_shape[0]; int y1 = params.broadcast_shape[1]; int y2 = params.broadcast_shape[2]; int y3 = params.broadcast_shape[3]; int y4 = params.broadcast_shape[4]; if (y4 > 1) { for (int i0 = 0; i0 < y0; ++i0) { const T* input2_data_ptr = nullptr; for (int i1 = 0; i1 < y1; ++i1) { input2_data_ptr = input2_data_reset; for (int i2 = 0; i2 < y2; ++i2) { for (int i3 = 0; i3 < y3; ++i3) { elementwise_f(y4, params, input1_data_ptr, input2_data_ptr, output_data_ptr); input2_data_ptr += y4; output_data_ptr += y4; } input1_data_ptr += y4; } } input2_data_reset = input2_data_ptr; } } else { for (int i0 = 0; i0 < y0; ++i0) { const T* input2_data_ptr = nullptr; for (int i1 = 0; i1 < y1; ++i1) { input2_data_ptr = input2_data_reset; for (int i2 = 0; i2 < y2; ++i2) { scalar_broadcast_f(y3, params, *input1_data_ptr, input2_data_ptr, output_data_ptr); input2_data_ptr += y3; output_data_ptr += y3; input1_data_ptr += 1; } } input2_data_reset = input2_data_ptr; } } }"
"int tee_shm_get_fd(struct tee_shm *shm) { int fd; if (!(shm->flags & TEE_SHM_DMA_BUF)) return -EINVAL; get_dma_buf(shm->dmabuf); fd = dma_buf_fd(shm->dmabuf, O_CLOEXEC); if (fd < 0) dma_buf_put(shm->dmabuf); return fd; }"
"struct error_obj run_pam_auth(const char *username, char *password) { struct pam_response *reply = malloc(sizeof(struct pam_response)); if (reply == NULL) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""malloc""; ret_val.error_msg = ""Out of memory""; return ret_val; } reply->resp = password; reply->resp_retcode = 0; const struct pam_conv local_conv = { conv_func, reply }; pam_handle_t *local_auth = NULL; int status = pam_start(""maddy"", username, &local_conv, &local_auth); if (status != PAM_SUCCESS) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""pam_start""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK); if (status != PAM_SUCCESS) { struct error_obj ret_val; if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) { ret_val.status = 1; } else { ret_val.status = 2; } ret_val.func_name = ""pam_authenticate""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } status = pam_end(local_auth, status); if (status != PAM_SUCCESS) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""pam_end""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } struct error_obj ret_val; ret_val.status = 0; ret_val.func_name = NULL; ret_val.error_msg = NULL; return ret_val; }"
"void svhandler_flash_pgm_word(void) { uint32_t dst = _param_1; uint32_t src = _param_2; if ((dst >= BSTRP_FLASH_SECT_START) && (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) { return; } if ((dst >= BLDR_FLASH_SECT_START) && (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) { return; } flash_clear_status_flags(); flash_unlock(); flash_program_word(dst, src); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }"
"int nfc_dep_link_down(struct nfc_dev *dev) { int rc = 0; pr_debug(""dev_name=%s\n"", dev_name(&dev->dev)); if (!dev->ops->dep_link_down) return -EOPNOTSUPP; device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (dev->dep_link_up == false) { rc = -EALREADY; goto error; } rc = dev->ops->dep_link_down(dev); if (!rc) { dev->dep_link_up = false; dev->active_target = NULL; dev->rf_mode = NFC_RF_NONE; nfc_llcp_mac_is_down(dev); nfc_genl_dep_link_down_event(dev); } error: device_unlock(&dev->dev); return rc; }"
void Filter::onUpstreamEvent(Network::ConnectionEvent event) { bool connecting = connecting_; connecting_ = false; if (event == Network::ConnectionEvent::RemoteClose || event == Network::ConnectionEvent::LocalClose) { upstream_.reset(); disableIdleTimer(); if (connecting) { if (event == Network::ConnectionEvent::RemoteClose) { getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure); read_callbacks_->upstreamHost()->outlierDetector().putResult( Upstream::Outlier::Result::LocalOriginConnectFailed); } initializeUpstreamConnection(); } else { if (read_callbacks_->connection().state() == Network::Connection::State::Open) { read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite); } } } }
"void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) { minify = dominify; if (prog->type == AST_LIST) pstmlist(-1, prog); else { pstm(0, prog); nl(); } if (minify > 1) putchar('\n'); }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { squashfs_dir_header_2 dirh; char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; long long start; int bytes = 0; int dir_count, size, res; struct dir_ent *ent, *cur_ent = NULL; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) MEM_ERROR(); dir->dir_count = 0; dir->cur_entry = NULL; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 0) return dir; start = sBlk.s.directory_table_start + (*i)->start; offset = (*i)->offset; size = (*i)->data + bytes; while(bytes < size) { if(swap) { squashfs_dir_header_2 sdirh; res = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh)); if(res) SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); } else res = read_directory_data(&dirh, &start, &offset, sizeof(dirh)); if(res == FALSE) goto corrupted; dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { if(swap) { squashfs_dir_entry_2 sdire; res = read_directory_data(&sdire, &start, &offset, sizeof(sdire)); if(res) SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); } else res = read_directory_data(dire, &start, &offset, sizeof(*dire)); if(res == FALSE) goto corrupted; bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } res = read_directory_data(dire->name, &start, &offset, dire->size + 1); if(res == FALSE) goto corrupted; dire->name[dire->size + 1] = '\0'; if(check_name(dire->name, dire->size + 1) == FALSE) { ERROR(""File system corrupted: invalid characters in name\n""); goto corrupted; } TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); ent = malloc(sizeof(struct dir_ent)); if(ent == NULL) MEM_ERROR(); ent->name = strdup(dire->name); ent->start_block = dirh.start_block; ent->offset = dire->offset; ent->type = dire->type; ent->next = NULL; if(cur_ent == NULL) dir->dirs = ent; else cur_ent->next = ent; cur_ent = ent; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: squashfs_closedir(dir); return NULL; }"
"void SSH_init(PTInstVar pvar) { int i; buf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen); buf_create(&pvar->ssh_state.precompress_outbuf, &pvar->ssh_state.precompress_outbuflen); buf_create(&pvar->ssh_state.postdecompress_inbuf, &pvar->ssh_state.postdecompress_inbuflen); pvar->ssh_state.payload = NULL; pvar->ssh_state.compressing = FALSE; pvar->ssh_state.decompressing = FALSE; pvar->ssh_state.status_flags = STATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS; pvar->ssh_state.payload_datalen = 0; pvar->ssh_state.hostname = NULL; pvar->ssh_state.server_ID = NULL; pvar->ssh_state.receiver_sequence_number = 0; pvar->ssh_state.sender_sequence_number = 0; for (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) { pvar->ssh_state.packet_handlers[i] = NULL; } memset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys)); pvar->userauth_success = 0; pvar->shell_id = SSH_CHANNEL_INVALID; pvar->session_nego_status = 0; pvar->settings.ssh_protocol_version = 2;  pvar->kex_status = 0; pvar->ssh2_autologin = 0;  pvar->ask4passwd = 0; pvar->userauth_retry_count = 0; pvar->decomp_buffer = NULL; pvar->authbanner_buffer = NULL; pvar->ssh2_authlist = NULL; pvar->tryed_ssh2_authlist = FALSE; pvar->agentfwd_enable = FALSE; pvar->use_subsystem = FALSE; pvar->nosession = FALSE; pvar->server_sig_algs = NULL; }"
"void IdentifierHashTable::growAndRehash(uint32_t newCapacity) { assert(llvh::isPowerOf2_32(newCapacity) && ""capacity must be power of 2""); CompactTable tmpTable(newCapacity, table_.getCurrentScale()); tmpTable.swap(table_); for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) { if (!tmpTable.isValid(oldIdx)) { continue; } uint32_t idx = 0; uint32_t oldVal = tmpTable.get(oldIdx); auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal); uint32_t hash = lookupTableEntry.getHash(); if (lookupTableEntry.isStringPrim()) { idx = lookupString(lookupTableEntry.getStringPrim(), hash, true); } else if (lookupTableEntry.isLazyASCII()) { idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true); } else if (lookupTableEntry.isLazyUTF16()) { idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true); } table_.set(idx, oldVal); } nonEmptyEntryCount_ = size_; }"
"void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev) { int i; struct kvm_io_bus *new_bus, *bus; bus = kvm_get_bus(kvm, bus_idx); if (!bus) return; for (i = 0; i < bus->dev_count; i++) if (bus->range[i].dev == dev) { break; } if (i == bus->dev_count) return; new_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1), GFP_KERNEL_ACCOUNT); if (!new_bus)  { pr_err(""kvm: failed to shrink bus, removing it completely\n""); goto broken; } memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range)); new_bus->dev_count--; memcpy(new_bus->range + i, bus->range + i + 1, (new_bus->dev_count - i) * sizeof(struct kvm_io_range)); broken: rcu_assign_pointer(kvm->buses[bus_idx], new_bus); synchronize_srcu_expedited(&kvm->srcu); kfree(bus); return; }"
"static int x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx, struct x509_verify_chain *chain, char *name) { size_t depth; X509 *last = x509_verify_chain_last(chain); X509 *leaf = x509_verify_chain_leaf(chain); depth = sk_X509_num(chain->certs); if (depth > 0) depth--; if (ctx->chains_count >= ctx->max_chains) return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_CERT_CHAIN_TOO_LONG, 0); if (chain->cert_errors[depth] == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) chain->cert_errors[depth] = X509_V_OK; if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth)) return 0; if ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) == NULL) { return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_OUT_OF_MEM, 0); } if (!x509_verify_cert_valid(ctx, leaf, NULL)) return 0; if (!x509_verify_cert_hostname(ctx, leaf, name)) return 0; ctx->chains_count++; ctx->error = X509_V_OK; ctx->error_depth = depth; return 1; }"
"void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& headers, bool end_stream) { ENVOY_STREAM_LOG(debug, ""request headers complete (end_stream={}):\n{}"", *this, end_stream, *headers); ScopeTrackerScopeState scope(this, connection_manager_.read_callbacks_->connection().dispatcher()); request_headers_ = std::move(headers); filter_manager_.requestHeadersInitialized(); if (request_header_timer_ != nullptr) { request_header_timer_->disableTimer(); request_header_timer_.reset(); } const Protocol protocol = connection_manager_.codec_->protocol(); if (Runtime::runtimeFeatureEnabled( ""envoy.reloadable_features.http1_connection_close_header_in_redirect"")) { if (HeaderUtility::shouldCloseConnection(protocol, *request_headers_)) { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true); } } else { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion( HeaderUtility::shouldCloseConnection(protocol, *request_headers_)); } filter_manager_.streamInfo().protocol(protocol); maybeEndDecode(end_stream); if (!validateHeaders()) { ENVOY_STREAM_LOG(debug, ""request headers validation failed\n{}"", *this, *request_headers_); return; } if (connection_manager_.config_.isRoutable()) { if (connection_manager_.config_.routeConfigProvider() != nullptr) { snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast(); } else if (connection_manager_.config_.scopedRouteConfigProvider() != nullptr && connection_manager_.config_.scopeKeyBuilder().has_value()) { snapped_scoped_routes_config_ = connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>(); snapScopedRouteConfig(); } } else { snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast(); } const bool drop_request_due_to_overload = (connection_manager_.accept_new_http_stream_ != nullptr && connection_manager_.accept_new_http_stream_->shouldShedLoad()) || connection_manager_.random_generator_.bernoulli( connection_manager_.overload_stop_accepting_requests_ref_.value()); if (drop_request_due_to_overload) { filter_manager_.skipFilterChainCreation(); connection_manager_.stats_.named_.downstream_rq_overload_close_.inc(); sendLocalReply(Http::Code::ServiceUnavailable, ""envoy overloaded"", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().Overload); return; } if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() && absl::EqualsIgnoreCase((request_headers_->Expect()->value().getStringView()), Headers::get().ExpectValues._100Continue)) { chargeStats(continueHeader()); response_encoder_->encode1xxHeaders(continueHeader()); request_headers_->removeExpect(); } connection_manager_.user_agent_.initializeFromHeaders(*request_headers_, connection_manager_.stats_.prefixStatName(), connection_manager_.stats_.scope_); if (!request_headers_->Host()) { sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().MissingHost); return; } absl::optional<std::reference_wrapper<const absl::string_view>> error = HeaderUtility::requestHeadersValid(*request_headers_); if (error != absl::nullopt) { sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, error.value().get()); if (!response_encoder_->streamErrorOnInvalidHttpMessage()) { connection_manager_.handleCodecError(error.value().get()); } return; } if ((!HeaderUtility::isConnect(*request_headers_) || request_headers_->Path()) && request_headers_->getPathValue().empty()) { sendLocalReply(Code::NotFound, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().MissingPath); return; } if (Runtime::runtimeFeatureEnabled(""envoy.reloadable_features.enable_connect_udp_support"") && HeaderUtility::isConnectUdpRequest(*request_headers_) && !HeaderUtility::rewriteAuthorityForConnectUdp(*request_headers_)) { sendLocalReply(Code::NotFound, ""The path is incorrect for CONNECT-UDP"", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().InvalidPath); return; } if (!request_headers_->getPathValue().empty() && request_headers_->getPathValue()[0] != '/') { connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc(); sendLocalReply(Code::NotFound, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().AbsolutePath); return; } #ifndef ENVOY_ENABLE_UHV const auto action = ConnectionManagerUtility::maybeNormalizePath(*request_headers_, connection_manager_.config_); if (action == ConnectionManagerUtility::NormalizePathAction::Reject || (action == ConnectionManagerUtility::NormalizePathAction::Redirect && Grpc::Common::hasGrpcContentType(*request_headers_))) { connection_manager_.stats_.named_.downstream_rq_failed_path_normalization_.inc(); sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed); return; } else if (action == ConnectionManagerUtility::NormalizePathAction::Redirect) { connection_manager_.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc(); sendLocalReply( Code::TemporaryRedirect, """", [new_path = request_headers_->Path()->value().getStringView()]( Http::ResponseHeaderMap& response_headers) -> void { response_headers.addReferenceKey(Http::Headers::get().Location, new_path); }, absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed); return; } ASSERT(action == ConnectionManagerUtility::NormalizePathAction::Continue); #endif auto optional_port = ConnectionManagerUtility::maybeNormalizeHost( *request_headers_, connection_manager_.config_, localPort()); if (optional_port.has_value() && requestWasConnect(request_headers_, connection_manager_.codec_->protocol())) { filter_manager_.streamInfo().filterState()->setData( Router::OriginalConnectPort::key(), std::make_unique<Router::OriginalConnectPort>(optional_port.value()), StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request); } if (!state_.is_internally_created_) {         const auto mutate_result = ConnectionManagerUtility::mutateRequestHeaders( *request_headers_, connection_manager_.read_callbacks_->connection(), connection_manager_.config_, *snapped_route_config_, connection_manager_.local_info_, filter_manager_.streamInfo()); if (mutate_result.reject_request.has_value()) { const auto& reject_request_params = mutate_result.reject_request.value(); connection_manager_.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc(); sendLocalReply(reject_request_params.response_code, reject_request_params.body, nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed); return; } filter_manager_.setDownstreamRemoteAddress(mutate_result.final_remote_address); } ASSERT(filter_manager_.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr); ASSERT(!cached_route_); refreshCachedRoute(); if (!state_.is_internally_created_) {     filter_manager_.streamInfo().setTraceReason( ConnectionManagerUtility::mutateTracingRequestHeader( *request_headers_, connection_manager_.runtime_, connection_manager_.config_, cached_route_.value().get())); } filter_manager_.streamInfo().setRequestHeaders(*request_headers_); const bool upgrade_rejected = filter_manager_.createFilterChain() == false; if (connection_manager_.config_.flushAccessLogOnNewRequest()) { filter_manager_.log(AccessLog::AccessLogType::DownstreamStart); } if (hasCachedRoute()) { if (upgrade_rejected) { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true); connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc(); sendLocalReply(Code::Forbidden, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().UpgradeFailed); return; } } if (connection_manager_tracing_config_.has_value()) { traceRequest(); } filter_manager_.decodeHeaders(*request_headers_, end_stream); resetIdleTimer(); }"
"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet, char *buf, u_int8_t client_hash) { u_int16_t offset = 22, buf_out_len = 0; if(offset+sizeof(u_int32_t) >= packet->payload_packet_len) goto invalid_payload; u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]); offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len); buf[buf_out_len++] = ';'; offset += len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; if(offset+sizeof(u_int32_t) >= packet->payload_packet_len) goto invalid_payload; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; offset += len; } else offset += 4 + len; #ifdef SSH_DEBUG printf(""[SSH] %s\n"", buf); #endif return(buf_out_len); invalid_payload: #ifdef SSH_DEBUG printf(""[SSH] Invalid packet payload\n""); #endif return(0); }"
"static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list) { GF_Node *node; GF_Command *com; GF_CommandField *inf; node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode); if (!node) return GF_NON_COMPLIANT_BITSTREAM; if (codec->scenegraph->global_qp) { gf_node_unregister(codec->scenegraph->global_qp, NULL); } codec->ActiveQP = NULL; codec->scenegraph->global_qp = NULL; if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) { gf_node_unregister(node, NULL); return GF_NON_COMPLIANT_BITSTREAM; } codec->ActiveQP = (M_QuantizationParameter *) node; codec->ActiveQP->isLocal = 0; codec->scenegraph->global_qp = node; node->sgprivate->num_instances = 2; com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER); inf = gf_sg_command_field_new(com); inf->new_node = node; inf->field_ptr = &inf->new_node; inf->fieldType = GF_SG_VRML_SFNODE; gf_list_add(com_list, com); return GF_OK; }"
"static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer) { struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer); struct bcm_msg_head msg_head; if (op->kt_ival1 && (op->count > 0)) { op->count--; if (!op->count && (op->flags & TX_COUNTEVT)) { msg_head.opcode  = TX_EXPIRED; msg_head.flags   = op->flags; msg_head.count   = op->count; msg_head.ival1   = op->ival1; msg_head.ival2   = op->ival2; msg_head.can_id  = op->can_id; msg_head.nframes = 0; bcm_send_to_user(op, &msg_head, NULL, 0); } bcm_can_tx(op); } else if (op->kt_ival2) { bcm_can_tx(op); } return bcm_tx_set_expiry(op, &op->timer) ? HRTIMER_RESTART : HRTIMER_NORESTART; }"
GF_Err chnl_box_size(GF_Box *s) { GF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s; s->size += 1; if (ptr->layout.stream_structure & 1) { s->size += 1; if (ptr->layout.definedLayout==0) { u32 i; for (i=0; i<ptr->layout.channels_count; i++) { s->size+=1; if (ptr->layout.layouts[i].position==126) s->size+=3; } } else { s->size += 8; } } if (ptr->layout.stream_structure & 2) { s->size += 1; } return GF_OK; }
"void continuous_agg_refresh_internal(const ContinuousAgg *cagg, const InternalTimeRange *refresh_window_arg, const CaggRefreshCallContext callctx, const bool start_isnull, const bool end_isnull) { Catalog *catalog = ts_catalog_get(); int32 mat_id = cagg->data.mat_hypertable_id; InternalTimeRange refresh_window = *refresh_window_arg; int64 computed_invalidation_threshold; int64 invalidation_threshold; bool is_raw_ht_distributed; int rc; if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT)) elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc)); if (!pg_class_ownercheck(cagg->relid, GetUserId())) aclcheck_error(ACLCHECK_NOT_OWNER, get_relkind_objtype(get_rel_relkind(cagg->relid)), get_rel_name(cagg->relid)); PreventCommandIfReadOnly(REFRESH_FUNCTION_NAME); PreventInTransactionBlock(true, REFRESH_FUNCTION_NAME); Hypertable *ht = cagg_get_hypertable_or_fail(cagg->data.raw_hypertable_id); is_raw_ht_distributed = hypertable_is_distributed(ht); if (!(start_isnull && end_isnull)) { if (ts_continuous_agg_bucket_width_variable(cagg)) { refresh_window = *refresh_window_arg; ts_compute_inscribed_bucketed_refresh_window_variable(&refresh_window.start, &refresh_window.end, cagg->bucket_function); } else { refresh_window = compute_inscribed_bucketed_refresh_window(refresh_window_arg, ts_continuous_agg_bucket_width(cagg)); } } if (refresh_window.start >= refresh_window.end) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""refresh window too small""), errdetail(""The refresh window must cover at least one bucket of data.""), errhint(""Align the refresh window with the bucket"" "" time zone or use at least two buckets.""))); log_refresh_window(callctx == CAGG_REFRESH_POLICY ? LOG : DEBUG1, cagg, &refresh_window, ""refreshing continuous aggregate""); LockRelationOid(catalog_get_table_id(catalog, CONTINUOUS_AGGS_INVALIDATION_THRESHOLD), AccessExclusiveLock); computed_invalidation_threshold = invalidation_threshold_compute(cagg, &refresh_window); invalidation_threshold = invalidation_threshold_set_or_get(cagg->data.raw_hypertable_id, computed_invalidation_threshold); if (refresh_window.end > invalidation_threshold) refresh_window.end = invalidation_threshold; if (refresh_window.start >= refresh_window.end) { emit_up_to_date_notice(cagg, callctx); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); return; } const CaggsInfo all_caggs_info = ts_continuous_agg_get_all_caggs_info(cagg->data.raw_hypertable_id); if (is_raw_ht_distributed) { remote_invalidation_process_hypertable_log(cagg->data.mat_hypertable_id, cagg->data.raw_hypertable_id, refresh_window.type, &all_caggs_info); } else { invalidation_process_hypertable_log(cagg->data.mat_hypertable_id, cagg->data.raw_hypertable_id, refresh_window.type, &all_caggs_info); } SPI_commit_and_chain(); cagg = ts_continuous_agg_find_by_mat_hypertable_id(mat_id); if (!process_cagg_invalidations_and_refresh(cagg, &refresh_window, callctx, INVALID_CHUNK_ID)) emit_up_to_date_notice(cagg, callctx); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); }"
"mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c) { mp_digit d; mp_err   err; if (a != c) { if ((err = mp_copy(a, c)) != MP_OKAY) { return err; } } if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) { if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } } if (b >= MP_DIGIT_BIT) { if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) { return err; } } d = (mp_digit)(b % MP_DIGIT_BIT); if (d != 0u) { mp_digit *tmpc, shift, mask, r, rr; int x; mask = ((mp_digit)1 << d) - (mp_digit)1; shift = (mp_digit)MP_DIGIT_BIT - d; tmpc = c->dp; r    = 0; for (x = 0; x < c->used; x++) { rr = (*tmpc >> shift) & mask; *tmpc = ((*tmpc << d) | r) & MP_MASK; ++tmpc; r = rr; } if (r != 0u) { c->dp[(c->used)++] = r; } } mp_clamp(c); return MP_OKAY; }"
void zmq::session_base_t::read_activated (pipe_t *pipe_) { if (unlikely (pipe_ != _pipe && pipe_ != _zap_pipe)) { zmq_assert (_terminating_pipes.count (pipe_) == 1); return; } if (unlikely (_engine == NULL)) { _pipe->check_read (); return; } if (likely (pipe_ == _pipe)) _engine->restart_output (); else { _engine->zap_msg_available (); } }
"void Compute(OpKernelContext* context) override { const Tensor& images = context->input(0); const Tensor& boxes = context->input(1); const int64 depth = images.dim_size(3); OP_REQUIRES(context, images.dims() == 4, errors::InvalidArgument(""The rank of the images should be 4"")); OP_REQUIRES( context, boxes.dims() == 3, errors::InvalidArgument(""The rank of the boxes tensor should be 3"")); OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0), errors::InvalidArgument(""The batch sizes should be the same"")); OP_REQUIRES( context, depth == 4 || depth == 1 || depth == 3, errors::InvalidArgument(""Channel depth should be either 1 (GRY), "" ""3 (RGB), or 4 (RGBA)"")); const int64 batch_size = images.dim_size(0); const int64 height = images.dim_size(1); const int64 width = images.dim_size(2); std::vector<std::vector<float>> color_table; if (context->num_inputs() == 3) { const Tensor& colors_tensor = context->input(2); OP_REQUIRES(context, colors_tensor.shape().dims() == 2, errors::InvalidArgument(""colors must be a 2-D matrix"", colors_tensor.shape().DebugString())); OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth, errors::InvalidArgument(""colors must have equal or more "", ""channels than the image provided: "", colors_tensor.shape().DebugString())); if (colors_tensor.NumElements() != 0) { color_table.clear(); auto colors = colors_tensor.matrix<float>(); for (int64 i = 0; i < colors.dimension(0); i++) { std::vector<float> color_value(4); for (int64 j = 0; j < 4; j++) { color_value[j] = colors(i, j); } color_table.emplace_back(color_value); } } } if (color_table.empty()) { color_table = DefaultColorTable(depth); } Tensor* output; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({batch_size, height, width, depth}), &output)); output->tensor<T, 4>() = images.tensor<T, 4>(); auto canvas = output->tensor<T, 4>(); for (int64 b = 0; b < batch_size; ++b) { const int64 num_boxes = boxes.dim_size(1); const auto tboxes = boxes.tensor<T, 3>(); for (int64 bb = 0; bb < num_boxes; ++bb) { int64 color_index = bb % color_table.size(); const int64 min_box_row = static_cast<float>(tboxes(b, bb, 0)) * (height - 1); const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0}); const int64 max_box_row = static_cast<float>(tboxes(b, bb, 2)) * (height - 1); const int64 max_box_row_clamp = std::min<int64>(max_box_row, height - 1); const int64 min_box_col = static_cast<float>(tboxes(b, bb, 1)) * (width - 1); const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0}); const int64 max_box_col = static_cast<float>(tboxes(b, bb, 3)) * (width - 1); const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1); if (min_box_row > max_box_row || min_box_col > max_box_col) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is inverted and will not be drawn.""; continue; } if (min_box_row >= height || max_box_row < 0 || min_box_col >= width || max_box_col < 0) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is completely outside the image"" << "" and will not be drawn.""; continue; } OP_REQUIRES( context, min_box_row_clamp >= 0, errors::InvalidArgument(""Min box row clamp is less than 0."")); OP_REQUIRES( context, max_box_row_clamp >= 0, errors::InvalidArgument(""Max box row clamp is less than 0."")); OP_REQUIRES(context, min_box_row_clamp <= height, errors::InvalidArgument( ""Min box row clamp is greater than height."")); OP_REQUIRES(context, max_box_row_clamp <= height, errors::InvalidArgument( ""Max box row clamp is greater than height."")); OP_REQUIRES( context, min_box_col_clamp >= 0, errors::InvalidArgument(""Min box col clamp is less than 0."")); OP_REQUIRES( context, max_box_col_clamp >= 0, errors::InvalidArgument(""Max box col clamp is less than 0."")); OP_REQUIRES(context, min_box_col_clamp <= width, errors::InvalidArgument( ""Min box col clamp is greater than width."")); OP_REQUIRES(context, max_box_col_clamp <= width, errors::InvalidArgument( ""Max box col clamp is greater than width."")); OP_REQUIRES( context, min_box_row <= height, errors::InvalidArgument(""Min box row is greater than height."")); OP_REQUIRES(context, max_box_row >= 0, errors::InvalidArgument(""Max box row is less than 0."")); OP_REQUIRES( context, min_box_col <= width, errors::InvalidArgument(""Min box col is greater than width."")); OP_REQUIRES(context, max_box_col >= 0, errors::InvalidArgument(""Max box col is less than 0."")); if (min_box_row >= 0) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, min_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_row < height) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, max_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (min_box_col >= 0) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, min_box_col, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_col < width) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, max_box_col, c) = static_cast<T>(color_table[color_index][c]); } } } } }"
"void motion_vectors_and_ref_indices(base_context* ctx, const slice_segment_header* shdr, de265_image* img, const PBMotionCoding& motion, int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx, PBMotion* out_vi) { int xP = xC+xB; int yP = yC+yB; enum PredMode predMode = img->get_pred_mode(xC,yC); if (predMode == MODE_SKIP || (predMode == MODE_INTER && motion.merge_flag)) { derive_luma_motion_merge_mode(ctx,shdr,img, xC,yC, xP,yP, nCS,nPbW,nPbH, partIdx, motion.merge_idx, out_vi); logMV(xP,yP,nPbW,nPbH, ""merge_mode"", out_vi); } else { int mvdL[2][2]; MotionVector mvpL[2]; for (int l=0;l<2;l++) { enum InterPredIdc inter_pred_idc = (enum InterPredIdc)motion.inter_pred_idc; if (inter_pred_idc == PRED_BI || (inter_pred_idc == PRED_L0 && l==0) || (inter_pred_idc == PRED_L1 && l==1)) { out_vi->refIdx[l] = motion.refIdx[l]; out_vi->predFlag[l] = 1; } else { out_vi->refIdx[l] = -1; out_vi->predFlag[l] = 0; } mvdL[l][0] = motion.mvd[l][0]; mvdL[l][1] = motion.mvd[l][1]; if (out_vi->predFlag[l]) { mvpL[l] = luma_motion_vector_prediction(ctx,shdr,img,motion, xC,yC,nCS,xP,yP, nPbW,nPbH, l, out_vi->refIdx[l], partIdx); int32_t x = (mvpL[l].x + mvdL[l][0] + 0x10000) & 0xFFFF; int32_t y = (mvpL[l].y + mvdL[l][1] + 0x10000) & 0xFFFF; out_vi->mv[l].x = (x>=0x8000) ? x-0x10000 : x; out_vi->mv[l].y = (y>=0x8000) ? y-0x10000 : y; } } logMV(xP,yP,nPbW,nPbH, ""mvp"", out_vi); } }"
"static int get_floppy_geometry(int drive, int type, struct floppy_struct **g) { if (type) *g = &floppy_type[type]; else { if (lock_fdc(drive, false)) return -EINTR; if (poll_drive(false, 0) == -EINTR) return -EINTR; process_fd_request(); *g = current_type[drive]; } if (!*g) return -ENODEV; return 0; }"
"TfLiteStatus ResizeOutputTensor(TfLiteContext* context, const TfLiteTensor* data, const TfLiteTensor* segment_ids, TfLiteTensor* output) { int max_index = -1; const int segment_id_size = segment_ids->dims->data[0]; if (segment_id_size > 0) { max_index = segment_ids->data.i32[segment_id_size - 1]; } const int data_rank = NumDimensions(data); TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data)); output_shape->data[0] = max_index + 1; for (int i = 1; i < data_rank; ++i) { output_shape->data[i] = data->dims->data[i]; } return context->ResizeTensor(context, output, output_shape); }"
"int handle_nsExtendConfigTable(netsnmp_mib_handler          *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info   *reqinfo, netsnmp_request_info         *requests) { netsnmp_request_info       *request; netsnmp_table_request_info *table_info; netsnmp_extend             *extension; extend_registration_block  *eptr; int  i; int  need_to_validate = 0; for ( request=requests; request; request=request->next ) { if (request->processed) continue; table_info = netsnmp_extract_table_info( request ); extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request ); DEBUGMSGTL(( ""nsExtendTable:config"", ""varbind: "")); DEBUGMSGOID((""nsExtendTable:config"", request->requestvb->name, request->requestvb->name_length)); DEBUGMSG((   ""nsExtendTable:config"", "" (%s)\n"", se_find_label_in_slist(""agent_mode"", reqinfo->mode))); switch (reqinfo->mode) { case MODE_GET: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->command, (extension->command)?strlen(extension->command):0); break; case COLUMN_EXTCFG_ARGS: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->args, (extension->args)?strlen(extension->args):0); break; case COLUMN_EXTCFG_INPUT: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->input, (extension->input)?strlen(extension->input):0); break; case COLUMN_EXTCFG_CACHETIME: snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&extension->cache->timeout, sizeof(int)); break; case COLUMN_EXTCFG_EXECTYPE: i = ((extension->flags & NS_EXTEND_FLAGS_SHELL) ? NS_EXTEND_ETYPE_SHELL : NS_EXTEND_ETYPE_EXEC); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_RUNTYPE: i = ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) ? NS_EXTEND_RTYPE_RWRITE : NS_EXTEND_RTYPE_RONLY); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_STORAGE: i = ((extension->flags & NS_EXTEND_FLAGS_CONFIG) ? ST_PERMANENT : ST_VOLATILE); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_STATUS: i = ((extension->flags & NS_EXTEND_FLAGS_ACTIVE) ? RS_ACTIVE : RS_NOTINSERVICE); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; default: netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT); continue; } break; #ifndef NETSNMP_NO_WRITE_SUPPORT case MODE_SET_RESERVE1: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: if (request->requestvb->type != ASN_OCTET_STR) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } if (request->requestvb->val_len == 0 || request->requestvb->val.string[0] != '/') { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_ARGS: case COLUMN_EXTCFG_INPUT: if (request->requestvb->type != ASN_OCTET_STR) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_CACHETIME: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i < -1 ) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } break; case COLUMN_EXTCFG_EXECTYPE: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i<1 || i>2) {   netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_RUNTYPE: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i<1 || i>3) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (i==3 && !(extension && (extension->flags & NS_EXTEND_FLAGS_WRITEABLE))) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } if ((extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) && i!=3 ) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break; case COLUMN_EXTCFG_STATUS: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_NOTINSERVICE: if (!extension) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break;     case RS_CREATEANDGO: case RS_CREATEANDWAIT: if (extension) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break; case RS_DESTROY: break; default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } break; default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case MODE_SET_RESERVE2: switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); extension = _new_extension( (char *) table_info->indexes->val.string, 0, eptr ); if (!extension) {   netsnmp_set_request_error(reqinfo, request, SNMP_ERR_RESOURCEUNAVAILABLE); return SNMP_ERR_RESOURCEUNAVAILABLE; } netsnmp_insert_table_row( request, extension->row ); } } break; case MODE_SET_FREE: switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); } } break; case MODE_SET_ACTION: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: extension->old_command = extension->command; extension->command = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_ARGS: extension->old_args = extension->args; extension->args = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_INPUT: extension->old_input = extension->input; extension->input = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_CREATEANDGO: need_to_validate = 1; } break; } break; case MODE_SET_UNDO: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: if ( extension && extension->old_command ) { SNMP_FREE(extension->command); extension->command     = extension->old_command; extension->old_command = NULL; } break; case COLUMN_EXTCFG_ARGS: if ( extension && extension->old_args ) { SNMP_FREE(extension->args); extension->args     = extension->old_args; extension->old_args = NULL; } break; case COLUMN_EXTCFG_INPUT: if ( extension && extension->old_input ) { SNMP_FREE(extension->input); extension->input     = extension->old_input; extension->old_input = NULL; } break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); } break; } break; case MODE_SET_COMMIT: switch (table_info->colnum) { case COLUMN_EXTCFG_CACHETIME: i = *request->requestvb->val.integer; extension->cache->timeout = i; break; case COLUMN_EXTCFG_RUNTYPE: i = *request->requestvb->val.integer; switch (i) { case 1: extension->flags &= ~NS_EXTEND_FLAGS_WRITEABLE; break; case 2: extension->flags |=  NS_EXTEND_FLAGS_WRITEABLE; break; case 3: (void)netsnmp_cache_check_and_reload( extension->cache ); break; } break; case COLUMN_EXTCFG_EXECTYPE: i = *request->requestvb->val.integer; if ( i == NS_EXTEND_ETYPE_SHELL ) extension->flags |=  NS_EXTEND_FLAGS_SHELL; else extension->flags &= ~NS_EXTEND_FLAGS_SHELL; break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_CREATEANDGO: extension->flags |= NS_EXTEND_FLAGS_ACTIVE; break; case RS_NOTINSERVICE: case RS_CREATEANDWAIT: extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE; break; case RS_DESTROY: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); break; } } break; #endif   default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR); return SNMP_ERR_GENERR; } } #ifndef NETSNMP_NO_WRITE_SUPPORT if (need_to_validate) { for ( request=requests; request; request=request->next ) { if (request->processed) continue; table_info = netsnmp_extract_table_info( request ); extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request ); switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; if (( i == RS_ACTIVE || i == RS_CREATEANDGO ) && !(extension && extension->command && extension->command[0] == '/' )) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } } } } #endif  return SNMP_ERR_NOERROR; }"
"static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile, size_t len, const struct iov_iter *it) { struct sk_buff *skb; size_t linear; int err; int i; if (it->nr_segs > MAX_SKB_FRAGS + 1) return ERR_PTR(-EMSGSIZE); local_bh_disable(); skb = napi_get_frags(&tfile->napi); local_bh_enable(); if (!skb) return ERR_PTR(-ENOMEM); linear = iov_iter_single_seg_count(it); err = __skb_grow(skb, linear); if (err) goto free; skb->len = len; skb->data_len = len - linear; skb->truesize += skb->data_len; for (i = 1; i < it->nr_segs; i++) { size_t fragsz = it->iov[i].iov_len; struct page *page; void *frag; if (fragsz == 0 || fragsz > PAGE_SIZE) { err = -EINVAL; goto free; } frag = netdev_alloc_frag(fragsz); if (!frag) { err = -ENOMEM; goto free; } page = virt_to_head_page(frag); skb_fill_page_desc(skb, i - 1, page, frag - page_address(page), fragsz); } return skb; free: napi_free_frags(&tfile->napi); return ERR_PTR(err); }"
"BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it) { NDEF_SUPPORT *ndef_aux = NULL; BIO *asn_bio = NULL; const ASN1_AUX *aux = it->funcs; ASN1_STREAM_ARG sarg; if (!aux || !aux->asn1_cb) { ERR_raise(ERR_LIB_ASN1, ASN1_R_STREAMING_NOT_SUPPORTED); return NULL; } ndef_aux = OPENSSL_zalloc(sizeof(*ndef_aux)); asn_bio = BIO_new(BIO_f_asn1()); if (ndef_aux == NULL || asn_bio == NULL) goto err; out = BIO_push(asn_bio, out); if (out == NULL) goto err; BIO_asn1_set_prefix(asn_bio, ndef_prefix, ndef_prefix_free); BIO_asn1_set_suffix(asn_bio, ndef_suffix, ndef_suffix_free); sarg.out = out; sarg.ndef_bio = NULL; sarg.boundary = NULL; if (aux->asn1_cb(ASN1_OP_STREAM_PRE, &val, it, &sarg) <= 0) goto err; ndef_aux->val = val; ndef_aux->it = it; ndef_aux->ndef_bio = sarg.ndef_bio; ndef_aux->boundary = sarg.boundary; ndef_aux->out = out; BIO_ctrl(asn_bio, BIO_C_SET_EX_ARG, 0, ndef_aux); return sarg.ndef_bio; err: BIO_free(asn_bio); OPENSSL_free(ndef_aux); return NULL; }"
"void gru_check_context_placement(struct gru_thread_state *gts) { struct gru_state *gru; gru = gts->ts_gru; if (!gru || gts->ts_tgid_owner != current->tgid) return; if (!gru_check_chiplet_assignment(gru, gts)) { STAT(check_context_unload); gru_unload_context(gts, 1); } else if (gru_retarget_intr(gts)) { STAT(check_context_retarget_intr); } }"
"int main(int argc, char **argv) { GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); el::Configurations defaultConf = et::LogHandler::setupLogHandler(&argc, &argv); defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); el::Loggers::setVerboseLevel(3); string maxlogsize = ""20971520""; LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + ""htmd.log"", maxlogsize); LogHandler::stderrToFile(GetTempDirectory() + ""htmd""); el::Loggers::reconfigureLogger(""default"", defaultConf); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler()); SocketEndpoint endpoint; endpoint.set_name(HtmServer::getPipeName()); HtmServer htm(socketHandler, endpoint); htm.run(); LOG(INFO) << ""Server is shutting down""; return 0; }"
"static int StreamTcpValidateRst(TcpSession *ssn, Packet *p) { uint8_t os_policy; if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) { if (!StreamTcpValidateTimestamp(ssn, p)) { SCReturnInt(0); } } if (PKT_IS_TOSERVER(p)) { if (ssn->server.os_policy == 0) StreamTcpSetOSPolicy(&ssn->server, p); os_policy = ssn->server.os_policy; if (p->tcph->th_flags & TH_ACK && TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) { SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn); StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK); SCReturnInt(0); } } else { if (ssn->client.os_policy == 0) StreamTcpSetOSPolicy(&ssn->client, p); os_policy = ssn->client.os_policy; if (p->tcph->th_flags & TH_ACK && TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) { SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn); StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK); SCReturnInt(0); } } if (ssn->flags & STREAMTCP_FLAG_ASYNC) { if (PKT_IS_TOSERVER(p)) { if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""ssn %p: ASYNC accept RST"", ssn); return 1; } } else { if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""ssn %p: ASYNC accept RST"", ssn); return 1; } } SCLogDebug(""ssn %p: ASYNC reject RST"", ssn); return 0; } switch (os_policy) { case OS_POLICY_HPUX11: if(PKT_IS_TOSERVER(p)){ if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not Valid! Packet SEQ: %"" PRIu32 "" "" ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" "" ""and client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; case OS_POLICY_OLD_LINUX: case OS_POLICY_LINUX: case OS_POLICY_SOLARIS: if(PKT_IS_TOSERVER(p)){ if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->client.last_ack)) {  if(SEQ_LT(TCP_GET_SEQ(p), (ssn->client.next_seq + ssn->client.window))) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->server.last_ack)) {  if(SEQ_LT(TCP_GET_SEQ(p), (ssn->server.next_seq + ssn->server.window))) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; default: case OS_POLICY_BSD: case OS_POLICY_FIRST: case OS_POLICY_HPUX10: case OS_POLICY_IRIX: case OS_POLICY_MACOS: case OS_POLICY_LAST: case OS_POLICY_WINDOWS: case OS_POLICY_WINDOWS2K3: case OS_POLICY_VISTA: if(PKT_IS_TOSERVER(p)) { if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" "" ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 "" Stream %u"", TCP_GET_SEQ(p), ssn->server.next_seq); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; } return 0; }"
"static int decode_font(ASS_Track *track) { unsigned char *p; unsigned char *q; size_t i; size_t size;                       size_t dsize;                      unsigned char *buf = 0; ass_msg(track->library, MSGL_V, ""Font: %d bytes encoded data"", track->parser_priv->fontdata_used); size = track->parser_priv->fontdata_used; if (size % 4 == 1) { ass_msg(track->library, MSGL_ERR, ""Bad encoded data size""); goto error_decode_font; } buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0)); if (!buf) goto error_decode_font; q = buf; for (i = 0, p = (unsigned char *) track->parser_priv->fontdata; i < size / 4; i++, p += 4) { q = decode_chars(p, q, 4); } if (size % 4 == 2) { q = decode_chars(p, q, 2); } else if (size % 4 == 3) { q = decode_chars(p, q, 3); } dsize = q - buf; assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0)); if (track->library->extract_fonts) { ass_add_font(track->library, track->parser_priv->fontname, (char *) buf, dsize); } error_decode_font: free(buf); reset_embedded_font_parsing(track->parser_priv); return 0; }"
"void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) { Q_UNUSED(size) using elf_addr   = typename M::elf_addr; using elf_header = typename M::elf_header; using elf_shdr   = typename M::elf_shdr; using elf_sym    = typename M::elf_sym; using elf_rela   = typename M::elf_rela; using elf_rel    = typename M::elf_rel; using symbol     = typename M::symbol; const auto base = reinterpret_cast<uintptr_t>(p); const auto header = static_cast<const elf_header *>(p); if (header->e_shnum == 0 || header->e_shentsize == 0) { return; } const auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff); const elf_shdr *const sections_end = sections_begin + header->e_shnum; auto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset); elf_addr plt_address = 0; elf_addr got_address = 0; std::set<elf_addr> plt_addresses; for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { if (strcmp(&section_strings[section->sh_name], "".plt"") == 0) { plt_address = section->sh_addr; } else if (strcmp(&section_strings[section->sh_name], "".got"") == 0) { got_address = section->sh_addr; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { elf_addr base_address = 0; if (strcmp(&section_strings[section->sh_name], "".rela.plt"") == 0) { base_address = plt_address; } else if (strcmp(&section_strings[section->sh_name], "".rel.plt"") == 0) { base_address = plt_address; } else if (strcmp(&section_strings[section->sh_name], "".rela.got"") == 0) { base_address = got_address; } else if (strcmp(&section_strings[section->sh_name], "".rel.got"") == 0) { base_address = got_address; } else { continue; } switch (section->sh_type) { case SHT_RELA: { elf_addr n      = 0; auto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset); if (section->sh_link == 0) { break; } for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const size_t sym_index = M::elf_r_sym(relocation[i].r_info); const elf_shdr *linked = &sections_begin[section->sh_link]; auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset); auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset); const elf_addr symbol_address = base_address + ++n * M::plt_entry_size; const char *sym_name = &section_strings[section->sh_name]; if (strlen(sym_name) > (sizeof("".rela."") - 1) && memcmp(sym_name, "".rela."", (sizeof("".rela."") - 1)) == 0) { sym_name += 6; } plt_addresses.insert(symbol_address); symbol sym; sym.address = symbol_address; sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10); sym.name    = &string_tab[symbol_tab[sym_index].st_name]; sym.name += ""@""; sym.name += sym_name; sym.type = 'P'; symbols.push_back(sym); } } break; case SHT_REL: { elf_addr n      = 0; auto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset); if (section->sh_link == 0) { break; } for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const size_t sym_index = M::elf_r_sym(relocation[i].r_info); const elf_shdr *linked = &sections_begin[section->sh_link]; auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset); auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset); const elf_addr symbol_address = base_address + ++n * M::plt_entry_size; const char *sym_name = &section_strings[section->sh_name]; if (strlen(sym_name) > (sizeof("".rel."") - 1) && memcmp(sym_name, "".rel."", (sizeof("".rel."") - 1)) == 0) { sym_name += 5; } plt_addresses.insert(symbol_address); symbol sym; sym.address = symbol_address; sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10); sym.name    = &string_tab[symbol_tab[sym_index].st_name]; sym.name += ""@""; sym.name += sym_name; sym.type = 'P'; symbols.push_back(sym); } } break; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { switch (section->sh_type) { case SHT_SYMTAB: case SHT_DYNSYM: { auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset); auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset); for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const elf_shdr *related_section = nullptr; if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) { related_section = &sections_begin[symbol_tab[i].st_shndx]; } Q_UNUSED(related_section) if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) { if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) { symbol sym; sym.address = symbol_tab[i].st_value; sym.size    = symbol_tab[i].st_size; sym.name    = &string_tab[symbol_tab[i].st_name]; sym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D'); symbols.push_back(sym); } } } } break; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { switch (section->sh_type) { case SHT_SYMTAB: case SHT_DYNSYM: { auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset); auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset); for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const elf_shdr *related_section = nullptr; if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) { related_section = &sections_begin[symbol_tab[i].st_shndx]; } Q_UNUSED(related_section) if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) { if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) { symbol sym; sym.address = symbol_tab[i].st_value; sym.size    = symbol_tab[i].st_size; for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { if (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) { const std::int64_t offset = sym.address - section->sh_addr; const QString hexPrefix   = std::abs(offset) > 9 ? ""0x"" : """"; const QString offsetStr   = offset ? ""+"" + hexPrefix + QString::number(offset, 16) : """"; const QString sectionName(&section_strings[section->sh_name]); if (!sectionName.isEmpty()) { sym.name = QString(sectionName + offsetStr); break; } } } if (sym.name.isEmpty()) { sym.name = QString(""$sym_%1"").arg(edb::v1::format_pointer(symbol_tab[i].st_value)); } sym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D'); symbols.push_back(sym); } } } } break; } } }"
"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) { if (!block) { return; } QLIST_REMOVE(block, next); uc->ram_list.mru_block = NULL; reclaim_ramblock(uc, block); }"
"void Compute(OpKernelContext* ctx) final { const CSRSparseMatrix* input_matrix; OP_REQUIRES_OK(ctx, ExtractVariantFromInput(ctx, 0, &input_matrix)); const Tensor& input_permutation_indices = ctx->input(1); int64 num_rows; int batch_size; ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size, &num_rows); Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1})); auto batch_ptr_vec = batch_ptr.vec<int32>(); batch_ptr_vec(0) = 0; std::vector<SparseMatrix> sparse_cholesky_factors(batch_size); const double nnz_per_row = (input_matrix->total_nnz() / batch_size) / num_rows; const int64 sparse_cholesky_cost_per_batch = nnz_per_row * nnz_per_row * num_rows; auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); std::atomic<int64> invalid_input_index(-1); Shard(worker_threads.num_threads, worker_threads.workers, batch_size, sparse_cholesky_cost_per_batch, [&](int64 batch_begin, int64 batch_end) { for (int64 batch_index = batch_begin; batch_index < batch_end; ++batch_index) { Eigen::Map<const SparseMatrix> sparse_matrix( num_rows, num_rows, input_matrix->nnz(batch_index), input_matrix->row_pointers_vec(batch_index).data(), input_matrix->col_indices_vec(batch_index).data(), input_matrix->values_vec<T>(batch_index).data()); Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper, Eigen::NaturalOrdering<int>> solver; auto permutation_indices_flat = input_permutation_indices.flat<int32>().data(); Eigen::Map< Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>> permutation(permutation_indices_flat + batch_index * num_rows, num_rows); auto permutation_inverse = permutation.inverse(); SparseMatrix permuted_sparse_matrix; permuted_sparse_matrix.template selfadjointView<Eigen::Upper>() = sparse_matrix.template selfadjointView<Eigen::Upper>() .twistedBy(permutation_inverse); solver.compute(permuted_sparse_matrix); if (solver.info() != Eigen::Success) { invalid_input_index = batch_index; return; } sparse_cholesky_factors[batch_index] = std::move(solver.matrixU()); batch_ptr_vec(batch_index + 1) = sparse_cholesky_factors[batch_index].nonZeros(); } }); OP_REQUIRES( ctx, invalid_input_index == -1, errors::InvalidArgument( ""Sparse Cholesky factorization failed for batch index "", invalid_input_index.load(), "". The input might not be valid."")); std::partial_sum(batch_ptr_vec.data(), batch_ptr_vec.data() + batch_size + 1, batch_ptr_vec.data()); const int64 total_nnz = batch_ptr_vec(batch_size); Tensor output_row_ptr(cpu_allocator(), DT_INT32, TensorShape({(num_rows + 1) * batch_size})); Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz})); Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value, TensorShape({total_nnz})); auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data(); auto output_col_ind_ptr = output_col_ind.flat<int32>().data(); auto output_values_ptr = output_values.flat<T>().data(); Shard(worker_threads.num_threads, worker_threads.workers, batch_size, (3 * total_nnz) / batch_size , [&](int64 batch_begin, int64 batch_end) { for (int64 batch_index = batch_begin; batch_index < batch_end; ++batch_index) { const SparseMatrix& cholesky_factor = sparse_cholesky_factors[batch_index]; const int64 nnz = cholesky_factor.nonZeros(); std::copy(cholesky_factor.outerIndexPtr(), cholesky_factor.outerIndexPtr() + num_rows + 1, output_row_ptr_ptr + batch_index * (num_rows + 1)); std::copy(cholesky_factor.innerIndexPtr(), cholesky_factor.innerIndexPtr() + nnz, output_col_ind_ptr + batch_ptr_vec(batch_index)); std::copy(cholesky_factor.valuePtr(), cholesky_factor.valuePtr() + nnz, output_values_ptr + batch_ptr_vec(batch_index)); } }); CSRSparseMatrix output_csr_matrix; OP_REQUIRES_OK( ctx, CSRSparseMatrix::CreateCSRSparseMatrix( DataTypeToEnum<T>::value, input_matrix->dense_shape(), batch_ptr, output_row_ptr, output_col_ind, output_values, &output_csr_matrix)); Tensor* output_csr_matrix_tensor; AllocatorAttributes cpu_alloc; cpu_alloc.set_on_host(true); OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({}), &output_csr_matrix_tensor, cpu_alloc)); output_csr_matrix_tensor->scalar<Variant>()() = std::move(output_csr_matrix); }"
"GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs) { char *buf; u32 buf_len, i, string_len, string_start; GF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s; ISOM_DECREASE_SIZE(ptr, 4); ptr->item_ID = gf_bs_read_u16(bs); ptr->item_protection_index = gf_bs_read_u16(bs); if (ptr->version == 2) { ISOM_DECREASE_SIZE(ptr, 4); ptr->item_type = gf_bs_read_u32(bs); } buf_len = (u32) (ptr->size); buf = (char*)gf_malloc(buf_len); if (!buf) return GF_OUT_OF_MEM; if (buf_len != gf_bs_read_data(bs, buf, buf_len)) { gf_free(buf); return GF_ISOM_INVALID_FILE; } string_len = 1; string_start = 0; for (i = 0; i < buf_len; i++) { if (buf[i] == 0) { if (!ptr->item_name) { ptr->item_name = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->item_name) return GF_OUT_OF_MEM; memcpy(ptr->item_name, buf+string_start, string_len); } else if (!ptr->content_type) { ptr->content_type = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->content_type) return GF_OUT_OF_MEM; memcpy(ptr->content_type, buf+string_start, string_len); } else { ptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->content_encoding) return GF_OUT_OF_MEM; memcpy(ptr->content_encoding, buf+string_start, string_len); } string_start += string_len; string_len = 0; if (ptr->content_encoding && ptr->version == 1) { break; } } string_len++; } gf_free(buf); if (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isoff] Infe without name or content type !\n"")); } return GF_OK; }"
"static int dissect_kafka_record(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int start_offset, guint64 base_offset, guint64 first_timestamp) { proto_item *record_ti; proto_tree *subtree; gint64     size; guint      len; int offset, end_offset; gboolean   invalid; offset = start_offset; subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record, &record_ti, ""Record""); len = tvb_get_varint(tvb, offset, 5, &size, ENC_VARINT_ZIGZAG); if (len == 0) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_varint); return offset; } else if (size < 6) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length); return offset + len; } end_offset = offset + len + (gint)size; offset += len; proto_tree_add_item(subtree, hf_kafka_record_attributes, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; offset = dissect_kafka_timestamp_delta(tvb, pinfo, subtree, hf_kafka_message_timestamp, offset, first_timestamp); offset = dissect_kafka_offset_delta(tvb, pinfo, subtree, hf_kafka_offset, offset, base_offset); offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_key, offset, NULL, NULL, &invalid); if (invalid) return end_offset; offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_value, offset, NULL, NULL, &invalid); if (invalid) return end_offset; offset = dissect_kafka_record_headers(tvb, pinfo, subtree, offset); if (offset != end_offset) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length); } proto_item_set_end(record_ti, tvb, end_offset); return end_offset; }"
"static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext) { u32 i, j; s32 vps_id; VVC_VPS *vps; Bool vps_default_ptl_dpb_hrd_max_tid_flag=0; vps_id = gf_bs_read_int_log(bs, 4, ""vps_id""); if (vps_id >= 16) return -1; if (!vps_id) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] VPS ID 0 is forbidden\n"")); return -1; } vps = &vvc->vps[vps_id]; if (!vps->state) { vps->id = vps_id; vps->state = 1; } vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, ""max_layers""); if (vps->max_layers > MAX_LHVC_LAYERS) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] sorry, %d layers in VPS but only %d supported\n"", vps->max_layers, MAX_LHVC_LAYERS)); return -1; } vps->max_sub_layers = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"") + 1; if ((vps->max_layers>1) && (vps->max_sub_layers>1)) vps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, ""vps_default_ptl_dpb_hrd_max_tid_flag""); if (vps->max_layers>1) vps->all_layers_independent = gf_bs_read_int_log(bs, 1, ""all_layers_independent""); for (i=0; i<vps->max_layers; i++) { u32 layer_id = gf_bs_read_int_log_idx(bs, 6, ""layer_id"", i); if (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id; if (i && !vps->all_layers_independent) { Bool layer_indep = gf_bs_read_int_log_idx(bs, 1, ""layer_independent"", i); if (!layer_indep) { Bool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_max_tid_ref_present_flag"", i); for (j=0; j<i; j++) { Bool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, ""vps_direct_ref_layer_flag"", i, j); if (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) { gf_bs_read_int_log_idx2(bs, 3, ""vps_max_tid_il_ref_pics_plus1"", i, j); } } } } } vps->num_ptl = 1; if (vps->max_layers > 1) { if (vps->all_layers_independent) { vps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, ""each_layer_is_ols""); } if (!vps->each_layer_is_ols) { u32 vps_ols_mode_idc = 2; if (!vps->all_layers_independent) { vps_ols_mode_idc = gf_bs_read_int_log(bs, 2, ""vps_ols_mode_idc""); } if (vps_ols_mode_idc==2) { u8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, ""vps_num_output_layer_sets_minus2""); for (i=0; i<vps_num_output_layer_sets; i++) { for (j=0; j<vps->max_layers; j++) { gf_bs_read_int_log_idx2(bs, 1, ""vps_ols_output_layer_flag"", i, j); } } } } vps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, ""num_ptl_minus1""); } vps->ptl[0].pt_present = 1; for (i=0; i<vps->num_ptl; i++) { if (i) vps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, ""pt_present"", i); if (!vps_default_ptl_dpb_hrd_max_tid_flag) vps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, ""ptl_max_tid"", i); else vps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;; } gf_bs_align(bs); for (i=0; i<vps->num_ptl; i++) { vvc_profile_tier_level(bs, &vps->ptl[i], i); } return vps_id; }"
"static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma) { struct bpf_map *map = filp->private_data; int err; if (!map->ops->map_mmap || map_value_has_spin_lock(map) || map_value_has_timer(map)) return -ENOTSUPP; if (!(vma->vm_flags & VM_SHARED)) return -EINVAL; mutex_lock(&map->freeze_mutex); if (vma->vm_flags & VM_WRITE) { if (map->frozen) { err = -EPERM; goto out; } if (map->map_flags & BPF_F_RDONLY_PROG) { err = -EACCES; goto out; } } vma->vm_ops = &bpf_map_default_vmops; vma->vm_private_data = map; vma->vm_flags &= ~VM_MAYEXEC; if (!(vma->vm_flags & VM_WRITE)) vma->vm_flags &= ~VM_MAYWRITE; err = map->ops->map_mmap(map, vma); if (err) goto out; if (vma->vm_flags & VM_MAYWRITE) map->writecnt++; out: mutex_unlock(&map->freeze_mutex); return err; }"
"static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock, unsigned long err) { int level = 0; int len = 0;  ERROR_LOG(""STATUS_FROM_SSL_ERR"", err, ssock); level++; if (err == SSL_ERROR_SSL) { err = ERR_get_error(); ERROR_LOG(""STATUS_FROM_SSL_ERR"", err, ssock); } ssock->last_err = err; return GET_STATUS_FROM_SSL_ERR(err); }"
"static int vmx_check_intercept(struct kvm_vcpu *vcpu, struct x86_instruction_info *info, enum x86_intercept_stage stage) { struct vmcs12 *vmcs12 = get_vmcs12(vcpu); struct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt; if (info->intercept == x86_intercept_rdtscp && !nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) { ctxt->exception.vector = UD_VECTOR; ctxt->exception.error_code_valid = false; return X86EMUL_PROPAGATE_FAULT; } return X86EMUL_UNHANDLEABLE; }"
"static void process_add_smartcard_key(SocketEntry *e) { char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX]; char **comments = NULL; int r, i, count = 0, success = 0, confirm = 0; u_int seconds = 0; time_t death = 0; struct sshkey **keys = NULL, *k; Identity *id; struct dest_constraint *dest_constraints = NULL; size_t ndest_constraints = 0; debug2_f(""entering""); if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 || (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) { error_fr(r, ""parse""); goto send; } if (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm, NULL, &dest_constraints, &ndest_constraints) != 0) { error_f(""failed to parse constraints""); goto send; } if (e->nsession_ids != 0 && !remote_add_provider) { verbose(""failed PKCS#11 add of \""%.100s\"": remote addition of "" ""providers is disabled"", provider); goto send; } if (realpath(provider, canonical_provider) == NULL) { verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"", provider, strerror(errno)); goto send; } if (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) { verbose(""refusing PKCS#11 add of \""%.100s\"": "" ""provider not allowed"", canonical_provider); goto send; } debug_f(""add %.100s"", canonical_provider); if (lifetime && !death) death = monotime() + lifetime; count = pkcs11_add_provider(canonical_provider, pin, &keys, &comments); for (i = 0; i < count; i++) { k = keys[i]; if (lookup_identity(k) == NULL) { id = xcalloc(1, sizeof(Identity)); id->key = k; keys[i] = NULL;  id->provider = xstrdup(canonical_provider); if (*comments[i] != '\0') { id->comment = comments[i]; comments[i] = NULL;  } else { id->comment = xstrdup(canonical_provider); } id->death = death; id->confirm = confirm; id->dest_constraints = dest_constraints; id->ndest_constraints = ndest_constraints; dest_constraints = NULL;  ndest_constraints = 0; TAILQ_INSERT_TAIL(&idtab->idlist, id, next); idtab->nentries++; success = 1; } sshkey_free(keys[i]); free(comments[i]); } send: free(pin); free(provider); free(keys); free(comments); free_dest_constraints(dest_constraints, ndest_constraints); send_status(e, success); }"
"static struct lys_node * read_yin_case(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options, struct unres_schema *unres) { struct ly_ctx *ctx = module->ctx; struct lyxml_elem *sub, *next, root; struct lys_node_case *cs; struct lys_node *retval, *node = NULL; int c_ftrs = 0, c_ext = 0, ret; void *reallocated; memset(&root, 0, sizeof root); cs = calloc(1, sizeof *cs); LY_CHECK_ERR_RETURN(!cs, LOGMEM(ctx), NULL); cs->nodetype = LYS_CASE; cs->prev = (struct lys_node *)cs; retval = (struct lys_node *)cs; if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin, OPT_IDENT | OPT_MODULE | (!(options & LYS_PARSE_OPT_CFG_MASK) ? OPT_CFG_INHERIT : 0), unres)) { goto error; } LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name); if (lys_node_addchild(parent, lys_main_module(module), retval, options)) { goto error; } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""case"", error); c_ext++; } else if (!strcmp(sub->name, ""container"") || !strcmp(sub->name, ""leaf-list"") || !strcmp(sub->name, ""leaf"") || !strcmp(sub->name, ""list"") || !strcmp(sub->name, ""uses"") || !strcmp(sub->name, ""choice"") || !strcmp(sub->name, ""anyxml"") || !strcmp(sub->name, ""anydata"")) { lyxml_unlink_elem(ctx, sub, 2); lyxml_add_child(ctx, &root, sub); } else if (!strcmp(sub->name, ""if-feature"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""case"", error); c_ftrs++; } else if (!strcmp(sub->name, ""when"")) { if (cs->when) { LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name); goto error; } cs->when = read_yin_when(module, sub, unres); if (!cs->when) { goto error; } lyxml_free(ctx, sub); } else { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name); goto error; } } if (c_ftrs) { cs->iffeature = calloc(c_ftrs, sizeof *cs->iffeature); LY_CHECK_ERR_GOTO(!cs->iffeature, LOGMEM(ctx), error); } if (c_ext) { reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext); LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error); retval->ext = reallocated; memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext); } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { ret = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres); if (ret) { goto error; } } else { ret = fill_yin_iffeature(retval, 0, sub, &cs->iffeature[cs->iffeature_size], unres); cs->iffeature_size++; if (ret) { goto error; } } } lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size); LY_TREE_FOR_SAFE(root.child, next, sub) { if (!strcmp(sub->name, ""container"")) { node = read_yin_container(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf-list"")) { node = read_yin_leaflist(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf"")) { node = read_yin_leaf(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""list"")) { node = read_yin_list(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""choice"")) { node = read_yin_choice(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""uses"")) { node = read_yin_uses(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""anyxml"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres); } else if (!strcmp(sub->name, ""anydata"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres); } if (!node) { goto error; } lyxml_free(ctx, sub); } if (!(ctx->models.flags & LY_CTX_TRUSTED) && cs->when) { if (options & LYS_PARSE_OPT_INGRP) { if (lyxp_node_check_syntax(retval)) { goto error; } } else { if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) { goto error; } } } return retval; error: while (root.child) { lyxml_free(ctx, root.child); } lys_node_free(retval, NULL, 0); return NULL; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& input = ctx->input(0); const Tensor& input_min_range = ctx->input(1); const Tensor& input_max_range = ctx->input(2); int num_slices = 1; if (axis_ > -1) { num_slices = input.dim_size(axis_); } const TensorShape& minmax_shape = ctx->input(1).shape(); Tensor* output = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output)); Tensor* output_min_tensor = nullptr; Tensor* output_max_tensor = nullptr; if (num_slices == 1) { OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor)); OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor)); const float min_range = input_min_range.template flat<float>()(0); const float max_range = input_max_range.template flat<float>()(0); QuantizeTensor(ctx, input, min_range, max_range, output, output_min_tensor, output_max_tensor); return; } OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST, errors::Unimplemented(""MIN_FIRST mode is not implemented for "" ""Quantize with axis != -1."")); OP_REQUIRES_OK(ctx, ctx->allocate_output(1, minmax_shape, &output_min_tensor)); OP_REQUIRES_OK(ctx, ctx->allocate_output(2, minmax_shape, &output_max_tensor)); auto input_tensor = input.template flat_inner_outer_dims<float, 3>(axis_ - 1); int64_t pre_dim = 1, post_dim = 1; for (int i = 0; i < axis_; ++i) { pre_dim *= output->dim_size(i); } for (int i = axis_ + 1; i < output->dims(); ++i) { post_dim *= output->dim_size(i); } auto output_tensor = output->template bit_casted_shaped<T, 3>( {pre_dim, num_slices, post_dim}); auto min_ranges = input_min_range.template vec<float>(); auto max_ranges = input_max_range.template vec<float>(); for (int i = 0; i < num_slices; ++i) { QuantizeSlice(ctx->eigen_device<Device>(), ctx, input_tensor.template chip<1>(i), min_ranges(i), max_ranges(i), output_tensor.template chip<1>(i), &output_min_tensor->flat<float>()(i), &output_max_tensor->flat<float>()(i)); } }"
"void Compute(OpKernelContext* ctx) override { const Tensor& in0 = ctx->input(0); const Tensor& in1 = ctx->input(1); ValidateInputTensors(ctx, in0, in1); MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes()); OP_REQUIRES( ctx, bcast.IsValid(), errors::InvalidArgument( ""In[0] and In[1] must have compatible batch dimensions: "", in0.shape().DebugString(), "" vs. "", in1.shape().DebugString())); TensorShape out_shape = bcast.output_batch_shape(); auto batch_size = bcast.output_batch_size(); auto d0 = in0.dim_size(in0.dims() - 2); auto d1 = in0.dim_size(in0.dims() - 1); Tensor in0_reshaped; OP_REQUIRES( ctx, in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})), errors::Internal(""Failed to reshape In[0] from "", in0.shape().DebugString())); auto d2 = in1.dim_size(in1.dims() - 2); auto d3 = in1.dim_size(in1.dims() - 1); Tensor in1_reshaped; OP_REQUIRES( ctx, in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})), errors::Internal(""Failed to reshape In[1] from "", in1.shape().DebugString())); if (adjoint_) std::swap(d0, d1); OP_REQUIRES(ctx, d1 == d2, errors::InvalidArgument( ""In[0] mismatch In[1] shape: "", d1, "" vs. "", d2, "": "", in0.shape().DebugString(), "" "", in1.shape().DebugString(), "" "", lower_, "" "", adjoint_)); out_shape.AddDim(d0); out_shape.AddDim(d3); Tensor* out = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out)); if (out->NumElements() == 0) { return; } Tensor out_reshaped; OP_REQUIRES(ctx, out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})), errors::Internal(""Failed to reshape output from "", out->shape().DebugString())); LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch( ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast, &out_reshaped); }"
"int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size) { struct vfs_ns_cap_data *nscap; uid_t nsrootid; const struct vfs_cap_data *cap = *ivalue; __u32 magic, nsmagic; struct inode *inode = d_backing_inode(dentry); struct user_namespace *task_ns = current_user_ns(), *fs_ns = inode->i_sb->s_user_ns; kuid_t rootid; size_t newsize; if (!*ivalue) return -EINVAL; if (!validheader(size, cap)) return -EINVAL; if (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP)) return -EPERM; if (size == XATTR_CAPS_SZ_2) if (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP)) return size; rootid = rootid_from_xattr(*ivalue, size, task_ns); if (!uid_valid(rootid)) return -EINVAL; nsrootid = from_kuid(fs_ns, rootid); if (nsrootid == -1) return -EINVAL; newsize = sizeof(struct vfs_ns_cap_data); nscap = kmalloc(newsize, GFP_ATOMIC); if (!nscap) return -ENOMEM; nscap->rootid = cpu_to_le32(nsrootid); nsmagic = VFS_CAP_REVISION_3; magic = le32_to_cpu(cap->magic_etc); if (magic & VFS_CAP_FLAGS_EFFECTIVE) nsmagic |= VFS_CAP_FLAGS_EFFECTIVE; nscap->magic_etc = cpu_to_le32(nsmagic); memcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32); kvfree(*ivalue); *ivalue = nscap; return newsize; }"
"uint64_t ThreadCommand::pc() const { uint64_t entry = 0; switch(architecture_) { case CPU_TYPES::CPU_TYPE_X86: { entry = reinterpret_cast<const details::x86_thread_state_t*>(state_.data())->eip; break; } case CPU_TYPES::CPU_TYPE_X86_64: { entry = reinterpret_cast<const details::x86_thread_state64_t*>(state_.data())->rip; break; } case CPU_TYPES::CPU_TYPE_ARM: { entry = reinterpret_cast<const details::arm_thread_state_t*>(state_.data())->r15; break; } case CPU_TYPES::CPU_TYPE_ARM64: { entry = reinterpret_cast<const details::arm_thread_state64_t*>(state_.data())->pc; break; } default: { LIEF_ERR(""Unknown architecture""); } } return entry; }"
"static int synic_set_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 data, bool host) { struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic); int ret; if (!synic->active && !host) return 1; trace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host); ret = 0; switch (msr) { case HV_X64_MSR_SCONTROL: synic->control = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_SVERSION: if (!host) { ret = 1; break; } synic->version = data; break; case HV_X64_MSR_SIEFP: if ((data & HV_SYNIC_SIEFP_ENABLE) && !host && !synic->dont_zero_synic_pages) if (kvm_clear_guest(vcpu->kvm, data & PAGE_MASK, PAGE_SIZE)) { ret = 1; break; } synic->evt_page = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_SIMP: if ((data & HV_SYNIC_SIMP_ENABLE) && !host && !synic->dont_zero_synic_pages) if (kvm_clear_guest(vcpu->kvm, data & PAGE_MASK, PAGE_SIZE)) { ret = 1; break; } synic->msg_page = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_EOM: { int i; for (i = 0; i < ARRAY_SIZE(synic->sint); i++) kvm_hv_notify_acked_sint(vcpu, i); break; } case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: ret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host); break; default: ret = 1; break; } return ret; }"
"char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) { char *p = strchr(reply+1,'\r'); long long mbulklen; int j = 0; string2ll(reply+1,p-reply-1,&mbulklen); if (server.lua_client->resp == 2 || atype == '*') { p += 2; if (mbulklen == -1) { lua_pushboolean(lua,0); return p; } lua_newtable(lua); for (j = 0; j < mbulklen; j++) { lua_pushnumber(lua,j+1); p = redisProtocolToLuaType(lua,p); lua_settable(lua,-3); } } else if (server.lua_client->resp == 3) { p += 2; lua_newtable(lua); lua_pushstring(lua,atype == '%' ? ""map"" : ""set""); lua_newtable(lua); for (j = 0; j < mbulklen; j++) { p = redisProtocolToLuaType(lua,p); if (atype == '%') { p = redisProtocolToLuaType(lua,p); } else { lua_pushboolean(lua,1); } lua_settable(lua,-3); } lua_settable(lua,-3); } return p; }"
"int dw_spi_add_host(struct device *dev, struct dw_spi *dws) { struct spi_controller *master; int ret; BUG_ON(dws == NULL); master = spi_alloc_master(dev, 0); if (!master) return -ENOMEM; dws->master = master; dws->type = SSI_MOTO_SPI; dws->dma_inited = 0; dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR); spi_controller_set_devdata(master, dws); ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev), master); if (ret < 0) { dev_err(dev, ""can not get IRQ\n""); goto err_free_master; } master->use_gpio_descriptors = true; master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP; master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16); master->bus_num = dws->bus_num; master->num_chipselect = dws->num_cs; master->setup = dw_spi_setup; master->cleanup = dw_spi_cleanup; master->set_cs = dw_spi_set_cs; master->transfer_one = dw_spi_transfer_one; master->handle_err = dw_spi_handle_err; master->max_speed_hz = dws->max_freq; master->dev.of_node = dev->of_node; master->dev.fwnode = dev->fwnode; master->flags = SPI_MASTER_GPIO_SS; master->auto_runtime_pm = true; if (dws->set_cs) master->set_cs = dws->set_cs; spi_hw_init(dev, dws); if (dws->dma_ops && dws->dma_ops->dma_init) { ret = dws->dma_ops->dma_init(dws); if (ret) { dev_warn(dev, ""DMA init failed\n""); dws->dma_inited = 0; } else { master->can_dma = dws->dma_ops->can_dma; } } ret = devm_spi_register_controller(dev, master); if (ret) { dev_err(&master->dev, ""problem registering spi master\n""); goto err_dma_exit; } dw_spi_debugfs_init(dws); return 0; err_dma_exit: if (dws->dma_ops && dws->dma_ops->dma_exit) dws->dma_ops->dma_exit(dws); spi_enable_chip(dws, 0); free_irq(dws->irq, master); err_free_master: spi_controller_put(master); return ret; }"
"static int ib_prctl_set(struct task_struct *task, unsigned long ctrl) { switch (ctrl) { case PR_SPEC_ENABLE: if (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE && spectre_v2_user_stibp == SPECTRE_V2_USER_NONE) return 0; if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED) return -EPERM; task_clear_spec_ib_disable(task); task_update_spec_tif(task); break; case PR_SPEC_DISABLE: case PR_SPEC_FORCE_DISABLE: if (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE && spectre_v2_user_stibp == SPECTRE_V2_USER_NONE) return -EPERM; if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED) return 0; task_set_spec_ib_disable(task); if (ctrl == PR_SPEC_FORCE_DISABLE) task_set_spec_ib_force_disable(task); task_update_spec_tif(task); break; default: return -ERANGE; } return 0; }"
"void dvb_dmxdev_release(struct dmxdev *dmxdev) { dmxdev->exit = 1; if (dmxdev->dvbdev->users > 1) { wait_event(dmxdev->dvbdev->wait_queue, dmxdev->dvbdev->users == 1); } if (dmxdev->dvr_dvbdev->users > 1) { wait_event(dmxdev->dvr_dvbdev->wait_queue, dmxdev->dvr_dvbdev->users == 1); } dvb_unregister_device(dmxdev->dvbdev); dvb_unregister_device(dmxdev->dvr_dvbdev); vfree(dmxdev->filter); dmxdev->filter = NULL; dmxdev->demux->close(dmxdev->demux); }"
"void isis_notif_authentication_failure(const struct isis_circuit *circuit, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:authentication-failure""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_authentication_failure, circuit, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"TfLiteStatus Subgraph::Invoke() { if (!consistent_) { ReportError(""Invoke called on model that is not consistent.""); return kTfLiteError; } TfLiteStatus status = kTfLiteOk; if (state_ == kStateUninvokable) { ReportError(""Invoke called on model that is not ready.""); return kTfLiteError; } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) { ReportError(""Non-persistent memory is not available.""); return kTfLiteError; } TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""Invoke""); for (int execution_plan_index = 0; execution_plan_index < execution_plan_.size(); execution_plan_index++) { if (execution_plan_index == next_execution_plan_index_to_prepare_) { TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors()); TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >= execution_plan_index); } int node_index = execution_plan_[execution_plan_index]; TfLiteNode& node = nodes_and_registration_[node_index].first; const TfLiteRegistration& registration = nodes_and_registration_[node_index].second; const char* op_name = nullptr; if (profiler_) op_name = GetTFLiteOpName(registration); TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index); for (int i = 0; i < node.inputs->size; ++i) { int tensor_index = node.inputs->data[i]; if (tensor_index == kTfLiteOptionalTensor) { continue; } TfLiteTensor* tensor = &tensors_[tensor_index]; if (tensor->delegate && tensor->delegate != node.delegate && tensor->data_is_stale) { TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index)); } if (tensor->data.raw == nullptr && tensor->bytes > 0) { if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 && tensor->dims->size != 1) { continue; } else { ReportError(""Input tensor %d lacks data"", tensor_index); return kTfLiteError; } } } if (check_cancelled_func_ != nullptr && check_cancelled_func_(cancellation_data_)) { ReportError(""Client requested cancel during Invoke()""); return kTfLiteError; } EnsureTensorsVectorCapacity(); tensor_resized_since_op_invoke_ = false; if (OpInvoke(registration, &node) != kTfLiteOk) { return ReportOpError(&context_, node, registration, node_index, ""failed to invoke""); } if (tensor_resized_since_op_invoke_ && HasDynamicTensor(context_, node.outputs)) { next_execution_plan_index_to_prepare_ = execution_plan_index + 1; if (next_execution_plan_index_to_plan_allocation_ > next_execution_plan_index_to_prepare_) { next_execution_plan_index_to_plan_allocation_ = next_execution_plan_index_to_prepare_; if (memory_planner_) { TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter( next_execution_plan_index_to_plan_allocation_ - 1)); } } } } return status; }"
"ecma_value_t ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p,  ecma_value_t pattern_value,  ecma_value_t flags_value)  { ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value); uint16_t flags = 0; if (JERRY_UNLIKELY (pattern_str_p == NULL)) { return ECMA_VALUE_ERROR; } if (!ecma_is_value_undefined (flags_value)) { ecma_string_t *flags_str_p = ecma_op_to_string (flags_value); if (JERRY_UNLIKELY (flags_str_p == NULL)) { ecma_deref_ecma_string (pattern_str_p); return ECMA_VALUE_ERROR; } ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags); ecma_deref_ecma_string (flags_str_p); if (ECMA_IS_VALUE_ERROR (parse_flags_value)) { ecma_deref_ecma_string (pattern_str_p); return parse_flags_value; } JERRY_ASSERT (ecma_is_value_empty (parse_flags_value)); } const re_compiled_code_t *bc_p = NULL; ecma_value_t ret_value = re_compile_bytecode (&bc_p, pattern_str_p, flags); ecma_deref_ecma_string (pattern_str_p); if (ECMA_IS_VALUE_ERROR (ret_value)) { return ret_value; } JERRY_ASSERT (ecma_is_value_empty (ret_value)); ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags); return ecma_make_object_value (regexp_obj_p); }"
"static void prepare_singleton_class(mrb_state *mrb, struct RBasic *o) { struct RClass *sc, *c; if (o->c->tt == MRB_TT_SCLASS) return; sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class); sc->flags |= MRB_FL_CLASS_IS_INHERITED; sc->mt = mt_new(mrb); sc->iv = 0; if (o->tt == MRB_TT_CLASS) { c = (struct RClass*)o; if (!c->super) { sc->super = mrb->class_class; } else { sc->super = c->super->c; } } else if (o->tt == MRB_TT_SCLASS) { c = (struct RClass*)o; while (c->super->tt == MRB_TT_ICLASS) c = c->super; make_metaclass(mrb, c->super); sc->super = c->super->c; } else { sc->super = o->c; prepare_singleton_class(mrb, (struct RBasic*)sc); } o->c = sc; mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc); mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o); mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o)); sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN; }"
"int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx, const uint8_t *der_cert, size_t der_size, char **_filter, char ***_domains) { int ret; struct match_map_rule *r; struct priority_list *p; struct sss_cert_content *cert_content = NULL; char *filter = NULL; char **domains = NULL; size_t c; if (_filter == NULL || _domains == NULL) { return EINVAL; } ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content); if (ret != 0) { CM_DEBUG(ctx, ""Failed to get certificate content [%d]."", ret); return ret; } if (ctx->prio_list == NULL) { if (ctx->default_mapping_rule == NULL) { CM_DEBUG(ctx, ""No matching or mapping rules available.""); return EINVAL; } ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter); goto done; } for (p = ctx->prio_list; p != NULL; p = p->next) { for (r = p->rule_list; r != NULL; r = r->next) { ret = do_match(ctx, r->parsed_match_rule, cert_content); if (ret == 0) { ret = get_filter(ctx, r->parsed_mapping_rule, cert_content, &filter); if (ret != 0) { CM_DEBUG(ctx, ""Failed to get filter""); goto done; } if (r->domains != NULL) { for (c = 0; r->domains[c] != NULL; c++); domains = talloc_zero_array(ctx, char *, c + 1); if (domains == NULL) { ret = ENOMEM; goto done; } for (c = 0; r->domains[c] != NULL; c++) { domains[c] = talloc_strdup(domains, r->domains[c]); if (domains[c] == NULL) { ret = ENOMEM; goto done; } } } ret = 0; goto done; } } } ret = ENOENT; done: talloc_free(cert_content); if (ret == 0) { *_filter = filter; *_domains = domains; } else { talloc_free(filter); talloc_free(domains); } return ret; }"
"static int wolfSSH_SFTP_DoStatus(WOLFSSH* ssh, word32 reqId, WS_SFTP_BUFFER* buffer) { word32 sz; word32 status = WOLFSSH_FTP_FAILURE; word32 localIdx = wolfSSH_SFTP_buffer_idx(buffer); word32 maxIdx = wolfSSH_SFTP_buffer_size(buffer); byte* buf = wolfSSH_SFTP_buffer_data(buffer); (void)reqId; if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &status); localIdx += UINT32_SZ; if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &sz); localIdx += UINT32_SZ; if (sz > 0) { byte* s; if (localIdx + sz > maxIdx) { return WS_FATAL_ERROR; } s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (s == NULL) { return WS_MEMORY_E; } WMEMCPY(s, buf + localIdx, sz); s[sz] = '\0'; WLOG(WS_LOG_SFTP, ""Status Recv : %s"", s); WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER); localIdx += sz; } if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &sz); localIdx += UINT32_SZ; if (sz > 0) { byte* s; if (localIdx + sz > maxIdx) { return WS_FATAL_ERROR; } s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (s == NULL) { return WS_MEMORY_E; } WMEMCPY(s, buf + localIdx, sz); s[sz] = '\0'; WLOG(WS_LOG_SFTP, ""Status Language : %s"", s); WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER); localIdx += sz; } wolfSSH_SFTP_buffer_seek(buffer, 0, localIdx); return status; }"
"static int match_func(struct libmnt_fs *fs, void *data __attribute__ ((__unused__))) { int rc = flags & FL_INVERT ? 1 : 0; const char *m; void *md; m = get_match(COL_FSTYPE); if (m && !mnt_fs_match_fstype(fs, m)) return rc; m = get_match(COL_OPTIONS); if (m && !mnt_fs_match_options(fs, m)) return rc; md = get_match_data(COL_MAJMIN); if (md && mnt_fs_get_devno(fs) != *((dev_t *) md)) return rc; m = get_match(COL_TARGET); if (m && !mnt_fs_match_target(fs, m, cache)) return rc; m = get_match(COL_SOURCE); if (m && !mnt_fs_match_source(fs, m, cache)) return rc; if ((flags & FL_DF) && !(flags & FL_ALL)) { const char *type = mnt_fs_get_fstype(fs); if (type && strstr(type, ""tmpfs"")) return !rc; if (mnt_fs_is_pseudofs(fs)) return rc; } if ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs)) return rc; if ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs)) return rc; if ((flags & FL_SHADOWED)) { struct libmnt_table *tb = NULL; mnt_fs_get_table(fs, &tb); if (tb && mnt_table_over_fs(tb, fs, NULL) != 0) return rc; } if ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs)) return rc; return !rc; }"
"static const char *fuse_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *callback) { struct fuse_conn *fc = get_fuse_conn(inode); struct page *page; int err; err = -EIO; if (is_bad_inode(inode)) goto out_err; if (fc->cache_symlinks) return page_get_link(dentry, inode, callback); err = -ECHILD; if (!dentry) goto out_err; page = alloc_page(GFP_KERNEL); err = -ENOMEM; if (!page) goto out_err; err = fuse_readlink_page(inode, page); if (err) { __free_page(page); goto out_err; } set_delayed_call(callback, page_put_link, page); return page_address(page); out_err: return ERR_PTR(err); }"
"static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out, size_t *out_len, const unsigned char *key, size_t key_len) { PSKeyTransport_gost *pst = NULL; EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx); struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx); int pkey_nid = EVP_PKEY_base_id(pubk); unsigned char expkeys[64]; EVP_PKEY *sec_key = NULL; int ret = 0; int mac_nid = NID_undef; size_t mac_len = 0; int exp_len = 0, iv_len = 0; unsigned char *exp_buf = NULL; int key_is_ephemeral = 0; switch (data->cipher_nid) { case NID_magma_ctr: mac_nid = NID_magma_mac; mac_len = 8; iv_len = 4; break; case NID_grasshopper_ctr: mac_nid = NID_grasshopper_mac; mac_len = 16; iv_len = 8; break; default: GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER); return -1; break; } exp_len = key_len + mac_len; exp_buf = OPENSSL_malloc(exp_len); if (!exp_buf) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); return -1; } sec_key = EVP_PKEY_CTX_get0_peerkey(pctx); if (!sec_key) { sec_key = EVP_PKEY_new(); if (sec_key == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE ); goto err; } if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new()) || !EVP_PKEY_copy_parameters(sec_key, pubk) || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } key_is_ephemeral = 1; } if (data->shared_ukm_size == 0) { if (RAND_bytes(data->shared_ukm, 32) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR); goto err; } data->shared_ukm_size = 32; } if (gost_keg(data->shared_ukm, pkey_nid, EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)), EVP_PKEY_get0(sec_key), expkeys) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS); goto err; } if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len, exp_buf, &exp_len) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } pst = PSKeyTransport_gost_new(); if (!pst) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } pst->ukm = ASN1_OCTET_STRING_new(); if (pst->ukm == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } if ((*out_len = i2d_PSKeyTransport_gost(pst, out ? &out : NULL)) > 0) ret = 1; err: OPENSSL_cleanse(expkeys, sizeof(expkeys)); if (key_is_ephemeral) EVP_PKEY_free(sec_key); PSKeyTransport_gost_free(pst); OPENSSL_free(exp_buf); return ret; }"
"static bool create_section_from_phdr(ELFOBJ *bin, RzVector *result, const char *name, ut64 addr, ut64 sz) { RzBinElfSection *section = rz_vector_push(result, NULL); if (!section) { RZ_LOG_WARN(""Failed to allocate memory for the section."") return false; } section->offset = Elf_(rz_bin_elf_v2p_new)(bin, addr); if (section->offset == UT64_MAX) { RZ_LOG_WARN(""invalid section offset."") return false; } section->rva = addr; section->size = sz; section->name = strdup(name); if (!section->name) { RZ_LOG_WARN(""Failed to allocate memory for the section name."") return false; } return true; }"
"static void append_options(DBusMessageIter *iter, void *user_data) { struct pending_op *op = user_data; const char *path = device_get_path(op->device); struct bt_gatt_server *server; const char *link; uint16_t mtu; switch (op->link_type) { case BT_ATT_BREDR: link = ""BR/EDR""; break; case BT_ATT_LE: link = ""LE""; break; default: link = NULL; break; } dict_append_entry(iter, ""device"", DBUS_TYPE_OBJECT_PATH, &path); if (op->offset) dict_append_entry(iter, ""offset"", DBUS_TYPE_UINT16, &op->offset); if (link) dict_append_entry(iter, ""link"", DBUS_TYPE_STRING, &link); if (op->prep_authorize) dict_append_entry(iter, ""prepare-authorize"", DBUS_TYPE_BOOLEAN, &op->prep_authorize); server = btd_device_get_gatt_server(op->device); mtu = bt_gatt_server_get_mtu(server); dict_append_entry(iter, ""mtu"", DBUS_TYPE_UINT16, &mtu); }"
"static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length, BtifAvrcpAudioTrack* trackHolder) { size_t sampleSize = sampleSizeFor(trackHolder); size_t i = 0; for (; i <= length / sampleSize; i++) { trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat; } return i * sampleSize; }"
"bool PathGroup::hasPath(const std::string& name, Http::Method method) const { auto group = paths(name); auto it    = std::find_if(std::begin(group), std::end(group), [&](const Path& p) { return p.method == method; }); return it != std::end(group); }"
"const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst, socklen_t size) { if (!src || !dst) { errno = EFAULT; return nullptr; } size_t src_size = 0; if (af == AF_INET) { src_size = sizeof(struct in_addr); } else if (af == AF_INET6) { src_size = sizeof(struct in6_addr); } else { errno = EAFNOSUPPORT; return nullptr; } MessageWriter input; input.Push<int>(TokLinuxAfFamily(af)); input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size}); input.Push(size); MessageReader output; const auto status = NonSystemCallDispatcher( ::asylo::host_call::kInetNtopHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_ntop"", 2); auto result = output.next(); int klinux_errno = output.next<int>(); if (result.empty()) { errno = FromkLinuxErrorNumber(klinux_errno); return nullptr; } memcpy(dst, result.data(), std::min(static_cast<size_t>(size), static_cast<size_t>(INET6_ADDRSTRLEN))); return dst; }"
"static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data) { size_t realsize = 0; connection_t *conn = NULL; char *ptr = NULL; conn = data; ogs_assert(conn); realsize = size * nmemb; ptr = ogs_realloc(conn->memory, conn->size + realsize + 1); if(!ptr) { ogs_fatal(""not enough memory (realloc returned NULL)""); ogs_assert_if_reached(); return 0; } conn->memory = ptr; memcpy(&(conn->memory[conn->size]), contents, realsize); conn->size += realsize; conn->memory[conn->size] = 0; return realsize; }"
"LiteralString(const std::string &s, bool ignore_case) : lit_(s), ignore_case_(ignore_case), is_word_(false) {}"
"static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current) { u32 count; count = gf_list_count(parser->entities); while (count) { char *entityEnd; XML_Entity *ent; char *entityStart = strstr(current, ""&""); Bool needs_text; u32 line_num; if (parser->in_entity) { u32 len; char *name; entityEnd = strstr(current, "";""); if (!entityEnd) return xml_sax_append_string(parser, current); entityStart = strrchr(parser->buffer, '&'); entityEnd[0] = 0; len = (u32) strlen(entityStart) + (u32) strlen(current) + 1; name = (char*)gf_malloc(sizeof(char)*len); sprintf(name, ""%s%s;"", entityStart+1, current); ent = gf_xml_locate_entity(parser, name, &needs_text); gf_free(name); if (!ent && !needs_text) { xml_sax_append_string(parser, current); xml_sax_parse(parser, GF_TRUE); entityEnd[0] = ';'; current = entityEnd; continue; } assert(ent); parser->line_size -= (u32) strlen(entityStart); entityStart[0] = 0; parser->in_entity = GF_FALSE; entityEnd[0] = ';'; current = entityEnd+1; } else { if (!entityStart) break; ent = gf_xml_locate_entity(parser, entityStart+1, &needs_text); entityStart[0] = 0; xml_sax_append_string(parser, current); xml_sax_parse(parser, GF_TRUE); entityStart[0] = '&'; if (!ent && !needs_text) { xml_sax_append_string(parser, ""&""); current = entityStart+1; continue; } if (!ent) { parser->in_entity = GF_TRUE; return xml_sax_append_string(parser, entityStart); } current = entityStart + ent->namelen + 2; } line_num = parser->line; xml_sax_append_string(parser, ent->value); GF_Err e = xml_sax_parse(parser, GF_TRUE); parser->line = line_num; if (e) return e; } xml_sax_append_string(parser, current); return xml_sax_parse(parser, GF_FALSE); }"
"Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context, NodeCosts* node_costs) const { bool found_unknown_shapes = false; const auto& op_info = op_context.op_info; ConvolutionDimensions dims = OpDimensionsFromInputs( op_info.inputs(0).shape(), op_info, &found_unknown_shapes); int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1; int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops; node_costs->num_compute_ops = ops; int64_t input_size = 0; if (dims.ky >= dims.sy) { input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes); } else {                  const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype())); input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz; } node_costs->num_input_bytes_accessed = {input_size}; const int64_t output_size = CalculateOutputSize(op_info, &found_unknown_shapes); node_costs->num_output_bytes_accessed = {output_size}; node_costs->max_memory = output_size; if (found_unknown_shapes) { node_costs->inaccurate = true; node_costs->num_nodes_with_unknown_shapes = 1; } return Status::OK(); }"
"static void *kmalloc_reserve(unsigned int *size, gfp_t flags, int node, bool *pfmemalloc) { bool ret_pfmemalloc = false; unsigned int obj_size; void *obj; obj_size = SKB_HEAD_ALIGN(*size); if (obj_size <= SKB_SMALL_HEAD_CACHE_SIZE && !(flags & KMALLOC_NOT_NORMAL_BITS)) { obj = kmem_cache_alloc_node(skb_small_head_cache, flags | __GFP_NOMEMALLOC | __GFP_NOWARN, node); *size = SKB_SMALL_HEAD_CACHE_SIZE; if (obj || !(gfp_pfmemalloc_allowed(flags))) goto out; ret_pfmemalloc = true; obj = kmem_cache_alloc_node(skb_small_head_cache, flags, node); goto out; } *size = obj_size = kmalloc_size_roundup(obj_size); obj = kmalloc_node_track_caller(obj_size, flags | __GFP_NOMEMALLOC | __GFP_NOWARN, node); if (obj || !(gfp_pfmemalloc_allowed(flags))) goto out; ret_pfmemalloc = true; obj = kmalloc_node_track_caller(obj_size, flags, node); out: if (pfmemalloc) *pfmemalloc = ret_pfmemalloc; return obj; }"
"static gboolean xcf_load_image_props (XcfInfo   *info, GimpImage *image) { PropType prop_type; guint32  prop_size; while (TRUE) { if (! xcf_load_prop (info, &prop_type, &prop_size)) return FALSE; switch (prop_type) { case PROP_END: return TRUE; case PROP_COLORMAP: { guint32 n_colors; guchar  cmap[GIMP_IMAGE_COLORMAP_SIZE]; xcf_read_int32 (info, &n_colors, 1); if (n_colors > (GIMP_IMAGE_COLORMAP_SIZE / 3)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_ERROR, ""Maximum colormap size (%d) exceeded"", GIMP_IMAGE_COLORMAP_SIZE); return FALSE; } if (info->file_version == 0) { gint i; gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, _(""XCF warning: version 0 of XCF file format\n"" ""did not save indexed colormaps correctly.\n"" ""Substituting grayscale map."")); if (! xcf_seek_pos (info, info->cp + n_colors, NULL)) return FALSE; for (i = 0; i < n_colors; i++) { cmap[i * 3 + 0] = i; cmap[i * 3 + 1] = i; cmap[i * 3 + 2] = i; } } else { xcf_read_int8 (info, cmap, n_colors * 3); } if (gimp_image_get_base_type (image) == GIMP_INDEXED) gimp_image_set_colormap (image, cmap, n_colors, FALSE); GIMP_LOG (XCF, ""prop colormap n_colors=%d"", n_colors); } break; case PROP_COMPRESSION: { guint8 compression; xcf_read_int8 (info, (guint8 *) &compression, 1); if ((compression != COMPRESS_NONE) && (compression != COMPRESS_RLE) && (compression != COMPRESS_ZLIB) && (compression != COMPRESS_FRACTAL)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_ERROR, ""Unknown compression type: %d"", (gint) compression); return FALSE; } info->compression = compression; gimp_image_set_xcf_compression (image, compression >= COMPRESS_ZLIB); GIMP_LOG (XCF, ""prop compression=%d"", compression); } break; case PROP_GUIDES: { GimpImagePrivate *private = GIMP_IMAGE_GET_PRIVATE (image); gint32            position; gint8             orientation; gint              i, nguides; nguides = prop_size / (4 + 1); for (i = 0; i < nguides; i++) { xcf_read_int32 (info, (guint32 *) &position,    1); xcf_read_int8  (info, (guint8 *)  &orientation, 1); if (info->file_version < 15 && position < 0) continue; GIMP_LOG (XCF, ""prop guide orientation=%d position=%d"", orientation, position); switch (orientation) { case XCF_ORIENTATION_HORIZONTAL: if (info->file_version < 15 && position > gimp_image_get_height (image)) gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Ignoring off-canvas horizontal guide (position %d) in XCF %d file"", position, info->file_version); else gimp_image_add_hguide (image, position, FALSE); break; case XCF_ORIENTATION_VERTICAL: if (info->file_version < 15 && position > gimp_image_get_width (image)) gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Ignoring off-canvas vertical guide (position %d) in XCF %d file"", position, info->file_version); else gimp_image_add_vguide (image, position, FALSE); break; default: gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Guide orientation out of range in XCF file""); continue; } } private->guides = g_list_reverse (private->guides); } break; case PROP_SAMPLE_POINTS: { gint n_sample_points, i; n_sample_points = prop_size / (5 * 4); for (i = 0; i < n_sample_points; i++) { GimpSamplePoint   *sample_point; gint32             x, y; GimpColorPickMode  pick_mode; guint32            padding[2] = { 0, }; xcf_read_int32 (info, (guint32 *) &x,         1); xcf_read_int32 (info, (guint32 *) &y,         1); xcf_read_int32 (info, (guint32 *) &pick_mode, 1); xcf_read_int32 (info, (guint32 *) padding,    2); GIMP_LOG (XCF, ""prop sample point x=%d y=%d mode=%d"", x, y, pick_mode); if (pick_mode > GIMP_COLOR_PICK_MODE_LAST) pick_mode = GIMP_COLOR_PICK_MODE_PIXEL; sample_point = gimp_image_add_sample_point_at_pos (image, x, y, FALSE); gimp_image_set_sample_point_pick_mode (image, sample_point, pick_mode, FALSE); } } break; case PROP_OLD_SAMPLE_POINTS: { gint32 x, y; gint   i, n_sample_points; if (gimp_image_get_sample_points (image)) { if (! xcf_skip_unknown_prop (info, prop_size)) return FALSE; break; } n_sample_points = prop_size / (4 + 4); for (i = 0; i < n_sample_points; i++) { xcf_read_int32 (info, (guint32 *) &x, 1); xcf_read_int32 (info, (guint32 *) &y, 1); GIMP_LOG (XCF, ""prop old sample point x=%d y=%d"", x, y); gimp_image_add_sample_point_at_pos (image, x, y, FALSE); } } break; case PROP_RESOLUTION: { gfloat xres, yres; xcf_read_float (info, &xres, 1); xcf_read_float (info, &yres, 1); GIMP_LOG (XCF, ""prop resolution x=%f y=%f"", xres, yres); if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION || yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION) { GimpTemplate *template = image->gimp->config->default_image; gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, resolution out of range in XCF file""); xres = gimp_template_get_resolution_x (template); yres = gimp_template_get_resolution_y (template); } gimp_image_set_resolution (image, xres, yres); } break; case PROP_TATTOO: { xcf_read_int32 (info, &info->tattoo_state, 1); GIMP_LOG (XCF, ""prop tattoo state=%d"", info->tattoo_state); } break; case PROP_PARASITES: { goffset base = info->cp; while (info->cp - base < prop_size) { GimpParasite *p     = xcf_load_parasite (info); GError       *error = NULL; if (! p) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Invalid image parasite found. "" ""Possibly corrupt XCF file.""); xcf_seek_pos (info, base + prop_size, NULL); continue; } if (! gimp_image_parasite_validate (image, p, &error)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, invalid image parasite in XCF file: %s"", error->message); g_clear_error (&error); } else { gimp_image_parasite_attach (image, p, FALSE); } gimp_parasite_free (p); } if (info->cp - base != prop_size) gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Error while loading an image's parasites""); } break; case PROP_UNIT: { guint32 unit; xcf_read_int32 (info, &unit, 1); GIMP_LOG (XCF, ""prop unit=%d"", unit); if ((unit <= GIMP_UNIT_PIXEL) || (unit >= gimp_unit_get_number_of_built_in_units ())) { gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, unit out of range in XCF file, "" ""falling back to inches""); unit = GIMP_UNIT_INCH; } gimp_image_set_unit (image, unit); } break; case PROP_PATHS: xcf_load_old_paths (info, image); break; case PROP_USER_UNIT: { gchar    *unit_strings[5]; float     factor; guint32   digits; GimpUnit  unit; gint      num_units; gint      i; xcf_read_float  (info, &factor,      1); xcf_read_int32  (info, &digits,      1); xcf_read_string (info, unit_strings, 5); for (i = 0; i < 5; i++) if (unit_strings[i] == NULL) unit_strings[i] = g_strdup (""""); num_units = gimp_unit_get_number_of_units (); for (unit = gimp_unit_get_number_of_built_in_units (); unit < num_units; unit++) { if ((ABS (gimp_unit_get_factor (unit) - factor) < 1e-5) && (strcmp (unit_strings[0], gimp_unit_get_identifier (unit)) == 0)) { break; } } if (unit == num_units) unit = gimp_unit_new (unit_strings[0], factor, digits, unit_strings[1], unit_strings[2], unit_strings[3], unit_strings[4]); gimp_image_set_unit (image, unit); for (i = 0; i < 5; i++) g_free (unit_strings[i]); } break; case PROP_VECTORS: { goffset base = info->cp; if (xcf_load_vectors (info, image)) { if (base + prop_size != info->cp) { g_printerr (""Mismatch in PROP_VECTORS size: "" ""skipping %"" G_GOFFSET_FORMAT "" bytes.\n"", base + prop_size - info->cp); xcf_seek_pos (info, base + prop_size, NULL); } } else { xcf_seek_pos (info, base + prop_size, NULL); } } break; case PROP_ITEM_SET: { GimpItemList *set       = NULL; gchar        *label; GType         item_type = 0; guint32       itype; guint32       method; xcf_read_int32  (info, &itype, 1); xcf_read_int32  (info, &method, 1); xcf_read_string (info, &label, 1); if (itype == 0) item_type = GIMP_TYPE_LAYER; else item_type = GIMP_TYPE_CHANNEL; if (itype > 1) { g_printerr (""xcf: unsupported item set '%s' type: %d (skipping)\n"", label ? label : ""unnamed"", itype); break; } else if (label == NULL) { g_printerr (""xcf: item set without a name or pattern (skipping)\n""); } else if (method != G_MAXUINT32 && method > GIMP_SELECT_GLOB_PATTERN) { g_printerr (""xcf: unsupported item set '%s' selection method attribute: 0x%x (skipping)\n"", label, method); } else { if (method == G_MAXUINT32) { set = g_object_new (GIMP_TYPE_ITEM_LIST, ""image"",      image, ""name"",       label, ""is-pattern"", FALSE, ""item-type"",  item_type, ""items"",      NULL, NULL); } else { set = gimp_item_list_pattern_new (image, item_type, method, label); } } if (item_type == GIMP_TYPE_LAYER) info->layer_sets = g_list_prepend (info->layer_sets, set); else info->channel_sets = g_list_prepend (info->channel_sets, set); } break; default: #ifdef GIMP_UNSTABLE g_printerr (""unexpected/unknown image property: %d (skipping)\n"", prop_type); #endif if (! xcf_skip_unknown_prop (info, prop_size)) return FALSE; break; } } return FALSE; }"
"static gboolean handle_spawn (PortalFlatpak         *object, GDBusMethodInvocation *invocation, GUnixFDList           *fd_list, const gchar           *arg_cwd_path, const gchar *const    *arg_argv, GVariant              *arg_fds, GVariant              *arg_envs, guint                  arg_flags, GVariant              *arg_options) { g_autoptr(GError) error = NULL; ChildSetupData child_setup_data = { NULL }; GPid pid; PidData *pid_data; InstanceIdReadData *instance_id_read_data = NULL; gsize i, j, n_fds, n_envs; const gint *fds = NULL; gint fds_len = 0; g_autofree FdMapEntry *fd_map = NULL; gchar **env; gint32 max_fd; GKeyFile *app_info; g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free); g_autofree char *app_id = NULL; g_autofree char *branch = NULL; g_autofree char *arch = NULL; g_autofree char *app_commit = NULL; g_autofree char *runtime_ref = NULL; g_auto(GStrv) runtime_parts = NULL; g_autofree char *runtime_commit = NULL; g_autofree char *instance_path = NULL; g_auto(GStrv) extra_args = NULL; g_auto(GStrv) shares = NULL; g_auto(GStrv) sockets = NULL; g_auto(GStrv) devices = NULL; g_auto(GStrv) sandbox_expose = NULL; g_auto(GStrv) sandbox_expose_ro = NULL; g_autoptr(GVariant) sandbox_expose_fd = NULL; g_autoptr(GVariant) sandbox_expose_fd_ro = NULL; g_autoptr(GOutputStream) instance_id_out_stream = NULL; guint sandbox_flags = 0; gboolean sandboxed; gboolean expose_pids; gboolean share_pids; gboolean notify_start; gboolean devel; g_autoptr(GString) env_string = g_string_new (""""); child_setup_data.instance_id_fd = -1; child_setup_data.env_fd = -1; if (fd_list != NULL) fds = g_unix_fd_list_peek_fds (fd_list, &fds_len); app_info = g_object_get_data (G_OBJECT (invocation), ""app-info""); g_assert (app_info != NULL); app_id = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_APPLICATION, FLATPAK_METADATA_KEY_NAME, NULL); g_assert (app_id != NULL); g_debug (""spawn() called from app: '%s'"", app_id); if (*app_id == 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak""); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (*arg_cwd_path == 0) arg_cwd_path = NULL; if (arg_argv == NULL || *arg_argv == NULL) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No command given""); return G_DBUS_METHOD_INVOCATION_HANDLED; } if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Unsupported flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL); return G_DBUS_METHOD_INVOCATION_HANDLED; } runtime_ref = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_APPLICATION, FLATPAK_METADATA_KEY_RUNTIME, NULL); if (runtime_ref == NULL) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No runtime found""); return G_DBUS_METHOD_INVOCATION_HANDLED; } runtime_parts = g_strsplit (runtime_ref, ""/"", -1); branch = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_BRANCH, NULL); instance_path = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL); arch = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_ARCH, NULL); extra_args = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL); app_commit = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_APP_COMMIT, NULL); runtime_commit = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL); shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL, NULL); sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL); devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL, NULL); devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_DEVEL, NULL); g_variant_lookup (arg_options, ""sandbox-expose"", ""^as"", &sandbox_expose); g_variant_lookup (arg_options, ""sandbox-expose-ro"", ""^as"", &sandbox_expose_ro); g_variant_lookup (arg_options, ""sandbox-flags"", ""u"", &sandbox_flags); sandbox_expose_fd = g_variant_lookup_value (arg_options, ""sandbox-expose-fd"", G_VARIANT_TYPE (""ah"")); sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, ""sandbox-expose-fd-ro"", G_VARIANT_TYPE (""ah"")); if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Unsupported sandbox flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (instance_path == NULL && ((sandbox_expose != NULL && sandbox_expose[0] != NULL) || (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL))) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Invalid sandbox expose, caller has no instance path""); return G_DBUS_METHOD_INVOCATION_HANDLED; } for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++) { const char *expose = sandbox_expose[i]; g_debug (""exposing %s"", expose); if (!is_valid_expose (expose, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } } for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) { const char *expose = sandbox_expose_ro[i]; g_debug (""exposing %s"", expose); if (!is_valid_expose (expose, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } } g_debug (""Running spawn command %s"", arg_argv[0]); n_fds = 0; if (fds != NULL) n_fds = g_variant_n_children (arg_fds); fd_map = g_new0 (FdMapEntry, n_fds); child_setup_data.fd_map = fd_map; child_setup_data.fd_map_len = n_fds; max_fd = -1; for (i = 0; i < n_fds; i++) { gint32 handle, dest_fd; int handle_fd; g_variant_get_child (arg_fds, i, ""{uh}"", &dest_fd, &handle); if (handle >= fds_len || handle < 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } handle_fd = fds[handle]; fd_map[i].to = dest_fd; fd_map[i].from = handle_fd; fd_map[i].final = fd_map[i].to; if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) && !child_setup_data.set_tty && isatty (handle_fd)) { child_setup_data.set_tty = TRUE; child_setup_data.tty = handle_fd; } max_fd = MAX (max_fd, fd_map[i].to); max_fd = MAX (max_fd, fd_map[i].from); } for (i = 0; i < n_fds; i++) { int to_fd = fd_map[i].to; gboolean conflict = FALSE; for (j = i + 1; j < n_fds; j++) { int from_fd = fd_map[j].from; if (from_fd == to_fd) { conflict = TRUE; break; } } if (conflict) fd_map[i].to = ++max_fd; } if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV) { char *empty[] = { NULL }; env = g_strdupv (empty); } else env = g_get_environ (); n_envs = g_variant_n_children (arg_envs); for (i = 0; i < n_envs; i++) { const char *var = NULL; const char *val = NULL; g_variant_get_child (arg_envs, i, ""{&s&s}"", &var, &val); env = g_environ_setenv (env, var, val, TRUE); } g_ptr_array_add (flatpak_argv, g_strdup (""flatpak"")); g_ptr_array_add (flatpak_argv, g_strdup (""run"")); sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0; if (sandboxed) { g_ptr_array_add (flatpak_argv, g_strdup (""--sandbox"")); if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY) { if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""wayland"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=wayland"")); if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""fallback-x11"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=fallback-x11"")); if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""x11"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=x11"")); if (shares != NULL && g_strv_contains ((const char * const *) shares, ""ipc"") && sockets != NULL && (g_strv_contains ((const char * const *) sockets, ""fallback-x11"") || g_strv_contains ((const char * const *) sockets, ""x11""))) g_ptr_array_add (flatpak_argv, g_strdup (""--share=ipc"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND) { if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""pulseaudio"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=pulseaudio"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU) { if (devices != NULL && (g_strv_contains ((const char * const *) devices, ""dri"") || g_strv_contains ((const char * const *) devices, ""all""))) g_ptr_array_add (flatpak_argv, g_strdup (""--device=dri"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS) g_ptr_array_add (flatpak_argv, g_strdup (""--session-bus"")); if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y) g_ptr_array_add (flatpak_argv, g_strdup (""--a11y-bus"")); } else { for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++) { if (g_str_has_prefix (extra_args[i], ""--env="")) { const char *var_val = extra_args[i] + strlen (""--env=""); if (var_val[0] == '\0' || var_val[0] == '=') { g_warning (""Environment variable in extra-args has empty name""); continue; } if (strchr (var_val, '=') == NULL) { g_warning (""Environment variable in extra-args has no value""); continue; } g_string_append (env_string, var_val); g_string_append_c (env_string, '\0'); } else { g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i])); } } } if (env_string->len > 0) { g_auto(GLnxTmpfile) env_tmpf  = { 0, }; if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, ""environ"", env_string->str, env_string->len, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--env-fd=%d"", child_setup_data.env_fd)); } expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0; share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0; if (expose_pids || share_pids) { g_autofree char *instance_id = NULL; int sender_pid1 = 0; if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS)) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED, ""Expose pids not supported with setuid bwrap""); return G_DBUS_METHOD_INVOCATION_HANDLED; } instance_id = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_INSTANCE_ID, NULL); if (instance_id) { g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id); sender_pid1 = flatpak_instance_get_child_pid (instance); } if (sender_pid1 == 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Could not find requesting pid""); return G_DBUS_METHOD_INVOCATION_HANDLED; } g_ptr_array_add (flatpak_argv, g_strdup_printf (""--parent-pid=%d"", sender_pid1)); if (share_pids) g_ptr_array_add (flatpak_argv, g_strdup (""--parent-share-pids"")); else g_ptr_array_add (flatpak_argv, g_strdup (""--parent-expose-pids"")); } notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0; if (notify_start) { int pipe_fds[2]; if (pipe (pipe_fds) == -1) { int errsv = errno; g_dbus_method_invocation_return_error (invocation, G_IO_ERROR, g_io_error_from_errno (errsv), ""Failed to create instance ID pipe: %s"", g_strerror (errsv)); return G_DBUS_METHOD_INVOCATION_HANDLED; } GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE)); instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE)); instance_id_read_data = g_new0 (InstanceIdReadData, 1); g_input_stream_read_async (in_stream, instance_id_read_data->buffer, INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL, instance_id_read_finish, instance_id_read_data); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--instance-id-fd=%d"", pipe_fds[1])); child_setup_data.instance_id_fd = pipe_fds[1]; } if (devel) g_ptr_array_add (flatpak_argv, g_strdup (""--devel"")); if (shares != NULL && g_strv_contains ((const char * const *) shares, ""network"") && !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK)) g_ptr_array_add (flatpak_argv, g_strdup (""--share=network"")); else g_ptr_array_add (flatpak_argv, g_strdup (""--unshare=network"")); if (instance_path) { for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++) g_ptr_array_add (flatpak_argv, filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE)); for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) g_ptr_array_add (flatpak_argv, filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE)); } for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) { const char *expose = sandbox_expose_ro[i]; g_debug (""exposing %s"", expose); } if (sandbox_expose_fd != NULL) { gsize len = g_variant_n_children (sandbox_expose_fd); for (i = 0; i < len; i++) { gint32 handle; g_variant_get_child (sandbox_expose_fd, i, ""h"", &handle); if (handle >= 0 && handle < fds_len) { int handle_fd = fds[handle]; g_autofree char *path = NULL; gboolean writable = FALSE; path = get_path_for_fd (handle_fd, &writable, &error); if (path) { g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable)); } else { g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"", handle_fd, error->message); g_clear_error (&error); } } else { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } } } if (sandbox_expose_fd_ro != NULL) { gsize len = g_variant_n_children (sandbox_expose_fd_ro); for (i = 0; i < len; i++) { gint32 handle; g_variant_get_child (sandbox_expose_fd_ro, i, ""h"", &handle); if (handle >= 0 && handle < fds_len) { int handle_fd = fds[handle]; g_autofree char *path = NULL; gboolean writable = FALSE; path = get_path_for_fd (handle_fd, &writable, &error); if (path) { g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE)); } else { g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"", handle_fd, error->message); g_clear_error (&error); } } else { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } } } g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime=%s"", runtime_parts[1])); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-version=%s"", runtime_parts[3])); if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0) { if (app_commit) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--commit=%s"", app_commit)); if (runtime_commit) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-commit=%s"", runtime_commit)); } if (arg_cwd_path != NULL) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--cwd=%s"", arg_cwd_path)); if (arg_argv[0][0] != 0) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--command=%s"", arg_argv[0])); g_ptr_array_add (flatpak_argv, g_strdup_printf (""%s/%s/%s"", app_id, arch ? arch : """", branch ? branch : """")); for (i = 1; arg_argv[i] != NULL; i++) g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i])); g_ptr_array_add (flatpak_argv, NULL); if (opt_verbose) { g_autoptr(GString) cmd = g_string_new (""""); for (i = 0; flatpak_argv->pdata[i] != NULL; i++) { if (i > 0) g_string_append (cmd, "" ""); g_string_append (cmd, flatpak_argv->pdata[i]); } g_debug (""Starting: %s\n"", cmd->str); } if (!g_spawn_async_with_pipes (NULL, (char **) flatpak_argv->pdata, env, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN, child_setup_func, &child_setup_data, &pid, NULL, NULL, NULL, &error)) { gint code = G_DBUS_ERROR_FAILED; if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES)) code = G_DBUS_ERROR_ACCESS_DENIED; else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT)) code = G_DBUS_ERROR_FILE_NOT_FOUND; g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code, ""Failed to start command: %s"", error->message); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (instance_id_read_data) instance_id_read_data->pid = pid; pid_data = g_new0 (PidData, 1); pid_data->pid = pid; pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation)); pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0; pid_data->expose_or_share_pids = (expose_pids || share_pids); pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, child_watch_died, pid_data, NULL); g_debug (""Client Pid is %d"", pid_data->pid); g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid), pid_data); portal_flatpak_complete_spawn (object, invocation, NULL, pid); return G_DBUS_METHOD_INVOCATION_HANDLED; }"
"static int spl2sw_nvmem_get_mac_address(struct device *dev, struct device_node *np, void *addrbuf) { struct nvmem_cell *cell; ssize_t len; u8 *mac; cell = of_nvmem_cell_get(np, ""mac-address""); if (IS_ERR(cell)) return PTR_ERR(cell); mac = nvmem_cell_read(cell, &len); nvmem_cell_put(cell); if (IS_ERR(mac)) return PTR_ERR(mac); if (len != ETH_ALEN) { kfree(mac); dev_info(dev, ""Invalid length of mac address in nvmem!\n""); return -EINVAL; } spl2sw_check_mac_vendor_id_and_convert(mac); if (!is_valid_ether_addr(mac)) { kfree(mac); dev_info(dev, ""Invalid mac address in nvmem (%pM)!\n"", mac); return -EINVAL; } ether_addr_copy(addrbuf, mac); kfree(mac); return 0; }"
"void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override { const Tensor* indices; OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices)); const Tensor* values; OP_REQUIRES_OK(ctx, ctx->input(""values"", &values)); const Tensor* dense_shape; OP_REQUIRES_OK(ctx, ctx->input(""dense_shape"", &dense_shape)); OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()), errors::InvalidArgument( ""Input indices should be a matrix but received shape "", indices->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()), errors::InvalidArgument( ""Input values should be a vector but received shape "", indices->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()), errors::InvalidArgument( ""Input shape should be a vector but received shape "", dense_shape->shape().DebugString())); int64_t previous_batch_index = -1; for (int64_t i = 0; i < indices->dim_size(0); ++i) { int64_t next_batch_index = indices->matrix<int64>()(i, 0); OP_REQUIRES( ctx, next_batch_index >= previous_batch_index, errors::Unimplemented(""The SparseTensor must be ordered in the batch "" ""dimension; handling arbitrarily ordered input "" ""is not currently supported."")); previous_batch_index = next_batch_index; } gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0); sparse::SparseTensor tensor; OP_REQUIRES_OK( ctx, sparse::SparseTensor::Create( *indices, *values, TensorShape(dense_shape->vec<int64>()), std_order, &tensor)); *output = new Dataset<T>(ctx, std::move(tensor)); }"
"Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) { DCHECK_EQ(t.args_size(), 3); const auto& cont = t.args(0); const auto& tmpl = t.args(1); const auto& t_var = t.args(2); StringPiece var_name = t_var.s(); if (!attrs.contains(var_name)) { return Status( error::INVALID_ARGUMENT, absl::StrCat(""could not find an attribute for key '"", var_name, ""'"")); } const AttrValue* attr = attrs.at(var_name); FullTypeDef result; result.set_type_id(cont.type_id()); const auto attr_type = attr->value_case(); if (attr_type == AttrValue::kType) { FullTypeDef* target = result.add_args(); *target = tmpl; TF_RETURN_WITH_CONTEXT_IF_ERROR( SubstituteFromAttrs(attrs, *target), ""while substituting '"", var_name, ""' from\n"", attr->DebugString(), ""\ninto "", target->DebugString()); } else if (attr_type == AttrValue::kList) { const auto& attr_list = attr->list(); int tsize = attr_list.type_size(); if (tsize == 0) { return Status(error::UNIMPLEMENTED, absl::StrCat(""unsupported list attribute type\n"", attr_list.DebugString(), ""\nkey="", var_name)); } AttrValue replacement; attrs[var_name] = &replacement; for (int i = 0; i < tsize; i++) { replacement.set_type(attr_list.type(i)); FullTypeDef* target = result.add_args(); *target = tmpl; TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target), ""while substituting '"", var_name, ""' from\n"", attr->DebugString(), ""\n["", i, ""] into\n"", target->DebugString()); } attrs[var_name] = attr; } else { return Status(error::UNIMPLEMENTED, absl::StrCat(""unsupported attribute type\n"", attr->DebugString(), ""\nfor name "", var_name)); } t = result; return OkStatus(); }"
"int db_update(char* name, char* value) { char* sql; int r = 0; if (crypt_key) { value = note_encrypt(value,crypt_key); r = asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'"", value, name); free(value); if (r < 0) return 1; }else{ if (asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'"", value, name) < 0) return 1; } r = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg); free(sql); return r; }"
"static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *spdm_context, const uint32_t *session_id, size_t *response_size, void **response, uint8_t original_request_code, uint8_t expected_response_code) { spdm_error_response_t *spdm_response; spdm_error_data_response_not_ready_t *extend_error_data; if(*response_size < sizeof(spdm_error_response_t) + sizeof(spdm_error_data_response_not_ready_t)) { return LIBSPDM_STATUS_INVALID_MSG_SIZE; } spdm_response = *response; extend_error_data = (spdm_error_data_response_not_ready_t *)(spdm_response + 1); LIBSPDM_ASSERT(spdm_response->header.request_response_code == SPDM_ERROR); LIBSPDM_ASSERT(spdm_response->header.param1 == SPDM_ERROR_CODE_RESPONSE_NOT_READY); if (extend_error_data->request_code != original_request_code) { return LIBSPDM_STATUS_INVALID_MSG_FIELD; } if (extend_error_data->rd_tm <= 1) { return LIBSPDM_STATUS_INVALID_MSG_FIELD; } spdm_context->error_data.rd_exponent = extend_error_data->rd_exponent; spdm_context->error_data.request_code = extend_error_data->request_code; spdm_context->error_data.token = extend_error_data->token; spdm_context->error_data.rd_tm = extend_error_data->rd_tm; libspdm_sleep((2 << extend_error_data->rd_exponent)); return libspdm_requester_respond_if_ready(spdm_context, session_id, response_size, response, expected_response_code); }"
static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id) { unsigned long h; const unsigned char *p; h = id->iface; h = MULTIPLIER * h + id->device; h = MULTIPLIER * h + id->subdevice; for (p = id->name; *p; p++) h = MULTIPLIER * h + *p; h = MULTIPLIER * h + id->index; h &= LONG_MAX; return h; }
"static int mj_raster_cmd(int c_id, int in_size, byte* in, byte* buf2, gx_device_printer* pdev, gp_file* prn_stream) { int band_size = 1; byte *out = buf2; int width = in_size; int count; byte* in_end = in + in_size; static char colour_number[] = ""\004\001\002\000"";  byte *inp = in; byte *outp = out; register byte *p, *q; gp_fputs(""\033r"",prn_stream);  gp_fputc(colour_number[c_id], prn_stream); for( p = inp, q = inp + 1 ; q < in_end ; ) { if( *p != *q ) { p += 2; q += 2; } else { if( p > inp && *p == *(p-1) ) p--; for( q++ ; *q == *p && q < in_end ; q++ ) { if( (q-p) >= 128 ) { if( p > inp ) { count = p - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1);  memcpy(outp, inp, count); outp += count; } *outp++ = '\201'; *outp++ = *p; p += 128; inp = p; } } if( (q - p) > 2 ) { if( p > inp ) { count = p - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1); memcpy(outp, inp, count); outp += count; } count = q - p; *outp++ = (char) (256 - count + 1); *outp++ = *p; p += count; inp = p; } else p = q; if( q < in_end ) q++; } } if( inp < in_end ) { count = in_end - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1); memcpy(outp, inp, count); outp += count; } gp_fwrite(""\033.\001"", 1, 3, prn_stream); if(pdev->y_pixels_per_inch == 720) gp_fputc('\005', prn_stream); else if(pdev->y_pixels_per_inch == 180) gp_fputc('\024', prn_stream); else  gp_fputc('\012', prn_stream); if(pdev->x_pixels_per_inch == 720) gp_fputc('\005', prn_stream); else if(pdev->x_pixels_per_inch == 180) gp_fputc('\024', prn_stream); else  gp_fputc('\012', prn_stream); gp_fputc(band_size, prn_stream); gp_fputc((width << 3) & 0xff, prn_stream); gp_fputc( width >> 5,   prn_stream); gp_fwrite(out, 1, (outp - out), prn_stream); gp_fputc('\r', prn_stream); return 0; }"
"static void fill_kobj_path(const struct kobject *kobj, char *path, int length) { const struct kobject *parent; --length; for (parent = kobj; parent; parent = parent->parent) { int cur = strlen(kobject_name(parent)); length -= cur; memcpy(path + length, kobject_name(parent), cur); *(path + --length) = '/'; } pr_debug(""kobject: '%s' (%p): %s: path = '%s'\n"", kobject_name(kobj), kobj, __func__, path); }"
static void init_peercred(struct sock *sk) { put_pid(sk->sk_peer_pid); if (sk->sk_peer_cred) put_cred(sk->sk_peer_cred); sk->sk_peer_pid  = get_pid(task_tgid(current)); sk->sk_peer_cred = get_current_cred(); }
"static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len) { const pj_uint8_t *p = start; int name_len, name_part_len; pj_status_t status; status = get_name_len(0, pkt, start, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4); rr->name.slen = 0; status = get_name(0, pkt, start, max, &rr->name); if (status != PJ_SUCCESS) return status; p = (start + name_part_len); if (p+10 > max) return PJLIB_UTIL_EDNSINSIZE; pj_memcpy(&rr->type, p, 2); rr->type = pj_ntohs(rr->type); p += 2; pj_memcpy(&rr->dnsclass, p, 2); rr->dnsclass = pj_ntohs(rr->dnsclass); p += 2; if (rr->dnsclass != 1) { if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  || rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    || rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV) { return PJLIB_UTIL_EDNSINCLASS; } } pj_memcpy(&rr->ttl, p, 4); rr->ttl = pj_ntohl(rr->ttl); p += 4; pj_memcpy(&rr->rdlength, p, 2); rr->rdlength = pj_ntohs(rr->rdlength); p += 2; if (p + rr->rdlength > max) return PJLIB_UTIL_EDNSINSIZE; if (rr->type == PJ_DNS_TYPE_A) { pj_memcpy(&rr->rdata.a.ip_addr, p, 4); p += 4; } else if (rr->type == PJ_DNS_TYPE_AAAA) { pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16); p += 16; } else if (rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS || rr->type == PJ_DNS_TYPE_PTR)  { status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.cname.name.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.cname.name); if (status != PJ_SUCCESS) return status; p += name_part_len; } else if (rr->type == PJ_DNS_TYPE_SRV) { pj_memcpy(&rr->rdata.srv.prio, p, 2); rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio); p += 2; pj_memcpy(&rr->rdata.srv.weight, p, 2); rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight); p += 2; pj_memcpy(&rr->rdata.srv.port, p, 2); rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port); p += 2; status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.srv.target.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.srv.target); if (status != PJ_SUCCESS) return status; p += name_part_len; } else { rr->data = pj_pool_alloc(pool, rr->rdlength); pj_memcpy(rr->data, p, rr->rdlength); p += rr->rdlength; } *parsed_len = (int)(p - start); return PJ_SUCCESS; }"
"void Compute(OpKernelContext* ctx) override { const auto splits = ctx->input(0).flat<int64_t>(); const auto values = ctx->input(1).flat<Tidx>(); const Tensor& size_t = ctx->input(2); const auto weights = ctx->input(3).flat<T>(); const int64_t weights_size = weights.size(); OP_REQUIRES(ctx, size_t.dims() == 0, errors::InvalidArgument(""Shape must be rank 0 but is rank "", size_t.dims())); Tidx size = size_t.scalar<Tidx>()(); OP_REQUIRES( ctx, size >= 0, errors::InvalidArgument(""size ("", size, "") must be non-negative"")); int num_rows = splits.size() - 1; int num_values = values.size(); int batch_idx = 0; OP_REQUIRES(ctx, splits(0) == 0, errors::InvalidArgument(""Splits must start with 0, not with "", splits(0))); OP_REQUIRES(ctx, splits(num_rows) == num_values, errors::InvalidArgument( ""Splits must end with the number of values, got "", splits(num_rows), "" instead of "", num_values)); Tensor* out_t; OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t)); functor::SetZeroFunctor<Device, T> fill; fill(ctx->eigen_device<Device>(), out_t->flat<T>()); const auto out = out_t->matrix<T>(); for (int idx = 0; idx < num_values; ++idx) { while (idx >= splits(batch_idx)) { batch_idx++; } Tidx bin = values(idx); OP_REQUIRES(ctx, bin >= 0, errors::InvalidArgument(""Input must be non-negative"")); if (bin < size) { if (binary_output_) { out(batch_idx - 1, bin) = T(1); } else { T value = (weights_size > 0) ? weights(idx) : T(1); out(batch_idx - 1, bin) += value; } } } }"
"void pt_intr_post(struct vcpu *v, struct hvm_intack intack) { struct periodic_time *pt; time_cb *cb; void *cb_priv; if ( intack.source == hvm_intsrc_vector ) return; spin_lock(&v->arch.hvm.tm_lock); pt = is_pt_irq(v, intack); if ( pt == NULL ) { spin_unlock(&v->arch.hvm.tm_lock); return; } pt_irq_fired(v, pt); cb = pt->cb; cb_priv = pt->priv; spin_unlock(&v->arch.hvm.tm_lock); if ( cb != NULL ) cb(v, cb_priv); }"
"static int install_relocation_handler(int num_cpus, size_t save_state_size) { struct smm_loader_params smm_params = { .per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE, .num_concurrent_stacks = num_cpus, .per_cpu_save_state_size = save_state_size, .num_concurrent_save_states = 1, .handler = smm_do_relocation, }; if (mp_state.ops.adjust_smm_params != NULL) mp_state.ops.adjust_smm_params(&smm_params, 0); if (smm_setup_relocation_handler(&smm_params)) return -1; adjust_smm_apic_id_map(&smm_params); return 0; }"
"static void tiff_expand_colormap(fz_context *ctx, struct tiff *tiff) { int maxval = 1 << tiff->bitspersample; unsigned char *samples; unsigned char *src, *dst; unsigned int x, y; unsigned int stride; if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2) fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of samples for RGBPal""); if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16) fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of bits for RGBPal""); if (tiff->colormaplen < (unsigned)maxval * 3) fz_throw(ctx, FZ_ERROR_GENERIC, ""insufficient colormap data""); if (tiff->imagelength > UINT_MAX / tiff->imagewidth / (tiff->samplesperpixel + 2)) fz_throw(ctx, FZ_ERROR_GENERIC, ""image too large""); stride = tiff->imagewidth * (tiff->samplesperpixel + 2); samples = fz_malloc(ctx, stride * tiff->imagelength); for (y = 0; y < tiff->imagelength; y++) { src = tiff->samples + (unsigned int)(tiff->stride * y); dst = samples + (unsigned int)(stride * y); for (x = 0; x < tiff->imagewidth; x++) { if (tiff->extrasamples) { int c = tiff_getcomp(src, x * 2, tiff->bitspersample); int a = tiff_getcomp(src, x * 2 + 1, tiff->bitspersample); *dst++ = tiff->colormap[c + 0] >> 8; *dst++ = tiff->colormap[c + maxval] >> 8; *dst++ = tiff->colormap[c + maxval * 2] >> 8; *dst++ = a << (8 - tiff->bitspersample); } else { int c = tiff_getcomp(src, x, tiff->bitspersample); *dst++ = tiff->colormap[c + 0] >> 8; *dst++ = tiff->colormap[c + maxval] >> 8; *dst++ = tiff->colormap[c + maxval * 2] >> 8; } } } tiff->samplesperpixel += 2; tiff->bitspersample = 8; tiff->stride = stride; fz_free(ctx, tiff->samples); tiff->samples = samples; }"
"int LiSendMouseMoveEvent(short deltaX, short deltaY) { PPACKET_HOLDER holder; int err; if (!initialized) { return -2; } holder = malloc(sizeof(*holder)); if (holder == NULL) { return -1; } holder->packetLength = sizeof(NV_MOUSE_MOVE_PACKET); holder->packet.mouseMove.header.packetType = htonl(PACKET_TYPE_MOUSE_MOVE); holder->packet.mouseMove.magic = MOUSE_MOVE_MAGIC; if (ServerMajorVersion >= 5) { holder->packet.mouseMove.magic++; } holder->packet.mouseMove.deltaX = htons(deltaX); holder->packet.mouseMove.deltaY = htons(deltaY); err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry); if (err != LBQ_SUCCESS) { free(holder); } return err; }"
"void LowerABIAttributesPass::runOnOperation() { spirv::ModuleOp module = getOperation(); MLIRContext *context = &getContext(); spirv::TargetEnv targetEnv(spirv::lookupTargetEnv(module)); SPIRVTypeConverter typeConverter(targetEnv); typeConverter.addSourceMaterialization([](OpBuilder &builder, spirv::PointerType type, ValueRange inputs, Location loc) { if (inputs.size() != 1 || !inputs[0].getType().isa<spirv::PointerType>()) return Value(); return builder.create<spirv::BitcastOp>(loc, type, inputs[0]).getResult(); }); RewritePatternSet patterns(context); patterns.add<ProcessInterfaceVarABI>(typeConverter, context); ConversionTarget target(*context); target.addDynamicallyLegalOp<spirv::FuncOp>([&](spirv::FuncOp op) { StringRef attrName = spirv::getInterfaceVarABIAttrName(); for (unsigned i = 0, e = op.getNumArguments(); i < e; ++i) if (op.getArgAttr(i, attrName)) return false; return true; }); target.markUnknownOpDynamicallyLegal([](Operation *op) { return op->getDialect()->getNamespace() == spirv::SPIRVDialect::getDialectNamespace(); }); if (failed(applyPartialConversion(module, target, std::move(patterns)))) return signalPassFailure(); OpBuilder builder(context); SmallVector<spirv::FuncOp, 1> entryPointFns; auto entryPointAttrName = spirv::getEntryPointABIAttrName(); module.walk([&](spirv::FuncOp funcOp) { if (funcOp->getAttrOfType<spirv::EntryPointABIAttr>(entryPointAttrName)) { entryPointFns.push_back(funcOp); } }); for (auto fn : entryPointFns) { if (failed(lowerEntryPointABIAttr(fn, builder))) { return signalPassFailure(); } } }"
"void Compute(OpKernelContext* ctx) override { const Tensor& in0 = ctx->input(0); const Tensor& in1 = ctx->input(1); ValidateInputTensors(ctx, in0, in1); MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes()); OP_REQUIRES( ctx, bcast.IsValid(), errors::InvalidArgument( ""In[0] and In[1] must have compatible batch dimensions: "", in0.shape().DebugString(), "" vs. "", in1.shape().DebugString())); TensorShape out_shape = bcast.output_batch_shape(); auto batch_size = bcast.output_batch_size(); auto d0 = in0.dim_size(in0.dims() - 2);      auto d1 = in0.dim_size(in0.dims() - 1); Tensor in0_reshaped; OP_REQUIRES( ctx, in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})), errors::Internal(""Failed to reshape In[0] from "", in0.shape().DebugString())); auto d2 = in1.dim_size(in1.dims() - 2); auto d3 = in1.dim_size(in1.dims() - 1); Tensor in1_reshaped; OP_REQUIRES( ctx, in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})), errors::Internal(""Failed to reshape In[1] from "", in1.shape().DebugString())); OP_REQUIRES(ctx, d1 == d2, errors::InvalidArgument( ""In[0] mismatch In[1] shape: "", d1, "" vs. "", d2, "": "", in0.shape().DebugString(), "" "", in1.shape().DebugString(), "" "", lower_, "" "", adjoint_)); out_shape.AddDim(d1); out_shape.AddDim(d3); Tensor* out = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out)); if (out->NumElements() == 0) { return; } Tensor out_reshaped; OP_REQUIRES(ctx, out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})), errors::Internal(""Failed to reshape output from "", out->shape().DebugString())); LaunchBatchBandedTriangularSolve<Scalar>::Launch( ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast, &out_reshaped); }"
"GF_Err gf_bifs_dec_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com) { GF_Err e; u8 flag; assert(node); if (gf_sg_vrml_is_sf_field(field->fieldType)) { e = gf_bifs_dec_sf_field(codec, bs, node, field, is_mem_com); if (e) return e; } else { if (field->eventType == GF_SG_EVENT_IN) { if (field->fieldType == GF_SG_VRML_MFNODE) { gf_node_unregister_children(node, * (GF_ChildNodeItem **)field->far_ptr); * (GF_ChildNodeItem **)field->far_ptr = NULL; } else { gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType); } } if (codec->info->config.UsePredictiveMFField) { flag = gf_bs_read_int(bs, 1); if (flag) { #ifdef GPAC_ENABLE_BIFS_PMF return gf_bifs_dec_pred_mf_field(codec, bs, node, field); #else GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BIFS] Stream uses Predictive Field Coding, disabled in this build!\n"")); return GF_NOT_SUPPORTED; #endif } } flag = gf_bs_read_int(bs, 1); if (!flag) { if (field->fieldType != GF_SG_VRML_MFNODE) { e = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType); if (e) return e; } flag = gf_bs_read_int(bs, 1); if (flag) { e = BD_DecMFFieldList(codec, bs, node, field, is_mem_com); } else { e = BD_DecMFFieldVec(codec, bs, node, field, is_mem_com); } if (e) return e; } } return GF_OK; }"
"void dmar_free_irte(const struct intr_source *intr_src, uint16_t index) { struct dmar_drhd_rt *dmar_unit; union dmar_ir_entry *ir_table, *ir_entry; union pci_bdf sid; if (intr_src->is_msi) { dmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun); } else { dmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid); } if (is_dmar_unit_valid(dmar_unit, sid)) { ir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr); ir_entry = ir_table + index; ir_entry->bits.remap.present = 0x0UL; iommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry)); dmar_invalid_iec(dmar_unit, index, 0U, false); if (!is_irte_reserved(dmar_unit, index)) { spinlock_obtain(&dmar_unit->lock); bitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]); spinlock_release(&dmar_unit->lock); } } }"
"static u_char * ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end) { size_t                     size; ngx_uint_t                 padded, priority, depend, dependency, excl, weight; ngx_uint_t                 status; ngx_http_v2_node_t        *node; ngx_http_v2_stream_t      *stream; ngx_http_v2_srv_conf_t    *h2scf; ngx_http_core_srv_conf_t  *cscf; ngx_http_core_loc_conf_t  *clcf; padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG; priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG; size = 0; if (padded) { size++; } if (priority) { size += sizeof(uint32_t) + 1; } if (h2c->state.length < size) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with incorrect length %uz"", h2c->state.length); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR); } if (h2c->state.length == size) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with empty header block""); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR); } if (h2c->goaway) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0, ""skipping http2 HEADERS frame""); return ngx_http_v2_state_skip(h2c, pos, end); } if ((size_t) (end - pos) < size) { return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_headers); } h2c->state.length -= size; if (padded) { h2c->state.padding = *pos++; if (h2c->state.padding > h2c->state.length) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent padded HEADERS frame "" ""with incorrect length: %uz, padding: %uz"", h2c->state.length, h2c->state.padding); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } h2c->state.length -= h2c->state.padding; } depend = 0; excl = 0; weight = NGX_HTTP_V2_DEFAULT_WEIGHT; if (priority) { dependency = ngx_http_v2_parse_uint32(pos); depend = dependency & 0x7fffffff; excl = dependency >> 31; weight = pos[4] + 1; pos += sizeof(uint32_t) + 1; } ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0, ""http2 HEADERS frame sid:%ui "" ""depends on %ui excl:%ui weight:%ui"", h2c->state.sid, depend, excl, weight); if (h2c->state.sid % 2 == 0 || h2c->state.sid <= h2c->last_sid) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with incorrect identifier "" ""%ui, the last was %ui"", h2c->state.sid, h2c->last_sid); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } if (depend == h2c->state.sid) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame for stream %ui "" ""with incorrect dependency"", h2c->state.sid); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } h2c->last_sid = h2c->state.sid; h2c->state.pool = ngx_create_pool(1024, h2c->connection->log); if (h2c->state.pool == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx, ngx_http_core_module); h2c->state.header_limit = cscf->large_client_header_buffers.size * cscf->large_client_header_buffers.num; h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx, ngx_http_v2_module); if (h2c->processing >= h2scf->concurrent_streams) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""concurrent streams exceeded %ui"", h2c->processing); status = NGX_HTTP_V2_REFUSED_STREAM; goto rst_stream; } if (!h2c->settings_ack && !(h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG) && h2scf->preread_size < NGX_HTTP_V2_DEFAULT_WINDOW) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent stream with data "" ""before settings were acknowledged""); status = NGX_HTTP_V2_REFUSED_STREAM; goto rst_stream; } node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 1); if (node == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } if (node->parent) { ngx_queue_remove(&node->reuse); h2c->closed_nodes--; } stream = ngx_http_v2_create_stream(h2c, 0); if (stream == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } h2c->state.stream = stream; stream->pool = h2c->state.pool; h2c->state.keep_pool = 1; stream->request->request_length = h2c->state.length; stream->in_closed = h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG; stream->node = node; node->stream = stream; if (priority || node->parent == NULL) { node->weight = weight; ngx_http_v2_set_dependency(h2c, node, depend, excl); } clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx, ngx_http_core_module); if (clcf->keepalive_timeout == 0 || h2c->connection->requests >= clcf->keepalive_requests || ngx_current_msec - h2c->connection->start_time > clcf->keepalive_time) { h2c->goaway = 1; if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } } return ngx_http_v2_state_header_block(h2c, pos, end); rst_stream: if (ngx_http_v2_send_rst_stream(h2c, h2c->state.sid, status) != NGX_OK) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } return ngx_http_v2_state_header_block(h2c, pos, end); }"
"void PackTmt::pack(OutputFile *fo) { big_relocs = 0; Packer::handleStub(fi, fo, adam_offset); const unsigned usize = ih.imagesize; const unsigned rsize = ih.relocsize; ibuf.alloc(usize + rsize + 128); obuf.allocForCompression(usize + rsize + 128); MemBuffer mb_wrkmem; mb_wrkmem.alloc(rsize + EXTRA_INFO);     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem); fi->seek(adam_offset + sizeof(ih), SEEK_SET); fi->readx(ibuf, usize); fi->readx(wrkmem + 4, rsize); const unsigned overlay = file_size - fi->tell(); if (find_le32(ibuf, 128, get_le32(""UPX "")) >= 0) throwAlreadyPacked(); if (rsize == 0) throwCantPack(""file is already compressed with another packer""); checkOverlay(overlay); unsigned relocsize = 0; { for (unsigned ic = 4; ic <= rsize; ic += 4) set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4); relocsize = optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs); } wrkmem[relocsize++] = 0; set_le32(wrkmem + relocsize, ih.entry);     relocsize += 4; set_le32(wrkmem + relocsize, relocsize + 4); relocsize += 4; memcpy(ibuf + usize, wrkmem, relocsize); ph.u_len = usize + relocsize; Filter ft(ph.level); ft.buf_len = usize; upx_compress_config_t cconf; cconf.reset(); cconf.conf_lzma.max_num_probs = 1846 + (768 << 4);     compressWithFilters(&ft, 512, &cconf); const unsigned lsize = getLoaderSize(); const unsigned s_point = getLoaderSection(""TMTMAIN1""); int e_len = getLoaderSectionStart(""TMTCUTPO""); const unsigned d_len = lsize - e_len; assert(e_len > 0 && s_point > 0); linker->defineSymbol(""original_entry"", ih.entry); defineDecompressorSymbols(); defineFilterSymbols(&ft); linker->defineSymbol(""bytes_to_copy"", ph.c_len + d_len); linker->defineSymbol(""copy_dest"", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1)); linker->defineSymbol(""copy_source"", ph.c_len + lsize - 1); linker->defineSymbol(""TMTCUTPO"", ph.u_len + ph.overlap_overhead); relocateLoader(); MemBuffer loader(lsize); memcpy(loader, getLoader(), lsize); patchPackHeader(loader, e_len); memcpy(&oh, &ih, sizeof(oh)); oh.imagesize = ph.c_len + lsize;     oh.entry = s_point;                  oh.relocsize = 4; fo->write(&oh, sizeof(oh)); fo->write(loader, e_len); fo->write(obuf, ph.c_len); fo->write(loader + lsize - d_len, d_len);     char rel_entry[4]; set_le32(rel_entry, 5 + s_point); fo->write(rel_entry, sizeof(rel_entry)); verifyOverlappingDecompression(); copyOverlay(fo, overlay, obuf); if (!checkFinalCompressionRatio(fo)) throwNotCompressible(); }"
"void readSampleCountForLineBlock(InputStreamMutex* streamData, DeepScanLineInputFile::Data* data, int lineBlockId) { streamData->is->seekg(data->lineOffsets[lineBlockId]); if (isMultiPart(data->version)) { int partNumber; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, partNumber); if (partNumber != data->partNumber) throw IEX_NAMESPACE::ArgExc(""Unexpected part number.""); } int minY; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, minY); if (minY != data->minY + lineBlockId * data->linesInBuffer) throw IEX_NAMESPACE::ArgExc(""Unexpected data block y coordinate.""); int maxY; maxY = min(minY + data->linesInBuffer - 1, data->maxY); uint64_t sampleCountTableDataSize; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, sampleCountTableDataSize); if(sampleCountTableDataSize>static_cast<uint64_t>(data->maxSampleCountTableSize)) { THROW (IEX_NAMESPACE::ArgExc, ""Bad sampleCountTableDataSize read from chunk ""<< lineBlockId << "": expected "" << data->maxSampleCountTableSize << "" or less, got ""<< sampleCountTableDataSize); } uint64_t packedDataSize; uint64_t unpackedDataSize; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, packedDataSize); OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, unpackedDataSize); int compressorMaxDataSize = std::numeric_limits<int>::max(); if (sampleCountTableDataSize > uint64_t(compressorMaxDataSize)) { THROW (IEX_NAMESPACE::ArgExc, ""This version of the library does not "" << ""support the allocation of data with size  > "" << compressorMaxDataSize << "" file table size    :"" << sampleCountTableDataSize << "".\n""); } streamData->is->read(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize)); const char* readPtr; if (sampleCountTableDataSize < static_cast<uint64_t>(data->maxSampleCountTableSize)) { if(!data->sampleCountTableComp) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline data corrupt at chunk "" << lineBlockId << "" (sampleCountTableDataSize error)""); } data->sampleCountTableComp->uncompress(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize), minY, readPtr); } else readPtr = data->sampleCountTableBuffer; char* base = data->sampleCountSliceBase; int xStride = data->sampleCountXStride; int yStride = data->sampleCountYStride; size_t cumulative_total_samples=0; for (int y = minY; y <= maxY; y++) { int yInDataWindow = y - data->minY; data->lineSampleCount[yInDataWindow] = 0; int lastAccumulatedCount = 0; for (int x = data->minX; x <= data->maxX; x++) { int accumulatedCount, count; Xdr::read <CharPtrIO> (readPtr, accumulatedCount); if (accumulatedCount < lastAccumulatedCount) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "" (negative sample count detected)""); } count = accumulatedCount - lastAccumulatedCount; lastAccumulatedCount = accumulatedCount; data->sampleCount[yInDataWindow][x - data->minX] = count; data->lineSampleCount[yInDataWindow] += count; sampleCount(base, xStride, yStride, x, y) = count; } cumulative_total_samples+=data->lineSampleCount[yInDataWindow]; if(cumulative_total_samples*data->combinedSampleSize > unpackedDataSize) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "": pixel data only contains "" << unpackedDataSize  << "" bytes of data but table references at least "" << cumulative_total_samples*data->combinedSampleSize << "" bytes of sample data"" );             } data->gotSampleCount[y - data->minY] = true; } }"
"static int da9150_charger_remove(struct platform_device *pdev) { struct da9150_charger *charger = platform_get_drvdata(pdev); int irq; irq = platform_get_irq_byname(pdev, ""CHG_VBUS""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_VFAULT""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_TJUNC""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_STATUS""); free_irq(irq, charger); if (!IS_ERR_OR_NULL(charger->usb_phy)) usb_unregister_notifier(charger->usb_phy, &charger->otg_nb); power_supply_unregister(charger->battery); power_supply_unregister(charger->usb); iio_channel_release(charger->ibus_chan); iio_channel_release(charger->vbus_chan); iio_channel_release(charger->tjunc_chan); iio_channel_release(charger->vbat_chan); return 0; }"
"int wolfSSH_SFTP_RecvSetSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) { WS_SFTP_FILEATRB atr; char* name = NULL; int   ret = WS_SUCCESS; word32 sz; word32 idx = 0; byte*  out = NULL; word32 outSz = 0; char  suc[] = ""Set Attirbutes""; char  ser[] = ""Unable to set attributes error""; char  per[] = ""Unable to parse attributes error""; char* res   = suc; byte  type  = WOLFSSH_FTP_OK; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_SETSTAT""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz) { return WS_BUFFER_E; } name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (name == NULL) { return WS_MEMORY_E; } WMEMCPY(name, data + idx, sz); idx += sz; name[sz] = '\0'; if (wolfSSH_CleanPath(ssh, name) < 0) { ret = WS_FATAL_ERROR; } if (ret == WS_SUCCESS && SFTP_ParseAtributes_buffer(ssh, &atr, data, &idx, maxSz) != 0) { type = WOLFSSH_FTP_FAILURE; res  = per; ret  = WS_BAD_FILE_E; } if (ret == WS_SUCCESS && (ret = SFTP_SetFileAttributes(ssh, name, &atr)) != WS_SUCCESS) { WLOG(WS_LOG_SFTP, ""Unable to get set attributes of file/directory""); type = WOLFSSH_FTP_FAILURE; res  = ser; ret  = WS_BAD_FILE_E; } WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", NULL, &outSz) != WS_SIZE_ONLY) { return WS_FATAL_ERROR; } out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }"
"void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) { mpz_t xdiff, ydiff, lambda; mpz_inits(xdiff, ydiff, lambda, NULL); mpz_sub(ydiff, op2->y, op1->y); mpz_sub(xdiff, op2->x, op1->x); mpz_invert(xdiff, xdiff, curve->p);      mpz_mul(lambda, ydiff, xdiff); mpz_mod(lambda, lambda, curve->p); mpz_mul(rop->x, lambda, lambda); mpz_sub(rop->x, rop->x, op1->x); mpz_sub(rop->x, rop->x, op2->x); mpz_mod(rop->x, rop->x, curve->p); mpz_sub(rop->y, op1->x, rop->x); mpz_mul(rop->y, lambda, rop->y); mpz_sub(rop->y, rop->y, op1->y); mpz_mod(rop->y, rop->y, curve->p); mpz_clears(xdiff, ydiff, lambda, NULL); }"
"GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs) { unsigned int i; GF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s; ISOM_DECREASE_SIZE(ptr, 9) ptr->long_ids = gf_bs_read_int(bs, 1); ptr->long_offsets = gf_bs_read_int(bs, 1); ptr->global_entries = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 5); ptr->time_scale = gf_bs_read_u32(bs); ptr->entry_count = gf_bs_read_u32(bs); if (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count) return GF_ISOM_INVALID_FILE; for (i=0; i<ptr->entry_count; i++) { GF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry)); if (!ae) return GF_OUT_OF_MEM; gf_list_insert(ptr->local_access_entries, ae, i); ISOM_DECREASE_SIZE(ptr, 8) ae->time = gf_bs_read_u64(bs); if (ptr->long_offsets) { ISOM_DECREASE_SIZE(ptr, 8) ae->offset = gf_bs_read_u64(bs); } else { ISOM_DECREASE_SIZE(ptr, 4) ae->offset = gf_bs_read_u32(bs); } } if (ptr->global_entries) { ISOM_DECREASE_SIZE(ptr, 4) ptr->global_entry_count = gf_bs_read_u32(bs); for (i=0; i<ptr->global_entry_count; i++) { GF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry)); if (!ae) return GF_OUT_OF_MEM; gf_list_insert(ptr->global_access_entries, ae, i); ISOM_DECREASE_SIZE(ptr, 8) ae->time = gf_bs_read_u64(bs); if (ptr->long_ids) { ISOM_DECREASE_SIZE(ptr, 8) ae->segment = gf_bs_read_u32(bs); ae->fragment = gf_bs_read_u32(bs); } else { ISOM_DECREASE_SIZE(ptr, 4) ae->segment = gf_bs_read_u16(bs); ae->fragment = gf_bs_read_u16(bs); } if (ptr->long_offsets) { ISOM_DECREASE_SIZE(ptr, 16) ae->afra_offset = gf_bs_read_u64(bs); ae->offset_from_afra = gf_bs_read_u64(bs); } else { ISOM_DECREASE_SIZE(ptr, 8) ae->afra_offset = gf_bs_read_u32(bs); ae->offset_from_afra = gf_bs_read_u32(bs); } } } return GF_OK; }"
"StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs, const OpDef& op_def) { FullTypeDef ft; ft.set_type_id(TFT_PRODUCT); for (int i = 0; i < op_def.output_arg_size(); i++) { auto* t = ft.add_args(); *t = op_def.output_arg(i).experimental_full_type(); for (int j = 0; j < t->args_size(); j++) { auto* arg = t->mutable_args(i); if (arg->type_id() == TFT_VAR) { const auto* attr = attrs.Find(arg->s()); DCHECK(attr != nullptr); if (attr->value_case() == AttrValue::kList) { const auto& attr_list = attr->list(); arg->set_type_id(TFT_PRODUCT); for (int i = 0; i < attr_list.type_size(); i++) { map_dtype_to_tensor(attr_list.type(i), arg->add_args()); } } else if (attr->value_case() == AttrValue::kType) { map_dtype_to_tensor(attr->type(), arg); } else { return Status(error::UNIMPLEMENTED, absl::StrCat(""unknown attribute type"", attrs.DebugString(), "" key="", arg->s())); } arg->clear_s(); } } } return ft; }"
"void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) { size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom; DCHECK_LT(newCapacity, UINT32_MAX); DCHECK(!isSharedOne()); if (headroom() + tailroom() >= minHeadroom + minTailroom) { uint8_t* newData = writableBuffer() + minHeadroom; memmove(newData, data_, length_); data_ = newData; return; } size_t newAllocatedCapacity = 0; uint8_t* newBuffer = nullptr; std::size_t newHeadroom = 0; std::size_t oldHeadroom = headroom(); SharedInfo* info = sharedInfo(); bool useHeapFullStorage = info && info->useHeapFullStorage; if (info && (info->freeFn == nullptr) && length_ != 0 && oldHeadroom >= minHeadroom) { size_t headSlack = oldHeadroom - minHeadroom; newAllocatedCapacity = goodExtBufferSize(newCapacity + headSlack); if (usingJEMalloc()) { if (headSlack * 4 <= newCapacity) { size_t allocatedCapacity = capacity() + sizeof(SharedInfo); void* p = buf_; if (allocatedCapacity >= jemallocMinInPlaceExpandable) { if (xallocx(p, newAllocatedCapacity, 0, 0) == newAllocatedCapacity) { if (io_buf_free_cb) { io_buf_free_cb(p, reinterpret_cast<size_t>(info->userData)); } newBuffer = static_cast<uint8_t*>(p); newHeadroom = oldHeadroom; info->userData = reinterpret_cast<void*>(newAllocatedCapacity); if (io_buf_alloc_cb) { io_buf_alloc_cb(newBuffer, newAllocatedCapacity); } } } } } else {       size_t copySlack = capacity() - length_; if (copySlack * 2 <= length_) { void* p = realloc(buf_, newAllocatedCapacity); if (UNLIKELY(p == nullptr)) { throw_exception<std::bad_alloc>(); } newBuffer = static_cast<uint8_t*>(p); newHeadroom = oldHeadroom; } } } if (newBuffer == nullptr) { newAllocatedCapacity = goodExtBufferSize(newCapacity); newBuffer = static_cast<uint8_t*>(checkedMalloc(newAllocatedCapacity)); if (length_ > 0) { assert(data_ != nullptr); memcpy(newBuffer + minHeadroom, data_, length_); } if (sharedInfo()) { freeExtBuffer(); } newHeadroom = minHeadroom; } std::size_t cap; initExtBuffer(newBuffer, newAllocatedCapacity, &info, &cap); if (flags() & kFlagFreeSharedInfo) { delete sharedInfo(); } else { if (useHeapFullStorage) { SharedInfo::releaseStorage(sharedInfo()); } } setFlagsAndSharedInfo(0, info); capacity_ = cap; buf_ = newBuffer; data_ = newBuffer + newHeadroom; }"
"static void print_insn32 (bfd_vma pc, disassemble_info *info, uint32_t insn) { int op = OP6 (insn); const int rt = RT5 (insn); const int ra = RA5 (insn); const int rb = RB5 (insn); const int imm15s = IMMS (insn, 15); const int imm15u = IMMU (insn, 15); uint32_t shift; fprintf_ftype func = info->fprintf_func; void *stream = info->stream; switch (op) { case 0x0: case 0x1: case 0x2: case 0x3: case 0x8: case 0x9: case 0xa: case 0xb: case 0x10: case 0x11: case 0x12: shift = op & 0x3; func (stream, ""%s\t%s, [%s + #%d]"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift); return; case 0x4: case 0x5: case 0x6: case 0x7: case 0xc: case 0xd: case 0xe: case 0xf: case 0x14: case 0x15: case 0x16: shift = op & 0x3; func (stream, ""%s\t%s, [%s], #%d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift); return; case 0x13: { const char *subtype = ""???""; char wd = 'w'; shift = 2; if (rt & 0x10) { wd = 'd'; shift = 3; } if ((rt & 0xf) < ARRAY_SIZE (keyword_dpref)) subtype = keyword_dpref[rt & 0xf]; func (stream, ""%s.%c\t%s, [%s + #%d]"", mnemonic_op6[op], wd, subtype, gpr_map[ra], imm15s << shift); } return; case 0x17: func (stream, ""%s\t%s, [+ %d]"", ((insn & __BIT (19)) ? ""lbsi.gp"" : ""lbi.gp""), gpr_map[rt], IMMS (insn, 19)); return; case 0x18: case 0x19: case 0x1a: case 0x1b: if (__GF (insn, 13, 2) == 0) { char ls = (op & 1) ? 's' : 'l'; char wd = (op & 2) ? 'd' : 's'; if (insn & __BIT (12)) { func (stream, ""f%c%ci.bi\t$f%c%d, [%s], %d"", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2); } else { func (stream, ""f%c%ci\t$f%c%d, [%s + %d]"", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2); } } else { char ls = (op & 1) ? 's' : 'l'; char wd = (op & 2) ? 'd' : 'w'; int cp = __GF (insn, 13, 2); if (insn & __BIT (12)) { func (stream, ""cp%c%ci\tcp%d, $cpr%d, [%s], %d"", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2); } else { func (stream, ""cp%c%ci\tcp%d, $cpr%d, [%s + %d]"", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2); } } return; case 0x1c: print_insn32_mem (pc, info, insn); return; case 0x1d: { int enb4 = __GF (insn, 6, 4); char ls = (insn & __BIT (5)) ? 's' : 'l'; char ab = (insn & __BIT (4)) ? 'a' : 'b'; char *di = (insn & __BIT (3)) ? ""d"" : ""i""; char *m = (insn & __BIT (2)) ? ""m"" : """"; static const char *s[] = {"""", ""a"", ""zb"", ""?""}; if ((insn & 0x3) == 2) di = """"; func (stream, ""%cmw%s.%c%s%s\t%s, [%s], %s, 0x%x"", ls, s[insn & 0x3], ab, di, m, gpr_map[rt], gpr_map[ra], gpr_map[rb], enb4); } return; case 0x1e: op = __GF (insn, 17, 3); switch (op) { case 0: case 1: case 2: case 3: case 4: case 5: func (stream, ""%s\t%s, [+ %d]"", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 18) << 1); return; case 6: case 7: func (stream, ""%s\t%s, [+ %d]"", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 17) << 2); return; } return; case 0x1f: if (insn & __BIT (19)) func (stream, ""addi.gp\t%s, %d"", gpr_map[rt], IMMS (insn, 19)); else func (stream, ""sbi.gp\t%s, [+ %d]"", gpr_map[rt], IMMS (insn, 19)); return; case 0x20: print_insn32_alu1 (pc, info, insn); return; case 0x21: print_insn32_alu2 (pc, info, insn); return; case 0x22: func (stream, ""movi\t%s, %d"", gpr_map[rt], IMMS (insn, 20)); return; case 0x23: func (stream, ""sethi\t%s, 0x%x"", gpr_map[rt], IMMU (insn, 20)); return; case 0x24: if (info->flags & INSN_HAS_RELOC) pc = 0; func (stream, ""%s\t"", ((insn & __BIT (24)) ? ""jal"" : ""j"")); info->print_address_func ((IMMS (insn, 24) << 1) + pc, info); return; case 0x25: print_insn32_jreg (pc, info, insn); return; case 0x26: func (stream, ""%s\t%s, %s, "", ((insn & __BIT (14)) ? ""bne"" : ""beq""), gpr_map[rt], gpr_map[ra]); info->print_address_func ((IMMS (insn, 14) << 1) + pc, info); return; case 0x27: func (stream, ""%s\t%s, "", mnemonic_br2[__GF (insn, 16, 4)], gpr_map[rt]); info->print_address_func ((IMMS (insn, 16) << 1) + pc, info); return; case 0x28: case 0x2e: case 0x2f: case 0x29: func (stream, ""%s\t%s, %s, %d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s); return; case 0x2a: case 0x2b: case 0x2c: case 0x33: func (stream, ""%s\t%s, %s, %d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15u); return; case 0x2d: func (stream, ""%s\t%s, %d, "", ((insn & __BIT (19)) ? ""bnec"" : ""beqc""), gpr_map[rt], __SEXT (__GF (insn, 8, 11), 11)); info->print_address_func ((IMMS (insn, 8) << 1) + pc, info); return; case 0x32: print_insn32_misc (pc, info, insn); return; case 0x35: print_insn32_fpu (pc, info, insn); return; } }"
void detachThreadLocals() { resetControlMessages_.cancelTimeout(); resetDirectErrors_.cancelTimeout(); timer_ = nullptr; numControlMsgsInCurrentInterval_ = 0; numDirectErrorHandlingInCurrentInterval_ = 0; }
"static int xenmem_add_to_physmap_batch(struct domain *d, struct xen_add_to_physmap_batch *xatpb, unsigned int extent) { if ( unlikely(xatpb->size < extent) ) return -EILSEQ; if ( unlikely(xatpb->size == extent) ) return extent ? -EILSEQ : 0; if ( !guest_handle_subrange_okay(xatpb->idxs, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->gpfns, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->errs, extent, xatpb->size - 1) ) return -EFAULT; while ( xatpb->size > extent ) { xen_ulong_t idx; xen_pfn_t gpfn; int rc; if ( unlikely(__copy_from_guest_offset(&idx, xatpb->idxs, extent, 1)) || unlikely(__copy_from_guest_offset(&gpfn, xatpb->gpfns, extent, 1)) ) return -EFAULT; rc = xenmem_add_to_physmap_one(d, xatpb->space, xatpb->u, idx, _gfn(gpfn)); if ( unlikely(__copy_to_guest_offset(xatpb->errs, extent, &rc, 1)) ) return -EFAULT; if ( xatpb->size > ++extent && hypercall_preempt_check() ) return extent; } return 0; }"
"mp_err mp_2expt(mp_int *a, int b) { mp_err    err; mp_zero(a); if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } a->used = (b / MP_DIGIT_BIT) + 1; a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT); return MP_OKAY; }"
"static int LZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s) { static const char module[] = ""LZWDecode""; LZWCodecState *sp = DecoderState(tif); uint8_t *op = (uint8_t*) op0; tmsize_t occ = occ0; uint8_t *bp; long nbits, nextbits, nbitsmask; WordType nextdata; code_t *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL); assert(sp->dec_codetab != NULL); if (sp->dec_restart) { tmsize_t residue; code_t* codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) { sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ && codep); if (codep) { uint8_t* tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ && codep); } return (1); } op += residue; occ -= residue; uint8_t* tp = op; do { *--tp = codep->value; codep = codep->next; } while (--residue && codep); sp->dec_restart = 0; } bp = (uint8_t*)tif->tif_rawcp; sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3); uint64_t dec_bitsleft = sp->dec_bitsleft; nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; code_t* const dec_codetab = sp->dec_codetab; code_t* codep; if (occ == 0) { goto after_loop; } begin: { WordType code; GetNextCodeLZW(); codep = dec_codetab + code; if (code >= CODE_FIRST) goto code_above_or_equal_to_258; if (code < 256) goto code_below_256; if (code == CODE_EOI) goto after_loop; goto code_clear; code_below_256: { if (codep > free_entp) goto error_code; free_entp->next = oldcodep; free_entp->firstchar = oldcodep->firstchar; free_entp->length = oldcodep->length+1; free_entp->value = (uint8_t)code; free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == code)); if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = dec_codetab + nbitsmask-1; if( free_entp >= &dec_codetab[CSIZE] ) { free_entp = dec_codetab - 1; } } oldcodep = codep; *op++ = (uint8_t)code; occ--; if (occ == 0) goto after_loop; goto begin; } code_above_or_equal_to_258: { if (codep >= free_entp) { if (codep != free_entp) goto error_code; free_entp->value = oldcodep->firstchar; } else { free_entp->value = codep->firstchar; } free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value)); free_entp->next = oldcodep; free_entp->firstchar = oldcodep->firstchar; free_entp->length = oldcodep->length+1; if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = dec_codetab + nbitsmask-1; if (free_entp >= &dec_codetab[CSIZE]) { free_entp = dec_codetab - 1; } } oldcodep = codep; unsigned short len = codep->length; if (len < 3)  { if (occ <= 2) { if (occ == 2) { memcpy(op, &(codep->firstchar), 2); op += 2; occ -= 2; goto after_loop; } goto too_short_buffer; } memcpy(op, &(codep->firstchar), 2); op += 2; occ -= 2; goto begin;  } if (len == 3) { if (occ <= 3) { if (occ == 3) { op[0] = codep->firstchar; op[1] = codep->next->value; op[2] = codep->value; op += 3; occ -= 3; goto after_loop; } goto too_short_buffer; } op[0] = codep->firstchar; op[1] = codep->next->value; op[2] = codep->value; op += 3; occ -= 3; goto begin;  } if (len > occ) { goto too_short_buffer; } if (codep->repeated) { memset(op, codep->value, len); op += len; occ -= len; if (occ == 0) goto after_loop; goto begin; } uint8_t* tp = op + len; assert(len >= 4); *--tp = codep->value; codep = codep->next; *--tp = codep->value; codep = codep->next; *--tp = codep->value; codep = codep->next; *--tp = codep->value; if (tp > op) { do { codep = codep->next; *--tp = codep->value; } while (tp > op); } assert(occ >= len); op += len; occ -= len; if (occ == 0) goto after_loop; goto begin; } code_clear: { free_entp = dec_codetab + CODE_FIRST; nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = dec_codetab + nbitsmask-1; do { GetNextCodeLZW(); } while (code == CODE_CLEAR); if (code == CODE_EOI) goto after_loop; if (code > CODE_EOI) { goto error_code; } *op++ = (uint8_t)code; occ--; oldcodep = dec_codetab + code; if (occ == 0) goto after_loop; goto begin; } } too_short_buffer: { sp->dec_codep = codep; do { codep = codep->next; } while (codep->length > occ); sp->dec_restart = occ; uint8_t* tp = op + occ; do  { *--tp = codep->value; codep = codep->next; }  while (--occ); } after_loop: tif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp ); tif->tif_rawcp = (uint8_t*) bp; sp->old_tif_rawcc = tif->tif_rawcc; sp->dec_bitsleft = dec_bitsleft; sp->lzw_nbits = (unsigned short) nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Not enough data at scanline %""PRIu32"" (short %""PRIu64"" bytes)"", tif->tif_row, (uint64_t)occ); return (0); } return (1); no_eoi: TIFFErrorExt(tif->tif_clientdata, module, ""LZWDecode: Strip %""PRIu32"" not terminated with EOI code"", tif->tif_curstrip); return 0; error_code: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, ""Using code not yet in table""); return 0; }"
"void input_l2cap_credit(uint8_t *data) { uint16_t len; uint16_t cid; uint16_t credits; l2cap_channel_t *channel = get_channel_for_addr(packetbuf_addr(PACKETBUF_ADDR_SENDER)); memcpy(&len, &data[1], 2); if(len != 4) { LOG_WARN(""process_l2cap_credit: invalid len: %d\n"", len); return; } memcpy(&cid, &data[3], 2); memcpy(&credits, &data[5], 2); channel->channel_peer.credits += credits; }"
"void Gobby::EditCommands::on_paste() { g_assert(m_current_view != NULL); g_assert(m_current_view->get_active_user() != NULL); gtk_text_buffer_paste_clipboard( GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), NULL, TRUE); m_current_view->scroll_to_cursor_position(0.0); }"
"uint8_t * copyn_utf8_str(const uint8_t *src, uint32_t *pos, int *str_len, int limit) { *str_len      = 0; uint8_t *dest = NULL; if (limit < 2) return NULL; NNI_GET16(src + (*pos), *str_len); *pos = (*pos) + 2; if (*str_len > (limit-2)) { *str_len = -1; return NULL; } if (*str_len > 0) { if (utf8_check((const char *) (src + *pos), *str_len) == ERR_SUCCESS) { if ((dest = nng_alloc(*str_len + 1)) == NULL) { *str_len = 0; return NULL; } memcpy(dest, src + (*pos), *str_len); dest[*str_len] = '\0'; *pos           = (*pos) + (*str_len); } else { *str_len = -1; } } return dest; }"
"static int sendControllerEventInternal(short controllerNumber, short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger, short leftStickX, short leftStickY, short rightStickX, short rightStickY) { PPACKET_HOLDER holder; int err; if (!initialized) { return -2; } holder = malloc(sizeof(*holder)); if (holder == NULL) { return -1; } if (ServerMajorVersion == 3) { holder->packetLength = sizeof(NV_CONTROLLER_PACKET); holder->packet.controller.header.packetType = htonl(PACKET_TYPE_CONTROLLER); holder->packet.controller.headerA = C_HEADER_A; holder->packet.controller.headerB = C_HEADER_B; holder->packet.controller.buttonFlags = buttonFlags; holder->packet.controller.leftTrigger = leftTrigger; holder->packet.controller.rightTrigger = rightTrigger; holder->packet.controller.leftStickX = leftStickX; holder->packet.controller.leftStickY = leftStickY; holder->packet.controller.rightStickX = rightStickX; holder->packet.controller.rightStickY = rightStickY; holder->packet.controller.tailA = C_TAIL_A; holder->packet.controller.tailB = C_TAIL_B; } else { holder->packetLength = sizeof(NV_MULTI_CONTROLLER_PACKET); holder->packet.multiController.header.packetType = htonl(PACKET_TYPE_MULTI_CONTROLLER); holder->packet.multiController.headerA = MC_HEADER_A; if (ServerMajorVersion >= 5) { holder->packet.multiController.headerA--; } holder->packet.multiController.headerB = MC_HEADER_B; holder->packet.multiController.controllerNumber = controllerNumber; holder->packet.multiController.midA = MC_ACTIVE_CONTROLLER_FLAGS; holder->packet.multiController.midB = MC_MID_B; holder->packet.multiController.buttonFlags = buttonFlags; holder->packet.multiController.leftTrigger = leftTrigger; holder->packet.multiController.rightTrigger = rightTrigger; holder->packet.multiController.leftStickX = leftStickX; holder->packet.multiController.leftStickY = leftStickY; holder->packet.multiController.rightStickX = rightStickX; holder->packet.multiController.rightStickY = rightStickY; holder->packet.multiController.tailA = MC_TAIL_A; holder->packet.multiController.tailB = MC_TAIL_B; } err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry); if (err != LBQ_SUCCESS) { free(holder); } return err; }"
"static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg, struct bpf_insn_aux_data *tmp_aux, const bool commit_window) { struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux; struct bpf_verifier_state *vstate = env->cur_state; bool off_is_neg = off_reg->smin_value < 0; bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; int err; if (can_skip_alu_sanitation(env, insn)) return 0; if (vstate->speculative) goto do_sim; err = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode); if (err < 0) return err; if (commit_window) { alu_state = tmp_aux->alu_state; alu_limit = abs(tmp_aux->alu_limit - alu_limit); } else { alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; } err = update_alu_sanitation_state(aux, alu_state, alu_limit); if (err < 0) return err; do_sim: if (commit_window) return 0; if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true); if (!ptr_is_dst_reg && ret) *dst_reg = tmp; return !ret ? REASON_STACK : 0; }"
"void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) { minify = dominify; if (prog->type == AST_LIST) pstmlist(-1, prog); else { pstm(0, prog); nl(); } if (minify > 1) putchar('\n'); }"
"Status XParseColor ( register Display *dpy, Colormap cmap, _Xconst char *spec, XColor *def) { register int n, i; int r, g, b; char c; XcmsCCC ccc; XcmsColor cmsColor; if (!spec) return(0); n = (int) strlen (spec); if (*spec == '#') { spec++; n--; if (n != 3 && n != 6 && n != 9 && n != 12) return (0); n /= 3; g = b = 0; do { r = g; g = b; b = 0; for (i = n; --i >= 0; ) { c = *spec++; b <<= 4; if (c >= '0' && c <= '9') b |= c - '0'; else if (c >= 'A' && c <= 'F') b |= c - ('A' - 10); else if (c >= 'a' && c <= 'f') b |= c - ('a' - 10); else return (0); } } while (*spec != '\0'); n <<= 2; n = 16 - n; def->red = r << n; def->green = g << n; def->blue = b << n; def->flags = DoRed | DoGreen | DoBlue; return (1); } #ifdef XCMS if ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) { const char *tmpName = spec; switch (_XcmsResolveColorString(ccc, &tmpName, &cmsColor, XcmsRGBFormat)) { case XcmsSuccess: case XcmsSuccessWithCompression: cmsColor.pixel = def->pixel; _XcmsRGB_to_XColor(&cmsColor, def, 1); return(1); case XcmsFailure: case _XCMS_NEWNAME: break; } } #endif { xLookupColorReply reply; register xLookupColorReq *req; LockDisplay(dpy); GetReq (LookupColor, req); req->cmap = cmap; req->nbytes = (CARD16) (n = (int) strlen(spec)); req->length += (n + 3) >> 2; Data (dpy, spec, (long)n); if (!_XReply (dpy, (xReply *) &reply, 0, xTrue)) { UnlockDisplay(dpy); SyncHandle(); return (0); } def->red = reply.exactRed; def->green = reply.exactGreen; def->blue = reply.exactBlue; def->flags = DoRed | DoGreen | DoBlue; UnlockDisplay(dpy); SyncHandle(); return (1); } }"
"static BOOL handle_SSH2_newkeys(PTInstVar pvar) { logputs(LOG_LEVEL_VERBOSE, ""SSH2_MSG_NEWKEYS was received(DH key generation is completed).""); if (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) { save_memdump(LOGDUMP); } finish_memdump(); pvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED; ssh2_set_newkeys(pvar, MODE_IN); if (!CRYPT_start_encryption(pvar, 0, 1)) { } pvar->ssh2_keys[MODE_IN].mac.enabled = 1; pvar->ssh2_keys[MODE_IN].comp.enabled = 1; enable_recv_compression(pvar); SSH2_dispatch_add_message(SSH2_MSG_EXT_INFO); if (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) { if (pvar->kex_status & KEX_FLAG_REKEYING) { int i; Channel_t *c; do_SSH2_dispatch_setup_for_transfer(pvar); for (i = 0 ; i < CHANNEL_MAX ; i++) { c = &channels[i]; if (c->used) { ssh2_channel_retry_send_bufchain(pvar, c); } } } else { ssh2_finish_encryption_setup(pvar); ssh2_prep_userauth(pvar); } pvar->kex_status = KEX_FLAG_KEXDONE; } return TRUE; }"
"int pdf_is_pdf(FILE *fp) { int   is_pdf; char *header; header = get_header(fp); if (header && strstr(header, ""%PDF-"")) is_pdf = 1; else  is_pdf = 0; free(header); return is_pdf; }"
"bool GIFInput::read_subimage_data() { GifColorType* colormap = NULL; int colormap_count; if (m_gif_file->Image.ColorMap) {          colormap = m_gif_file->Image.ColorMap->Colors; colormap_count = m_gif_file->Image.ColorMap->ColorCount; } else if (m_gif_file->SColorMap) {          colormap = m_gif_file->SColorMap->Colors; colormap_count = m_gif_file->SColorMap->ColorCount; } else { errorf(""Neither local nor global colormap present.""); return false; } if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) { std::fill(m_canvas.begin(), m_canvas.end(), 0x00); } bool interlacing = m_spec.get_int_attribute(""gif:Interlacing"") != 0; int window_height = m_gif_file->Image.Height; int window_width  = m_gif_file->Image.Width; int window_top    = m_gif_file->Image.Top; int window_left   = m_gif_file->Image.Left; std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]); for (int wy = 0; wy < window_height; wy++) { if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) { report_last_error(); return false; } int y = window_top + (interlacing ? decode_line_number(wy, window_height) : wy); if (0 <= y && y < m_spec.height) { for (int wx = 0; wx < window_width; wx++) { if (fscanline[wx] >= colormap_count) { errorfmt(""Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\n"", fscanline[wx], wx, y, colormap_count); return false; } int x   = window_left + wx; int idx = m_spec.nchannels * (y * m_spec.width + x); if (0 <= x && x < m_spec.width && fscanline[wx] != m_transparent_color) { m_canvas[idx]     = colormap[fscanline[wx]].Red; m_canvas[idx + 1] = colormap[fscanline[wx]].Green; m_canvas[idx + 2] = colormap[fscanline[wx]].Blue; m_canvas[idx + 3] = 0xff; } } } } return true; }"
"void Context::onLog() { if (wasm_->onLog_) { wasm_->onLog_(this, id_); } }"
"static jobject getMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags) { jobject returnValue = NULL; J9VMThread *vmThread = (J9VMThread *) env; J9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions; SunReflectCPResult result = NULL_POINTER_EXCEPTION; jmethodID methodID = NULL; UDATA cpType = J9CPTYPE_UNUSED; if (NULL != constantPoolOop) { J9RAMConstantRef *ramConstantRef = NULL; jclass jlClass = NULL; vmFunctions->internalEnterVMFromJNI(vmThread); result = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef); if (OK == result) { J9Method *method = NULL; J9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop); J9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass); switch (cpType) { case J9CPTYPE_HANDLE_METHOD:  case J9CPTYPE_INSTANCE_METHOD:  case J9CPTYPE_INTERFACE_INSTANCE_METHOD: method = ((J9RAMMethodRef *) ramConstantRef)->method; if ((NULL == method) || (NULL == method->constantPool)) { if (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) { clearException(vmThread); method = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags); } if (NULL == method) { clearException(vmThread); method = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL); } } break; case J9CPTYPE_STATIC_METHOD:  case J9CPTYPE_INTERFACE_STATIC_METHOD: method = ((J9RAMStaticMethodRef *) ramConstantRef)->method; if ((NULL == method) || (NULL == method->constantPool)) { method = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags); if (NULL == method) { clearException(vmThread); vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method); } } break; case J9CPTYPE_INTERFACE_METHOD: method = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags); break; default: result = WRONG_CP_ENTRY_TYPE_EXCEPTION; break; } if (NULL != method) { methodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method); jlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject); } } vmFunctions->internalExitVMToJNI(vmThread); if (NULL != methodID) { if (NULL != jlClass) { const jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType); returnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic); } else { vmFunctions->throwNativeOOMError(env, 0, 0); } } } checkResult(env, result); return returnValue; }"
"int main(int argc, char** argv) { GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); cxxopts::Options options(""htm"", ""Headless terminal multiplexer""); options.allow_unrecognised_options(); options.add_options()             (""help"", ""Print help"")        (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")        ; auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } setvbuf(stdin, NULL, _IONBF, 0);     setvbuf(stdout, NULL, _IONBF, 0);   termios terminal_local; tcgetattr(0, &terminal_local); memcpy(&terminal_backup, &terminal_local, sizeof(struct termios)); cfmakeraw(&terminal_local); tcsetattr(0, TCSANOW, &terminal_local); struct sigaction action; memset(&action, 0, sizeof(struct sigaction)); action.sa_handler = term; sigaction(SIGTERM, &action, NULL); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); el::Loggers::setVerboseLevel(3); string maxlogsize = ""20971520""; LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + ""htm.log"", maxlogsize); LogHandler::stderrToFile(GetTempDirectory() + ""htm""); el::Loggers::reconfigureLogger(""default"", defaultConf); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); uid_t myuid = getuid(); if (result.count(""x"")) { LOG(INFO) << ""Killing previous htmd""; string command = string(""pkill -x -U "") + to_string(myuid) + string("" htmd""); system(command.c_str()); } string command = string(""pgrep -x -U "") + to_string(myuid) + string("" htmd""); string pgrepOutput = SystemToStr(command.c_str()); if (pgrepOutput.length() == 0) { int result = DaemonCreator::create(false, """"); if (result == DaemonCreator::CHILD) { exit(system(""htmd"")); } } std::this_thread::sleep_for(std::chrono::microseconds( 10 * 1000));    shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler()); SocketEndpoint pipeEndpoint; pipeEndpoint.set_name(HtmServer::getPipeName()); HtmClient htmClient(socketHandler, pipeEndpoint); htmClient.run(); char buf[] = { 0x1b, 0x5b, '$', '$', '$', 'q', }; RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf)); fflush(stdout); tcsetattr(0, TCSANOW, &terminal_backup); return 0; }"
"static int cfg80211_add_nontrans_list(struct cfg80211_bss *trans_bss, struct cfg80211_bss *nontrans_bss) { const struct element *ssid_elem; struct cfg80211_bss *bss = NULL; rcu_read_lock(); ssid_elem = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID); if (!ssid_elem) { rcu_read_unlock(); return -EINVAL; } list_for_each_entry(bss, &trans_bss->nontrans_list, nontrans_list) { if (is_bss(bss, nontrans_bss->bssid, ssid_elem->data, ssid_elem->datalen)) { rcu_read_unlock(); return 0; } } rcu_read_unlock(); list_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list); return 0; }"
static void vmei_reset_teardown(void *param) { struct virtio_mei *vmei = param; vmei->reset_mevp = NULL; pthread_mutex_destroy(&vmei->mutex); free(vmei->config); free(vmei); }
"static void lsi_do_msgout(LSIState *s) { uint8_t msg; int len; uint32_t current_tag; lsi_request *current_req, *p, *p_next; if (s->current) { current_tag = s->current->tag; current_req = s->current; } else { current_tag = s->select_tag; current_req = lsi_find_by_tag(s, current_tag); } trace_lsi_do_msgout(s->dbc); while (s->dbc) { msg = lsi_get_msgbyte(s); s->sfbr = msg; switch (msg) { case 0x04: trace_lsi_do_msgout_disconnect(); lsi_disconnect(s); break; case 0x08: trace_lsi_do_msgout_noop(); lsi_set_phase(s, PHASE_CMD); break; case 0x01: len = lsi_get_msgbyte(s); msg = lsi_get_msgbyte(s); (void)len;  trace_lsi_do_msgout_extended(msg, len); switch (msg) { case 1: trace_lsi_do_msgout_ignored(""SDTR""); lsi_skip_msgbytes(s, 2); break; case 3: trace_lsi_do_msgout_ignored(""WDTR""); lsi_skip_msgbytes(s, 1); break; case 4: trace_lsi_do_msgout_ignored(""PPR""); lsi_skip_msgbytes(s, 5); break; default: goto bad; } break; case 0x20:  s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; trace_lsi_do_msgout_simplequeue(s->select_tag & 0xff); break; case 0x21:  qemu_log_mask(LOG_UNIMP, ""lsi_scsi: HEAD queue not implemented\n""); s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; break; case 0x22:  qemu_log_mask(LOG_UNIMP, ""lsi_scsi: ORDERED queue not implemented\n""); s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; break; case 0x0d: trace_lsi_do_msgout_abort(current_tag); if (current_req) { scsi_req_cancel(current_req->req); } lsi_disconnect(s); break; case 0x06: case 0x0e: case 0x0c: if (msg == 0x06) { trace_lsi_do_msgout_abort(current_tag); } if (msg == 0x0e) { trace_lsi_do_msgout_clearqueue(current_tag); } if (msg == 0x0c) { trace_lsi_do_msgout_busdevicereset(current_tag); } if (s->current) { scsi_req_cancel(s->current->req); } QTAILQ_FOREACH_SAFE(p, &s->queue, next, p_next) { if ((p->tag & 0x0000ff00) == (current_tag & 0x0000ff00)) { scsi_req_cancel(p->req); } } lsi_disconnect(s); break; default: if ((msg & 0x80) == 0) { goto bad; } s->current_lun = msg & 7; trace_lsi_do_msgout_select(s->current_lun); lsi_set_phase(s, PHASE_CMD); break; } } return; bad: qemu_log_mask(LOG_UNIMP, ""Unimplemented message 0x%02x\n"", msg); lsi_set_phase(s, PHASE_MI); lsi_add_msg_byte(s, 7);  s->msg_action = LSI_MSG_ACTION_COMMAND; }"
"inline typename V::VariantType FBUnserializer<V>::unserializeThing() { size_t code = nextCode(); switch (code) { case FB_SERIALIZE_BYTE: case FB_SERIALIZE_I16: case FB_SERIALIZE_I32: case FB_SERIALIZE_I64: return V::fromInt64(unserializeInt64()); case FB_SERIALIZE_VARCHAR: case FB_SERIALIZE_STRING: return V::fromString(unserializeString()); case FB_SERIALIZE_STRUCT: return V::fromMap(unserializeMap()); case FB_SERIALIZE_NULL: ++p_; return V::createNull(); case FB_SERIALIZE_DOUBLE: return V::fromDouble(unserializeDouble()); case FB_SERIALIZE_BOOLEAN: return V::fromBool(unserializeBoolean()); case FB_SERIALIZE_VECTOR: return V::fromVector(unserializeVector()); case FB_SERIALIZE_LIST: return V::fromVector(unserializeList()); case FB_SERIALIZE_SET: return V::fromSet(unserializeSet()); default: throw UnserializeError(""Invalid code: "" + folly::to<std::string>(code) + "" at location "" + folly::to<std::string>(p_)); } }"
"static void mctp_unregister(struct net_device *dev) { struct mctp_dev *mdev; mdev = mctp_dev_get_rtnl(dev); if (mdev && !mctp_known(dev)) { netdev_warn(dev, ""%s: BUG mctp_ptr set for unknown type %d"", __func__, dev->type); return; } if (!mdev) return; RCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL); mctp_route_remove_dev(mdev); mctp_neigh_remove_dev(mdev); kfree(mdev->addrs); mctp_dev_put(mdev); }"
"static void ax25_kill_by_device(struct net_device *dev) { ax25_dev *ax25_dev; ax25_cb *s; struct sock *sk; if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) return; spin_lock_bh(&ax25_list_lock); again: ax25_for_each(s, &ax25_list) { if (s->ax25_dev == ax25_dev) { sk = s->sk; sock_hold(sk); spin_unlock_bh(&ax25_list_lock); lock_sock(sk); s->ax25_dev = NULL; ax25_dev_put(ax25_dev); release_sock(sk); ax25_disconnect(s, ENETUNREACH); spin_lock_bh(&ax25_list_lock); sock_put(sk); goto again; } } spin_unlock_bh(&ax25_list_lock); }"
"static int read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg, Bit_Chain *sec_dat, Dwg_Section_Type type) { uint32_t address, sec_mask, initial_address; uint32_t max_decomp_size; long bytes_left; Dwg_Section_Info *info = NULL; encrypted_section_header es; BITCODE_RC *decomp; BITCODE_BL i, j; int error = 0; for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i) { if (dwg->header.section_info[i].fixedtype == type) { info = &dwg->header.section_info[i]; break; } } sec_dat->chain = NULL;   if (!info) { if (type < SECTION_REVHISTORY && type != SECTION_TEMPLATE && type != SECTION_OBJFREESPACE) { LOG_WARN (""Failed to find section_info[%u] with type %d"", i, type) } else { LOG_TRACE (""Found no section_info[%u] with type %d\n"", i, type) } return DWG_ERR_SECTIONNOTFOUND; } else { LOG_TRACE (""\nFound section_info["" FORMAT_BL ""] %s type %d with %d sections (%scompressed):\n"", i, info->name, type, info->num_sections, info->compressed == 2 ? """" : ""un""); } max_decomp_size = info->num_sections * info->max_decomp_size; if (info->num_sections == 0) return 0; if (max_decomp_size == 0 || max_decomp_size > 0x2f000000)     { LOG_ERROR (""Invalid section %s count or max decompression size. "" ""Sections: %u, Max size: %u"", info->name, info->num_sections, info->max_decomp_size); return DWG_ERR_INVALIDDWG; } decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC)); if (!decomp) { LOG_ERROR (""Out of memory with %u sections"", info->num_sections); return DWG_ERR_OUTOFMEM; } bytes_left = max_decomp_size; initial_address = info->sections[0] ? info->sections[0]->address : 0; sec_dat->bit = 0; sec_dat->byte = 0; sec_dat->version = dat->version; sec_dat->from_version = dat->from_version; sec_dat->chain = decomp; for (i = 0; i < info->num_sections; ++i) { if (!info->sections[i]) { LOG_WARN (""Skip empty section %u %s"", i, info->name); continue; } address = info->sections[i]->address; dat->byte = address; bit_read_fixed (dat, es.char_data, 32); sec_mask = 0x4164536b ^ address; for (j = 0; j < 8; ++j) es.long_data[j] ^= sec_mask; LOG_INFO (""=== Section %s (%u) @%u ===\n"", info->name, i, address) if (es.fields.tag != 0x4163043b) { LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"", (unsigned)es.fields.tag); } else { LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)es.fields.tag); } LOG_INFO (""Section Type:     %u\n"", (unsigned)es.fields.section_type) LOG_INFO (""Data size:        0x%x/%u\n"", (unsigned)es.fields.data_size, (unsigned)es.fields.data_size) LOG_INFO (""Comp data size:   0x%x\n"", (unsigned)es.fields.section_size) LOG_TRACE (""StartOffset:      0x%x\n"", (unsigned)es.fields.address) LOG_HANDLE (""Unknown:          0x%x\n"", (unsigned)es.fields.unknown) LOG_HANDLE (""Checksum1:        0x%x\n"", (unsigned)es.fields.checksum_1) LOG_HANDLE (""Checksum2:        0x%x\n"", (unsigned)es.fields.checksum_2) LOG_TRACE (""Section start:    %lu\n\n"", dat->byte); LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", i, (unsigned long)info->max_decomp_size, (unsigned long)info->max_decomp_size) LOG_INSANE (""max_decomp_size:          %lu (0x%lx)\n"", (unsigned long)max_decomp_size, (unsigned long)max_decomp_size) LOG_INSANE (""bytes_left:               %ld\n"", bytes_left); if (info->compressed == 2 && bytes_left > 0 && (i * info->max_decomp_size) <= max_decomp_size) { error = decompress_R2004_section ( dat, &decomp[i * info->max_decomp_size],               info->max_decomp_size, es.fields.data_size); if (error > DWG_ERR_CRITICAL) { sec_dat->chain = NULL;               free (decomp); return error; } bytes_left -= info->max_decomp_size; sec_dat->size = max_decomp_size; } else { if (info->compressed == 2 || info->size > max_decomp_size || bytes_left < 0 ) { LOG_ERROR (""Some section size out of bounds"") sec_dat->chain = NULL; free (decomp); return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG : DWG_ERR_VALUEOUTOFBOUNDS; } memcpy (&decomp[i * info->size], &dat->chain[address + es.fields.address + 32], MIN (bytes_left, info->size)); bytes_left -= info->size; sec_dat->size = max_decomp_size; } } return error; }"
"static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr) { struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx; struct tipc_aead_key *skey = NULL; u16 key_gen = msg_key_gen(hdr); u16 size = msg_data_sz(hdr); u8 *data = msg_data(hdr); spin_lock(&rx->lock); if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) { pr_err(""%s: key existed <%p>, gen %d vs %d\n"", rx->name, rx->skey, key_gen, rx->key_gen); goto exit; } skey = kmalloc(size, GFP_ATOMIC); if (unlikely(!skey)) { pr_err(""%s: unable to allocate memory for skey\n"", rx->name); goto exit; } skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME))); memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME); memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32), skey->keylen); if (unlikely(size != tipc_aead_key_size(skey))) { kfree(skey); skey = NULL; goto exit; } rx->key_gen = key_gen; rx->skey_mode = msg_key_mode(hdr); rx->skey = skey; rx->nokey = 0; mb();  exit: spin_unlock(&rx->lock); if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0))) return true; return false; }"
"void Client::encryptConnection() { boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23}; const auto remote_hostname = *client_options_.remote_hostname_; bool verify_hostname = false; if (client_options_.always_verify_peer_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); verify_hostname = true; } else { ctx.set_verify_mode(boost::asio::ssl::verify_none); } if (client_options_.server_certificate_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); ctx.load_verify_file(*client_options_.server_certificate_); verify_hostname = true; } if (client_options_.verify_path_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); ctx.add_verify_path(*client_options_.verify_path_); verify_hostname = true; } if (client_options_.ciphers_) { ::SSL_CTX_set_cipher_list(ctx.native_handle(), client_options_.ciphers_->c_str()); } if (client_options_.ssl_options_) { ctx.set_options(client_options_.ssl_options_); } if (client_options_.client_certificate_file_) { ctx.use_certificate_file(*client_options_.client_certificate_file_, boost::asio::ssl::context::pem); } if (client_options_.client_private_key_file_) { ctx.use_private_key_file(*client_options_.client_private_key_file_, boost::asio::ssl::context::pem); } ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx); ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(), remote_hostname.c_str()); if (verify_hostname) { ssl_sock_->set_verify_callback( boost::asio::ssl::rfc2818_verification(remote_hostname)); } callNetworkOperation([&]() { ssl_sock_->async_handshake( boost::asio::ssl::stream_base::client, std::bind(&Client::handshakeHandler, this, std::placeholders::_1)); }); if (ec_) { throw std::system_error(ec_); } }"
"db_result_t storage_put_index(index_t *index) { char filename[INDEX_NAME_LENGTH]; int fd; int r; struct index_record record; db_result_t result; merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX); fd = cfs_open(filename, CFS_WRITE | CFS_APPEND); if(fd < 0) { return DB_STORAGE_ERROR; } strcpy(record.attribute_name, index->attr->name); memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name)); record.type = index->type; result = DB_OK; r = cfs_write(fd, &record, sizeof(record)); if(r < sizeof(record)) { result = DB_STORAGE_ERROR; } else { PRINTF(""DB: Wrote an index record for %s.%s, type %d\n"", index->rel->name, index->attr->name, record.type); } cfs_close(fd); return result; }"
"char *build_local_reparse(tm_cell_t *Trans,unsigned int branch, unsigned int *len, char *method, int method_len, str *to , struct cancel_reason *reason ) { char*invite_buf, *invite_buf_end; char*cancel_buf; char*s, *s1, *d; shortinvite_len; enum _hdr_types_thf_type; intfirst_via, to_len; int cancel_buf_len; int reason_len, code_len; struct hdr_field *reas1, *reas_last, *hdr; int hadded = 0; sr_cfgenv_t *cenv = NULL; invite_buf = Trans->uac[branch].request.buffer; invite_len = Trans->uac[branch].request.buffer_len; if (!invite_buf || invite_len<=0) { LM_ERR(""INVITE is missing\n""); goto error; } if ((*invite_buf != 'I') && (*invite_buf != 'i')) { LM_ERR(""trying to build with local reparse"" "" for a non-INVITE request?\n""); goto error; } reason_len = 0; reas1 = 0; reas_last = 0; if (reason && reason->cause != CANCEL_REAS_UNKNOWN){ if (likely(reason->cause > 0 && cfg_get(tm, tm_cfg, local_cancel_reason))){ reason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN + (reason->u.text.s? REASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) + CRLF_LEN; } else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS && !(Trans->flags & T_NO_E2E_CANCEL_REASON))) { reason_len = reason->u.packed_hdrs.len; } else if (reason->cause == CANCEL_REAS_RCVD_CANCEL && reason->u.e2e_cancel && !(Trans->flags & T_NO_E2E_CANCEL_REASON)) { if(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) { LM_WARN(""failed to parse headers\n""); } for(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr; hdr; hdr=next_sibling_hdr(hdr)) { reason_len += hdr->len; reas_last=hdr; } } else if (unlikely(reason->cause < CANCEL_REAS_MIN)) LM_BUG(""unhandled reason cause %d\n"", reason->cause); } invite_buf_end = invite_buf + invite_len; s = invite_buf; to_len = to ? to->len : 0; cancel_buf_len = invite_len + to_len + reason_len; cancel_buf = shm_malloc(sizeof(char)*cancel_buf_len); if (!cancel_buf) { SHM_MEM_ERROR; goto error; } d = cancel_buf; append_str(d, method, method_len); *d = ' '; d++; s += 7; s1 = s; s = eat_line(s, invite_buf_end - s); append_str(d, s1, s - s1); cenv = sr_cfgenv_get(); first_via = 1; while (s < invite_buf_end) { s1 = s; if ((*s == '\n') || (*s == '\r')) { hf_type = HDR_EOH_T; } else { s = lw_get_hf_name(s, invite_buf_end, &hf_type); } switch(hf_type) { case HDR_CSEQ_T: while ((s < invite_buf_end) && ((*s == ':') || (*s == ' ') || (*s == '\t') || ((*s >= '0') && (*s <= '9'))) ) s++; append_str(d, s1, s - s1); append_str(d, method, method_len); append_str(d, CRLF, CRLF_LEN); s = lw_next_line(s, invite_buf_end); break; case HDR_VIA_T: s = lw_next_line(s, invite_buf_end); if (first_via) { append_str(d, s1, s - s1); first_via = 0; }  break; case HDR_TO_T: if (to_len == 0) { s = lw_next_line(s, invite_buf_end); append_str(d, s1, s - s1); } else { append_str(d, to->s, to->len); s = lw_next_line(s, invite_buf_end); } break; case HDR_FROM_T: case HDR_CALLID_T: case HDR_ROUTE_T: case HDR_MAXFORWARDS_T: s = lw_next_line(s, invite_buf_end); append_str(d, s1, s - s1); break; case HDR_REQUIRE_T: case HDR_PROXYREQUIRE_T: s = lw_next_line(s, invite_buf_end); break; case HDR_CONTENTLENGTH_T: append_str(d, s1, s - s1); append_str(d, "": 0"" CRLF, 3 + CRLF_LEN); s = lw_next_line(s, invite_buf_end); break; case HDR_EOH_T: if (reason_len) { if (likely(reason->cause > 0)) { append_str(d, REASON_PREFIX, REASON_PREFIX_LEN); code_len=ushort2sbuf(reason->cause, d, cancel_buf_len-(int)(d-cancel_buf)); if (unlikely(code_len==0)) LM_BUG(""not enough space to write reason code""); d+=code_len; if (reason->u.text.s){ append_str(d, REASON_TEXT, REASON_TEXT_LEN); *d='""'; d++; append_str(d, reason->u.text.s, reason->u.text.len); *d='""'; d++; } append_str(d, CRLF, CRLF_LEN); } else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS)) { append_str(d, reason->u.packed_hdrs.s, reason->u.packed_hdrs.len); } else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) { for(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) { append_str(d, hdr->name.s, hdr->len); if (likely(hdr==reas_last)) break; } } } append_str(d, CRLF, CRLF_LEN); *len = d - cancel_buf; return cancel_buf; default: s = lw_next_line(s, invite_buf_end); hadded = 0; if(Trans->uas.request && (Trans->uas.request->msg_flags & FL_UAC_AUTH)) { if(s1 + cenv->uac_cseq_auth.len + 2 < invite_buf_end) { if(s1[cenv->uac_cseq_auth.len]==':' && strncmp(s1, cenv->uac_cseq_auth.s, cenv->uac_cseq_auth.len)==0) { hadded = 1; append_str(d, s1, s - s1); } else if(s1[cenv->uac_cseq_refresh.len]==':' && strncmp(s1, cenv->uac_cseq_refresh.s, cenv->uac_cseq_refresh.len)==0) { hadded = 1; append_str(d, s1, s - s1); } } } if(likely(hadded==0)) { if (cfg_get(tm, tm_cfg, ac_extra_hdrs).len && (s1 + cfg_get(tm, tm_cfg, ac_extra_hdrs).len < invite_buf_end) && (strncasecmp(s1, cfg_get(tm, tm_cfg, ac_extra_hdrs).s, cfg_get(tm, tm_cfg, ac_extra_hdrs).len) == 0)) { append_str(d, s1, s - s1); } } break; } } LM_ERR(""HDR_EOH_T was not found\n""); shm_free(cancel_buf); error: LM_ERR(""cannot build %.*s request\n"", method_len, method); return NULL; }"
"static void paste_option_changed(void) { static intold_p_paste = FALSE; static intsave_sm = 0; static intsave_sta = 0; #ifdef FEAT_CMDL_INFO static intsave_ru = 0; #endif #ifdef FEAT_RIGHTLEFT static intsave_ri = 0; static intsave_hkmap = 0; #endif buf_T*buf; if (p_paste) { if (!old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw_nopaste = buf->b_p_tw; buf->b_p_wm_nopaste = buf->b_p_wm; buf->b_p_sts_nopaste = buf->b_p_sts; buf->b_p_ai_nopaste = buf->b_p_ai; buf->b_p_et_nopaste = buf->b_p_et; #ifdef FEAT_VARTABS if (buf->b_p_vsts_nopaste) vim_free(buf->b_p_vsts_nopaste); buf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option ? vim_strsave(buf->b_p_vsts) : NULL; #endif } save_sm = p_sm; save_sta = p_sta; #ifdef FEAT_CMDL_INFO save_ru = p_ru; #endif #ifdef FEAT_RIGHTLEFT save_ri = p_ri; save_hkmap = p_hkmap; #endif p_ai_nopaste = p_ai; p_et_nopaste = p_et; p_sts_nopaste = p_sts; p_tw_nopaste = p_tw; p_wm_nopaste = p_wm; #ifdef FEAT_VARTABS if (p_vsts_nopaste) vim_free(p_vsts_nopaste); p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL; #endif } FOR_ALL_BUFFERS(buf) { buf->b_p_tw = 0;        buf->b_p_wm = 0;        buf->b_p_sts = 0;        buf->b_p_ai = 0;        buf->b_p_et = 0;    #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = empty_option; if (buf->b_p_vsts_array) vim_free(buf->b_p_vsts_array); buf->b_p_vsts_array = 0; #endif } p_sm = 0;    p_sta = 0;    #ifdef FEAT_CMDL_INFO if (p_ru) status_redraw_all();    p_ru = 0;    #endif #ifdef FEAT_RIGHTLEFT p_ri = 0;    p_hkmap = 0;    #endif p_tw = 0; p_wm = 0; p_sts = 0; p_ai = 0; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = empty_option; #endif } else if (old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw = buf->b_p_tw_nopaste; buf->b_p_wm = buf->b_p_wm_nopaste; buf->b_p_sts = buf->b_p_sts_nopaste; buf->b_p_ai = buf->b_p_ai_nopaste; buf->b_p_et = buf->b_p_et_nopaste; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = buf->b_p_vsts_nopaste ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option; if (buf->b_p_vsts_array) vim_free(buf->b_p_vsts_array); if (buf->b_p_vsts && buf->b_p_vsts != empty_option) tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array); else buf->b_p_vsts_array = 0; #endif } p_sm = save_sm; p_sta = save_sta; #ifdef FEAT_CMDL_INFO if (p_ru != save_ru) status_redraw_all();    p_ru = save_ru; #endif #ifdef FEAT_RIGHTLEFT p_ri = save_ri; p_hkmap = save_hkmap; #endif p_ai = p_ai_nopaste; p_et = p_et_nopaste; p_sts = p_sts_nopaste; p_tw = p_tw_nopaste; p_wm = p_wm_nopaste; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option; #endif } old_p_paste = p_paste; }"
"double js_strtod(const char *string, char **endPtr) { int sign, expSign = FALSE; double fraction, dblExp, *d; register const char *p; register int c; int exp = 0; int fracExp = 0; int mantSize; int decPt; const char *pExp; p = string; while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') { p += 1; } if (*p == '-') { sign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } sign = FALSE; } decPt = -1; for (mantSize = 0; ; mantSize += 1) { c = *p; if (!(c>='0'&&c<='9')) { if ((c != '.') || (decPt >= 0)) { break; } decPt = mantSize; } p += 1; } pExp = p; p -= mantSize; if (decPt < 0) { decPt = mantSize; } else { mantSize -= 1; } if (mantSize > 18) { fracExp = decPt - 18; mantSize = 18; } else { fracExp = decPt - mantSize; } if (mantSize == 0) { fraction = 0.0; p = string; goto done; } else { int frac1, frac2; frac1 = 0; for ( ; mantSize > 9; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac1 = 10*frac1 + (c - '0'); } frac2 = 0; for (; mantSize > 0; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac2 = 10*frac2 + (c - '0'); } fraction = (1.0e9 * frac1) + frac2; } p = pExp; if ((*p == 'E') || (*p == 'e')) { p += 1; if (*p == '-') { expSign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } expSign = FALSE; } while ((*p >= '0') && (*p <= '9')) { exp = exp * 10 + (*p - '0'); p += 1; } } if (expSign) { exp = fracExp - exp; } else { exp = fracExp + exp; } if (exp < -maxExponent) { exp = maxExponent; expSign = TRUE; errno = ERANGE; } else if (exp > maxExponent) { exp = maxExponent; expSign = FALSE; errno = ERANGE; } else if (exp < 0) { expSign = TRUE; exp = -exp; } else { expSign = FALSE; } dblExp = 1.0; for (d = powersOf10; exp != 0; exp >>= 1, d += 1) { if (exp & 01) { dblExp *= *d; } } if (expSign) { fraction /= dblExp; } else { fraction *= dblExp; } done: if (endPtr != NULL) { *endPtr = (char *) p; } if (sign) { return -fraction; } return fraction; }"
"static GBytes * finish_headers (CockpitWebResponse *self, GString *string, gssize length, gint status, guint seen) { const gchar *content_type; if ((seen & HEADER_CONTENT_TYPE) == 0 && self->full_path != NULL && status >= 200 && status <= 299) { content_type = cockpit_web_response_content_type (self->full_path); if (content_type) g_string_append_printf (string, ""Content-Type: %s\r\n"", content_type); } if (status != 304) { if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters) { self->chunked = TRUE; g_string_append_printf (string, ""Transfer-Encoding: chunked\r\n""); } else { self->chunked = FALSE; g_string_append_printf (string, ""Content-Length: %"" G_GSSIZE_FORMAT ""\r\n"", length); self->out_queueable = length; } } if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299) { if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER) g_string_append (string, ""Cache-Control: max-age=31556926, public\r\n""); else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE) g_string_append (string, ""Cache-Control: no-cache, no-store\r\n""); else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE) g_string_append (string, ""Cache-Control: max-age=86400, private\r\n""); } if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 && self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE) { g_string_append (string, ""Vary: Cookie\r\n""); } if (!self->keep_alive) g_string_append (string, ""Connection: close\r\n""); if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0) g_string_append (string, ""X-DNS-Prefetch-Control: off\r\n""); if ((seen & HEADER_REFERRER_POLICY) == 0) g_string_append (string, ""Referrer-Policy: no-referrer\r\n""); if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0) g_string_append (string, ""X-Content-Type-Options: nosniff\r\n""); if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0) g_string_append (string, ""Cross-Origin-Resource-Policy: same-origin\r\n""); g_string_append (string, ""\r\n""); return g_string_free_to_bytes (string); }"
"static int printbuf_extend(struct printbuf *p, int min_size) { char *t; int new_size; if (p->size >= min_size) return 0; new_size = p->size * 2; if (new_size < min_size + 8) new_size =  min_size + 8; #ifdef PRINTBUF_DEBUG MC_DEBUG(""printbuf_memappend: realloc "" ""bpos=%d min_size=%d old_size=%d new_size=%d\n"", p->bpos, min_size, p->size, new_size); #endif  if(!(t = (char*)realloc(p->buf, new_size))) return -1; p->size = new_size; p->buf = t; return 0; }"
"static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf) { clist_node_t new_queue = { .next = NULL }; fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL; evtimer_del((evtimer_t *)(&_arq_timer), &fbuf->sfr.arq_timeout_event.event); fbuf->sfr.arq_timeout_event.event.next = NULL; if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) { for (clist_node_t *node = clist_lpop(&_frame_queue); node != NULL; node = clist_lpop(&_frame_queue)) { _frame_queue_t *entry = (_frame_queue_t *)node; if (entry->datagram_tag == fbuf->tag) { gnrc_pktbuf_release(entry->frame); entry->frame = NULL; clist_rpush(&_frag_descs_free, node); } else { clist_rpush(&new_queue, node); } } _frame_queue = new_queue; } fbuf->offset = 0U; fbuf->sfr.cur_seq = 0U; fbuf->sfr.frags_sent = 0U; for (clist_node_t *node = clist_lpop(&fbuf->sfr.window); node != NULL; node = clist_lpop(&fbuf->sfr.window)) { clist_rpush(&_frag_descs_free, node); } }"
"static GCObject **correctgraylist (GCObject **p) { GCObject *curr; while ((curr = *p) != NULL) { switch (curr->tt) { case LUA_VTABLE: case LUA_VUSERDATA: { GCObject **next = getgclist(curr); if (getage(curr) == G_TOUCHED1) {   lua_assert(isgray(curr)); gray2black(curr);   changeage(curr, G_TOUCHED1, G_TOUCHED2); p = next;   } else {   if (!iswhite(curr)) {   lua_assert(isold(curr)); if (getage(curr) == G_TOUCHED2)   changeage(curr, G_TOUCHED2, G_OLD);   gray2black(curr);   } *p = *next;   } break; } case LUA_VTHREAD: { lua_State *th = gco2th(curr); lua_assert(!isblack(th)); if (iswhite(th))   *p = th->gclist;   else   p = &th->gclist;   break; } default: lua_assert(0);   } } return p; }"
"void cb_metrics_prometheus(mk_request_t *request, void *data) { int i; int j; int m; int len; int time_len; int start_time_len; size_t index; size_t num_metrics = 0; long now; flb_sds_t sds; flb_sds_t sds_metric; flb_sds_t tmp_sds; struct flb_sds *metric_helptxt_head; flb_sds_t metric_helptxt; size_t off = 0; struct flb_hs_buf *buf; msgpack_unpacked result; msgpack_object map; char tmp[32]; char time_str[64]; char start_time_str[64]; char* *metrics_arr; struct timeval tp; struct flb_hs *hs = data; struct flb_config *config = hs->config; buf = metrics_get_latest(); if (!buf) { mk_http_status(request, 404); mk_http_done(request); return; } buf->users++; sds = flb_sds_create_size(1024); if (!sds) { mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt = flb_sds_create_size(128); if (!metric_helptxt) { flb_sds_destroy(sds); mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt); gettimeofday(&tp, NULL); now = tp.tv_sec * 1000 + tp.tv_usec / 1000; time_len = snprintf(time_str, sizeof(time_str) - 1, ""%lu"", now); start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, ""%lu"", config->init_time); index = 0; msgpack_unpacked_init(&result); msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off); map = result.data; for (i = 0; i < map.via.map.size; i++) { msgpack_object v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { num_metrics++; } } } metrics_arr = flb_malloc(num_metrics * sizeof(char*)); for (i = 0; i < map.via.map.size; i++) { msgpack_object k; msgpack_object v; k = map.via.map.ptr[i].key; v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sk; msgpack_object sv; sk = v.via.map.ptr[j].key; sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { msgpack_object mk; msgpack_object mv; mk = sv.via.map.ptr[m].key; mv = sv.via.map.ptr[m].val; len = snprintf(tmp, sizeof(tmp) - 1, ""%"" PRIu64 "" "", mv.via.u64); if (len < 0) { goto error; } sds_metric = flb_sds_create_size(k.via.str.size + mk.via.str.size + sk.via.str.size + len + time_len + 28); if (sds_metric == NULL) { goto error; } sds_metric = flb_sds_cat(sds_metric, ""fluentbit_"", 10); sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_"", 1); sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_total{name=\"""", 13); sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""\""} "", 3); sds_metric = flb_sds_cat(sds_metric, tmp, len); sds_metric = flb_sds_cat(sds_metric, time_str, time_len); sds_metric = flb_sds_cat(sds_metric, ""\n"", 1); metrics_arr[index] = sds_metric; index++; } } } qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp); tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); for (i = 0; i < num_metrics; i++) { tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i])); null_check(tmp_sds); if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) { tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); metric_helptxt_head->len = 0; if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); } } tmp_sds = flb_sds_cat(sds, ""# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n"", 89); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE process_start_time_seconds gauge\n"", 40); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""process_start_time_seconds "", 27); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\n"", 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# HELP fluentbit_build_info Build version information.\n"", 55); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE fluentbit_build_info gauge\n"", 34); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""fluentbit_build_info{version=\"""", 30); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\"",edition=\"""", 11); null_check(tmp_sds); #ifdef FLB_ENTERPRISE tmp_sds = flb_sds_cat(sds, ""Enterprise\""} 1\n"", 15); null_check(tmp_sds); #else tmp_sds = flb_sds_cat(sds, ""Community\""} 1\n"", 14); null_check(tmp_sds); #endif msgpack_unpacked_destroy(&result); buf->users--; mk_http_status(request, 200); mk_http_header(request, ""Content-Type"", 12, PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1); mk_http_send(request, sds, flb_sds_len(sds), NULL); for (i = 0; i < num_metrics; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); mk_http_done(request); return; error: mk_http_status(request, 500); mk_http_done(request); buf->users--; for (i = 0; i < index; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); msgpack_unpacked_destroy(&result); }"
"static int build_open_gop_key_points(AVStream *st) { int k; int sample_id = 0; uint32_t cra_index; MOVStreamContext *sc = st->priv_data; if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count) return 0; sc->sample_offsets_count = 0; for (uint32_t i = 0; i < sc->ctts_count; i++) sc->sample_offsets_count += sc->ctts_data[i].count; av_freep(&sc->sample_offsets); sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets)); if (!sc->sample_offsets) return AVERROR(ENOMEM); k = 0; for (uint32_t i = 0; i < sc->ctts_count; i++) for (int j = 0; j < sc->ctts_data[i].count; j++) sc->sample_offsets[k++] = sc->ctts_data[i].duration; cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT);  if (!cra_index) return 0; sc->open_key_samples_count = 0; for (uint32_t i = 0; i < sc->sync_group_count; i++) if (sc->sync_group[i].index == cra_index) sc->open_key_samples_count += sc->sync_group[i].count; av_freep(&sc->open_key_samples); sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples)); if (!sc->open_key_samples) return AVERROR(ENOMEM); k = 0; for (uint32_t i = 0; i < sc->sync_group_count; i++) { const MOVSbgp *sg = &sc->sync_group[i]; if (sg->index == cra_index) for (uint32_t j = 0; j < sg->count; j++) sc->open_key_samples[k++] = sample_id; sample_id += sg->count; } sc->min_sample_duration = UINT_MAX; for (uint32_t i = 0; i < sc->stts_count; i++) sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration); return 0; }"
"void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v) { if (v->vt != JSI_VT_OBJECT) { Jsi_LogBug(""Jsi_ValueArrayShift, target is not object""); return; } Jsi_Obj *o = v->d.obj; if (o->isarrlist) { uint i; if (!o->arrCnt) return; if (o->arr[0]) Jsi_DecrRefCount(interp, o->arr[0]); for (i=1; i<o->arrCnt; i++) { o->arr[i-1] = o->arr[i]; } o->arr[o->arrCnt--] = NULL; return; } int len = Jsi_ObjGetLength(interp, v->d.obj); if (len <= 0) return; Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0); if (!v0) return; Jsi_ValueReset(interp, &v0); int i; Jsi_Value *last = v0; for (i = 1; i < len; ++i) { Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i); if (!t) return; Jsi_ValueCopy(interp, last, t); Jsi_ValueReset(interp, &t); last = t; } Jsi_ObjSetLength(interp, v->d.obj, len - 1); }"
"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box) { u32 type, uuid_type, hdr_size, restore_type; u64 size, start, comp_start, end; char uuid[16]; GF_Err e; GF_BitStream *uncomp_bs = NULL; u8 *uncomp_data = NULL; u32 compressed_size=0; GF_Box *newBox; Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE; Bool is_special = GF_TRUE; if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM; *outBox = NULL; if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } comp_start = start = gf_bs_get_position(bs); uuid_type = 0; size = (u64) gf_bs_read_u32(bs); hdr_size = 4; if ((size >= 2) && (size <= 4)) { size = 4; type = GF_ISOM_BOX_TYPE_VOID; } else { type = gf_bs_read_u32(bs); hdr_size += 4; if (type == GF_ISOM_BOX_TYPE_TOTL) size = 12; if (!size) { if (is_root_box) { if (!skip_logs) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type)); } size = gf_bs_available(bs) + 8; } else { if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start)); } return GF_OK; } } if (is_root_box && (size>=8)) { Bool do_uncompress = GF_FALSE; u8 *compb = NULL; u32 osize = 0; u32 otype = type; if (type==GF_4CC('!', 'm', 'o', 'f')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_MOOF; } else if (type==GF_4CC('!', 'm', 'o', 'v')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_MOOV; } else if (type==GF_4CC('!', 's', 'i', 'x')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_SIDX; } else if (type==GF_4CC('!', 's', 's', 'x')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_SSIX; } if (do_uncompress) { compb = gf_malloc((u32) (size-8)); compressed_size = (u32) (size - 8); gf_bs_read_data(bs, compb, compressed_size); e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype)); return e; } size = osize + 8; uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ); bs = uncomp_bs; start = 0; gf_free(compb); } } } memset(uuid, 0, 16); if (type == GF_ISOM_BOX_TYPE_UUID ) { if (gf_bs_available(bs) < 16) { return GF_ISOM_INCOMPLETE_FILE; } gf_bs_read_data(bs, uuid, 16); hdr_size += 16; uuid_type = gf_isom_solve_uuid_box(uuid); } if (size == 1) { if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } size = gf_bs_read_u64(bs); hdr_size += 8; } if (!skip_logs) GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start)); if ( size < hdr_size ) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size)); return GF_ISOM_INVALID_FILE; } restore_type = 0; if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) { u64 cookie = gf_bs_get_cookie(bs); restore_type = type; if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK) type = GF_QT_SUBTYPE_RAW_VID; else type = GF_QT_SUBTYPE_RAW_AUD; } if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI); if (!newBox) return GF_OUT_OF_MEM; ((GF_ItemReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackGroupTypeBox*)newBox)->group_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT); if (!newBox) return GF_OUT_OF_MEM; ((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type; } else { is_special = GF_FALSE; newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box); if (!newBox) return GF_OUT_OF_MEM; } if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) { memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16); ((GF_UUIDBox *)newBox)->internal_4cc = uuid_type; } if (!newBox->type) newBox->type = type; if (restore_type) newBox->type = restore_type; end = gf_bs_available(bs); if (size - hdr_size > end ) { newBox->size = size - hdr_size - end; *outBox = newBox; return GF_ISOM_INCOMPLETE_FILE; } newBox->size = size - hdr_size; e = gf_isom_full_box_read(newBox, bs); if (!e) e = gf_isom_box_read(newBox, bs); if (e) { if (gf_opts_get_bool(""core"", ""no-check"")) e = GF_OK; } newBox->size = size; end = gf_bs_get_position(bs); if (uncomp_bs) { gf_free(uncomp_data); gf_bs_del(uncomp_bs); if (e) { gf_isom_box_del(newBox); *outBox = NULL; return e; } size -= 8; if (type==GF_ISOM_BOX_TYPE_MOOF) { ((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } else if (type==GF_ISOM_BOX_TYPE_MOOV) { ((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; ((GF_MovieBox *)newBox)->file_offset = comp_start; } else if (type==GF_ISOM_BOX_TYPE_SIDX) { ((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } else if (type==GF_ISOM_BOX_TYPE_SSIX) { ((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } newBox->internal_flags = GF_ISOM_BOX_COMPRESSED; } if (e && (e != GF_ISOM_INCOMPLETE_FILE)) { gf_isom_box_del(newBox); *outBox = NULL; if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e))); } return e; } if (end-start > size) { if (!skip_logs) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) )); } gf_bs_seek(bs, start+size); } else if (end-start < size) { u32 to_skip = (u32) (size-(end-start)); if (!skip_logs) { if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip)); unused_bytes += to_skip; } } gf_bs_skip_bytes(bs, to_skip); } *outBox = newBox; return e; }"
"int mutt_seqset_iterator_next (SEQSET_ITERATOR *iter, unsigned int *next) { char *range_sep; if (!iter || !next) return -1; if (iter->in_range) { if ((iter->down && iter->range_cur == (iter->range_end - 1)) || (!iter->down && iter->range_cur == (iter->range_end + 1))) iter->in_range = 0; } if (!iter->in_range) { iter->substr_cur = iter->substr_end; if (iter->substr_cur == iter->eostr) return 1; while (!*(iter->substr_cur)) iter->substr_cur++; iter->substr_end = strchr (iter->substr_cur, ','); if (!iter->substr_end) iter->substr_end = iter->eostr; else *(iter->substr_end) = '\0'; range_sep = strchr (iter->substr_cur, ':'); if (range_sep) *range_sep++ = '\0'; if (mutt_atoui (iter->substr_cur, &iter->range_cur)) return -1; if (range_sep) { if (mutt_atoui (range_sep, &iter->range_end)) return -1; } else iter->range_end = iter->range_cur; iter->down = (iter->range_end < iter->range_cur); iter->in_range = 1; } *next = iter->range_cur; if (iter->down) iter->range_cur--; else iter->range_cur++; return 0; }"
"static SQInteger thread_call(HSQUIRRELVM v) { SQObjectPtr o = stack_get(v,1); if(sq_type(o) == OT_THREAD) { SQInteger nparams = sq_gettop(v); _thread(o)->Push(_thread(o)->_roottable); for(SQInteger i = 2; i<(nparams+1); i++) sq_move(_thread(o),v,i); if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) { sq_move(v,_thread(o),-1); sq_pop(_thread(o),1); return 1; } v->_lasterror = _thread(o)->_lasterror; return SQ_ERROR; } return sq_throwerror(v,_SC(""wrong parameter"")); }"
"static gboolean gvs_tuple_is_normal (GVariantSerialised value) { guint offset_size; gsize offset_ptr; gsize length; gsize offset; gsize i; if G_UNLIKELY (value.data == NULL && value.size != 0) return FALSE; offset_size = gvs_get_offset_size (value.size); length = g_variant_type_info_n_members (value.type_info); offset_ptr = value.size; offset = 0; for (i = 0; i < length; i++) { const GVariantMemberInfo *member_info; GVariantSerialised child = { 0, }; gsize fixed_size; guint alignment; gsize end; member_info = g_variant_type_info_member_info (value.type_info, i); child.type_info = member_info->type_info; child.depth = value.depth + 1; g_variant_type_info_query (child.type_info, &alignment, &fixed_size); while (offset & alignment) { if (offset > value.size || value.data[offset] != '\0') return FALSE; offset++; } child.data = value.data + offset; switch (member_info->ending_type) { case G_VARIANT_MEMBER_ENDING_FIXED: end = offset + fixed_size; break; case G_VARIANT_MEMBER_ENDING_LAST: end = offset_ptr; break; case G_VARIANT_MEMBER_ENDING_OFFSET: if (offset_ptr < offset_size) return FALSE; offset_ptr -= offset_size; if (offset_ptr < offset) return FALSE; end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size); break; default: g_assert_not_reached (); } if (end < offset || end > offset_ptr) return FALSE; child.size = end - offset; if (child.size == 0) child.data = NULL; if (!g_variant_serialised_is_normal (child)) return FALSE; offset = end; } value.ordered_offsets_up_to = G_MAXSIZE; value.checked_offsets_up_to = G_MAXSIZE; { gsize fixed_size; guint alignment; g_variant_type_info_query (value.type_info, &alignment, &fixed_size); if (fixed_size) { g_assert (fixed_size == value.size); g_assert (offset_ptr == value.size); if (i == 0) { if (value.data[offset++] != '\0') return FALSE; } else { while (offset & alignment) if (value.data[offset++] != '\0') return FALSE; } g_assert (offset == value.size); } } return offset_ptr == offset; }"
"int read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id, uint32_t offset, uint32_t length, uint8_t *frubuf) { static uint32_t fru_data_rqst_size = 20; uint32_t off = offset, tmp, finish; struct ipmi_rs * rsp; struct ipmi_rq req; uint8_t msg_data[4]; if (offset > fru->size) { lprintf(LOG_ERR, ""Read FRU Area offset incorrect: %d > %d"", offset, fru->size); return -1; } finish = offset + length; if (finish > fru->size) { finish = fru->size; lprintf(LOG_NOTICE, ""Read FRU Area length %d too large, "" ""Adjusting to %d"", offset + length, finish - offset); } memset(&req, 0, sizeof(req)); req.msg.netfn = IPMI_NETFN_STORAGE; req.msg.cmd = GET_FRU_DATA; req.msg.data = msg_data; req.msg.data_len = 4; #ifdef LIMIT_ALL_REQUEST_SIZE if (fru_data_rqst_size > 16) #else if (fru->access && fru_data_rqst_size > 16) #endif fru_data_rqst_size = 16; do { tmp = fru->access ? off >> 1 : off; msg_data[0] = id; msg_data[1] = (uint8_t)(tmp & 0xff); msg_data[2] = (uint8_t)(tmp >> 8); tmp = finish - off; if (tmp > fru_data_rqst_size) msg_data[3] = (uint8_t)fru_data_rqst_size; else msg_data[3] = (uint8_t)tmp; rsp = intf->sendrecv(intf, &req); if (!rsp) { lprintf(LOG_NOTICE, ""FRU Read failed""); break; } if (rsp->ccode) { if (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) { lprintf(LOG_INFO, ""Retrying FRU read with request size %d"", fru_data_rqst_size); continue; } lprintf(LOG_NOTICE, ""FRU Read failed: %s"", val2str(rsp->ccode, completion_code_vals)); break; } tmp = fru->access ? rsp->data[0] << 1 : rsp->data[0]; memcpy((frubuf + off)-offset, rsp->data + 1, tmp); off += tmp; if (tmp == 0 && off < finish) return 0; } while (off < finish); if (off < finish) return -1; return 0; }"
"static int dissect_bencoded_list(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char *label  ) { proto_item *ti; proto_tree *sub_tree; guint       one_byte; const char *result; ti = proto_tree_add_none_format( tree, hf_bencoded_list, tvb, offset, 0, ""%s: list..."", label ); sub_tree = proto_item_add_subtree( ti, ett_bencoded_list); offset += 1; while( (one_byte=tvb_get_guint8(tvb,offset)) != 'e' ) { switch( one_byte ) { case 'i': offset = dissect_bencoded_int( tvb, pinfo, sub_tree, offset, &result, ""Integer"" ); break; case 'l': offset = dissect_bencoded_list( tvb, pinfo, sub_tree, offset, ""Sub-list"" ); break; case 'd': offset = dissect_bencoded_dict( tvb, pinfo, sub_tree, offset, ""Sub-dict"" ); break; default: offset = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &result, FALSE, ""String"" ); if (offset == 0) { proto_tree_add_expert(sub_tree, pinfo, &ei_int_string, tvb, offset, -1); return 0; } break; } } proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA); offset += 1; return offset; }"
"static CallResult<HermesValue> getCodeBlockFileName( Runtime &runtime, const CodeBlock *codeBlock, OptValue<hbc::DebugSourceLocation> location) { RuntimeModule *runtimeModule = codeBlock->getRuntimeModule(); if (location) { auto debugInfo = runtimeModule->getBytecode()->getDebugInfo(); return StringPrimitive::createEfficient( runtime, debugInfo->getFilenameByID(location->filenameId)); } else { llvh::StringRef sourceURL = runtimeModule->getSourceURL(); if (!sourceURL.empty()) { return StringPrimitive::createEfficient(runtime, sourceURL); } } return HermesValue::encodeUndefinedValue(); }"
"Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index, const bool validate_indices, sparse::SparseTensor* tensor) { TensorShape shape; TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape( ctx->input(base_index + 2).vec<int64_t>(), &shape)); CheckRankAtLeast2(ctx, shape); std::vector<int64_t> order(shape.dims()); std::iota(order.begin(), order.end(), 0); Status status = sparse::SparseTensor::Create( ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor); if (!validate_indices || !status.ok()) return status; return tensor->IndicesValid(); }"
"static gboolean compare_by_guid(gconstpointer a, gconstpointer b) { const endpoint_guid * guid_a = (const endpoint_guid *) a; const endpoint_guid * guid_b = (const endpoint_guid *) b; return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0; }"
"static int dpu_crtc_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state) { struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc); struct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc); struct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc_state); struct plane_state *pstates; const struct drm_plane_state *pstate; struct drm_plane *plane; struct drm_display_mode *mode; int cnt = 0, rc = 0, mixer_width = 0, i, z_pos; struct dpu_multirect_plane_states multirect_plane[DPU_STAGE_MAX * 2]; int multirect_count = 0; const struct drm_plane_state *pipe_staged[SSPP_MAX]; int left_zpos_cnt = 0, right_zpos_cnt = 0; struct drm_rect crtc_rect = { 0 }; bool needs_dirtyfb = dpu_crtc_needs_dirtyfb(crtc_state); pstates = kzalloc(sizeof(*pstates) * DPU_STAGE_MAX * 4, GFP_KERNEL); if (!crtc_state->enable || !crtc_state->active) { DRM_DEBUG_ATOMIC(""crtc%d -> enable %d, active %d, skip atomic_check\n"", crtc->base.id, crtc_state->enable, crtc_state->active); memset(&cstate->new_perf, 0, sizeof(cstate->new_perf)); goto end; } mode = &crtc_state->adjusted_mode; DRM_DEBUG_ATOMIC(""%s: check\n"", dpu_crtc->name); if (crtc_state->active_changed) crtc_state->mode_changed = true; memset(pipe_staged, 0, sizeof(pipe_staged)); if (cstate->num_mixers) { mixer_width = mode->hdisplay / cstate->num_mixers; _dpu_crtc_setup_lm_bounds(crtc, crtc_state); } crtc_rect.x2 = mode->hdisplay; crtc_rect.y2 = mode->vdisplay; drm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) { struct dpu_plane_state *dpu_pstate = to_dpu_plane_state(pstate); struct drm_rect dst, clip = crtc_rect; if (IS_ERR_OR_NULL(pstate)) { rc = PTR_ERR(pstate); DPU_ERROR(""%s: failed to get plane%d state, %d\n"", dpu_crtc->name, plane->base.id, rc); goto end; } if (cnt >= DPU_STAGE_MAX * 4) continue; if (!pstate->visible) continue; pstates[cnt].dpu_pstate = dpu_pstate; pstates[cnt].drm_pstate = pstate; pstates[cnt].stage = pstate->normalized_zpos; pstates[cnt].pipe_id = dpu_plane_pipe(plane); dpu_pstate->needs_dirtyfb = needs_dirtyfb; if (pipe_staged[pstates[cnt].pipe_id]) { multirect_plane[multirect_count].r0 = pipe_staged[pstates[cnt].pipe_id]; multirect_plane[multirect_count].r1 = pstate; multirect_count++; pipe_staged[pstates[cnt].pipe_id] = NULL; } else { pipe_staged[pstates[cnt].pipe_id] = pstate; } cnt++; dst = drm_plane_state_dest(pstate); if (!drm_rect_intersect(&clip, &dst)) { DPU_ERROR(""invalid vertical/horizontal destination\n""); DPU_ERROR(""display: "" DRM_RECT_FMT "" plane: "" DRM_RECT_FMT ""\n"", DRM_RECT_ARG(&crtc_rect), DRM_RECT_ARG(&dst)); rc = -E2BIG; goto end; } } for (i = 1; i < SSPP_MAX; i++) { if (pipe_staged[i]) dpu_plane_clear_multirect(pipe_staged[i]); } z_pos = -1; for (i = 0; i < cnt; i++) { if (pstates[i].stage != z_pos) { left_zpos_cnt = 0; right_zpos_cnt = 0; z_pos = pstates[i].stage; } if (z_pos >= DPU_STAGE_MAX - DPU_STAGE_0) { DPU_ERROR(""> %d plane stages assigned\n"", DPU_STAGE_MAX - DPU_STAGE_0); rc = -EINVAL; goto end; } else if (pstates[i].drm_pstate->crtc_x < mixer_width) { if (left_zpos_cnt == 2) { DPU_ERROR(""> 2 planes @ stage %d on left\n"", z_pos); rc = -EINVAL; goto end; } left_zpos_cnt++; } else { if (right_zpos_cnt == 2) { DPU_ERROR(""> 2 planes @ stage %d on right\n"", z_pos); rc = -EINVAL; goto end; } right_zpos_cnt++; } pstates[i].dpu_pstate->stage = z_pos + DPU_STAGE_0; DRM_DEBUG_ATOMIC(""%s: zpos %d\n"", dpu_crtc->name, z_pos); } for (i = 0; i < multirect_count; i++) { if (dpu_plane_validate_multirect_v2(&multirect_plane[i])) { DPU_ERROR( ""multirect validation failed for planes (%d - %d)\n"", multirect_plane[i].r0->plane->base.id, multirect_plane[i].r1->plane->base.id); rc = -EINVAL; goto end; } } atomic_inc(&_dpu_crtc_get_kms(crtc)->bandwidth_ref); rc = dpu_core_perf_crtc_check(crtc, crtc_state); if (rc) { DPU_ERROR(""crtc%d failed performance check %d\n"", crtc->base.id, rc); goto end; } for (i = 1; i < cnt; i++) { struct plane_state *prv_pstate, *cur_pstate; struct drm_rect left_rect, right_rect; int32_t left_pid, right_pid; int32_t stage; prv_pstate = &pstates[i - 1]; cur_pstate = &pstates[i]; if (prv_pstate->stage != cur_pstate->stage) continue; stage = cur_pstate->stage; left_pid = prv_pstate->dpu_pstate->base.plane->base.id; left_rect = drm_plane_state_dest(prv_pstate->drm_pstate); right_pid = cur_pstate->dpu_pstate->base.plane->base.id; right_rect = drm_plane_state_dest(cur_pstate->drm_pstate); if (right_rect.x1 < left_rect.x1) { swap(left_pid, right_pid); swap(left_rect, right_rect); } if (right_pid < left_pid) { DPU_ERROR( ""invalid src split cfg. priority mismatch. stage: %d left: %d right: %d\n"", stage, left_pid, right_pid); rc = -EINVAL; goto end; } else if (right_rect.x1 != drm_rect_width(&left_rect)) { DPU_ERROR(""non-contiguous coordinates for src split. "" ""stage: %d left: "" DRM_RECT_FMT "" right: "" DRM_RECT_FMT ""\n"", stage, DRM_RECT_ARG(&left_rect), DRM_RECT_ARG(&right_rect)); rc = -EINVAL; goto end; } else if (left_rect.y1 != right_rect.y1 || drm_rect_height(&left_rect) != drm_rect_height(&right_rect)) { DPU_ERROR(""source split at stage: %d. invalid "" ""yoff/height: left: "" DRM_RECT_FMT "" right: "" DRM_RECT_FMT ""\n"", stage, DRM_RECT_ARG(&left_rect), DRM_RECT_ARG(&right_rect)); rc = -EINVAL; goto end; } } end: kfree(pstates); return rc; }"
"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only, ept_entry_t **table, unsigned long *gfn_remainder, int next_level) { ept_entry_t *ept_entry, *next = NULL, e; u32 shift, index; shift = next_level * EPT_TABLE_ORDER; index = *gfn_remainder >> shift; ASSERT(index < EPT_PAGETABLE_ENTRIES); ept_entry = (*table) + index; e = atomic_read_ept_entry(ept_entry); if ( !is_epte_present(&e) ) { if ( e.sa_p2mt == p2m_populate_on_demand ) return GUEST_TABLE_POD_PAGE; if ( read_only ) return GUEST_TABLE_MAP_FAILED; next = ept_set_middle_entry(p2m, ept_entry); if ( !next ) return GUEST_TABLE_MAP_FAILED; } else if ( is_epte_superpage(&e) ) return GUEST_TABLE_SUPER_PAGE; unmap_domain_page(*table); *table = next ?: map_domain_page(_mfn(e.mfn)); *gfn_remainder &= (1UL << shift) - 1; return GUEST_TABLE_NORMAL_PAGE; }"
"void Converter::cnvXmpGPSVersion(const char* from, const char* to) { Exiv2::XmpData::iterator pos = xmpData_->findKey(XmpKey(from)); if (pos == xmpData_->end()) return; if (!prepareExifTarget(to)) return; std::string value = pos->toString(); if (!pos->value().ok()) { #ifndef SUPPRESS_WARNINGS EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n""; #endif return; } for (unsigned i = 0; i < value.length(); ++i) { if (value[i] == '.') value[i] = ' '; } (*exifData_)[to] = value; if (erase_) xmpData_->erase(pos); }"
"static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte, unsigned long next_mfn, unsigned int next_level, bool iw, bool ir) { unsigned int flush_flags = IOMMU_FLUSHF_added; if ( pte->pr && (pte->mfn != next_mfn || pte->iw != iw || pte->ir != ir || pte->next_level != next_level) ) flush_flags |= IOMMU_FLUSHF_modified; pte->fc = !next_level; pte->mfn = next_mfn; pte->iw = iw; pte->ir = ir; pte->next_level = next_level; pte->pr = 1; return flush_flags; }"
"inline typename V::VectorType FBUnserializer<V>::unserializeVector() { p_ += CODE_SIZE; typename V::VectorType ret = V::createVector(); size_t code = nextCode(); while (code != FB_SERIALIZE_STOP) { V::vectorAppend(ret, unserializeThing()); code = nextCode(); } p_ += CODE_SIZE; return ret; }"
"void SingleDuel::UpdateDeck(DuelPlayer* dp, void* pdata, unsigned int len) { if(dp->type > 1 || ready[dp->type]) return; char* deckbuf = (char*)pdata; int mainc = BufferIO::ReadInt32(deckbuf); int sidec = BufferIO::ReadInt32(deckbuf); if((unsigned)mainc + (unsigned)sidec > (len - 8) / 4) { STOC_ErrorMsg scem; scem.msg = ERRMSG_DECKERROR; scem.code = 0; NetServer::SendPacketToPlayer(dp, STOC_ERROR_MSG, scem); return; } if(duel_count == 0) { deck_error[dp->type] = deckManager.LoadDeck(pdeck[dp->type], (int*)deckbuf, mainc, sidec); } else { if(deckManager.LoadSide(pdeck[dp->type], (int*)deckbuf, mainc, sidec)) { ready[dp->type] = true; NetServer::SendPacketToPlayer(dp, STOC_DUEL_START); if(ready[0] && ready[1]) { NetServer::SendPacketToPlayer(players[tp_player], STOC_SELECT_TP); players[1 - tp_player]->state = 0xff; players[tp_player]->state = CTOS_TP_RESULT; duel_stage = DUEL_STAGE_FIRSTGO; } } else { STOC_ErrorMsg scem; scem.msg = ERRMSG_SIDEERROR; scem.code = 0; NetServer::SendPacketToPlayer(dp, STOC_ERROR_MSG, scem); } } }"
"set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) { lock_guard<std::recursive_mutex> guard(globalMutex); string pipePath = endpoint.name(); if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) { throw runtime_error(""Tried to listen twice on the same path""); } sockaddr_un local; int fd = socket(AF_UNIX, SOCK_STREAM, 0); FATAL_FAIL(fd); initServerSocket(fd); local.sun_family = AF_UNIX;  strcpy(local.sun_path, pipePath.c_str()); unlink(local.sun_path); FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un))); ::listen(fd, 5); #ifndef WIN32 FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR)); #endif pipeServerSockets[pipePath] = set<int>({fd}); return pipeServerSockets[pipePath]; }"
"static void ecma_op_internal_buffer_append (ecma_collection_t *container_p,  ecma_value_t key_arg,  ecma_value_t value_arg,  lit_magic_string_id_t lit_id)  { JERRY_ASSERT (container_p != NULL); ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg)); if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL) { ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg)); } ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1); }"
"bool JpegEncoder::Encode(const struct heif_image_handle* handle, const struct heif_image* image, const std::string& filename) { FILE* fp = fopen(filename.c_str(), ""wb""); if (!fp) { fprintf(stderr, ""Can't open %s: %s\n"", filename.c_str(), strerror(errno)); return false; } struct jpeg_compress_struct cinfo; struct ErrorHandler jerr; cinfo.err = jpeg_std_error(reinterpret_cast<struct jpeg_error_mgr*>(&jerr)); jerr.pub.error_exit = &JpegEncoder::OnJpegError; if (setjmp(jerr.setjmp_buffer)) { cinfo.err->output_message(reinterpret_cast<j_common_ptr>(&cinfo)); jpeg_destroy_compress(&cinfo); fclose(fp); return false; } jpeg_create_compress(&cinfo); jpeg_stdio_dest(&cinfo, fp); cinfo.image_width = heif_image_get_width(image, heif_channel_Y); cinfo.image_height = heif_image_get_height(image, heif_channel_Y); cinfo.input_components = 3; cinfo.in_color_space = JCS_YCbCr; jpeg_set_defaults(&cinfo); static const boolean kForceBaseline = TRUE; jpeg_set_quality(&cinfo, quality_, kForceBaseline); static const boolean kWriteAllTables = TRUE; jpeg_start_compress(&cinfo, kWriteAllTables); size_t exifsize = 0; uint8_t* exifdata = GetExifMetaData(handle, &exifsize); if (exifdata) { if (exifsize > 4) { static const uint8_t kExifMarker = JPEG_APP0 + 1; uint32_t skip = (exifdata[0]<<24) | (exifdata[1]<<16) | (exifdata[2]<<8) | exifdata[3]; skip += 4; uint8_t* ptr = exifdata + skip; size_t size = exifsize - skip; modify_exif_orientation_tag_if_it_exists(ptr, (int)size, 1); if (size>0x1000000) { size = 0x1000000; } std::vector<uint8_t> jpegExifMarkerData(6+size); memcpy(jpegExifMarkerData.data()+6, ptr, size); jpegExifMarkerData[0]='E'; jpegExifMarkerData[1]='x'; jpegExifMarkerData[2]='i'; jpegExifMarkerData[3]='f'; jpegExifMarkerData[4]=0; jpegExifMarkerData[5]=0; ptr = jpegExifMarkerData.data(); size = jpegExifMarkerData.size(); while (size > MAX_BYTES_IN_MARKER) { jpeg_write_marker(&cinfo, kExifMarker, ptr, static_cast<unsigned int>(MAX_BYTES_IN_MARKER)); ptr += MAX_BYTES_IN_MARKER; size -= MAX_BYTES_IN_MARKER; } jpeg_write_marker(&cinfo, kExifMarker, ptr, static_cast<unsigned int>(size)); } free(exifdata); } auto xmp = get_xmp_metadata(handle); if (xmp.size() > 65502) { fprintf(stderr, ""XMP data too large, ExtendedXMP is not supported yet.\n""); } else if (!xmp.empty()) { std::vector<uint8_t> xmpWithId; xmpWithId.resize(xmp.size() + strlen(JPEG_XMP_MARKER_ID)+1); strcpy((char*)xmpWithId.data(), JPEG_XMP_MARKER_ID); memcpy(xmpWithId.data() + strlen(JPEG_XMP_MARKER_ID) + 1, xmp.data(), xmp.size()); jpeg_write_marker(&cinfo, JPEG_XMP_MARKER, xmpWithId.data(), static_cast<unsigned int>(xmpWithId.size())); } size_t profile_size = heif_image_handle_get_raw_color_profile_size(handle); if (profile_size > 0) { uint8_t* profile_data = static_cast<uint8_t*>(malloc(profile_size)); heif_image_handle_get_raw_color_profile(handle, profile_data); jpeg_write_icc_profile(&cinfo, profile_data, (unsigned int) profile_size); free(profile_data); } if (heif_image_get_bits_per_pixel(image, heif_channel_Y) != 8) { fprintf(stderr, ""JPEG writer cannot handle image with >8 bpp.\n""); return false; } int stride_y; const uint8_t* row_y = heif_image_get_plane_readonly(image, heif_channel_Y, &stride_y); int stride_u; const uint8_t* row_u = heif_image_get_plane_readonly(image, heif_channel_Cb, &stride_u); int stride_v; const uint8_t* row_v = heif_image_get_plane_readonly(image, heif_channel_Cr, &stride_v); JSAMPARRAY buffer = cinfo.mem->alloc_sarray( reinterpret_cast<j_common_ptr>(&cinfo), JPOOL_IMAGE, cinfo.image_width * cinfo.input_components, 1); JSAMPROW row[1] = {buffer[0]}; while (cinfo.next_scanline < cinfo.image_height) { size_t offset_y = cinfo.next_scanline * stride_y; const uint8_t* start_y = &row_y[offset_y]; size_t offset_u = (cinfo.next_scanline / 2) * stride_u; const uint8_t* start_u = &row_u[offset_u]; size_t offset_v = (cinfo.next_scanline / 2) * stride_v; const uint8_t* start_v = &row_v[offset_v]; JOCTET* bufp = buffer[0]; for (JDIMENSION x = 0; x < cinfo.image_width; ++x) { *bufp++ = start_y[x]; *bufp++ = start_u[x / 2]; *bufp++ = start_v[x / 2]; } jpeg_write_scanlines(&cinfo, row, 1); } jpeg_finish_compress(&cinfo); fclose(fp); jpeg_destroy_compress(&cinfo); return true; }"
"Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this) { Jsi_Func *fstatic = func->d.obj->d.fobj->func; jsi_OpCode *oldops = interp->curIp; if (fstatic->opcodes) interp->curIp = fstatic->opcodes->codes; Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this); interp->curIp = oldops; if (Jsi_InterpGone(interp)) return JSI_ERROR; return rc; }"
"void MultiPartOutputFile::Data::do_header_sanity_checks(bool overrideSharedAttributes) { size_t parts = _headers.size(); if (parts == 0)  throw IEX_NAMESPACE::ArgExc (""Empty header list.""); bool isMultiPart = (parts > 1);  _headers[0].sanityCheck (_headers[0].hasTileDescription(), isMultiPart); if (isMultiPart) { _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true)); for (size_t i = 1; i < parts; i++) { if (_headers[i].hasType() == false) throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type""); _headers[i].setChunkCount(getChunkOffsetTableSize(_headers[i],true)); _headers[i].sanityCheck (_headers[i].hasTileDescription(), isMultiPart); if (overrideSharedAttributes) overrideSharedAttributesValues(_headers[0],_headers[i]); else { std::vector<std::string> conflictingAttributes; bool valid =checkSharedAttributesValues (_headers[0], _headers[i],  conflictingAttributes); if (valid) { string excMsg(""Conflicting attributes found for header :: ""); excMsg += _headers[i].name(); for (size_t i=0; i<conflictingAttributes.size(); i++) excMsg += "" '"" + conflictingAttributes[i] + ""' ""; THROW (IEX_NAMESPACE::ArgExc, excMsg); } } } headerNameUniquenessCheck(_headers); }else{ if (_headers[0].hasType() && isImage(_headers[0].type()) == false) { _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true)); } } }"
"GF_EXPORT GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; if (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) { u32 ref_track; GF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track); if (e == GF_OK) { trackNumber = ref_track; } } trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->hevc_config) return NULL; return HEVC_DuplicateConfig(entry->hevc_config->config); }"
"static int vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, struct vhu_msg_context *ctx) { uint32_t vring_idx; switch (ctx->msg.request.master) { case VHOST_USER_SET_VRING_KICK: case VHOST_USER_SET_VRING_CALL: case VHOST_USER_SET_VRING_ERR: vring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK; break; case VHOST_USER_SET_VRING_NUM: case VHOST_USER_SET_VRING_BASE: case VHOST_USER_GET_VRING_BASE: case VHOST_USER_SET_VRING_ENABLE: vring_idx = ctx->msg.payload.state.index; break; case VHOST_USER_SET_VRING_ADDR: vring_idx = ctx->msg.payload.addr.index; break; default: return 0; } if (vring_idx >= VHOST_MAX_VRING) { VHOST_LOG_CONFIG(ERR, ""(%s) invalid vring index: %u\n"", dev->ifname, vring_idx); return -1; } if (dev->virtqueue[vring_idx]) return 0; return alloc_vring_queue(dev, vring_idx); }"
"static int dissect_kafka_string_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_string_offset, int *p_string_length) { gint64 val; guint len; proto_item *pi; len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG); if (len == 0) { pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_varint); len = 5; val = 0; } else if (val > 0) { proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_UTF_8); } else if (val == 0) { proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<EMPTY>""); } else if (val == -1) { proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<NULL>""); val = 0; } else { pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_string_length); val = 0; } if (p_string_offset != NULL) { *p_string_offset = offset+len; } if (p_string_length != NULL) { *p_string_length = (gint)val; } return offset+len+(gint)val; }"
"int table_regex_match(const char *string, const char *pattern) { regex_t preg; intcflags = REG_EXTENDED|REG_NOSUB; if (strncmp(pattern, ""(?i)"", 4) == 0) { cflags |= REG_ICASE; pattern += 4; } if (regcomp(&preg, pattern, cflags) != 0) return (0); if (regexec(&preg, string, 0, NULL, 0) != 0) return (0); return (1); }"
"static int sudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx, unsigned int *validated, struct cmnd_info *info, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, struct cmndspec **matching_cs, struct defaults_list **defs) { struct cmndspec *cs; struct privilege *priv; struct userspec *us; struct member *matching_user; debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER); init_cmnd_info(ctx, info); TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) { int user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users); if (user_match != ALLOW) { if (callback != NULL && user_match != UNSPEC) { callback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data); } continue; } CLR(*validated, FLAG_NO_USER); TAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) { int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw, &priv->hostlist); if (host_match == ALLOW) { CLR(*validated, FLAG_NO_HOST); } else { if (callback != NULL) { callback(nss->parse_tree, us, user_match, priv, host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data); } continue; } TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) { int cmnd_match = UNSPEC; int date_match = UNSPEC; int runas_match = UNSPEC; if (cs->notbefore != UNSPEC) { date_match = now < cs->notbefore ? DENY : ALLOW; } if (cs->notafter != UNSPEC) { date_match = now > cs->notafter ? DENY : ALLOW; } if (date_match != DENY) { matching_user = NULL; runas_match = runaslist_matches(nss->parse_tree, cs->runasuserlist, cs->runasgrouplist, &matching_user, NULL); if (runas_match == ALLOW) { cmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd, cs->runchroot, info); } } if (callback != NULL) { callback(nss->parse_tree, us, user_match, priv, host_match, cs, date_match, runas_match, cmnd_match, cb_data); } if (cmnd_match != UNSPEC) { if (matching_user && matching_user->type == MYSELF) { sudo_pw_delref(ctx->runas.pw); sudo_pw_addref(ctx->user.pw); ctx->runas.pw = ctx->user.pw; } *matching_cs = cs; *defs = &priv->defaults; sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, ""userspec matched @ %s:%d:%d: %s"", us->file ? us->file : ""???"", us->line, us->column, cmnd_match ? ""allowed"" : ""denied""); debug_return_int(cmnd_match); } free(info->cmnd_path); init_cmnd_info(ctx, info); } } } debug_return_int(UNSPEC); }"
"int DCTStream::getChars(int nChars, unsigned char *buffer) { for (int i = 0; i < nChars;) { if (current == limit) { if (!readLine()) return i; } int left = limit - current; if (nChars < left) left = nChars; memcpy(buffer + i, current, left); current += left; i += left; } return nChars; }"
"static char * expand_dynamic_string_token (struct link_map *l, const char *s) { size_t cnt; size_t total; char *result; cnt = DL_DST_COUNT (s, 1); if (cnt == 0) return local_strdup (s); total = DL_DST_REQUIRED (l, s, strlen (s), cnt); result = (char *) malloc (total + 1); if (result == NULL) return NULL; return DL_DST_SUBSTITUTE (l, s, result, 1); }"
"static dict *dictCreate(dictType *type, void *privDataPtr) { dict *ht = malloc(sizeof(*ht)); _dictInit(ht,type,privDataPtr); return ht; }"
"static void io_msg_tw_complete(struct callback_head *head) { struct io_msg *msg = container_of(head, struct io_msg, tw); struct io_kiocb *req = cmd_to_io_kiocb(msg); struct io_ring_ctx *target_ctx = req->file->private_data; int ret = 0; if (current->flags & PF_EXITING) ret = -EOWNERDEAD; else if (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0)) ret = -EOVERFLOW; if (ret < 0) req_set_fail(req); io_req_queue_tw_complete(req, ret); }"
"static struct lys_node * read_yin_notif(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options, struct unres_schema *unres) { struct ly_ctx *ctx = module->ctx; struct lyxml_elem *sub, *next, root; struct lys_node *node = NULL; struct lys_node *retval; struct lys_node_notif *notif; int r; int c_tpdf = 0, c_ftrs = 0, c_must = 0, c_ext = 0; void *reallocated; if (parent && (module->version < 2)) { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, parent, ""notification""); return NULL; } memset(&root, 0, sizeof root); notif = calloc(1, sizeof *notif); LY_CHECK_ERR_RETURN(!notif, LOGMEM(ctx), NULL); notif->nodetype = LYS_NOTIF; notif->prev = (struct lys_node *)notif; retval = (struct lys_node *)notif; if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin, OPT_IDENT | OPT_MODULE, unres)) { goto error; } LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name); if (lys_node_addchild(parent, lys_main_module(module), retval, options)) { goto error; } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""notification"", error); c_ext++; continue; } else if (!strcmp(sub->name, ""container"") || !strcmp(sub->name, ""leaf-list"") || !strcmp(sub->name, ""leaf"") || !strcmp(sub->name, ""list"") || !strcmp(sub->name, ""choice"") || !strcmp(sub->name, ""uses"") || !strcmp(sub->name, ""grouping"") || !strcmp(sub->name, ""anyxml"") || !strcmp(sub->name, ""anydata"")) { lyxml_unlink_elem(ctx, sub, 2); lyxml_add_child(ctx, &root, sub); } else if (!strcmp(sub->name, ""typedef"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, notif->tpdf_size, ""typedefs"", ""notification"", error); c_tpdf++; } else if (!strcmp(sub->name, ""if-feature"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""notification"", error); c_ftrs++; } else if ((module->version >= 2) && !strcmp(sub->name, ""must"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, notif->must_size, ""musts"", ""notification"", error); c_must++; } else { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name); goto error; } } if (c_tpdf) { notif->tpdf = calloc(c_tpdf, sizeof *notif->tpdf); LY_CHECK_ERR_GOTO(!notif->tpdf, LOGMEM(ctx), error); } if (c_ftrs) { notif->iffeature = calloc(c_ftrs, sizeof *notif->iffeature); LY_CHECK_ERR_GOTO(!notif->iffeature, LOGMEM(ctx), error); } if (c_must) { notif->must = calloc(c_must, sizeof *notif->must); LY_CHECK_ERR_GOTO(!notif->must, LOGMEM(ctx), error); } if (c_ext) { reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext); LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error); retval->ext = reallocated; memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext); } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres); if (r) { goto error; } } else if (!strcmp(sub->name, ""typedef"")) { r = fill_yin_typedef(module, retval, sub, &notif->tpdf[notif->tpdf_size], unres); notif->tpdf_size++; if (r) { goto error; } } else if (!strcmp(sub->name, ""if-feature"")) { r = fill_yin_iffeature(retval, 0, sub, &notif->iffeature[notif->iffeature_size], unres); notif->iffeature_size++; if (r) { goto error; } } else if (!strcmp(sub->name, ""must"")) { r = fill_yin_must(module, sub, &notif->must[notif->must_size], unres); notif->must_size++; if (r) { goto error; } } } lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size); options |= LYS_PARSE_OPT_CFG_IGNORE; LY_TREE_FOR_SAFE(root.child, next, sub) { if (!strcmp(sub->name, ""container"")) { node = read_yin_container(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf-list"")) { node = read_yin_leaflist(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf"")) { node = read_yin_leaf(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""list"")) { node = read_yin_list(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""choice"")) { node = read_yin_choice(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""uses"")) { node = read_yin_uses(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""grouping"")) { node = read_yin_grouping(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""anyxml"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres); } else if (!strcmp(sub->name, ""anydata"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres); } if (!node) { goto error; } lyxml_free(ctx, sub); } if (!(ctx->models.flags & LY_CTX_TRUSTED) && notif->must) { if (options & LYS_PARSE_OPT_INGRP) { if (lyxp_node_check_syntax(retval)) { goto error; } } else { if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) { goto error; } } } return retval; error: lys_node_free(retval, NULL, 0); while (root.child) { lyxml_free(ctx, root.child); } return NULL; }"
"static void hso_free_net_device(struct hso_device *hso_dev, bool bailout) { int i; struct hso_net *hso_net = dev2net(hso_dev); if (!hso_net) return; remove_net_device(hso_net->parent); if (hso_net->net) unregister_netdev(hso_net->net); for (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) { usb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]); kfree(hso_net->mux_bulk_rx_buf_pool[i]); hso_net->mux_bulk_rx_buf_pool[i] = NULL; } usb_free_urb(hso_net->mux_bulk_tx_urb); kfree(hso_net->mux_bulk_tx_buf); hso_net->mux_bulk_tx_buf = NULL; if (hso_net->net && !bailout) free_netdev(hso_net->net); kfree(hso_dev); }"
"void GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::onGoAway( Http::GoAwayErrorCode error_code) { ENVOY_CONN_LOG(debug, ""connection going away health_flags={}"", *client_, HostUtility::healthFlagsToString(*host_)); if (request_encoder_ && error_code == Http::GoAwayErrorCode::NoError) { received_no_error_goaway_ = true; return; } if (request_encoder_) { handleFailure(envoy::data::core::v3::NETWORK); expect_reset_ = true; request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset); } client_->close(); }"
"bool RequestParser::OnHeadersEnd() { bool matched = view_matcher_(request_->method(), request_->url().path(), &stream_); if (!matched) { LOG_WARN(""No view matches the request: %s %s"", request_->method().c_str(), request_->url().path().c_str()); } return matched; }"
"void ZlibDecompressorImpl::decompress(const Buffer::Instance& input_buffer, Buffer::Instance& output_buffer) { for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) { zstream_ptr_->avail_in = input_slice.len_; zstream_ptr_->next_in = static_cast<Bytef*>(input_slice.mem_); while (inflateNext()) { if (zstream_ptr_->avail_out == 0) { updateOutput(output_buffer); } } } updateOutput(output_buffer); }"
"static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e) { char *content = attribute_content; while (*content == ' ') content++; if (strstr(content, ""defer"")) { par->defer = 1; content += 4; } else { content = attribute_content; } while (*content == ' ') content++; if (strstr(content, ""none"")) { par->align = SVG_PRESERVEASPECTRATIO_NONE; content+=4; } else if (strstr(content, ""xMinYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMIN; content+=8; } else if (strstr(content, ""xMidYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN; content+=8; } else if (strstr(content, ""xMaxYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN; content+=8; } else if (strstr(content, ""xMinYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMID; content+=8; } else if (strstr(content, ""xMidYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMID; content+=8; } else if (strstr(content, ""xMaxYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMID; content+=8; } else if (strstr(content, ""xMinYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMAX; content+=8; } else if (strstr(content, ""xMidYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX; content+=8; } else if (strstr(content, ""xMaxYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX; content+=8; } else { *out_e = GF_NON_COMPLIANT_BITSTREAM; } while (*content == ' ') content++; if (*content == 0) return; if (strstr(content, ""meet"")) { par->meetOrSlice = SVG_MEETORSLICE_MEET; } else if (strstr(content, ""slice"")) { par->meetOrSlice = SVG_MEETORSLICE_SLICE; } else { *out_e = GF_NON_COMPLIANT_BITSTREAM; } }"
"Macho_Binary_t** macho_parse(const char *file) { FatBinary* fat = Parser::parse(file).release(); auto** c_macho_binaries = static_cast<Macho_Binary_t**>( malloc((fat->size() + 1) * sizeof(Macho_Binary_t**))); for (size_t i = 0; i < fat->size(); ++i) { Binary* binary = fat->at(i); if (binary != nullptr) { c_macho_binaries[i] = static_cast<Macho_Binary_t*>(malloc(sizeof(Macho_Binary_t))); init_c_binary(c_macho_binaries[i], binary); } } c_macho_binaries[fat->size()] = nullptr; return c_macho_binaries; }"
"apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location, char **javascript, char **javascript_method) { if (oidc_cfg_dir_preserve_post(r) == 0) return FALSE; oidc_debug(r, ""enter""); oidc_cfg *cfg = ap_get_module_config(r->server->module_config, &auth_openidc_module); const char *method = oidc_original_request_method(r, cfg, FALSE); if (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0) return FALSE; apr_table_t *params = apr_table_make(r->pool, 8); if (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) { oidc_error(r, ""something went wrong when reading the POST parameters""); return FALSE; } const apr_array_header_t *arr = apr_table_elts(params); const apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts; int i; char *json = """"; for (i = 0; i < arr->nelts; i++) { json = apr_psprintf(r->pool, ""%s'%s': '%s'%s"", json, oidc_util_escape_string(r, elts[i].key), oidc_util_escape_string(r, elts[i].val), i < arr->nelts - 1 ? "","" : """"); } json = apr_psprintf(r->pool, ""{ %s }"", json); const char *jmethod = ""preserveOnLoad""; const char *jscript = apr_psprintf(r->pool, ""    <script type=\""text/javascript\"">\n"" ""      function %s() {\n"" ""        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\n"" ""        %s"" ""      }\n"" ""    </script>\n"", jmethod, json, location ? apr_psprintf(r->pool, ""window.location='%s';\n"", location) : """"); if (location == NULL) { if (javascript_method) *javascript_method = apr_pstrdup(r->pool, jmethod); if (javascript) *javascript = apr_pstrdup(r->pool, jscript); } else { oidc_util_html_send(r, ""Preserving..."", jscript, jmethod, ""<p>Preserving...</p>"", OK); } return TRUE; }"
"const char *janus_get_codec_from_pt(const char *sdp, int pt) { if(!sdp || pt < 0) return NULL; if(pt == 0) return ""pcmu""; if(pt == 8) return ""pcma""; if(pt == 9) return ""g722""; char rtpmap[50]; g_snprintf(rtpmap, 50, ""a=rtpmap:%d "", pt); const char *line = strstr(sdp, ""m=""); while(line) { char *next = strchr(line, '\n'); if(next) { *next = '\0'; if(strstr(line, rtpmap)) { char name[100]; if(sscanf(line, ""a=rtpmap:%d %s"", &pt, name) == 2) { *next = '\n'; if(strstr(name, ""vp8"") || strstr(name, ""VP8"")) return ""vp8""; if(strstr(name, ""vp9"") || strstr(name, ""VP9"")) return ""vp9""; if(strstr(name, ""h264"") || strstr(name, ""H264"")) return ""h264""; if(strstr(name, ""av1"") || strstr(name, ""AV1"")) return ""av1""; if(strstr(name, ""h265"") || strstr(name, ""H265"")) return ""h265""; if(strstr(name, ""opus"") || strstr(name, ""OPUS"")) return ""opus""; if(strstr(name, ""pcmu"") || strstr(name, ""PCMU"")) return ""pcmu""; if(strstr(name, ""pcma"") || strstr(name, ""PCMA"")) return ""pcma""; if(strstr(name, ""g722"") || strstr(name, ""G722"")) return ""g722""; if(strstr(name, ""isac/16"") || strstr(name, ""ISAC/16"")) return ""isac16""; if(strstr(name, ""isac/32"") || strstr(name, ""ISAC/32"")) return ""isac32""; JANUS_LOG(LOG_ERR, ""Unsupported codec '%s'\n"", name); return NULL; } } *next = '\n'; } line = next ? (next+1) : NULL; } return NULL; }"
"static int fuse_unlink(struct inode *dir, struct dentry *entry) { int err; struct fuse_mount *fm = get_fuse_mount(dir); FUSE_ARGS(args); args.opcode = FUSE_UNLINK; args.nodeid = get_node_id(dir); args.in_numargs = 1; args.in_args[0].size = entry->d_name.len + 1; args.in_args[0].value = entry->d_name.name; err = fuse_simple_request(fm, &args); if (!err) { struct inode *inode = d_inode(entry); struct fuse_inode *fi = get_fuse_inode(inode); spin_lock(&fi->lock); fi->attr_version = atomic64_inc_return(&fm->fc->attr_version); if (inode->i_nlink > 0) drop_nlink(inode); spin_unlock(&fi->lock); fuse_invalidate_attr(inode); fuse_dir_changed(dir); fuse_invalidate_entry_cache(entry); fuse_update_ctime(inode); } else if (err == -EINTR) fuse_invalidate_entry(entry); return err; }"
"static void child_setup_func (gpointer user_data) { ChildSetupData *data = (ChildSetupData *) user_data; FdMapEntry *fd_map = data->fd_map; sigset_t set; int i; flatpak_close_fds_workaround (3); if (data->instance_id_fd != -1) drop_cloexec (data->instance_id_fd); sigemptyset (&set); if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1) { g_warning (""Failed to unblock signals when starting child""); return; } for (i = 1; i < NSIG; i++) { if (i != SIGSTOP && i != SIGKILL) signal (i, SIG_DFL); } for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].from != fd_map[i].to) { dup2 (fd_map[i].from, fd_map[i].to); close (fd_map[i].from); } } for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].to != fd_map[i].final) { dup2 (fd_map[i].to, fd_map[i].final); close (fd_map[i].to); } drop_cloexec (fd_map[i].final); } setsid (); setpgid (0, 0); if (data->set_tty) { for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].from == data->tty) { if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1) g_debug (""ioctl(%d, TIOCSCTTY, 0) failed: %s"", fd_map[i].final, strerror (errno)); break; } } } }"
"static void gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) { int idx; int type = nint(tree->car); switch (type) { case NODE_GVAR: case NODE_ARG: case NODE_LVAR: case NODE_IVAR: case NODE_CVAR: case NODE_CONST: case NODE_NIL: case NODE_MASGN: if (rhs) { codegen(s, rhs, VAL); pop(); sp = cursp(); } break; case NODE_COLON2: case NODE_CALL: case NODE_SCALL: break; case NODE_NVAR: codegen_error(s, ""Can't assign to numbered parameter""); break; default: codegen_error(s, ""unknown lhs""); break; } tree = tree->cdr; switch (type) { case NODE_GVAR: gen_setxv(s, OP_SETGV, sp, nsym(tree), val); break; case NODE_ARG: case NODE_LVAR: idx = lv_idx(s, nsym(tree)); if (idx > 0) { if (idx != sp) { gen_move(s, idx, sp, val); } break; } else {                       gen_setupvar(s, sp, nsym(tree)); } break; case NODE_IVAR: gen_setxv(s, OP_SETIV, sp, nsym(tree), val); break; case NODE_CVAR: gen_setxv(s, OP_SETCV, sp, nsym(tree), val); break; case NODE_CONST: gen_setxv(s, OP_SETCONST, sp, nsym(tree), val); break; case NODE_COLON2: if (sp) { gen_move(s, cursp(), sp, 0); } sp = cursp(); push(); codegen(s, tree->car, VAL); if (rhs) { codegen(s, rhs, VAL); pop(); gen_move(s, sp, cursp(), 0); } pop_n(2); idx = new_sym(s, nsym(tree->cdr)); genop_2(s, OP_SETMCNST, sp, idx); break; case NODE_CALL: case NODE_SCALL: { int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0; mrb_sym mid = nsym(tree->cdr->car); top = cursp(); if (val || sp == cursp()) { push();                    } call = cursp(); if (!tree->car) { noself = 1; push(); } else { codegen(s, tree->car, VAL);  } if (safe) { int recv = cursp()-1; gen_move(s, cursp(), recv, 1); skip = genjmp2_0(s, OP_JMPNIL, cursp(), val); } tree = tree->cdr->cdr->car; if (tree) { if (tree->car) {             n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14); if (n < 0) {               n = 15; push(); } } if (tree->cdr->car) {        if (n == 14) { pop_n(n); genop_2(s, OP_ARRAY, cursp(), n); push(); n = 15; } gen_hash(s, tree->cdr->car->cdr, VAL, 0); if (n < 14) { n++; } else { pop_n(2); genop_2(s, OP_ARYPUSH, cursp(), 1); } push(); } } if (rhs) { codegen(s, rhs, VAL); pop(); } else { gen_move(s, cursp(), sp, 0); } if (val) { gen_move(s, top, cursp(), 1); } if (n < 15) { n++; if (n == 15) { pop_n(14); genop_2(s, OP_ARRAY, cursp(), 15); } } else { pop(); genop_2(s, OP_ARYPUSH, cursp(), 1); } s->sp = call; if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) { genop_1(s, OP_SETIDX, cursp()); } else { genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n); } if (safe) { dispatch(s, skip); } s->sp = top; } break; case NODE_MASGN: gen_massignment(s, tree->car, sp, val); break; case NODE_NIL: break; default: codegen_error(s, ""unknown lhs""); break; } if (val) push(); }"
"future<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags) { using namespace compression_buffers; if (flags & cql_frame_flags::compression) { if (_compression == cql_compression::lz4) { if (length < 4) { throw std::runtime_error(fmt::format(""CQL frame truncated: expected to have at least 4 bytes, got {}"", length)); } return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) { auto linearization_buffer = bytes_ostream(); int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int(); if (uncomp_len < 0) { throw std::runtime_error(""CQL frame uncompressed length is negative: "" + std::to_string(uncomp_len)); } buf.remove_prefix(4); auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf)); auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) { auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()), in.size(), out.size()); if (ret < 0) { throw std::runtime_error(""CQL frame LZ4 uncompression failure""); } return out.size(); }); on_compression_buffer_use(); return uncomp; }); } else if (_compression == cql_compression::snappy) { return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) { auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf)); size_t uncomp_len; if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) { throw std::runtime_error(""CQL frame Snappy uncompressed size is unknown""); } auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) { size_t output_len = out.size(); if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) { throw std::runtime_error(""CQL frame Snappy uncompression failure""); } return output_len; }); on_compression_buffer_use(); return uncomp; }); } else { throw exceptions::protocol_exception(format(""Unknown compression algorithm"")); } } return _buffer_reader.read_exactly(_read_buf, length); }"
"bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) { ecc_25519_work_t s2, work; ecc_int256_t w, tmp; ecc_25519_scalarmult(&s2, &ctx->u2, pubkey); ecc_25519_add(&work, &ctx->s1, &s2); ecc_25519_store_xy_legacy(&w, NULL, &work); ecc_25519_gf_sub(&tmp, &ctx->r, &w); return ecc_25519_gf_is_zero(&tmp); }"
"static bool_t ept_split_super_page(struct p2m_domain *p2m, ept_entry_t *ept_entry, unsigned int level, unsigned int target) { ept_entry_t new_ept, *table; uint64_t trunk; unsigned int i; bool_t rv = 1; if ( level <= target ) return 1; ASSERT(is_epte_superpage(ept_entry)); if ( !ept_set_middle_entry(p2m, &new_ept) ) return 0; table = map_domain_page(_mfn(new_ept.mfn)); trunk = 1UL << ((level - 1) * EPT_TABLE_ORDER); for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ ) { ept_entry_t *epte = table + i; *epte = *ept_entry; epte->sp = (level > 1); epte->mfn += i * trunk; epte->snp = is_iommu_enabled(p2m->domain) && iommu_snoop; epte->suppress_ve = 1; ept_p2m_type_to_flags(p2m, epte); if ( (level - 1) == target ) continue; ASSERT(is_epte_superpage(epte)); if ( !(rv = ept_split_super_page(p2m, epte, level - 1, target)) ) break; } unmap_domain_page(table); *ept_entry = new_ept; return rv; }"
"static multipart_info_t * get_multipart_info(packet_info *pinfo, http_message_info_t *message_info) { char *start_boundary, *start_protocol = NULL; multipart_info_t *m_info = NULL; const char *type = pinfo->match_string; char *parameters; gint dummy; if (type == NULL) { return NULL; } if (message_info == NULL) { return NULL; } if (message_info->media_str == NULL) { return NULL; } parameters = unfold_and_compact_mime_header(message_info->media_str, &dummy); start_boundary = ws_find_media_type_parameter(wmem_packet_scope(), parameters, ""boundary""); if(!start_boundary) { return NULL; } if(strncmp(type, ""multipart/encrypted"", sizeof(""multipart/encrypted"")-1) == 0) { start_protocol = ws_find_media_type_parameter(wmem_packet_scope(), parameters, ""protocol""); if(!start_protocol) { g_free(start_boundary); return NULL; } } m_info = wmem_new(wmem_packet_scope(), multipart_info_t); m_info->type = type; m_info->boundary = start_boundary; m_info->boundary_length = (guint)strlen(start_boundary); if(start_protocol) { m_info->protocol = start_protocol; m_info->protocol_length = (guint)strlen(start_protocol); } else { m_info->protocol = NULL; m_info->protocol_length = -1; } m_info->orig_content_type = NULL; m_info->orig_parameters = NULL; return m_info; }"
"s32_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter) { int i; struct xmit_buf *pxmitbuf; struct xmit_frame *pxframe; intres = _SUCCESS; u32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ; u32 num_xmit_extbuf = NR_XMIT_EXTBUFF; spin_lock_init(&pxmitpriv->lock); sema_init(&pxmitpriv->terminate_xmitthread_sema, 0); pxmitpriv->adapter = padapter; rtw_init_queue(&pxmitpriv->be_pending); rtw_init_queue(&pxmitpriv->bk_pending); rtw_init_queue(&pxmitpriv->vi_pending); rtw_init_queue(&pxmitpriv->vo_pending); rtw_init_queue(&pxmitpriv->bm_pending); rtw_init_queue(&pxmitpriv->free_xmit_queue); pxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4); if (!pxmitpriv->pallocated_frame_buf) { pxmitpriv->pxmit_frame_buf = NULL; res = _FAIL; goto exit; } pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_frame_buf), 4); pxframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf; for (i = 0; i < NR_XMITFRAME; i++) { INIT_LIST_HEAD(&pxframe->list); pxframe->padapter = padapter; pxframe->frame_tag = NULL_FRAMETAG; pxframe->pkt = NULL; pxframe->buf_addr = NULL; pxframe->pxmitbuf = NULL; list_add_tail(&pxframe->list, &pxmitpriv->free_xmit_queue.queue); pxframe++; } pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME; pxmitpriv->frag_len = MAX_FRAG_THRESHOLD; rtw_init_queue(&pxmitpriv->free_xmitbuf_queue); rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue); pxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4); if (!pxmitpriv->pallocated_xmitbuf) { res = _FAIL; goto exit; } pxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_xmitbuf), 4); pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf; for (i = 0; i < NR_XMITBUFF; i++) { INIT_LIST_HEAD(&pxmitbuf->list); pxmitbuf->priv_data = NULL; pxmitbuf->padapter = padapter; pxmitbuf->ext_tag = false; res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ)); if (res == _FAIL) { msleep(10); res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ)); if (res == _FAIL) goto exit; } pxmitbuf->flags = XMIT_VO_QUEUE; list_add_tail(&pxmitbuf->list, &pxmitpriv->free_xmitbuf_queue.queue); pxmitbuf++; } pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF; rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue); pxmitpriv->pallocated_xmit_extbuf = vzalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4); if (!pxmitpriv->pallocated_xmit_extbuf) { res = _FAIL; goto exit; } pxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_xmit_extbuf), 4); pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf; for (i = 0; i < num_xmit_extbuf; i++) { INIT_LIST_HEAD(&pxmitbuf->list); pxmitbuf->priv_data = NULL; pxmitbuf->padapter = padapter; pxmitbuf->ext_tag = true; res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ); if (res == _FAIL) { res = _FAIL; goto exit; } list_add_tail(&pxmitbuf->list, &pxmitpriv->free_xmit_extbuf_queue.queue); pxmitbuf++; } pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf; rtw_alloc_hwxmits(padapter); rtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry); for (i = 0; i < 4; i++) pxmitpriv->wmm_para_seq[i] = i; pxmitpriv->txirp_cnt = 1; sema_init(&pxmitpriv->tx_retevt, 0); pxmitpriv->beq_cnt = 0; pxmitpriv->bkq_cnt = 0; pxmitpriv->viq_cnt = 0; pxmitpriv->voq_cnt = 0; pxmitpriv->ack_tx = false; mutex_init(&pxmitpriv->ack_tx_mutex); rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0); rtl8188eu_init_xmit_priv(padapter); exit: return res; }"
"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { RBuffer *fbuf = r_buf_ref (buf); struct MACH0_(opts_t) opts; MACH0_(opts_set_default) (&opts, bf); struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts); if (!main_mach0) { return false; } RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0); RKernelCacheObj *obj = NULL; RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0); if (!prelink_range) { goto beach; } obj = R_NEW0 (RKernelCacheObj); if (!obj) { R_FREE (prelink_range); goto beach; } RCFValueDict *prelink_info = NULL; if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) { prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset, prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA); if (!prelink_info) { R_FREE (prelink_range); R_FREE (obj); goto beach; } } if (!pending_bin_files) { pending_bin_files = r_list_new (); if (!pending_bin_files) { R_FREE (prelink_range); R_FREE (obj); R_FREE (prelink_info); goto beach; } } obj->mach0 = main_mach0; obj->rebase_info = rebase_info; obj->prelink_info = prelink_info; obj->cache_buf = fbuf; obj->pa2va_exec = prelink_range->pa2va_exec; obj->pa2va_data = prelink_range->pa2va_data; R_FREE (prelink_range); *bin_obj = obj; r_list_push (pending_bin_files, bf); if (rebase_info || main_mach0->chained_starts) { RIO *io = bf->rbin->iob.io; swizzle_io_read (obj, io); } return true; beach: r_buf_free (fbuf); obj->cache_buf = NULL; MACH0_(mach0_free) (main_mach0); return false; }"
"static int fixup_bpf_calls(struct bpf_verifier_env *env) { struct bpf_prog *prog = env->prog; bool expect_blinding = bpf_jit_blinding_enabled(prog); struct bpf_insn *insn = prog->insnsi; const struct bpf_func_proto *fn; const int insn_cnt = prog->len; const struct bpf_map_ops *ops; struct bpf_insn_aux_data *aux; struct bpf_insn insn_buf[16]; struct bpf_prog *new_prog; struct bpf_map *map_ptr; int i, ret, cnt, delta = 0; for (i = 0; i < insn_cnt; i++, insn++) { if (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) || insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) || insn->code == (BPF_ALU | BPF_MOD | BPF_X) || insn->code == (BPF_ALU | BPF_DIV | BPF_X)) { bool is64 = BPF_CLASS(insn->code) == BPF_ALU64; bool isdiv = BPF_OP(insn->code) == BPF_DIV; struct bpf_insn *patchlet; struct bpf_insn chk_and_div[] = { BPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) | BPF_JNE | BPF_K, insn->src_reg, 0, 2, 0), BPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg), BPF_JMP_IMM(BPF_JA, 0, 0, 1), *insn, }; struct bpf_insn chk_and_mod[] = { BPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) | BPF_JEQ | BPF_K, insn->src_reg, 0, 1, 0), *insn, }; patchlet = isdiv ? chk_and_div : chk_and_mod; cnt = isdiv ? ARRAY_SIZE(chk_and_div) : ARRAY_SIZE(chk_and_mod); new_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (BPF_CLASS(insn->code) == BPF_LD && (BPF_MODE(insn->code) == BPF_ABS || BPF_MODE(insn->code) == BPF_IND)) { cnt = env->ops->gen_ld_abs(insn, insn_buf); if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) || insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X; struct bpf_insn insn_buf[16]; struct bpf_insn *patch = &insn_buf[0]; bool issrc, isneg; u32 off_reg; aux = &env->insn_aux_data[i + delta]; if (!aux->alu_state || aux->alu_state == BPF_ALU_NON_POINTER) continue; isneg = aux->alu_state & BPF_ALU_NEG_VALUE; issrc = (aux->alu_state & BPF_ALU_SANITIZE) == BPF_ALU_SANITIZE_SRC; off_reg = issrc ? insn->src_reg : insn->dst_reg; if (isneg) *patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1); *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1); *patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg); *patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg); *patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0); *patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63); if (issrc) { *patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg); insn->src_reg = BPF_REG_AX; } else { *patch++ = BPF_ALU64_REG(BPF_AND, off_reg, BPF_REG_AX); } if (isneg) insn->code = insn->code == code_add ? code_sub : code_add; *patch++ = *insn; if (issrc && isneg) *patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1); cnt = patch - insn_buf; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (insn->code != (BPF_JMP | BPF_CALL)) continue; if (insn->src_reg == BPF_PSEUDO_CALL) continue; if (insn->imm == BPF_FUNC_get_route_realm) prog->dst_needed = 1; if (insn->imm == BPF_FUNC_get_prandom_u32) bpf_user_rnd_init_once(); if (insn->imm == BPF_FUNC_override_return) prog->kprobe_override = 1; if (insn->imm == BPF_FUNC_tail_call) { prog->cb_access = 1; if (!allow_tail_call_in_subprogs(env)) prog->aux->stack_depth = MAX_BPF_STACK; prog->aux->max_pkt_offset = MAX_PACKET_OFF; insn->imm = 0; insn->code = BPF_JMP | BPF_TAIL_CALL; aux = &env->insn_aux_data[i + delta]; if (env->bpf_capable && !expect_blinding && prog->jit_requested && !bpf_map_key_poisoned(aux) && !bpf_map_ptr_poisoned(aux) && !bpf_map_ptr_unpriv(aux)) { struct bpf_jit_poke_descriptor desc = { .reason = BPF_POKE_REASON_TAIL_CALL, .tail_call.map = BPF_MAP_PTR(aux->map_ptr_state), .tail_call.key = bpf_map_key_immediate(aux), .insn_idx = i + delta, }; ret = bpf_jit_add_poke_descriptor(prog, &desc); if (ret < 0) { verbose(env, ""adding tail call poke descriptor failed\n""); return ret; } insn->imm = ret + 1; continue; } if (!bpf_map_ptr_unpriv(aux)) continue; if (bpf_map_ptr_poisoned(aux)) { verbose(env, ""tail_call abusing map_ptr\n""); return -EINVAL; } map_ptr = BPF_MAP_PTR(aux->map_ptr_state); insn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3, map_ptr->max_entries, 2); insn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3, container_of(map_ptr, struct bpf_array, map)->index_mask); insn_buf[2] = *insn; cnt = 3; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (prog->jit_requested && BITS_PER_LONG == 64 && (insn->imm == BPF_FUNC_map_lookup_elem || insn->imm == BPF_FUNC_map_update_elem || insn->imm == BPF_FUNC_map_delete_elem || insn->imm == BPF_FUNC_map_push_elem   || insn->imm == BPF_FUNC_map_pop_elem    || insn->imm == BPF_FUNC_map_peek_elem)) { aux = &env->insn_aux_data[i + delta]; if (bpf_map_ptr_poisoned(aux)) goto patch_call_imm; map_ptr = BPF_MAP_PTR(aux->map_ptr_state); ops = map_ptr->ops; if (insn->imm == BPF_FUNC_map_lookup_elem && ops->map_gen_lookup) { cnt = ops->map_gen_lookup(map_ptr, insn_buf); if (cnt == -EOPNOTSUPP) goto patch_map_ops_generic; if (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } BUILD_BUG_ON(!__same_type(ops->map_lookup_elem, (void *(*)(struct bpf_map *map, void *key))NULL)); BUILD_BUG_ON(!__same_type(ops->map_delete_elem, (int (*)(struct bpf_map *map, void *key))NULL)); BUILD_BUG_ON(!__same_type(ops->map_update_elem, (int (*)(struct bpf_map *map, void *key, void *value, u64 flags))NULL)); BUILD_BUG_ON(!__same_type(ops->map_push_elem, (int (*)(struct bpf_map *map, void *value, u64 flags))NULL)); BUILD_BUG_ON(!__same_type(ops->map_pop_elem, (int (*)(struct bpf_map *map, void *value))NULL)); BUILD_BUG_ON(!__same_type(ops->map_peek_elem, (int (*)(struct bpf_map *map, void *value))NULL)); patch_map_ops_generic: switch (insn->imm) { case BPF_FUNC_map_lookup_elem: insn->imm = BPF_CAST_CALL(ops->map_lookup_elem) - __bpf_call_base; continue; case BPF_FUNC_map_update_elem: insn->imm = BPF_CAST_CALL(ops->map_update_elem) - __bpf_call_base; continue; case BPF_FUNC_map_delete_elem: insn->imm = BPF_CAST_CALL(ops->map_delete_elem) - __bpf_call_base; continue; case BPF_FUNC_map_push_elem: insn->imm = BPF_CAST_CALL(ops->map_push_elem) - __bpf_call_base; continue; case BPF_FUNC_map_pop_elem: insn->imm = BPF_CAST_CALL(ops->map_pop_elem) - __bpf_call_base; continue; case BPF_FUNC_map_peek_elem: insn->imm = BPF_CAST_CALL(ops->map_peek_elem) - __bpf_call_base; continue; } goto patch_call_imm; } if (prog->jit_requested && BITS_PER_LONG == 64 && insn->imm == BPF_FUNC_jiffies64) { struct bpf_insn ld_jiffies_addr[2] = { BPF_LD_IMM64(BPF_REG_0, (unsigned long)&jiffies), }; insn_buf[0] = ld_jiffies_addr[0]; insn_buf[1] = ld_jiffies_addr[1]; insn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0); cnt = 3; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } patch_call_imm: fn = env->ops->get_func_proto(insn->imm, env->prog); if (!fn->func) { verbose(env, ""kernel subsystem misconfigured func %s#%d\n"", func_id_name(insn->imm), insn->imm); return -EFAULT; } insn->imm = fn->func - __bpf_call_base; } for (i = 0; i < prog->aux->size_poke_tab; i++) { map_ptr = prog->aux->poke_tab[i].tail_call.map; if (!map_ptr->ops->map_poke_track || !map_ptr->ops->map_poke_untrack || !map_ptr->ops->map_poke_run) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } ret = map_ptr->ops->map_poke_track(map_ptr, prog->aux); if (ret < 0) { verbose(env, ""tracking tail call prog failed\n""); return ret; } } return 0; }"
"Jsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v) { if (v->vt == JSI_VT_NUMBER) return JSI_OK; Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0); Jsi_ValueReset(interp, &v); Jsi_ValueMakeNumber(interp, &v, a); return JSI_OK; }"
"static void handle_PORT(ctrl_t *ctrl, char *str) { int a, b, c, d, e, f; char addr[INET_ADDRSTRLEN]; struct sockaddr_in sin; if (ctrl->data_sd > 0) { uev_io_stop(&ctrl->data_watcher); close(ctrl->data_sd); ctrl->data_sd = -1; } sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f); sprintf(addr, ""%d.%d.%d.%d"", a, b, c, d); if (!inet_aton(addr, &(sin.sin_addr))) { ERR(0, ""Invalid address '%s' given to PORT command"", addr); send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n""); return; } strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address)); ctrl->data_port = e * 256 + f; DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port); send_msg(ctrl->sd, ""200 PORT command successful.\r\n""); }"
"int PDFDoc::savePageAs(const GooString &name, int pageNo) { FILE *f; OutStream *outStr; XRef *yRef, *countRef; if (file && file->modificationTimeChangedSinceOpen()) { return errFileChangedSinceOpen; } int rootNum = getXRef()->getNumObjects() + 1; xref->scanSpecialFlags(); unsigned char *fileKey; CryptAlgorithm encAlgorithm; int keyLength; xref->getEncryptionParameters(&fileKey, &encAlgorithm, &keyLength); if (pageNo < 1 || pageNo > getNumPages() || !getCatalog()->getPage(pageNo)) { error(errInternal, -1, ""Illegal pageNo: {0:d}({1:d})"", pageNo, getNumPages()); return errOpenFile; } const PDFRectangle *cropBox = nullptr; if (getCatalog()->getPage(pageNo)->isCropped()) { cropBox = getCatalog()->getPage(pageNo)->getCropBox(); } replacePageDict(pageNo, getCatalog()->getPage(pageNo)->getRotate(), getCatalog()->getPage(pageNo)->getMediaBox(), cropBox); Ref *refPage = getCatalog()->getPageRef(pageNo); Object page = getXRef()->fetch(*refPage); if (!(f = openFile(name.c_str(), ""wb""))) { error(errIO, -1, ""Couldn't open file '{0:t}'"", &name); return errOpenFile; } outStr = new FileOutStream(f, 0); yRef = new XRef(getXRef()->getTrailerDict()); if (secHdlr != nullptr && !secHdlr->isUnencrypted()) { yRef->setEncryption(secHdlr->getPermissionFlags(), secHdlr->getOwnerPasswordOk(), fileKey, keyLength, secHdlr->getEncVersion(), secHdlr->getEncRevision(), encAlgorithm); } countRef = new XRef(); Object *trailerObj = getXRef()->getTrailerDict(); if (trailerObj->isDict()) { markPageObjects(trailerObj->getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } yRef->add(0, 65535, 0, false); writeHeader(outStr, getPDFMajorVersion(), getPDFMinorVersion()); Object infoObj = getXRef()->getDocInfo(); if (infoObj.isDict()) { Dict *infoDict = infoObj.getDict(); markPageObjects(infoDict, yRef, countRef, 0, refPage->num, rootNum + 2); if (trailerObj->isDict()) { Dict *trailerDict = trailerObj->getDict(); const Object &ref = trailerDict->lookupNF(""Info""); if (ref.isRef()) { yRef->add(ref.getRef(), 0, true); if (getXRef()->getEntry(ref.getRef().num)->type == xrefEntryCompressed) { yRef->getEntry(ref.getRef().num)->type = xrefEntryCompressed; } } } } Object catObj = getXRef()->getCatalog(); if (!catObj.isDict()) { fclose(f); delete yRef; delete countRef; delete outStr; error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary""); return errOpenFile; } Dict *catDict = catObj.getDict(); Object pagesObj = catDict->lookup(""Pages""); Object afObj = catDict->lookupNF(""AcroForm"").copy(); if (!afObj.isNull()) { markAcroForm(&afObj, yRef, countRef, 0, refPage->num, rootNum + 2); } Dict *pagesDict = pagesObj.getDict(); Object resourcesObj = pagesDict->lookup(""Resources""); if (resourcesObj.isDict()) { markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2); Dict *pageDict = page.getDict(); if (resourcesObj.isNull() && !pageDict->hasKey(""Resources"")) { Object *resourceDictObject = getCatalog()->getPage(pageNo)->getResourceDictObject(); if (resourceDictObject->isDict()) { resourcesObj = resourceDictObject->copy(); markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } } markPageObjects(pageDict, yRef, countRef, 0, refPage->num, rootNum + 2); Object annotsObj = pageDict->lookupNF(""Annots"").copy(); if (!annotsObj.isNull()) { markAnnotations(&annotsObj, yRef, countRef, 0, refPage->num, rootNum + 2); } yRef->markUnencrypted(); writePageObjects(outStr, yRef, 0); yRef->add(rootNum, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum); outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1); for (int j = 0; j < catDict->getLength(); j++) { const char *key = catDict->getKey(j); if (strcmp(key, ""Type"") != 0 && strcmp(key, ""Catalog"") != 0 && strcmp(key, ""Pages"") != 0) { if (j > 0) { outStr->printf("" ""); } Object value = catDict->getValNF(j).copy(); outStr->printf(""/%s "", key); writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } } outStr->printf("">>\nendobj\n""); yRef->add(rootNum + 1, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + 1); outStr->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", rootNum + 2); if (resourcesObj.isDict()) { outStr->printf(""/Resources ""); writeObject(&resourcesObj, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } outStr->printf("">>\n""); outStr->printf(""endobj\n""); yRef->add(rootNum + 2, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + 2); outStr->printf(""<< ""); for (int n = 0; n < pageDict->getLength(); n++) { if (n > 0) { outStr->printf("" ""); } const char *key = pageDict->getKey(n); Object value = pageDict->getValNF(n).copy(); if (strcmp(key, ""Parent"") == 0) { outStr->printf(""/Parent %d 0 R"", rootNum + 1); } else { outStr->printf(""/%s "", key); writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } } outStr->printf("" >>\nendobj\n""); Goffset uxrefOffset = outStr->getPos(); Ref ref; ref.num = rootNum; ref.gen = 0; Object trailerDict = createTrailerDict(rootNum + 3, false, 0, &ref, getXRef(), name.c_str(), uxrefOffset); writeXRefTableTrailer(std::move(trailerDict), yRef, false , uxrefOffset, outStr, getXRef()); outStr->close(); fclose(f); delete yRef; delete countRef; delete outStr; return errNone; }"
"static int lock_fdc(int drive, bool interruptible) { if (WARN(atomic_read(&usage_count) == 0, ""Trying to lock fdc while usage count=0\n"")) return -1; if (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy))) return -EINTR; command_status = FD_COMMAND_NONE; reschedule_timeout(drive, ""lock fdc""); set_fdc(drive); return 0; }"
"static int xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options, const char *encoding) { if (ctxt == NULL) return(-1); if (encoding != NULL) { if (ctxt->encoding != NULL) xmlFree((xmlChar *) ctxt->encoding); ctxt->encoding = xmlStrdup((const xmlChar *) encoding); } if (options & XML_PARSE_RECOVER) { ctxt->recovery = 1; options -= XML_PARSE_RECOVER; ctxt->options |= XML_PARSE_RECOVER; } else ctxt->recovery = 0; if (options & XML_PARSE_DTDLOAD) { ctxt->loadsubset = XML_DETECT_IDS; options -= XML_PARSE_DTDLOAD; ctxt->options |= XML_PARSE_DTDLOAD; } else ctxt->loadsubset = 0; if (options & XML_PARSE_DTDATTR) { ctxt->loadsubset |= XML_COMPLETE_ATTRS; options -= XML_PARSE_DTDATTR; ctxt->options |= XML_PARSE_DTDATTR; } if (options & XML_PARSE_NOENT) { ctxt->replaceEntities = 1; options -= XML_PARSE_NOENT; ctxt->options |= XML_PARSE_NOENT; } else ctxt->replaceEntities = 0; if (options & XML_PARSE_PEDANTIC) { ctxt->pedantic = 1; options -= XML_PARSE_PEDANTIC; ctxt->options |= XML_PARSE_PEDANTIC; } else ctxt->pedantic = 0; if (options & XML_PARSE_NOBLANKS) { ctxt->keepBlanks = 0; ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace; options -= XML_PARSE_NOBLANKS; ctxt->options |= XML_PARSE_NOBLANKS; } else ctxt->keepBlanks = 1; if (options & XML_PARSE_DTDVALID) { ctxt->validate = 1; if (options & XML_PARSE_NOWARNING) ctxt->vctxt.warning = NULL; if (options & XML_PARSE_NOERROR) ctxt->vctxt.error = NULL; options -= XML_PARSE_DTDVALID; ctxt->options |= XML_PARSE_DTDVALID; } else ctxt->validate = 0; if (options & XML_PARSE_NOWARNING) { ctxt->sax->warning = NULL; options -= XML_PARSE_NOWARNING; } if (options & XML_PARSE_NOERROR) { ctxt->sax->error = NULL; ctxt->sax->fatalError = NULL; options -= XML_PARSE_NOERROR; } #ifdef LIBXML_SAX1_ENABLED if (options & XML_PARSE_SAX1) { ctxt->sax->startElement = xmlSAX2StartElement; ctxt->sax->endElement = xmlSAX2EndElement; ctxt->sax->startElementNs = NULL; ctxt->sax->endElementNs = NULL; ctxt->sax->initialized = 1; options -= XML_PARSE_SAX1; ctxt->options |= XML_PARSE_SAX1; } #endif  if (options & XML_PARSE_NODICT) { ctxt->dictNames = 0; options -= XML_PARSE_NODICT; ctxt->options |= XML_PARSE_NODICT; } else { ctxt->dictNames = 1; } if (options & XML_PARSE_NOCDATA) { ctxt->sax->cdataBlock = NULL; options -= XML_PARSE_NOCDATA; ctxt->options |= XML_PARSE_NOCDATA; } if (options & XML_PARSE_NSCLEAN) { ctxt->options |= XML_PARSE_NSCLEAN; options -= XML_PARSE_NSCLEAN; } if (options & XML_PARSE_NONET) { ctxt->options |= XML_PARSE_NONET; options -= XML_PARSE_NONET; } if (options & XML_PARSE_COMPACT) { ctxt->options |= XML_PARSE_COMPACT; options -= XML_PARSE_COMPACT; } if (options & XML_PARSE_OLD10) { ctxt->options |= XML_PARSE_OLD10; options -= XML_PARSE_OLD10; } if (options & XML_PARSE_NOBASEFIX) { ctxt->options |= XML_PARSE_NOBASEFIX; options -= XML_PARSE_NOBASEFIX; } if (options & XML_PARSE_HUGE) { ctxt->options |= XML_PARSE_HUGE; options -= XML_PARSE_HUGE; if (ctxt->dict != NULL) xmlDictSetLimit(ctxt->dict, 0); } if (options & XML_PARSE_OLDSAX) { ctxt->options |= XML_PARSE_OLDSAX; options -= XML_PARSE_OLDSAX; } if (options & XML_PARSE_IGNORE_ENC) { ctxt->options |= XML_PARSE_IGNORE_ENC; options -= XML_PARSE_IGNORE_ENC; } if (options & XML_PARSE_BIG_LINES) { ctxt->options |= XML_PARSE_BIG_LINES; options -= XML_PARSE_BIG_LINES; } ctxt->linenumbers = 1; return (options); }"
"void pt_migrate(struct vcpu *v) { struct list_head *head = &v->arch.hvm.tm_list; struct periodic_time *pt; spin_lock(&v->arch.hvm.tm_lock); list_for_each_entry ( pt, head, list ) migrate_timer(&pt->timer, v->processor); spin_unlock(&v->arch.hvm.tm_lock); }"
"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si) { s32 pps_id; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if ((pps_id<0) || (pps_id > 255)) return -1; si->pps = &avc->pps[pps_id]; si->pps->id = pps_id; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT]; if (!si->sps->log2_max_frame_num) return -2; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; if (si->sps->frame_mbs_only_flag) { } else { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->svc_nalhdr.idr_pic_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } return 0; }"
"static LY_ERR lysp_stmt_validate_value(struct lysp_ctx *ctx, enum yang_arg val_type, const char *val) { uint8_t prefix = 0; ly_bool first = 1; uint32_t c; size_t utf8_char_len; while (*val) { LY_CHECK_ERR_RET(ly_getutf8(&val, &c, &utf8_char_len), LOGVAL_PARSER(ctx, LY_VCODE_INCHAR, (val)[-utf8_char_len]), LY_EVALID); switch (val_type) { case Y_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, NULL)); break; case Y_PREF_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, &prefix)); break; case Y_STR_ARG: case Y_MAYBE_STR_ARG: LY_CHECK_RET(lysp_check_stringchar(ctx, c)); break; } first = 0; } return LY_SUCCESS; }"
"static void m2tsdmx_declare_pid(GF_M2TSDmxCtx *ctx, GF_M2TS_PES *stream, GF_ESD *esd) { u32 i, count, codecid=0, stype=0, orig_stype=0; GF_FilterPid *opid; Bool m4sys_stream = GF_FALSE; Bool m4sys_iod_stream = GF_FALSE; Bool has_scal_layer = GF_FALSE; Bool unframed = GF_FALSE; Bool unframed_latm = GF_FALSE; char szName[20]; const char *stname; if (stream->user) return; if (stream->flags & GF_M2TS_GPAC_CODEC_ID) { codecid = stream->stream_type; stype = gf_codecid_type(codecid); if (stream->gpac_meta_dsi) stype = stream->gpac_meta_dsi[4]; if (!stype) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] Unrecognized gpac codec %s - ignoring pid\n"", gf_4cc_to_str(codecid) )); return; } } else { switch (stream->stream_type) { case GF_M2TS_VIDEO_MPEG1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG1; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_MPEG2: case GF_M2TS_VIDEO_DCII: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG2_MAIN; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_MPEG4: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG4_PART2; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_H264: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AVC; unframed = GF_TRUE; if (stream->program->is_scalable) has_scal_layer = GF_TRUE; break; case GF_M2TS_HLS_AVC_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AVC; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_SVC: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_SVC; has_scal_layer = GF_TRUE; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_HEVC: case GF_M2TS_VIDEO_HEVC_TEMPORAL: case GF_M2TS_VIDEO_HEVC_MCTS: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_HEVC; unframed = GF_TRUE; if (stream->program->is_scalable) has_scal_layer = GF_TRUE; break; case GF_M2TS_VIDEO_SHVC: case GF_M2TS_VIDEO_SHVC_TEMPORAL: case GF_M2TS_VIDEO_MHVC: case GF_M2TS_VIDEO_MHVC_TEMPORAL: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_LHVC; has_scal_layer = GF_TRUE; break; case GF_M2TS_VIDEO_VVC: case GF_M2TS_VIDEO_VVC_TEMPORAL: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_VVC; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_VC1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_SMPTE_VC1; stream->flags |= GF_M2TS_CHECK_VC1; break; case GF_M2TS_VIDEO_AV1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AV1; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_MPEG1: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MPEG_AUDIO; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_MPEG2: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MPEG2_PART3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_AAC: case GF_CODECID_AAC_MPEG2_MP: case GF_CODECID_AAC_MPEG2_LCP: case GF_CODECID_AAC_MPEG2_SSRP: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_LATM_AAC: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; unframed_latm = GF_TRUE; break; case GF_M2TS_MHAS_MAIN: case GF_M2TS_MHAS_AUX: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MHAS; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_AC3: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AC3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_EC3: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_TRUEHD: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_TRUEHD; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_DTS: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_DTS_X; break; case GF_M2TS_AUDIO_OPUS: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_OPUS; break; case GF_M2TS_SYSTEMS_MPEG4_SECTIONS: ((GF_M2TS_ES*)stream)->flags |= GF_M2TS_ES_SEND_REPEATED_SECTIONS; case GF_M2TS_SYSTEMS_MPEG4_PES: if (!esd) { m4sys_iod_stream = GF_TRUE; count = gf_list_count(stream->program->pmt_iod->ESDescriptors); for (i=0; i<count; i++) { esd = gf_list_get(stream->program->pmt_iod->ESDescriptors, i); if (esd->ESID == stream->mpeg4_es_id) break; esd = NULL; } } m4sys_stream = GF_TRUE; if (!esd) return; break; case GF_M2TS_METADATA_PES: case GF_M2TS_METADATA_ID3_HLS: stype = GF_STREAM_METADATA; codecid = GF_CODECID_SIMPLE_TEXT; break; case 0xA1: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; break; case GF_M2TS_HLS_AAC_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; break; case GF_M2TS_HLS_AC3_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AC3; unframed = GF_TRUE; break; case GF_M2TS_HLS_EC3_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; break; case GF_M2TS_DVB_SUBTITLE: stype = GF_STREAM_TEXT; codecid = GF_CODECID_DVB_SUBS; stream->flags |= GF_M2TS_ES_FULL_AU; break; case GF_M2TS_DVB_TELETEXT: if (!ctx->dvbtxt) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] DVB teletext pid skipped, use --dvbtxt to enable\n"", stream->stream_type)); return; } stype = GF_STREAM_TEXT; codecid = GF_CODECID_DVB_TELETEXT; stream->flags |= GF_M2TS_ES_FULL_AU; break; default: GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] Stream type 0x%02X not supported - ignoring pid\n"", stream->stream_type)); return; } } opid = NULL; for (i=0; i<gf_filter_get_opid_count(ctx->filter); i++) { opid = gf_filter_get_opid(ctx->filter, i); const GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_ID); if (p && (p->value.uint == stream->pid)) break; opid = NULL; } if (!opid) opid = gf_filter_pid_new(ctx->filter); stream->user = opid; stream->flags |= GF_M2TS_ES_ALREADY_DECLARED; u32 d_type = orig_stype ? orig_stype : stype; switch (d_type) { case GF_STREAM_AUDIO: case GF_STREAM_VISUAL: stream->flags |= GF_M2TS_CHECK_DISC; break; default: stream->flags &= ~GF_M2TS_CHECK_DISC; break; } stname = gf_stream_type_name(stype); sprintf(szName, ""P%d%c%d"", stream->program->number, stname[0], 1+gf_list_find(stream->program->streams, stream)); gf_filter_pid_set_name(opid, szName); gf_filter_pid_set_property(opid, GF_PROP_PID_ID, &PROP_UINT(stream->pid) ); gf_filter_pid_set_property(opid, GF_PROP_PID_ESID, stream->mpeg4_es_id ? &PROP_UINT(stream->mpeg4_es_id) : NULL); if (m4sys_stream) { if (stream->slcfg) gf_free(stream->slcfg); stream->slcfg = esd->slConfig; esd->slConfig = NULL; gf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(esd->decoderConfig ? esd->decoderConfig->streamType : GF_STREAM_SCENE) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(esd->decoderConfig ? esd->decoderConfig->objectTypeIndication : GF_CODECID_BIFS) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(esd->OCRESID ? esd->OCRESID : esd->ESID) ); gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID) ); if (esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->dataLength) gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength) ); gf_filter_pid_set_property(opid, GF_PROP_PID_IN_IOD, &PROP_BOOL(m4sys_iod_stream) ); gf_filter_pid_set_property(opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(((GF_M2TS_ES*)stream)->slcfg->timestampResolution) ); if (esd->decoderConfig && (esd->decoderConfig->streamType==GF_STREAM_OD)) stream->flags |= GF_M2TS_ES_IS_MPEG4_OD; } else { gf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(stype) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(codecid) ); gf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED, unframed ? &PROP_BOOL(GF_TRUE) : NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED_LATM, unframed_latm ? &PROP_BOOL(GF_TRUE) : NULL ); if (orig_stype) { gf_filter_pid_set_property(opid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(orig_stype) ); gf_filter_pid_set_property(opid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_UINT(GF_HLS_SAMPLE_AES_SCHEME) ); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_ORIG_STREAM_TYPE, NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, NULL); } gf_filter_pid_set_property(opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(90000) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(stream->program->pcr_pid) ); if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->gpac_meta_dsi) { char *cname; GF_BitStream *bs = gf_bs_new(stream->gpac_meta_dsi, stream->gpac_meta_dsi_size, GF_BITSTREAM_READ); u32 val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(val) ); gf_bs_read_u8(bs); gf_bs_read_u8(bs); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT(val) ); cname = gf_bs_read_utf8(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_CODEC_NAME, cname ? &PROP_STRING_NO_COPY(cname) : NULL ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(val) ); u32 dsi_len = gf_bs_read_u32(bs); if (dsi_len) { u32 pos = gf_bs_get_position(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(stream->gpac_meta_dsi+pos, dsi_len) ); gf_bs_skip_bytes(bs, dsi_len); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, NULL); } if (stype==GF_STREAM_VISUAL) { val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_WIDTH, &PROP_UINT(val) ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_HEIGHT, &PROP_UINT(val) ); } else if (stype==GF_STREAM_AUDIO) { val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(val) ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(val) ); } gf_bs_del(bs); } } gf_filter_pid_set_property(opid, GF_PROP_PID_SCALABLE, has_scal_layer ? &PROP_BOOL(GF_TRUE) : NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_SERVICE_ID, &PROP_UINT(stream->program->number) ); if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->lang) { char szLang[4]; szLang[0] = (stream->lang>>16) & 0xFF; szLang[1] = (stream->lang>>8) & 0xFF; szLang[2] = stream->lang & 0xFF; szLang[3] = 0; if (szLang[2]==' ') szLang[2] = 0; gf_filter_pid_set_property(opid, GF_PROP_PID_LANGUAGE, &PROP_STRING(szLang) ); } if (codecid == GF_CODECID_DVB_SUBS) { char szLang[4]; memcpy(szLang, stream->sub.language, 3); szLang[3]=0; gf_filter_pid_set_property(opid, GF_PROP_PID_LANGUAGE, &PROP_STRING(szLang) ); u8 dsi[5]; dsi[0] = stream->sub.composition_page_id>>8; dsi[1] = stream->sub.composition_page_id & 0xFF; dsi[2] = stream->sub.ancillary_page_id>>8; dsi[3] = stream->sub.ancillary_page_id & 0xFF; dsi[4] = stream->sub.type; gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi, 5)); } if (ctx->duration.num>1) { gf_filter_pid_set_property(opid, GF_PROP_PID_DURATION, &PROP_FRAC64(ctx->duration) ); gf_filter_pid_set_property(opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) ); } if (!m4sys_stream) { if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->depends_on_pid) { gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(stream->depends_on_pid) ); if ((stream->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) || (stream->stream_type == GF_M2TS_VIDEO_HEVC_MCTS)) { gf_filter_pid_set_property(opid, GF_PROP_PID_SUBLAYER, &PROP_BOOL(GF_TRUE) ); } } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_SUBLAYER, NULL); } } if ((stream->flags & GF_M2TS_ES_IS_PES) && (stream->dv_info[0])) { gf_filter_pid_set_property(opid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(stream->dv_info, 24) ); u32 dvtype=0; if (stream->dv_info[24]) { if (stream->stream_type == GF_M2TS_VIDEO_H264) dvtype = GF_4CC('d','a','v','1'); else dvtype = GF_4CC('d','v','h','1'); } gf_filter_pid_set_property(opid, GF_PROP_PID_ISOM_SUBTYPE, dvtype ? &PROP_4CC(dvtype) : NULL); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DOLBY_VISION, NULL); } m2tsdmx_update_sdt(ctx->ts, opid); gf_m2ts_set_pes_framing((GF_M2TS_PES *)stream, GF_M2TS_PES_FRAMING_DEFAULT); }"
"size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) { switch (dt) { case DT_FLOAT: return 4; case DT_DOUBLE: return 8; case DT_INT32: return 10; case DT_UINT8: return 2; case DT_INT16: return 10; case DT_INT8: return 10; case DT_COMPLEX64: return 8; case DT_INT64: return 10; case DT_BOOL: return 1; case DT_QINT8: return 10; case DT_QUINT8: return 2; case DT_QINT32: return 10; case DT_QINT16: return 10; case DT_QUINT16: return 3; case DT_UINT16: return 3; case DT_COMPLEX128: return 16; case DT_HALF: return 3; case DT_INVALID: case DT_STRING: case DT_BFLOAT16: default: LOG(FATAL) << ""MaxBytesPerElement not implemented for dtype: "" << dt; } return 0; }"
"GVariant * g_variant_new_from_bytes (const GVariantType *type, GBytes             *bytes, gboolean            trusted) { GVariant *value; guint alignment; gsize size; GBytes *owned_bytes = NULL; GVariantSerialised serialised; value = g_variant_alloc (type, TRUE, trusted); g_variant_type_info_query (value->type_info, &alignment, &size); serialised.type_info = value->type_info; serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size); serialised.depth = 0; if (!g_variant_serialised_check (serialised)) { #ifdef HAVE_POSIX_MEMALIGN gpointer aligned_data = NULL; gsize aligned_size = g_bytes_get_size (bytes); if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1), aligned_size) != 0) g_error (""posix_memalign failed""); if (aligned_size != 0) memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size); bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data, aligned_size, free, aligned_data); aligned_data = NULL; #else bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL), g_bytes_get_size (bytes)); #endif } value->contents.serialised.bytes = g_bytes_ref (bytes); if (size && g_bytes_get_size (bytes) != size) { value->contents.serialised.data = NULL; value->size = size; } else { value->contents.serialised.data = g_bytes_get_data (bytes, &value->size); } g_clear_pointer (&owned_bytes, g_bytes_unref); return value; }"
"static int expandrow2(UINT8* dest, const UINT8* src, int n, int z, int xsize) { UINT8 pixel, count; for (;n > 0; n--) { pixel = src[1]; src+=2; if (n == 1 && pixel != 0) return n; count = pixel & RLE_MAX_RUN; if (!count) return count; if (count > xsize) { return -1; } if (pixel & RLE_COPY_FLAG) { while(count--) { memcpy(dest, src, 2); src += 2; dest += z * 2; } } else { while (count--) { memcpy(dest, src, 2); dest += z * 2; } src+=2; } } return 0; }"
"GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only) { u32 type; GF_ESD *esd; GF_MPEGSampleEntryBox *entry = NULL; GF_ESDBox *ESDa; GF_ProtectionSchemeInfoBox *sinf; GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription; *out_esd = NULL; if (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM; esd = NULL; entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1); if (! entry) return GF_ISOM_INVALID_MEDIA; *out_esd = NULL; ESDa = NULL; type = entry->type; switch (type) { case GF_ISOM_BOX_TYPE_ENCV: case GF_ISOM_BOX_TYPE_ENCA: case GF_ISOM_BOX_TYPE_ENCS: case GF_ISOM_BOX_TYPE_ENCF: case GF_ISOM_BOX_TYPE_ENCM: case GF_ISOM_BOX_TYPE_ENCT: sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) { type = sinf->original_format->data_format; } break; case GF_ISOM_BOX_TYPE_RESV: sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF); if (sinf && sinf->original_format) { type = sinf->original_format->data_format; } break; } switch (type) { case GF_ISOM_BOX_TYPE_MP4V: ESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd; if (ESDa) esd = (GF_ESD *) ESDa->desc; else esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_AVC1: case GF_ISOM_BOX_TYPE_AVC2: case GF_ISOM_BOX_TYPE_AVC3: case GF_ISOM_BOX_TYPE_AVC4: case GF_ISOM_BOX_TYPE_HVC1: case GF_ISOM_BOX_TYPE_HEV1: case GF_ISOM_BOX_TYPE_HVC2: case GF_ISOM_BOX_TYPE_HEV2: case GF_ISOM_BOX_TYPE_HVT1: case GF_ISOM_BOX_TYPE_264B: case GF_ISOM_BOX_TYPE_265B: case GF_ISOM_BOX_TYPE_DVHE: case GF_ISOM_BOX_TYPE_VVC1: case GF_ISOM_BOX_TYPE_VVI1: esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_SVC1: case GF_ISOM_BOX_TYPE_MVC1: if ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT) AVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia); else AVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL); esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_LHE1: case GF_ISOM_BOX_TYPE_LHV1: if ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT) HEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia); else HEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL); esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_AV01: AV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia); esd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_VP08: case GF_ISOM_BOX_TYPE_VP09: VP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia); esd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_MP4A: { GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry; ESDa = ase->esd; if (ESDa) { esd = (GF_ESD *) ESDa->desc; } else if (!true_desc_only) { Bool make_mp4a = GF_FALSE; sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) { if (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) { make_mp4a = GF_TRUE; } } else { make_mp4a = GF_TRUE; } if (make_mp4a) { GF_M4ADecSpecInfo aacinfo; memset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo)); aacinfo.nb_chan = ase->channel_count; aacinfo.base_object_type = GF_M4A_AAC_LC; aacinfo.base_sr = ase->samplerate_hi; *out_esd = gf_odf_desc_esd_new(0); (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO; (*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4; gf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength); } } } break; case GF_ISOM_BOX_TYPE_MP4S: if (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) { ESDa = entry->esd; if (ESDa) esd = (GF_ESD *) ESDa->desc; } break; #ifndef GPAC_DISABLE_TTXT case GF_ISOM_BOX_TYPE_TX3G: case GF_ISOM_BOX_TYPE_TEXT: if (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) { GF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd); if (e) return e; break; } else return GF_ISOM_INVALID_MEDIA; #endif #ifndef GPAC_DISABLE_VTT case GF_ISOM_BOX_TYPE_WVTT: { GF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry; esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_TEXT; esd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT; if (vtte->config) { esd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string); esd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength); memcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength); } } break; case GF_ISOM_BOX_TYPE_STPP: case GF_ISOM_BOX_TYPE_SBTT: case GF_ISOM_BOX_TYPE_STXT: break; #endif case GF_ISOM_SUBTYPE_3GP_AMR: case GF_ISOM_SUBTYPE_3GP_AMR_WB: case GF_ISOM_SUBTYPE_3GP_EVRC: case GF_ISOM_SUBTYPE_3GP_QCELP: case GF_ISOM_SUBTYPE_3GP_SMV: if (!true_desc_only) { GF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd); if (e) return e; break; } else return GF_ISOM_INVALID_MEDIA; case GF_ISOM_SUBTYPE_OPUS: { GF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus; GF_BitStream *bs_out; if (!e) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ESD not found for Opus\n)"")); break; } *out_esd = gf_odf_desc_esd_new(2); (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO; (*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS; bs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_isom_box_size((GF_Box *) e); gf_isom_box_write((GF_Box *) e, bs_out); gf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength); gf_bs_del(bs_out); break; } case GF_ISOM_SUBTYPE_3GP_H263: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_VISUAL; esd->decoderConfig->objectTypeIndication = GF_CODECID_H263; break; } case GF_ISOM_SUBTYPE_MP3: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_AUDIO; esd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO; break; } case GF_ISOM_SUBTYPE_LSR1: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { GF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry; esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_SCENE; esd->decoderConfig->objectTypeIndication = GF_CODECID_LASER; esd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size; esd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size); if (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM; memcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size); break; } case GF_ISOM_SUBTYPE_MH3D_MHA1: case GF_ISOM_SUBTYPE_MH3D_MHA2: case GF_ISOM_SUBTYPE_MH3D_MHM1: case GF_ISOM_SUBTYPE_MH3D_MHM2: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { GF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry; esd = gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_AUDIO; if ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2)) esd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA; else esd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS; if (ptr->cfg_mha) { GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_bs_write_u8(bs, ptr->cfg_mha->configuration_version); gf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication); gf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout); gf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0); if (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size) gf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size); gf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength); gf_bs_del(bs); } } break; default: return GF_ISOM_INVALID_MEDIA; } if (true_desc_only) { if (!esd) return GF_ISOM_INVALID_MEDIA; *out_esd = esd; return GF_OK; } else { if (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA; if (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd); } return GF_OK; }"
"static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus, struct sk_buff *skb, bool first) { int size = lstatus & BD_LENGTH_MASK; struct page *page = rxb->page; if (likely(first)) { skb_put(skb, size); } else { if (lstatus & BD_LFLAG(RXBD_LAST)) size -= skb->len; skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, rxb->page_offset + RXBUF_ALIGNMENT, size, GFAR_RXB_TRUESIZE); } if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page))) return false; rxb->page_offset ^= GFAR_RXB_TRUESIZE; page_ref_inc(page); return true; }"
static int redisIvykisAttach(redisAsyncContext *ac) { redisContext *c = &(ac->c); redisIvykisEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisIvykisEvents*)hiredis_safe_malloc(sizeof(*e)); e->context = ac; ac->ev.addRead = redisIvykisAddRead; ac->ev.delRead = redisIvykisDelRead; ac->ev.addWrite = redisIvykisAddWrite; ac->ev.delWrite = redisIvykisDelWrite; ac->ev.cleanup = redisIvykisCleanup; ac->ev.data = e; IV_FD_INIT(&e->fd); e->fd.fd = c->fd; e->fd.handler_in = redisIvykisReadEvent; e->fd.handler_out = redisIvykisWriteEvent; e->fd.handler_err = NULL; e->fd.cookie = e->context; iv_fd_register(&e->fd); return REDIS_OK; }
"static int cit_get_packet_size(struct gspca_dev *gspca_dev) { struct usb_host_interface *alt; struct usb_interface *intf; intf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface); alt = usb_altnum_to_altsetting(intf, gspca_dev->alt); if (!alt) { pr_err(""Couldn't get altsetting\n""); return -EIO; } return le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize); }"
"TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context, OpData* op_data, TfLiteNode* node) { const TfLiteTensor* input; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputTensor, &input)); const TfLiteTensor* output_state = GetVariableInput(context, node, lstm::full::kOutputStateTensor); TF_LITE_ENSURE(context, output_state != nullptr); const int32_t input_zero_point = -input->params.zero_point; const int32_t output_state_zero_point = -output_state->params.zero_point; const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor( context, node, lstm::full::kInputToInputWeightsTensor); const TfLiteTensor* input_to_forget_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor, &input_to_forget_weights)); const TfLiteTensor* input_to_cell_weights; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, lstm::full::kInputToCellWeightsTensor, &input_to_cell_weights)); const TfLiteTensor* input_to_output_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor, &input_to_output_weights)); const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor( context, node, lstm::full::kRecurrentToInputWeightsTensor); const TfLiteTensor* recurrent_to_forget_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor, &recurrent_to_forget_weights)); const TfLiteTensor* recurrent_to_cell_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor, &recurrent_to_cell_weights)); const TfLiteTensor* recurrent_to_output_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor, &recurrent_to_output_weights)); const TfLiteTensor* projection_weights = GetOptionalInputTensor( context, node, lstm::full::kProjectionWeightsTensor); const TfLiteTensor* projection_bias = GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor); lstm_eval::IntegerLstmParameter* integer_lstm_params = &op_data->integer_lstm_param; const TfLiteTensor* intermediate = &context->tensors[node->intermediates->data[4]]; const auto* params = static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params); const int32_t hidden_zp = params->zero_point->data[0]; const bool is_layer_norm = op_data->use_layer_norm; const TfLiteTensor* forget_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kForgetGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_forget_weights, forget_gate_bias, &(integer_lstm_params->input_to_forget_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_forget_weights, nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias))); const TfLiteTensor* cell_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kCellGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_cell_weights, cell_gate_bias, &(integer_lstm_params->input_to_cell_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_cell_weights, nullptr, &(integer_lstm_params->recurrent_to_cell_effective_bias))); const TfLiteTensor* output_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kOutputGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_output_weights, output_gate_bias, &(integer_lstm_params->input_to_output_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_output_weights, nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias))); const TfLiteTensor* input_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kInputGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_input_weights, input_gate_bias, &(integer_lstm_params->input_to_input_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_input_weights, nullptr, &(integer_lstm_params->recurrent_to_input_effective_bias))); TF_LITE_ENSURE_OK(context, PrecomputeZeroPointTimesWeightWithBias( context, hidden_zp, projection_weights, projection_bias, &(integer_lstm_params->projection_effective_bias))); return kTfLiteOk; }"
"inline void Response::set_header(const char *key, const char *val) { headers.emplace(key, val); }"
"static int check_assertion(struct config_module * config, json_t * j_params, const char * username, json_t * j_scheme_data, json_t * j_assertion) { int ret, res; unsigned char * client_data = NULL, * challenge_b64 = NULL, * auth_data = NULL, rpid_hash[32] = {0}, * flags, cdata_hash[32] = {0}, data_signed[128] = {0}, sig[128] = {0}, * counter; char * challenge_hash = NULL; const char * rpid = NULL; size_t client_data_len, challenge_b64_len, auth_data_len, rpid_hash_len = 32, cdata_hash_len = 32, sig_len = 128, counter_value = 0, rpid_len = 0; json_t * j_client_data = NULL, * j_credential = NULL, * j_query; gnutls_pubkey_t pubkey = NULL; gnutls_datum_t pubkey_dat, data, signature; if (j_scheme_data != NULL && j_assertion != NULL) { do { ret = G_OK; if (!json_is_string(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId"")) || !json_string_length(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - rawId missing""); ret = G_ERROR_PARAM; break; } j_credential = get_credential(config, j_params, username, json_string_value(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId""))); if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - credential ID not found""); ret = G_ERROR_UNAUTHORIZED; break; } if (!json_is_string(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")) || !json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON mandatory""); ret = G_ERROR_PARAM; break; } if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON""))+1)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error allocating resources for client_data""); ret = G_ERROR_MEMORY; break; } if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")), client_data, &client_data_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64_decode client_data""); ret = G_ERROR_PARAM; break; } client_data[client_data_len] = '\0'; j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL); if (j_client_data == NULL) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error parsing JSON client data %s"", client_data); ret = G_ERROR_PARAM; break; } if (0 != o_strcmp(""webauthn.get"", json_string_value(json_object_get(j_client_data, ""type"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.type invalid""); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(j_client_data, ""challenge""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge mandatory""); ret = G_ERROR_PARAM; break; } if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, ""challenge""))+3)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""register_new_attestation - Error allocating resources for challenge_b64""); ret = G_ERROR_MEMORY; break; } if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, ""challenge"")), json_string_length(json_object_get(j_client_data, ""challenge"")), challenge_b64, &challenge_b64_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge invalid base64""); ret = G_ERROR_PARAM; break; } challenge_b64[challenge_b64_len] = '\0'; if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""register_new_attestation - Error generate_hash for challenge_b64""); ret = G_ERROR; break; } if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_assertion, ""challenge_hash"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge invalid""); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(j_client_data, ""origin""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.origin mandatory""); ret = G_ERROR_PARAM; break; } if (0 != o_strcmp(json_string_value(json_object_get(j_params, ""rp-origin"")), json_string_value(json_object_get(j_client_data, ""origin"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.origin invalid - Client send %s, required %s"", json_string_value(json_object_get(j_client_data, ""origin"")), json_string_value(json_object_get(j_params, ""rp-origin""))); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authenticatorData mandatory""); ret = G_ERROR_PARAM; break; } if ((auth_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData""))+1)) == NULL) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error allocating resources for auth_data""); ret = G_ERROR_PARAM; break; } if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData"")), auth_data, &auth_data_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64_decode auth_data""); ret = G_ERROR_PARAM; break; } if (auth_data_len < 37) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error authenticatorData invalid""); ret = G_ERROR_PARAM; break; } if (o_strstr(json_string_value(json_object_get(j_params, ""rp-origin"")), "":        rpid = o_strstr(json_string_value(json_object_get(j_params, ""rp-origin"")), "":      } else { rpid = json_string_value(json_object_get(j_params, ""rp-origin"")); } if (o_strchr(rpid, ':') != NULL) { rpid_len = o_strchr(rpid, ':') - rpid; } else { rpid_len = o_strlen(rpid); } if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error generate_digest_raw for rpid_hash""); ret = G_ERROR_PARAM; break; } if (0 != memcmp(auth_data, rpid_hash, rpid_hash_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authData.rpIdHash invalid""); ret = G_ERROR_PARAM; break; } flags = auth_data + FLAGS_OFFSET; if (!(*flags & FLAG_USER_PRESENT)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authData.userPresent not set""); ret = G_ERROR_PARAM; break; } if (!generate_digest_raw(digest_SHA256, client_data, client_data_len, cdata_hash, &cdata_hash_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error generate_digest_raw for cdata_hash""); ret = G_ERROR_PARAM; break; } counter = auth_data + COUNTER_OFFSET; counter_value = counter[3] | (counter[2] << 8) | (counter[1] << 16) | (counter[0] << 24); if (gnutls_pubkey_init(&pubkey) < 0) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error gnutls_pubkey_init""); ret = G_ERROR; break; } pubkey_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_credential, ""credential""), ""public_key"")); pubkey_dat.size = json_string_length(json_object_get(json_object_get(j_credential, ""credential""), ""public_key"")); if ((ret = gnutls_pubkey_import(pubkey, &pubkey_dat, GNUTLS_X509_FMT_PEM)) < 0) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error gnutls_pubkey_import: %d"", ret); ret = G_ERROR; break; } if (!o_base64url_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""signature"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""signature"")), sig, &sig_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64url_decode signature""); ret = G_ERROR_PARAM; break; } memcpy(data_signed, auth_data, auth_data_len); memcpy(data_signed+auth_data_len, cdata_hash, cdata_hash_len); data.data = data_signed; data.size = (auth_data_len+cdata_hash_len); signature.data = sig; signature.size = sig_len; if ((res = gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) < 0) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Invalid signature: %d"", res); ret = G_ERROR_UNAUTHORIZED; break; } if ((json_integer_value(json_object_get(json_object_get(j_credential, ""credential""), ""counter"")) || counter_value) && counter_value <= (size_t)json_integer_value(json_object_get(json_object_get(j_credential, ""credential""), ""counter""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - counter invalid""); ret = G_ERROR_UNAUTHORIZED; break; } } while (0);  if (ret == G_OK) { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 1, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (1)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } else { if (counter) { j_query = json_pack(""{sss{si}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_CREDENTIAL, ""set"", ""gswc_counter"", counter_value, ""where"", ""gswc_id"", json_object_get(json_object_get(j_credential, ""credential""), ""gswc_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (2)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } } } else if (ret == G_ERROR_PARAM) { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 2, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (3)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } else { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 3, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (4)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } o_free(client_data); o_free(challenge_b64); o_free(challenge_hash); o_free(auth_data); json_decref(j_client_data); json_decref(j_credential); gnutls_pubkey_deinit(pubkey); } else { ret = G_ERROR_PARAM; } return ret; }"
"static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop) { struct se_device *remote_dev; if (xop->op_origin == XCOL_SOURCE_RECV_OP) remote_dev = xop->dst_dev; else remote_dev = xop->src_dev; pr_debug(""Calling configfs_undepend_item for"" "" remote_dev: %p remote_dev->dev_group: %p\n"", remote_dev, &remote_dev->dev_group.cg_item); target_undepend_item(&remote_dev->dev_group.cg_item); }"
"static int printbuf_extend(struct printbuf *p, int min_size) { char *t; int new_size; if (p->size >= min_size) return 0; new_size = p->size * 2; if (new_size < min_size + 8) new_size = min_size + 8; #ifdef PRINTBUF_DEBUG MC_DEBUG(""printbuf_memappend: realloc "" ""bpos=%d min_size=%d old_size=%d new_size=%d\n"", p->bpos, min_size, p->size, new_size); #endif  if (!(t = (char *)realloc(p->buf, new_size))) return -1; p->size = new_size; p->buf = t; return 0; }"
"static void get_info_from_frame (mpeg2ps_stream_t *sptr, u8 *buffer, u32 buflen) { if (sptr->is_video) { if (MPEG12_ParseSeqHdr(buffer, buflen, &sptr->have_mpeg2, &sptr->h, &sptr->w, &sptr->frame_rate, &sptr->bit_rate, &sptr->par) < 0) { sptr->m_stream_id = 0; sptr->m_fd = FDNULL; } sptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate); return; } if (sptr->m_stream_id >= 0xc0) { u32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]); sptr->channels = gf_mp3_num_channels(hdr); sptr->freq = gf_mp3_sampling_rate(hdr); sptr->samples_per_frame = gf_mp3_window_size(hdr); sptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; sptr->layer = gf_mp3_layer(hdr); } else if (sptr->m_stream_id == 0xbd) { if (sptr->m_substream_id >= 0xa0) { } else if (sptr->m_substream_id >= 0x80) { u32 pos; GF_AC3Config hdr; memset(&hdr, 0, sizeof(GF_AC3Config)); gf_ac3_parser(buffer, buflen, &pos, &hdr, 0); sptr->bitrate = gf_ac3_get_bitrate(hdr.brcode); sptr->freq = hdr.sample_rate; sptr->channels = hdr.streams[0].channels; sptr->samples_per_frame = 256 * 6; } else { return; } } else { return; } }"
"static void g_variant_serialise (GVariant *value, gpointer  data) { GVariantSerialised serialised = { 0, }; gpointer *children; gsize n_children; g_assert (~value->state & STATE_SERIALISED); g_assert (value->state & STATE_LOCKED); serialised.type_info = value->type_info; serialised.size = value->size; serialised.data = data; serialised.depth = value->depth; children = (gpointer *) value->contents.tree.children; n_children = value->contents.tree.n_children; g_variant_serialiser_serialise (serialised, g_variant_fill_gvs, children, n_children); }"
"static void check_POLYLINE_handles (Dwg_Object *obj) { Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D; Dwg_Data *dwg = obj->parent; if (dwg->header.version >= R_2004) { BITCODE_BL i = 0; Dwg_Object_Ref *layer = obj->tio.entity->layer; Dwg_Object_Ref *seqend = _obj->seqend; if (layer && !layer->obj) layer->obj = dwg_ref_object_relative (dwg, layer, obj); if (!layer || !layer->obj) {           LOG_WARN (""Wrong POLYLINE.layer %lX"", layer ? layer->handleref.value : 0L); if (_obj->num_owned > 0 && _obj->vertex) { Dwg_Object_Ref *vertex = _obj->vertex[0]; if (vertex && !vertex->obj) vertex->obj = dwg_ref_object_relative (dwg, vertex, obj); if (vertex && vertex->obj  && vertex->obj->fixedtype == DWG_TYPE_LAYER) { Dwg_Object *seq; obj->tio.entity->layer = layer = vertex; LOG_WARN ( ""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"", layer->handleref.value); for (i = 0; i < _obj->num_owned - 1; i++) { _obj->vertex[i] = _obj->vertex[i + 1]; } _obj->vertex[_obj->num_owned - 1] = seqend; _obj->seqend = NULL; seq = dwg_next_object (obj); if (seq && seq->type == DWG_TYPE_SEQEND) { LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"", seq->handle.value); seqend = _obj->seqend = dwg_find_objectref (dwg, seq); } else { seq = dwg_next_object (seqend->obj); if (seq && seq->type == DWG_TYPE_SEQEND) { LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"", seq->handle.value); seqend = _obj->seqend = dwg_find_objectref (dwg, seq); } } } } } else if (layer->obj->fixedtype != DWG_TYPE_LAYER && layer->obj->fixedtype != DWG_TYPE_DICTIONARY) {           LOG_WARN (""Wrong POLYLINE.layer %s"", layer->obj->dxfname) } if (!seqend || !seqend->handleref.value) { LOG_WARN (""Empty POLYLINE.seqend"") } else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND) {           LOG_WARN (""Wrong POLYLINE.seqend %s"", seqend->obj->dxfname) } if (!_obj->vertex) return; for (; i < _obj->num_owned; i++) { Dwg_Object_Ref *v = _obj->vertex[i]; if (!v || !v->handleref.value) { LOG_WARN (""Empty POLYLINE.vertex[%d]"", i); } else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D && v->obj->fixedtype != DWG_TYPE_VERTEX_3D && v->obj->fixedtype != DWG_TYPE_VERTEX_MESH && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE) { LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", i, v->handleref.value, v->obj->dxfname) } } } }"
"int sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw, bool force) { sudo_auth *auth; debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH); for (auth = auth_switch; auth->name; auth++) { if (auth->cleanup && !IS_DISABLED(auth)) { int status = (auth->cleanup)(ctx, pw, auth, force); if (status == AUTH_ERROR) { debug_return_int(-1); } } } debug_return_int(0); }"
"int32_t *enc_untrusted_create_wait_queue() { MessageWriter input; MessageReader output; input.Push<uint64_t>(sizeof(int32_t)); const auto status = NonSystemCallDispatcher( ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_create_wait_queue"", 2); int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>()); int klinux_errno = output.next<int>(); if (queue == nullptr) { errno = FromkLinuxErrorNumber(klinux_errno); } enc_untrusted_disable_waiting(queue); return queue; }"
static void __reg_combine_64_into_32(struct bpf_reg_state *reg) { __mark_reg32_unbounded(reg); if (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) { reg->s32_min_value = (s32)reg->smin_value; reg->s32_max_value = (s32)reg->smax_value; } if (__reg64_bound_u32(reg->umin_value)) reg->u32_min_value = (u32)reg->umin_value; if (__reg64_bound_u32(reg->umax_value)) reg->u32_max_value = (u32)reg->umax_value; __reg_deduce_bounds(reg); __reg_bound_offset(reg); __update_reg_bounds(reg); }
"static int map_delete_elem(union bpf_attr *attr) { void __user *ukey = u64_to_user_ptr(attr->key); int ufd = attr->map_fd; struct bpf_map *map; struct fd f; void *key; int err; if (CHECK_ATTR(BPF_MAP_DELETE_ELEM)) return -EINVAL; f = fdget(ufd); map = __bpf_map_get(f); if (IS_ERR(map)) return PTR_ERR(map); if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) { err = -EPERM; goto err_put; } key = __bpf_copy_key(ukey, map->key_size); if (IS_ERR(key)) { err = PTR_ERR(key); goto err_put; } if (bpf_map_is_dev_bound(map)) { err = bpf_map_offload_delete_elem(map, key); goto out; } else if (IS_FD_PROG_ARRAY(map) || map->map_type == BPF_MAP_TYPE_STRUCT_OPS) { err = map->ops->map_delete_elem(map, key); goto out; } bpf_disable_instrumentation(); rcu_read_lock(); err = map->ops->map_delete_elem(map, key); rcu_read_unlock(); bpf_enable_instrumentation(); maybe_wait_bpf_programs(map); out: kvfree(key); err_put: fdput(f); return err; }"
"static void print_include_directory_details(Dwarf_Debug dbg, unsigned int line_version, Dwarf_Line_Context line_context) { Dwarf_Unsigned u = 0; dwarfstring    m4; Dwarf_Unsigned indexbase = 0; Dwarf_Unsigned indexlimit = 0; dwarfstring_constructor_static(&m4,locallinebuf, sizeof(locallinebuf)); if (line_version == DW_LINE_VERSION5) { unsigned i = 0; unsigned dfcount = line_context->lc_directory_entry_format_count; dwarfstring_constructor(&m4); dwarfstring_append_printf_u(&m4, ""  directory entry format count %u\n"",dfcount); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); for ( ; i < dfcount;++i) { struct Dwarf_Unsigned_Pair_s *valpair = 0; const char *tname = 0; const char *fname = 0; int res; valpair = line_context->lc_directory_format_values +i; dwarfstring_append_printf_u(&m4, ""  format [%2u] "",i); res = dwarf_get_LNCT_name(valpair->up_first, &tname); if ( res != DW_DLV_OK) { tname = ""<unknown type>""; } dwarfstring_append_printf_u (&m4, "" type 0x%"" DW_PR_XZEROS DW_PR_DUx ,valpair->up_first); dwarfstring_append_printf_s (&m4, "" %-20s\n"",(char *)tname); res = dwarf_get_FORM_name(valpair->up_second,&fname); if ( res != DW_DLV_OK) { fname = ""<unknown form>""; } dwarfstring_append_printf_u(&m4, ""               code 0x%"" DW_PR_XZEROS DW_PR_DUx , valpair->up_second); dwarfstring_append_printf_s(&m4, "" %-20s\n"", (char *)fname); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); } } if (line_version == DW_LINE_VERSION5) { dwarfstring_append_printf_i(&m4, ""  include directories count %d\n"", (int) line_context->lc_include_directories_count); } else { if(!line_context->lc_include_directories_count) { dwarfstring_append_printf_i(&m4, ""  include directories count %d\n"", (int) line_context->lc_include_directories_count); } else { dwarfstring_append_printf_i(&m4, ""  include directories count %d"" "" (index starts at 1)\n"", (int) line_context->lc_include_directories_count); } } _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); if (line_version == DW_LINE_VERSION5) { indexbase = 0; indexlimit =  line_context->lc_include_directories_count; } else { indexbase = 1; indexlimit = 1 + line_context->lc_include_directories_count; } for (u = indexbase; u < indexlimit; ++u) { dwarfstring_append_printf_u(&m4, ""  include dir[%u] "",u); dwarfstring_append_printf_s(&m4, ""%s\n"",(char *) line_context->lc_include_directories[u-indexbase]); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); } dwarfstring_destructor(&m4); }"
"void VpnDbus::connect(const QString &preferredServer, const QList<QString> &servers, const QString &username, const QString &passwd, const QString &extraArgs) { inner->connect(preferredServer, username, passwd, extraArgs); }"
"int detach_capi_ctr(struct capi_ctr *ctr) { int err = 0; mutex_lock(&capi_controller_lock); ctr_down(ctr, CAPI_CTR_DETACHED); if (capi_controller[ctr->cnr - 1] != ctr) { err = -EINVAL; goto unlock_out; } capi_controller[ctr->cnr - 1] = NULL; ncontrollers--; if (ctr->procent) remove_proc_entry(ctr->procfn, NULL); printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"", ctr->cnr, ctr->name); unlock_out: mutex_unlock(&capi_controller_lock); return err; }"
"static QSvgNode *createPathNode(QSvgNode *parent, const QXmlStreamAttributes &attributes, QSvgHandler *) { QStringRef data      = attributes.value(QLatin1String(""d"")); QPainterPath qpath; qpath.setFillRule(Qt::WindingFill); parsePathDataFast(data, qpath); QSvgNode *path = new QSvgPath(parent, qpath); return path; }"
"static cmd_rec *make_ftp_cmd(pool *p, char *buf, size_t buflen, int flags) { register unsigned int i, j; char *arg, *ptr, *wrd; size_t arg_len; cmd_rec *cmd; pool *subpool; array_header *tarr; int have_crnul = FALSE, str_flags = PR_STR_FL_PRESERVE_COMMENTS|flags; if (PR_ISSPACE(buf[0])) { pr_trace_msg(""ctrl"", 5, ""command '%s' has illegal leading whitespace, rejecting"", buf); errno = EINVAL; return NULL; } ptr = buf; wrd = pr_str_get_word(&ptr, str_flags); if (wrd == NULL) { pr_trace_msg(""ctrl"", 5, ""command '%s' is empty, ignoring"", buf); errno = ENOENT; return NULL; } subpool = make_sub_pool(p); pr_pool_tag(subpool, ""make_ftp_cmd pool""); cmd = pcalloc(subpool, sizeof(cmd_rec)); cmd->pool = subpool; cmd->tmp_pool = NULL; cmd->stash_index = -1; cmd->stash_hash = 0; tarr = make_array(cmd->pool, 2, sizeof(char *)); *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd); cmd->argc++; arg_len = buflen - strlen(wrd); arg = pcalloc(cmd->pool, arg_len + 1); for (i = 0, j = 0; i < arg_len; i++) { pr_signals_handle(); if (i > 1 && ptr[i] == '\0' && ptr[i-1] == '\r') { have_crnul = TRUE; } else { arg[j++] = ptr[i]; } } cmd->arg = arg; if (have_crnul) { char *dup_arg; dup_arg = pstrdup(cmd->pool, arg); ptr = dup_arg; } while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL) { pr_signals_handle(); *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd); cmd->argc++; } *((char **) push_array(tarr)) = NULL; cmd->argv = tarr->elts; pr_pool_tag(cmd->pool, cmd->argv[0]); cmd->notes = pr_table_nalloc(cmd->pool, 0, 8); return cmd; }"
"struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) { size_t i, len = strlen(name); for (i = 0; hm->header_names[i].len > 0; i++) { struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i]; if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len)) return v; } return NULL; }"
void my_output_message( j_common_ptr ) {}
"int  dlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx) { tcpeditdlt_plugin_t *plugin; assert(ctx); if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) { tcpedit_seterr(ctx->tcpedit, ""Unable to cleanup unregistered plugin %s"", dlt_name); return TCPEDIT_ERROR; } safe_free(plugin->name); plugin->name = NULL; if (plugin->config != NULL) { jnpr_ether_config_t *config; config = (jnpr_ether_config_t *)ctx->encoder->config; tcpedit_dlt_cleanup(config->subctx); safe_free(config->subctx); safe_free(plugin->config); plugin->config = NULL; plugin->config_size = 0; } return TCPEDIT_OK;  }"
"WOURLError WOParseApplicationName(WOURLComponents *wc, const char *url) { int len; const char *s; const char *webobjects, *extension, *version, *start, *end; int i; len = strlen(url); webobjects = NULL; s = (url != NULL) ? url : """"; while ( (s <= url + (len - WebObjects_LEN)) && (webobjects == NULL) && (*s != '?') ) { while ((*s != '/') && (s <= url + (len - WebObjects_LEN))) s++; if ((strncmp(s, WebObjects_STR, WebObjects_LEN) == 0) || (strncmp(s, WEBOBJECTS_STR, WebObjects_LEN) == 0) ) webobjects = s; else s++; } if (webobjects == NULL) return WOURLInvalidPrefix; s = webobjects + WebObjects_LEN; for (end = s; (end < url + len) && (*end != '?') && (*end != '/'); end++) ; version = (*s == '-') ? s : NULL; extension = NULL; for (i=0; (extension == NULL) && (cgi_extensions[i] != NULL); i++) { int n = strlen(cgi_extensions[i]); if ((end - n >= version) && (strncmp(end-n, cgi_extensions[i], n) == 0)) extension = end - n; } if (extension != NULL) { if (version && ((extension - (version+1) < 1) || ( !isdigit((int)*(extension-1)) ))) return WOURLInvalidWebObjectsVersion; } else if (version != NULL) { if ((end - (version+1) < 1) || ( !isdigit((int)*(end-1)) )) return WOURLInvalidWebObjectsVersion; } else if ((end - s) > 1 ) return WOURLInvalidPrefix; wc->prefix.start = url; wc->prefix.length = end - url; if (version != NULL) { wc->webObjectsVersion.start = version + 1; wc->webObjectsVersion.length = ((extension) ? extension : end)-version; } start = ((end < url + len) && (*end != '?')) ? end + 1 : end; end = url + len; extension = end; for (i=0; (extension == end) && (app_extensions[i] != NULL); i++) { int n = strlen(app_extensions[i]); for (s=start; (s+n <= url+len) && (*s != '?') && (extension == end); ++s) { if ( (strncmp(s, app_extensions[i], n) == 0) && ((s + n == url + len) || (*(s+n) == '?') || (*(s+n) == '/')) ) { extension = s; end = s + n; } } if (*s == '?') end = s; } wc->applicationName.length = (end < extension) ? end - start : extension - start; if (wc->applicationName.length != 0) { wc->applicationName.start = start; while(wc->applicationName.length && wc->applicationName.start[wc->applicationName.length-1] == '/') wc->applicationName.length--; return WOURLOK; } else return WOURLInvalidApplicationName; }"
"bool XRef::readXRefTable(Parser *parser, Goffset *pos, std::vector<Goffset> *followedXRefStm, std::vector<int> *xrefStreamObjsNum) { XRefEntry entry; bool more; Object obj, obj2; Goffset pos2; int first, n; while (true) { obj = parser->getObj(true); if (obj.isCmd(""trailer"")) { break; } if (!obj.isInt()) { goto err0; } first = obj.getInt(); obj = parser->getObj(true); if (!obj.isInt()) { goto err0; } n = obj.getInt(); if (first < 0 || n < 0 || first > INT_MAX - n) { goto err0; } if (first + n > size) { if (resize(first + n) != first + n) { error(errSyntaxError, -1, ""Invalid 'obj' parameters'""); goto err0; } } for (int i = first; i < first + n; ++i) { obj = parser->getObj(true); if (obj.isInt()) { entry.offset = obj.getInt(); } else if (obj.isInt64()) { entry.offset = obj.getInt64(); } else { goto err0; } obj = parser->getObj(true); if (!obj.isInt()) { goto err0; } entry.gen = obj.getInt(); entry.flags = 0; obj = parser->getObj(true); if (obj.isCmd(""n"")) { entry.type = xrefEntryUncompressed; } else if (obj.isCmd(""f"")) { entry.type = xrefEntryFree; } else { goto err0; } if (entries[i].offset == -1) { entries[i].offset = entry.offset; entries[i].gen = entry.gen; entries[i].type = entry.type; entries[i].flags = entry.flags; entries[i].obj.setToNull(); if (i == 1 && first == 1 && entries[1].offset == 0 && entries[1].gen == 65535 && entries[1].type == xrefEntryFree) { i = first = 0; entries[0].offset = 0; entries[0].gen = 65535; entries[0].type = xrefEntryFree; entries[0].flags = entries[1].flags; entries[0].obj = std::move(entries[1].obj); entries[1].offset = -1; entries[1].obj.setToNull(); } } } } obj = parser->getObj(); if (!obj.isDict()) { goto err0; } obj2 = obj.getDict()->lookupNF(""Prev"").copy(); if (obj2.isInt() || obj2.isInt64()) { if (obj2.isInt()) pos2 = obj2.getInt(); else pos2 = obj2.getInt64(); if (pos2 != *pos) { *pos = pos2; more = true; } else { error(errSyntaxWarning, -1, ""Infinite loop in xref table""); more = false; } } else if (obj2.isRef()) { pos2 = (unsigned int)obj2.getRefNum(); if (pos2 != *pos) { *pos = pos2; more = true; } else { error(errSyntaxWarning, -1, ""Infinite loop in xref table""); more = false; } } else { more = false; } if (trailerDict.isNone()) { trailerDict = obj.copy(); } obj2 = obj.getDict()->lookup(""XRefStm""); if (obj2.isInt() || obj2.isInt64()) { if (obj2.isInt()) pos2 = obj2.getInt(); else pos2 = obj2.getInt64(); for (size_t i = 0; ok == true && i < followedXRefStm->size(); ++i) { if (followedXRefStm->at(i) == pos2) { ok = false; } } if (ok) { followedXRefStm->push_back(pos2); readXRef(&pos2, followedXRefStm, xrefStreamObjsNum); } if (!ok) { goto err0; } } return more; err0: ok = false; return false; }"
"xmlIDPtr xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr) { xmlIDPtr ret; xmlIDTablePtr table; if (doc == NULL) { return(NULL); } if (value == NULL) { return(NULL); } if (attr == NULL) { return(NULL); } table = (xmlIDTablePtr) doc->ids; if (table == NULL)  { doc->ids = table = xmlHashCreateDict(0, doc->dict); } if (table == NULL) { xmlVErrMemory(ctxt, ""xmlAddID: Table creation failed!\n""); return(NULL); } ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID)); if (ret == NULL) { xmlVErrMemory(ctxt, ""malloc failed""); return(NULL); } ret->value = xmlStrdup(value); ret->doc = doc; if ((ctxt != NULL) && (ctxt->vstateNr != 0)) { if (doc->dict != NULL) ret->name = xmlDictLookup(doc->dict, attr->name, -1); else ret->name = xmlStrdup(attr->name); ret->attr = NULL; } else { ret->attr = attr; ret->name = NULL; } ret->lineno = xmlGetLineNo(attr->parent); if (xmlHashAddEntry(table, value, ret) < 0) { #ifdef LIBXML_VALID_ENABLED if (ctxt != NULL) { xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED, ""ID %s already defined\n"", value, NULL, NULL); } #endif  xmlFreeID(ret); return(NULL); } if (attr != NULL) attr->atype = XML_ATTRIBUTE_ID; return(ret); }"
"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes) { Bool null_size_ok = GF_FALSE; GF_DefaultSampleGroupDescriptionEntry *def_ptr; switch (grouping_type) { case GF_ISOM_SAMPLE_GROUP_ROLL: case GF_ISOM_SAMPLE_GROUP_PROL: { GF_RollRecoveryEntry *ptr; GF_SAFEALLOC(ptr, GF_RollRecoveryEntry); if (!ptr) return NULL; ptr->roll_distance = gf_bs_read_int(bs, 16); *total_bytes = 2; return ptr; } case GF_ISOM_SAMPLE_GROUP_RAP: { GF_VisualRandomAccessEntry *ptr; GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry); if (!ptr) return NULL; ptr->num_leading_samples_known = gf_bs_read_int(bs, 1); ptr->num_leading_samples = gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SAP: { GF_SAPEntry *ptr; GF_SAFEALLOC(ptr, GF_SAPEntry); if (!ptr) return NULL; ptr->dependent_flag = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 3); ptr->SAP_type = gf_bs_read_int(bs, 4); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SYNC: { GF_SYNCEntry *ptr; GF_SAFEALLOC(ptr, GF_SYNCEntry); if (!ptr) return NULL; gf_bs_read_int(bs, 2); ptr->NALU_type = gf_bs_read_int(bs, 6); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_TELE: { GF_TemporalLevelEntry *ptr; GF_SAFEALLOC(ptr, GF_TemporalLevelEntry); if (!ptr) return NULL; ptr->level_independently_decodable = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SEIG: { GF_CENCSampleEncryptionGroupEntry *ptr; if (bytes_in_box<3) return NULL; GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry); if (!ptr) return NULL; Bool use_mkey = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); ptr->crypt_byte_block = gf_bs_read_int(bs, 4); ptr->skip_byte_block = gf_bs_read_int(bs, 4); ptr->IsProtected = gf_bs_read_u8(bs); bytes_in_box -= 3; if (use_mkey) { u64 pos = gf_bs_get_position(bs); u32 i, count = gf_bs_read_u16(bs); bytes_in_box -= 2; if (bytes_in_box<0) { gf_free(ptr); return NULL; } for (i=0; i<count; i++) { u8 ivsize = gf_bs_read_u8(bs); gf_bs_skip_bytes(bs, 16); bytes_in_box -= 17; if (!ivsize) { ivsize = gf_bs_read_u8(bs); gf_bs_skip_bytes(bs, ivsize); bytes_in_box -= 1 + ivsize; } if (bytes_in_box<0) { gf_free(ptr); return NULL; } } ptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos); ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size); if (!ptr->key_info) { gf_free(ptr); return NULL; } gf_bs_seek(bs, pos); ptr->key_info[0] = 1; gf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1); *total_bytes = 3 + ptr->key_info_size - 1; if (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) { gf_free(ptr->key_info); gf_free(ptr); return NULL; } } else { bin128 kid; u8 const_iv_size = 0; u8 iv_size = gf_bs_read_u8(bs); gf_bs_read_data(bs, kid, 16); bytes_in_box -= 17; if (bytes_in_box<0) { gf_free(ptr); return NULL; } *total_bytes = 20; if ((ptr->IsProtected == 1) && !iv_size) { const_iv_size = gf_bs_read_u8(bs); if ((const_iv_size != 8) && (const_iv_size != 16)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n"")); gf_free(ptr); return NULL; } } ptr->key_info_size = 20; if (!iv_size && ptr->IsProtected) { ptr->key_info_size += 1 + const_iv_size; } ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size); if (!ptr->key_info) { gf_free(ptr); return NULL; } ptr->key_info[0] = 0; ptr->key_info[1] = 0; ptr->key_info[2] = 0; ptr->key_info[3] = iv_size; memcpy(ptr->key_info+4, kid, 16); if (!iv_size && ptr->IsProtected) { ptr->key_info[20] = const_iv_size; gf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size); *total_bytes += 1 + const_iv_size; } } if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_OINF: { GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_oinf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_LINF: { GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_linf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_TRIF: if (! entry_size) { u32 flags = gf_bs_peek_bits(bs, 24, 0); if (flags & 0x10000) entry_size=3; else { if (flags & 0x80000) entry_size=7; else entry_size=11; if (flags & 0x200000) { u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size); entry_size += 2 + 2*nb_entries; } } GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_NALM: if (! entry_size) { u64 start = gf_bs_get_position(bs); Bool rle, large_size; u32 entry_count; gf_bs_read_int(bs, 6); large_size = gf_bs_read_int(bs, 1); rle = gf_bs_read_int(bs, 1); entry_count = gf_bs_read_int(bs, large_size ? 16 : 8); gf_bs_seek(bs, start); entry_size = 1 + (large_size ? 2 : 1); entry_size += entry_count * 2; if (rle) entry_size += entry_count * (large_size ? 2 : 1); GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_TSAS: case GF_ISOM_SAMPLE_GROUP_STSA: null_size_ok = GF_TRUE; break; case GF_ISOM_SAMPLE_GROUP_TSCL: entry_size = 20; break; case GF_ISOM_SAMPLE_GROUP_LBLI: entry_size = 2; break; case GF_ISOM_SAMPLE_GROUP_SPOR: { u32 i; GF_SubpictureOrderEntry *ptr; GF_SAFEALLOC(ptr, GF_SubpictureOrderEntry); if (!ptr) return NULL; ptr->subpic_id_info_flag = gf_bs_read_int(bs, 1); ptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15); *total_bytes = 2; ptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx); if (!ptr->subp_track_ref_idx) { gf_free(ptr); return NULL; } for (i=0; i<ptr->num_subpic_ref_idx; i++) { ptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs); *total_bytes += 2; } if (ptr->subpic_id_info_flag) { ptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4); ptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12); ptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1); ptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1); if (ptr->spinfo.pps_sps_subpic_id_flag) { ptr->spinfo.xps_id = gf_bs_read_int(bs, 6); } else { ptr->spinfo.xps_id = gf_bs_read_int(bs, 4); gf_bs_read_int(bs, 2); } *total_bytes += 3; } return ptr; } case GF_ISOM_SAMPLE_GROUP_SULM: { u32 i; GF_SubpictureLayoutMapEntry *ptr; GF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry); if (!ptr) return NULL; ptr->groupID_info_4cc = gf_bs_read_u32(bs); ptr->nb_entries = 1 + gf_bs_read_u16(bs); *total_bytes = 6; ptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries); if (!ptr->groupIDs) { gf_free(ptr); return NULL; } for (i=0; i<ptr->nb_entries; i++) { ptr->groupIDs[i] = gf_bs_read_u16(bs); *total_bytes += 2; } return ptr; } default: break; } if (!entry_size && !null_size_ok) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) )); return NULL; } GF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry); if (!def_ptr) return NULL; if (entry_size) { def_ptr->length = entry_size; def_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length); if (!def_ptr->data) { gf_free(def_ptr); return NULL; } gf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length); *total_bytes = entry_size; } return def_ptr; }"
"static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu) { struct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache; struct kvm_steal_time __user *st; struct kvm_memslots *slots; static const u8 preempted = KVM_VCPU_PREEMPTED; if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED)) return; if (vcpu->arch.st.preempted) return; if (unlikely(current->mm != vcpu->kvm->mm)) return; slots = kvm_memslots(vcpu->kvm); if (unlikely(slots->generation != ghc->generation || kvm_is_error_hva(ghc->hva) || !ghc->memslot)) return; st = (struct kvm_steal_time __user *)ghc->hva; BUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted)); if (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted))) vcpu->arch.st.preempted = KVM_VCPU_PREEMPTED; mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa)); }"
"void PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp) { if (dt_table[Elf32_Dyn::DT_NULL]) { return;      } Elf32_Dyn const *const dynp0 = dynp; unsigned ndx = 1+ 0; if (dynp) for (; ; ++ndx, ++dynp) { unsigned const d_tag = get_te32(&dynp->d_tag); if (d_tag < DT_NUM) { if (Elf32_Dyn::DT_NEEDED != d_tag &&  dt_table[d_tag] &&    get_te32(&dynp->d_val) != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) { char msg[50]; snprintf(msg, sizeof(msg), ""duplicate DT_%#x: [%#x] [%#x]"", d_tag, -1+ dt_table[d_tag], -1+ ndx); throwCantPack(msg); } dt_table[d_tag] = ndx; } if (Elf32_Dyn::DT_NULL == d_tag) { break;          } } upx_dt_init = 0; if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT; else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY; else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY; unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ]; if (z_str) { strtab_end = get_te32(&dynp0[-1+ z_str].d_val); if ((u32_t)file_size <= strtab_end) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_STRSZ %#x"", strtab_end); throwCantPack(msg); } } unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB]; unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB]; if (x_sym && x_str) { upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val); unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT]; unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym) : get_te32(&dynp0[-1+ z_sym].d_val); if (v_sym < v_str) { symnum_end = (v_str - v_sym) / sz_sym; } } unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH); if (v_hsh && file_image) { hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH); if (!hashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_HASH %#x"", v_hsh); throwCantPack(msg); } unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; (void)chains; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!nbucket || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)          || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2                  + sizeof(*buckets)*nbucket                  + sizeof(*chains) *nbucket             )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_HASH nbucket=%#x  len=%#x"", nbucket, (v_sym - v_hsh)); throwCantPack(msg); } } unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH); if (v_gsh && file_image) { gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH); if (!gashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH %#x"", v_gsh); throwCantPack(msg); } unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!n_bucket || !n_bitmask || (-1+ n_bitmask) & n_bitmask          || 8*sizeof(unsigned) <= gnu_shift          || (n_bucket>>30)          || (n_bitmask>>30) || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)                  || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4                  + sizeof(*bitmask)*n_bitmask                  + sizeof(*buckets)*n_bucket                  + sizeof(*hasharr)*n_bucket              )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x"", n_bucket, n_bitmask, v_sym - v_gsh); throwCantPack(msg); } } unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx); if (e_shnum <= e_shstrndx &&  !(0==e_shnum && 0==e_shstrndx) ) { char msg[40]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } }"
"static void perf_event__header_size(struct perf_event *event) { __perf_event_read_size(event, event->group_leader->nr_siblings); __perf_event_header_size(event, event->attr.sample_type); }"
"char_u * compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx) { char_u  *arg = eap->arg; lhs_T   *lhs = &cctx->ctx_redir_lhs; if (lhs->lhs_name != NULL) { if (STRNCMP(arg, ""END"", 3) == 0) { if (lhs->lhs_append) { if (compile_load_lhs_with_index(lhs, lhs->lhs_whole, cctx) == FAIL) return NULL; } generate_instr_type(cctx, ISN_REDIREND, &t_string); if (lhs->lhs_append) generate_CONCAT(cctx, 2); if (lhs->lhs_has_index) { if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE, &t_string, cctx) == FAIL) return NULL; } else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL) return NULL; VIM_CLEAR(lhs->lhs_name); VIM_CLEAR(lhs->lhs_whole); return arg + 3; } emsg(_(e_cannot_nest_redir)); return NULL; } if (arg[0] == '=' && arg[1] == '>') { int    append = FALSE; arg += 2; if (*arg == '>') { ++arg; append = TRUE; } arg = skipwhite(arg); if (compile_assign_lhs(arg, lhs, CMD_redir, FALSE, FALSE, FALSE, 1, cctx) == FAIL) return NULL; if (need_type(&t_string, lhs->lhs_member_type, -1, 0, cctx, FALSE, FALSE) == FAIL) return NULL; generate_instr(cctx, ISN_REDIRSTART); lhs->lhs_append = append; if (lhs->lhs_has_index) { lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total); if (lhs->lhs_whole == NULL) return NULL; } return arg + lhs->lhs_varlen_total; } return compile_exec(line, eap, cctx); }"
"void ConnectionManagerImpl::ActiveStream::recreateStream( StreamInfo::FilterStateSharedPtr filter_state) { ResponseEncoder* response_encoder = response_encoder_; response_encoder_ = nullptr; Buffer::InstancePtr request_data = std::make_unique<Buffer::OwnedImpl>(); const auto& buffered_request_data = filter_manager_.bufferedRequestData(); const bool proxy_body = buffered_request_data != nullptr && buffered_request_data->length() > 0; if (proxy_body) { request_data->move(*buffered_request_data); } response_encoder->getStream().removeCallbacks(*this); connection_manager_.doEndStream(*this); RequestDecoder& new_stream = connection_manager_.newStream(*response_encoder, true); if (filter_state->hasDataAtOrAboveLifeSpan(StreamInfo::FilterState::LifeSpan::Request)) { (*connection_manager_.streams_.begin())->filter_manager_.streamInfo().filter_state_ = std::make_shared<StreamInfo::FilterStateImpl>( filter_state->parent(), StreamInfo::FilterState::LifeSpan::FilterChain); } new_stream.decodeHeaders(std::move(request_headers_), !proxy_body); if (proxy_body) { new_stream.decodeData(*request_data, true); } }"
"static struct page *follow_pmd_mask(struct vm_area_struct *vma, unsigned long address, pud_t *pudp, unsigned int flags, struct follow_page_context *ctx) { pmd_t *pmd, pmdval; spinlock_t *ptl; struct page *page; struct mm_struct *mm = vma->vm_mm; pmd = pmd_offset(pudp, address); pmdval = READ_ONCE(*pmd); if (pmd_none(pmdval)) return no_page_table(vma, flags); if (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) { page = follow_huge_pmd(mm, address, pmd, flags); if (page) return page; return no_page_table(vma, flags); } if (is_hugepd(__hugepd(pmd_val(pmdval)))) { page = follow_huge_pd(vma, address, __hugepd(pmd_val(pmdval)), flags, PMD_SHIFT); if (page) return page; return no_page_table(vma, flags); } retry: if (!pmd_present(pmdval)) { VM_BUG_ON(!thp_migration_supported() || !is_pmd_migration_entry(pmdval)); if (likely(!(flags & FOLL_MIGRATION))) return no_page_table(vma, flags); pmd_migration_entry_wait(mm, pmd); pmdval = READ_ONCE(*pmd); if (pmd_none(pmdval)) return no_page_table(vma, flags); goto retry; } if (pmd_devmap(pmdval)) { ptl = pmd_lock(mm, pmd); page = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap); spin_unlock(ptl); if (page) return page; } if (likely(!pmd_trans_huge(pmdval))) return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); if ((flags & FOLL_NUMA) && pmd_protnone(pmdval)) return no_page_table(vma, flags); retry_locked: ptl = pmd_lock(mm, pmd); if (unlikely(pmd_none(*pmd))) { spin_unlock(ptl); return no_page_table(vma, flags); } if (unlikely(!pmd_present(*pmd))) { spin_unlock(ptl); if (likely(!(flags & FOLL_MIGRATION))) return no_page_table(vma, flags); pmd_migration_entry_wait(mm, pmd); goto retry_locked; } if (unlikely(!pmd_trans_huge(*pmd))) { spin_unlock(ptl); return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); } if (flags & FOLL_SPLIT_PMD) { int ret; page = pmd_page(*pmd); if (is_huge_zero_page(page)) { spin_unlock(ptl); ret = 0; split_huge_pmd(vma, pmd, address); if (pmd_trans_unstable(pmd)) ret = -EBUSY; } else { spin_unlock(ptl); split_huge_pmd(vma, pmd, address); ret = pte_alloc(mm, pmd) ? -ENOMEM : 0; } return ret ? ERR_PTR(ret) : follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); } page = follow_trans_huge_pmd(vma, address, pmd, flags); spin_unlock(ptl); ctx->page_mask = HPAGE_PMD_NR - 1; return page; }"
"void setrangeCommand(client *c) { robj *o; long offset; sds value = c->argv[3]->ptr; if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK) return; if (offset < 0) { addReplyError(c,""offset is out of range""); return; } o = lookupKeyWrite(c->db,c->argv[1]); if (o == NULL) { if (sdslen(value) == 0) { addReply(c,shared.czero); return; } if (checkStringLength(c,offset+sdslen(value)) != C_OK) return; o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value))); dbAdd(c->db,c->argv[1],o); } else { size_t olen; if (checkType(c,o,OBJ_STRING)) return; olen = stringObjectLen(o); if (sdslen(value) == 0) { addReplyLongLong(c,olen); return; } if (checkStringLength(c,offset+sdslen(value)) != C_OK) return; o = dbUnshareStringValue(c->db,c->argv[1],o); } if (sdslen(value) > 0) { o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value)); memcpy((char*)o->ptr+offset,value,sdslen(value)); signalModifiedKey(c,c->db,c->argv[1]); notifyKeyspaceEvent(NOTIFY_STRING, ""setrange"",c->argv[1],c->db->id); server.dirty++; } addReplyLongLong(c,sdslen(o->ptr)); }"
"static int write_node(FILE   *out, tree_t *t, int    col) { inti; uchar*ptr, *entity, *src, *realsrc, newsrc[1024]; if (out == NULL) return (0); switch (t->markup) { case MARKUP_NONE : if (t->data == NULL) break; if (t->preformatted) { for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); if (t->data[strlen((char *)t->data) - 1] == '\n') col = 0; else col += strlen((char *)t->data); } else { if ((col + (int)strlen((char *)t->data)) > 72 && col > 0) { putc('\n', out); col = 0; } for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); col += strlen((char *)t->data); if (col > 72) { putc('\n', out); col = 0; } } break; case MARKUP_COMMENT : case MARKUP_UNKNOWN : fputs(""\n<!--"", out); for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); fputs(""-->\n"", out); col = 0; break; case MARKUP_AREA : case MARKUP_BODY : case MARKUP_DOCTYPE : case MARKUP_ERROR : case MARKUP_FILE : case MARKUP_HEAD : case MARKUP_HTML : case MARKUP_MAP : case MARKUP_META : case MARKUP_TITLE : break; case MARKUP_BR : case MARKUP_CENTER : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_H7 : case MARKUP_H8 : case MARKUP_H9 : case MARKUP_H10 : case MARKUP_H11 : case MARKUP_H12 : case MARKUP_H13 : case MARKUP_H14 : case MARKUP_H15 : case MARKUP_HR : case MARKUP_LI : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TR : case MARKUP_UL : if (col > 0) { putc('\n', out); col = 0; } default : if (t->markup == MARKUP_IMG && OutputFiles && (src = htmlGetVariable(t, (uchar *)""SRC"")) != NULL && (realsrc = htmlGetVariable(t, (uchar *)""REALSRC"")) != NULL) { if (file_method((char *)src) == NULL && src[0] != '/' && src[0] != '\\' && (!isalpha(src[0]) || src[1] != ':')) { image_copy((char *)src, (char *)realsrc, OutputPath); strlcpy((char *)newsrc, file_basename((char *)src), sizeof(newsrc)); htmlSetVariable(t, (uchar *)""SRC"", newsrc); } } if (t->markup != MARKUP_EMBED) { col += fprintf(out, ""<%s"", _htmlMarkups[t->markup]); for (i = 0; i < t->nvars; i ++) { if (strcasecmp((char *)t->vars[i].name, ""BREAK"") == 0 && t->markup == MARKUP_HR) continue; if (strcasecmp((char *)t->vars[i].name, ""REALSRC"") == 0 && t->markup == MARKUP_IMG) continue; if (strncasecmp((char *)t->vars[i].name, ""_HD_"", 4) == 0) continue; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } if (col > 0) { putc(' ', out); col ++; } if (t->vars[i].value == NULL) col += fprintf(out, ""%s"", t->vars[i].name); else { col += fprintf(out, ""%s=\"""", t->vars[i].name); for (ptr = t->vars[i].value; *ptr; ptr ++) { entity = iso8859(*ptr); fputs((char *)entity, out); col += strlen((char *)entity); } putc('\""', out); col ++; } } putc('>', out); col ++; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } } break; } return (col); }"
"ssize_t _import_text(caca_canvas_t *cv, void const *data, size_t size) { char const *text = (char const *)data; unsigned int width = 0, height = 0, x = 0, y = 0, i; caca_set_canvas_size(cv, width, height); for(i = 0; i < size; i++) { unsigned char ch = *text++; if(ch == '\r') continue; if(ch == '\n') { x = 0; y++; continue; } if(x >= width || y >= height) { if(x >= width) width = x + 1; if(y >= height) height = y + 1; caca_set_canvas_size(cv, width, height); } caca_put_char(cv, x, y, ch); x++; } if(y > height) caca_set_canvas_size(cv, width, height = y); return (ssize_t)size; }"
"static int internal_get_user_pages_fast(unsigned long start, int nr_pages, unsigned int gup_flags, struct page **pages) { unsigned long addr, len, end; int nr_pinned = 0, ret = 0; if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM | FOLL_FORCE | FOLL_PIN | FOLL_GET))) return -EINVAL; start = untagged_addr(start) & PAGE_MASK; addr = start; len = (unsigned long) nr_pages << PAGE_SHIFT; end = start + len; if (end <= start) return 0; if (unlikely(!access_ok((void __user *)start, len))) return -EFAULT; if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) && gup_fast_permitted(start, end)) { local_irq_disable(); gup_pgd_range(addr, end, gup_flags, pages, &nr_pinned); local_irq_enable(); ret = nr_pinned; } if (nr_pinned < nr_pages) { start += nr_pinned << PAGE_SHIFT; pages += nr_pinned; ret = __gup_longterm_unlocked(start, nr_pages - nr_pinned, gup_flags, pages); if (nr_pinned > 0) { if (ret < 0) ret = nr_pinned; else ret += nr_pinned; } } return ret; }"
"static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid) { linenr_Tlnum; qfline_T*qfp; intold_KeyTyped = KeyTyped; list_T*qftf_list = NULL; listitem_T*qftf_li = NULL; if (old_last == NULL) { if (buf != curbuf) { internal_error(""qf_fill_buffer()""); return; } while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0) (void)ml_delete((linenr_T)1); } if (qfl != NULL) { char_udirname[MAXPATHL]; intinvalid_val = FALSE; intprev_bufnr = -1; *dirname = NUL; if (old_last == NULL) { qfp = qfl->qf_start; lnum = 0; } else { if (old_last->qf_next != NULL) qfp = old_last->qf_next; else qfp = old_last; lnum = buf->b_ml.ml_line_count; } qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1), (long)qfl->qf_count); if (qftf_list != NULL) qftf_li = qftf_list->lv_first; while (lnum < qfl->qf_count) { char_u*qftf_str = NULL; if (qftf_li != NULL && !invalid_val) { qftf_str = tv_get_string_chk(&qftf_li->li_tv); if (qftf_str == NULL) invalid_val = TRUE; } if (qf_buf_add_line(buf, lnum, qfp, dirname, prev_bufnr != qfp->qf_fnum, qftf_str) == FAIL) break; prev_bufnr = qfp->qf_fnum; ++lnum; qfp = qfp->qf_next; if (qfp == NULL) break; if (qftf_li != NULL) qftf_li = qftf_li->li_next; } if (old_last == NULL) (void)ml_delete(lnum + 1); } check_lnums(TRUE); if (old_last == NULL) { ++curbuf_lock; set_option_value_give_err((char_u *)""ft"", 0L, (char_u *)""qf"", OPT_LOCAL); curbuf->b_p_ma = FALSE; keep_filetype = TRUE;apply_autocmds(EVENT_BUFREADPOST, (char_u *)""quickfix"", NULL, FALSE, curbuf); apply_autocmds(EVENT_BUFWINENTER, (char_u *)""quickfix"", NULL, FALSE, curbuf); keep_filetype = FALSE; --curbuf_lock; redraw_curbuf_later(UPD_NOT_VALID); } KeyTyped = old_KeyTyped; }"
"static inline struct file *io_file_get(struct io_ring_ctx *ctx, struct io_kiocb *req, int fd, bool fixed) { if (fixed) return io_file_get_fixed(ctx, req, fd); else return io_file_get_normal(ctx, req, fd); }"
"int main(int argc, char **argv, char **envp) { int opt; while ((opt = getopt(argc, argv, ""b:h:k:p:q:w:z:xv"")) != -1) { switch (opt) { case 'b': tmate_settings->bind_addr = xstrdup(optarg); break; case 'h': tmate_settings->tmate_host = xstrdup(optarg); break; case 'k': tmate_settings->keys_dir = xstrdup(optarg); break; case 'p': tmate_settings->ssh_port = atoi(optarg); break; case 'q': tmate_settings->ssh_port_advertized = atoi(optarg); break; case 'w': tmate_settings->websocket_hostname = xstrdup(optarg); break; case 'z': tmate_settings->websocket_port = atoi(optarg); break; case 'x': tmate_settings->use_proxy_protocol = true; break; case 'v': tmate_settings->log_level++; break; default: usage(); return 1; } } init_logging(tmate_settings->log_level); setup_locale(); if (!tmate_settings->tmate_host) tmate_settings->tmate_host = get_full_hostname(); cmdline = *argv; cmdline_end = *envp; tmate_preload_trace_lib(); tmate_catch_sigsegv(); tmate_init_rand(); if ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) || (mkdir(TMATE_WORKDIR ""/sessions"", 0703) < 0 && errno != EEXIST) || (mkdir(TMATE_WORKDIR ""/jail"", 0700)     < 0 && errno != EEXIST)) tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR); if ((chmod(TMATE_WORKDIR, 0701)             < 0) || (chmod(TMATE_WORKDIR ""/sessions"", 0703) < 0) || (chmod(TMATE_WORKDIR ""/jail"", 0700)     < 0)) tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR); tmate_ssh_server_main(tmate_session, tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port); return 0; }"
"DataBuf packIfdId(const ExifData& exifData, IfdId     ifdId, ByteOrder byteOrder) { const uint16_t size = 1024; DataBuf buf(size); std::memset(buf.pData_, 0x0, buf.size_); uint16_t len = 0; const ExifData::const_iterator b = exifData.begin(); const ExifData::const_iterator e = exifData.end(); for (ExifData::const_iterator i = b; i != e; ++i) { if (i->ifdId() != ifdId) continue; const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size()); assert(s <= size); if (len < s) len = s; i->copy(buf.pData_ + i->tag()*2, byteOrder); } buf.size_ = len + len%2; return buf; }"
"void pt_restore_timer(struct vcpu *v) { struct list_head *head = &v->arch.hvm.tm_list; struct periodic_time *pt; spin_lock(&v->arch.hvm.tm_lock); list_for_each_entry ( pt, head, list ) { if ( pt->pending_intr_nr == 0 ) { pt_process_missed_ticks(pt); set_timer(&pt->timer, pt->scheduled); } } pt_thaw_time(v); spin_unlock(&v->arch.hvm.tm_lock); }"
"int _TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag) { switch (tag) { case TIFFTAG_PREDICTOR: case TIFFTAG_JPEGTABLES: case TIFFTAG_JPEGIFOFFSET: case TIFFTAG_JPEGIFBYTECOUNT: case TIFFTAG_JPEGQTABLES: case TIFFTAG_JPEGDCTABLES: case TIFFTAG_JPEGACTABLES: case TIFFTAG_JPEGPROC: case TIFFTAG_JPEGRESTARTINTERVAL: case TIFFTAG_BADFAXLINES: case TIFFTAG_CLEANFAXDATA: case TIFFTAG_CONSECUTIVEBADFAXLINES: case TIFFTAG_GROUP3OPTIONS: case TIFFTAG_GROUP4OPTIONS: case TIFFTAG_LERC_PARAMETERS: break; default: return 1; } switch (tif->tif_dir.td_compression) { case COMPRESSION_LZW: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_PACKBITS: break; case COMPRESSION_THUNDERSCAN: break; case COMPRESSION_NEXT: break; case COMPRESSION_JPEG: if (tag == TIFFTAG_JPEGTABLES) return 1; break; case COMPRESSION_OJPEG: switch (tag) { case TIFFTAG_JPEGIFOFFSET: case TIFFTAG_JPEGIFBYTECOUNT: case TIFFTAG_JPEGQTABLES: case TIFFTAG_JPEGDCTABLES: case TIFFTAG_JPEGACTABLES: case TIFFTAG_JPEGPROC: case TIFFTAG_JPEGRESTARTINTERVAL: return 1; } break; case COMPRESSION_CCITTRLE: case COMPRESSION_CCITTRLEW: case COMPRESSION_CCITTFAX3: case COMPRESSION_CCITTFAX4: switch (tag) { case TIFFTAG_BADFAXLINES: case TIFFTAG_CLEANFAXDATA: case TIFFTAG_CONSECUTIVEBADFAXLINES: return 1; case TIFFTAG_GROUP3OPTIONS: if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3) return 1; break; case TIFFTAG_GROUP4OPTIONS: if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) return 1; break; } break; case COMPRESSION_JBIG: break; case COMPRESSION_DEFLATE: case COMPRESSION_ADOBE_DEFLATE: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_PIXARLOG: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_SGILOG: case COMPRESSION_SGILOG24: break; case COMPRESSION_LZMA: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_ZSTD: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_LERC: if (tag == TIFFTAG_LERC_PARAMETERS) return 1; break; case COMPRESSION_WEBP: if (tag == TIFFTAG_PREDICTOR) return 1; break; } return 0; }"
"static void async_polkit_query_free(AsyncPolkitQuery *q) { if (!q) return; sd_bus_slot_unref(q->slot); if (q->registry && q->request) hashmap_remove(q->registry, q->request); sd_bus_message_unref(q->request); sd_bus_message_unref(q->reply); free(q->action); strv_free(q->details); free(q); }"
"static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind) { struct evtchn *lchn, *rchn; struct domain *ld = current->domain, *rd; int            lport, rport = bind->remote_port; domid_t        rdom = bind->remote_dom; long           rc; if ( rdom == DOMID_SELF ) rdom = current->domain->domain_id; if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL ) return -ESRCH; if ( ld < rd ) { spin_lock(&ld->event_lock); spin_lock(&rd->event_lock); } else { if ( ld != rd ) spin_lock(&rd->event_lock); spin_lock(&ld->event_lock); } if ( (lport = get_free_port(ld)) < 0 ) ERROR_EXIT(lport); lchn = evtchn_from_port(ld, lport); if ( !port_is_valid(rd, rport) ) ERROR_EXIT_DOM(-EINVAL, rd); rchn = evtchn_from_port(rd, rport); if ( (rchn->state != ECS_UNBOUND) || (rchn->u.unbound.remote_domid != ld->domain_id) ) ERROR_EXIT_DOM(-EINVAL, rd); rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn); if ( rc ) goto out; double_evtchn_lock(lchn, rchn); lchn->u.interdomain.remote_dom  = rd; lchn->u.interdomain.remote_port = rport; lchn->state                     = ECS_INTERDOMAIN; evtchn_port_init(ld, lchn); rchn->u.interdomain.remote_dom  = ld; rchn->u.interdomain.remote_port = lport; rchn->state                     = ECS_INTERDOMAIN; evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn); double_evtchn_unlock(lchn, rchn); bind->local_port = lport; out: check_free_port(ld, lport); spin_unlock(&ld->event_lock); if ( ld != rd ) spin_unlock(&rd->event_lock); rcu_unlock_domain(rd); return rc; }"
"GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge) { u32 i, j, chunk_size, track_num; u64 base_offset, data_offset, traf_duration; u32 def_duration, DescIndex, def_size, def_flags; u32 duration, size, flags, prev_trun_data_offset, sample_index; u8 pad, sync; u16 degr; Bool first_samp_in_traf=GF_TRUE; Bool store_traf_map=GF_FALSE; u8 *moof_template=NULL; u32 moof_template_size=0; Bool is_seg_start = GF_FALSE; u64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0; GF_TrackFragmentRunBox *trun; GF_TrunEntry *ent; #ifdef GF_ENABLE_CTRN GF_TrackFragmentBox *traf_ref = NULL; #endif GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack); GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack); GF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset); GF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk); GF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset); GF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap); GF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding); GF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority); if (trak->Header->trackID != traf->tfhd->trackID) return GF_OK; if (!trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample || !trak->Media->information->sampleTable->SampleToChunk || !trak->Media->information->sampleTable->ChunkOffset ) { return GF_ISOM_INVALID_FILE; } if (!traf->trex->track) traf->trex->track = trak; DescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index; if (!DescIndex) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to 0, likely broken ! Fixing to 1\n"" )); DescIndex = 1; } else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\n"", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))); DescIndex = 1; } #ifdef GF_ENABLE_CTRN if (traf->trex->inherit_from_traf_id) { u32 traf_count = gf_list_count(moof_box->TrackList); for (i=0; i<traf_count; i++) { GF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i); if (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) { traf_ref = atraf; break; } } } #endif def_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration; def_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size; def_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags; base_offset = moof_offset; if (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET) base_offset = traf->tfhd->base_data_offset; else if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET)) base_offset = *cumulated_offset; chunk_size = 0; prev_trun_data_offset = 0; data_offset = 0; traf_duration = 0; if (traf->tfdt && is_first_merge) { #ifndef GPAC_DISABLE_LOG if (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) { s32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start); if (drift<0)  { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Warning: TFDT timing ""LLD"" less than cumulated timing ""LLD"" - using tfdt\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start )); } else { GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[iso file] TFDT timing ""LLD"" higher than cumulated timing ""LLD"" (last sample got extended in duration)\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start )); } } #endif trak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime; } else if (traf->tfxd) { trak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale; } if (traf->tfxd) { trak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale; trak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale; } if (traf->tfrf) { if (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf); trak->tfrf = traf->tfrf; gf_list_del_item(traf->child_boxes, traf->tfrf); gf_list_add(trak->child_boxes, trak->tfrf); } if (trak->moov->mov->signal_frag_bounds) { store_traf_map = GF_TRUE; if (is_first_merge) { GF_MovieFragmentBox *moof_clone = NULL; gf_isom_box_freeze_order((GF_Box *)moof_box); gf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone); if (moof_clone) { GF_BitStream *bs; for (i=0; i<gf_list_count(moof_clone->TrackList); i++) { GF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes); if (traf_clone->sample_encryption) { gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption); traf_clone->sample_encryption = NULL; } if (traf_clone->sdtp) { gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp); traf_clone->sdtp = NULL; } } gf_isom_box_size((GF_Box *)moof_clone); bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); if (trak->moov->mov->seg_styp) { gf_isom_box_size(trak->moov->mov->seg_styp); gf_isom_box_write(trak->moov->mov->seg_styp, bs); } if (trak->moov->mov->root_sidx) { gf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx); gf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs); } if (trak->moov->mov->seg_ssix) { gf_isom_box_size(trak->moov->mov->seg_ssix); gf_isom_box_write(trak->moov->mov->seg_ssix, bs); } gf_isom_box_write((GF_Box *)moof_clone, bs); gf_isom_box_del((GF_Box*)moof_clone); gf_bs_get_content(bs, &moof_template, &moof_template_size); gf_bs_del(bs); } } if (trak->moov->mov->seg_styp) { is_seg_start = GF_TRUE; seg_start = trak->moov->mov->styp_start_offset; } if (trak->moov->mov->root_sidx) { is_seg_start = GF_TRUE; sidx_start = trak->moov->mov->sidx_start_offset; sidx_end = trak->moov->mov->sidx_end_offset; if (! seg_start || (sidx_start<seg_start)) seg_start = sidx_start; } frag_start = trak->moov->mov->current_top_box_start; } else if (trak->moov->mov->store_traf_map) { store_traf_map = GF_TRUE; } sample_index = 0; i=0; while ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) { for (j=0; j<trun->sample_count; j++) { GF_Err e; s32 cts_offset=0; if (j<trun->nb_samples) { ent = &trun->samples[j]; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\n"", traf->trex->trackID, trun->nb_samples, trun->sample_count )); break; } size = def_size; duration = def_duration; flags = def_flags; cts_offset = ent->CTS_Offset; #ifdef GF_ENABLE_CTRN if (trun->use_ctrn) { if (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) { if (trun->ctrn_first_dur) duration = ent->Duration; if (trun->ctrn_first_size) size = ent->size; if (trun->ctrn_first_ctts) flags = ent->flags; } else { if (trun->ctrn_dur) duration = ent->Duration; if (trun->ctrn_size) size = ent->size; if (trun->ctrn_sample_flags) flags = ent->flags; } if (trun->ctrn_flags & 0xF0) { GF_TrunEntry *ref_entry; if (!traf_ref) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\n"", traf->trex->trackID, traf->trex->inherit_from_traf_id )); break; } ref_entry = traf_get_sample_entry(traf_ref, sample_index); if (!ref_entry) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance but sample %d not found in reference traf\n"", traf->trex->trackID, sample_index+1 )); break; } if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR) duration = ref_entry->Duration; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE) size = ref_entry->size; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS) flags = ref_entry->flags; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO) cts_offset = ref_entry->CTS_Offset; } } else #endif { if (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration; if (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size; if (trun->flags & GF_ISOM_TRUN_FLAGS) { flags = ent->flags; } else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) { flags = trun->first_sample_flags; } } sample_index++; ent->size = size; ent->Duration = duration; ent->flags = flags; ent->CTS_Offset = cts_offset; last_dts += duration; if (!trak->Media->information->sampleTable->SampleSize) { trak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ); if (!trak->Media->information->sampleTable->SampleSize) return GF_OUT_OF_MEM; } e = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack); if (e) return e; if (!trak->Media->information->sampleTable->TimeToSample) { trak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS); if (!trak->Media->information->sampleTable->TimeToSample) return GF_OUT_OF_MEM; } e = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack); if (e) return e; if (!j) { u64 final_offset; data_offset = base_offset; if (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) { data_offset += trun->data_offset; chunk_size = 0; prev_trun_data_offset = trun->data_offset; if (trun->data_offset>=0) { data_offset -= compressed_diff; prev_trun_data_offset -= compressed_diff; } } else if (prev_trun_data_offset) { data_offset += prev_trun_data_offset + chunk_size; } else { data_offset += chunk_size; if ((i==1) && (trun->data_offset>=0)) { data_offset -= compressed_diff; } } final_offset = data_offset; if (trak->moov->compressed_diff) { final_offset += trak->moov->compressed_diff; } if (!trak->Media->information->sampleTable->ChunkOffset) { trak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO); if (!trak->Media->information->sampleTable->ChunkOffset) return GF_OUT_OF_MEM; } e = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset); if (e) return e; if (!trak->Media->information->sampleTable->SampleToChunk) { trak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC); if (!trak->Media->information->sampleTable->SampleToChunk) return GF_OUT_OF_MEM; } e = stbl_AppendSampleToChunk(trak->Media->information->sampleTable, DescIndex, trun->sample_count); if (e) return e; } chunk_size += size; if (store_traf_map && first_samp_in_traf) { first_samp_in_traf = GF_FALSE; e = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end); if (e) return e; moof_template = NULL; moof_template_size = 0; } if (ent->nb_pack>1) { j+= ent->nb_pack-1; traf_duration += ent->nb_pack*duration; continue; } traf_duration += duration; e = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset); if (e) return e; sync = GF_ISOM_GET_FRAG_SYNC(flags); if (trak->Media->information->sampleTable->no_sync_found && sync) { trak->Media->information->sampleTable->no_sync_found = 0; } e = stbl_AppendRAP(trak->Media->information->sampleTable, sync); if (e) return e; pad = GF_ISOM_GET_FRAG_PAD(flags); if (pad) { e = stbl_AppendPadding(trak->Media->information->sampleTable, pad); if (e) return e; } degr = GF_ISOM_GET_FRAG_DEG(flags); if (degr) { e = stbl_AppendDegradation(trak->Media->information->sampleTable, degr); if (e) return e; } e = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags)); if (e) return e; } } if (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) { if (is_first_merge) trak->dts_at_seg_start = trak->dts_at_next_seg_start; trak->dts_at_next_seg_start += last_dts; } if (traf_duration && trak->editBox && trak->editBox->editList) { for (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) { GF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i); if (edts_e->was_empty_dur) { u64 extend_dur = traf_duration; extend_dur *= trak->moov->mvhd->timeScale; extend_dur /= trak->Media->mediaHeader->timeScale; edts_e->segmentDuration += extend_dur; } else if (!edts_e->segmentDuration) { edts_e->was_empty_dur = GF_TRUE; if ((s64) traf_duration > edts_e->mediaTime) traf_duration -= edts_e->mediaTime; else traf_duration = 0; edts_e->segmentDuration = traf_duration; edts_e->segmentDuration *= trak->moov->mvhd->timeScale; edts_e->segmentDuration /= trak->Media->mediaHeader->timeScale; } } } *cumulated_offset = data_offset + chunk_size; if (traf->sampleGroups) { GF_List *groups; GF_List *groupDescs; Bool is_identical_sgpd = GF_TRUE; u32 *new_idx = NULL, new_idx_count=0; if (!trak->Media->information->sampleTable->sampleGroups) trak->Media->information->sampleTable->sampleGroups = gf_list_new(); if (!trak->Media->information->sampleTable->sampleGroupsDescription) trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new(); groupDescs = trak->Media->information->sampleTable->sampleGroupsDescription; for (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) { GF_SampleGroupDescriptionBox *new_sgdesc = NULL; GF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i); for (j=0; j<gf_list_count(groupDescs); j++) { new_sgdesc = gf_list_get(groupDescs, j); if (new_sgdesc->grouping_type==sgdesc->grouping_type) break; new_sgdesc = NULL; } if (!new_sgdesc) { gf_list_add(groupDescs, sgdesc); gf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc); gf_list_rem(traf->sampleGroupsDescription, i); gf_list_del_item(traf->child_boxes, sgdesc); i--; } else { u32 count; is_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0); if (is_identical_sgpd) continue; new_idx_count = gf_list_count(sgdesc->group_descriptions); new_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32)); if (!new_idx) return GF_OUT_OF_MEM; count = 0; while (gf_list_count(sgdesc->group_descriptions)) { void *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0); Bool new_entry = GF_TRUE; for (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) { void *ptr = gf_list_get(new_sgdesc->group_descriptions, j); if (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) { new_idx[count] = j + 1; count ++; new_entry = GF_FALSE; gf_free(sgpd_entry); break; } } if (new_entry) { gf_list_add(new_sgdesc->group_descriptions, sgpd_entry); new_idx[count] = gf_list_count(new_sgdesc->group_descriptions); count ++; } gf_list_rem(sgdesc->group_descriptions, 0); } } } groups = trak->Media->information->sampleTable->sampleGroups; for (i=0; i<gf_list_count(traf->sampleGroups); i++) { GF_SampleGroupBox *stbl_group = NULL; GF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i); for (j=0; j<gf_list_count(groups); j++) { stbl_group = gf_list_get(groups, j); if ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter)) break; stbl_group = NULL; } if (!stbl_group) { stbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP); if (!stbl_group) return GF_OUT_OF_MEM; stbl_group->grouping_type = frag_group->grouping_type; stbl_group->grouping_type_parameter = frag_group->grouping_type_parameter; stbl_group->version = frag_group->version; gf_list_add(groups, stbl_group); } if (is_identical_sgpd) { for (j = 0; j < frag_group->entry_count; j++) frag_group->sample_entries[j].group_description_index &= 0x0FFFF; if (frag_group->entry_count && stbl_group->entry_count && (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index) ) { stbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count; if (frag_group->entry_count>1) { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1)); memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1)); stbl_group->entry_count += frag_group->entry_count - 1; } } else { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count)); memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count); stbl_group->entry_count += frag_group->entry_count; } } else { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count)); for (j = 0; j < frag_group->entry_count; j++) { u32 sgidx = frag_group->sample_entries[j].group_description_index; if (sgidx > 0x10000) { sgidx -= 0x10001; if (sgidx>=new_idx_count) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\n"", sgidx, new_idx_count)); } else { frag_group->sample_entries[j].group_description_index = new_idx[sgidx]; } } } memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count); stbl_group->entry_count += frag_group->entry_count; } } if (new_idx) gf_free(new_idx); } track_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID); if (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex) || traf->sample_encryption) { GF_SampleEncryptionBox *senc = NULL; u32 scheme_type; gf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL); if (traf->sample_encryption) { for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) { GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i); if (a->type != traf->sample_encryption->type) continue; if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) { senc = (GF_SampleEncryptionBox *)a; break; } else if (a->type ==GF_ISOM_BOX_TYPE_SENC) { senc = (GF_SampleEncryptionBox *)a; break; } } if (!senc && trak->sample_encryption) senc = trak->sample_encryption; if (!senc) { if (traf->sample_encryption->piff_type==1) { senc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL); } else { senc = gf_isom_create_samp_enc_box(1, 0x2); } if (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new(); trak->sample_encryption = senc; if (!trak->child_boxes) trak->child_boxes = gf_list_new(); gf_list_add(trak->child_boxes, senc); } } if (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) { u32 nb_saio; u32 aux_info_type; u64 offset; GF_Err e; Bool is_encrypted; GF_SampleAuxiliaryInfoOffsetBox *saio = NULL; GF_SampleAuxiliaryInfoSizeBox *saiz = NULL; offset = nb_saio = 0; for (i = 0; i < gf_list_count(traf->sai_offsets); i++) { saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i); aux_info_type = saio->aux_info_type; if (!aux_info_type) aux_info_type = scheme_type; if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) || (aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) || (gf_list_count(traf->sai_offsets) == 1)) { offset = saio->offsets[0] + moof_offset; nb_saio = saio->entry_count; break; } } for (i = 0; i < gf_list_count(traf->sai_sizes); i++) { saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i); aux_info_type = saiz->aux_info_type; if (!aux_info_type) aux_info_type = scheme_type; if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) || (aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) || (gf_list_count(traf->sai_sizes) == 1)) { break; } } if (saiz && saio) { for (i = 0; i < saiz->sample_count; i++) { GF_CENCSampleAuxInfo *sai; const u8 *key_info=NULL; u32 key_info_size; u64 cur_position; if (nb_saio != 1) offset = saio->offsets[i] + moof_offset; size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i]; cur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs); gf_bs_seek(trak->moov->mov->movieFileMap->bs, offset); GF_SAFEALLOC(sai, GF_CENCSampleAuxInfo); if (!sai) return GF_OUT_OF_MEM; e = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isobmf] could not get cenc info for sample %d: %s\n"", i+1, gf_error_to_string(e) )); return e; } if (is_encrypted) { sai->cenc_data_size = size; sai->cenc_data = gf_malloc(sizeof(u8)*size); if (!sai->cenc_data) return GF_OUT_OF_MEM; gf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size); } else { sai->isNotProtected=1; } if (key_info) { if (!key_info[0]) { if (size > key_info[3]) senc->flags = 0x00000002; } else { senc->flags = 0x00000002; } } gf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position); gf_list_add(senc->samp_aux_info, sai); e = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size); if (e) return e; if (nb_saio == 1) offset += size; } } } else if (traf->sample_encryption) { senc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption); trak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID; if (!trak->sample_encryption->IV_size) trak->sample_encryption->IV_size = traf->sample_encryption->IV_size; if (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new(); gf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info); if (traf->sample_encryption->flags & 0x00000002) trak->sample_encryption->flags |= 0x00000002; } } return GF_OK; }"
"static int SetupSavePath(const DetectEngineCtx *de_ctx, char *save, size_t save_size) { SCLogDebug(""save %s"", save); if (PathIsAbsolute(save)) { return 0; } const char *dir = ConfigGetDataDirectory(); BUG_ON(dir == NULL);     char path[PATH_MAX]; if (snprintf(path, sizeof(path), ""%s/%s"", dir, save) >= (int)sizeof(path))         return -1; strlcpy(save, path, save_size); return 0; }"
"BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) { int i; BYTE iBitmapFormat; BOOL compressed = FALSE; if (!Stream_EnsureRemainingCapacity(s, update_approximate_cache_brush_order(cache_brush, flags))) return FALSE; iBitmapFormat = BPP_BMF[cache_brush->bpp]; Stream_Write_UINT8(s, cache_brush->index);   Stream_Write_UINT8(s, iBitmapFormat);        Stream_Write_UINT8(s, cache_brush->cx);      Stream_Write_UINT8(s, cache_brush->cy);      Stream_Write_UINT8(s, cache_brush->style);   Stream_Write_UINT8(s, cache_brush->length);  if ((cache_brush->cx == 8) && (cache_brush->cy == 8)) { if (cache_brush->bpp == 1) { if (cache_brush->length != 8) { WLog_ERR(TAG, ""incompatible 1bpp brush of length:%"" PRIu32 """", cache_brush->length); return FALSE; } for (i = 7; i >= 0; i--) { Stream_Write_UINT8(s, cache_brush->data[i]); } } else { if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20)) compressed = TRUE; else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24)) compressed = TRUE; else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32)) compressed = TRUE; if (compressed != FALSE) { if (!update_compress_brush(s, cache_brush->data, cache_brush->bpp)) return FALSE; } else { int scanline = (cache_brush->bpp / 8) * 8; for (i = 7; i >= 0; i--) { Stream_Write(s, &cache_brush->data[i * scanline], scanline); } } } } return TRUE; }"
"static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs) { GF_Err e; u32 NodeID, ind, field_ind, NumBits; GF_Node *node; GF_ChildNodeItem *prev_child; GF_FieldInfo field; NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); node = gf_sg_find_node(codec->current_graph, NodeID); if (!node) return GF_NON_COMPLIANT_BITSTREAM; NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1); ind = gf_bs_read_int(bs, NumBits); e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind); if (e) return e; e = gf_node_get_field(node, field_ind, &field); if (e) return e; prev_child = NULL; if (field.fieldType == GF_SG_VRML_MFNODE) { prev_child = * ((GF_ChildNodeItem **) field.far_ptr); * ((GF_ChildNodeItem **) field.far_ptr) = NULL; } else if (!gf_sg_vrml_is_sf_field(field.fieldType)) { gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType); } codec->is_com_dec = GF_TRUE; e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE); codec->is_com_dec = GF_FALSE; if (field.fieldType == GF_SG_VRML_MFNODE) { gf_node_unregister_children(node, prev_child); } if (!e) gf_bifs_check_field_change(node, &field); return e; }"
"static void chrc_write_cb(struct gatt_db_attribute *attrib, unsigned int id, uint16_t offset, const uint8_t *value, size_t len, uint8_t opcode, struct bt_att *att, void *user_data) { struct external_chrc *chrc = user_data; struct btd_device *device; struct queue *queue; DBusMessageIter iter; if (chrc->attrib != attrib) { error(""Write callback called with incorrect attribute""); goto fail; } device = att_get_device(att); if (!device) { error(""Unable to find device object""); goto fail; } if (!(chrc->props & BT_GATT_CHRC_PROP_WRITE_WITHOUT_RESP)) queue = chrc->pending_writes; else queue = NULL; if (opcode == BT_ATT_OP_PREP_WRITE_REQ) { if (!device_is_trusted(device) && !chrc->prep_authorized && chrc->req_prep_authorization) send_write(device, attrib, chrc->proxy, queue, id, value, len, offset, bt_att_get_link_type(att), true, true); else gatt_db_attribute_write_result(attrib, id, 0); return; } if (opcode == BT_ATT_OP_EXEC_WRITE_REQ) chrc->prep_authorized = false; if (chrc->write_io) { if (sock_io_send(chrc->write_io, value, len) < 0) { error(""Unable to write: %s"", strerror(errno)); goto fail; } gatt_db_attribute_write_result(attrib, id, 0); return; } if (g_dbus_proxy_get_property(chrc->proxy, ""WriteAcquired"", &iter)) { if (acquire_write(chrc, device, attrib, id, value, len, bt_att_get_link_type(att))) return; } if (send_write(device, attrib, chrc->proxy, queue, id, value, len, offset, bt_att_get_link_type(att), false, false)) return; fail: gatt_db_attribute_write_result(attrib, id, BT_ATT_ERROR_UNLIKELY); }"
"void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input, typename TTypes<T, 3>::ConstTensor filter, typename TTypes<T, 4>::ConstTensor out_backprop, int stride_rows, int stride_cols, int rate_rows, int rate_cols, int pad_top, int pad_left, typename TTypes<T, 3>::Tensor filter_backprop) { const int batch = input.dimension(0); const int input_rows = input.dimension(1); const int input_cols = input.dimension(2); const int depth = input.dimension(3); const int filter_rows = filter.dimension(0); const int filter_cols = filter.dimension(1); const int output_rows = out_backprop.dimension(1); const int output_cols = out_backprop.dimension(2); filter_backprop.setZero(); for (int b = 0; b < batch; ++b) { for (int h_out = 0; h_out < output_rows; ++h_out) { int h_beg = h_out * stride_rows - pad_top; for (int w_out = 0; w_out < output_cols; ++w_out) { int w_beg = w_out * stride_cols - pad_left; for (int d = 0; d < depth; ++d) { T cur_val = Eigen::NumTraits<T>::lowest(); int h_max = 0; int w_max = 0; for (int h = 0; h < filter_rows; ++h) { const int h_in = h_beg + h * rate_rows; if (h_in >= 0 && h_in < input_rows) { for (int w = 0; w < filter_cols; ++w) { const int w_in = w_beg + w * rate_cols; if (w_in >= 0 && w_in < input_cols) { const T val = input(b, h_in, w_in, d) + filter(h, w, d); if (val > cur_val) { cur_val = val; h_max = h; w_max = w; } } } } } filter_backprop(h_max, w_max, d) += out_backprop(b, h_out, w_out, d); } } } } }"
"int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols) { int rc; pr_debug(""dev_name %s initiator protocols 0x%x target protocols 0x%x\n"", dev_name(&dev->dev), im_protocols, tm_protocols); if (!im_protocols && !tm_protocols) return -EINVAL; device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (!dev->dev_up) { rc = -ENODEV; goto error; } if (dev->polling) { rc = -EBUSY; goto error; } rc = dev->ops->start_poll(dev, im_protocols, tm_protocols); if (!rc) { dev->polling = true; dev->rf_mode = NFC_RF_NONE; } error: device_unlock(&dev->dev); return rc; }"
"inline void Conv3DTranspose( const Conv3DTransposeParams& params, const RuntimeShape& input_shape, const float* input_data, const RuntimeShape& filter_shape, const float* filter_data, const RuntimeShape& bias_shape, const float* bias_data, const RuntimeShape& output_shape, float* output_data) { const int stride_width = params.stride_width; const int stride_height = params.stride_height; const int stride_depth = params.stride_depth; const int pad_width = params.padding_values.width; const int pad_height = params.padding_values.height; const int pad_depth = params.padding_values.depth; TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 5); TFLITE_DCHECK_EQ(filter_shape.DimensionsCount(), 5); TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 5); const int batches = MatchingDim(input_shape, 0, output_shape, 0); const int input_num_channels = MatchingDim(input_shape, 4, filter_shape, 4); const int output_num_channels = output_shape.Dims(4); const int input_depth = input_shape.Dims(1); const int input_height = input_shape.Dims(2); const int input_width = input_shape.Dims(3); const int filter_depth = filter_shape.Dims(0); const int filter_height = filter_shape.Dims(1); const int filter_width = filter_shape.Dims(2); const int output_depth = output_shape.Dims(1); const int output_height = output_shape.Dims(2); const int output_width = output_shape.Dims(3); if (bias_data) { TFLITE_DCHECK_EQ(bias_shape.FlatSize(), output_num_channels); } const int num_elements = output_shape.FlatSize(); for (int i = 0; i < num_elements; i++) { output_data[i] = 0.0f; } for (int batch = 0; batch < batches; ++batch) { for (int in_d = 0; in_d < input_depth; ++in_d) { for (int in_y = 0; in_y < input_height; ++in_y) { for (int in_x = 0; in_x < input_width; ++in_x) { for (int in_channel = 0; in_channel < input_num_channels; ++in_channel) { const int out_x_origin = (in_x * stride_width) - pad_width; const int out_y_origin = (in_y * stride_height) - pad_height; const int out_d_origin = (in_d * stride_depth) - pad_depth; for (int filter_d = 0; filter_d < filter_depth; ++filter_d) { for (int filter_y = 0; filter_y < filter_height; ++filter_y) { for (int filter_x = 0; filter_x < filter_width; ++filter_x) { for (int out_channel = 0; out_channel < output_num_channels; ++out_channel) { const int out_x = out_x_origin + params.dilation_width * filter_x; const int out_y = out_y_origin + params.dilation_height * filter_y; const int out_d = out_d_origin + params.dilation_depth * filter_d; if ((out_x >= 0) && (out_x < output_width) && (out_y >= 0) && (out_y < output_height) && (out_d >= 0) && (out_d < output_depth)) { float input_value = input_data[Offset( input_shape, batch, in_d, in_y, in_x, in_channel)]; float filter_value = filter_data[Offset( filter_shape, filter_d, filter_y, filter_x, out_channel, in_channel)]; output_data[Offset(output_shape, batch, out_d, out_y, out_x, out_channel)] += input_value * filter_value; } } } } } } } } } } const float float_activation_min = params.float_activation_min; const float float_activation_max = params.float_activation_max; float* data_ptr = output_data; if (bias_data) { const int outer_size = batches * output_depth * output_height * output_width; const int num_channels = input_shape.Dims(4); for (int n = 0; n < outer_size; ++n) { for (int c = 0; c < output_num_channels; ++c) { data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c], float_activation_min, float_activation_max); } data_ptr += num_channels; } } else { const int flat_size = output_shape.FlatSize(); for (int i = 0; i < flat_size; ++i) { data_ptr[i] = ActivationFunctionWithMinMax( data_ptr[i], float_activation_min, float_activation_max); } } }"
"TEE_Result crypto_mac_alloc_ctx(void **ctx_ret, uint32_t algo) { TEE_Result res; size_t ctx_size; void *ctx; res = mac_get_ctx_size(algo, &ctx_size); if (res) return res; ctx = calloc(1, ctx_size); if (!ctx) return TEE_ERROR_OUT_OF_MEMORY; *ctx_ret = ctx; return TEE_SUCCESS; }"
"static int wav_fmt(wav_reader_t *reader, uint32_t size) { uint16_t wFormatTag, nChannels, nBlockAlign, wBitsPerSample, cbSize; uint32_t nSamplesPerSec, nAvgBytesPerSec, dwChannelMask = 0; uint16_t wValidBitsPerSample; uint8_t guid[16]; int is_float = 0; ENSURE(size >= 16); TRY_IO(pcm_scanl(&reader->io, ""SSLLSS"", &wFormatTag, &nChannels, &nSamplesPerSec, &nAvgBytesPerSec, &nBlockAlign, &wBitsPerSample) != 6); wValidBitsPerSample = wBitsPerSample; ENSURE(wFormatTag == 1 || wFormatTag == 3 || wFormatTag == 0xfffe); ENSURE(nChannels && nSamplesPerSec && nAvgBytesPerSec && nBlockAlign && wBitsPerSample && !(wBitsPerSample & 7) && nBlockAlign == nChannels * wBitsPerSample / 8); if (wFormatTag == 3) is_float = 1; if (wFormatTag != 0xfffe) TRY_IO(pcm_skip(&reader->io, (size - 15) & ~1)); else { ENSURE(size >= 40); TRY_IO(pcm_scanl(&reader->io, ""SSL"", &cbSize, &wValidBitsPerSample, &dwChannelMask) != 3); TRY_IO(pcm_read(&reader->io, guid, 16) != 16); if (memcmp(guid, WAV_GUID_FLOAT, 16) == 0) is_float = 1; else if (memcmp(guid, WAV_GUID_PCM, 16) != 0) goto FAIL; ENSURE(wValidBitsPerSample && wValidBitsPerSample <= wBitsPerSample); TRY_IO(pcm_skip(&reader->io, (size - 39) & ~1)); } reader->sample_format.sample_rate = nSamplesPerSec; reader->sample_format.bits_per_channel = wValidBitsPerSample; reader->sample_format.bytes_per_frame = nBlockAlign; reader->sample_format.channels_per_frame = nChannels; reader->sample_format.channel_mask = dwChannelMask; if (is_float) reader->sample_format.sample_type = PCM_TYPE_FLOAT; else if (wBitsPerSample == 8) reader->sample_format.sample_type = PCM_TYPE_UINT; else reader->sample_format.sample_type = PCM_TYPE_SINT; return 0; FAIL: return -1; }"
"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr) { AVC_SPS *sps; s32 mb_width, mb_height, sps_id = -1; u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd; u8 separate_colour_plane_flag = 0; if (!vui_flag_pos) { gf_bs_enable_emulation_byte_removal(bs, GF_TRUE); } if (!bs) { return -1; } if (!nal_hdr) { gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit""); gf_bs_read_int_log(bs, 2, ""nal_ref_idc""); gf_bs_read_int_log(bs, 5, ""nal_unit_type""); } profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc""); pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility""); if (pcomp & 0x3) return -1; level_idc = gf_bs_read_int_log(bs, 8, ""level_idc""); sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps; if (sps_id >= 32) { return -1; } if (sps_id < 0) { return -1; } luma_bd = chroma_bd = 0; sps = &avc->sps[sps_id]; chroma_format_idc = sps->ChromaArrayType = 1; sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED; switch (profile_idc) { case 100: case 110: case 122: case 244: case 44: if (pcomp & 0xE0) return -1; case 83: case 86: case 118: case 128: chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc""); sps->ChromaArrayType = chroma_format_idc; if (chroma_format_idc == 3) { separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag""); if (separate_colour_plane_flag) sps->ChromaArrayType = 0; } luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth""); chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth""); gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag""); if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) { u32 k; for (k = 0; k < 8; k++) { if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) { u32 z, last = 8, next = 8; u32 sl = k < 6 ? 16 : 64; for (z = 0; z < sl; z++) { if (next) { s32 delta = gf_bs_read_se(bs); next = (last + delta + 256) % 256; } last = next ? next : last; } } } } break; } sps->profile_idc = profile_idc; sps->level_idc = level_idc; sps->prof_compat = pcomp; sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4; sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type""); sps->chroma_format = chroma_format_idc; sps->luma_bit_depth_m8 = luma_bd; sps->chroma_bit_depth_m8 = chroma_bd; if (sps->poc_type == 0) { sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4; } else if (sps->poc_type == 1) { sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag""); sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic""); sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field""); sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length""); if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n"")); return -1; } for (i = 0; i < sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i); } if (sps->poc_type > 2) { return -1; } sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames""); sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag""); mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1; mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1; sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag""); sps->width = mb_width * 16; sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16; if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag""); gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag""); if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) { int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1; if (chroma_format_idc == 1) { SubWidthC = 2; SubHeightC = 2; } else if (chroma_format_idc == 2) { SubWidthC = 2; SubHeightC = 1; } else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) { SubWidthC = 1; SubHeightC = 1; } if (sps->ChromaArrayType == 0) { assert(SubWidthC == -1); CropUnitX = 1; CropUnitY = 2 - sps->frame_mbs_only_flag; } else { CropUnitX = SubWidthC; CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag); } cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset""); cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset""); ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset""); cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset""); sps->width -= CropUnitX * (cl + cr); sps->height -= CropUnitY * (ct + cb); cl *= CropUnitX; cr *= CropUnitX; ct *= CropUnitY; cb *= CropUnitY; } sps->crop.left = cl; sps->crop.right = cr; sps->crop.top = ct; sps->crop.bottom = cb; if (vui_flag_pos) { *vui_flag_pos = (u32)gf_bs_get_bit_offset(bs); } sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag""); if (sps->vui_parameters_present_flag) { sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag""); if (sps->vui.aspect_ratio_info_present_flag) { s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc""); if (aspect_ratio_idc == 255) { sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num""); sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den""); } else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) { sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w; sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n"")); } } sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag""); if (sps->vui.overscan_info_present_flag) gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag""); sps->vui.video_format = 5; sps->vui.colour_primaries = 2; sps->vui.transfer_characteristics = 2; sps->vui.matrix_coefficients = 2; sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag""); if (sps->vui.video_signal_type_present_flag) { sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format""); sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag""); sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag""); if (sps->vui.colour_description_present_flag) { sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries""); sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics""); sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients""); } } if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) { gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field""); gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field""); } sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag""); if (sps->vui.timing_info_present_flag) { sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick""); sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale""); sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag""); } sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag""); if (sps->vui.nal_hrd_parameters_present_flag) avc_parse_hrd_parameters(bs, &sps->vui.hrd); sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag""); if (sps->vui.vcl_hrd_parameters_present_flag) avc_parse_hrd_parameters(bs, &sps->vui.hrd); if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag) sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag""); sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag""); } if (subseq_sps) { if ((profile_idc == 83) || (profile_idc == 86)) { u8 extended_spatial_scalability_idc; gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag""); extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc""); if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) { gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag""); } if (sps->ChromaArrayType == 1) { gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1""); } if (extended_spatial_scalability_idc == 1) { if (sps->ChromaArrayType > 0) { gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag""); gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1""); } gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset""); } if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) { gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag""); } gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag""); if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) { u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1""); for (i = 0; i <= vui_ext_num_entries_minus1; i++) { u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag; gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id""); gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id""); gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id""); vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag""); if (vui_ext_timing_info_present_flag) { gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick""); gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale""); gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag""); } vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag""); if (vui_ext_nal_hrd_parameters_present_flag) { } vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag""); if (vui_ext_vcl_hrd_parameters_present_flag) { } if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) { gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag""); } gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag""); } } } else if ((profile_idc == 118) || (profile_idc == 128)) { GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n"")); return sps_id; } if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n"")); return sps_id; } } return sps_id; }"
"static int qdisc_graft(struct net_device *dev, struct Qdisc *parent, struct sk_buff *skb, struct nlmsghdr *n, u32 classid, struct Qdisc *new, struct Qdisc *old, struct netlink_ext_ack *extack) { struct Qdisc *q = old; struct net *net = dev_net(dev); if (parent == NULL) { unsigned int i, num_q, ingress; ingress = 0; num_q = dev->num_tx_queues; if ((q && q->flags & TCQ_F_INGRESS) || (new && new->flags & TCQ_F_INGRESS)) { num_q = 1; ingress = 1; if (!dev_ingress_queue(dev)) { NL_SET_ERR_MSG(extack, ""Device does not have an ingress queue""); return -ENOENT; } } if (dev->flags & IFF_UP) dev_deactivate(dev); qdisc_offload_graft_root(dev, new, old, extack); if (new && new->ops->attach && !ingress) goto skip; for (i = 0; i < num_q; i++) { struct netdev_queue *dev_queue = dev_ingress_queue(dev); if (!ingress) dev_queue = netdev_get_tx_queue(dev, i); old = dev_graft_qdisc(dev_queue, new); if (new && i > 0) qdisc_refcount_inc(new); if (!ingress) qdisc_put(old); } skip: if (!ingress) { old = rtnl_dereference(dev->qdisc); if (new && !new->ops->attach) qdisc_refcount_inc(new); rcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc); notify_and_destroy(net, skb, n, classid, old, new); if (new && new->ops->attach) new->ops->attach(new); } else { notify_and_destroy(net, skb, n, classid, old, new); } if (dev->flags & IFF_UP) dev_activate(dev); } else { const struct Qdisc_class_ops *cops = parent->ops->cl_ops; unsigned long cl; int err; if (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK)) qdisc_clear_nolock(new); if (!cops || !cops->graft) return -EOPNOTSUPP; cl = cops->find(parent, classid); if (!cl) { NL_SET_ERR_MSG(extack, ""Specified class not found""); return -ENOENT; } err = cops->graft(parent, cl, new, &old, extack); if (err) return err; notify_and_destroy(net, skb, n, classid, old, new); } return 0; }"
"gint wimax_decode_dlmapc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *base_tree) { guint offset = 0; proto_item *ti = NULL; proto_item *ti_phy = NULL; proto_item *ti_dlmap_ies = NULL; proto_tree *tree = NULL; proto_tree *ie_tree = NULL; proto_tree *phy_tree = NULL; gint ulmap_appended; guint length, lennib, pad; guint mac_len, dl_ie_count; guint tvb_len = tvb_reported_length(tvb); guint nib = 0; guint32 mac_crc, calculated_crc; col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, ""Compressed DL-MAP""); INC_CID = 0; length = tvb_get_ntohs(tvb, offset) & 0x07FF;  mac_len = length; lennib = BYTE_TO_NIB(length); ulmap_appended = (tvb_get_guint8(tvb, offset) >> 4) & 1;  ti = proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, offset, length, ""Compressed DL-MAP (%u bytes)"", length); tree = proto_item_add_subtree(ti, ett_305); proto_tree_add_item(tree, hf_dlmapc_compr, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_ulmap, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_rsv, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_len, tvb, offset, 2, ENC_BIG_ENDIAN); { phy_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_275_phy, &ti_phy, ""Phy Synchronization Field""); proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_ms, tvb, offset+2, 1, ENC_BIG_ENDIAN); proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_per_sec, tvb, offset+2, 1, ENC_BIG_ENDIAN); proto_tree_add_item(phy_tree, hf_dlmap_phy_fnum, tvb, offset+3, 3, ENC_BIG_ENDIAN); } proto_tree_add_item(tree, hf_dlmap_dcd,   tvb, offset+6, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_opid, tvb, offset+7, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_secid,tvb, offset+8, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmap_ofdma_sym, tvb, offset+9, 1, ENC_BIG_ENDIAN);  proto_tree_add_item(tree, hf_dlmapc_count,tvb, offset+10,1, ENC_BIG_ENDIAN); dl_ie_count = tvb_get_guint8(tvb, offset + 10); offset += 11; nib = BYTE_TO_NIB(offset); length -= 15;  if (dl_ie_count) { ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, length, ett_dlmap_ie, &ti_dlmap_ies, ""DL-MAP IEs (%d bytes)"", length); while (dl_ie_count--) { nib += dissect_dlmap_ie(ie_tree, pinfo, nib, tvb_len * 2, tvb); } pad = NIB_PADDING(nib); if (pad) { proto_tree_add_bytes_format(tree, hf_padding, tvb, NIBHI(nib,1), NULL, ""Padding nibble""); nib++; } } if (ulmap_appended) { proto_item_set_text(ti, ""Compressed DL-MAP (%u bytes)"", NIB_ADDR(nib)); proto_item_set_text(ti_dlmap_ies, ""DL-MAP IEs (%u bytes)"",NIB_ADDR(nib)- offset); proto_item_set_end(ti_dlmap_ies, tvb, NIB_ADDR(nib)); proto_item_set_end(ti, tvb, NIB_ADDR(nib)); col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, ""Compressed UL-MAP""); wimax_decode_ulmapc(base_tree, pinfo, nib, lennib - 8, tvb); } if (mac_len <= sizeof(mac_crc)) { expert_add_info_format(pinfo, ti, &ei_mac_header_invalid_length, ""Invalid length: %d."", mac_len); } else if (MIN(tvb_len, tvb_reported_length(tvb)) >= mac_len) { calculated_crc = wimax_mac_calc_crc32(tvb_get_ptr(tvb, 0, mac_len - (int)sizeof(mac_crc)), mac_len - (int)sizeof(mac_crc)); proto_tree_add_checksum(base_tree, tvb, mac_len - (int)sizeof(mac_crc), hf_mac_header_compress_dlmap_crc, hf_mac_header_compress_dlmap_crc_status, &ei_mac_header_compress_dlmap_crc, pinfo, calculated_crc, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY); } else {    proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, 0, tvb_len, ""CRC missing - the frame is too short (%u bytes)"", tvb_len); } return mac_len; }"
"static void ngx_http_v2_read_handler(ngx_event_t *rev) { u_char                    *p, *end; size_t                     available; ssize_t                    n; ngx_connection_t          *c; ngx_http_v2_main_conf_t   *h2mcf; ngx_http_v2_connection_t  *h2c; c = rev->data; h2c = c->data; if (rev->timedout) { ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out""); ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); return; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 read handler""); h2c->blocked = 1; if (c->close) { c->close = 0; if (c->error) { ngx_http_v2_finalize_connection(h2c, 0); return; } if (!h2c->processing && !h2c->pushing) { ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR); return; } if (!h2c->goaway) { h2c->goaway = 1; if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } } h2c->blocked = 0; return; } h2mcf = ngx_http_get_module_main_conf(h2c->http_connection->conf_ctx, ngx_http_v2_module); available = h2mcf->recv_buffer_size - 2 * NGX_HTTP_V2_STATE_BUFFER_SIZE; do { p = h2mcf->recv_buffer; ngx_memcpy(p, h2c->state.buffer, NGX_HTTP_V2_STATE_BUFFER_SIZE); end = p + h2c->state.buffer_used; n = c->recv(c, end, available); if (n == NGX_AGAIN) { break; } if (n == 0 && (h2c->state.incomplete || h2c->processing || h2c->pushing)) { ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client prematurely closed connection""); } if (n == 0 || n == NGX_ERROR) { c->error = 1; ngx_http_v2_finalize_connection(h2c, 0); return; } end += n; h2c->state.buffer_used = 0; h2c->state.incomplete = 0; do { p = h2c->state.handler(h2c, p, end); if (p == NULL) { return; } } while (p != end); h2c->total_bytes += n; if (h2c->total_bytes / 8 > h2c->payload_bytes + 1048576) { ngx_log_error(NGX_LOG_INFO, c->log, 0, ""http2 flood detected""); ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR); return; } } while (rev->ready); if (ngx_handle_read_event(rev, 0) != NGX_OK) { ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR); return; } if (h2c->last_out && ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } h2c->blocked = 0; ngx_http_v2_handle_connection(h2c); }"
"void writeStats(Array& ) override { fprintf(stderr, ""writeStats start\n""); fprintf(stderr, ""Count Function MinSerLen MaxSerLen RetSame HasThis "" ""AllSame MemberCount\n""); for (auto& me : m_memos) { if (me.second.m_ignore) continue; if (me.second.m_count == 1) continue; int min_ser_len = 999999999; int max_ser_len = 0; int count = 0; int member_count = 0; bool all_same = true; if (me.second.m_has_this) { bool any_multiple = false; auto& fr = me.second.m_member_memos.begin()->second.m_return_value; member_count = me.second.m_member_memos.size(); for (auto& mme : me.second.m_member_memos) { if (mme.second.m_return_value != fr) all_same = false; count += mme.second.m_count; auto ser_len = mme.second.m_return_value.length(); min_ser_len = std::min(min_ser_len, ser_len); max_ser_len = std::max(max_ser_len, ser_len); if (mme.second.m_count > 1) any_multiple = true; } if (!any_multiple && !all_same) continue; } else { min_ser_len = max_ser_len = me.second.m_return_value.length(); count = me.second.m_count; all_same = me.second.m_ret_tv_same; } fprintf(stderr, ""%d %s %d %d %s %s %s %d\n"", count, me.first.data(), min_ser_len, max_ser_len, me.second.m_ret_tv_same ? "" true"" : ""false"", me.second.m_has_this ? "" true"" : ""false"", all_same ? "" true"" : ""false"", member_count ); } fprintf(stderr, ""writeStats end\n""); }"
"bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path) { barrier::FingerprintData fingerprint_sha1, fingerprint_sha256; try { auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl); fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert, barrier::FingerprintType::SHA1); fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert, barrier::FingerprintType::SHA256); } catch (const std::exception& e) { LOG((CLOG_ERR ""%s"", e.what())); return false; } LOG((CLOG_NOTE ""server fingerprint (SHA1): %s (SHA256): %s"", barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(), barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str())); LOG((CLOG_NOTE ""fingerprint_db_path: %s"", fingerprint_db_path.u8string().c_str())); barrier::FingerprintDatabase db; db.read(fingerprint_db_path); if (!db.fingerprints().empty()) { LOG((CLOG_NOTE ""Read %d fingerprints from: %s"", db.fingerprints().size(), fingerprint_db_path.u8string().c_str())); } else { LOG((CLOG_NOTE ""Could not read fingerprints from: %s"", fingerprint_db_path.u8string().c_str())); } if (db.is_trusted(fingerprint_sha256)) { LOG((CLOG_NOTE ""Fingerprint matches trusted fingerprint"")); return true; } else { LOG((CLOG_NOTE ""Fingerprint does not match trusted fingerprint"")); return false; } }"
"void sqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type) { ST *tree = *ptree; int is_id; int cr_forced_static = 0; sc->sc_no_remote = 1; if (IS_UNION_ST (tree)) { tree = sqlp_view_def (NULL, tree, 1); tree = sqlc_union_dt_wrap (tree); *ptree = tree; } sqlc_top_select_wrap_dt (sc, tree); sql_stmt_comp (sc, ptree); tree = *ptree; if (sc->sc_so) is_id = sqlo_cr_is_identifiable (sc->sc_so, tree); else is_id = sqlc_cr_is_identifiable (sc, tree); if (!is_id) cr_forced_static = 1; { NEW_VARZ (query_cursor_t, qc); if (sc->sc_cc->cc_query->qr_cursor) { qc_free (sc->sc_cc->cc_query->qr_cursor); fprintf (stderr, ""Freeing qc in sqlc_cursor\n""); } sc->sc_cc->cc_query->qr_cursor = qc; sc->sc_cc->cc_query->qr_cursor_type = cr_type; if (sc->sc_so) { if (!cr_forced_static && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree)) cr_forced_static = 1; } else { if (!cr_forced_static && -1 == qc_make_cols (sc, qc, tree)) cr_forced_static = 1; } if (!cr_forced_static) { qc->qc_cursor_type = cr_type; if (sc->sc_so) sqlo_qc_make_stmts (sc->sc_so, qc); else qc_make_stmts (sc, qc); } else { qc_make_static (sc, qc, ptree); tree = *ptree; } } }"
"static VALUE rb_xml_reader_attribute_hash(VALUE rb_reader) { VALUE rb_attributes = rb_hash_new(); xmlTextReaderPtr c_reader; xmlNodePtr c_node; xmlAttrPtr c_property; Data_Get_Struct(rb_reader, xmlTextReader, c_reader); if (!has_attributes(c_reader)) { return rb_attributes; } c_node = xmlTextReaderExpand(c_reader); c_property = c_node->properties; while (c_property != NULL) { VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name); VALUE rb_value = Qnil; xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property); if (c_value) { rb_value = NOKOGIRI_STR_NEW2(c_value); xmlFree(c_value); } rb_hash_aset(rb_attributes, rb_name, rb_value); c_property = c_property->next; } return rb_attributes; }"
"ST * sqlc_table_from_select_view (query_t * view_qr, ST * view_def) { int inx; state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots; int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection); dk_set_t cols = NULL; dk_set_t key_parts = NULL; DO_BOX (state_slot_t *, ssl, inx, sel_out) { dtp_t sl_dtp; uint32 sl_prec; char sl_scale; int col_is_indexable; if (inx >= n_out) break; if (SSL_REF == ssl->ssl_type) ssl = ((state_slot_ref_t*)ssl)->sslr_ssl; sl_dtp = ssl->ssl_dtp; sl_prec = ssl->ssl_prec; sl_scale = ssl->ssl_scale; if (!sl_dtp || !dtp_is_column_compatible (sl_dtp)) { sl_dtp = DV_LONG_STRING; sl_prec = 0; sl_scale = 0; } col_is_indexable = !( (DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) || (DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) ); t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name)); t_dk_set_append_1 (&cols, t_list (2, t_list (3, t_box_num (sl_dtp), t_box_num (sl_prec), t_box_num (sl_scale)), NULL)); if (col_is_indexable) t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name)); } END_DO_BOX; t_dk_set_append_1 (&cols, NULL); t_dk_set_append_1 (&cols, t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL)); return ((ST *) t_list (3, TABLE_DEF, t_box_string (view_def->_.view_def.name), t_list_to_array (cols))); }"
"static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind) { struct evtchn *chn; struct domain *d = current->domain; struct vcpu   *v = d->vcpu[0]; struct pirq   *info; int            port = 0, pirq = bind->pirq; long           rc; if ( (pirq < 0) || (pirq >= d->nr_pirqs) ) return -EINVAL; if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) ) return -EPERM; spin_lock(&d->event_lock); if ( pirq_to_evtchn(d, pirq) != 0 ) ERROR_EXIT(-EEXIST); if ( (port = get_free_port(d)) < 0 ) ERROR_EXIT(port); chn = evtchn_from_port(d, port); info = pirq_get_info(d, pirq); if ( !info ) ERROR_EXIT(-ENOMEM); info->evtchn = port; rc = (!is_hvm_domain(d) ? pirq_guest_bind(v, info, !!(bind->flags & BIND_PIRQ__WILL_SHARE)) : 0); if ( rc != 0 ) { info->evtchn = 0; pirq_cleanup_check(info, d); goto out; } spin_lock(&chn->lock); chn->state  = ECS_PIRQ; chn->u.pirq.irq = pirq; link_pirq_port(port, chn, v); evtchn_port_init(d, chn); spin_unlock(&chn->lock); bind->port = port; arch_evtchn_bind_pirq(d, pirq); out: check_free_port(d, port); spin_unlock(&d->event_lock); return rc; }"
"void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath) { const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) { if (accountState && accountState->account()) { const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) { return accountState->account()->davUrl() == folder->remoteUrl(); }); if (foundFolder != std::cend(map())) { (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject); } } const auto messageBox = new QMessageBox; messageBox->setAttribute(Qt::WA_DeleteOnClose); messageBox->setText(errorMessage); messageBox->setInformativeText(subject); messageBox->setIcon(QMessageBox::Warning); messageBox->addButton(QMessageBox::StandardButton::Ok); messageBox->show(); messageBox->activateWindow(); messageBox->raise(); }; const auto accountFound = AccountManager::instance()->account(accountDisplayName); if (!accountFound) { qCWarning(lcFolderMan) << ""Could not find an account "" << accountDisplayName << "" to edit file "" << relPath << "" locally.""; showError(accountFound, tr(""Could not find an account for local editing""), accountDisplayName); return; } const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account()); if (foundFiles.isEmpty()) { for (const auto &folder : map()) { bool result = false; const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result); for (const auto &excludedPath : excludedThroughSelectiveSync) { if (relPath.startsWith(excludedPath)) { showError(accountFound, tr(""Could not find a file for local editing. Make sure it is not excluded via selective sync.""), relPath); return; } } } showError(accountFound, tr(""Could not find a file for local editing. Make sure its path is valid and it is synced locally.""), relPath); return; } const auto localFilePath = foundFiles.first(); const auto folderForFile = folderForPath(localFilePath); if (!folderForFile) { showError(accountFound, tr(""Could not find a folder to sync.""), relPath); return; } const auto relPathSplit = relPath.split(QLatin1Char('/')); if (relPathSplit.size() > 0) { Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last()); } else { showError(accountFound, tr(""Could not find a file for local editing. Make sure its path is valid and it is synced locally.""), relPath); return; } folderForFile->startSync(); _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this, [this, localFilePath](const OCC::SyncResult &result) { Q_UNUSED(result); const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath); if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) { QObject::disconnect(foundConnectionIt.value()); _localFileEditingSyncFinishedConnections.erase(foundConnectionIt); } QtConcurrent::run([localFilePath]() { QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath)); Systray::instance()->destroyEditFileLocallyLoadingDialog(); }); })); }"
"static int dissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_) { proto_item  *message_ti; proto_tree  *subtree; tvbuff_t    *decompressed_tvb; int         decompressed_offset; int         start_offset = offset; int         bytes_offset; gint8       magic_byte; guint8      codec; guint32     message_size; guint32     length; message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN); subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, ""Message""); offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL); offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL); offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL); offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte); offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec); codec &= KAFKA_MESSAGE_CODEC_MASK; offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL); if (magic_byte == 1) { proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN); offset += 8; } bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL); if (bytes_offset > offset) { offset = bytes_offset; } else { expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length); return offset; } if (codec == 0) { bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length); if (bytes_offset > offset) { offset = bytes_offset; } else { expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length); return offset; } } else { length = tvb_get_ntohl(tvb, offset); offset += 4; if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) { add_new_data_source(pinfo, decompressed_tvb, ""Decompressed content""); show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb)); dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset, tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec); } else { proto_item_append_text(subtree, "" [Cannot decompress records]""); } offset += length; } proto_item_set_end(message_ti, tvb, offset); return offset; }"
"static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize) { UINT32 left = originalSize; while (left > 4) { const BYTE value = *in++; UINT32 len = 0; if (left == 5) { if (outSize < 1) return FALSE; outSize--; *out++ = value; left--; } else if (value == *in) { in++; if (*in < 0xFF) { len = (UINT32)*in++; len += 2; } else { in++; len = ((UINT32)(*in++)); len |= ((UINT32)(*in++)) << 8U; len |= ((UINT32)(*in++)) << 16U; len |= ((UINT32)(*in++)) << 24U; } if (outSize < len) return FALSE; outSize -= len; FillMemory(out, len, value); out += len; left -= len; } else { if (outSize < 1) return FALSE; outSize--; *out++ = value; left--; } } if ((outSize < 4) || (left < 4)) return FALSE; memcpy(out, in, 4); return TRUE; }"
"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { if (!bin->entry_table) { return NULL; } RList *entries = r_list_newf (free); if (!entries) { return NULL; } RList *segments = r_bin_ne_get_segments (bin); if (!segments) { r_list_free (entries); return NULL; } if (bin->ne_header->csEntryPoint) { RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } entry->bits = 16; ut32 entry_cs = bin->ne_header->csEntryPoint; RBinSection *s = r_list_get_n (segments, entry_cs - 1); entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0); r_list_append (entries, entry); } int off = 0; size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; while (off < bin->ne_header->EntryTableLength) { if (tableat + off >= r_buf_size (bin->buf)) { break; } ut8 bundle_length = *(ut8 *)(bin->entry_table + off); if (!bundle_length) { break; } off++; ut8 bundle_type = *(ut8 *)(bin->entry_table + off); off++; int i; for (i = 0; i < bundle_length; i++) { if (tableat + off + 4 >= r_buf_size (bin->buf)) { break; } RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } off++; if (!bundle_type) { off--; free (entry); break; } else if (bundle_type == 0xff) { off += 2; ut8 segnum = *(bin->entry_table + off); off++; ut16 segoff = *(ut16 *)(bin->entry_table + off); if (segnum > 0) { entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; } } else { if (bundle_type < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off); } } off += 2; r_list_append (entries, entry); } } r_list_free (segments); bin->entries = entries; return entries; }"
"void Compute(OpKernelContext* context) override { const Tensor& images = context->input(0); const Tensor& boxes = context->input(1); const int64 depth = images.dim_size(3); OP_REQUIRES(context, images.dims() == 4, errors::InvalidArgument(""The rank of the images should be 4"")); OP_REQUIRES( context, boxes.dims() == 3, errors::InvalidArgument(""The rank of the boxes tensor should be 3"")); OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0), errors::InvalidArgument(""The batch sizes should be the same"")); OP_REQUIRES( context, depth == 4 || depth == 1 || depth == 3, errors::InvalidArgument(""Channel depth should be either 1 (GRY), "" ""3 (RGB), or 4 (RGBA)"")); const int64 batch_size = images.dim_size(0); const int64 height = images.dim_size(1); const int64 width = images.dim_size(2); std::vector<std::vector<float>> color_table; if (context->num_inputs() == 3) { const Tensor& colors_tensor = context->input(2); OP_REQUIRES(context, colors_tensor.shape().dims() == 2, errors::InvalidArgument(""colors must be a 2-D matrix"", colors_tensor.shape().DebugString())); OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth, errors::InvalidArgument(""colors must have equal or more "", ""channels than the image provided: "", colors_tensor.shape().DebugString())); if (colors_tensor.NumElements() != 0) { color_table.clear(); auto colors = colors_tensor.matrix<float>(); for (int64 i = 0; i < colors.dimension(0); i++) { std::vector<float> color_value(4); for (int64 j = 0; j < 4; j++) { color_value[j] = colors(i, j); } color_table.emplace_back(color_value); } } } if (color_table.empty()) { color_table = DefaultColorTable(depth); } Tensor* output; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({batch_size, height, width, depth}), &output)); output->tensor<T, 4>() = images.tensor<T, 4>(); auto canvas = output->tensor<T, 4>(); for (int64 b = 0; b < batch_size; ++b) { const int64 num_boxes = boxes.dim_size(1); const auto tboxes = boxes.tensor<T, 3>(); for (int64 bb = 0; bb < num_boxes; ++bb) { int64 color_index = bb % color_table.size(); const int64 min_box_row = static_cast<float>(tboxes(b, bb, 0)) * (height - 1); const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0}); const int64 max_box_row = static_cast<float>(tboxes(b, bb, 2)) * (height - 1); const int64 max_box_row_clamp = std::min<int64>(max_box_row, height - 1); const int64 min_box_col = static_cast<float>(tboxes(b, bb, 1)) * (width - 1); const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0}); const int64 max_box_col = static_cast<float>(tboxes(b, bb, 3)) * (width - 1); const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1); if (min_box_row > max_box_row || min_box_col > max_box_col) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is inverted and will not be drawn.""; continue; } if (min_box_row >= height || max_box_row < 0 || min_box_col >= width || max_box_col < 0) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is completely outside the image"" << "" and will not be drawn.""; continue; } CHECK_GE(min_box_row_clamp, 0); CHECK_GE(max_box_row_clamp, 0); CHECK_LT(min_box_row_clamp, height); CHECK_LT(max_box_row_clamp, height); CHECK_GE(min_box_col_clamp, 0); CHECK_GE(max_box_col_clamp, 0); CHECK_LT(min_box_col_clamp, width); CHECK_LT(max_box_col_clamp, width); CHECK_LT(min_box_row, height); CHECK_GE(max_box_row, 0); CHECK_LT(min_box_col, width); CHECK_GE(max_box_col, 0); if (min_box_row >= 0) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, min_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_row < height) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, max_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (min_box_col >= 0) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, min_box_col, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_col < width) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, max_box_col, c) = static_cast<T>(color_table[color_index][c]); } } } } }"
"static int io_req_defer_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe) { ssize_t ret = 0; switch (req->opcode) { case IORING_OP_NOP: break; case IORING_OP_READV: case IORING_OP_READ_FIXED: ret = io_read_prep(req, sqe, true); break; case IORING_OP_WRITEV: case IORING_OP_WRITE_FIXED: ret = io_write_prep(req, sqe, true); break; case IORING_OP_POLL_ADD: ret = io_poll_add_prep(req, sqe); break; case IORING_OP_POLL_REMOVE: ret = io_poll_remove_prep(req, sqe); break; case IORING_OP_FSYNC: ret = io_prep_fsync(req, sqe); break; case IORING_OP_SYNC_FILE_RANGE: ret = io_prep_sfr(req, sqe); break; case IORING_OP_SENDMSG: ret = io_sendmsg_prep(req, sqe); break; case IORING_OP_RECVMSG: ret = io_recvmsg_prep(req, sqe); break; case IORING_OP_CONNECT: ret = io_connect_prep(req, sqe); break; case IORING_OP_TIMEOUT: ret = io_timeout_prep(req, sqe, false); break; case IORING_OP_TIMEOUT_REMOVE: ret = io_timeout_remove_prep(req, sqe); break; case IORING_OP_ASYNC_CANCEL: ret = io_async_cancel_prep(req, sqe); break; case IORING_OP_LINK_TIMEOUT: ret = io_timeout_prep(req, sqe, true); break; case IORING_OP_ACCEPT: ret = io_accept_prep(req, sqe); break; case IORING_OP_FALLOCATE: ret = io_fallocate_prep(req, sqe); break; case IORING_OP_OPENAT: ret = io_openat_prep(req, sqe); break; default: printk_once(KERN_WARNING ""io_uring: unhandled opcode %d\n"", req->opcode); ret = -EINVAL; break; } return ret; }"
"static VALUE from_document(VALUE klass, VALUE document) { xmlDocPtr doc; xmlRelaxNGParserCtxtPtr ctx; xmlRelaxNGPtr schema; VALUE errors; VALUE rb_schema; Data_Get_Struct(document, xmlDoc, doc); doc = doc->doc; ctx = xmlRelaxNGNewDocParserCtxt(doc); errors = rb_ary_new(); xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher); #ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS xmlRelaxNGSetParserStructuredErrors( ctx, Nokogiri_error_array_pusher, (void *)errors ); #endif schema = xmlRelaxNGParse(ctx); xmlSetStructuredErrorFunc(NULL, NULL); xmlRelaxNGFreeParserCtxt(ctx); if(NULL == schema) { xmlErrorPtr error = xmlGetLastError(); if(error) Nokogiri_error_raise(NULL, error); else rb_raise(rb_eRuntimeError, ""Could not parse document""); return Qnil; } rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema); rb_iv_set(rb_schema, ""@errors"", errors); return rb_schema; }"
"static int GetNumSameData(const byte * curPtr, const int maxnum) { int count = 1; if (1 == maxnum) { return (1); } while (*curPtr == *(curPtr + count) && maxnum > count) { count++; } return (count); }"
"static void io_req_free_batch_finish(struct io_ring_ctx *ctx, struct req_batch *rb) { if (rb->to_free) __io_req_free_batch_flush(ctx, rb); if (rb->task) { put_task_struct_many(rb->task, rb->task_refs); rb->task = NULL; } }"
static void release_card(struct l1oip *hc) { intch; if (timer_pending(&hc->keep_tl)) del_timer(&hc->keep_tl); if (timer_pending(&hc->timeout_tl)) del_timer(&hc->timeout_tl); cancel_work_sync(&hc->workq); if (hc->socket_thread) l1oip_socket_close(hc); if (hc->registered && hc->chan[hc->d_idx].dch) mISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev); for (ch = 0; ch < 128; ch++) { if (hc->chan[ch].dch) { mISDN_freedchannel(hc->chan[ch].dch); kfree(hc->chan[ch].dch); } if (hc->chan[ch].bch) { mISDN_freebchannel(hc->chan[ch].bch); kfree(hc->chan[ch].bch); #ifdef REORDER_DEBUG dev_kfree_skb(hc->chan[ch].disorder_skb); #endif } } spin_lock(&l1oip_lock); list_del(&hc->list); spin_unlock(&l1oip_lock); kfree(hc); }
"static mrb_value mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class) { mrb_value blk; mrb_value proc; struct RProc *p; mrb_get_args(mrb, ""&!"", &blk); p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class)); mrb_proc_copy(p, mrb_proc_ptr(blk)); proc = mrb_obj_value(p); mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc); if (!MRB_PROC_STRICT_P(p) && mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) { p->flags |= MRB_PROC_ORPHAN; } return proc; }"
"static void xudc_set_clear_feature(struct xusb_udc *udc) { struct xusb_ep *ep0= &udc->ep[0]; struct xusb_req *req= udc->req; struct xusb_ep *target_ep; u8 endpoint; u8 outinbit; u32 epcfgreg; int flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0); int ret; switch (udc->setup.bRequestType) { case USB_RECIP_DEVICE: switch (udc->setup.wValue) { case USB_DEVICE_TEST_MODE: break; case USB_DEVICE_REMOTE_WAKEUP: if (flag) udc->remote_wkp = 1; else udc->remote_wkp = 0; break; default: xudc_ep0_stall(udc); break; } break; case USB_RECIP_ENDPOINT: if (!udc->setup.wValue) { endpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK; target_ep = &udc->ep[endpoint]; outinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK; outinbit = outinbit >> 7; if (outinbit != target_ep->is_in) { xudc_ep0_stall(udc); return; } epcfgreg = udc->read_fn(udc->addr + target_ep->offset); if (!endpoint) { epcfgreg &= ~XUSB_EP_CFG_STALL_MASK; udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } else { if (flag) { epcfgreg |= XUSB_EP_CFG_STALL_MASK; udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } else { epcfgreg &= ~(XUSB_EP_CFG_STALL_MASK | XUSB_EP_CFG_DATA_TOGGLE_MASK); udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } } } break; default: xudc_ep0_stall(udc); return; } req->usb_req.length = 0; ret = __xudc_ep0_queue(ep0, req); if (ret == 0) return; dev_err(udc->dev, ""Can't respond to SET/CLEAR FEATURE\n""); xudc_ep0_stall(udc); }"
"void gf_isom_meta_restore_items_ref(GF_ISOFile *movie, GF_MetaBox *meta) { u32 i, nb_items, nb_tracks; if (!meta->item_locations || !meta->item_infos) return; nb_tracks = movie->moov ? gf_list_count(movie->moov->trackList) : 0; nb_items = gf_list_count(meta->item_locations->location_entries); for (i=0; i<nb_items; i++) { u32 j; u64 item_offset; GF_ItemExtentEntry *entry; GF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i); GF_ItemInfoEntryBox *iinf = NULL; j=0; while ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) { if (iinf->item_ID==iloc->item_ID) break; iinf = NULL; } if (!iinf) continue; if (iinf->ref_it_id) continue; if (gf_list_count(iloc->extent_entries) != 1) continue; entry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0); if (!entry) continue; item_offset = iloc->base_offset + entry->extent_offset; for (j=0;j<nb_tracks; j++) { GF_TrackBox *trak; GF_SampleSizeBox *stsz; u32 k; trak = gf_list_get(movie->moov->trackList, j); if (! gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) continue; stsz = trak->Media->information->sampleTable->SampleSize; if (!stsz->sampleCount) continue; for (k=0; k<stsz->sampleCount; k++) { GF_Err e; u32 chunk, di, samp_size; u64 samp_offset; samp_size = stsz->sampleSize ? stsz->sampleSize : stsz->sizes[k]; if (samp_size != entry->extent_length) continue; e = stbl_GetSampleInfos(trak->Media->information->sampleTable, k+1, &samp_offset, &chunk, &di, NULL); if (e) continue; if (samp_offset == item_offset) { iinf->tk_id = trak->Header->trackID; iinf->sample_num = k+1; iinf->data_len = (u32) entry->extent_length; meta->use_item_sample_sharing = 1; break; } } if (iinf->tk_id) break; } for (j=i+1;j<nb_items; j++) { u32 k; u64 item_offset2; GF_ItemExtentEntry *entry2; GF_ItemLocationEntry *iloc2 = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, j); GF_ItemInfoEntryBox *iinf2 = NULL; k=0; while ((iinf2 = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &k))) { if (iinf2->item_ID==iloc2->item_ID) break; iinf2 = NULL; } if (!iinf2) continue; if (gf_list_count(iloc2->extent_entries) != 1) continue; entry2 = (GF_ItemExtentEntry *)gf_list_get(iloc2->extent_entries, 0); if (!entry2) continue; item_offset2 = iloc2->base_offset + entry2->extent_offset; if (item_offset == item_offset2) { iinf2->ref_it_id = iinf->item_ID; meta->use_item_item_sharing = 1; } } } }"
"v8::Local<v8::Object> CreateNativeEvent( v8::Isolate* isolate, v8::Local<v8::Object> sender, content::RenderFrameHost* frame, electron::mojom::ElectronBrowser::MessageSyncCallback callback) { v8::Local<v8::Object> event; if (frame && callback) { gin::Handle<Event> native_event = Event::Create(isolate); native_event->SetCallback(std::move(callback)); event = v8::Local<v8::Object>::Cast(native_event.ToV8()); } else { event = CreateEvent(isolate); } Dictionary dict(isolate, event); dict.Set(""sender"", sender); if (frame) dict.Set(""frameId"", frame->GetRoutingID()); return event; }"
"void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext) { std::string real_rule; if(startsWith(rule, ""[]"") && add_direct) { filtered_nodelist.emplace_back(rule.substr(2)); } #ifndef NO_JS_RUNTIME else if(startsWith(rule, ""script:"")) { script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){ std::string script = fileGet(rule.substr(7), true); try { ctx.eval(script); auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(""filter""); std::string result_list = filter(nodelist); filtered_nodelist = split(regTrim(result_list), ""\n""); } catch (qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } #endif     else { for(Proxy &x : nodelist) { if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end()) filtered_nodelist.emplace_back(x.Remark); } } }"
"PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool, const char *filename, unsigned ptime, unsigned options, pj_ssize_t buff_size, pjmedia_port **p_port ) { pjmedia_wave_hdr wave_hdr; pj_ssize_t size_to_read, size_read; struct file_reader_port *fport; pjmedia_audio_format_detail *ad; pj_off_t pos; pj_str_t name; unsigned samples_per_frame; pj_status_t status = PJ_SUCCESS; PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL); if (!pj_file_exists(filename)) { return PJ_ENOTFOUND; } if (ptime == 0) ptime = 20; if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE; fport = create_file_port(pool); if (!fport) { return PJ_ENOMEM; } fport->fsize = pj_file_size(filename); if (fport->fsize <= sizeof(pjmedia_wave_hdr)) { return PJMEDIA_ENOTVALIDWAVE; } status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd); if (status != PJ_SUCCESS) return status; size_read = size_to_read = sizeof(wave_hdr) - 8; status = pj_file_read( fport->fd, &wave_hdr, &size_read); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } if (size_read != size_to_read) { pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE; } pjmedia_wave_hdr_file_to_host(&wave_hdr); if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG || wave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG || wave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG) { pj_file_close(fport->fd); TRACE_((THIS_FILE,  ""actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x"", wave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG, wave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG, wave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG)); return PJMEDIA_ENOTVALIDWAVE; } switch (wave_hdr.fmt_hdr.fmt_tag) { case PJMEDIA_WAVE_FMT_TAG_PCM: if (wave_hdr.fmt_hdr.bits_per_sample != 16 ||  wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan) status = PJMEDIA_EWAVEUNSUPP; break; case PJMEDIA_WAVE_FMT_TAG_ALAW: case PJMEDIA_WAVE_FMT_TAG_ULAW: if (wave_hdr.fmt_hdr.bits_per_sample != 8 || wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan) status = PJMEDIA_ENOTVALIDWAVE; break; default: status = PJMEDIA_EWAVEUNSUPP; break; } if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag; fport->bytes_per_sample = (pj_uint16_t)  (wave_hdr.fmt_hdr.bits_per_sample / 8); if (wave_hdr.fmt_hdr.len > 16) { size_to_read = wave_hdr.fmt_hdr.len - 16; status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } } for (;;) { pjmedia_wave_subchunk subchunk; size_read = 8; status = pj_file_read(fport->fd, &subchunk, &size_read); if (status != PJ_SUCCESS || size_read != 8) { pj_file_close(fport->fd); return PJMEDIA_EWAVETOOSHORT; } PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk); if (subchunk.id == PJMEDIA_DATA_TAG) { wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG; wave_hdr.data_hdr.len = subchunk.len; break; } size_to_read = subchunk.len; status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } } status = pj_file_getpos(fport->fd, &pos); fport->start_data = (unsigned)pos; fport->data_len = wave_hdr.data_hdr.len; fport->data_left = wave_hdr.data_hdr.len; if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) { wave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data; } if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate * wave_hdr.fmt_hdr.nchan / 1000) { pj_file_close(fport->fd); return PJMEDIA_EWAVETOOSHORT; } fport->options = options; ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1); pj_strdup2(pool, &name, filename); samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate * wave_hdr.fmt_hdr.nchan / 1000; pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE, wave_hdr.fmt_hdr.sample_rate, wave_hdr.fmt_hdr.nchan, BITS_PER_SAMPLE, samples_per_frame); if (wave_hdr.data_hdr.len < (unsigned)buff_size) buff_size = wave_hdr.data_hdr.len; fport->bufsize = (pj_uint32_t)buff_size; if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) { pj_file_close(fport->fd); return PJ_EINVAL; } fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize); if (!fport->buf) { pj_file_close(fport->fd); return PJ_ENOMEM; } fport->readpos = fport->buf; fport->fpos = fport->start_data; status = fill_buffer(fport); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } *p_port = &fport->base; PJ_LOG(4,(THIS_FILE,  ""File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, "" ""filesize=%luKB"", (int)fport->base.info.name.slen, fport->base.info.name.ptr, ad->clock_rate, ad->channel_count, fport->bufsize / 1000, (unsigned long)(fport->fsize / 1000))); return PJ_SUCCESS; }"
"static int vrend_renderer_resource_allocate_texture(struct vrend_resource *gr, void *image_oes) { uint level; GLenum internalformat, glformat, gltype; enum virgl_formats format = gr->base.format; struct vrend_texture *gt = (struct vrend_texture *)gr; struct pipe_resource *pr = &gr->base; if (pr->width0 == 0) return EINVAL; bool format_can_texture_storage = has_feature(feat_texture_storage) && (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE); if (vrend_state.use_gles && pr->nr_samples > 0 && !format_can_texture_storage) { VREND_DEBUG(dbg_tex, NULL, ""Apply VIRGL_BIND_PREFER_EMULATED_BGRA because GLES+MS+noTS\n""); gr->base.bind |= VIRGL_BIND_PREFER_EMULATED_BGRA; } if (image_oes && !has_feature(feat_egl_image_storage)) gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA; #ifdef ENABLE_GBM_ALLOCATION if (virgl_gbm_external_allocation_preferred(gr->base.bind) && !has_feature(feat_egl_image_storage)) gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA; #endif format = vrend_format_replace_emulated(gr->base.bind, gr->base.format); format_can_texture_storage = has_feature(feat_texture_storage) && (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE); if (format_can_texture_storage) gr->storage_bits |= VREND_STORAGE_GL_IMMUTABLE; if (!image_oes) { vrend_resource_gbm_init(gr, format); if (gr->gbm_bo && !has_bit(gr->storage_bits, VREND_STORAGE_EGL_IMAGE)) return 0; image_oes = gr->egl_image; } gr->target = tgsitargettogltarget(pr->target, pr->nr_samples); gr->storage_bits |= VREND_STORAGE_GL_TEXTURE; if (vrend_state.use_gles && gr->target == GL_TEXTURE_RECTANGLE_NV) { if (pr->width0 != 1 || pr->height0 != 1) { report_gles_warn(NULL, GLES_WARN_TEXTURE_RECT); } gr->target = GL_TEXTURE_2D; } if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D) { gr->target = GL_TEXTURE_2D; } if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D_ARRAY) { gr->target = GL_TEXTURE_2D_ARRAY; } glGenTextures(1, &gr->id); glBindTexture(gr->target, gr->id); debug_texture(__func__, gr); if (image_oes) { if (has_bit(gr->storage_bits, VREND_STORAGE_GL_IMMUTABLE) && has_feature(feat_egl_image_storage)) { glEGLImageTargetTexStorageEXT(gr->target, (GLeglImageOES) image_oes, NULL); } else if (has_feature(feat_egl_image_external)) { gr->storage_bits &= ~VREND_STORAGE_GL_IMMUTABLE; glEGLImageTargetTexture2DOES(gr->target, (GLeglImageOES) image_oes); } else { vrend_printf( ""missing GL_OES_EGL_image_external extensions\n""); glBindTexture(gr->target, 0); FREE(gr); return EINVAL; } } else { internalformat = tex_conv_table[format].internalformat; glformat = tex_conv_table[format].glformat; gltype = tex_conv_table[format].gltype; if (internalformat == 0) { vrend_printf(""unknown format is %d\n"", pr->format); glBindTexture(gr->target, 0); FREE(gt); return EINVAL; } if (pr->nr_samples > 0) { if (format_can_texture_storage) { if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) { glTexStorage2DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, GL_TRUE); } else { glTexStorage3DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, pr->array_size, GL_TRUE); } } else { if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) { glTexImage2DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, GL_TRUE); } else { glTexImage3DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, pr->array_size, GL_TRUE); } } } else if (gr->target == GL_TEXTURE_CUBE_MAP) { int i; if (format_can_texture_storage) glTexStorage2D(GL_TEXTURE_CUBE_MAP, pr->last_level + 1, internalformat, pr->width0, pr->height0); else { for (i = 0; i < 6; i++) { GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i; for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage2D(ctarget, level, internalformat, mwidth, mheight, 0, glformat, gltype, NULL); } } } } else if (gr->target == GL_TEXTURE_3D || gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) { if (format_can_texture_storage) { unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ? pr->array_size : pr->depth0; glTexStorage3D(gr->target, pr->last_level + 1, internalformat, pr->width0, pr->height0, depth_param); } else { for (level = 0; level <= pr->last_level; level++) { unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ? pr->array_size : u_minify(pr->depth0, level); unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage3D(gr->target, level, internalformat, mwidth, mheight, depth_param, 0, glformat, gltype, NULL); } } } else if (gr->target == GL_TEXTURE_1D && vrend_state.use_gles) { report_gles_missing_func(NULL, ""glTexImage1D""); } else if (gr->target == GL_TEXTURE_1D) { if (format_can_texture_storage) { glTexStorage1D(gr->target, pr->last_level + 1, internalformat, pr->width0); } else { for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); glTexImage1D(gr->target, level, internalformat, mwidth, 0, glformat, gltype, NULL); } } } else { if (format_can_texture_storage) glTexStorage2D(gr->target, pr->last_level + 1, internalformat, pr->width0, gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : pr->height0); else { for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage2D(gr->target, level, internalformat, mwidth, gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : mheight, 0, glformat, gltype, NULL); } } } } if (!format_can_texture_storage) { glTexParameteri(gr->target, GL_TEXTURE_BASE_LEVEL, 0); glTexParameteri(gr->target, GL_TEXTURE_MAX_LEVEL, pr->last_level); } glBindTexture(gr->target, 0); if (image_oes && gr->gbm_bo) { #ifdef ENABLE_GBM_ALLOCATION for (int i = 0; i < gbm_bo_get_plane_count(gr->gbm_bo) - 1; i++) { gr->aux_plane_egl_image[i] = virgl_egl_aux_plane_image_from_dmabuf(egl, gr->gbm_bo, i + 1); } #endif } gt->state.max_lod = -1; gt->cur_swizzle_r = gt->cur_swizzle_g = gt->cur_swizzle_b = gt->cur_swizzle_a = -1; gt->cur_base = -1; gt->cur_max = 10000; return 0; }"
"void DecodePngV2(OpKernelContext* context, StringPiece input) { int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16; png::DecodeContext decode; OP_REQUIRES( context, png::CommonInitDecode(input, channels_, channel_bits, &decode), errors::InvalidArgument(""Invalid PNG. Failed to initialize decoder."")); const int width = static_cast<int>(decode.width); const int height = static_cast<int>(decode.height); const int64_t total_size = static_cast<int64_t>(width) * static_cast<int64_t>(height); if (width != static_cast<int64_t>(decode.width) || width <= 0 || width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) || height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) { OP_REQUIRES(context, false, errors::InvalidArgument(""PNG size too large for int: "", decode.width, "" by "", decode.height)); } Tensor* output = nullptr; if (op_type_ == ""DecodeGif"") { OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({1, height, width, decode.channels}), &output)); } else { OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({height, width, decode.channels}), &output)); } if (op_type_ == ""DecodeBmp"") { OP_REQUIRES(context, false, errors::InvalidArgument( ""Trying to decode PNG format using DecodeBmp op. Use "" ""`decode_png` or `decode_image` instead."")); } else if (op_type_ == ""DecodeAndCropJpeg"") { OP_REQUIRES(context, false, errors::InvalidArgument( ""DecodeAndCropJpeg operation can run on JPEG only, but "" ""detected PNG."")); } if (data_type_ == DataType::DT_UINT8) { OP_REQUIRES( context, png::CommonFinishDecode( reinterpret_cast<png_bytep>(output->flat<uint8>().data()), decode.channels * width * sizeof(uint8), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); } else if (data_type_ == DataType::DT_UINT16) { OP_REQUIRES( context, png::CommonFinishDecode( reinterpret_cast<png_bytep>(output->flat<uint16>().data()), decode.channels * width * sizeof(uint16), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); } else if (data_type_ == DataType::DT_FLOAT) { std::unique_ptr<uint16[]> buffer( new uint16[height * width * decode.channels]); OP_REQUIRES( context, png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()), decode.channels * width * sizeof(uint16), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>(); TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width, decode.channels); float scale = 1. / std::numeric_limits<uint16>::max(); output->tensor<float, 3>().device(device) = buf.cast<float>() * scale; } }"
"static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size) { unsigned long cons_pos, prod_pos, new_prod_pos, flags; u32 len, pg_off; struct bpf_ringbuf_hdr *hdr; if (unlikely(size > RINGBUF_MAX_RECORD_SZ)) return NULL; len = round_up(size + BPF_RINGBUF_HDR_SZ, 8); cons_pos = smp_load_acquire(&rb->consumer_pos); if (in_nmi()) { if (!spin_trylock_irqsave(&rb->spinlock, flags)) return NULL; } else { spin_lock_irqsave(&rb->spinlock, flags); } prod_pos = rb->producer_pos; new_prod_pos = prod_pos + len; if (new_prod_pos - cons_pos > rb->mask) { spin_unlock_irqrestore(&rb->spinlock, flags); return NULL; } hdr = (void *)rb->data + (prod_pos & rb->mask); pg_off = bpf_ringbuf_rec_pg_off(rb, hdr); hdr->len = size | BPF_RINGBUF_BUSY_BIT; hdr->pg_off = pg_off; smp_store_release(&rb->producer_pos, new_prod_pos); spin_unlock_irqrestore(&rb->spinlock, flags); return (void *)hdr + BPF_RINGBUF_HDR_SZ; }"
"void FilterManager::maybeEndDecode(bool end_stream) { ASSERT(!state_.remote_complete_); state_.remote_complete_ = end_stream; if (end_stream) { stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(dispatcher().timeSource()); ENVOY_STREAM_LOG(debug, ""request end stream"", *this); } }"
"static void *createArrayObject(const redisReadTask *task, size_t elements) { redisReply *r, *parent; r = createReplyObject(task->type); if (r == NULL) return NULL; if (elements > 0) { r->element = hi_calloc(elements,sizeof(redisReply*)); if (r->element == NULL) { freeReplyObject(r); return NULL; } } r->elements = elements; if (task->parent) { parent = task->parent->obj; assert(parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET || parent->type == REDIS_REPLY_PUSH); parent->element[task->idx] = r; } return r; }"
"static void pci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq) { struct virtio_blk_hdr *vbh; struct virtio_blk_discard_write_zeroes *vbdiscard; struct pci_vtblk_ioreq *io; int i, n; int err; ssize_t iolen; int expectro, type; struct iovec iov[BLOCKIF_IOV_MAX + 2]; uint16_t idx, flags[BLOCKIF_IOV_MAX + 2]; n = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags); assert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2); io = &sc->vbsc_ios[idx]; assert((flags[0] & VRING_DESC_F_WRITE) == 0); assert(iov[0].iov_len == sizeof(struct virtio_blk_hdr)); vbh = iov[0].iov_base; memcpy(&io->io_req.br_iov, &iov[1], sizeof(struct iovec) * ((size_t)n - 2)); io->io_req.br_iovcnt = n - 2; io->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE); io->io_status = iov[--n].iov_base; assert(iov[n].iov_len == 1); assert(flags[n] & VRING_DESC_F_WRITE); type = vbh->vbh_type & ~VBH_FLAG_BARRIER; expectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD); iolen = 0; for (i = 1; i < n; i++) { assert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro); iolen += iov[i].iov_len; } io->io_req.br_resid = iolen; DPRINTF((""virtio-block: %s op, %zd bytes, %d segs\n\r"", print_vbh_op(type), iolen, i - 1)); switch (type) { case VBH_OP_READ: err = blockif_read(sc->bc, &io->io_req); break; case VBH_OP_WRITE: err = blockif_write(sc->bc, &io->io_req); break; case VBH_OP_DISCARD: assert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes)); assert(n == 2); vbdiscard = iov[1].iov_base; io->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE; io->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE; err = blockif_delete(sc->bc, &io->io_req); break; case VBH_OP_FLUSH: case VBH_OP_FLUSH_OUT: err = blockif_flush(sc->bc, &io->io_req); break; case VBH_OP_IDENT: memset(iov[1].iov_base, 0, iov[1].iov_len); strncpy(iov[1].iov_base, sc->vbsc_ident, MIN(iov[1].iov_len, sizeof(sc->vbsc_ident))); pci_vtblk_done_locked(&io->io_req, 0); return; default: pci_vtblk_done_locked(&io->io_req, EOPNOTSUPP); return; } assert(err == 0); }"
"static int prealloc_elems_and_freelist(struct bpf_stack_map *smap) { u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size; int err; smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries, smap->map.numa_node); if (!smap->elems) return -ENOMEM; err = pcpu_freelist_init(&smap->freelist); if (err) goto free_elems; pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size, smap->map.max_entries); return 0; free_elems: bpf_map_area_free(smap->elems); return err; }"
"static void nv_replace(cmdarg_T *cap) { char_u*ptr; inthad_ctrl_v; longn; if (checkclearop(cap->oap)) return; #ifdef FEAT_JOB_CHANNEL if (bt_prompt(curbuf) && !prompt_curpos_editable()) { clearopbeep(cap->oap); return; } #endif if (cap->nchar == Ctrl_V) { had_ctrl_v = Ctrl_V; cap->nchar = get_literal(FALSE); if (cap->nchar > DEL) had_ctrl_v = NUL; } else had_ctrl_v = NUL; if (IS_SPECIAL(cap->nchar)) { clearopbeep(cap->oap); return; } if (VIsual_active) { if (got_int) reset_VIsual(); if (had_ctrl_v) { if (cap->nchar == CAR) cap->nchar = REPLACE_CR_NCHAR; else if (cap->nchar == NL) cap->nchar = REPLACE_NL_NCHAR; } nv_operator(cap); return; } if (virtual_active()) { if (u_save_cursor() == FAIL) return; if (gchar_cursor() == NUL) { coladvance_force((colnr_T)(getviscol() + cap->count1)); curwin->w_cursor.col -= cap->count1; } else if (gchar_cursor() == TAB) coladvance_force(getviscol()); } ptr = ml_get_cursor(); if (STRLEN(ptr) < (unsigned)cap->count1 || (has_mbyte && mb_charlen(ptr) < cap->count1)) { clearopbeep(cap->oap); return; } if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta)) { stuffnumReadbuff(cap->count1); stuffcharReadbuff('R'); stuffcharReadbuff('\t'); stuffcharReadbuff(ESC); return; } if (u_save_cursor() == FAIL) return; if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n')) { (void)del_chars(cap->count1, FALSE);stuffcharReadbuff('\r'); stuffcharReadbuff(ESC); invoke_edit(cap, TRUE, 'r', FALSE); } else { prep_redo(cap->oap->regname, cap->count1, NUL, 'r', NUL, had_ctrl_v, cap->nchar); curbuf->b_op_start = curwin->w_cursor; if (has_mbyte) { intold_State = State; if (cap->ncharC1 != 0) AppendCharToRedobuff(cap->ncharC1); if (cap->ncharC2 != 0) AppendCharToRedobuff(cap->ncharC2); for (n = cap->count1; n > 0; --n) { State = REPLACE; if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ins_char(c); else ++curwin->w_cursor.col; } else ins_char(cap->nchar); State = old_State; if (cap->ncharC1 != 0) ins_char(cap->ncharC1); if (cap->ncharC2 != 0) ins_char(cap->ncharC2); } } else { for (n = cap->count1; n > 0; --n) { ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE); if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ptr[curwin->w_cursor.col] = c; } else ptr[curwin->w_cursor.col] = cap->nchar; if (p_sm && msg_silent == 0) showmatch(cap->nchar); ++curwin->w_cursor.col; } #ifdef FEAT_NETBEANS_INTG if (netbeans_active()) { colnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1); netbeans_removed(curbuf, curwin->w_cursor.lnum, start, (long)cap->count1); netbeans_inserted(curbuf, curwin->w_cursor.lnum, start, &ptr[start], (int)cap->count1); } #endif changed_bytes(curwin->w_cursor.lnum, (colnr_T)(curwin->w_cursor.col - cap->count1)); } --curwin->w_cursor.col;    if (has_mbyte) mb_adjust_cursor(); curbuf->b_op_end = curwin->w_cursor; curwin->w_set_curswant = TRUE; set_last_insert(cap->nchar); } }"
"GF_Err gnrv_box_dump(GF_Box *a, FILE * trace) { GF_GenericVisualSampleEntryBox *p = (GF_GenericVisualSampleEntryBox *)a; if (p->EntryType) { a->type = p->EntryType; if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) a->type = GF_4CC('u','k','n','w'); } gf_isom_box_dump_start(a, ""VisualSampleDescriptionBox"", trace); gf_fprintf(trace, ""DataReferenceIndex=\""%d\"" Version=\""%d\"" Revision=\""%d\"" Vendor=\""%d\"" TemporalQuality=\""%d\"" SpacialQuality=\""%d\"" Width=\""%d\"" Height=\""%d\"" HorizontalResolution=\""%d\"" VerticalResolution=\""%d\"" CompressorName=\""%s\"" BitDepth=\""%d\"""", p->dataReferenceIndex, p->version, p->revision, p->vendor, p->temporal_quality, p->spatial_quality, p->Width, p->Height, p->horiz_res, p->vert_res, isalnum(p->compressor_name[0]) ? p->compressor_name : p->compressor_name+1, p->bit_depth); a->type = GF_ISOM_BOX_TYPE_GNRV; gnr_dump_exts(p->data, p->data_size, trace); gf_isom_box_dump_done(""VisualSampleDescriptionBox"", a, trace); return GF_OK; }"
"static void tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node) { Oid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0); const char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1)); const char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2)); const char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3)); int rc; bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) && !castNode(CallContext, fcinfo->context)->atomic; TS_PREVENT_FUNC_IF_READ_ONLY(); PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo))); if (src_node_name == NULL || dst_node_name == NULL) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid source or destination node""))); if (!OidIsValid(chunk_id)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid chunk""))); if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT) elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc)); chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); }"
"int __get_user_pages_fast(unsigned long start, int nr_pages, int write, struct page **pages) { unsigned long len, end; unsigned long flags; int nr_pinned = 0; unsigned int gup_flags = FOLL_GET; if (write) gup_flags |= FOLL_WRITE; start = untagged_addr(start) & PAGE_MASK; len = (unsigned long) nr_pages << PAGE_SHIFT; end = start + len; if (end <= start) return 0; if (unlikely(!access_ok((void __user *)start, len))) return 0; if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) && gup_fast_permitted(start, end)) { local_irq_save(flags); gup_pgd_range(start, end, gup_flags, pages, &nr_pinned); local_irq_restore(flags); } return nr_pinned; }"
"static bool ATHEME_FATTR_WUR sasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len) { struct sasl_output_buf outbuf = { .buf    = NULL, .len    = 0, .flags  = ASASL_OUTFLAG_NONE, }; enum sasl_mechanism_result rc; bool have_responded = false; if (! p->mechptr && ! len) { if (! (p->mechptr = sasl_mechanism_find(buf))) { (void) sasl_sts(p->uid, 'M', sasl_mechlist_string); return false; } (void) sasl_sourceinfo_recreate(p); if (p->mechptr->mech_start) rc = p->mechptr->mech_start(p, &outbuf); else rc = ASASL_MRESULT_CONTINUE; } else if (! p->mechptr) { (void) slog(LG_DEBUG, ""%s: session has no mechanism?"", MOWGLI_FUNC_NAME); return false; } else { rc = sasl_process_input(p, buf, len, &outbuf); } if (outbuf.buf && outbuf.len) { if (! sasl_process_output(p, &outbuf)) return false; have_responded = true; } p->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION; switch (rc) { case ASASL_MRESULT_CONTINUE: { if (! have_responded) (void) sasl_sts(p->uid, 'C', ""+""); return true; } case ASASL_MRESULT_SUCCESS: { struct user *const u = user_find(p->uid); struct myuser *const mu = sasl_user_can_login(p); if (! mu) { if (u) (void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR); return false; } if (u && ! sasl_handle_login(p, u, mu)) return false; return sasl_session_success(p, mu, (u != NULL)); } case ASASL_MRESULT_FAILURE: { if (*p->authceid) { struct myuser *const mu = myuser_find_uid(p->authceid); if (! mu) return false; (void) sasl_sourceinfo_recreate(p); (void) logcommand(p->si, CMDLOG_LOGIN, ""failed LOGIN (%s) to \2%s\2 (bad password)"", p->mechptr->name, entity(mu)->name); (void) bad_password(p->si, mu); } return false; } case ASASL_MRESULT_ERROR: return false; } return false; }"
"static njs_int_t njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args, njs_value_t *value, int64_t index) { njs_int_t                    ret; njs_array_t                  *array; njs_value_t                  arguments[2], next; njs_function_t               *on_fulfilled; njs_promise_capability_t     *capability; njs_promise_all_context_t    *context; njs_promise_iterator_args_t  *pargs; pargs = (njs_promise_iterator_args_t *) args; capability = pargs->capability; array = args->data; njs_set_undefined(&array->start[index]); ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1, &next); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } on_fulfilled = njs_promise_create_function(vm, sizeof(njs_promise_all_context_t)); if (njs_slow_path(on_fulfilled == NULL)) { return NJS_ERROR; } on_fulfilled->u.native = njs_promise_all_resolve_element_functions; on_fulfilled->args_count = 1; context = on_fulfilled->context; context->already_called = 0; context->index = (uint32_t) index; context->values = pargs->args.data; context->capability = capability; context->remaining_elements = pargs->remaining; (*pargs->remaining)++; njs_set_function(&arguments[0], on_fulfilled); arguments[1] = capability->reject; ret = njs_promise_invoke_then(vm, &next, arguments, 2); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } return NJS_OK; }"
"bool BmpInput::read_rle_image() { int rletype = m_dib_header.compression == RLE4_COMPRESSION ? 4 : 8; m_spec.attribute(""compression"", rletype == 4 ? ""rle4"" : ""rle8""); m_uncompressed.clear(); m_uncompressed.resize(m_spec.height * m_spec.width); bool ok = true; int y = 0, x = 0; while (ok) { unsigned char rle_pair[2]; if (!ioread(rle_pair, 2)) { ok = false; break; } if (y >= m_spec.height) {              errorfmt( ""BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})"", x, y); ok = false; break; } int npixels = rle_pair[0]; int value   = rle_pair[1]; if (npixels == 0 && value == 0) { x = 0; ++y; } else if (npixels == 0 && value == 1) { break; } else if (npixels == 0 && value == 2) { unsigned char offset[2]; ok &= ioread(offset, 2); x += offset[0]; y += offset[1]; } else if (npixels == 0) { npixels    = value; int nbytes = (rletype == 4) ? round_to_multiple((npixels + 1) / 2, 2) : round_to_multiple(npixels, 2); unsigned char absolute[256]; ok &= ioread(absolute, nbytes); for (int i = 0; i < npixels; ++i, ++x) { if (rletype == 4) value = (i & 1) ? (absolute[i / 2] & 0x0f) : (absolute[i / 2] >> 4); else value = absolute[i]; if (x < m_spec.width) m_uncompressed[y * m_spec.width + x] = value; } } else { for (int i = 0; i < npixels; ++i, ++x) { int v; if (rletype == 4) v = (i & 1) ? (value & 0x0f) : (value >> 4); else v = value; if (x < m_spec.width) m_uncompressed[y * m_spec.width + x] = v; } } } return ok; }"
"Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td, const String& key, const String& iv) { auto pm = get_valid_mcrypt_resource(td); if (!pm) { return false; } int max_key_size = mcrypt_enc_get_key_size(pm->m_td); int iv_size = mcrypt_enc_get_iv_size(pm->m_td); if (key.empty()) { raise_warning(""Key size is 0""); } unsigned char *key_s = (unsigned char *)malloc(key.size()); memset(key_s, 0, key.size()); unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1); memset(iv_s, 0, iv_size + 1); int key_size; if (key.size() > max_key_size) { raise_warning(""Key size too large; supplied length: %d, max: %d"", key.size(), max_key_size); key_size = max_key_size; } else { key_size = key.size(); } memcpy(key_s, key.data(), key.size()); if (iv.size() != iv_size) { raise_warning(""Iv size incorrect; supplied length: %d, needed: %d"", iv.size(), iv_size); } memcpy(iv_s, iv.data(), std::min(iv_size, iv.size())); mcrypt_generic_deinit(pm->m_td); int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s); if (result < 0) { pm->close(); switch (result) { case -3: raise_warning(""Key length incorrect""); break; case -4: raise_warning(""Memory allocation error""); break; case -1: default: raise_warning(""Unknown error""); break; } } else { pm->m_init = true; } free(iv_s); free(key_s); return result; }"
static void cil_reset_classperms_set(struct cil_classperms_set *cp_set) { cil_reset_classpermission(cp_set->set); }
static void io_req_track_inflight(struct io_kiocb *req) { if (!(req->flags & REQ_F_INFLIGHT)) { req->flags |= REQ_F_INFLIGHT; atomic_inc(&current->io_uring->inflight_tracked); } }
"GF_Err latm_dmx_process(GF_Filter *filter) { GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter); GF_FilterPacket *pck, *dst_pck; u32 pos; u8 *data=NULL, *output; u32 pck_size=0, prev_pck_size; u64 cts = GF_FILTER_NO_TS; if (ctx->in_error) return ctx->in_error; if (!ctx->duration.num) latm_dmx_check_dur(filter, ctx); if (ctx->opid && !ctx->is_playing) return GF_OK; pck = gf_filter_pid_get_packet(ctx->ipid); if (!pck) { if (gf_filter_pid_is_eos(ctx->ipid)) { if (!ctx->latm_buffer_size) { if (ctx->opid) gf_filter_pid_set_eos(ctx->opid); if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = NULL; return GF_EOS; } } else { return GF_OK; } } else { data = (char *) gf_filter_pck_get_data(pck, &pck_size); } if (ctx->timescale && pck) { cts = gf_filter_pck_get_cts(pck); if (!ctx->cts && (cts != GF_FILTER_NO_TS)) ctx->cts = cts; } prev_pck_size = ctx->latm_buffer_size; if (pck && !ctx->resume_from) { if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) { ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size; ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc); } memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size); ctx->latm_buffer_size += pck_size; } if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ); else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size); if (ctx->resume_from) { gf_bs_seek(ctx->bs, ctx->resume_from-1); ctx->resume_from = 0; } if (cts == GF_FILTER_NO_TS) prev_pck_size = 0; while (1) { pos = (u32) gf_bs_get_position(ctx->bs); u8 latm_buffer[4096]; u32 latm_frame_size = 4096; if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break; if (ctx->in_seek) { u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]); if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) { ctx->in_seek = GF_FALSE; } } latm_dmx_check_pid(filter, ctx); if (!ctx->is_playing) { ctx->resume_from = pos+1; return GF_OK; } if (!ctx->in_seek) { GF_FilterSAPType sap = GF_FILTER_SAP_1; dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(output, latm_buffer, latm_frame_size); gf_filter_pck_set_cts(dst_pck, ctx->cts); gf_filter_pck_set_duration(dst_pck, ctx->dts_inc); gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE); if (ctx->acfg.base_object_type==GF_CODECID_USAC) { if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) { sap = GF_FILTER_SAP_1; ctx->prev_sap = GF_TRUE; } else { sap = GF_FILTER_SAP_NONE; ctx->prev_sap = GF_FALSE; } } gf_filter_pck_set_sap(dst_pck, sap); gf_filter_pck_send(dst_pck); } latm_dmx_update_cts(ctx); if (prev_pck_size) { pos = (u32) gf_bs_get_position(ctx->bs); if (prev_pck_size<=pos) { prev_pck_size=0; if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = pck; if (pck) gf_filter_pck_ref_props(&ctx->src_pck); } } } if (pck) { pos = (u32) gf_bs_get_position(ctx->bs); assert(ctx->latm_buffer_size >= pos); memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos); ctx->latm_buffer_size -= pos; gf_filter_pid_drop_packet(ctx->ipid); assert(!ctx->resume_from); } else { ctx->latm_buffer_size = 0; return latm_dmx_process(filter); } return GF_OK; }"
"static int mptcp_disconnect(struct sock *sk, int flags) { struct mptcp_subflow_context *subflow; struct mptcp_sock *msk = mptcp_sk(sk); inet_sk_state_store(sk, TCP_CLOSE); mptcp_for_each_subflow(msk, subflow) { struct sock *ssk = mptcp_subflow_tcp_sock(subflow); __mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE); } mptcp_stop_timer(sk); sk_stop_timer(sk, &sk->sk_timer); if (mptcp_sk(sk)->token) mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL); mptcp_destroy_common(msk); msk->last_snd = NULL; WRITE_ONCE(msk->flags, 0); msk->cb_flags = 0; msk->push_pending = 0; msk->recovery = false; msk->can_ack = false; msk->fully_established = false; msk->rcv_data_fin = false; msk->snd_data_fin_enable = false; msk->rcv_fastclose = false; msk->use_64bit_ack = false; WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk))); mptcp_pm_data_reset(msk); mptcp_ca_reset(sk); sk->sk_shutdown = 0; sk_error_report(sk); return 0; }"
"static GF_Err BD_DecIndexValueReplace(GF_BifsDecoder * codec, GF_BitStream *bs) { GF_Node *new_node; u32 NodeID, ind, field_ind, NumBits, pos; u8 type; GF_Node *node; GF_Err e; GF_FieldInfo field, sffield; NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); node = gf_sg_find_node(codec->current_graph, NodeID); if (!node) return GF_NON_COMPLIANT_BITSTREAM; NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1); ind = gf_bs_read_int(bs, NumBits); e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind); if (e) return e; e = gf_node_get_field(node, field_ind, &field); if (e) return e; if (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM; type = gf_bs_read_int(bs, 2); switch (type) { case 0: pos = gf_bs_read_int(bs, 16); break; case 2: pos = 0; break; case 3: pos = ((GenMFField *) field.far_ptr)->count - 1; break; default: return GF_NON_COMPLIANT_BITSTREAM; } if (field.fieldType == GF_SG_VRML_MFNODE) { new_node = gf_bifs_dec_node(codec, bs, field.NDTtype); if (codec->LastError) { e = codec->LastError; goto exit; } if (new_node) { e = gf_node_register(new_node, node); if (e) return e; } e = gf_node_replace_child(node, (GF_ChildNodeItem**) field.far_ptr, pos, new_node); if (!e) gf_bifs_check_field_change(node, &field); } else { memcpy(&sffield, &field, sizeof(GF_FieldInfo)); sffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType); if (pos && pos >= ((GenMFField *)field.far_ptr)->count) { pos = ((GenMFField *)field.far_ptr)->count - 1; } e = gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, & sffield.far_ptr, pos); if (e) return e; e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE); if (!e) gf_bifs_check_field_change(node, &field); } exit: return e; }"
"static bool inferBinaryBitwise(BinaryOperatorInst *BOI) { Type LeftTy = BOI->getLeftHandSide()->getType(); Type RightTy = BOI->getRightHandSide()->getType(); Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt() ? Type::createBigInt() : Type::createNoType(); BOI->setType(Type::unionTy(Type::createInt32(), mayBeBigInt)); return true; }"
"int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len) { if (rr_nested == NULL || data == NULL || data_len <= 0) { return -1; } if (_dns_left_len(&rr_nested->context) < data_len) { return -1; } memcpy(rr_nested->context.ptr, data, data_len); rr_nested->context.ptr += data_len; return 0; }"
"static void outbound_phy_packet_callback(struct fw_packet *packet, struct fw_card *card, int status) { struct outbound_phy_packet_event *e = container_of(packet, struct outbound_phy_packet_event, p); switch (status) { case ACK_COMPLETE:e->phy_packet.rcode = RCODE_COMPLETE;break; case ACK_PENDING:e->phy_packet.rcode = RCODE_COMPLETE;break; case ACK_BUSY_X: case ACK_BUSY_A: case ACK_BUSY_B:e->phy_packet.rcode = RCODE_BUSY;break; case ACK_DATA_ERROR:e->phy_packet.rcode = RCODE_DATA_ERROR;break; case ACK_TYPE_ERROR:e->phy_packet.rcode = RCODE_TYPE_ERROR;break; default:e->phy_packet.rcode = status;break; } e->phy_packet.data[0] = packet->timestamp; queue_event(e->client, &e->event, &e->phy_packet, sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0); client_put(e->client); }"
"void proto_register_cbor(void) { static hf_register_info hf[] = { { &hf_cbor_item_major_type, { ""Major Type"", ""cbor.item.major_type"", FT_UINT8, BASE_DEC, VALS(major_type_vals), 0xe0, NULL, HFILL } }, { &hf_cbor_item_integer_size, { ""Size"", ""cbor.item.size"", FT_UINT8, BASE_DEC, VALS(integer_size_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_length_size, { ""Size"", ""cbor.item.size"", FT_UINT8, BASE_DEC, VALS(length_size_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_length5, { ""Length"", ""cbor.item.length5"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_length, { ""Length"", ""cbor.item.length"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_items5, { ""Items"", ""cbor.item.items5"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_items, { ""Items"", ""cbor.item.items"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_pairs5, { ""Pairs"", ""cbor.item.pairs"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_pairs, { ""Pairs"", ""cbor.item.pairs"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_float_simple_type, { ""Type"", ""cbor.item.float_simple_type"", FT_UINT8, BASE_DEC, VALS(float_simple_type_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_unsigned_integer, { ""Unsigned Integer"", ""cbor.item.unsigned_integer"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_negative_integer, { ""Negative Integer"", ""cbor.item.negative_integer"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_text_string, { ""Text String"", ""cbor.item.textstring"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_byte_string, { ""Byte String"", ""cbor.item.bytestring"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_array, { ""Array"", ""cbor.item.array"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_map, { ""Map"", ""cbor.item.map"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_tag, { ""Tag"", ""cbor.item.tag"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_float_simple, { ""Floating-point or Simple"", ""cbor.item.float_or_simple"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_uint5, { ""Unsigned Integer"", ""cbor.type.uint"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_type_uint, { ""Unsigned Integer"", ""cbor.type.uint"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_nint, { ""Negative Integer"", ""cbor.type.nint"", FT_INT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_byte_string, { ""Byte String"", ""cbor.type.bytestring"", FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_byte_string_indef, { ""Byte String (indefinite length)"", ""cbor.type.bytestring.indef"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_cbor_type_text_string, { ""Text String"", ""cbor.type.textstring"", FT_STRING, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_text_string_indef, { ""Text String (indefinite length)"", ""cbor.type.textstring.indef"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_cbor_type_tag5, { ""Tag"", ""cbor.type.tag"", FT_UINT8, BASE_DEC, VALS(tag32_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_type_tag, { ""Tag"", ""cbor.type.tag"", FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(tag64_vals), 0x00, NULL, HFILL } }, { &hf_cbor_type_simple_data5, { ""Simple data"", ""cbor.type.simple_data"", FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x1f, NULL, HFILL } }, { &hf_cbor_type_simple_data8, { ""Simple data"", ""cbor.type.simple_data"", FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x00, NULL, HFILL } }, { &hf_cbor_type_float16, { ""Float 16 Bit"", ""cbor.type.float16"", FT_FLOAT, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_float32, { ""Float 32 Bit"", ""cbor.type.float32"", FT_FLOAT, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_float64, { ""Float 64 Bit"", ""cbor.type.float64"", FT_DOUBLE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, }; static gint *ett[] = { &ett_cbor, &ett_cbor_type, &ett_cbor_unsigned_integer, &ett_cbor_negative_integer, &ett_cbor_byte_string, &ett_cbor_byte_string_indef, &ett_cbor_text_string, &ett_cbor_text_string_indef, &ett_cbor_array, &ett_cbor_map, &ett_cbor_tag, &ett_cbor_float_simple }; static ei_register_info ei[] = { { &ei_cbor_invalid_minor_type, { ""cbor.invalid_minor_type"", PI_MALFORMED, PI_WARN, ""Invalid minor type"", EXPFILL }}, { &ei_cbor_invalid_element, { ""cbor.invalid_element"", PI_MALFORMED, PI_WARN, ""Invalid element"", EXPFILL }}, { &ei_cbor_too_long_length, { ""cbor.too_long_length"", PI_MALFORMED, PI_WARN, ""Too long length"", EXPFILL }}, }; expert_module_t *expert_cbor; proto_cbor = proto_register_protocol(""Concise Binary Object Representation"", ""CBOR"", ""cbor""); proto_register_field_array(proto_cbor, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_cbor = expert_register_protocol(proto_cbor); expert_register_field_array(expert_cbor, ei, array_length(ei)); cbor_handle = register_dissector(""cbor"", dissect_cbor, proto_cbor); cborseq_handle = register_dissector(""cborseq"", dissect_cborseq, proto_cbor); }"
"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) { TIFFSTATE *clientstate = (TIFFSTATE *)state->context; char *filename = ""tempfile.tif""; char *mode = ""r""; TIFF *tiff; TRACE((""in decoder: bytes %d\n"", bytes)); TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state, state->x, state->y, state->ystep)); TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize, state->xoff, state->yoff)); TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes)); TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3])); TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3])); TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"", im->mode, im->type, im->bands, im->xsize, im->ysize)); TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"", im->image8, im->image32, im->image, im->block)); TRACE((""Image: pixelsize: %d, linesize %d \n"", im->pixelsize, im->linesize)); dump_state(clientstate); clientstate->size = bytes; clientstate->eof = clientstate->size; clientstate->loc = 0; clientstate->data = (tdata_t)buffer; clientstate->flrealloc = 0; dump_state(clientstate); TIFFSetWarningHandler(NULL); TIFFSetWarningHandlerExt(NULL); if (clientstate->fp) { TRACE((""Opening using fd: %d\n"",clientstate->fp)); lseek(clientstate->fp,0,SEEK_SET);         tiff = TIFFFdOpen(clientstate->fp, filename, mode); } else { TRACE((""Opening from string\n"")); tiff = TIFFClientOpen(filename, mode, (thandle_t) clientstate, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); } if (!tiff){ TRACE((""Error, didn't get the tiff\n"")); state->errcode = IMAGING_CODEC_BROKEN; return -1; } if (clientstate->ifd){ int rv; uint32 ifdoffset = clientstate->ifd; TRACE((""reading tiff ifd %u\n"", ifdoffset)); rv = TIFFSetSubDirectory(tiff, ifdoffset); if (!rv){ TRACE((""error in TIFFSetSubDirectory"")); return -1; } } if (TIFFIsTiled(tiff)) { UINT32 x, y, tile_y, row_byte_size; UINT32 tile_width, tile_length, current_tile_width; UINT8 *new_data; TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width); TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length); row_byte_size = (tile_width * state->bits + 7) / 8; state->bytes = row_byte_size * tile_length; if (state->bytes > INT_MAX - 1) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } new_data = realloc (state->buffer, state->bytes); if (!new_data) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } state->buffer = new_data; TRACE((""TIFFTileSize: %d\n"", state->bytes)); for (y = state->yoff; y < state->ysize; y += tile_length) { for (x = state->xoff; x < state->xsize; x += tile_width) { if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) { TRACE((""Decode Error, Tile at %dx%d\n"", x, y)); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } TRACE((""Read tile at %dx%d; \n\n"", x, y)); current_tile_width = min(tile_width, state->xsize - x); for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) { TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width)); state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize, state->buffer + tile_y * row_byte_size, current_tile_width ); } } } } else { UINT32 strip_row, row_byte_size; UINT8 *new_data; UINT32 rows_per_strip; int ret; ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip); if (ret != 1) { rows_per_strip = state->ysize; } TRACE((""RowsPerStrip: %u \n"", rows_per_strip)); row_byte_size = (state->xsize * state->bits + 7) / 8; state->bytes = rows_per_strip * row_byte_size; TRACE((""StripSize: %d \n"", state->bytes)); new_data = realloc (state->buffer, state->bytes); if (!new_data) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } state->buffer = new_data; for (; state->y < state->ysize; state->y += rows_per_strip) { if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) { TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0))); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } TRACE((""Decoded strip for row %d \n"", state->y)); for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) { TRACE((""Writing data into line %d ; \n"", state->y + strip_row)); state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] + state->xoff * im->pixelsize, state->buffer + strip_row * row_byte_size, state->xsize); } } } TIFFClose(tiff); TRACE((""Done Decoding, Returning \n"")); return -1; }"
"static void win_exchange(long Prenum) { frame_T*frp; frame_T*frp2; win_T*wp; win_T*wp2; inttemp; if (ERROR_IF_ANY_POPUP_WINDOW) return; if (ONE_WINDOW)        { beep_flush(); return; } #ifdef FEAT_GUI need_mouse_correct = TRUE; #endif if (Prenum) { frp = curwin->w_frame->fr_parent->fr_child; while (frp != NULL && --Prenum > 0) frp = frp->fr_next; } else if (curwin->w_frame->fr_next != NULL)frp = curwin->w_frame->fr_next; else    frp = curwin->w_frame->fr_prev; if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin) return; wp = frp->fr_win; wp2 = curwin->w_prev; frp2 = curwin->w_frame->fr_prev; if (wp->w_prev != curwin) { win_remove(curwin, NULL); frame_remove(curwin->w_frame); win_append(wp->w_prev, curwin); frame_insert(frp, curwin->w_frame); } if (wp != wp2) { win_remove(wp, NULL); frame_remove(wp->w_frame); win_append(wp2, wp); if (frp2 == NULL) frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame); else frame_append(frp2, wp->w_frame); } temp = curwin->w_status_height; curwin->w_status_height = wp->w_status_height; wp->w_status_height = temp; temp = curwin->w_vsep_width; curwin->w_vsep_width = wp->w_vsep_width; wp->w_vsep_width = temp; frame_fix_height(curwin); frame_fix_height(wp); frame_fix_width(curwin); frame_fix_width(wp); (void)win_comp_pos(); if (wp->w_buffer != curbuf) reset_VIsual_and_resel(); else if (VIsual_active) wp->w_cursor = curwin->w_cursor; win_enter(wp, TRUE); redraw_all_later(UPD_NOT_VALID); }"
"RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server, GeneralRequest* request, GeneralResponse* response) : RestVocbaseBaseHandler(server, request, response), _validFor(60 * 60 * 24 * 30) {}"
void ConnectDialog::on_qaUrl_triggered() { ServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem()); if (! si || si->qsUrl.isEmpty()) return; QDesktopServices::openUrl(QUrl(si->qsUrl)); }
"int verifyAttribute(struct MYSOFA_ATTRIBUTE *attr, char *name, char *value) { while (attr) { if (!strcmp(name, attr->name) && !strcmp(value, attr->value)) return 1; attr = attr->next; } return 0; }"
void rose_start_t3timer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); del_timer(&rose->timer); rose->timer.function = rose_timer_expiry; rose->timer.expires  = jiffies + rose->t3; add_timer(&rose->timer); }
"static void inline shadow_put_page_from_l1e(shadow_l1e_t sl1e, struct domain *d) { mfn_t mfn = shadow_l1e_get_mfn(sl1e); if ( !shadow_mode_refcounts(d) ) return; if ( mfn_valid(mfn) && page_refcounting_suppressed(mfn_to_page(mfn)) ) return; put_page_from_l1e(sl1e, d); }"
"void ReceiveMsg() { int left, len; static struct msg m; char *p; int ns = ServerSocket; struct win *wi; int recvfd = -1; struct acluser *user; bool is_socket; struct sockaddr_un a; struct msghdr msg; struct iovec iov; char control[1024]; is_socket = IsSocket(SockPath); if (!is_socket) { debug(""Ha, there was someone knocking on my fifo??\n""); if (fcntl(ServerSocket, F_SETFL, 0) == -1) Panic(errno, ""BLOCK fcntl""); p = (char *)&m; left = sizeof(m); } else { len = sizeof(a); debug(""Ha, there was someone knocking on my socket??\n""); if ((ns = accept(ns, (struct sockaddr *)&a, (void *)&len)) < 0) { Msg(errno, ""accept""); return; } p = (char *)&m; left = sizeof(m); bzero(&msg, sizeof(msg)); iov.iov_base = &m; iov.iov_len = left; msg.msg_iov = &iov; msg.msg_iovlen = 1; msg.msg_controllen = sizeof(control); msg.msg_control = &control; while (left > 0) { len = recvmsg(ns, &msg, 0); if (len < 0 && errno == EINTR) continue; if (len < 0) { close(ns); Msg(errno, ""read""); return; } if (msg.msg_controllen) { struct cmsghdr *cmsg; for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) { int cl; char *cp; if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) continue; cp = (char *)CMSG_DATA(cmsg); cl = cmsg->cmsg_len; while (cl >= CMSG_LEN(sizeof(int))) { int passedfd; bcopy(cp, &passedfd, sizeof(int)); if (recvfd >= 0 && passedfd != recvfd) close(recvfd); recvfd = passedfd; cl -= CMSG_LEN(sizeof(int)); } } } p += len; left -= len; break; } } while (left > 0) { len = read(ns, p, left); if (len < 0 && errno == EINTR) continue; if (len <= 0) break; p += len; left -= len; } if (!is_socket) { #ifndef BROKEN_PIPE close(ServerSocket); if ((ServerSocket = secopen(SockPath, O_RDONLY | O_NONBLOCK, 0)) < 0) Panic(errno, ""reopen fifo %s"", SockPath); evdeq(&serv_read); serv_read.fd = ServerSocket; evenq(&serv_read); #endif } else { close(ns); } if (len < 0) { Msg(errno, ""read""); if (recvfd != -1) close(recvfd); return; } if (left > 0) { if (left != sizeof(m)) Msg(0, ""Message %d of %d bytes too small"", left, (int)sizeof(m)); else debug(""No data on socket.\n""); return; } if (m.protocol_revision != MSG_REVISION) { if (recvfd != -1) close(recvfd); Msg(0, ""Invalid message (magic 0x%08x)."", m.protocol_revision); return; } debug2(""*** RecMsg: type %d tty %s\n"", m.type, m.m_tty); if (m.type != MSG_ATTACH && recvfd != -1) { close(recvfd); recvfd = -1; } for (display = displays; display; display = display->d_next) if (TTYCMP(D_usertty, m.m_tty) == 0) break; debug2(""display: %s display %sfound\n"", m.m_tty, display ? """" : ""not ""); wi = 0; if (!display) { for (wi = windows; wi; wi = wi->w_next) if (!TTYCMP(m.m_tty, wi->w_tty)) { display = wi->w_layer.l_cvlist ? wi->w_layer.l_cvlist->c_display : 0; debug2(""but window %s %sfound.\n"", m.m_tty, display ? """" : ""(backfacing)""); break; } } if (display && D_status) RemoveStatus(); if (display && !D_tcinited && m.type != MSG_HANGUP) { if (recvfd != -1) close(recvfd); return;  } switch (m.type) { case MSG_WINCH: if (display) CheckScreenSize(1);  break; case MSG_CREATE: ExecCreate(&m); break; case MSG_CONT: if (display && D_userpid != 0 && kill(D_userpid, 0) == 0) break;  debug2(""RecMsg: apid=%d,was %d\n"", m.m.attach.apid, display ? D_userpid : 0); case MSG_ATTACH: if (CreateTempDisplay(&m, recvfd, wi)) break; #ifdef PASSWORD if (D_user->u_password && *D_user->u_password) AskPassword(&m); else #endif FinishAttach(&m); break; case MSG_ERROR: { int blocked=D_blocked; if(D_blocked == 4)  D_blocked=0;  Msg(0, ""%s"", m.m.message); D_blocked=blocked; } break; case MSG_HANGUP: if (!wi)  Hangup(); break; #ifdef REMOTE_DETACH case MSG_DETACH: #ifdef POW_DETACH case MSG_POW_DETACH: #endif  #ifdef PASSWORD user = *FindUserPtr(m.m.detach.duser); if (user && user->u_password && *user->u_password) { if (CreateTempDisplay(&m, recvfd, 0)) break; AskPassword(&m); } else #endif  FinishDetach(&m); break; #endif case MSG_QUERY: { char *oldSockPath = SaveStr(SockPath); strcpy(SockPath, m.m.command.writeback); bool is_socket = IsSocket(SockPath); int s = MakeClientSocket(0, is_socket); strcpy(SockPath, oldSockPath); Free(oldSockPath); if (s >= 0) { queryflag = s; DoCommandMsg(&m); close(s); } else queryflag = -1; Kill(m.m.command.apid, (queryflag >= 0) ? SIGCONT : SIG_BYE);  queryflag = -1; } break; case MSG_COMMAND: DoCommandMsg(&m); break; default: Msg(0, ""Invalid message (type %d)."", m.type); } }"
"void rfbClientCleanup(rfbClient* client) { #ifdef LIBVNCSERVER_HAVE_LIBZ int i; for ( i = 0; i < 4; i++ ) { if (client->zlibStreamActive[i] == TRUE ) { if (inflateEnd (&client->zlibStream[i]) != Z_OK && client->zlibStream[i].msg != NULL) rfbClientLog(""inflateEnd: %s\n"", client->zlibStream[i].msg); } } if ( client->decompStreamInited == TRUE ) { if (inflateEnd (&client->decompStream) != Z_OK && client->decompStream.msg != NULL) rfbClientLog(""inflateEnd: %s\n"", client->decompStream.msg ); } #endif if (client->ultra_buffer) free(client->ultra_buffer); if (client->raw_buffer) free(client->raw_buffer); FreeTLS(client); while (client->clientData) { rfbClientData* next = client->clientData->next; free(client->clientData); client->clientData = next; } if (client->sock != RFB_INVALID_SOCKET) rfbCloseSocket(client->sock); if (client->listenSock != RFB_INVALID_SOCKET) rfbCloseSocket(client->listenSock); free(client->desktopName); free(client->serverHost); if (client->destHost) free(client->destHost); if (client->clientAuthSchemes) free(client->clientAuthSchemes); #ifdef LIBVNCSERVER_HAVE_SASL if (client->saslSecret) free(client->saslSecret); #endif  #ifdef WIN32 if(WSACleanup() != 0) { errno=WSAGetLastError(); rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(errno)); } #endif free(client); }"
"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth) { if (cid != ctx->cid) { const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid); if (!cid_table) { av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %""PRIu32""\n"", cid); return AVERROR(ENOSYS); } if (cid_table->bit_depth != bitdepth && cid_table->bit_depth != DNXHD_VARIABLE) { av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", cid_table->bit_depth, bitdepth); return AVERROR_INVALIDDATA; } ctx->cid_table = cid_table; av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %""PRIu32"".\n"", cid); ff_free_vlc(&ctx->ac_vlc); ff_free_vlc(&ctx->dc_vlc); ff_free_vlc(&ctx->run_vlc); init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257, ctx->cid_table->ac_bits, 1, 1, ctx->cid_table->ac_codes, 2, 2, 0); init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12, ctx->cid_table->dc_bits, 1, 1, ctx->cid_table->dc_codes, 1, 1, 0); init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62, ctx->cid_table->run_bits, 1, 1, ctx->cid_table->run_codes, 2, 2, 0); ctx->cid = cid; } return 0; }"
"DltReturnValue dlt_file_message(DltFile *file, int index, int verbose) { PRINT_FUNCTION_VERBOSE(verbose); if (file == NULL) return DLT_RETURN_WRONG_PARAMETER; if (index >= file->counter) { dlt_vlog(LOG_WARNING, ""Message %d out of range!\r\n"", index); return DLT_RETURN_WRONG_PARAMETER; } if (fseek(file->handle, file->index[index], SEEK_SET) != 0) { dlt_vlog(LOG_WARNING, ""Seek to message %d to position %ld failed!\r\n"", index, file->index[index]); return DLT_RETURN_ERROR; } if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; file->position = index; return DLT_RETURN_OK; }"
"int secure_decrypt(void *data, unsigned int data_length, int is_signed) { at91_aes_key_size_t key_size; unsigned int cmac_key[8], cipher_key[8]; unsigned int iv[AT91_AES_IV_SIZE_WORD]; unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD]; unsigned int fixed_length; const unsigned int *cmac; int rc = -1; init_keys(&key_size, cipher_key, cmac_key, iv); at91_aes_init(); if (is_signed) { if (at91_aes_cmac(data_length, data, computed_cmac, key_size, cmac_key)) goto exit; fixed_length = at91_aes_roundup(data_length); cmac = (const unsigned int *)((char *)data + fixed_length); if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE)) goto exit; } if (at91_aes_cbc(data_length, data, data, 0, key_size, cipher_key, iv)) goto exit; rc = 0; exit: at91_aes_cleanup(); memset(cmac_key, 0, sizeof(cmac_key)); memset(cipher_key, 0, sizeof(cipher_key)); memset(iv, 0, sizeof(iv)); return rc; }"
"GF_EXPORT GF_DOVIDecoderConfigurationRecord *gf_isom_dovi_config_get(GF_ISOFile* the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox* trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1); if (!entry || !entry->dovi_config) return NULL; return DOVI_DuplicateConfig(&entry->dovi_config->DOVIConfig); }"
"Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g, ControlFlowInfo* cf_info) { const int num_nodes = g->num_node_ids(); cf_info->frame_names.resize(num_nodes); std::vector<Node*> parent_nodes; parent_nodes.resize(num_nodes); std::vector<bool> visited; visited.resize(num_nodes); string frame_name; std::deque<Node*> ready; for (Node* n : g->nodes()) { if (n->in_edges().empty()) { visited[n->id()] = true; cf_info->unique_frame_names.insert(frame_name); ready.push_back(n); } } while (!ready.empty()) { Node* curr_node = ready.front(); int curr_id = curr_node->id(); ready.pop_front(); Node* parent = nullptr; if (IsEnter(curr_node)) { TF_RETURN_IF_ERROR( GetNodeAttr(curr_node->attrs(), ""frame_name"", &frame_name)); parent = curr_node; } else if (IsExit(curr_node)) { parent = parent_nodes[curr_id]; frame_name = cf_info->frame_names[parent->id()]; parent = parent_nodes[parent->id()]; } else { parent = parent_nodes[curr_id]; frame_name = cf_info->frame_names[curr_id]; } for (const Edge* out_edge : curr_node->out_edges()) { Node* out = out_edge->dst(); if (IsSink(out)) continue; const int out_id = out->id(); bool is_visited = visited[out_id]; if (!is_visited) { ready.push_back(out); visited[out_id] = true; cf_info->frame_names[out_id] = frame_name; parent_nodes[out_id] = parent; cf_info->unique_frame_names.insert(frame_name); } } } return Status::OK(); }"
static void drop_futex_key_refs(union futex_key *key) { if (!key->both.ptr) { WARN_ON_ONCE(1); return; } if (!IS_ENABLED(CONFIG_MMU)) return; switch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) { case FUT_OFF_INODE: iput(key->shared.inode); break; case FUT_OFF_MMSHARED: mmdrop(key->private.mm); break; } }
"static void __evtchn_fifo_handle_events(unsigned cpu, bool drop) { struct evtchn_fifo_control_block *control_block; unsigned long ready; unsigned q; control_block = per_cpu(cpu_control_block, cpu); ready = xchg(&control_block->ready, 0); while (ready) { q = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES); consume_one_event(cpu, control_block, q, &ready, drop); ready |= xchg(&control_block->ready, 0); } }"
"static int r_jwe_aesgcm_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) { int ret, res; unsigned char iv[96] = {0}, * key = NULL, cipherkey[64] = {0}, tag[128] = {0}, tag_b64url[256] = {0}; size_t iv_len = 0, key_len = 0, cipherkey_len = 0, tag_b64url_len = 0, tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg)); unsigned int bits = 0; gnutls_datum_t key_g, iv_g; gnutls_cipher_hd_t handle = NULL; if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && o_strlen(r_jwe_get_header_str_value(jwe, ""iv"")) && o_strlen(r_jwe_get_header_str_value(jwe, ""tag""))) { ret = RHN_OK; key_len = bits; do { if ((key = o_malloc(key_len+4)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error allocating resources for key""); ret = RHN_ERROR_MEMORY; break; } if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error r_jwk_export_to_symmetric_key""); ret = RHN_ERROR; break; } if (!o_base64url_decode((const unsigned char *)r_jwe_get_header_str_value(jwe, ""iv""), o_strlen(r_jwe_get_header_str_value(jwe, ""iv"")), iv, &iv_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_decode iv""); ret = RHN_ERROR_INVALID; break; } if (!o_base64url_decode((const unsigned char *)jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_decode cipherkey""); ret = RHN_ERROR_INVALID; break; } key_g.data = key; key_g.size = key_len; iv_g.data = iv; iv_g.size = iv_len; if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_init: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR_INVALID; break; } if ((res = gnutls_cipher_decrypt(handle, cipherkey, cipherkey_len))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_decrypt: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR; break; } if ((res = gnutls_cipher_tag(handle, tag, tag_len))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_tag: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR; break; } if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_encode tag""); ret = RHN_ERROR; break; } tag_b64url[tag_b64url_len] = '\0'; if (0 != o_strcmp((const char *)tag_b64url, r_jwe_get_header_str_value(jwe, ""tag""))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Invalid tag %s %s"", tag_b64url, r_jwe_get_header_str_value(jwe, ""tag"")); ret = RHN_ERROR_INVALID; break; } if (r_jwe_set_cypher_key(jwe, cipherkey, cipherkey_len) != RHN_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error r_jwe_set_cypher_key""); ret = RHN_ERROR; } } while (0); o_free(key); if (handle != NULL) { gnutls_cipher_deinit(handle); } } else { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error invalid key""); ret = RHN_ERROR_INVALID; } return ret; }"
"int win_alloc_lines(win_T *wp) { wp->w_lines_valid = 0; wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows ); if (wp->w_lines == NULL) return FAIL; return OK; }"
"GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex) { GF_DataEntryURLBox *entry; GF_DataMap *map; GF_Err e; if (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM; entry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1); if (!entry) return GF_ISOM_INVALID_FILE; if (entry->flags == 1) return GF_OK; if (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED; if (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) { e = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map); } else { e = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map); } if (e) return e; gf_isom_datamap_del(map); return GF_OK; }"
"void ldbRedis(lua_State *lua, sds *argv, int argc) { int j, saved_rc = server.lua_replicate_commands; lua_getglobal(lua,""redis""); lua_pushstring(lua,""call""); lua_gettable(lua,-2);        for (j = 1; j < argc; j++) lua_pushlstring(lua,argv[j],sdslen(argv[j])); ldb.step = 1;                server.lua_replicate_commands = 1; lua_pcall(lua,argc-1,1,0);   ldb.step = 0;                server.lua_replicate_commands = saved_rc; lua_pop(lua,2);              }"
"bool TransactionSync::importDownloadedTxs( NodeIDPtr _fromNode, TransactionsPtr _txs, Block::Ptr _verifiedProposal) { if (_txs->size() == 0) { return true; } auto txsSize = _txs->size(); bool enforceImport = false; BlockHeader::Ptr proposalHeader = nullptr; if (_verifiedProposal && _verifiedProposal->blockHeader()) { proposalHeader = _verifiedProposal->blockHeader(); enforceImport = true; } auto recordT = utcTime(); auto startT = utcTime(); std::atomic_bool verifySuccess = {true}; tbb::parallel_for( tbb::blocked_range<size_t>(0, txsSize), [&](const tbb::blocked_range<size_t>& _r) { for (size_t i = _r.begin(); i < _r.end(); i++) { auto tx = (*_txs)[i]; if (!tx) { continue; } tx->appendKnownNode(_fromNode); if (_verifiedProposal && proposalHeader) { tx->setBatchId(proposalHeader->number()); tx->setBatchHash(proposalHeader->hash()); } if (m_config->txpoolStorage()->exist(tx->hash())) { continue; } try { tx->verify(); } catch (std::exception const& e) { tx->setInvalid(true); SYNC_LOG(WARNING) << LOG_DESC(""verify sender for tx failed"") << LOG_KV(""reason"", boost::diagnostic_information(e)) << LOG_KV(""hash"", tx->hash().abridged()); verifySuccess = false; } } }); if (enforceImport && !verifySuccess) { return false; } auto verifyT = utcTime() - startT; startT = utcTime(); auto txpool = m_config->txpoolStorage(); size_t successImportTxs = 0; for (size_t i = 0; i < txsSize; i++) { auto tx = (*_txs)[i]; if (tx->invalid()) { continue; } auto result = txpool->submitTransaction( std::const_pointer_cast<Transaction>(tx), nullptr, enforceImport); if (result != TransactionStatus::None) { if (enforceImport) { SYNC_LOG(DEBUG) << LOG_BADGE(""importDownloadedTxs: verify proposal failed"") << LOG_KV(""tx"", tx->hash().abridged()) << LOG_KV(""result"", result) << LOG_KV(""propIndex"", proposalHeader->number()) << LOG_KV(""propHash"", proposalHeader->hash().abridged()); return false; } SYNC_LOG(TRACE) << LOG_BADGE(""importDownloadedTxs"") << LOG_DESC(""Import transaction into txpool failed"") << LOG_KV(""errorCode"", result) << LOG_KV(""tx"", tx->hash().abridged()); continue; } successImportTxs++; } SYNC_LOG(DEBUG) << LOG_DESC(""importDownloadedTxs success"") << LOG_KV(""nodeId"", m_config->nodeID()->shortHex()) << LOG_KV(""successImportTxs"", successImportTxs) << LOG_KV(""totalTxs"", txsSize) << LOG_KV(""verifyT"", verifyT) << LOG_KV(""submitT"", (utcTime() - startT)) << LOG_KV(""timecost"", (utcTime() - recordT)); return true; }"
"R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut32 i = 0; RBinJavaBootStrapMethod *bsm = NULL; ut64 offset = 0; RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); offset += 6; if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR; attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free); for (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) { if (offset >= sz) { break; } bsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset); if (bsm) { offset += bsm->size; r_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm); } else { } } attr->size = offset; } return attr; }"
"static char_u * skip_string(char_u *p) { int    i; for ( ; ; ++p) { if (p[0] == '\'')    { if (p[1] == NUL)    break; i = 2; if (p[1] == '\\' && p[2] != NUL)        { ++i; while (vim_isdigit(p[i - 1]))       ++i; } if (p[i] == '\'')        { p += i; continue; } } else if (p[0] == '""')    { for (++p; p[0]; ++p) { if (p[0] == '\\' && p[1] != NUL) ++p; else if (p[0] == '""')        break; } if (p[0] == '""') continue; } else if (p[0] == 'R' && p[1] == '""') { char_u *delim = p + 2; char_u *paren = vim_strchr(delim, '('); if (paren != NULL) { size_t delim_len = paren - delim; for (p += 3; *p; ++p) if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0 && p[delim_len + 1] == '""') { p += delim_len + 1; break; } if (p[0] == '""') continue;     } } break;        } if (!*p) --p;        return p; }"
"static Jsi_RC MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_RC rc = JSI_OK; MySqlObj *jdb; if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR; Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0); Jsi_DString eStr = {}; JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE); const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0); Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1); int cnt = 0; char **apColName = NULL; Jsi_OptionId *apColType = NULL; int isopts = 0; MyDbEvalContext sEval = {}; QueryOpts opts, *oEopt = NULL; opts = jdb->queryOpts; opts.callback = NULL; opts.width = NULL; Jsi_Value *callback = NULL, *width = NULL; if (arg) { if (Jsi_ValueIsFunction(interp,arg)) callback = opts.callback = arg; else if (Jsi_ValueIsString(interp, arg)) opts.objName = Jsi_ValueString(interp, arg, NULL); else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY)) opts.values = arg; else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) isopts = 1; else  { rc = Jsi_LogError(""argument must be null, a function, string, array or options""); goto bail; } } if (isopts) { if (Jsi_OptionsProcess(interp, QueryFmtOptions, &opts, arg, 0) < 0) { rc = JSI_ERROR; goto bail; } callback = (opts.callback ? opts.callback : jdb->queryOpts.callback); width = (opts.width ? opts.width : jdb->queryOpts.width); } if (opts.objName) { if (Jsi_SqlObjBinds(interp, &eStr, opts.objName,  !(opts.objOpts&OBJMODE_NOTYPES),  !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK) goto bail; zSql = Jsi_DSValue(&eStr); } if (!opts.separator) { switch (opts.mode) { case _mdb_EF_LIST: opts.separator = ""|""; break; case _mdb_EF_COLUMN: opts.separator = "" ""; break; case _mdb_EF_TABS: opts.separator = ""\t""; break; default: opts.separator = "",""; } } Jsi_DString sStr; Jsi_DSInit(&sStr); sEval.nocache = opts.nocache; if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) { rc = JSI_ERROR; goto bail; } sEval.namedParams = (opts.noNamedParams==0 && !opts.values); sEval.ret = *ret; oEopt = jdb->optPtr; jdb->optPtr = &opts; if (sEval.namedParams) { rc = mdbEvalPrep(&sEval); if (rc == JSI_ERROR) goto bail; if (rc == JSI_BREAK) { rc = JSI_OK; goto bail; } } if (opts.mode == _mdb_EF_NONE) goto bail; if (callback) { sEval.tocall = callback; if (opts.mode != _mdb_EF_ROWS) rc = Jsi_LogError(""'mode' must be 'rows' with 'callback'""); else  rc = mdbEvalCallCmd(&sEval, interp, JSI_OK); goto bail; } switch (opts.mode) { case _mdb_EF_NONE: while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) { cnt++; if (opts.limit && cnt>=opts.limit) break; } goto bail; break; case _mdb_EF_JSON: if (opts.headers) { Jsi_DSAppend(dStr, ""[ "", NULL); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0) { Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); } Jsi_DSAppend(dStr, ""]"", NULL); cnt++; } if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, ""]"", NULL); cnt++; if (opts.limit && cnt>opts.limit) break; } Jsi_DSAppend(dStr, "" ]"", NULL); } else { Jsi_DSAppend(dStr, ""[ "", NULL); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""{"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); Jsi_DSAppend(dStr, "":"", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, ""}"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSAppend(dStr, "" ]"", NULL); } break; case _mdb_EF_JSON2: { while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && 1) { Jsi_DSAppend(dStr, ""{ \""names\"": [ "", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); } Jsi_DSAppend(dStr, "" ], \""values\"": [ "", NULL); } if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, "" ]"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } if (cnt) Jsi_DSAppend(dStr, "" ] } "", NULL); } break; case _mdb_EF_LIST: while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(dStr, apColName[i], NULL); } } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); mdbEvalSetColumn(&sEval, i, dStr); } cnt++; if (opts.limit && cnt>=opts.limit) break; } break; case _mdb_EF_COLUMN: { int *wids = NULL; Jsi_DString vStr = {}; while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i, w; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && nCol>0) { Jsi_DString sStr; wids = (int*)Jsi_Calloc(nCol, sizeof(int)); Jsi_DSInit(&sStr); for(i=0; i<nCol; i++) { int j = Jsi_Strlen(apColName[i]); wids[i] = (j<10?10:j); if (width) { Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i); if (wv) { Jsi_Number dv; Jsi_ValueGetNumber(interp, wv, &dv); if (dv>0) wids[i] = (int)dv; } } w = (j<wids[i] ? j : wids[i]); Jsi_DSAppendLen(dStr, apColName[i], w); w = (j<wids[i] ? wids[i]-j+1 : 0); while (w-- > 0) Jsi_DSAppend(dStr, "" "", NULL); } for(i=0; i<nCol && opts.headers; i++) { w = wids[i]; w -= Jsi_Strlen(apColName[i]); if (i) { Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(&sStr, opts.separator, NULL); } w = wids[i]; while (w-- > 0) Jsi_DSAppend(&sStr, ""-"", NULL); } if (opts.headers) Jsi_DSAppend(dStr, ""\n"", Jsi_DSValue(&sStr), ""\n"", NULL); Jsi_DSFree(&sStr); } if (cnt) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); int nl = Jsi_DSLength(&vStr); if (nl > wids[i]) { Jsi_DSSetLength(&vStr, wids[i]); w = 0; } else { w = wids[i]-nl; } Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL); while (w-- > 0) Jsi_DSAppend(dStr, "" "", NULL); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); if (wids) Jsi_Free(wids); break; } case _mdb_EF_INSERT: { Jsi_DString vStr = {};     while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; const char *tbl = (opts.table ? opts.table : ""table""); if (cnt) Jsi_DSAppend(dStr, ""\n"", NULL); Jsi_DSAppend(dStr, ""INSERT INTO "", tbl, "" VALUES("", NULL); mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); for(i=0; i<nCol; i++) { Jsi_Number dv; const char *azArg; Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); MysqlPrep *prep = sEval.prep; Jsi_OptionId ptype = prep->fieldResult[i].jsiTypeMap; azArg = Jsi_DSValue(&vStr); const char *zSep = i>0 ? "","": """"; if (azArg[i]==0 && ptype != JSI_OPTION_STRING) { Jsi_DSAppend(dStr, zSep, ""NULL"", NULL); } else if( ptype ==JSI_OPTION_STRING) { if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL); mdbOutputQuotedString(dStr, azArg); } else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) { Jsi_DSAppend(dStr, zSep, azArg, NULL); } else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ) { Jsi_DSAppend(dStr, zSep, azArg, NULL); } else { if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL); mdbOutputQuotedString(dStr, azArg); } } Jsi_DSAppend(dStr, "");"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); } case _mdb_EF_TABS: case _mdb_EF_CSV: { Jsi_DString vStr = {};   while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(dStr, apColName[i], NULL); } } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); if (opts.mode == _mdb_EF_CSV) mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0); else Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_LINE: { int i, w = 5, ww; int nCol; Jsi_DString vStr = {};    while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0) { for(i=0; i<nCol; i++) { ww = Jsi_Strlen(apColName[i]); if (ww>w) w = ww; } } for(i=0; i<nCol; i++) { Jsi_DString eStr; Jsi_DSInit(&eStr); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); Jsi_DSPrintf(&eStr, ""%*s = %s"", w, apColName[i], Jsi_DSValue(&vStr)); Jsi_DSAppend(dStr, (cnt?""\n"":""""), Jsi_DSValue(&eStr), NULL); Jsi_DSFree(&eStr); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_HTML: { Jsi_DString vStr = {};    while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { Jsi_DSAppend(dStr, ""<TR>"", NULL); for(i=0; i<nCol; i++) { Jsi_DSAppend(dStr, ""<TH>"", NULL); mdbOutputHtmlString(&opts, apColName[i], dStr); Jsi_DSAppend(dStr, ""</TH>"", NULL); } Jsi_DSAppend(dStr, ""</TR>"", NULL); } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); Jsi_DSAppend(dStr, ""<TR>"", NULL); for(i=0; i<nCol; i++) { Jsi_DSAppend(dStr, ""<TD>"", NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr); Jsi_DSAppend(dStr, ""</TD>"", NULL); } Jsi_DSAppend(dStr, ""</TR>"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_ROWS: { Jsi_Value *vcur, *vrow; int cnt = 0; Jsi_Obj *oall, *ocur; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT); vrow = Jsi_ValueMakeObject(interp, NULL, ocur); for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0); } Jsi_ObjArrayAdd(interp, oall, vrow); cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } case _mdb_EF_ARRAYS: { Jsi_Value *vcur, *vrow; int cnt = 0; Jsi_Obj *oall, *ocur; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); for(i=0; i<nCol; i++) { vcur = Jsi_ValueNewStringDup(interp, apColName[i]); Jsi_ObjArrayAdd(interp, ocur, vcur); } Jsi_ObjArrayAdd(interp, oall, vrow); } vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjArrayAdd(interp, ocur, vcur); } Jsi_ObjArrayAdd(interp, oall, vrow); cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } case _mdb_EF_ARRAY1D: { Jsi_Value *vcur; int cnt = 0; Jsi_Obj *oall; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { vcur = Jsi_ValueNewStringDup(interp, apColName[i]); Jsi_ObjArrayAdd(interp, oall, vcur); } } for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjArrayAdd(interp, oall, vcur); } cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } } if( rc==JSI_BREAK ) { rc = JSI_OK; } Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr)); bail: mdbEvalFinalize(&sEval); if (isopts) { Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0); } Jsi_DSFree(dStr); Jsi_DSFree(&eStr); jdb->optPtr = oEopt; return rc; }"
"void sqlc_union_order (sql_comp_t * sc, ST ** ptree) { ST * out = sqlc_union_dt_wrap (*ptree); if (out != *ptree) { *ptree = out; sql_stmt_comp (sc, ptree); } else sqlc_union_stmt (sc, ptree); }"
"static int bigben_probe(struct hid_device *hid, const struct hid_device_id *id) { struct bigben_device *bigben; struct hid_input *hidinput; struct list_head *report_list; struct led_classdev *led; char *name; size_t name_sz; int n, error; bigben = devm_kzalloc(&hid->dev, sizeof(*bigben), GFP_KERNEL); if (!bigben) return -ENOMEM; hid_set_drvdata(hid, bigben); bigben->hid = hid; bigben->removed = false; error = hid_parse(hid); if (error) { hid_err(hid, ""parse failed\n""); return error; } error = hid_hw_start(hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF); if (error) { hid_err(hid, ""hw start failed\n""); return error; } report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list; bigben->report = list_entry(report_list->next, struct hid_report, list); hidinput = list_first_entry(&hid->inputs, struct hid_input, list); set_bit(FF_RUMBLE, hidinput->input->ffbit); INIT_WORK(&bigben->worker, bigben_worker); error = input_ff_create_memless(hidinput->input, NULL, hid_bigben_play_effect); if (error) goto error_hw_stop; name_sz = strlen(dev_name(&hid->dev)) + strlen("":red:bigben#"") + 1; for (n = 0; n < NUM_LEDS; n++) { led = devm_kzalloc( &hid->dev, sizeof(struct led_classdev) + name_sz, GFP_KERNEL ); if (!led) { error = -ENOMEM; goto error_hw_stop; } name = (void *)(&led[1]); snprintf(name, name_sz, ""%s:red:bigben%d"", dev_name(&hid->dev), n + 1 ); led->name = name; led->brightness = (n == 0) ? LED_ON : LED_OFF; led->max_brightness = 1; led->brightness_get = bigben_get_led; led->brightness_set = bigben_set_led; bigben->leds[n] = led; error = devm_led_classdev_register(&hid->dev, led); if (error) goto error_hw_stop; } bigben->led_state = BIT(0); bigben->right_motor_on = 0; bigben->left_motor_force = 0; bigben->work_led = true; bigben->work_ff = true; schedule_work(&bigben->worker); hid_info(hid, ""LED and force feedback support for BigBen gamepad\n""); return 0; error_hw_stop: hid_hw_stop(hid); return error; }"
"txScript* fxLoadScript(txMachine* the, txString path, txUnsigned flags) { txParser _parser; txParser* parser = &_parser; txParserJump jump; FILE* file = NULL; txString name = NULL; char map[C_PATH_MAX]; txScript* script = NULL; fxInitializeParser(parser, the, the->parserBufferSize, the->parserTableModulo); parser->firstJump = &jump; file = fopen(path, ""r""); if (c_setjmp(jump.jmp_buf) == 0) { mxParserThrowElse(file); parser->path = fxNewParserSymbol(parser, path); fxParserTree(parser, file, (txGetter)fgetc, flags, &name); fclose(file); file = NULL; if (name) { txString slash = c_strrchr(path, mxSeparator); if (slash) *slash = 0; c_strcat(path, name); mxParserThrowElse(c_realpath(path, map)); parser->path = fxNewParserSymbol(parser, map); file = fopen(map, ""r""); mxParserThrowElse(file); fxParserSourceMap(parser, file, (txGetter)fgetc, flags, &name); fclose(file); file = NULL; if (parser->errorCount == 0) { if (slash) *slash = 0; c_strcat(path, name); mxParserThrowElse(c_realpath(path, map)); parser->path = fxNewParserSymbol(parser, map); } } fxParserHoist(parser); fxParserBind(parser); script = fxParserCode(parser); } if (file) fclose(file); #ifdef mxInstrument if (the->peakParserSize < parser->total) the->peakParserSize = parser->total; #endif fxTerminateParser(parser); return script; }"
"void Compute(OpKernelContext* context) override { const Tensor& input = context->input(0); float input_min = context->input(1).flat<float>()(0); float input_max = context->input(2).flat<float>()(0); float input_scale = (input_max - input_min) / 255.0f; OP_REQUIRES(context, input_min < input_max, errors::InvalidArgument( ""input_min must be less than input_max : "", input_min, "" >= "", input_max)); auto input_tensor = input.tensor<quint8, 4>(); auto N = input_tensor.dimension(0); auto H = input_tensor.dimension(1); auto W = input_tensor.dimension(2); auto C = input_tensor.dimension(3); Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output(0, input.shape(), &output)); Tensor* output_min = nullptr; OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min)); Tensor* output_max = nullptr; OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max)); typedef TTypes<float>::Tensor::Index Index; const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>> reduction_indices; Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>> broadcast_spec; broadcast_spec.set(1, H); broadcast_spec.set(2, W); Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index> expand_spec; expand_spec.set(0, N); expand_spec.set(3, C); Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C); Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C); #ifdef USE_NEON if (N == 1 && (C % 16 == 0)) { VLOG(2) << ""Calling optimized""; ColMeanAndVariance(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data()); float minimum = given_y_min_, maximum = given_y_max_; if (!output_range_given_) { MinAndMax(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data(), variance_epsilon_, &minimum, &maximum); } if (maximum - minimum < min_separation_) { maximum = minimum + min_separation_; } InstanceNorm(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data(), variance_epsilon_, minimum, maximum, reinterpret_cast<uint8_t*>(output->flat<quint8>().data())); output_min->scalar<float>()() = minimum; output_max->scalar<float>()() = maximum; } else  #endif { VLOG(2) << ""Calling unoptimized""; float_mean = input_tensor.cast<float>().reduce( reduction_indices, Eigen::internal::MeanReducer<float>()); float_variance = (input_scale * ((input_tensor.cast<float>() - float_mean.reshape(expand_spec).broadcast(broadcast_spec)))) .square() .reduce(reduction_indices, Eigen::internal::MeanReducer<float>()); Eigen::Tensor<float, 4, Eigen::RowMajor> instance_normed = input_scale * (input_tensor.cast<float>() - float_mean.reshape(expand_spec).broadcast(broadcast_spec)) * (float_variance + variance_epsilon_) .rsqrt() .reshape(expand_spec) .broadcast(broadcast_spec); Eigen::Tensor<float, 0, Eigen::RowMajor> normed_min; Eigen::Tensor<float, 0, Eigen::RowMajor> normed_max; if (!output_range_given_) { normed_min = instance_normed.minimum(); normed_max = instance_normed.maximum(); } else { normed_min() = given_y_min_; normed_max() = given_y_max_; } if (normed_max() - normed_min() < min_separation_) { normed_max() = normed_min() + min_separation_; } FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max()); auto instance_normed_quantized = QUANTIZE_WITH_EIGEN(instance_normed, output_f2q, quint8); output->tensor<quint8, 4>().device( context->template eigen_device<CPUDevice>()) = instance_normed_quantized; output_min->flat<float>()(0) = normed_min(); output_max->flat<float>()(0) = normed_max(); } }"
"void StartAdvertisingSet(int reg_id, IdTxPowerStatusCallback register_cb, AdvertiseParameters params, std::vector<uint8_t> advertise_data, std::vector<uint8_t> scan_response_data, PeriodicAdvertisingParameters periodic_params, std::vector<uint8_t> periodic_data, uint16_t duration, uint8_t maxExtAdvEvents, IdStatusCallback timeout_cb) { LOG(INFO) << __func__ << "" in shim layer""; bluetooth::hci::ExtendedAdvertisingConfig config{}; parse_parameter(config, params); bluetooth::hci::PeriodicAdvertisingParameters periodic_parameters; periodic_parameters.max_interval = periodic_params.max_interval; periodic_parameters.min_interval = periodic_params.min_interval; periodic_parameters.properties = periodic_params.periodic_advertising_properties; config.periodic_advertising_parameters = periodic_parameters; size_t offset = 0; while (offset < advertise_data.size()) { GapData gap_data; uint8_t len = advertise_data[offset]; auto begin = advertise_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.advertisement.push_back(gap_data); offset += len + 1;      } offset = 0; while (offset < scan_response_data.size()) { GapData gap_data; uint8_t len = scan_response_data[offset]; auto begin = scan_response_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.scan_response.push_back(gap_data); offset += len + 1;      } offset = 0; while (offset < periodic_data.size()) { GapData gap_data; uint8_t len = periodic_data[offset]; auto begin = periodic_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.periodic_data.push_back(gap_data); offset += len + 1;      } bluetooth::hci::AdvertiserId id = bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser( reg_id, config, scan_callback, set_terminated_callback, duration, maxExtAdvEvents, bluetooth::shim::GetGdShimHandler()); LOG(INFO) << ""create advertising set, reg_id:"" << reg_id << "", id:"" << (uint16_t)id; BTM_LogHistory(kBtmLogTag, RawAddress::kEmpty, ""Le advert started"", base::StringPrintf(""advert_id:%d"", reg_id)); }"
"void TileManager::crop( RawTile *ttt ){ int tw = image->getTileWidth(); int th = image->getTileHeight(); if( loglevel >= 5 ){ *logfile << ""TileManager :: Edge tile: Base size: "" << tw << ""x"" << th << "": This tile: "" << ttt->width << ""x"" << ttt->height << endl; } int len = tw * th * ttt->channels * (ttt->bpc/8); unsigned char* buffer = (unsigned char*) malloc( len ); unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len ); unsigned char* dst_ptr = (unsigned char*) ttt->data; len =  ttt->width * ttt->channels * (ttt->bpc/8); for( unsigned int i=0; i<ttt->height; i++ ){ memcpy( dst_ptr, src_ptr, len ); dst_ptr += len; src_ptr += tw * ttt->channels * (ttt->bpc/8); } free( buffer ); len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8); ttt->dataLength = len; ttt->padded = false; }"
"static void inputSendThreadProc(void* context) { SOCK_RET err; PPACKET_HOLDER holder; char encryptedBuffer[MAX_INPUT_PACKET_SIZE]; int encryptedSize; while (!PltIsThreadInterrupted(&inputSendThread)) { int encryptedLengthPrefix; err = LbqWaitForQueueElement(&packetQueue, (void**)&holder); if (err != LBQ_SUCCESS) { return; } if (holder->packet.multiController.header.packetType == htonl(PACKET_TYPE_MULTI_CONTROLLER)) { PPACKET_HOLDER controllerBatchHolder; PNV_MULTI_CONTROLLER_PACKET origPkt; int dirs[6]; memset(dirs, 0, sizeof(dirs)); origPkt = &holder->packet.multiController; for (;;) { PNV_MULTI_CONTROLLER_PACKET newPkt; if (LbqPeekQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) { break; } if (controllerBatchHolder->packet.multiController.header.packetType != htonl(PACKET_TYPE_MULTI_CONTROLLER)) { break; } newPkt = &controllerBatchHolder->packet.multiController; if (newPkt->buttonFlags != origPkt->buttonFlags || newPkt->controllerNumber != origPkt->controllerNumber || !checkDirs(origPkt->leftTrigger, newPkt->leftTrigger, &dirs[0]) || !checkDirs(origPkt->rightTrigger, newPkt->rightTrigger, &dirs[1]) || !checkDirs(origPkt->leftStickX, newPkt->leftStickX, &dirs[2]) || !checkDirs(origPkt->leftStickY, newPkt->leftStickY, &dirs[3]) || !checkDirs(origPkt->rightStickX, newPkt->rightStickX, &dirs[4]) || !checkDirs(origPkt->rightStickY, newPkt->rightStickY, &dirs[5])) { break; } if (LbqPollQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) { break; } origPkt->leftTrigger = newPkt->leftTrigger; origPkt->rightTrigger = newPkt->rightTrigger; origPkt->leftStickX = newPkt->leftStickX; origPkt->leftStickY = newPkt->leftStickY; origPkt->rightStickX = newPkt->rightStickX; origPkt->rightStickY = newPkt->rightStickY; free(controllerBatchHolder); } } else if (holder->packet.mouseMove.header.packetType == htonl(PACKET_TYPE_MOUSE_MOVE)) { PPACKET_HOLDER mouseBatchHolder; int totalDeltaX = (short)htons(holder->packet.mouseMove.deltaX); int totalDeltaY = (short)htons(holder->packet.mouseMove.deltaY); for (;;) { int partialDeltaX; int partialDeltaY; if (LbqPeekQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) { break; } if (mouseBatchHolder->packet.mouseMove.header.packetType != htonl(PACKET_TYPE_MOUSE_MOVE)) { break; } partialDeltaX = (short)htons(mouseBatchHolder->packet.mouseMove.deltaX); partialDeltaY = (short)htons(mouseBatchHolder->packet.mouseMove.deltaY); if (partialDeltaX + totalDeltaX > INT16_MAX || partialDeltaX + totalDeltaX < INT16_MIN || partialDeltaY + totalDeltaY > INT16_MAX || partialDeltaY + totalDeltaY < INT16_MIN) { break; } if (LbqPollQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) { break; } totalDeltaX += partialDeltaX; totalDeltaY += partialDeltaY; free(mouseBatchHolder); } holder->packet.mouseMove.deltaX = htons((short)totalDeltaX); holder->packet.mouseMove.deltaY = htons((short)totalDeltaY); } encryptedSize = sizeof(encryptedBuffer) - 4; err = encryptData((const unsigned char*)&holder->packet, holder->packetLength, (unsigned char*)&encryptedBuffer[4], &encryptedSize); free(holder); if (err != 0) { Limelog(""Input: Encryption failed: %d\n"", (int)err); ListenerCallbacks.connectionTerminated(err); return; } encryptedLengthPrefix = htonl((unsigned long)encryptedSize); memcpy(&encryptedBuffer[0], &encryptedLengthPrefix, 4); if (ServerMajorVersion < 5) { err = send(inputSock, (const char*) encryptedBuffer, (int) (encryptedSize + sizeof(encryptedLengthPrefix)), 0); if (err <= 0) { Limelog(""Input: send() failed: %d\n"", (int) LastSocketError()); ListenerCallbacks.connectionTerminated(LastSocketError()); return; } } else { if (ServerMajorVersion >= 7 && encryptedSize >= 16 + sizeof(currentAesIv)) { memcpy(currentAesIv, &encryptedBuffer[4 + encryptedSize - sizeof(currentAesIv)], sizeof(currentAesIv)); } err = (SOCK_RET)sendInputPacketOnControlStream((unsigned char*) encryptedBuffer, (int) (encryptedSize + sizeof(encryptedLengthPrefix))); if (err < 0) { Limelog(""Input: sendInputPacketOnControlStream() failed: %d\n"", (int) err); ListenerCallbacks.connectionTerminated(LastSocketError()); return; } } } }"
"static int MqttClient_WaitType(MqttClient *client, void *packet_obj, byte wait_type, word16 wait_packet_id, int timeout_ms) { int rc; word16 packet_id; MqttPacketType packet_type; #ifdef WOLFMQTT_MULTITHREAD MqttPendResp *pendResp; int readLocked; #endif MqttMsgStat* mms_stat; int waitMatchFound; if (client == NULL || packet_obj == NULL) { return MQTT_CODE_ERROR_BAD_ARG; } mms_stat = (MqttMsgStat*)packet_obj; wait_again: packet_id = 0; packet_type = MQTT_PACKET_TYPE_RESERVED; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; readLocked = 0; #endif waitMatchFound = 0; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Type %s (%d), ID %d"", MqttPacket_TypeDesc((MqttPacketType)wait_type), wait_type, wait_packet_id); #endif switch ((int)*mms_stat) { case MQTT_MSG_BEGIN: { #ifdef WOLFMQTT_MULTITHREAD rc = wm_SemLock(&client->lockRecv); if (rc != 0) { PRINTF(""MqttClient_WaitType: recv lock error!""); return rc; } readLocked = 1; #endif client->packet.stat = MQTT_PK_BEGIN; } FALL_THROUGH; #ifdef WOLFMQTT_V5 case MQTT_MSG_AUTH: #endif case MQTT_MSG_WAIT: { #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,  wait_packet_id, &pendResp)) { if (pendResp->packetDone) { rc = pendResp->packet_ret; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp already Done %p: Rc %d"", pendResp, rc); #endif MqttClient_RespList_Remove(client, pendResp); wm_SemUnlock(&client->lockClient); wm_SemUnlock(&client->lockRecv); return rc; } } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  *mms_stat = MQTT_MSG_WAIT; rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len, timeout_ms); if (rc <= 0) { break; } client->packet.buf_len = rc; rc = MqttClient_DecodePacket(client, client->rx_buf, client->packet.buf_len, NULL, &packet_type, NULL, &packet_id); if (rc < 0) { break; } #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""Read Packet: Len %d, Type %d, ID %d"", client->packet.buf_len, packet_type, packet_id); #endif *mms_stat = MQTT_MSG_READ; } FALL_THROUGH; case MQTT_MSG_READ: case MQTT_MSG_READ_PAYLOAD: { MqttPacketType use_packet_type; void* use_packet_obj; #ifdef WOLFMQTT_MULTITHREAD readLocked = 1;  #endif if (*mms_stat == MQTT_MSG_READ_PAYLOAD) { packet_type = MQTT_PACKET_TYPE_PUBLISH; } if ((wait_type == MQTT_PACKET_TYPE_ANY || wait_type == packet_type || MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) && (wait_packet_id == 0 || wait_packet_id == packet_id)) { use_packet_obj = packet_obj; waitMatchFound = 1; } else { use_packet_obj = &client->msg; } use_packet_type = packet_type; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, packet_type, packet_id, &pendResp)) { pendResp->packetProcessing = 1; use_packet_obj = pendResp->packet_obj; use_packet_type = pendResp->packet_type; waitMatchFound = 0; } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  rc = MqttClient_HandlePacket(client, use_packet_type, use_packet_obj, timeout_ms); #ifdef WOLFMQTT_NONBLOCK if (rc == MQTT_CODE_CONTINUE) { return rc; } #endif if (rc >= 0) { rc = MQTT_CODE_SUCCESS; } #ifdef WOLFMQTT_MULTITHREAD if (pendResp) { if (wm_SemLock(&client->lockClient) == 0) { pendResp->packetDone = 1; pendResp->packet_ret = rc; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp Done %p"", pendResp); #endif pendResp = NULL; wm_SemUnlock(&client->lockClient); } } #endif  break; } case MQTT_MSG_WRITE: case MQTT_MSG_WRITE_PAYLOAD: default: { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Invalid state %d!"", *mms_stat); #endif rc = MQTT_CODE_ERROR_STAT; break; } }  #ifdef WOLFMQTT_NONBLOCK if (rc != MQTT_CODE_CONTINUE) #endif { *mms_stat = MQTT_MSG_BEGIN; } #ifdef WOLFMQTT_MULTITHREAD if (readLocked) { wm_SemUnlock(&client->lockRecv); } #endif if (rc < 0) { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Failure: %s (%d)"", MqttClient_ReturnCodeToString(rc), rc); #endif return rc; } if (!waitMatchFound) { goto wait_again; } return rc; }"
"SWFReader *gf_swf_reader_new(const char *localPath, const char *inputName) { SWFReader *read; FILE *input; input = gf_fopen(inputName, ""rb""); if (!input) return NULL; GF_SAFEALLOC(read, SWFReader); if (!read) return NULL; read->inputName = gf_strdup(inputName); read->input = input; read->bs = gf_bs_from_file(input, GF_BITSTREAM_READ); gf_bs_set_eos_callback(read->bs, swf_io_error, &read); read->display_list = gf_list_new(); read->fonts = gf_list_new(); read->apps = gf_list_new(); read->sounds = gf_list_new(); if (localPath) { read->localPath = gf_strdup(localPath); } else { char *c; read->localPath = gf_strdup(inputName); c = strrchr(read->localPath, GF_PATH_SEPARATOR); if (c) c[1] = 0; else { gf_free(read->localPath); read->localPath = NULL; } } return read; }"
"static bool read_lead(zckCtx *zck) { VALIDATE_READ_BOOL(zck); int lead = 5 + 2*MAX_COMP_SIZE; char *header = zmalloc(lead); if (!header) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); return false; } size_t length = 0; if(read_data(zck, header, lead) < lead) { free(header); set_error(zck, ""Short read""); return false; } if(memcmp(header, ""\0ZHR1"", 5) == 0) { zck->header_only = true; } else if(memcmp(header, ""\0ZCK1"", 5) != 0) { free(header); set_error(zck, ""Invalid lead, perhaps this is not a zck file?""); return false; } length += 5; int hash_type = 0; if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) { free(header); return false; } if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) { free(header); set_error(zck, ""Hash type (%i) doesn't match requested hash type "" ""(%i)"", hash_type, zck->prep_hash_type); return false; } if(!hash_setup(zck, &(zck->hash_type), hash_type)) { free(header); return false; } zck_log(ZCK_LOG_DEBUG, ""Setting header and full digest hash type to %s"", zck_hash_name_from_type(hash_type)); size_t header_length = 0; if(!compint_to_size(zck, &header_length, header+length, &length, lead)) { free(header); hash_reset(&(zck->hash_type)); return false; } if(header_length > SIZE_MAX) { free(header); set_error(zck, ""Header length of %li invalid"", header_length); hash_reset(&(zck->hash_type)); return false; } zck->header_length = header_length; zck->hdr_digest_loc = length; zck_log(ZCK_LOG_DEBUG, ""Reading header digest""); header = zrealloc(header, length + zck->hash_type.digest_size); if (!header) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); return false; } size_t to_read = 0; if(lead < length + zck->hash_type.digest_size) to_read = length + zck->hash_type.digest_size - lead; if(read_data(zck, header + lead, to_read) < to_read) { free(header); zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); return false; } lead += to_read; if(zck->prep_digest && memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) { zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); set_error(zck, ""Header digest doesn't match requested header digest"" ""Expected: %sActual: %s"", get_digest_string(zck->prep_digest, zck->hash_type.digest_size), get_digest_string(header + length, zck->hash_type.digest_size)); free(header); return false; } zck->header_digest = zmalloc(zck->hash_type.digest_size); if (!zck->header_digest) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); free(header); return false; } memcpy(zck->header_digest, header + length, zck->hash_type.digest_size); length += zck->hash_type.digest_size; if(zck->prep_hdr_size > -1 && (size_t)zck->prep_hdr_size != zck->header_length + length) { free(header); zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); free(zck->header_digest); zck->header_digest = NULL; set_error( zck, ""Header length (%llu) doesn't match requested header length (%llu)"", (long long unsigned) zck->header_length + length, (long long unsigned) zck->prep_hdr_size ); return false; } zck->header = header; zck->header_size = lead; zck->lead_string = header; zck->lead_size = length; zck_log( ZCK_LOG_DEBUG, ""Parsed lead: %llu bytes"", (long long unsigned) length ); return true; }"
"struct ieee802_11_elems * ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params) { struct ieee802_11_elems *elems; const struct element *non_inherit = NULL; u8 *nontransmitted_profile; int nontransmitted_profile_len = 0; elems = kzalloc(sizeof(*elems), GFP_ATOMIC); if (!elems) return NULL; elems->ie_start = params->start; elems->total_len = params->len; nontransmitted_profile = kmalloc(params->len, GFP_ATOMIC); if (nontransmitted_profile) { nontransmitted_profile_len = ieee802_11_find_bssid_profile(params->start, params->len, elems, params->bss, nontransmitted_profile); non_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE, nontransmitted_profile, nontransmitted_profile_len); } elems->crc = _ieee802_11_parse_elems_full(params, elems, non_inherit); if (nontransmitted_profile_len) { struct ieee80211_elems_parse_params sub = { .start = nontransmitted_profile, .len = nontransmitted_profile_len, .action = params->action, .link_id = params->link_id, }; _ieee802_11_parse_elems_full(&sub, elems, NULL); } if (elems->tim && !elems->parse_error) { const struct ieee80211_tim_ie *tim_ie = elems->tim; elems->dtim_period = tim_ie->dtim_period; elems->dtim_count = tim_ie->dtim_count; } if (elems->bssid_index && elems->bssid_index_len >= offsetofend(struct ieee80211_bssid_index, dtim_period)) elems->dtim_period = elems->bssid_index->dtim_period; if (elems->bssid_index && elems->bssid_index_len >= offsetofend(struct ieee80211_bssid_index, dtim_count)) elems->dtim_count = elems->bssid_index->dtim_count; kfree(nontransmitted_profile); return elems; }"
"int ldbRepl(lua_State *lua) { sds *argv; int argc; while(1) { while((argv = ldbReplParseCommand(&argc)) == NULL) { char buf[1024]; int nread = connRead(ldb.conn,buf,sizeof(buf)); if (nread <= 0) { ldb.step = 0; ldb.bpcount = 0; return C_ERR; } ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread); } sdsfree(ldb.cbuf); ldb.cbuf = sdsempty(); if (!strcasecmp(argv[0],""h"") || !strcasecmp(argv[0],""help"")) { ldbLog(sdsnew(""Redis Lua debugger help:"")); ldbLog(sdsnew(""[h]elp               Show this help."")); ldbLog(sdsnew(""[s]tep               Run current line and stop again."")); ldbLog(sdsnew(""[n]ext               Alias for step."")); ldbLog(sdsnew(""[c]continue          Run till next breakpoint."")); ldbLog(sdsnew(""[l]list              List source code around current line."")); ldbLog(sdsnew(""[l]list [line]       List source code around [line]."")); ldbLog(sdsnew(""                     line = 0 means: current position."")); ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines"")); ldbLog(sdsnew(""                     to show before/after [line]."")); ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'."")); ldbLog(sdsnew(""[p]rint              Show all the local variables."")); ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable."")); ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV."")); ldbLog(sdsnew(""[b]reak              Show all breakpoints."")); ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line."")); ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line."")); ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints."")); ldbLog(sdsnew(""[t]race              Show a backtrace."")); ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe)."")); ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command."")); ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."")); ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited."")); ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync"")); ldbLog(sdsnew(""                     mode dataset changes will be retained."")); ldbLog(sdsnew("""")); ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:"")); ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console."")); ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the"")); ldbLog(sdsnew(""                     next line of code."")); ldbSendLogs(); } else if (!strcasecmp(argv[0],""s"") || !strcasecmp(argv[0],""step"") || !strcasecmp(argv[0],""n"") || !strcasecmp(argv[0],""next"")) { ldb.step = 1; break; } else if (!strcasecmp(argv[0],""c"") || !strcasecmp(argv[0],""continue"")){ break; } else if (!strcasecmp(argv[0],""t"") || !strcasecmp(argv[0],""trace"")) { ldbTrace(lua); ldbSendLogs(); } else if (!strcasecmp(argv[0],""m"") || !strcasecmp(argv[0],""maxlen"")) { ldbMaxlen(argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""b"") || !strcasecmp(argv[0],""break"")) { ldbBreak(argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""e"") || !strcasecmp(argv[0],""eval"")) { ldbEval(lua,argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""a"") || !strcasecmp(argv[0],""abort"")) { lua_pushstring(lua, ""script aborted for user request""); lua_error(lua); } else if (argc > 1 && (!strcasecmp(argv[0],""r"") || !strcasecmp(argv[0],""redis""))) { ldbRedis(lua,argv,argc); ldbSendLogs(); } else if ((!strcasecmp(argv[0],""p"") || !strcasecmp(argv[0],""print""))) { if (argc == 2) ldbPrint(lua,argv[1]); else ldbPrintAll(lua); ldbSendLogs(); } else if (!strcasecmp(argv[0],""l"") || !strcasecmp(argv[0],""list"")){ int around = ldb.currentline, ctx = 5; if (argc > 1) { int num = atoi(argv[1]); if (num > 0) around = num; } if (argc > 2) ctx = atoi(argv[2]); ldbList(around,ctx); ldbSendLogs(); } else if (!strcasecmp(argv[0],""w"") || !strcasecmp(argv[0],""whole"")){ ldbList(1,1000000); ldbSendLogs(); } else { ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or "" ""wrong number of arguments."")); ldbSendLogs(); } sdsfreesplitres(argv,argc); } sdsfreesplitres(argv,argc); return C_OK; }"
"static int handle_input_expect_data_payload(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end, const char **err_desc) { size_t bytes_avail = src_end - *src; if (bytes_avail > stream->recvbuf.bytes_left_in_data_frame) bytes_avail = stream->recvbuf.bytes_left_in_data_frame; if (stream->req_body == NULL) h2o_buffer_init(&stream->req_body, &h2o_socket_buffer_prototype); if (!h2o_buffer_try_append(&stream->req_body, *src, bytes_avail)) return H2O_HTTP3_ERROR_INTERNAL; stream->req.entity = h2o_iovec_init(stream->req_body->bytes, stream->req_body->size); stream->req.req_body_bytes_received += bytes_avail; stream->recvbuf.bytes_left_in_data_frame -= bytes_avail; *src += bytes_avail; if (stream->recvbuf.bytes_left_in_data_frame == 0) stream->recvbuf.handle_input = handle_input_expect_data; return 0; }"
"int read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id, uint32_t offset, uint32_t length, uint8_t *frubuf) { uint32_t off = offset, tmp, finish; struct ipmi_rs * rsp; struct ipmi_rq req; uint8_t msg_data[4]; if (offset > fru->size) { lprintf(LOG_ERR, ""Read FRU Area offset incorrect: %d > %d"", offset, fru->size); return -1; } finish = offset + length; if (finish > fru->size) { finish = fru->size; lprintf(LOG_NOTICE, ""Read FRU Area length %d too large, "" ""Adjusting to %d"", offset + length, finish - offset); } memset(&req, 0, sizeof(req)); req.msg.netfn = IPMI_NETFN_STORAGE; req.msg.cmd = GET_FRU_DATA; req.msg.data = msg_data; req.msg.data_len = 4; if (fru->max_read_size == 0) { uint16_t max_rs_size = ipmi_intf_get_max_response_data_size(intf) - 1; if (max_rs_size <= 1) { lprintf(LOG_ERROR, ""Maximum response size is too small to send "" ""a read request""); return -1; } if (max_rs_size - 1 > 255) { fru->max_read_size = 255; } else { fru->max_read_size = max_rs_size - 1; } if (fru->access) { fru->max_read_size &= ~1; } } do { tmp = fru->access ? off >> 1 : off; msg_data[0] = id; msg_data[1] = (uint8_t)(tmp & 0xff); msg_data[2] = (uint8_t)(tmp >> 8); tmp = finish - off; if (tmp > fru->max_read_size) msg_data[3] = (uint8_t)fru->max_read_size; else msg_data[3] = (uint8_t)tmp; rsp = intf->sendrecv(intf, &req); if (!rsp) { lprintf(LOG_NOTICE, ""FRU Read failed""); break; } if (rsp->ccode) { if (fru_cc_rq2big(rsp->ccode) && fru->max_read_size > FRU_BLOCK_SZ) { if (fru->max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ) { fru->max_read_size -= FRU_BLOCK_SZ; } else { fru->max_read_size--; } lprintf(LOG_INFO, ""Retrying FRU read with request size %d"", fru->max_read_size); continue; } lprintf(LOG_NOTICE, ""FRU Read failed: %s"", val2str(rsp->ccode, completion_code_vals)); break; } tmp = fru->access ? rsp->data[0] << 1 : rsp->data[0]; memcpy(frubuf, rsp->data + 1, tmp); off += tmp; frubuf += tmp; if (tmp == 0 && off < finish) { return 0; } } while (off < finish); if (off < finish) { return -1; } return 0; }"
"static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { int istart = 0, n, i = 0, dir=1, idx=-1; Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1); Jsi_Obj *obj = _this->d.obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); if (!seq) { goto bail; } n = jsi_SizeOfArray(interp, obj);     if (n == 0) { goto bail; } Jsi_Number nstart; if (op == 2) { istart = n-1; } if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (op == 2) { istart = n-1; dir = -1; } Jsi_ObjListifyArray(interp, obj); for (i = istart; ; i+=dir) { if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt) break; if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) { idx = i; break; } } bail: if (op == 3) Jsi_ValueMakeBool(interp, ret, (idx!=-1)); else Jsi_ValueMakeNumber(interp, ret, idx); return JSI_OK; }"
"void rdp_read_flow_control_pdu(wStream* s, UINT16* type) { UINT8 pduType; Stream_Read_UINT8(s, pduType);  *type = pduType; Stream_Seek_UINT8(s);   Stream_Seek_UINT8(s);   Stream_Seek_UINT8(s);   Stream_Seek_UINT16(s);  }"
"int get_lisp_indent(void) { pos_T*pos, realpos, paren; intamount; char_u*that; colnr_Tcol; colnr_Tfirsttry; intparencount, quotecount; intvi_lisp; vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL); realpos = curwin->w_cursor; curwin->w_cursor.col = 0; if ((pos = findmatch(NULL, '(')) == NULL) pos = findmatch(NULL, '['); else { paren = *pos; pos = findmatch(NULL, '['); if (pos == NULL || LT_POSP(pos, &paren)) pos = &paren; } if (pos != NULL) { amount = -1; parencount = 0; while (--curwin->w_cursor.lnum >= pos->lnum) { if (linewhite(curwin->w_cursor.lnum)) continue; for (that = ml_get_curline(); *that != NUL; ++that) { if (*that == ';') { while (*(that + 1) != NUL) ++that; continue; } if (*that == '\\') { if (*(that + 1) != NUL) ++that; continue; } if (*that == '""' && *(that + 1) != NUL) { while (*++that && *that != '""') { if (*that == '\\') { if (*++that == NUL) break; if (that[1] == NUL) { ++that; break; } } } } if (*that == '(' || *that == '[') ++parencount; else if (*that == ')' || *that == ']') --parencount; } if (parencount == 0) { amount = get_indent(); break; } } if (amount == -1) { curwin->w_cursor.lnum = pos->lnum; curwin->w_cursor.col = pos->col; col = pos->col; that = ml_get_curline(); if (vi_lisp && get_indent() == 0) amount = 2; else { char_u *line = that; amount = 0; while (*that && col) { amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); col--; } if (!vi_lisp && (*that == '(' || *that == '[') && lisp_match(that + 1)) amount += 2; else { that++; amount++; firsttry = amount; while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize(line, that, (colnr_T)amount); ++that; } if (*that && *that != ';')     { if (!vi_lisp && *that != '(' && *that != '[') firsttry++; parencount = 0; quotecount = 0; if (vi_lisp || (*that != '""' && *that != '\'' && *that != '#' && (*that < '0' || *that > '9'))) { while (*that && (!VIM_ISWHITE(*that) || quotecount || parencount) && (!((*that == '(' || *that == '[') && !quotecount && !parencount && vi_lisp))) { if (*that == '""') quotecount = !quotecount; if ((*that == '(' || *that == '[') && !quotecount) ++parencount; if ((*that == ')' || *that == ']') && !quotecount) --parencount; if (*that == '\\' && *(that+1) != NUL) amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); } } while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize( line, that, (colnr_T)amount); that++; } if (!*that || *that == ';') amount = firsttry; } } } } } else amount = 0; curwin->w_cursor = realpos; return amount; }"
"void ImageWriteJPEG( Image const& image, String const& filename, dip::uint jpegLevel ) { DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED ); DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED ); jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 ); JpegOutput jpeg( filename ); int nchan = static_cast< int >( image.TensorElements() ); jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 )); jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 )); jpeg.cinfo().input_components = nchan; jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE; jpeg_set_defaults( jpeg.cinfoptr() ); jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE ); jpeg.cinfo().density_unit = 2;    jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude );    jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude ); Image image_u8 = image.QuickCopy(); image_u8.Convert( DT_UINT8 ); jpeg_start_compress( jpeg.cinfoptr(), TRUE ); std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan )); dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() ); auto stride = image_u8.Strides(); auto tStride = image_u8.TensorStride(); for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) { JSAMPLE* outdata = buffer.data(); dip::uint8* indata = imagedata; for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) { for( int kk = 0; kk < nchan; ++kk ) { *outdata = *( indata + kk * tStride ); ++outdata; } indata += stride[ 0 ]; } outdata = buffer.data(); jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 ); imagedata += stride[ 1 ]; } jpeg_finish_compress( jpeg.cinfoptr()); }"
"char* parse_content_length( char* buffer, char* end, int* length) { int number; char *p; int  size; p = buffer; while ( p<end && (*p==' ' || *p=='\t' || (*p=='\r' && *(p+1)=='\n') || (*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) )) p++; if (p==end) goto error; size = 0; number = 0; while (p<end && *p>='0' && *p<='9') { number = number*10 + (*p)-'0'; if (number<0) { LM_ERR(""number overflow at pos %d in len number [%.*s]\n"", (int)(p-buffer),(int)(end-buffer), buffer); return 0; } size ++; p++; } if (p==end || size==0) goto error; while ( p<end && (*p==' ' || *p=='\t' || (*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) )) p++; if (p==end) goto error; if ( (*(p++)!='\n') && (*(p-1)!='\r' || *(p++)!='\n' ) ) goto error; *length = number; return p; error: LM_ERR(""parse error near char [%d][%c]\n"",*p,*p); return 0; }"
ompl::geometric::LazyPRM::~LazyPRM() = default;
"static int eval_lambda( char_u**arg, typval_T*rettv, evalarg_T*evalarg, intverbose){ intevaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); typval_Tbase = *rettv; intret; rettv->v_type = VAR_UNKNOWN; if (**arg == '{') { ret = get_lambda_tv(arg, rettv, FALSE, evalarg); } else { ++*arg; ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); if (**arg != ')') { emsg(_(e_missing_closing_paren)); ret = FAIL; } ++*arg; } if (ret != OK) return FAIL; else if (**arg != '(') { if (verbose) { if (*skipwhite(*arg) == '(') emsg(_(e_nowhitespace)); else semsg(_(e_missing_parenthesis_str), ""lambda""); } clear_tv(rettv); ret = FAIL; } else ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base); if (evaluate) clear_tv(&base); return ret; }"
PDFObject::~PDFObject(void) { StringToVoidP::iterator it = mMetadata.begin(); for (; it != mMetadata.end(); ++it) { delete it->second; } mMetadata.clear(); }
"TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input, int axis, TfLiteTensor* output) { const TfLiteIntArray& input_dims = *input.dims; if (axis < 0) { axis = input_dims.size + 1 + axis; } TF_LITE_ENSURE(context, axis <= input_dims.size); TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1); for (int i = 0; i < output_dims->size; ++i) { if (i < axis) { output_dims->data[i] = input_dims.data[i]; } else if (i == axis) { output_dims->data[i] = 1; } else { output_dims->data[i] = input_dims.data[i - 1]; } } return context->ResizeTensor(context, output, output_dims); }"
"void PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts) { pageDict->remove(""OpenAction""); pageDict->remove(""Outlines""); pageDict->remove(""StructTreeRoot""); for (int n = 0; n < pageDict->getLength(); n++) { const char *key = pageDict->getKey(n); Object value = pageDict->getValNF(n).copy(); if (strcmp(key, ""Parent"") != 0 && strcmp(key, ""Pages"") != 0 && strcmp(key, ""AcroForm"") != 0 && strcmp(key, ""Annots"") != 0 && strcmp(key, ""P"") != 0 && strcmp(key, ""Root"") != 0) { markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts); } } }"
"flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o, struct flb_time *tm, struct flb_gelf_fields *fields) { int i; int loop; flb_sds_t tmp; int host_key_found = FLB_FALSE; int timestamp_key_found = FLB_FALSE; int level_key_found = FLB_FALSE; int short_message_key_found = FLB_FALSE; int full_message_key_found = FLB_FALSE; char *host_key = NULL; char *timestamp_key = NULL; char *level_key = NULL; char *short_message_key = NULL; char *full_message_key = NULL; int host_key_len = 0; int timestamp_key_len = false; int level_key_len = 0; int short_message_key_len = 0; int full_message_key_len = 0; if (s == NULL || o == NULL) { return NULL; } if (o->type != MSGPACK_OBJECT_MAP) { return NULL; } if (fields != NULL && fields->host_key != NULL) { host_key = fields->host_key; host_key_len = flb_sds_len(fields->host_key); } else { host_key = ""host""; host_key_len = 4; } if (fields != NULL && fields->timestamp_key != NULL) { timestamp_key = fields->timestamp_key; timestamp_key_len = flb_sds_len(fields->timestamp_key); } else { timestamp_key = ""timestamp""; timestamp_key_len = 9; } if (fields != NULL && fields->level_key != NULL) { level_key = fields->level_key; level_key_len = flb_sds_len(fields->level_key); } else { level_key = ""level""; level_key_len = 5; } if (fields != NULL && fields->short_message_key != NULL) { short_message_key = fields->short_message_key; short_message_key_len = flb_sds_len(fields->short_message_key); } else { short_message_key = ""short_message""; short_message_key_len = 13; } if (fields != NULL && fields->full_message_key != NULL) { full_message_key = fields->full_message_key; full_message_key_len = flb_sds_len(fields->full_message_key); } else { full_message_key = ""full_message""; full_message_key_len = 12; } tmp = flb_sds_cat(*s, ""{\""version\"":\""1.1\"""", 16); if (tmp == NULL) { return NULL; } *s = tmp; loop = o->via.map.size; if (loop != 0) { msgpack_object_kv *p = o->via.map.ptr; for (i = 0; i < loop; i++) { const char *key = NULL; int key_len; const char *val = NULL; int val_len = 0; int quote = FLB_FALSE; int custom_key = FLB_FALSE; msgpack_object *k = &p[i].key; msgpack_object *v = &p[i].val; msgpack_object vtmp;  if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) { continue; } if (k->type == MSGPACK_OBJECT_STR) { key = k->via.str.ptr; key_len = k->via.str.size; } else { key = k->via.bin.ptr; key_len = k->via.bin.size; } if ((key_len == host_key_len) && !strncmp(key, host_key, host_key_len)) { if (host_key_found == FLB_TRUE) { continue; } host_key_found = FLB_TRUE; key = ""host""; key_len = 4; } else if ((key_len == short_message_key_len) && !strncmp(key, short_message_key, short_message_key_len)) { if (short_message_key_found == FLB_TRUE) { continue; } short_message_key_found = FLB_TRUE; key = ""short_message""; key_len = 13; } else if ((key_len == timestamp_key_len) && !strncmp(key, timestamp_key, timestamp_key_len)) { if (timestamp_key_found == FLB_TRUE) { continue; } timestamp_key_found = FLB_TRUE; key = ""timestamp""; key_len = 9; } else if ((key_len == level_key_len) && !strncmp(key, level_key, level_key_len )) { if (level_key_found == FLB_TRUE) { continue; } level_key_found = FLB_TRUE; key = ""level""; key_len = 5; if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) { if ( v->via.u64 > 7 ) { flb_warn(""[flb_msgpack_to_gelf] level is %"" PRIu64 "", "" ""but should be in 0..7 or a syslog keyword"", v->via.u64); } } else if (v->type == MSGPACK_OBJECT_STR) { val     = v->via.str.ptr; val_len = v->via.str.size; if (val_len == 1 && val[0] >= '0' && val[0] <= '7') { v = &vtmp; v->type = MSGPACK_OBJECT_POSITIVE_INTEGER; v->via.u64 = (uint64_t)(val[0] - '0'); } else { int n; char* allowed_levels[] = { ""emerg"", ""alert"", ""crit"", ""err"", ""warning"", ""notice"", ""info"", ""debug"", NULL }; for (n = 0; allowed_levels[n] != NULL; ++n) { if (val_len == strlen(allowed_levels[n]) && !strncasecmp(val, allowed_levels[n], val_len)) { v = &vtmp; v->type = MSGPACK_OBJECT_POSITIVE_INTEGER; v->via.u64 = (uint64_t)n; break; } } if (allowed_levels[n] == NULL) { flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', "" ""but should be in 0..7 or a syslog keyword"", val_len, val); } } } else { flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string""); return NULL; } } else if ((key_len == full_message_key_len) && !strncmp(key, full_message_key, full_message_key_len)) { if (full_message_key_found == FLB_TRUE) { continue; } full_message_key_found = FLB_TRUE; key = ""full_message""; key_len = 12; } else if ((key_len == 2)  && !strncmp(key, ""id"", 2)) { continue; } else { custom_key = FLB_TRUE; } if (v->type == MSGPACK_OBJECT_MAP) { char *prefix = NULL; int prefix_len = 0; prefix_len = key_len + 1; prefix = flb_calloc(1, prefix_len + 1); if (prefix == NULL) { return NULL; } prefix[0] = '_'; strncpy(prefix + 1, key, key_len); prefix[prefix_len] = '\0'; tmp = flb_msgpack_gelf_flatten(s, v, prefix, prefix_len, FLB_FALSE); if (tmp == NULL) { flb_free(prefix); return NULL; } *s = tmp; flb_free(prefix); } else if (v->type == MSGPACK_OBJECT_ARRAY) { if (custom_key == FLB_TRUE) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE, key, key_len); } else { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, key, key_len); } if (tmp == NULL) { return NULL; } *s = tmp; tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE); if (tmp == NULL) { return NULL; } *s = tmp; } else { char temp[48] = {0}; if (v->type == MSGPACK_OBJECT_NIL) { val = ""null""; val_len = 4; continue; } else if (v->type == MSGPACK_OBJECT_BOOLEAN) { quote   = FLB_TRUE; val = v->via.boolean ? ""true"" : ""false""; val_len = v->via.boolean ? 4 : 5; } else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%"" PRIu64, v->via.u64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%"" PRId64, v->via.i64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_FLOAT) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%f"", v->via.f64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_STR) { quote   = FLB_TRUE; val     = v->via.str.ptr; val_len = v->via.str.size; } else if (v->type == MSGPACK_OBJECT_BIN) { quote   = FLB_TRUE; val     = v->via.bin.ptr; val_len = v->via.bin.size; } else if (v->type == MSGPACK_OBJECT_EXT) { quote   = FLB_TRUE; val     = o->via.ext.ptr; val_len = o->via.ext.size; } if (!val || !key) { continue; } if (custom_key == FLB_TRUE) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE, key, key_len); } else { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, key, key_len); } if (tmp == NULL) { return NULL; } *s = tmp; if (v->type == MSGPACK_OBJECT_EXT) { tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len); } else { tmp = flb_msgpack_gelf_value(s, quote, val, val_len); } if (tmp == NULL) { return NULL; } *s = tmp; } } } if (timestamp_key_found == FLB_FALSE && tm != NULL) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, ""timestamp"", 9); if (tmp == NULL) { return NULL; } *s = tmp; tmp = flb_sds_printf(s, ""%"" PRIu32"".%lu"", tm->tm.tv_sec, tm->tm.tv_nsec / 1000000); if (tmp == NULL) { return NULL; } *s = tmp; } if (short_message_key_found == FLB_FALSE) { flb_error(""[flb_msgpack_to_gelf] missing short_message key""); return NULL; } tmp = flb_sds_cat(*s, ""}"", 1); if (tmp == NULL) { return NULL; } *s = tmp; return *s; }"
"uint8_t* DTSStreamReader::findFrame(uint8_t* buff, uint8_t* end) { while (end - buff >= 16) { int64_t* ptr = (int64_t*)buff; int64_t hdrType = my_ntohll(ptr[0]); int64_t hdrSize = my_ntohll(ptr[1]) + 16; if (hdrType == AUPRINFO || hdrType == BITSHVTB || hdrType == BLACKOUT || hdrType == BRANCHPT || hdrType == BUILDVER || hdrType == CORESSMD || hdrType == EXTSS_MD || hdrType == FILEINFO || hdrType == NAVI_TBL || hdrType == TIMECODE || hdrType == DTSHDHDR) { if (buff + hdrSize > end) return 0;              buff += hdrSize; } else if (hdrType == AUPR_HDR) { if (buff + hdrSize > end) return 0;                          m_skippingSamples = (buff[35] << 8) + buff[36]; buff += hdrSize; } else if (hdrType == STRMDATA) { m_dataSegmentLen = hdrSize; buff += 16; break; } else { break;          } } if (m_firstCall) { m_firstCall = false; checkIfOnlyHDDataExists(buff, end); } if (!m_isCoreExists) { for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++) { if (p_buf[0] == 0x64 && p_buf[1] == 0x58 && p_buf[2] == 0x20 && p_buf[3] == 0x25) { return p_buf; } } return 0; } for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++) { if (p_buf < end - 6) { if (p_buf[0] == 0xff && p_buf[1] == 0x1f && p_buf[2] == 0x00 && p_buf[3] == 0xe8 && (p_buf[4] & 0xf0) == 0xf0 && p_buf[5] == 0x07) { return p_buf; } else if (p_buf[0] == 0x1f && p_buf[1] == 0xff && p_buf[2] == 0xe8 && p_buf[3] == 0x00 && p_buf[4] == 0x07 && (p_buf[5] & 0xf0) == 0xf0) { return p_buf; } } if (p_buf[0] == 0x7f && p_buf[1] == 0xfe && p_buf[2] == 0x80 && p_buf[3] == 0x01) { return p_buf; } else if (p_buf[0] == 0xfe && p_buf[1] == 0x7f && p_buf[2] == 0x01 && p_buf[3] == 0x80) { return p_buf; } } return 0; }"
"explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""display_name"", &display_name_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_threads"", &num_threads_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""max_intra_op_parallelism"", &max_intra_op_parallelism_)); OP_REQUIRES( ctx, num_threads_ > 0, errors::InvalidArgument(""`num_threads` must be greater than zero."")); }"
"int spider_db_mbase::exec_query( const char *query, uint length, int quick_mode ) { int error_num = 0; uint log_result_errors = spider_param_log_result_errors(); DBUG_ENTER(""spider_db_mbase::exec_query""); DBUG_PRINT(""info"",(""spider this=%p"", this)); if (spider_param_general_log()) { const char *tgt_str = conn->tgt_host; uint32 tgt_len = conn->tgt_host_length; spider_string tmp_query_str; tmp_query_str.init_calc_mem(230); if (tmp_query_str.reserve( length + conn->tgt_wrapper_length + tgt_len + (SPIDER_SQL_SPACE_LEN * 2))) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(conn->tgt_wrapper, conn->tgt_wrapper_length); tmp_query_str.q_append(SPIDER_SQL_SPACE_STR, SPIDER_SQL_SPACE_LEN); tmp_query_str.q_append(tgt_str, tgt_len); tmp_query_str.q_append(SPIDER_SQL_SPACE_STR, SPIDER_SQL_SPACE_LEN); tmp_query_str.q_append(query, length); general_log_write(current_thd, COM_QUERY, tmp_query_str.ptr(), tmp_query_str.length()); } if (!spider_param_dry_access()) { error_num = mysql_real_query(db_conn, query, length); } if ( (error_num && log_result_errors >= 1) || (log_result_errors >= 2 && db_conn->warning_count > 0) || (log_result_errors >= 4) ) { THD *thd = current_thd; uint log_result_error_with_sql = spider_param_log_result_error_with_sql(); if (log_result_error_with_sql) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); spider_string tmp_query_str; tmp_query_str.init_calc_mem(243); uint query_length = thd->query_length(); if ((log_result_error_with_sql & 2) && query_length) { Security_context *security_ctx = thd->security_ctx; tmp_query_str.length(0); if (tmp_query_str.reserve(query_length + 1)) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(thd->query(), query_length); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [RECV SPIDER SQL] "" ""from [%s][%s] to %ld:  "" ""sql: %s\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, security_ctx->user ? security_ctx->user : ""system user"", security_ctx->host_or_ip, (ulong) thd->thread_id, tmp_query_str.c_ptr_safe()); } if (log_result_error_with_sql & 1) { tmp_query_str.length(0); if (tmp_query_str.reserve(length + 1)) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(query, length); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [SEND SPIDER SQL] "" ""from %ld to [%s] %ld:  "" ""sql: %s\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, (ulong) thd->thread_id, conn->tgt_host, (ulong) db_conn->thread_id, tmp_query_str.c_ptr_safe()); } } if (log_result_errors >= 2 && db_conn->warning_count > 0) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [WARN SPIDER RESULT] "" ""from [%s] %ld to %ld:  "" ""affected_rows: %llu  id: %llu  status: %u  warning_count: %u\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, conn->tgt_host, (ulong) db_conn->thread_id, (ulong) thd->thread_id, db_conn->affected_rows, db_conn->insert_id, db_conn->server_status, db_conn->warning_count); if (spider_param_log_result_errors() >= 3) print_warnings(l_time); } else if (log_result_errors >= 4) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [INFO SPIDER RESULT] "" ""from [%s] %ld to %ld:  "" ""affected_rows: %llu  id: %llu  status: %u  warning_count: %u\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, conn->tgt_host, (ulong) db_conn->thread_id, (ulong) thd->thread_id, db_conn->affected_rows, db_conn->insert_id, db_conn->server_status, db_conn->warning_count); } } DBUG_RETURN(error_num); }"
"TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices, const TfLiteTensor* updates, const TfLiteTensor* shape, TfLiteTensor* output) { if (IsDynamicTensor(output)) { TF_LITE_ENSURE_OK( context, CheckShapes<IndicesT>( context, GetTensorShape(indices), GetTensorShape(updates), GetTensorShape(shape), GetTensorData<IndicesT>(shape))); TF_LITE_ENSURE_OK(context, ResizeOutputTensor<IndicesT>(context, shape, output)); } switch (updates->type) { case kTfLiteFloat32: return ScatterNd<IndicesT, float>(indices, updates, output); case kTfLiteUInt8: return ScatterNd<IndicesT, uint8_t>(indices, updates, output); case kTfLiteBool: return ScatterNd<IndicesT, bool>(indices, updates, output); case kTfLiteInt8: return ScatterNd<IndicesT, int8_t>(indices, updates, output); case kTfLiteInt32: return ScatterNd<IndicesT, int32_t>(indices, updates, output); case kTfLiteInt64: return ScatterNd<IndicesT, int64_t>(indices, updates, output); default: TF_LITE_KERNEL_LOG( context, ""Updates of type '%s' are not supported by scatter_nd."", TfLiteTypeGetName(updates->type)); return kTfLiteError; } }"
"void nsexec(void) { int pipenum; jmp_buf env; int sync_child_pipe[2], sync_grandchild_pipe[2]; struct nlconfig_t config = { 0 }; setup_logpipe(); pipenum = getenv_int(""_LIBCONTAINER_INITPIPE""); if (pipenum < 0) { return; } if (ensure_cloned_binary() < 0) bail(""could not ensure we are a cloned binary""); if (write(pipenum, """", 1) != 1) bail(""could not inform the parent we are past initial setup""); write_log(DEBUG, ""=> nsexec container setup""); nl_parse(pipenum, &config); update_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len); if (config.namespaces) { write_log(DEBUG, ""set process as non-dumpable""); if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0) bail(""failed to set process as non-dumpable""); } if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0) bail(""failed to setup sync pipe between parent and child""); if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0) bail(""failed to setup sync pipe between parent and grandchild""); current_stage = setjmp(env); switch (current_stage) { case STAGE_PARENT:{ int len; pid_t stage1_pid = -1, stage2_pid = -1; bool stage1_complete, stage2_complete; prctl(PR_SET_NAME, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-0""); write_log(DEBUG, ""spawn stage-1""); stage1_pid = clone_parent(&env, STAGE_CHILD); if (stage1_pid < 0) bail(""unable to spawn stage-1""); syncfd = sync_child_pipe[1]; if (close(sync_child_pipe[0]) < 0) bail(""failed to close sync_child_pipe[0] fd""); write_log(DEBUG, ""-> stage-1 synchronisation loop""); stage1_complete = false; while (!stage1_complete) { enum sync_t s; if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with stage-1: next state""); switch (s) { case SYNC_USERMAP_PLS: write_log(DEBUG, ""stage-1 requested userns mappings""); if (config.is_rootless_euid && !config.is_setgroup) update_setgroups(stage1_pid, SETGROUPS_DENY); update_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len); update_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len); s = SYNC_USERMAP_ACK; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: write(SYNC_USERMAP_ACK)""); } break; case SYNC_RECVPID_PLS: write_log(DEBUG, ""stage-1 requested pid to be forwarded""); if (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: read(stage2_pid)""); } s = SYNC_RECVPID_ACK; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: write(SYNC_RECVPID_ACK)""); } write_log(DEBUG, ""forward stage-1 (%d) and stage-2 (%d) pids to runc"", stage1_pid, stage2_pid); len = dprintf(pipenum, ""{\""stage1_pid\"":%d,\""stage2_pid\"":%d}\n"", stage1_pid, stage2_pid); if (len < 0) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with runc: write(pid-JSON)""); } break; case SYNC_CHILD_FINISH: write_log(DEBUG, ""stage-1 complete""); stage1_complete = true; break; default: bail(""unexpected sync value: %u"", s); } } write_log(DEBUG, ""<- stage-1 synchronisation loop""); syncfd = sync_grandchild_pipe[1]; if (close(sync_grandchild_pipe[0]) < 0) bail(""failed to close sync_grandchild_pipe[0] fd""); write_log(DEBUG, ""-> stage-2 synchronisation loop""); stage2_complete = false; while (!stage2_complete) { enum sync_t s; write_log(DEBUG, ""signalling stage-2 to run""); s = SYNC_GRANDCHILD; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with child: write(SYNC_GRANDCHILD)""); } if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with child: next state""); switch (s) { case SYNC_CHILD_FINISH: write_log(DEBUG, ""stage-2 complete""); stage2_complete = true; break; default: bail(""unexpected sync value: %u"", s); } } write_log(DEBUG, ""<- stage-2 synchronisation loop""); write_log(DEBUG, ""<~ nsexec stage-0""); exit(0); } break; case STAGE_CHILD:{ pid_t stage2_pid = -1; enum sync_t s; syncfd = sync_child_pipe[0]; if (close(sync_child_pipe[1]) < 0) bail(""failed to close sync_child_pipe[1] fd""); prctl(PR_SET_NAME, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-1""); if (config.namespaces) join_namespaces(config.namespaces); if (config.cloneflags & CLONE_NEWUSER) { write_log(DEBUG, ""unshare user namespace""); if (unshare(CLONE_NEWUSER) < 0) bail(""failed to unshare user namespace""); config.cloneflags &= ~CLONE_NEWUSER; if (config.namespaces) { write_log(DEBUG, ""temporarily set process as dumpable""); if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0) bail(""failed to temporarily set process as dumpable""); } write_log(DEBUG, ""request stage-0 to map user namespace""); s = SYNC_USERMAP_PLS; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)""); write_log(DEBUG, ""request stage-0 to map user namespace""); if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)""); if (s != SYNC_USERMAP_ACK) bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", s); if (config.namespaces) { write_log(DEBUG, ""re-set process as non-dumpable""); if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0) bail(""failed to re-set process as non-dumpable""); } if (setresuid(0, 0, 0) < 0) bail(""failed to become root in user namespace""); } write_log(DEBUG, ""unshare remaining namespace (except cgroupns)""); if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0) bail(""failed to unshare remaining namespaces (except cgroupns)""); write_log(DEBUG, ""spawn stage-2""); stage2_pid = clone_parent(&env, STAGE_INIT); if (stage2_pid < 0) bail(""unable to spawn stage-2""); write_log(DEBUG, ""request stage-0 to forward stage-2 pid (%d)"", stage2_pid); s = SYNC_RECVPID_PLS; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)""); } if (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(stage2_pid)""); } if (read(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)""); } if (s != SYNC_RECVPID_ACK) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", s); } write_log(DEBUG, ""signal completion to stage-0""); s = SYNC_CHILD_FINISH; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(SYNC_CHILD_FINISH)""); } write_log(DEBUG, ""<~ nsexec stage-1""); exit(0); } break; case STAGE_INIT:{ enum sync_t s; syncfd = sync_grandchild_pipe[0]; if (close(sync_grandchild_pipe[1]) < 0) bail(""failed to close sync_grandchild_pipe[1] fd""); if (close(sync_child_pipe[0]) < 0) bail(""failed to close sync_child_pipe[0] fd""); prctl(PR_SET_NAME, (unsigned long)""runc:[2:INIT]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-2""); if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: read(SYNC_GRANDCHILD)""); if (s != SYNC_GRANDCHILD) bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", s); if (setsid() < 0) bail(""setsid failed""); if (setuid(0) < 0) bail(""setuid failed""); if (setgid(0) < 0) bail(""setgid failed""); if (!config.is_rootless_euid && config.is_setgroup) { if (setgroups(0, NULL) < 0) bail(""setgroups failed""); } if (config.cloneflags & CLONE_NEWCGROUP) { if (unshare(CLONE_NEWCGROUP) < 0) bail(""failed to unshare cgroup namespace""); } write_log(DEBUG, ""signal completion to stage-0""); s = SYNC_CHILD_FINISH; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: write(SYNC_CHILD_FINISH)""); if (close(sync_grandchild_pipe[0]) < 0) bail(""failed to close sync_grandchild_pipe[0] fd""); nl_free(&config); write_log(DEBUG, ""<= nsexec container setup""); write_log(DEBUG, ""booting up go runtime ...""); return; } break; default: bail(""unknown stage '%d' for jump value"", current_stage); } bail(""should never be reached""); }"
"int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params) { int Result = RESULT_SUCCESS; try { std::unique_ptr<TStrings> Arguments(new TStringList()); if (!DebugAlwaysTrue(Params->FindSwitch(L""batchsettings"", Arguments.get()))) { Abort(); } else { if (Arguments->Count < 1) { throw Exception(LoadStr(BATCH_SET_NO_MASK)); } else if (Arguments->Count < 2) { throw Exception(LoadStr(BATCH_SET_NO_SETTINGS)); } else { TFileMasks Mask(Arguments->Strings[0]); Arguments->Delete(0); std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false)); int Matches = 0; int Changes = 0; for (int Index = 0; Index < StoredSessions->Count; Index++) { TSessionData * Data = StoredSessions->Sessions[Index]; if (!Data->IsWorkspace && Mask.Matches(Data->Name, false, false)) { Matches++; std::unique_ptr<TSessionData> OriginalData(new TSessionData(L"""")); OriginalData->CopyDataNoRecrypt(Data); Data->ApplyRawSettings(OptionsStorage.get()); bool Changed = !OriginalData->IsSame(Data, false); if (Changed) { Changes++; } UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED); Console->PrintLine(FORMAT(L""%s - %s"", (Data->Name, StateStr))); } } StoredSessions->Save(false, true);         Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes))); } } } catch (Exception & E) { Result = HandleException(Console, E); } Console->WaitBeforeExit(); return Result; }"
"char *GetCommandbyName(const char *name, int *timeout) { int i = 0; if (name[0] == '!') { static char command[OS_FLSIZE]; if (snprintf(command, sizeof(command), ""%s/%s"", AR_BINDIR, name + 1) >= (int)sizeof(command)) { mwarn(""Cannot execute command '%32s...': path too long."", name + 1); return NULL; } *timeout = 0; return command; } for (; i < exec_size; i++) { if (strcmp(name, exec_names[i]) == 0) { *timeout = exec_timeout[i]; return (exec_cmd[i]); } } return (NULL); }"
"LogicalResult IfOpConversion::matchAndRewrite(scf::IfOp ifOp, OpAdaptor adaptor, ConversionPatternRewriter &rewriter) const { auto loc = ifOp.getLoc(); auto selectionOp = rewriter.create<spirv::SelectionOp>(loc, spirv::SelectionControl::None); auto *mergeBlock = rewriter.createBlock(&selectionOp.getBody(), selectionOp.getBody().end()); rewriter.create<spirv::MergeOp>(loc); OpBuilder::InsertionGuard guard(rewriter); auto *selectionHeaderBlock = rewriter.createBlock(&selectionOp.getBody().front()); auto &thenRegion = ifOp.getThenRegion(); auto *thenBlock = &thenRegion.front(); rewriter.setInsertionPointToEnd(&thenRegion.back()); rewriter.create<spirv::BranchOp>(loc, mergeBlock); rewriter.inlineRegionBefore(thenRegion, mergeBlock); auto *elseBlock = mergeBlock; if (!ifOp.getElseRegion().empty()) { auto &elseRegion = ifOp.getElseRegion(); elseBlock = &elseRegion.front(); rewriter.setInsertionPointToEnd(&elseRegion.back()); rewriter.create<spirv::BranchOp>(loc, mergeBlock); rewriter.inlineRegionBefore(elseRegion, mergeBlock); } rewriter.setInsertionPointToEnd(selectionHeaderBlock); rewriter.create<spirv::BranchConditionalOp>(loc, adaptor.getCondition(), thenBlock, ArrayRef<Value>(), elseBlock, ArrayRef<Value>()); SmallVector<Type, 8> returnTypes; for (auto result : ifOp.getResults()) { auto convertedType = typeConverter.convertType(result.getType()); returnTypes.push_back(convertedType); } replaceSCFOutputValue(ifOp, selectionOp, rewriter, scfToSPIRVContext, returnTypes); return success(); }"
"static int action_getconfig(struct mansession *s, const struct message *m) { struct ast_config *cfg; const char *fn = astman_get_header(m, ""Filename""); const char *category = astman_get_header(m, ""Category""); const char *filter = astman_get_header(m, ""Filter""); const char *category_name; int catcount = 0; int lineno = 0; struct ast_category *cur_category = NULL; struct ast_variable *v; struct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE }; if (ast_strlen_zero(fn)) { astman_send_error(s, m, ""Filename not specified""); return 0; } if (restrictedFile(fn)) { astman_send_error(s, m, ""File requires escalated priveledges""); return 0; } cfg = ast_config_load2(fn, ""manager"", config_flags); if (cfg == CONFIG_STATUS_FILEMISSING) { astman_send_error(s, m, ""Config file not found""); return 0; } else if (cfg == CONFIG_STATUS_FILEINVALID) { astman_send_error(s, m, ""Config file has invalid format""); return 0; } astman_start_ack(s, m); while ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) { struct ast_str *templates; category_name = ast_category_get_name(cur_category); lineno = 0; astman_append(s, ""Category-%06d: %s\r\n"", catcount, category_name); if (ast_category_is_template(cur_category)) { astman_append(s, ""IsTemplate-%06d: %d\r\n"", catcount, 1); } if ((templates = ast_category_get_templates(cur_category)) && ast_str_strlen(templates) > 0) { astman_append(s, ""Templates-%06d: %s\r\n"", catcount, ast_str_buffer(templates)); ast_free(templates); } for (v = ast_category_first(cur_category); v; v = v->next) { astman_append(s, ""Line-%06d-%06d: %s=%s\r\n"", catcount, lineno++, v->name, v->value); } catcount++; } if (!ast_strlen_zero(category) && catcount == 0) {  astman_append(s, ""No categories found\r\n""); } ast_config_destroy(cfg); astman_append(s, ""\r\n""); return 0; }"
"static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req, const struct io_uring_sqe *sqe) __must_hold(&ctx->uring_lock) { struct io_submit_state *state; unsigned int sqe_flags; int personality, ret = 0; req->opcode = READ_ONCE(sqe->opcode); req->flags = sqe_flags = READ_ONCE(sqe->flags); req->user_data = READ_ONCE(sqe->user_data); req->file = NULL; req->fixed_rsrc_refs = NULL; req->task = current; if (unlikely(sqe_flags & ~SQE_VALID_FLAGS)) return -EINVAL; if (unlikely(req->opcode >= IORING_OP_LAST)) return -EINVAL; if (!io_check_restriction(ctx, req, sqe_flags)) return -EACCES; if ((sqe_flags & IOSQE_BUFFER_SELECT) && !io_op_defs[req->opcode].buffer_select) return -EOPNOTSUPP; if (unlikely(sqe_flags & IOSQE_IO_DRAIN)) ctx->drain_active = true; personality = READ_ONCE(sqe->personality); if (personality) { req->creds = xa_load(&ctx->personalities, personality); if (!req->creds) return -EINVAL; get_cred(req->creds); req->flags |= REQ_F_CREDS; } state = &ctx->submit_state; if (!state->plug_started && state->ios_left > 1 && io_op_defs[req->opcode].plug) { blk_start_plug(&state->plug); state->plug_started = true; } if (io_op_defs[req->opcode].needs_file) { req->file = io_file_get(ctx, req, READ_ONCE(sqe->fd), (sqe_flags & IOSQE_FIXED_FILE)); if (unlikely(!req->file)) ret = -EBADF; } state->ios_left--; return ret; }"
"static int writeback_single_inode(struct inode *inode, struct writeback_control *wbc) { struct bdi_writeback *wb; int ret = 0; spin_lock(&inode->i_lock); if (!atomic_read(&inode->i_count)) WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING))); else WARN_ON(inode->i_state & I_WILL_FREE); if (inode->i_state & I_SYNC) { if (wbc->sync_mode != WB_SYNC_ALL) goto out; __inode_wait_for_writeback(inode); } WARN_ON(inode->i_state & I_SYNC); if (!(inode->i_state & I_DIRTY_ALL) && (wbc->sync_mode != WB_SYNC_ALL || !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK))) goto out; inode->i_state |= I_SYNC; wbc_attach_and_unlock_inode(wbc, inode); ret = __writeback_single_inode(inode, wbc); wbc_detach_inode(wbc); wb = inode_to_wb_and_lock_list(inode); spin_lock(&inode->i_lock); if (!(inode->i_state & I_DIRTY_ALL)) inode_cgwb_move_to_attached(inode, wb); else if (!(inode->i_state & I_SYNC_QUEUED)) { if ((inode->i_state & I_DIRTY)) redirty_tail_locked(inode, wb); else if (inode->i_state & I_DIRTY_TIME) { inode->dirtied_when = jiffies; inode_io_list_move_locked(inode, wb, &wb->b_dirty_time); } } spin_unlock(&wb->list_lock); inode_sync_complete(inode); out: spin_unlock(&inode->i_lock); return ret; }"
"static Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { const char *source_str; int source_len, bLen; const char *replace_str = NULL; int replace_len; int regexec_flags = 0; Jsi_Value *seq, *strVal; Jsi_DString dStr = {}; regex_t *regex; Jsi_Regex *re; const char *p; int maxArgs = 1; int offset = 0, n, j, isglob = 0, num_matches = 0; ChkString(_this, funcPtr, source_str, &source_len, &bLen); source_len = bLen; if (!skip) strVal = _this; else strVal = Jsi_ValueArrayIndex(interp, args, 0); seq = Jsi_ValueArrayIndex(interp, args, skip); Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip); if (!Jsi_ValueIsFunction(interp, repVal)) replace_str = Jsi_ValueToString(interp, repVal, &replace_len); else maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt; Jsi_DSInit(&dStr); if (Jsi_ValueIsString(interp, seq)) { const char *ce, *cp = Jsi_ValueString(interp, seq, NULL); if (!(ce = Jsi_Strstr(source_str, cp))) Jsi_ValueMakeStringDup(interp, ret, source_str); else { int slen; slen = (ce-source_str); if (slen) Jsi_DSAppendLen(&dStr, source_str, slen); if (replace_str) Jsi_DSAppendLen(&dStr, replace_str, replace_len); else { Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str); Jsi_IncrRefCount(interp, inStr); Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr); if (Jsi_InterpGone(interp)) return JSI_ERROR; if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } Jsi_DecrRefCount(interp, inStr); } Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL); Jsi_ValueFromDS(interp, &dStr, ret); } return JSI_OK; } if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) { Jsi_ValueMakeNull(interp, ret); return JSI_OK; } re = seq->d.obj->d.robj; regex = &re->reg; isglob = (re->eflags & JSI_REG_GLOB); regmatch_t pmatch[MAX_SUBREGEX] = {}; int eoffset=0; if (offset) { if (offset < 0) { offset += source_len + 1; } if (offset > source_len) { offset = source_len; } else if (offset < 0) { offset = 0; } } Jsi_DSAppendLen(&dStr, source_str, offset); n = source_len - offset; p = source_str + offset; Jsi_RC rc = JSI_OK; do { if (num_matches > 10000000) { Jsi_LogBug(""regexp infinite loop""); rc = JSI_ERROR; break; } int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags); if (match >= REG_BADPAT) { char buf[JSI_MAX_NUMBER_STRING]; regerror(match, regex, buf, sizeof(buf)); Jsi_LogError(""error while matching pattern: %s"", buf); Jsi_DSFree(&dStr); return JSI_ERROR; } if (match == REG_NOMATCH) { break; } num_matches++; Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so); if (replace_str &&  !Jsi_Strchr(replace_str, '$')) Jsi_DSAppend(&dStr, replace_str, NULL); else if (replace_str) { for (j = 0; j < replace_len; j++) { int idx; int c = replace_str[j]; if (c == '$' && j < replace_len) { c = replace_str[++j]; if ((c >= '0') && (c <= '9')) { idx = c - '0'; } else if (c == '&') { idx = 0; } else if (c == '$') { Jsi_DSAppendLen(&dStr, replace_str + j, 1); continue; } else if (c == '\'') { Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p)); continue; } else if (c == '`') { Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so); continue; } else { Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2); continue; } } else { Jsi_DSAppendLen(&dStr, replace_str + j, 1); continue; } if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) { Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so, pmatch[idx].rm_eo - pmatch[idx].rm_so); } } } else { Jsi_DString sStr; Jsi_DSInit(&sStr);  if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0) break; int olen = -1; char *ostr = jsi_SubstrDup(p, -1, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so, &olen); Jsi_Value *inStr = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen); Jsi_DSFree(&sStr); Jsi_IncrRefCount(interp, inStr); if (maxArgs==1) { Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr); if (Jsi_InterpGone(interp)) return JSI_ERROR; if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } } else { Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret; int i; items[0] = inStr; for (i=1; i<=(int)re->reg.re_nsub && i<(MAX_SUBREGEX-3); i++) { if (pmatch[i].rm_so<0) items[i] = interp->NullValue; else { ostr = jsi_SubstrDup(p, -1, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so, &olen); items[i] = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen); } } items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so); items[i++] = strVal; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0)); Jsi_IncrRefCount(interp, vpargs); ret = Jsi_ValueNew1(interp); rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL); if (Jsi_InterpGone(interp)) return JSI_ERROR; Jsi_DecrRefCount(interp, vpargs); if (rc == JSI_OK) Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL); Jsi_DecrRefCount(interp, ret); if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } } Jsi_DecrRefCount(interp, inStr); } eoffset += pmatch[0].rm_eo; p += pmatch[0].rm_eo; n -= pmatch[0].rm_eo; if (!isglob || n == 0 || pmatch[0].rm_eo == 0) { break; } if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') { break; } if (re->pattern[0] == '\0' && n) { Jsi_DSAppendLen(&dStr, p, 1); p++; n--; } regexec_flags |= REG_NOTBOL; } while (n); Jsi_DSAppend(&dStr, p, NULL); Jsi_ValueFromDS(interp, &dStr, ret); return rc; }"
"void Pl_ASCII85Decoder::flush() { if (this->pos == 0) { QTC::TC(""libtests"", ""Pl_ASCII85Decoder no-op flush""); return; } unsigned long lval = 0; for (int i = 0; i < 5; ++i) { lval *= 85; lval += (this->inbuf[i] - 33U); } unsigned char outbuf[4]; memset(outbuf, 0, 4); for (int i = 3; i >= 0; --i) { outbuf[i] = lval & 0xff; lval >>= 8; } QTC::TC(""libtests"", ""Pl_ASCII85Decoder partial flush"", (this->pos == 5) ? 0 : 1); getNext()->write(outbuf, this->pos - 1); this->pos = 0; memset(this->inbuf, 117, 5); }"
"static void gf_media_update_bitrate_ex(GF_ISOFile *file, u32 track, Bool use_esd) { #ifndef GPAC_DISABLE_ISOM_WRITE u32 i, count, timescale, db_size, cdur, csize; u64 time_wnd, max_rate, avg_rate, bitrate; Double br; GF_ISOSample sample; db_size = 0; max_rate = avg_rate = time_wnd = bitrate = 0; csize = 0; cdur = 0; if (gf_isom_get_media_type(file, track)==GF_ISOM_MEDIA_AUDIO) { csize = gf_isom_get_constant_sample_size(file, track); cdur = gf_isom_get_constant_sample_duration(file, track); if (cdur > 1) cdur = 0; } memset(&sample, 0, sizeof(GF_ISOSample)); timescale = gf_isom_get_media_timescale(file, track); count = gf_isom_get_sample_count(file, track); if (csize && cdur) { db_size = 0; avg_rate = 8 * csize * timescale / cdur; bitrate = avg_rate; } else { u32 rate = 0; for (i=0; i<count; i++) { u32 di; GF_ISOSample *samp = gf_isom_get_sample_info_ex(file, track, i+1, &di, NULL, &sample); if (!samp) break; if (samp->dataLength > db_size) db_size = samp->dataLength; avg_rate += samp->dataLength; rate += samp->dataLength; if (samp->DTS > time_wnd + timescale) { if (rate > max_rate) max_rate = rate; time_wnd = samp->DTS; rate = 0; } } } br = (Double) (s64) gf_isom_get_media_duration(file, track); br /= timescale; if (br) { GF_ESD *esd = NULL; if (!csize || !cdur) { bitrate = (u32) ((Double) (s64)avg_rate / br); bitrate *= 8; max_rate *= 8; } if (!max_rate) max_rate = bitrate; if (use_esd) esd = gf_isom_get_esd(file, track, 1); if (esd && esd->decoderConfig) { esd->decoderConfig->avgBitrate = (u32) bitrate; esd->decoderConfig->maxBitrate = (u32) max_rate; esd->decoderConfig->bufferSizeDB = db_size; gf_isom_change_mpeg4_description(file, track, 1, esd); } else { gf_isom_update_bitrate(file, track, 1, (u32) bitrate, (u32) max_rate, db_size); } if (esd) gf_odf_desc_del((GF_Descriptor *)esd); } #endif }"
"static void handle_mailto (EMsgComposer *composer, const gchar *mailto) { EAttachmentView *view; EAttachmentStore *store; EComposerHeaderTable *table; GList *to = NULL, *cc = NULL, *bcc = NULL; EDestination **tov, **ccv, **bccv; gchar *subject = NULL, *body = NULL; gchar *header, *content, *buf; gsize nread, nwritten; const gchar *p; gint len, clen; table = e_msg_composer_get_header_table (composer); view = e_msg_composer_get_attachment_view (composer); store = e_attachment_view_get_store (view); buf = g_strdup (mailto); p = buf + 7; while (*p == '/' && p - buf < 10) p++; len = strcspn (p, ""?""); if (len) { content = g_strndup (p, len); camel_url_decode (content); to = add_recipients (to, content); g_free (content); } p += len; if (*p == '?') { p++; while (*p) { len = strcspn (p, ""=&""); if (p[len] != '=') break; header = (gchar *) p; header[len] = '\0'; p += len + 1; clen = strcspn (p, ""&""); content = g_strndup (p, clen); if (!g_ascii_strcasecmp (header, ""to"")) { camel_url_decode (content); to = add_recipients (to, content); } else if (!g_ascii_strcasecmp (header, ""cc"")) { camel_url_decode (content); cc = add_recipients (cc, content); } else if (!g_ascii_strcasecmp (header, ""bcc"")) { camel_url_decode (content); bcc = add_recipients (bcc, content); } else if (!g_ascii_strcasecmp (header, ""subject"")) { g_free (subject); camel_url_decode (content); if (g_utf8_validate (content, -1, NULL)) { subject = content; content = NULL; } else { subject = g_locale_to_utf8 ( content, clen, &nread, &nwritten, NULL); if (subject) { subject = g_realloc (subject, nwritten + 1); subject[nwritten] = '\0'; } } } else if (!g_ascii_strcasecmp (header, ""body"")) { g_free (body); camel_url_decode (content); if (g_utf8_validate (content, -1, NULL)) { body = content; content = NULL; } else { body = g_locale_to_utf8 ( content, clen, &nread, &nwritten, NULL); if (body) { body = g_realloc (body, nwritten + 1); body[nwritten] = '\0'; } } } else if (!g_ascii_strcasecmp (header, ""attach"") || !g_ascii_strcasecmp (header, ""attachment"")) { EAttachment *attachment; camel_url_decode (content); if (file_is_blacklisted (content)) e_alert_submit ( E_ALERT_SINK (e_msg_composer_get_editor (composer)), ""mail:blacklisted-file"", content, NULL); if (g_ascii_strncasecmp (content, ""file:"", 5) == 0) attachment = e_attachment_new_for_uri (content); else attachment = e_attachment_new_for_path (content); e_attachment_store_add_attachment (store, attachment); e_attachment_load_async ( attachment, (GAsyncReadyCallback) e_attachment_load_handle_error, composer); g_object_unref (attachment); } else if (!g_ascii_strcasecmp (header, ""from"")) { } else if (!g_ascii_strcasecmp (header, ""reply-to"")) { } else { camel_url_decode (content); e_msg_composer_add_header (composer, header, content); } g_free (content); p += clen; if (*p == '&') { p++; if (!g_ascii_strncasecmp (p, ""amp;"", 4)) p += 4; } } } g_free (buf); merge_always_cc_and_bcc (table, to, &cc, &bcc); tov = destination_list_to_vector (to); ccv = destination_list_to_vector (cc); bccv = destination_list_to_vector (bcc); g_list_free (to); g_list_free (cc); g_list_free (bcc); e_composer_header_table_set_destinations_to (table, tov); e_composer_header_table_set_destinations_cc (table, ccv); e_composer_header_table_set_destinations_bcc (table, bccv); e_destination_freev (tov); e_destination_freev (ccv); e_destination_freev (bccv); e_composer_header_table_set_subject (table, subject); g_free (subject); if (body) { GSettings *settings; gchar *html_body; guint32 flags = 0; settings = e_util_ref_settings (""org.gnome.evolution.mail""); if (g_settings_get_boolean (settings, ""composer-magic-links"")) { flags |= CAMEL_MIME_FILTER_TOHTML_CONVERT_URLS | CAMEL_MIME_FILTER_TOHTML_CONVERT_ADDRESSES; } if (g_settings_get_boolean (settings, ""composer-mailto-body-in-pre"")) flags |= CAMEL_MIME_FILTER_TOHTML_PRE; else flags |= CAMEL_MIME_FILTER_TOHTML_CONVERT_NL | CAMEL_MIME_FILTER_TOHTML_CONVERT_SPACES; g_clear_object (&settings); html_body = camel_text_to_html (body, flags, 0); set_editor_text (composer, html_body, TRUE, TRUE); g_free (html_body); g_free (body); } }"
"void *zmalloc_no_tcache(size_t size) { void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE); if (!ptr) zmalloc_oom_handler(size); update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; }"
static int redisIvykisAttach(redisAsyncContext *ac) { redisContext *c = &(ac->c); redisIvykisEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisIvykisEvents*)malloc(sizeof(*e)); e->context = ac; ac->ev.addRead = redisIvykisAddRead; ac->ev.delRead = redisIvykisDelRead; ac->ev.addWrite = redisIvykisAddWrite; ac->ev.delWrite = redisIvykisDelWrite; ac->ev.cleanup = redisIvykisCleanup; ac->ev.data = e; IV_FD_INIT(&e->fd); e->fd.fd = c->fd; e->fd.handler_in = redisIvykisReadEvent; e->fd.handler_out = redisIvykisWriteEvent; e->fd.handler_err = NULL; e->fd.cookie = e->context; iv_fd_register(&e->fd); return REDIS_OK; }
"static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc) { struct evtchn *chn; struct domain *d; int            port; domid_t        dom = alloc->dom; long           rc; d = rcu_lock_domain_by_any_id(dom); if ( d == NULL ) return -ESRCH; spin_lock(&d->event_lock); if ( (port = get_free_port(d)) < 0 ) ERROR_EXIT_DOM(port, d); chn = evtchn_from_port(d, port); rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom); if ( rc ) goto out; spin_lock(&chn->lock); chn->state = ECS_UNBOUND; if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF ) chn->u.unbound.remote_domid = current->domain->domain_id; evtchn_port_init(d, chn); spin_unlock(&chn->lock); alloc->port = port; out: check_free_port(d, port); spin_unlock(&d->event_lock); rcu_unlock_domain(d); return rc; }"
"ssize_t netio_recv(netio_desc_t *nio,void *pkt,size_t max_len) { ssize_t len; int res; if (!nio) return(-1); if ((len = nio->recv(nio->dptr,pkt,max_len)) <= 0) return(-1); if (nio->debug) { printf(""NIO %s: receiving a packet of %ld bytes:\n"",nio->name,(long)len); mem_dump(stdout,pkt,len); } if (nio->rx_filter != NULL) { res = nio->rx_filter->pkt_handler(nio,pkt,len,nio->rx_filter_data); if (res == NETIO_FILTER_ACTION_DROP) return(-1); } if (nio->both_filter != NULL) { res = nio->both_filter->pkt_handler(nio,pkt,len,nio->both_filter_data); if (res == NETIO_FILTER_ACTION_DROP) return(-1); } nio->stats_pkts_in++; nio->stats_bytes_in += len; return(len); }"
"bool ConstantFolding::SimplifyReshape(const GraphProperties& properties, bool use_shape_info, NodeDef* node) { if (!use_shape_info || node->attr().count(""T"") == 0 || !IsSimplifiableReshape(*node, properties)) { return false; } DataType output_type = node->attr().at(""T"").type(); node->set_op(""Identity""); EraseRegularNodeAttributes(node); (*node->mutable_attr())[""T""].set_type(output_type); *node->mutable_input(1) = AsControlDependency(node->input(1)); return true; }"
"static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) { RAnalRef *xref; RListIter *xrefIter; if (!curAddress || curAddress == UT64_MAX) { return false; } if (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) { return false; } RList *xrefs = r_anal_xrefs_get (context->anal, curAddress); if (r_list_empty (xrefs)) { r_list_free (xrefs); return false; } r_list_foreach (xrefs, xrefIter, xref) { if (vtable_addr_in_text_section (context, xref->addr)) { ut8 buf[VTABLE_BUFF_SIZE]; context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf)); RAnalOp analop = {0}; r_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC); if (analop.type == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) { r_list_free (xrefs); r_anal_op_fini (&analop); return true; } r_anal_op_fini (&analop); } } r_list_free (xrefs); return false; }"
"static int nut_read_header(AVFormatContext *s) { NUTContext *nut = s->priv_data; AVIOContext *bc = s->pb; int64_t pos; int initialized_stream_count; nut->avf = s; pos = 0; do { pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, ""No main startcode found.\n""); return AVERROR_INVALIDDATA; } } while (decode_main_header(nut) < 0); pos = 0; for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) { pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, ""Not all stream headers found.\n""); return AVERROR_INVALIDDATA; } if (decode_stream_header(nut) >= 0) initialized_stream_count++; } pos = 0; for (;;) { uint64_t startcode = find_any_startcode(bc, pos); pos = avio_tell(bc); if (startcode == 0) { av_log(s, AV_LOG_ERROR, ""EOF before video frames\n""); return AVERROR_INVALIDDATA; } else if (startcode == SYNCPOINT_STARTCODE) { nut->next_startcode = startcode; break; } else if (startcode != INFO_STARTCODE) { continue; } decode_info_header(nut); } ffformatcontext(s)->data_offset = pos - 8; if (bc->seekable & AVIO_SEEKABLE_NORMAL) { int64_t orig_pos = avio_tell(bc); find_and_decode_index(nut); avio_seek(bc, orig_pos, SEEK_SET); } av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE); ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv); return 0; }"
"static void svg_process_media_href(GF_SVG_Parser *parser, GF_Node *elt, XMLRI *iri) { u32 tag = gf_node_get_tag(elt); if ((tag==TAG_SVG_image) || (tag==TAG_SVG_video) || (tag==TAG_SVG_audio)) { SVG_SAFExternalStream *st = svg_saf_get_stream(parser, 0, iri->string+1); if (!st && !strnicmp(iri->string, ""stream:"", 7)) st = svg_saf_get_stream(parser, 0, iri->string+7); if (st) { gf_free(iri->string); iri->string = NULL; iri->lsr_stream_id = st->id; iri->type = XMLRI_STREAMID; return; } } if ((parser->load->flags & GF_SM_LOAD_EMBEDS_RES) && (iri->type==XMLRI_STRING) ) { u32 size; char *buffer; GF_Err e = gf_file_load_data(iri->string, (u8 **) &buffer, &size); if (e) return; if (tag==TAG_SVG_script) { GF_DOMText *dtext; GF_DOMAttribute *att, *prev; buffer[size]=0; dtext = gf_dom_add_text_node(elt, buffer); dtext->type = GF_DOM_TEXT_CDATA; gf_free(iri->string); iri->string=NULL; att = ((GF_DOMNode*)elt)->attributes; prev = NULL; while(att) { if (att->tag!=TAG_XLINK_ATT_href) { prev = att; att = att->next; continue; } gf_svg_delete_attribute_value(att->data_type, att->data, elt->sgprivate->scenegraph); if (prev) prev->next = att->next; else ((GF_DOMNode*)elt)->attributes = att->next; gf_free(att); break; } } else { char *mtype; char *buf64; u64 size64; char *ext; buf64 = (char *)gf_malloc((size_t)size*2); size64 = gf_base64_encode(buffer, (u32)size, buf64, (u32)size*2); buf64[size64] = 0; mtype = ""application/data""; ext = strchr(iri->string, '.'); if (ext) { if (!stricmp(ext, "".png"")) mtype = ""image/png""; if (!stricmp(ext, "".jpg"") || !stricmp(ext, "".jpeg"")) mtype = ""image/jpg""; } gf_free(iri->string); iri->string = (char *)gf_malloc(sizeof(char)*(40+(size_t)size64)); sprintf(iri->string, ""data:%s;base64,%s"", mtype, buf64); gf_free(buf64); gf_free(buffer); } } }"
"int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) { unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX]; unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX]; unsigned char sharedsecret[sshcrypto_kem_MAX]; unsigned char sm[sshcrypto_sign_MAX]; unsigned char key[sshcrypto_cipher_KEYMAX]; unsigned char hash[sshcrypto_hash_MAX]; long long pos = 0; crypto_uint8 ch; crypto_uint32 len; long long i; if (packet.kex_packet_follows && !packet.kex_guess) { buf_purge(b1); if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0; } buf_purge(b1); if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0; pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);            if (ch != SSH_MSG_KEXDH_INIT) bug_proto(); pos = packetparser_uint32(b1->buf, b1->len, pos, &len);          if (len != sshcrypto_kem_publickeybytes) bug_proto(); pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len); pos = packetparser_end(b1->buf, b1->len, pos); buf_purge(b1); do {  if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto(); } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32); buf_purge(&packet.hashbuf); buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len); buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len); buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len); buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len); sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey); buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes); buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes); sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret); sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len); if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash); packet.flagrekeying = 1; if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0; buf_purge(b1); buf_purge(b2); buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                            sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);           buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);   sshcrypto_buf_putsignature(b2, sm);                              packet_put(b2); buf_purge(b2); buf_putnum8(b2, SSH_MSG_NEWKEYS); packet_put(b2); if (!packet_sendall()) return 0; do { buf_purge(b2); if (!packet_getall(b2, 0)) return 0; } while (b2->buf[0] != SSH_MSG_NEWKEYS); for(i = 0; i < 6; ++i) { buf_purge(b1); sshcrypto_buf_putkemkey(b1, sharedsecret); buf_put(b1, hash, sshcrypto_hash_bytes); buf_putnum8(b1, 'A' + i); buf_put(b1, packet.sessionid, sshcrypto_hash_bytes); sshcrypto_hash(key, b1->buf, b1->len); buf_purge(b1); sshcrypto_buf_putkemkey(b1, sharedsecret); buf_put(b1, hash, sshcrypto_hash_bytes); buf_put(b1, key, sshcrypto_hash_bytes); sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len); if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key); if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key); if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key); if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key); if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key); if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key); } purge(clientpk, sizeof clientpk); purge(serverpk, sizeof serverpk); purge(sharedsecret, sizeof sharedsecret); purge(sm, sizeof sm); purge(key, sizeof key); purge(hash, sizeof hash); return 1; }"
"static int smtp_open(struct Connection *conn, bool esmtp) { int rc; if (mutt_socket_open(conn)) return -1; rc = smtp_get_resp(conn); if (rc != 0) return rc; rc = smtp_helo(conn, esmtp); if (rc != 0) return rc; #ifdef USE_SSL enum QuadOption ans = MUTT_NO; if (conn->ssf) ans = MUTT_NO; else if (C_SslForceTls) ans = MUTT_YES; else if ((Capabilities & SMTP_CAP_STARTTLS) && ((ans = query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""))) == MUTT_ABORT)) { return -1; } if (ans == MUTT_YES) { if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0) return SMTP_ERR_WRITE; rc = smtp_get_resp(conn); if (rc != 0) return rc; if (mutt_ssl_starttls(conn)) { mutt_error(_(""Could not negotiate TLS connection"")); return -1; } rc = smtp_helo(conn, esmtp); if (rc != 0) return rc; } #endif if (conn->account.flags & MUTT_ACCT_USER) { if (!(Capabilities & SMTP_CAP_AUTH)) { mutt_error(_(""SMTP server does not support authentication"")); return -1; } return smtp_auth(conn); } return 0; }"
"ServerSecurityFeature::ServerSecurityFeature( application_features::ApplicationServer& server) : ApplicationFeature(server, ""ServerSecurity""), _enableFoxxApi(true), _enableFoxxStore(true), _hardenedRestApi(false) { setOptional(false); startsAfter<application_features::GreetingsFeaturePhase>(); }"
"static int smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args, const char *domain) { char   *p, *e; if (line == NULL) return (0); if (*line != '<') return (0); e = strchr(line, '>'); if (e == NULL) return (0); *e++ = '\0'; while (*e == ' ') e++; *args = e; if (!text_to_mailaddr(maddr, line + 1)) return (0); p = strchr(maddr->user, ':'); if (p != NULL) { p++; memmove(maddr->user, p, strlen(p) + 1); } if (!valid_localpart(maddr->user) || !valid_domainpart(maddr->domain)) { if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0') return (1); if (maddr->user[0] == '\0') return (0); if (maddr->domain[0] == '\0') { (void)strlcpy(maddr->domain, domain, sizeof(maddr->domain)); return (1); } return (0); } return (1); }"
"void gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, u32 force_flush_type) { GF_M2TS_PESHeader pesh; if (!ts) return; if ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) { u32 len; Bool has_pes_header = GF_TRUE; Bool has_data = GF_TRUE; u32 stream_id = pes->pck_data[3]; Bool same_pts = GF_FALSE; switch (stream_id) { case GF_M2_STREAMID_PADDING: has_data = GF_FALSE; case GF_M2_STREAMID_PROGRAM_STREAM_MAP: case GF_M2_STREAMID_PRIVATE_2: case GF_M2_STREAMID_ECM: case GF_M2_STREAMID_EMM: case GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY: case GF_M2_STREAMID_DSMCC: case GF_M2_STREAMID_H222_TYPE_E: has_pes_header = GF_FALSE; break; } if (has_pes_header) { gf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh); if (ts->notify_pes_timing) { GF_M2TS_PES_PCK pck; memset(&pck, 0, sizeof(GF_M2TS_PES_PCK)); pck.PTS = pesh.PTS; pck.DTS = pesh.DTS; pck.stream = pes; if (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP; pes->pes_end_packet_number = ts->pck_number; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck); } GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\n"", pes->pid, pesh.DTS, pesh.PTS)); if (pesh.PTS) { if (pesh.PTS == pes->PTS) { same_pts = GF_TRUE; if ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) { same_pts = GF_FALSE; } else if (!pes->is_resume) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - same PTS ""LLU"" for two consecutive PES packets \n"", pes->pid, pes->PTS)); } } #ifndef GPAC_DISABLE_LOG #endif pes->PTS = pesh.PTS; #ifndef GPAC_DISABLE_LOG { if (!pes->is_resume && pes->DTS && (pesh.DTS == pes->DTS)) { if ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) { } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - same DTS ""LLU"" for two consecutive PES packets \n"", pes->pid, pes->DTS)); } } if (pesh.DTS < pes->DTS) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - DTS ""LLU"" less than previous DTS ""LLU""\n"", pes->pid, pesh.DTS, pes->DTS)); } } #endif pes->DTS = pesh.DTS; } else if (!pesh.hdr_data_len) { same_pts = GF_TRUE; } pes->is_resume = GF_FALSE; len = 9 + pesh.hdr_data_len; } else { if (!has_data) goto exit; len = 4; memset(&pesh, 0, sizeof(pesh)); } if ((u8) pes->pck_data[3]==0xfa) { GF_M2TS_SL_PCK sl_pck; GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\n"", pes->pid, pes->mpeg4_es_id)); if (pes->pck_data_len > len) { sl_pck.data = (char *)pes->pck_data + len; sl_pck.data_len = pes->pck_data_len - len; sl_pck.stream = (GF_M2TS_ES *)pes; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck); } else { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\n"", pes->pid, pes->pck_data_len, len)); } goto exit; } if (pes->reframe) { u32 remain = 0; u32 offset = len; if (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) { if (!force_flush_type) { pes->is_resume = GF_TRUE; return; } if (force_flush_type==1) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\n"", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len)); } } if (pes->prev_data_len) { if (pes->prev_data_len < len) { offset = len - pes->prev_data_len; memcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len); } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\n"", pes->pid, pes->prev_data_len )); } } if (!pes->temi_pending && pes->temi_tc_desc_len) { gf_m2ts_store_temi(ts, pes); } if (pes->temi_pending) { pes->temi_pending = 0; pes->temi_tc.pes_pts = pes->PTS; pes->temi_tc.pid = pes->pid; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc); } if (! ts->seek_mode) remain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh); if (pes->prev_data) gf_free(pes->prev_data); pes->prev_data = NULL; pes->prev_data_len = 0; if (remain) { pes->prev_data = gf_malloc(sizeof(char)*remain); assert(pes->pck_data_len >= remain); memcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain); pes->prev_data_len = remain; } } } else if (pes->pck_data_len) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\n"", pes->pid)); } exit: pes->pck_data_len = 0; pes->pes_len = 0; pes->rap = 0; }"
"PJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port( pjmedia_vid_conf *vid_conf, unsigned src_slot, unsigned sink_slot, void *opt) { vconf_port *src_port, *dst_port; unsigned i; PJ_ASSERT_RETURN(vid_conf && src_slot<vid_conf->opt.max_slot_cnt &&  sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL); PJ_UNUSED_ARG(opt); pj_mutex_lock(vid_conf->mutex); src_port = vid_conf->ports[src_slot]; dst_port = vid_conf->ports[sink_slot]; if (!src_port || !src_port->port->get_frame || !dst_port || !dst_port->port->put_frame) { PJ_LOG(4,(THIS_FILE,""Failed connecting video ports, make sure that "" ""source has get_frame() & sink has put_frame()"")); pj_mutex_unlock(vid_conf->mutex); return PJ_EINVAL; } for (i=0; i<src_port->listener_cnt; ++i) { if (src_port->listener_slots[i] == sink_slot) break; } if (i == src_port->listener_cnt) { src_port->listener_slots[src_port->listener_cnt] = sink_slot; dst_port->transmitter_slots[dst_port->transmitter_cnt] = src_slot; ++src_port->listener_cnt; ++dst_port->transmitter_cnt; if (src_port->listener_cnt == 1) { const pjmedia_video_format_info *vfi; pjmedia_video_apply_fmt_param vafp; vfi = pjmedia_get_video_format_info(NULL, src_port->port->info.fmt.id); pj_bzero(&vafp, sizeof(vafp)); vafp.size = src_port->port->info.fmt.det.vid.size; (*vfi->apply_fmt)(vfi, &vafp); if (vfi->color_model == PJMEDIA_COLOR_MODEL_RGB) { pj_memset(src_port->get_buf, 0, vafp.framebytes); } else if (src_port->port->info.fmt.id == PJMEDIA_FORMAT_I420 || src_port->port->info.fmt.id == PJMEDIA_FORMAT_YV12) {     pj_memset(src_port->get_buf, 16, vafp.plane_bytes[0]); pj_memset((pj_uint8_t*)src_port->get_buf + vafp.plane_bytes[0], 0x80, vafp.plane_bytes[1] * 2); } } update_render_state(vid_conf, dst_port); ++vid_conf->connect_cnt; if (vid_conf->connect_cnt == 1) { pj_status_t status; status = pjmedia_clock_start(vid_conf->clock); if (status != PJ_SUCCESS) { PJ_PERROR(4, (THIS_FILE, status, ""Failed to start clock"")); return status; } } PJ_LOG(4,(THIS_FILE,""Port %d (%.*s) transmitting to port %d (%.*s)"", src_slot, (int)src_port->name.slen, src_port->name.ptr, sink_slot, (int)dst_port->name.slen, dst_port->name.ptr)); } pj_mutex_unlock(vid_conf->mutex); return PJ_SUCCESS; }"
"void symmetric_difference (const hb_bit_set_invertible_t &other) { process (hb_bitwise_xor, other); inverted = inverted ^ other.inverted; }"
"void Compute(tensorflow::OpKernelContext* context) override { const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
"static uint8_t yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum, TSK_DADDR_T numblock, int32_t sec_skew) { TSK_FS_META *fs_meta; TSK_FS_FILE *fs_file; YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs; char ls[12]; YAFFSFS_PRINT_ADDR print; char timeBuf[32]; YaffsCacheObject * obj = NULL; YaffsCacheVersion * version = NULL; YaffsHeader * header = NULL; yaffscache_version_find_by_inode(yfs, inum, &version, &obj); if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) { return 1; } fs_meta = fs_file->meta; tsk_fprintf(hFile, ""inode: %"" PRIuINUM ""\n"", inum); tsk_fprintf(hFile, ""%sAllocated\n"", (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? """" : ""Not ""); if (fs_meta->link) tsk_fprintf(hFile, ""symbolic link to: %s\n"", fs_meta->link); tsk_fprintf(hFile, ""uid / gid: %"" PRIuUID "" / %"" PRIuGID ""\n"", fs_meta->uid, fs_meta->gid); tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls)); tsk_fprintf(hFile, ""mode: %s\n"", ls); tsk_fprintf(hFile, ""size: %"" PRIdOFF ""\n"", fs_meta->size); tsk_fprintf(hFile, ""num of links: %d\n"", fs_meta->nlink); if(version != NULL){ yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset); if(header != NULL){ tsk_fprintf(hFile, ""Name: %s\n"", header->name); } } if (sec_skew != 0) { tsk_fprintf(hFile, ""\nAdjusted Inode Times:\n""); fs_meta->mtime -= sec_skew; fs_meta->atime -= sec_skew; fs_meta->ctime -= sec_skew; tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); fs_meta->mtime += sec_skew; fs_meta->atime += sec_skew; fs_meta->ctime += sec_skew; tsk_fprintf(hFile, ""\nOriginal Inode Times:\n""); } else { tsk_fprintf(hFile, ""\nInode Times:\n""); } tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); if(version != NULL){ tsk_fprintf(hFile, ""\nHeader Chunk:\n""); tsk_fprintf(hFile, ""%"" PRIuDADDR ""\n"", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size))); } if (numblock > 0) { TSK_OFF_T lower_size = numblock * fs->block_size; fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size); } tsk_fprintf(hFile, ""\nData Chunks:\n""); if (flags & TSK_FS_ISTAT_RUNLIST){ const TSK_FS_ATTR *fs_attr_default = tsk_fs_file_attr_get_type(fs_file, TSK_FS_ATTR_TYPE_DEFAULT, 0, 0); if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) { if (tsk_fs_attr_print(fs_attr_default, hFile)) { tsk_fprintf(hFile, ""\nError creating run lists  ""); tsk_error_print(hFile); tsk_error_reset(); } } } else { print.idx = 0; print.hFile = hFile; if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY, (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) { tsk_fprintf(hFile, ""\nError reading file:  ""); tsk_error_print(hFile); tsk_error_reset(); } else if (print.idx != 0) { tsk_fprintf(hFile, ""\n""); } } tsk_fs_file_close(fs_file); return 0; }"
"int ksmbd_conn_handler_loop(void *p) { struct ksmbd_conn *conn = (struct ksmbd_conn *)p; struct ksmbd_transport *t = conn->transport; unsigned int pdu_size, max_allowed_pdu_size; char hdr_buf[4] = {0,}; int size; mutex_init(&conn->srv_mutex); __module_get(THIS_MODULE); if (t->ops->prepare && t->ops->prepare(t)) goto out; conn->last_active = jiffies; while (ksmbd_conn_alive(conn)) { if (try_to_freeze()) continue; kvfree(conn->request_buf); conn->request_buf = NULL; size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1); if (size != sizeof(hdr_buf)) break; pdu_size = get_rfc1002_len(hdr_buf); ksmbd_debug(CONN, ""RFC1002 header %u bytes\n"", pdu_size); if (ksmbd_conn_good(conn)) max_allowed_pdu_size = SMB3_MAX_MSGSIZE + conn->vals->max_write_size; else max_allowed_pdu_size = SMB3_MAX_MSGSIZE; if (pdu_size > max_allowed_pdu_size) { pr_err_ratelimited(""PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\n"", pdu_size, max_allowed_pdu_size, READ_ONCE(conn->status)); break; } if (pdu_size > MAX_STREAM_PROT_LEN) break; if (pdu_size < SMB1_MIN_SUPPORTED_HEADER_SIZE) break; size = pdu_size + 4 + 1; conn->request_buf = kvmalloc(size, GFP_KERNEL); if (!conn->request_buf) break; memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf)); if (!ksmbd_smb_request(conn)) break; size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2); if (size < 0) { pr_err(""sock_read failed: %d\n"", size); break; } if (size != pdu_size) { pr_err(""PDU error. Read: %d, Expected: %d\n"", size, pdu_size); continue; } if (((struct smb2_hdr *)smb2_get_msg(conn->request_buf))->ProtocolId == SMB2_PROTO_NUMBER) { if (pdu_size < SMB2_MIN_SUPPORTED_HEADER_SIZE) break; } if (!default_conn_ops.process_fn) { pr_err(""No connection request callback\n""); break; } if (default_conn_ops.process_fn(conn)) { pr_err(""Cannot handle request\n""); break; } } out: ksmbd_conn_set_releasing(conn); wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0); if (IS_ENABLED(CONFIG_UNICODE)) utf8_unload(conn->um); unload_nls(conn->local_nls); if (default_conn_ops.terminate_fn) default_conn_ops.terminate_fn(conn); t->ops->disconnect(t); module_put(THIS_MODULE); return 0; }"
"static void xgmac_enet_send(XgmacState *s) { struct desc bd; int frame_size; int len; uint8_t frame[8192]; uint8_t *ptr; ptr = frame; frame_size = 0; while (1) { xgmac_read_desc(s, &bd, 0); if ((bd.ctl_stat & 0x80000000) == 0) { break; } len = (bd.buffer1_size & 0xfff) + (bd.buffer2_size & 0xfff); if ((bd.buffer1_size & 0xfff) > 2048) { DEBUGF_BRK(""qemu:%s:ERROR...ERROR...ERROR... -- "" ""xgmac buffer 1 len on send > 2048 (0x%x)\n"", __func__, bd.buffer1_size & 0xfff); } if ((bd.buffer2_size & 0xfff) != 0) { DEBUGF_BRK(""qemu:%s:ERROR...ERROR...ERROR... -- "" ""xgmac buffer 2 len on send != 0 (0x%x)\n"", __func__, bd.buffer2_size & 0xfff); } if (len >= sizeof(frame)) { DEBUGF_BRK(""qemu:%s: buffer overflow %d read into %zu "" ""buffer\n"" , __func__, len, sizeof(frame)); DEBUGF_BRK(""qemu:%s: buffer1.size=%d; buffer2.size=%d\n"", __func__, bd.buffer1_size, bd.buffer2_size); } cpu_physical_memory_read(bd.buffer1_addr, ptr, len); ptr += len; frame_size += len; if (bd.ctl_stat & 0x20000000) { qemu_send_packet(qemu_get_queue(s->nic), frame, len); ptr = frame; frame_size = 0; s->regs[DMA_STATUS] |= DMA_STATUS_TI | DMA_STATUS_NIS; } bd.ctl_stat &= ~0x80000000; xgmac_write_desc(s, &bd, 0); } }"
"static int fw_set_parms(struct net *net, struct tcf_proto *tp, struct fw_filter *f, struct nlattr **tb, struct nlattr **tca, unsigned long base, u32 flags, struct netlink_ext_ack *extack) { struct fw_head *head = rtnl_dereference(tp->root); u32 mask; int err; err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags, extack); if (err < 0) return err; if (tb[TCA_FW_CLASSID]) { f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]); tcf_bind_filter(tp, &f->res, base); } if (tb[TCA_FW_INDEV]) { int ret; ret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack); if (ret < 0) return ret; f->ifindex = ret; } err = -EINVAL; if (tb[TCA_FW_MASK]) { mask = nla_get_u32(tb[TCA_FW_MASK]); if (mask != head->mask) return err; } else if (head->mask != 0xFFFFFFFF) return err; return 0; }"
"GF_Err gf_swf_read_header(SWFReader *read) { SWFRec rc; u8 sig[3]; sig[0] = gf_bs_read_u8(read->bs); sig[1] = gf_bs_read_u8(read->bs); sig[2] = gf_bs_read_u8(read->bs); if ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) { return GF_NON_COMPLIANT_BITSTREAM; } gf_bs_read_u8(read->bs); read->length = swf_get_32(read); if (sig[0] == 'C') { swf_init_decompress(read); if (!read->bs) return GF_NON_COMPLIANT_BITSTREAM; } swf_get_rec(read, &rc); read->width = rc.w; read->height = rc.h; swf_align(read); read->frame_rate = swf_get_16(read)>>8; read->frame_count = swf_get_16(read); GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""SWF Import - Scene Size %gx%g - %d frames @ %d FPS\n"", read->width, read->height, read->frame_count, read->frame_rate)); return GF_OK; }"
"int zfp_prec_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) { BLOSC_UNUSED_PARAM(chunk); ZFP_ERROR_NULL(input); ZFP_ERROR_NULL(output); ZFP_ERROR_NULL(cparams); int8_t ndim; int64_t *shape = malloc(8 * sizeof(int64_t)); int32_t *chunkshape = malloc(8 * sizeof(int32_t)); int32_t *blockshape = malloc(8 * sizeof(int32_t)); uint8_t *smeta; int32_t smeta_len; if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) { free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""b2nd layer not found!""); return BLOSC2_ERROR_FAILURE; } deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape); free(smeta); for(int i = 0; i < ndim; i++) { if (blockshape[i] < 4) { BLOSC_TRACE_ERROR(""ZFP does not support blocks smaller than cells (4x...x4""); return BLOSC2_ERROR_FAILURE; } } zfp_type type;      zfp_field *field;   zfp_stream *zfp;    zfp_stream *zfp_aux;    bitstream *stream;  bitstream *stream_aux;  size_t zfpsize;     uint prec; switch (ndim) { case 1: prec = meta + 5; break; case 2: prec = meta + 7; break; case 3: prec = meta + 9; break; case 4: prec = meta + 11; break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for ndims: %d"", ndim); return BLOSC2_ERROR_FAILURE; } if (prec > ZFP_MAX_PREC) { BLOSC_TRACE_ERROR(""Max precision for this codecs is %d"", ZFP_MAX_PREC); prec = ZFP_MAX_PREC; } int32_t typesize = cparams->typesize; switch (typesize) { case sizeof(float): type = zfp_type_float; break; case sizeof(double): type = zfp_type_double; break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for typesize: %d"", typesize); return BLOSC2_ERROR_FAILURE; } zfp = zfp_stream_open(NULL); zfp_stream_set_precision(zfp, prec); stream = stream_open(output, output_len); zfp_stream_set_bit_stream(zfp, stream); zfp_stream_rewind(zfp); switch (ndim) { case 1: field = zfp_field_1d((void *) input, type, blockshape[0]); break; case 2: field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]); break; case 3: field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]); break; case 4: field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]); break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for ndims: %d"", ndim); return BLOSC2_ERROR_FAILURE; } int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field); zfp_stream_close(zfp); stream_close(stream); uint8_t *aux_out = malloc(zfp_maxout); zfp_aux = zfp_stream_open(NULL); zfp_stream_set_precision(zfp_aux, prec); stream_aux = stream_open(aux_out, zfp_maxout); zfp_stream_set_bit_stream(zfp_aux, stream_aux); zfp_stream_rewind(zfp_aux); zfpsize = zfp_compress(zfp_aux, field); zfp_field_free(field); zfp_stream_close(zfp_aux); stream_close(stream_aux); free(shape); free(chunkshape); free(blockshape); if (zfpsize == 0) { BLOSC_TRACE_ERROR(""\n ZFP: Compression failed\n""); free(aux_out); return (int) zfpsize; } if ((int32_t) zfpsize >= input_len) { BLOSC_TRACE_ERROR(""\n ZFP: Compressed data is bigger than input! \n""); free(aux_out); return 0; } memcpy(output, aux_out, zfpsize); free(aux_out); return (int) zfpsize; }"
static unsigned int rpcrdma_max_call_header_size(unsigned int maxsegs) { unsigned int size; size = RPCRDMA_HDRLEN_MIN; size = maxsegs * rpcrdma_readchunk_maxsz * sizeof(__be32); size += sizeof(__be32); size += rpcrdma_segment_maxsz * sizeof(__be32); size += sizeof(__be32); return size; }
"int XmpTextValue::read(const std::string& buf) { std::string b = buf; std::string type; if (buf.length() > 5 && buf.substr(0, 5) == ""type="") { std::string::size_type pos = buf.find_first_of(' '); type = buf.substr(5, pos-5); if (type[0] == '""') type = type.substr(1); if (type[type.length()-1] == '""') type = type.substr(0, type.length()-1); b.clear(); if (pos != std::string::npos) b = buf.substr(pos+1); } if (!type.empty()) { if (type == ""Alt"") { setXmpArrayType(XmpValue::xaAlt); } else if (type == ""Bag"") { setXmpArrayType(XmpValue::xaBag); } else if (type == ""Seq"") { setXmpArrayType(XmpValue::xaSeq); } else if (type == ""Struct"") { setXmpStruct(); } else { throw Error(kerInvalidXmpText, type); } } value_ = b; return 0; }"
"int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max) { uint request = HID_REQ_GET_REPORT;     uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN;     uint value = 0x300; uint size = RAZER_USB_REPORT_LEN;     int len; int retval; int result = 0; char *buf; buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL); if (buf == NULL) return -ENOMEM; retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max); len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0), request,                                   request_type,                              value,                                     response_index,                            buf,                                       size, USB_CTRL_SET_TIMEOUT); memcpy(response_report, buf, sizeof(struct razer_report)); kfree(buf); if(len != 90) { printk(KERN_WARNING ""razer driver: Invalid USB response. USB Report length: %d\n"", len); result = 1; } return result; }"
"static int svm_migrate_vram_to_vram(struct svm_range *prange, uint32_t best_loc, struct mm_struct *mm, uint32_t trigger) { int r, retries = 3; pr_debug(""from gpu 0x%x to gpu 0x%x\n"", prange->actual_loc, best_loc); do { r = svm_migrate_vram_to_ram(prange, mm, trigger); if (r) return r; } while (prange->actual_loc && --retries); if (prange->actual_loc) return -EDEADLK; return svm_migrate_ram_to_vram(prange, best_loc, mm, trigger); }"
void shutdown_mib(void) { unload_all_mibs(); if (tree_top) { if (tree_top->label) SNMP_FREE(tree_top->label); SNMP_FREE(tree_top); } tree_head = NULL; Mib = NULL; if (_mibindexes) { int i; for (i = 0; i < _mibindex; ++i) SNMP_FREE(_mibindexes[i]); free(_mibindexes); _mibindex = 0; _mibindex_max = 0; _mibindexes = NULL; } if (Prefix != NULL && Prefix != &Standard_Prefix[0]) SNMP_FREE(Prefix); if (Prefix) Prefix = NULL; SNMP_FREE(confmibs); SNMP_FREE(confmibdir); }
"static int ambiguity_error(Clp_Parser *clp, int ambiguous, int *ambiguous_values, const Clp_Option *opt, const Clp_InternOption *iopt, const char *prefix, const char *fmt, ...) { Clp_Internal *cli = clp->internal; Clp_BuildString bs; int i; va_list val; va_start(val, fmt); build_string_init(&bs, clp); Clp_vbsprintf(clp, &bs, fmt, val); append_build_string(&bs, ""\n"", 1); build_string_program_prefix(&bs, clp); append_build_string(&bs, ""(Possibilities are"", -1); for (i = 0; i < ambiguous && i < MAX_AMBIGUOUS_VALUES; i++) { int value = ambiguous_values[i]; const char *no_dash = """"; if (value < 0) value = -(value + 1), no_dash = ""no-""; if (i == 0) append_build_string(&bs, "" "", 1); else if (i == ambiguous - 1) append_build_string(&bs, (i == 1 ? "" and "" : "", and ""), -1); else append_build_string(&bs, "", "", 2); append_build_string(&bs, (cli->utf8 ? ""\342\200\230"" : ""'""), -1); append_build_string(&bs, prefix, -1); append_build_string(&bs, no_dash, -1); append_build_string(&bs, opt[value].long_name + iopt[value].ilongoff, -1); append_build_string(&bs, (cli->utf8 ? ""\342\200\231"" : ""'""), -1); } if (ambiguous > MAX_AMBIGUOUS_VALUES) append_build_string(&bs, "", and others"", -1); append_build_string(&bs, "".)\n"", -1); va_end(val); do_error(clp, &bs); build_string_cleanup(&bs); return 0; }"
"ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr, void *buffer, size_t len) { mgs_handle_t *ctxt = ptr; apr_size_t in = len; apr_read_type_e block = ctxt->input_block; ctxt->input_rc = APR_SUCCESS; if (!len || buffer == NULL) { return 0; } if (!ctxt->input_bb) { ctxt->input_rc = APR_EOF; gnutls_transport_set_errno(ctxt->session, ECONNABORTED); return -1; } if (APR_BRIGADE_EMPTY(ctxt->input_bb)) { apr_status_t rc = ap_get_brigade(ctxt->input_filter->next, ctxt->input_bb, AP_MODE_READBYTES, ctxt->input_block, in); if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc) || (rc == APR_SUCCESS && APR_BRIGADE_EMPTY(ctxt->input_bb))) { ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR); gnutls_transport_set_errno(ctxt->session, EAI_APR_TO_RAW(ctxt->input_rc)); return -1; } if (ctxt->input_block == APR_BLOCK_READ && APR_STATUS_IS_TIMEUP(rc) && APR_BRIGADE_EMPTY(ctxt->input_bb)) { ctxt->input_rc = rc; gnutls_transport_set_errno(ctxt->session, EAGAIN); return -1; } if (rc != APR_SUCCESS) { ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c, ""%s: Unexpected error!"", __func__); apr_brigade_cleanup(ctxt->input_bb); ctxt->input_bb = NULL; gnutls_transport_set_errno(ctxt->session, EIO); return -1; } } ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len); if (ctxt->input_rc == APR_SUCCESS) { return (ssize_t) len; } if (APR_STATUS_IS_EAGAIN(ctxt->input_rc) || APR_STATUS_IS_EINTR(ctxt->input_rc)) { if (len == 0) { gnutls_transport_set_errno(ctxt->session, EAI_APR_TO_RAW(ctxt->input_rc)); return -1; } return (ssize_t) len; } apr_brigade_cleanup(ctxt->input_bb); ctxt->input_bb = NULL; if (APR_STATUS_IS_EOF(ctxt->input_rc) && len) { return (ssize_t) len; } gnutls_transport_set_errno(ctxt->session, EIO); return -1; }"
"static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len) { const pj_uint8_t *p = start; int name_len, name_part_len; pj_status_t status; status = get_name_len(0, pkt, start, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4); q->name.slen = 0; status = get_name(0, pkt, start, max, &q->name); if (status != PJ_SUCCESS) return status; p = (start + name_part_len); pj_memcpy(&q->type, p, 2); q->type = pj_ntohs(q->type); p += 2; pj_memcpy(&q->dnsclass, p, 2); q->dnsclass = pj_ntohs(q->dnsclass); p += 2; *parsed_len = (int)(p - start); return PJ_SUCCESS; }"
"void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints) { lEnvPoints.clear(); CEnvPoint *pPoints = 0x0; { int Start, Num; pLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num); if(!Num) return; pPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0); } int Start, Num; pLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num); if(!Num) return; for(int env = 0; env < Num; env++) { CMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0); if(pItem->m_Version >= 3) { for(int i = 0; i < pItem->m_NumPoints; i++) lEnvPoints.add(pPoints[i + pItem->m_StartPoint]); } else { for(int i = 0; i < pItem->m_NumPoints; i++) { CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint]; CEnvPoint p; p.m_Time = pEnvPoint_v1->m_Time; p.m_Curvetype = pEnvPoint_v1->m_Curvetype; for(int c = 0; c < pItem->m_Channels; c++) { p.m_aValues[c] = pEnvPoint_v1->m_aValues[c]; p.m_aInTangentdx[c] = 0; p.m_aInTangentdy[c] = 0; p.m_aOutTangentdx[c] = 0; p.m_aOutTangentdy[c] = 0; } lEnvPoints.add(p); } } } }"
"IdKeyPair UserTerminalRouter::acceptNewConnection() { LOG(INFO) << ""Listening to id/key FIFO""; int terminalFd = socketHandler->accept(serverFd); if (terminalFd < 0) { if (GetErrno() != EAGAIN && GetErrno() != EWOULDBLOCK) { FATAL_FAIL(-1);      } else { return IdKeyPair({"""", """"});      } } LOG(INFO) << ""Connected""; try { Packet packet; if (!socketHandler->readPacket(terminalFd, &packet)) { STFATAL << ""Missing user info packet""; } if (packet.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) { STFATAL << ""Got an invalid packet header: "" << int(packet.getHeader()); } TerminalUserInfo tui = stringToProto<TerminalUserInfo>(packet.getPayload()); tui.set_fd(terminalFd); idInfoMap[tui.id()] = tui; return IdKeyPair({tui.id(), tui.passkey()}); } catch (const std::runtime_error &re) { STFATAL << ""Router can't talk to terminal: "" << re.what(); } STFATAL << ""Should never get here""; return IdKeyPair({"""", """"}); }"
"void f_fullcommand(typval_T *argvars, typval_T *rettv) { exarg_Tea; char_u*name; char_u*p; intvim9script = in_vim9script(); intsave_cmod_flags = cmdmod.cmod_flags; rettv->v_type = VAR_STRING; rettv->vval.v_string = NULL; if (in_vim9script() && (check_for_string_arg(argvars, 0) == FAIL || check_for_opt_bool_arg(argvars, 1) == FAIL)) return; name = argvars[0].vval.v_string; if (name == NULL) return; if (argvars[1].v_type != VAR_UNKNOWN) { vim9script = tv_get_bool(&argvars[1]); cmdmod.cmod_flags &= ~(CMOD_VIM9CMD | CMOD_LEGACY); cmdmod.cmod_flags |= vim9script ? CMOD_VIM9CMD : CMOD_LEGACY; } while (*name == ':') name++; name = skip_range(name, TRUE, NULL); ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name; ea.cmdidx = (cmdidx_T)0; ea.addr_count = 0; ++emsg_silent;      p = find_ex_command(&ea, NULL, NULL, NULL); --emsg_silent; if (p == NULL || ea.cmdidx == CMD_SIZE) goto theend; if (vim9script) { int     res; ++emsg_silent; res = not_in_vim9(&ea); --emsg_silent; if (res == FAIL) goto theend; } rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx) ? get_user_command_name(ea.useridx, ea.cmdidx) : cmdnames[ea.cmdidx].cmd_name); theend: cmdmod.cmod_flags = save_cmod_flags; }"
"static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl) { uint32_t delta_poc_st, strp_entry_sign_flag = 0; rpl->ref_pic_num = get_ue_golomb_long(gb); if (rpl->ref_pic_num > 0) { delta_poc_st = get_ue_golomb_long(gb); rpl->ref_pics[0] = delta_poc_st; if (rpl->ref_pics[0] != 0) { strp_entry_sign_flag = get_bits(gb, 1); rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1); } } for (int i = 1; i < rpl->ref_pic_num; ++i) { delta_poc_st = get_ue_golomb_long(gb); if (delta_poc_st != 0) strp_entry_sign_flag = get_bits(gb, 1); rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1)); } return 0; }"
"void _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1) { SYMENT *ext = (SYMENT *) ext1; struct internal_syment *in = (struct internal_syment *) in1; if (ext->e.e_name[0] == 0) { in->_n._n_n._n_zeroes = 0; in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset); } else memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN); in->n_value = H_GET_32 (abfd, ext->e_value); in->n_scnum = (short) H_GET_16 (abfd, ext->e_scnum); if (sizeof (ext->e_type) == 2) in->n_type = H_GET_16 (abfd, ext->e_type); else in->n_type = H_GET_32 (abfd, ext->e_type); in->n_sclass = H_GET_8 (abfd, ext->e_sclass); in->n_numaux = H_GET_8 (abfd, ext->e_numaux); #ifndef STRICT_PE_FORMAT if (in->n_sclass == C_SECTION) { char namebuf[SYMNMLEN + 1]; const char *name = NULL; in->n_value = 0x0; if (in->n_scnum == 0) { asection *sec; name = _bfd_coff_internal_syment_name (abfd, in, namebuf); if (name == NULL) { _bfd_error_handler (_(""%pB: unable to find name for empty section""), abfd); bfd_set_error (bfd_error_invalid_target); return; } sec = bfd_get_section_by_name (abfd, name); if (sec != NULL) in->n_scnum = sec->target_index; } if (in->n_scnum == 0) { int unused_section_number = 0; asection *sec; flagword flags; for (sec = abfd->sections; sec; sec = sec->next) if (unused_section_number <= sec->target_index) unused_section_number = sec->target_index + 1; if (name == namebuf) { name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1); if (name == NULL) { _bfd_error_handler (_(""%pB: out of memory creating name for empty section""), abfd); return; } strcpy ((char *) name, namebuf); } flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD; sec = bfd_make_section_anyway_with_flags (abfd, name, flags); if (sec == NULL) { _bfd_error_handler (_(""%pB: unable to create fake empty section""), abfd); return; } sec->vma = 0; sec->lma = 0; sec->size = 0; sec->filepos = 0; sec->rel_filepos = 0; sec->reloc_count = 0; sec->line_filepos = 0; sec->lineno_count = 0; sec->userdata = NULL; sec->next = NULL; sec->alignment_power = 2; sec->target_index = unused_section_number; in->n_scnum = unused_section_number; } in->n_sclass = C_STAT; } #endif #ifdef coff_swap_sym_in_hook coff_swap_sym_in_hook (abfd, ext1, in1); #endif }"
"bool lcPiecesLibrary::LoadTexture(lcTexture* Texture) { char FileName[2*LC_MAXPATH]; if (mZipFiles[static_cast<int>(lcZipFileType::Official)]) { lcMemFile TextureFile; sprintf(FileName, ""parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Unofficial)] || !mZipFiles[static_cast<int>(lcZipFileType::Unofficial)]->ExtractFile(FileName, TextureFile)) { sprintf(FileName, ""ldraw/parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Official)]->ExtractFile(FileName, TextureFile)) return false; } return Texture->Load(TextureFile); } else return Texture->Load(Texture->mFileName); }"
"PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2( pjmedia_rtp_session *ses, const void *pkt, int pkt_len, const pjmedia_rtp_hdr **hdr, pjmedia_rtp_dec_hdr *dec_hdr, const void **payload, unsigned *payloadlen) { int offset; PJ_UNUSED_ARG(ses); *hdr = (pjmedia_rtp_hdr*)pkt; if ((*hdr)->v != RTP_VERSION) { return PJMEDIA_RTP_EINVER; } offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t)); if ((*hdr)->x) { dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset); dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1); dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length); offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t)); } else { dec_hdr->ext_hdr = NULL; dec_hdr->ext = NULL; dec_hdr->ext_len = 0; } if (offset > pkt_len) return PJMEDIA_RTP_EINLEN; *payload = ((pj_uint8_t*)pkt) + offset; *payloadlen = pkt_len - offset; if ((*hdr)->p && *payloadlen > 0) { pj_uint8_t pad_len; pad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1]; if (pad_len <= *payloadlen) *payloadlen -= pad_len; } return PJ_SUCCESS; }"
"int parse_mpls(const u_char *pktdata, uint32_t datalen, uint16_t *next_protocol, uint32_t *l2len, uint32_t *l2offset) { struct tcpr_mpls_label *mpls_label; const u_char *end_ptr = pktdata + datalen; u_char first_nibble; eth_hdr_t *eth_hdr; bool bos = false; uint32_t label; int len; assert(next_protocol); assert(l2len); assert(l2offset); len = (int)*l2len; while (!bos) { if (pktdata + len + sizeof(*mpls_label) > end_ptr) return -1; mpls_label = (struct tcpr_mpls_label *)(pktdata + len); len += sizeof(*mpls_label); bos = (ntohl(mpls_label->entry) & MPLS_LS_S_MASK) != 0; label = ntohl(mpls_label->entry) >> MPLS_LS_LABEL_SHIFT; if (label == MPLS_LABEL_GACH) { warn(""GACH MPLS label not supported at this time""); return -1; } } if ((u_char *)mpls_label + 1 > end_ptr) return -1; first_nibble = *((u_char *)(mpls_label + 1)) >> 4; switch (first_nibble) { case 4: *next_protocol = ETHERTYPE_IP; break; case 6: *next_protocol = ETHERTYPE_IP6; break; case 0: if (pktdata + len + 4 + sizeof(*eth_hdr) > end_ptr) return -1; len += 4; *l2offset = len; eth_hdr = (eth_hdr_t *)(pktdata + len); len += sizeof(*eth_hdr); *next_protocol = ntohs(eth_hdr->ether_type); break; default: return -1; } *l2len = (uint32_t)len; return 0; }"
"GF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs) { u32 i; u32 sampleCount; GF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s; ISOM_DECREASE_SIZE(ptr, 4); ptr->nb_entries = gf_bs_read_u32(bs); if (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid number of entries %d in ctts\n"", ptr->nb_entries)); return GF_ISOM_INVALID_FILE; } ptr->alloc_size = ptr->nb_entries; ptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size); if (!ptr->entries) return GF_OUT_OF_MEM; sampleCount = 0; for (i=0; i<ptr->nb_entries; i++) { ISOM_DECREASE_SIZE(ptr, 8); ptr->entries[i].sampleCount = gf_bs_read_u32(bs); if (ptr->version) ptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32); else ptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs); if (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) { ptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset); } sampleCount += ptr->entries[i].sampleCount; } #ifndef GPAC_DISABLE_ISOM_WRITE ptr->w_LastSampleNumber = sampleCount; #endif return GF_OK; }"
"static void cifs_compound_callback(struct mid_q_entry *mid) { struct TCP_Server_Info *server = mid->server; struct cifs_credits credits; credits.value = server->ops->get_credits(mid); credits.instance = server->reconnect_instance; add_credits(server, &credits, mid->optype); }"
"static int get_max_inline_xattr_value_size(struct inode *inode, struct ext4_iloc *iloc) { struct ext4_xattr_ibody_header *header; struct ext4_xattr_entry *entry; struct ext4_inode *raw_inode; int free, min_offs; if (!EXT4_INODE_HAS_XATTR_SPACE(inode)) return 0; min_offs = EXT4_SB(inode->i_sb)->s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - EXT4_I(inode)->i_extra_isize - sizeof(struct ext4_xattr_ibody_header); if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR)) return EXT4_XATTR_SIZE(min_offs - EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) - EXT4_XATTR_ROUND - sizeof(__u32)); raw_inode = ext4_raw_inode(iloc); header = IHDR(inode, raw_inode); entry = IFIRST(header); for (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) { if (!entry->e_value_inum && entry->e_value_size) { size_t offs = le16_to_cpu(entry->e_value_offs); if (offs < min_offs) min_offs = offs; } } free = min_offs - ((void *)entry - (void *)IFIRST(header)) - sizeof(__u32); if (EXT4_I(inode)->i_inline_off) { entry = (struct ext4_xattr_entry *) ((void *)raw_inode + EXT4_I(inode)->i_inline_off); free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)); goto out; } free -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)); if (free > EXT4_XATTR_ROUND) free = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND); else free = 0; out: return free; }"
"int main(int argc, char** argv) { WinsockContext context; string tmpDir = GetTempDirectory(); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); LogHandler::setupStdoutLogger(); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); cxxopts::Options options(""et"", ""Remote shell for the busy and impatient""); try { options.allow_unrecognised_options(); options.positional_help(""""); options.custom_help( ""[OPTION...] [user@]host[:port]\n\n"" ""  Note that 'host' can be a hostname or ipv4 address with or without "" ""a port\n  or an ipv6 address. If the ipv6 address is abbreviated with "" "":: then it must\n  be specfied without a port (use -p,--port).""); options.add_options()                     (""h,help"", ""Print help"")              (""version"", ""Print version"")          (""u,username"", ""Username"")            (""host"", ""Remote host name"", cxxopts::value<std::string>())          (""p,port"", ""Remote machine etserver port"", cxxopts::value<int>()->default_value(""2022""))          (""c,command"", ""Run command on connect"", cxxopts::value<std::string>())          (""terminal-path"", ""Path to etterminal on server side. "" ""Use if etterminal is not on the system path."", cxxopts::value<std::string>())          (""t,tunnel"", ""Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. "" ""10080:80,10443:443, 10090-10092:8000-8002)"", cxxopts::value<std::string>())          (""r,reversetunnel"", ""Reverse Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges"", cxxopts::value<std::string>())          (""jumphost"", ""jumphost between localhost and destination"", cxxopts::value<std::string>())          (""jport"", ""Jumphost machine port"", cxxopts::value<int>()->default_value(""2022""))          (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")          (""macserver"", ""Set when connecting to an macOS server.  Sets "" ""--terminal-path=/usr/local/bin/etterminal"")          (""v,verbose"", ""Enable verbose logging"", cxxopts::value<int>()->default_value(""0""))          (""k,keepalive"", ""Client keepalive duration in seconds"", cxxopts::value<int>())                                      (""logtostdout"", ""Write log to stdout"")                       (""silent"", ""Disable logging"")                                (""N,no-terminal"", ""Do not create a terminal"")                (""f,forward-ssh-agent"", ""Forward ssh-agent socket"")          (""ssh-socket"", ""The ssh-agent socket to forward"", cxxopts::value<std::string>())          (""telemetry"", ""Allow et to anonymously send errors to guide future improvements"", cxxopts::value<bool>()->default_value(""true""))          (""serverfifo"", ""If set, communicate to etserver on the matching fifo name"", cxxopts::value<std::string>()->default_value(""""))          (""ssh-option"", ""Options to pass down to `ssh -o`"", cxxopts::value<std::vector<std::string>>()); options.parse_positional({""host""}); auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } if (result.count(""version"")) { CLOG(INFO, ""stdout"") << ""et version "" << ET_VERSION << endl; exit(0); } el::Loggers::setVerboseLevel(result[""verbose""].as<int>()); if (result.count(""logtostdout"")) { defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""true""); } else { defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); LogHandler::stderrToFile((tmpDir + ""/etclient"")); } if (result.count(""silent"")) { defaultConf.setGlobally(el::ConfigurationType::Enabled, ""false""); } LogHandler::setupLogFile( &defaultConf, (tmpDir + ""/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log"")); el::Loggers::reconfigureLogger(""default"", defaultConf); el::Helpers::setThreadName(""client-main""); el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler); GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); TelemetryService::create(result[""telemetry""].as<bool>(), tmpDir + ""/.sentry-native-et"", ""Client""); string username = """"; if (result.count(""username"")) { username = result[""username""].as<string>(); } int destinationPort = result[""port""].as<int>(); string destinationHost; if (!result.count(""host"")) { CLOG(INFO, ""stdout"") << ""Missing host to connect to"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } string host_arg = result[""host""].as<std::string>(); if (host_arg.find('@') != string::npos) { int i = host_arg.find('@'); username = host_arg.substr(0, i); host_arg = host_arg.substr(i + 1); } if (host_arg.find(':') != string::npos) { int colon_count = std::count(host_arg.begin(), host_arg.end(), ':'); if (colon_count == 1) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { if (host_arg.find(""::"") != string::npos) { } else { if (colon_count == 7) { } else if (colon_count == 8) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { CLOG(INFO, ""stdout"") << ""Invalid host positional arg: "" << result[""host""].as<std::string>() << endl; exit(1); } } } } destinationHost = host_arg; string host_alias = destinationHost; string jumphost = result.count(""jumphost"") ? result[""jumphost""].as<string>() : """"; int keepaliveDuration = result.count(""keepalive"") ? result[""keepalive""].as<int>() : MAX_CLIENT_KEEP_ALIVE_DURATION; if (keepaliveDuration < 1 || keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) { CLOG(INFO, ""stdout"") << ""Keep-alive duration must between 1 and "" << MAX_CLIENT_KEEP_ALIVE_DURATION << "" seconds"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } Options sshConfigOptions = { NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          0,             0,             0,             0,             0,             NULL,          NULL,          0,             0,             NULL       }; char* home_dir = ssh_get_user_home_dir(); const char* host_from_command = destinationHost.c_str(); ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST, destinationHost.c_str()); parse_ssh_config_file(host_from_command, &sshConfigOptions, string(home_dir) + USER_SSH_CONFIG_PATH); parse_ssh_config_file(host_from_command, &sshConfigOptions, SYSTEM_SSH_CONFIG_PATH); LOG(INFO) << ""Parsed ssh config file, connecting to "" << sshConfigOptions.host; destinationHost = string(sshConfigOptions.host); if (username.empty()) { if (sshConfigOptions.username) { username = string(sshConfigOptions.username); } else { username = string(ssh_get_local_username()); } } if (sshConfigOptions.ProxyJump && jumphost.length() == 0) { string proxyjump = string(sshConfigOptions.ProxyJump); size_t colonIndex = proxyjump.find("":""); if (colonIndex != string::npos) { string userhostpair = proxyjump.substr(0, colonIndex); size_t atIndex = userhostpair.find(""@""); if (atIndex != string::npos) { jumphost = userhostpair.substr(atIndex + 1); } } else { jumphost = proxyjump; } LOG(INFO) << ""ProxyJump found for dst in ssh config: "" << proxyjump; } bool is_jumphost = false; SocketEndpoint socketEndpoint; if (!jumphost.empty()) { is_jumphost = true; LOG(INFO) << ""Setting port to jumphost port""; socketEndpoint.set_name(jumphost); socketEndpoint.set_port(result[""jport""].as<int>()); } else { socketEndpoint.set_name(destinationHost); socketEndpoint.set_port(destinationPort); } shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler()); shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler()); if (!ping(socketEndpoint, clientSocket)) { CLOG(INFO, ""stdout"") << ""Could not reach the ET server: "" << socketEndpoint.name() << "":"" << socketEndpoint.port() << endl; exit(1); } int jport = result[""jport""].as<int>(); string serverFifo = """"; if (result[""serverfifo""].as<string>() != """") { serverFifo = result[""serverfifo""].as<string>(); } std::vector<string> ssh_options; if (result.count(""ssh-option"")) { ssh_options = result[""ssh-option""].as<std::vector<string>>(); } string etterminal_path = """"; if (result.count(""macserver"") > 0) { etterminal_path = ""/usr/local/bin/etterminal""; } if (result.count(""etterminal_path"")) { etterminal_path = result[""terminal-path""].as<string>(); } string idpasskeypair = SshSetupHandler::SetupSsh( username, destinationHost, host_alias, destinationPort, jumphost, jport, result.count(""x"") > 0, result[""verbose""].as<int>(), etterminal_path, serverFifo, ssh_options); string id = """", passkey = """"; idpasskeypair.erase(idpasskeypair.find_last_not_of("" \n\r\t"") + 1); size_t slashIndex = idpasskeypair.find(""/""); if (slashIndex == string::npos) { STFATAL << ""Invalid idPasskey id/key pair: "" << idpasskeypair; } else { id = idpasskeypair.substr(0, slashIndex); passkey = idpasskeypair.substr(slashIndex + 1); } if (passkey.length() != 32) { STFATAL << ""Invalid/missing passkey: "" << passkey << "" "" << passkey.length(); } shared_ptr<Console> console; if (!result.count(""N"")) { console.reset(new PsuedoTerminalConsole()); } bool forwardAgent = result.count(""f"") > 0; string sshSocket = """"; #ifndef WIN32 if (sshConfigOptions.identity_agent) { sshSocket = string(sshConfigOptions.identity_agent); } forwardAgent |= sshConfigOptions.forward_agent; #endif if (result.count(""ssh-socket"")) { sshSocket = result[""ssh-socket""].as<string>(); } TelemetryService::get()->logToDatadog(""Session Started"", el::Level::Info, __FILE__, __LINE__); string tunnel_arg = result.count(""tunnel"") ? result[""tunnel""].as<string>() : """"; string r_tunnel_arg = result.count(""reversetunnel"") ? result[""reversetunnel""].as<string>() : """"; TerminalClient terminalClient(clientSocket, clientPipeSocket, socketEndpoint, id, passkey, console, is_jumphost, tunnel_arg, r_tunnel_arg, forwardAgent, sshSocket, keepaliveDuration); terminalClient.run(result.count(""command"") ? result[""command""].as<string>() : """"); } catch (TunnelParseException& tpe) { handleParseException(tpe, options); } catch (cxxopts::OptionException& oe) { handleParseException(oe, options); } #ifdef WIN32 WSACleanup(); #endif TelemetryService::get()->shutdown(); TelemetryService::destroy(); el::Helpers::uninstallPreRollOutCallback(); return 0; }"
"int FileIo::Impl::switchMode(OpMode opMode) { assert(fp_ != 0); if (opMode_ == opMode) return 0; OpMode oldOpMode = opMode_; opMode_ = opMode; bool reopen = true; switch(opMode) { case opRead: if (openMode_[0] == 'r' || openMode_[1] == '+') reopen = false; break; case opWrite: if (openMode_[0] != 'r' || openMode_[1] == '+') reopen = false; break; case opSeek: reopen = false; break; } if (!reopen) { if (oldOpMode == opSeek) return 0; std::fseek(fp_, 0, SEEK_CUR); return 0; } long offset = std::ftell(fp_); if (offset == -1) return -1; if (fp_ != 0) { std::fclose(fp_); fp_= 0; } openMode_ = ""r+b""; opMode_ = opSeek; #ifdef EXV_UNICODE_PATH if (wpMode_ == wpUnicode) { fp_ = ::_wfopen(wpath_.c_str(), s2ws(openMode_).c_str()); } else #endif { fp_ = std::fopen(path_.c_str(), openMode_.c_str()); } if (!fp_) return 1; return std::fseek(fp_, offset, SEEK_SET); }"
"void Application::handleEditLocally(const QUrl &url) const { auto pathSplit = url.path().split('/', Qt::SkipEmptyParts); if (pathSplit.size() < 2) { qCWarning(lcApplication) << ""Invalid URL for file local editing: "" + pathSplit.join('/'); return; } const auto accountDisplayName = pathSplit.takeFirst(); const auto fileRemotePath = pathSplit.join('/'); FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath); }"
"unsigned long X509_issuer_and_serial_hash(X509 *a) { unsigned long ret = 0; EVP_MD_CTX *ctx = EVP_MD_CTX_new(); unsigned char md[16]; char *f; if (ctx == NULL) goto err; f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0); if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL)) goto err; if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f))) goto err; OPENSSL_free(f); if (!EVP_DigestUpdate (ctx, (unsigned char *)a->cert_info.serialNumber.data, (unsigned long)a->cert_info.serialNumber.length)) goto err; if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL)) goto err; ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) | ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L) ) & 0xffffffffL; err: EVP_MD_CTX_free(ctx); return ret; }"
"static pj_status_t  codec_open( pjmedia_codec *codec, pjmedia_codec_param *attr ) { struct opus_data *opus_data = (struct opus_data *)codec->codec_data; int idx, err; pj_bool_t auto_bit_rate = PJ_TRUE; PJ_ASSERT_RETURN(codec && attr && opus_data, PJ_EINVAL); pj_mutex_lock (opus_data->mutex); TRACE_((THIS_FILE, ""%s:%d: - TRACE"", __FUNCTION__, __LINE__)); opus_data->cfg.sample_rate = attr->info.clock_rate; opus_data->cfg.channel_cnt = attr->info.channel_cnt; opus_data->enc_ptime = opus_data->dec_ptime = attr->info.frm_ptime; if (!opus_data->enc) { opus_data->enc = pj_pool_zalloc(opus_data->pool, opus_encoder_get_size(2)); } if (!opus_data->dec) { opus_data->dec = pj_pool_zalloc(opus_data->pool, opus_decoder_get_size(2)); } if (!opus_data->enc_packer) { opus_data->enc_packer = pj_pool_zalloc(opus_data->pool, opus_repacketizer_get_size()); } if (!opus_data->dec_packer) { opus_data->dec_packer = pj_pool_zalloc(opus_data->pool, opus_repacketizer_get_size()); } if (!opus_data->enc || !opus_data->dec || !opus_data->enc_packer || !opus_data->dec_packer) { PJ_LOG(2, (THIS_FILE, ""Unable to allocate memory for the codec"")); pj_mutex_unlock (opus_data->mutex); return PJ_ENOMEM; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE); if (idx >= 0) { unsigned rate; auto_bit_rate = PJ_FALSE; rate = (unsigned)pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); if (rate < attr->info.avg_bps) attr->info.avg_bps = rate; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_INBAND_FEC, PJ_FALSE); if (idx >= 0) { unsigned plc; plc = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); attr->setting.plc = plc > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_DTX, PJ_FALSE); if (idx >= 0) { unsigned vad; vad = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); attr->setting.vad = vad > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_CBR, PJ_FALSE); if (idx >= 0) { unsigned cbr; cbr = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); opus_data->cfg.cbr = cbr > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE); if (idx >= 0) { unsigned rate; rate = (unsigned) pj_strtoul(&attr->setting.dec_fmtp.param[idx].val); if (rate < attr->info.avg_bps) attr->info.avg_bps = rate; } TRACE_((THIS_FILE, ""%s:%d: sample_rate: %u"", __FUNCTION__, __LINE__, opus_data->cfg.sample_rate)); err = opus_encoder_init(opus_data->enc, opus_data->cfg.sample_rate, attr->info.channel_cnt, OPUS_APPLICATION_VOIP); if (err != OPUS_OK) { PJ_LOG(2, (THIS_FILE, ""Unable to create encoder"")); return PJMEDIA_CODEC_EFAILED; } opus_encoder_ctl(opus_data->enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_VOICE)); opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(auto_bit_rate? OPUS_AUTO: attr->info.avg_bps)); opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0)); opus_encoder_ctl(opus_data->enc, OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0)); opus_encoder_ctl(opus_data->enc, OPUS_SET_MAX_BANDWIDTH(get_opus_bw_constant( opus_data->cfg.sample_rate))); opus_encoder_ctl(opus_data->enc, OPUS_SET_PACKET_LOSS_PERC(opus_data->cfg.packet_loss)); opus_encoder_ctl(opus_data->enc, OPUS_SET_COMPLEXITY(opus_data->cfg.complexity)); opus_encoder_ctl(opus_data->enc, OPUS_SET_VBR(opus_data->cfg.cbr ? 0 : 1)); PJ_LOG(5, (THIS_FILE, ""Initialize Opus encoder, sample rate: %d, "" ""avg bitrate: %d, vad: %d, plc: %d, pkt loss: %d, "" ""complexity: %d, constant bit rate: %d"", opus_data->cfg.sample_rate, attr->info.avg_bps, attr->setting.vad?1:0, attr->setting.plc?1:0, opus_data->cfg.packet_loss, opus_data->cfg.complexity, opus_data->cfg.cbr?1:0)); err = opus_decoder_init (opus_data->dec, opus_data->cfg.sample_rate, attr->info.channel_cnt); if (err != OPUS_OK) { PJ_LOG(2, (THIS_FILE, ""Unable to initialize decoder"")); return PJMEDIA_CODEC_EFAILED; } opus_data->dec_frame[0].type = PJMEDIA_FRAME_TYPE_NONE; opus_data->dec_frame[0].buf  = pj_pool_zalloc(opus_data->pool,                                    (opus_data->cfg.sample_rate / 1000) * 60 * attr->info.channel_cnt * 2 ); opus_data->dec_frame[1].type = PJMEDIA_FRAME_TYPE_NONE; opus_data->dec_frame[1].buf  = pj_pool_zalloc(opus_data->pool, (opus_data->cfg.sample_rate / 1000) * 60 * attr->info.channel_cnt * 2 ); opus_data->dec_frame_index = -1; opus_repacketizer_init(opus_data->enc_packer); opus_repacketizer_init(opus_data->dec_packer); pj_mutex_unlock (opus_data->mutex); return PJ_SUCCESS; }"
"Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const { std::string image_type = m_heif_file->get_item_type(id); if (image_type==""grid"" || image_type==""iden"" || image_type==""iovl"") { auto iref_box = m_heif_file->get_iref_box(); std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(""dimg"")); if (image_references.empty()) { return Error(heif_error_Invalid_input, heif_suberror_No_item_data, ""Derived image does not reference any other image items""); } else { return get_id_of_non_virtual_child_image(image_references[0], out); } } else { out = id; return Error::Ok; } }"
"Status AutoParallel::Initialize(const GrapplerItem& item) { num_gpus_ = GetNumAvailableGPUs(); LOG(INFO) << ""Number of GPUs: "" << num_gpus_; item_ = &item; graph_ = item.graph; LOG(INFO) << ""Original graph size: "" << graph_.node_size(); if (item.fetch.empty()) { return Status(error::INVALID_ARGUMENT, ""No fetch nodes provided.""); } if (item.MainVariables().empty()) { return Status(error::INVALID_ARGUMENT, ""No variables provided.""); } for (const auto& init : item.init_ops) { VLOG(1) << ""Init node: "" << init; } for (const auto& fetch : item.fetch) { VLOG(1) << ""Fetch node: "" << fetch; } for (const auto& var : item.MainVariables()) { VLOG(2) << ""Variable: "" << var->name(); } const std::set<string> apply_gradients_ops = {""ApplyGradientDescent"", ""ApplyProximalGradientDescent"", ""ApplyAdadelta"", ""ApplyAdagrad"", ""ApplyProximalAdagrad"", ""ApplyAdagradDA"", ""ApplyFtrl"", ""ApplyMomentum"", ""ApplyAdam"", ""ApplyRMSProp"", ""ApplyCenteredRMSProp""}; for (int i = 0; i < graph_.node_size(); i++) { all_nodes_.insert( std::make_pair(graph_.node(i).name(), graph_.mutable_node(i))); if (apply_gradients_ops.find(graph_.node(i).op()) != apply_gradients_ops.end()) { apply_gradients_nodes_.insert(graph_.node(i).name()); VLOG(2) << ""Apply gradients node: "" << graph_.node(i).name(); } } auto div_const_node = AddNodeDivConst(); all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node)); std::map<string, int> gradient_pos = {{""ApplyGradientDescent"", 2}, {""ApplyProximalGradientDescent"", 4}, {""ApplyAdadelta"", 6}, {""ApplyAdagrad"", 3}, {""ApplyProximalAdagrad"", 5}, {""ApplyAdagradDA"", 3}, {""ApplyFtrl"", 3}, {""ApplyMomentum"", 3}, {""ApplyAdam"", 9}, {""ApplyRMSProp"", 7}, {""ApplyCenteredRMSProp"", 8}}; for (const auto& apply_gradient_node_name : apply_gradients_nodes_) { auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op(); auto apply_gradients_node = all_nodes_[apply_gradient_node_name]; auto div_node = AddNodeDiv( apply_gradient_node_name, apply_gradients_node->input(gradient_pos[apply_gradients_op]), div_const_node->name()); all_nodes_.insert(std::make_pair(div_node->name(), div_node)); *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) = div_node->name(); } LOG(INFO) << ""Graph size after adding div nodes: "" << all_nodes_.size(); std::vector<const NodeDef*> train_nodes; TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes)); LOG(INFO) << ""Number of training nodes: "" << train_nodes.size(); const NodeDef* dequeue_node; for (const auto& train_node : train_nodes) { if (IsDequeueOp(*train_node)) { dequeue_node = train_node; break; } } std::vector<const NodeDef*> input_nodes; if (dequeue_node) { LOG(INFO) << ""Dequeue node: "" << dequeue_node->name(); TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()}, {}, &input_nodes)); } LOG(INFO) << ""Number of input nodes: "" << input_nodes.size(); std::set<string> dont_replicate_nodes; for (const auto& variable : item.MainVariables()) { dont_replicate_nodes.insert(variable->name()); } for (const auto& init : item.init_ops) { dont_replicate_nodes.insert(NodeName(init)); } for (const auto& input_node : input_nodes) { if (input_node->name() != dequeue_node->name()) { dont_replicate_nodes.insert(input_node->name()); } } for (const auto& node : train_nodes) { if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) { replica_nodes_.insert(node->name()); } } LOG(INFO) << ""Number of replica nodes: "" << replica_nodes_.size(); for (const auto& node : all_nodes_) { if (replica_nodes_.find(node.first) == replica_nodes_.end()) { shared_nodes_.insert(node.first); } } LOG(INFO) << ""Number of shared nodes: "" << shared_nodes_.size(); return Status::OK(); }"
"void janus_voicemail_destroy_session(janus_plugin_session *handle, int *error) { if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) { *error = -1; return; } janus_mutex_lock(&sessions_mutex); janus_voicemail_session *session = janus_voicemail_lookup_session(handle); if(!session) { janus_mutex_unlock(&sessions_mutex); JANUS_LOG(LOG_ERR, ""No VoiceMail session associated with this handle...\n""); *error = -2; return; } JANUS_LOG(LOG_VERB, ""Removing VoiceMail session...\n""); janus_voicemail_hangup_media_internal(handle); handle->plugin_handle = NULL; g_hash_table_remove(sessions, handle); janus_mutex_unlock(&sessions_mutex); return; }"
static unsigned int rpcrdma_max_reply_header_size(unsigned int maxsegs) { unsigned int size; size = RPCRDMA_HDRLEN_MIN; size = sizeof(__be32); size += maxsegs * rpcrdma_segment_maxsz * sizeof(__be32); size += sizeof(__be32); return size; }
"gboolean flatpak_context_load_metadata (FlatpakContext *context, GKeyFile       *metakey, GError        **error) { gboolean remove; g_auto(GStrv) groups = NULL; gsize i; if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL)) { g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL, error); if (shares == NULL) return FALSE; for (i = 0; shares[i] != NULL; i++) { FlatpakContextShares share; share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL); if (share == 0) g_info (""Unknown share type %s"", shares[i]); else { if (remove) flatpak_context_remove_shares (context, share); else flatpak_context_add_shares (context, share); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL)) { g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL, error); if (sockets == NULL) return FALSE; for (i = 0; sockets[i] != NULL; i++) { FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL); if (socket == 0) g_info (""Unknown socket type %s"", sockets[i]); else { if (remove) flatpak_context_remove_sockets (context, socket); else flatpak_context_add_sockets (context, socket); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL)) { g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL, error); if (devices == NULL) return FALSE; for (i = 0; devices[i] != NULL; i++) { FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL); if (device == 0) g_info (""Unknown device type %s"", devices[i]); else { if (remove) flatpak_context_remove_devices (context, device); else flatpak_context_add_devices (context, device); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL)) { g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL, error); if (features == NULL) return FALSE; for (i = 0; features[i] != NULL; i++) { FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL); if (feature == 0) g_info (""Unknown feature type %s"", features[i]); else { if (remove) flatpak_context_remove_features (context, feature); else flatpak_context_add_features (context, feature); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL)) { g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error); if (filesystems == NULL) return FALSE; for (i = 0; filesystems[i] != NULL; i++) { const char *fs = parse_negated (filesystems[i], &remove); g_autofree char *filesystem = NULL; FlatpakFilesystemMode mode; if (!flatpak_context_parse_filesystem (fs, remove, &filesystem, &mode, NULL)) g_info (""Unknown filesystem type %s"", filesystems[i]); else { g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove); flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL)) { g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL, error); if (persistent == NULL) return FALSE; for (i = 0; persistent[i] != NULL; i++) flatpak_context_set_persistent (context, persistent[i]); } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL); FlatpakPolicy policy; if (!flatpak_verify_dbus_name (key, error)) return FALSE; policy = flatpak_policy_from_string (value, NULL); if ((int) policy != -1) flatpak_context_set_session_bus_policy (context, key, policy); } } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL); FlatpakPolicy policy; if (!flatpak_verify_dbus_name (key, error)) return FALSE; policy = flatpak_policy_from_string (value, NULL); if ((int) policy != -1) flatpak_context_set_system_bus_policy (context, key, policy); } } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL); flatpak_context_set_env_var (context, key, value); } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL)) { g_auto(GStrv) vars = NULL; gsize vars_count; vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, &vars_count, error); if (vars == NULL) return FALSE; for (i = 0; i < vars_count; i++) { const char *var = vars[i]; flatpak_context_set_env_var (context, var, NULL); } } groups = g_key_file_get_groups (metakey, NULL); for (i = 0; groups[i] != NULL; i++) { const char *group = groups[i]; const char *subsystem; int j; if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY)) { g_auto(GStrv) keys = NULL; subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY); keys = g_key_file_get_keys (metakey, group, NULL, NULL); for (j = 0; keys != NULL && keys[j] != NULL; j++) { const char *key = keys[j]; g_autofree char *policy_key = g_strdup_printf (""%s.%s"", subsystem, key); g_auto(GStrv) values = NULL; int k; values = g_key_file_get_string_list (metakey, group, key, NULL, NULL); for (k = 0; values != NULL && values[k] != NULL; k++) flatpak_context_apply_generic_policy (context, policy_key, values[k]); } } } return TRUE; }"
"int sonmp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware, struct lldpd_chassis **newchassis, struct lldpd_port **newport) { const u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR; struct lldpd_chassis *chassis; struct lldpd_port *port; struct lldpd_mgmt *mgmt; int length, i; u_int8_t *pos; u_int8_t seg[3], rchassis; struct in_addr address; log_debug(""sonmp"", ""decode SONMP PDU from %s"", hardware->h_ifname); if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) { log_warn(""sonmp"", ""failed to allocate remote chassis""); return -1; } TAILQ_INIT(&chassis->c_mgmt); if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) { log_warn(""sonmp"", ""failed to allocate remote port""); free(chassis); return -1; } #ifdef ENABLE_DOT1 TAILQ_INIT(&port->p_vlans); #endif length = s; pos = (u_int8_t*)frame; if (length < SONMP_SIZE) { log_warnx(""sonmp"", ""too short SONMP frame received on %s"", hardware->h_ifname); goto malformed; } if (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0) goto malformed; PEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16; PEEK_DISCARD(6); if (PEEK_UINT16 != LLC_PID_SONMP_HELLO) { log_debug(""sonmp"", ""incorrect LLC protocol ID received for SONMP on %s"", hardware->h_ifname); goto malformed; } chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR; if ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) { log_warn(""sonmp"", ""unable to allocate memory for chassis id on %s"", hardware->h_ifname); goto malformed; } chassis->c_id_len = sizeof(struct in_addr) + 1; chassis->c_id[0] = 1; PEEK_BYTES(&address, sizeof(struct in_addr)); memcpy(chassis->c_id + 1, &address, sizeof(struct in_addr)); if (asprintf(&chassis->c_name, ""%s"", inet_ntoa(address)) == -1) { log_warnx(""sonmp"", ""unable to write chassis name for %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(seg, sizeof(seg)); rchassis = PEEK_UINT8; for (i=0; sonmp_chassis_types[i].type != 0; i++) { if (sonmp_chassis_types[i].type == rchassis) break; } if (asprintf(&chassis->c_descr, ""%s"", sonmp_chassis_types[i].description) == -1) { log_warnx(""sonmp"", ""unable to write chassis description for %s"", hardware->h_ifname); goto malformed; } mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0); if (mgmt == NULL) { if (errno == ENOMEM) log_warn(""sonmp"", ""unable to allocate memory for management address""); else log_warn(""sonmp"", ""too large management address received on %s"", hardware->h_ifname); goto malformed; } TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries); port->p_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold): LLDPD_TTL; port->p_ttl = (port->p_ttl + 999) / 1000; port->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL; if (asprintf(&port->p_id, ""%02x-%02x-%02x"", seg[0], seg[1], seg[2]) == -1) { log_warn(""sonmp"", ""unable to allocate memory for port id on %s"", hardware->h_ifname); goto malformed; } port->p_id_len = strlen(port->p_id); if ((seg[0] == 0) && (seg[1] == 0)) { if (asprintf(&port->p_descr, ""port %d"", seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } else if (seg[0] == 0) { if (asprintf(&port->p_descr, ""port %d/%d"", seg[1], seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } else { if (asprintf(&port->p_descr, ""port %x:%x:%x"", seg[0], seg[1], seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } *newchassis = chassis; *newport = port; return 1; malformed: lldpd_chassis_cleanup(chassis, 1); lldpd_port_cleanup(port, 1); free(port); return -1; }"
"void nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma) { struct nvkm_vma *next; nvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags); nvkm_memory_unref(&vma->memory); if (vma->part) { struct nvkm_vma *prev = node(vma, prev); if (!prev->memory) { prev->size += vma->size; rb_erase(&vma->tree, &vmm->root); list_del(&vma->head); kfree(vma); vma = prev; } } next = node(vma, next); if (next && next->part) { if (!next->memory) { vma->size += next->size; rb_erase(&next->tree, &vmm->root); list_del(&next->head); kfree(next); } } }"
"bool isXmpType(BasicIo& iIo, bool advance) { const int32_t len = 80; byte buf[len]; iIo.read(buf, xmlHdrCnt + 1); if (   iIo.eof() && 0 == strncmp(reinterpret_cast<const char*>(buf), xmlHeader, xmlHdrCnt)) { return true; } if (iIo.error() || iIo.eof()) { return false; } iIo.read(buf + xmlHdrCnt + 1, len - xmlHdrCnt - 1); if (iIo.error() || iIo.eof()) { return false; } int32_t start = 0; if (0 == strncmp(reinterpret_cast<const char*>(buf), ""\xef\xbb\xbf"", 3)) { start = 3; } bool rc = false; std::string head(reinterpret_cast<const char*>(buf + start), len - start); if (head.substr(0, 5)  == ""<?xml"") { for (unsigned i = 5; i < head.size(); ++i) { if (head[i] == '<') { head = head.substr(i); break; } } } if (   head.size() > 9 && (   head.substr(0, 9)  == ""<?xpacket"" || head.substr(0, 10) == ""<x:xmpmeta"")) { rc = true; } if (!advance || !rc) { iIo.seek(-(len - start), BasicIo::cur);         } return rc; }"
"static int vmxnet3_rq_alloc_rx_buf(struct vmxnet3_rx_queue *rq, u32 ring_idx, int num_to_alloc, struct vmxnet3_adapter *adapter) { int num_allocated = 0; struct vmxnet3_rx_buf_info *rbi_base = rq->buf_info[ring_idx]; struct vmxnet3_cmd_ring *ring = &rq->rx_ring[ring_idx]; u32 val; while (num_allocated <= num_to_alloc) { struct vmxnet3_rx_buf_info *rbi; union Vmxnet3_GenericDesc *gd; rbi = rbi_base + ring->next2fill; gd = ring->base + ring->next2fill; if (rbi->buf_type == VMXNET3_RX_BUF_SKB) { if (rbi->skb == NULL) { rbi->skb = __netdev_alloc_skb_ip_align(adapter->netdev, rbi->len, GFP_KERNEL); if (unlikely(rbi->skb == NULL)) { rq->stats.rx_buf_alloc_failure++; break; } rbi->dma_addr = dma_map_single( &adapter->pdev->dev, rbi->skb->data, rbi->len, DMA_FROM_DEVICE); if (dma_mapping_error(&adapter->pdev->dev, rbi->dma_addr)) { dev_kfree_skb_any(rbi->skb); rq->stats.rx_buf_alloc_failure++; break; } } else { } val = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT; } else { BUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE || rbi->len  != PAGE_SIZE); if (rbi->page == NULL) { rbi->page = alloc_page(GFP_ATOMIC); if (unlikely(rbi->page == NULL)) { rq->stats.rx_buf_alloc_failure++; break; } rbi->dma_addr = dma_map_page( &adapter->pdev->dev, rbi->page, 0, PAGE_SIZE, DMA_FROM_DEVICE); if (dma_mapping_error(&adapter->pdev->dev, rbi->dma_addr)) { put_page(rbi->page); rq->stats.rx_buf_alloc_failure++; break; } } else { } val = VMXNET3_RXD_BTYPE_BODY << VMXNET3_RXD_BTYPE_SHIFT; } gd->rxd.addr = cpu_to_le64(rbi->dma_addr); gd->dword[2] = cpu_to_le32((!ring->gen << VMXNET3_RXD_GEN_SHIFT) | val | rbi->len); if (num_allocated == num_to_alloc) break; gd->dword[2] |= cpu_to_le32(ring->gen << VMXNET3_RXD_GEN_SHIFT); num_allocated++; vmxnet3_cmd_ring_adv_next2fill(ring); } netdev_dbg(adapter->netdev, ""alloc_rx_buf: %d allocated, next2fill %u, next2comp %u\n"", num_allocated, ring->next2fill, ring->next2comp); BUG_ON(num_allocated != 0 && ring->next2fill == ring->next2comp); return num_allocated; }"
"Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; unsigned const h = gnu_hash(name); unsigned const hbit1 = 077& h; unsigned const hbit2 = 077& (h>>gnu_shift); upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf64_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, 0==(1u& get_te32(hp++))); } } } return 0; }"
static RzList *strings(RzBinFile *bf) { if (!bf) { return NULL; } LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf); if (!bin_info_obj) { return NULL; } return bin_info_obj->string_list; }
"static int load_pgen(SFData *sf, int size) { fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list; SFZone *z; SFGen *g; SFGenAmount genval; unsigned short genid; int level, skip, drop, gzone, discarded; p = sf->preset; while(p) { gzone = FALSE; discarded = FALSE; start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone; if(p2) { hz = &p2; } while(p2) { level = 0; z = (SFZone *)(p2->data); p3 = z->gen; while(p3) { dup = NULL; skip = FALSE; drop = FALSE; if((size -= SF_GEN_SIZE) < 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } READW(sf, genid); if(genid == Gen_KeyRange) { if(level == 0) { level = 1; READB(sf, genval.range.lo); READB(sf, genval.range.hi); } else { skip = TRUE; } } else if(genid == Gen_VelRange) { if(level <= 1) { level = 2; READB(sf, genval.range.lo); READB(sf, genval.range.hi); } else { skip = TRUE; } } else if(genid == Gen_Instrument) { level = 3; READW(sf, genval.uword); ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1); break;  } else { level = 2; if(valid_preset_genid(genid)) { READW(sf, genval.sword); dup = find_gen_by_id(genid, z->gen); } else { skip = TRUE; } } if(!skip) { if(!dup) { if((g = FLUID_NEW(SFGen)) == NULL) { FLUID_LOG(FLUID_ERR, ""Out of memory""); return FALSE; } p3->data = g; g->id = genid; } else { g = (SFGen *)(dup->data);  drop = TRUE; } g->amount = genval; } else { discarded = TRUE; drop = TRUE; FSKIPW(sf); } if(!drop) { p3 = fluid_list_next(p3);     } else { SLADVREM(z->gen, p3);     } }  if(level == 3) { SLADVREM(z->gen, p3);     } else { if(!gzone) { gzone = TRUE; if(*hz != p2) { void *save = p2->data; FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"", ((SFPreset *)(p->data))->name); SLADVREM(*hz, p2); *hz = fluid_list_prepend(*hz, save); continue; } } else { SFZone * pzone = fluid_list_get(p2); FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"", ((SFPreset *)(p->data))->name); *hz = fluid_list_remove(start_of_zone_list, pzone); delete_zone(pzone); } } while(p3) { discarded = TRUE; if((size -= SF_GEN_SIZE) < 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } FSKIP(sf, SF_GEN_SIZE); SLADVREM(z->gen, p3); } p2 = fluid_list_next(p2);  } if(discarded) { FLUID_LOG(FLUID_WARN, ""Preset '%s': Some invalid generators were discarded"", ((SFPreset *)(p->data))->name); } p = fluid_list_next(p); } if(size == 0) { return TRUE; } size -= SF_GEN_SIZE; if(size != 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } FSKIP(sf, SF_GEN_SIZE);  return TRUE; }"
"GF_EXPORT GF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs) { GF_TextSample *s = gf_isom_new_text_sample(); if (!bs || !gf_bs_available(bs)) return s; s->len = gf_bs_read_u16(bs); if (s->len) { s->text = (char *) gf_malloc(sizeof(char)*(s->len+2) ); if (!s->text) return NULL; s->text[s->len] = 0; s->text[s->len+1] = 0; gf_bs_read_data(bs, s->text, s->len); } while (gf_bs_available(bs)) { GF_Box *a; GF_Err e = gf_isom_box_parse(&a, bs); if (e) break; switch (a->type) { case GF_ISOM_BOX_TYPE_STYL: if (s->styles) { GF_TextStyleBox *st2 = (GF_TextStyleBox *)a; if (!s->styles->entry_count) { gf_isom_box_del((GF_Box*)s->styles); s->styles = st2; } else { s->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count)); memcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count); s->styles->entry_count += st2->entry_count; gf_isom_box_del(a); } } else { s->styles = (GF_TextStyleBox*)a; } break; case GF_ISOM_BOX_TYPE_KROK: s->cur_karaoke = (GF_TextKaraokeBox*)a; case GF_ISOM_BOX_TYPE_HLIT: case GF_ISOM_BOX_TYPE_HREF: case GF_ISOM_BOX_TYPE_BLNK: gf_list_add(s->others, a); break; case GF_ISOM_BOX_TYPE_HCLR: if (s->highlight_color) gf_isom_box_del(a); else s->highlight_color = (GF_TextHighlightColorBox *) a; break; case GF_ISOM_BOX_TYPE_DLAY: if (s->scroll_delay) gf_isom_box_del(a); else s->scroll_delay= (GF_TextScrollDelayBox*) a; break; case GF_ISOM_BOX_TYPE_TBOX: if (s->box) gf_isom_box_del(a); else s->box= (GF_TextBoxBox *) a; break; case GF_ISOM_BOX_TYPE_TWRP: if (s->wrap) gf_isom_box_del(a); else s->wrap= (GF_TextWrapBox*) a; break; case GF_QT_BOX_TYPE_FRCD: s->is_forced = GF_TRUE; gf_isom_box_del(a); break; default: gf_isom_box_del(a); break; } } return s; }"
"void operator()(OpKernelContext* context, const T1* input_data, int input_batches, int input_height, int input_width, int input_depth, int input_offset, const T2* filter_data, int filter_height, int filter_width, int filter_count, int filter_offset, int stride, Padding padding, T3* output_data, int output_height, int output_width, int output_shift, int output_offset, int output_mult) { if (input_offset < 0) { static int warning_count = 0; if (warning_count < 10) { ++warning_count; LOG(WARNING) << ""For kernel '"" << context->op_kernel().name() << ""' from input '"" << context->op_kernel().requested_input(0) << ""': Zero is not representable in the quantized range used by the"" << "" input. This means QuantizedConv2d has to fall back to a slow"" << "" implementation, since the border of zero values can't be"" << "" represented easily. You should try to construct graphs that"" << "" avoid this situation.""; } ReferenceConvFunctor<T1, T2, T3> conv_functor; conv_functor(context, input_data, input_batches, input_height, input_width, input_depth, input_offset, filter_data, filter_height, filter_width, filter_count, filter_offset, stride, padding, output_data, output_height, output_width, output_shift, output_offset, output_mult); return; } CHECK_GT(output_width, 0); CHECK_GT(output_height, 0); int filter_left_offset; int filter_top_offset; if (padding == VALID) { filter_left_offset = ((output_width - 1) * stride + filter_width - input_width + 1) / 2; filter_top_offset = ((output_height - 1) * stride + filter_height - input_height + 1) / 2; } else { filter_left_offset = ((output_width - 1) * stride + filter_width - input_width) / 2; filter_top_offset = ((output_height - 1) * stride + filter_height - input_height) / 2; } const int filter_value_count = filter_width * filter_height * input_depth; const int64 patches_per_chunk = kMaxChunkSize / (filter_value_count * sizeof(T1)); const int64 chunk_value_count = (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1); Im2ColBufferResource<T1, chunk_value_count>* im2col_buffer_resource; std::function<Status(Im2ColBufferResource<T1, chunk_value_count>**)> creator = [](Im2ColBufferResource<T1, chunk_value_count>** resource) { #ifdef _MSC_VER const int64 chunk_value_count = (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1); #endif *resource = new Im2ColBufferResource<T1, chunk_value_count>(); return Status::OK(); }; OP_REQUIRES_OK(context, context->resource_manager()->LookupOrCreate( ""Conv2d"", ""im2col_buffer"", &im2col_buffer_resource, creator)); mutex_lock lock_buffer(im2col_buffer_resource->mu); core::ScopedUnref unref_buffer(im2col_buffer_resource); T1* im2col_buffer = im2col_buffer_resource->data; const int64 patch_count = (input_batches * output_height * output_width); const int64 chunk_count = (patch_count + (patches_per_chunk - 1)) / patches_per_chunk; for (int64 chunk_index = 0; chunk_index < chunk_count; ++chunk_index) { const int64 patch_index_start = chunk_index * patches_per_chunk; const int64 patch_index_end = std::min(patch_index_start + patches_per_chunk, patch_count); for (int64 patch_index = patch_index_start; patch_index < patch_index_end; ++patch_index) { const int64 batch = patch_index / (output_height * output_width); const int64 out_y = (patch_index / output_width) % output_height; const int64 out_x = patch_index % output_width; const T1* input_batch_start = input_data + (batch * input_height * input_width * input_depth); const int in_y_origin = (out_y * stride) - filter_top_offset; const int in_x_origin = (out_x * stride) - filter_left_offset; const int patch_index_within_chunk = patch_index % patches_per_chunk; T1* im2col_patch_start = im2col_buffer + (patch_index_within_chunk * filter_value_count); for (int filter_y = 0; filter_y < filter_height; ++filter_y) { const int in_y = in_y_origin + filter_y; T1* im2col_row_start = im2col_patch_start + (filter_y * filter_width * input_depth); if ((in_y < 0) || (in_y >= input_height)) { memset(im2col_row_start, input_offset, (filter_width * input_depth)); } else { const int in_x_end = in_x_origin + filter_width; const int left_zero_count = std::max(0, 0 - in_x_origin); const int right_zero_count = std::max(0, in_x_end - input_width); const int center_copy_count = filter_width - (left_zero_count + right_zero_count); if (left_zero_count > 0) { T1* im2col_left_start = im2col_row_start; memset(im2col_left_start, input_offset, (left_zero_count * input_depth)); } if (center_copy_count > 0) { const T1* input_row_start = input_batch_start + (in_y * input_width * input_depth) + (std::max(0, in_x_origin) * input_depth); T1* im2col_center_start = im2col_row_start + (left_zero_count * input_depth); memcpy(im2col_center_start, input_row_start, (center_copy_count * input_depth)); } if (right_zero_count > 0) { T1* im2col_right_start = im2col_row_start + ((left_zero_count + center_copy_count) * input_depth); memset(im2col_right_start, input_offset, (right_zero_count * input_depth)); } } } } const int how_many_patches = patch_index_end - patch_index_start; const bool transpose_a = false; const bool transpose_b = false; const bool transpose_c = false; const int m = how_many_patches; const int n = filter_count; const int k = filter_value_count; const int lda = filter_value_count; const int ldb = filter_count; const int ldc = filter_count; T3* chunk_output_data = output_data + (patch_index_start * filter_count); if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() && std::is_same<T2, quint8>() && std::is_same<T3, qint32>() && (output_offset == 0) && (output_mult == 1) && (output_shift == 0) && (transpose_c == false) && (k <= 2048)) { meta::QuantizedGemm(context, transpose_a, transpose_b, im2col_buffer, filter_data, chunk_output_data, m, n, k, -input_offset, -filter_offset, lda, ldb, ldc); } else if (std::is_same<T1, quint8>() && std::is_same<T2, quint8>() && std::is_same<T3, qint32>() && (output_offset == 0) && (output_mult == 1) && (output_shift == 0)) { const uint8* im2col_data_as_uint8 = &(im2col_buffer->value); const uint8* filter_data_as_uint8 = &(filter_data->value); int32* output_data_as_int32 = &(chunk_output_data->value); static const gemmlowp::MapOrder ResultOrder = !transpose_c ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; static const gemmlowp::MapOrder LhsOrder = !transpose_a ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; static const gemmlowp::MapOrder RhsOrder = !transpose_b ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; gemmlowp::MatrixMap<const std::uint8_t, LhsOrder> lhs( im2col_data_as_uint8, m, k, lda); gemmlowp::MatrixMap<const std::uint8_t, RhsOrder> rhs( filter_data_as_uint8, k, n, ldb); gemmlowp::MatrixMap<std::int32_t, ResultOrder> result( output_data_as_int32, m, n, ldc); const std::tuple<> empty_pipeline = {}; auto& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); TensorflowGemmContext context(worker_threads.num_threads, worker_threads.workers); gemmlowp::GemmWithOutputPipeline<std::uint8_t, std::int32_t, gemmlowp::DefaultL8R8BitDepthParams>( &context, lhs, rhs, &result, -input_offset, -filter_offset, empty_pipeline); TF_ANNOTATE_MEMORY_IS_INITIALIZED(output_data_as_int32, m * n * sizeof(int32)); } else { ReferenceGemm<T1, T2, T3>( transpose_a, transpose_b, transpose_c, m, n, k, im2col_buffer, input_offset, lda, filter_data, filter_offset, ldb, chunk_output_data, output_shift, output_offset, output_mult, ldc); } } }"
"static char *get_die_name(const RBinDwarfDie *die) { char *name = NULL; st32 name_attr_idx = find_attr_idx (die, DW_AT_name); if (name_attr_idx != -1) { name = strdup (die->attr_values[name_attr_idx].string.content); } else { name = create_type_name_from_offset (die->offset); } return name; }"
"AP4_Stz2Atom::AP4_Stz2Atom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_STZ2, size, version, flags) { AP4_UI08 reserved; stream.ReadUI08(reserved); stream.ReadUI08(reserved); stream.ReadUI08(reserved); stream.ReadUI08(m_FieldSize); stream.ReadUI32(m_SampleCount); if (m_FieldSize != 4 && m_FieldSize != 8 && m_FieldSize != 16) { return; } AP4_Cardinal sample_count = m_SampleCount; m_Entries.SetItemCount(sample_count); unsigned int table_size = (sample_count*m_FieldSize+7)/8; if ((table_size+8) > size) return; unsigned char* buffer = new unsigned char[table_size]; AP4_Result result = stream.Read(buffer, table_size); if (AP4_FAILED(result)) { delete[] buffer; return; } switch (m_FieldSize) { case 4: for (unsigned int i=0; i<sample_count; i++) { if ((i%2) == 0) { m_Entries[i] = (buffer[i/2]>>4)&0x0F; } else { m_Entries[i] = buffer[i/2]&0x0F; } } break; case 8: for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = buffer[i]; } break; case 16: for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = AP4_BytesToUInt16BE(&buffer[i*2]); } break; } delete[] buffer; }"
"TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) { auto it = idInfoMap.find(id); if (it == idInfoMap.end()) { STFATAL << "" Tried to read from an id that no longer exists""; } return it->second; }"
"mp_err s_mp_mul_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs) { mp_int  t; mp_err  err; int     pa, pb, ix, iy; mp_digit u; mp_word r; mp_digit tmpx, *tmpt, *tmpy; if ((digs < MP_WARRAY) && (MP_MIN(a->used, b->used) < MP_MAXFAST)) { return s_mp_mul_digs_fast(a, b, c, digs); } if ((err = mp_init_size(&t, digs)) != MP_OKAY) { return err; } t.used = digs; pa = a->used; for (ix = 0; ix < pa; ix++) { u = 0; pb = MP_MIN(b->used, digs - ix); tmpx = a->dp[ix]; tmpt = t.dp + ix; tmpy = b->dp; for (iy = 0; iy < pb; iy++) { r       = (mp_word)*tmpt + ((mp_word)tmpx * (mp_word)*tmpy++) + (mp_word)u; *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK); u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT); } if ((ix + iy) < digs) { *tmpt = u; } } mp_clamp(&t); mp_exch(&t, c); mp_clear(&t); return MP_OKAY; }"
"void DoRealBackwardFFT(OpKernelContext* ctx, uint64* fft_shape, const Tensor& in, Tensor* out) { auto device = ctx->eigen_device<CPUDevice>(); auto input = Tensor(in).flat_inner_dims<ComplexT, FFTRank + 1>(); auto output = out->flat_inner_dims<RealT, FFTRank + 1>(); const auto input_dims = input.dimensions(); Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes; input_slice_sizes[0] = input_dims[0]; TensorShape full_fft_shape; full_fft_shape.AddDim(input_dims[0]); for (auto i = 1; i <= FFTRank; i++) { input_slice_sizes[i] = i == FFTRank ? fft_shape[i - 1] / 2 + 1 : fft_shape[i - 1]; full_fft_shape.AddDim(fft_shape[i - 1]); } Tensor temp; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(), full_fft_shape, &temp)); auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>(); auto neg_sizes = input_slice_sizes; neg_sizes[FFTRank] = fft_shape[FFTRank - 1] - input_slice_sizes[FFTRank]; Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_target_indices; neg_target_indices[FFTRank] = input_slice_sizes[FFTRank]; const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> start_indices; Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_start_indices; neg_start_indices[FFTRank] = 1; full_fft.slice(start_indices, input_slice_sizes).device(device) = input.slice(start_indices, input_slice_sizes); if (FFTRank > 1) { const auto outer_axes = Eigen::ArrayXi::LinSpaced(FFTRank - 1, 1, FFTRank - 1); full_fft.slice(start_indices, input_slice_sizes).device(device) = full_fft.slice(start_indices, input_slice_sizes) .template fft<Eigen::BothParts, Eigen::FFT_REVERSE>(outer_axes); } Eigen::array<bool, FFTRank + 1> reverse_last_axis; for (auto i = 0; i <= FFTRank; i++) { reverse_last_axis[i] = i == FFTRank; } if (neg_sizes[FFTRank] != 0) { full_fft.slice(neg_target_indices, neg_sizes).device(device) = full_fft.slice(neg_start_indices, neg_sizes) .reverse(reverse_last_axis) .conjugate(); } auto inner_axis = Eigen::array<int, 1>{FFTRank}; output.device(device) = full_fft.template fft<Eigen::RealPart, Eigen::FFT_REVERSE>(inner_axis); }"
"static guint fAbstractSyntaxNType(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset) { guint8  tag_no, tag_info; guint32 lvt; guint   lastoffset = 0, depth = 0; char    ar[256]; guint32 save_object_type; gboolean do_default_handling; if (propertyIdentifier >= 0) { g_snprintf(ar, sizeof(ar), ""%s: "", val_to_split_str(propertyIdentifier, 512, BACnetPropertyIdentifier, ASHRAE_Reserved_Fmt, Vendor_Proprietary_Fmt)); } else { g_snprintf(ar, sizeof(ar), ""Abstract Type: ""); } while (tvb_reported_length_remaining(tvb, offset) > 0) {   lastoffset = offset; fTagHeader(tvb, pinfo, offset, &tag_no, &tag_info, &lvt); if (tag_is_closing(tag_info)) {  if (depth <= 0) return offset; } do_default_handling = FALSE; switch (propertyIdentifier) { case 0:  case 35:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAcknowledgedTransitions); break; case 2:  if (tag_is_context_specific(tag_info)) { offset = fActionList(tvb, pinfo, tree, offset); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAction); } break; case 7:  switch (object_type) { case 21:  case 22:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 30:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 31:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 36:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 39:  default: if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } break; } break; case 37:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEventType); break; case 39:  switch (object_type) { case 21:  case 22:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 30:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 31:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 36:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 39:  default: if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } break; } break; case 30:  case 331:  offset = fAddressBinding(tvb, pinfo, tree, offset); break; case 52:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLimitEnable); break; case 54:  offset = fLOPR(tvb, pinfo, tree, offset); break; case 55:  fSessionKey(tvb, pinfo, tree, offset); break; case 79:  case 96:  offset = fApplicationTypesEnumeratedSplit(tvb, pinfo, tree, offset, ar, BACnetObjectType, 128); break; case 97:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetServicesSupported); break; case 102:  offset = fDestination(tvb, pinfo, tree, offset); break; case 107:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSegmentation); break; case 111:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetStatusFlags); break; case 112:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDeviceStatus); break; case 117:  case 455:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEngineeringUnits); break; case 87:     if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fPriorityArray(tvb, pinfo, tree, offset); } break; case 38:     if (object_type < 128) { if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fSpecialEvent(tvb, pinfo, tree, offset); } } break; case 19:   case 60:   case 78:   case 181:  case 355:  offset = fObjectPropertyReference(tvb, pinfo, tree, offset); break; case 132:  offset = fDeviceObjectPropertyReference(tvb, pinfo, tree, offset); break; case 109:  offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); offset = fBACnetObjectPropertyReference(tvb, pinfo, tree, offset); offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); break; case 123:    if (object_type < 128) { if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fWeeklySchedule(tvb, pinfo, tree, offset); } } break; case 127:    offset = fClientCOV(tvb, pinfo, tree, offset); break; case 131:   if ( object_type == 25 ) offset = fEventLogRecord(tvb, pinfo, tree, offset); else if ( object_type == 27 ) offset = fLogMultipleRecord(tvb, pinfo, tree, offset); else offset = fLogRecord(tvb, pinfo, tree, offset); break; case 159:  case 165:  case 211:  case 246:  case 249:  case 252:  case 265:  case 266:  case 277:  case 279:  case 286:  case 320:  case 321:  case 461:  case 491:  offset = fDeviceObjectReference(tvb, pinfo, tree, offset); break; case 196:  offset = fRestartReason(tvb, pinfo, tree, offset); break; case 212:  case 214:  case 218:  offset = fShedLevel(tvb, pinfo, tree, offset); break; case 152:  offset = fCOVSubscription(tvb, pinfo, tree, offset); break; case 23:  offset = fCalendarEntry(tvb, pinfo, tree, offset); break; case 116:  case 206:  case 202:  offset = fRecipient(tvb, pinfo, tree, offset); break; case 83:  offset = fEventParameter(tvb, pinfo, tree, offset); break; case 130:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fEventTimeStamps(tvb, pinfo, tree, offset); } break; case 197:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLoggingType); break; case 36:  offset = fApplicationTypesEnumeratedSplit(tvb, pinfo, tree, offset, ar, BACnetEventState, 64); break; case 103:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetReliability); break; case 72:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNotifyType); break; case 208:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNodeType); break; case 231:  case 450:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorStatus); break; case 233:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLockStatus); break; case 235:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorSecuredStatus); break; case 158:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetMaintenance); break; case 92:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramState); break; case 90:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramRequest); break; case 100:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramError); break; case 160:  case 175:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyMode); break; case 163:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSilencedState); break; case 161:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyOperation); break; case 164:  case 166:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 41:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetFileAccessMethod); break; case 185:   offset = fPrescale(tvb, pinfo, tree, offset); break; case 187:   offset = fScale(tvb, pinfo, tree, offset); break; case 189:  if (object_type == 37) offset = fTimeStamp(tvb, pinfo, tree, offset, ar); else offset = fDateTime(tvb, pinfo, tree, offset, ar); break; case 184:  offset = fLoggingRecord(tvb, pinfo, tree, offset); break; case 203:  offset = fTimeStamp(tvb, pinfo, tree, offset, ar); break; case 226:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 228:  offset = fDoorMembers(tvb, pinfo, tree, offset); break; case 234:  offset = fSequenceOfEnums(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 248:  offset = fAuthenticationFactor(tvb, pinfo, tree, offset); break; case 261:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAuthorizationMode); break; case 53:   save_object_type = object_type; offset = fListOfGroupMembers(tvb, pinfo, tree, offset); object_type = save_object_type; break; case 296:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 300:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessPassbackMode); break; case 303:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessCredentialDisableReason); break; case 318:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessUserType); break; case 330:  offset = fSecurityKeySet(tvb, pinfo, tree, offset); break; case 332:  offset = fNetworkSecurityPolicy(tvb, pinfo, tree, offset); break; case 338:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetBackupState); break; case 370:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetWriteStatus); break; case 385:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLightingTransition); break; case 288:  case 302:  offset = fAccessRule(tvb, pinfo, tree, offset); break; case 304:  offset = fAuthenticationFactorFormat(tvb, pinfo, tree, offset); break; case 327:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSecurityLevel); break; case 371:  offset = fSequenceOfEnums(tvb, pinfo, tree, offset, ar, BACnetPropertyIdentifier); break; case 358:  offset = fFaultParameter(tvb, pinfo, tree, offset); break; case 359:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetFaultType); break; case 362:  offset = fEventNotificationSubscription(tvb, pinfo, tree, offset); break; case 364:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAuthorizationExemption); break; case 378:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLightingInProgress); break; case 380:  offset = fLightingCommand(tvb, pinfo, tree, offset, ar); break; case 16:   case 71:   case 114:  case 115:  case 142:  case 143:  case 149:  case 150:  case 179:  case 192:  case 254:  case 270:  case 278:  case 280:  case 281:  case 392:  offset = fDateTime(tvb, pinfo, tree, offset, ar); break; case 258:  offset = fAuthenticationPolicy(tvb, pinfo, tree, offset); break; case 395:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerTransition); break; case 396:  offset = fTimerStateChangeValue(tvb, pinfo, tree, offset); break; case 398:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 407:  case 418:  offset = fHostNPort(tvb, pinfo, tree, offset, ar); break; case 408:  case 435:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetIpMode); break; case 414:  offset = fBDTEntry(tvb, pinfo, tree, offset, ar); break; case 415:  offset = fFDTEntry(tvb, pinfo, tree, offset, ar); break; case 417:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkPortCommand); break; case 426:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkNumberQuality); break; case 427:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkType); break; case 428:  offset = fRouterEntry(tvb, pinfo, tree, offset); break; case 429:  offset = fVMACEntry(tvb, pinfo, tree, offset); break; case 430:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fTimeStamp(tvb, pinfo, tree, offset, ar); } break; case 432:  offset = fTimeStamp(tvb, pinfo, tree, offset, ar); break; case 433:  offset = fValueSource(tvb, pinfo, tree, offset); break; case 434:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fValueSource(tvb, pinfo, tree, offset); } break; case 447:  offset = fAssignedLandingCalls(tvb, pinfo, tree, offset); break; case 448:  case 457:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDirection); break; case 449:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDoorCommand); break; case 453:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDriveStatus); break; case 456:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarMode); break; case 462:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorMode); break; case 463:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { if (object_type == 59)  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftFault); else offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorFault); } break; case 467:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftGroupMode); break; case 470:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fLandingCallStatus(tvb, pinfo, tree, offset); } break; case 471:  offset = fLandingCallStatus(tvb, pinfo, tree, offset); break; case 472:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fLandingDoorStatus(tvb, pinfo, tree, offset); } break; case 477:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorOperationDirection); break; case 481:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fCOVMultipleSubscription(tvb, pinfo, tree, offset); } break; case 482:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProtocolLevel); break; case 486:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fNameValue(tvb, pinfo, tree, offset); } break; case 487:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNodeType); } break; case 488:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fNameValueCollection(tvb, pinfo, tree, offset); } break; case 489:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetRelationship); } break; case 490:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetRelationship); break; case 85:   if ( object_type == 11 )     { offset = fReadAccessResult(tvb, pinfo, tree, offset); } else if (object_type == 30)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetDoorValue); } else if (object_type == 21)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); } else if (object_type == 22)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); } else if (object_type == 53)  { offset = fChannelValue(tvb, pinfo, tree, offset, ar); } else if (object_type == 37)  { offset = fAuthenticationFactor(tvb, pinfo, tree, offset); } else if (object_type == 26)  { offset = fPropertyAccessResult(tvb, pinfo, tree, offset); } else if (object_type == 28)  { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetShedState); } else { do_default_handling = TRUE; } break; default: do_default_handling = TRUE; break; } if (do_default_handling) { if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset  = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } } if (offset <= lastoffset) break;      } return offset; }"
"static int xenoprof_buf_space(struct domain *d, xenoprof_buf_t * buf, int size) { int head, tail; head = xenoprof_buf(d, buf, event_head); tail = xenoprof_buf(d, buf, event_tail); return ((tail > head) ? 0 : size) + tail - head - 1; }"
"void proto_register_iscsi(void) { module_t *iscsi_module; expert_module_t* expert_iscsi; static hf_register_info hf[] = { { &hf_iscsi_request_frame, { ""Request in"", ""iscsi.request_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The request to this transaction is in this frame"", HFILL }}, { &hf_iscsi_time, { ""Time from request"", ""iscsi.time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0, ""Time between the Command and the Response"", HFILL }}, { &hf_iscsi_data_in_frame, { ""Data In in"", ""iscsi.data_in_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The Data In for this transaction is in this frame"", HFILL }}, { &hf_iscsi_data_out_frame, { ""Data Out in"", ""iscsi.data_out_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The Data Out for this transaction is in this frame"", HFILL }}, { &hf_iscsi_response_frame, { ""Response in"", ""iscsi.response_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The response to this transaction is in this frame"", HFILL }}, { &hf_iscsi_AHS_length, { ""AHS Length"", ""iscsi.ahs.length"", FT_UINT16, BASE_DEC, NULL, 0, ""Length of Additional header segment"", HFILL } }, { &hf_iscsi_AHS_read_data_length, { ""Bidirectional Read Data Length"", ""iscsi.ahs.bidir.length"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_iscsi_AHS_type, { ""AHS Type"", ""iscsi.ahs.type"", FT_UINT8, BASE_DEC, VALS(ahs_type_vals), 0, ""Type of Additional header segment"", HFILL } }, { &hf_iscsi_AHS_extended_cdb, { ""AHS Extended CDB"", ""iscsi.ahs.extended_cdb"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_iscsi_AHS_blob, { ""Unknown AHS blob"", ""iscsi.ahs.unknown_blob"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_iscsi_Padding, { ""Padding"", ""iscsi.padding"", FT_BYTES, BASE_NONE, NULL, 0, ""Padding to 4 byte boundary"", HFILL } }, { &hf_iscsi_ping_data, { ""PingData"", ""iscsi.pingdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Ping Data"", HFILL } }, { &hf_iscsi_immediate_data, { ""ImmediateData"", ""iscsi.immediatedata"", FT_BYTES, BASE_NONE, NULL, 0, ""Immediate Data"", HFILL } }, { &hf_iscsi_async_event_data, { ""AsyncEventData"", ""iscsi.asynceventdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Async Event Data"", HFILL } }, { &hf_iscsi_vendor_specific_data, { ""VendorSpecificData"", ""iscsi.vendorspecificdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Vendor Specific Data"", HFILL } }, { &hf_iscsi_HeaderDigest32, { ""HeaderDigest"", ""iscsi.headerdigest32"", FT_UINT32, BASE_HEX, NULL, 0, ""Header Digest"", HFILL } }, { &hf_iscsi_DataDigest32, { ""DataDigest"", ""iscsi.datadigest32"", FT_UINT32, BASE_HEX, NULL, 0, ""Data Digest"", HFILL } }, { &hf_iscsi_Opcode, { ""Opcode"", ""iscsi.opcode"", FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0, NULL, HFILL } }, { &hf_iscsi_X, { ""X"", ""iscsi.X"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_X), 0x80, ""Command Retry"", HFILL } }, { &hf_iscsi_I, { ""I"", ""iscsi.I"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_I), 0x40, ""Immediate delivery"", HFILL } }, { &hf_iscsi_Flags, { ""Flags"", ""iscsi.flags"", FT_UINT8, BASE_HEX, NULL, 0, ""Opcode specific flags"", HFILL } }, { &hf_iscsi_SCSICommand_F, { ""F"", ""iscsi.scsicommand.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80, ""PDU completes command"", HFILL } }, { &hf_iscsi_SCSICommand_R, { ""R"", ""iscsi.scsicommand.R"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_R), 0x40, ""Command reads from SCSI target"", HFILL } }, { &hf_iscsi_SCSICommand_W, { ""W"", ""iscsi.scsicommand.W"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_W), 0x20, ""Command writes to SCSI target"", HFILL } }, { &hf_iscsi_SCSICommand_Attr, { ""Attr"", ""iscsi.scsicommand.attr"", FT_UINT8, BASE_HEX, VALS(iscsi_scsicommand_taskattrs), 0x07, ""SCSI task attributes"", HFILL } }, { &hf_iscsi_SCSICommand_CRN, { ""CRN"", ""iscsi.scsicommand.crn"", FT_UINT8, BASE_HEX, NULL, 0, ""SCSI command reference number"", HFILL } }, { &hf_iscsi_DataSegmentLength, { ""DataSegmentLength"", ""iscsi.datasegmentlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Data segment length (bytes)"", HFILL } }, { &hf_iscsi_TotalAHSLength, { ""TotalAHSLength"", ""iscsi.totalahslength"", FT_UINT8, BASE_DEC_HEX, NULL, 0, ""Total additional header segment length (4 byte words)"", HFILL } }, { &hf_iscsi_InitiatorTaskTag, { ""InitiatorTaskTag"", ""iscsi.initiatortasktag"", FT_UINT32, BASE_HEX, NULL, 0, ""Initiator's task tag"", HFILL } }, { &hf_iscsi_ExpectedDataTransferLength, { ""ExpectedDataTransferLength"", ""iscsi.scsicommand.expecteddatatransferlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Expected length of data transfer"", HFILL } }, { &hf_iscsi_CmdSN, { ""CmdSN"", ""iscsi.cmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Sequence number for this command"", HFILL } }, { &hf_iscsi_ExpStatSN, { ""ExpStatSN"", ""iscsi.expstatsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Next expected status sequence number"", HFILL } }, { &hf_iscsi_SCSIResponse_ResidualCount, { ""ResidualCount"", ""iscsi.scsiresponse.residualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Residual count"", HFILL } }, { &hf_iscsi_StatSN, { ""StatSN"", ""iscsi.statsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Status sequence number"", HFILL } }, { &hf_iscsi_ExpCmdSN, { ""ExpCmdSN"", ""iscsi.expcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Next expected command sequence number"", HFILL } }, { &hf_iscsi_MaxCmdSN, { ""MaxCmdSN"", ""iscsi.maxcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Maximum acceptable command sequence number"", HFILL } }, { &hf_iscsi_SCSIResponse_o, { ""o"", ""iscsi.scsiresponse.o"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_o), 0x10, ""Bi-directional read residual overflow"", HFILL } }, { &hf_iscsi_SCSIResponse_u, { ""u"", ""iscsi.scsiresponse.u"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_u), 0x08, ""Bi-directional read residual underflow"", HFILL } }, { &hf_iscsi_SCSIResponse_O, { ""O"", ""iscsi.scsiresponse.O"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_O), 0x04, ""Residual overflow"", HFILL } }, { &hf_iscsi_SCSIResponse_U, { ""U"", ""iscsi.scsiresponse.U"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_U), 0x02, ""Residual underflow"", HFILL } }, { &hf_iscsi_SCSIResponse_Status, { ""Status"", ""iscsi.scsiresponse.status"", FT_UINT8, BASE_HEX, VALS(scsi_status_val), 0, ""SCSI command status value"", HFILL } }, { &hf_iscsi_SCSIResponse_Response, { ""Response"", ""iscsi.scsiresponse.response"", FT_UINT8, BASE_HEX, VALS(iscsi_scsi_responses), 0, ""SCSI command response value"", HFILL } }, { &hf_iscsi_SCSIResponse_BidiReadResidualCount, { ""BidiReadResidualCount"", ""iscsi.scsiresponse.bidireadresidualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Bi-directional read residual count"", HFILL } }, { &hf_iscsi_SenseLength, { ""SenseLength"", ""iscsi.scsiresponse.senselength"", FT_UINT16, BASE_DEC_HEX, NULL, 0, ""Sense data length"", HFILL } }, { &hf_iscsi_SCSIData_F, { ""F"", ""iscsi.scsidata.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), ISCSI_SCSI_DATA_FLAG_F, ""Final PDU"", HFILL } }, { &hf_iscsi_SCSIData_A, { ""A"", ""iscsi.scsidata.A"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_A), ISCSI_SCSI_DATA_FLAG_A, ""Acknowledge Requested"", HFILL } }, { &hf_iscsi_SCSIData_S, { ""S"", ""iscsi.scsidata.S"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_S), ISCSI_SCSI_DATA_FLAG_S, ""PDU Contains SCSI command status"", HFILL } }, { &hf_iscsi_SCSIData_U, { ""U"", ""iscsi.scsidata.U"", FT_BOOLEAN, 8,  TFS(&iscsi_meaning_U), ISCSI_SCSI_DATA_FLAG_U, ""Residual underflow"", HFILL } }, { &hf_iscsi_SCSIData_O, { ""O"", ""iscsi.scsidata.O"", FT_BOOLEAN, 8,  TFS(&iscsi_meaning_O), ISCSI_SCSI_DATA_FLAG_O, ""Residual overflow"", HFILL } }, { &hf_iscsi_TargetTransferTag, { ""TargetTransferTag"", ""iscsi.targettransfertag"", FT_UINT32, BASE_HEX, NULL, 0, ""Target transfer tag"", HFILL } }, { &hf_iscsi_BufferOffset, { ""BufferOffset"", ""iscsi.bufferOffset"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Buffer offset"", HFILL } }, { &hf_iscsi_SCSIData_ResidualCount, { ""ResidualCount"", ""iscsi.scsidata.readresidualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Residual count"", HFILL } }, { &hf_iscsi_DataSN, { ""DataSN"", ""iscsi.datasn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Data sequence number"", HFILL } }, { &hf_iscsi_VersionMax, { ""VersionMax"", ""iscsi.versionmax"", FT_UINT8, BASE_HEX, NULL, 0, ""Maximum supported protocol version"", HFILL } }, { &hf_iscsi_VersionMin, { ""VersionMin"", ""iscsi.versionmin"", FT_UINT8, BASE_HEX, NULL, 0, ""Minimum supported protocol version"", HFILL } }, { &hf_iscsi_VersionActive, { ""VersionActive"", ""iscsi.versionactive"", FT_UINT8, BASE_HEX, NULL, 0, ""Negotiated protocol version"", HFILL } }, { &hf_iscsi_CID, { ""CID"", ""iscsi.cid"", FT_UINT16, BASE_HEX, NULL, 0, ""Connection identifier"", HFILL } }, { &hf_iscsi_ISID8, { ""ISID"", ""iscsi.isid8"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier"", HFILL } }, { &hf_iscsi_ISID, { ""ISID"", ""iscsi.isid"", FT_BYTES, BASE_NONE, NULL, 0, ""Initiator part of session identifier"", HFILL } }, { &hf_iscsi_ISID_Type, { ""ISID_Type"", ""iscsi.isid.type"", FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0, ""Initiator part of session identifier - type"", HFILL } }, { &hf_iscsi_ISID_NamingAuthority, { ""ISID_NamingAuthority"", ""iscsi.isid.namingauthority"", FT_UINT24, BASE_HEX, NULL, 0, ""Initiator part of session identifier - naming authority"", HFILL } }, { &hf_iscsi_ISID_Qualifier, { ""ISID_Qualifier"", ""iscsi.isid.qualifier"", FT_UINT8, BASE_HEX, NULL, 0, ""Initiator part of session identifier - qualifier"", HFILL } }, { &hf_iscsi_ISID_t, { ""ISID_t"", ""iscsi.isid.t"", FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0xc0, ""Initiator part of session identifier - t"", HFILL } }, { &hf_iscsi_ISID_a, { ""ISID_a"", ""iscsi.isid.a"", FT_UINT8, BASE_HEX, NULL, 0x3f, ""Initiator part of session identifier - a"", HFILL } }, { &hf_iscsi_ISID_b, { ""ISID_b"", ""iscsi.isid.b"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier - b"", HFILL } }, { &hf_iscsi_ISID_c, { ""ISID_c"", ""iscsi.isid.c"", FT_UINT8, BASE_HEX, NULL, 0, ""Initiator part of session identifier - c"", HFILL } }, { &hf_iscsi_ISID_d, { ""ISID_d"", ""iscsi.isid.d"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier - d"", HFILL } }, { &hf_iscsi_TSID, { ""TSID"", ""iscsi.tsid"", FT_UINT16, BASE_HEX, NULL, 0, ""Target part of session identifier"", HFILL } }, { &hf_iscsi_TSIH, { ""TSIH"", ""iscsi.tsih"", FT_UINT16, BASE_HEX, NULL, 0, ""Target session identifying handle"", HFILL } }, { &hf_iscsi_Login_T, { ""T"", ""iscsi.login.T"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_T), 0x80, ""Transit to next login stage"",  HFILL } }, { &hf_iscsi_Login_C, { ""C"", ""iscsi.login.C"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40, ""Text incomplete"",  HFILL } }, { &hf_iscsi_Login_X, { ""X"", ""iscsi.login.X"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_login_X), 0x40, ""Restart Connection"",  HFILL } }, { &hf_iscsi_Login_CSG, { ""CSG"", ""iscsi.login.csg"", FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), CSG_MASK, ""Current stage"",  HFILL } }, { &hf_iscsi_Login_NSG, { ""NSG"", ""iscsi.login.nsg"", FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), NSG_MASK, ""Next stage"",  HFILL } }, { &hf_iscsi_Login_Status, { ""Status"", ""iscsi.login.status"", FT_UINT16, BASE_HEX, VALS(iscsi_login_status), 0, ""Status class and detail"", HFILL } }, { &hf_iscsi_KeyValue, { ""KeyValue"", ""iscsi.keyvalue"", FT_STRING, BASE_NONE, NULL, 0, ""Key/value pair"", HFILL } }, { &hf_iscsi_Text_F, { ""F"", ""iscsi.text.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80, ""Final PDU in text sequence"", HFILL } }, { &hf_iscsi_Text_C, { ""C"", ""iscsi.text.C"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40, ""Text incomplete"", HFILL } }, { &hf_iscsi_ExpDataSN, { ""ExpDataSN"", ""iscsi.expdatasn"", FT_UINT32, BASE_HEX, NULL, 0, ""Next expected data sequence number"", HFILL } }, { &hf_iscsi_R2TSN, { ""R2TSN"", ""iscsi.r2tsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""R2T PDU Number"", HFILL } }, { &hf_iscsi_TaskManagementFunction_Response, { ""Response"", ""iscsi.taskmanfun.response"", FT_UINT8, BASE_HEX, VALS(iscsi_task_management_responses), 0, NULL, HFILL } }, { &hf_iscsi_TaskManagementFunction_ReferencedTaskTag, { ""ReferencedTaskTag"", ""iscsi.taskmanfun.referencedtasktag"", FT_UINT32, BASE_HEX, NULL, 0, ""Referenced task tag"", HFILL } }, { &hf_iscsi_RefCmdSN, { ""RefCmdSN"", ""iscsi.refcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Command sequence number for command to be aborted"", HFILL } }, { &hf_iscsi_TaskManagementFunction_Function, { ""Function"", ""iscsi.taskmanfun.function"", FT_UINT8, BASE_HEX, VALS(iscsi_task_management_functions), 0x7F, ""Requested task function"", HFILL } }, { &hf_iscsi_Logout_Reason, { ""Reason"", ""iscsi.logout.reason"", FT_UINT8, BASE_HEX, VALS(iscsi_logout_reasons), 0x7F, ""Reason for logout"", HFILL } }, { &hf_iscsi_Logout_Response, { ""Response"", ""iscsi.logout.response"", FT_UINT8, BASE_HEX, VALS(iscsi_logout_response), 0, ""Logout response"", HFILL } }, { &hf_iscsi_Time2Wait, { ""Time2Wait"", ""iscsi.time2wait"", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_iscsi_Time2Retain, { ""Time2Retain"", ""iscsi.time2retain"", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_iscsi_DesiredDataLength, { ""DesiredDataLength"", ""iscsi.desireddatalength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Desired data length (bytes)"", HFILL } }, { &hf_iscsi_AsyncEvent, { ""AsyncEvent"", ""iscsi.asyncevent"", FT_UINT8, BASE_HEX, VALS(iscsi_asyncevents), 0, ""Async event type"", HFILL } }, { &hf_iscsi_EventVendorCode, { ""EventVendorCode"", ""iscsi.eventvendorcode"", FT_UINT8, BASE_HEX, NULL, 0, ""Event vendor code"", HFILL } }, { &hf_iscsi_Parameter1, { ""Parameter1"", ""iscsi.parameter1"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 1"", HFILL } }, { &hf_iscsi_Parameter2, { ""Parameter2"", ""iscsi.parameter2"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 2"", HFILL } }, { &hf_iscsi_Parameter3, { ""Parameter3"", ""iscsi.parameter3"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 3"", HFILL } }, { &hf_iscsi_Reject_Reason, { ""Reason"", ""iscsi.reject.reason"", FT_UINT8, BASE_HEX, VALS(iscsi_reject_reasons), 0, ""Reason for command rejection"", HFILL } }, { &hf_iscsi_snack_type, { ""S"", ""iscsi.snack.type"", FT_UINT8, BASE_DEC, VALS(iscsi_snack_types), 0x0f, ""Type of SNACK requested"", HFILL } }, { &hf_iscsi_BegRun, { ""BegRun"", ""iscsi.snack.begrun"", FT_UINT32, BASE_HEX, NULL, 0, ""First missed DataSN or StatSN"", HFILL } }, { &hf_iscsi_RunLength, { ""RunLength"", ""iscsi.snack.runlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Number of additional missing status PDUs in this run"", HFILL } }, }; static gint *ett[] = { &ett_iscsi, &ett_iscsi_KeyValues, &ett_iscsi_CDB, &ett_iscsi_Flags, &ett_iscsi_RejectHeader, &ett_iscsi_lun, &ett_iscsi_ISID, }; static ei_register_info ei[] = { { &ei_iscsi_keyvalue_invalid, { ""iscsi.keyvalue.invalid"", PI_MALFORMED, PI_ERROR, ""Invalid key/value pair"", EXPFILL }} }; proto_iscsi = proto_register_protocol(""iSCSI"", ""iSCSI"", ""iscsi""); iscsi_handle = register_dissector(""iscsi"", dissect_iscsi_handle, proto_iscsi); proto_register_field_array(proto_iscsi, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); iscsi_module = prefs_register_protocol(proto_iscsi, NULL); prefs_register_enum_preference(iscsi_module, ""protocol_version"", ""Protocol version"", ""The iSCSI protocol version"", &iscsi_protocol_version, iscsi_protocol_versions, FALSE); prefs_register_bool_preference(iscsi_module, ""desegment_iscsi_messages"", ""Reassemble iSCSI messages spanning multiple TCP segments"", ""Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments."" "" To use this option, you must also enable \""Allow subdissectors to reassemble TCP streams\"" in the TCP protocol settings."", &iscsi_desegment); prefs_register_bool_preference(iscsi_module, ""bogus_pdu_filter"", ""Enable bogus pdu filter"", ""When enabled, packets that appear bogus are ignored"", &enable_bogosity_filter); prefs_register_bool_preference(iscsi_module, ""demand_good_f_bit"", ""Ignore packets with bad F bit"", ""Ignore packets that haven't set the F bit when they should have"", &demand_good_f_bit); prefs_register_uint_preference(iscsi_module, ""bogus_pdu_max_data_len"", ""Bogus pdu max data length threshold"", ""Treat packets whose data segment length is greater than this value as bogus"", 10, &bogus_pdu_data_length_threshold); range_convert_str(wmem_epan_scope(), &global_iscsi_port_range, TCP_PORT_ISCSI_RANGE, MAX_TCP_PORT); prefs_register_range_preference(iscsi_module, ""target_ports"", ""Target Ports Range"", ""Range of iSCSI target ports"" ""(default "" TCP_PORT_ISCSI_RANGE "")"", &global_iscsi_port_range, MAX_TCP_PORT); prefs_register_uint_preference(iscsi_module, ""target_system_port"", ""Target system port"", ""System port number of iSCSI target"", 10, &iscsi_system_port); prefs_register_obsolete_preference(iscsi_module, ""version_03_compatible""); prefs_register_obsolete_preference(iscsi_module, ""bogus_pdu_max_digest_padding""); prefs_register_obsolete_preference(iscsi_module, ""header_digest_is_crc32c""); prefs_register_obsolete_preference(iscsi_module, ""header_digest_size""); prefs_register_obsolete_preference(iscsi_module, ""enable_header_digests""); prefs_register_obsolete_preference(iscsi_module, ""data_digest_is_crc32c""); prefs_register_obsolete_preference(iscsi_module, ""data_digest_size""); prefs_register_obsolete_preference(iscsi_module, ""enable_data_digests""); expert_iscsi = expert_register_protocol(proto_iscsi); expert_register_field_array(expert_iscsi, ei, array_length(ei)); }"
"static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry, int flags) { int err; DEFINE_DELAYED_CALL(done); struct path parentpath; struct ovl_copy_up_ctx ctx = { .parent = parent, .dentry = dentry, .workdir = ovl_workdir(dentry), }; if (WARN_ON(!ctx.workdir)) return -EROFS; ovl_path_lower(dentry, &ctx.lowerpath); err = vfs_getattr(&ctx.lowerpath, &ctx.stat, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT); if (err) return err; ctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags); if (parent) { ovl_path_upper(parent, &parentpath); ctx.destdir = parentpath.dentry; ctx.destname = dentry->d_name; err = vfs_getattr(&parentpath, &ctx.pstat, STATX_ATIME | STATX_MTIME, AT_STATX_SYNC_AS_STAT); if (err) return err; } if (flags & O_TRUNC) ctx.stat.size = 0; if (S_ISLNK(ctx.stat.mode)) { ctx.link = vfs_get_link(ctx.lowerpath.dentry, &done); if (IS_ERR(ctx.link)) return PTR_ERR(ctx.link); } err = ovl_copy_up_start(dentry, flags); if (unlikely(err)) { if (err > 0) err = 0; } else { if (!ovl_dentry_upper(dentry)) err = ovl_do_copy_up(&ctx); if (!err && parent && !ovl_dentry_has_upper_alias(dentry)) err = ovl_link_up(&ctx); if (!err && ovl_dentry_needs_data_copy_up_locked(dentry, flags)) err = ovl_copy_up_meta_inode_data(&ctx); ovl_copy_up_end(dentry); } do_delayed_call(&done); return err; }"
"static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr) { while (jump) { if (jump->type == STM_BREAK) labelto(J, F, jump->inst, baddr); if (jump->type == STM_CONTINUE) labelto(J, F, jump->inst, caddr); jump = jump->next; } }"
static void vhost_vdpa_config_put(struct vhost_vdpa *v) { if (v->config_ctx) eventfd_ctx_put(v->config_ctx); }
"static std::optional<Type> convertStructType(spirv::StructType type, LLVMTypeConverter &converter) { SmallVector<spirv::StructType::MemberDecorationInfo, 4> memberDecorations; type.getMemberDecorations(memberDecorations); if (!memberDecorations.empty()) return std::nullopt; if (type.hasOffset()) return convertStructTypeWithOffset(type, converter); return convertStructTypePacked(type, converter); }"
"Status InferenceContext::InternalMakeShapeFromTensor( bool treat_unknown_scalar_tensor_as_unknown_shape, const Tensor* t, ShapeHandle tensor_shape, ShapeHandle* out) { if (!treat_unknown_scalar_tensor_as_unknown_shape) { TF_RETURN_IF_ERROR(WithRank(tensor_shape, 1, &tensor_shape)); } if (t == nullptr) { if (Rank(tensor_shape) == 0) { return ReturnUnknownShape(out); } DimensionHandle shape_dim = Dim(tensor_shape, 0); if (!ValueKnown(shape_dim)) { return ReturnUnknownShape(out); } const auto num_dims = Value(shape_dim); std::vector<DimensionHandle> dims; dims.reserve(num_dims); for (int i = 0; i < num_dims; i++) dims.push_back(UnknownDim()); return ReturnCreatedShape(dims, out); } if (t->shape().dims() == 0) { if (t->dtype() == DataType::DT_INT32) { auto flat_t = t->scalar<int32>(); if (flat_t() != -1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, or if its rank 0 it must have value "" ""-1 "" ""(representing an unknown shape).  Saw value: "", flat_t()); } return ReturnUnknownShape(out); } else if (t->dtype() == DataType::DT_INT64) { auto flat_t = t->scalar<int64_t>(); if (flat_t() != -1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, or if its rank 0 it must have value "" ""-1 "" ""(representing an unknown shape).  Saw value: "", flat_t()); } return ReturnUnknownShape(out); } else { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be int32 or int64, but was "", DataTypeString(t->dtype())); } } if (t->shape().dims() != 1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, but was rank "", t->shape().dims(), ""."", ((t->shape().dims() == 0) ? ""If it is rank 0 rank 0 it must have statically known value -1 "" ""(representing an unknown shape). "" : "" ""), ""Saw tensor shape "", t->shape().DebugString()); } std::vector<DimensionHandle> dims; if (t->dtype() == DataType::DT_INT32) { auto flat_t = t->flat<int32>(); for (int i = 0; i < flat_t.size(); ++i) { const int32_t val = flat_t(i); if (val < -1) { return errors::InvalidArgument( ""Invalid value in tensor used for shape: "", val); } dims.push_back(MakeDim(val)); } } else if (t->dtype() == DataType::DT_INT64) { auto flat_t = t->flat<int64_t>(); for (int i = 0; i < flat_t.size(); ++i) { const int64_t val = flat_t(i); if (val < -1) { return errors::InvalidArgument( ""Invalid value in tensor used for shape: "", val); } dims.push_back(MakeDim(val)); } } else { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be int32 or int64, but was "", DataTypeString(t->dtype())); } return ReturnCreatedShape(dims, out); }"
int32_t mz_path_has_slash(const char *path) { int32_t path_len = (int32_t)strlen(path); if (path[path_len - 1] != '\\' && path[path_len - 1] != '/') return MZ_EXIST_ERROR; return MZ_OK; }
"int fixExec2Error(int action, u_char * var_val, u_char var_val_type, size_t var_val_len, u_char * statP, oid * name, size_t name_len) { netsnmp_old_extend *exten = NULL; unsigned int idx; idx = name[name_len-1] -1; exten = &compatability_entries[ idx ]; #ifndef NETSNMP_NO_WRITE_SUPPORT switch (action) { case MODE_SET_RESERVE1: if (var_val_type != ASN_INTEGER) { snmp_log(LOG_ERR, ""Wrong type != int\n""); return SNMP_ERR_WRONGTYPE; } idx = *((long *) var_val); if (idx != 1) { snmp_log(LOG_ERR, ""Wrong value != 1\n""); return SNMP_ERR_WRONGVALUE; } if (!exten || !exten->efix_entry) { snmp_log(LOG_ERR, ""No command to run\n""); return SNMP_ERR_GENERR; } return SNMP_ERR_NOERROR; case MODE_SET_COMMIT: netsnmp_cache_check_and_reload( exten->efix_entry->cache ); } #endif  return SNMP_ERR_NOERROR; }"
"int move_hugetlb_page_tables(struct vm_area_struct *vma, struct vm_area_struct *new_vma, unsigned long old_addr, unsigned long new_addr, unsigned long len) { struct hstate *h = hstate_vma(vma); struct address_space *mapping = vma->vm_file->f_mapping; unsigned long sz = huge_page_size(h); struct mm_struct *mm = vma->vm_mm; unsigned long old_end = old_addr + len; unsigned long old_addr_copy; pte_t *src_pte, *dst_pte; struct mmu_notifier_range range; mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, old_addr, old_end); adjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end); mmu_notifier_invalidate_range_start(&range); i_mmap_lock_write(mapping); for (; old_addr < old_end; old_addr += sz, new_addr += sz) { src_pte = huge_pte_offset(mm, old_addr, sz); if (!src_pte) continue; if (huge_pte_none(huge_ptep_get(src_pte))) continue; old_addr_copy = old_addr; if (huge_pmd_unshare(mm, vma, &old_addr_copy, src_pte)) continue; dst_pte = huge_pte_alloc(mm, new_vma, new_addr, sz); if (!dst_pte) break; move_huge_pte(vma, old_addr, new_addr, src_pte); } i_mmap_unlock_write(mapping); flush_tlb_range(vma, old_end - len, old_end); mmu_notifier_invalidate_range_end(&range); return len + old_addr - old_end; }"
"static void http_manage_server_side_cookies(struct stream *s, struct channel *res) { struct session *sess = s->sess; struct http_txn *txn = s->txn; struct htx *htx; struct http_hdr_ctx ctx; struct server *srv; char *hdr_beg, *hdr_end; char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next; int is_cookie2 = 0; htx = htxbuf(&res->buf); ctx.blk = NULL; while (1) { int is_first = 1; if (!http_find_header(htx, ist(""Set-Cookie""), &ctx, 1)) { if (!http_find_header(htx, ist(""Set-Cookie2""), &ctx, 1)) break; is_cookie2 = 1; } txn->flags |= TX_SCK_PRESENT; if (s->be->cookie_name == NULL && sess->fe->capture_name == NULL) break; hdr_beg = ctx.value.ptr; hdr_end = hdr_beg + ctx.value.len; for (prev = hdr_beg; prev < hdr_end; prev = next) { att_beg = prev; if (!is_first) att_beg++; is_first = 0; while (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg)) att_beg++; equal = att_end = att_beg; while (equal < hdr_end) { if (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ',')) break; if (HTTP_IS_SPHT(*equal++)) continue; att_end = equal; } if (equal < hdr_end && *equal == '=') { val_beg = equal + 1; while (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg)) val_beg++; next = http_find_cookie_value_end(val_beg, hdr_end); val_end = next; while (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1))) val_end--; } else { val_beg = val_end = next = equal; } if (next < hdr_end) { if (is_cookie2) next = http_find_hdr_value_end(next, hdr_end); else next = hdr_end; } if (equal == val_end) continue; if (unlikely(att_end != equal || val_beg > equal + 1)) { int stripped_before = 0; int stripped_after = 0; if (att_end != equal) { memmove(att_end, equal, hdr_end - equal); stripped_before = (att_end - equal); equal   += stripped_before; val_beg += stripped_before; } if (val_beg > equal + 1) { memmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg); stripped_after = (equal + 1) - val_beg; val_beg += stripped_after; stripped_before += stripped_after; } val_end      += stripped_before; next         += stripped_before; hdr_end      += stripped_before; htx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg); ctx.value.len = hdr_end - hdr_beg; } if (sess->fe->capture_name != NULL && txn->srv_cookie == NULL && (val_end - att_beg >= sess->fe->capture_namelen) && memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) { int log_len = val_end - att_beg; if ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) { ha_alert(""HTTP logging : out of memory.\n""); } else { if (log_len > sess->fe->capture_len) log_len = sess->fe->capture_len; memcpy(txn->srv_cookie, att_beg, log_len); txn->srv_cookie[log_len] = 0; } } srv = objt_server(s->target); if (!(s->flags & SF_IGNORE_PRST) && (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) && (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) { txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_FOUND; if (s->be->ck_opts & PR_CK_PSV) { } else if ((srv && (s->be->ck_opts & PR_CK_INS)) || ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) { if (prev == hdr_beg && next == hdr_end) { http_remove_header(htx, &ctx); } else { int delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next); next      = prev; hdr_end  += delta; } txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_DELETED; } else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) { int sliding, delta; ctx.value = ist2(val_beg, val_end - val_beg); ctx.lws_before = ctx.lws_after = 0; http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen)); delta     = srv->cklen - (val_end - val_beg); sliding   = (ctx.value.ptr - val_beg); hdr_beg  += sliding; val_beg  += sliding; next     += sliding + delta; hdr_end  += sliding + delta; txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_REPLACED; } else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) { int sliding, delta; ctx.value = ist2(val_beg, 0); ctx.lws_before = ctx.lws_after = 0; http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1)); delta     = srv->cklen + 1; sliding   = (ctx.value.ptr - val_beg); hdr_beg  += sliding; val_beg  += sliding; next     += sliding + delta; hdr_end  += sliding + delta; val_beg[srv->cklen] = COOKIE_DELIM; txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_REPLACED; } } } } }"
"static gboolean option_persist_cb (const gchar *option_name, const gchar *value, gpointer     data, GError     **error) { FlatpakContext *context = data; flatpak_context_set_persistent (context, value); return TRUE; }"
"void LineBufferTask::execute () { try { if (_lineBuffer->uncompressedData == 0) { Int64 uncompressedSize = 0; int maxY = min (_lineBuffer->maxY, _ifd->maxY); for (int i = _lineBuffer->minY - _ifd->minY; i <= maxY - _ifd->minY; ++i) { uncompressedSize += (int) _ifd->bytesPerLine[i]; } if (_lineBuffer->compressor != 0) delete _lineBuffer->compressor; Int64 maxBytesPerLine = 0; for (int i = _lineBuffer->minY - _ifd->minY; i <= maxY - _ifd->minY; ++i) { if (_ifd->bytesPerLine[i] > maxBytesPerLine) maxBytesPerLine = _ifd->bytesPerLine[i]; } _lineBuffer->compressor = newCompressor(_ifd->header.compression(), maxBytesPerLine, _ifd->header); if (_lineBuffer->compressor && _lineBuffer->packedDataSize < uncompressedSize) { _lineBuffer->format = _lineBuffer->compressor->format(); _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress (_lineBuffer->buffer, _lineBuffer->packedDataSize, _lineBuffer->minY, _lineBuffer->uncompressedData); } else { _lineBuffer->format = Compressor::XDR; _lineBuffer->uncompressedData = _lineBuffer->buffer; } } int yStart, yStop, dy; if (_ifd->lineOrder == INCREASING_Y) { yStart = _scanLineMin; yStop = _scanLineMax + 1; dy = 1; } else { yStart = _scanLineMax; yStop = _scanLineMin - 1; dy = -1; } for (int y = yStart; y != yStop; y += dy) { const char *readPtr = _lineBuffer->uncompressedData + _ifd->offsetInLineBuffer[y - _ifd->minY]; for (unsigned int i = 0; i < _ifd->slices.size(); ++i) { InSliceInfo &slice = *_ifd->slices[i]; if (modp (y, slice.ySampling) != 0) continue; if (slice.skip) { skipChannel (readPtr, slice.typeInFile, _ifd->lineSampleCount[y - _ifd->minY]); } else { int width = (_ifd->maxX - _ifd->minX + 1); copyIntoDeepFrameBuffer (readPtr, slice.base, (char*) (&_ifd->sampleCount[0][0] - _ifd->minX - _ifd->minY * width), sizeof(unsigned int) * 1, sizeof(unsigned int) * width, y, _ifd->minX, _ifd->maxX, 0, 0, 0, 0, slice.sampleStride,  slice.xPointerStride, slice.yPointerStride, slice.fill, slice.fillValue, _lineBuffer->format, slice.typeInFrameBuffer, slice.typeInFile); } } } } catch (std::exception &e) { if (!_lineBuffer->hasException) { _lineBuffer->exception = e.what(); _lineBuffer->hasException = true; } } catch (...) { if (!_lineBuffer->hasException) { _lineBuffer->exception = ""unrecognized exception""; _lineBuffer->hasException = true; } } }"
"GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs) { GF_Err e; u8 hasTLV, type; u16 i, count; u32 TLVsize, tempSize; GF_Box *a; ptr->relativeTransTime = gf_bs_read_u32(bs); gf_bs_read_int(bs, 2); ptr->P_bit = gf_bs_read_int(bs, 1); ptr->X_bit = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 4); ptr->M_bit = gf_bs_read_int(bs, 1); ptr->payloadType = gf_bs_read_int(bs, 7); ptr->SequenceNumber = gf_bs_read_u16(bs); gf_bs_read_int(bs, 13); hasTLV = gf_bs_read_int(bs, 1); ptr->B_bit = gf_bs_read_int(bs, 1); ptr->R_bit = gf_bs_read_int(bs, 1); count = gf_bs_read_u16(bs); if (hasTLV) { tempSize = 4;TLVsize = gf_bs_read_u32(bs); while (tempSize < TLVsize) { e = gf_isom_box_parse(&a, bs); if (e) return e; gf_list_add(ptr->TLV, a); tempSize += (u32) a->size; } if (tempSize != TLVsize) return GF_ISOM_INVALID_FILE; } for (i=0; i<count; i++) { GF_GenericDTE *dte; Bool add_it = 0; type = gf_bs_read_u8(bs); dte = NewDTE(type); if (!dte) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", type, ptr->sampleNumber, ptr->trackID)); return GF_ISOM_INVALID_FILE; } e = ReadDTE(dte, bs); if (e) return e; switch (type) { case 1: if ( ((GF_ImmediateDTE *)dte)->dataLength) add_it = 1; break; case 2: if ( ((GF_SampleDTE *)dte)->dataLength) add_it = 1; break; case 3: if ( ((GF_StreamDescDTE *)dte)->dataLength) add_it = 1; break; } if (add_it) gf_list_add(ptr->DataTable, dte); else DelDTE(dte); } return GF_OK; }"
"Variant HHVM_FUNCTION(fwrite, const Resource& handle, const String& data, int64_t length ) { CHECK_HANDLE(handle, f); int64_t ret = f->write(data, length); if (ret < 0) { raise_notice(""fwrite(): send of %d bytes failed with errno=%d %s"", data.size(), errno, folly::errnoStr(errno).c_str()); ret = 0; } return ret; }"
"int unix_expandpath( garray_T*gap, char_u*path, intwildoff, intflags,    intdidstar){ char_u*buf; char_u*path_end; char_u*p, *s, *e; intstart_len = gap->ga_len; char_u*pat; regmatch_Tregmatch; intstarts_with_dot; intmatches; intlen; intstarstar = FALSE; static intstardepth = 0;     DIR*dirp; struct dirent *dp; if (stardepth > 0) { ui_breakcheck(); if (got_int) return 0; } buf = alloc(STRLEN(path) + BASENAMELEN + 5); if (buf == NULL) return 0; p = buf; s = buf; e = NULL; path_end = path; while (*path_end != NUL) { if (path_end >= path + wildoff && rem_backslash(path_end)) *p++ = *path_end++; else if (*path_end == '/') { if (e != NULL) break; s = p + 1; } else if (path_end >= path + wildoff && (vim_strchr((char_u *)""*?[{~$"", *path_end) != NULL || (!p_fic && (flags & EW_ICASE) && isalpha(PTR2CHAR(path_end))))) e = p; if (has_mbyte) { len = (*mb_ptr2len)(path_end); STRNCPY(p, path_end, len); p += len; path_end += len; } else *p++ = *path_end++; } e = p; *e = NUL; for (p = buf + wildoff; p < s; ++p) if (rem_backslash(p)) { STRMOVE(p, p + 1); --e; --s; } for (p = s; p < e; ++p) if (p[0] == '*' && p[1] == '*') starstar = TRUE; starts_with_dot = *s == '.'; pat = file_pat_to_reg_pat(s, e, NULL, FALSE); if (pat == NULL) { vim_free(buf); return 0; } if (flags & EW_ICASE) regmatch.rm_ic = TRUE;    else regmatch.rm_ic = p_fic;    if (flags & (EW_NOERROR | EW_NOTWILD)) ++emsg_silent; regmatch.regprog = vim_regcomp(pat, RE_MAGIC); if (flags & (EW_NOERROR | EW_NOTWILD)) --emsg_silent; vim_free(pat); if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0) { vim_free(buf); return 0; } if (!didstar && stardepth < 100 && starstar && e - s == 2 && *path_end == '/') { STRCPY(s, path_end + 1); ++stardepth; (void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE); --stardepth; } *s = NUL; dirp = opendir(*buf == NUL ? ""."" : (char *)buf); if (dirp != NULL) { for (;;) { dp = readdir(dirp); if (dp == NULL) break; if ((dp->d_name[0] != '.' || starts_with_dot || ((flags & EW_DODOT) && dp->d_name[1] != NUL && (dp->d_name[1] != '.' || dp->d_name[2] != NUL))) && ((regmatch.regprog != NULL && vim_regexec(&regmatch, (char_u *)dp->d_name, (colnr_T)0)) || ((flags & EW_NOTWILD) && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0))) { STRCPY(s, dp->d_name); len = STRLEN(buf); if (starstar && stardepth < 100) { STRCPY(buf + len, ""/**""); STRCPY(buf + len + 3, path_end); ++stardepth; (void)unix_expandpath(gap, buf, len + 1, flags, TRUE); --stardepth; } STRCPY(buf + len, path_end); if (mch_has_exp_wildcard(path_end)) { (void)unix_expandpath(gap, buf, len + 1, flags, FALSE); } else { stat_T  sb; if (*path_end != NUL) backslash_halve(buf + len + 1); if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0 : mch_getperm(buf) >= 0) { #ifdef MACOS_CONVERT size_t precomp_len = STRLEN(buf)+1; char_u *precomp_buf = mac_precompose_path(buf, precomp_len, &precomp_len); if (precomp_buf) { mch_memmove(buf, precomp_buf, precomp_len); vim_free(precomp_buf); } #endif addfile(gap, buf, flags); } } } } closedir(dirp); } vim_free(buf); vim_regfree(regmatch.regprog); matches = gap->ga_len - start_len; if (matches > 0) qsort(((char_u **)gap->ga_data) + start_len, matches, sizeof(char_u *), pstrcmp); return matches; }"
"explicit FractionalAvgPoolOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_)); OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_)); OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_)); OP_REQUIRES(context, pooling_ratio_.size() == 4, errors::InvalidArgument( ""pooling_ratio field must specify 4 dimensions"")); for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) { OP_REQUIRES(context, pooling_ratio_[i] >= 1, errors::InvalidArgument( ""pooling_ratio cannot be smaller than 1, got: "", pooling_ratio_[i])); } OP_REQUIRES( context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1, errors::Unimplemented(""Fractional average pooling is not yet "" ""supported on the batch nor channel dimension."")); OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_)); OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_)); OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_)); if (deterministic_) { if ((seed_ == 0) && (seed2_ == 0)) { seed_ = random::New64(); seed2_ = random::New64(); } } else { OP_REQUIRES( context, (seed_ == 0) && (seed2_ == 0), errors::InvalidArgument( ""Both seed and seed2 should be 0 if deterministic is false."")); } }"
"PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd, pj_off_t offset, enum pj_file_seek_type whence) { int mode; switch (whence) { case PJ_SEEK_SET: mode = SEEK_SET; break; case PJ_SEEK_CUR: mode = SEEK_CUR; break; case PJ_SEEK_END: mode = SEEK_END; break; default: pj_assert(!""Invalid whence in file_setpos""); return PJ_EINVAL; } if (fseek((FILE*)fd, (long)offset, mode) != 0) return PJ_RETURN_OS_ERROR(errno); return PJ_SUCCESS; }"
"void Gobby::EditCommands::on_can_undo_changed(InfAdoptedUser* user, bool can_undo) { g_assert(m_current_view != NULL); if(INF_ADOPTED_USER(m_current_view->get_active_user()) == user) m_actions.undo->set_enabled(can_undo); }"
"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node, TfLiteDepthwiseConvParams* params, OpData* data, const TfLiteTensor* input, const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output) { float output_activation_min, output_activation_max; CalculateActivationRange(params->activation, &output_activation_min, &output_activation_max); const int batch_size = SizeOfDimension(input, 0); TF_LITE_ENSURE(context, batch_size != 0); const int input_size = NumElements(input) / batch_size; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); int8_t* quantized_input_ptr_batch = input_quantized->data.int8; TfLiteTensor* scaling_factors_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors_tensor)); float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor); TfLiteTensor* input_offset_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_offset_index, &input_offset_tensor)); int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor); for (int b = 0; b < batch_size; ++b) { const int offset = b * input_size; tensor_utils::AsymmetricQuantizeFloats( GetTensorData<float>(input) + offset, input_size, quantized_input_ptr_batch + offset, &scaling_factors_ptr[b], &input_offset_ptr[b]); } DepthwiseParams op_params; op_params.padding_type = PaddingType::kSame; op_params.padding_values.width = data->padding.width; op_params.padding_values.height = data->padding.height; op_params.stride_width = params->stride_width; op_params.stride_height = params->stride_height; op_params.dilation_width_factor = params->dilation_width_factor; op_params.dilation_height_factor = params->dilation_height_factor; op_params.depth_multiplier = params->depth_multiplier; op_params.weights_offset = 0; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params); if (kernel_type == kReference) { reference_integer_ops::DepthwiseConvHybridPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), GetTensorData<int8>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), affine_quantization->scale->data, input_offset_ptr); } else { optimized_integer_ops::DepthwiseConvHybridPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), GetTensorData<int8>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), affine_quantization->scale->data, input_offset_ptr, CpuBackendContext::GetFromContext(context)); } return kTfLiteOk; }"
"static int tiffcp(TIFF* in, TIFF* out) { uint16 bitspersample = 1, samplesperpixel = 1; uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK; copyFunc cf; uint32 width, length; struct cpTag* p; CopyField(TIFFTAG_IMAGEWIDTH, width); CopyField(TIFFTAG_IMAGELENGTH, length); CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample); CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else CopyField(TIFFTAG_COMPRESSION, compression); TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression); TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric); if (input_compression == COMPRESSION_JPEG) { TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else if (input_photometric == PHOTOMETRIC_YCBCR) { uint16 subsamplinghor,subsamplingver; TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver); if (subsamplinghor!=1 || subsamplingver!=1) { fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"", TIFFFileName(in)); return FALSE; } } if (compression == COMPRESSION_JPEG) { if (input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric); } else if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); else if (input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); } else CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT); if (fillorder != 0) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT); TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); switch (orientation) { case ORIENTATION_BOTRIGHT: case ORIENTATION_RIGHTBOT: TIFFWarning(TIFFFileName(in), ""using bottom-left orientation""); orientation = ORIENTATION_BOTLEFT; case ORIENTATION_LEFTBOT: case ORIENTATION_BOTLEFT: break; case ORIENTATION_TOPRIGHT: case ORIENTATION_RIGHTTOP: default: TIFFWarning(TIFFFileName(in), ""using top-left orientation""); orientation = ORIENTATION_TOPLEFT; case ORIENTATION_LEFTTOP: case ORIENTATION_TOPLEFT: break; } TIFFSetField(out, TIFFTAG_ORIENTATION, orientation); if (outtiled == -1) outtiled = TIFFIsTiled(in); if (outtiled) { if (tilewidth == (uint32) -1) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth); if (tilelength == (uint32) -1) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength); TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth); TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength); } else { if (rowsperstrip == (uint32) 0) { if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) { rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); } if (rowsperstrip > length && rowsperstrip != (uint32)-1) rowsperstrip = length; } else if (rowsperstrip == (uint32) -1) rowsperstrip = length; TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); } if (config != (uint16) -1) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); else CopyField(TIFFTAG_PLANARCONFIG, config); if (samplesperpixel <= 4) CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT); CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT); switch (compression) { case COMPRESSION_JPEG: TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_JBIG: CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII); break; case COMPRESSION_LZW: case COMPRESSION_ADOBE_DEFLATE: case COMPRESSION_DEFLATE: case COMPRESSION_LZMA: case COMPRESSION_ZSTD: case COMPRESSION_WEBP: if (predictor != (uint16)-1) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); else CopyField(TIFFTAG_PREDICTOR, predictor); if (preset != -1) { if (compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE) TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset); else if (compression == COMPRESSION_LZMA) TIFFSetField(out, TIFFTAG_LZMAPRESET, preset); else if (compression == COMPRESSION_ZSTD) TIFFSetField(out, TIFFTAG_ZSTD_LEVEL, preset); else if (compression == COMPRESSION_WEBP) { if (preset == 100) { TIFFSetField(out, TIFFTAG_WEBP_LOSSLESS, TRUE); } else { TIFFSetField(out, TIFFTAG_WEBP_LEVEL, preset); } } } break; case COMPRESSION_CCITTFAX3: case COMPRESSION_CCITTFAX4: if (compression == COMPRESSION_CCITTFAX3) { if (g3opts != (uint32) -1) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); else CopyField(TIFFTAG_GROUP3OPTIONS, g3opts); } else CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG); CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG); CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); break; } { uint32 len32; void** data; if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data)) TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data); } { uint16 ninks; const char* inknames; if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) { TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks); if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) { int inknameslen = strlen(inknames) + 1; const char* cp = inknames; while (ninks > 1) { cp = strchr(cp, '\0'); cp++; inknameslen += (strlen(cp) + 1); ninks--; } TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames); } } } { unsigned short pg0, pg1; if (pageInSeq == 1) { if (pageNum < 0)  { if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); } else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } else { if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) { if (pageNum < 0)  TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } } } for (p = tags; p < &tags[NTAGS]; p++) CopyTag(p->tag, p->count, p->type); cf = pickCopyFunc(in, out, bitspersample, samplesperpixel); return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE); }"
"int compile_def_function( ufunc_T*ufunc, intcheck_return_type, compiletype_T   compile_type, cctx_T*outer_cctx) { char_u*line = NULL; char_u*line_to_free = NULL; char_u*p; char*errormsg = NULL;    cctx_Tcctx; garray_T*instr; intdid_emsg_before = did_emsg; intdid_emsg_silent_before = did_emsg_silent; intret = FAIL; sctx_Tsave_current_sctx = current_sctx; intsave_estack_compiling = estack_compiling; intsave_cmod_flags = cmdmod.cmod_flags; intdo_estack_push; intnew_def_function = FALSE; #ifdef FEAT_PROFILE intprof_lnum = -1; #endif intdebug_lnum = -1; if (ufunc->uf_dfunc_idx > 0) { dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; isn_T*instr_dest = NULL; switch (compile_type) { case CT_PROFILE: #ifdef FEAT_PROFILE instr_dest = dfunc->df_instr_prof; break; #endif case CT_NONE:   instr_dest = dfunc->df_instr; break; case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break; } if (instr_dest != NULL) delete_def_function_contents(dfunc, FALSE); ga_clear_strings(&dfunc->df_var_names); } else { if (add_def_function(ufunc) == FAIL) return FAIL; new_def_function = TRUE; } ufunc->uf_def_status = UF_COMPILING; CLEAR_FIELD(cctx); cctx.ctx_compile_type = compile_type; cctx.ctx_ufunc = ufunc; cctx.ctx_lnum = -1; cctx.ctx_outer = outer_cctx; ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10); ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50); ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10); cctx.ctx_type_list = &ufunc->uf_type_list; ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50); instr = &cctx.ctx_instr; current_sctx = ufunc->uf_script_ctx; current_sctx.sc_version = SCRIPT_VERSION_VIM9; cmdmod.cmod_flags &= ~CMOD_LEGACY; do_estack_push = !estack_top_is_ufunc(ufunc, 1); if (do_estack_push) estack_push_ufunc(ufunc, 1); estack_compiling = TRUE; if (check_args_shadowing(ufunc, &cctx) == FAIL) goto erret; if (ufunc->uf_def_args.ga_len > 0) { intcount = ufunc->uf_def_args.ga_len; intfirst_def_arg = ufunc->uf_args.ga_len - count; inti; char_u*arg; intoff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0); intdid_set_arg_type = FALSE; SOURCING_LNUM = 0;  for (i = 0; i < count; ++i) { type_T*val_type; intarg_idx = first_def_arg + i; where_Twhere = WHERE_INIT; intr; intjump_instr_idx = instr->ga_len; isn_T*isn; if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL) goto erret; ufunc->uf_args_visible = arg_idx; arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i]; r = compile_expr0(&arg, &cctx); if (r == FAIL) goto erret; val_type = get_type_on_stack(&cctx, 0); where.wt_index = arg_idx + 1; if (ufunc->uf_arg_types[arg_idx] == &t_unknown) { did_set_arg_type = TRUE; ufunc->uf_arg_types[arg_idx] = val_type; } else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx], -1, where, &cctx, FALSE, FALSE) == FAIL) goto erret; if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL) goto erret; isn = ((isn_T *)instr->ga_data) + jump_instr_idx; isn->isn_arg.jumparg.jump_where = instr->ga_len; } if (did_set_arg_type) set_function_type(ufunc); } ufunc->uf_args_visible = ufunc->uf_args.ga_len; for (;;) { exarg_T    ea; int    starts_with_colon = FALSE; char_u    *cmd; cmdmod_T    local_cmdmod; if (did_emsg_before != did_emsg) goto erret; if (line != NULL && *line == '|') ++line; else if (line != NULL && *skipwhite(line) != NUL && !(*line == '#' && (line == cctx.ctx_line_start || VIM_ISWHITE(line[-1])))) { semsg(_(e_trailing_characters_str), line); goto erret; } else if (line != NULL && vim9_bad_comment(skipwhite(line))) goto erret; else { line = next_line_from_context(&cctx, FALSE); if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len) { #ifdef FEAT_PROFILE if (cctx.ctx_skip != SKIP_YES) may_generate_prof_end(&cctx, prof_lnum); #endif break; } if (line != NULL) { line = vim_strsave(line); vim_free(line_to_free); line_to_free = line; } } CLEAR_FIELD(ea); ea.cmdlinep = &line; ea.cmd = skipwhite(line); if (*ea.cmd == '#') { line = (char_u *)""""; continue; } #ifdef FEAT_PROFILE if (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum && cctx.ctx_skip != SKIP_YES) { may_generate_prof_end(&cctx, prof_lnum); prof_lnum = cctx.ctx_lnum; generate_instr(&cctx, ISN_PROF_START); } #endif if (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum && cctx.ctx_skip != SKIP_YES) { debug_lnum = cctx.ctx_lnum; generate_instr_debug(&cctx); } cctx.ctx_prev_lnum = cctx.ctx_lnum + 1; switch (*ea.cmd) { case '}': { scopetype_T stype = cctx.ctx_scope == NULL ? NO_SCOPE : cctx.ctx_scope->se_type; if (stype == BLOCK_SCOPE) { compile_endblock(&cctx); line = ea.cmd; } else { emsg(_(e_using_rcurly_outside_if_block_scope)); goto erret; } if (line != NULL) line = skipwhite(ea.cmd + 1); continue; } case '{': if (ends_excmd(*skipwhite(ea.cmd + 1))) { line = compile_block(ea.cmd, &cctx); continue; } break; } cctx.ctx_has_cmdmod = FALSE; if (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE) == FAIL) { if (errormsg != NULL) goto erret; line = (char_u *)""""; continue; } generate_cmdmods(&cctx, &local_cmdmod); undo_cmdmod(&local_cmdmod); for (p = ea.cmd; p >= line; --p) { if (*p == ':') starts_with_colon = TRUE; if (p < ea.cmd && !VIM_ISWHITE(*p)) break; } p = ea.cmd; if (!(local_cmdmod.cmod_flags & CMOD_LEGACY)) { if (checkforcmd(&ea.cmd, ""call"", 3)) { if (*ea.cmd == '(') ea.cmd = p; else ea.cmd = skipwhite(ea.cmd); } if (!starts_with_colon) { int    assign; assign = may_compile_assignment(&ea, &line, &cctx); if (assign == OK) goto nextline; if (assign == FAIL) goto erret; } } cmd = ea.cmd; if ((*cmd != '$' || starts_with_colon) && (starts_with_colon || !(*cmd == '\'' || (cmd[0] != NUL && cmd[0] == cmd[1] && (*cmd == '+' || *cmd == '-'))))) { ea.cmd = skip_range(ea.cmd, TRUE, NULL); if (ea.cmd > cmd) { if (!starts_with_colon && !(local_cmdmod.cmod_flags & CMOD_LEGACY)) { semsg(_(e_colon_required_before_range_str), cmd); goto erret; } ea.addr_count = 1; if (ends_excmd2(line, ea.cmd)) { generate_EXEC(&cctx, ISN_EXECRANGE, vim_strnsave(cmd, ea.cmd - cmd)); line = ea.cmd; goto nextline; } } } p = find_ex_command(&ea, NULL, starts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY) ? NULL : item_exists, &cctx); if (p == NULL) { if (cctx.ctx_skip != SKIP_YES) emsg(_(e_ambiguous_use_of_user_defined_command)); goto erret; } if (local_cmdmod.cmod_flags & CMOD_LEGACY) { char_u *start = ea.cmd; switch (ea.cmdidx) { case CMD_if: case CMD_elseif: case CMD_else: case CMD_endif: case CMD_for: case CMD_endfor: case CMD_continue: case CMD_break: case CMD_while: case CMD_endwhile: case CMD_try: case CMD_catch: case CMD_finally: case CMD_endtry: semsg(_(e_cannot_use_legacy_with_command_str), ea.cmd); goto erret; default: break; } if (checkforcmd(&start, ""return"", 4)) ea.cmdidx = CMD_return; else ea.cmdidx = CMD_legacy; } if (p == ea.cmd && ea.cmdidx != CMD_SIZE) { if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval) { line += STRLEN(line); goto nextline; } else if (ea.cmdidx != CMD_eval) { semsg(_(e_command_not_recognized_str), ea.cmd); goto erret; } } if (cctx.ctx_had_return && ea.cmdidx != CMD_elseif && ea.cmdidx != CMD_else && ea.cmdidx != CMD_endif && ea.cmdidx != CMD_endfor && ea.cmdidx != CMD_endwhile && ea.cmdidx != CMD_catch && ea.cmdidx != CMD_finally && ea.cmdidx != CMD_endtry) { emsg(_(e_unreachable_code_after_return)); goto erret; } p = skipwhite(p); if (ea.cmdidx != CMD_SIZE && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read) { if (ea.cmdidx >= 0) ea.argt = excmd_get_argt(ea.cmdidx); if ((ea.argt & EX_BANG) && *p == '!') { ea.forceit = TRUE; p = skipwhite(p + 1); } } switch (ea.cmdidx) { case CMD_def: case CMD_function: ea.arg = p; line = compile_nested_function(&ea, &cctx, &line_to_free); break; case CMD_return: line = compile_return(p, check_return_type, local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx); cctx.ctx_had_return = TRUE; break; case CMD_let: emsg(_(e_cannot_use_let_in_vim9_script)); break; case CMD_var: case CMD_final: case CMD_const: case CMD_increment: case CMD_decrement: line = compile_assignment(p, &ea, ea.cmdidx, &cctx); if (line == p) line = NULL; break; case CMD_unlet: case CMD_unlockvar: case CMD_lockvar: line = compile_unletlock(p, &ea, &cctx); break; case CMD_import: emsg(_(e_import_can_only_be_used_in_script)); line = NULL; break; case CMD_if: line = compile_if(p, &cctx); break; case CMD_elseif: line = compile_elseif(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_else: line = compile_else(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_endif: line = compile_endif(p, &cctx); break; case CMD_while: line = compile_while(p, &cctx); break; case CMD_endwhile: line = compile_endwhile(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_for: line = compile_for(p, &cctx); break; case CMD_endfor: line = compile_endfor(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_continue: line = compile_continue(p, &cctx); break; case CMD_break: line = compile_break(p, &cctx); break; case CMD_try: line = compile_try(p, &cctx); break; case CMD_catch: line = compile_catch(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_finally: line = compile_finally(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_endtry: line = compile_endtry(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_throw: line = compile_throw(p, &cctx); break; case CMD_eval: line = compile_eval(p, &cctx); break; case CMD_echo: case CMD_echon: case CMD_execute: case CMD_echomsg: case CMD_echoerr: case CMD_echoconsole: line = compile_mult_expr(p, ea.cmdidx, &cctx); break; case CMD_put: ea.cmd = cmd; line = compile_put(p, &ea, &cctx); break; case CMD_substitute: if (check_global_and_subst(ea.cmd, p) == FAIL) goto erret; if (cctx.ctx_skip == SKIP_YES) line = (char_u *)""""; else { ea.arg = p; line = compile_substitute(line, &ea, &cctx); } break; case CMD_redir: ea.arg = p; line = compile_redir(line, &ea, &cctx); break; case CMD_cexpr: case CMD_lexpr: case CMD_caddexpr: case CMD_laddexpr: case CMD_cgetexpr: case CMD_lgetexpr: #ifdef FEAT_QUICKFIX ea.arg = p; line = compile_cexpr(line, &ea, &cctx); #else ex_ni(&ea); line = NULL; #endif break; case CMD_append: case CMD_change: case CMD_insert: case CMD_k: case CMD_t: case CMD_xit: not_in_vim9(&ea); goto erret; case CMD_SIZE: if (cctx.ctx_skip != SKIP_YES) { semsg(_(e_invalid_command_str), ea.cmd); goto erret; } line = (char_u *)""""; break; case CMD_lua: case CMD_mzscheme: case CMD_perl: case CMD_py3: case CMD_python3: case CMD_python: case CMD_pythonx: case CMD_ruby: case CMD_tcl: ea.arg = p; if (vim_strchr(line, '\n') == NULL) line = compile_exec(line, &ea, &cctx); else line = compile_script(line, &cctx); break; case CMD_global: if (check_global_and_subst(ea.cmd, p) == FAIL) goto erret; default: ea.arg = p; line = compile_exec(line, &ea, &cctx); break; } nextline: if (line == NULL) goto erret; line = skipwhite(line); generate_undo_cmdmods(&cctx); if (cctx.ctx_type_stack.ga_len < 0) { iemsg(""Type stack underflow""); goto erret; } } if (cctx.ctx_scope != NULL) { if (cctx.ctx_scope->se_type == IF_SCOPE) emsg(_(e_missing_endif)); else if (cctx.ctx_scope->se_type == WHILE_SCOPE) emsg(_(e_missing_endwhile)); else if (cctx.ctx_scope->se_type == FOR_SCOPE) emsg(_(e_missing_endfor)); else emsg(_(e_missing_rcurly)); goto erret; } if (!cctx.ctx_had_return) { if (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN) ufunc->uf_ret_type = &t_void; else if (ufunc->uf_ret_type->tt_type != VAR_VOID) { emsg(_(e_missing_return_statement)); goto erret; } generate_instr(&cctx, ISN_RETURN_VOID); } if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before) { dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; dfunc->df_deleted = FALSE; dfunc->df_script_seq = current_sctx.sc_seq; #ifdef FEAT_PROFILE if (cctx.ctx_compile_type == CT_PROFILE) { dfunc->df_instr_prof = instr->ga_data; dfunc->df_instr_prof_count = instr->ga_len; } else #endif if (cctx.ctx_compile_type == CT_DEBUG) { dfunc->df_instr_debug = instr->ga_data; dfunc->df_instr_debug_count = instr->ga_len; } else { dfunc->df_instr = instr->ga_data; dfunc->df_instr_count = instr->ga_len; } dfunc->df_varcount = dfunc->df_var_names.ga_len; dfunc->df_has_closure = cctx.ctx_has_closure; if (cctx.ctx_outer_used) ufunc->uf_flags |= FC_CLOSURE; ufunc->uf_def_status = UF_COMPILED; } ret = OK; erret: if (ufunc->uf_def_status == UF_COMPILING) { dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; clear_instr_ga(instr); VIM_CLEAR(dfunc->df_name); ga_clear_strings(&dfunc->df_var_names); if (!dfunc->df_deleted && new_def_function && ufunc->uf_dfunc_idx == def_functions.ga_len - 1) { --def_functions.ga_len; ufunc->uf_dfunc_idx = 0; } ufunc->uf_def_status = UF_COMPILE_ERROR; while (cctx.ctx_scope != NULL) drop_scope(&cctx); if (errormsg != NULL) emsg(errormsg); else if (did_emsg == did_emsg_before) emsg(_(e_compiling_def_function_failed)); } if (cctx.ctx_redir_lhs.lhs_name != NULL) { if (ret == OK) { emsg(_(e_missing_redir_end)); ret = FAIL; } vim_free(cctx.ctx_redir_lhs.lhs_name); vim_free(cctx.ctx_redir_lhs.lhs_whole); } current_sctx = save_current_sctx; estack_compiling = save_estack_compiling; cmdmod.cmod_flags =save_cmod_flags; if (do_estack_push) estack_pop(); vim_free(line_to_free); free_imported(&cctx); free_locals(&cctx); ga_clear(&cctx.ctx_type_stack); return ret; }"
"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) { int i; if (!bin) { return NULL; } RList *segments = r_list_newf (free); for (i = 0; i < bin->ne_header->SegCount; i++) { RBinSection *bs = R_NEW0 (RBinSection); NE_image_segment_entry *se = &bin->segment_entries[i]; if (!bs) { return segments; } bs->size = se->length; bs->vsize = se->minAllocSz ? se->minAllocSz : 64000; bs->bits = R_SYS_BITS_16; bs->is_data = se->flags & IS_DATA; bs->perm = __translate_perms (se->flags); bs->paddr = (ut64)se->offset * bin->alignment; bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr); bs->is_segment = true; r_list_append (segments, bs); } bin->segments = segments; return segments; }"
"AP4_CttsAtom::AP4_CttsAtom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_CTTS, size, version, flags) { m_LookupCache.sample      = 0; m_LookupCache.entry_index = 0; AP4_UI32 entry_count; stream.ReadUI32(entry_count); m_Entries.SetItemCount(entry_count); unsigned char* buffer = new unsigned char[entry_count*8]; AP4_Result result = stream.Read(buffer, entry_count*8); if (AP4_FAILED(result)) { delete[] buffer; return; } for (unsigned i=0; i<entry_count; i++) { m_Entries[i].m_SampleCount  = AP4_BytesToUInt32BE(&buffer[i*8  ]); AP4_UI32 offset             = AP4_BytesToUInt32BE(&buffer[i*8+4]); m_Entries[i].m_SampleOffset = offset; } delete[] buffer; }"
"void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext) { std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x) { if(ext.remove_emoji) x.Remark = trim(removeEmoji(x.Remark)); nodeRename(x, ext.rename_array, ext); if(ext.add_emoji) x.Remark = addEmoji(x, ext.emoji_array, ext); }); if(ext.sort_flag) { bool failed = true; if(ext.sort_script.size()) { std::string script = ext.sort_script; if(startsWith(script, ""path:"")) script = fileGet(script.substr(5), false); script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx) { try { ctx.eval(script); auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(""compare""); auto comparer = [&](const Proxy &a, const Proxy &b) { if(a.Type == ProxyType::Unknow) return 1; if(b.Type == ProxyType::Unknow) return 0; return compare(a, b); }; std::stable_sort(nodes.begin(), nodes.end(), comparer); failed = false; } catch(qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b) { return a.Remark < b.Remark; }); } }"
"bool operator()(const OpKernelContext* context, typename TTypes<T, 4>::ConstTensor image, typename TTypes<float, 2>::ConstTensor boxes, typename TTypes<int32, 1>::ConstTensor box_index, const string& method_name, float extrapolation_value, typename TTypes<float, 4>::Tensor crops) { const int batch_size = image.dimension(0); const int image_height = image.dimension(1); const int image_width = image.dimension(2); const int num_boxes = crops.dimension(0); const int crop_height = crops.dimension(1); const int crop_width = crops.dimension(2); const int depth = crops.dimension(3); auto CropAndResizePerBox = [&](int start_box, int limit_box) { for (int b = start_box; b < limit_box; ++b) { const float y1 = boxes(b, 0); const float x1 = boxes(b, 1); const float y2 = boxes(b, 2); const float x2 = boxes(b, 3); const int32 b_in = box_index(b); if (!FastBoundsCheck(b_in, batch_size)) { continue; } const float height_scale = (crop_height > 1) ? (y2 - y1) * (image_height - 1) / (crop_height - 1) : 0; const float width_scale = (crop_width > 1) ? (x2 - x1) * (image_width - 1) / (crop_width - 1) : 0; for (int y = 0; y < crop_height; ++y) { const float in_y = (crop_height > 1) ? y1 * (image_height - 1) + y * height_scale : 0.5 * (y1 + y2) * (image_height - 1); if (in_y < 0 || in_y > image_height - 1) { for (int x = 0; x < crop_width; ++x) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } } continue; } if (method_name == ""bilinear"") { const int top_y_index = floorf(in_y); const int bottom_y_index = ceilf(in_y); const float y_lerp = in_y - top_y_index; for (int x = 0; x < crop_width; ++x) { const float in_x = (crop_width > 1) ? x1 * (image_width - 1) + x * width_scale : 0.5 * (x1 + x2) * (image_width - 1); if (in_x < 0 || in_x > image_width - 1) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } continue; } const int left_x_index = floorf(in_x); const int right_x_index = ceilf(in_x); const float x_lerp = in_x - left_x_index; for (int d = 0; d < depth; ++d) { const float top_left(static_cast<float>( image(b_in, top_y_index, left_x_index, d))); const float top_right(static_cast<float>( image(b_in, top_y_index, right_x_index, d))); const float bottom_left(static_cast<float>( image(b_in, bottom_y_index, left_x_index, d))); const float bottom_right(static_cast<float>( image(b_in, bottom_y_index, right_x_index, d))); const float top = top_left + (top_right - top_left) * x_lerp; const float bottom = bottom_left + (bottom_right - bottom_left) * x_lerp; crops(b, y, x, d) = top + (bottom - top) * y_lerp; } } } else {              for (int x = 0; x < crop_width; ++x) { const float in_x = (crop_width > 1) ? x1 * (image_width - 1) + x * width_scale : 0.5 * (x1 + x2) * (image_width - 1); if (in_x < 0 || in_x > image_width - 1) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } continue; } const int closest_x_index = roundf(in_x); const int closest_y_index = roundf(in_y); for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = static_cast<float>( image(b_in, closest_y_index, closest_x_index, d)); } } } } } }; double cost_per_pixel = depth * (Eigen::TensorOpCost::AddCost<float>() * 6 + Eigen::TensorOpCost::MulCost<float>() * 3 + Eigen::TensorOpCost::CastCost<T, float>() * 4) + (Eigen::TensorOpCost::AddCost<float>() * 2 + Eigen::TensorOpCost::AddCost<float>() * 3); if (method_name == ""nearest"") { cost_per_pixel = depth * Eigen::TensorOpCost::CastCost<T, float>() + Eigen::TensorOpCost::AddCost<float>() * 4 + Eigen::TensorOpCost::MulCost<float>() * 4; } const double cost_per_box = crop_height * crop_width * cost_per_pixel; const DeviceBase::CpuWorkerThreads& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); Shard(worker_threads.num_threads, worker_threads.workers, num_boxes, cost_per_box, CropAndResizePerBox); return true; }"
"static void dissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq) { int     offset = 0; int     remain; int     want; guint8  header_type; int     basic_hlen; int     message_hlen; guint32 id; guint32 ts     = 0; guint32 tsd    = 0; int     body_len; guint8  cmd; guint32 src; int     chunk_size; rtmpt_frag_t   *tf; rtmpt_id_t     *ti; rtmpt_packet_t *tp; tvbuff_t       *pktbuf; remain = tvb_reported_length(tvb); if (!remain) return; RTMPT_DEBUG(""Segment: cdir=%d seq=%d-%d\n"", cdir, seq, seq+remain-1); if (pinfo->fd->visited) { wmem_stack_t *packets; packets = wmem_stack_new(wmem_packet_scope()); wmem_stack_push(packets, 0); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1); while (tp && tp->lastseq >= seq) { wmem_stack_push(packets, tp); if (tp->seq == 0) { break; } tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->seq-1); } while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) { if (tp->resident) { pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); } else { pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); } dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } return; } while (remain>0) { tf = NULL; ti = NULL; tp = NULL; if (offset == 0) { tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1); if (tf) { RTMPT_DEBUG(""  tf seq=%d lseq=%d h=%d l=%d\n"", tf->seq, tf->lastseq, tf->have, tf->len); if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) { tf = NULL; } else if (!tf->ishdr) { ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id); if (ti) { tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); } if (tp && tp->chunkwant) { goto unchunk; } tf = NULL; ti = NULL; tp = NULL; } if (tf) { want = tf->len - tf->have; if (remain<want) want = remain; tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want); id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) { if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) { tf->len += 4; } } tf->have += want; tf->lastseq = seq+want-1; remain -= want; offset += want; if (tf->have < tf->len) { return; } } } } if (!tf) { id = tvb_get_guint8(tvb, offset); if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) { header_type = 4; basic_hlen = 1; message_hlen = 0; id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2; } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) { header_type = 4; basic_hlen = 0; message_hlen = 0; id = RTMPT_TYPE_HANDSHAKE_3; } else { header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = rtmpt_message_header_length(id); if ((header_type < 3) && (remain >= (basic_hlen+3))) { if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) { message_hlen += 4; } } if (remain < (basic_hlen+message_hlen)) { tf = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf->ishdr = 1; tf->seq = seq + offset; tf->lastseq = tf->seq + remain - 1; tf->len = basic_hlen + message_hlen; tvb_memcpy(tvb, tf->saved.d, offset, remain); tf->have = remain; wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf); return; } id = id & 0x3f; if (id == 0) id = tvb_get_guint8(tvb, offset+1) + 64; else if (id == 1) id = tvb_get_letohs(tvb, offset+1) + 64; } } else { id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = tf->len - basic_hlen; id = id & 0x3f; if (id == 0) id = tf->saved.d[1] + 64; else if (id == 1) id = pletoh16(tf->saved.d+1) + 64; } if (id <= RTMPT_ID_MAX) ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id); if (ti) tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); if (header_type == 0) src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7); else if (ti) src = ti->src; else src = 0; if (header_type < 2) cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6); else if (ti) cmd = ti->cmd; else cmd = 0; if (id > RTMPT_ID_MAX) { if (id == RTMPT_TYPE_HANDSHAKE_1) chunk_size = body_len = 1536; else if (id == RTMPT_TYPE_HANDSHAKE_2) chunk_size = body_len = 3072; else  chunk_size = body_len = 1536; } else { chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1)); if (!chunk_size) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE; if (header_type < 2) body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3); else if (ti) body_len = ti->len; else body_len = chunk_size; if (body_len > (gint)rtmpt_max_packet_size) { return; } } if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) { RTMPT_DEBUG(""New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); if (!ti) { ti = wmem_new(wmem_file_scope(), rtmpt_id_t); ti->packets = wmem_tree_new(wmem_file_scope()); ti->ts  = 0; ti->tsd = 0; wmem_tree_insert32(rconv->ids[cdir], id, ti); } if (header_type == 0) { ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (ts == 0xffffff) { ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11); } tsd = ts - ti->ts; } else if (header_type < 3) { tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (tsd == 0xffffff) { ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4); tsd = ti->tsd;  } else { ts  = ti->ts + tsd; } } else { ts  = ti->ts + ti->tsd; tsd = ti->tsd; } tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t); tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset; tp->have       = 0; tp->want       = basic_hlen + message_hlen + body_len; tp->chunkwant  = 0; tp->chunkhave  = 0; tp->bhlen      = basic_hlen; tp->mhlen      = message_hlen; tp->fmt        = header_type; tp->id         = id; tp->ts         = ts; tp->len        = body_len; if (id > RTMPT_ID_MAX) tp->cmd = id; else tp->cmd = cmd & 0x7f; tp->src        = src; tp->txid       = 0; tp->isresponse = FALSE; tp->otherframe = 0; ti->ts  = ts; ti->tsd = tsd; ti->len = body_len; ti->cmd = cmd; ti->src = src; wmem_tree_insert32(ti->packets, tp->seq, tp); if (!tf && body_len <= chunk_size && tp->want <= remain) { tp->resident    = FALSE; tp->data.offset = offset; tp->lastseq     = seq+offset+tp->want-1; tp->have        = tp->want; wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); offset += tp->want; remain -= tp->want; continue; } else { tp->resident = TRUE; tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len); if (tf && tf->ishdr) { memcpy(tp->data.p, tf->saved.d, tf->len); } else { tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen); offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tp->lastseq = seq+offset-1; tp->have = basic_hlen + message_hlen; if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); continue; } tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; } } else { if (header_type == 3 && tp->resident && tp->have > tp->bhlen + 3 && pntoh24(tp->data.p+tp->bhlen) == 0xffffff) { message_hlen += 4; } RTMPT_DEBUG(""Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tf = NULL; unchunk: want = tp->chunkwant - tp->chunkhave; if (want > remain) want = remain; RTMPT_DEBUG(""  cw=%d ch=%d r=%d w=%d\n"", tp->chunkwant, tp->chunkhave, remain, want); tvb_memcpy(tvb, tp->data.p+tp->have, offset, want); if (tf) { tf->have += want; tf->lastseq = seq+offset+want-1; } tp->lastseq = seq+offset+want-1; tp->have += want; tp->chunkhave += want; offset += want; remain -= want; if (tp->chunkhave == tp->chunkwant) { tp->chunkhave = 0; tp->chunkwant = 0; } if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } else if (tp->chunkhave < tp->chunkwant) { rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf2->ishdr    = 0; tf2->seq      = seq + offset - want; tf2->lastseq  = tf2->seq + remain - 1 + want; tf2->have     = tp->chunkhave; tf2->len      = tp->chunkwant; tf2->saved.id = tp->id; RTMPT_DEBUG(""  inserting tf @ %d\n"", seq+offset-want-1); wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2); } } }"
"int ksmbd_smb2_check_message(struct ksmbd_work *work) { struct smb2_pdu *pdu = ksmbd_req_buf_next(work); struct smb2_hdr *hdr = &pdu->hdr; int command; __u32 clc_len;   __u32 len = get_rfc1002_len(work->request_buf); if (le32_to_cpu(hdr->NextCommand) > 0) len = le32_to_cpu(hdr->NextCommand); else if (work->next_smb2_rcv_hdr_off) len -= work->next_smb2_rcv_hdr_off; if (check_smb2_hdr(hdr)) return 1; if (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) { ksmbd_debug(SMB, ""Illegal structure size %u\n"", le16_to_cpu(hdr->StructureSize)); return 1; } command = le16_to_cpu(hdr->Command); if (command >= NUMBER_OF_SMB2_COMMANDS) { ksmbd_debug(SMB, ""Illegal SMB2 command %d\n"", command); return 1; } if (smb2_req_struct_sizes[command] != pdu->StructureSize2) { if (command != SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) { ksmbd_debug(SMB, ""Illegal request size %u for command %d\n"", le16_to_cpu(pdu->StructureSize2), command); return 1; } else if (command == SMB2_OPLOCK_BREAK_HE && hdr->Status == 0 && le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 && le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) { ksmbd_debug(SMB, ""Illegal request size %d for oplock break\n"", le16_to_cpu(pdu->StructureSize2)); return 1; } } if (smb2_calc_size(hdr, &clc_len)) return 1; if (len != clc_len) { if (clc_len == len + 1) goto validate_credit; if (ALIGN(clc_len, 8) == len) goto validate_credit; if (command == SMB2_NEGOTIATE_HE) goto validate_credit; if (clc_len < len && (len - clc_len) <= 8) goto validate_credit; pr_err_ratelimited( ""cli req too short, len %d not %d. cmd:%d mid:%llu\n"", len, clc_len, command, le64_to_cpu(hdr->MessageId)); return 1; } validate_credit: if ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) && smb2_validate_credit_charge(work->conn, hdr)) { work->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER); return 1; } return 0; }"
"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf) { DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         long    outlen = sizeof(Jp2BoxHeader) ;         long    inlen = sizeof(Jp2BoxHeader) ;         enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata); Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_; uint32_t      length = getLong((byte*)&pBox->length, bigEndian); enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata); uint32_t      count  = sizeof (Jp2BoxHeader); char*         p      = (char*) boxBuf.pData_; bool          bWroteColor = false ; while ( count < length || !bWroteColor ) { enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata); Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ; Jp2BoxHeader   subBox = *pSubBox ; Jp2BoxHeader   newBox =  subBox; if ( count < length ) { subBox.length = getLong((byte*)&subBox.length, bigEndian); subBox.type   = getLong((byte*)&subBox.type  , bigEndian); #ifdef EXIV2_DEBUG_MESSAGES std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl; #endif enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata); enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata); count        += subBox.length; newBox.type   = subBox.type; } else { subBox.length=0; newBox.type = kJp2BoxTypeColorHeader; count = length; } uint32_t newlen = subBox.length; if ( newBox.type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined() ) { const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid""; uint32_t    psize = 15; newlen            = sizeof(newBox) + psize ; enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ul2Data((byte*)&newBox.length,psize      ,bigEndian); ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)); ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         ); } else { const char* pad   = ""\x02\x00\x00""; uint32_t    psize = 3; newlen            = sizeof(newBox) + psize + iccProfile_.size_; enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ul2Data((byte*)&newBox.length,newlen,bigEndian); ul2Data((byte*)&newBox.type,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  ); ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           ); ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_); } } else { enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length); } outlen += newlen; inlen  += subBox.length; } outBuf.alloc(outlen); ::memcpy(outBuf.pData_,output.pData_,outlen); pBox   = (Jp2BoxHeader*) outBuf.pData_; ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian); ul2Data((byte*)&pBox->length,outlen,bigEndian); }"
"static int io_tee(struct io_kiocb *req, unsigned int issue_flags) { struct io_splice *sp = &req->splice; struct file *out = sp->file_out; unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED; struct file *in; long ret = 0; if (issue_flags & IO_URING_F_NONBLOCK) return -EAGAIN; in = io_file_get(req->ctx, req, sp->splice_fd_in, (sp->flags & SPLICE_F_FD_IN_FIXED)); if (!in) { ret = -EBADF; goto done; } if (sp->len) ret = do_tee(in, out, sp->len, flags); if (!(sp->flags & SPLICE_F_FD_IN_FIXED)) io_put_file(in); done: if (ret != sp->len) req_set_fail(req); io_req_complete(req, ret); return 0; }"
"static void rtps_util_add_typeobject(proto_tree *tree, packet_info * pinfo, tvbuff_t * tvb, gint offset, const guint encoding, guint32 size, type_mapping * type_mapping_object ) { proto_tree * typeobject_tree; gint offset_tmp = 0; guint32 member_id = 0, member_length = 0; guint32 long_number; guint64 type_id; typeobject_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_rtps_type_object, NULL, ""Type Object""); rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; rtps_util_add_type_library(typeobject_tree, pinfo, tvb, offset_tmp, encoding, member_length); offset += member_length; rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; rtps_util_add_type_id(typeobject_tree, tvb, offset_tmp, encoding, offset, -1, NULL, &type_id); if (type_mapping_object) type_mapping_object->type_id = type_id; offset = offset + member_length; long_number = tvb_get_guint32(tvb, offset, encoding); if ((long_number & PID_LIST_END) != PID_LIST_END) { expert_add_info_format(pinfo, typeobject_tree, &ei_rtps_parameter_value_invalid, ""This should be PID_LIST_END and it is not""); \ } }"
"static void get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info, ASS_Vector *pos, ASS_Vector *pos_o, ASS_DVector *offset, bool first, int flags) { if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip) { ass_cache_dec_ref(info->outline); return; } double m1[3][3], m2[3][3], m[3][3]; const ASS_Transform *tr = &info->transform; calc_transform_matrix(render_priv, info, m1); for (int i = 0; i < 3; i++) { m2[i][0] = m1[i][0] * tr->scale.x; m2[i][1] = m1[i][1] * tr->scale.y; m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2]; } memcpy(m, m2, sizeof(m)); BitmapHashKey key; key.outline = info->outline; if (!quantize_transform(m, pos, offset, first, &key)) { ass_cache_dec_ref(info->outline); return; } info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv); if (!info->bm || !info->bm->buffer) { ass_cache_dec_ref(info->bm); info->bm = NULL; } *pos_o = *pos; OutlineHashKey ol_key; if (flags & FILTER_BORDER_STYLE_3) { if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW))) return; ol_key.type = OUTLINE_BOX; double w = 64 * render_priv->border_scale; ASS_DVector bord = { info->border_x * w, info->border_y * w }; double width = info->hspacing_scaled + info->advance.x; double height = info->asc + info->desc; ASS_DVector orig_scale; orig_scale.x = info->scale_x * info->scale_fix; orig_scale.y = info->scale_y * info->scale_fix; bord.x *= orig_scale.x; bord.y *= orig_scale.y; width  *= orig_scale.x; height *= orig_scale.y; bord.x = FFMAX(64, bord.x); bord.y = FFMAX(64, bord.y); ASS_DVector scale = { (width  + 2 * bord.x) / 64, (height + 2 * bord.y) / 64, }; ASS_DVector offset = { -bord.x, -bord.y - info->asc }; for (int i = 0; i < 3; i++) { m[i][0] = m1[i][0] * scale.x; m[i][1] = m1[i][1] * scale.y; m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2]; } } else { if (!(flags & FILTER_NONZERO_BORDER)) return; ol_key.type = OUTLINE_BORDER; BorderHashKey *k = &ol_key.u.border; k->outline = info->outline; double w = 64 * render_priv->border_scale; double bord_x = w * info->border_x / tr->scale.x; double bord_y = w * info->border_y / tr->scale.y; const ASS_Rect *bbox = &info->outline->cbox; double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64); double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64); double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]); double myx = fabs(m[1][0]), myy = fabs(m[1][1]); double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]); double z0 = m[2][2] - mzx * dx - mzy * dy; w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE); double x_lim = mxx * dx + mxy * dy; double y_lim = myx * dx + myy * dy; double rz = FFMAX(x_lim, y_lim) * w; w *= STROKER_PRECISION / POSITION_PRECISION; frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x); frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y); k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION); k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION); if (!k->border.x && !k->border.y) { ass_cache_inc_ref(info->bm); info->bm_o = info->bm; return; } for (int i = 0; i < 3; i++) { m[i][0] = ldexp(m2[i][0], -k->scale_ord_x); m[i][1] = ldexp(m2[i][1], -k->scale_ord_y); m[i][2] = m2[i][2]; } } key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv); if (!key.outline || !key.outline->valid || !quantize_transform(m, pos_o, offset, false, &key)) { ass_cache_dec_ref(key.outline); return; } info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv); if (!info->bm_o || !info->bm_o->buffer) { ass_cache_dec_ref(info->bm_o); info->bm_o = NULL; *pos_o = *pos; } else if (!info->bm) *pos = *pos_o; }"
"int amf_namf_comm_handle_n1_n2_message_transfer( ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg) { int status; amf_ue_t *amf_ue = NULL; amf_sess_t *sess = NULL; ogs_pkbuf_t *n1buf = NULL; ogs_pkbuf_t *n2buf = NULL; ogs_pkbuf_t *gmmbuf = NULL; ogs_pkbuf_t *ngapbuf = NULL; char *supi = NULL; uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED; ogs_sbi_message_t sendmsg; ogs_sbi_response_t *response = NULL; OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData; OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData; OpenAPI_n1_message_container_t *n1MessageContainer = NULL; OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL; OpenAPI_n2_info_container_t *n2InfoContainer = NULL; OpenAPI_n2_sm_information_t *smInfo = NULL; OpenAPI_n2_info_content_t *n2InfoContent = NULL; OpenAPI_ref_to_binary_data_t *ngapData = NULL; ogs_assert(stream); ogs_assert(recvmsg); N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData; if (!N1N2MessageTransferReqData) { ogs_error(""No N1N2MessageTransferReqData""); return OGS_ERROR; } if (N1N2MessageTransferReqData->is_pdu_session_id == false) { ogs_error(""No PDU Session Identity""); return OGS_ERROR; } pdu_session_id = N1N2MessageTransferReqData->pdu_session_id; supi = recvmsg->h.resource.component[1]; if (!supi) { ogs_error(""No SUPI""); return OGS_ERROR; } amf_ue = amf_ue_find_by_supi(supi); if (!amf_ue) { ogs_error(""No UE context [%s]"", supi); return OGS_ERROR; } sess = amf_sess_find_by_psi(amf_ue, pdu_session_id); if (!sess) { ogs_error(""[%s] No PDU Session Context [%d]"", amf_ue->supi, pdu_session_id); return OGS_ERROR; } n1MessageContainer = N1N2MessageTransferReqData->n1_message_container; if (n1MessageContainer) { n1MessageContent = n1MessageContainer->n1_message_content; if (!n1MessageContent || !n1MessageContent->content_id) { ogs_error(""No n1MessageContent""); return OGS_ERROR; } n1buf = ogs_sbi_find_part_by_content_id( recvmsg, n1MessageContent->content_id); if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } n1buf = ogs_pkbuf_copy(n1buf); ogs_assert(n1buf); } n2InfoContainer = N1N2MessageTransferReqData->n2_info_container; if (n2InfoContainer) { smInfo = n2InfoContainer->sm_info; if (!smInfo) { ogs_error(""No smInfo""); return OGS_ERROR; } n2InfoContent = smInfo->n2_info_content; if (!n2InfoContent) { ogs_error(""No n2InfoContent""); return OGS_ERROR; } ngapData = n2InfoContent->ngap_data; if (!ngapData || !ngapData->content_id) { ogs_error(""No ngapData""); return OGS_ERROR; } n2buf = ogs_sbi_find_part_by_content_id( recvmsg, ngapData->content_id); if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } n2buf = ogs_pkbuf_copy(n2buf); ogs_assert(n2buf); } memset(&sendmsg, 0, sizeof(sendmsg)); status = OGS_SBI_HTTP_STATUS_OK; memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData)); N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED; sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData; switch (n2InfoContent->ngap_ie_type) { case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); } if (gmmbuf) { ran_ue_t *ran_ue = NULL; ran_ue = ran_ue_cycle(amf_ue->ran_ue); ogs_assert(ran_ue); if (sess->pdu_session_establishment_accept) { ogs_pkbuf_free(sess->pdu_session_establishment_accept); sess->pdu_session_establishment_accept = NULL; } if (ran_ue->initial_context_setup_request_sent == true) { ngapbuf = ngap_sess_build_pdu_session_resource_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); } else { ngapbuf = ngap_sess_build_initial_context_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); ran_ue->initial_context_setup_request_sent = true; } if (SESSION_CONTEXT_IN_SMF(sess)) { if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { sess->pdu_session_establishment_accept = ngapbuf; } } else { if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; ogs_sbi_client_t *client = NULL; ogs_sockaddr_t *addr = NULL; if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) { ogs_error(""[%s:%d] No n1-n2-failure-notification-uri"", amf_ue->supi, sess->psi); return OGS_ERROR; } addr = ogs_sbi_getaddr_from_uri( N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); if (!addr) { ogs_error(""[%s:%d] Invalid URI [%s]"", amf_ue->supi, sess->psi, N1N2MessageTransferReqData-> n1n2_failure_txf_notif_uri); return OGS_ERROR;; } client = ogs_sbi_client_find(addr); if (!client) { client = ogs_sbi_client_add(addr); ogs_assert(client); } OGS_SETUP_SBI_CLIENT(&sess->paging, client); ogs_freeaddrinfo(addr); status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); AMF_SESS_STORE_N2_TRANSFER( sess, pdu_session_resource_setup_request, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { ogs_assert(OGS_OK == ngap_send_pdu_resource_setup_request(sess, n2buf)); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } } break; case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ: if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, NULL); AMF_SESS_STORE_5GSM_MESSAGE(sess, OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND, n1buf, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); ngapbuf = ngap_build_pdu_session_resource_modify_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) ogs_pkbuf_free(n1buf); if (CM_IDLE(amf_ue)) { if (n2buf) ogs_pkbuf_free(n2buf); if (N1N2MessageTransferReqData->is_skip_ind == true && N1N2MessageTransferReqData->skip_ind == true) { N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED; } else { ogs_fatal(""[%s] No skipInd"", amf_ue->supi); ogs_assert_if_reached(); } } else if (CM_CONNECTED(amf_ue)) { ngapbuf = ngap_build_pdu_session_resource_release_command( sess, NULL, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; default: ogs_error(""Not implemented ngap_ie_type[%d]"", n2InfoContent->ngap_ie_type); ogs_assert_if_reached(); } response = ogs_sbi_build_response(&sendmsg, status); ogs_assert(response); ogs_assert(true == ogs_sbi_server_send_response(stream, response)); if (sendmsg.http.location) ogs_free(sendmsg.http.location); return OGS_OK; }"
"static int check_chain_extensions(X509_STORE_CTX *ctx) { int i, must_be_ca, plen = 0; X509 *x; int proxy_path_length = 0; int purpose; int allow_proxy_certs; int num = sk_X509_num(ctx->chain); must_be_ca = -1; if (ctx->parent) { allow_proxy_certs = 0; purpose = X509_PURPOSE_CRL_SIGN; } else { allow_proxy_certs = ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS); purpose = ctx->param->purpose; } for (i = 0; i < num; i++) { int ret; x = sk_X509_value(ctx->chain, i); if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) && (x->ex_flags & EXFLAG_CRITICAL)) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION)) return 0; } if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED)) return 0; } ret = X509_check_ca(x); switch (must_be_ca) { case -1: if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && (ret != 1) && (ret != 0)) { ret = 0; ctx->error = X509_V_ERR_INVALID_CA; } else ret = 1; break; case 0: if (ret != 0) { ret = 0; ctx->error = X509_V_ERR_INVALID_NON_CA; } else ret = 1; break; default: if ((ret == 0) || ((i + 1 < num || ctx->param->flags & X509_V_FLAG_X509_STRICT) && (ret != 1))) { ret = 0; ctx->error = X509_V_ERR_INVALID_CA; } else ret = 1; break; } if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) { ret = check_curve(x); if (ret < 0) ctx->error = X509_V_ERR_UNSPECIFIED; else if (ret == 0) ctx->error = X509_V_ERR_EC_KEY_EXPLICIT_PARAMS; } if ((x->ex_flags & EXFLAG_CA) == 0 && x->ex_pathlen != -1 && (ctx->param->flags & X509_V_FLAG_X509_STRICT)) { ctx->error = X509_V_ERR_INVALID_EXTENSION; ret = 0; } if (ret == 0 && !verify_cb_cert(ctx, x, i, X509_V_OK)) return 0; if (purpose > 0 && !check_purpose(ctx, x, purpose, i, must_be_ca)) return 0; if ((i > 1) && (x->ex_pathlen != -1) && (plen > (x->ex_pathlen + proxy_path_length))) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PATH_LENGTH_EXCEEDED)) return 0; } if (i > 0 && (x->ex_flags & EXFLAG_SI) == 0) plen++; if (x->ex_flags & EXFLAG_PROXY) { if (x->ex_pcpathlen != -1) { if (proxy_path_length > x->ex_pcpathlen) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED)) return 0; } proxy_path_length = x->ex_pcpathlen; } proxy_path_length++; must_be_ca = 0; } else must_be_ca = 1; } return 1; }"
"int main(int argc, char *argv[]) { struct libmnt_table *tb = NULL; char **tabfiles = NULL; int direction = MNT_ITER_FORWARD; int verify = 0; int c, rc = -1, timeout = -1; int ntabfiles = 0, tabtype = 0; char *outarg = NULL; size_t i; int force_tree = 0, istree = 0; struct libscols_table *table = NULL; enum { FINDMNT_OPT_VERBOSE = CHAR_MAX + 1, FINDMNT_OPT_TREE, FINDMNT_OPT_OUTPUT_ALL, FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL, FINDMNT_OPT_VFS_ALL, FINDMNT_OPT_SHADOWED, FINDMNT_OPT_DELETED, }; static const struct option longopts[] = { { ""all"",    no_argument,       NULL, 'A' }, { ""ascii"",    no_argument,       NULL, 'a' }, { ""bytes"",    no_argument,       NULL, 'b' }, { ""canonicalize"",   no_argument,       NULL, 'c' }, { ""deleted"",        no_argument,       NULL, FINDMNT_OPT_DELETED }, { ""direction"",    required_argument, NULL, 'd' }, { ""df"",    no_argument,       NULL, 'D' }, { ""evaluate"",    no_argument,       NULL, 'e' }, { ""first-only"",    no_argument,       NULL, 'f' }, { ""fstab"",    no_argument,       NULL, 's' }, { ""help"",    no_argument,       NULL, 'h' }, { ""invert"",    no_argument,       NULL, 'i' }, { ""json"",    no_argument,       NULL, 'J' }, { ""kernel"",    no_argument,       NULL, 'k' }, { ""list"",    no_argument,       NULL, 'l' }, { ""mountpoint"",    required_argument, NULL, 'M' }, { ""mtab"",    no_argument,       NULL, 'm' }, { ""noheadings"",    no_argument,       NULL, 'n' }, { ""notruncate"",    no_argument,       NULL, 'u' }, { ""options"",    required_argument, NULL, 'O' }, { ""output"",    required_argument, NULL, 'o' }, { ""output-all"",    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL }, { ""poll"",    optional_argument, NULL, 'p' }, { ""pairs"",    no_argument,       NULL, 'P' }, { ""raw"",    no_argument,       NULL, 'r' }, { ""types"",    required_argument, NULL, 't' }, { ""nocanonicalize"", no_argument,       NULL, 'C' }, { ""nofsroot"",    no_argument,       NULL, 'v' }, { ""submounts"",    no_argument,       NULL, 'R' }, { ""source"",    required_argument, NULL, 'S' }, { ""tab-file"",    required_argument, NULL, 'F' }, { ""task"",    required_argument, NULL, 'N' }, { ""target"",    required_argument, NULL, 'T' }, { ""timeout"",    required_argument, NULL, 'w' }, { ""uniq"",    no_argument,       NULL, 'U' }, { ""verify"",    no_argument,       NULL, 'x' }, { ""version"",    no_argument,       NULL, 'V' }, { ""verbose"",    no_argument,       NULL, FINDMNT_OPT_VERBOSE }, { ""tree"",    no_argument,       NULL, FINDMNT_OPT_TREE }, { ""real"",    no_argument,       NULL, FINDMNT_OPT_REAL }, { ""pseudo"",    no_argument,       NULL, FINDMNT_OPT_PSEUDO }, { ""vfs-all"",    no_argument,       NULL, FINDMNT_OPT_VFS_ALL }, { ""shadowed"",       no_argument,       NULL, FINDMNT_OPT_SHADOWED }, { NULL, 0, NULL, 0 } }; static const ul_excl_t excl[] = { { 'C', 'c'}, { 'C', 'e' }, { 'J', 'P', 'r','x' }, { 'M', 'T' }, { 'N','k','m','s' }, { 'P','l','r','x' }, { 'p','x' }, { 'm','p','s' }, { FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL }, { 0 } }; int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT; setlocale(LC_ALL, """"); bindtextdomain(PACKAGE, LOCALEDIR); textdomain(PACKAGE); close_stdout_atexit(); flags |= FL_TREE; while ((c = getopt_long(argc, argv, ""AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx"", longopts, NULL)) != -1) { err_exclusive_options(c, longopts, excl, excl_st); switch(c) { case 'A': flags |= FL_ALL; break; case 'a': flags |= FL_ASCII; break; case 'b': flags |= FL_BYTES; break; case 'C': flags |= FL_NOCACHE; break; case 'c': flags |= FL_CANONICALIZE; break; case 'D': flags &= ~FL_TREE; flags |= FL_DF; break; case 'd': if (!strcmp(optarg, ""forward"")) direction = MNT_ITER_FORWARD; else if (!strcmp(optarg, ""backward"")) direction = MNT_ITER_BACKWARD; else errx(EXIT_FAILURE, _(""unknown direction '%s'""), optarg); break; case 'e': flags |= FL_EVALUATE; break; case 'i': flags |= FL_INVERT; break; case 'J': flags |= FL_JSON; break; case 'f': flags |= FL_FIRSTONLY; break; case 'F': tabfiles = append_tabfile(tabfiles, &ntabfiles, optarg); break; case 'u': disable_columns_truncate(); break; case 'o': outarg = optarg; break; case FINDMNT_OPT_OUTPUT_ALL: for (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) { if (is_tabdiff_column(ncolumns)) continue; columns[ncolumns] = ncolumns; } break; case 'O': set_match(COL_OPTIONS, optarg); break; case 'p': if (optarg) { nactions = string_to_idarray(optarg, actions, ARRAY_SIZE(actions), poll_action_name_to_id); if (nactions < 0) exit(EXIT_FAILURE); } flags |= FL_POLL; flags &= ~FL_TREE; break; case 'P': flags |= FL_EXPORT; flags &= ~FL_TREE; break; case 'm': tabtype = TABTYPE_MTAB; flags &= ~FL_TREE; break; case 's': tabtype = TABTYPE_FSTAB; flags &= ~FL_TREE; break; case 'k': tabtype = TABTYPE_KERNEL; break; case 't': set_match(COL_FSTYPE, optarg); break; case 'r': flags &= ~FL_TREE; flags |= FL_RAW; break; case 'l': flags &= ~FL_TREE; break; case 'n': flags |= FL_NOHEADINGS; break; case 'N': tabtype = TABTYPE_KERNEL; tabfiles = append_pid_tabfile(tabfiles, &ntabfiles, strtou32_or_err(optarg, _(""invalid TID argument""))); break; case 'v': flags |= FL_NOFSROOT; break; case 'R': flags |= FL_SUBMOUNTS; break; case 'S': set_source_match(optarg); flags |= FL_NOSWAPMATCH; break; case 'M': flags |= FL_STRICTTARGET; case 'T': set_match(COL_TARGET, optarg); flags |= FL_NOSWAPMATCH; break; case 'U': flags |= FL_UNIQ; break; case 'w': timeout = strtos32_or_err(optarg, _(""invalid timeout argument"")); break; case 'x': verify = 1; break; case FINDMNT_OPT_VERBOSE: flags |= FL_VERBOSE; break; case FINDMNT_OPT_TREE: force_tree = 1; break; case FINDMNT_OPT_PSEUDO: flags |= FL_PSEUDO; break; case FINDMNT_OPT_REAL: flags |= FL_REAL; break; case FINDMNT_OPT_VFS_ALL: flags |= FL_VFS_ALL; break; case FINDMNT_OPT_SHADOWED: flags |= FL_SHADOWED; break; case FINDMNT_OPT_DELETED: flags |= FL_DELETED; break; case 'h': usage(); case 'V': print_version(EXIT_SUCCESS); default: errtryhelp(EXIT_FAILURE); } } if (!ncolumns && (flags & FL_DF)) { add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_SIZE); add_column(columns, ncolumns++, COL_USED); add_column(columns, ncolumns++, COL_AVAIL); add_column(columns, ncolumns++, COL_USEPERC); add_column(columns, ncolumns++, COL_TARGET); } if (!ncolumns) { if (flags & FL_POLL) add_column(columns, ncolumns++, COL_ACTION); add_column(columns, ncolumns++, COL_TARGET); add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_OPTIONS); } if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns), &ncolumns, column_name_to_id) < 0) return EXIT_FAILURE; if (!tabtype) tabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL; if ((flags & FL_POLL) && ntabfiles > 1) errx(EXIT_FAILURE, _(""--poll accepts only one file, but more specified by --tab-file"")); if (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET))) errx(EXIT_FAILURE, _( ""options --target and --source can't be used together "" ""with command line element that is not an option"")); if (optind < argc) set_source_match(argv[optind++]); if (optind < argc) set_match(COL_TARGET, argv[optind++]); if ((flags & FL_SUBMOUNTS) && is_listall_mode()) flags &= ~FL_SUBMOUNTS; if (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY) || get_match(COL_TARGET) || get_match(COL_SOURCE) || get_match(COL_MAJMIN))) flags &= ~FL_TREE; if (!(flags & FL_NOSWAPMATCH) && !get_match(COL_TARGET) && get_match(COL_SOURCE)) { const char *x = get_match(COL_SOURCE); if (!strncmp(x, ""LABEL="", 6) || !strncmp(x, ""UUID="", 5) || !strncmp(x, ""PARTLABEL="", 10) || !strncmp(x, ""PARTUUID="", 9)) flags |= FL_NOSWAPMATCH; } mnt_init_debug(0); tb = parse_tabfiles(tabfiles, ntabfiles, tabtype); if (!tb) goto leave; if (tabtype == TABTYPE_MTAB && tab_is_kernel(tb)) tabtype = TABTYPE_KERNEL; istree = tab_is_tree(tb); if (istree && force_tree) flags |= FL_TREE; if ((flags & FL_TREE) && (ntabfiles > 1 || !istree)) flags &= ~FL_TREE; if (!(flags & FL_NOCACHE)) { cache = mnt_new_cache(); if (!cache) { warn(_(""failed to initialize libmount cache"")); goto leave; } mnt_table_set_cache(tb, cache); if (tabtype != TABTYPE_KERNEL) cache_set_targets(cache); } if (flags & FL_UNIQ) mnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp); if (verify) { rc = verify_table(tb); goto leave; } scols_init_debug(0); table = scols_new_table(); if (!table) { warn(_(""failed to allocate output table"")); goto leave; } scols_table_enable_raw(table,        !!(flags & FL_RAW)); scols_table_enable_export(table,     !!(flags & FL_EXPORT)); scols_table_enable_json(table,       !!(flags & FL_JSON)); scols_table_enable_ascii(table,      !!(flags & FL_ASCII)); scols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS)); if (flags & FL_JSON) scols_table_set_name(table, ""filesystems""); for (i = 0; i < ncolumns; i++) { struct libscols_column *cl; int fl = get_column_flags(i); int id = get_column_id(i); if (!(flags & FL_TREE)) fl &= ~SCOLS_FL_TREE; if (!(flags & FL_POLL) && is_tabdiff_column(id)) { warnx(_(""%s column is requested, but --poll "" ""is not enabled""), get_column_name(i)); goto leave; } cl = scols_table_new_column(table, get_column_name(i), get_column_whint(i), fl); if (!cl){ warn(_(""failed to allocate output column"")); goto leave; } if (fl & SCOLS_FL_WRAP) { scols_column_set_wrapfunc(cl, scols_wrapnl_chunksize, scols_wrapnl_nextchunk, NULL); scols_column_set_safechars(cl, ""\n""); } if (flags & FL_JSON) { switch (id) { case COL_SIZE: case COL_AVAIL: case COL_USED: if (!(flags & FL_BYTES)) break; case COL_ID: case COL_PARENT: case COL_FREQ: case COL_PASSNO: case COL_TID: scols_column_set_json_type(cl, SCOLS_JSON_NUMBER); break; case COL_DELETED: scols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN); break; default: if (fl & SCOLS_FL_WRAP) scols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING); else scols_column_set_json_type(cl, SCOLS_JSON_STRING); break; } } } if (flags & FL_POLL) { rc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction); } else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) { rc = create_treenode(table, tb, NULL, NULL); } else { rc = add_matching_lines(tb, table, direction); if (rc != 0 && tabtype == TABTYPE_KERNEL && (flags & FL_NOSWAPMATCH) && !(flags & FL_STRICTTARGET) && get_match(COL_TARGET)) { enable_extra_target_match(tb); rc = add_matching_lines(tb, table, direction); } } if (!rc && !(flags & FL_POLL)) scols_print_table(table); leave: scols_unref_table(table); mnt_unref_table(tb); mnt_unref_cache(cache); free(tabfiles); #ifdef HAVE_LIBUDEV udev_unref(udev); #endif return rc ? EXIT_FAILURE : EXIT_SUCCESS; }"
"NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId, size_t* pcbAvPairListRemaining) { size_t cbAvPair = cbAvPairList; NTLM_AV_PAIR* pAvPair = pAvPairList; if (!ntlm_av_pair_check(pAvPair, cbAvPair)) pAvPair = NULL; while (pAvPair) { UINT16 id = ntlm_av_pair_get_id(pAvPair); if (id == AvId) break; if (id == MsvAvEOL) { pAvPair = NULL; break; } pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair); } if (!pAvPair) cbAvPair = 0; if (pcbAvPairListRemaining) *pcbAvPairListRemaining = cbAvPair; return pAvPair; }"
"void* __iotc_calloc(size_t num, size_t byte_count) { const size_t size_to_allocate = num * byte_count; void* ret = iotc_bsp_mem_alloc(size_to_allocate); if (NULL != ret) { memset(ret, 0, size_to_allocate); } return ret; }"
"static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data) { int rv; ssize_t size; sgwc_event_t *e = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_pfcp_node_t *node = NULL; ogs_pfcp_header_t *h = NULL; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recvfrom() failed""); ogs_pkbuf_free(pkbuf); return; } ogs_pkbuf_trim(pkbuf, size); h = (ogs_pfcp_header_t *)pkbuf->data; if (h->version > OGS_PFCP_VERSION) { ogs_pfcp_header_t rsp; ogs_error(""Not supported version[%d]"", h->version); memset(&rsp, 0, sizeof rsp); rsp.flags = (OGS_PFCP_VERSION << 5); rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE; rsp.length = htobe16(4); rsp.sqn_only = h->sqn_only; if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(pkbuf); return; } e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE); ogs_assert(e); node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from); if (!node) { node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from); ogs_assert(node); node->sock = data; pfcp_node_fsm_init(node, false); } e->pfcp_node = node; e->pkbuf = pkbuf; rv = ogs_queue_push(ogs_app()->queue, e); if (rv != OGS_OK) { ogs_error(""ogs_queue_push() failed:%d"", (int)rv); ogs_pkbuf_free(e->pkbuf); sgwc_event_free(e); } }"
