Unnamed: 0,Access Gained,Attack Origin,Authentication Required,Availability,CVE ID,CVE Page,CWE ID,Complexity,Confidentiality,Integrity,Known Exploits,Publish Date,Score,Summary,Update Date,Vulnerability Classification,add_lines,codeLink,commit_id,commit_message,del_lines,file_name,files_changed,func_after,func_before,lang,lines_after,lines_before,parentID,patch,project,project_after,project_before,vul,vul_func_with_fix
21115,,Local Network,Single system,Complete,CVE-2012-1179,https://www.cvedetails.com/cve/CVE-2012-1179/,CWE-264,Medium,,,,2012-05-17,5.2,"The Linux kernel before 3.3.1, when KVM is used, allows guest OS users to cause a denial of service (host OS crash) by leveraging administrative access to the guest OS, related to the pmd_none_or_clear_bad function and page faults for huge pages.",2017-12-28,DoS ,0,https://github.com/torvalds/linux/commit/4a1d704194a441bf83c636004a479e01360ec850,4a1d704194a441bf83c636004a479e01360ec850,"mm: thp: fix pmd_bad() triggering in code paths holding mmap_sem read mode

commit 1a5a9906d4e8d1976b701f889d8f35d54b928f25 upstream.

In some cases it may happen that pmd_none_or_clear_bad() is called with
the mmap_sem hold in read mode.  In those cases the huge page faults can
allocate hugepmds under pmd_none_or_clear_bad() and that can trigger a
false positive from pmd_bad() that will not like to see a pmd
materializing as trans huge.

It's not khugepaged causing the problem, khugepaged holds the mmap_sem
in write mode (and all those sites must hold the mmap_sem in read mode
to prevent pagetables to go away from under them, during code review it
seems vm86 mode on 32bit kernels requires that too unless it's
restricted to 1 thread per process or UP builds).  The race is only with
the huge pagefaults that can convert a pmd_none() into a
pmd_trans_huge().

Effectively all these pmd_none_or_clear_bad() sites running with
mmap_sem in read mode are somewhat speculative with the page faults, and
the result is always undefined when they run simultaneously.  This is
probably why it wasn't common to run into this.  For example if the
madvise(MADV_DONTNEED) runs zap_page_range() shortly before the page
fault, the hugepage will not be zapped, if the page fault runs first it
will be zapped.

Altering pmd_bad() not to error out if it finds hugepmds won't be enough
to fix this, because zap_pmd_range would then proceed to call
zap_pte_range (which would be incorrect if the pmd become a
pmd_trans_huge()).

The simplest way to fix this is to read the pmd in the local stack
(regardless of what we read, no need of actual CPU barriers, only
compiler barrier needed), and be sure it is not changing under the code
that computes its value.  Even if the real pmd is changing under the
value we hold on the stack, we don't care.  If we actually end up in
zap_pte_range it means the pmd was not none already and it was not huge,
and it can't become huge from under us (khugepaged locking explained
above).

All we need is to enforce that there is no way anymore that in a code
path like below, pmd_trans_huge can be false, but pmd_none_or_clear_bad
can run into a hugepmd.  The overhead of a barrier() is just a compiler
tweak and should not be measurable (I only added it for THP builds).  I
don't exclude different compiler versions may have prevented the race
too by caching the value of *pmd on the stack (that hasn't been
verified, but it wouldn't be impossible considering
pmd_none_or_clear_bad, pmd_bad, pmd_trans_huge, pmd_none are all inlines
and there's no external function called in between pmd_trans_huge and
pmd_none_or_clear_bad).

		if (pmd_trans_huge(*pmd)) {
			if (next-addr != HPAGE_PMD_SIZE) {
				VM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));
				split_huge_page_pmd(vma->vm_mm, pmd);
			} else if (zap_huge_pmd(tlb, vma, pmd, addr))
				continue;
			/* fall through */
		}
		if (pmd_none_or_clear_bad(pmd))

Because this race condition could be exercised without special
privileges this was reported in CVE-2012-1179.

The race was identified and fully explained by Ulrich who debugged it.
I'm quoting his accurate explanation below, for reference.

====== start quote =======
      mapcount 0 page_mapcount 1
      kernel BUG at mm/huge_memory.c:1384!

    At some point prior to the panic, a ""bad pmd ..."" message similar to the
    following is logged on the console:

      mm/memory.c:145: bad pmd ffff8800376e1f98(80000000314000e7).

    The ""bad pmd ..."" message is logged by pmd_clear_bad() before it clears
    the page's PMD table entry.

        143 void pmd_clear_bad(pmd_t *pmd)
        144 {
    ->  145         pmd_ERROR(*pmd);
        146         pmd_clear(pmd);
        147 }

    After the PMD table entry has been cleared, there is an inconsistency
    between the actual number of PMD table entries that are mapping the page
    and the page's map count (_mapcount field in struct page). When the page
    is subsequently reclaimed, __split_huge_page() detects this inconsistency.

       1381         if (mapcount != page_mapcount(page))
       1382                 printk(KERN_ERR ""mapcount %d page_mapcount %d\n"",
       1383                        mapcount, page_mapcount(page));
    -> 1384         BUG_ON(mapcount != page_mapcount(page));

    The root cause of the problem is a race of two threads in a multithreaded
    process. Thread B incurs a page fault on a virtual address that has never
    been accessed (PMD entry is zero) while Thread A is executing an madvise()
    system call on a virtual address within the same 2 MB (huge page) range.

               virtual address space
              .---------------------.
              |                     |
              |                     |
            .-|---------------------|
            | |                     |
            | |                     |<-- B(fault)
            | |                     |
      2 MB  | |/////////////////////|-.
      huge <  |/////////////////////|  > A(range)
      page  | |/////////////////////|-'
            | |                     |
            | |                     |
            '-|---------------------|
              |                     |
              |                     |
              '---------------------'

    - Thread A is executing an madvise(..., MADV_DONTNEED) system call
      on the virtual address range ""A(range)"" shown in the picture.

    sys_madvise
      // Acquire the semaphore in shared mode.
      down_read(&current->mm->mmap_sem)
      ...
      madvise_vma
        switch (behavior)
        case MADV_DONTNEED:
             madvise_dontneed
               zap_page_range
                 unmap_vmas
                   unmap_page_range
                     zap_pud_range
                       zap_pmd_range
                         //
                         // Assume that this huge page has never been accessed.
                         // I.e. content of the PMD entry is zero (not mapped).
                         //
                         if (pmd_trans_huge(*pmd)) {
                             // We don't get here due to the above assumption.
                         }
                         //
                         // Assume that Thread B incurred a page fault and
             .---------> // sneaks in here as shown below.
             |           //
             |           if (pmd_none_or_clear_bad(pmd))
             |               {
             |                 if (unlikely(pmd_bad(*pmd)))
             |                     pmd_clear_bad
             |                     {
             |                       pmd_ERROR
             |                         // Log ""bad pmd ..."" message here.
             |                       pmd_clear
             |                         // Clear the page's PMD entry.
             |                         // Thread B incremented the map count
             |                         // in page_add_new_anon_rmap(), but
             |                         // now the page is no longer mapped
             |                         // by a PMD entry (-> inconsistency).
             |                     }
             |               }
             |
             v
    - Thread B is handling a page fault on virtual address ""B(fault)"" shown
      in the picture.

    ...
    do_page_fault
      __do_page_fault
        // Acquire the semaphore in shared mode.
        down_read_trylock(&mm->mmap_sem)
        ...
        handle_mm_fault
          if (pmd_none(*pmd) && transparent_hugepage_enabled(vma))
              // We get here due to the above assumption (PMD entry is zero).
              do_huge_pmd_anonymous_page
                alloc_hugepage_vma
                  // Allocate a new transparent huge page here.
                ...
                __do_huge_pmd_anonymous_page
                  ...
                  spin_lock(&mm->page_table_lock)
                  ...
                  page_add_new_anon_rmap
                    // Here we increment the page's map count (starts at -1).
                    atomic_set(&page->_mapcount, 0)
                  set_pmd_at
                    // Here we set the page's PMD entry which will be cleared
                    // when Thread A calls pmd_clear_bad().
                  ...
                  spin_unlock(&mm->page_table_lock)

    The mmap_sem does not prevent the race because both threads are acquiring
    it in shared mode (down_read).  Thread B holds the page_table_lock while
    the page's map count and PMD table entry are updated.  However, Thread A
    does not synchronize on that lock.

====== end quote =======

[akpm@linux-foundation.org: checkpatch fixes]
Reported-by: Ulrich Obergfell <uobergfe@redhat.com>
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Acked-by: Johannes Weiner <hannes@cmpxchg.org>
Cc: Mel Gorman <mgorman@suse.de>
Cc: Hugh Dickins <hughd@google.com>
Cc: Dave Jones <davej@redhat.com>
Acked-by: Larry Woodman <lwoodman@redhat.com>
Acked-by: Rik van Riel <riel@redhat.com>
Cc: Mark Salter <msalter@redhat.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",0,mm/memcontrol.c,"{""sha"": ""328cb37bb827915ccc3e87cc6518acd7ccf25686"", ""filename"": ""arch/x86/kernel/vm86_32.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/arch/x86/kernel/vm86_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/arch/x86/kernel/vm86_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/vm86_32.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -172,6 +172,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \tspinlock_t *ptl;\n \tint i;\n \n+\tdown_write(&mm->mmap_sem);\n \tpgd = pgd_offset(mm, 0xA0000);\n \tif (pgd_none_or_clear_bad(pgd))\n \t\tgoto out;\n@@ -190,6 +191,7 @@ static void mark_screen_rdonly(struct mm_struct *mm)\n \t}\n \tpte_unmap_unlock(pte, ptl);\n out:\n+\tup_write(&mm->mmap_sem);\n \tflush_tlb();\n }\n ""}<_**next**_>{""sha"": ""3efa7253523e77c7a07d47d340f6df7a88deb741"", ""filename"": ""fs/proc/task_mmu.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/fs/proc/task_mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/fs/proc/task_mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/task_mmu.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -409,6 +409,9 @@ static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \t} else {\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n+\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \t/*\n \t * The mmap_sem held all the way back in m_start() is what\n \t * keeps khugepaged out of here and from collapsing things\n@@ -507,6 +510,8 @@ static int clear_refs_pte_range(pmd_t *pmd, unsigned long addr,\n \tstruct page *page;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n@@ -670,6 +675,8 @@ static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n \tint err = 0;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \t/* find the first VMA at or above 'addr' */\n \tvma = find_vma(walk->mm, addr);\n@@ -961,6 +968,8 @@ static int gather_pte_stats(pmd_t *pmd, unsigned long addr,\n \t\tspin_unlock(&walk->mm->page_table_lock);\n \t}\n \n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \torig_pte = pte = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n \tdo {\n \t\tstruct page *page = can_gather_numa_stats(*pte, md->vma, addr);""}<_**next**_>{""sha"": ""a03c098b0cce94e06c87e022fb33f9e19b8f89cb"", ""filename"": ""include/asm-generic/pgtable.h"", ""status"": ""modified"", ""additions"": 61, ""deletions"": 0, ""changes"": 61, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/include/asm-generic/pgtable.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/include/asm-generic/pgtable.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/asm-generic/pgtable.h?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -425,6 +425,8 @@ extern void untrack_pfn_vma(struct vm_area_struct *vma, unsigned long pfn,\n \t\t\t\tunsigned long size);\n #endif\n \n+#ifdef CONFIG_MMU\n+\n #ifndef CONFIG_TRANSPARENT_HUGEPAGE\n static inline int pmd_trans_huge(pmd_t pmd)\n {\n@@ -441,7 +443,66 @@ static inline int pmd_write(pmd_t pmd)\n \treturn 0;\n }\n #endif /* __HAVE_ARCH_PMD_WRITE */\n+#endif /* CONFIG_TRANSPARENT_HUGEPAGE */\n+\n+/*\n+ * This function is meant to be used by sites walking pagetables with\n+ * the mmap_sem hold in read mode to protect against MADV_DONTNEED and\n+ * transhuge page faults. MADV_DONTNEED can convert a transhuge pmd\n+ * into a null pmd and the transhuge page fault can convert a null pmd\n+ * into an hugepmd or into a regular pmd (if the hugepage allocation\n+ * fails). While holding the mmap_sem in read mode the pmd becomes\n+ * stable and stops changing under us only if it's not null and not a\n+ * transhuge pmd. When those races occurs and this function makes a\n+ * difference vs the standard pmd_none_or_clear_bad, the result is\n+ * undefined so behaving like if the pmd was none is safe (because it\n+ * can return none anyway). The compiler level barrier() is critically\n+ * important to compute the two checks atomically on the same pmdval.\n+ */\n+static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n+{\n+\t/* depend on compiler for an atomic pmd read */\n+\tpmd_t pmdval = *pmd;\n+\t/*\n+\t * The barrier will stabilize the pmdval in a register or on\n+\t * the stack so that it will stop changing under the code.\n+\t */\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\tbarrier();\n+#endif\n+\tif (pmd_none(pmdval))\n+\t\treturn 1;\n+\tif (unlikely(pmd_bad(pmdval))) {\n+\t\tif (!pmd_trans_huge(pmdval))\n+\t\t\tpmd_clear_bad(pmd);\n+\t\treturn 1;\n+\t}\n+\treturn 0;\n+}\n+\n+/*\n+ * This is a noop if Transparent Hugepage Support is not built into\n+ * the kernel. Otherwise it is equivalent to\n+ * pmd_none_or_trans_huge_or_clear_bad(), and shall only be called in\n+ * places that already verified the pmd is not none and they want to\n+ * walk ptes while holding the mmap sem in read mode (write mode don't\n+ * need this). If THP is not enabled, the pmd can't go away under the\n+ * code even if MADV_DONTNEED runs, but if THP is enabled we need to\n+ * run a pmd_trans_unstable before walking the ptes after\n+ * split_huge_page_pmd returns (because it may have run when the pmd\n+ * become null, but then a page fault can map in a THP and not a\n+ * regular page).\n+ */\n+static inline int pmd_trans_unstable(pmd_t *pmd)\n+{\n+#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n+\treturn pmd_none_or_trans_huge_or_clear_bad(pmd);\n+#else\n+\treturn 0;\n #endif\n+}\n+\n+#endif /* CONFIG_MMU */\n \n #endif /* !__ASSEMBLY__ */\n ""}<_**next**_>{""sha"": ""cd412fc9b802c69a279adaf7d74c4dfcb142f089"", ""filename"": ""mm/memcontrol.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/memcontrol.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/memcontrol.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/memcontrol.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -5234,6 +5234,8 @@ static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n \n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; pte++, addr += PAGE_SIZE)\n@@ -5396,6 +5398,8 @@ static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,\n \tspinlock_t *ptl;\n \n \tsplit_huge_page_pmd(walk->mm, pmd);\n+\tif (pmd_trans_unstable(pmd))\n+\t\treturn 0;\n retry:\n \tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n \tfor (; addr != end; addr += PAGE_SIZE) {""}<_**next**_>{""sha"": ""10b4ddadc37ebca11133a74c8081fcde8e259bae"", ""filename"": ""mm/memory.c"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 4, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/memory.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/memory.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/memory.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -1247,16 +1247,24 @@ static inline unsigned long zap_pmd_range(struct mmu_gather *tlb,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tif (pmd_trans_huge(*pmd)) {\n-\t\t\tif (next-addr != HPAGE_PMD_SIZE) {\n+\t\t\tif (next - addr != HPAGE_PMD_SIZE) {\n \t\t\t\tVM_BUG_ON(!rwsem_is_locked(&tlb->mm->mmap_sem));\n \t\t\t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n \t\t\t} else if (zap_huge_pmd(tlb, vma, pmd, addr))\n-\t\t\t\tcontinue;\n+\t\t\t\tgoto next;\n \t\t\t/* fall through */\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n-\t\t\tcontinue;\n+\t\t/*\n+\t\t * Here there can be other concurrent MADV_DONTNEED or\n+\t\t * trans huge page faults running, and if the pmd is\n+\t\t * none or trans huge it can change under us. This is\n+\t\t * because MADV_DONTNEED holds the mmap_sem in read\n+\t\t * mode.\n+\t\t */\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n+\t\t\tgoto next;\n \t\tnext = zap_pte_range(tlb, vma, pmd, addr, next, details);\n+next:\n \t\tcond_resched();\n \t} while (pmd++, addr = next, addr != end);\n ""}<_**next**_>{""sha"": ""0a3757067631413e97ff1d843364321027be32b2"", ""filename"": ""mm/mempolicy.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/mempolicy.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/mempolicy.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mempolicy.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -512,7 +512,7 @@ static inline int check_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n \t\tsplit_huge_page_pmd(vma->vm_mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tif (check_pte_range(vma, pmd, addr, next, nodes,\n \t\t\t\t    flags, private))""}<_**next**_>{""sha"": ""936b4cee8cb1ee126e7c78672d54062437ba5c45"", ""filename"": ""mm/mincore.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/mincore.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/mincore.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mincore.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -164,7 +164,7 @@ static void mincore_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \t\t\t}\n \t\t\t/* fall through */\n \t\t}\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tmincore_unmapped_range(vma, addr, next, vec);\n \t\telse\n \t\t\tmincore_pte_range(vma, pmd, addr, next, vec);""}<_**next**_>{""sha"": ""aa9701e12714af2ce7ead752def02200910bf2b1"", ""filename"": ""mm/pagewalk.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/pagewalk.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/pagewalk.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/pagewalk.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -59,7 +59,7 @@ static int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\n \t\t\tcontinue;\n \n \t\tsplit_huge_page_pmd(walk->mm, pmd);\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tgoto again;\n \t\terr = walk_pte_range(pmd, addr, next, walk);\n \t\tif (err)""}<_**next**_>{""sha"": ""f31b29d2ca4e5062d889e74bd3f531f092748dad"", ""filename"": ""mm/swapfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 3, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/4a1d704194a441bf83c636004a479e01360ec850/mm/swapfile.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/4a1d704194a441bf83c636004a479e01360ec850/mm/swapfile.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/swapfile.c?ref=4a1d704194a441bf83c636004a479e01360ec850"", ""patch"": ""@@ -932,9 +932,7 @@ static inline int unuse_pmd_range(struct vm_area_struct *vma, pud_t *pud,\n \tpmd = pmd_offset(pud, addr);\n \tdo {\n \t\tnext = pmd_addr_end(addr, end);\n-\t\tif (unlikely(pmd_trans_huge(*pmd)))\n-\t\t\tcontinue;\n-\t\tif (pmd_none_or_clear_bad(pmd))\n+\t\tif (pmd_none_or_trans_huge_or_clear_bad(pmd))\n \t\t\tcontinue;\n \t\tret = unuse_pte_range(vma, pmd, addr, next, entry, page);\n \t\tif (ret)""}","bool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)
{
	int nid;

	/*
	 * quick check...making use of scan_node.
	 * We can skip unused nodes.
	 */
	if (!nodes_empty(memcg->scan_nodes)) {
		for (nid = first_node(memcg->scan_nodes);
		     nid < MAX_NUMNODES;
		     nid = next_node(nid, memcg->scan_nodes)) {

			if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
				return true;
		}
	}
	/*
	 * Check rest of nodes.
	 */
	for_each_node_state(nid, N_HIGH_MEMORY) {
		if (node_isset(nid, memcg->scan_nodes))
			continue;
		if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
			return true;
	}
	return false;
}
","bool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)
{
	int nid;

	/*
	 * quick check...making use of scan_node.
	 * We can skip unused nodes.
	 */
	if (!nodes_empty(memcg->scan_nodes)) {
		for (nid = first_node(memcg->scan_nodes);
		     nid < MAX_NUMNODES;
		     nid = next_node(nid, memcg->scan_nodes)) {

			if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
				return true;
		}
	}
	/*
	 * Check rest of nodes.
	 */
	for_each_node_state(nid, N_HIGH_MEMORY) {
		if (node_isset(nid, memcg->scan_nodes))
			continue;
		if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
			return true;
	}
	return false;
}
",C,,,,"@@ -5234,6 +5234,8 @@ static int mem_cgroup_count_precharge_pte_range(pmd_t *pmd,
 	spinlock_t *ptl;
 
 	split_huge_page_pmd(walk->mm, pmd);
+	if (pmd_trans_unstable(pmd))
+		return 0;
 
 	pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
 	for (; addr != end; pte++, addr += PAGE_SIZE)
@@ -5396,6 +5398,8 @@ static int mem_cgroup_move_charge_pte_range(pmd_t *pmd,
 	spinlock_t *ptl;
 
 	split_huge_page_pmd(walk->mm, pmd);
+	if (pmd_trans_unstable(pmd))
+		return 0;
 retry:
 	pte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);
 	for (; addr != end; addr += PAGE_SIZE) {",linux,4a1d704194a441bf83c636004a479e01360ec850,a998dc2fa76f496d2944f0602b920d1d10d7467d,0,"bool mem_cgroup_reclaimable(struct mem_cgroup *memcg, bool noswap)
{
	int nid;

	/*
	 * quick check...making use of scan_node.
	 * We can skip unused nodes.
	 */
	if (!nodes_empty(memcg->scan_nodes)) {
		for (nid = first_node(memcg->scan_nodes);
		     nid < MAX_NUMNODES;
		     nid = next_node(nid, memcg->scan_nodes)) {

			if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
				return true;
		}
	}
	/*
	 * Check rest of nodes.
	 */
	for_each_node_state(nid, N_HIGH_MEMORY) {
		if (node_isset(nid, memcg->scan_nodes))
			continue;
		if (test_mem_cgroup_node_reclaimable(memcg, nid, noswap))
			return true;
	}
	return false;
}
"
118448,,Remote,Not required,Partial,CVE-2013-6621,https://www.cvedetails.com/cve/CVE-2013-6621/,CWE-399,Low,Partial,Partial,,2013-11-13,7.5,Use-after-free vulnerability in Google Chrome before 31.0.1650.48 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to the x-webkit-speech attribute in a text INPUT element.,2018-10-30,DoS ,0,https://github.com/chromium/chromium/commit/4039d2fcaab746b6c20017ba9bb51c3a2403a76c,4039d2fcaab746b6c20017ba9bb51c3a2403a76c,"Add logging to figure out which IPC we're failing to deserialize in RenderFrame.

BUG=369553
R=creis@chromium.org

Review URL: https://codereview.chromium.org/263833020

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@268565 0039d316-1c4b-4281-b951-d872f2087c98",0,content/renderer/render_frame_impl.cc,"{""sha"": ""2141f47944ee52b0a6335879a24630103e78ca7f"", ""filename"": ""content/renderer/render_frame_impl.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/4039d2fcaab746b6c20017ba9bb51c3a2403a76c/content/renderer/render_frame_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4039d2fcaab746b6c20017ba9bb51c3a2403a76c/content/renderer/render_frame_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_frame_impl.cc?ref=4039d2fcaab746b6c20017ba9bb51c3a2403a76c"", ""patch"": ""@@ -608,6 +608,8 @@ bool RenderFrameImpl::Send(IPC::Message* message) {\n }\n \n bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {\n+  GetContentClient()->SetActiveURL(frame_->document().url());\n+\n   ObserverListBase<RenderFrameObserver>::Iterator it(observers_);\n   RenderFrameObserver* observer;\n   while ((observer = it.GetNext()) != NULL) {\n@@ -658,7 +660,8 @@ bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {\n   if (!msg_is_ok) {\n     // The message had a handler, but its deserialization failed.\n     // Kill the renderer to avoid potential spoofing attacks.\n-    CHECK(false) << \""Unable to deserialize message in RenderFrameImpl.\"";\n+    int id = msg.type();\n+    CHECK(false) << \""Unable to deserialize \"" << id << \"" in RenderFrameImpl.\"";\n   }\n \n   return handled;""}","void RenderFrameImpl::OnSelectRange(const gfx::Point& start,
                                    const gfx::Point& end) {
  Send(new ViewHostMsg_SelectRange_ACK(GetRenderWidget()->routing_id()));

  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
  frame_->selectRange(start, end);
}
","void RenderFrameImpl::OnSelectRange(const gfx::Point& start,
                                    const gfx::Point& end) {
  Send(new ViewHostMsg_SelectRange_ACK(GetRenderWidget()->routing_id()));

  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
  frame_->selectRange(start, end);
}
",C,,,,"@@ -608,6 +608,8 @@ bool RenderFrameImpl::Send(IPC::Message* message) {
 }
 
 bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {
+  GetContentClient()->SetActiveURL(frame_->document().url());
+
   ObserverListBase<RenderFrameObserver>::Iterator it(observers_);
   RenderFrameObserver* observer;
   while ((observer = it.GetNext()) != NULL) {
@@ -658,7 +660,8 @@ bool RenderFrameImpl::OnMessageReceived(const IPC::Message& msg) {
   if (!msg_is_ok) {
     // The message had a handler, but its deserialization failed.
     // Kill the renderer to avoid potential spoofing attacks.
-    CHECK(false) << ""Unable to deserialize message in RenderFrameImpl."";
+    int id = msg.type();
+    CHECK(false) << ""Unable to deserialize "" << id << "" in RenderFrameImpl."";
   }
 
   return handled;",Chrome,4039d2fcaab746b6c20017ba9bb51c3a2403a76c,2b2efbce50b2ede98321526e47a78f50b62604a4,0,"void RenderFrameImpl::OnSelectRange(const gfx::Point& start,
                                    const gfx::Point& end) {
  // This IPC is dispatched by RenderWidgetHost, so use its routing id.
  Send(new ViewHostMsg_SelectRange_ACK(GetRenderWidget()->routing_id()));

  base::AutoReset<bool> handling_select_range(&handling_select_range_, true);
  frame_->selectRange(start, end);
}
"
185353,,Remote,Not required,Partial,CVE-2014-3168,https://www.cvedetails.com/cve/CVE-2014-3168/,,Low,Partial,Partial,,2014-08-26,7.5,"Use-after-free vulnerability in the SVG implementation in Blink, as used in Google Chrome before 37.0.2062.94, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper caching associated with animation.",2018-10-30,DoS ,5,https://github.com/chromium/chromium/commit/f592cf6a66b63decc7e7093b36501229a5de1f1d,f592cf6a66b63decc7e7093b36501229a5de1f1d,"SVG: Moving animating <svg> to other iframe should not crash.

Moving SVGSVGElement with its SMILTimeContainer already started caused crash before this patch.
|SVGDocumentExtentions::startAnimations()| calls begin() against all SMILTimeContainers in the document, but the SMILTimeContainer for <svg> moved from other document may be already started.

BUG=369860

Review URL: https://codereview.chromium.org/290353002

git-svn-id: svn://svn.chromium.org/blink/trunk@174338 bbb929c8-8fbe-4397-9dbb-9b2b20218538",2,third_party/WebKit/Source/core/svg/SVGDocumentExtensions.cpp,"{""sha"": ""11718d2ff0dbdbf5e561a4ee437d17b3b915ff02"", ""filename"": ""third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame-expected.txt"", ""status"": ""added"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame-expected.txt?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -0,0 +1,11 @@\n+Moving animating svg document to other iframe should not crash.\n+\n+On success, you will see a series of \""PASS\"" messages, followed by \""TEST COMPLETE\"".\n+\n+\n+loaded SVG to be moved\n+PASS successfullyParsed is true\n+\n+TEST COMPLETE\n+ \n+Test pass if no crash.""}<_**next**_>{""sha"": ""966d8bb029beb5c78cab4b5be61286addafa7150"", ""filename"": ""third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame.html"", ""status"": ""added"", ""additions"": 21, ""deletions"": 0, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/svg/dom/move-animating-svg-to-other-frame.html?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -0,0 +1,21 @@\n+<script src=\""../../resources/js-test.js\""></script>\n+<script>\n+jsTestIsAsync = true;\n+description(\""Moving animating svg document to other iframe should not crash.\"");\n+\n+var otherSVG = null; // read from resources/import-other-svg.svg\n+function loadedSVGToBeMoved()\n+{\n+    debug(\""loaded SVG to be moved\"");\n+\n+    var source = document.getElementById(\""source\"");\n+    otherSVG = source.contentDocument.documentElement;\n+\n+    var target = document.getElementById(\""target\"");\n+    target.src = \""resources/import-other-svg.svg\"";\n+    target.onload = finishJSTest;\n+}\n+</script>\n+<iframe id=\""source\"" src=\""resources/svg-with-animate.svg\"" onload=\""loadedSVGToBeMoved()\""></iframe>\n+<iframe id=\""target\""></iframe>\n+<p>Test pass if no crash.</p>""}<_**next**_>{""sha"": ""21bc20208728ae976790e72ecd0755758c33c48d"", ""filename"": ""third_party/WebKit/LayoutTests/svg/dom/resources/import-other-svg.svg"", ""status"": ""added"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/resources/import-other-svg.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/resources/import-other-svg.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/svg/dom/resources/import-other-svg.svg?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -0,0 +1,7 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"">\n+  <foreignObject id=\""insertionPoint\"" width=\""500\"" height=\""500\"">\n+  </foreignObject>\n+  <script>\n+    document.getElementById(\""insertionPoint\"").appendChild(window.top.otherSVG);\n+  </script>\n+</svg>""}<_**next**_>{""sha"": ""ae12313c61f970f2081c8e87551e4d13b7703808"", ""filename"": ""third_party/WebKit/LayoutTests/svg/dom/resources/svg-with-animate.svg"", ""status"": ""added"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/resources/svg-with-animate.svg"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/LayoutTests/svg/dom/resources/svg-with-animate.svg"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/svg/dom/resources/svg-with-animate.svg?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -0,0 +1,5 @@\n+<svg xmlns=\""http://www.w3.org/2000/svg\"" xmlns:xlink=\""http://www.w3.org/1999/xlink\"">\n+  <rect x=\""10\"" y=\""10\"" width=\""10\"" height=\""10\"" fill=\""red\"">\n+    <animate attributeName=\""x\"" attributeType=\""XML\"" begin=\""0s\"" dur=\""10s\"" fill=\""freeze\"" from=\""0\"" to=\""100\"" />\n+  </rect>\n+</svg>""}<_**next**_>{""sha"": ""bf28cc21f5f24a112c4381a7a47891f7a2868b6b"", ""filename"": ""third_party/WebKit/Source/core/svg/SVGDocumentExtensions.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/Source/core/svg/SVGDocumentExtensions.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/Source/core/svg/SVGDocumentExtensions.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/svg/SVGDocumentExtensions.cpp?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -111,8 +111,11 @@ void SVGDocumentExtensions::startAnimations()\n     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;\n     timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());\n     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();\n-    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)\n-        (*itr)->timeContainer()->begin();\n+    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr) {\n+        SMILTimeContainer* timeContainer = (*itr)->timeContainer();\n+        if (!timeContainer->isStarted())\n+            timeContainer->begin();\n+    }\n }\n \n void SVGDocumentExtensions::pauseAnimations()""}<_**next**_>{""sha"": ""9ca8626fc78cb5b86ec6037904b9f2c528ea0e1d"", ""filename"": ""third_party/WebKit/Source/core/svg/animation/SMILTimeContainer.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/Source/core/svg/animation/SMILTimeContainer.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f592cf6a66b63decc7e7093b36501229a5de1f1d/third_party/WebKit/Source/core/svg/animation/SMILTimeContainer.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/svg/animation/SMILTimeContainer.cpp?ref=f592cf6a66b63decc7e7093b36501229a5de1f1d"", ""patch"": ""@@ -159,7 +159,7 @@ bool SMILTimeContainer::isStarted() const\n \n void SMILTimeContainer::begin()\n {\n-    ASSERT(!m_beginTime);\n+    RELEASE_ASSERT(!m_beginTime);\n     double now = currentTime();\n \n     // If 'm_presetStartTime' is set, the timeline was modified via setElapsed() before the document began.""}","void SVGDocumentExtensions::startAnimations()
{
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;
     timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();
    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr) {
        SMILTimeContainer* timeContainer = (*itr)->timeContainer();
        if (!timeContainer->isStarted())
            timeContainer->begin();
    }
 }
","void SVGDocumentExtensions::startAnimations()
{
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;
     timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();
    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)
        (*itr)->timeContainer()->begin();
 }
",C,"    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr) {
        SMILTimeContainer* timeContainer = (*itr)->timeContainer();
        if (!timeContainer->isStarted())
            timeContainer->begin();
    }
","    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)
        (*itr)->timeContainer()->begin();
",,"@@ -111,8 +111,11 @@ void SVGDocumentExtensions::startAnimations()
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;
     timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();
-    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)
-        (*itr)->timeContainer()->begin();
+    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr) {
+        SMILTimeContainer* timeContainer = (*itr)->timeContainer();
+        if (!timeContainer->isStarted())
+            timeContainer->begin();
+    }
 }
 
 void SVGDocumentExtensions::pauseAnimations()",Chrome,f592cf6a66b63decc7e7093b36501229a5de1f1d,7ee5c6e42eeda8d2f00210a57c865ddb7ebcda19,1,"void SVGDocumentExtensions::startAnimations()
{
    // FIXME: Eventually every ""Time Container"" will need a way to latch on to some global timer
    // starting animations for a document will do this ""latching""
    // FIXME: We hold a ref pointers to prevent a shadow tree from getting removed out from underneath us.
    // In the future we should refactor the use-element to avoid this. See https://webkit.org/b/53704
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> > timeContainers;
     timeContainers.appendRange(m_timeContainers.begin(), m_timeContainers.end());
     WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator end = timeContainers.end();
//flaw_line_below:
    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr)
//flaw_line_below:
        (*itr)->timeContainer()->begin();
//fix_flaw_line_below:
//    for (WillBeHeapVector<RefPtrWillBeMember<SVGSVGElement> >::iterator itr = timeContainers.begin(); itr != end; ++itr) {
//fix_flaw_line_below:
//        SMILTimeContainer* timeContainer = (*itr)->timeContainer();
//fix_flaw_line_below:
//        if (!timeContainer->isStarted())
//fix_flaw_line_below:
//            timeContainer->begin();
//fix_flaw_line_below:
//    }
 }
"
176600,,Remote,Not required,Partial,CVE-2017-7375,https://www.cvedetails.com/cve/CVE-2017-7375/,CWE-611,Low,Partial,Partial,,2018-02-19,7.5,"A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes). Depending on the context, this may expose a higher-risk attack surface in libxml2 not usually reachable with default parser flags, and expose content from local files, HTTP, or FTP servers (which might be otherwise unreachable).",2018-03-18,,0,https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa,308396a55280f69ad4112d4f9892f4cbeff042aa,"DO NOT MERGE: Add validation for eternal enities

https://bugzilla.gnome.org/show_bug.cgi?id=780691

Bug: 36556310
Change-Id: I9450743e167c3c73af5e4071f3fc85e81d061648
(cherry picked from commit bef9af3d89d241bcb518c20cba6da2a2fd9ba049)
",0,parser.c,"{""filename"": ""parser.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa/parser.c"", ""patch"": ""@@ -8130,6 +8130,14 @@\n\n \t    if (xmlPushInput(ctxt, input) < 0)\n \t\treturn;\n \t} else {\n+\t    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+\t        ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n+\t        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n+\t        (ctxt->replaceEntities == 0) &&\n+\t        (ctxt->validate == 0))\n+\t        return;\n \t    /*\n \t     * TODO !!!\n \t     * handle the extra spaces added before and after\n""}","xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
 return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
}
","xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
 return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
}
",C,,,,"@@ -8130,6 +8130,14 @@

 	    if (xmlPushInput(ctxt, input) < 0)
 		return;
 	} else {
+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+	        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+	        (ctxt->replaceEntities == 0) &&
+	        (ctxt->validate == 0))
+	        return;
 	    /*
 	     * TODO !!!
 	     * handle the extra spaces added before and after
",Android,https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa/,https://android.googlesource.com/platform/external/libxml2/+/308396a55280f69ad4112d4f9892f4cbeff042aa%5E/,0,"xmlParseAttValue(xmlParserCtxtPtr ctxt) {
 if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);
 return(xmlParseAttValueInternal(ctxt, NULL, NULL, 0));
}
"
12362,,Remote,Not required,Partial,CVE-2014-3515,https://www.cvedetails.com/cve/CVE-2014-3515/,,Low,Partial,Partial,,2014-07-09,7.5,"The SPL component in PHP before 5.4.30 and 5.5.x before 5.5.14 incorrectly anticipates that certain data structures will have the array data type after unserialization, which allows remote attackers to execute arbitrary code via a crafted string that triggers use of a Hashtable destructor, related to ""type confusion"" issues in (1) ArrayObject and (2) SPLObjectStorage.",2017-01-06,Exec Code,0,https://git.php.net/?p=php-src.git;a=commit;h=88223c5245e9b470e1e6362bfd96829562ffe6ab,88223c5245e9b470e1e6362bfd96829562ffe6ab,,0,,,"static void spl_array_it_dtor(zend_object_iterator *iter TSRMLS_DC) /* {{{ */
{
	spl_array_it *iterator = (spl_array_it *)iter;

	zend_user_it_invalidate_current(iter TSRMLS_CC);
	zval_ptr_dtor((zval**)&iterator->intern.it.data);

	efree(iterator);
}
/* }}} */
","static void spl_array_it_dtor(zend_object_iterator *iter TSRMLS_DC) /* {{{ */
{
	spl_array_it *iterator = (spl_array_it *)iter;

	zend_user_it_invalidate_current(iter TSRMLS_CC);
	zval_ptr_dtor((zval**)&iterator->intern.it.data);

	efree(iterator);
}
/* }}} */
",C,,,6027c56fd727d2c4b193b96fee19cdbb4a128447,"@@ -1808,7 +1808,7 @@ SPL_METHOD(Array, unserialize)
        ++p;
 
        ALLOC_INIT_ZVAL(pmembers);
-       if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC)) {
+       if (!php_var_unserialize(&pmembers, &p, s + buf_len, &var_hash TSRMLS_CC) || Z_TYPE_P(pmembers) != IS_ARRAY) {
                zval_ptr_dtor(&pmembers);
                goto outexcept;
        }",php,https://git.php.net/?p=php-src.git;a=blob;f=ext/spl/spl_array.c;h=bf034ab248a1a8acf4057ba4a9f1534cd878ba1c;hb=88223c5245e9b470e1e6362bfd96829562ffe6ab,https://git.php.net/?p=php-src.git;a=blob;f=ext/spl/spl_array.c;h=758947a8cc756899a7a4ef70cdfa325e4d09abe5,0,"static void spl_array_it_dtor(zend_object_iterator *iter TSRMLS_DC) /* {{{ */
{
	spl_array_it *iterator = (spl_array_it *)iter;

	zend_user_it_invalidate_current(iter TSRMLS_CC);
	zval_ptr_dtor((zval**)&iterator->intern.it.data);

	efree(iterator);
}
/* }}} */
"
52948,,Local,Not required,Complete,CVE-2016-4565,https://www.cvedetails.com/cve/CVE-2016-4565/,CWE-264,Low,Complete,Complete,,2016-05-23,7.2,"The InfiniBand (aka IB) stack in the Linux kernel before 4.5.3 incorrectly relies on the write system call, which allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a uAPI interface.",2018-01-04,DoS ,0,https://github.com/torvalds/linux/commit/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,"IB/security: Restrict use of the write() interface

The drivers/infiniband stack uses write() as a replacement for
bi-directional ioctl().  This is not safe. There are ways to
trigger write calls that result in the return structure that
is normally written to user space being shunted off to user
specified kernel memory instead.

For the immediate repair, detect and deny suspicious accesses to
the write API.

For long term, update the user space libraries and the kernel API
to something that doesn't present the same security vulnerabilities
(likely a structured ioctl() interface).

The impacted uAPI interfaces are generally only available if
hardware from drivers/infiniband is installed in the system.

Reported-by: Jann Horn <jann@thejh.net>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Jason Gunthorpe <jgunthorpe@obsidianresearch.com>
[ Expanded check to all known write() entry points ]
Cc: stable@vger.kernel.org
Signed-off-by: Doug Ledford <dledford@redhat.com>",0,drivers/infiniband/hw/qib/qib_file_ops.c,"{""sha"": ""7713ef089c3ccc5109045c2ed88455799d740033"", ""filename"": ""drivers/infiniband/core/ucm.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/ucm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/ucm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/ucm.c?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -48,6 +48,7 @@\n \n #include <asm/uaccess.h>\n \n+#include <rdma/ib.h>\n #include <rdma/ib_cm.h>\n #include <rdma/ib_user_cm.h>\n #include <rdma/ib_marshall.h>\n@@ -1103,6 +1104,9 @@ static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n \tstruct ib_ucm_cmd_hdr hdr;\n \tssize_t result;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""c0f3826abb30aa09d755650d5055610679c846c8"", ""filename"": ""drivers/infiniband/core/ucma.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/ucma.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/ucma.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/ucma.c?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -1574,6 +1574,9 @@ static ssize_t ucma_write(struct file *filp, const char __user *buf,\n \tstruct rdma_ucm_cmd_hdr hdr;\n \tssize_t ret;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (len < sizeof(hdr))\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""31f422a70623a5df98f94acc90a6f6a2d598c2bc"", ""filename"": ""drivers/infiniband/core/uverbs_main.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/uverbs_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/core/uverbs_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/uverbs_main.c?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -48,6 +48,8 @@\n \n #include <asm/uaccess.h>\n \n+#include <rdma/ib.h>\n+\n #include \""uverbs.h\""\n \n MODULE_AUTHOR(\""Roland Dreier\"");\n@@ -709,6 +711,9 @@ static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,\n \tint srcu_key;\n \tssize_t ret;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof hdr)\n \t\treturn -EINVAL;\n ""}<_**next**_>{""sha"": ""24f4a782e0f431282bb8f79fc496a0b998a7a55a"", ""filename"": ""drivers/infiniband/hw/qib/qib_file_ops.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/hw/qib/qib_file_ops.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/infiniband/hw/qib/qib_file_ops.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/hw/qib/qib_file_ops.c?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -45,6 +45,8 @@\n #include <linux/export.h>\n #include <linux/uio.h>\n \n+#include <rdma/ib.h>\n+\n #include \""qib.h\""\n #include \""qib_common.h\""\n #include \""qib_user_sdma.h\""\n@@ -2067,6 +2069,9 @@ static ssize_t qib_write(struct file *fp, const char __user *data,\n \tssize_t ret = 0;\n \tvoid *dest;\n \n+\tif (WARN_ON_ONCE(!ib_safe_file_access(fp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof(cmd.type)) {\n \t\tret = -EINVAL;\n \t\tgoto bail;""}<_**next**_>{""sha"": ""4c6f1d7d2eaf21d17bffa1cc2f0f624052e16f22"", ""filename"": ""drivers/staging/rdma/hfi1/TODO"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/staging/rdma/hfi1/TODO"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/staging/rdma/hfi1/TODO"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/rdma/hfi1/TODO?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -3,4 +3,4 @@ July, 2015\n - Remove unneeded file entries in sysfs\n - Remove software processing of IB protocol and place in library for use\n   by qib, ipath (if still present), hfi1, and eventually soft-roce\n-\n+- Replace incorrect uAPI""}<_**next**_>{""sha"": ""c1c5bf82addb07aba003790069b7d36574b112ac"", ""filename"": ""drivers/staging/rdma/hfi1/file_ops.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/staging/rdma/hfi1/file_ops.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/drivers/staging/rdma/hfi1/file_ops.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/rdma/hfi1/file_ops.c?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -49,6 +49,8 @@\n #include <linux/vmalloc.h>\n #include <linux/io.h>\n \n+#include <rdma/ib.h>\n+\n #include \""hfi.h\""\n #include \""pio.h\""\n #include \""device.h\""\n@@ -190,6 +192,10 @@ static ssize_t hfi1_file_write(struct file *fp, const char __user *data,\n \tint uctxt_required = 1;\n \tint must_be_root = 0;\n \n+\t/* FIXME: This interface cannot continue out of staging */\n+\tif (WARN_ON_ONCE(!ib_safe_file_access(fp)))\n+\t\treturn -EACCES;\n+\n \tif (count < sizeof(cmd)) {\n \t\tret = -EINVAL;\n \t\tgoto bail;""}<_**next**_>{""sha"": ""a6b93706b0fc96494d7de3d7408c26fb57436a02"", ""filename"": ""include/rdma/ib.h"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/torvalds/linux/blob/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/include/rdma/ib.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3/include/rdma/ib.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/rdma/ib.h?ref=e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3"", ""patch"": ""@@ -34,6 +34,7 @@\n #define _RDMA_IB_H\n \n #include <linux/types.h>\n+#include <linux/sched.h>\n \n struct ib_addr {\n \tunion {\n@@ -86,4 +87,19 @@ struct sockaddr_ib {\n \t__u64\t\t\tsib_scope_id;\n };\n \n+/*\n+ * The IB interfaces that use write() as bi-directional ioctl() are\n+ * fundamentally unsafe, since there are lots of ways to trigger \""write()\""\n+ * calls from various contexts with elevated privileges. That includes the\n+ * traditional suid executable error message writes, but also various kernel\n+ * interfaces that can write to file descriptors.\n+ *\n+ * This function provides protection for the legacy API by restricting the\n+ * calling context.\n+ */\n+static inline bool ib_safe_file_access(struct file *filp)\n+{\n+\treturn filp->f_cred == current_cred() && segment_eq(get_fs(), USER_DS);\n+}\n+\n #endif /* _RDMA_IB_H */""}","int qib_set_uevent_bits(struct qib_pportdata *ppd, const int evtbit)
{
	struct qib_ctxtdata *rcd;
	unsigned ctxt;
	int ret = 0;
	unsigned long flags;

	spin_lock_irqsave(&ppd->dd->uctxt_lock, flags);
	for (ctxt = ppd->dd->first_user_ctxt; ctxt < ppd->dd->cfgctxts;
	     ctxt++) {
		rcd = ppd->dd->rcd[ctxt];
		if (!rcd)
			continue;
		if (rcd->user_event_mask) {
			int i;
			/*
			 * subctxt_cnt is 0 if not shared, so do base
			 * separately, first, then remaining subctxt, if any
			 */
			set_bit(evtbit, &rcd->user_event_mask[0]);
			for (i = 1; i < rcd->subctxt_cnt; i++)
				set_bit(evtbit, &rcd->user_event_mask[i]);
		}
		ret = 1;
		break;
	}
	spin_unlock_irqrestore(&ppd->dd->uctxt_lock, flags);

	return ret;
}
","int qib_set_uevent_bits(struct qib_pportdata *ppd, const int evtbit)
{
	struct qib_ctxtdata *rcd;
	unsigned ctxt;
	int ret = 0;
	unsigned long flags;

	spin_lock_irqsave(&ppd->dd->uctxt_lock, flags);
	for (ctxt = ppd->dd->first_user_ctxt; ctxt < ppd->dd->cfgctxts;
	     ctxt++) {
		rcd = ppd->dd->rcd[ctxt];
		if (!rcd)
			continue;
		if (rcd->user_event_mask) {
			int i;
			/*
			 * subctxt_cnt is 0 if not shared, so do base
			 * separately, first, then remaining subctxt, if any
			 */
			set_bit(evtbit, &rcd->user_event_mask[0]);
			for (i = 1; i < rcd->subctxt_cnt; i++)
				set_bit(evtbit, &rcd->user_event_mask[i]);
		}
		ret = 1;
		break;
	}
	spin_unlock_irqrestore(&ppd->dd->uctxt_lock, flags);

	return ret;
}
",C,,,,"@@ -45,6 +45,8 @@
 #include <linux/export.h>
 #include <linux/uio.h>
 
+#include <rdma/ib.h>
+
 #include ""qib.h""
 #include ""qib_common.h""
 #include ""qib_user_sdma.h""
@@ -2067,6 +2069,9 @@ static ssize_t qib_write(struct file *fp, const char __user *data,
 	ssize_t ret = 0;
 	void *dest;
 
+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))
+		return -EACCES;
+
 	if (count < sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;",linux,e6bd18f57aad1a2d1ef40e646d03ed0f2515c9e3,7723d8c2445c4dfa91f8df42703b56f8ade59af7,0,"int qib_set_uevent_bits(struct qib_pportdata *ppd, const int evtbit)
{
	struct qib_ctxtdata *rcd;
	unsigned ctxt;
	int ret = 0;
	unsigned long flags;

	spin_lock_irqsave(&ppd->dd->uctxt_lock, flags);
	for (ctxt = ppd->dd->first_user_ctxt; ctxt < ppd->dd->cfgctxts;
	     ctxt++) {
		rcd = ppd->dd->rcd[ctxt];
		if (!rcd)
			continue;
		if (rcd->user_event_mask) {
			int i;
			/*
			 * subctxt_cnt is 0 if not shared, so do base
			 * separately, first, then remaining subctxt, if any
			 */
			set_bit(evtbit, &rcd->user_event_mask[0]);
			for (i = 1; i < rcd->subctxt_cnt; i++)
				set_bit(evtbit, &rcd->user_event_mask[i]);
		}
		ret = 1;
		break;
	}
	spin_unlock_irqrestore(&ppd->dd->uctxt_lock, flags);

	return ret;
}
"
120061,,Remote,Not required,Partial,CVE-2013-2900,https://www.cvedetails.com/cve/CVE-2013-2900/,CWE-22,Low,Partial,Partial,,2013-08-21,7.5,"The FilePath::ReferencesParent function in files/file_path.cc in Google Chrome before 29.0.1547.57 on Windows does not properly handle pathname components composed entirely of . (dot) and whitespace characters, which allows remote attackers to conduct directory traversal attacks via a crafted directory name.",2017-09-18,Dir. Trav. ,0,https://github.com/chromium/chromium/commit/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,"AX: Calendar Picker: Add AX labels to MonthPopupButton and CalendarNavigationButtons.

This CL adds no new tests. Will add tests after a Chromium change for
string resource.

BUG=123896

Review URL: https://codereview.chromium.org/552163002

git-svn-id: svn://svn.chromium.org/blink/trunk@181617 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/web/DateTimeChooserImpl.cpp,"{""sha"": ""12cccdfa59676411125945dcd7aa13898fc408e2"", ""filename"": ""third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/ManualTests/forms/calendar-picker.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/ManualTests/forms/calendar-picker.html?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -269,7 +269,11 @@ <h2>Config</h2>\n         min: config.min,\n         step: config.step * (config.type === \""month\"" ? 1 : 86400000),\n         stepBase: \""0\"",\n-        currentValue: config.value\n+        currentValue: config.value,\n+        axShowMonthSelector: \""Show month selection panel\"",\n+        axShowNextMonth: \""Show next month\"",\n+        axShowPreviousMonth: \""Show previous month\"",\n+        todayLabel: \""Today\"",\n     }\n };\n ""}<_**next**_>{""sha"": ""1cdb077dea9cd61af7c69ae482e4c0cfe9253113"", ""filename"": ""third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/DateTimeChooserImpl.cpp?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)\n     addProperty(\""todayLabel\"", todayLabelString, data);\n     addProperty(\""clearLabel\"", locale().queryString(WebLocalizedString::CalendarClear), data);\n     addProperty(\""weekLabel\"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);\n+    addProperty(\""axShowMonthSelector\"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);\n+    addProperty(\""axShowNextMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);\n+    addProperty(\""axShowPreviousMonth\"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);\n     addProperty(\""weekStartDay\"", m_locale->firstDayOfWeek(), data);\n     addProperty(\""shortMonthLabels\"", m_locale->shortMonthLabels(), data);\n     addProperty(\""dayLabels\"", m_locale->weekDayShortLabels(), data);""}<_**next**_>{""sha"": ""2459e401c4237a186e0039c67c54ad271412b12d"", ""filename"": ""third_party/WebKit/Source/web/resources/calendarPicker.js"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/Source/web/resources/calendarPicker.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/web/resources/calendarPicker.js?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -2763,6 +2763,7 @@ MonthPopupView.prototype.onClick = function(event) {\n  */\n function MonthPopupButton(maxWidth) {\n     View.call(this, createElement(\""button\"", MonthPopupButton.ClassNameMonthPopupButton));\n+    this.element.setAttribute(\""aria-label\"", global.params.axShowMonthSelector);\n \n     /**\n      * @type {!Element}\n@@ -2951,6 +2952,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._previousMonthButton.attachTo(this);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._previousMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._previousMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowPreviousMonth);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2962,6 +2964,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._todayButton.element.classList.add(CalendarHeaderView.ClassNameTodayButton);\n     var monthContainingToday = Month.createFromToday();\n     this._todayButton.setDisabled(monthContainingToday < this.calendarPicker.minimumMonth || monthContainingToday > this.calendarPicker.maximumMonth);\n+    this._todayButton.element.setAttribute(\""aria-label\"", global.params.todayLabel);\n \n     /**\n      * @type {!CalendarNavigationButton}\n@@ -2971,6 +2974,7 @@ function CalendarHeaderView(calendarPicker) {\n     this._nextMonthButton.attachTo(this);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeButtonClick, this.onNavigationButtonClick);\n     this._nextMonthButton.on(CalendarNavigationButton.EventTypeRepeatingButtonClick, this.onNavigationButtonClick);\n+    this._nextMonthButton.element.setAttribute(\""aria-label\"", global.params.axShowNextMonth);\n \n     if (global.params.isLocaleRTL) {\n         this._nextMonthButton.element.innerHTML = CalendarHeaderView._BackwardTriangle;""}<_**next**_>{""sha"": ""d2cc50cce3d1f450b6e1e35ca03a41d25518be8c"", ""filename"": ""third_party/WebKit/public/platform/WebLocalizedString.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/bd3392a1f8b95bf0b0ee3821bc3245d743fb1337/third_party/WebKit/public/platform/WebLocalizedString.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/public/platform/WebLocalizedString.h?ref=bd3392a1f8b95bf0b0ee3821bc3245d743fb1337"", ""patch"": ""@@ -37,6 +37,9 @@ struct WebLocalizedString {\n     enum Name {\n         AXAMPMFieldText,\n         AXButtonActionVerb,\n+        AXCalendarShowMonthSelector,\n+        AXCalendarShowNextMonth,\n+        AXCalendarShowPreviousMonth,\n         AXCheckedCheckBoxActionVerb,\n         AXDateTimeFieldEmptyValueText,\n         AXDayOfMonthFieldText,""}","void DateTimeChooserImpl::didClosePopup()
{
    ASSERT(m_client);
    m_popup = 0;
    m_client->didEndChooser();
}
","void DateTimeChooserImpl::didClosePopup()
{
    ASSERT(m_client);
    m_popup = 0;
    m_client->didEndChooser();
}
",C,,,,"@@ -138,6 +138,9 @@ void DateTimeChooserImpl::writeDocument(SharedBuffer* data)
     addProperty(""todayLabel"", todayLabelString, data);
     addProperty(""clearLabel"", locale().queryString(WebLocalizedString::CalendarClear), data);
     addProperty(""weekLabel"", locale().queryString(WebLocalizedString::WeekNumberLabel), data);
+    addProperty(""axShowMonthSelector"", locale().queryString(WebLocalizedString::AXCalendarShowMonthSelector), data);
+    addProperty(""axShowNextMonth"", locale().queryString(WebLocalizedString::AXCalendarShowNextMonth), data);
+    addProperty(""axShowPreviousMonth"", locale().queryString(WebLocalizedString::AXCalendarShowPreviousMonth), data);
     addProperty(""weekStartDay"", m_locale->firstDayOfWeek(), data);
     addProperty(""shortMonthLabels"", m_locale->shortMonthLabels(), data);
     addProperty(""dayLabels"", m_locale->weekDayShortLabels(), data);",Chrome,bd3392a1f8b95bf0b0ee3821bc3245d743fb1337,8a2c034f43ae98cc6a429f91dd1d16fc3fe331c9,0,"void DateTimeChooserImpl::didClosePopup()
{
    ASSERT(m_client);
    m_popup = 0;
    m_client->didEndChooser();
}
"
53358,,Remote,Not required,Partial,CVE-2016-4303,https://www.cvedetails.com/cve/CVE-2016-4303/,CWE-119,Low,Partial,Partial,,2016-09-26,7.5,"The parse_string function in cjson.c in the cJSON library mishandles UTF8/16 strings, which allows remote attackers to cause a denial of service (crash) or execute arbitrary code via a non-hex character in a JSON string, which triggers a heap-based buffer overflow.",2018-10-30,DoS Exec Code Overflow ,0,https://github.com/esnet/iperf/commit/91f2fa59e8ed80dfbf400add0164ee0e508e412a,91f2fa59e8ed80dfbf400add0164ee0e508e412a,"Fix a buffer overflow / heap corruption issue that could occur if a
malformed JSON string was passed on the control channel.  This issue,
present in the cJSON library, was already fixed upstream, so was
addressed here in iperf3 by importing a newer version of cJSON (plus
local ESnet modifications).

Discovered and reported by Dave McDaniel, Cisco Talos.

Based on a patch by @dopheide-esnet, with input from @DaveGamble.

Cross-references:  TALOS-CAN-0164, ESNET-SECADV-2016-0001,
CVE-2016-4303

(cherry picked from commit ed94082be27d971a5e1b08b666e2c217cf470a40)
Signed-off-by: Bruce A. Mah <bmah@es.net>",0,src/iperf_api.c,"{""sha"": ""90edf81727db241c41b5761b25b8f1d26e24e17d"", ""filename"": ""configure.ac"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/esnet/iperf/blob/91f2fa59e8ed80dfbf400add0164ee0e508e412a/configure.ac"", ""raw_url"": ""https://github.com/esnet/iperf/raw/91f2fa59e8ed80dfbf400add0164ee0e508e412a/configure.ac"", ""contents_url"": ""https://api.github.com/repos/esnet/iperf/contents/configure.ac?ref=91f2fa59e8ed80dfbf400add0164ee0e508e412a"", ""patch"": ""@@ -62,6 +62,12 @@ AC_HEADER_STDC\n # Check for systems which need -lsocket and -lnsl\n #AX_LIB_SOCKET_NSL\n \n+# Check for the math library (needed by cjson on some platforms)\n+AC_SEARCH_LIBS(floor, [m], [], [\n+echo \""floor()\""\n+exit 1\n+])\n+\n # Solaris puts nanosleep in -lrt\n AC_SEARCH_LIBS(nanosleep, [rt], [], [\n echo \""nanosleep() required for timing operations.\""""}<_**next**_>{""sha"": ""4dc892f2a8fd4fa2028ca661cda5a1c008394a61"", ""filename"": ""src/cjson.c"", ""status"": ""modified"", ""additions"": 571, ""deletions"": 842, ""changes"": 1413, ""blob_url"": ""https://github.com/esnet/iperf/blob/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/cjson.c"", ""raw_url"": ""https://github.com/esnet/iperf/raw/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/cjson.c"", ""contents_url"": ""https://api.github.com/repos/esnet/iperf/contents/src/cjson.c?ref=91f2fa59e8ed80dfbf400add0164ee0e508e412a"", ""patch"": ""@@ -40,994 +40,723 @@\n #ifndef LLONG_MIN\n #define LLONG_MIN (-LLONG_MAX - 1LL)\n #endif\n+static const char *global_ep;\n \n+const char *cJSON_GetErrorPtr(void) {return global_ep;}\n \n-static const char *ep;\n-\n-const char *cJSON_GetErrorPtr( void )\n-{\n-\treturn ep;\n-}\n-\n-\n-static int cJSON_strcasecmp( const char *s1, const char *s2 )\n+static int cJSON_strcasecmp(const char *s1,const char *s2)\n {\n-\tif ( ! s1 )\n-\t\treturn ( s1 == s2 ) ? 0 : 1;\n-\tif ( ! s2 )\n-\t\treturn 1;\n-\tfor ( ; tolower(*s1) == tolower(*s2); ++s1, ++s2)\n-\t\tif( *s1 == 0 )\n-\t\t\treturn 0;\n+\tif (!s1) return (s1==s2)?0:1;if (!s2) return 1;\n+\tfor(; tolower(*s1) == tolower(*s2); ++s1, ++s2)\tif(*s1 == 0)\treturn 0;\n \treturn tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);\n }\n \n+static void *(*cJSON_malloc)(size_t sz) = malloc;\n+static void (*cJSON_free)(void *ptr) = free;\n \n-static void *(*cJSON_malloc)( size_t ) = malloc;\n-static void (*cJSON_free)( void * ) = free;\n-\n-void cJSON_InitHooks(cJSON_Hooks* hooks)\n+static char* cJSON_strdup(const char* str)\n {\n-\tif ( ! hooks ) {\n-\t\t/* Reset hooks. */\n-\t\tcJSON_malloc = malloc;\n-\t\tcJSON_free = free;\n-\t\treturn;\n-\t}\n-\tcJSON_malloc = (hooks->malloc_fn) ? hooks->malloc_fn : malloc;\n-\tcJSON_free = (hooks->free_fn) ? hooks->free_fn : free;\n-}\n+      size_t len;\n+      char* copy;\n \n+      len = strlen(str) + 1;\n+      if (!(copy = (char*)cJSON_malloc(len))) return 0;\n+      memcpy(copy,str,len);\n+      return copy;\n+}\n \n-static char* cJSON_strdup( const char* str )\n+void cJSON_InitHooks(cJSON_Hooks* hooks)\n {\n-\tsize_t len;\n-\tchar* copy;\n+    if (!hooks) { /* Reset hooks */\n+        cJSON_malloc = malloc;\n+        cJSON_free = free;\n+        return;\n+    }\n \n-\tlen = strlen( str ) + 1;\n-\tif ( ! ( copy = (char*) cJSON_malloc( len ) ) )\n-\t\treturn 0;\n-\tmemcpy( copy, str, len );\n-\treturn copy;\n+\tcJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;\n+\tcJSON_free\t = (hooks->free_fn)?hooks->free_fn:free;\n }\n \n-\n /* Internal constructor. */\n-static cJSON *cJSON_New_Item( void )\n+static cJSON *cJSON_New_Item(void)\n {\n-\tcJSON* node = (cJSON*) cJSON_malloc( sizeof(cJSON) );\n-\tif ( node )\n-\t\tmemset( node, 0, sizeof(cJSON) );\n+\tcJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));\n+\tif (node) memset(node,0,sizeof(cJSON));\n \treturn node;\n }\n \n-\n /* Delete a cJSON structure. */\n-void cJSON_Delete( cJSON *c )\n+void cJSON_Delete(cJSON *c)\n {\n \tcJSON *next;\n-\n-\twhile ( c ) {\n-\t\tnext = c->next;\n-\t\tif ( ! ( c->type & cJSON_IsReference ) && c->child )\n-\t\t\tcJSON_Delete( c->child );\n-\t\tif ( ! ( c->type & cJSON_IsReference ) && c->valuestring )\n-\t\t\tcJSON_free( c->valuestring );\n-\t\tif ( c->string )\n-\t\t\tcJSON_free( c->string );\n-\t\tcJSON_free( c );\n-\t\tc = next;\n+\twhile (c)\n+\t{\n+\t\tnext=c->next;\n+\t\tif (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);\n+\t\tif (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);\n+\t\tif (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);\n+\t\tcJSON_free(c);\n+\t\tc=next;\n \t}\n }\n \n-\n-static double ipow( double n, int exp )\n+/* Parse the input text to generate a number, and populate the result into item. */\n+static const char *parse_number(cJSON *item,const char *num)\n {\n-\tdouble r;\n+\tdouble n=0,sign=1,scale=0;int subscale=0,signsubscale=1;\n \n-\tif ( exp < 0 )\n-\t\treturn 1.0 / ipow( n, -exp );\n-\tr = 1;\n-\twhile ( exp > 0 ) {\n-\t\tif ( exp & 1 )\n-\t\t\tr *= n;\n-\t\texp >>= 1;\n-\t\tn *= n;\n+\tif (*num=='-') sign=-1,num++;\t/* Has sign? */\n+\tif (*num=='0') num++;\t\t\t/* is zero */\n+\tif (*num>='1' && *num<='9')\tdo\tn=(n*10.0)+(*num++ -'0');\twhile (*num>='0' && *num<='9');\t/* Number? */\n+\tif (*num=='.' && num[1]>='0' && num[1]<='9') {num++;\t\tdo\tn=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}\t/* Fractional part? */\n+\tif (*num=='e' || *num=='E')\t\t/* Exponent? */\n+\t{\tnum++;if (*num=='+') num++;\telse if (*num=='-') signsubscale=-1,num++;\t\t/* With sign? */\n+\t\twhile (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');\t/* Number? */\n \t}\n-\treturn r;\n-}\n \n+\tn=sign*n*pow(10.0,(scale+subscale*signsubscale));\t/* number = +/- number.fraction * 10^+/- exponent */\n+\t\n+\titem->valuedouble=n;\n+\titem->valueint=(int64_t)n;\n+\titem->type=cJSON_Number;\n+\treturn num;\n+}\n \n-/* Parse the input text to generate a number, and populate the result into item. */\n-static const char *parse_number( cJSON *item, const char *num )\n-{\n-\tint64_t i = 0;\n-\tdouble f = 0;\n-\tint isint = 1;\n-\tint sign = 1, scale = 0, subscale = 0, signsubscale = 1;\n+static int pow2gt (int x)\t{\t--x;\tx|=x>>1;\tx|=x>>2;\tx|=x>>4;\tx|=x>>8;\tx|=x>>16;\treturn x+1;\t}\n \n-\t/* Could use sscanf for this? */\n-\tif ( *num == '-' ) {\n-\t\t/* Has sign. */\n-\t\tsign = -1;\n-\t\t++num;\n-\t}\n-\tif ( *num == '0' )\n-\t\t/* Is zero. */\n-\t\t++num;\n-\tif ( *num >= '1' && *num<='9' ) {\n-\t\t/* Number. */\n-\t\tdo {\n-\t\t\ti = ( i * 10 ) + ( *num - '0' );\n-\t\t\tf = ( f * 10.0 ) + ( *num - '0' );\n-\t\t\t++num;\n-\t\t} while ( *num >= '0' && *num <= '9' );\n-\t}\n-\tif ( *num == '.' && num[1] >= '0' && num[1] <= '9' ) {\n-\t\t/* Fractional part. */\n-\t\tisint = 0;\n-\t\t++num;\n-\t\tdo {\n-\t\t\tf = ( f * 10.0 ) + ( *num++ - '0' );\n-\t\t\tscale--;\n-\t\t} while ( *num >= '0' && *num <= '9' );\n-\t}\n-\tif ( *num == 'e' || *num == 'E' ) {\n-\t\t/* Exponent. */\n-\t\tisint = 0;\n-\t\t++num;\n-\t\tif ( *num == '+' )\n-\t\t\t++num;\n-\t\telse if ( *num == '-' ) {\n-\t\t\t/* With sign. */\n-\t\t\tsignsubscale = -1;\n-\t\t\t++num;\n-\t\t}\n-\t\twhile ( *num >= '0' && *num <= '9' )\n-\t\t\tsubscale = ( subscale * 10 ) + ( *num++ - '0' );\n-\t}\n+typedef struct {char *buffer; int length; int offset; } printbuffer;\n \n-\t/* Put it together. */\n-\tif ( isint ) {\n-\t\t/* Int: number = +/- number */\n-\t\ti = sign * i;\n-\t\titem->valueint = i;\n-\t\titem->valuefloat = i;\n-\t} else {\n-\t\t/* Float: number = +/- number.fraction * 10^+/- exponent */\n-\t\tf = sign * f * ipow( 10.0, scale + subscale * signsubscale );\n-\t\titem->valueint = f;\n-\t\titem->valuefloat = f;\n-\t}\n+static char* ensure(printbuffer *p,int needed)\n+{\n+\tchar *newbuffer;int newsize;\n+\tif (!p || !p->buffer) return 0;\n+\tneeded+=p->offset;\n+\tif (needed<=p->length) return p->buffer+p->offset;\n \n-\titem->type = cJSON_Number;\n-\treturn num;\n+\tnewsize=pow2gt(needed);\n+\tnewbuffer=(char*)cJSON_malloc(newsize);\n+\tif (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}\n+\tif (newbuffer) memcpy(newbuffer,p->buffer,p->length);\n+\tcJSON_free(p->buffer);\n+\tp->length=newsize;\n+\tp->buffer=newbuffer;\n+\treturn newbuffer+p->offset;\n }\n \n-\n-/* Render the number nicely from the given item into a string. */\n-static char *print_number( cJSON *item )\n+static int update(printbuffer *p)\n {\n \tchar *str;\n-\tdouble f, f2;\n-\tint64_t i;\n+\tif (!p || !p->buffer) return 0;\n+\tstr=p->buffer+p->offset;\n+\treturn p->offset+strlen(str);\n+}\n \n-\tstr = (char*) cJSON_malloc( 64 );\n-\tif ( str ) {\n-\t\tf = item->valuefloat;\n-\t\ti = f;\n-\t\tf2 = i;\n-\t\tif ( f2 == f && item->valueint >= LLONG_MIN && item->valueint <= LLONG_MAX )\n-\t\t\tsprintf( str, \""%lld\"", (long long) item->valueint );\n-\t\telse\n-\t\t\tsprintf( str, \""%g\"", item->valuefloat );\n+/* Render the number nicely from the given item into a string. */\n+static char *print_number(cJSON *item,printbuffer *p)\n+{\n+\tchar *str=0;\n+\tdouble d=item->valuedouble;\n+\tif (d==0)\n+\t{\n+\t\tif (p)\tstr=ensure(p,2);\n+\t\telse\tstr=(char*)cJSON_malloc(2);\t/* special case for 0. */\n+\t\tif (str) strcpy(str,\""0\"");\n+\t}\n+\telse if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=LLONG_MAX && d>=LLONG_MIN)\n+\t{\n+\t\tif (p)\tstr=ensure(p,64);\n+\t\telse\tstr=(char*)cJSON_malloc(64);\n+\t\tif (str)\tsprintf(str,\""%lld\"",(long long) item->valueint);\n+\t}\n+\telse\n+\t{\n+\t\tif (p)\tstr=ensure(p,64);\n+\t\telse\tstr=(char*)cJSON_malloc(64);\t/* This is a nice tradeoff. */\n+\t\tif (str)\n+\t\t{\n+\t\t\tif (fpclassify(d) != FP_ZERO && !isnormal(d))\t\t\t\tsprintf(str,\""null\"");\n+\t\t\telse if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)\tsprintf(str,\""%.0f\"",d);\n+\t\t\telse if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)\t\t\t\t\tsprintf(str,\""%e\"",d);\n+\t\t\telse\t\t\t\t\t\t\t\t\t\t\t\t\t\tsprintf(str,\""%f\"",d);\n+\t\t}\n \t}\n \treturn str;\n }\n \n+static unsigned parse_hex4(const char *str)\n+{\n+\tunsigned h=0;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\th=h<<4;str++;\n+\tif (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;\n+\treturn h;\n+}\n \n /* Parse the input text into an unescaped cstring, and populate item. */\n static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };\n-\n-static const char *parse_string( cJSON *item, const char *str )\n+static const char *parse_string(cJSON *item,const char *str,const char **ep)\n {\n-\tconst char *ptr = str + 1;\n-\tchar *ptr2;\n-\tchar *out;\n-\tint len = 0;\n-\tunsigned uc, uc2;\n-\n-\tif ( *str != '\\\""' ) {\n-\t\t/* Not a string! */\n-\t\tep = str;\n-\t\treturn 0;\n-\t}\n+\tconst char *ptr=str+1,*end_ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;\n+\tif (*str!='\\\""') {*ep=str;return 0;}\t/* not a string! */\n \t\n-\t/* Skip escaped quotes. */\n-\twhile ( *ptr != '\\\""' && *ptr && ++len )\n-\t\tif ( *ptr++ == '\\\\' )\n-\t\t\tptr++;\n+\twhile (*end_ptr!='\\\""' && *end_ptr && ++len) if (*end_ptr++ == '\\\\') end_ptr++;\t/* Skip escaped quotes. */\n \t\n-\tif ( ! ( out = (char*) cJSON_malloc( len + 1 ) ) )\n-\t\treturn 0;\n+\tout=(char*)cJSON_malloc(len+1);\t/* This is how long we need for the string, roughly. */\n+\tif (!out) return 0;\n+\titem->valuestring=out; /* assign here so out will be deleted during cJSON_Delete() later */\n+\titem->type=cJSON_String;\n \t\n-\tptr = str + 1;\n-\tptr2 = out;\n-\twhile ( *ptr != '\\\""' && *ptr ) {\n-\t\tif ( *ptr != '\\\\' )\n-\t\t\t*ptr2++ = *ptr++;\n-\t\telse {\n+\tptr=str+1;ptr2=out;\n+\twhile (ptr < end_ptr)\n+\t{\n+\t\tif (*ptr!='\\\\') *ptr2++=*ptr++;\n+\t\telse\n+\t\t{\n \t\t\tptr++;\n-\t\t\tswitch ( *ptr ) {\n-\t\t\t\tcase 'b': *ptr2++ ='\\b'; break;\n-\t\t\t\tcase 'f': *ptr2++ ='\\f'; break;\n-\t\t\t\tcase 'n': *ptr2++ ='\\n'; break;\n-\t\t\t\tcase 'r': *ptr2++ ='\\r'; break;\n-\t\t\t\tcase 't': *ptr2++ ='\\t'; break;\n-\t\t\t\tcase 'u':\n-\t\t\t\t\t/* Transcode utf16 to utf8. */\n-\t\t\t\t\t/* Get the unicode char. */\n-\t\t\t\t\tsscanf( ptr + 1,\""%4x\"", &uc );\n-\t\t\t\t\tptr += 4;\n-\t\t\t\t\t/* Check for invalid. */\n-\t\t\t\t\tif ( ( uc >= 0xDC00 && uc <= 0xDFFF ) || uc == 0 )\n-\t\t\t\t\t\tbreak;\n-\n-\t\t\t\t\t/* UTF16 surrogate pairs. */\n-\t\t\t\t\tif ( uc >= 0xD800 && uc <= 0xDBFF ) {\n-\t\t\t\t\t\tif ( ptr[1] != '\\\\' || ptr[2] != 'u' )\n-\t\t\t\t\t\t\t/* Missing second-half of surrogate. */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tsscanf( ptr + 3, \""%4x\"", &uc2 );\n-\t\t\t\t\t\tptr += 6;\n-\t\t\t\t\t\tif ( uc2 < 0xDC00 || uc2 > 0xDFFF )\n-\t\t\t\t\t\t\t/* Invalid second-half of surrogate. */\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\tuc = 0x10000 | ( ( uc & 0x3FF ) << 10 ) | ( uc2 & 0x3FF );\n+\t\t\tswitch (*ptr)\n+\t\t\t{\n+\t\t\t\tcase 'b': *ptr2++='\\b';\tbreak;\n+\t\t\t\tcase 'f': *ptr2++='\\f';\tbreak;\n+\t\t\t\tcase 'n': *ptr2++='\\n';\tbreak;\n+\t\t\t\tcase 'r': *ptr2++='\\r';\tbreak;\n+\t\t\t\tcase 't': *ptr2++='\\t';\tbreak;\n+\t\t\t\tcase 'u':\t /* transcode utf16 to utf8. */\n+\t\t\t\t\tuc=parse_hex4(ptr+1);ptr+=4;\t/* get the unicode char. */\n+\t\t\t\t\tif (ptr >= end_ptr) {*ep=str;return 0;}\t/* invalid */\n+\t\t\t\t\t\n+\t\t\t\t\tif ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)    {*ep=str;return 0;}\t/* check for invalid.   */\n+\t\t\t\t\t\n+\t\t\t\t\tif (uc>=0xD800 && uc<=0xDBFF)\t/* UTF16 surrogate pairs.\t*/\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif (ptr+6 > end_ptr)    {*ep=str;return 0;}\t/* invalid */\n+\t\t\t\t\t\tif (ptr[1]!='\\\\' || ptr[2]!='u')    {*ep=str;return 0;}\t/* missing second-half of surrogate.    */\n+\t\t\t\t\t\tuc2=parse_hex4(ptr+3);ptr+=6;\n+\t\t\t\t\t\tif (uc2<0xDC00 || uc2>0xDFFF)       {*ep=str;return 0;}\t/* invalid second-half of surrogate.    */\n+\t\t\t\t\t\tuc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));\n \t\t\t\t\t}\n \n-\t\t\t\t\tlen = 4;\n-\t\t\t\t\tif ( uc < 0x80 )\n-\t\t\t\t\t\tlen = 1;\n-\t\t\t\t\telse if ( uc < 0x800 )\n-\t\t\t\t\t\tlen = 2;\n-\t\t\t\t\telse if ( uc < 0x10000 )\n-\t\t\t\t\t\tlen = 3;\n-\t\t\t\t\tptr2 += len;\n+\t\t\t\t\tlen=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;\n \t\t\t\t\t\n-\t\t\t\t\tswitch ( len ) {\n-\t\t\t\t\t\tcase 4: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 3: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 2: *--ptr2 = ( ( uc | 0x80) & 0xBF ); uc >>= 6;\n-\t\t\t\t\t\tcase 1: *--ptr2 = ( uc | firstByteMark[len] );\n+\t\t\t\t\tswitch (len) {\n+\t\t\t\t\t\tcase 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;\n+\t\t\t\t\t\tcase 1: *--ptr2 =(uc | firstByteMark[len]);\n \t\t\t\t\t}\n-\t\t\t\t\tptr2 += len;\n+\t\t\t\t\tptr2+=len;\n \t\t\t\t\tbreak;\n-\t\t\t\tdefault:  *ptr2++ = *ptr; break;\n+\t\t\t\tdefault:  *ptr2++=*ptr; break;\n \t\t\t}\n-\t\t\t++ptr;\n+\t\t\tptr++;\n \t\t}\n \t}\n-\t*ptr2 = 0;\n-\tif ( *ptr == '\\\""' )\n-\t\t++ptr;\n-\titem->valuestring = out;\n-\titem->type = cJSON_String;\n+\t*ptr2=0;\n+\tif (*ptr=='\\\""') ptr++;\n \treturn ptr;\n }\n \n-\n /* Render the cstring provided to an escaped version that can be printed. */\n-static char *print_string_ptr( const char *str )\n+static char *print_string_ptr(const char *str,printbuffer *p)\n {\n-\tconst char *ptr;\n-\tchar *ptr2, *out;\n-\tint len = 0;\n-\tunsigned char token;\n+\tconst char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;\n+\n+\tif (!str)\n+\t{\n+\t\tif (p)\tout=ensure(p,3);\n+\t\telse\tout=(char*)cJSON_malloc(3);\n+\t\tif (!out) return 0;\n+\t\tstrcpy(out,\""\\\""\\\""\"");\n+\t\treturn out;\n+\t}\n \t\n-\tif ( ! str )\n-\t\treturn cJSON_strdup( \""\"" );\n-\tptr = str;\n-\twhile ( ( token = *ptr ) && ++len ) {\n-\t\tif ( strchr( \""\\\""\\\\\\b\\f\\n\\r\\t\"", token ) )\n-\t\t\t++len;\n-\t\telse if ( token < 32 )\n-\t\t\tlen += 5;\n-\t\t++ptr;\n+\tfor (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\\\""')||(*ptr=='\\\\'))?1:0;\n+\tif (!flag)\n+\t{\n+\t\tlen=ptr-str;\n+\t\tif (p) out=ensure(p,len+3);\n+\t\telse\t\tout=(char*)cJSON_malloc(len+3);\n+\t\tif (!out) return 0;\n+\t\tptr2=out;*ptr2++='\\\""';\n+\t\tstrcpy(ptr2,str);\n+\t\tptr2[len]='\\\""';\n+\t\tptr2[len+1]=0;\n+\t\treturn out;\n \t}\n \t\n-\tif ( ! ( out = (char*) cJSON_malloc( len + 3 ) ) )\n-\t\treturn 0;\n-\n-\tptr2 = out;\n-\tptr = str;\n-\t*ptr2++ = '\\\""';\n-\twhile ( *ptr ) {\n-\t\tif ( (unsigned char) *ptr > 31 && *ptr != '\\\""' && *ptr != '\\\\' )\n-\t\t\t*ptr2++ = *ptr++;\n-\t\telse {\n-\t\t\t*ptr2++ = '\\\\';\n-\t\t\tswitch ( token = *ptr++ ) {\n-\t\t\t\tcase '\\\\': *ptr2++ = '\\\\'; break;\n-\t\t\t\tcase '\\\""': *ptr2++ = '\\\""'; break;\n-\t\t\t\tcase '\\b': *ptr2++ = 'b'; break;\n-\t\t\t\tcase '\\f': *ptr2++ = 'f'; break;\n-\t\t\t\tcase '\\n': *ptr2++ = 'n'; break;\n-\t\t\t\tcase '\\r': *ptr2++ = 'r'; break;\n-\t\t\t\tcase '\\t': *ptr2++ = 't'; break;\n-\t\t\t\tdefault:\n-\t\t\t\t/* Escape and print. */\n-\t\t\t\tsprintf( ptr2, \""u%04x\"", token );\n-\t\t\t\tptr2 += 5;\n-\t\t\t\tbreak;\n+\tptr=str;while ((token=*ptr) && ++len) {if (strchr(\""\\\""\\\\\\b\\f\\n\\r\\t\"",token)) len++; else if (token<32) len+=5;ptr++;}\n+\t\n+\tif (p)\tout=ensure(p,len+3);\n+\telse\tout=(char*)cJSON_malloc(len+3);\n+\tif (!out) return 0;\n+\n+\tptr2=out;ptr=str;\n+\t*ptr2++='\\\""';\n+\twhile (*ptr)\n+\t{\n+\t\tif ((unsigned char)*ptr>31 && *ptr!='\\\""' && *ptr!='\\\\') *ptr2++=*ptr++;\n+\t\telse\n+\t\t{\n+\t\t\t*ptr2++='\\\\';\n+\t\t\tswitch (token=*ptr++)\n+\t\t\t{\n+\t\t\t\tcase '\\\\':\t*ptr2++='\\\\';\tbreak;\n+\t\t\t\tcase '\\\""':\t*ptr2++='\\\""';\tbreak;\n+\t\t\t\tcase '\\b':\t*ptr2++='b';\tbreak;\n+\t\t\t\tcase '\\f':\t*ptr2++='f';\tbreak;\n+\t\t\t\tcase '\\n':\t*ptr2++='n';\tbreak;\n+\t\t\t\tcase '\\r':\t*ptr2++='r';\tbreak;\n+\t\t\t\tcase '\\t':\t*ptr2++='t';\tbreak;\n+\t\t\t\tdefault: sprintf(ptr2,\""u%04x\"",token);ptr2+=5;\tbreak;\t/* escape and print */\n \t\t\t}\n \t\t}\n \t}\n-\t*ptr2++ = '\\\""';\n-\t*ptr2++ = 0;\n+\t*ptr2++='\\\""';*ptr2++=0;\n \treturn out;\n }\n-\n-\n /* Invote print_string_ptr (which is useful) on an item. */\n-static char *print_string( cJSON *item )\n-{\n-\treturn print_string_ptr( item->valuestring );\n-}\n-\n+static char *print_string(cJSON *item,printbuffer *p)\t{return print_string_ptr(item->valuestring,p);}\n \n /* Predeclare these prototypes. */\n-static const char *parse_value( cJSON *item, const char *value );\n-static char *print_value( cJSON *item, int depth, int fmt );\n-static const char *parse_array( cJSON *item, const char *value );\n-static char *print_array( cJSON *item, int depth, int fmt );\n-static const char *parse_object( cJSON *item, const char *value );\n-static char *print_object( cJSON *item, int depth, int fmt );\n-\n-/* Utility to jump whitespace and cr/lf. */\n-static const char *skip( const char *in )\n-{\n-\twhile ( in && *in && (unsigned char) *in <= 32 )\n-\t\tin++;\n-\treturn in;\n-}\n+static const char *parse_value(cJSON *item,const char *value,const char **ep);\n+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);\n+static const char *parse_array(cJSON *item,const char *value,const char **ep);\n+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);\n+static const char *parse_object(cJSON *item,const char *value,const char **ep);\n+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);\n \n+/* Utility to jump whitespace and cr/lf */\n+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}\n \n /* Parse an object - create a new root, and populate. */\n-cJSON *cJSON_Parse( const char *value )\n+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)\n {\n-\tcJSON *c;\n-\tep = 0;\n-\tif ( ! ( c = cJSON_New_Item() ) )\n-\t\treturn 0;\t/* memory fail */\n+\tconst char *end=0,**ep=return_parse_end?return_parse_end:&global_ep;\n+\tcJSON *c=cJSON_New_Item();\n+\t*ep=0;\n+\tif (!c) return 0;       /* memory fail */\n \n-\tif ( ! parse_value( c, skip( value ) ) ) {\n-\t\tcJSON_Delete( c );\n-\t\treturn 0;\n-\t}\n+\tend=parse_value(c,skip(value),ep);\n+\tif (!end)\t{cJSON_Delete(c);return 0;}\t/* parse failure. ep is set. */\n+\n+\t/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */\n+\tif (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);*ep=end;return 0;}}\n+\tif (return_parse_end) *return_parse_end=end;\n \treturn c;\n }\n-\n+/* Default options for cJSON_Parse */\n+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}\n \n /* Render a cJSON item/entity/structure to text. */\n-char *cJSON_Print( cJSON *item )\n-{\n-\treturn print_value( item, 0, 1 );\n-}\n-char *cJSON_PrintUnformatted( cJSON *item )\n+char *cJSON_Print(cJSON *item)\t\t\t\t{return print_value(item,0,1,0);}\n+char *cJSON_PrintUnformatted(cJSON *item)\t{return print_value(item,0,0,0);}\n+\n+char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)\n {\n-\treturn print_value( item, 0, 0 );\n+\tprintbuffer p;\n+\tp.buffer=(char*)cJSON_malloc(prebuffer);\n+\tp.length=prebuffer;\n+\tp.offset=0;\n+\treturn print_value(item,0,fmt,&p);\n }\n \n \n /* Parser core - when encountering text, process appropriately. */\n-static const char *parse_value( cJSON *item, const char *value )\n+static const char *parse_value(cJSON *item,const char *value,const char **ep)\n {\n-\tif ( ! value )\n-\t\treturn 0;\t/* Fail on null. */\n-\tif ( ! strncmp( value, \""null\"", 4 ) ) {\n-\t\titem->type = cJSON_NULL;\n-\t\treturn value + 4;\n-\t}\n-\tif ( ! strncmp( value, \""false\"", 5 ) ) {\n-\t\titem->type = cJSON_False;\n-\t\treturn value + 5;\n-\t}\n-\tif ( ! strncmp( value, \""true\"", 4 ) ) {\n-\t\titem->type = cJSON_True;\n-\t\titem->valueint = 1;\n-\t\treturn value + 4;\n-\t}\n-\tif ( *value == '\\\""' )\n-\t\treturn parse_string( item, value );\n-\tif ( *value == '-' || ( *value >= '0' && *value <= '9' ) )\n-\t\treturn parse_number( item, value );\n-\tif ( *value == '[' )\n-\t\treturn parse_array( item, value );\n-\tif ( *value == '{' )\n-\t\treturn parse_object( item, value );\n+\tif (!value)\t\t\t\t\t\treturn 0;\t/* Fail on null. */\n+\tif (!strncmp(value,\""null\"",4))\t{ item->type=cJSON_NULL;  return value+4; }\n+\tif (!strncmp(value,\""false\"",5))\t{ item->type=cJSON_False; return value+5; }\n+\tif (!strncmp(value,\""true\"",4))\t{ item->type=cJSON_True; item->valueint=1;\treturn value+4; }\n+\tif (*value=='\\\""')\t\t\t\t{ return parse_string(item,value,ep); }\n+\tif (*value=='-' || (*value>='0' && *value<='9'))\t{ return parse_number(item,value); }\n+\tif (*value=='[')\t\t\t\t{ return parse_array(item,value,ep); }\n+\tif (*value=='{')\t\t\t\t{ return parse_object(item,value,ep); }\n \n-\t/* Fail. */\n-\tep = value;\n-\treturn 0;\n+\t*ep=value;return 0;\t/* failure. */\n }\n \n-\n /* Render a value to text. */\n-static char *print_value( cJSON *item, int depth, int fmt )\n-{\n-\tchar *out = 0;\n-\n-\tif ( ! item )\n-\t\treturn 0;\n-\tswitch ( ( item->type ) & 255 ) {\n-\t\tcase cJSON_NULL:   out = cJSON_strdup( \""null\"" ); break;\n-\t\tcase cJSON_False:  out = cJSON_strdup( \""false\"" ); break;\n-\t\tcase cJSON_True:   out = cJSON_strdup( \""true\"" ); break;\n-\t\tcase cJSON_Number: out = print_number( item ); break;\n-\t\tcase cJSON_String: out = print_string( item ); break;\n-\t\tcase cJSON_Array:  out = print_array( item, depth, fmt ); break;\n-\t\tcase cJSON_Object: out = print_object( item, depth, fmt ); break;\n+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)\n+{\n+\tchar *out=0;\n+\tif (!item) return 0;\n+\tif (p)\n+\t{\n+\t\tswitch ((item->type)&255)\n+\t\t{\n+\t\t\tcase cJSON_NULL:\t{out=ensure(p,5);\tif (out) strcpy(out,\""null\"");\tbreak;}\n+\t\t\tcase cJSON_False:\t{out=ensure(p,6);\tif (out) strcpy(out,\""false\"");\tbreak;}\n+\t\t\tcase cJSON_True:\t{out=ensure(p,5);\tif (out) strcpy(out,\""true\"");\tbreak;}\n+\t\t\tcase cJSON_Number:\tout=print_number(item,p);break;\n+\t\t\tcase cJSON_String:\tout=print_string(item,p);break;\n+\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,p);break;\n+\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,p);break;\n+\t\t}\n+\t}\n+\telse\n+\t{\n+\t\tswitch ((item->type)&255)\n+\t\t{\n+\t\t\tcase cJSON_NULL:\tout=cJSON_strdup(\""null\"");\tbreak;\n+\t\t\tcase cJSON_False:\tout=cJSON_strdup(\""false\"");break;\n+\t\t\tcase cJSON_True:\tout=cJSON_strdup(\""true\""); break;\n+\t\t\tcase cJSON_Number:\tout=print_number(item,0);break;\n+\t\t\tcase cJSON_String:\tout=print_string(item,0);break;\n+\t\t\tcase cJSON_Array:\tout=print_array(item,depth,fmt,0);break;\n+\t\t\tcase cJSON_Object:\tout=print_object(item,depth,fmt,0);break;\n+\t\t}\n \t}\n \treturn out;\n }\n \n-\n /* Build an array from input text. */\n-static const char *parse_array( cJSON *item, const char *value )\n+static const char *parse_array(cJSON *item,const char *value,const char **ep)\n {\n \tcJSON *child;\n+\tif (*value!='[')\t{*ep=value;return 0;}\t/* not an array! */\n \n-\tif ( *value != '[' ) {\n-\t\t/* Not an array! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n-\n-\titem->type = cJSON_Array;\n-\tvalue = skip( value + 1 );\n-\tif ( *value == ']' )\n-\t\treturn value + 1;\t/* empty array. */\n+\titem->type=cJSON_Array;\n+\tvalue=skip(value+1);\n+\tif (*value==']') return value+1;\t/* empty array. */\n \n-\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n-\t\treturn 0;\t\t /* memory fail */\n-\tif ( ! ( value = skip( parse_value( child, skip( value ) ) ) ) )\n-\t\treturn 0;\n+\titem->child=child=cJSON_New_Item();\n+\tif (!item->child) return 0;\t\t /* memory fail */\n+\tvalue=skip(parse_value(child,skip(value),ep));\t/* skip any spacing, get the value. */\n+\tif (!value) return 0;\n \n-\twhile ( *value == ',' ) {\n+\twhile (*value==',')\n+\t{\n \t\tcJSON *new_item;\n-\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n-\t\t\treturn 0;\t/* memory fail */\n-\t\tchild->next = new_item;\n-\t\tnew_item->prev = child;\n-\t\tchild = new_item;\n-\t\tif ( ! ( value = skip( parse_value( child, skip( value+1 ) ) ) ) )\n-\t\t\treturn 0;\t/* memory fail */\n+\t\tif (!(new_item=cJSON_New_Item())) return 0; \t/* memory fail */\n+\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n+\t\tvalue=skip(parse_value(child,skip(value+1),ep));\n+\t\tif (!value) return 0;\t/* memory fail */\n \t}\n \n-\tif ( *value == ']' )\n-\t\treturn value + 1;\t/* end of array */\n-\t/* Malformed. */\n-\tep = value;\n-\treturn 0;\n+\tif (*value==']') return value+1;\t/* end of array */\n+\t*ep=value;return 0;\t/* malformed. */\n }\n \n-\n /* Render an array to text */\n-static char *print_array( cJSON *item, int depth, int fmt )\n+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)\n {\n \tchar **entries;\n-\tchar *out = 0, *ptr, *ret;\n-\tint len = 5;\n-\tcJSON *child = item->child;\n-\tint numentries = 0, i = 0, fail = 0;\n+\tchar *out=0,*ptr,*ret;int len=5;\n+\tcJSON *child=item->child;\n+\tint numentries=0,i=0,fail=0;\n+\tsize_t tmplen=0;\n \t\n \t/* How many entries in the array? */\n-\twhile ( child ) {\n-\t\t++numentries;\n-\t\tchild = child->next;\n-\t}\n-\t/* Allocate an array to hold the values for each. */\n-\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n-\t\treturn 0;\n-\tmemset( entries, 0, numentries * sizeof(char*) );\n-\t/* Retrieve all the results. */\n-\tchild = item->child;\n-\twhile ( child && ! fail ) {\n-\t\tret = print_value( child, depth + 1, fmt );\n-\t\tentries[i++] = ret;\n-\t\tif ( ret )\n-\t\t\tlen += strlen( ret ) + 2 + ( fmt ? 1 : 0 );\n-\t\telse\n-\t\t\tfail = 1;\n-\t\tchild = child -> next;\n-\t}\n-\t\n-\t/* If we didn't fail, try to malloc the output string. */\n-\tif ( ! fail ) {\n-\t\tout = (char*) cJSON_malloc( len );\n-\t\tif ( ! out )\n-\t\t\tfail = 1;\n-\t}\n-\n-\t/* Handle failure. */\n-\tif ( fail ) {\n-\t\tfor ( i = 0; i < numentries; ++i )\n-\t\t\tif ( entries[i] )\n-\t\t\t\tcJSON_free( entries[i] );\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n+\twhile (child) numentries++,child=child->next;\n+\t/* Explicitly handle numentries==0 */\n+\tif (!numentries)\n+\t{\n+\t\tif (p)\tout=ensure(p,3);\n+\t\telse\tout=(char*)cJSON_malloc(3);\n+\t\tif (out) strcpy(out,\""[]\"");\n+\t\treturn out;\n+\t}\n+\n+\tif (p)\n+\t{\n+\t\t/* Compose the output array. */\n+\t\ti=p->offset;\n+\t\tptr=ensure(p,1);if (!ptr) return 0;\t*ptr='[';\tp->offset++;\n+\t\tchild=item->child;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tprint_value(child,depth+1,fmt,p);\n+\t\t\tp->offset=update(p);\n+\t\t\tif (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}\n+\t\t\tchild=child->next;\n+\t\t}\n+\t\tptr=ensure(p,2);if (!ptr) return 0;\t*ptr++=']';*ptr=0;\n+\t\tout=(p->buffer)+i;\n \t}\n-\t\n-\t/* Compose the output array. */\n-\t*out = '[';\n-\tptr = out + 1;\n-\t*ptr = 0;\n-\tfor ( i = 0; i < numentries; ++i ) {\n-\t\tstrcpy( ptr, entries[i] );\n-\t\tptr += strlen( entries[i] );\n-\t\tif ( i != numentries - 1 ) {\n-\t\t\t*ptr++ = ',';\n-\t\t\tif ( fmt )\n-\t\t\t\t*ptr++ = ' ';\n-\t\t\t*ptr = 0;\n+\telse\n+\t{\n+\t\t/* Allocate an array to hold the values for each */\n+\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!entries) return 0;\n+\t\tmemset(entries,0,numentries*sizeof(char*));\n+\t\t/* Retrieve all the results: */\n+\t\tchild=item->child;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tret=print_value(child,depth+1,fmt,0);\n+\t\t\tentries[i++]=ret;\n+\t\t\tif (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;\n+\t\t\tchild=child->next;\n \t\t}\n-\t\tcJSON_free( entries[i] );\n+\t\t\n+\t\t/* If we didn't fail, try to malloc the output string */\n+\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n+\t\t/* If that fails, we fail. */\n+\t\tif (!out) fail=1;\n+\n+\t\t/* Handle failure. */\n+\t\tif (fail)\n+\t\t{\n+\t\t\tfor (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);\n+\t\t\tcJSON_free(entries);\n+\t\t\treturn 0;\n+\t\t}\n+\t\t\n+\t\t/* Compose the output array. */\n+\t\t*out='[';\n+\t\tptr=out+1;*ptr=0;\n+\t\tfor (i=0;i<numentries;i++)\n+\t\t{\n+\t\t\ttmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;\n+\t\t\tif (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}\n+\t\t\tcJSON_free(entries[i]);\n+\t\t}\n+\t\tcJSON_free(entries);\n+\t\t*ptr++=']';*ptr++=0;\n \t}\n-\tcJSON_free( entries );\n-\t*ptr++ = ']';\n-\t*ptr++ = 0;\n \treturn out;\t\n }\n \n-\n /* Build an object from the text. */\n-static const char *parse_object( cJSON *item, const char *value )\n+static const char *parse_object(cJSON *item,const char *value,const char **ep)\n {\n \tcJSON *child;\n-\n-\tif ( *value != '{' ) {\n-\t\t/* Not an object! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n+\tif (*value!='{')\t{*ep=value;return 0;}\t/* not an object! */\n \t\n-\titem->type = cJSON_Object;\n-\tvalue =skip( value + 1 );\n-\tif ( *value == '}' )\n-\t\treturn value + 1;\t/* empty array. */\n+\titem->type=cJSON_Object;\n+\tvalue=skip(value+1);\n+\tif (*value=='}') return value+1;\t/* empty array. */\n \t\n-\tif ( ! ( item->child = child = cJSON_New_Item() ) )\n-\t\treturn 0;\n-\tif ( ! ( value = skip( parse_string( child, skip( value ) ) ) ) )\n-\t\treturn 0;\n-\tchild->string = child->valuestring;\n-\tchild->valuestring = 0;\n-\tif ( *value != ':' ) {\n-\t\t/* Fail! */\n-\t\tep = value;\n-\t\treturn 0;\n-\t}\n-\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n-\t\treturn 0;\n+\titem->child=child=cJSON_New_Item();\n+\tif (!item->child) return 0;\n+\tvalue=skip(parse_string(child,skip(value),ep));\n+\tif (!value) return 0;\n+\tchild->string=child->valuestring;child->valuestring=0;\n+\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n+\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n+\tif (!value) return 0;\n \t\n-\twhile ( *value == ',' ) {\n+\twhile (*value==',')\n+\t{\n \t\tcJSON *new_item;\n-\t\tif ( ! ( new_item = cJSON_New_Item() ) )\n-\t\t\treturn 0;\t/* memory fail */\n-\t\tchild->next = new_item;\n-\t\tnew_item->prev = child;\n-\t\tchild = new_item;\n-\t\tif ( ! ( value = skip( parse_string( child, skip( value + 1 ) ) ) ) )\n-\t\t\treturn 0;\n-\t\tchild->string = child->valuestring;\n-\t\tchild->valuestring = 0;\n-\t\tif ( *value != ':' ) {\n-\t\t\t/* Fail! */\n-\t\t\tep = value;\n-\t\t\treturn 0;\n-\t\t}\n-\t\tif ( ! ( value = skip( parse_value( child, skip( value + 1 ) ) ) ) )\n-\t\t\treturn 0;\n+\t\tif (!(new_item=cJSON_New_Item()))\treturn 0; /* memory fail */\n+\t\tchild->next=new_item;new_item->prev=child;child=new_item;\n+\t\tvalue=skip(parse_string(child,skip(value+1),ep));\n+\t\tif (!value) return 0;\n+\t\tchild->string=child->valuestring;child->valuestring=0;\n+\t\tif (*value!=':') {*ep=value;return 0;}\t/* fail! */\n+\t\tvalue=skip(parse_value(child,skip(value+1),ep));\t/* skip any spacing, get the value. */\n+\t\tif (!value) return 0;\n \t}\n \t\n-\tif ( *value == '}' )\n-\t\treturn value + 1;\t/* end of array */\n-\t/* Malformed. */\n-\tep = value;\n-\treturn 0;\n+\tif (*value=='}') return value+1;\t/* end of array */\n+\t*ep=value;return 0;\t/* malformed. */\n }\n \n-\n /* Render an object to text. */\n-static char *print_object( cJSON *item, int depth, int fmt )\n+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)\n {\n-\tchar **entries = 0, **names = 0;\n-\tchar *out = 0, *ptr, *ret, *str;\n-\tint len = 7, i = 0, j;\n-\tcJSON *child = item->child;\n-\tint numentries = 0, fail = 0;\n-\n+\tchar **entries=0,**names=0;\n+\tchar *out=0,*ptr,*ret,*str;int len=7,i=0,j;\n+\tcJSON *child=item->child;\n+\tint numentries=0,fail=0;\n+\tsize_t tmplen=0;\n \t/* Count the number of entries. */\n-\twhile ( child ) {\n-\t\t++numentries;\n-\t\tchild = child->next;\n-\t}\n-\t/* Allocate space for the names and the objects. */\n-\tif ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )\n-\t\treturn 0;\n-\tif ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n-\t}\n-\tmemset( entries, 0, sizeof(char*) * numentries );\n-\tmemset( names, 0, sizeof(char*) * numentries );\n-\n-\t/* Collect all the results into our arrays. */\n-\tchild = item->child;\n-\t++depth;\n-\tif ( fmt )\n-\t\tlen += depth;\n-\twhile ( child ) {\n-\t\tnames[i] = str = print_string_ptr( child->string );\n-\t\tentries[i++] = ret = print_value( child, depth, fmt );\n-\t\tif ( str && ret )\n-\t\t\tlen += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );\n-\t\telse\n-\t\t\tfail = 1;\n-\t\tchild = child->next;\n-\t}\n-\t\n-\t/* Try to allocate the output string. */\n-\tif ( ! fail ) {\n-\t\tout = (char*) cJSON_malloc( len );\n-\t\tif ( ! out )\n-\t\t\tfail = 1;\n-\t}\n-\n-\t/* Handle failure. */\n-\tif ( fail ) {\n-\t\tfor ( i = 0; i < numentries; ++i ) {\n-\t\t\tif ( names[i] )\n-\t\t\t\tcJSON_free( names[i] );\n-\t\t\tif ( entries[i] )\n-\t\t\t\tcJSON_free( entries[i] );\n+\twhile (child) numentries++,child=child->next;\n+\t/* Explicitly handle empty object case */\n+\tif (!numentries)\n+\t{\n+\t\tif (p) out=ensure(p,fmt?depth+4:3);\n+\t\telse\tout=(char*)cJSON_malloc(fmt?depth+4:3);\n+\t\tif (!out)\treturn 0;\n+\t\tptr=out;*ptr++='{';\n+\t\tif (fmt) {*ptr++='\\n';for (i=0;i<depth;i++) *ptr++='\\t';}\n+\t\t*ptr++='}';*ptr++=0;\n+\t\treturn out;\n+\t}\n+\tif (p)\n+\t{\n+\t\t/* Compose the output: */\n+\t\ti=p->offset;\n+\t\tlen=fmt?2:1;\tptr=ensure(p,len+1);\tif (!ptr) return 0;\n+\t\t*ptr++='{';\tif (fmt) *ptr++='\\n';\t*ptr=0;\tp->offset+=len;\n+\t\tchild=item->child;depth++;\n+\t\twhile (child)\n+\t\t{\n+\t\t\tif (fmt)\n+\t\t\t{\n+\t\t\t\tptr=ensure(p,depth);\tif (!ptr) return 0;\n+\t\t\t\tfor (j=0;j<depth;j++) *ptr++='\\t';\n+\t\t\t\tp->offset+=depth;\n+\t\t\t}\n+\t\t\tprint_string_ptr(child->string,p);\n+\t\t\tp->offset=update(p);\n+\t\t\t\n+\t\t\tlen=fmt?2:1;\n+\t\t\tptr=ensure(p,len);\tif (!ptr) return 0;\n+\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n+\t\t\tp->offset+=len;\n+\t\t\t\n+\t\t\tprint_value(child,depth,fmt,p);\n+\t\t\tp->offset=update(p);\n+\n+\t\t\tlen=(fmt?1:0)+(child->next?1:0);\n+\t\t\tptr=ensure(p,len+1); if (!ptr) return 0;\n+\t\t\tif (child->next) *ptr++=',';\n+\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n+\t\t\tp->offset+=len;\n+\t\t\tchild=child->next;\n \t\t}\n-\t\tcJSON_free( names );\n-\t\tcJSON_free( entries );\n-\t\treturn 0;\n+\t\tptr=ensure(p,fmt?(depth+1):2);\t if (!ptr) return 0;\n+\t\tif (fmt)\tfor (i=0;i<depth-1;i++) *ptr++='\\t';\n+\t\t*ptr++='}';*ptr=0;\n+\t\tout=(p->buffer)+i;\n \t}\n-\t\n-\t/* Compose the output. */\n-\t*out = '{';\n-\tptr = out + 1;\n-\tif ( fmt )\n-\t\t*ptr++ = '\\n';\n-\t*ptr = 0;\n-\tfor ( i = 0; i < numentries; ++i ) {\n-\t\tif ( fmt )\n-\t\t\tfor ( j = 0; j < depth; ++j )\n-\t\t\t\t*ptr++ = '\\t';\n-\t\tstrcpy( ptr, names[i] );\n-\t\tptr += strlen( names[i] );\n-\t\t*ptr++ = ':';\n-\t\tif ( fmt )\n-\t\t\t*ptr++ = '\\t';\n-\t\tstrcpy( ptr, entries[i] );\n-\t\tptr += strlen( entries[i] );\n-\t\tif ( i != numentries - 1 )\n-\t\t\t*ptr++ = ',';\n-\t\tif ( fmt )\n-\t\t\t*ptr++ = '\\n';\n-\t\t*ptr = 0;\n-\t\tcJSON_free( names[i] );\n-\t\tcJSON_free( entries[i] );\n+\telse\n+\t{\n+\t\t/* Allocate space for the names and the objects */\n+\t\tentries=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!entries) return 0;\n+\t\tnames=(char**)cJSON_malloc(numentries*sizeof(char*));\n+\t\tif (!names) {cJSON_free(entries);return 0;}\n+\t\tmemset(entries,0,sizeof(char*)*numentries);\n+\t\tmemset(names,0,sizeof(char*)*numentries);\n+\n+\t\t/* Collect all the results into our arrays: */\n+\t\tchild=item->child;depth++;if (fmt) len+=depth;\n+\t\twhile (child && !fail)\n+\t\t{\n+\t\t\tnames[i]=str=print_string_ptr(child->string,0);\n+\t\t\tentries[i++]=ret=print_value(child,depth,fmt,0);\n+\t\t\tif (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;\n+\t\t\tchild=child->next;\n+\t\t}\n+\t\t\n+\t\t/* Try to allocate the output string */\n+\t\tif (!fail)\tout=(char*)cJSON_malloc(len);\n+\t\tif (!out) fail=1;\n+\n+\t\t/* Handle failure */\n+\t\tif (fail)\n+\t\t{\n+\t\t\tfor (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}\n+\t\t\tcJSON_free(names);cJSON_free(entries);\n+\t\t\treturn 0;\n+\t\t}\n+\t\t\n+\t\t/* Compose the output: */\n+\t\t*out='{';ptr=out+1;if (fmt)*ptr++='\\n';*ptr=0;\n+\t\tfor (i=0;i<numentries;i++)\n+\t\t{\n+\t\t\tif (fmt) for (j=0;j<depth;j++) *ptr++='\\t';\n+\t\t\ttmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;\n+\t\t\t*ptr++=':';if (fmt) *ptr++='\\t';\n+\t\t\tstrcpy(ptr,entries[i]);ptr+=strlen(entries[i]);\n+\t\t\tif (i!=numentries-1) *ptr++=',';\n+\t\t\tif (fmt) *ptr++='\\n';*ptr=0;\n+\t\t\tcJSON_free(names[i]);cJSON_free(entries[i]);\n+\t\t}\n+\t\t\n+\t\tcJSON_free(names);cJSON_free(entries);\n+\t\tif (fmt) for (i=0;i<depth-1;i++) *ptr++='\\t';\n+\t\t*ptr++='}';*ptr++=0;\n \t}\n-\t\n-\tcJSON_free( names );\n-\tcJSON_free( entries );\n-\tif ( fmt )\n-\t\tfor ( i = 0; i < depth - 1; ++i )\n-\t\t\t*ptr++ = '\\t';\n-\t*ptr++ = '}';\n-\t*ptr++ = 0;\n \treturn out;\t\n }\n \n-\n-int cJSON_GetArraySize( cJSON *array )\n-{\n-\tcJSON *c = array->child;\n-\tint i = 0;\n-\twhile ( c ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\treturn i;\n-}\n-\n-\n-cJSON *cJSON_GetArrayItem( cJSON *array, int item )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && item > 0 ) {\n-\t\t--item;\n-\t\tc = c->next;\n-\t}\n-\treturn c;\n-}\n-\n-\n-cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n-{\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) )\n-\t\tc = c->next;\n-\treturn c;\n-}\n-\n+/* Get Array size/item / object item. */\n+int    cJSON_GetArraySize(cJSON *array)\t\t\t\t\t\t\t{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}\n+cJSON *cJSON_GetArrayItem(cJSON *array,int item)\t\t\t\t{cJSON *c=array?array->child:0;while (c && item>0) item--,c=c->next; return c;}\n+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)\t{cJSON *c=object?object->child:0;while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}\n+int cJSON_HasObjectItem(cJSON *object,const char *string)\t\t{return cJSON_GetObjectItem(object,string)?1:0;}\n \n /* Utility for array list handling. */\n-static void suffix_object( cJSON *prev, cJSON *item )\n-{\n-\tprev->next = item;\n-\titem->prev = prev;\n-}\n-\n-\n+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}\n /* Utility for handling references. */\n-static cJSON *create_reference( cJSON *item )\n-{\n-\tcJSON *ref;\n-\tif ( ! ( ref = cJSON_New_Item() ) )\n-\t\treturn 0;\n-\tmemcpy( ref, item, sizeof(cJSON) );\n-\tref->string = 0;\n-\tref->type |= cJSON_IsReference;\n-\tref->next = ref->prev = 0;\n-\treturn ref;\n-}\n-\n+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}\n \n /* Add item to array/object. */\n-void cJSON_AddItemToArray( cJSON *array, cJSON *item )\n-{\n-\tcJSON *c = array->child;\n-\tif ( ! item )\n-\t\treturn;\n-\tif ( ! c ) {\n-\t\tarray->child = item;\n-\t} else {\n-\t\twhile ( c && c->next )\n-\t\t\tc = c->next;\n-\t\tsuffix_object( c, item );\n-\t}\n-}\n-\n-void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item )\n-{\n-\tif ( ! item )\n-\t\treturn;\n-\tif ( item->string )\n-\t\tcJSON_free( item->string );\n-\titem->string = cJSON_strdup( string );\n-\tcJSON_AddItemToArray( object, item );\n-}\n-\n-void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item )\n-{\n-\tcJSON_AddItemToArray( array, create_reference( item ) );\n-}\n-\n-void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )\n-{\n-\tcJSON_AddItemToObject( object, string, create_reference( item ) );\n-}\n-\n-cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && which > 0 ) {\n-\t\tc = c->next;\n-\t\t--which;\n-\t}\n-\tif ( ! c )\n-\t\treturn 0;\n-\tif ( c->prev )\n-\t\tc->prev->next = c->next;\n-\tif ( c->next ) c->next->prev = c->prev;\n-\tif ( c == array->child )\n-\t\tarray->child = c->next;\n-\tc->prev = c->next = 0;\n-\treturn c;\n-}\n-\n-void cJSON_DeleteItemFromArray( cJSON *array, int which )\n-{\n-\tcJSON_Delete( cJSON_DetachItemFromArray( array, which ) );\n-}\n-\n-cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string )\n-{\n-\tint i = 0;\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\tif ( c )\n-\t\treturn cJSON_DetachItemFromArray( object, i );\n-\treturn 0;\n-}\n-\n-void cJSON_DeleteItemFromObject( cJSON *object, const char *string )\n-{\n-\tcJSON_Delete( cJSON_DetachItemFromObject( object, string ) );\n-}\n+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}\n+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}\n+void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)\t{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}\n+void\tcJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)\t\t\t\t\t\t{cJSON_AddItemToArray(array,create_reference(item));}\n+void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)\t{cJSON_AddItemToObject(object,string,create_reference(item));}\n+\n+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)\t\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;\n+\tif (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}\n+void   cJSON_DeleteItemFromArray(cJSON *array,int which)\t\t\t{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}\n+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}\n+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}\n \n /* Replace array/object items with new ones. */\n-void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem )\n-{\n-\tcJSON *c = array->child;\n-\twhile ( c && which > 0 ) {\n-\t\tc = c->next;\n-\t\t--which;\n-\t}\n-\tif ( ! c )\n-\t\treturn;\n-\tnewitem->next = c->next;\n-\tnewitem->prev = c->prev;\n-\tif ( newitem->next )\n-\t\tnewitem->next->prev = newitem;\n-\tif ( c == array->child )\n-\t\tarray->child = newitem;\n-\telse\n-\t\tnewitem->prev->next = newitem;\n-\tc->next = c->prev = 0;\n-\tcJSON_Delete( c );\n-}\n-\n-void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem )\n-{\n-\tint i = 0;\n-\tcJSON *c = object->child;\n-\twhile ( c && cJSON_strcasecmp( c->string, string ) ) {\n-\t\t++i;\n-\t\tc = c->next;\n-\t}\n-\tif ( c ) {\n-\t\tnewitem->string = cJSON_strdup( string );\n-\t\tcJSON_ReplaceItemInArray( object, i, newitem );\n-\t}\n-}\n-\n+void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}\n+\tnewitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}\n+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)\t\t{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;\n+\tnewitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;\n+\tif (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}\n+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}\n \n /* Create basic types: */\n-\n-cJSON *cJSON_CreateNull( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_NULL;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateTrue( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_True;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateFalse( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_False;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateBool( int b )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = b ? cJSON_True : cJSON_False;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateInt( int64_t num )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_Number;\n-\t\titem->valuefloat = num;\n-\t\titem->valueint = num;\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateFloat( double num )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_Number;\n-\t\titem->valuefloat = num;\n-\t\titem->valueint = num;\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateString( const char *string )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item ) {\n-\t\titem->type = cJSON_String;\n-\t\titem->valuestring = cJSON_strdup( string );\n-\t}\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateArray( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_Array;\n-\treturn item;\n-}\n-\n-cJSON *cJSON_CreateObject( void )\n-{\n-\tcJSON *item = cJSON_New_Item();\n-\tif ( item )\n-\t\titem->type = cJSON_Object;\n-\treturn item;\n-}\n-\n-\n-/* Create Arrays. */\n-\n-cJSON *cJSON_CreateIntArray( int64_t *numbers, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateInt( numbers[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n-}\n-\n-cJSON *cJSON_CreateFloatArray( double *numbers, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateFloat( numbers[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n-}\n-\n-cJSON *cJSON_CreateStringArray( const char **strings, int count )\n-{\n-\tint i;\n-\tcJSON *n = 0, *p = 0, *a = cJSON_CreateArray();\n-\tfor ( i = 0; a && i < count; ++i ) {\n-\t\tn = cJSON_CreateString( strings[i] );\n-\t\tif ( ! i )\n-\t\t\ta->child = n;\n-\t\telse\n-\t\t\tsuffix_object( p, n );\n-\t\tp = n;\n-\t}\n-\treturn a;\n+cJSON *cJSON_CreateNull(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}\n+cJSON *cJSON_CreateTrue(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}\n+cJSON *cJSON_CreateFalse(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}\n+cJSON *cJSON_CreateBool(int b)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}\n+cJSON *cJSON_CreateNumber(double num)\t\t\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int64_t)num;}return item;}\n+cJSON *cJSON_CreateString(const char *string)\t{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);if(!item->valuestring){cJSON_Delete(item);return 0;}}return item;}\n+cJSON *cJSON_CreateArray(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}\n+cJSON *cJSON_CreateObject(void)\t\t\t\t\t{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}\n+\n+/* Create Arrays: */\n+cJSON *cJSON_CreateIntArray(const int *numbers,int count)\t\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateFloatArray(const float *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+cJSON *cJSON_CreateStringArray(const char **strings,int count)\t{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!n){cJSON_Delete(a);return 0;}if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}\n+\n+/* Duplication */\n+cJSON *cJSON_Duplicate(cJSON *item,int recurse)\n+{\n+\tcJSON *newitem,*cptr,*nptr=0,*newchild;\n+\t/* Bail on bad ptr */\n+\tif (!item) return 0;\n+\t/* Create new item */\n+\tnewitem=cJSON_New_Item();\n+\tif (!newitem) return 0;\n+\t/* Copy over all vars */\n+\tnewitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;\n+\tif (item->valuestring)\t{newitem->valuestring=cJSON_strdup(item->valuestring);\tif (!newitem->valuestring)\t{cJSON_Delete(newitem);return 0;}}\n+\tif (item->string)\t\t{newitem->string=cJSON_strdup(item->string);\t\t\tif (!newitem->string)\t\t{cJSON_Delete(newitem);return 0;}}\n+\t/* If non-recursive, then we're done! */\n+\tif (!recurse) return newitem;\n+\t/* Walk the ->next chain for the child. */\n+\tcptr=item->child;\n+\twhile (cptr)\n+\t{\n+\t\tnewchild=cJSON_Duplicate(cptr,1);\t\t/* Duplicate (with recurse) each item in the ->next chain */\n+\t\tif (!newchild) {cJSON_Delete(newitem);return 0;}\n+\t\tif (nptr)\t{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}\t/* If newitem->child already set, then crosswire ->prev and ->next and move on */\n+\t\telse\t\t{newitem->child=newchild;nptr=newchild;}\t\t\t\t\t/* Set newitem->child and move to it */\n+\t\tcptr=cptr->next;\n+\t}\n+\treturn newitem;\n+}\n+\n+void cJSON_Minify(char *json)\n+{\n+\tchar *into=json;\n+\twhile (*json)\n+\t{\n+\t\tif (*json==' ') json++;\n+\t\telse if (*json=='\\t') json++;\t/* Whitespace characters. */\n+\t\telse if (*json=='\\r') json++;\n+\t\telse if (*json=='\\n') json++;\n+\t\telse if (*json=='/' && json[1]=='/')  while (*json && *json!='\\n') json++;\t/* double-slash comments, to end of line. */\n+\t\telse if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}\t/* multiline comments. */\n+\t\telse if (*json=='\\\""'){*into++=*json++;while (*json && *json!='\\\""'){if (*json=='\\\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \\\"" sensitive. */\n+\t\telse *into++=*json++;\t\t\t/* All other characters. */\n+\t}\n+\t*into=0;\t/* and null-terminate. */\n }""}<_**next**_>{""sha"": ""fb8cd3bc577f3619757e20799cf01673869ba5b8"", ""filename"": ""src/cjson.h"", ""status"": ""modified"", ""additions"": 79, ""deletions"": 54, ""changes"": 133, ""blob_url"": ""https://github.com/esnet/iperf/blob/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/cjson.h"", ""raw_url"": ""https://github.com/esnet/iperf/raw/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/cjson.h"", ""contents_url"": ""https://api.github.com/repos/esnet/iperf/contents/src/cjson.h?ref=91f2fa59e8ed80dfbf400add0164ee0e508e412a"", ""patch"": ""@@ -29,97 +29,122 @@ extern \""C\""\n #endif\n \n /* cJSON Types: */\n-#define cJSON_False 0\n-#define cJSON_True 1\n-#define cJSON_NULL 2\n-#define cJSON_Number 3\n-#define cJSON_String 4\n-#define cJSON_Array 5\n-#define cJSON_Object 6\n+#define cJSON_False  (1 << 0)\n+#define cJSON_True   (1 << 1)\n+#define cJSON_NULL   (1 << 2)\n+#define cJSON_Number (1 << 3)\n+#define cJSON_String (1 << 4)\n+#define cJSON_Array  (1 << 5)\n+#define cJSON_Object (1 << 6)\n \t\n #define cJSON_IsReference 256\n+#define cJSON_StringIsConst 512\n \n /* The cJSON structure: */\n typedef struct cJSON {\n-\tstruct cJSON *next, *prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n+\tstruct cJSON *next,*prev;\t/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */\n \tstruct cJSON *child;\t\t/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */\n \n-\tint type;\t\t\t/* The type of the item, as above. */\n+\tint type;\t\t\t\t\t/* The type of the item, as above. */\n \n-\tchar *valuestring;\t\t/* The item's string, if type==cJSON_String */\n-\tint64_t valueint;\t\t/* The item's number, if type==cJSON_Number */\n-\tdouble valuefloat;\t\t/* The item's number, if type==cJSON_Number */\n+\tchar *valuestring;\t\t\t/* The item's string, if type==cJSON_String */\n+\tint64_t valueint;\t\t\t/* The item's number, if type==cJSON_Number */\n+\tdouble valuedouble;\t\t\t/* The item's number, if type==cJSON_Number */\n \n-\tchar *string;\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n+\tchar *string;\t\t\t\t/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */\n } cJSON;\n \n typedef struct cJSON_Hooks {\n-      void *(*malloc_fn)(size_t sz );\n-      void (*free_fn)( void *ptr );\n+      void *(*malloc_fn)(size_t sz);\n+      void (*free_fn)(void *ptr);\n } cJSON_Hooks;\n \n /* Supply malloc, realloc and free functions to cJSON */\n-extern void cJSON_InitHooks( cJSON_Hooks* hooks );\n+extern void cJSON_InitHooks(cJSON_Hooks* hooks);\n \n \n /* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */\n-extern cJSON *cJSON_Parse( const char *value );\n+extern cJSON *cJSON_Parse(const char *value);\n /* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */\n-extern char *cJSON_Print( cJSON *item );\n+extern char  *cJSON_Print(cJSON *item);\n /* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */\n-extern char *cJSON_PrintUnformatted( cJSON *item );\n+extern char  *cJSON_PrintUnformatted(cJSON *item);\n+/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */\n+extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);\n /* Delete a cJSON entity and all subentities. */\n-extern void cJSON_Delete( cJSON *c );\n+extern void   cJSON_Delete(cJSON *c);\n \n /* Returns the number of items in an array (or object). */\n-extern int cJSON_GetArraySize( cJSON *array );\n+extern int\t  cJSON_GetArraySize(cJSON *array);\n /* Retrieve item number \""item\"" from array \""array\"". Returns NULL if unsuccessful. */\n-extern cJSON *cJSON_GetArrayItem( cJSON *array, int item );\n+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);\n /* Get item \""string\"" from object. Case insensitive. */\n-extern cJSON *cJSON_GetObjectItem( cJSON *object, const char *string );\n-\n+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);\n+extern int cJSON_HasObjectItem(cJSON *object,const char *string);\n /* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */\n-extern const char *cJSON_GetErrorPtr( void );\n+extern const char *cJSON_GetErrorPtr(void);\n \t\n /* These calls create a cJSON item of the appropriate type. */\n-extern cJSON *cJSON_CreateNull( void );\n-extern cJSON *cJSON_CreateTrue( void );\n-extern cJSON *cJSON_CreateFalse( void );\n-extern cJSON *cJSON_CreateBool( int b );\n-extern cJSON *cJSON_CreateInt( int64_t num );\n-extern cJSON *cJSON_CreateFloat( double num );\n-extern cJSON *cJSON_CreateString( const char *string );\n-extern cJSON *cJSON_CreateArray( void );\n-extern cJSON *cJSON_CreateObject( void );\n+extern cJSON *cJSON_CreateNull(void);\n+extern cJSON *cJSON_CreateTrue(void);\n+extern cJSON *cJSON_CreateFalse(void);\n+extern cJSON *cJSON_CreateBool(int b);\n+extern cJSON *cJSON_CreateNumber(double num);\n+extern cJSON *cJSON_CreateString(const char *string);\n+extern cJSON *cJSON_CreateArray(void);\n+extern cJSON *cJSON_CreateObject(void);\n \n /* These utilities create an Array of count items. */\n-extern cJSON *cJSON_CreateIntArray( int64_t *numbers, int count );\n-extern cJSON *cJSON_CreateFloatArray( double *numbers, int count );\n-extern cJSON *cJSON_CreateStringArray( const char **strings, int count );\n+extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);\n+extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);\n+extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);\n+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);\n \n /* Append item to the specified array/object. */\n-extern void cJSON_AddItemToArray( cJSON *array, cJSON *item );\n-extern void cJSON_AddItemToObject( cJSON *object, const char *string, cJSON *item );\n+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);\n+extern void\tcJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);\n+extern void\tcJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);\t/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */\n /* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */\n-extern void cJSON_AddItemReferenceToArray( cJSON *array, cJSON *item );\n-extern void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item );\n+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);\n+extern void\tcJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);\n \n /* Remove/Detatch items from Arrays/Objects. */\n-extern cJSON *cJSON_DetachItemFromArray( cJSON *array, int which );\n-extern void cJSON_DeleteItemFromArray( cJSON *array, int which );\n-extern cJSON *cJSON_DetachItemFromObject( cJSON *object, const char *string );\n-extern void cJSON_DeleteItemFromObject( cJSON *object, const char *string );\n+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);\n+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);\n+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);\n+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);\n \t\n /* Update array items. */\n-extern void cJSON_ReplaceItemInArray( cJSON *array, int which, cJSON *newitem );\n-extern void cJSON_ReplaceItemInObject( cJSON *object, const char *string, cJSON *newitem );\n-\n-#define cJSON_AddNullToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateNull() )\n-#define cJSON_AddTrueToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateTrue() )\n-#define cJSON_AddFalseToObject( object, name )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateFalse() )\n-#define cJSON_AddIntToObject( object, name, n )\t\tcJSON_AddItemToObject( object, name, cJSON_CreateInt( n ) )\n-#define cJSON_AddFloatToObject( object, name, n )\tcJSON_AddItemToObject( object, name, cJSON_CreateFloat( n ) )\n-#define cJSON_AddStringToObject( object, name, s )\tcJSON_AddItemToObject( object, name, cJSON_CreateString( s ) )\n+extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);\t/* Shifts pre-existing items to the right. */\n+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);\n+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);\n+\n+/* Duplicate a cJSON item */\n+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);\n+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will\n+need to be released. With recurse!=0, it will duplicate any children connected to the item.\n+The item->next and ->prev pointers are always zero on return from Duplicate. */\n+\n+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */\n+/* If you supply a ptr in return_parse_end and parsing fails, then return_parse_end will contain a pointer to the error. If not, then cJSON_GetErrorPtr() does the job. */\n+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);\n+\n+extern void cJSON_Minify(char *json);\n+\n+/* Macros for creating things quickly. */\n+#define cJSON_AddNullToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateNull())\n+#define cJSON_AddTrueToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateTrue())\n+#define cJSON_AddFalseToObject(object,name)\t\tcJSON_AddItemToObject(object, name, cJSON_CreateFalse())\n+#define cJSON_AddBoolToObject(object,name,b)\tcJSON_AddItemToObject(object, name, cJSON_CreateBool(b))\n+#define cJSON_AddNumberToObject(object,name,n)\tcJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))\n+#define cJSON_AddStringToObject(object,name,s)\tcJSON_AddItemToObject(object, name, cJSON_CreateString(s))\n+\n+/* When assigning an integer value, it needs to be propagated to valuedouble too. */\n+#define cJSON_SetIntValue(object,val)\t\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n+#define cJSON_SetNumberValue(object,val)\t\t((object)?(object)->valueint=(object)->valuedouble=(val):(val))\n+\n+/* Macro for iterating over an array */\n+#define cJSON_ArrayForEach(pos, head)\t\t\tfor(pos = (head)->child; pos != NULL; pos = pos->next)\n \n #ifdef __cplusplus\n }""}<_**next**_>{""sha"": ""4a8b14b78f62439a67ca1348b3c2053c724b650a"", ""filename"": ""src/iperf_api.c"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 29, ""changes"": 68, ""blob_url"": ""https://github.com/esnet/iperf/blob/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/iperf_api.c"", ""raw_url"": ""https://github.com/esnet/iperf/raw/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/iperf_api.c"", ""contents_url"": ""https://api.github.com/repos/esnet/iperf/contents/src/iperf_api.c?ref=91f2fa59e8ed80dfbf400add0164ee0e508e412a"", ""patch"": ""@@ -523,11 +523,11 @@ iperf_on_connect(struct iperf_test *test)\n \tcJSON_AddStringToObject(test->json_start, \""cookie\"", test->cookie);\n         if (test->protocol->id == SOCK_STREAM) {\n \t    if (test->settings->mss)\n-\t\tcJSON_AddIntToObject(test->json_start, \""tcp_mss\"", test->settings->mss);\n+\t\tcJSON_AddNumberToObject(test->json_start, \""tcp_mss\"", test->settings->mss);\n \t    else {\n \t\tlen = sizeof(opt);\n \t\tgetsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);\n-\t\tcJSON_AddIntToObject(test->json_start, \""tcp_mss_default\"", opt);\n+\t\tcJSON_AddNumberToObject(test->json_start, \""tcp_mss_default\"", opt);\n \t    }\n \t}\n     } else if (test->verbose) {\n@@ -1135,40 +1135,50 @@ send_parameters(struct iperf_test *test)\n \t    cJSON_AddTrueToObject(j, \""tcp\"");\n \telse if (test->protocol->id == Pudp)\n \t    cJSON_AddTrueToObject(j, \""udp\"");\n-\tcJSON_AddIntToObject(j, \""omit\"", test->omit);\n+\tcJSON_AddNumberToObject(j, \""omit\"", test->omit);\n \tif (test->server_affinity != -1)\n-\t    cJSON_AddIntToObject(j, \""server_affinity\"", test->server_affinity);\n+\t    cJSON_AddNumberToObject(j, \""server_affinity\"", test->server_affinity);\n \tif (test->duration)\n-\t    cJSON_AddIntToObject(j, \""time\"", test->duration);\n+\t    cJSON_AddNumberToObject(j, \""time\"", test->duration);\n \tif (test->settings->bytes)\n-\t    cJSON_AddIntToObject(j, \""num\"", test->settings->bytes);\n+\t    cJSON_AddNumberToObject(j, \""num\"", test->settings->bytes);\n \tif (test->settings->blocks)\n-\t    cJSON_AddIntToObject(j, \""blockcount\"", test->settings->blocks);\n+\t    cJSON_AddNumberToObject(j, \""blockcount\"", test->settings->blocks);\n \tif (test->settings->mss)\n-\t    cJSON_AddIntToObject(j, \""MSS\"", test->settings->mss);\n+\t    cJSON_AddNumberToObject(j, \""MSS\"", test->settings->mss);\n \tif (test->no_delay)\n \t    cJSON_AddTrueToObject(j, \""nodelay\"");\n-\tcJSON_AddIntToObject(j, \""parallel\"", test->num_streams);\n+\tcJSON_AddNumberToObject(j, \""parallel\"", test->num_streams);\n \tif (test->reverse)\n \t    cJSON_AddTrueToObject(j, \""reverse\"");\n \tif (test->settings->socket_bufsize)\n-\t    cJSON_AddIntToObject(j, \""window\"", test->settings->socket_bufsize);\n+\t    cJSON_AddNumberToObject(j, \""window\"", test->settings->socket_bufsize);\n \tif (test->settings->blksize)\n-\t    cJSON_AddIntToObject(j, \""len\"", test->settings->blksize);\n+\t    cJSON_AddNumberToObject(j, \""len\"", test->settings->blksize);\n \tif (test->settings->rate)\n-\t    cJSON_AddIntToObject(j, \""bandwidth\"", test->settings->rate);\n+\t    cJSON_AddNumberToObject(j, \""bandwidth\"", test->settings->rate);\n \tif (test->settings->burst)\n-\t    cJSON_AddIntToObject(j, \""burst\"", test->settings->burst);\n+\t    cJSON_AddNumberToObject(j, \""burst\"", test->settings->burst);\n \tif (test->settings->tos)\n-\t    cJSON_AddIntToObject(j, \""TOS\"", test->settings->tos);\n+\t    cJSON_AddNumberToObject(j, \""TOS\"", test->settings->tos);\n \tif (test->settings->flowlabel)\n-\t    cJSON_AddIntToObject(j, \""flowlabel\"", test->settings->flowlabel);\n+\t    cJSON_AddNumberToObject(j, \""flowlabel\"", test->settings->flowlabel);\n \tif (test->title)\n \t    cJSON_AddStringToObject(j, \""title\"", test->title);\n \tif (test->congestion)\n \t    cJSON_AddStringToObject(j, \""congestion\"", test->congestion);\n \tif (test->get_server_output)\n+<<<<<<< HEAD\n \t    cJSON_AddIntToObject(j, \""get_server_output\"", iperf_get_test_get_server_output(test));\n+=======\n+\t    cJSON_AddNumberToObject(j, \""get_server_output\"", iperf_get_test_get_server_output(test));\n+\tif (test->udp_counters_64bit)\n+\t    cJSON_AddNumberToObject(j, \""udp_counters_64bit\"", iperf_get_test_udp_counters_64bit(test));\n+\tif (test->no_fq_socket_pacing)\n+\t    cJSON_AddNumberToObject(j, \""no_fq_socket_pacing\"", iperf_get_no_fq_socket_pacing(test));\n+\n+\tcJSON_AddStringToObject(j, \""client_version\"", IPERF_VERSION);\n+>>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a\n \n \tif (test->debug) {\n \t    printf(\""send_parameters:\\n%s\\n\"", cJSON_Print(j));\n@@ -1267,14 +1277,14 @@ send_results(struct iperf_test *test)\n \ti_errno = IEPACKAGERESULTS;\n \tr = -1;\n     } else {\n-\tcJSON_AddFloatToObject(j, \""cpu_util_total\"", test->cpu_util[0]);\n-\tcJSON_AddFloatToObject(j, \""cpu_util_user\"", test->cpu_util[1]);\n-\tcJSON_AddFloatToObject(j, \""cpu_util_system\"", test->cpu_util[2]);\n+\tcJSON_AddNumberToObject(j, \""cpu_util_total\"", test->cpu_util[0]);\n+\tcJSON_AddNumberToObject(j, \""cpu_util_user\"", test->cpu_util[1]);\n+\tcJSON_AddNumberToObject(j, \""cpu_util_system\"", test->cpu_util[2]);\n \tif ( ! test->sender )\n \t    sender_has_retransmits = -1;\n \telse\n \t    sender_has_retransmits = test->sender_has_retransmits;\n-\tcJSON_AddIntToObject(j, \""sender_has_retransmits\"", sender_has_retransmits);\n+\tcJSON_AddNumberToObject(j, \""sender_has_retransmits\"", sender_has_retransmits);\n \n \t/* If on the server and sending server output, then do this */\n \tif (test->role == 's' && test->get_server_output) {\n@@ -1318,12 +1328,12 @@ send_results(struct iperf_test *test)\n \t\t    cJSON_AddItemToArray(j_streams, j_stream);\n \t\t    bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;\n \t\t    retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;\n-\t\t    cJSON_AddIntToObject(j_stream, \""id\"", sp->id);\n-\t\t    cJSON_AddIntToObject(j_stream, \""bytes\"", bytes_transferred);\n-\t\t    cJSON_AddIntToObject(j_stream, \""retransmits\"", retransmits);\n-\t\t    cJSON_AddFloatToObject(j_stream, \""jitter\"", sp->jitter);\n-\t\t    cJSON_AddIntToObject(j_stream, \""errors\"", sp->cnt_error);\n-\t\t    cJSON_AddIntToObject(j_stream, \""packets\"", sp->packet_count);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""id\"", sp->id);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""bytes\"", bytes_transferred);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""retransmits\"", retransmits);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""jitter\"", sp->jitter);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""errors\"", sp->cnt_error);\n+\t\t    cJSON_AddNumberToObject(j_stream, \""packets\"", sp->packet_count);\n \t\t}\n \t    }\n \t    if (r == 0 && test->debug) {\n@@ -1384,9 +1394,9 @@ get_results(struct iperf_test *test)\n \t\tprintf(\""get_results\\n%s\\n\"", cJSON_Print(j));\n \t    }\n \n-\t    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;\n-\t    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;\n-\t    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;\n+\t    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;\n+\t    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;\n+\t    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;\n \t    result_has_retransmits = j_sender_has_retransmits->valueint;\n \t    if (! test->sender)\n \t\ttest->sender_has_retransmits = result_has_retransmits;\n@@ -1415,7 +1425,7 @@ get_results(struct iperf_test *test)\n \t\t\t    sid = j_id->valueint;\n \t\t\t    bytes_transferred = j_bytes->valueint;\n \t\t\t    retransmits = j_retransmits->valueint;\n-\t\t\t    jitter = j_jitter->valuefloat;\n+\t\t\t    jitter = j_jitter->valuedouble;\n \t\t\t    cerror = j_errors->valueint;\n \t\t\t    pcount = j_packets->valueint;\n \t\t\t    SLIST_FOREACH(sp, &test->streams, streams)""}<_**next**_>{""sha"": ""f62191c9430f284ebd3eff19cb7e4e07c4ebc6e2"", ""filename"": ""src/iperf_util.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/esnet/iperf/blob/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/iperf_util.c"", ""raw_url"": ""https://github.com/esnet/iperf/raw/91f2fa59e8ed80dfbf400add0164ee0e508e412a/src/iperf_util.c"", ""contents_url"": ""https://api.github.com/repos/esnet/iperf/contents/src/iperf_util.c?ref=91f2fa59e8ed80dfbf400add0164ee0e508e412a"", ""patch"": ""@@ -272,10 +272,10 @@ iperf_json_printf(const char *format, ...)\n \t\tj = cJSON_CreateBool(va_arg(argp, int));\n \t\tbreak;\n \t\tcase 'd':\n-\t\tj = cJSON_CreateInt(va_arg(argp, int64_t));\n+\t\tj = cJSON_CreateNumber(va_arg(argp, int64_t));\n \t\tbreak;\n \t\tcase 'f':\n-\t\tj = cJSON_CreateFloat(va_arg(argp, double));\n+\t\tj = cJSON_CreateNumber(va_arg(argp, double));\n \t\tbreak;\n \t\tcase 's':\n \t\tj = cJSON_CreateString(va_arg(argp, char *));""}","JSON_write(int fd, cJSON *json)
{
    uint32_t hsize, nsize;
    char *str;
    int r = 0;

    str = cJSON_PrintUnformatted(json);
    if (str == NULL)
	r = -1;
    else {
	hsize = strlen(str);
	nsize = htonl(hsize);
	if (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)
	    r = -1;
	else {
	    if (Nwrite(fd, str, hsize, Ptcp) < 0)
		r = -1;
	}
	free(str);
    }
    return r;
}
","JSON_write(int fd, cJSON *json)
{
    uint32_t hsize, nsize;
    char *str;
    int r = 0;

    str = cJSON_PrintUnformatted(json);
    if (str == NULL)
	r = -1;
    else {
	hsize = strlen(str);
	nsize = htonl(hsize);
	if (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)
	    r = -1;
	else {
	    if (Nwrite(fd, str, hsize, Ptcp) < 0)
		r = -1;
	}
	free(str);
    }
    return r;
}
",C,,,,"@@ -523,11 +523,11 @@ iperf_on_connect(struct iperf_test *test)
 	cJSON_AddStringToObject(test->json_start, ""cookie"", test->cookie);
         if (test->protocol->id == SOCK_STREAM) {
 	    if (test->settings->mss)
-		cJSON_AddIntToObject(test->json_start, ""tcp_mss"", test->settings->mss);
+		cJSON_AddNumberToObject(test->json_start, ""tcp_mss"", test->settings->mss);
 	    else {
 		len = sizeof(opt);
 		getsockopt(test->ctrl_sck, IPPROTO_TCP, TCP_MAXSEG, &opt, &len);
-		cJSON_AddIntToObject(test->json_start, ""tcp_mss_default"", opt);
+		cJSON_AddNumberToObject(test->json_start, ""tcp_mss_default"", opt);
 	    }
 	}
     } else if (test->verbose) {
@@ -1135,40 +1135,50 @@ send_parameters(struct iperf_test *test)
 	    cJSON_AddTrueToObject(j, ""tcp"");
 	else if (test->protocol->id == Pudp)
 	    cJSON_AddTrueToObject(j, ""udp"");
-	cJSON_AddIntToObject(j, ""omit"", test->omit);
+	cJSON_AddNumberToObject(j, ""omit"", test->omit);
 	if (test->server_affinity != -1)
-	    cJSON_AddIntToObject(j, ""server_affinity"", test->server_affinity);
+	    cJSON_AddNumberToObject(j, ""server_affinity"", test->server_affinity);
 	if (test->duration)
-	    cJSON_AddIntToObject(j, ""time"", test->duration);
+	    cJSON_AddNumberToObject(j, ""time"", test->duration);
 	if (test->settings->bytes)
-	    cJSON_AddIntToObject(j, ""num"", test->settings->bytes);
+	    cJSON_AddNumberToObject(j, ""num"", test->settings->bytes);
 	if (test->settings->blocks)
-	    cJSON_AddIntToObject(j, ""blockcount"", test->settings->blocks);
+	    cJSON_AddNumberToObject(j, ""blockcount"", test->settings->blocks);
 	if (test->settings->mss)
-	    cJSON_AddIntToObject(j, ""MSS"", test->settings->mss);
+	    cJSON_AddNumberToObject(j, ""MSS"", test->settings->mss);
 	if (test->no_delay)
 	    cJSON_AddTrueToObject(j, ""nodelay"");
-	cJSON_AddIntToObject(j, ""parallel"", test->num_streams);
+	cJSON_AddNumberToObject(j, ""parallel"", test->num_streams);
 	if (test->reverse)
 	    cJSON_AddTrueToObject(j, ""reverse"");
 	if (test->settings->socket_bufsize)
-	    cJSON_AddIntToObject(j, ""window"", test->settings->socket_bufsize);
+	    cJSON_AddNumberToObject(j, ""window"", test->settings->socket_bufsize);
 	if (test->settings->blksize)
-	    cJSON_AddIntToObject(j, ""len"", test->settings->blksize);
+	    cJSON_AddNumberToObject(j, ""len"", test->settings->blksize);
 	if (test->settings->rate)
-	    cJSON_AddIntToObject(j, ""bandwidth"", test->settings->rate);
+	    cJSON_AddNumberToObject(j, ""bandwidth"", test->settings->rate);
 	if (test->settings->burst)
-	    cJSON_AddIntToObject(j, ""burst"", test->settings->burst);
+	    cJSON_AddNumberToObject(j, ""burst"", test->settings->burst);
 	if (test->settings->tos)
-	    cJSON_AddIntToObject(j, ""TOS"", test->settings->tos);
+	    cJSON_AddNumberToObject(j, ""TOS"", test->settings->tos);
 	if (test->settings->flowlabel)
-	    cJSON_AddIntToObject(j, ""flowlabel"", test->settings->flowlabel);
+	    cJSON_AddNumberToObject(j, ""flowlabel"", test->settings->flowlabel);
 	if (test->title)
 	    cJSON_AddStringToObject(j, ""title"", test->title);
 	if (test->congestion)
 	    cJSON_AddStringToObject(j, ""congestion"", test->congestion);
 	if (test->get_server_output)
+<<<<<<< HEAD
 	    cJSON_AddIntToObject(j, ""get_server_output"", iperf_get_test_get_server_output(test));
+=======
+	    cJSON_AddNumberToObject(j, ""get_server_output"", iperf_get_test_get_server_output(test));
+	if (test->udp_counters_64bit)
+	    cJSON_AddNumberToObject(j, ""udp_counters_64bit"", iperf_get_test_udp_counters_64bit(test));
+	if (test->no_fq_socket_pacing)
+	    cJSON_AddNumberToObject(j, ""no_fq_socket_pacing"", iperf_get_no_fq_socket_pacing(test));
+
+	cJSON_AddStringToObject(j, ""client_version"", IPERF_VERSION);
+>>>>>>> ed94082... Fix a buffer overflow / heap corruption issue that could occur if a
 
 	if (test->debug) {
 	    printf(""send_parameters:\n%s\n"", cJSON_Print(j));
@@ -1267,14 +1277,14 @@ send_results(struct iperf_test *test)
 	i_errno = IEPACKAGERESULTS;
 	r = -1;
     } else {
-	cJSON_AddFloatToObject(j, ""cpu_util_total"", test->cpu_util[0]);
-	cJSON_AddFloatToObject(j, ""cpu_util_user"", test->cpu_util[1]);
-	cJSON_AddFloatToObject(j, ""cpu_util_system"", test->cpu_util[2]);
+	cJSON_AddNumberToObject(j, ""cpu_util_total"", test->cpu_util[0]);
+	cJSON_AddNumberToObject(j, ""cpu_util_user"", test->cpu_util[1]);
+	cJSON_AddNumberToObject(j, ""cpu_util_system"", test->cpu_util[2]);
 	if ( ! test->sender )
 	    sender_has_retransmits = -1;
 	else
 	    sender_has_retransmits = test->sender_has_retransmits;
-	cJSON_AddIntToObject(j, ""sender_has_retransmits"", sender_has_retransmits);
+	cJSON_AddNumberToObject(j, ""sender_has_retransmits"", sender_has_retransmits);
 
 	/* If on the server and sending server output, then do this */
 	if (test->role == 's' && test->get_server_output) {
@@ -1318,12 +1328,12 @@ send_results(struct iperf_test *test)
 		    cJSON_AddItemToArray(j_streams, j_stream);
 		    bytes_transferred = test->sender ? sp->result->bytes_sent : sp->result->bytes_received;
 		    retransmits = (test->sender && test->sender_has_retransmits) ? sp->result->stream_retrans : -1;
-		    cJSON_AddIntToObject(j_stream, ""id"", sp->id);
-		    cJSON_AddIntToObject(j_stream, ""bytes"", bytes_transferred);
-		    cJSON_AddIntToObject(j_stream, ""retransmits"", retransmits);
-		    cJSON_AddFloatToObject(j_stream, ""jitter"", sp->jitter);
-		    cJSON_AddIntToObject(j_stream, ""errors"", sp->cnt_error);
-		    cJSON_AddIntToObject(j_stream, ""packets"", sp->packet_count);
+		    cJSON_AddNumberToObject(j_stream, ""id"", sp->id);
+		    cJSON_AddNumberToObject(j_stream, ""bytes"", bytes_transferred);
+		    cJSON_AddNumberToObject(j_stream, ""retransmits"", retransmits);
+		    cJSON_AddNumberToObject(j_stream, ""jitter"", sp->jitter);
+		    cJSON_AddNumberToObject(j_stream, ""errors"", sp->cnt_error);
+		    cJSON_AddNumberToObject(j_stream, ""packets"", sp->packet_count);
 		}
 	    }
 	    if (r == 0 && test->debug) {
@@ -1384,9 +1394,9 @@ get_results(struct iperf_test *test)
 		printf(""get_results\n%s\n"", cJSON_Print(j));
 	    }
 
-	    test->remote_cpu_util[0] = j_cpu_util_total->valuefloat;
-	    test->remote_cpu_util[1] = j_cpu_util_user->valuefloat;
-	    test->remote_cpu_util[2] = j_cpu_util_system->valuefloat;
+	    test->remote_cpu_util[0] = j_cpu_util_total->valuedouble;
+	    test->remote_cpu_util[1] = j_cpu_util_user->valuedouble;
+	    test->remote_cpu_util[2] = j_cpu_util_system->valuedouble;
 	    result_has_retransmits = j_sender_has_retransmits->valueint;
 	    if (! test->sender)
 		test->sender_has_retransmits = result_has_retransmits;
@@ -1415,7 +1425,7 @@ get_results(struct iperf_test *test)
 			    sid = j_id->valueint;
 			    bytes_transferred = j_bytes->valueint;
 			    retransmits = j_retransmits->valueint;
-			    jitter = j_jitter->valuefloat;
+			    jitter = j_jitter->valuedouble;
 			    cerror = j_errors->valueint;
 			    pcount = j_packets->valueint;
 			    SLIST_FOREACH(sp, &test->streams, streams)",iperf,91f2fa59e8ed80dfbf400add0164ee0e508e412a,fec5bd1db87eed176c50b9697be2eb3e960b6661,0,"JSON_write(int fd, cJSON *json)
{
    uint32_t hsize, nsize;
    char *str;
    int r = 0;

    str = cJSON_PrintUnformatted(json);
    if (str == NULL)
	r = -1;
    else {
	hsize = strlen(str);
	nsize = htonl(hsize);
	if (Nwrite(fd, (char*) &nsize, sizeof(nsize), Ptcp) < 0)
	    r = -1;
	else {
	    if (Nwrite(fd, str, hsize, Ptcp) < 0)
		r = -1;
	}
	free(str);
    }
    return r;
}
"
56477,,Local,Not required,Complete,CVE-2015-8844,https://www.cvedetails.com/cve/CVE-2015-8844/,CWE-20,Medium,,,,2016-04-27,4.7,"The signal implementation in the Linux kernel before 4.3.5 on powerpc platforms does not check for an MSR with both the S and T bits set, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application.",2018-01-04,DoS ,0,https://github.com/torvalds/linux/commit/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55,d2b9d2a5ad5ef04ff978c9923d19730cb05efd55,"powerpc/tm: Block signal return setting invalid MSR state

Currently we allow both the MSR T and S bits to be set by userspace on
a signal return.  Unfortunately this is a reserved configuration and
will cause a TM Bad Thing exception if attempted (via rfid).

This patch checks for this case in both the 32 and 64 bit signals
code.  If both T and S are set, we mark the context as invalid.

Found using a syscall fuzzer.

Fixes: 2b0a576d15e0 (""powerpc: Add new transactional memory state to the signal context"")
Cc: stable@vger.kernel.org # v3.9+
Signed-off-by: Michael Neuling <mikey@neuling.org>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>",0,arch/powerpc/kernel/signal_32.c,"{""sha"": ""2220f7a60def314be5c8f23e18ceb8982061cb18"", ""filename"": ""arch/powerpc/include/asm/reg.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/include/asm/reg.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/include/asm/reg.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/include/asm/reg.h?ref=d2b9d2a5ad5ef04ff978c9923d19730cb05efd55"", ""patch"": ""@@ -108,6 +108,7 @@\n #define MSR_TS_T\t__MASK(MSR_TS_T_LG)\t/*  Transaction Transactional */\n #define MSR_TS_MASK\t(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */\n #define MSR_TM_ACTIVE(x) (((x) & MSR_TS_MASK) != 0) /* Transaction active? */\n+#define MSR_TM_RESV(x) (((x) & MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */\n #define MSR_TM_TRANSACTIONAL(x)\t(((x) & MSR_TS_MASK) == MSR_TS_T)\n #define MSR_TM_SUSPENDED(x)\t(((x) & MSR_TS_MASK) == MSR_TS_S)\n ""}<_**next**_>{""sha"": ""ef7c24e84a623882c8f98dbc93aa7ab318a4ff68"", ""filename"": ""arch/powerpc/kernel/signal_32.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 5, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/kernel/signal_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/kernel/signal_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/signal_32.c?ref=d2b9d2a5ad5ef04ff978c9923d19730cb05efd55"", ""patch"": ""@@ -875,6 +875,15 @@ static long restore_tm_user_regs(struct pt_regs *regs,\n \t\treturn 1;\n #endif /* CONFIG_SPE */\n \n+\t/* Get the top half of the MSR from the user context */\n+\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n+\t\treturn 1;\n+\tmsr_hi <<= 32;\n+\t/* If TM bits are set to the reserved value, it's an invalid context */\n+\tif (MSR_TM_RESV(msr_hi))\n+\t\treturn 1;\n+\t/* Pull in the MSR TM bits from the user context */\n+\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n \t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n \t * registers, including FP and V[S]Rs.  After recheckpointing, the\n \t * transactional versions should be loaded.\n@@ -884,11 +893,6 @@ static long restore_tm_user_regs(struct pt_regs *regs,\n \tcurrent->thread.tm_texasr |= TEXASR_FS;\n \t/* This loads the checkpointed FP/VEC state, if used */\n \ttm_recheckpoint(&current->thread, msr);\n-\t/* Get the top half of the MSR */\n-\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n-\t\treturn 1;\n-\t/* Pull in MSR TM from user context */\n-\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);\n \n \t/* This loads the speculative FP/VEC state, if used */\n \tif (msr & MSR_FP) {""}<_**next**_>{""sha"": ""c676ecec0869b26216e87483f54c2c6906ea6d01"", ""filename"": ""arch/powerpc/kernel/signal_64.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/kernel/signal_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/d2b9d2a5ad5ef04ff978c9923d19730cb05efd55/arch/powerpc/kernel/signal_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/signal_64.c?ref=d2b9d2a5ad5ef04ff978c9923d19730cb05efd55"", ""patch"": ""@@ -438,6 +438,10 @@ static long restore_tm_sigcontexts(struct pt_regs *regs,\n \n \t/* get MSR separately, transfer the LE bit if doing signal return */\n \terr |= __get_user(msr, &sc->gp_regs[PT_MSR]);\n+\t/* Don't allow reserved mode. */\n+\tif (MSR_TM_RESV(msr))\n+\t\treturn -EINVAL;\n+\n \t/* pull in MSR TM from user context */\n \tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK);\n ""}","static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
{
	compat_sigset_t	cset;

	switch (_NSIG_WORDS) {
	case 4: cset.sig[6] = set->sig[3] & 0xffffffffull;
		cset.sig[7] = set->sig[3] >> 32;
	case 3: cset.sig[4] = set->sig[2] & 0xffffffffull;
		cset.sig[5] = set->sig[2] >> 32;
	case 2: cset.sig[2] = set->sig[1] & 0xffffffffull;
		cset.sig[3] = set->sig[1] >> 32;
	case 1: cset.sig[0] = set->sig[0] & 0xffffffffull;
		cset.sig[1] = set->sig[0] >> 32;
	}
	return copy_to_user(uset, &cset, sizeof(*uset));
}
","static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
{
	compat_sigset_t	cset;

	switch (_NSIG_WORDS) {
	case 4: cset.sig[6] = set->sig[3] & 0xffffffffull;
		cset.sig[7] = set->sig[3] >> 32;
	case 3: cset.sig[4] = set->sig[2] & 0xffffffffull;
		cset.sig[5] = set->sig[2] >> 32;
	case 2: cset.sig[2] = set->sig[1] & 0xffffffffull;
		cset.sig[3] = set->sig[1] >> 32;
	case 1: cset.sig[0] = set->sig[0] & 0xffffffffull;
		cset.sig[1] = set->sig[0] >> 32;
	}
	return copy_to_user(uset, &cset, sizeof(*uset));
}
",C,,,,"@@ -875,6 +875,15 @@ static long restore_tm_user_regs(struct pt_regs *regs,
 		return 1;
 #endif /* CONFIG_SPE */
 
+	/* Get the top half of the MSR from the user context */
+	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
+		return 1;
+	msr_hi <<= 32;
+	/* If TM bits are set to the reserved value, it's an invalid context */
+	if (MSR_TM_RESV(msr_hi))
+		return 1;
+	/* Pull in the MSR TM bits from the user context */
+	regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
@@ -884,11 +893,6 @@ static long restore_tm_user_regs(struct pt_regs *regs,
 	current->thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&current->thread, msr);
-	/* Get the top half of the MSR */
-	if (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))
-		return 1;
-	/* Pull in MSR TM from user context */
-	regs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr & MSR_FP) {",linux,d2b9d2a5ad5ef04ff978c9923d19730cb05efd55,1ec218373b8ebda821aec00bb156a9c94fad9cd4,0,"static inline int put_sigset_t(compat_sigset_t __user *uset, sigset_t *set)
{
	compat_sigset_t	cset;

	switch (_NSIG_WORDS) {
	case 4: cset.sig[6] = set->sig[3] & 0xffffffffull;
		cset.sig[7] = set->sig[3] >> 32;
	case 3: cset.sig[4] = set->sig[2] & 0xffffffffull;
		cset.sig[5] = set->sig[2] >> 32;
	case 2: cset.sig[2] = set->sig[1] & 0xffffffffull;
		cset.sig[3] = set->sig[1] >> 32;
	case 1: cset.sig[0] = set->sig[0] & 0xffffffffull;
		cset.sig[1] = set->sig[0] >> 32;
	}
	return copy_to_user(uset, &cset, sizeof(*uset));
}
"
39260,,Local,Single system,Complete,CVE-2014-1874,https://www.cvedetails.com/cve/CVE-2014-1874/,CWE-20,Medium,,,,2014-02-28,4.4,The security_context_to_sid_core function in security/selinux/ss/services.c in the Linux kernel before 3.13.4 allows local users to cause a denial of service (system crash) by leveraging the CAP_MAC_ADMIN capability to set a zero-length security context.,2015-10-13,DoS ,0,https://github.com/torvalds/linux/commit/2172fa709ab32ca60e86179dc67d0857be8e2c98,2172fa709ab32ca60e86179dc67d0857be8e2c98,"SELinux:  Fix kernel BUG on empty security contexts.

Setting an empty security context (length=0) on a file will
lead to incorrectly dereferencing the type and other fields
of the security context structure, yielding a kernel BUG.
As a zero-length security context is never valid, just reject
all such security contexts whether coming from userspace
via setxattr or coming from the filesystem upon a getxattr
request by SELinux.

Setting a security context value (empty or otherwise) unknown to
SELinux in the first place is only possible for a root process
(CAP_MAC_ADMIN), and, if running SELinux in enforcing mode, only
if the corresponding SELinux mac_admin permission is also granted
to the domain by policy.  In Fedora policies, this is only allowed for
specific domains such as livecd for setting down security contexts
that are not defined in the build host policy.

Reproducer:
su
setenforce 0
touch foo
setfattr -n security.selinux foo

Caveat:
Relabeling or removing foo after doing the above may not be possible
without booting with SELinux disabled.  Any subsequent access to foo
after doing the above will also trigger the BUG.

BUG output from Matthew Thode:
[  473.893141] ------------[ cut here ]------------
[  473.962110] kernel BUG at security/selinux/ss/services.c:654!
[  473.995314] invalid opcode: 0000 [#6] SMP
[  474.027196] Modules linked in:
[  474.058118] CPU: 0 PID: 8138 Comm: ls Tainted: G      D   I
3.13.0-grsec #1
[  474.116637] Hardware name: Supermicro X8ST3/X8ST3, BIOS 2.0
07/29/10
[  474.149768] task: ffff8805f50cd010 ti: ffff8805f50cd488 task.ti:
ffff8805f50cd488
[  474.183707] RIP: 0010:[<ffffffff814681c7>]  [<ffffffff814681c7>]
context_struct_compute_av+0xce/0x308
[  474.219954] RSP: 0018:ffff8805c0ac3c38  EFLAGS: 00010246
[  474.252253] RAX: 0000000000000000 RBX: ffff8805c0ac3d94 RCX:
0000000000000100
[  474.287018] RDX: ffff8805e8aac000 RSI: 00000000ffffffff RDI:
ffff8805e8aaa000
[  474.321199] RBP: ffff8805c0ac3cb8 R08: 0000000000000010 R09:
0000000000000006
[  474.357446] R10: 0000000000000000 R11: ffff8805c567a000 R12:
0000000000000006
[  474.419191] R13: ffff8805c2b74e88 R14: 00000000000001da R15:
0000000000000000
[  474.453816] FS:  00007f2e75220800(0000) GS:ffff88061fc00000(0000)
knlGS:0000000000000000
[  474.489254] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  474.522215] CR2: 00007f2e74716090 CR3: 00000005c085e000 CR4:
00000000000207f0
[  474.556058] Stack:
[  474.584325]  ffff8805c0ac3c98 ffffffff811b549b ffff8805c0ac3c98
ffff8805f1190a40
[  474.618913]  ffff8805a6202f08 ffff8805c2b74e88 00068800d0464990
ffff8805e8aac860
[  474.653955]  ffff8805c0ac3cb8 000700068113833a ffff880606c75060
ffff8805c0ac3d94
[  474.690461] Call Trace:
[  474.723779]  [<ffffffff811b549b>] ? lookup_fast+0x1cd/0x22a
[  474.778049]  [<ffffffff81468824>] security_compute_av+0xf4/0x20b
[  474.811398]  [<ffffffff8196f419>] avc_compute_av+0x2a/0x179
[  474.843813]  [<ffffffff8145727b>] avc_has_perm+0x45/0xf4
[  474.875694]  [<ffffffff81457d0e>] inode_has_perm+0x2a/0x31
[  474.907370]  [<ffffffff81457e76>] selinux_inode_getattr+0x3c/0x3e
[  474.938726]  [<ffffffff81455cf6>] security_inode_getattr+0x1b/0x22
[  474.970036]  [<ffffffff811b057d>] vfs_getattr+0x19/0x2d
[  475.000618]  [<ffffffff811b05e5>] vfs_fstatat+0x54/0x91
[  475.030402]  [<ffffffff811b063b>] vfs_lstat+0x19/0x1b
[  475.061097]  [<ffffffff811b077e>] SyS_newlstat+0x15/0x30
[  475.094595]  [<ffffffff8113c5c1>] ? __audit_syscall_entry+0xa1/0xc3
[  475.148405]  [<ffffffff8197791e>] system_call_fastpath+0x16/0x1b
[  475.179201] Code: 00 48 85 c0 48 89 45 b8 75 02 0f 0b 48 8b 45 a0 48
8b 3d 45 d0 b6 00 8b 40 08 89 c6 ff ce e8 d1 b0 06 00 48 85 c0 49 89 c7
75 02 <0f> 0b 48 8b 45 b8 4c 8b 28 eb 1e 49 8d 7d 08 be 80 01 00 00 e8
[  475.255884] RIP  [<ffffffff814681c7>]
context_struct_compute_av+0xce/0x308
[  475.296120]  RSP <ffff8805c0ac3c38>
[  475.328734] ---[ end trace f076482e9d754adc ]---

Reported-by:  Matthew Thode <mthode@mthode.org>
Signed-off-by: Stephen Smalley <sds@tycho.nsa.gov>
Cc: stable@vger.kernel.org
Signed-off-by: Paul Moore <pmoore@redhat.com>",0,security/selinux/ss/services.c,"{""sha"": ""f1e46d776544fc4694a78ad436f5d9b06ece5589"", ""filename"": ""security/selinux/ss/services.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/2172fa709ab32ca60e86179dc67d0857be8e2c98/security/selinux/ss/services.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/2172fa709ab32ca60e86179dc67d0857be8e2c98/security/selinux/ss/services.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/security/selinux/ss/services.c?ref=2172fa709ab32ca60e86179dc67d0857be8e2c98"", ""patch"": ""@@ -1232,6 +1232,10 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n \tstruct context context;\n \tint rc = 0;\n \n+\t/* An empty security context is never valid. */\n+\tif (!scontext_len)\n+\t\treturn -EINVAL;\n+\n \tif (!ss_initialized) {\n \t\tint i;\n ""}","static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)
{
	int i, fail = 0;

	for (i = 0; i < 4; i++)
		if (addr[i] != (input[i] & mask[i])) {
			fail = 1;
			break;
		}

	return !fail;
}
","static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)
{
	int i, fail = 0;

	for (i = 0; i < 4; i++)
		if (addr[i] != (input[i] & mask[i])) {
			fail = 1;
			break;
		}

	return !fail;
}
",C,,,,"@@ -1232,6 +1232,10 @@ static int security_context_to_sid_core(const char *scontext, u32 scontext_len,
 	struct context context;
 	int rc = 0;
 
+	/* An empty security context is never valid. */
+	if (!scontext_len)
+		return -EINVAL;
+
 	if (!ss_initialized) {
 		int i;
 ",linux,2172fa709ab32ca60e86179dc67d0857be8e2c98,6a96e15096da6e7491107321cfa660c7c2aa119d,0,"static int match_ipv6_addrmask(u32 *input, u32 *addr, u32 *mask)
{
	int i, fail = 0;

	for (i = 0; i < 4; i++)
		if (addr[i] != (input[i] & mask[i])) {
			fail = 1;
			break;
		}

	return !fail;
}
"
24318,,Local,Not required,Complete,CVE-2011-4112,https://www.cvedetails.com/cve/CVE-2011-4112/,CWE-264,Low,,,,2012-05-17,4.9,"The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface.",2015-05-05,DoS ,0,https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162,550fd08c2cebad61c548def135f67aba284c6162,"net: Audit drivers to identify those needing IFF_TX_SKB_SHARING cleared

After the last patch, We are left in a state in which only drivers calling
ether_setup have IFF_TX_SKB_SHARING set (we assume that drivers touching real
hardware call ether_setup for their net_devices and don't hold any state in
their skbs.  There are a handful of drivers that violate this assumption of
course, and need to be fixed up.  This patch identifies those drivers, and marks
them as not being able to support the safe transmission of skbs by clearning the
IFF_TX_SKB_SHARING flag in priv_flags

Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
CC: Karsten Keil <isdn@linux-pingi.de>
CC: ""David S. Miller"" <davem@davemloft.net>
CC: Jay Vosburgh <fubar@us.ibm.com>
CC: Andy Gospodarek <andy@greyhouse.net>
CC: Patrick McHardy <kaber@trash.net>
CC: Krzysztof Halasa <khc@pm.waw.pl>
CC: ""John W. Linville"" <linville@tuxdriver.com>
CC: Greg Kroah-Hartman <gregkh@suse.de>
CC: Marcel Holtmann <marcel@holtmann.org>
CC: Johannes Berg <johannes@sipsolutions.net>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/mac80211/iface.c,"{""sha"": ""1f73d7f7e0242e4e73d55582935f4ff0a11f6646"", ""filename"": ""drivers/isdn/i4l/isdn_net.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/isdn/i4l/isdn_net.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/isdn/i4l/isdn_net.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/isdn/i4l/isdn_net.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -2532,6 +2532,9 @@ static void _isdn_setup(struct net_device *dev)\n \n \t/* Setup the generic properties */\n \tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n+\n+\t/* isdn prepends a header in the tx path, can't share skbs */\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->header_ops = NULL;\n \tdev->netdev_ops = &isdn_netdev_ops;\n ""}<_**next**_>{""sha"": ""df21e84f8198f1e989026a71d5e2c1ccee0aa607"", ""filename"": ""drivers/net/bonding/bond_main.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 2, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/bonding/bond_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/bonding/bond_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/bonding/bond_main.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -1557,8 +1557,10 @@ int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)\n \n \t\t\tif (slave_dev->type != ARPHRD_ETHER)\n \t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n-\t\t\telse\n+\t\t\telse {\n \t\t\t\tether_setup(bond_dev);\n+\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\t\t\t}\n \n \t\t\tnetdev_bonding_change(bond_dev,\n \t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n@@ -4330,7 +4332,7 @@ static void bond_setup(struct net_device *bond_dev)\n \tbond_dev->tx_queue_len = 0;\n \tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n \tbond_dev->priv_flags |= IFF_BONDING;\n-\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n+\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \n \t/* At first, we block adding VLANs. That's the only way to\n \t * prevent problems that occur when adding VLANs over an""}<_**next**_>{""sha"": ""46b5f5fd686bab98b98aff86fbf3e43b0702ddb8"", ""filename"": ""drivers/net/ifb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/ifb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/ifb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/ifb.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -183,7 +183,7 @@ static void ifb_setup(struct net_device *dev)\n \n \tdev->flags |= IFF_NOARP;\n \tdev->flags &= ~IFF_MULTICAST;\n-\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \trandom_ether_addr(dev->dev_addr);\n }\n ""}<_**next**_>{""sha"": ""05172c39a0ceaab229c4c89411c7fabc7201ce0c"", ""filename"": ""drivers/net/macvlan.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/macvlan.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/macvlan.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/macvlan.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -572,7 +572,7 @@ void macvlan_common_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n-\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags\t       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n \tdev->header_ops\t\t= &macvlan_hard_header_ops,""}<_**next**_>{""sha"": ""71f3d1a35b74ea4c0d1615bb5326e254a4475e63"", ""filename"": ""drivers/net/tun.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/tun.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/tun.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/tun.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -528,6 +528,7 @@ static void tun_net_init(struct net_device *dev)\n \t\tdev->netdev_ops = &tap_netdev_ops;\n \t\t/* Ethernet TAP Device */\n \t\tether_setup(dev);\n+\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \t\trandom_ether_addr(dev->dev_addr);\n ""}<_**next**_>{""sha"": ""5b23767ea817232a24b33a479f9b2014e895d1b6"", ""filename"": ""drivers/net/veth.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/veth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/veth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/veth.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -263,6 +263,8 @@ static void veth_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n \n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\n \tdev->netdev_ops = &veth_netdev_ops;\n \tdev->ethtool_ops = &veth_ethtool_ops;\n \tdev->features |= NETIF_F_LLTX;""}<_**next**_>{""sha"": ""eb2028187fbe1a5e7de31f862bd908d45fcd82e8"", ""filename"": ""drivers/net/wan/hdlc_fr.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wan/hdlc_fr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wan/hdlc_fr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/wan/hdlc_fr.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -1074,9 +1074,10 @@ static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n \n \tused = pvc_is_used(pvc);\n \n-\tif (type == ARPHRD_ETHER)\n+\tif (type == ARPHRD_ETHER) {\n \t\tdev = alloc_netdev(0, \""pvceth%d\"", ether_setup);\n-\telse\n+\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n+\t} else\n \t\tdev = alloc_netdev(0, \""pvc%d\"", pvc_setup);\n \n \tif (!dev) {""}<_**next**_>{""sha"": ""e1b3e3c134fdfaeccbd2f575734fa9754b9660e6"", ""filename"": ""drivers/net/wireless/airo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wireless/airo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wireless/airo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/wireless/airo.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -2823,6 +2823,7 @@ static struct net_device *_init_airo_card( unsigned short irq, int port,\n \tdev->wireless_data = &ai->wireless_data;\n \tdev->irq = irq;\n \tdev->base_addr = port;\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \tSET_NETDEV_DEV(dev, dmdev);\n ""}<_**next**_>{""sha"": ""89a116fba1de24f81d4fd3b25f7d5ad6e059c27a"", ""filename"": ""drivers/net/wireless/hostap/hostap_main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wireless/hostap/hostap_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/net/wireless/hostap/hostap_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/wireless/hostap/hostap_main.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -855,6 +855,7 @@ void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n \n \tiface = netdev_priv(dev);\n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n \t/* kernel callbacks */\n \tif (iface) {""}<_**next**_>{""sha"": ""8ff52899ddee175b27a2de32be2291aabb8a35a3"", ""filename"": ""drivers/staging/ath6kl/os/linux/ar6000_drv.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/drivers/staging/ath6kl/os/linux/ar6000_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/drivers/staging/ath6kl/os/linux/ar6000_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/staging/ath6kl/os/linux/ar6000_drv.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -6179,6 +6179,7 @@ int ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n     \n     ether_setup(dev);\n     init_netdev(dev, ap_ifname);\n+    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \n     if (register_netdev(dev)) {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\""ar6000_create_ap_interface: register_netdev failed\\n\""));""}<_**next**_>{""sha"": ""9d40a071d0382e7e893483066fa3bb5285fa8bc0"", ""filename"": ""net/8021q/vlan_dev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/net/8021q/vlan_dev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/net/8021q/vlan_dev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/8021q/vlan_dev.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -695,7 +695,7 @@ void vlan_setup(struct net_device *dev)\n \tether_setup(dev);\n \n \tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n-\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n+\tdev->priv_flags\t\t&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n \tdev->tx_queue_len\t= 0;\n \n \tdev->netdev_ops\t\t= &vlan_netdev_ops;""}<_**next**_>{""sha"": ""d4f5dff7c95510f9b31cbd0797210f9105c0e098"", ""filename"": ""net/bluetooth/bnep/netdev.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/net/bluetooth/bnep/netdev.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/net/bluetooth/bnep/netdev.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/bluetooth/bnep/netdev.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -231,6 +231,7 @@ void bnep_net_setup(struct net_device *dev)\n \tdev->addr_len = ETH_ALEN;\n \n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops = &bnep_netdev_ops;\n \n \tdev->watchdog_timeo  = HZ * 2;""}<_**next**_>{""sha"": ""d2726a74597d104eb3fa57b2f6b48ab297106f23"", ""filename"": ""net/l2tp/l2tp_eth.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/net/l2tp/l2tp_eth.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/net/l2tp/l2tp_eth.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/l2tp/l2tp_eth.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -103,7 +103,7 @@ static struct net_device_ops l2tp_eth_netdev_ops = {\n static void l2tp_eth_dev_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n-\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n \tdev->destructor\t\t= free_netdev;\n }""}<_**next**_>{""sha"": ""556e7e6ddf0a6b26dda29a33c00ee6c4d0ffed5b"", ""filename"": ""net/mac80211/iface.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/550fd08c2cebad61c548def135f67aba284c6162/net/mac80211/iface.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/550fd08c2cebad61c548def135f67aba284c6162/net/mac80211/iface.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/mac80211/iface.c?ref=550fd08c2cebad61c548def135f67aba284c6162"", ""patch"": ""@@ -698,6 +698,7 @@ static const struct net_device_ops ieee80211_monitorif_ops = {\n static void ieee80211_if_setup(struct net_device *dev)\n {\n \tether_setup(dev);\n+\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n \tdev->netdev_ops = &ieee80211_dataif_ops;\n \tdev->destructor = free_netdev;\n }""}","static int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,
					    enum nl80211_iftype iftype)
{
	struct ieee80211_local *local = sdata->local;
	struct ieee80211_sub_if_data *nsdata;
	struct net_device *dev = sdata->dev;

	ASSERT_RTNL();

	/* we hold the RTNL here so can safely walk the list */
	list_for_each_entry(nsdata, &local->interfaces, list) {
		struct net_device *ndev = nsdata->dev;

		if (ndev != dev && ieee80211_sdata_running(nsdata)) {
			/*
			 * Allow only a single IBSS interface to be up at any
			 * time. This is restricted because beacon distribution
			 * cannot work properly if both are in the same IBSS.
			 *
			 * To remove this restriction we'd have to disallow them
			 * from setting the same SSID on different IBSS interfaces
			 * belonging to the same hardware. Then, however, we're
			 * faced with having to adopt two different TSF timers...
			 */
			if (iftype == NL80211_IFTYPE_ADHOC &&
			    nsdata->vif.type == NL80211_IFTYPE_ADHOC)
				return -EBUSY;

			/*
			 * The remaining checks are only performed for interfaces
			 * with the same MAC address.
			 */
			if (compare_ether_addr(dev->dev_addr, ndev->dev_addr))
				continue;

			/*
			 * check whether it may have the same address
			 */
			if (!identical_mac_addr_allowed(iftype,
							nsdata->vif.type))
				return -ENOTUNIQ;

			/*
			 * can only add VLANs to enabled APs
			 */
			if (iftype == NL80211_IFTYPE_AP_VLAN &&
			    nsdata->vif.type == NL80211_IFTYPE_AP)
				sdata->bss = &nsdata->u.ap;
		}
	}

	return 0;
}
","static int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,
					    enum nl80211_iftype iftype)
{
	struct ieee80211_local *local = sdata->local;
	struct ieee80211_sub_if_data *nsdata;
	struct net_device *dev = sdata->dev;

	ASSERT_RTNL();

	/* we hold the RTNL here so can safely walk the list */
	list_for_each_entry(nsdata, &local->interfaces, list) {
		struct net_device *ndev = nsdata->dev;

		if (ndev != dev && ieee80211_sdata_running(nsdata)) {
			/*
			 * Allow only a single IBSS interface to be up at any
			 * time. This is restricted because beacon distribution
			 * cannot work properly if both are in the same IBSS.
			 *
			 * To remove this restriction we'd have to disallow them
			 * from setting the same SSID on different IBSS interfaces
			 * belonging to the same hardware. Then, however, we're
			 * faced with having to adopt two different TSF timers...
			 */
			if (iftype == NL80211_IFTYPE_ADHOC &&
			    nsdata->vif.type == NL80211_IFTYPE_ADHOC)
				return -EBUSY;

			/*
			 * The remaining checks are only performed for interfaces
			 * with the same MAC address.
			 */
			if (compare_ether_addr(dev->dev_addr, ndev->dev_addr))
				continue;

			/*
			 * check whether it may have the same address
			 */
			if (!identical_mac_addr_allowed(iftype,
							nsdata->vif.type))
				return -ENOTUNIQ;

			/*
			 * can only add VLANs to enabled APs
			 */
			if (iftype == NL80211_IFTYPE_AP_VLAN &&
			    nsdata->vif.type == NL80211_IFTYPE_AP)
				sdata->bss = &nsdata->u.ap;
		}
	}

	return 0;
}
",C,,,,"@@ -698,6 +698,7 @@ static const struct net_device_ops ieee80211_monitorif_ops = {
 static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
+	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
 	dev->netdev_ops = &ieee80211_dataif_ops;
 	dev->destructor = free_netdev;
 }",linux,550fd08c2cebad61c548def135f67aba284c6162,d8873315065f1f527c7c380402cf59b1e1d0ae36,0,"static int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,
					    enum nl80211_iftype iftype)
{
	struct ieee80211_local *local = sdata->local;
	struct ieee80211_sub_if_data *nsdata;
	struct net_device *dev = sdata->dev;

	ASSERT_RTNL();

	/* we hold the RTNL here so can safely walk the list */
	list_for_each_entry(nsdata, &local->interfaces, list) {
		struct net_device *ndev = nsdata->dev;

		if (ndev != dev && ieee80211_sdata_running(nsdata)) {
			/*
			 * Allow only a single IBSS interface to be up at any
			 * time. This is restricted because beacon distribution
			 * cannot work properly if both are in the same IBSS.
			 *
			 * To remove this restriction we'd have to disallow them
			 * from setting the same SSID on different IBSS interfaces
			 * belonging to the same hardware. Then, however, we're
			 * faced with having to adopt two different TSF timers...
			 */
			if (iftype == NL80211_IFTYPE_ADHOC &&
			    nsdata->vif.type == NL80211_IFTYPE_ADHOC)
				return -EBUSY;

			/*
			 * The remaining checks are only performed for interfaces
			 * with the same MAC address.
			 */
			if (compare_ether_addr(dev->dev_addr, ndev->dev_addr))
				continue;

			/*
			 * check whether it may have the same address
			 */
			if (!identical_mac_addr_allowed(iftype,
							nsdata->vif.type))
				return -ENOTUNIQ;

			/*
			 * can only add VLANs to enabled APs
			 */
			if (iftype == NL80211_IFTYPE_AP_VLAN &&
			    nsdata->vif.type == NL80211_IFTYPE_AP)
				sdata->bss = &nsdata->u.ap;
		}
	}

	return 0;
}
"
95043,,Remote,Not required,,CVE-2015-8852,https://www.cvedetails.com/cve/CVE-2015-8852/,,Low,,Partial,,2016-04-25,5.0,"Varnish 3.x before 3.0.7, when used in certain stacked installations, allows remote attackers to inject arbitrary HTTP headers and conduct HTTP response splitting attacks via a header line terminated by a r (carriage return) character in conjunction with multiple Content-Length headers in an HTTP request.",2016-11-30,Http R.Spl. ,0,https://github.com/varnish/Varnish-Cache/commit/85e8468bec9416bd7e16b0d80cb820ecd2b330c3,85e8468bec9416bd7e16b0d80cb820ecd2b330c3,"Do not consider a CR by itself as a valid line terminator

Varnish (prior to version 4.0) was not following the standard with
regard to line separator.

Spotted and analyzed by: Régis Leroy [regilero] regis.leroy@makina-corpus.com",0,bin/varnishtest/vtc_http.c,"{""sha"": ""5ab7bc09283fa07d484b115ef6ef708a2cd0b8be"", ""filename"": ""bin/varnishd/cache_http.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/varnish/Varnish-Cache/blob/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishd/cache_http.c"", ""raw_url"": ""https://github.com/varnish/Varnish-Cache/raw/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishd/cache_http.c"", ""contents_url"": ""https://api.github.com/repos/varnish/Varnish-Cache/contents/bin/varnishd/cache_http.c?ref=85e8468bec9416bd7e16b0d80cb820ecd2b330c3"", ""patch"": ""@@ -502,7 +502,7 @@ http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,\n \t\t/* Find end of next header */\n \t\tq = r = p;\n \t\twhile (r < t.e) {\n-\t\t\tif (!vct_iscrlf(*r)) {\n+\t\t\tif (!vct_iscrlf(r)) {\n \t\t\t\tr++;\n \t\t\t\tcontinue;\n \t\t\t}\n@@ -611,8 +611,8 @@ http_splitline(struct worker *w, int fd, struct http *hp,\n \n \t/* Third field is optional and cannot contain CTL */\n \tq = p;\n-\tif (!vct_iscrlf(*p)) {\n-\t\tfor (; !vct_iscrlf(*p); p++)\n+\tif (!vct_iscrlf(p)) {\n+\t\tfor (; !vct_iscrlf(p); p++)\n \t\t\tif (!vct_issep(*p) && vct_isctl(*p))\n \t\t\t\treturn (400);\n \t}""}<_**next**_>{""sha"": ""3492570eff436281a9ca3ce63fc058e78c3d1c8f"", ""filename"": ""bin/varnishtest/tests/b00040.vtc"", ""status"": ""added"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/varnish/Varnish-Cache/blob/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishtest/tests/b00040.vtc"", ""raw_url"": ""https://github.com/varnish/Varnish-Cache/raw/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishtest/tests/b00040.vtc"", ""contents_url"": ""https://api.github.com/repos/varnish/Varnish-Cache/contents/bin/varnishtest/tests/b00040.vtc?ref=85e8468bec9416bd7e16b0d80cb820ecd2b330c3"", ""patch"": ""@@ -0,0 +1,24 @@\n+varnishtest \""Do not consider CR as a valid line separator\""\n+\n+server s1 {\n+\trxreq\n+\ttxresp\n+} -start\n+\n+varnish v1 -vcl+backend {\n+\tsub vcl_deliver {\n+\t\tif (req.http.foo) {\n+\t\t\tset resp.http.Foo = req.http.foo;\n+\t\t}\n+\t\tif (req.http.bar) {\n+\t\t\tset resp.http.Bar = req.http.bar;\n+\t\t}\n+\t}\n+} -start\n+\n+client c1 {\n+\tsend \""GET / HTTP/1.1\\r\\nFoo: foo\\rBar: bar\\r\\n\\r\\n\""\n+\trxresp\n+\texpect resp.http.foo == \""foo\\rBar: bar\""\n+\texpect resp.http.bar == \""<undef>\""\n+} -run""}<_**next**_>{""sha"": ""dd2c804fb56eb1cd9cda4f11bcf57f957cb434d9"", ""filename"": ""bin/varnishtest/vtc_http.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/varnish/Varnish-Cache/blob/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishtest/vtc_http.c"", ""raw_url"": ""https://github.com/varnish/Varnish-Cache/raw/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/bin/varnishtest/vtc_http.c"", ""contents_url"": ""https://api.github.com/repos/varnish/Varnish-Cache/contents/bin/varnishtest/vtc_http.c?ref=85e8468bec9416bd7e16b0d80cb820ecd2b330c3"", ""patch"": ""@@ -283,17 +283,17 @@ http_splitheader(struct http *hp, int req)\n \thh[n++] = p;\n \twhile (!vct_islws(*p))\n \t\tp++;\n-\tassert(!vct_iscrlf(*p));\n+\tassert(!vct_iscrlf(p));\n \t*p++ = '\\0';\n \n \t/* URL/STATUS */\n \twhile (vct_issp(*p))\t\t/* XXX: H space only */\n \t\tp++;\n-\tassert(!vct_iscrlf(*p));\n+\tassert(!vct_iscrlf(p));\n \thh[n++] = p;\n \twhile (!vct_islws(*p))\n \t\tp++;\n-\tif (vct_iscrlf(*p)) {\n+\tif (vct_iscrlf(p)) {\n \t\thh[n++] = NULL;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n@@ -304,7 +304,7 @@ http_splitheader(struct http *hp, int req)\n \t\twhile (vct_issp(*p))\t\t/* XXX: H space only */\n \t\t\tp++;\n \t\thh[n++] = p;\n-\t\twhile (!vct_iscrlf(*p))\n+\t\twhile (!vct_iscrlf(p))\n \t\t\tp++;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n@@ -314,10 +314,10 @@ http_splitheader(struct http *hp, int req)\n \n \twhile (*p != '\\0') {\n \t\tassert(n < MAX_HDR);\n-\t\tif (vct_iscrlf(*p))\n+\t\tif (vct_iscrlf(p))\n \t\t\tbreak;\n \t\thh[n++] = p++;\n-\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n+\t\twhile (*p != '\\0' && !vct_iscrlf(p))\n \t\t\tp++;\n \t\tq = p;\n \t\tp += vct_skipcrlf(p);\n@@ -408,11 +408,11 @@ http_rxchunk(struct http *hp)\n \t}\n \tl = hp->prxbuf;\n \t(void)http_rxchar(hp, 2, 0);\n-\tif(!vct_iscrlf(hp->rxbuf[l]))\n+\tif(!vct_iscrlf(&hp->rxbuf[l]))\n \t\tvtc_log(hp->vl, hp->fatal,\n \t\t    \""Wrong chunk tail[0] = %02x\"",\n \t\t    hp->rxbuf[l] & 0xff);\n-\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n+\tif(!vct_iscrlf(&hp->rxbuf[l + 1]))\n \t\tvtc_log(hp->vl, hp->fatal,\n \t\t    \""Wrong chunk tail[1] = %02x\"",\n \t\t    hp->rxbuf[l + 1] & 0xff);""}<_**next**_>{""sha"": ""8884755a813122c2f8307a07862fdecc89bb1d41"", ""filename"": ""include/vct.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/varnish/Varnish-Cache/blob/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/include/vct.h"", ""raw_url"": ""https://github.com/varnish/Varnish-Cache/raw/85e8468bec9416bd7e16b0d80cb820ecd2b330c3/include/vct.h"", ""contents_url"": ""https://api.github.com/repos/varnish/Varnish-Cache/contents/include/vct.h?ref=85e8468bec9416bd7e16b0d80cb820ecd2b330c3"", ""patch"": ""@@ -54,7 +54,6 @@ vct_is(unsigned char x, uint16_t y)\n \n #define vct_issp(x) vct_is(x, VCT_SP)\n #define vct_ishex(x) vct_is(x, VCT_HEX)\n-#define vct_iscrlf(x) vct_is(x, VCT_CRLF)\n #define vct_islws(x) vct_is(x, VCT_LWS)\n #define vct_isctl(x) vct_is(x, VCT_CTL)\n #define vct_isdigit(x) vct_is(x, VCT_DIGIT)\n@@ -64,5 +63,7 @@ vct_is(unsigned char x, uint16_t y)\n #define vct_isxmlnamestart(x) vct_is(x, VCT_XMLNAMESTART)\n #define vct_isxmlname(x) vct_is(x, VCT_XMLNAMESTART | VCT_XMLNAME)\n \n+#define vct_iscrlf(p) (((p)[0] == '\\r' && (p)[1] == '\\n') || (p)[0] == '\\n')\n+\n /* NB: VCT always operate in ASCII, don't replace 0x0d with \\r etc. */\n #define vct_skipcrlf(p) (p[0] == 0x0d && p[1] == 0x0a ? 2 : 1)""}","synth_body(const char *len, int rnd)
{
	int i, j, k, l;
	char *b;


	AN(len);
	i = strtoul(len, NULL, 0);
	assert(i > 0);
	b = malloc(i + 1L);
	AN(b);
	l = k = '!';
	for (j = 0; j < i; j++) {
		if ((j % 64) == 63) {
			b[j] = '\n';
			k++;
			if (k == '~')
				k = '!';
			l = k;
		} else if (rnd) {
			b[j] = (random() % 95) + ' ';
		} else {
			b[j] = (char)l;
			if (++l == '~')
				l = '!';
		}
	}
	b[i - 1] = '\n';
	b[i] = '\0';
	return (b);
}
","synth_body(const char *len, int rnd)
{
	int i, j, k, l;
	char *b;


	AN(len);
	i = strtoul(len, NULL, 0);
	assert(i > 0);
	b = malloc(i + 1L);
	AN(b);
	l = k = '!';
	for (j = 0; j < i; j++) {
		if ((j % 64) == 63) {
			b[j] = '\n';
			k++;
			if (k == '~')
				k = '!';
			l = k;
		} else if (rnd) {
			b[j] = (random() % 95) + ' ';
		} else {
			b[j] = (char)l;
			if (++l == '~')
				l = '!';
		}
	}
	b[i - 1] = '\n';
	b[i] = '\0';
	return (b);
}
",C,,,,"@@ -283,17 +283,17 @@ http_splitheader(struct http *hp, int req)
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
-	assert(!vct_iscrlf(*p));
+	assert(!vct_iscrlf(p));
 	*p++ = '\0';
 
 	/* URL/STATUS */
 	while (vct_issp(*p))		/* XXX: H space only */
 		p++;
-	assert(!vct_iscrlf(*p));
+	assert(!vct_iscrlf(p));
 	hh[n++] = p;
 	while (!vct_islws(*p))
 		p++;
-	if (vct_iscrlf(*p)) {
+	if (vct_iscrlf(p)) {
 		hh[n++] = NULL;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -304,7 +304,7 @@ http_splitheader(struct http *hp, int req)
 		while (vct_issp(*p))		/* XXX: H space only */
 			p++;
 		hh[n++] = p;
-		while (!vct_iscrlf(*p))
+		while (!vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -314,10 +314,10 @@ http_splitheader(struct http *hp, int req)
 
 	while (*p != '\0') {
 		assert(n < MAX_HDR);
-		if (vct_iscrlf(*p))
+		if (vct_iscrlf(p))
 			break;
 		hh[n++] = p++;
-		while (*p != '\0' && !vct_iscrlf(*p))
+		while (*p != '\0' && !vct_iscrlf(p))
 			p++;
 		q = p;
 		p += vct_skipcrlf(p);
@@ -408,11 +408,11 @@ http_rxchunk(struct http *hp)
 	}
 	l = hp->prxbuf;
 	(void)http_rxchar(hp, 2, 0);
-	if(!vct_iscrlf(hp->rxbuf[l]))
+	if(!vct_iscrlf(&hp->rxbuf[l]))
 		vtc_log(hp->vl, hp->fatal,
 		    ""Wrong chunk tail[0] = %02x"",
 		    hp->rxbuf[l] & 0xff);
-	if(!vct_iscrlf(hp->rxbuf[l + 1]))
+	if(!vct_iscrlf(&hp->rxbuf[l + 1]))
 		vtc_log(hp->vl, hp->fatal,
 		    ""Wrong chunk tail[1] = %02x"",
 		    hp->rxbuf[l + 1] & 0xff);",Varnish-Cache,85e8468bec9416bd7e16b0d80cb820ecd2b330c3,9190770d54322567d3d4fa4b5bd0f1dc091c63c4,0,"synth_body(const char *len, int rnd)
{
	int i, j, k, l;
	char *b;


	AN(len);
	i = strtoul(len, NULL, 0);
	assert(i > 0);
	b = malloc(i + 1L);
	AN(b);
	l = k = '!';
	for (j = 0; j < i; j++) {
		if ((j % 64) == 63) {
			b[j] = '\n';
			k++;
			if (k == '~')
				k = '!';
			l = k;
		} else if (rnd) {
			b[j] = (random() % 95) + ' ';
		} else {
			b[j] = (char)l;
			if (++l == '~')
				l = '!';
		}
	}
	b[i - 1] = '\n';
	b[i] = '\0';
	return (b);
}
"
78006,,Remote,Not required,Partial,CVE-2018-16640,https://www.cvedetails.com/cve/CVE-2018-16640/,CWE-772,Medium,,,,2018-09-06,4.3,ImageMagick 7.0.8-5 has a memory leak vulnerability in the function ReadOneJNGImage in coders/png.c.,2019-10-02,,0,https://github.com/ImageMagick/ImageMagick/commit/76efa969342568841ecf320b5a041685a6d24e0b,76efa969342568841ecf320b5a041685a6d24e0b,https://github.com/ImageMagick/ImageMagick/issues/1201,0,coders/png.c,"{""sha"": ""d811544e311031c6f6f105fa13d4f5aa94e03137"", ""filename"": ""coders/png.c"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/76efa969342568841ecf320b5a041685a6d24e0b/coders/png.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/76efa969342568841ecf320b5a041685a6d24e0b/coders/png.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/png.c?ref=76efa969342568841ecf320b5a041685a6d24e0b"", ""patch"": ""@@ -4560,7 +4560,11 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));\n \n         if (chunk == (unsigned char *) NULL)\n-          ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+          {\n+            DestroyJNG(NULL,&color_image,&color_image_info,\n+              &alpha_image,&alpha_image_info);\n+            ThrowReaderException(ResourceLimitError,\""MemoryAllocationFailed\"");\n+          }\n \n         for (i=0; i < (ssize_t) length; i++)\n         {\n@@ -4587,13 +4591,12 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,\n             jng_width=(png_uint_32)mng_get_long(p);\n             jng_height=(png_uint_32)mng_get_long(&p[4]);\n             if ((jng_width == 0) || (jng_height == 0))\n-            {\n-              DestroyJNG(chunk,&color_image,&color_image_info,\n-                &alpha_image,&alpha_image_info);\n-\n-              ThrowReaderException(CorruptImageError,\n-                \""NegativeOrZeroImageSize\"");\n-            }\n+              {\n+                DestroyJNG(chunk,&color_image,&color_image_info,\n+                  &alpha_image,&alpha_image_info);\n+                ThrowReaderException(CorruptImageError,\n+                  \""NegativeOrZeroImageSize\"");\n+              }\n             jng_color_type=p[8];\n             jng_image_sample_depth=p[9];\n             jng_image_compression_method=p[10];""}<_**next**_>{""sha"": ""2bc5726fab1818d1dd2f54142b8f5abaa59d6262"", ""filename"": ""configure"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 13, ""changes"": 26, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/76efa969342568841ecf320b5a041685a6d24e0b/configure"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/76efa969342568841ecf320b5a041685a6d24e0b/configure"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/configure?ref=76efa969342568841ecf320b5a041685a6d24e0b"", ""patch"": ""@@ -1,6 +1,6 @@\n #! /bin/sh\n # Guess values for system-dependent variables and create Makefiles.\n-# Generated by GNU Autoconf 2.69 for ImageMagick 7.0.8-5.\n+# Generated by GNU Autoconf 2.69 for ImageMagick 7.0.8-6.\n #\n # Report bugs to <https://github.com/ImageMagick/ImageMagick/issues>.\n #\n@@ -590,8 +590,8 @@ MAKEFLAGS=\n # Identity of this package.\n PACKAGE_NAME='ImageMagick'\n PACKAGE_TARNAME='ImageMagick'\n-PACKAGE_VERSION='7.0.8-5'\n-PACKAGE_STRING='ImageMagick 7.0.8-5'\n+PACKAGE_VERSION='7.0.8-6'\n+PACKAGE_STRING='ImageMagick 7.0.8-6'\n PACKAGE_BUGREPORT='https://github.com/ImageMagick/ImageMagick/issues'\n PACKAGE_URL='https://www.imagemagick.org'\n \n@@ -1842,7 +1842,7 @@ if test \""$ac_init_help\"" = \""long\""; then\n   # Omit some internal or obsolete options to make the list less imposing.\n   # This message is too long to be a string in the A/UX 3.1 sh.\n   cat <<_ACEOF\n-\\`configure' configures ImageMagick 7.0.8-5 to adapt to many kinds of systems.\n+\\`configure' configures ImageMagick 7.0.8-6 to adapt to many kinds of systems.\n \n Usage: $0 [OPTION]... [VAR=VALUE]...\n \n@@ -1917,7 +1917,7 @@ fi\n \n if test -n \""$ac_init_help\""; then\n   case $ac_init_help in\n-     short | recursive ) echo \""Configuration of ImageMagick 7.0.8-5:\"";;\n+     short | recursive ) echo \""Configuration of ImageMagick 7.0.8-6:\"";;\n    esac\n   cat <<\\_ACEOF\n \n@@ -2204,7 +2204,7 @@ fi\n test -n \""$ac_init_help\"" && exit $ac_status\n if $ac_init_version; then\n   cat <<\\_ACEOF\n-ImageMagick configure 7.0.8-5\n+ImageMagick configure 7.0.8-6\n generated by GNU Autoconf 2.69\n \n Copyright (C) 2012 Free Software Foundation, Inc.\n@@ -3255,7 +3255,7 @@ cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n \n-It was created by ImageMagick $as_me 7.0.8-5, which was\n+It was created by ImageMagick $as_me 7.0.8-6, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   $ $0 $@\n@@ -4241,7 +4241,7 @@ fi\n \n # Define the identity of the package.\n  PACKAGE='ImageMagick'\n- VERSION='7.0.8-5'\n+ VERSION='7.0.8-6'\n \n \n cat >>confdefs.h <<_ACEOF\n@@ -4551,11 +4551,11 @@ MAGICK_MINOR_VERSION=0\n \n MAGICK_MICRO_VERSION=8\n \n-MAGICK_PATCHLEVEL_VERSION=5\n+MAGICK_PATCHLEVEL_VERSION=6\n \n-MAGICK_VERSION=7.0.8-5\n+MAGICK_VERSION=7.0.8-6\n \n-MAGICK_GIT_REVISION=14506:0e75f0a50:20180703\n+MAGICK_GIT_REVISION=14516:c7537dd70:20180705\n \n \n # Substitute library versioning\n@@ -37632,7 +37632,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n # report actual input values of CONFIG_FILES etc. instead of their\n # values after options handling.\n ac_log=\""\n-This file was extended by ImageMagick $as_me 7.0.8-5, which was\n+This file was extended by ImageMagick $as_me 7.0.8-6, which was\n generated by GNU Autoconf 2.69.  Invocation command line was\n \n   CONFIG_FILES    = $CONFIG_FILES\n@@ -37699,7 +37699,7 @@ _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n ac_cs_config=\""`$as_echo \""$ac_configure_args\"" | sed 's/^ //; s/[\\\\\""\""\\`\\$]/\\\\\\\\&/g'`\""\n ac_cs_version=\""\\\\\n-ImageMagick config.status 7.0.8-5\n+ImageMagick config.status 7.0.8-6\n configured by $0, generated by GNU Autoconf 2.69,\n   with options \\\\\""\\$ac_cs_config\\\\\""\n ""}","static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,
   const ImageInfo *image_info,Image *image,ExceptionInfo *exception)
{
  Image
    *jpeg_image;

  ImageInfo
    *jpeg_image_info;

  MagickBooleanType
    logging,
    status;

  size_t
    length;

  unsigned char
    *blob,
    chunk[80],
    *p;

  unsigned int
    jng_alpha_compression_method,
    jng_alpha_sample_depth,
    jng_color_type,
    transparent;

  size_t
    jng_alpha_quality,
    jng_quality;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
    ""  Enter WriteOneJNGImage()"");

  blob=(unsigned char *) NULL;
  jpeg_image=(Image *) NULL;
  jpeg_image_info=(ImageInfo *) NULL;
  length=0;

  status=MagickTrue;
  transparent=image_info->type==GrayscaleAlphaType ||
     image_info->type==TrueColorAlphaType ||
     image->alpha_trait != UndefinedPixelTrait;

  jng_alpha_sample_depth = 0;

  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;

  jng_alpha_compression_method=(image->compression==JPEGCompression ||
    image_info->compression==JPEGCompression) ? 8 : 0;

  jng_alpha_quality=image_info->quality == 0UL ? 75UL :
      image_info->quality;

  if (jng_alpha_quality >= 1000)
    jng_alpha_quality /= 1000;

  length=0;

  if (transparent != 0)
    {
      jng_color_type=14;

      /* Create JPEG blob, image, and image_info */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image_info for alpha."");

      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);

      if (jpeg_image_info == (ImageInfo *) NULL)
        {
          jpeg_image_info=DestroyImageInfo(jpeg_image_info);
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image."");

      jpeg_image=SeparateImage(image,AlphaChannel,exception);
      if (jpeg_image == (Image *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
      jpeg_image->alpha_trait=UndefinedPixelTrait;
      jpeg_image->quality=jng_alpha_quality;
      jpeg_image_info->type=GrayscaleType;
      (void) SetImageType(jpeg_image,GrayscaleType,exception);
      (void) AcquireUniqueFilename(jpeg_image->filename);
      (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,
        ""%s"",jpeg_image->filename);
    }
  else
    {
      jng_alpha_compression_method=0;
      jng_color_type=10;
      jng_alpha_sample_depth=0;
    }

  /* To do: check bit depth of PNG alpha channel */

  /* Check if image is grayscale. */
  if (image_info->type != TrueColorAlphaType && image_info->type !=
    TrueColorType && SetImageGray(image,exception))
    jng_color_type-=2;

  if (logging != MagickFalse)
    {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Quality           = %d"",(int) jng_quality);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Color Type        = %d"",jng_color_type);
        if (transparent != 0)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Compression = %d"",jng_alpha_compression_method);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Depth       = %d"",jng_alpha_sample_depth);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Quality     = %d"",(int) jng_alpha_quality);
          }
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          const char
            *value;

          /* Encode alpha as a grayscale PNG blob */
          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating PNG blob."");

          (void) CopyMagickString(jpeg_image_info->magick,""PNG"",
             MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""PNG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;

          /* Exclude all ancillary chunks */
          (void) SetImageArtifact(jpeg_image,""png:exclude-chunks"",""all"");

          blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,
            &length,exception);

          /* Retrieve sample depth used */
          value=GetImageProperty(jpeg_image,""png:bit-depth-written"",exception);
          if (value != (char *) NULL)
            jng_alpha_sample_depth= (unsigned int) value[0];
        }
      else
        {
          /* Encode alpha as a grayscale JPEG blob */

          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",
            MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating blob."");
          blob=(unsigned char *) ImageToBlob(jpeg_image_info,
             jpeg_image,&length,
           exception);
          jng_alpha_sample_depth=8;

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Successfully read jpeg_image into a blob, length=%.20g."",
              (double) length);

        }
      /* Destroy JPEG image and image_info */
      jpeg_image=DestroyImage(jpeg_image);
      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
    }

  /* Write JHDR chunk */
  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */
  PNGType(chunk,mng_JHDR);
  LogPNGChunk(logging,mng_JHDR,16L);
  PNGLong(chunk+4,(png_uint_32) image->columns);
  PNGLong(chunk+8,(png_uint_32) image->rows);
  chunk[12]=jng_color_type;
  chunk[13]=8;  /* sample depth */
  chunk[14]=8; /*jng_image_compression_method */
  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);
  chunk[16]=jng_alpha_sample_depth;
  chunk[17]=jng_alpha_compression_method;
  chunk[18]=0; /*jng_alpha_filter_method */
  chunk[19]=0; /*jng_alpha_interlace_method */
  (void) WriteBlob(image,20,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG width:%15lu"",(unsigned long) image->columns);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG height:%14lu"",(unsigned long) image->rows);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG color type:%10d"",jng_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG sample depth:%8d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG compression:%9d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG interlace:%11d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha depth:%9d"",jng_alpha_sample_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha compression:%3d"",jng_alpha_compression_method);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha filter:%8d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha interlace:%5d"",0);
    }

  /*
     Write leading ancillary chunks
  */

  if (transparent != 0)
  {
    /*
      Write JNG bKGD chunk
    */

    unsigned char
      blue,
      green,
      red;

    ssize_t
      num_bytes;

    if (jng_color_type == 8 || jng_color_type == 12)
      num_bytes=6L;
    else
      num_bytes=10L;
    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));
    PNGType(chunk,mng_bKGD);
    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));
    red=ScaleQuantumToChar(image->background_color.red);
    green=ScaleQuantumToChar(image->background_color.green);
    blue=ScaleQuantumToChar(image->background_color.blue);
    *(chunk+4)=0;
    *(chunk+5)=red;
    *(chunk+6)=0;
    *(chunk+7)=green;
    *(chunk+8)=0;
    *(chunk+9)=blue;
    (void) WriteBlob(image,(size_t) num_bytes,chunk);
    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));
  }

  if ((image->colorspace == sRGBColorspace || image->rendering_intent))
    {
      /*
        Write JNG sRGB chunk
      */
      (void) WriteBlobMSBULong(image,1L);
      PNGType(chunk,mng_sRGB);
      LogPNGChunk(logging,mng_sRGB,1L);

      if (image->rendering_intent != UndefinedIntent)
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (image->rendering_intent));

      else
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (PerceptualIntent));

      (void) WriteBlob(image,5,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));
    }
  else
    {
      if (image->gamma != 0.0)
        {
          /*
             Write JNG gAMA chunk
          */
          (void) WriteBlobMSBULong(image,4L);
          PNGType(chunk,mng_gAMA);
          LogPNGChunk(logging,mng_gAMA,4L);
          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));
          (void) WriteBlob(image,8,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));
        }

      if ((mng_info->equal_chrms == MagickFalse) &&
          (image->chromaticity.red_primary.x != 0.0))
        {
          PrimaryInfo
            primary;

          /*
             Write JNG cHRM chunk
          */
          (void) WriteBlobMSBULong(image,32L);
          PNGType(chunk,mng_cHRM);
          LogPNGChunk(logging,mng_cHRM,32L);
          primary=image->chromaticity.white_point;
          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.red_primary;
          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.green_primary;
          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.blue_primary;
          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));
          (void) WriteBlob(image,36,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));
        }
    }

  if (image->resolution.x && image->resolution.y && !mng_info->equal_physs)
    {
      /*
         Write JNG pHYs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_pHYs);
      LogPNGChunk(logging,mng_pHYs,9L);
      if (image->units == PixelsPerInchResolution)
        {
          PNGLong(chunk+4,(png_uint_32)
            (image->resolution.x*100.0/2.54+0.5));

          PNGLong(chunk+8,(png_uint_32)
            (image->resolution.y*100.0/2.54+0.5));

          chunk[12]=1;
        }

      else
        {
          if (image->units == PixelsPerCentimeterResolution)
            {
              PNGLong(chunk+4,(png_uint_32)
                (image->resolution.x*100.0+0.5));

              PNGLong(chunk+8,(png_uint_32)
                (image->resolution.y*100.0+0.5));

              chunk[12]=1;
            }

          else
            {
              PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));
              PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));
              chunk[12]=0;
            }
        }
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))
    {
      /*
         Write JNG oFFs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_oFFs);
      LogPNGChunk(logging,mng_oFFs,9L);
      PNGsLong(chunk+4,(ssize_t) (image->page.x));
      PNGsLong(chunk+8,(ssize_t) (image->page.y));
      chunk[12]=0;
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          register ssize_t
            i;

          size_t
            len;

          /* Write IDAT chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write IDAT chunks from blob, length=%.20g."",(double)
              length);

          /* Copy IDAT chunks */
          len=0;
          p=blob+8;
          for (i=8; i<(ssize_t) length; i+=len+12)
          {
            len=(((unsigned int) *(p    ) & 0xff) << 24) +
                (((unsigned int) *(p + 1) & 0xff) << 16) +
                (((unsigned int) *(p + 2) & 0xff) <<  8) +
                (((unsigned int) *(p + 3) & 0xff)      ) ;
            p+=4;

            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */
              {
                /* Found an IDAT chunk. */
                (void) WriteBlobMSBULong(image,len);
                LogPNGChunk(logging,mng_IDAT,len);
                (void) WriteBlob(image,len+4,p);
                (void) WriteBlobMSBULong(image, crc32(0,p,(uInt) len+4));
              }

            else
              {
                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""    Skipping %c%c%c%c chunk, length=%.20g."",
                    *(p),*(p+1),*(p+2),*(p+3),(double) len);
              }
            p+=(8+len);
          }
        }
      else if (length != 0)
        {
          /* Write JDAA chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write JDAA chunk, length=%.20g."",(double) length);
          (void) WriteBlobMSBULong(image,(size_t) length);
          PNGType(chunk,mng_JDAA);
          LogPNGChunk(logging,mng_JDAA,length);
          /* Write JDAT chunk(s) data */
          (void) WriteBlob(image,4,chunk);
          (void) WriteBlob(image,length,blob);
          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,
             (uInt) length));
        }
      blob=(unsigned char *) RelinquishMagickMemory(blob);
    }

  /* Encode image as a JPEG blob */
  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image_info."");
  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);
  if (jpeg_image_info == (ImageInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image."");

  jpeg_image=CloneImage(image,0,0,MagickTrue,exception);
  if (jpeg_image == (Image *) NULL)
    {
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  (void) AcquireUniqueFilename(jpeg_image->filename);
  (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,""%s"",
    jpeg_image->filename);

  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
    exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Created jpeg_image, %.20g x %.20g."",(double) jpeg_image->columns,
      (double) jpeg_image->rows);

  if (status == MagickFalse)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (jng_color_type == 8 || jng_color_type == 12)
    jpeg_image_info->type=GrayscaleType;

  jpeg_image_info->quality=jng_quality;
  jpeg_image->quality=jng_quality;
  (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",MagickPathExtent);
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating blob."");

  blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,&length,
    exception);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Successfully read jpeg_image into a blob, length=%.20g."",
        (double) length);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Write JDAT chunk, length=%.20g."",(double) length);
    }

  /* Write JDAT chunk(s) */
  (void) WriteBlobMSBULong(image,(size_t) length);
  PNGType(chunk,mng_JDAT);
  LogPNGChunk(logging,mng_JDAT,length);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlob(image,length,blob);
  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));

  jpeg_image=DestroyImage(jpeg_image);
  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
  jpeg_image_info=DestroyImageInfo(jpeg_image_info);
  blob=(unsigned char *) RelinquishMagickMemory(blob);

  /* Write IEND chunk */
  (void) WriteBlobMSBULong(image,0L);
  PNGType(chunk,mng_IEND);
  LogPNGChunk(logging,mng_IEND,0);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOneJNGImage()"");

  return(status);
}
","static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,
   const ImageInfo *image_info,Image *image,ExceptionInfo *exception)
{
  Image
    *jpeg_image;

  ImageInfo
    *jpeg_image_info;

  MagickBooleanType
    logging,
    status;

  size_t
    length;

  unsigned char
    *blob,
    chunk[80],
    *p;

  unsigned int
    jng_alpha_compression_method,
    jng_alpha_sample_depth,
    jng_color_type,
    transparent;

  size_t
    jng_alpha_quality,
    jng_quality;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
    ""  Enter WriteOneJNGImage()"");

  blob=(unsigned char *) NULL;
  jpeg_image=(Image *) NULL;
  jpeg_image_info=(ImageInfo *) NULL;
  length=0;

  status=MagickTrue;
  transparent=image_info->type==GrayscaleAlphaType ||
     image_info->type==TrueColorAlphaType ||
     image->alpha_trait != UndefinedPixelTrait;

  jng_alpha_sample_depth = 0;

  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;

  jng_alpha_compression_method=(image->compression==JPEGCompression ||
    image_info->compression==JPEGCompression) ? 8 : 0;

  jng_alpha_quality=image_info->quality == 0UL ? 75UL :
      image_info->quality;

  if (jng_alpha_quality >= 1000)
    jng_alpha_quality /= 1000;

  length=0;

  if (transparent != 0)
    {
      jng_color_type=14;

      /* Create JPEG blob, image, and image_info */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image_info for alpha."");

      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);

      if (jpeg_image_info == (ImageInfo *) NULL)
        {
          jpeg_image_info=DestroyImageInfo(jpeg_image_info);
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image."");

      jpeg_image=SeparateImage(image,AlphaChannel,exception);
      if (jpeg_image == (Image *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
      jpeg_image->alpha_trait=UndefinedPixelTrait;
      jpeg_image->quality=jng_alpha_quality;
      jpeg_image_info->type=GrayscaleType;
      (void) SetImageType(jpeg_image,GrayscaleType,exception);
      (void) AcquireUniqueFilename(jpeg_image->filename);
      (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,
        ""%s"",jpeg_image->filename);
    }
  else
    {
      jng_alpha_compression_method=0;
      jng_color_type=10;
      jng_alpha_sample_depth=0;
    }

  /* To do: check bit depth of PNG alpha channel */

  /* Check if image is grayscale. */
  if (image_info->type != TrueColorAlphaType && image_info->type !=
    TrueColorType && SetImageGray(image,exception))
    jng_color_type-=2;

  if (logging != MagickFalse)
    {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Quality           = %d"",(int) jng_quality);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Color Type        = %d"",jng_color_type);
        if (transparent != 0)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Compression = %d"",jng_alpha_compression_method);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Depth       = %d"",jng_alpha_sample_depth);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Quality     = %d"",(int) jng_alpha_quality);
          }
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          const char
            *value;

          /* Encode alpha as a grayscale PNG blob */
          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating PNG blob."");

          (void) CopyMagickString(jpeg_image_info->magick,""PNG"",
             MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""PNG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;

          /* Exclude all ancillary chunks */
          (void) SetImageArtifact(jpeg_image,""png:exclude-chunks"",""all"");

          blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,
            &length,exception);

          /* Retrieve sample depth used */
          value=GetImageProperty(jpeg_image,""png:bit-depth-written"",exception);
          if (value != (char *) NULL)
            jng_alpha_sample_depth= (unsigned int) value[0];
        }
      else
        {
          /* Encode alpha as a grayscale JPEG blob */

          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",
            MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating blob."");
          blob=(unsigned char *) ImageToBlob(jpeg_image_info,
             jpeg_image,&length,
           exception);
          jng_alpha_sample_depth=8;

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Successfully read jpeg_image into a blob, length=%.20g."",
              (double) length);

        }
      /* Destroy JPEG image and image_info */
      jpeg_image=DestroyImage(jpeg_image);
      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
    }

  /* Write JHDR chunk */
  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */
  PNGType(chunk,mng_JHDR);
  LogPNGChunk(logging,mng_JHDR,16L);
  PNGLong(chunk+4,(png_uint_32) image->columns);
  PNGLong(chunk+8,(png_uint_32) image->rows);
  chunk[12]=jng_color_type;
  chunk[13]=8;  /* sample depth */
  chunk[14]=8; /*jng_image_compression_method */
  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);
  chunk[16]=jng_alpha_sample_depth;
  chunk[17]=jng_alpha_compression_method;
  chunk[18]=0; /*jng_alpha_filter_method */
  chunk[19]=0; /*jng_alpha_interlace_method */
  (void) WriteBlob(image,20,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG width:%15lu"",(unsigned long) image->columns);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG height:%14lu"",(unsigned long) image->rows);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG color type:%10d"",jng_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG sample depth:%8d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG compression:%9d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG interlace:%11d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha depth:%9d"",jng_alpha_sample_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha compression:%3d"",jng_alpha_compression_method);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha filter:%8d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha interlace:%5d"",0);
    }

  /*
     Write leading ancillary chunks
  */

  if (transparent != 0)
  {
    /*
      Write JNG bKGD chunk
    */

    unsigned char
      blue,
      green,
      red;

    ssize_t
      num_bytes;

    if (jng_color_type == 8 || jng_color_type == 12)
      num_bytes=6L;
    else
      num_bytes=10L;
    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));
    PNGType(chunk,mng_bKGD);
    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));
    red=ScaleQuantumToChar(image->background_color.red);
    green=ScaleQuantumToChar(image->background_color.green);
    blue=ScaleQuantumToChar(image->background_color.blue);
    *(chunk+4)=0;
    *(chunk+5)=red;
    *(chunk+6)=0;
    *(chunk+7)=green;
    *(chunk+8)=0;
    *(chunk+9)=blue;
    (void) WriteBlob(image,(size_t) num_bytes,chunk);
    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));
  }

  if ((image->colorspace == sRGBColorspace || image->rendering_intent))
    {
      /*
        Write JNG sRGB chunk
      */
      (void) WriteBlobMSBULong(image,1L);
      PNGType(chunk,mng_sRGB);
      LogPNGChunk(logging,mng_sRGB,1L);

      if (image->rendering_intent != UndefinedIntent)
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (image->rendering_intent));

      else
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (PerceptualIntent));

      (void) WriteBlob(image,5,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));
    }
  else
    {
      if (image->gamma != 0.0)
        {
          /*
             Write JNG gAMA chunk
          */
          (void) WriteBlobMSBULong(image,4L);
          PNGType(chunk,mng_gAMA);
          LogPNGChunk(logging,mng_gAMA,4L);
          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));
          (void) WriteBlob(image,8,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));
        }

      if ((mng_info->equal_chrms == MagickFalse) &&
          (image->chromaticity.red_primary.x != 0.0))
        {
          PrimaryInfo
            primary;

          /*
             Write JNG cHRM chunk
          */
          (void) WriteBlobMSBULong(image,32L);
          PNGType(chunk,mng_cHRM);
          LogPNGChunk(logging,mng_cHRM,32L);
          primary=image->chromaticity.white_point;
          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.red_primary;
          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.green_primary;
          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.blue_primary;
          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));
          (void) WriteBlob(image,36,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));
        }
    }

  if (image->resolution.x && image->resolution.y && !mng_info->equal_physs)
    {
      /*
         Write JNG pHYs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_pHYs);
      LogPNGChunk(logging,mng_pHYs,9L);
      if (image->units == PixelsPerInchResolution)
        {
          PNGLong(chunk+4,(png_uint_32)
            (image->resolution.x*100.0/2.54+0.5));

          PNGLong(chunk+8,(png_uint_32)
            (image->resolution.y*100.0/2.54+0.5));

          chunk[12]=1;
        }

      else
        {
          if (image->units == PixelsPerCentimeterResolution)
            {
              PNGLong(chunk+4,(png_uint_32)
                (image->resolution.x*100.0+0.5));

              PNGLong(chunk+8,(png_uint_32)
                (image->resolution.y*100.0+0.5));

              chunk[12]=1;
            }

          else
            {
              PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));
              PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));
              chunk[12]=0;
            }
        }
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))
    {
      /*
         Write JNG oFFs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_oFFs);
      LogPNGChunk(logging,mng_oFFs,9L);
      PNGsLong(chunk+4,(ssize_t) (image->page.x));
      PNGsLong(chunk+8,(ssize_t) (image->page.y));
      chunk[12]=0;
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          register ssize_t
            i;

          size_t
            len;

          /* Write IDAT chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write IDAT chunks from blob, length=%.20g."",(double)
              length);

          /* Copy IDAT chunks */
          len=0;
          p=blob+8;
          for (i=8; i<(ssize_t) length; i+=len+12)
          {
            len=(((unsigned int) *(p    ) & 0xff) << 24) +
                (((unsigned int) *(p + 1) & 0xff) << 16) +
                (((unsigned int) *(p + 2) & 0xff) <<  8) +
                (((unsigned int) *(p + 3) & 0xff)      ) ;
            p+=4;

            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */
              {
                /* Found an IDAT chunk. */
                (void) WriteBlobMSBULong(image,len);
                LogPNGChunk(logging,mng_IDAT,len);
                (void) WriteBlob(image,len+4,p);
                (void) WriteBlobMSBULong(image, crc32(0,p,(uInt) len+4));
              }

            else
              {
                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""    Skipping %c%c%c%c chunk, length=%.20g."",
                    *(p),*(p+1),*(p+2),*(p+3),(double) len);
              }
            p+=(8+len);
          }
        }
      else if (length != 0)
        {
          /* Write JDAA chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write JDAA chunk, length=%.20g."",(double) length);
          (void) WriteBlobMSBULong(image,(size_t) length);
          PNGType(chunk,mng_JDAA);
          LogPNGChunk(logging,mng_JDAA,length);
          /* Write JDAT chunk(s) data */
          (void) WriteBlob(image,4,chunk);
          (void) WriteBlob(image,length,blob);
          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,
             (uInt) length));
        }
      blob=(unsigned char *) RelinquishMagickMemory(blob);
    }

  /* Encode image as a JPEG blob */
  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image_info."");
  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);
  if (jpeg_image_info == (ImageInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image."");

  jpeg_image=CloneImage(image,0,0,MagickTrue,exception);
  if (jpeg_image == (Image *) NULL)
    {
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  (void) AcquireUniqueFilename(jpeg_image->filename);
  (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,""%s"",
    jpeg_image->filename);

  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
    exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Created jpeg_image, %.20g x %.20g."",(double) jpeg_image->columns,
      (double) jpeg_image->rows);

  if (status == MagickFalse)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (jng_color_type == 8 || jng_color_type == 12)
    jpeg_image_info->type=GrayscaleType;

  jpeg_image_info->quality=jng_quality;
  jpeg_image->quality=jng_quality;
  (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",MagickPathExtent);
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating blob."");

  blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,&length,
    exception);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Successfully read jpeg_image into a blob, length=%.20g."",
        (double) length);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Write JDAT chunk, length=%.20g."",(double) length);
    }

  /* Write JDAT chunk(s) */
  (void) WriteBlobMSBULong(image,(size_t) length);
  PNGType(chunk,mng_JDAT);
  LogPNGChunk(logging,mng_JDAT,length);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlob(image,length,blob);
  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));

  jpeg_image=DestroyImage(jpeg_image);
  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
  jpeg_image_info=DestroyImageInfo(jpeg_image_info);
  blob=(unsigned char *) RelinquishMagickMemory(blob);

  /* Write IEND chunk */
  (void) WriteBlobMSBULong(image,0L);
  PNGType(chunk,mng_IEND);
  LogPNGChunk(logging,mng_IEND,0);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOneJNGImage()"");

  return(status);
}
",C,,,,"@@ -4560,7 +4560,11 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
         chunk=(unsigned char *) AcquireQuantumMemory(length,sizeof(*chunk));
 
         if (chunk == (unsigned char *) NULL)
-          ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+          {
+            DestroyJNG(NULL,&color_image,&color_image_info,
+              &alpha_image,&alpha_image_info);
+            ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed"");
+          }
 
         for (i=0; i < (ssize_t) length; i++)
         {
@@ -4587,13 +4591,12 @@ static Image *ReadOneJNGImage(MngInfo *mng_info,
             jng_width=(png_uint_32)mng_get_long(p);
             jng_height=(png_uint_32)mng_get_long(&p[4]);
             if ((jng_width == 0) || (jng_height == 0))
-            {
-              DestroyJNG(chunk,&color_image,&color_image_info,
-                &alpha_image,&alpha_image_info);
-
-              ThrowReaderException(CorruptImageError,
-                ""NegativeOrZeroImageSize"");
-            }
+              {
+                DestroyJNG(chunk,&color_image,&color_image_info,
+                  &alpha_image,&alpha_image_info);
+                ThrowReaderException(CorruptImageError,
+                  ""NegativeOrZeroImageSize"");
+              }
             jng_color_type=p[8];
             jng_image_sample_depth=p[9];
             jng_image_compression_method=p[10];",ImageMagick,76efa969342568841ecf320b5a041685a6d24e0b,6b6bff054d569a77973f2140c0e86366e6168a6c,0,"static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info,
   const ImageInfo *image_info,Image *image,ExceptionInfo *exception)
{
  Image
    *jpeg_image;

  ImageInfo
    *jpeg_image_info;

  MagickBooleanType
    logging,
    status;

  size_t
    length;

  unsigned char
    *blob,
    chunk[80],
    *p;

  unsigned int
    jng_alpha_compression_method,
    jng_alpha_sample_depth,
    jng_color_type,
    transparent;

  size_t
    jng_alpha_quality,
    jng_quality;

  logging=LogMagickEvent(CoderEvent,GetMagickModule(),
    ""  Enter WriteOneJNGImage()"");

  blob=(unsigned char *) NULL;
  jpeg_image=(Image *) NULL;
  jpeg_image_info=(ImageInfo *) NULL;
  length=0;

  status=MagickTrue;
  transparent=image_info->type==GrayscaleAlphaType ||
     image_info->type==TrueColorAlphaType ||
     image->alpha_trait != UndefinedPixelTrait;

  jng_alpha_sample_depth = 0;

  jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000;

  jng_alpha_compression_method=(image->compression==JPEGCompression ||
    image_info->compression==JPEGCompression) ? 8 : 0;

  jng_alpha_quality=image_info->quality == 0UL ? 75UL :
      image_info->quality;

  if (jng_alpha_quality >= 1000)
    jng_alpha_quality /= 1000;

  length=0;

  if (transparent != 0)
    {
      jng_color_type=14;

      /* Create JPEG blob, image, and image_info */
      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image_info for alpha."");

      jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);

      if (jpeg_image_info == (ImageInfo *) NULL)
        {
          jpeg_image_info=DestroyImageInfo(jpeg_image_info);
          ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
        }

      if (logging != MagickFalse)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""  Creating jpeg_image."");

      jpeg_image=SeparateImage(image,AlphaChannel,exception);
      if (jpeg_image == (Image *) NULL)
        ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
      (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
      jpeg_image->alpha_trait=UndefinedPixelTrait;
      jpeg_image->quality=jng_alpha_quality;
      jpeg_image_info->type=GrayscaleType;
      (void) SetImageType(jpeg_image,GrayscaleType,exception);
      (void) AcquireUniqueFilename(jpeg_image->filename);
      (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,
        ""%s"",jpeg_image->filename);
    }
  else
    {
      jng_alpha_compression_method=0;
      jng_color_type=10;
      jng_alpha_sample_depth=0;
    }

  /* To do: check bit depth of PNG alpha channel */

  /* Check if image is grayscale. */
  if (image_info->type != TrueColorAlphaType && image_info->type !=
    TrueColorType && SetImageGray(image,exception))
    jng_color_type-=2;

  if (logging != MagickFalse)
    {
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Quality           = %d"",(int) jng_quality);
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),
          ""    JNG Color Type        = %d"",jng_color_type);
        if (transparent != 0)
          {
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Compression = %d"",jng_alpha_compression_method);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Depth       = %d"",jng_alpha_sample_depth);
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""    JNG Alpha Quality     = %d"",(int) jng_alpha_quality);
          }
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          const char
            *value;

          /* Encode alpha as a grayscale PNG blob */
          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating PNG blob."");

          (void) CopyMagickString(jpeg_image_info->magick,""PNG"",
             MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""PNG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;

          /* Exclude all ancillary chunks */
          (void) SetImageArtifact(jpeg_image,""png:exclude-chunks"",""all"");

          blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,
            &length,exception);

          /* Retrieve sample depth used */
          value=GetImageProperty(jpeg_image,""png:bit-depth-written"",exception);
          if (value != (char *) NULL)
            jng_alpha_sample_depth= (unsigned int) value[0];
        }
      else
        {
          /* Encode alpha as a grayscale JPEG blob */

          status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
            exception);
          if (status == MagickFalse)
            ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

          (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",
            MagickPathExtent);
          (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);
          jpeg_image_info->interlace=NoInterlace;
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Creating blob."");
          blob=(unsigned char *) ImageToBlob(jpeg_image_info,
             jpeg_image,&length,
           exception);
          jng_alpha_sample_depth=8;

          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Successfully read jpeg_image into a blob, length=%.20g."",
              (double) length);

        }
      /* Destroy JPEG image and image_info */
      jpeg_image=DestroyImage(jpeg_image);
      (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
    }

  /* Write JHDR chunk */
  (void) WriteBlobMSBULong(image,16L);  /* chunk data length=16 */
  PNGType(chunk,mng_JHDR);
  LogPNGChunk(logging,mng_JHDR,16L);
  PNGLong(chunk+4,(png_uint_32) image->columns);
  PNGLong(chunk+8,(png_uint_32) image->rows);
  chunk[12]=jng_color_type;
  chunk[13]=8;  /* sample depth */
  chunk[14]=8; /*jng_image_compression_method */
  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8);
  chunk[16]=jng_alpha_sample_depth;
  chunk[17]=jng_alpha_compression_method;
  chunk[18]=0; /*jng_alpha_filter_method */
  chunk[19]=0; /*jng_alpha_interlace_method */
  (void) WriteBlob(image,20,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,20));
  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG width:%15lu"",(unsigned long) image->columns);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG height:%14lu"",(unsigned long) image->rows);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG color type:%10d"",jng_color_type);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG sample depth:%8d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG compression:%9d"",8);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG interlace:%11d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha depth:%9d"",jng_alpha_sample_depth);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha compression:%3d"",jng_alpha_compression_method);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha filter:%8d"",0);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""    JNG alpha interlace:%5d"",0);
    }

  /*
     Write leading ancillary chunks
  */

  if (transparent != 0)
  {
    /*
      Write JNG bKGD chunk
    */

    unsigned char
      blue,
      green,
      red;

    ssize_t
      num_bytes;

    if (jng_color_type == 8 || jng_color_type == 12)
      num_bytes=6L;
    else
      num_bytes=10L;
    (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L));
    PNGType(chunk,mng_bKGD);
    LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L));
    red=ScaleQuantumToChar(image->background_color.red);
    green=ScaleQuantumToChar(image->background_color.green);
    blue=ScaleQuantumToChar(image->background_color.blue);
    *(chunk+4)=0;
    *(chunk+5)=red;
    *(chunk+6)=0;
    *(chunk+7)=green;
    *(chunk+8)=0;
    *(chunk+9)=blue;
    (void) WriteBlob(image,(size_t) num_bytes,chunk);
    (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes));
  }

  if ((image->colorspace == sRGBColorspace || image->rendering_intent))
    {
      /*
        Write JNG sRGB chunk
      */
      (void) WriteBlobMSBULong(image,1L);
      PNGType(chunk,mng_sRGB);
      LogPNGChunk(logging,mng_sRGB,1L);

      if (image->rendering_intent != UndefinedIntent)
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (image->rendering_intent));

      else
        chunk[4]=(unsigned char)
          Magick_RenderingIntent_to_PNG_RenderingIntent(
          (PerceptualIntent));

      (void) WriteBlob(image,5,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,5));
    }
  else
    {
      if (image->gamma != 0.0)
        {
          /*
             Write JNG gAMA chunk
          */
          (void) WriteBlobMSBULong(image,4L);
          PNGType(chunk,mng_gAMA);
          LogPNGChunk(logging,mng_gAMA,4L);
          PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5));
          (void) WriteBlob(image,8,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,8));
        }

      if ((mng_info->equal_chrms == MagickFalse) &&
          (image->chromaticity.red_primary.x != 0.0))
        {
          PrimaryInfo
            primary;

          /*
             Write JNG cHRM chunk
          */
          (void) WriteBlobMSBULong(image,32L);
          PNGType(chunk,mng_cHRM);
          LogPNGChunk(logging,mng_cHRM,32L);
          primary=image->chromaticity.white_point;
          PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.red_primary;
          PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.green_primary;
          PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5));
          primary=image->chromaticity.blue_primary;
          PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5));
          PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5));
          (void) WriteBlob(image,36,chunk);
          (void) WriteBlobMSBULong(image,crc32(0,chunk,36));
        }
    }

  if (image->resolution.x && image->resolution.y && !mng_info->equal_physs)
    {
      /*
         Write JNG pHYs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_pHYs);
      LogPNGChunk(logging,mng_pHYs,9L);
      if (image->units == PixelsPerInchResolution)
        {
          PNGLong(chunk+4,(png_uint_32)
            (image->resolution.x*100.0/2.54+0.5));

          PNGLong(chunk+8,(png_uint_32)
            (image->resolution.y*100.0/2.54+0.5));

          chunk[12]=1;
        }

      else
        {
          if (image->units == PixelsPerCentimeterResolution)
            {
              PNGLong(chunk+4,(png_uint_32)
                (image->resolution.x*100.0+0.5));

              PNGLong(chunk+8,(png_uint_32)
                (image->resolution.y*100.0+0.5));

              chunk[12]=1;
            }

          else
            {
              PNGLong(chunk+4,(png_uint_32) (image->resolution.x+0.5));
              PNGLong(chunk+8,(png_uint_32) (image->resolution.y+0.5));
              chunk[12]=0;
            }
        }
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (mng_info->write_mng == 0 && (image->page.x || image->page.y))
    {
      /*
         Write JNG oFFs chunk
      */
      (void) WriteBlobMSBULong(image,9L);
      PNGType(chunk,mng_oFFs);
      LogPNGChunk(logging,mng_oFFs,9L);
      PNGsLong(chunk+4,(ssize_t) (image->page.x));
      PNGsLong(chunk+8,(ssize_t) (image->page.y));
      chunk[12]=0;
      (void) WriteBlob(image,13,chunk);
      (void) WriteBlobMSBULong(image,crc32(0,chunk,13));
    }

  if (transparent != 0)
    {
      if (jng_alpha_compression_method==0)
        {
          register ssize_t
            i;

          size_t
            len;

          /* Write IDAT chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write IDAT chunks from blob, length=%.20g."",(double)
              length);

          /* Copy IDAT chunks */
          len=0;
          p=blob+8;
          for (i=8; i<(ssize_t) length; i+=len+12)
          {
            len=(((unsigned int) *(p    ) & 0xff) << 24) +
                (((unsigned int) *(p + 1) & 0xff) << 16) +
                (((unsigned int) *(p + 2) & 0xff) <<  8) +
                (((unsigned int) *(p + 3) & 0xff)      ) ;
            p+=4;

            if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84) /* IDAT */
              {
                /* Found an IDAT chunk. */
                (void) WriteBlobMSBULong(image,len);
                LogPNGChunk(logging,mng_IDAT,len);
                (void) WriteBlob(image,len+4,p);
                (void) WriteBlobMSBULong(image, crc32(0,p,(uInt) len+4));
              }

            else
              {
                if (logging != MagickFalse)
                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),
                    ""    Skipping %c%c%c%c chunk, length=%.20g."",
                    *(p),*(p+1),*(p+2),*(p+3),(double) len);
              }
            p+=(8+len);
          }
        }
      else if (length != 0)
        {
          /* Write JDAA chunk header */
          if (logging != MagickFalse)
            (void) LogMagickEvent(CoderEvent,GetMagickModule(),
              ""  Write JDAA chunk, length=%.20g."",(double) length);
          (void) WriteBlobMSBULong(image,(size_t) length);
          PNGType(chunk,mng_JDAA);
          LogPNGChunk(logging,mng_JDAA,length);
          /* Write JDAT chunk(s) data */
          (void) WriteBlob(image,4,chunk);
          (void) WriteBlob(image,length,blob);
          (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,
             (uInt) length));
        }
      blob=(unsigned char *) RelinquishMagickMemory(blob);
    }

  /* Encode image as a JPEG blob */
  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image_info."");
  jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info);
  if (jpeg_image_info == (ImageInfo *) NULL)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating jpeg_image."");

  jpeg_image=CloneImage(image,0,0,MagickTrue,exception);
  if (jpeg_image == (Image *) NULL)
    {
      jpeg_image_info=DestroyImageInfo(jpeg_image_info);
      ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");
    }
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  (void) AcquireUniqueFilename(jpeg_image->filename);
  (void) FormatLocaleString(jpeg_image_info->filename,MagickPathExtent,""%s"",
    jpeg_image->filename);

  status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode,
    exception);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Created jpeg_image, %.20g x %.20g."",(double) jpeg_image->columns,
      (double) jpeg_image->rows);

  if (status == MagickFalse)
    ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed"");

  if (jng_color_type == 8 || jng_color_type == 12)
    jpeg_image_info->type=GrayscaleType;

  jpeg_image_info->quality=jng_quality;
  jpeg_image->quality=jng_quality;
  (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",MagickPathExtent);
  (void) CopyMagickString(jpeg_image->magick,""JPEG"",MagickPathExtent);

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  Creating blob."");

  blob=(unsigned char *) ImageToBlob(jpeg_image_info,jpeg_image,&length,
    exception);

  if (logging != MagickFalse)
    {
      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Successfully read jpeg_image into a blob, length=%.20g."",
        (double) length);

      (void) LogMagickEvent(CoderEvent,GetMagickModule(),
        ""  Write JDAT chunk, length=%.20g."",(double) length);
    }

  /* Write JDAT chunk(s) */
  (void) WriteBlobMSBULong(image,(size_t) length);
  PNGType(chunk,mng_JDAT);
  LogPNGChunk(logging,mng_JDAT,length);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlob(image,length,blob);
  (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length));

  jpeg_image=DestroyImage(jpeg_image);
  (void) RelinquishUniqueFileResource(jpeg_image_info->filename);
  jpeg_image_info=DestroyImageInfo(jpeg_image_info);
  blob=(unsigned char *) RelinquishMagickMemory(blob);

  /* Write IEND chunk */
  (void) WriteBlobMSBULong(image,0L);
  PNGType(chunk,mng_IEND);
  LogPNGChunk(logging,mng_IEND,0);
  (void) WriteBlob(image,4,chunk);
  (void) WriteBlobMSBULong(image,crc32(0,chunk,4));

  if (logging != MagickFalse)
    (void) LogMagickEvent(CoderEvent,GetMagickModule(),
      ""  exit WriteOneJNGImage()"");

  return(status);
}
"
16670,,Local,Not required,Partial,CVE-2011-4930,https://www.cvedetails.com/cve/CVE-2011-4930/,CWE-134,Medium,Partial,Partial,,2014-02-10,4.4,"Multiple format string vulnerabilities in Condor 7.2.0 through 7.6.4, and possibly certain 7.7.x versions, as used in Red Hat MRG Grid and possibly other products, allow local users to cause a denial of service (condor_schedd daemon and failure to launch jobs) and possibly execute arbitrary code via format string specifiers in (1) the reason for a hold for a job that uses an XML user log, (2) the filename of a file to be transferred, and possibly other unspecified vectors.",2014-02-10,DoS Exec Code,0,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=commitdiff;h=5e5571d1a431eb3c61977b6dd6ec90186ef79867,5e5571d1a431eb3c61977b6dd6ec90186ef79867,,0,,,"ReadUserLogStateAccess::isInitialized( void ) const
{
	return m_state->isInitialized( );
}
","ReadUserLogStateAccess::isInitialized( void ) const
{
	return m_state->isInitialized( );
}
",CPP,,,9f2e09401a1a262e1b00ac3bf8cd3f0d79aa876c,"@@ -752,7 +752,7 @@ ReadUserLogState::SetState( const ReadUserLog::FileState &state )
 
        MyString        str;
        GetStateString( str, ""Restored reader state"" );
-       dprintf( D_FULLDEBUG, str.Value() );
+       dprintf( D_FULLDEBUG, ""%s"", str.Value() );
 
        return true;
 }",htcondor,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/read_user_log_state.cpp;h=715e0fbac16028399aecf2b98628eab3137f3423;hb=5e5571d1a431eb3c61977b6dd6ec90186ef79867,https://htcondor-git.cs.wisc.edu/?p=condor.git;a=blob;f=src/condor_utils/read_user_log_state.cpp;h=b7bbfb4fbdc0419236214cf371be89dae2fbedea,0,"ReadUserLogStateAccess::isInitialized( void ) const
{
	return m_state->isInitialized( );
}
"
108713,,Remote,Not required,Complete,CVE-2012-5141,https://www.cvedetails.com/cve/CVE-2012-5141/,,Low,Complete,Complete,,2012-12-12,10.0,"Google Chrome before 23.0.1271.97 does not properly restrict instantiation of the Chromoting client plug-in, which has unspecified impact and attack vectors.",2018-10-30,,0,https://github.com/chromium/chromium/commit/21fdcdd977e8ab479dd99c6d0d2f562dda98261d,21fdcdd977e8ab479dd99c6d0d2f562dda98261d,"Restrict the Chromoting client plugin to use by extensions & apps.

BUG=160456


Review URL: https://chromiumcodereview.appspot.com/11365276

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@168289 0039d316-1c4b-4281-b951-d872f2087c98",0,remoting/client/plugin/chromoting_instance.cc,"{""sha"": ""4b2be13d4b955f7fbde4280cf3c72dea48c577d5"", ""filename"": ""remoting/client/plugin/chromoting_instance.cc"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 0, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/21fdcdd977e8ab479dd99c6d0d2f562dda98261d/remoting/client/plugin/chromoting_instance.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/21fdcdd977e8ab479dd99c6d0d2f562dda98261d/remoting/client/plugin/chromoting_instance.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/remoting/client/plugin/chromoting_instance.cc?ref=21fdcdd977e8ab479dd99c6d0d2f562dda98261d"", ""patch"": ""@@ -23,6 +23,7 @@\n #include \""media/base/media.h\""\n #include \""net/socket/ssl_server_socket.h\""\n #include \""ppapi/cpp/completion_callback.h\""\n+#include \""ppapi/cpp/dev/url_util_dev.h\""\n #include \""ppapi/cpp/input_event.h\""\n #include \""ppapi/cpp/mouse_cursor.h\""\n #include \""ppapi/cpp/rect.h\""\n@@ -55,6 +56,9 @@ const int kBytesPerPixel = 4;\n \n const int kPerfStatsIntervalMs = 1000;\n \n+// URL scheme used by Chrome apps and extensions.\n+const char kChromeExtensionUrlScheme[] = \""chrome-extension\"";\n+\n std::string ConnectionStateToString(protocol::ConnectionToHost::State state) {\n   // Values returned by this function must match the\n   // remoting.ClientSession.State enum in JS code.\n@@ -217,6 +221,12 @@ bool ChromotingInstance::Init(uint32_t argc,\n     return false;\n   }\n \n+  // Check that the calling content is part of an app or extension.\n+  if (!IsCallerAppOrExtension()) {\n+    LOG(ERROR) << \""Not an app or extension\"";\n+    return false;\n+  }\n+\n   // Enable support for SSL server sockets, which must be done as early as\n   // possible, preferably before any NSS SSL sockets (client or server) have\n   // been created.\n@@ -754,6 +764,22 @@ void ChromotingInstance::ProcessLogToUI(const std::string& message) {\n   g_logging_to_plugin = false;\n }\n \n+bool ChromotingInstance::IsCallerAppOrExtension() {\n+  const pp::URLUtil_Dev* url_util = pp::URLUtil_Dev::Get();\n+  if (!url_util)\n+    return false;\n+\n+  PP_URLComponents_Dev url_components;\n+  pp::Var url_var = url_util->GetDocumentURL(this, &url_components);\n+  if (!url_var.is_string())\n+    return false;\n+\n+  std::string url = url_var.AsString();\n+  std::string url_scheme = url.substr(url_components.scheme.begin,\n+                                      url_components.scheme.len);\n+  return url_scheme == kChromeExtensionUrlScheme;\n+}\n+\n bool ChromotingInstance::IsConnected() {\n   return host_connection_.get() &&\n     (host_connection_->state() == protocol::ConnectionToHost::CONNECTED);""}<_**next**_>{""sha"": ""44911c890822bd5d80220ffc48473acc42771046"", ""filename"": ""remoting/client/plugin/chromoting_instance.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/21fdcdd977e8ab479dd99c6d0d2f562dda98261d/remoting/client/plugin/chromoting_instance.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/21fdcdd977e8ab479dd99c6d0d2f562dda98261d/remoting/client/plugin/chromoting_instance.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/remoting/client/plugin/chromoting_instance.h?ref=21fdcdd977e8ab479dd99c6d0d2f562dda98261d"", ""patch"": ""@@ -177,6 +177,9 @@ class ChromotingInstance :\n \n   void ProcessLogToUI(const std::string& message);\n \n+  // Returns true if the hosting content has the chrome-extension:// scheme.\n+  bool IsCallerAppOrExtension();\n+\n   // Returns true if there is a ConnectionToHost and it is connected.\n   bool IsConnected();\n ""}","bool ChromotingInstance::ParseAuthMethods(const std::string& auth_methods_str,
                                          ClientConfig* config) {
  std::vector<std::string> auth_methods;
  base::SplitString(auth_methods_str, ',', &auth_methods);
  for (std::vector<std::string>::iterator it = auth_methods.begin();
       it != auth_methods.end(); ++it) {
    protocol::AuthenticationMethod authentication_method =
        protocol::AuthenticationMethod::FromString(*it);
    if (authentication_method.is_valid())
      config->authentication_methods.push_back(authentication_method);
  }
  if (config->authentication_methods.empty()) {
    LOG(ERROR) << ""No valid authentication methods specified."";
    return false;
  }

  return true;
}
","bool ChromotingInstance::ParseAuthMethods(const std::string& auth_methods_str,
                                          ClientConfig* config) {
  std::vector<std::string> auth_methods;
  base::SplitString(auth_methods_str, ',', &auth_methods);
  for (std::vector<std::string>::iterator it = auth_methods.begin();
       it != auth_methods.end(); ++it) {
    protocol::AuthenticationMethod authentication_method =
        protocol::AuthenticationMethod::FromString(*it);
    if (authentication_method.is_valid())
      config->authentication_methods.push_back(authentication_method);
  }
  if (config->authentication_methods.empty()) {
    LOG(ERROR) << ""No valid authentication methods specified."";
    return false;
  }

  return true;
}
",C,,,,"@@ -23,6 +23,7 @@
 #include ""media/base/media.h""
 #include ""net/socket/ssl_server_socket.h""
 #include ""ppapi/cpp/completion_callback.h""
+#include ""ppapi/cpp/dev/url_util_dev.h""
 #include ""ppapi/cpp/input_event.h""
 #include ""ppapi/cpp/mouse_cursor.h""
 #include ""ppapi/cpp/rect.h""
@@ -55,6 +56,9 @@ const int kBytesPerPixel = 4;
 
 const int kPerfStatsIntervalMs = 1000;
 
+// URL scheme used by Chrome apps and extensions.
+const char kChromeExtensionUrlScheme[] = ""chrome-extension"";
+
 std::string ConnectionStateToString(protocol::ConnectionToHost::State state) {
   // Values returned by this function must match the
   // remoting.ClientSession.State enum in JS code.
@@ -217,6 +221,12 @@ bool ChromotingInstance::Init(uint32_t argc,
     return false;
   }
 
+  // Check that the calling content is part of an app or extension.
+  if (!IsCallerAppOrExtension()) {
+    LOG(ERROR) << ""Not an app or extension"";
+    return false;
+  }
+
   // Enable support for SSL server sockets, which must be done as early as
   // possible, preferably before any NSS SSL sockets (client or server) have
   // been created.
@@ -754,6 +764,22 @@ void ChromotingInstance::ProcessLogToUI(const std::string& message) {
   g_logging_to_plugin = false;
 }
 
+bool ChromotingInstance::IsCallerAppOrExtension() {
+  const pp::URLUtil_Dev* url_util = pp::URLUtil_Dev::Get();
+  if (!url_util)
+    return false;
+
+  PP_URLComponents_Dev url_components;
+  pp::Var url_var = url_util->GetDocumentURL(this, &url_components);
+  if (!url_var.is_string())
+    return false;
+
+  std::string url = url_var.AsString();
+  std::string url_scheme = url.substr(url_components.scheme.begin,
+                                      url_components.scheme.len);
+  return url_scheme == kChromeExtensionUrlScheme;
+}
+
 bool ChromotingInstance::IsConnected() {
   return host_connection_.get() &&
     (host_connection_->state() == protocol::ConnectionToHost::CONNECTED);",Chrome,21fdcdd977e8ab479dd99c6d0d2f562dda98261d,c4a5d6e32dffa766ca4df79d5b2ed262a71c9440,0,"bool ChromotingInstance::ParseAuthMethods(const std::string& auth_methods_str,
                                          ClientConfig* config) {
  std::vector<std::string> auth_methods;
  base::SplitString(auth_methods_str, ',', &auth_methods);
  for (std::vector<std::string>::iterator it = auth_methods.begin();
       it != auth_methods.end(); ++it) {
    protocol::AuthenticationMethod authentication_method =
        protocol::AuthenticationMethod::FromString(*it);
    if (authentication_method.is_valid())
      config->authentication_methods.push_back(authentication_method);
  }
  if (config->authentication_methods.empty()) {
    LOG(ERROR) << ""No valid authentication methods specified."";
    return false;
  }

  return true;
}
"
7145,,Remote,Not required,Partial,CVE-2014-9659,https://www.cvedetails.com/cve/CVE-2014-9659/,CWE-119,Low,Partial,Partial,,2015-02-08,7.5,"cff/cf2intrp.c in the CFF CharString interpreter in FreeType before 2.5.4 proceeds with additional hints after the hint mask has been computed, which allows remote attackers to execute arbitrary code or cause a denial of service (stack-based buffer overflow) via a crafted OpenType font.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-2240.",2018-10-30,DoS Exec Code Overflow,0,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/commit/?id=2cdc4562f873237f1c77d43540537c7a721d3fd8,2cdc4562f873237f1c77d43540537c7a721d3fd8,,0,,,"  cf2_hint_initZero( CF2_Hint  hint )
  {
    FT_ZERO( hint );
  }
","  cf2_hint_initZero( CF2_Hint  hint )
  {
    FT_ZERO( hint );
  }
",C,,,8fa69a88d75fd374ea86a9869f6e74a924926e49,"@@ -794,9 +794,12 @@
     maskPtr      = cf2_hintmask_getMaskPtr( &tempHintMask );
 
     /* use the hStem hints only, which are first in the mask */
-    /* TODO: compare this to cffhintmaskGetBitCount */
     bitCount = cf2_arrstack_size( hStemHintArray );
 
+    /* Defense-in-depth.  Should never return here. */
+    if ( bitCount > hintMask->bitCount )
+        return;
+
     /* synthetic embox hints get highest priority */
     if ( font->blues.doEmBoxHints )
     {",savannah,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/cff/cf2hints.c?id=2cdc4562f873237f1c77d43540537c7a721d3fd8,https://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/cff/cf2hints.c?id=8fa69a88d75fd374ea86a9869f6e74a924926e49,0,"  cf2_hint_initZero( CF2_Hint  hint )
  {
    FT_ZERO( hint );
  }
"
187249,,Remote,Not required,,CVE-2018-6137,https://www.cvedetails.com/cve/CVE-2018-6137/,CWE-200,Medium,Partial,,,2019-01-09,4.3,CSS Paint API in Blink in Google Chrome prior to 67.0.3396.62 allowed a remote attacker to leak cross-origin data via a crafted HTML page.,2019-01-14,+Info ,6,https://github.com/chromium/chromium/commit/67d9b414fa64448abc398ae9fc57c3ddf5de5998,67d9b414fa64448abc398ae9fc57c3ddf5de5998,"[PaintWorklet] Do not paint when paint target is associated with a link

When the target element of a paint worklet has an associated link, then
the 'paint' function will be invoked when the link's href is changed
from a visited URL to an unvisited URL (or vice versa).

This CL changes the behavior by detecting whether the target element
of a paint worklet has an associated link or not. If it does, then don't
paint.

TBR=haraken@chromium.org

Bug: 835589
Change-Id: I5fdf85685f863c960a6f48cc9a345dda787bece1
Reviewed-on: https://chromium-review.googlesource.com/1035524
Reviewed-by: Xida Chen <xidachen@chromium.org>
Reviewed-by: Ian Kilpatrick <ikilpatrick@chromium.org>
Reviewed-by: Stephen McGruer <smcgruer@chromium.org>
Commit-Queue: Xida Chen <xidachen@chromium.org>
Cr-Commit-Position: refs/heads/master@{#555788}",1,third_party/blink/renderer/core/css/css_paint_value.cc,"{""sha"": ""1aaa34c60ac96d285e6499bb85ffc2d7c8e4e9c7"", ""filename"": ""third_party/blink/renderer/controller/BUILD.gn"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/controller/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/controller/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/controller/BUILD.gn?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -61,6 +61,7 @@ group(\""webkit_unit_tests_data\"") {\n     \""../core/testing/data/\"",\n     \""../core/paint/test_data/\"",\n     \""../core/animation/test_data/\"",\n+    \""../core/css/test_data/\"",\n   ]\n }\n ""}<_**next**_>{""sha"": ""4a61cbf15ce9dde587277d90f30e84079e9b0af1"", ""filename"": ""third_party/blink/renderer/core/BUILD.gn"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/BUILD.gn?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -1644,6 +1644,7 @@ jumbo_source_set(\""unit_tests\"") {\n     \""css/css_font_face_source_test.cc\"",\n     \""css/css_gradient_value_test.cc\"",\n     \""css/css_page_rule_test.cc\"",\n+    \""css/css_paint_value_test.cc\"",\n     \""css/css_selector_test.cc\"",\n     \""css/css_selector_watch_test.cc\"",\n     \""css/css_style_declaration_test.cc\"",""}<_**next**_>{""sha"": ""dd2cef1941980d4a3fb123eada063f56d5542c23"", ""filename"": ""third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_custom_ident_value.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_custom_ident_value.h?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -11,7 +11,7 @@\n \n namespace blink {\n \n-class CSSCustomIdentValue : public CSSValue {\n+class CORE_EXPORT CSSCustomIdentValue : public CSSValue {\n  public:\n   static CSSCustomIdentValue* Create(const AtomicString& str) {\n     return new CSSCustomIdentValue(str);""}<_**next**_>{""sha"": ""78a4816e04ff2d48a1721a0db2b86eb04b9c0768"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -46,8 +46,13 @@ String CSSPaintValue::GetName() const {\n scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n-    const ComputedStyle&,\n+    const ComputedStyle& style,\n     const FloatSize& target_size) {\n+  // https://crbug.com/835589: early exit when paint target is associated with\n+  // a link.\n+  if (style.InsideLink() != EInsideLink::kNotInsideLink)\n+    return nullptr;\n+\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);""}<_**next**_>{""sha"": ""fc879596b9b4f2f389e75f6fbb520feaa84ebbbc"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value.h?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -15,7 +15,7 @@\n \n namespace blink {\n \n-class CSSPaintValue : public CSSImageGeneratorValue {\n+class CORE_EXPORT CSSPaintValue : public CSSImageGeneratorValue {\n  public:\n   static CSSPaintValue* Create(CSSCustomIdentValue* name) {\n     return new CSSPaintValue(name);""}<_**next**_>{""sha"": ""923faeaf8234d61e44100388a1636c12ca548cf7"", ""filename"": ""third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""status"": ""added"", ""additions"": 81, ""deletions"": 0, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/css_paint_value_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/css_paint_value_test.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,81 @@\n+// Copyright 2018 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""third_party/blink/renderer/core/css/css_paint_value.h\""\n+\n+#include <memory>\n+#include \""testing/gtest/include/gtest/gtest.h\""\n+#include \""third_party/blink/renderer/core/css/css_custom_ident_value.h\""\n+#include \""third_party/blink/renderer/core/dom/document.h\""\n+#include \""third_party/blink/renderer/core/frame/frame_test_helpers.h\""\n+#include \""third_party/blink/renderer/core/frame/web_local_frame_impl.h\""\n+#include \""third_party/blink/renderer/core/layout/layout_object.h\""\n+#include \""third_party/blink/renderer/core/style/computed_style.h\""\n+#include \""third_party/blink/renderer/core/testing/core_unit_test_helper.h\""\n+#include \""third_party/blink/renderer/platform/testing/unit_test_helpers.h\""\n+#include \""third_party/blink/renderer/platform/testing/url_test_helpers.h\""\n+\n+namespace blink {\n+\n+class CSSPaintValueTest : public RenderingTest {\n+ public:\n+  void LoadTestData(const std::string& file_name) {\n+    String testing_path = test::BlinkRootDir();\n+    testing_path.append(\""/renderer/core/css/test_data/\"");\n+    WebURL url = URLTestHelpers::RegisterMockedURLLoadFromBase(\n+        WebString::FromUTF8(base_url_), testing_path,\n+        WebString::FromUTF8(file_name));\n+    FrameTestHelpers::LoadFrame(helper_.GetWebView()->MainFrameImpl(),\n+                                base_url_ + file_name);\n+    ForceFullCompositingUpdate();\n+    URLTestHelpers::RegisterMockedURLUnregister(url);\n+  }\n+\n+  void ForceFullCompositingUpdate() {\n+    helper_.GetWebView()->UpdateAllLifecyclePhases();\n+  }\n+\n+  LocalFrame* GetFrame() const { return helper_.LocalMainFrame()->GetFrame(); }\n+\n+ private:\n+  void SetUp() override {\n+    RenderingTest::SetUp();\n+    EnableCompositing();\n+    helper_.Initialize(nullptr, nullptr, nullptr);\n+    base_url_ = \""https://www.test.com/\"";\n+  }\n+  FrameTestHelpers::WebViewHelper helper_;\n+  std::string base_url_;\n+};\n+\n+void CheckTargetObject(Document* document) {\n+  LayoutObject* target_layout_object =\n+      document->getElementById(\""target\"")->GetLayoutObject();\n+  EXPECT_NE(target_layout_object, nullptr);\n+  EXPECT_NE(target_layout_object->Style()->InsideLink(),\n+            EInsideLink::kNotInsideLink);\n+\n+  CSSPaintValue* css_paint_value =\n+      CSSPaintValue::Create(CSSCustomIdentValue::Create(\""linkpainter\""));\n+  EXPECT_EQ(css_paint_value->GetImage(*target_layout_object, *document,\n+                                      target_layout_object->StyleRef(),\n+                                      FloatSize(100.0f, 100.0f)),\n+            nullptr);\n+}\n+\n+// Regression test for https://crbug.com/835589.\n+TEST_F(CSSPaintValueTest, CSSPaintDoNotPaintForLink) {\n+  LoadTestData(\""csspaint-do-not-paint-for-link.html\"");\n+  Document* document = GetFrame()->GetDocument();\n+  CheckTargetObject(document);\n+}\n+\n+// Regression test for https://crbug.com/835589.\n+TEST_F(CSSPaintValueTest, CSSPaintDoNotPaintWhenParentHasLink) {\n+  LoadTestData(\""csspaint-do-not-paint-for-link-descendant.html\"");\n+  Document* document = GetFrame()->GetDocument();\n+  CheckTargetObject(document);\n+}\n+\n+}  // namespace blink""}<_**next**_>{""sha"": ""958ea8f4638e44921cd610c92504606b661c78d0"", ""filename"": ""third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""status"": ""added"", ""additions"": 39, ""deletions"": 0, ""changes"": 39, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link-descendant.html?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,39 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<style>\n+a {\n+  width: 200px;\n+  height: 200px;\n+}\n+b {\n+  background-image: paint(linkpainter);\n+  width: 100px;\n+  height: 100px;\n+}\n+</style>\n+</head>\n+<body>\n+  <a id=\""ancestor\"">\n+    <b id=\""target\""></b>\n+  </a>\n+<script>\n+function addPaintletFromSource (src) {\n+  var uri = 'data:application/javascript;charset=utf-8;base64,' + btoa(src);\n+  CSS.paintWorklet.addModule(uri).then();\n+}\n+\n+addPaintletFromSource(`\n+  class LinkPainter {\n+    paint(ctx, geom) {\n+      ctx.fillStyle = 'black';\n+      ctx.fillRect(0, 0, geom.width, geom.height);\n+    }\n+  }\n+  registerPaint('linkpainter', LinkPainter);\n+`);\n+\n+ancestor.href = 'https://cs.chromium.org';\n+</script>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""1d78b530ef889768c3cd7b24e92a337f7ab8e201"", ""filename"": ""third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""status"": ""added"", ""additions"": 33, ""deletions"": 0, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/css/test_data/csspaint-do-not-paint-for-link.html?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -0,0 +1,33 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+<style>\n+a {\n+  background-image: paint(linkpainter);\n+  width: 100px;\n+  height: 100px;\n+}\n+</style>\n+</head>\n+<body>\n+  <a id=\""target\""></a>\n+<script>\n+function addPaintletFromSource (src) {\n+  var uri = 'data:application/javascript;charset=utf-8;base64,' + btoa(src);\n+  CSS.paintWorklet.addModule(uri).then();\n+}\n+\n+addPaintletFromSource(`\n+  class LinkPainter {\n+    paint(ctx, geom) {\n+      ctx.fillStyle = 'black';\n+      ctx.fillRect(0, 0, geom.width, geom.height);\n+    }\n+  }\n+  registerPaint('linkpainter', LinkPainter);\n+`);\n+\n+target.href = 'https://cs.chromium.org';\n+</script>\n+</body>\n+</html>""}<_**next**_>{""sha"": ""58e8e7882d8298630391836adafd8e248c3435b1"", ""filename"": ""third_party/blink/renderer/core/style/computed_style.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/style/computed_style.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/67d9b414fa64448abc398ae9fc57c3ddf5de5998/third_party/blink/renderer/core/style/computed_style.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/style/computed_style.cc?ref=67d9b414fa64448abc398ae9fc57c3ddf5de5998"", ""patch"": ""@@ -721,6 +721,11 @@ bool ComputedStyle::DiffNeedsPaintInvalidationObject(\n bool ComputedStyle::DiffNeedsPaintInvalidationObjectForPaintImage(\n     const StyleImage& image,\n     const ComputedStyle& other) const {\n+  // https://crbug.com/835589: early exit when paint target is associated with\n+  // a link.\n+  if (InsideLink() != EInsideLink::kNotInsideLink)\n+    return false;\n+\n   CSSPaintValue* value = ToCSSPaintValue(image.CssValue());\n \n   // NOTE: If the invalidation properties vectors are null, we are invalid as""}"," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle& style,
     const FloatSize& target_size) {
  // https://crbug.com/835589: early exit when paint target is associated with
  // a link.
  if (style.InsideLink() != EInsideLink::kNotInsideLink)
    return nullptr;

   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
"," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle&,
     const FloatSize& target_size) {
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
",C,"    const ComputedStyle& style,
  // https://crbug.com/835589: early exit when paint target is associated with
  // a link.
  if (style.InsideLink() != EInsideLink::kNotInsideLink)
    return nullptr;

","    const ComputedStyle&,
",,"@@ -46,8 +46,13 @@ String CSSPaintValue::GetName() const {
 scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
-    const ComputedStyle&,
+    const ComputedStyle& style,
     const FloatSize& target_size) {
+  // https://crbug.com/835589: early exit when paint target is associated with
+  // a link.
+  if (style.InsideLink() != EInsideLink::kNotInsideLink)
+    return nullptr;
+
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);",Chrome,67d9b414fa64448abc398ae9fc57c3ddf5de5998,ad500fba0e02a219c6b8d7714a2bb56856234a3d,1," scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
//flaw_line_below:
    const ComputedStyle&,
//fix_flaw_line_below:
//    const ComputedStyle& style,
     const FloatSize& target_size) {
//fix_flaw_line_below:
//  // https://crbug.com/835589: early exit when paint target is associated with
//fix_flaw_line_below:
//  // a link.
//fix_flaw_line_below:
//  if (style.InsideLink() != EInsideLink::kNotInsideLink)
//fix_flaw_line_below:
//    return nullptr;
//fix_flaw_line_below:
//
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
"
66841,,Remote,Not required,Partial,CVE-2017-7946,https://www.cvedetails.com/cve/CVE-2017-7946/,CWE-416,Medium,,,,2017-04-18,4.3,The get_relocs_64 function in libr/bin/format/mach0/mach0.c in radare2 1.3.0 allows remote attackers to cause a denial of service (use-after-free and application crash) via a crafted Mach0 file.,2017-04-21,DoS ,0,https://github.com/radare/radare2/commit/d1e8ac62c6d978d4662f69116e30230d43033c92,d1e8ac62c6d978d4662f69116e30230d43033c92,Fix null deref and uaf in mach0 parser,0,libr/bin/format/mach0/mach0.c,"{""sha"": ""398a44b15289f997c25c6e7d9c2dd50129bb62e4"", ""filename"": ""libr/bin/format/mach0/mach0.c"", ""status"": ""modified"", ""additions"": 51, ""deletions"": 41, ""changes"": 92, ""blob_url"": ""https://github.com/radareorg/radare2/blob/d1e8ac62c6d978d4662f69116e30230d43033c92/libr/bin/format/mach0/mach0.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/d1e8ac62c6d978d4662f69116e30230d43033c92/libr/bin/format/mach0/mach0.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/format/mach0/mach0.c?ref=d1e8ac62c6d978d4662f69116e30230d43033c92"", ""patch"": ""@@ -1119,7 +1119,7 @@ static int init_items(struct MACH0_(obj_t)* bin) {\n \t\tcase LC_LOAD_WEAK_DYLIB:\n \t\t\tsdb_set (bin->kv, sdb_fmt (0, \""mach0_cmd_%d.cmd\"", i), \""load_dylib\"", 0);\n \t\t\tbin->nlibs++;\n-\t\t\tif (!parse_dylib(bin, off)){\n+\t\t\tif (!parse_dylib (bin, off)){\n \t\t\t\tbprintf (\""Cannot parse dylib\\n\"");\n \t\t\t\tbin->nlibs--;\n \t\t\t\treturn false;\n@@ -1130,30 +1130,31 @@ static int init_items(struct MACH0_(obj_t)* bin) {\n \t\t\t{\n \t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n \t\t\tsdb_set (bin->kv, sdb_fmt (0, \""mach0_cmd_%d.cmd\"", i), \""dyld_info\"", 0);\n-\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n-\n-\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n-\t\t\t\tbprintf (\""Cannot parse dyldinfo\\n\"");\n-\t\t\t\tfree (bin->dyld_info);\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n-\t\t\t\tfree (bin->dyld_info);\n-\t\t\t\tbin->dyld_info = NULL;\n-\t\t\t\tbprintf (\""Error: read (LC_DYLD_INFO) at 0x%08\""PFMT64x\""\\n\"", off);\n-\t\t\t} else {\n-\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n-\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n-\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n-\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n-\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n-\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n-\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n-\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n-\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n-\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n-\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n-\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n+\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n+\t\t\tif (bin->dyld_info) {\n+\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n+\t\t\t\t\tbprintf (\""Cannot parse dyldinfo\\n\"");\n+\t\t\t\t\tR_FREE (bin->dyld_info);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n+\t\t\t\t\tfree (bin->dyld_info);\n+\t\t\t\t\tbin->dyld_info = NULL;\n+\t\t\t\t\tbprintf (\""Error: read (LC_DYLD_INFO) at 0x%08\""PFMT64x\""\\n\"", off);\n+\t\t\t\t} else {\n+\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n+\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n+\t\t\t\t}\n \t\t\t}\n \t\t\t}\n \t\t\tbreak;\n@@ -1747,17 +1748,20 @@ struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {\n \t\tif ((bind_size + lazy_size)<1) {\n \t\t\treturn NULL;\n \t\t}\n-\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)\n+\t\tif (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {\n \t\t\treturn NULL;\n+\t\t}\n \t\tif (bin->dyld_info->lazy_bind_off > bin->size || \\\n-\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size)\n+\t\t\tbin->dyld_info->lazy_bind_off + lazy_size > bin->size) {\n \t\t\treturn NULL;\n-\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)\n+\t\t}\n+\t\tif (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {\n \t\t\treturn NULL;\n+\t\t}\n \t\t// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.\n-\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))\n+\t\tif (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {\n \t\t\treturn NULL;\n-\n+\t\t}\n \t\topcodes = calloc (1, bind_size + lazy_size + 1);\n \t\tif (!opcodes) {\n \t\t\tfree (relocs);\n@@ -1905,12 +1909,14 @@ relocs[i++].last = 0;\\\n \t\tfree (opcodes);\n \t} else {\n \t\tint j;\n-\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n+\t\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n \t\t\treturn NULL;\n-\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))\n+\t\t}\n+\t\tif (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {\n \t\t\treturn NULL;\n+\t\t}\n \t\tfor (j = 0; j < bin->dysymtab.nundefsym; j++) {\n-\t\t\tif (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n+\t\t\tif (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {\n \t\t\t\trelocs[i].ord = j;\n \t\t\t\trelocs[i++].last = 0;\n \t\t\t}\n@@ -1954,18 +1960,19 @@ struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n \t\t}\n \t\tbin->entry = entry->addr;\n \t}\n-\n \treturn entry;\n }\n \n struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n \tstruct lib_t *libs;\n \tint i;\n \n-\tif (!bin->nlibs)\n+\tif (!bin->nlibs) {\n \t\treturn NULL;\n-\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n+\t}\n+\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n \t\treturn NULL;\n+\t}\n \tfor (i = 0; i < bin->nlibs; i++) {\n \t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n \t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n@@ -1978,12 +1985,14 @@ struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n \tint i;\n \n-\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n+\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {\n \t\treturn 0;\n-\n-\tfor (i = 0; i < bin->nsegs; ++i)\n-\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n+\t}\n+\tfor (i = 0; i < bin->nsegs; ++i) {\n+\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {\n \t\t\treturn bin->segs[i].vmaddr;\n+\t\t}\n+\t}\n \treturn 0;\n }\n \n@@ -2309,8 +2318,9 @@ ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n \t\tut8 b[128];\n \t\tut64 entry = addr_to_offset(bin, bin->entry);\n \t\t// XXX: X86 only and hacky!\n-\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n+\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n \t\t\treturn 0;\n+\t\t}\n \t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n \t\tif (i < 1) {\n \t\t\treturn 0;""}","static int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {
	struct symtab_command st;
	ut32 size_sym;
	int i;
	ut8 symt[sizeof (struct symtab_command)] = {0};
	ut8 nlst[sizeof (struct MACH0_(nlist))] = {0};

	if (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size) { 
		return false;
	}	
	int len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));
	if (len != sizeof (struct symtab_command)) {
		bprintf (""Error: read (symtab)\n"");
		return false;
	}
	st.cmd = r_read_ble32 (&symt[0], bin->big_endian);
	st.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);
	st.symoff = r_read_ble32 (&symt[8], bin->big_endian);
	st.nsyms = r_read_ble32 (&symt[12], bin->big_endian);
	st.stroff = r_read_ble32 (&symt[16], bin->big_endian);
	st.strsize = r_read_ble32 (&symt[20], bin->big_endian);

	bin->symtab = NULL;
	bin->nsymtab = 0;
	if (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {
		bin->nsymtab = st.nsyms;
		if (st.stroff > bin->size || st.stroff + st.strsize > bin->size) {
			return false;
		}
		if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {
			bprintf(""fail2\n"");
			return false;
		}
		if (!size_sym) {
			bprintf(""fail3\n"");
			return false;
		}
		if (st.symoff > bin->size || st.symoff + size_sym > bin->size) {
			bprintf(""fail4\n"");
			return false;
		}
		if (!(bin->symstr = calloc (1, st.strsize + 2))) {
			perror (""calloc (symstr)"");
			return false;
		}
		bin->symstrlen = st.strsize;
		len = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);
		if (len != st.strsize) {
			bprintf (""Error: read (symstr)\n"");
			R_FREE (bin->symstr);
			return false;
		}
		if (!(bin->symtab = calloc (bin->nsymtab, sizeof (struct MACH0_(nlist))))) {
			perror (""calloc (symtab)"");
			return false;
		}
		for (i = 0; i < bin->nsymtab; i++) {
			len = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))), 
								nlst, sizeof (struct MACH0_(nlist)));
			if (len != sizeof (struct MACH0_(nlist))) {
				bprintf (""Error: read (nlist)\n"");
				R_FREE (bin->symtab);
				return false;
			}
			bin->symtab[i].n_strx = r_read_ble32 (&nlst[0], bin->big_endian);
			bin->symtab[i].n_type = r_read_ble8 (&nlst[4]);
			bin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);
			bin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);
#if R_BIN_MACH064
			bin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);
#else
			bin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);
#endif
		}
	}
	return true;
}
","static int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {
	struct symtab_command st;
	ut32 size_sym;
	int i;
	ut8 symt[sizeof (struct symtab_command)] = {0};
	ut8 nlst[sizeof (struct MACH0_(nlist))] = {0};

	if (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size) { 
		return false;
	}	
	int len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));
	if (len != sizeof (struct symtab_command)) {
		bprintf (""Error: read (symtab)\n"");
		return false;
	}
	st.cmd = r_read_ble32 (&symt[0], bin->big_endian);
	st.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);
	st.symoff = r_read_ble32 (&symt[8], bin->big_endian);
	st.nsyms = r_read_ble32 (&symt[12], bin->big_endian);
	st.stroff = r_read_ble32 (&symt[16], bin->big_endian);
	st.strsize = r_read_ble32 (&symt[20], bin->big_endian);

	bin->symtab = NULL;
	bin->nsymtab = 0;
	if (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {
		bin->nsymtab = st.nsyms;
		if (st.stroff > bin->size || st.stroff + st.strsize > bin->size) {
			return false;
		}
		if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {
			bprintf(""fail2\n"");
			return false;
		}
		if (!size_sym) {
			bprintf(""fail3\n"");
			return false;
		}
		if (st.symoff > bin->size || st.symoff + size_sym > bin->size) {
			bprintf(""fail4\n"");
			return false;
		}
		if (!(bin->symstr = calloc (1, st.strsize + 2))) {
			perror (""calloc (symstr)"");
			return false;
		}
		bin->symstrlen = st.strsize;
		len = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);
		if (len != st.strsize) {
			bprintf (""Error: read (symstr)\n"");
			R_FREE (bin->symstr);
			return false;
		}
		if (!(bin->symtab = calloc (bin->nsymtab, sizeof (struct MACH0_(nlist))))) {
			perror (""calloc (symtab)"");
			return false;
		}
		for (i = 0; i < bin->nsymtab; i++) {
			len = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))), 
								nlst, sizeof (struct MACH0_(nlist)));
			if (len != sizeof (struct MACH0_(nlist))) {
				bprintf (""Error: read (nlist)\n"");
				R_FREE (bin->symtab);
				return false;
			}
			bin->symtab[i].n_strx = r_read_ble32 (&nlst[0], bin->big_endian);
			bin->symtab[i].n_type = r_read_ble8 (&nlst[4]);
			bin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);
			bin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);
#if R_BIN_MACH064
			bin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);
#else
			bin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);
#endif
		}
	}
	return true;
}
",C,,,,"@@ -1119,7 +1119,7 @@ static int init_items(struct MACH0_(obj_t)* bin) {
 		case LC_LOAD_WEAK_DYLIB:
 			sdb_set (bin->kv, sdb_fmt (0, ""mach0_cmd_%d.cmd"", i), ""load_dylib"", 0);
 			bin->nlibs++;
-			if (!parse_dylib(bin, off)){
+			if (!parse_dylib (bin, off)){
 				bprintf (""Cannot parse dylib\n"");
 				bin->nlibs--;
 				return false;
@@ -1130,30 +1130,31 @@ static int init_items(struct MACH0_(obj_t)* bin) {
 			{
 			ut8 dyldi[sizeof (struct dyld_info_command)] = {0};
 			sdb_set (bin->kv, sdb_fmt (0, ""mach0_cmd_%d.cmd"", i), ""dyld_info"", 0);
-			bin->dyld_info = malloc (sizeof(struct dyld_info_command));
-
-			if (off + sizeof (struct dyld_info_command) > bin->size){
-				bprintf (""Cannot parse dyldinfo\n"");
-				free (bin->dyld_info);
-				return false;
-			}
-			if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {
-				free (bin->dyld_info);
-				bin->dyld_info = NULL;
-				bprintf (""Error: read (LC_DYLD_INFO) at 0x%08""PFMT64x""\n"", off);
-			} else {
-				bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);
-				bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);
-				bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);
-				bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);
-				bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);
-				bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);
-				bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);
-				bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);
-				bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);
-				bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);
-				bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);
-				bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);
+			bin->dyld_info = calloc (1, sizeof (struct dyld_info_command));
+			if (bin->dyld_info) {
+				if (off + sizeof (struct dyld_info_command) > bin->size){
+					bprintf (""Cannot parse dyldinfo\n"");
+					R_FREE (bin->dyld_info);
+					return false;
+				}
+				if (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {
+					free (bin->dyld_info);
+					bin->dyld_info = NULL;
+					bprintf (""Error: read (LC_DYLD_INFO) at 0x%08""PFMT64x""\n"", off);
+				} else {
+					bin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);
+					bin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);
+					bin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);
+					bin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);
+					bin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);
+					bin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);
+					bin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);
+					bin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);
+					bin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);
+					bin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);
+					bin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);
+					bin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);
+				}
 			}
 			}
 			break;
@@ -1747,17 +1748,20 @@ struct reloc_t* MACH0_(get_relocs)(struct MACH0_(obj_t)* bin) {
 		if ((bind_size + lazy_size)<1) {
 			return NULL;
 		}
-		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size)
+		if (bin->dyld_info->bind_off > bin->size || bin->dyld_info->bind_off + bind_size > bin->size) {
 			return NULL;
+		}
 		if (bin->dyld_info->lazy_bind_off > bin->size || \
-			bin->dyld_info->lazy_bind_off + lazy_size > bin->size)
+			bin->dyld_info->lazy_bind_off + lazy_size > bin->size) {
 			return NULL;
-		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size)
+		}
+		if (bin->dyld_info->bind_off+bind_size+lazy_size > bin->size) {
 			return NULL;
+		}
 		// NOTE(eddyb) it's a waste of memory, but we don't know the actual number of relocs.
-		if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t))))
+		if (!(relocs = calloc (1, (1 + bind_size + lazy_size) * sizeof (struct reloc_t)))) {
 			return NULL;
-
+		}
 		opcodes = calloc (1, bind_size + lazy_size + 1);
 		if (!opcodes) {
 			free (relocs);
@@ -1905,12 +1909,14 @@ relocs[i++].last = 0;\
 		free (opcodes);
 	} else {
 		int j;
-		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)
+		if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {
 			return NULL;
-		if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t))))
+		}
+		if (!(relocs = malloc ((bin->dysymtab.nundefsym + 1) * sizeof(struct reloc_t)))) {
 			return NULL;
+		}
 		for (j = 0; j < bin->dysymtab.nundefsym; j++) {
-			if (parse_import_ptr(bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
+			if (parse_import_ptr (bin, &relocs[i], bin->dysymtab.iundefsym + j)) {
 				relocs[i].ord = j;
 				relocs[i++].last = 0;
 			}
@@ -1954,18 +1960,19 @@ struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {
 		}
 		bin->entry = entry->addr;
 	}
-
 	return entry;
 }
 
 struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {
 	struct lib_t *libs;
 	int i;
 
-	if (!bin->nlibs)
+	if (!bin->nlibs) {
 		return NULL;
-	if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))
+	}
+	if (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {
 		return NULL;
+	}
 	for (i = 0; i < bin->nlibs; i++) {
 		strncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);
 		libs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\0';
@@ -1978,12 +1985,14 @@ struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {
 ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {
 	int i;
 
-	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)
+	if (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER) {
 		return 0;
-
-	for (i = 0; i < bin->nsegs; ++i)
-		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)
+	}
+	for (i = 0; i < bin->nsegs; ++i) {
+		if (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0) {
 			return bin->segs[i].vmaddr;
+		}
+	}
 	return 0;
 }
 
@@ -2309,8 +2318,9 @@ ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {
 		ut8 b[128];
 		ut64 entry = addr_to_offset(bin, bin->entry);
 		// XXX: X86 only and hacky!
-		if (entry > bin->size || entry + sizeof (b) > bin->size)
+		if (entry > bin->size || entry + sizeof (b) > bin->size) {
 			return 0;
+		}
 		i = r_buf_read_at (bin->b, entry, b, sizeof (b));
 		if (i < 1) {
 			return 0;",radare2,d1e8ac62c6d978d4662f69116e30230d43033c92,03f0ad4187a69d01451632d8ad0f1eb55cdd712b,0,"static int parse_symtab(struct MACH0_(obj_t)* bin, ut64 off) {
	struct symtab_command st;
	ut32 size_sym;
	int i;
	ut8 symt[sizeof (struct symtab_command)] = {0};
	ut8 nlst[sizeof (struct MACH0_(nlist))] = {0};

	if (off > (ut64)bin->size || off + sizeof (struct symtab_command) > (ut64)bin->size) { 
		return false;
	}	
	int len = r_buf_read_at (bin->b, off, symt, sizeof (struct symtab_command));
	if (len != sizeof (struct symtab_command)) {
		bprintf (""Error: read (symtab)\n"");
		return false;
	}
	st.cmd = r_read_ble32 (&symt[0], bin->big_endian);
	st.cmdsize = r_read_ble32 (&symt[4], bin->big_endian);
	st.symoff = r_read_ble32 (&symt[8], bin->big_endian);
	st.nsyms = r_read_ble32 (&symt[12], bin->big_endian);
	st.stroff = r_read_ble32 (&symt[16], bin->big_endian);
	st.strsize = r_read_ble32 (&symt[20], bin->big_endian);

	bin->symtab = NULL;
	bin->nsymtab = 0;
	if (st.strsize > 0 && st.strsize < bin->size && st.nsyms > 0) {
		bin->nsymtab = st.nsyms;
		if (st.stroff > bin->size || st.stroff + st.strsize > bin->size) {
			return false;
		}
		if (!UT32_MUL (&size_sym, bin->nsymtab, sizeof (struct MACH0_(nlist)))) {
			bprintf(""fail2\n"");
			return false;
		}
		if (!size_sym) {
			bprintf(""fail3\n"");
			return false;
		}
		if (st.symoff > bin->size || st.symoff + size_sym > bin->size) {
			bprintf(""fail4\n"");
			return false;
		}
		if (!(bin->symstr = calloc (1, st.strsize + 2))) {
			perror (""calloc (symstr)"");
			return false;
		}
		bin->symstrlen = st.strsize;
		len = r_buf_read_at (bin->b, st.stroff, (ut8*)bin->symstr, st.strsize);
		if (len != st.strsize) {
			bprintf (""Error: read (symstr)\n"");
			R_FREE (bin->symstr);
			return false;
		}
		if (!(bin->symtab = calloc (bin->nsymtab, sizeof (struct MACH0_(nlist))))) {
			perror (""calloc (symtab)"");
			return false;
		}
		for (i = 0; i < bin->nsymtab; i++) {
			len = r_buf_read_at (bin->b, st.symoff + (i * sizeof (struct MACH0_(nlist))), 
								nlst, sizeof (struct MACH0_(nlist)));
			if (len != sizeof (struct MACH0_(nlist))) {
				bprintf (""Error: read (nlist)\n"");
				R_FREE (bin->symtab);
				return false;
			}
			//XXX not very safe what if is n_un.n_name instead?
			bin->symtab[i].n_strx = r_read_ble32 (&nlst[0], bin->big_endian);
			bin->symtab[i].n_type = r_read_ble8 (&nlst[4]);
			bin->symtab[i].n_sect = r_read_ble8 (&nlst[5]);
			bin->symtab[i].n_desc = r_read_ble16 (&nlst[6], bin->big_endian);
#if R_BIN_MACH064
			bin->symtab[i].n_value = r_read_ble64 (&nlst[8], bin->big_endian);
#else
			bin->symtab[i].n_value = r_read_ble32 (&nlst[8], bin->big_endian);
#endif
		}
	}
	return true;
}
"
61133,,Remote,Single system,,CVE-2017-14604,https://www.cvedetails.com/cve/CVE-2017-14604/,CWE-20,Low,,Partial,,2017-09-20,4.0,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious *sh -c* command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",2018-01-26,Exec Code ,0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,1630f53481f445ada0a455e9979236d31a8d3bb0,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",0,src/nautilus-file-operations.c,"{""sha"": ""b02e3de87b10a1d07f6f8bdd3d9ec9febfe7a024"", ""filename"": ""src/nautilus-directory-async.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-directory-async.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-directory-async.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-directory-async.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -30,6 +30,7 @@\n #include \""nautilus-global-preferences.h\""\n #include \""nautilus-link.h\""\n #include \""nautilus-profile.h\""\n+#include \""nautilus-metadata.h\""\n #include <eel/eel-glib-extensions.h>\n #include <gtk/gtk.h>\n #include <libxml/parser.h>\n@@ -3580,13 +3581,17 @@ is_link_trusted (NautilusFile *file,\n {\n     GFile *location;\n     gboolean res;\n+    g_autofree gchar* trusted = NULL;\n \n     if (!is_launcher)\n     {\n         return TRUE;\n     }\n \n-    if (nautilus_file_can_execute (file))\n+    trusted = nautilus_file_get_metadata (file,\n+                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                          NULL);\n+    if (nautilus_file_can_execute (file) && trusted != NULL)\n     {\n         return TRUE;\n     }""}<_**next**_>{""sha"": ""cd8ea0bdc66e087f860df07126f3cbe71d0c9c38"", ""filename"": ""src/nautilus-file-operations.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 122, ""changes"": 153, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-file-operations.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -235,10 +235,10 @@ typedef struct\n #define COPY_FORCE _(\""Copy _Anyway\"")\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive);\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive);\n \n static gboolean\n is_all_button_text (const char *button_text)\n@@ -5290,10 +5290,10 @@ copy_move_file (CopyMoveJob   *copy_job,\n             g_file_equal (copy_job->desktop_location, dest_dir) &&\n             is_trusted_desktop_file (src, job->cancellable))\n         {\n-            mark_desktop_file_trusted (job,\n-                                       job->cancellable,\n-                                       dest,\n-                                       FALSE);\n+            mark_desktop_file_executable (job,\n+                                          job->cancellable,\n+                                          dest,\n+                                          FALSE);\n         }\n \n         if (job->undo_info != NULL)\n@@ -7887,9 +7887,9 @@ nautilus_file_operations_empty_trash (GtkWidget *parent_view)\n }\n \n static void\n-mark_trusted_task_done (GObject      *source_object,\n-                        GAsyncResult *res,\n-                        gpointer      user_data)\n+mark_desktop_file_executable_task_done (GObject      *source_object,\n+                                        GAsyncResult *res,\n+                                        gpointer      user_data)\n {\n     MarkTrustedJob *job = user_data;\n \n@@ -7907,110 +7907,19 @@ mark_trusted_task_done (GObject      *source_object,\n #define TRUSTED_SHEBANG \""#!/usr/bin/env xdg-open\\n\""\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive)\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive)\n {\n-    char *contents, *new_contents;\n-    gsize length, new_length;\n     GError *error;\n     guint32 current_perms, new_perms;\n     int response;\n     GFileInfo *info;\n \n retry:\n-    error = NULL;\n-    if (!g_file_load_contents (file,\n-                               cancellable,\n-                               &contents, &length,\n-                               NULL, &error))\n-    {\n-        if (interactive)\n-        {\n-            response = run_error (common,\n-                                  g_strdup (_(\""Unable to mark launcher trusted (executable)\"")),\n-                                  error->message,\n-                                  NULL,\n-                                  FALSE,\n-                                  CANCEL, RETRY,\n-                                  NULL);\n-        }\n-        else\n-        {\n-            response = 0;\n-        }\n-\n-\n-        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-        {\n-            abort_job (common);\n-        }\n-        else if (response == 1)\n-        {\n-            goto retry;\n-        }\n-        else\n-        {\n-            g_assert_not_reached ();\n-        }\n-\n-        goto out;\n-    }\n-\n-    if (!g_str_has_prefix (contents, \""#!\""))\n-    {\n-        new_length = length + strlen (TRUSTED_SHEBANG);\n-        new_contents = g_malloc (new_length);\n-\n-        strcpy (new_contents, TRUSTED_SHEBANG);\n-        memcpy (new_contents + strlen (TRUSTED_SHEBANG),\n-                contents, length);\n-\n-        if (!g_file_replace_contents (file,\n-                                      new_contents,\n-                                      new_length,\n-                                      NULL,\n-                                      FALSE, 0,\n-                                      NULL, cancellable, &error))\n-        {\n-            g_free (contents);\n-            g_free (new_contents);\n-\n-            if (interactive)\n-            {\n-                response = run_error (common,\n-                                      g_strdup (_(\""Unable to mark launcher trusted (executable)\"")),\n-                                      error->message,\n-                                      NULL,\n-                                      FALSE,\n-                                      CANCEL, RETRY,\n-                                      NULL);\n-            }\n-            else\n-            {\n-                response = 0;\n-            }\n-\n-            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-            {\n-                abort_job (common);\n-            }\n-            else if (response == 1)\n-            {\n-                goto retry;\n-            }\n-            else\n-            {\n-                g_assert_not_reached ();\n-            }\n-\n-            goto out;\n-        }\n-        g_free (new_contents);\n-    }\n-    g_free (contents);\n \n+    error = NULL;\n     info = g_file_query_info (file,\n                               G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\""\n                               G_FILE_ATTRIBUTE_UNIX_MODE,\n@@ -8101,10 +8010,10 @@ mark_desktop_file_trusted (CommonJob    *common,\n }\n \n static void\n-mark_trusted_task_thread_func (GTask        *task,\n-                               gpointer      source_object,\n-                               gpointer      task_data,\n-                               GCancellable *cancellable)\n+mark_desktop_file_executable_task_thread_func (GTask        *task,\n+                                               gpointer      source_object,\n+                                               gpointer      task_data,\n+                                               GCancellable *cancellable)\n {\n     MarkTrustedJob *job = task_data;\n     CommonJob *common;\n@@ -8113,18 +8022,18 @@ mark_trusted_task_thread_func (GTask        *task,\n \n     nautilus_progress_info_start (job->common.progress);\n \n-    mark_desktop_file_trusted (common,\n-                               cancellable,\n-                               job->file,\n-                               job->interactive);\n+    mark_desktop_file_executable (common,\n+                                  cancellable,\n+                                  job->file,\n+                                  job->interactive);\n }\n \n void\n-nautilus_file_mark_desktop_file_trusted (GFile              *file,\n-                                         GtkWindow          *parent_window,\n-                                         gboolean            interactive,\n-                                         NautilusOpCallback  done_callback,\n-                                         gpointer            done_callback_data)\n+nautilus_file_mark_desktop_file_executable (GFile              *file,\n+                                            GtkWindow          *parent_window,\n+                                            gboolean            interactive,\n+                                            NautilusOpCallback  done_callback,\n+                                            gpointer            done_callback_data)\n {\n     GTask *task;\n     MarkTrustedJob *job;\n@@ -8135,9 +8044,9 @@ nautilus_file_mark_desktop_file_trusted (GFile              *file,\n     job->done_callback = done_callback;\n     job->done_callback_data = done_callback_data;\n \n-    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n+    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n     g_task_set_task_data (task, job, NULL);\n-    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n+    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n     g_object_unref (task);\n }\n ""}<_**next**_>{""sha"": ""a479ee6e0232dad341a282a1771bcdc4a04173dc"", ""filename"": ""src/nautilus-file-operations.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.h"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.h"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-file-operations.h?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -146,11 +146,11 @@ void nautilus_file_operations_link      (GList                *files,\n \t\t\t\t\t GtkWindow            *parent_window,\n \t\t\t\t\t NautilusCopyCallback  done_callback,\n \t\t\t\t\t gpointer              done_callback_data);\n-void nautilus_file_mark_desktop_file_trusted (GFile           *file,\n-\t\t\t\t\t      GtkWindow        *parent_window,\n-\t\t\t\t\t      gboolean          interactive,\n-\t\t\t\t\t      NautilusOpCallback done_callback,\n-\t\t\t\t\t      gpointer          done_callback_data);\n+void nautilus_file_mark_desktop_file_executable (GFile           *file,\n+                                                 GtkWindow        *parent_window,\n+                                                 gboolean          interactive,\n+                                                 NautilusOpCallback done_callback,\n+                                                 gpointer          done_callback_data);\n void nautilus_file_operations_extract_files (GList                   *files,\n                                              GFile                   *destination_directory,\n                                              GtkWindow               *parent_window,""}<_**next**_>{""sha"": ""bee04e7ca5e3ac45884d9c265f2717d49a3d2f40"", ""filename"": ""src/nautilus-metadata.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-metadata.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -51,6 +51,7 @@ static char *used_metadata_names[] =\n     NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME,\n     NAUTILUS_METADATA_KEY_SCREEN,\n     NAUTILUS_METADATA_KEY_EMBLEMS,\n+    NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n     NULL\n };\n ""}<_**next**_>{""sha"": ""c4a303ec555ecfb1252bb44f7cd8261cfb2faea5"", ""filename"": ""src/nautilus-metadata.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.h"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.h"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-metadata.h?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -67,6 +67,8 @@\n #define NAUTILUS_METADATA_KEY_SCREEN\t\t\t\t\""screen\""\n #define NAUTILUS_METADATA_KEY_EMBLEMS\t\t\t\t\""emblems\""\n \n+#define NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED\t\t\t\t\""trusted\""\n+\n guint nautilus_metadata_get_id (const char *metadata);\n \n #endif /* NAUTILUS_METADATA_H */""}<_**next**_>{""sha"": ""14fe44bc39a40cfd3faf7119206145ed9968162f"", ""filename"": ""src/nautilus-mime-actions.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 18, ""changes"": 46, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-mime-actions.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-mime-actions.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-mime-actions.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -42,6 +42,7 @@\n #include \""nautilus-program-choosing.h\""\n #include \""nautilus-global-preferences.h\""\n #include \""nautilus-signaller.h\""\n+#include \""nautilus-metadata.h\""\n \n #define DEBUG_FLAG NAUTILUS_DEBUG_MIME\n #include \""nautilus-debug.h\""\n@@ -221,7 +222,6 @@ struct\n #define RESPONSE_RUN 1000\n #define RESPONSE_DISPLAY 1001\n #define RESPONSE_RUN_IN_TERMINAL 1002\n-#define RESPONSE_MARK_TRUSTED 1003\n \n #define SILENT_WINDOW_OPEN_LIMIT 5\n #define SILENT_OPEN_LIMIT 5\n@@ -1517,24 +1517,35 @@ untrusted_launcher_response_callback (GtkDialog                 *dialog,\n \n     switch (response_id)\n     {\n-        case RESPONSE_RUN:\n+        case GTK_RESPONSE_OK:\n         {\n+            file = nautilus_file_get_location (parameters->file);\n+\n+            /* We need to do this in order to prevent malicious desktop files\n+             * with the executable bit already set.\n+             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991\n+             */\n+            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                        NULL,\n+                                        \""yes\"");\n+\n+            nautilus_file_mark_desktop_file_executable (file,\n+                                                        parameters->parent_window,\n+                                                        TRUE,\n+                                                        NULL, NULL);\n+\n+            /* Need to force a reload of the attributes so is_trusted is marked\n+             * correctly. Not sure why the general monitor doesn't fire in this\n+             * case when setting the metadata\n+             */\n+            nautilus_file_invalidate_all_attributes (parameters->file);\n+\n             screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n             uri = nautilus_file_get_uri (parameters->file);\n             DEBUG (\""Launching untrusted launcher %s\"", uri);\n             nautilus_launch_desktop_file (screen, uri, NULL,\n                                           parameters->parent_window);\n             g_free (uri);\n-        }\n-        break;\n-\n-        case RESPONSE_MARK_TRUSTED:\n-        {\n-            file = nautilus_file_get_location (parameters->file);\n-            nautilus_file_mark_desktop_file_trusted (file,\n-                                                     parameters->parent_window,\n-                                                     TRUE,\n-                                                     NULL, NULL);\n             g_object_unref (file);\n         }\n         break;\n@@ -1590,17 +1601,16 @@ activate_desktop_file (ActivateParameters *parameters,\n                       \""text\"", primary,\n                       \""secondary-text\"", secondary,\n                       NULL);\n+\n         gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\""_Launch Anyway\""), RESPONSE_RUN);\n+                               _(\""_Cancel\""), GTK_RESPONSE_CANCEL);\n+\n+        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n         if (nautilus_file_can_set_permissions (file))\n         {\n             gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                                   _(\""Mark as _Trusted\""), RESPONSE_MARK_TRUSTED);\n+                                   _(\""Trust and _Launch\""), GTK_RESPONSE_OK);\n         }\n-        gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\""_Cancel\""), GTK_RESPONSE_CANCEL);\n-        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n-\n         g_signal_connect (dialog, \""response\"",\n                           G_CALLBACK (untrusted_launcher_response_callback),\n                           parameters_desktop);""}","run_simple_dialog_va (CommonJob      *job,
                      gboolean        ignore_close_box,
                      GtkMessageType  message_type,
                      char           *primary_text,
                      char           *secondary_text,
                      const char     *details_text,
                      gboolean        show_all,
                      va_list         varargs)
{
    RunSimpleDialogData *data;
    int res;
    const char *button_title;
    GPtrArray *ptr_array;

    g_timer_stop (job->time);

    data = g_new0 (RunSimpleDialogData, 1);
    data->parent_window = &job->parent_window;
    data->ignore_close_box = ignore_close_box;
    data->message_type = message_type;
    data->primary_text = primary_text;
    data->secondary_text = secondary_text;
    data->details_text = details_text;
    data->show_all = show_all;
    data->completed = FALSE;
    g_mutex_init (&data->mutex);
    g_cond_init (&data->cond);

    ptr_array = g_ptr_array_new ();
    while ((button_title = va_arg (varargs, const char *)) != NULL)
    {
        g_ptr_array_add (ptr_array, (char *) button_title);
    }
    g_ptr_array_add (ptr_array, NULL);
    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);

    nautilus_progress_info_pause (job->progress);

    g_mutex_lock (&data->mutex);

    g_main_context_invoke (NULL,
                           do_run_simple_dialog,
                           data);

    while (!data->completed)
    {
        g_cond_wait (&data->cond, &data->mutex);
    }

    nautilus_progress_info_resume (job->progress);
    res = data->result;

    g_mutex_unlock (&data->mutex);
    g_mutex_clear (&data->mutex);
    g_cond_clear (&data->cond);

    g_free (data->button_titles);
    g_free (data);

    g_timer_continue (job->time);

    g_free (primary_text);
    g_free (secondary_text);

    return res;
}
","run_simple_dialog_va (CommonJob      *job,
                      gboolean        ignore_close_box,
                      GtkMessageType  message_type,
                      char           *primary_text,
                      char           *secondary_text,
                      const char     *details_text,
                      gboolean        show_all,
                      va_list         varargs)
{
    RunSimpleDialogData *data;
    int res;
    const char *button_title;
    GPtrArray *ptr_array;

    g_timer_stop (job->time);

    data = g_new0 (RunSimpleDialogData, 1);
    data->parent_window = &job->parent_window;
    data->ignore_close_box = ignore_close_box;
    data->message_type = message_type;
    data->primary_text = primary_text;
    data->secondary_text = secondary_text;
    data->details_text = details_text;
    data->show_all = show_all;
    data->completed = FALSE;
    g_mutex_init (&data->mutex);
    g_cond_init (&data->cond);

    ptr_array = g_ptr_array_new ();
    while ((button_title = va_arg (varargs, const char *)) != NULL)
    {
        g_ptr_array_add (ptr_array, (char *) button_title);
    }
    g_ptr_array_add (ptr_array, NULL);
    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);

    nautilus_progress_info_pause (job->progress);

    g_mutex_lock (&data->mutex);

    g_main_context_invoke (NULL,
                           do_run_simple_dialog,
                           data);

    while (!data->completed)
    {
        g_cond_wait (&data->cond, &data->mutex);
    }

    nautilus_progress_info_resume (job->progress);
    res = data->result;

    g_mutex_unlock (&data->mutex);
    g_mutex_clear (&data->mutex);
    g_cond_clear (&data->cond);

    g_free (data->button_titles);
    g_free (data);

    g_timer_continue (job->time);

    g_free (primary_text);
    g_free (secondary_text);

    return res;
}
",C,,,,"@@ -235,10 +235,10 @@ typedef struct
 #define COPY_FORCE _(""Copy _Anyway"")
 
 static void
-mark_desktop_file_trusted (CommonJob    *common,
-                           GCancellable *cancellable,
-                           GFile        *file,
-                           gboolean      interactive);
+mark_desktop_file_executable (CommonJob    *common,
+                              GCancellable *cancellable,
+                              GFile        *file,
+                              gboolean      interactive);
 
 static gboolean
 is_all_button_text (const char *button_text)
@@ -5290,10 +5290,10 @@ copy_move_file (CopyMoveJob   *copy_job,
             g_file_equal (copy_job->desktop_location, dest_dir) &&
             is_trusted_desktop_file (src, job->cancellable))
         {
-            mark_desktop_file_trusted (job,
-                                       job->cancellable,
-                                       dest,
-                                       FALSE);
+            mark_desktop_file_executable (job,
+                                          job->cancellable,
+                                          dest,
+                                          FALSE);
         }
 
         if (job->undo_info != NULL)
@@ -7887,9 +7887,9 @@ nautilus_file_operations_empty_trash (GtkWidget *parent_view)
 }
 
 static void
-mark_trusted_task_done (GObject      *source_object,
-                        GAsyncResult *res,
-                        gpointer      user_data)
+mark_desktop_file_executable_task_done (GObject      *source_object,
+                                        GAsyncResult *res,
+                                        gpointer      user_data)
 {
     MarkTrustedJob *job = user_data;
 
@@ -7907,110 +7907,19 @@ mark_trusted_task_done (GObject      *source_object,
 #define TRUSTED_SHEBANG ""#!/usr/bin/env xdg-open\n""
 
 static void
-mark_desktop_file_trusted (CommonJob    *common,
-                           GCancellable *cancellable,
-                           GFile        *file,
-                           gboolean      interactive)
+mark_desktop_file_executable (CommonJob    *common,
+                              GCancellable *cancellable,
+                              GFile        *file,
+                              gboolean      interactive)
 {
-    char *contents, *new_contents;
-    gsize length, new_length;
     GError *error;
     guint32 current_perms, new_perms;
     int response;
     GFileInfo *info;
 
 retry:
-    error = NULL;
-    if (!g_file_load_contents (file,
-                               cancellable,
-                               &contents, &length,
-                               NULL, &error))
-    {
-        if (interactive)
-        {
-            response = run_error (common,
-                                  g_strdup (_(""Unable to mark launcher trusted (executable)"")),
-                                  error->message,
-                                  NULL,
-                                  FALSE,
-                                  CANCEL, RETRY,
-                                  NULL);
-        }
-        else
-        {
-            response = 0;
-        }
-
-
-        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
-        {
-            abort_job (common);
-        }
-        else if (response == 1)
-        {
-            goto retry;
-        }
-        else
-        {
-            g_assert_not_reached ();
-        }
-
-        goto out;
-    }
-
-    if (!g_str_has_prefix (contents, ""#!""))
-    {
-        new_length = length + strlen (TRUSTED_SHEBANG);
-        new_contents = g_malloc (new_length);
-
-        strcpy (new_contents, TRUSTED_SHEBANG);
-        memcpy (new_contents + strlen (TRUSTED_SHEBANG),
-                contents, length);
-
-        if (!g_file_replace_contents (file,
-                                      new_contents,
-                                      new_length,
-                                      NULL,
-                                      FALSE, 0,
-                                      NULL, cancellable, &error))
-        {
-            g_free (contents);
-            g_free (new_contents);
-
-            if (interactive)
-            {
-                response = run_error (common,
-                                      g_strdup (_(""Unable to mark launcher trusted (executable)"")),
-                                      error->message,
-                                      NULL,
-                                      FALSE,
-                                      CANCEL, RETRY,
-                                      NULL);
-            }
-            else
-            {
-                response = 0;
-            }
-
-            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)
-            {
-                abort_job (common);
-            }
-            else if (response == 1)
-            {
-                goto retry;
-            }
-            else
-            {
-                g_assert_not_reached ();
-            }
-
-            goto out;
-        }
-        g_free (new_contents);
-    }
-    g_free (contents);
 
+    error = NULL;
     info = g_file_query_info (file,
                               G_FILE_ATTRIBUTE_STANDARD_TYPE "",""
                               G_FILE_ATTRIBUTE_UNIX_MODE,
@@ -8101,10 +8010,10 @@ mark_desktop_file_trusted (CommonJob    *common,
 }
 
 static void
-mark_trusted_task_thread_func (GTask        *task,
-                               gpointer      source_object,
-                               gpointer      task_data,
-                               GCancellable *cancellable)
+mark_desktop_file_executable_task_thread_func (GTask        *task,
+                                               gpointer      source_object,
+                                               gpointer      task_data,
+                                               GCancellable *cancellable)
 {
     MarkTrustedJob *job = task_data;
     CommonJob *common;
@@ -8113,18 +8022,18 @@ mark_trusted_task_thread_func (GTask        *task,
 
     nautilus_progress_info_start (job->common.progress);
 
-    mark_desktop_file_trusted (common,
-                               cancellable,
-                               job->file,
-                               job->interactive);
+    mark_desktop_file_executable (common,
+                                  cancellable,
+                                  job->file,
+                                  job->interactive);
 }
 
 void
-nautilus_file_mark_desktop_file_trusted (GFile              *file,
-                                         GtkWindow          *parent_window,
-                                         gboolean            interactive,
-                                         NautilusOpCallback  done_callback,
-                                         gpointer            done_callback_data)
+nautilus_file_mark_desktop_file_executable (GFile              *file,
+                                            GtkWindow          *parent_window,
+                                            gboolean            interactive,
+                                            NautilusOpCallback  done_callback,
+                                            gpointer            done_callback_data)
 {
     GTask *task;
     MarkTrustedJob *job;
@@ -8135,9 +8044,9 @@ nautilus_file_mark_desktop_file_trusted (GFile              *file,
     job->done_callback = done_callback;
     job->done_callback_data = done_callback_data;
 
-    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);
+    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);
     g_task_set_task_data (task, job, NULL);
-    g_task_run_in_thread (task, mark_trusted_task_thread_func);
+    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);
     g_object_unref (task);
 }
 ",nautilus,1630f53481f445ada0a455e9979236d31a8d3bb0,cc6910ff6511a5a2939cf36a49ca81fb62005382,0,"run_simple_dialog_va (CommonJob      *job,
                      gboolean        ignore_close_box,
                      GtkMessageType  message_type,
                      char           *primary_text,
                      char           *secondary_text,
                      const char     *details_text,
                      gboolean        show_all,
                      va_list         varargs)
{
    RunSimpleDialogData *data;
    int res;
    const char *button_title;
    GPtrArray *ptr_array;

    g_timer_stop (job->time);

    data = g_new0 (RunSimpleDialogData, 1);
    data->parent_window = &job->parent_window;
    data->ignore_close_box = ignore_close_box;
    data->message_type = message_type;
    data->primary_text = primary_text;
    data->secondary_text = secondary_text;
    data->details_text = details_text;
    data->show_all = show_all;
    data->completed = FALSE;
    g_mutex_init (&data->mutex);
    g_cond_init (&data->cond);

    ptr_array = g_ptr_array_new ();
    while ((button_title = va_arg (varargs, const char *)) != NULL)
    {
        g_ptr_array_add (ptr_array, (char *) button_title);
    }
    g_ptr_array_add (ptr_array, NULL);
    data->button_titles = (const char **) g_ptr_array_free (ptr_array, FALSE);

    nautilus_progress_info_pause (job->progress);

    g_mutex_lock (&data->mutex);

    g_main_context_invoke (NULL,
                           do_run_simple_dialog,
                           data);

    while (!data->completed)
    {
        g_cond_wait (&data->cond, &data->mutex);
    }

    nautilus_progress_info_resume (job->progress);
    res = data->result;

    g_mutex_unlock (&data->mutex);
    g_mutex_clear (&data->mutex);
    g_cond_clear (&data->cond);

    g_free (data->button_titles);
    g_free (data);

    g_timer_continue (job->time);

    g_free (primary_text);
    g_free (secondary_text);

    return res;
}
"
25602,,Local,Not required,Complete,CVE-2011-2918,https://www.cvedetails.com/cve/CVE-2011-2918/,CWE-399,Low,,,,2012-05-24,4.9,"The Performance Events subsystem in the Linux kernel before 3.1 does not properly handle event overflows associated with PERF_COUNT_SW_CPU_CLOCK events, which allows local users to cause a denial of service (system hang) via a crafted application.",2012-05-29,DoS Overflow ,0,https://github.com/torvalds/linux/commit/a8b0ca17b80e92faab46ee7179ba9e99ccb61233,a8b0ca17b80e92faab46ee7179ba9e99ccb61233,"perf: Remove the nmi parameter from the swevent and overflow interface

The nmi parameter indicated if we could do wakeups from the current
context, if not, we would set some state and self-IPI and let the
resulting interrupt do the wakeup.

For the various event classes:

  - hardware: nmi=0; PMI is in fact an NMI or we run irq_work_run from
    the PMI-tail (ARM etc.)
  - tracepoint: nmi=0; since tracepoint could be from NMI context.
  - software: nmi=[0,1]; some, like the schedule thing cannot
    perform wakeups, and hence need 0.

As one can see, there is very little nmi=1 usage, and the down-side of
not using it is that on some platforms some software events can have a
jiffy delay in wakeup (when arch_irq_work_raise isn't implemented).

The up-side however is that we can remove the nmi parameter and save a
bunch of conditionals in fast paths.

Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Cc: Michael Cree <mcree@orcon.net.nz>
Cc: Will Deacon <will.deacon@arm.com>
Cc: Deng-Cheng Zhu <dengcheng.zhu@gmail.com>
Cc: Anton Blanchard <anton@samba.org>
Cc: Eric B Munson <emunson@mgebm.net>
Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
Cc: Paul Mundt <lethal@linux-sh.org>
Cc: David S. Miller <davem@davemloft.net>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Jason Wessel <jason.wessel@windriver.com>
Cc: Don Zickus <dzickus@redhat.com>
Link: http://lkml.kernel.org/n/tip-agjev8eu666tvknpb3iaj0fg@git.kernel.org
Signed-off-by: Ingo Molnar <mingo@elte.hu>",0,arch/sh/math-emu/math.c,"{""sha"": ""8e47709160f84962bd6b2744ea6a1a5b9ae49b28"", ""filename"": ""arch/alpha/kernel/perf_event.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/alpha/kernel/perf_event.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/alpha/kernel/perf_event.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/alpha/kernel/perf_event.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -847,7 +847,7 @@ static void alpha_perf_event_irq_handler(unsigned long la_ptr,\n \tdata.period = event->hw.last_period;\n \n \tif (alpha_perf_event_set_period(event, hwc, idx)) {\n-\t\tif (perf_event_overflow(event, 1, &data, regs)) {\n+\t\tif (perf_event_overflow(event, &data, regs)) {\n \t\t\t/* Interrupts coming too quickly; \""throttle\"" the\n \t\t\t * counter, i.e., disable it for a little while.\n \t\t\t */""}<_**next**_>{""sha"": ""38dc4da1d612d5ee2b83f71fbbcba2615c4bc18c"", ""filename"": ""arch/arm/kernel/perf_event_v6.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_v6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_v6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/perf_event_v6.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -479,7 +479,7 @@ armv6pmu_handle_irq(int irq_num,\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n ""}<_**next**_>{""sha"": ""6e5f8752303bedb4684c19cbe73933ea0871a292"", ""filename"": ""arch/arm/kernel/perf_event_v7.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_v7.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_v7.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/perf_event_v7.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -787,7 +787,7 @@ static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n ""}<_**next**_>{""sha"": ""99b6b85c7e491ebe97f7cb73a1e130c256171bfc"", ""filename"": ""arch/arm/kernel/perf_event_xscale.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_xscale.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/perf_event_xscale.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/perf_event_xscale.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -251,7 +251,7 @@ xscale1pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n \n@@ -583,7 +583,7 @@ xscale2pmu_handle_irq(int irq_num, void *dev)\n \t\tif (!armpmu_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tarmpmu->disable(hwc, idx);\n \t}\n ""}<_**next**_>{""sha"": ""0c9b1054f79003eee74d06d3e273ad68558dce97"", ""filename"": ""arch/arm/kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/ptrace.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -396,7 +396,7 @@ static long ptrace_hbp_idx_to_num(int idx)\n /*\n  * Handle hitting a HW-breakpoint.\n  */\n-static void ptrace_hbptriggered(struct perf_event *bp, int unused,\n+static void ptrace_hbptriggered(struct perf_event *bp,\n \t\t\t\t     struct perf_sample_data *data,\n \t\t\t\t     struct pt_regs *regs)\n {""}<_**next**_>{""sha"": ""5f452f8fde0569d140e0d6055220f29be08396f1"", ""filename"": ""arch/arm/kernel/swp_emulate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/swp_emulate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/kernel/swp_emulate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/kernel/swp_emulate.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -183,7 +183,7 @@ static int swp_handler(struct pt_regs *regs, unsigned int instr)\n \tunsigned int address, destreg, data, type;\n \tunsigned int res = 0;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, regs->ARM_pc);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->ARM_pc);\n \n \tif (current->pid != previous_pid) {\n \t\tpr_debug(\""\\\""%s\\\"" (%ld) uses deprecated SWP{B} instruction\\n\"",""}<_**next**_>{""sha"": ""9ea4f7ddd665cdba971c0b6d433dac89fb3aba9a"", ""filename"": ""arch/arm/mm/fault.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/mm/fault.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/arm/mm/fault.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/mm/fault.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -318,11 +318,11 @@ do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\n \tfault = __do_page_fault(mm, addr, fsr, tsk);\n \tup_read(&mm->mmap_sem);\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, addr);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, addr);\n \tif (fault & VM_FAULT_MAJOR)\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, addr);\n \telse if (fault & VM_FAULT_MINOR)\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, addr);\n \n \t/*\n \t * Handle the \""normal\"" case first - VM_FAULT_MAJOR / VM_FAULT_MINOR""}<_**next**_>{""sha"": ""d0deaab9ace2e670db80844235de55ce157349d7"", ""filename"": ""arch/mips/kernel/perf_event.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/perf_event.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/perf_event.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/mips/kernel/perf_event.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -527,7 +527,7 @@ handle_associated_event(struct cpu_hw_events *cpuc,\n \tif (!mipspmu_event_set_period(event, hwc, idx))\n \t\treturn;\n \n-\tif (perf_event_overflow(event, 0, data, regs))\n+\tif (perf_event_overflow(event, data, regs))\n \t\tmipspmu->disable_event(idx);\n }\n ""}<_**next**_>{""sha"": ""b7517e3abc8527721fdffca5ded64a035d33fddb"", ""filename"": ""arch/mips/kernel/traps.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/traps.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/traps.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/mips/kernel/traps.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -578,12 +578,12 @@ static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n {\n \tif ((opcode & OPCODE) == LL) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn simulate_ll(regs, opcode);\n \t}\n \tif ((opcode & OPCODE) == SC) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn simulate_sc(regs, opcode);\n \t}\n \n@@ -602,7 +602,7 @@ static int simulate_rdhwr(struct pt_regs *regs, unsigned int opcode)\n \t\tint rd = (opcode & RD) >> 11;\n \t\tint rt = (opcode & RT) >> 16;\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\tswitch (rd) {\n \t\tcase 0:\t\t/* CPU number */\n \t\t\tregs->regs[rt] = smp_processor_id();\n@@ -640,7 +640,7 @@ static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n {\n \tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t\t1, 0, regs, 0);\n+\t\t\t\t1, regs, 0);\n \t\treturn 0;\n \t}\n ""}<_**next**_>{""sha"": ""eb319b58035377f5305286a587926f1f356ced41"", ""filename"": ""arch/mips/kernel/unaligned.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/unaligned.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/kernel/unaligned.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/mips/kernel/unaligned.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -111,8 +111,7 @@ static void emulate_load_store_insn(struct pt_regs *regs,\n \tunsigned long value;\n \tunsigned int res;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t      1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \t/*\n \t * This load never faults.\n@@ -517,7 +516,7 @@ asmlinkage void do_ade(struct pt_regs *regs)\n \tmm_segment_t seg;\n \n \tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n-\t\t\t1, 0, regs, regs->cp0_badvaddr);\n+\t\t\t1, regs, regs->cp0_badvaddr);\n \t/*\n \t * Did we catch a fault trying to load an instruction?\n \t * Or are we running in MIPS16 mode?""}<_**next**_>{""sha"": ""dbf2f93a50911b5914a295a82b3179c36562013f"", ""filename"": ""arch/mips/math-emu/cp1emu.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/math-emu/cp1emu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/math-emu/cp1emu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/mips/math-emu/cp1emu.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -272,8 +272,7 @@ static int cop1Emulate(struct pt_regs *xcp, struct mips_fpu_struct *ctx,\n \t}\n \n       emul:\n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n-\t\t\t1, 0, xcp, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, xcp, 0);\n \tMIPS_FPU_EMU_INC_STATS(emulated);\n \tswitch (MIPSInst_OPCODE(ir)) {\n \tcase ldc1_op:{""}<_**next**_>{""sha"": ""937cf3368164c6f6d4a6db4b1867ca5866a36ed7"", ""filename"": ""arch/mips/mm/fault.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 5, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/mm/fault.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/mips/mm/fault.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/mips/mm/fault.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -145,7 +145,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long writ\n \t * the fault.\n \t */\n \tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \tif (unlikely(fault & VM_FAULT_ERROR)) {\n \t\tif (fault & VM_FAULT_OOM)\n \t\t\tgoto out_of_memory;\n@@ -154,12 +154,10 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs, unsigned long writ\n \t\tBUG();\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\n-\t\t\t\t1, 0, regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t\ttsk->maj_flt++;\n \t} else {\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\n-\t\t\t\t1, 0, regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t\ttsk->min_flt++;\n \t}\n ""}<_**next**_>{""sha"": ""2cc41c715d2ba2cfb9783d91bda466c3edac0099"", ""filename"": ""arch/powerpc/include/asm/emulated_ops.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/include/asm/emulated_ops.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/include/asm/emulated_ops.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/include/asm/emulated_ops.h?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -78,14 +78,14 @@ extern void ppc_warn_emulated_print(const char *type);\n #define PPC_WARN_EMULATED(type, regs)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n \t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\t\t\\\n-\t\t\t1, 0, regs, 0);\t\t\t\t\t\\\n+\t\t\t1, regs, 0);\t\t\t\t\t\\\n \t\t__PPC_WARN_EMULATED(type);\t\t\t\t\\\n \t} while (0)\n \n #define PPC_WARN_ALIGNMENT(type, regs)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n \t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\t\t\\\n-\t\t\t1, 0, regs, regs->dar);\t\t\t\t\\\n+\t\t\t1, regs, regs->dar);\t\t\t\t\\\n \t\t__PPC_WARN_EMULATED(type);\t\t\t\t\\\n \t} while (0)\n ""}<_**next**_>{""sha"": ""14967de9887603c91d10650939a015eb0aa7a2ec"", ""filename"": ""arch/powerpc/kernel/perf_event.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/perf_event.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/perf_event.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/perf_event.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -1207,7 +1207,7 @@ struct pmu power_pmu = {\n  * here so there is no possibility of being interrupted.\n  */\n static void record_and_restart(struct perf_event *event, unsigned long val,\n-\t\t\t       struct pt_regs *regs, int nmi)\n+\t\t\t       struct pt_regs *regs)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n@@ -1258,7 +1258,7 @@ static void record_and_restart(struct perf_event *event, unsigned long val,\n \t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n \t\t\tperf_get_data_addr(regs, &data.addr);\n \n-\t\tif (perf_event_overflow(event, nmi, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tpower_pmu_stop(event, 0);\n \t}\n }\n@@ -1346,7 +1346,7 @@ static void perf_event_interrupt(struct pt_regs *regs)\n \t\tif ((int)val < 0) {\n \t\t\t/* event has overflowed */\n \t\t\tfound = 1;\n-\t\t\trecord_and_restart(event, val, regs, nmi);\n+\t\t\trecord_and_restart(event, val, regs);\n \t\t}\n \t}\n ""}<_**next**_>{""sha"": ""0a6d2a9d569cde1e924735dd24147eb90bd84c04"", ""filename"": ""arch/powerpc/kernel/perf_event_fsl_emb.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/perf_event_fsl_emb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/perf_event_fsl_emb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/perf_event_fsl_emb.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -568,7 +568,7 @@ static struct pmu fsl_emb_pmu = {\n  * here so there is no possibility of being interrupted.\n  */\n static void record_and_restart(struct perf_event *event, unsigned long val,\n-\t\t\t       struct pt_regs *regs, int nmi)\n+\t\t\t       struct pt_regs *regs)\n {\n \tu64 period = event->hw.sample_period;\n \ts64 prev, delta, left;\n@@ -616,7 +616,7 @@ static void record_and_restart(struct perf_event *event, unsigned long val,\n \t\tperf_sample_data_init(&data, 0);\n \t\tdata.period = event->hw.last_period;\n \n-\t\tif (perf_event_overflow(event, nmi, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tfsl_emb_pmu_stop(event, 0);\n \t}\n }\n@@ -644,7 +644,7 @@ static void perf_event_interrupt(struct pt_regs *regs)\n \t\t\tif (event) {\n \t\t\t\t/* event has overflowed */\n \t\t\t\tfound = 1;\n-\t\t\t\trecord_and_restart(event, val, regs, nmi);\n+\t\t\t\trecord_and_restart(event, val, regs);\n \t\t\t} else {\n \t\t\t\t/*\n \t\t\t\t * Disabled counter is negative,""}<_**next**_>{""sha"": ""3177617af2ef4f2d954cb405eac4470f4061353a"", ""filename"": ""arch/powerpc/kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/kernel/ptrace.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -882,7 +882,7 @@ void user_disable_single_step(struct task_struct *task)\n }\n \n #ifdef CONFIG_HAVE_HW_BREAKPOINT\n-void ptrace_triggered(struct perf_event *bp, int nmi,\n+void ptrace_triggered(struct perf_event *bp,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;""}<_**next**_>{""sha"": ""dbc48254c6cc9e71a7b1b099def4973654a256c0"", ""filename"": ""arch/powerpc/mm/fault.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/mm/fault.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/powerpc/mm/fault.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/mm/fault.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -173,7 +173,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n \t\tdie(\""Weird page fault\"", regs, SIGSEGV);\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t/* When running in the kernel we expect faults to occur only to\n \t * addresses in user space.  All other faults represent errors in the\n@@ -319,7 +319,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n \t}\n \tif (ret & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n #ifdef CONFIG_PPC_SMLPAR\n \t\tif (firmware_has_feature(FW_FEATURE_CMO)) {\n@@ -330,7 +330,7 @@ int __kprobes do_page_fault(struct pt_regs *regs, unsigned long address,\n #endif\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n \tup_read(&mm->mmap_sem);""}<_**next**_>{""sha"": ""095f782a5512d1c7c8c783e459729286786ef834"", ""filename"": ""arch/s390/mm/fault.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/s390/mm/fault.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/s390/mm/fault.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/mm/fault.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -299,7 +299,7 @@ static inline int do_exception(struct pt_regs *regs, int access,\n \t\tgoto out;\n \n \taddress = trans_exc_code & __FAIL_ADDR_MASK;\n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \tflags = FAULT_FLAG_ALLOW_RETRY;\n \tif (access == VM_WRITE || (trans_exc_code & store_indication) == 0x400)\n \t\tflags |= FAULT_FLAG_WRITE;\n@@ -345,11 +345,11 @@ static inline int do_exception(struct pt_regs *regs, int access,\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {""}<_**next**_>{""sha"": ""8051976100a615b036f929154f7d50373d03db8c"", ""filename"": ""arch/sh/kernel/ptrace_32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/ptrace_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/ptrace_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/kernel/ptrace_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -63,7 +63,7 @@ static inline int put_stack_long(struct task_struct *task, int offset,\n \treturn 0;\n }\n \n-void ptrace_triggered(struct perf_event *bp, int nmi,\n+void ptrace_triggered(struct perf_event *bp,\n \t\t      struct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct perf_event_attr attr;""}<_**next**_>{""sha"": ""d9006f8ffc142532d99b0ff539f88831f4027999"", ""filename"": ""arch/sh/kernel/traps_32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/traps_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/traps_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/kernel/traps_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -393,7 +393,7 @@ int handle_unaligned_access(insn_size_t instruction, struct pt_regs *regs,\n \t */\n \tif (!expected) {\n \t\tunaligned_fixups_notify(current, instruction, regs);\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n \t\t\t      regs, address);\n \t}\n ""}<_**next**_>{""sha"": ""67110be83fd7239b963390942f7a2fa165fca59b"", ""filename"": ""arch/sh/kernel/traps_64.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/traps_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/kernel/traps_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/kernel/traps_64.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -434,7 +434,7 @@ static int misaligned_load(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\n \n \tdestreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -512,7 +512,7 @@ static int misaligned_store(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -588,7 +588,7 @@ static int misaligned_fpu_load(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);\n \n \tdestreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {\n@@ -665,7 +665,7 @@ static int misaligned_fpu_store(struct pt_regs *regs,\n \t\treturn error;\n \t}\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, address);\n \n \tsrcreg = (opcode >> 4) & 0x3f;\n \tif (user_mode(regs)) {""}<_**next**_>{""sha"": ""977195210653ede066d541f39e75ebb2745e55c6"", ""filename"": ""arch/sh/math-emu/math.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/math-emu/math.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/math-emu/math.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/math-emu/math.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -620,7 +620,7 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)\n \tstruct task_struct *tsk = current;\n \tstruct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tif (!(task_thread_info(tsk)->status & TS_USEDFPU)) {\n \t\t/* initialize once. */""}<_**next**_>{""sha"": ""7bebd044f2a1fc02f598c3293a358064784c2045"", ""filename"": ""arch/sh/mm/fault_32.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/mm/fault_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/mm/fault_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/mm/fault_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -160,7 +160,7 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,\n \tif ((regs->sr & SR_IMASK) != SR_IMASK)\n \t\tlocal_irq_enable();\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t/*\n \t * If we're in an interrupt, have no user context or are running\n@@ -210,11 +210,11 @@ asmlinkage void __kprobes do_page_fault(struct pt_regs *regs,\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\ttsk->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n \t} else {\n \t\ttsk->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n ""}<_**next**_>{""sha"": ""e3430e093d436d300bb1928ea4320ce230b1d632"", ""filename"": ""arch/sh/mm/tlbflush_64.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/mm/tlbflush_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sh/mm/tlbflush_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sh/mm/tlbflush_64.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -116,7 +116,7 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long writeaccess,\n \t/* Not an IO address, so reenable interrupts */\n \tlocal_irq_enable();\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t/*\n \t * If we're in an interrupt or have no user\n@@ -200,11 +200,11 @@ asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long writeaccess,\n \n \tif (fault & VM_FAULT_MAJOR) {\n \t\ttsk->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t     regs, address);\n \t} else {\n \t\ttsk->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t     regs, address);\n \t}\n ""}<_**next**_>{""sha"": ""0b32f2e9e08d90b82f479f333423576a56257cef"", ""filename"": ""arch/sparc/kernel/perf_event.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/perf_event.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/perf_event.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/kernel/perf_event.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -1277,7 +1277,7 @@ static int __kprobes perf_event_nmi_handler(struct notifier_block *self,\n \t\tif (!sparc_perf_event_set_period(event, hwc, idx))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tsparc_pmu_stop(event, 0);\n \t}\n ""}<_**next**_>{""sha"": ""7efbb2f9e77ff63d9a18be9f44f166cd04f05bda"", ""filename"": ""arch/sparc/kernel/unaligned_32.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/unaligned_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/unaligned_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/kernel/unaligned_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -247,7 +247,7 @@ asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \t\tunsigned long addr = compute_effective_address(regs, insn);\n \t\tint err;\n \n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch (dir) {\n \t\tcase load:\n \t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n@@ -338,7 +338,7 @@ asmlinkage void user_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \t\t}\n \n \t\taddr = compute_effective_address(regs, insn);\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch(dir) {\n \t\tcase load:\n \t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),""}<_**next**_>{""sha"": ""35cff1673aa4ec320cd25fc86b660eb88cc28cb8"", ""filename"": ""arch/sparc/kernel/unaligned_64.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/unaligned_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/unaligned_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/kernel/unaligned_64.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -317,7 +317,7 @@ asmlinkage void kernel_unaligned_trap(struct pt_regs *regs, unsigned int insn)\n \n \t\taddr = compute_effective_address(regs, insn,\n \t\t\t\t\t\t ((insn >> 25) & 0x1f));\n-\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n+\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n \t\tswitch (asi) {\n \t\tcase ASI_NL:\n \t\tcase ASI_AIUPL:\n@@ -384,7 +384,7 @@ int handle_popc(u32 insn, struct pt_regs *regs)\n \tint ret, i, rd = ((insn >> 25) & 0x1f);\n \tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n \t                        \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \tif (insn & 0x2000) {\n \t\tmaybe_flush_windows(0, 0, rd, from_kernel);\n \t\tvalue = sign_extend_imm13(insn);\n@@ -431,7 +431,7 @@ int handle_ldf_stq(u32 insn, struct pt_regs *regs)\n \tint asi = decode_asi(insn, regs);\n \tint flag = (freg < 32) ? FPRS_DL : FPRS_DU;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tsave_and_clear_fpu();\n \tcurrent_thread_info()->xfsr[0] &= ~0x1c000;\n@@ -554,7 +554,7 @@ void handle_ld_nf(u32 insn, struct pt_regs *regs)\n \tint from_kernel = (regs->tstate & TSTATE_PRIV) != 0;\n \tunsigned long *reg;\n \t                        \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tmaybe_flush_windows(0, 0, rd, from_kernel);\n \treg = fetch_reg_addr(rd, regs);\n@@ -586,7 +586,7 @@ void handle_lddfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\""lddfmna from kernel\"", regs);\n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {\n@@ -647,7 +647,7 @@ void handle_stdfmna(struct pt_regs *regs, unsigned long sfar, unsigned long sfsr\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\""stdfmna from kernel\"", regs);\n-\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, sfar);\n+\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, sfar);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {""}<_**next**_>{""sha"": ""32b626c9d815601e445b0d47e76cc0ebbab84e75"", ""filename"": ""arch/sparc/kernel/visemul.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/visemul.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/kernel/visemul.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/kernel/visemul.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -802,7 +802,7 @@ int vis_emul(struct pt_regs *regs, unsigned int insn)\n \n \tBUG_ON(regs->tstate & TSTATE_PRIV);\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;""}<_**next**_>{""sha"": ""aa4d55b0bdf0326370ec6d54a4759b04215d61cb"", ""filename"": ""arch/sparc/math-emu/math_32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/math-emu/math_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/math-emu/math_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/math-emu/math_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -164,7 +164,7 @@ int do_mathemu(struct pt_regs *regs, struct task_struct *fpt)\n \tint retcode = 0;                               /* assume all succeed */\n \tunsigned long insn;\n \n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \n #ifdef DEBUG_MATHEMU\n \tprintk(\""In do_mathemu()... pc is %08lx\\n\"", regs->pc);""}<_**next**_>{""sha"": ""e575bd2fe38167eadf61386b86df733807ef7ead"", ""filename"": ""arch/sparc/math-emu/math_64.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/math-emu/math_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/math-emu/math_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/math-emu/math_64.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -184,7 +184,7 @@ int do_mathemu(struct pt_regs *regs, struct fpustate *f)\n \n \tif (tstate & TSTATE_PRIV)\n \t\tdie_if_kernel(\""unfinished/unimplemented FPop from kernel\"", regs);\n-\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);\n+\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);\n \tif (test_thread_flag(TIF_32BIT))\n \t\tpc = (u32)pc;\n \tif (get_user(insn, (u32 __user *) pc) != -EFAULT) {""}<_**next**_>{""sha"": ""aa1c1b1ce5cc05ce4daa3f67161b565a1101ea4c"", ""filename"": ""arch/sparc/mm/fault_32.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 5, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/mm/fault_32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/mm/fault_32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/mm/fault_32.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -251,7 +251,7 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\n         if (in_atomic() || !mm)\n                 goto no_context;\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \tdown_read(&mm->mmap_sem);\n \n@@ -301,12 +301,10 @@ asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\n \treturn;""}<_**next**_>{""sha"": ""504c0622f7296c42bb09cae18bc487630e6344a4"", ""filename"": ""arch/sparc/mm/fault_64.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 5, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/mm/fault_64.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/sparc/mm/fault_64.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/mm/fault_64.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -325,7 +325,7 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n \tif (in_atomic() || !mm)\n \t\tgoto intr_or_no_mm;\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \tif (!down_read_trylock(&mm->mmap_sem)) {\n \t\tif ((regs->tstate & TSTATE_PRIV) &&\n@@ -433,12 +433,10 @@ asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n \t}\n \tif (fault & VM_FAULT_MAJOR) {\n \t\tcurrent->maj_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n \t} else {\n \t\tcurrent->min_flt++;\n-\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n-\t\t\t      regs, address);\n+\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n \t}\n \tup_read(&mm->mmap_sem);\n ""}<_**next**_>{""sha"": ""5b86ec51534cf7fb5ad91edd59edeece14407a97"", ""filename"": ""arch/x86/kernel/cpu/perf_event.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/cpu/perf_event.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -1339,7 +1339,7 @@ static int x86_pmu_handle_irq(struct pt_regs *regs)\n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n ""}<_**next**_>{""sha"": ""d38b0020f77564f926da3104b275b1cefd6e9113"", ""filename"": ""arch/x86/kernel/cpu/perf_event_intel.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_intel.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_intel.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/cpu/perf_event_intel.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -1003,7 +1003,7 @@ static int intel_pmu_handle_irq(struct pt_regs *regs)\n \n \t\tdata.period = event->hw.last_period;\n \n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n ""}<_**next**_>{""sha"": ""0941f93f2940b3c51498b01de6f20c54a4737abc"", ""filename"": ""arch/x86/kernel/cpu/perf_event_intel_ds.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_intel_ds.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_intel_ds.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/cpu/perf_event_intel_ds.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -340,7 +340,7 @@ static int intel_pmu_drain_bts_buffer(void)\n \t */\n \tperf_prepare_sample(&header, &data, event, &regs);\n \n-\tif (perf_output_begin(&handle, event, header.size * (top - at), 1, 1))\n+\tif (perf_output_begin(&handle, event, header.size * (top - at), 1))\n \t\treturn 1;\n \n \tfor (; at < top; at++) {\n@@ -616,7 +616,7 @@ static void __intel_pmu_pebs_event(struct perf_event *event,\n \telse\n \t\tregs.flags &= ~PERF_EFLAGS_EXACT;\n \n-\tif (perf_event_overflow(event, 1, &data, &regs))\n+\tif (perf_event_overflow(event, &data, &regs))\n \t\tx86_pmu_stop(event, 0);\n }\n ""}<_**next**_>{""sha"": ""d6e6a67b9608eae96b8751a145a57a65c3cb2327"", ""filename"": ""arch/x86/kernel/cpu/perf_event_p4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_p4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/cpu/perf_event_p4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/cpu/perf_event_p4.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -970,7 +970,7 @@ static int p4_pmu_handle_irq(struct pt_regs *regs)\n \n \t\tif (!x86_perf_event_set_period(event))\n \t\t\tcontinue;\n-\t\tif (perf_event_overflow(event, 1, &data, regs))\n+\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\tx86_pmu_stop(event, 0);\n \t}\n ""}<_**next**_>{""sha"": ""98da6a7b5e8223bc28465c4fecaf49a3e6a03ee2"", ""filename"": ""arch/x86/kernel/kgdb.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/kgdb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/kgdb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/kgdb.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -608,7 +608,7 @@ int kgdb_arch_init(void)\n \treturn register_die_notifier(&kgdb_notifier);\n }\n \n-static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,\n+static void kgdb_hw_overflow_handler(struct perf_event *event,\n \t\tstruct perf_sample_data *data, struct pt_regs *regs)\n {\n \tstruct task_struct *tsk = current;""}<_**next**_>{""sha"": ""11db2e9b860a7205112105d80e23d09f451bac52"", ""filename"": ""arch/x86/kernel/ptrace.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/ptrace.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/kernel/ptrace.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kernel/ptrace.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -528,7 +528,7 @@ static int genregs_set(struct task_struct *target,\n \treturn ret;\n }\n \n-static void ptrace_triggered(struct perf_event *bp, int nmi,\n+static void ptrace_triggered(struct perf_event *bp,\n \t\t\t     struct perf_sample_data *data,\n \t\t\t     struct pt_regs *regs)\n {""}<_**next**_>{""sha"": ""4d09df054e391822aa7a5e634a4ff2f4f8afabc0"", ""filename"": ""arch/x86/mm/fault.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/mm/fault.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/arch/x86/mm/fault.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/mm/fault.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -1059,7 +1059,7 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)\n \tif (unlikely(error_code & PF_RSVD))\n \t\tpgtable_bad(regs, error_code, address);\n \n-\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n+\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n \n \t/*\n \t * If we're in an interrupt, have no user context or are running\n@@ -1161,11 +1161,11 @@ do_page_fault(struct pt_regs *regs, unsigned long error_code)\n \tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n \t\tif (fault & VM_FAULT_MAJOR) {\n \t\t\ttsk->maj_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n \t\t\t\t      regs, address);\n \t\t} else {\n \t\t\ttsk->min_flt++;\n-\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n+\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n \t\t\t\t      regs, address);\n \t\t}\n \t\tif (fault & VM_FAULT_RETRY) {""}<_**next**_>{""sha"": ""0946a8bc098dbfced946033c5e73be66b56ca634"", ""filename"": ""include/linux/perf_event.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 10, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/include/linux/perf_event.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/include/linux/perf_event.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/perf_event.h?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -682,7 +682,7 @@ enum perf_event_active_state {\n struct file;\n struct perf_sample_data;\n \n-typedef void (*perf_overflow_handler_t)(struct perf_event *, int,\n+typedef void (*perf_overflow_handler_t)(struct perf_event *,\n \t\t\t\t\tstruct perf_sample_data *,\n \t\t\t\t\tstruct pt_regs *regs);\n \n@@ -925,7 +925,6 @@ struct perf_output_handle {\n \tunsigned long\t\t\tsize;\n \tvoid\t\t\t\t*addr;\n \tint\t\t\t\tpage;\n-\tint\t\t\t\tnmi;\n \tint\t\t\t\tsample;\n };\n \n@@ -993,7 +992,7 @@ extern void perf_prepare_sample(struct perf_event_header *header,\n \t\t\t\tstruct perf_event *event,\n \t\t\t\tstruct pt_regs *regs);\n \n-extern int perf_event_overflow(struct perf_event *event, int nmi,\n+extern int perf_event_overflow(struct perf_event *event,\n \t\t\t\t struct perf_sample_data *data,\n \t\t\t\t struct pt_regs *regs);\n \n@@ -1012,7 +1011,7 @@ static inline int is_software_event(struct perf_event *event)\n \n extern struct jump_label_key perf_swevent_enabled[PERF_COUNT_SW_MAX];\n \n-extern void __perf_sw_event(u32, u64, int, struct pt_regs *, u64);\n+extern void __perf_sw_event(u32, u64, struct pt_regs *, u64);\n \n #ifndef perf_arch_fetch_caller_regs\n static inline void perf_arch_fetch_caller_regs(struct pt_regs *regs, unsigned long ip) { }\n@@ -1034,7 +1033,7 @@ static inline void perf_fetch_caller_regs(struct pt_regs *regs)\n }\n \n static __always_inline void\n-perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n+perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n {\n \tstruct pt_regs hot_regs;\n \n@@ -1043,7 +1042,7 @@ perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n \t\t\tperf_fetch_caller_regs(&hot_regs);\n \t\t\tregs = &hot_regs;\n \t\t}\n-\t\t__perf_sw_event(event_id, nr, nmi, regs, addr);\n+\t\t__perf_sw_event(event_id, nr, regs, addr);\n \t}\n }\n \n@@ -1057,7 +1056,7 @@ static inline void perf_event_task_sched_in(struct task_struct *task)\n \n static inline void perf_event_task_sched_out(struct task_struct *task, struct task_struct *next)\n {\n-\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, 1, NULL, 0);\n+\tperf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, NULL, 0);\n \n \t__perf_event_task_sched_out(task, next);\n }\n@@ -1119,7 +1118,7 @@ extern void perf_bp_event(struct perf_event *event, void *data);\n \n extern int perf_output_begin(struct perf_output_handle *handle,\n \t\t\t     struct perf_event *event, unsigned int size,\n-\t\t\t     int nmi, int sample);\n+\t\t\t     int sample);\n extern void perf_output_end(struct perf_output_handle *handle);\n extern void perf_output_copy(struct perf_output_handle *handle,\n \t\t\t     const void *buf, unsigned int len);\n@@ -1143,8 +1142,7 @@ static inline int perf_event_task_disable(void)\t\t\t\t{ return -EINVAL; }\n static inline int perf_event_task_enable(void)\t\t\t\t{ return -EINVAL; }\n \n static inline void\n-perf_sw_event(u32 event_id, u64 nr, int nmi,\n-\t\t     struct pt_regs *regs, u64 addr)\t\t\t{ }\n+perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\t{ }\n static inline void\n perf_bp_event(struct perf_event *event, void *data)\t\t\t{ }\n ""}<_**next**_>{""sha"": ""dbd1ca75bd3cb36472877829c896621baf76d924"", ""filename"": ""kernel/events/core.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 35, ""changes"": 63, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/events/core.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -3972,7 +3972,7 @@ void perf_prepare_sample(struct perf_event_header *header,\n \t}\n }\n \n-static void perf_event_output(struct perf_event *event, int nmi,\n+static void perf_event_output(struct perf_event *event,\n \t\t\t\tstruct perf_sample_data *data,\n \t\t\t\tstruct pt_regs *regs)\n {\n@@ -3984,7 +3984,7 @@ static void perf_event_output(struct perf_event *event, int nmi,\n \n \tperf_prepare_sample(&header, data, event, regs);\n \n-\tif (perf_output_begin(&handle, event, header.size, nmi, 1))\n+\tif (perf_output_begin(&handle, event, header.size, 1))\n \t\tgoto exit;\n \n \tperf_output_sample(&handle, &header, data, event);\n@@ -4024,7 +4024,7 @@ perf_event_read_event(struct perf_event *event,\n \tint ret;\n \n \tperf_event_header__init_id(&read_event.header, &sample, event);\n-\tret = perf_output_begin(&handle, event, read_event.header.size, 0, 0);\n+\tret = perf_output_begin(&handle, event, read_event.header.size, 0);\n \tif (ret)\n \t\treturn;\n \n@@ -4067,7 +4067,7 @@ static void perf_event_task_output(struct perf_event *event,\n \tperf_event_header__init_id(&task_event->event_id.header, &sample, event);\n \n \tret = perf_output_begin(&handle, event,\n-\t\t\t\ttask_event->event_id.header.size, 0, 0);\n+\t\t\t\ttask_event->event_id.header.size, 0);\n \tif (ret)\n \t\tgoto out;\n \n@@ -4204,7 +4204,7 @@ static void perf_event_comm_output(struct perf_event *event,\n \n \tperf_event_header__init_id(&comm_event->event_id.header, &sample, event);\n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tcomm_event->event_id.header.size, 0, 0);\n+\t\t\t\tcomm_event->event_id.header.size, 0);\n \n \tif (ret)\n \t\tgoto out;\n@@ -4351,7 +4351,7 @@ static void perf_event_mmap_output(struct perf_event *event,\n \n \tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n+\t\t\t\tmmap_event->event_id.header.size, 0);\n \tif (ret)\n \t\tgoto out;\n \n@@ -4546,7 +4546,7 @@ static void perf_log_throttle(struct perf_event *event, int enable)\n \tperf_event_header__init_id(&throttle_event.header, &sample, event);\n \n \tret = perf_output_begin(&handle, event,\n-\t\t\t\tthrottle_event.header.size, 1, 0);\n+\t\t\t\tthrottle_event.header.size, 0);\n \tif (ret)\n \t\treturn;\n \n@@ -4559,7 +4559,7 @@ static void perf_log_throttle(struct perf_event *event, int enable)\n  * Generic event overflow handling, sampling.\n  */\n \n-static int __perf_event_overflow(struct perf_event *event, int nmi,\n+static int __perf_event_overflow(struct perf_event *event,\n \t\t\t\t   int throttle, struct perf_sample_data *data,\n \t\t\t\t   struct pt_regs *regs)\n {\n@@ -4602,34 +4602,28 @@ static int __perf_event_overflow(struct perf_event *event, int nmi,\n \tif (events && atomic_dec_and_test(&event->event_limit)) {\n \t\tret = 1;\n \t\tevent->pending_kill = POLL_HUP;\n-\t\tif (nmi) {\n-\t\t\tevent->pending_disable = 1;\n-\t\t\tirq_work_queue(&event->pending);\n-\t\t} else\n-\t\t\tperf_event_disable(event);\n+\t\tevent->pending_disable = 1;\n+\t\tirq_work_queue(&event->pending);\n \t}\n \n \tif (event->overflow_handler)\n-\t\tevent->overflow_handler(event, nmi, data, regs);\n+\t\tevent->overflow_handler(event, data, regs);\n \telse\n-\t\tperf_event_output(event, nmi, data, regs);\n+\t\tperf_event_output(event, data, regs);\n \n \tif (event->fasync && event->pending_kill) {\n-\t\tif (nmi) {\n-\t\t\tevent->pending_wakeup = 1;\n-\t\t\tirq_work_queue(&event->pending);\n-\t\t} else\n-\t\t\tperf_event_wakeup(event);\n+\t\tevent->pending_wakeup = 1;\n+\t\tirq_work_queue(&event->pending);\n \t}\n \n \treturn ret;\n }\n \n-int perf_event_overflow(struct perf_event *event, int nmi,\n+int perf_event_overflow(struct perf_event *event,\n \t\t\t  struct perf_sample_data *data,\n \t\t\t  struct pt_regs *regs)\n {\n-\treturn __perf_event_overflow(event, nmi, 1, data, regs);\n+\treturn __perf_event_overflow(event, 1, data, regs);\n }\n \n /*\n@@ -4678,7 +4672,7 @@ static u64 perf_swevent_set_period(struct perf_event *event)\n }\n \n static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n-\t\t\t\t    int nmi, struct perf_sample_data *data,\n+\t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n@@ -4692,7 +4686,7 @@ static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n \t\treturn;\n \n \tfor (; overflow; overflow--) {\n-\t\tif (__perf_event_overflow(event, nmi, throttle,\n+\t\tif (__perf_event_overflow(event, throttle,\n \t\t\t\t\t    data, regs)) {\n \t\t\t/*\n \t\t\t * We inhibit the overflow from happening when\n@@ -4705,7 +4699,7 @@ static void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n }\n \n static void perf_swevent_event(struct perf_event *event, u64 nr,\n-\t\t\t       int nmi, struct perf_sample_data *data,\n+\t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {\n \tstruct hw_perf_event *hwc = &event->hw;\n@@ -4719,12 +4713,12 @@ static void perf_swevent_event(struct perf_event *event, u64 nr,\n \t\treturn;\n \n \tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n-\t\treturn perf_swevent_overflow(event, 1, nmi, data, regs);\n+\t\treturn perf_swevent_overflow(event, 1, data, regs);\n \n \tif (local64_add_negative(nr, &hwc->period_left))\n \t\treturn;\n \n-\tperf_swevent_overflow(event, 0, nmi, data, regs);\n+\tperf_swevent_overflow(event, 0, data, regs);\n }\n \n static int perf_exclude_event(struct perf_event *event,\n@@ -4812,7 +4806,7 @@ find_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n }\n \n static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n-\t\t\t\t    u64 nr, int nmi,\n+\t\t\t\t    u64 nr,\n \t\t\t\t    struct perf_sample_data *data,\n \t\t\t\t    struct pt_regs *regs)\n {\n@@ -4828,7 +4822,7 @@ static void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n \n \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n \t\tif (perf_swevent_match(event, type, event_id, data, regs))\n-\t\t\tperf_swevent_event(event, nr, nmi, data, regs);\n+\t\t\tperf_swevent_event(event, nr, data, regs);\n \t}\n end:\n \trcu_read_unlock();\n@@ -4849,8 +4843,7 @@ inline void perf_swevent_put_recursion_context(int rctx)\n \tput_recursion_context(swhash->recursion, rctx);\n }\n \n-void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n-\t\t\t    struct pt_regs *regs, u64 addr)\n+void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n {\n \tstruct perf_sample_data data;\n \tint rctx;\n@@ -4862,7 +4855,7 @@ void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n \n \tperf_sample_data_init(&data, addr);\n \n-\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n+\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n \n \tperf_swevent_put_recursion_context(rctx);\n \tpreempt_enable_notrace();\n@@ -5110,7 +5103,7 @@ void perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n \n \thlist_for_each_entry_rcu(event, node, head, hlist_entry) {\n \t\tif (perf_tp_event_match(event, &data, regs))\n-\t\t\tperf_swevent_event(event, count, 1, &data, regs);\n+\t\t\tperf_swevent_event(event, count, &data, regs);\n \t}\n \n \tperf_swevent_put_recursion_context(rctx);\n@@ -5203,7 +5196,7 @@ void perf_bp_event(struct perf_event *bp, void *data)\n \tperf_sample_data_init(&sample, bp->attr.bp_addr);\n \n \tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n-\t\tperf_swevent_event(bp, 1, 1, &sample, regs);\n+\t\tperf_swevent_event(bp, 1, &sample, regs);\n }\n #endif\n \n@@ -5232,7 +5225,7 @@ static enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n \n \tif (regs && !perf_exclude_event(event, regs)) {\n \t\tif (!(event->attr.exclude_idle && current->pid == 0))\n-\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n+\t\t\tif (perf_event_overflow(event, &data, regs))\n \t\t\t\tret = HRTIMER_NORESTART;\n \t}\n ""}<_**next**_>{""sha"": ""09097dd8116c0e0bf5120d4da26c5f539a7f600a"", ""filename"": ""kernel/events/internal.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/internal.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/internal.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/events/internal.h?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -27,7 +27,6 @@ struct ring_buffer {\n \tvoid\t\t\t\t*data_pages[0];\n };\n \n-\n extern void rb_free(struct ring_buffer *rb);\n extern struct ring_buffer *\n rb_alloc(int nr_pages, long watermark, int cpu, int flags);""}<_**next**_>{""sha"": ""8b3b73630fa4c35add61468a9903985de64b6a3b"", ""filename"": ""kernel/events/ring_buffer.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/ring_buffer.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/events/ring_buffer.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/events/ring_buffer.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -38,11 +38,8 @@ static void perf_output_wakeup(struct perf_output_handle *handle)\n {\n \tatomic_set(&handle->rb->poll, POLL_IN);\n \n-\tif (handle->nmi) {\n-\t\thandle->event->pending_wakeup = 1;\n-\t\tirq_work_queue(&handle->event->pending);\n-\t} else\n-\t\tperf_event_wakeup(handle->event);\n+\thandle->event->pending_wakeup = 1;\n+\tirq_work_queue(&handle->event->pending);\n }\n \n /*\n@@ -102,7 +99,7 @@ static void perf_output_put_handle(struct perf_output_handle *handle)\n \n int perf_output_begin(struct perf_output_handle *handle,\n \t\t      struct perf_event *event, unsigned int size,\n-\t\t      int nmi, int sample)\n+\t\t      int sample)\n {\n \tstruct ring_buffer *rb;\n \tunsigned long tail, offset, head;\n@@ -127,7 +124,6 @@ int perf_output_begin(struct perf_output_handle *handle,\n \n \thandle->rb\t= rb;\n \thandle->event\t= event;\n-\thandle->nmi\t= nmi;\n \thandle->sample\t= sample;\n \n \tif (!rb->nr_pages)""}<_**next**_>{""sha"": ""d08d110b8976407a70643ff71223974f296edfaa"", ""filename"": ""kernel/sched.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/sched.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/sched.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -2220,7 +2220,7 @@ void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n \n \tif (task_cpu(p) != new_cpu) {\n \t\tp->se.nr_migrations++;\n-\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 1, NULL, 0);\n+\t\tperf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);\n \t}\n \n \t__set_task_cpu(p, new_cpu);""}<_**next**_>{""sha"": ""a6708e677a0af11db15af1b65b40c7d7951df772"", ""filename"": ""kernel/watchdog.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/watchdog.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/kernel/watchdog.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/watchdog.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -211,7 +211,7 @@ static struct perf_event_attr wd_hw_attr = {\n };\n \n /* Callback function for perf event subsystem */\n-static void watchdog_overflow_callback(struct perf_event *event, int nmi,\n+static void watchdog_overflow_callback(struct perf_event *event,\n \t\t struct perf_sample_data *data,\n \t\t struct pt_regs *regs)\n {""}<_**next**_>{""sha"": ""7b164d3200ffe8061b63d33603c3f11b1b3e82f9"", ""filename"": ""samples/hw_breakpoint/data_breakpoint.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/samples/hw_breakpoint/data_breakpoint.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a8b0ca17b80e92faab46ee7179ba9e99ccb61233/samples/hw_breakpoint/data_breakpoint.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/samples/hw_breakpoint/data_breakpoint.c?ref=a8b0ca17b80e92faab46ee7179ba9e99ccb61233"", ""patch"": ""@@ -41,7 +41,7 @@ module_param_string(ksym, ksym_name, KSYM_NAME_LEN, S_IRUGO);\n MODULE_PARM_DESC(ksym, \""Kernel symbol to monitor; this module will report any\""\n \t\t\t\"" write operations on the kernel symbol\"");\n \n-static void sample_hbp_handler(struct perf_event *bp, int nmi,\n+static void sample_hbp_handler(struct perf_event *bp,\n \t\t\t       struct perf_sample_data *data,\n \t\t\t       struct pt_regs *regs)\n {""}","fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
	     int n)
{
	if (FPSCR_SZ) {
		FMOV_EXT(m);
		Rn -= 8;
		WRITE(FRm, Rn + 4);
		m++;
		WRITE(FRm, Rn);
	} else {
		Rn -= 4;
		WRITE(FRm, Rn);
	}

	return 0;
}
","fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
	     int n)
{
	if (FPSCR_SZ) {
		FMOV_EXT(m);
		Rn -= 8;
		WRITE(FRm, Rn + 4);
		m++;
		WRITE(FRm, Rn);
	} else {
		Rn -= 4;
		WRITE(FRm, Rn);
	}

	return 0;
}
",C,,,,"@@ -620,7 +620,7 @@ int do_fpu_inst(unsigned short inst, struct pt_regs *regs)
 	struct task_struct *tsk = current;
 	struct sh_fpu_soft_struct *fpu = &(tsk->thread.xstate->softfpu);
 
-	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, 0, regs, 0);
+	perf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, 0);
 
 	if (!(task_thread_info(tsk)->status & TS_USEDFPU)) {
 		/* initialize once. */",linux,a8b0ca17b80e92faab46ee7179ba9e99ccb61233,1880c4ae182afb5650c5678949ecfe7ff66a724e,0,"fmov_reg_dec(struct sh_fpu_soft_struct *fregs, struct pt_regs *regs, int m,
	     int n)
{
	if (FPSCR_SZ) {
		FMOV_EXT(m);
		Rn -= 8;
		WRITE(FRm, Rn + 4);
		m++;
		WRITE(FRm, Rn);
	} else {
		Rn -= 4;
		WRITE(FRm, Rn);
	}

	return 0;
}
"
70262,,Remote,Not required,Partial,CVE-2016-10269,https://www.cvedetails.com/cve/CVE-2016-10269/,CWE-125,Medium,Partial,Partial,,2017-03-24,6.8,"LibTIFF 4.0.7 allows remote attackers to cause a denial of service (heap-based buffer over-read) or possibly have unspecified other impact via a crafted TIFF image, related to *READ of size 512* and libtiff/tif_unix.c:340:2.",2018-03-21,DoS ,0,https://github.com/vadz/libtiff/commit/1044b43637fa7f70fb19b93593777b78bd20da86,1044b43637fa7f70fb19b93593777b78bd20da86,"* libtiff/tif_pixarlog.c, libtiff/tif_luv.c: fix heap-based buffer
overflow on generation of PixarLog / LUV compressed files, with
ColorMap, TransferFunction attached and nasty plays with bitspersample.
The fix for LUV has not been tested, but suffers from the same kind
of issue of PixarLog.
Reported by Agostino Sarubbo.
Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2604",0,libtiff/tif_luv.c,"{""sha"": ""93c01f80edf83e0a0d25b8f587a481492f322a80"", ""filename"": ""ChangeLog"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/vadz/libtiff/blob/1044b43637fa7f70fb19b93593777b78bd20da86/ChangeLog"", ""raw_url"": ""https://github.com/vadz/libtiff/raw/1044b43637fa7f70fb19b93593777b78bd20da86/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/vadz/libtiff/contents/ChangeLog?ref=1044b43637fa7f70fb19b93593777b78bd20da86"", ""patch"": ""@@ -1,3 +1,13 @@\n+2016-12-03 Even Rouault <even.rouault at spatialys.com>\n+\n+\t* libtiff/tif_pixarlog.c, libtiff/tif_luv.c: fix heap-based buffer\n+\toverflow on generation of PixarLog / LUV compressed files, with\n+\tColorMap, TransferFunction attached and nasty plays with bitspersample.\n+\tThe fix for LUV has not been tested, but suffers from the same kind\n+\tof issue of PixarLog.\n+\tReported by Agostino Sarubbo.\n+\tFixes http://bugzilla.maptools.org/show_bug.cgi?id=2604\n+\n 2016-12-02 Even Rouault <even.rouault at spatialys.com>\n \n \t* tools/tiffcp.c: avoid uint32 underflow in cpDecodedStrips that ""}<_**next**_>{""sha"": ""e6783db5674c31c9699240001fb54c16e518cda7"", ""filename"": ""libtiff/tif_luv.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 4, ""changes"": 18, ""blob_url"": ""https://github.com/vadz/libtiff/blob/1044b43637fa7f70fb19b93593777b78bd20da86/libtiff/tif_luv.c"", ""raw_url"": ""https://github.com/vadz/libtiff/raw/1044b43637fa7f70fb19b93593777b78bd20da86/libtiff/tif_luv.c"", ""contents_url"": ""https://api.github.com/repos/vadz/libtiff/contents/libtiff/tif_luv.c?ref=1044b43637fa7f70fb19b93593777b78bd20da86"", ""patch"": ""@@ -158,6 +158,7 @@\n typedef struct logLuvState LogLuvState;\n \n struct logLuvState {\n+        int                     encoder_state;  /* 1 if encoder correctly initialized */\n \tint                     user_datafmt;   /* user data format */\n \tint                     encode_meth;    /* encoding method */\n \tint                     pixel_size;     /* bytes per pixel */\n@@ -1552,6 +1553,7 @@ LogLuvSetupEncode(TIFF* tif)\n \t\t    td->td_photometric, \""must be either LogLUV or LogL\"");\n \t\tbreak;\n \t}\n+\tsp->encoder_state = 1;\n \treturn (1);\n notsupported:\n \tTIFFErrorExt(tif->tif_clientdata, module,\n@@ -1563,19 +1565,27 @@ LogLuvSetupEncode(TIFF* tif)\n static void\n LogLuvClose(TIFF* tif)\n {\n+        LogLuvState* sp = (LogLuvState*) tif->tif_data;\n \tTIFFDirectory *td = &tif->tif_dir;\n \n+\tassert(sp != 0);\n \t/*\n \t * For consistency, we always want to write out the same\n \t * bitspersample and sampleformat for our TIFF file,\n \t * regardless of the data format being used by the application.\n \t * Since this routine is called after tags have been set but\n \t * before they have been recorded in the file, we reset them here.\n+         * Note: this is really a nasty approach. See PixarLogClose\n \t */\n-\ttd->td_samplesperpixel =\n-\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n-\ttd->td_bitspersample = 16;\n-\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n+        if( sp->encoder_state )\n+        {\n+            /* See PixarLogClose. Might avoid issues with tags whose size depends\n+             * on those below, but not completely sure this is enough. */\n+            td->td_samplesperpixel =\n+                (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n+            td->td_bitspersample = 16;\n+            td->td_sampleformat = SAMPLEFORMAT_INT;\n+        }\n }\n \n static void""}<_**next**_>{""sha"": ""aa99bc92038fada3f1a77f3cd9cd9865c7bac1fb"", ""filename"": ""libtiff/tif_pixarlog.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/vadz/libtiff/blob/1044b43637fa7f70fb19b93593777b78bd20da86/libtiff/tif_pixarlog.c"", ""raw_url"": ""https://github.com/vadz/libtiff/raw/1044b43637fa7f70fb19b93593777b78bd20da86/libtiff/tif_pixarlog.c"", ""contents_url"": ""https://api.github.com/repos/vadz/libtiff/contents/libtiff/tif_pixarlog.c?ref=1044b43637fa7f70fb19b93593777b78bd20da86"", ""patch"": ""@@ -1233,8 +1233,10 @@ PixarLogPostEncode(TIFF* tif)\n static void\n PixarLogClose(TIFF* tif)\n {\n+        PixarLogState* sp = (PixarLogState*) tif->tif_data;\n \tTIFFDirectory *td = &tif->tif_dir;\n \n+\tassert(sp != 0);\n \t/* In a really sneaky (and really incorrect, and untruthful, and\n \t * troublesome, and error-prone) maneuver that completely goes against\n \t * the spirit of TIFF, and breaks TIFF, on close, we covertly\n@@ -1243,8 +1245,19 @@ PixarLogClose(TIFF* tif)\n \t * readers that don't know about PixarLog, or how to set\n \t * the PIXARLOGDATFMT pseudo-tag.\n \t */\n-\ttd->td_bitspersample = 8;\n-\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n+\n+        if (sp->state&PLSTATE_INIT) {\n+            /* We test the state to avoid an issue such as in\n+             * http://bugzilla.maptools.org/show_bug.cgi?id=2604\n+             * What appends in that case is that the bitspersample is 1 and\n+             * a TransferFunction is set. The size of the TransferFunction\n+             * depends on 1<<bitspersample. So if we increase it, an access\n+             * out of the buffer will happen at directory flushing.\n+             * Another option would be to clear those targs. \n+             */\n+            td->td_bitspersample = 8;\n+            td->td_sampleformat = SAMPLEFORMAT_UINT;\n+        }\n }\n \n static void""}","TIFFInitSGILog(TIFF* tif, int scheme)
{
	static const char module[] = ""TIFFInitSGILog"";
	LogLuvState* sp;

	assert(scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG);

	/*
	 * Merge codec-specific tag information.
	 */
	if (!_TIFFMergeFields(tif, LogLuvFields,
			      TIFFArrayCount(LogLuvFields))) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Merging SGILog codec-specific tags failed"");
		return 0;
	}

	/*
	 * Allocate state block so tag methods have storage to record values.
	 */
	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LogLuvState));
	if (tif->tif_data == NULL)
		goto bad;
	sp = (LogLuvState*) tif->tif_data;
	_TIFFmemset((void*)sp, 0, sizeof (*sp));
	sp->user_datafmt = SGILOGDATAFMT_UNKNOWN;
	sp->encode_meth = (scheme == COMPRESSION_SGILOG24) ?
	    SGILOGENCODE_RANDITHER : SGILOGENCODE_NODITHER;
	sp->tfunc = _logLuvNop;

	/*
	 * Install codec methods.
	 * NB: tif_decoderow & tif_encoderow are filled
	 *     in at setup time.
	 */
	tif->tif_fixuptags = LogLuvFixupTags;  
	tif->tif_setupdecode = LogLuvSetupDecode;
	tif->tif_decodestrip = LogLuvDecodeStrip;
	tif->tif_decodetile = LogLuvDecodeTile;
	tif->tif_setupencode = LogLuvSetupEncode;
	tif->tif_encodestrip = LogLuvEncodeStrip;  
	tif->tif_encodetile = LogLuvEncodeTile;
	tif->tif_close = LogLuvClose;
	tif->tif_cleanup = LogLuvCleanup;

	/*
	 * Override parent get/set field methods.
	 */
	sp->vgetparent = tif->tif_tagmethods.vgetfield;
	tif->tif_tagmethods.vgetfield = LogLuvVGetField;   /* hook for codec tags */
	sp->vsetparent = tif->tif_tagmethods.vsetfield;
	tif->tif_tagmethods.vsetfield = LogLuvVSetField;   /* hook for codec tags */

	return (1);
bad:
	TIFFErrorExt(tif->tif_clientdata, module,
		     ""%s: No space for LogLuv state block"", tif->tif_name);
	return (0);
}
","TIFFInitSGILog(TIFF* tif, int scheme)
{
	static const char module[] = ""TIFFInitSGILog"";
	LogLuvState* sp;

	assert(scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG);

	/*
	 * Merge codec-specific tag information.
	 */
	if (!_TIFFMergeFields(tif, LogLuvFields,
			      TIFFArrayCount(LogLuvFields))) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Merging SGILog codec-specific tags failed"");
		return 0;
	}

	/*
	 * Allocate state block so tag methods have storage to record values.
	 */
	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LogLuvState));
	if (tif->tif_data == NULL)
		goto bad;
	sp = (LogLuvState*) tif->tif_data;
	_TIFFmemset((void*)sp, 0, sizeof (*sp));
	sp->user_datafmt = SGILOGDATAFMT_UNKNOWN;
	sp->encode_meth = (scheme == COMPRESSION_SGILOG24) ?
	    SGILOGENCODE_RANDITHER : SGILOGENCODE_NODITHER;
	sp->tfunc = _logLuvNop;

	/*
	 * Install codec methods.
	 * NB: tif_decoderow & tif_encoderow are filled
	 *     in at setup time.
	 */
	tif->tif_fixuptags = LogLuvFixupTags;  
	tif->tif_setupdecode = LogLuvSetupDecode;
	tif->tif_decodestrip = LogLuvDecodeStrip;
	tif->tif_decodetile = LogLuvDecodeTile;
	tif->tif_setupencode = LogLuvSetupEncode;
	tif->tif_encodestrip = LogLuvEncodeStrip;  
	tif->tif_encodetile = LogLuvEncodeTile;
	tif->tif_close = LogLuvClose;
	tif->tif_cleanup = LogLuvCleanup;

	/*
	 * Override parent get/set field methods.
	 */
	sp->vgetparent = tif->tif_tagmethods.vgetfield;
	tif->tif_tagmethods.vgetfield = LogLuvVGetField;   /* hook for codec tags */
	sp->vsetparent = tif->tif_tagmethods.vsetfield;
	tif->tif_tagmethods.vsetfield = LogLuvVSetField;   /* hook for codec tags */

	return (1);
bad:
	TIFFErrorExt(tif->tif_clientdata, module,
		     ""%s: No space for LogLuv state block"", tif->tif_name);
	return (0);
}
",C,,,,"@@ -158,6 +158,7 @@
 typedef struct logLuvState LogLuvState;
 
 struct logLuvState {
+        int                     encoder_state;  /* 1 if encoder correctly initialized */
 	int                     user_datafmt;   /* user data format */
 	int                     encode_meth;    /* encoding method */
 	int                     pixel_size;     /* bytes per pixel */
@@ -1552,6 +1553,7 @@ LogLuvSetupEncode(TIFF* tif)
 		    td->td_photometric, ""must be either LogLUV or LogL"");
 		break;
 	}
+	sp->encoder_state = 1;
 	return (1);
 notsupported:
 	TIFFErrorExt(tif->tif_clientdata, module,
@@ -1563,19 +1565,27 @@ LogLuvSetupEncode(TIFF* tif)
 static void
 LogLuvClose(TIFF* tif)
 {
+        LogLuvState* sp = (LogLuvState*) tif->tif_data;
 	TIFFDirectory *td = &tif->tif_dir;
 
+	assert(sp != 0);
 	/*
 	 * For consistency, we always want to write out the same
 	 * bitspersample and sampleformat for our TIFF file,
 	 * regardless of the data format being used by the application.
 	 * Since this routine is called after tags have been set but
 	 * before they have been recorded in the file, we reset them here.
+         * Note: this is really a nasty approach. See PixarLogClose
 	 */
-	td->td_samplesperpixel =
-	    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;
-	td->td_bitspersample = 16;
-	td->td_sampleformat = SAMPLEFORMAT_INT;
+        if( sp->encoder_state )
+        {
+            /* See PixarLogClose. Might avoid issues with tags whose size depends
+             * on those below, but not completely sure this is enough. */
+            td->td_samplesperpixel =
+                (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;
+            td->td_bitspersample = 16;
+            td->td_sampleformat = SAMPLEFORMAT_INT;
+        }
 }
 
 static void",libtiff,1044b43637fa7f70fb19b93593777b78bd20da86,5397a417e61258c69209904e652a1f409ec3b9df,0,"TIFFInitSGILog(TIFF* tif, int scheme)
{
	static const char module[] = ""TIFFInitSGILog"";
	LogLuvState* sp;

	assert(scheme == COMPRESSION_SGILOG24 || scheme == COMPRESSION_SGILOG);

	/*
	 * Merge codec-specific tag information.
	 */
	if (!_TIFFMergeFields(tif, LogLuvFields,
			      TIFFArrayCount(LogLuvFields))) {
		TIFFErrorExt(tif->tif_clientdata, module,
		    ""Merging SGILog codec-specific tags failed"");
		return 0;
	}

	/*
	 * Allocate state block so tag methods have storage to record values.
	 */
	tif->tif_data = (uint8*) _TIFFmalloc(sizeof (LogLuvState));
	if (tif->tif_data == NULL)
		goto bad;
	sp = (LogLuvState*) tif->tif_data;
	_TIFFmemset((void*)sp, 0, sizeof (*sp));
	sp->user_datafmt = SGILOGDATAFMT_UNKNOWN;
	sp->encode_meth = (scheme == COMPRESSION_SGILOG24) ?
	    SGILOGENCODE_RANDITHER : SGILOGENCODE_NODITHER;
	sp->tfunc = _logLuvNop;

	/*
	 * Install codec methods.
	 * NB: tif_decoderow & tif_encoderow are filled
	 *     in at setup time.
	 */
	tif->tif_fixuptags = LogLuvFixupTags;  
	tif->tif_setupdecode = LogLuvSetupDecode;
	tif->tif_decodestrip = LogLuvDecodeStrip;
	tif->tif_decodetile = LogLuvDecodeTile;
	tif->tif_setupencode = LogLuvSetupEncode;
	tif->tif_encodestrip = LogLuvEncodeStrip;  
	tif->tif_encodetile = LogLuvEncodeTile;
	tif->tif_close = LogLuvClose;
	tif->tif_cleanup = LogLuvCleanup;

	/*
	 * Override parent get/set field methods.
	 */
	sp->vgetparent = tif->tif_tagmethods.vgetfield;
	tif->tif_tagmethods.vgetfield = LogLuvVGetField;   /* hook for codec tags */
	sp->vsetparent = tif->tif_tagmethods.vsetfield;
	tif->tif_tagmethods.vsetfield = LogLuvVSetField;   /* hook for codec tags */

	return (1);
bad:
	TIFFErrorExt(tif->tif_clientdata, module,
		     ""%s: No space for LogLuv state block"", tif->tif_name);
	return (0);
}
"
41533,,Local,Not required,Complete,CVE-2015-8543,https://www.cvedetails.com/cve/CVE-2015-8543/,,Medium,Complete,Complete,,2015-12-28,6.9,"The networking implementation in the Linux kernel through 4.3.3, as used in Android and other products, does not validate protocol identifiers for certain protocol families, which allows local users to cause a denial of service (NULL function pointer dereference and system crash) or possibly gain privileges by leveraging CLONE_NEWUSER support to execute a crafted SOCK_RAW application.",2018-01-04,DoS +Priv ,0,https://github.com/torvalds/linux/commit/79462ad02e861803b3840cc782248c7359451cd9,79462ad02e861803b3840cc782248c7359451cd9,"net: add validation for the socket syscall protocol argument

郭永刚 reported that one could simply crash the kernel as root by
using a simple program:

	int socket_fd;
	struct sockaddr_in addr;
	addr.sin_port = 0;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_family = 10;

	socket_fd = socket(10,3,0x40000000);
	connect(socket_fd , &addr,16);

AF_INET, AF_INET6 sockets actually only support 8-bit protocol
identifiers. inet_sock's skc_protocol field thus is sized accordingly,
thus larger protocol identifiers simply cut off the higher bits and
store a zero in the protocol fields.

This could lead to e.g. NULL function pointer because as a result of
the cut off inet_num is zero and we call down to inet_autobind, which
is NULL for raw sockets.

kernel: Call Trace:
kernel:  [<ffffffff816db90e>] ? inet_autobind+0x2e/0x70
kernel:  [<ffffffff816db9a4>] inet_dgram_connect+0x54/0x80
kernel:  [<ffffffff81645069>] SYSC_connect+0xd9/0x110
kernel:  [<ffffffff810ac51b>] ? ptrace_notify+0x5b/0x80
kernel:  [<ffffffff810236d8>] ? syscall_trace_enter_phase2+0x108/0x200
kernel:  [<ffffffff81645e0e>] SyS_connect+0xe/0x10
kernel:  [<ffffffff81779515>] tracesys_phase2+0x84/0x89

I found no particular commit which introduced this problem.

CVE: CVE-2015-8543
Cc: Cong Wang <cwang@twopensource.com>
Reported-by: 郭永刚 <guoyonggang@360.cn>
Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/af_inet.c,"{""sha"": ""c4205e0a3a2d28066c207221eeacb75c6c99eedc"", ""filename"": ""include/net/sock.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/include/net/sock.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/include/net/sock.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/net/sock.h?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -403,6 +403,7 @@ struct sock {\n \t\t\t\tsk_no_check_rx : 1,\n \t\t\t\tsk_userlocks : 4,\n \t\t\t\tsk_protocol  : 8,\n+#define SK_PROTOCOL_MAX U8_MAX\n \t\t\t\tsk_type      : 16;\n \tkmemcheck_bitfield_end(flags);\n \tint\t\t\tsk_wmem_queued;""}<_**next**_>{""sha"": ""fbd0acf80b13236bd8c768bc8bf5d69d6a7e7125"", ""filename"": ""net/ax25/af_ax25.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/net/ax25/af_ax25.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/net/ax25/af_ax25.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ax25/af_ax25.c?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -805,6 +805,9 @@ static int ax25_create(struct net *net, struct socket *sock, int protocol,\n \tstruct sock *sk;\n \tax25_cb *ax25;\n \n+\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n+\t\treturn -EINVAL;\n+\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n ""}<_**next**_>{""sha"": ""13d6b1a6e0fc2b0730827d93d154d6464a3e58ec"", ""filename"": ""net/decnet/af_decnet.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/net/decnet/af_decnet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/net/decnet/af_decnet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/decnet/af_decnet.c?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -678,6 +678,9 @@ static int dn_create(struct net *net, struct socket *sock, int protocol,\n {\n \tstruct sock *sk;\n \n+\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n+\t\treturn -EINVAL;\n+\n \tif (!net_eq(net, &init_net))\n \t\treturn -EAFNOSUPPORT;\n ""}<_**next**_>{""sha"": ""5c5db6636704daa0c49fc13e84b2c5b282a44ed3"", ""filename"": ""net/ipv4/af_inet.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/net/ipv4/af_inet.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/net/ipv4/af_inet.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/af_inet.c?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -257,6 +257,9 @@ static int inet_create(struct net *net, struct socket *sock, int protocol,\n \tint try_loading_module = 0;\n \tint err;\n \n+\tif (protocol < 0 || protocol >= IPPROTO_MAX)\n+\t\treturn -EINVAL;\n+\n \tsock->state = SS_UNCONNECTED;\n \n \t/* Look for the requested type/protocol pair. */""}<_**next**_>{""sha"": ""9f5137cd604e51316c6c3a85ca5423b30ed7ce30"", ""filename"": ""net/ipv6/af_inet6.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/net/ipv6/af_inet6.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/net/ipv6/af_inet6.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/af_inet6.c?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -109,6 +109,9 @@ static int inet6_create(struct net *net, struct socket *sock, int protocol,\n \tint try_loading_module = 0;\n \tint err;\n \n+\tif (protocol < 0 || protocol >= IPPROTO_MAX)\n+\t\treturn -EINVAL;\n+\n \t/* Look for the requested type/protocol pair. */\n lookup_protocol:\n \terr = -ESOCKTNOSUPPORT;""}<_**next**_>{""sha"": ""923abd6b3064074f39f84644b2d3d1f068403f51"", ""filename"": ""net/irda/af_irda.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/79462ad02e861803b3840cc782248c7359451cd9/net/irda/af_irda.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/79462ad02e861803b3840cc782248c7359451cd9/net/irda/af_irda.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/irda/af_irda.c?ref=79462ad02e861803b3840cc782248c7359451cd9"", ""patch"": ""@@ -1086,6 +1086,9 @@ static int irda_create(struct net *net, struct socket *sock, int protocol,\n \tstruct sock *sk;\n \tstruct irda_sock *self;\n \n+\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n+\t\treturn -EINVAL;\n+\n \tif (net != &init_net)\n \t\treturn -EAFNOSUPPORT;\n ""}","static __net_init int inet_init_net(struct net *net)
{
	/*
	 * Set defaults for local port range
	 */
	seqlock_init(&net->ipv4.ip_local_ports.lock);
	net->ipv4.ip_local_ports.range[0] =  32768;
	net->ipv4.ip_local_ports.range[1] =  60999;

	seqlock_init(&net->ipv4.ping_group_range.lock);
	/*
	 * Sane defaults - nobody may create ping sockets.
	 * Boot scripts should set this to distro-specific group.
	 */
	net->ipv4.ping_group_range.range[0] = make_kgid(&init_user_ns, 1);
	net->ipv4.ping_group_range.range[1] = make_kgid(&init_user_ns, 0);
	return 0;
}
","static __net_init int inet_init_net(struct net *net)
{
	/*
	 * Set defaults for local port range
	 */
	seqlock_init(&net->ipv4.ip_local_ports.lock);
	net->ipv4.ip_local_ports.range[0] =  32768;
	net->ipv4.ip_local_ports.range[1] =  60999;

	seqlock_init(&net->ipv4.ping_group_range.lock);
	/*
	 * Sane defaults - nobody may create ping sockets.
	 * Boot scripts should set this to distro-specific group.
	 */
	net->ipv4.ping_group_range.range[0] = make_kgid(&init_user_ns, 1);
	net->ipv4.ping_group_range.range[1] = make_kgid(&init_user_ns, 0);
	return 0;
}
",C,,,,"@@ -257,6 +257,9 @@ static int inet_create(struct net *net, struct socket *sock, int protocol,
 	int try_loading_module = 0;
 	int err;
 
+	if (protocol < 0 || protocol >= IPPROTO_MAX)
+		return -EINVAL;
+
 	sock->state = SS_UNCONNECTED;
 
 	/* Look for the requested type/protocol pair. */",linux,79462ad02e861803b3840cc782248c7359451cd9,20b08e1a793d898f0f13040d5418ee0955f678cf,0,"static __net_init int inet_init_net(struct net *net)
{
	/*
	 * Set defaults for local port range
	 */
	seqlock_init(&net->ipv4.ip_local_ports.lock);
	net->ipv4.ip_local_ports.range[0] =  32768;
	net->ipv4.ip_local_ports.range[1] =  60999;

	seqlock_init(&net->ipv4.ping_group_range.lock);
	/*
	 * Sane defaults - nobody may create ping sockets.
	 * Boot scripts should set this to distro-specific group.
	 */
	net->ipv4.ping_group_range.range[0] = make_kgid(&init_user_ns, 1);
	net->ipv4.ping_group_range.range[1] = make_kgid(&init_user_ns, 0);
	return 0;
}
"
181832,,Local,Not required,,CVE-2016-10011,https://www.cvedetails.com/cve/CVE-2016-10011/,CWE-320,Low,Partial,,,2017-01-04,2.1,"authfile.c in sshd in OpenSSH before 7.4 does not properly consider the effects of realloc on buffer contents, which might allow local users to obtain sensitive private-key information by leveraging access to a privilege-separated child process.",2018-09-11,+Info ,13,https://github.com/openbsd/src/commit/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,"use sshbuf_allocate() to pre-allocate the buffer used for loading
keys. This avoids implicit realloc inside the buffer code, which
might theoretically leave fragments of the key on the heap. This
doesn't appear to happen in practice for normal sized keys, but
was observed for novelty oversize ones.

Pointed out by Jann Horn of Project Zero; ok markus@",1,usr.bin/ssh/authfile.c,"{""sha"": ""ec685544e7bc80db0e49e19fbeba91e1b496f912"", ""filename"": ""usr.bin/ssh/authfile.c"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 2, ""changes"": 16, ""blob_url"": ""https://github.com/openbsd/src/blob/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9/usr.bin/ssh/authfile.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9/usr.bin/ssh/authfile.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/authfile.c?ref=ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: authfile.c,v 1.121 2016/04/09 12:39:30 djm Exp $ */\n+/* $OpenBSD: authfile.c,v 1.122 2016/11/25 23:24:45 djm Exp $ */\n /*\n  * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.\n  *\n@@ -98,13 +98,25 @@ sshkey_load_file(int fd, struct sshbuf *blob)\n \tu_char buf[1024];\n \tsize_t len;\n \tstruct stat st;\n-\tint r;\n+\tint r, dontmax = 0;\n \n \tif (fstat(fd, &st) < 0)\n \t\treturn SSH_ERR_SYSTEM_ERROR;\n \tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n \t    st.st_size > MAX_KEY_FILE_SIZE)\n \t\treturn SSH_ERR_INVALID_FORMAT;\n+\t/*\n+\t * Pre-allocate the buffer used for the key contents and clamp its\n+\t * maximum size. This ensures that key contents are never leaked via\n+\t * implicit realloc() in the sshbuf code.\n+\t */\n+\tif ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {\n+\t\tst.st_size = 64*1024; /* 64k should be enough for anyone :) */\n+\t\tdontmax = 1;\n+\t}\n+\tif ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||\n+\t    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))\n+\t\treturn r;\n \tfor (;;) {\n \t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n \t\t\tif (errno == EPIPE)""}","sshkey_load_file(int fd, struct sshbuf *blob)
{
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
	int r, dontmax = 0;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
	/*
	 * Pre-allocate the buffer used for the key contents and clamp its
	 * maximum size. This ensures that key contents are never leaked via
	 * implicit realloc() in the sshbuf code.
	 */
	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
		dontmax = 1;
	}
	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)
				break;
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}
		if ((r = sshbuf_put(blob, buf, len)) != 0)
			goto out;
		if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size != (off_t)sshbuf_len(blob)) {
		r = SSH_ERR_FILE_CHANGED;
		goto out;
	}
	r = 0;

 out:
	explicit_bzero(buf, sizeof(buf));
	if (r != 0)
		sshbuf_reset(blob);
	return r;
}
","sshkey_load_file(int fd, struct sshbuf *blob)
{
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
	int r;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)
				break;
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}
		if ((r = sshbuf_put(blob, buf, len)) != 0)
			goto out;
		if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size != (off_t)sshbuf_len(blob)) {
		r = SSH_ERR_FILE_CHANGED;
		goto out;
	}
	r = 0;

 out:
	explicit_bzero(buf, sizeof(buf));
	if (r != 0)
		sshbuf_reset(blob);
	return r;
}
",C,"	int r, dontmax = 0;
	/*
	 * Pre-allocate the buffer used for the key contents and clamp its
	 * maximum size. This ensures that key contents are never leaked via
	 * implicit realloc() in the sshbuf code.
	 */
	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
		dontmax = 1;
	}
	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
		return r;
","	int r;
",,"@@ -1,4 +1,4 @@
-/* $OpenBSD: authfile.c,v 1.121 2016/04/09 12:39:30 djm Exp $ */
+/* $OpenBSD: authfile.c,v 1.122 2016/11/25 23:24:45 djm Exp $ */
 /*
  * Copyright (c) 2000, 2013 Markus Friedl.  All rights reserved.
  *
@@ -98,13 +98,25 @@ sshkey_load_file(int fd, struct sshbuf *blob)
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
-	int r;
+	int r, dontmax = 0;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
+	/*
+	 * Pre-allocate the buffer used for the key contents and clamp its
+	 * maximum size. This ensures that key contents are never leaked via
+	 * implicit realloc() in the sshbuf code.
+	 */
+	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
+		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
+		dontmax = 1;
+	}
+	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
+	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
+		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)",src,ac8147a06ed2e2403fb6b9a0c03e618a9333c0e9,66d9cecc96a0968b7e292664dd4ae9918fb04a42,1,"sshkey_load_file(int fd, struct sshbuf *blob)
{
 	u_char buf[1024];
 	size_t len;
 	struct stat st;
//flaw_line_below:
	int r;
//fix_flaw_line_below:
//	int r, dontmax = 0;
 
 	if (fstat(fd, &st) < 0)
 		return SSH_ERR_SYSTEM_ERROR;
 	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
 	    st.st_size > MAX_KEY_FILE_SIZE)
 		return SSH_ERR_INVALID_FORMAT;
//fix_flaw_line_below:
//	/*
//fix_flaw_line_below:
//	 * Pre-allocate the buffer used for the key contents and clamp its
//fix_flaw_line_below:
//	 * maximum size. This ensures that key contents are never leaked via
//fix_flaw_line_below:
//	 * implicit realloc() in the sshbuf code.
//fix_flaw_line_below:
//	 */
//fix_flaw_line_below:
//	if ((st.st_mode & S_IFREG) == 0 || st.st_size <= 0) {
//fix_flaw_line_below:
//		st.st_size = 64*1024; /* 64k should be enough for anyone :) */
//fix_flaw_line_below:
//		dontmax = 1;
//fix_flaw_line_below:
//	}
//fix_flaw_line_below:
//	if ((r = sshbuf_allocate(blob, st.st_size)) != 0 ||
//fix_flaw_line_below:
//	    (dontmax && (r = sshbuf_set_max_size(blob, st.st_size)) != 0))
//fix_flaw_line_below:
//		return r;
 	for (;;) {
 		if ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {
 			if (errno == EPIPE)
				break;
			r = SSH_ERR_SYSTEM_ERROR;
			goto out;
		}
		if ((r = sshbuf_put(blob, buf, len)) != 0)
			goto out;
		if (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {
			r = SSH_ERR_INVALID_FORMAT;
			goto out;
		}
	}
	if ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&
	    st.st_size != (off_t)sshbuf_len(blob)) {
		r = SSH_ERR_FILE_CHANGED;
		goto out;
	}
	r = 0;

 out:
	explicit_bzero(buf, sizeof(buf));
	if (r != 0)
		sshbuf_reset(blob);
	return r;
}
"
182396,,Remote,Not required,Partial,CVE-2018-11381,https://www.cvedetails.com/cve/CVE-2018-11381/,CWE-125,Medium,,,,2018-05-22,4.3,The string_scan_range() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.,2018-06-27,DoS ,5,https://github.com/radare/radare2/commit/3fcf41ed96ffa25b38029449520c8d0a198745f3,3fcf41ed96ffa25b38029449520c8d0a198745f3,Fix #9902 - Fix oobread in RBin.string_scan_range,4,libr/bin/file.c,"{""sha"": ""8538600657e1f780c34bad4cf25f53bafcc47d5f"", ""filename"": ""libr/bin/file.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/radareorg/radare2/blob/3fcf41ed96ffa25b38029449520c8d0a198745f3/libr/bin/file.c"", ""raw_url"": ""https://github.com/radareorg/radare2/raw/3fcf41ed96ffa25b38029449520c8d0a198745f3/libr/bin/file.c"", ""contents_url"": ""https://api.github.com/repos/radareorg/radare2/contents/libr/bin/file.c?ref=3fcf41ed96ffa25b38029449520c8d0a198745f3"", ""patch"": ""@@ -76,11 +76,12 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\teprintf (\""Invalid range to find strings 0x%llx .. 0x%llx\\n\"", from, to);\n \t\treturn -1;\n \t}\n-\tut8 *buf = calloc (to - from, 1);\n+\tint len = to - from;\n+\tut8 *buf = calloc (len, 1);\n \tif (!buf || !min) {\n \t\treturn -1;\n \t}\n-\tr_buf_read_at (bf->buf, from, buf, to - from);\n+\tr_buf_read_at (bf->buf, from, buf, len);\n \t// may oobread\n \twhile (needle < to) {\n \t\trc = r_utf8_decode (buf + needle - from, to - needle, NULL);\n@@ -90,8 +91,8 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,\n \t\t}\n \t\tif (type == R_STRING_TYPE_DETECT) {\n \t\t\tchar *w = (char *)buf + needle + rc - from;\n-\t\t\tif ((to - needle) > 5) {\n-\t\t\t\tbool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];\n+\t\t\tif ((to - needle) > 5 + rc) {\n+\t\t\t\tbool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);\n \t\t\t\tif (is_wide32) {\n \t\t\t\t\tstr_type = R_STRING_TYPE_WIDE32;\n \t\t\t\t} else {""}","static int string_scan_range(RList *list, RBinFile *bf, int min,
			      const ut64 from, const ut64 to, int type) {
	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
	ut64 str_start, needle = from;
	int count = 0, i, rc, runes;
	int str_type = R_STRING_TYPE_DETECT;

	if (type == -1) {
		type = R_STRING_TYPE_DETECT;
	}
	if (from >= to) {
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
	int len = to - from;
	ut8 *buf = calloc (len, 1);
 	if (!buf || !min) {
 		return -1;
 	}
	r_buf_read_at (bf->buf, from, buf, len);
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
		if (!rc) {
			needle++;
			continue;
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
			if ((to - needle) > 5 + rc) {
				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {
					bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} else {
				str_type = R_STRING_TYPE_ASCII;
			}
		} else {
			str_type = type;
		}
		runes = 0;
		str_start = needle;

		/* Eat a whole C string */
		for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
			RRune r = {0};

			if (str_type == R_STRING_TYPE_WIDE32) {
				rc = r_utf32le_decode (buf + needle - from, to - needle, &r);
				if (rc) {
					rc = 4;
				}
			} else if (str_type == R_STRING_TYPE_WIDE) {
				rc = r_utf16le_decode (buf + needle - from, to - needle, &r);
				if (rc == 1) {
					rc = 2;
				}
			} else {
				rc = r_utf8_decode (buf + needle - from, to - needle, &r);
				if (rc > 1) {
					str_type = R_STRING_TYPE_UTF8;
				}
			}

			/* Invalid sequence detected */
			if (!rc) {
				needle++;
				break;
			}

			needle += rc;

			if (r_isprint (r) && r != '\\') {
				if (str_type == R_STRING_TYPE_WIDE32) {
					if (r == 0xff) {
						r = 0;
					}
				}
				rc = r_utf8_encode (&tmp[i], r);
				runes++;
				/* Print the escape code */
			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) {
				if ((i + 32) < sizeof (tmp) && r < 93) {
					tmp[i + 0] = '\\';
					tmp[i + 1] = ""       abtnvfr             e  ""
					             ""                              ""
					             ""                              ""
					             ""  \\""[r];
				} else {
					break;
				}
				rc = 2;
				runes++;
			} else {
				/* \0 marks the end of C-strings */
				break;
			}
		}

		tmp[i++] = '\0';

		if (runes >= min) {
			if (str_type == R_STRING_TYPE_ASCII) {
				int j;
				for (j = 0; j < i; j++) {
					char ch = tmp[j];
					if (ch != '\n' && ch != '\r' && ch != '\t') {
						if (!IS_PRINTABLE (tmp[j])) {
							continue;
						}
					}
				}
			}
			RBinString *bs = R_NEW0 (RBinString);
			if (!bs) {
				break;
			}
			bs->type = str_type;
			bs->length = runes;
			bs->size = needle - str_start;
			bs->ordinal = count++;
			switch (str_type) {
			case R_STRING_TYPE_WIDE:
				if (str_start -from> 1) {
					const ut8 *p = buf + str_start - 2 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 2; // \xff\xfe
					}
				}
				break;
			case R_STRING_TYPE_WIDE32:
				if (str_start -from> 3) {
					const ut8 *p = buf + str_start - 4 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 4; // \xff\xfe\x00\x00
					}
				}
				break;
			}
			bs->paddr = bs->vaddr = str_start;
			bs->string = r_str_ndup ((const char *)tmp, i);
			if (list) {
				r_list_append (list, bs);
			} else {
				print_string (bs, bf);
				r_bin_string_free (bs);
			}
		}
	}
	free (buf);
	return count;
}
","static int string_scan_range(RList *list, RBinFile *bf, int min,
			      const ut64 from, const ut64 to, int type) {
	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
	ut64 str_start, needle = from;
	int count = 0, i, rc, runes;
	int str_type = R_STRING_TYPE_DETECT;

	if (type == -1) {
		type = R_STRING_TYPE_DETECT;
	}
	if (from >= to) {
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
	ut8 *buf = calloc (to - from, 1);
 	if (!buf || !min) {
 		return -1;
 	}
	r_buf_read_at (bf->buf, from, buf, to - from);
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
		if (!rc) {
			needle++;
			continue;
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
			if ((to - needle) > 5) {
				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {
					bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} else {
				str_type = R_STRING_TYPE_ASCII;
			}
		} else {
			str_type = type;
		}
		runes = 0;
		str_start = needle;

		/* Eat a whole C string */
		for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
			RRune r = {0};

			if (str_type == R_STRING_TYPE_WIDE32) {
				rc = r_utf32le_decode (buf + needle - from, to - needle, &r);
				if (rc) {
					rc = 4;
				}
			} else if (str_type == R_STRING_TYPE_WIDE) {
				rc = r_utf16le_decode (buf + needle - from, to - needle, &r);
				if (rc == 1) {
					rc = 2;
				}
			} else {
				rc = r_utf8_decode (buf + needle - from, to - needle, &r);
				if (rc > 1) {
					str_type = R_STRING_TYPE_UTF8;
				}
			}

			/* Invalid sequence detected */
			if (!rc) {
				needle++;
				break;
			}

			needle += rc;

			if (r_isprint (r) && r != '\\') {
				if (str_type == R_STRING_TYPE_WIDE32) {
					if (r == 0xff) {
						r = 0;
					}
				}
				rc = r_utf8_encode (&tmp[i], r);
				runes++;
				/* Print the escape code */
			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) {
				if ((i + 32) < sizeof (tmp) && r < 93) {
					tmp[i + 0] = '\\';
					tmp[i + 1] = ""       abtnvfr             e  ""
					             ""                              ""
					             ""                              ""
					             ""  \\""[r];
				} else {
					break;
				}
				rc = 2;
				runes++;
			} else {
				/* \0 marks the end of C-strings */
				break;
			}
		}

		tmp[i++] = '\0';

		if (runes >= min) {
			if (str_type == R_STRING_TYPE_ASCII) {
				int j;
				for (j = 0; j < i; j++) {
					char ch = tmp[j];
					if (ch != '\n' && ch != '\r' && ch != '\t') {
						if (!IS_PRINTABLE (tmp[j])) {
							continue;
						}
					}
				}
			}
			RBinString *bs = R_NEW0 (RBinString);
			if (!bs) {
				break;
			}
			bs->type = str_type;
			bs->length = runes;
			bs->size = needle - str_start;
			bs->ordinal = count++;
			switch (str_type) {
			case R_STRING_TYPE_WIDE:
				if (str_start -from> 1) {
					const ut8 *p = buf + str_start - 2 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 2; // \xff\xfe
					}
				}
				break;
			case R_STRING_TYPE_WIDE32:
				if (str_start -from> 3) {
					const ut8 *p = buf + str_start - 4 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 4; // \xff\xfe\x00\x00
					}
				}
				break;
			}
			bs->paddr = bs->vaddr = str_start;
			bs->string = r_str_ndup ((const char *)tmp, i);
			if (list) {
				r_list_append (list, bs);
			} else {
				print_string (bs, bf);
				r_bin_string_free (bs);
			}
		}
	}
	free (buf);
	return count;
}
",C,"	int len = to - from;
	ut8 *buf = calloc (len, 1);
	r_buf_read_at (bf->buf, from, buf, len);
			if ((to - needle) > 5 + rc) {
				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
","	ut8 *buf = calloc (to - from, 1);
	r_buf_read_at (bf->buf, from, buf, to - from);
			if ((to - needle) > 5) {
				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
",,"@@ -76,11 +76,12 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
-	ut8 *buf = calloc (to - from, 1);
+	int len = to - from;
+	ut8 *buf = calloc (len, 1);
 	if (!buf || !min) {
 		return -1;
 	}
-	r_buf_read_at (bf->buf, from, buf, to - from);
+	r_buf_read_at (bf->buf, from, buf, len);
 	// may oobread
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
@@ -90,8 +91,8 @@ static int string_scan_range(RList *list, RBinFile *bf, int min,
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
-			if ((to - needle) > 5) {
-				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
+			if ((to - needle) > 5 + rc) {
+				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {",radare2,3fcf41ed96ffa25b38029449520c8d0a198745f3,77c47cf873dd55b396da60baa2ca83bbd39e4add,1,"static int string_scan_range(RList *list, RBinFile *bf, int min,
			      const ut64 from, const ut64 to, int type) {
	ut8 tmp[R_STRING_SCAN_BUFFER_SIZE];
	ut64 str_start, needle = from;
	int count = 0, i, rc, runes;
	int str_type = R_STRING_TYPE_DETECT;

	if (type == -1) {
		type = R_STRING_TYPE_DETECT;
	}
	if (from >= to) {
 		eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to);
 		return -1;
 	}
//flaw_line_below:
	ut8 *buf = calloc (to - from, 1);
//fix_flaw_line_below:
//	int len = to - from;
//fix_flaw_line_below:
//	ut8 *buf = calloc (len, 1);
 	if (!buf || !min) {
 		return -1;
 	}
//flaw_line_below:
	r_buf_read_at (bf->buf, from, buf, to - from);
//fix_flaw_line_below:
//	r_buf_read_at (bf->buf, from, buf, len);
 	// may oobread
 	while (needle < to) {
 		rc = r_utf8_decode (buf + needle - from, to - needle, NULL);
		if (!rc) {
			needle++;
			continue;
 		}
 		if (type == R_STRING_TYPE_DETECT) {
 			char *w = (char *)buf + needle + rc - from;
//flaw_line_below:
			if ((to - needle) > 5) {
//flaw_line_below:
				bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4];
//fix_flaw_line_below:
//			if ((to - needle) > 5 + rc) {
//fix_flaw_line_below:
//				bool is_wide32 = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]);
 				if (is_wide32) {
 					str_type = R_STRING_TYPE_WIDE32;
 				} else {
					bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2];
					str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII;
				}
			} else {
				str_type = R_STRING_TYPE_ASCII;
			}
		} else {
			str_type = type;
		}
		runes = 0;
		str_start = needle;

		/* Eat a whole C string */
		for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) {
			RRune r = {0};

			if (str_type == R_STRING_TYPE_WIDE32) {
				rc = r_utf32le_decode (buf + needle - from, to - needle, &r);
				if (rc) {
					rc = 4;
				}
			} else if (str_type == R_STRING_TYPE_WIDE) {
				rc = r_utf16le_decode (buf + needle - from, to - needle, &r);
				if (rc == 1) {
					rc = 2;
				}
			} else {
				rc = r_utf8_decode (buf + needle - from, to - needle, &r);
				if (rc > 1) {
					str_type = R_STRING_TYPE_UTF8;
				}
			}

			/* Invalid sequence detected */
			if (!rc) {
				needle++;
				break;
			}

			needle += rc;

			if (r_isprint (r) && r != '\\') {
				if (str_type == R_STRING_TYPE_WIDE32) {
					if (r == 0xff) {
						r = 0;
					}
				}
				rc = r_utf8_encode (&tmp[i], r);
				runes++;
				/* Print the escape code */
			} else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) {
				if ((i + 32) < sizeof (tmp) && r < 93) {
					tmp[i + 0] = '\\';
					tmp[i + 1] = ""       abtnvfr             e  ""
					             ""                              ""
					             ""                              ""
					             ""  \\""[r];
				} else {
					// string too long
					break;
				}
				rc = 2;
				runes++;
			} else {
				/* \0 marks the end of C-strings */
				break;
			}
		}

		tmp[i++] = '\0';

		if (runes >= min) {
			if (str_type == R_STRING_TYPE_ASCII) {
				// reduce false positives
				int j;
				for (j = 0; j < i; j++) {
					char ch = tmp[j];
					if (ch != '\n' && ch != '\r' && ch != '\t') {
						if (!IS_PRINTABLE (tmp[j])) {
							continue;
						}
					}
				}
			}
			RBinString *bs = R_NEW0 (RBinString);
			if (!bs) {
				break;
			}
			bs->type = str_type;
			bs->length = runes;
			bs->size = needle - str_start;
			bs->ordinal = count++;
			// TODO: move into adjust_offset
			switch (str_type) {
			case R_STRING_TYPE_WIDE:
				if (str_start -from> 1) {
					const ut8 *p = buf + str_start - 2 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 2; // \xff\xfe
					}
				}
				break;
			case R_STRING_TYPE_WIDE32:
				if (str_start -from> 3) {
					const ut8 *p = buf + str_start - 4 - from;
					if (p[0] == 0xff && p[1] == 0xfe) {
						str_start -= 4; // \xff\xfe\x00\x00
					}
				}
				break;
			}
			bs->paddr = bs->vaddr = str_start;
			bs->string = r_str_ndup ((const char *)tmp, i);
			if (list) {
				r_list_append (list, bs);
			} else {
				print_string (bs, bf);
				r_bin_string_free (bs);
			}
		}
	}
	free (buf);
	return count;
}
"
79733,,Remote,Not required,Partial,CVE-2018-13785,https://www.cvedetails.com/cve/CVE-2018-13785/,CWE-190,Medium,,,,2018-07-09,4.3,"In libpng 1.6.34, a wrong calculation of row_factor in the png_check_chunk_length function (pngrutil.c) may trigger an integer overflow and resultant divide-by-zero while processing a crafted PNG file, leading to a denial of service.",2019-08-15,DoS Overflow ,0,https://github.com/glennrp/libpng/commit/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2,8a05766cb74af05c04c53e6c9d60c13fc4d59bf2,"[libpng16] Fix the calculation of row_factor in png_check_chunk_length

(Bug report by Thuan Pham, SourceForge issue #278)",0,pngrutil.c,"{""sha"": ""5ba995abf949846d99b09fdf153e9ca387e8c7fb"", ""filename"": ""pngrutil.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/glennrp/libpng/blob/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2/pngrutil.c"", ""raw_url"": ""https://github.com/glennrp/libpng/raw/8a05766cb74af05c04c53e6c9d60c13fc4d59bf2/pngrutil.c"", ""contents_url"": ""https://api.github.com/repos/glennrp/libpng/contents/pngrutil.c?ref=8a05766cb74af05c04c53e6c9d60c13fc4d59bf2"", ""patch"": ""@@ -3167,10 +3167,13 @@ png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n    {\n       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n       size_t row_factor =\n-         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n-          + 1 + (png_ptr->interlaced? 6: 0));\n+         (size_t)png_ptr->width\n+         * (size_t)png_ptr->channels\n+         * (png_ptr->bit_depth > 8? 2: 1)\n+         + 1\n+         + (png_ptr->interlaced? 6: 0);\n       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n-         idat_limit=PNG_UINT_31_MAX;\n+         idat_limit = PNG_UINT_31_MAX;\n       else\n          idat_limit = png_ptr->height * row_factor;\n       row_factor = row_factor > 32566? 32566 : row_factor;""}","png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int i;

   png_debug(1, ""in png_handle_eXIf"");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, ""missing IHDR"");

   if (length < 2)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""too short"");
      return;
   }

   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""duplicate"");
      return;
   }

   info_ptr->free_me |= PNG_FREE_EXIF;

   info_ptr->eXIf_buf = png_voidcast(png_bytep,
             png_malloc_warn(png_ptr, length));

   if (info_ptr->eXIf_buf == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""out of memory"");
      return;
   }

   for (i = 0; i < length; i++)
   {
      png_byte buf[1];
      png_crc_read(png_ptr, buf, 1);
      info_ptr->eXIf_buf[i] = buf[0];
      if (i == 1 && buf[0] != 'M' && buf[0] != 'I'
                 && info_ptr->eXIf_buf[0] != buf[0])
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, ""incorrect byte-order specifier"");
         png_free(png_ptr, info_ptr->eXIf_buf);
         info_ptr->eXIf_buf = NULL;
         return;
      }
   }

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);

   png_free(png_ptr, info_ptr->eXIf_buf);
   info_ptr->eXIf_buf = NULL;
}
","png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int i;

   png_debug(1, ""in png_handle_eXIf"");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, ""missing IHDR"");

   if (length < 2)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""too short"");
      return;
   }

   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""duplicate"");
      return;
   }

   info_ptr->free_me |= PNG_FREE_EXIF;

   info_ptr->eXIf_buf = png_voidcast(png_bytep,
             png_malloc_warn(png_ptr, length));

   if (info_ptr->eXIf_buf == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""out of memory"");
      return;
   }

   for (i = 0; i < length; i++)
   {
      png_byte buf[1];
      png_crc_read(png_ptr, buf, 1);
      info_ptr->eXIf_buf[i] = buf[0];
      if (i == 1 && buf[0] != 'M' && buf[0] != 'I'
                 && info_ptr->eXIf_buf[0] != buf[0])
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, ""incorrect byte-order specifier"");
         png_free(png_ptr, info_ptr->eXIf_buf);
         info_ptr->eXIf_buf = NULL;
         return;
      }
   }

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);

   png_free(png_ptr, info_ptr->eXIf_buf);
   info_ptr->eXIf_buf = NULL;
}
",C,,,,"@@ -3167,10 +3167,13 @@ png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)
    {
       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
       size_t row_factor =
-         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)
-          + 1 + (png_ptr->interlaced? 6: 0));
+         (size_t)png_ptr->width
+         * (size_t)png_ptr->channels
+         * (png_ptr->bit_depth > 8? 2: 1)
+         + 1
+         + (png_ptr->interlaced? 6: 0);
       if (png_ptr->height > PNG_UINT_32_MAX/row_factor)
-         idat_limit=PNG_UINT_31_MAX;
+         idat_limit = PNG_UINT_31_MAX;
       else
          idat_limit = png_ptr->height * row_factor;
       row_factor = row_factor > 32566? 32566 : row_factor;",libpng,8a05766cb74af05c04c53e6c9d60c13fc4d59bf2,a74aa9a0028a8e746ec5646a3d3ee1c659f0af8a,0,"png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
{
   unsigned int i;

   png_debug(1, ""in png_handle_eXIf"");

   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)
      png_chunk_error(png_ptr, ""missing IHDR"");

   if (length < 2)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""too short"");
      return;
   }

   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""duplicate"");
      return;
   }

   info_ptr->free_me |= PNG_FREE_EXIF;

   info_ptr->eXIf_buf = png_voidcast(png_bytep,
             png_malloc_warn(png_ptr, length));

   if (info_ptr->eXIf_buf == NULL)
   {
      png_crc_finish(png_ptr, length);
      png_chunk_benign_error(png_ptr, ""out of memory"");
      return;
   }

   for (i = 0; i < length; i++)
   {
      png_byte buf[1];
      png_crc_read(png_ptr, buf, 1);
      info_ptr->eXIf_buf[i] = buf[0];
      if (i == 1 && buf[0] != 'M' && buf[0] != 'I'
                 && info_ptr->eXIf_buf[0] != buf[0])
      {
         png_crc_finish(png_ptr, length);
         png_chunk_benign_error(png_ptr, ""incorrect byte-order specifier"");
         png_free(png_ptr, info_ptr->eXIf_buf);
         info_ptr->eXIf_buf = NULL;
         return;
      }
   }

   if (png_crc_finish(png_ptr, 0) != 0)
      return;

   png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);

   png_free(png_ptr, info_ptr->eXIf_buf);
   info_ptr->eXIf_buf = NULL;
}
"
136535,,Remote,Not required,Complete,CVE-2015-6787,https://www.cvedetails.com/cve/CVE-2015-6787/,,Low,Complete,Complete,,2015-12-05,10.0,Multiple unspecified vulnerabilities in Google Chrome before 47.0.2526.73 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.,2017-09-13,DoS ,0,https://github.com/chromium/chromium/commit/f911e11e7f6b5c0d6f5ee694a9871de6619889f7,f911e11e7f6b5c0d6f5ee694a9871de6619889f7,"Reland ""[CI] Make paint property nodes non-ref-counted""

This reverts commit 887383b30842d9d9006e11bb6932660a3cb5b1b7.

Reason for revert: Retry in M69.

Original change's description:
> Revert ""[CI] Make paint property nodes non-ref-counted""
>
> This reverts commit 70fc0b018c9517558b7aa2be00edf2debb449123.
>
> Reason for revert: Caused bugs found by clusterfuzz
>
> Original change's description:
> > [CI] Make paint property nodes non-ref-counted
> >
> > Now all paint property nodes are owned by ObjectPaintProperties
> > (and LocalFrameView temporarily before removing non-RLS mode).
> > Others just use raw pointers or references.
> >
> > Bug: 833496
> > Cq-Include-Trybots: master.tryserver.blink:linux_trusty_blink_rel;master.tryserver.chromium.linux:linux_layout_tests_slimming_paint_v2
> > Change-Id: I2d544fe153bb94698623248748df63c8aa2081ae
> > Reviewed-on: https://chromium-review.googlesource.com/1031101
> > Reviewed-by: Tien-Ren Chen <trchen@chromium.org>
> > Commit-Queue: Xianzhu Wang <wangxianzhu@chromium.org>
> > Cr-Commit-Position: refs/heads/master@{#554626}
>
> TBR=wangxianzhu@chromium.org,trchen@chromium.org,chrishtr@chromium.org
>
> Change-Id: I02bb50d6744cb81a797246a0116b677e80a3c69f
> No-Presubmit: true
> No-Tree-Checks: true
> No-Try: true
> Bug: 833496,837932,837943
> Cq-Include-Trybots: master.tryserver.blink:linux_trusty_blink_rel;master.tryserver.chromium.linux:linux_layout_tests_slimming_paint_v2
> Reviewed-on: https://chromium-review.googlesource.com/1034292
> Reviewed-by: Xianzhu Wang <wangxianzhu@chromium.org>
> Commit-Queue: Xianzhu Wang <wangxianzhu@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#554653}

TBR=wangxianzhu@chromium.org,trchen@chromium.org,chrishtr@chromium.org

# Not skipping CQ checks because original CL landed > 1 day ago.

Bug: 833496, 837932, 837943
Change-Id: I0b4ef70db1f1f211ba97c30d617225355c750992
Cq-Include-Trybots: master.tryserver.blink:linux_trusty_blink_rel;master.tryserver.chromium.linux:linux_layout_tests_slimming_paint_v2
Reviewed-on: https://chromium-review.googlesource.com/1083491
Commit-Queue: Xianzhu Wang <wangxianzhu@chromium.org>
Reviewed-by: Xianzhu Wang <wangxianzhu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#563930}",0,third_party/blink/renderer/platform/graphics/paint/paint_controller.cc,"{""sha"": ""6da131da4ecafb786c67365ccc6cd446111933b4"", ""filename"": ""third_party/blink/renderer/core/paint/block_painter.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/block_painter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/block_painter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/block_painter.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -196,7 +196,7 @@ void BlockPainter::PaintScrollHitTestDisplayItem(const PaintInfo& paint_info) {\n         DisplayItem::kScrollHitTest);\n     ScrollHitTestDisplayItem::Record(paint_info.context, layout_block_,\n                                      DisplayItem::kScrollHitTest,\n-                                     properties->ScrollTranslation());\n+                                     *properties->ScrollTranslation());\n   }\n }\n ""}<_**next**_>{""sha"": ""e8101ec0800dbffd8f12b387201b82eed2324d0e"", ""filename"": ""third_party/blink/renderer/core/paint/compositing/compositing_layer_property_updater.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/compositing/compositing_layer_property_updater.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/compositing/compositing_layer_property_updater.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/compositing/compositing_layer_property_updater.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -139,7 +139,7 @@ void CompositingLayerPropertyUpdater::Update(const LayoutObject& object) {\n     state.SetClip(\n         clipping_container\n             ? clipping_container->FirstFragment().ContentsProperties().Clip()\n-            : ClipPaintPropertyNode::Root());\n+            : &ClipPaintPropertyNode::Root());\n     squashing_layer->SetLayerState(\n         state,\n         snapped_paint_offset + mapping->SquashingLayerOffsetFromLayoutObject());""}<_**next**_>{""sha"": ""b319147613465bbc820283e2e4d2b2a168beb2cf"", ""filename"": ""third_party/blink/renderer/core/paint/find_paint_offset_and_visual_rect_needing_update.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/find_paint_offset_and_visual_rect_needing_update.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/find_paint_offset_and_visual_rect_needing_update.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/find_paint_offset_and_visual_rect_needing_update.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -56,7 +56,7 @@ class FindPaintOffsetNeedingUpdateScope {\n   const FragmentData& fragment_data_;\n   const bool& is_actually_needed_;\n   LayoutPoint old_paint_offset_;\n-  scoped_refptr<const TransformPaintPropertyNode> old_paint_offset_translation_;\n+  std::unique_ptr<TransformPaintPropertyNode> old_paint_offset_translation_;\n };\n \n class FindVisualRectNeedingUpdateScopeBase {""}<_**next**_>{""sha"": ""ea2a2d7c7ffefaefeb89190f9d20d6d44b4b7fee"", ""filename"": ""third_party/blink/renderer/core/paint/fragment_data.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/fragment_data.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/fragment_data.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/fragment_data.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -7,7 +7,7 @@\n \n #include \""base/optional.h\""\n #include \""third_party/blink/renderer/core/paint/object_paint_properties.h\""\n-#include \""third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h\""\n+#include \""third_party/blink/renderer/platform/graphics/paint/property_tree_state.h\""\n \n namespace blink {\n \n@@ -147,9 +147,9 @@ class CORE_EXPORT FragmentData {\n   //   node. Even though the div has no transform, its local border box\n   //   properties would have a transform node that points to the div's\n   //   ancestor transform space.\n-  PropertyTreeState LocalBorderBoxProperties() const {\n+  const PropertyTreeState& LocalBorderBoxProperties() const {\n     DCHECK(HasLocalBorderBoxProperties());\n-    return rare_data_->local_border_box_properties->GetPropertyTreeState();\n+    return *rare_data_->local_border_box_properties;\n   }\n   bool HasLocalBorderBoxProperties() const {\n     return rare_data_ && rare_data_->local_border_box_properties;\n@@ -162,9 +162,9 @@ class CORE_EXPORT FragmentData {\n     EnsureRareData();\n     if (!rare_data_->local_border_box_properties) {\n       rare_data_->local_border_box_properties =\n-          std::make_unique<RefCountedPropertyTreeState>(state);\n+          std::make_unique<PropertyTreeState>(state);\n     } else {\n-      *rare_data_->local_border_box_properties = std::move(state);\n+      *rare_data_->local_border_box_properties = state;\n     }\n   }\n \n@@ -226,7 +226,7 @@ class CORE_EXPORT FragmentData {\n     LayoutPoint pagination_offset;\n     LayoutUnit logical_top_in_flow_thread;\n     std::unique_ptr<ObjectPaintProperties> paint_properties;\n-    std::unique_ptr<RefCountedPropertyTreeState> local_border_box_properties;\n+    std::unique_ptr<PropertyTreeState> local_border_box_properties;\n     bool is_clip_path_cache_valid = false;\n     base::Optional<IntRect> clip_path_bounding_box;\n     scoped_refptr<const RefCountedPath> clip_path_path;""}<_**next**_>{""sha"": ""c0bc1624220abc06d98f7f08a1f3ce0ccaac8628"", ""filename"": ""third_party/blink/renderer/core/paint/object_paint_properties.h"", ""status"": ""modified"", ""additions"": 66, ""deletions"": 75, ""changes"": 141, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/object_paint_properties.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/object_paint_properties.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/object_paint_properties.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -188,98 +188,88 @@ class CORE_EXPORT ObjectPaintProperties {\n   };\n \n   UpdateResult UpdatePaintOffsetTranslation(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n+      const TransformPaintPropertyNode& parent,\n       TransformPaintPropertyNode::State&& state) {\n-    return Update(paint_offset_translation_, std::move(parent),\n-                  std::move(state));\n+    return Update(paint_offset_translation_, parent, std::move(state));\n   }\n-  UpdateResult UpdateTransform(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n-      TransformPaintPropertyNode::State&& state) {\n-    return Update(transform_, std::move(parent), std::move(state));\n+  UpdateResult UpdateTransform(const TransformPaintPropertyNode& parent,\n+                               TransformPaintPropertyNode::State&& state) {\n+    return Update(transform_, parent, std::move(state));\n   }\n-  UpdateResult UpdatePerspective(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n-      TransformPaintPropertyNode::State&& state) {\n-    return Update(perspective_, std::move(parent), std::move(state));\n+  UpdateResult UpdatePerspective(const TransformPaintPropertyNode& parent,\n+                                 TransformPaintPropertyNode::State&& state) {\n+    return Update(perspective_, parent, std::move(state));\n   }\n   UpdateResult UpdateSvgLocalToBorderBoxTransform(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n+      const TransformPaintPropertyNode& parent,\n       TransformPaintPropertyNode::State&& state) {\n     DCHECK(!ScrollTranslation()) << \""SVG elements cannot scroll so there \""\n                                     \""should never be both a scroll translation \""\n                                     \""and an SVG local to border box transform.\"";\n-    return Update(svg_local_to_border_box_transform_, std::move(parent),\n-                  std::move(state));\n+    return Update(svg_local_to_border_box_transform_, parent, std::move(state));\n   }\n-  UpdateResult UpdateScroll(scoped_refptr<const ScrollPaintPropertyNode> parent,\n+  UpdateResult UpdateScroll(const ScrollPaintPropertyNode& parent,\n                             ScrollPaintPropertyNode::State&& state) {\n-    return Update(scroll_, std::move(parent), std::move(state));\n+    return Update(scroll_, parent, std::move(state));\n   }\n   UpdateResult UpdateScrollTranslation(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n+      const TransformPaintPropertyNode& parent,\n       TransformPaintPropertyNode::State&& state) {\n     DCHECK(!SvgLocalToBorderBoxTransform())\n         << \""SVG elements cannot scroll so there should never be both a scroll \""\n            \""translation and an SVG local to border box transform.\"";\n-    return Update(scroll_translation_, std::move(parent), std::move(state));\n+    return Update(scroll_translation_, parent, std::move(state));\n   }\n-  UpdateResult UpdateEffect(scoped_refptr<const EffectPaintPropertyNode> parent,\n+  UpdateResult UpdateEffect(const EffectPaintPropertyNode& parent,\n                             EffectPaintPropertyNode::State&& state) {\n-    return Update(effect_, std::move(parent), std::move(state));\n+    return Update(effect_, parent, std::move(state));\n   }\n-  UpdateResult UpdateFilter(scoped_refptr<const EffectPaintPropertyNode> parent,\n+  UpdateResult UpdateFilter(const EffectPaintPropertyNode& parent,\n                             EffectPaintPropertyNode::State&& state) {\n-    return Update(filter_, std::move(parent), std::move(state));\n+    return Update(filter_, parent, std::move(state));\n   }\n-  UpdateResult UpdateMask(scoped_refptr<const EffectPaintPropertyNode> parent,\n+  UpdateResult UpdateMask(const EffectPaintPropertyNode& parent,\n                           EffectPaintPropertyNode::State&& state) {\n-    return Update(mask_, std::move(parent), std::move(state));\n+    return Update(mask_, parent, std::move(state));\n   }\n-  UpdateResult UpdateClipPath(\n-      scoped_refptr<const EffectPaintPropertyNode> parent,\n-      EffectPaintPropertyNode::State&& state) {\n-    return Update(clip_path_, std::move(parent), std::move(state));\n+  UpdateResult UpdateClipPath(const EffectPaintPropertyNode& parent,\n+                              EffectPaintPropertyNode::State&& state) {\n+    return Update(clip_path_, parent, std::move(state));\n   }\n-  UpdateResult UpdateFragmentClip(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n-      ClipPaintPropertyNode::State&& state) {\n-    return Update(fragment_clip_, std::move(parent), std::move(state));\n+  UpdateResult UpdateFragmentClip(const ClipPaintPropertyNode& parent,\n+                                  ClipPaintPropertyNode::State&& state) {\n+    return Update(fragment_clip_, parent, std::move(state));\n   }\n-  UpdateResult UpdateClipPathClip(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n-      ClipPaintPropertyNode::State&& state) {\n-    return Update(clip_path_clip_, std::move(parent), std::move(state));\n+  UpdateResult UpdateClipPathClip(const ClipPaintPropertyNode& parent,\n+                                  ClipPaintPropertyNode::State&& state) {\n+    return Update(clip_path_clip_, parent, std::move(state));\n   }\n-  UpdateResult UpdateMaskClip(scoped_refptr<const ClipPaintPropertyNode> parent,\n+  UpdateResult UpdateMaskClip(const ClipPaintPropertyNode& parent,\n                               ClipPaintPropertyNode::State&& state) {\n-    return Update(mask_clip_, std::move(parent), std::move(state));\n+    return Update(mask_clip_, parent, std::move(state));\n   }\n-  UpdateResult UpdateCssClip(scoped_refptr<const ClipPaintPropertyNode> parent,\n+  UpdateResult UpdateCssClip(const ClipPaintPropertyNode& parent,\n                              ClipPaintPropertyNode::State&& state) {\n-    return Update(css_clip_, std::move(parent), std::move(state));\n+    return Update(css_clip_, parent, std::move(state));\n   }\n   UpdateResult UpdateCssClipFixedPosition(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n+      const ClipPaintPropertyNode& parent,\n       ClipPaintPropertyNode::State&& state) {\n-    return Update(css_clip_fixed_position_, std::move(parent),\n-                  std::move(state));\n+    return Update(css_clip_fixed_position_, parent, std::move(state));\n   }\n   UpdateResult UpdateOverflowControlsClip(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n+      const ClipPaintPropertyNode& parent,\n       ClipPaintPropertyNode::State&& state) {\n-    return Update(overflow_controls_clip_, std::move(parent), std::move(state));\n+    return Update(overflow_controls_clip_, parent, std::move(state));\n   }\n   UpdateResult UpdateInnerBorderRadiusClip(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n+      const ClipPaintPropertyNode& parent,\n       ClipPaintPropertyNode::State&& state) {\n-    return Update(inner_border_radius_clip_, std::move(parent),\n-                  std::move(state));\n+    return Update(inner_border_radius_clip_, parent, std::move(state));\n   }\n-  UpdateResult UpdateOverflowClip(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n-      ClipPaintPropertyNode::State&& state) {\n-    return Update(overflow_clip_, std::move(parent), std::move(state));\n+  UpdateResult UpdateOverflowClip(const ClipPaintPropertyNode& parent,\n+                                  ClipPaintPropertyNode::State&& state) {\n+    return Update(overflow_clip_, parent, std::move(state));\n   }\n \n #if DCHECK_IS_ON()\n@@ -335,7 +325,7 @@ class CORE_EXPORT ObjectPaintProperties {\n   // deleted), and false otherwise. See the class-level comment (\""update & clear\n   // implementation note\"") for details about why this is needed for efficiency.\n   template <typename PaintPropertyNode>\n-  bool Clear(scoped_refptr<PaintPropertyNode>& field) {\n+  bool Clear(std::unique_ptr<PaintPropertyNode>& field) {\n     if (field) {\n       field = nullptr;\n       return true;\n@@ -347,39 +337,40 @@ class CORE_EXPORT ObjectPaintProperties {\n   // created), and false otherwise. See the class-level comment (\""update & clear\n   // implementation note\"") for details about why this is needed for efficiency.\n   template <typename PaintPropertyNode>\n-  UpdateResult Update(scoped_refptr<PaintPropertyNode>& field,\n-                      scoped_refptr<const PaintPropertyNode> parent,\n+  UpdateResult Update(std::unique_ptr<PaintPropertyNode>& field,\n+                      const PaintPropertyNode& parent,\n                       typename PaintPropertyNode::State&& state) {\n     if (field) {\n-      return field->Update(std::move(parent), std::move(state))\n+      return field->Update(parent, std::move(state))\n                  ? UpdateResult::kValueChanged\n                  : UpdateResult::kUnchanged;\n     }\n-    field = PaintPropertyNode::Create(std::move(parent), std::move(state));\n+    field = PaintPropertyNode::Create(parent, std::move(state));\n     return UpdateResult::kNewNodeCreated;\n   }\n \n   // ATTENTION! Make sure to keep FindPropertiesNeedingUpdate.h in sync when\n   // new properites are added!\n-  scoped_refptr<TransformPaintPropertyNode> paint_offset_translation_;\n-  scoped_refptr<TransformPaintPropertyNode> transform_;\n-  scoped_refptr<EffectPaintPropertyNode> effect_;\n-  scoped_refptr<EffectPaintPropertyNode> filter_;\n-  scoped_refptr<EffectPaintPropertyNode> mask_;\n-  scoped_refptr<EffectPaintPropertyNode> clip_path_;\n-  scoped_refptr<ClipPaintPropertyNode> fragment_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> clip_path_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> mask_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> css_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> css_clip_fixed_position_;\n-  scoped_refptr<ClipPaintPropertyNode> overflow_controls_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> inner_border_radius_clip_;\n-  scoped_refptr<ClipPaintPropertyNode> overflow_clip_;\n-  scoped_refptr<TransformPaintPropertyNode> perspective_;\n+  std::unique_ptr<TransformPaintPropertyNode> paint_offset_translation_;\n+  std::unique_ptr<TransformPaintPropertyNode> transform_;\n+  std::unique_ptr<EffectPaintPropertyNode> effect_;\n+  std::unique_ptr<EffectPaintPropertyNode> filter_;\n+  std::unique_ptr<EffectPaintPropertyNode> mask_;\n+  std::unique_ptr<EffectPaintPropertyNode> clip_path_;\n+  std::unique_ptr<ClipPaintPropertyNode> fragment_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> clip_path_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> mask_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> css_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> css_clip_fixed_position_;\n+  std::unique_ptr<ClipPaintPropertyNode> overflow_controls_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> inner_border_radius_clip_;\n+  std::unique_ptr<ClipPaintPropertyNode> overflow_clip_;\n+  std::unique_ptr<TransformPaintPropertyNode> perspective_;\n   // TODO(pdr): Only LayoutSVGRoot needs this and it should be moved there.\n-  scoped_refptr<TransformPaintPropertyNode> svg_local_to_border_box_transform_;\n-  scoped_refptr<ScrollPaintPropertyNode> scroll_;\n-  scoped_refptr<TransformPaintPropertyNode> scroll_translation_;\n+  std::unique_ptr<TransformPaintPropertyNode>\n+      svg_local_to_border_box_transform_;\n+  std::unique_ptr<ScrollPaintPropertyNode> scroll_;\n+  std::unique_ptr<TransformPaintPropertyNode> scroll_translation_;\n \n   DISALLOW_COPY_AND_ASSIGN(ObjectPaintProperties);\n };""}<_**next**_>{""sha"": ""4be475bfc458f1170ab81ba3a7733f81b6984348"", ""filename"": ""third_party/blink/renderer/core/paint/paint_property_tree_builder.cc"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 28, ""changes"": 56, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/paint_property_tree_builder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/paint_property_tree_builder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_property_tree_builder.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -39,13 +39,13 @@ namespace blink {\n \n PaintPropertyTreeBuilderFragmentContext::\n     PaintPropertyTreeBuilderFragmentContext()\n-    : current_effect(EffectPaintPropertyNode::Root()) {\n+    : current_effect(&EffectPaintPropertyNode::Root()) {\n   current.clip = absolute_position.clip = fixed_position.clip =\n-      ClipPaintPropertyNode::Root();\n+      &ClipPaintPropertyNode::Root();\n   current.transform = absolute_position.transform = fixed_position.transform =\n-      TransformPaintPropertyNode::Root();\n+      &TransformPaintPropertyNode::Root();\n   current.scroll = absolute_position.scroll = fixed_position.scroll =\n-      ScrollPaintPropertyNode::Root();\n+      &ScrollPaintPropertyNode::Root();\n }\n \n void PaintPropertyTreeBuilder::SetupContextForFrame(\n@@ -295,7 +295,7 @@ void FragmentPaintPropertyTreeBuilder::UpdatePaintOffsetTranslation(\n         RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())\n       state.rendering_context_id = context_.current.rendering_context_id;\n     OnUpdate(properties_->UpdatePaintOffsetTranslation(\n-        context_.current.transform, std::move(state)));\n+        *context_.current.transform, std::move(state)));\n     context_.current.transform = properties_->PaintOffsetTranslation();\n     if (object_.IsLayoutView()) {\n       context_.absolute_position.transform =\n@@ -331,7 +331,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateTransformForNonRootSVG() {\n     if (NeedsTransformForNonRootSVG(object_)) {\n       // The origin is included in the local transform, so leave origin empty.\n       OnUpdate(properties_->UpdateTransform(\n-          context_.current.transform,\n+          *context_.current.transform,\n           TransformPaintPropertyNode::State{transform}));\n     } else {\n       OnClear(properties_->ClearTransform());\n@@ -449,7 +449,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateTransform() {\n             object_.UniqueId(), CompositorElementIdNamespace::kPrimary);\n       }\n \n-      OnUpdate(properties_->UpdateTransform(context_.current.transform,\n+      OnUpdate(properties_->UpdateTransform(*context_.current.transform,\n                                             std::move(state)));\n     } else {\n       OnClear(properties_->ClearTransform());\n@@ -578,7 +578,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateEffect() {\n           combined_clip.Intersect(*clip_path_clip);\n \n         OnUpdateClip(properties_->UpdateMaskClip(\n-            context_.current.clip,\n+            *context_.current.clip,\n             ClipPaintPropertyNode::State{context_.current.transform,\n                                          FloatRoundedRect(combined_clip)}));\n         output_clip = properties_->MaskClip();\n@@ -607,8 +607,8 @@ void FragmentPaintPropertyTreeBuilder::UpdateEffect() {\n         state.compositor_element_id = CompositorElementIdFromUniqueObjectId(\n             object_.UniqueId(), CompositorElementIdNamespace::kPrimary);\n       }\n-      OnUpdate(\n-          properties_->UpdateEffect(context_.current_effect, std::move(state)));\n+      OnUpdate(properties_->UpdateEffect(*context_.current_effect,\n+                                         std::move(state)));\n \n       if (mask_clip || has_spv1_composited_clip_path) {\n         EffectPaintPropertyNode::State mask_state;\n@@ -623,16 +623,16 @@ void FragmentPaintPropertyTreeBuilder::UpdateEffect() {\n                   object_.UniqueId(),\n                   CompositorElementIdNamespace::kEffectMask);\n         }\n-        OnUpdate(properties_->UpdateMask(properties_->Effect(),\n+        OnUpdate(properties_->UpdateMask(*properties_->Effect(),\n                                          std::move(mask_state)));\n       } else {\n         OnClear(properties_->ClearMask());\n       }\n \n       if (has_mask_based_clip_path) {\n-        const EffectPaintPropertyNode* parent = has_spv1_composited_clip_path\n-                                                    ? properties_->Mask()\n-                                                    : properties_->Effect();\n+        const EffectPaintPropertyNode& parent = has_spv1_composited_clip_path\n+                                                    ? *properties_->Mask()\n+                                                    : *properties_->Effect();\n         EffectPaintPropertyNode::State clip_path_state;\n         clip_path_state.local_transform_space = context_.current.transform;\n         clip_path_state.output_clip = output_clip;\n@@ -746,8 +746,8 @@ void FragmentPaintPropertyTreeBuilder::UpdateFilter() {\n             object_.UniqueId(), CompositorElementIdNamespace::kEffectFilter);\n       }\n \n-      OnUpdate(\n-          properties_->UpdateFilter(context_.current_effect, std::move(state)));\n+      OnUpdate(properties_->UpdateFilter(*context_.current_effect,\n+                                         std::move(state)));\n     } else {\n       OnClear(properties_->ClearFilter());\n     }\n@@ -775,7 +775,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {\n   if (NeedsPaintPropertyUpdate()) {\n     if (context_.fragment_clip) {\n       OnUpdateClip(properties_->UpdateFragmentClip(\n-          context_.current.clip,\n+          *context_.current.clip,\n           ClipPaintPropertyNode::State{context_.current.transform,\n                                        ToClipRect(*context_.fragment_clip)}));\n     } else {\n@@ -802,7 +802,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateCssClip() {\n       // copy from in-flow context later at updateOutOfFlowContext() step.\n       DCHECK(object_.CanContainAbsolutePositionObjects());\n       OnUpdateClip(properties_->UpdateCssClip(\n-          context_.current.clip,\n+          *context_.current.clip,\n           ClipPaintPropertyNode::State{context_.current.transform,\n                                        ToClipRect(ToLayoutBox(object_).ClipRect(\n                                            context_.current.paint_offset))}));\n@@ -835,7 +835,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(\n       state.clip_rect =\n           FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));\n       state.clip_path = fragment_data_.ClipPathPath();\n-      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,\n+      OnUpdateClip(properties_->UpdateClipPathClip(*context_.current.clip,\n                                                    std::move(state)));\n     }\n   }\n@@ -964,7 +964,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateOverflowControlsClip() {\n     // Clip overflow controls to the border box rect. Not wrapped with\n     // OnUpdateClip() because this clip doesn't affect descendants.\n     properties_->UpdateOverflowControlsClip(\n-        context_.current.clip,\n+        *context_.current.clip,\n         ClipPaintPropertyNode::State{\n             context_.current.transform,\n             ToClipRect(LayoutRect(context_.current.paint_offset,\n@@ -1000,7 +1000,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateInnerBorderRadiusClip() {\n             LayoutRect(context_.current.paint_offset, box.Size()));\n       }\n       OnUpdateClip(properties_->UpdateInnerBorderRadiusClip(\n-          context_.current.clip, std::move(state)));\n+          *context_.current.clip, std::move(state)));\n     } else {\n       OnClearClip(properties_->ClearInnerBorderRadiusClip());\n     }\n@@ -1071,7 +1071,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateOverflowClip() {\n       bool equal_ignoring_hit_test_rects =\n           !!existing &&\n           existing->EqualIgnoringHitTestRects(context_.current.clip, state);\n-      OnUpdateClip(properties_->UpdateOverflowClip(context_.current.clip,\n+      OnUpdateClip(properties_->UpdateOverflowClip(*context_.current.clip,\n                                                    std::move(state)),\n                    equal_ignoring_hit_test_rects);\n     } else {\n@@ -1113,7 +1113,7 @@ void FragmentPaintPropertyTreeBuilder::UpdatePerspective() {\n       if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled() ||\n           RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())\n         state.rendering_context_id = context_.current.rendering_context_id;\n-      OnUpdate(properties_->UpdatePerspective(context_.current.transform,\n+      OnUpdate(properties_->UpdatePerspective(*context_.current.transform,\n                                               std::move(state)));\n     } else {\n       OnClear(properties_->ClearPerspective());\n@@ -1138,7 +1138,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateSvgLocalToBorderBoxTransform() {\n     if (!transform_to_border_box.IsIdentity() &&\n         NeedsSVGLocalToBorderBoxTransform(object_)) {\n       OnUpdate(properties_->UpdateSvgLocalToBorderBoxTransform(\n-          context_.current.transform,\n+          *context_.current.transform,\n           TransformPaintPropertyNode::State{transform_to_border_box}));\n     } else {\n       OnClear(properties_->ClearSvgLocalToBorderBoxTransform());\n@@ -1220,8 +1220,8 @@ void FragmentPaintPropertyTreeBuilder::UpdateScrollAndScrollTranslation() {\n           RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled())\n         state.compositor_element_id = scrollable_area->GetCompositorElementId();\n \n-      OnUpdate(\n-          properties_->UpdateScroll(context_.current.scroll, std::move(state)));\n+      OnUpdate(properties_->UpdateScroll(*context_.current.scroll,\n+                                         std::move(state)));\n     } else {\n       OnClear(properties_->ClearScroll());\n     }\n@@ -1241,7 +1241,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateScrollAndScrollTranslation() {\n         state.rendering_context_id = context_.current.rendering_context_id;\n       }\n       state.scroll = properties_->Scroll();\n-      OnUpdate(properties_->UpdateScrollTranslation(context_.current.transform,\n+      OnUpdate(properties_->UpdateScrollTranslation(*context_.current.transform,\n                                                     std::move(state)));\n     } else {\n       OnClear(properties_->ClearScrollTranslation());\n@@ -1296,7 +1296,7 @@ void FragmentPaintPropertyTreeBuilder::UpdateOutOfFlowContext() {\n     } else {\n       if (NeedsPaintPropertyUpdate()) {\n         OnUpdate(properties_->UpdateCssClipFixedPosition(\n-            context_.fixed_position.clip,\n+            *context_.fixed_position.clip,\n             ClipPaintPropertyNode::State{css_clip->LocalTransformSpace(),\n                                          css_clip->ClipRect()}));\n       }""}<_**next**_>{""sha"": ""a5e8279e2cf430828e119c57c036c9442c598003"", ""filename"": ""third_party/blink/renderer/core/paint/paint_property_tree_builder_test.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/paint_property_tree_builder_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/paint_property_tree_builder_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/paint_property_tree_builder_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -845,7 +845,7 @@ TEST_P(PaintPropertyTreeBuilderTest, EffectNodesInSVG) {\n       PaintPropertiesForElement(\""groupWithOpacity\"");\n   EXPECT_EQ(0.6f, group_with_opacity_properties->Effect()->Opacity());\n   EXPECT_EQ(svg_clip, group_with_opacity_properties->Effect()->OutputClip());\n-  EXPECT_EQ(EffectPaintPropertyNode::Root(),\n+  EXPECT_EQ(&EffectPaintPropertyNode::Root(),\n             group_with_opacity_properties->Effect()->Parent());\n \n   EXPECT_EQ(nullptr, PaintPropertiesForElement(\""rectWithoutOpacity\""));\n@@ -4626,7 +4626,7 @@ TEST_P(PaintPropertyTreeBuilderTest, SVGResource) {\n \n   // The <marker> object resets to a new paint property tree, so the\n   // transform within it should have the root as parent.\n-  EXPECT_EQ(TransformPaintPropertyNode::Root(),\n+  EXPECT_EQ(&TransformPaintPropertyNode::Root(),\n             transform_inside_marker_properties->Transform()->Parent());\n \n   // Whereas this is not true of the transform above the path.\n@@ -4659,7 +4659,7 @@ TEST_P(PaintPropertyTreeBuilderTest, SVGHiddenResource) {\n \n   // The <marker> object resets to a new paint property tree, so the\n   // transform within it should have the root as parent.\n-  EXPECT_EQ(TransformPaintPropertyNode::Root(),\n+  EXPECT_EQ(&TransformPaintPropertyNode::Root(),\n             transform_inside_symbol_properties->Transform()->Parent());\n \n   // Whereas this is not true of the transform above the path.\n@@ -4680,7 +4680,7 @@ TEST_P(PaintPropertyTreeBuilderTest, SVGRootBlending) {\n   const ObjectPaintProperties* svg_root_properties =\n       svg_root.FirstFragment().PaintProperties();\n   EXPECT_TRUE(svg_root_properties->Effect());\n-  EXPECT_EQ(EffectPaintPropertyNode::Root(),\n+  EXPECT_EQ(&EffectPaintPropertyNode::Root(),\n             svg_root_properties->Effect()->Parent());\n }\n ""}<_**next**_>{""sha"": ""cbd6c700deaac30bbe6150c81570b09b12aefa30"", ""filename"": ""third_party/blink/renderer/core/paint/view_painter_test.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/view_painter_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/core/paint/view_painter_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/paint/view_painter_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -116,7 +116,7 @@ TEST_P(ViewPainterTest, DocumentBackgroundWithScroll) {\n   EXPECT_EQ(background_chunk_client, &chunk.id.client);\n \n   const auto& tree_state = chunk.properties;\n-  EXPECT_EQ(EffectPaintPropertyNode::Root(), tree_state.Effect());\n+  EXPECT_EQ(&EffectPaintPropertyNode::Root(), tree_state.Effect());\n   const auto* properties = GetLayoutView().FirstFragment().PaintProperties();\n   EXPECT_EQ(properties->ScrollTranslation(), tree_state.Transform());\n   EXPECT_EQ(properties->OverflowClip(), tree_state.Clip());""}<_**next**_>{""sha"": ""f3f0bc491bb7c589d07416163842e940bcf7689f"", ""filename"": ""third_party/blink/renderer/platform/BUILD.gn"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/BUILD.gn?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -1061,8 +1061,6 @@ jumbo_component(\""platform\"") {\n     \""graphics/paint/property_tree_state.h\"",\n     \""graphics/paint/raster_invalidation_tracking.cc\"",\n     \""graphics/paint/raster_invalidation_tracking.h\"",\n-    \""graphics/paint/ref_counted_property_tree_state.cc\"",\n-    \""graphics/paint/ref_counted_property_tree_state.h\"",\n     \""graphics/paint/scoped_display_item_fragment.h\"",\n     \""graphics/paint/scoped_paint_chunk_properties.h\"",\n     \""graphics/paint/scroll_display_item.cc\"",""}<_**next**_>{""sha"": ""83deea6ab05a8ad92f709b3d66f68d93f37f6b4e"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -12,7 +12,7 @@ namespace blink {\n void ChunkToLayerMapper::SwitchToChunk(const PaintChunk& chunk) {\n   outset_for_raster_effects_ = chunk.outset_for_raster_effects;\n \n-  const auto& new_chunk_state = chunk.properties.GetPropertyTreeState();\n+  const auto& new_chunk_state = chunk.properties;\n   if (new_chunk_state == chunk_state_)\n     return;\n ""}<_**next**_>{""sha"": ""79c1bf38ab159b0f66b644f161f319e68f3cb3c5"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper_test.cc"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 25, ""changes"": 52, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/chunk_to_layer_mapper_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -27,27 +27,29 @@ class ChunkToLayerMapperTest : public testing::Test {\n   // A state containing arbitrary values which should not affect test results\n   // if the state is used as a layer state.\n   PropertyTreeState LayerState() {\n-    DEFINE_STATIC_REF(\n-        TransformPaintPropertyNode, transform,\n-        CreateTransform(TransformPaintPropertyNode::Root(),\n-                        TransformationMatrix().Translate(123, 456),\n-                        FloatPoint3D(1, 2, 3)));\n-    DEFINE_STATIC_REF(ClipPaintPropertyNode, clip,\n-                      CreateClip(ClipPaintPropertyNode::Root(), transform,\n-                                 FloatRoundedRect(12, 34, 56, 78)));\n-    DEFINE_STATIC_REF(\n-        EffectPaintPropertyNode, effect,\n-        EffectPaintPropertyNode::Create(\n-            EffectPaintPropertyNode::Root(),\n-            EffectPaintPropertyNode::State{\n-                transform, clip, kColorFilterLuminanceToAlpha,\n-                CompositorFilterOperations(), 0.789f, SkBlendMode::kSrcIn}));\n-    return PropertyTreeState(transform, clip, effect);\n+    if (!layer_transform_) {\n+      layer_transform_ =\n+          CreateTransform(t0(), TransformationMatrix().Translate(123, 456),\n+                          FloatPoint3D(1, 2, 3));\n+      layer_clip_ = CreateClip(c0(), layer_transform_.get(),\n+                               FloatRoundedRect(12, 34, 56, 78));\n+      layer_effect_ = EffectPaintPropertyNode::Create(\n+          e0(), EffectPaintPropertyNode::State{\n+                    layer_transform_.get(), layer_clip_.get(),\n+                    kColorFilterLuminanceToAlpha, CompositorFilterOperations(),\n+                    0.789f, SkBlendMode::kSrcIn});\n+    }\n+    return PropertyTreeState(layer_transform_.get(), layer_clip_.get(),\n+                             layer_effect_.get());\n   }\n \n   bool HasFilterThatMovesPixels(const ChunkToLayerMapper& mapper) {\n     return mapper.has_filter_that_moves_pixels_;\n   }\n+\n+  std::unique_ptr<TransformPaintPropertyNode> layer_transform_;\n+  std::unique_ptr<ClipPaintPropertyNode> layer_clip_;\n+  std::unique_ptr<EffectPaintPropertyNode> layer_effect_;\n };\n \n TEST_F(ChunkToLayerMapperTest, OneChunkUsingLayerState) {\n@@ -92,9 +94,9 @@ TEST_F(ChunkToLayerMapperTest, TwoChunkUsingLayerState) {\n \n TEST_F(ChunkToLayerMapperTest, TwoChunkSameState) {\n   ChunkToLayerMapper mapper(LayerState(), gfx::Vector2dF(10, 20));\n-  auto transform = CreateTransform(LayerState().Transform(),\n+  auto transform = CreateTransform(*LayerState().Transform(),\n                                    TransformationMatrix().Scale(2));\n-  auto clip = CreateClip(LayerState().Clip(), LayerState().Transform(),\n+  auto clip = CreateClip(*LayerState().Clip(), LayerState().Transform(),\n                          FloatRoundedRect(10, 10, 100, 100));\n   auto* effect = LayerState().Effect();\n   auto chunk1 = Chunk(PropertyTreeState(transform.get(), clip.get(), effect));\n@@ -123,16 +125,16 @@ TEST_F(ChunkToLayerMapperTest, TwoChunkSameState) {\n \n TEST_F(ChunkToLayerMapperTest, TwoChunkDifferentState) {\n   ChunkToLayerMapper mapper(LayerState(), gfx::Vector2dF(10, 20));\n-  auto transform1 = CreateTransform(LayerState().Transform(),\n+  auto transform1 = CreateTransform(*LayerState().Transform(),\n                                     TransformationMatrix().Scale(2));\n-  auto clip1 = CreateClip(LayerState().Clip(), LayerState().Transform(),\n+  auto clip1 = CreateClip(*LayerState().Clip(), LayerState().Transform(),\n                           FloatRoundedRect(10, 10, 100, 100));\n   auto* effect = LayerState().Effect();\n   auto chunk1 = Chunk(PropertyTreeState(transform1.get(), clip1.get(), effect));\n \n   auto transform2 =\n-      CreateTransform(transform1, TransformationMatrix().Translate(20, 30));\n-  auto clip2 = CreateClip(LayerState().Clip(), transform2,\n+      CreateTransform(*transform1, TransformationMatrix().Translate(20, 30));\n+  auto clip2 = CreateClip(*LayerState().Clip(), transform2.get(),\n                           FloatRoundedRect(0, 0, 20, 20));\n   auto chunk2 = Chunk(PropertyTreeState(transform2.get(), clip2.get(), effect));\n \n@@ -165,21 +167,21 @@ TEST_F(ChunkToLayerMapperTest, SlowPath) {\n   // Chunk2 has a blur filter. Should use the slow path.\n   CompositorFilterOperations filter2;\n   filter2.AppendBlurFilter(20);\n-  auto effect2 = CreateFilterEffect(LayerState().Effect(), std::move(filter2));\n+  auto effect2 = CreateFilterEffect(*LayerState().Effect(), std::move(filter2));\n   auto chunk2 = Chunk(PropertyTreeState(LayerState().Transform(),\n                                         LayerState().Clip(), effect2.get()));\n \n   // Chunk3 has a different effect which inherits from chunk2's effect.\n   // Should use the slow path.\n-  auto effect3 = CreateOpacityEffect(effect2, 1.f);\n+  auto effect3 = CreateOpacityEffect(*effect2, 1.f);\n   auto chunk3 = Chunk(PropertyTreeState(LayerState().Transform(),\n                                         LayerState().Clip(), effect3.get()));\n \n   // Chunk4 has an opacity filter effect which inherits from the layer's effect.\n   // Should use the fast path.\n   CompositorFilterOperations filter4;\n   filter4.AppendOpacityFilter(0.5);\n-  auto effect4 = CreateFilterEffect(LayerState().Effect(), std::move(filter4));\n+  auto effect4 = CreateFilterEffect(*LayerState().Effect(), std::move(filter4));\n   auto chunk4 = Chunk(PropertyTreeState(LayerState().Transform(),\n                                         LayerState().Clip(), effect4.get()));\n ""}<_**next**_>{""sha"": ""b84d8ade547c7086affada60199ee34c9cb0e776"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -56,7 +56,7 @@ static bool ApproximatelyEqual(const SkMatrix& a, const SkMatrix& b) {\n \n PaintInvalidationReason\n CompositedLayerRasterInvalidator::ChunkPropertiesChanged(\n-    const RefCountedPropertyTreeState& new_chunk_state,\n+    const PropertyTreeState& new_chunk_state,\n     const PaintChunkInfo& new_chunk,\n     const PaintChunkInfo& old_chunk,\n     const PropertyTreeState& layer_state) const {""}<_**next**_>{""sha"": ""02529e49525433d64fbe13af4cd0063d66daad29"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -114,7 +114,7 @@ class PLATFORM_EXPORT CompositedLayerRasterInvalidator {\n                                            PaintInvalidationReason,\n                                            const String* debug_name = nullptr);\n   PaintInvalidationReason ChunkPropertiesChanged(\n-      const RefCountedPropertyTreeState& new_chunk_state,\n+      const PropertyTreeState& new_chunk_state,\n       const PaintChunkInfo& new_chunk,\n       const PaintChunkInfo& old_chunk,\n       const PropertyTreeState& layer_state) const;""}<_**next**_>{""sha"": ""adb969ca48a436bc8689181687f2354974f22057"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator_test.cc"", ""status"": ""modified"", ""additions"": 53, ""deletions"": 72, ""changes"": 125, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/composited_layer_raster_invalidator_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -39,19 +39,16 @@ class CompositedLayerRasterInvalidatorTest\n   }\n \n   CompositedLayerRasterInvalidatorTest& Properties(\n-      const TransformPaintPropertyNode* t,\n-      const ClipPaintPropertyNode* c = ClipPaintPropertyNode::Root(),\n-      const EffectPaintPropertyNode* e = EffectPaintPropertyNode::Root()) {\n-    auto& state = data_.chunks.back().properties;\n-    state.SetTransform(t);\n-    state.SetClip(c);\n-    state.SetEffect(e);\n+      const PropertyTreeState& state) {\n+    data_.chunks.back().properties = state;\n     return *this;\n   }\n \n   CompositedLayerRasterInvalidatorTest& Properties(\n-      const RefCountedPropertyTreeState& state) {\n-    data_.chunks.back().properties = state;\n+      const TransformPaintPropertyNode& t,\n+      const ClipPaintPropertyNode& c,\n+      const EffectPaintPropertyNode& e) {\n+    Properties(PropertyTreeState(&t, &c, &e));\n     return *this;\n   }\n \n@@ -351,22 +348,17 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeRounded) {\n   FloatRoundedRect::Radii radii(FloatSize(1, 2), FloatSize(2, 3),\n                                 FloatSize(3, 4), FloatSize(4, 5));\n   FloatRoundedRect clip_rect(FloatRect(-1000, -1000, 2000, 2000), radii);\n-  scoped_refptr<ClipPaintPropertyNode> clip0 =\n-      CreateClip(ClipPaintPropertyNode::Root(),\n-                 TransformPaintPropertyNode::Root(), clip_rect);\n-  scoped_refptr<ClipPaintPropertyNode> clip2 =\n-      CreateClip(clip0, TransformPaintPropertyNode::Root(), clip_rect);\n-\n-  PropertyTreeState layer_state(TransformPaintPropertyNode::Root(), clip0.get(),\n-                                EffectPaintPropertyNode::Root());\n-  auto artifact =\n-      Chunk(0)\n-          .Properties(layer_state)\n-          .Chunk(1)\n-          .Properties(layer_state)\n-          .Chunk(2)\n-          .Properties(TransformPaintPropertyNode::Root(), clip2.get())\n-          .Build();\n+  auto clip0 = CreateClip(c0(), &t0(), clip_rect);\n+  auto clip2 = CreateClip(*clip0, &t0(), clip_rect);\n+\n+  PropertyTreeState layer_state(&t0(), clip0.get(), &e0());\n+  auto artifact = Chunk(0)\n+                      .Properties(layer_state)\n+                      .Chunk(1)\n+                      .Properties(layer_state)\n+                      .Chunk(2)\n+                      .Properties(t0(), *clip2, e0())\n+                      .Build();\n \n   GeometryMapperClipCache::ClearCache();\n   invalidator.SetTracksRasterInvalidations(true);\n@@ -382,10 +374,10 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeRounded) {\n                           .Properties(artifact.PaintChunks()[2].properties)\n                           .Build();\n   FloatRoundedRect new_clip_rect(FloatRect(-2000, -2000, 4000, 4000), radii);\n-  clip0->Update(clip0->Parent(),\n+  clip0->Update(*clip0->Parent(),\n                 ClipPaintPropertyNode::State{clip0->LocalTransformSpace(),\n                                              new_clip_rect});\n-  clip2->Update(clip2->Parent(),\n+  clip2->Update(*clip2->Parent(),\n                 ClipPaintPropertyNode::State{clip2->LocalTransformSpace(),\n                                              new_clip_rect});\n \n@@ -423,21 +415,17 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeRounded) {\n TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeSimple) {\n   CompositedLayerRasterInvalidator invalidator(kNoopRasterInvalidation);\n   FloatRoundedRect clip_rect(-1000, -1000, 2000, 2000);\n-  scoped_refptr<ClipPaintPropertyNode> clip0 =\n-      CreateClip(ClipPaintPropertyNode::Root(),\n-                 TransformPaintPropertyNode::Root(), clip_rect);\n-  scoped_refptr<ClipPaintPropertyNode> clip1 =\n-      CreateClip(clip0, TransformPaintPropertyNode::Root(), clip_rect);\n+  auto clip0 = CreateClip(c0(), &t0(), clip_rect);\n+  auto clip1 = CreateClip(*clip0, &t0(), clip_rect);\n \n   PropertyTreeState layer_state = PropertyTreeState::Root();\n-  auto artifact =\n-      Chunk(0)\n-          .Properties(TransformPaintPropertyNode::Root(), clip0.get())\n-          .Bounds(clip_rect.Rect())\n-          .Chunk(1)\n-          .Properties(TransformPaintPropertyNode::Root(), clip1.get())\n-          .Bounds(clip_rect.Rect())\n-          .Build();\n+  auto artifact = Chunk(0)\n+                      .Properties(t0(), *clip0, e0())\n+                      .Bounds(clip_rect.Rect())\n+                      .Chunk(1)\n+                      .Properties(t0(), *clip1, e0())\n+                      .Bounds(clip_rect.Rect())\n+                      .Build();\n \n   GeometryMapperClipCache::ClearCache();\n   invalidator.SetTracksRasterInvalidations(true);\n@@ -447,7 +435,7 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeSimple) {\n   // Change clip1 to bigger, which is still bound by clip0, resulting no actual\n   // visual change.\n   FloatRoundedRect new_clip_rect1(-2000, -2000, 4000, 4000);\n-  clip1->Update(clip1->Parent(),\n+  clip1->Update(*clip1->Parent(),\n                 ClipPaintPropertyNode::State{clip1->LocalTransformSpace(),\n                                              new_clip_rect1});\n   auto new_artifact1 = Chunk(0)\n@@ -465,7 +453,7 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeSimple) {\n \n   // Change clip1 to smaller.\n   FloatRoundedRect new_clip_rect2(-500, -500, 1000, 1000);\n-  clip1->Update(clip1->Parent(),\n+  clip1->Update(*clip1->Parent(),\n                 ClipPaintPropertyNode::State{clip1->LocalTransformSpace(),\n                                              new_clip_rect2});\n   auto new_artifact2 = Chunk(0)\n@@ -498,7 +486,7 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeSimple) {\n \n   // Change clip1 bigger at one side.\n   FloatRoundedRect new_clip_rect3(-500, -500, 2000, 1000);\n-  clip1->Update(clip1->Parent(),\n+  clip1->Update(*clip1->Parent(),\n                 ClipPaintPropertyNode::State{clip1->LocalTransformSpace(),\n                                              new_clip_rect3});\n   auto new_artifact3 = Chunk(0)\n@@ -525,20 +513,17 @@ TEST_F(CompositedLayerRasterInvalidatorTest, ClipPropertyChangeSimple) {\n TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n   CompositedLayerRasterInvalidator invalidator(kNoopRasterInvalidation);\n \n-  auto layer_transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                         TransformationMatrix().Scale(5));\n-  auto transform0 = CreateTransform(layer_transform,\n+  auto layer_transform = CreateTransform(t0(), TransformationMatrix().Scale(5));\n+  auto transform0 = CreateTransform(*layer_transform,\n                                     TransformationMatrix().Translate(10, 20));\n   auto transform1 =\n-      CreateTransform(transform0, TransformationMatrix().Translate(-50, -60));\n+      CreateTransform(*transform0, TransformationMatrix().Translate(-50, -60));\n \n-  PropertyTreeState layer_state(layer_transform.get(),\n-                                ClipPaintPropertyNode::Root(),\n-                                EffectPaintPropertyNode::Root());\n+  PropertyTreeState layer_state(layer_transform.get(), &c0(), &e0());\n   auto artifact = Chunk(0)\n-                      .Properties(transform0.get())\n+                      .Properties(*transform0, c0(), e0())\n                       .Chunk(1)\n-                      .Properties(transform1.get())\n+                      .Properties(*transform1, c0(), e0())\n                       .Build();\n \n   GeometryMapperTransformCache::ClearCache();\n@@ -548,7 +533,7 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n \n   // Change layer_transform should not cause raster invalidation in the layer.\n   layer_transform->Update(\n-      layer_transform->Parent(),\n+      *layer_transform->Parent(),\n       TransformPaintPropertyNode::State{TransformationMatrix().Scale(10)});\n   auto new_artifact = Chunk(0)\n                           .Properties(artifact.PaintChunks()[0].properties)\n@@ -565,11 +550,9 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n   // raster invalidation in the layer. This simulates a composited layer is\n   // scrolled from its original location.\n   auto new_layer_transform = CreateTransform(\n-      layer_transform, TransformationMatrix().Translate(-100, -200));\n-  layer_state = PropertyTreeState(new_layer_transform.get(),\n-                                  ClipPaintPropertyNode::Root(),\n-                                  EffectPaintPropertyNode::Root());\n-  transform0->Update(new_layer_transform,\n+      *layer_transform, TransformationMatrix().Translate(-100, -200));\n+  layer_state = PropertyTreeState(new_layer_transform.get(), &c0(), &e0());\n+  transform0->Update(*new_layer_transform,\n                      TransformPaintPropertyNode::State{transform0->Matrix()});\n   auto new_artifact1 = Chunk(0)\n                            .Properties(artifact.PaintChunks()[0].properties)\n@@ -584,7 +567,7 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n   // Removing transform nodes above the layer state should not cause raster\n   // invalidation in the layer.\n   layer_state = DefaultPropertyTreeState();\n-  transform0->Update(layer_state.Transform(),\n+  transform0->Update(*layer_state.Transform(),\n                      TransformPaintPropertyNode::State{transform0->Matrix()});\n   auto new_artifact2 = Chunk(0)\n                            .Properties(artifact.PaintChunks()[0].properties)\n@@ -600,11 +583,11 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n   // and transform1 unchanged for chunk 2. We should invalidate only chunk 0\n   // for changed paint property.\n   transform0->Update(\n-      layer_state.Transform(),\n+      *layer_state.Transform(),\n       TransformPaintPropertyNode::State{\n           TransformationMatrix(transform0->Matrix()).Translate(20, 30)});\n   transform1->Update(\n-      transform0,\n+      *transform0,\n       TransformPaintPropertyNode::State{\n           TransformationMatrix(transform1->Matrix()).Translate(-20, -30)});\n   auto new_artifact3 = Chunk(0)\n@@ -631,29 +614,26 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyChange) {\n TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyTinyChange) {\n   CompositedLayerRasterInvalidator invalidator(kNoopRasterInvalidation);\n \n-  auto layer_transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                         TransformationMatrix().Scale(5));\n+  auto layer_transform = CreateTransform(t0(), TransformationMatrix().Scale(5));\n   auto chunk_transform = CreateTransform(\n-      layer_transform, TransformationMatrix().Translate(10, 20));\n+      *layer_transform, TransformationMatrix().Translate(10, 20));\n \n-  PropertyTreeState layer_state(layer_transform.get(),\n-                                ClipPaintPropertyNode::Root(),\n-                                EffectPaintPropertyNode::Root());\n-  auto artifact = Chunk(0).Properties(chunk_transform.get()).Build();\n+  PropertyTreeState layer_state(layer_transform.get(), &c0(), &e0());\n+  auto artifact = Chunk(0).Properties(*chunk_transform, c0(), e0()).Build();\n \n   GeometryMapperTransformCache::ClearCache();\n   invalidator.SetTracksRasterInvalidations(true);\n   invalidator.Generate(artifact, kDefaultLayerBounds, layer_state);\n   EXPECT_TRUE(TrackedRasterInvalidations(invalidator).IsEmpty());\n \n   // Change chunk_transform by tiny difference, which should be ignored.\n-  chunk_transform->Update(layer_state.Transform(),\n+  chunk_transform->Update(*layer_state.Transform(),\n                           TransformPaintPropertyNode::State{\n                               TransformationMatrix(chunk_transform->Matrix())\n                                   .Translate(0.0000001, -0.0000001)\n                                   .Scale(1.0000001)\n                                   .Rotate(0.0000001)});\n-  auto new_artifact = Chunk(0).Properties(chunk_transform.get()).Build();\n+  auto new_artifact = Chunk(0).Properties(*chunk_transform, c0(), e0()).Build();\n \n   GeometryMapperTransformCache::ClearCache();\n   invalidator.Generate(new_artifact, kDefaultLayerBounds, layer_state);\n@@ -663,13 +643,14 @@ TEST_F(CompositedLayerRasterInvalidatorTest, TransformPropertyTinyChange) {\n   // accumulation is large enough.\n   bool invalidated = false;\n   for (int i = 0; i < 100 && !invalidated; i++) {\n-    chunk_transform->Update(layer_state.Transform(),\n+    chunk_transform->Update(*layer_state.Transform(),\n                             TransformPaintPropertyNode::State{\n                                 TransformationMatrix(chunk_transform->Matrix())\n                                     .Translate(0.0000001, -0.0000001)\n                                     .Scale(1.0000001)\n                                     .Rotate(0.0000001)});\n-    auto new_artifact = Chunk(0).Properties(chunk_transform.get()).Build();\n+    auto new_artifact =\n+        Chunk(0).Properties(*chunk_transform, c0(), e0()).Build();\n \n     GeometryMapperTransformCache::ClearCache();\n     invalidator.Generate(new_artifact, kDefaultLayerBounds, layer_state);""}<_**next**_>{""sha"": ""edf0e16e24bdb261407a7d40dbb5b05cac87a4a7"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 11, ""changes"": 18, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -285,7 +285,7 @@ PaintArtifactCompositor::PendingLayer::PendingLayer(\n     : bounds(first_paint_chunk.bounds),\n       rect_known_to_be_opaque(\n           first_paint_chunk.known_to_be_opaque ? bounds : FloatRect()),\n-      property_tree_state(first_paint_chunk.properties.GetPropertyTreeState()),\n+      property_tree_state(first_paint_chunk.properties),\n       requires_own_layer(chunk_requires_own_layer) {\n   paint_chunk_indices.push_back(chunk_index);\n }\n@@ -397,16 +397,12 @@ static const EffectPaintPropertyNode* StrictChildOfAlongPath(\n \n bool PaintArtifactCompositor::MightOverlap(const PendingLayer& layer_a,\n                                            const PendingLayer& layer_b) {\n-  PropertyTreeState root_property_tree_state(TransformPaintPropertyNode::Root(),\n-                                             ClipPaintPropertyNode::Root(),\n-                                             EffectPaintPropertyNode::Root());\n-\n   FloatClipRect bounds_a(layer_a.bounds);\n-  GeometryMapper::LocalToAncestorVisualRect(layer_a.property_tree_state,\n-                                            root_property_tree_state, bounds_a);\n+  GeometryMapper::LocalToAncestorVisualRect(\n+      layer_a.property_tree_state, PropertyTreeState::Root(), bounds_a);\n   FloatClipRect bounds_b(layer_b.bounds);\n-  GeometryMapper::LocalToAncestorVisualRect(layer_b.property_tree_state,\n-                                            root_property_tree_state, bounds_b);\n+  GeometryMapper::LocalToAncestorVisualRect(\n+      layer_b.property_tree_state, PropertyTreeState::Root(), bounds_b);\n \n   return bounds_a.Rect().Intersects(bounds_b.Rect());\n }\n@@ -575,8 +571,8 @@ void PaintArtifactCompositor::CollectPendingLayers(\n     Vector<PendingLayer>& pending_layers) {\n   Vector<PaintChunk>::const_iterator cursor =\n       paint_artifact.PaintChunks().begin();\n-  LayerizeGroup(paint_artifact, pending_layers,\n-                *EffectPaintPropertyNode::Root(), cursor);\n+  LayerizeGroup(paint_artifact, pending_layers, EffectPaintPropertyNode::Root(),\n+                cursor);\n   DCHECK_EQ(paint_artifact.PaintChunks().end(), cursor);\n }\n ""}<_**next**_>{""sha"": ""56df523461b21646e07f8559b30195a8c1958138"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor_test.cc"", ""status"": ""modified"", ""additions"": 322, ""deletions"": 634, ""changes"": 956, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/paint_artifact_compositor_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -197,9 +197,7 @@ class PaintArtifactCompositorTest : public testing::Test,\n   }\n \n   void AddSimpleRectChunk(TestPaintArtifact& artifact) {\n-    artifact\n-        .Chunk(TransformPaintPropertyNode::Root(),\n-               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())\n+    artifact.Chunk(t0(), c0(), e0())\n         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   }\n \n@@ -210,9 +208,7 @@ class PaintArtifactCompositorTest : public testing::Test,\n     if (include_preceding_chunk)\n       AddSimpleRectChunk(artifact);\n     auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), opacity);\n-    artifact\n-        .Chunk(TransformPaintPropertyNode::Root(),\n-               ClipPaintPropertyNode::Root(), effect)\n+    artifact.Chunk(t0(), c0(), *effect)\n         .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n     if (include_subsequent_chunk)\n       AddSimpleRectChunk(artifact);\n@@ -237,17 +233,6 @@ class PaintArtifactCompositorTest : public testing::Test,\n \n const auto kNotScrollingOnMain = MainThreadScrollingReason::kNotScrollingOnMain;\n \n-// Convenient shorthands.\n-const TransformPaintPropertyNode* t0() {\n-  return TransformPaintPropertyNode::Root();\n-}\n-const ClipPaintPropertyNode* c0() {\n-  return ClipPaintPropertyNode::Root();\n-}\n-const EffectPaintPropertyNode* e0() {\n-  return EffectPaintPropertyNode::Root();\n-}\n-\n TEST_F(PaintArtifactCompositorTest, EmptyPaintArtifact) {\n   PaintArtifact empty_artifact;\n   Update(empty_artifact);\n@@ -256,7 +241,7 @@ TEST_F(PaintArtifactCompositorTest, EmptyPaintArtifact) {\n \n TEST_F(PaintArtifactCompositorTest, OneChunkWithAnOffset) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, -50, 100, 100), Color::kWhite);\n   Update(artifact.Build());\n \n@@ -271,22 +256,16 @@ TEST_F(PaintArtifactCompositorTest, OneChunkWithAnOffset) {\n \n TEST_F(PaintArtifactCompositorTest, OneTransform) {\n   // A 90 degree clockwise rotation about (100, 100).\n-  auto transform = CreateTransform(\n-      TransformPaintPropertyNode::Root(), TransformationMatrix().Rotate(90),\n-      FloatPoint3D(100, 100, 0), CompositingReason::k3DTransform);\n+  auto transform = CreateTransform(t0(), TransformationMatrix().Rotate(90),\n+                                   FloatPoint3D(100, 100, 0),\n+                                   CompositingReason::k3DTransform);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -317,21 +296,17 @@ TEST_F(PaintArtifactCompositorTest, OneTransform) {\n \n TEST_F(PaintArtifactCompositorTest, TransformCombining) {\n   // A translation by (5, 5) within a 2x scale about (10, 10).\n-  auto transform1 = CreateTransform(\n-      TransformPaintPropertyNode::Root(), TransformationMatrix().Scale(2),\n-      FloatPoint3D(10, 10, 0), CompositingReason::k3DTransform);\n+  auto transform1 =\n+      CreateTransform(t0(), TransformationMatrix().Scale(2),\n+                      FloatPoint3D(10, 10, 0), CompositingReason::k3DTransform);\n   auto transform2 =\n-      CreateTransform(transform1, TransformationMatrix().Translate(5, 5),\n+      CreateTransform(*transform1, TransformationMatrix().Translate(5, 5),\n                       FloatPoint3D(), CompositingReason::k3DTransform);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(transform1, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform1, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kWhite);\n-  artifact\n-      .Chunk(transform2, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform2, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -363,29 +338,23 @@ TEST_F(PaintArtifactCompositorTest, BackfaceVisibility) {\n   backface_hidden_state.backface_visibility =\n       TransformPaintPropertyNode::BackfaceVisibility::kHidden;\n   auto backface_hidden_transform = TransformPaintPropertyNode::Create(\n-      TransformPaintPropertyNode::Root(), std::move(backface_hidden_state));\n+      t0(), std::move(backface_hidden_state));\n \n   auto backface_inherited_transform = TransformPaintPropertyNode::Create(\n-      backface_hidden_transform, TransformPaintPropertyNode::State{});\n+      *backface_hidden_transform, TransformPaintPropertyNode::State{});\n \n   TransformPaintPropertyNode::State backface_visible_state;\n   backface_visible_state.backface_visibility =\n       TransformPaintPropertyNode::BackfaceVisibility::kVisible;\n   auto backface_visible_transform = TransformPaintPropertyNode::Create(\n-      backface_hidden_transform, std::move(backface_visible_state));\n+      *backface_hidden_transform, std::move(backface_visible_state));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(backface_hidden_transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*backface_hidden_transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kWhite);\n-  artifact\n-      .Chunk(backface_inherited_transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*backface_inherited_transform, c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 100, 100), Color::kBlack);\n-  artifact\n-      .Chunk(backface_visible_transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*backface_visible_transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kDarkGray);\n   Update(artifact.Build());\n \n@@ -408,20 +377,17 @@ TEST_F(PaintArtifactCompositorTest, FlattensInheritedTransform) {\n     // transform node flattens the transform. This is because Blink's notion of\n     // flattening determines whether content within the node's local transform\n     // is flattened, while cc's notion applies in the parent's coordinate space.\n-    auto transform1 = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                      TransformationMatrix());\n+    auto transform1 = CreateTransform(t0(), TransformationMatrix());\n     auto transform2 =\n-        CreateTransform(transform1, TransformationMatrix().Rotate3d(0, 45, 0));\n+        CreateTransform(*transform1, TransformationMatrix().Rotate3d(0, 45, 0));\n     TransformPaintPropertyNode::State transform3_state;\n     transform3_state.matrix = TransformationMatrix().Rotate3d(0, 45, 0);\n     transform3_state.flattens_inherited_transform = transform_is_flattened;\n     auto transform3 = TransformPaintPropertyNode::Create(\n-        transform2, std::move(transform3_state));\n+        *transform2, std::move(transform3_state));\n \n     TestPaintArtifact artifact;\n-    artifact\n-        .Chunk(transform3, ClipPaintPropertyNode::Root(),\n-               EffectPaintPropertyNode::Root())\n+    artifact.Chunk(*transform3, c0(), e0())\n         .RectDrawing(FloatRect(0, 0, 300, 200), Color::kWhite);\n     Update(artifact.Build());\n \n@@ -456,41 +422,32 @@ TEST_F(PaintArtifactCompositorTest, FlattensInheritedTransform) {\n \n TEST_F(PaintArtifactCompositorTest, SortingContextID) {\n   // Has no 3D rendering context.\n-  auto transform1 = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                    TransformationMatrix());\n+  auto transform1 = CreateTransform(t0(), TransformationMatrix());\n   // Establishes a 3D rendering context.\n   TransformPaintPropertyNode::State transform2_3_state;\n   transform2_3_state.rendering_context_id = 1;\n   transform2_3_state.direct_compositing_reasons =\n       CompositingReason::k3DTransform;\n   auto transform2 = TransformPaintPropertyNode::Create(\n-      transform1, std::move(transform2_3_state));\n+      *transform1, std::move(transform2_3_state));\n   // Extends the 3D rendering context of transform2.\n   auto transform3 = TransformPaintPropertyNode::Create(\n-      transform2, std::move(transform2_3_state));\n+      *transform2, std::move(transform2_3_state));\n   // Establishes a 3D rendering context distinct from transform2.\n   TransformPaintPropertyNode::State transform4_state;\n   transform4_state.rendering_context_id = 2;\n   transform4_state.direct_compositing_reasons = CompositingReason::k3DTransform;\n   auto transform4 = TransformPaintPropertyNode::Create(\n-      transform2, std::move(transform4_state));\n+      *transform2, std::move(transform4_state));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(transform1, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform1, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kWhite);\n-  artifact\n-      .Chunk(transform2, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform2, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kLightGray);\n-  artifact\n-      .Chunk(transform3, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform3, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kDarkGray);\n-  artifact\n-      .Chunk(transform4, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform4, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 200), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -540,14 +497,10 @@ TEST_F(PaintArtifactCompositorTest, SortingContextID) {\n }\n \n TEST_F(PaintArtifactCompositorTest, OneClip) {\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(100, 100, 300, 200));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(100, 100, 300, 200));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip, e0())\n       .RectDrawing(FloatRect(220, 80, 300, 200), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -568,30 +521,19 @@ TEST_F(PaintArtifactCompositorTest, OneClip) {\n }\n \n TEST_F(PaintArtifactCompositorTest, NestedClips) {\n-  auto clip1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(100, 100, 700, 700),\n+  auto clip1 = CreateClip(c0(), &t0(), FloatRoundedRect(100, 100, 700, 700),\n                           CompositingReason::kOverflowScrollingTouch);\n-  auto clip2 = CreateClip(clip1, TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(200, 200, 700, 700),\n+  auto clip2 = CreateClip(*clip1, &t0(), FloatRoundedRect(200, 200, 700, 700),\n                           CompositingReason::kOverflowScrollingTouch);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip1,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip1, e0())\n       .RectDrawing(FloatRect(300, 350, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip2,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip2, e0())\n       .RectDrawing(FloatRect(300, 350, 100, 100), Color::kLightGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip1,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip1, e0())\n       .RectDrawing(FloatRect(300, 350, 100, 100), Color::kDarkGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip2,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip2, e0())\n       .RectDrawing(FloatRect(300, 350, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -637,18 +579,14 @@ TEST_F(PaintArtifactCompositorTest, NestedClips) {\n }\n \n TEST_F(PaintArtifactCompositorTest, DeeplyNestedClips) {\n-  Vector<scoped_refptr<ClipPaintPropertyNode>> clips;\n+  Vector<std::unique_ptr<ClipPaintPropertyNode>> clips;\n   for (unsigned i = 1; i <= 10; i++) {\n-    clips.push_back(CreateClip(\n-        clips.IsEmpty() ? ClipPaintPropertyNode::Root() : clips.back(),\n-        TransformPaintPropertyNode::Root(),\n-        FloatRoundedRect(5 * i, 0, 100, 200 - 10 * i)));\n+    clips.push_back(CreateClip(clips.IsEmpty() ? c0() : *clips.back(), &t0(),\n+                               FloatRoundedRect(5 * i, 0, 100, 200 - 10 * i)));\n   }\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clips.back(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clips.back(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 200), Color::kWhite);\n   Update(artifact.Build());\n \n@@ -674,22 +612,16 @@ TEST_F(PaintArtifactCompositorTest, DeeplyNestedClips) {\n }\n \n TEST_F(PaintArtifactCompositorTest, SiblingClips) {\n-  auto common_clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                                TransformPaintPropertyNode::Root(),\n-                                FloatRoundedRect(0, 0, 800, 600));\n-  auto clip1 = CreateClip(common_clip, TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(0, 0, 400, 600));\n-  auto clip2 = CreateClip(common_clip, TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(400, 0, 400, 600));\n+  auto common_clip = CreateClip(c0(), &t0(), FloatRoundedRect(0, 0, 800, 600));\n+  auto clip1 =\n+      CreateClip(*common_clip, &t0(), FloatRoundedRect(0, 0, 400, 600));\n+  auto clip2 =\n+      CreateClip(*common_clip, &t0(), FloatRoundedRect(400, 0, 400, 600));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip1,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip1, e0())\n       .RectDrawing(FloatRect(0, 0, 640, 480), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip2,\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip2, e0())\n       .RectDrawing(FloatRect(0, 0, 640, 480), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(2u, ContentLayerCount());\n@@ -731,15 +663,11 @@ TEST_F(PaintArtifactCompositorTest, ForeignLayerPassesThrough) {\n   layer->SetBounds(gfx::Size(400, 300));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact.Chunk(PropertyTreeState::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .ForeignLayer(FloatPoint(50, 60), IntSize(400, 300), layer);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -754,37 +682,30 @@ TEST_F(PaintArtifactCompositorTest, ForeignLayerPassesThrough) {\n \n TEST_F(PaintArtifactCompositorTest, EffectTreeConversion) {\n   EffectPaintPropertyNode::State effect1_state;\n-  effect1_state.local_transform_space = TransformPaintPropertyNode::Root();\n-  effect1_state.output_clip = ClipPaintPropertyNode::Root();\n+  effect1_state.local_transform_space = &t0();\n+  effect1_state.output_clip = &c0();\n   effect1_state.opacity = 0.5;\n   effect1_state.direct_compositing_reasons = CompositingReason::kAll;\n   effect1_state.compositor_element_id = CompositorElementId(2);\n-  auto effect1 = EffectPaintPropertyNode::Create(\n-      EffectPaintPropertyNode::Root(), std::move(effect1_state));\n-  auto effect2 = CreateOpacityEffect(effect1, 0.3, CompositingReason::kAll);\n-  auto effect3 = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.2,\n-                                     CompositingReason::kAll);\n+  auto effect1 =\n+      EffectPaintPropertyNode::Create(e0(), std::move(effect1_state));\n+  auto effect2 = CreateOpacityEffect(*effect1, 0.3, CompositingReason::kAll);\n+  auto effect3 = CreateOpacityEffect(e0(), 0.2, CompositingReason::kAll);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect2.get())\n+  artifact.Chunk(t0(), c0(), *effect2)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect1.get())\n+  artifact.Chunk(t0(), c0(), *effect1)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect3.get())\n+  artifact.Chunk(t0(), c0(), *effect3)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n   Update(artifact.Build());\n \n   ASSERT_EQ(3u, ContentLayerCount());\n \n   const cc::EffectTree& effect_tree = GetPropertyTrees().effect_tree;\n   // Node #0 reserved for null; #1 for root render surface; #2 for\n-  // EffectPaintPropertyNode::root(), plus 3 nodes for those created by\n+  // e0(), plus 3 nodes for those created by\n   // this test.\n   ASSERT_EQ(5u, effect_tree.size());\n \n@@ -829,8 +750,8 @@ static ScrollPaintPropertyNode::State ScrollState2() {\n   return state;\n }\n \n-static scoped_refptr<ScrollPaintPropertyNode> CreateScroll(\n-    scoped_refptr<const ScrollPaintPropertyNode> parent,\n+static std::unique_ptr<ScrollPaintPropertyNode> CreateScroll(\n+    const ScrollPaintPropertyNode& parent,\n     const ScrollPaintPropertyNode::State& state_arg,\n     MainThreadScrollingReasons main_thread_scrolling_reasons =\n         MainThreadScrollingReason::kNotScrollingOnMain,\n@@ -860,17 +781,11 @@ TEST_F(PaintArtifactCompositorTest, OneScrollNode) {\n   CompositorElementId scroll_element_id = ScrollElementId(2);\n   auto scroll = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState1(),\n                              kNotScrollingOnMain, scroll_element_id);\n-  auto scroll_translation =\n-      CreateScrollTranslation(TransformPaintPropertyNode::Root(), 7, 9, scroll);\n+  auto scroll_translation = CreateScrollTranslation(t0(), 7, 9, *scroll);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation);\n-  artifact\n-      .Chunk(scroll_translation, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0()).ScrollHitTest(*scroll_translation);\n+  artifact.Chunk(*scroll_translation, c0(), e0())\n       .RectDrawing(FloatRect(-110, 12, 170, 19), Color::kWhite);\n   Update(artifact.Build());\n \n@@ -920,20 +835,16 @@ TEST_F(PaintArtifactCompositorTest, OneScrollNode) {\n \n TEST_F(PaintArtifactCompositorTest, TransformUnderScrollNode) {\n   auto scroll = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState1());\n-  auto scroll_translation =\n-      CreateScrollTranslation(TransformPaintPropertyNode::Root(), 7, 9, scroll);\n+  auto scroll_translation = CreateScrollTranslation(t0(), 7, 9, *scroll);\n \n   auto transform =\n-      CreateTransform(scroll_translation, TransformationMatrix(),\n+      CreateTransform(*scroll_translation, TransformationMatrix(),\n                       FloatPoint3D(), CompositingReason::k3DTransform);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(scroll_translation, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*scroll_translation, c0(), e0())\n       .RectDrawing(FloatRect(-20, 4, 60, 8), Color::kBlack)\n-      .Chunk(transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+      .Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(1, -30, 5, 70), Color::kWhite);\n   Update(artifact.Build());\n \n@@ -969,35 +880,30 @@ TEST_F(PaintArtifactCompositorTest, TransformUnderScrollNode) {\n }\n \n TEST_F(PaintArtifactCompositorTest, NestedScrollNodes) {\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto effect = CreateOpacityEffect(e0(), 0.5);\n \n   CompositorElementId scroll_element_id_a = ScrollElementId(2);\n   auto scroll_a = CreateScroll(\n       ScrollPaintPropertyNode::Root(), ScrollState1(),\n       MainThreadScrollingReason::kHasBackgroundAttachmentFixedObjects,\n       scroll_element_id_a);\n   auto scroll_translation_a = CreateScrollTranslation(\n-      TransformPaintPropertyNode::Root(), 11, 13, scroll_a,\n-      CompositingReason::kLayerForScrollingContents);\n+      t0(), 11, 13, *scroll_a, CompositingReason::kLayerForScrollingContents);\n \n   CompositorElementId scroll_element_id_b = ScrollElementId(3);\n-  auto scroll_b = CreateScroll(scroll_a, ScrollState2(), kNotScrollingOnMain,\n+  auto scroll_b = CreateScroll(*scroll_a, ScrollState2(), kNotScrollingOnMain,\n                                scroll_element_id_b);\n   auto scroll_translation_b =\n-      CreateScrollTranslation(scroll_translation_a, 37, 41, scroll_b);\n+      CreateScrollTranslation(*scroll_translation_a, 37, 41, *scroll_b);\n   TestPaintArtifact artifact;\n-  artifact.Chunk(scroll_translation_a, ClipPaintPropertyNode::Root(), effect)\n+  artifact.Chunk(*scroll_translation_a, c0(), *effect)\n       .RectDrawing(FloatRect(7, 11, 13, 17), Color::kWhite);\n-  artifact\n-      .Chunk(scroll_translation_a->Parent(), ClipPaintPropertyNode::Root(),\n-             effect)\n-      .ScrollHitTest(scroll_translation_a);\n-  artifact.Chunk(scroll_translation_b, ClipPaintPropertyNode::Root(), effect)\n+  artifact.Chunk(*scroll_translation_a->Parent(), c0(), *effect)\n+      .ScrollHitTest(*scroll_translation_a);\n+  artifact.Chunk(*scroll_translation_b, c0(), *effect)\n       .RectDrawing(FloatRect(1, 2, 3, 5), Color::kWhite);\n-  artifact\n-      .Chunk(scroll_translation_b->Parent(), ClipPaintPropertyNode::Root(),\n-             effect)\n-      .ScrollHitTest(scroll_translation_b);\n+  artifact.Chunk(*scroll_translation_b->Parent(), c0(), *effect)\n+      .ScrollHitTest(*scroll_translation_b);\n   Update(artifact.Build());\n \n   const cc::ScrollTree& scroll_tree = GetPropertyTrees().scroll_tree;\n@@ -1028,29 +934,24 @@ TEST_F(PaintArtifactCompositorTest, NestedScrollNodes) {\n }\n \n TEST_F(PaintArtifactCompositorTest, ScrollHitTestLayerOrder) {\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(0, 0, 100, 100));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(0, 0, 100, 100));\n \n   CompositorElementId scroll_element_id = ScrollElementId(2);\n   auto scroll = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState1(),\n                              kNotScrollingOnMain, scroll_element_id);\n-  auto scroll_translation =\n-      CreateScrollTranslation(TransformPaintPropertyNode::Root(), 7, 9, scroll,\n-                              CompositingReason::kWillChangeCompositingHint);\n+  auto scroll_translation = CreateScrollTranslation(\n+      t0(), 7, 9, *scroll, CompositingReason::kWillChangeCompositingHint);\n \n   auto transform = CreateTransform(\n-      scroll_translation, TransformationMatrix().Translate(5, 5),\n+      *scroll_translation, TransformationMatrix().Translate(5, 5),\n       FloatPoint3D(), CompositingReason::k3DTransform);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(scroll_translation, clip, EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*scroll_translation, *clip, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(scroll_translation->Parent(), clip,\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation);\n-  artifact.Chunk(transform, clip, EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*scroll_translation->Parent(), *clip, e0())\n+      .ScrollHitTest(*scroll_translation);\n+  artifact.Chunk(*transform, *clip, e0())\n       .RectDrawing(FloatRect(0, 0, 50, 50), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -1072,35 +973,27 @@ TEST_F(PaintArtifactCompositorTest, ScrollHitTestLayerOrder) {\n }\n \n TEST_F(PaintArtifactCompositorTest, NestedScrollHitTestLayerOrder) {\n-  auto clip_1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                           TransformPaintPropertyNode::Root(),\n-                           FloatRoundedRect(0, 0, 100, 100));\n+  auto clip_1 = CreateClip(c0(), &t0(), FloatRoundedRect(0, 0, 100, 100));\n   CompositorElementId scroll_1_element_id = ScrollElementId(1);\n   auto scroll_1 = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState1(),\n                                kNotScrollingOnMain, scroll_1_element_id);\n   auto scroll_translation_1 = CreateScrollTranslation(\n-      TransformPaintPropertyNode::Root(), 7, 9, scroll_1,\n-      CompositingReason::kWillChangeCompositingHint);\n+      t0(), 7, 9, *scroll_1, CompositingReason::kWillChangeCompositingHint);\n \n-  auto clip_2 =\n-      CreateClip(clip_1, scroll_translation_1, FloatRoundedRect(0, 0, 50, 50));\n+  auto clip_2 = CreateClip(*clip_1, scroll_translation_1.get(),\n+                           FloatRoundedRect(0, 0, 50, 50));\n   CompositorElementId scroll_2_element_id = ScrollElementId(2);\n   auto scroll_2 = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState2(),\n                                kNotScrollingOnMain, scroll_2_element_id);\n   auto scroll_translation_2 = CreateScrollTranslation(\n-      TransformPaintPropertyNode::Root(), 0, 0, scroll_2,\n-      CompositingReason::kWillChangeCompositingHint);\n+      t0(), 0, 0, *scroll_2, CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(scroll_translation_1->Parent(), clip_1->Parent(),\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation_1);\n-  artifact\n-      .Chunk(scroll_translation_2->Parent(), clip_2->Parent(),\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation_2);\n-  artifact.Chunk(scroll_translation_2, clip_2, EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*scroll_translation_1->Parent(), *clip_1->Parent(), e0())\n+      .ScrollHitTest(*scroll_translation_1);\n+  artifact.Chunk(*scroll_translation_2->Parent(), *clip_2->Parent(), e0())\n+      .ScrollHitTest(*scroll_translation_2);\n+  artifact.Chunk(*scroll_translation_2, *clip_2, e0())\n       .RectDrawing(FloatRect(0, 0, 50, 50), Color::kWhite);\n   Update(artifact.Build());\n \n@@ -1138,24 +1031,18 @@ TEST_F(PaintArtifactCompositorTest, AncestorScrollNodes) {\n   auto scroll_a = CreateScroll(ScrollPaintPropertyNode::Root(), ScrollState1(),\n                                kNotScrollingOnMain, scroll_element_id_a);\n   auto scroll_translation_a = CreateScrollTranslation(\n-      TransformPaintPropertyNode::Root(), 11, 13, scroll_a,\n-      CompositingReason::kLayerForScrollingContents);\n+      t0(), 11, 13, *scroll_a, CompositingReason::kLayerForScrollingContents);\n \n   CompositorElementId scroll_element_id_b = ScrollElementId(3);\n-  auto scroll_b = CreateScroll(scroll_a, ScrollState2(), kNotScrollingOnMain,\n+  auto scroll_b = CreateScroll(*scroll_a, ScrollState2(), kNotScrollingOnMain,\n                                scroll_element_id_b);\n   auto scroll_translation_b =\n-      CreateScrollTranslation(scroll_translation_a, 37, 41, scroll_b);\n+      CreateScrollTranslation(*scroll_translation_a, 37, 41, *scroll_b);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation_b);\n-  artifact\n-      .Chunk(scroll_translation_b, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n-      .ScrollHitTest(scroll_translation_a);\n+  artifact.Chunk(t0(), c0(), e0()).ScrollHitTest(*scroll_translation_b);\n+  artifact.Chunk(*scroll_translation_b, c0(), e0())\n+      .ScrollHitTest(*scroll_translation_a);\n   Update(artifact.Build());\n \n   const cc::ScrollTree& scroll_tree = GetPropertyTrees().scroll_tree;\n@@ -1192,13 +1079,9 @@ TEST_F(PaintArtifactCompositorTest, AncestorScrollNodes) {\n \n TEST_F(PaintArtifactCompositorTest, MergeSimpleChunks) {\n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1220,22 +1103,14 @@ TEST_F(PaintArtifactCompositorTest, MergeSimpleChunks) {\n }\n \n TEST_F(PaintArtifactCompositorTest, MergeClip) {\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 20, 50, 60));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 20, 50, 60));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip.get(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), *clip, e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1260,22 +1135,16 @@ TEST_F(PaintArtifactCompositorTest, MergeClip) {\n }\n \n TEST_F(PaintArtifactCompositorTest, Merge2DTransform) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(50, 50),\n-                                   FloatPoint3D(100, 100, 0));\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(50, 50),\n+                      FloatPoint3D(100, 100, 0));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(transform.get(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1300,24 +1169,18 @@ TEST_F(PaintArtifactCompositorTest, Merge2DTransform) {\n }\n \n TEST_F(PaintArtifactCompositorTest, Merge2DTransformDirectAncestor) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix(), FloatPoint3D(),\n+  auto transform = CreateTransform(t0(), TransformationMatrix(), FloatPoint3D(),\n                                    CompositingReason::k3DTransform);\n-\n   auto transform2 =\n-      CreateTransform(transform.get(), TransformationMatrix().Translate(50, 50),\n+      CreateTransform(*transform, TransformationMatrix().Translate(50, 50),\n                       FloatPoint3D(100, 100, 0));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(transform.get(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n   // The second chunk can merge into the first because it has a descendant\n   // state of the first's transform and no direct compositing reason.\n-  test_artifact\n-      .Chunk(transform2.get(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform2, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1339,22 +1202,15 @@ TEST_F(PaintArtifactCompositorTest, Merge2DTransformDirectAncestor) {\n }\n \n TEST_F(PaintArtifactCompositorTest, MergeTransformOrigin) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Rotate(45),\n+  auto transform = CreateTransform(t0(), TransformationMatrix().Rotate(45),\n                                    FloatPoint3D(100, 100, 0));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(transform.get(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1379,20 +1235,14 @@ TEST_F(PaintArtifactCompositorTest, MergeTransformOrigin) {\n \n TEST_F(PaintArtifactCompositorTest, MergeOpacity) {\n   float opacity = 2.0 / 255.0;\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), opacity);\n+  auto effect = CreateOpacityEffect(e0(), opacity);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  test_artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1419,28 +1269,20 @@ TEST_F(PaintArtifactCompositorTest, MergeOpacity) {\n TEST_F(PaintArtifactCompositorTest, MergeNested) {\n   // Tests merging of an opacity effect, inside of a clip, inside of a\n   // transform.\n-\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(50, 50),\n-                                   FloatPoint3D(100, 100, 0));\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(), transform.get(),\n-                         FloatRoundedRect(10, 20, 50, 60));\n-\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(50, 50),\n+                      FloatPoint3D(100, 100, 0));\n+  auto clip =\n+      CreateClip(c0(), transform.get(), FloatRoundedRect(10, 20, 50, 60));\n   float opacity = 2.0 / 255.0;\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), transform,\n-                                    clip, opacity);\n+  auto effect = CreateOpacityEffect(e0(), transform.get(), clip.get(), opacity);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact.Chunk(transform.get(), clip.get(), effect.get())\n+  test_artifact.Chunk(*transform, *clip, *effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1468,30 +1310,21 @@ TEST_F(PaintArtifactCompositorTest, ClipPushedUp) {\n   // Tests merging of an element which has a clipapplied to it,\n   // but has an ancestor transform of them. This can happen for fixed-\n   // or absolute-position elements which escape scroll transforms.\n-\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(20, 25),\n-                                   FloatPoint3D(100, 100, 0));\n-\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(20, 25),\n+                      FloatPoint3D(100, 100, 0));\n   auto transform2 =\n-      CreateTransform(transform.get(), TransformationMatrix().Translate(20, 25),\n+      CreateTransform(*transform, TransformationMatrix().Translate(20, 25),\n                       FloatPoint3D(100, 100, 0));\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(), transform2.get(),\n-                         FloatRoundedRect(10, 20, 50, 60));\n+  auto clip =\n+      CreateClip(c0(), transform2.get(), FloatRoundedRect(10, 20, 50, 60));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip.get(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), *clip, e0())\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1523,30 +1356,23 @@ TEST_F(PaintArtifactCompositorTest, EffectPushedUp_DISABLED) {\n   // but has an ancestor transform of them. This can happen for fixed-\n   // or absolute-position elements which escape scroll transforms.\n \n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(20, 25),\n-                                   FloatPoint3D(100, 100, 0));\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(20, 25),\n+                      FloatPoint3D(100, 100, 0));\n \n   auto transform2 =\n-      CreateTransform(transform.get(), TransformationMatrix().Translate(20, 25),\n+      CreateTransform(*transform, TransformationMatrix().Translate(20, 25),\n                       FloatPoint3D(100, 100, 0));\n \n   float opacity = 2.0 / 255.0;\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), transform2,\n-                                    ClipPaintPropertyNode::Root(), opacity);\n+  auto effect = CreateOpacityEffect(e0(), transform2.get(), &c0(), opacity);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  test_artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1576,33 +1402,25 @@ TEST_F(PaintArtifactCompositorTest, EffectAndClipPushedUp_DISABLED) {\n   // Tests merging of an element which has an effect applied to it,\n   // but has an ancestor transform of them. This can happen for fixed-\n   // or absolute-position elements which escape scroll transforms.\n-\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(20, 25),\n-                                   FloatPoint3D(100, 100, 0));\n-\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(20, 25),\n+                      FloatPoint3D(100, 100, 0));\n   auto transform2 =\n-      CreateTransform(transform.get(), TransformationMatrix().Translate(20, 25),\n+      CreateTransform(*transform, TransformationMatrix().Translate(20, 25),\n                       FloatPoint3D(100, 100, 0));\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(), transform.get(),\n-                         FloatRoundedRect(10, 20, 50, 60));\n+  auto clip =\n+      CreateClip(c0(), transform.get(), FloatRoundedRect(10, 20, 50, 60));\n \n   float opacity = 2.0 / 255.0;\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), transform2,\n-                                    clip, opacity);\n+  auto effect =\n+      CreateOpacityEffect(e0(), transform2.get(), clip.get(), opacity);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip.get(), effect.get())\n+  test_artifact.Chunk(t0(), *clip, *effect)\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1630,27 +1448,16 @@ TEST_F(PaintArtifactCompositorTest, EffectAndClipPushedUp_DISABLED) {\n TEST_F(PaintArtifactCompositorTest, ClipAndEffectNoTransform) {\n   // Tests merging of an element which has a clip and effect in the root\n   // transform space.\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 20, 50, 60));\n-\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 20, 50, 60));\n   float opacity = 2.0 / 255.0;\n-  auto effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(), clip, opacity);\n+  auto effect = CreateOpacityEffect(e0(), &t0(), clip.get(), opacity);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip.get(), effect.get())\n+  test_artifact.Chunk(t0(), *clip, *effect)\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1676,26 +1483,15 @@ TEST_F(PaintArtifactCompositorTest, ClipAndEffectNoTransform) {\n TEST_F(PaintArtifactCompositorTest, TwoClips) {\n   // Tests merging of an element which has two clips in the root\n   // transform space.\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(20, 30, 10, 20));\n-\n-  auto clip2 = CreateClip(clip.get(), TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(10, 20, 50, 60));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(20, 30, 10, 20));\n+  auto clip2 = CreateClip(*clip, &t0(), FloatRoundedRect(10, 20, 50, 60));\n \n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip2.get(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), *clip2, e0())\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1719,26 +1515,19 @@ TEST_F(PaintArtifactCompositorTest, TwoClips) {\n }\n \n TEST_F(PaintArtifactCompositorTest, TwoTransformsClipBetween) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(20, 25),\n-                                   FloatPoint3D(100, 100, 0));\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(0, 0, 50, 60));\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(20, 25),\n+                      FloatPoint3D(100, 100, 0));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(0, 0, 50, 60));\n   auto transform2 =\n-      CreateTransform(transform.get(), TransformationMatrix().Translate(20, 25),\n+      CreateTransform(*transform, TransformationMatrix().Translate(20, 25),\n                       FloatPoint3D(100, 100, 0));\n   TestPaintArtifact test_artifact;\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(transform2.get(), clip.get(), EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform2, *clip, e0())\n       .RectDrawing(FloatRect(0, 0, 300, 400), Color::kBlack);\n-  test_artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1760,19 +1549,16 @@ TEST_F(PaintArtifactCompositorTest, TwoTransformsClipBetween) {\n }\n \n TEST_F(PaintArtifactCompositorTest, OverlapTransform) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(50, 50),\n-                                   FloatPoint3D(100, 100, 0),\n-                                   CompositingReason::k3DTransform);\n+  auto transform = CreateTransform(\n+      t0(), TransformationMatrix().Translate(50, 50), FloatPoint3D(100, 100, 0),\n+      CompositingReason::k3DTransform);\n \n   TestPaintArtifact test_artifact;\n-  test_artifact.Chunk(PropertyTreeState::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  test_artifact\n-      .Chunk(transform.get(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  test_artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  test_artifact.Chunk(PropertyTreeState::Root())\n+  test_artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 200, 300), Color::kGray);\n \n   const PaintArtifact& artifact = test_artifact.Build();\n@@ -1797,18 +1583,17 @@ TEST_F(PaintArtifactCompositorTest, MightOverlap) {\n     EXPECT_TRUE(MightOverlap(pending_layer, pending_layer2));\n   }\n \n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(99, 0),\n-                                   FloatPoint3D(100, 100, 0));\n+  auto transform = CreateTransform(\n+      t0(), TransformationMatrix().Translate(99, 0), FloatPoint3D(100, 100, 0));\n   {\n     paint_chunk2.properties.SetTransform(transform.get());\n     PendingLayer pending_layer2(paint_chunk2, 1, false);\n     EXPECT_TRUE(MightOverlap(pending_layer, pending_layer2));\n   }\n \n-  auto transform2 = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                    TransformationMatrix().Translate(100, 0),\n-                                    FloatPoint3D(100, 100, 0));\n+  auto transform2 =\n+      CreateTransform(t0(), TransformationMatrix().Translate(100, 0),\n+                      FloatPoint3D(100, 100, 0));\n   {\n     paint_chunk2.properties.SetTransform(transform2.get());\n     PendingLayer pending_layer2(paint_chunk2, 1, false);\n@@ -1851,14 +1636,12 @@ TEST_F(PaintArtifactCompositorTest, PendingLayer) {\n }\n \n TEST_F(PaintArtifactCompositorTest, PendingLayerWithGeometry) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix().Translate(20, 25),\n-                                   FloatPoint3D(100, 100, 0));\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(20, 25),\n+                      FloatPoint3D(100, 100, 0));\n \n   PaintChunk chunk1 = DefaultChunk();\n-  chunk1.properties = PropertyTreeState(TransformPaintPropertyNode::Root(),\n-                                        ClipPaintPropertyNode::Root(),\n-                                        EffectPaintPropertyNode::Root());\n+  chunk1.properties = PropertyTreeState::Root();\n   chunk1.bounds = FloatRect(0, 0, 30, 40);\n \n   PendingLayer pending_layer(chunk1, 0, false);\n@@ -1867,7 +1650,7 @@ TEST_F(PaintArtifactCompositorTest, PendingLayerWithGeometry) {\n \n   PaintChunk chunk2 = DefaultChunk();\n   chunk2.properties = chunk1.properties;\n-  chunk2.properties.SetTransform(transform);\n+  chunk2.properties.SetTransform(transform.get());\n   chunk2.bounds = FloatRect(0, 0, 50, 60);\n   pending_layer.Merge(PendingLayer(chunk2, 1, false));\n \n@@ -1878,9 +1661,7 @@ TEST_F(PaintArtifactCompositorTest, PendingLayerWithGeometry) {\n // The test is disabled because opaque rect mapping is not implemented yet.\n TEST_F(PaintArtifactCompositorTest, PendingLayerKnownOpaque_DISABLED) {\n   PaintChunk chunk1 = DefaultChunk();\n-  chunk1.properties = PropertyTreeState(TransformPaintPropertyNode::Root(),\n-                                        ClipPaintPropertyNode::Root(),\n-                                        EffectPaintPropertyNode::Root());\n+  chunk1.properties = PropertyTreeState::Root();\n   chunk1.bounds = FloatRect(0, 0, 30, 40);\n   chunk1.known_to_be_opaque = false;\n   PendingLayer pending_layer(chunk1, 0, false);\n@@ -1908,34 +1689,30 @@ TEST_F(PaintArtifactCompositorTest, PendingLayerKnownOpaque_DISABLED) {\n   EXPECT_EQ(pending_layer.bounds, pending_layer.rect_known_to_be_opaque);\n }\n \n-scoped_refptr<EffectPaintPropertyNode> CreateSampleEffectNodeWithElementId() {\n+std::unique_ptr<EffectPaintPropertyNode> CreateSampleEffectNodeWithElementId() {\n   EffectPaintPropertyNode::State state;\n-  state.local_transform_space = TransformPaintPropertyNode::Root();\n-  state.output_clip = ClipPaintPropertyNode::Root();\n+  state.local_transform_space = &t0();\n+  state.output_clip = &c0();\n   state.opacity = 2.0 / 255.0;\n   state.direct_compositing_reasons = CompositingReason::kActiveOpacityAnimation;\n   state.compositor_element_id = CompositorElementId(2);\n-  return EffectPaintPropertyNode::Create(EffectPaintPropertyNode::Root(),\n-                                         std::move(state));\n+  return EffectPaintPropertyNode::Create(e0(), std::move(state));\n }\n \n-scoped_refptr<TransformPaintPropertyNode>\n+std::unique_ptr<TransformPaintPropertyNode>\n CreateSampleTransformNodeWithElementId() {\n   TransformPaintPropertyNode::State state;\n   state.matrix.Rotate(90);\n   state.origin = FloatPoint3D(100, 100, 0);\n   state.direct_compositing_reasons = CompositingReason::k3DTransform;\n   state.compositor_element_id = CompositorElementId(3);\n-  return TransformPaintPropertyNode::Create(TransformPaintPropertyNode::Root(),\n-                                            std::move(state));\n+  return TransformPaintPropertyNode::Create(t0(), std::move(state));\n }\n \n TEST_F(PaintArtifactCompositorTest, TransformWithElementId) {\n   auto transform = CreateSampleTransformNodeWithElementId();\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -1946,37 +1723,30 @@ TEST_F(PaintArtifactCompositorTest, TransformWithElementId) {\n TEST_F(PaintArtifactCompositorTest, EffectWithElementId) {\n   auto effect = CreateSampleEffectNodeWithElementId();\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   Update(artifact.Build());\n \n   EXPECT_EQ(2, ElementIdToEffectNodeIndex(effect->GetCompositorElementId()));\n }\n \n TEST_F(PaintArtifactCompositorTest, CompositedLuminanceMask) {\n-  auto masked =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 1.0,\n-                          CompositingReason::kIsolateCompositedDescendants);\n+  auto masked = CreateOpacityEffect(\n+      e0(), 1.0, CompositingReason::kIsolateCompositedDescendants);\n   EffectPaintPropertyNode::State masking_state;\n-  masking_state.local_transform_space = TransformPaintPropertyNode::Root();\n-  masking_state.output_clip = ClipPaintPropertyNode::Root();\n+  masking_state.local_transform_space = &t0();\n+  masking_state.output_clip = &c0();\n   masking_state.color_filter = kColorFilterLuminanceToAlpha;\n   masking_state.blend_mode = SkBlendMode::kDstIn;\n   masking_state.direct_compositing_reasons =\n       CompositingReason::kSquashingDisallowed;\n   auto masking =\n-      EffectPaintPropertyNode::Create(masked, std::move(masking_state));\n+      EffectPaintPropertyNode::Create(*masked, std::move(masking_state));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             masked.get())\n+  artifact.Chunk(t0(), c0(), *masked)\n       .RectDrawing(FloatRect(100, 100, 200, 200), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             masking.get())\n+  artifact.Chunk(t0(), c0(), *masking)\n       .RectDrawing(FloatRect(150, 150, 100, 100), Color::kWhite);\n   Update(artifact.Build());\n   ASSERT_EQ(2u, ContentLayerCount());\n@@ -2007,22 +1777,16 @@ TEST_F(PaintArtifactCompositorTest, CompositedLuminanceMask) {\n \n TEST_F(PaintArtifactCompositorTest, UpdateProducesNewSequenceNumber) {\n   // A 90 degree clockwise rotation about (100, 100).\n-  auto transform = CreateTransform(\n-      TransformPaintPropertyNode::Root(), TransformationMatrix().Rotate(90),\n-      FloatPoint3D(100, 100, 0), CompositingReason::k3DTransform);\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(100, 100, 300, 200));\n-\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto transform = CreateTransform(t0(), TransformationMatrix().Rotate(90),\n+                                   FloatPoint3D(100, 100, 0),\n+                                   CompositingReason::k3DTransform);\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(100, 100, 300, 200));\n+  auto effect = CreateOpacityEffect(e0(), 0.5);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(transform, clip, effect)\n+  artifact.Chunk(*transform, *clip, *effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kWhite);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kGray);\n   Update(artifact.Build());\n \n@@ -2057,19 +1821,12 @@ TEST_F(PaintArtifactCompositorTest, UpdateProducesNewSequenceNumber) {\n TEST_F(PaintArtifactCompositorTest, DecompositeClip) {\n   // A clipped paint chunk that gets merged into a previous layer should\n   // only contribute clipped bounds to the layer bound.\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(75, 75, 100, 100));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(75, 75, 100, 100));\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 50, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), clip.get(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), *clip, e0())\n       .RectDrawing(FloatRect(100, 100, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -2084,20 +1841,14 @@ TEST_F(PaintArtifactCompositorTest, DecompositeEffect) {\n   // group compositing descendants should not be composited and can merge\n   // with other chunks.\n \n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto effect = CreateOpacityEffect(e0(), 0.5);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 25, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(25, 75, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(75, 75, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -2110,21 +1861,14 @@ TEST_F(PaintArtifactCompositorTest, DecompositeEffect) {\n \n TEST_F(PaintArtifactCompositorTest, DirectlyCompositedEffect) {\n   // An effect node with direct compositing shall be composited.\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5f,\n-                                    CompositingReason::kAll);\n+  auto effect = CreateOpacityEffect(e0(), 0.5f, CompositingReason::kAll);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 25, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(25, 75, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(75, 75, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(3u, ContentLayerCount());\n@@ -2152,22 +1896,16 @@ TEST_F(PaintArtifactCompositorTest, DecompositeDeepEffect) {\n   // A paint chunk may enter multiple level effects with or without compositing\n   // reasons. This test verifies we still decomposite effects without a direct\n   // reason, but stop at a directly composited effect.\n-  auto effect1 = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.1f);\n-  auto effect2 = CreateOpacityEffect(effect1, 0.2f, CompositingReason::kAll);\n-  auto effect3 = CreateOpacityEffect(effect2, 0.3f);\n+  auto effect1 = CreateOpacityEffect(e0(), 0.1f);\n+  auto effect2 = CreateOpacityEffect(*effect1, 0.2f, CompositingReason::kAll);\n+  auto effect3 = CreateOpacityEffect(*effect2, 0.3f);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 25, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect3.get())\n+  artifact.Chunk(t0(), c0(), *effect3)\n       .RectDrawing(FloatRect(25, 75, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(75, 75, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(3u, ContentLayerCount());\n@@ -2197,21 +1935,16 @@ TEST_F(PaintArtifactCompositorTest, DecompositeDeepEffect) {\n TEST_F(PaintArtifactCompositorTest, IndirectlyCompositedEffect) {\n   // An effect node without direct compositing still needs to be composited\n   // for grouping, if some chunks need to be composited.\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5f);\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix(), FloatPoint3D(),\n+  auto effect = CreateOpacityEffect(e0(), 0.5f);\n+  auto transform = CreateTransform(t0(), TransformationMatrix(), FloatPoint3D(),\n                                    CompositingReason::k3DTransform);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 25, 100, 100), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(25, 75, 100, 100), Color::kGray);\n-  artifact.Chunk(transform.get(), ClipPaintPropertyNode::Root(), effect.get())\n+  artifact.Chunk(*transform, c0(), *effect)\n       .RectDrawing(FloatRect(75, 75, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(3u, ContentLayerCount());\n@@ -2238,34 +1971,25 @@ TEST_F(PaintArtifactCompositorTest, IndirectlyCompositedEffect) {\n TEST_F(PaintArtifactCompositorTest, DecompositedEffectNotMergingDueToOverlap) {\n   // This tests an effect that doesn't need to be composited, but needs\n   // separate backing due to overlap with a previous composited effect.\n-  auto effect1 = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.1f);\n-  auto effect2 = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.2f);\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix(), FloatPoint3D(),\n+  auto effect1 = CreateOpacityEffect(e0(), 0.1f);\n+  auto effect2 = CreateOpacityEffect(e0(), 0.2f);\n+  auto transform = CreateTransform(t0(), TransformationMatrix(), FloatPoint3D(),\n                                    CompositingReason::k3DTransform);\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 50, 50), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect1.get())\n+  artifact.Chunk(t0(), c0(), *effect1)\n       .RectDrawing(FloatRect(100, 0, 50, 50), Color::kGray);\n   // This chunk has a transform that must be composited, thus causing effect1\n   // to be composited too.\n-  artifact.Chunk(transform.get(), ClipPaintPropertyNode::Root(), effect1.get())\n+  artifact.Chunk(*transform, c0(), *effect1)\n       .RectDrawing(FloatRect(200, 0, 50, 50), Color::kGray);\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect2.get())\n+  artifact.Chunk(t0(), c0(), *effect2)\n       .RectDrawing(FloatRect(200, 100, 50, 50), Color::kGray);\n   // This chunk overlaps with the 2nd chunk, but is seemingly safe to merge.\n   // However because effect1 gets composited due to a composited transform,\n   // we can't merge with effect1 nor skip it to merge with the first chunk.\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect2.get())\n+  artifact.Chunk(t0(), c0(), *effect2)\n       .RectDrawing(FloatRect(100, 0, 50, 50), Color::kGray);\n \n   Update(artifact.Build());\n@@ -2299,12 +2023,9 @@ TEST_F(PaintArtifactCompositorTest, UpdatePopulatesCompositedElementIds) {\n   auto transform = CreateSampleTransformNodeWithElementId();\n   auto effect = CreateSampleEffectNodeWithElementId();\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(transform, ClipPaintPropertyNode::Root(),\n-             EffectPaintPropertyNode::Root())\n+  artifact.Chunk(*transform, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack)\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+      .Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n \n   CompositorElementIdSet composited_element_ids;\n@@ -2411,27 +2132,22 @@ TEST_F(PaintArtifactCompositorTest, DontSkipChunkWithAboveMinimumOpacity) {\n \n TEST_F(PaintArtifactCompositorTest,\n        DontSkipChunkWithTinyOpacityAndDirectCompositingReason) {\n-  auto effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.0001f,\n-                                    CompositingReason::kCanvas);\n+  auto effect = CreateOpacityEffect(e0(), 0.0001f, CompositingReason::kCanvas);\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect)\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n }\n \n TEST_F(PaintArtifactCompositorTest,\n        SkipChunkWithTinyOpacityAndVisibleChildEffectNode) {\n-  auto tiny_effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(),\n-                                         0.0001f, CompositingReason::kNone);\n+  auto tiny_effect =\n+      CreateOpacityEffect(e0(), 0.0001f, CompositingReason::kNone);\n   auto visible_effect =\n-      CreateOpacityEffect(tiny_effect, 0.5f, CompositingReason::kNone);\n+      CreateOpacityEffect(*tiny_effect, 0.5f, CompositingReason::kNone);\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             visible_effect)\n+  artifact.Chunk(t0(), c0(), *visible_effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(0u, ContentLayerCount());\n@@ -2440,28 +2156,23 @@ TEST_F(PaintArtifactCompositorTest,\n TEST_F(\n     PaintArtifactCompositorTest,\n     DontSkipChunkWithTinyOpacityAndVisibleChildEffectNodeWithCompositingParent) {\n-  auto tiny_effect = CreateOpacityEffect(EffectPaintPropertyNode::Root(),\n-                                         0.0001f, CompositingReason::kCanvas);\n-  auto visible_effect = CreateOpacityEffect(tiny_effect, 0.5f);\n+  auto tiny_effect =\n+      CreateOpacityEffect(e0(), 0.0001f, CompositingReason::kCanvas);\n+  auto visible_effect = CreateOpacityEffect(*tiny_effect, 0.5f);\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             visible_effect)\n+  artifact.Chunk(t0(), c0(), *visible_effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n }\n \n TEST_F(PaintArtifactCompositorTest,\n        SkipChunkWithTinyOpacityAndVisibleChildEffectNodeWithCompositingChild) {\n-  auto tiny_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.0001f);\n+  auto tiny_effect = CreateOpacityEffect(e0(), 0.0001f);\n   auto visible_effect =\n-      CreateOpacityEffect(tiny_effect, 0.5f, CompositingReason::kCanvas);\n+      CreateOpacityEffect(*tiny_effect, 0.5f, CompositingReason::kCanvas);\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             visible_effect)\n+  artifact.Chunk(t0(), c0(), *visible_effect)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(0u, ContentLayerCount());\n@@ -2473,9 +2184,7 @@ TEST_F(PaintArtifactCompositorTest, UpdateManagesLayerElementIds) {\n \n   {\n     TestPaintArtifact artifact;\n-    artifact\n-        .Chunk(transform, ClipPaintPropertyNode::Root(),\n-               EffectPaintPropertyNode::Root())\n+    artifact.Chunk(*transform, c0(), e0())\n         .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n \n     Update(artifact.Build());\n@@ -2498,11 +2207,11 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipSimple) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2547,12 +2256,12 @@ TEST_F(PaintArtifactCompositorTest,\n        SynthesizedClipIndirectlyCompositedClipPath) {\n   // This tests the case that a clip node needs to be synthesized due to\n   // applying clip path to a composited effect.\n-  auto c1 = CreateClipPathClip(c0(), t0(), FloatRoundedRect(50, 50, 300, 200));\n-  auto e1 = CreateOpacityEffect(e0(), t0(), c1, 1,\n+  auto c1 = CreateClipPathClip(c0(), &t0(), FloatRoundedRect(50, 50, 300, 200));\n+  auto e1 = CreateOpacityEffect(e0(), &t0(), c1.get(), 1,\n                                 CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e1)\n+  artifact.Chunk(t0(), *c1, *e1)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2607,13 +2316,13 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipContiguous) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t1, c1, e0())\n+  artifact.Chunk(*t1, *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2676,15 +2385,15 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipDiscontiguous) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t1, c0(), e0())\n+  artifact.Chunk(*t1, c0(), e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2765,18 +2474,17 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipAcrossChildEffect) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n-\n-  auto e1 = CreateOpacityEffect(e0(), t0(), c1, 1,\n+  auto e1 = CreateOpacityEffect(e0(), &t0(), c1.get(), 1,\n                                 CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e1)\n+  artifact.Chunk(t0(), *c1, *e1)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2836,7 +2544,7 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipRespectOutputClip) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n \n   CompositorFilterOperations non_trivial_filter;\n@@ -2845,11 +2553,11 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipRespectOutputClip) {\n                                CompositingReason::kWillChangeCompositingHint);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e1)\n+  artifact.Chunk(t0(), *c1, *e1)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -2941,23 +2649,23 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipDelegateBlending) {\n   FloatSize corner(5, 5);\n   FloatRoundedRect rrect(FloatRect(50, 50, 300, 200), corner, corner, corner,\n                          corner);\n-  auto c1 = CreateClip(c0(), t0(), rrect,\n+  auto c1 = CreateClip(c0(), &t0(), rrect,\n                        CompositingReason::kWillChangeCompositingHint);\n \n   EffectPaintPropertyNode::State e1_state;\n-  e1_state.local_transform_space = t0();\n-  e1_state.output_clip = c1;\n+  e1_state.local_transform_space = &t0();\n+  e1_state.output_clip = c1.get();\n   e1_state.blend_mode = SkBlendMode::kMultiply;\n   e1_state.direct_compositing_reasons =\n       CompositingReason::kWillChangeCompositingHint;\n   auto e1 = EffectPaintPropertyNode::Create(e0(), std::move(e1_state));\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e1)\n+  artifact.Chunk(t0(), *c1, *e1)\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n-  artifact.Chunk(t0(), c1, e0())\n+  artifact.Chunk(t0(), *c1, e0())\n       .RectDrawing(FloatRect(0, 0, 100, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -3045,9 +2753,7 @@ TEST_F(PaintArtifactCompositorTest, SynthesizedClipDelegateBlending) {\n TEST_F(PaintArtifactCompositorTest, WillBeRemovedFromFrame) {\n   auto effect = CreateSampleEffectNodeWithElementId();\n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect.get())\n+  artifact.Chunk(t0(), c0(), *effect)\n       .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);\n   Update(artifact.Build());\n \n@@ -3060,7 +2766,7 @@ TEST_F(PaintArtifactCompositorTest, WillBeRemovedFromFrame) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsNonOpaque) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 200), Color::kBlack);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -3069,7 +2775,7 @@ TEST_F(PaintArtifactCompositorTest, ContentsNonOpaque) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsOpaque) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 200), Color::kBlack)\n       .KnownToBeOpaque();\n   Update(artifact.Build());\n@@ -3079,7 +2785,7 @@ TEST_F(PaintArtifactCompositorTest, ContentsOpaque) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsOpaqueSubpixel) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100.5, 100.5, 200, 200), Color::kBlack)\n       .KnownToBeOpaque();\n   Update(artifact.Build());\n@@ -3090,10 +2796,10 @@ TEST_F(PaintArtifactCompositorTest, ContentsOpaqueSubpixel) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedNonOpaque) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 200), Color::kBlack)\n       .KnownToBeOpaque()\n-      .Chunk(PropertyTreeState::Root())\n+      .Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(200, 200, 200, 200), Color::kBlack)\n       .KnownToBeOpaque();\n   Update(artifact.Build());\n@@ -3104,10 +2810,10 @@ TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedNonOpaque) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedOpaque1) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 300, 300), Color::kBlack)\n       .KnownToBeOpaque()\n-      .Chunk(PropertyTreeState::Root())\n+      .Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(200, 200, 200, 200), Color::kBlack)\n       .KnownToBeOpaque();\n   Update(artifact.Build());\n@@ -3118,10 +2824,10 @@ TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedOpaque1) {\n \n TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedOpaque2) {\n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 200, 200), Color::kBlack)\n       .KnownToBeOpaque()\n-      .Chunk(PropertyTreeState::Root())\n+      .Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(100, 100, 300, 300), Color::kBlack)\n       .KnownToBeOpaque();\n   Update(artifact.Build());\n@@ -3135,18 +2841,13 @@ TEST_F(PaintArtifactCompositorTest, ContentsOpaqueUnitedOpaque2) {\n TEST_F(PaintArtifactCompositorTest, DecompositeEffectWithNoOutputClip) {\n   // This test verifies effect nodes with no output clip correctly decomposites\n   // if there is no compositing reasons.\n-  auto clip1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(75, 75, 100, 100));\n-\n-  auto effect1 =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(), nullptr, 0.5);\n+  auto clip1 = CreateClip(c0(), &t0(), FloatRoundedRect(75, 75, 100, 100));\n+  auto effect1 = CreateOpacityEffect(e0(), &t0(), nullptr, 0.5);\n \n   TestPaintArtifact artifact;\n-  artifact.Chunk(PropertyTreeState::Root())\n+  artifact.Chunk(t0(), c0(), e0())\n       .RectDrawing(FloatRect(50, 50, 100, 100), Color::kGray);\n-  artifact.Chunk(TransformPaintPropertyNode::Root(), clip1.get(), effect1.get())\n+  artifact.Chunk(t0(), *clip1, *effect1)\n       .RectDrawing(FloatRect(100, 100, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -3160,20 +2861,15 @@ TEST_F(PaintArtifactCompositorTest, DecompositeEffectWithNoOutputClip) {\n TEST_F(PaintArtifactCompositorTest, CompositedEffectWithNoOutputClip) {\n   // This test verifies effect nodes with no output clip but has compositing\n   // reason correctly squash children chunks and assign clip node.\n-  auto clip1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(75, 75, 100, 100));\n+  auto clip1 = CreateClip(c0(), &t0(), FloatRoundedRect(75, 75, 100, 100));\n \n-  auto effect1 = CreateOpacityEffect(EffectPaintPropertyNode::Root(),\n-                                     TransformPaintPropertyNode::Root(),\n-                                     nullptr, 0.5, CompositingReason::kAll);\n+  auto effect1 =\n+      CreateOpacityEffect(e0(), &t0(), nullptr, 0.5, CompositingReason::kAll);\n \n   TestPaintArtifact artifact;\n-  artifact\n-      .Chunk(TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-             effect1.get())\n+  artifact.Chunk(t0(), c0(), *effect1)\n       .RectDrawing(FloatRect(50, 50, 100, 100), Color::kGray);\n-  artifact.Chunk(TransformPaintPropertyNode::Root(), clip1.get(), effect1.get())\n+  artifact.Chunk(t0(), *clip1, *effect1)\n       .RectDrawing(FloatRect(100, 100, 100, 100), Color::kGray);\n   Update(artifact.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -3187,13 +2883,9 @@ TEST_F(PaintArtifactCompositorTest, CompositedEffectWithNoOutputClip) {\n \n TEST_F(PaintArtifactCompositorTest, LayerRasterInvalidationWithClip) {\n   // The layer's painting is initially not clipped.\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 20, 300, 400));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 20, 300, 400));\n   TestPaintArtifact artifact1;\n-  artifact1\n-      .Chunk(TransformPaintPropertyNode::Root(), clip,\n-             EffectPaintPropertyNode::Root())\n+  artifact1.Chunk(t0(), *clip, e0())\n       .RectDrawing(FloatRect(50, 50, 200, 200), Color::kBlack);\n   Update(artifact1.Build());\n   ASSERT_EQ(1u, ContentLayerCount());\n@@ -3207,9 +2899,7 @@ TEST_F(PaintArtifactCompositorTest, LayerRasterInvalidationWithClip) {\n \n   // The layer's painting overflows the left, top, right edges of the clip .\n   TestPaintArtifact artifact2;\n-  artifact2\n-      .Chunk(artifact1.Client(0), TransformPaintPropertyNode::Root(), clip,\n-             EffectPaintPropertyNode::Root())\n+  artifact2.Chunk(artifact1.Client(0), t0(), *clip, e0())\n       .RectDrawing(artifact1.Client(1), FloatRect(0, 0, 400, 200),\n                    Color::kBlack);\n   layer->ResetNeedsDisplayForTesting();\n@@ -3227,9 +2917,7 @@ TEST_F(PaintArtifactCompositorTest, LayerRasterInvalidationWithClip) {\n \n   // The layer's painting overflows all edges of the clip.\n   TestPaintArtifact artifact3;\n-  artifact3\n-      .Chunk(artifact1.Client(0), TransformPaintPropertyNode::Root(), clip,\n-             EffectPaintPropertyNode::Root())\n+  artifact3.Chunk(artifact1.Client(0), t0(), *clip, e0())\n       .RectDrawing(artifact1.Client(1), FloatRect(-100, -200, 500, 800),\n                    Color::kBlack);\n   layer->ResetNeedsDisplayForTesting();""}<_**next**_>{""sha"": ""10b7226bc9cf61a99e99d32285f4b8c87dac2fb9"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -653,7 +653,7 @@ void ConversionContext::Convert(const PaintChunkSubset& paint_chunks,\n       // \""draw\"" this record in order to ensure that the effect has correct\n       // visual rects.\n       if ((!record || record->size() == 0) &&\n-          chunk_state.Effect() == EffectPaintPropertyNode::Root()) {\n+          chunk_state.Effect() == &EffectPaintPropertyNode::Root()) {\n         continue;\n       }\n ""}<_**next**_>{""sha"": ""ddbe6519f2a7f341102f5aeaa3a478eb2298f10c"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer_test.cc"", ""status"": ""modified"", ""additions"": 142, ""deletions"": 152, ""changes"": 294, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/paint_chunks_to_cc_layer_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -147,17 +147,6 @@ class PaintRecordMatcher\n     EXPECT_EQ(SkRRect(r), clip_op->rrect);                     \\\n   } while (false)\n \n-// Convenient shorthands.\n-const TransformPaintPropertyNode* t0() {\n-  return TransformPaintPropertyNode::Root();\n-}\n-const ClipPaintPropertyNode* c0() {\n-  return ClipPaintPropertyNode::Root();\n-}\n-const EffectPaintPropertyNode* e0() {\n-  return EffectPaintPropertyNode::Root();\n-}\n-\n PaintChunk::Id DefaultId() {\n   DEFINE_STATIC_LOCAL(FakeDisplayItemClient, fake_client,\n                       (\""FakeDisplayItemClient\"", LayoutRect(0, 0, 100, 100)));\n@@ -169,9 +158,9 @@ struct TestChunks {\n   DisplayItemList items = DisplayItemList(0);\n \n   // Add a paint chunk with a non-empty paint record and given property nodes.\n-  void AddChunk(const TransformPaintPropertyNode* t,\n-                const ClipPaintPropertyNode* c,\n-                const EffectPaintPropertyNode* e,\n+  void AddChunk(const TransformPaintPropertyNode& t,\n+                const ClipPaintPropertyNode& c,\n+                const EffectPaintPropertyNode& e,\n                 const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {\n     auto record = sk_make_sp<PaintRecord>();\n     record->push<cc::DrawRectOp>(bounds, cc::PaintFlags());\n@@ -180,14 +169,14 @@ struct TestChunks {\n \n   // Add a paint chunk with a given paint record and property nodes.\n   void AddChunk(sk_sp<PaintRecord> record,\n-                const TransformPaintPropertyNode* t,\n-                const ClipPaintPropertyNode* c,\n-                const EffectPaintPropertyNode* e,\n+                const TransformPaintPropertyNode& t,\n+                const ClipPaintPropertyNode& c,\n+                const EffectPaintPropertyNode& e,\n                 const FloatRect& bounds = FloatRect(0, 0, 100, 100)) {\n     size_t i = items.size();\n     items.AllocateAndConstruct<DrawingDisplayItem>(\n         DefaultId().client, DefaultId().type, std::move(record));\n-    chunks.emplace_back(i, i + 1, DefaultId(), PropertyTreeState(t, c, e));\n+    chunks.emplace_back(i, i + 1, DefaultId(), PropertyTreeState(&t, &c, &e));\n     chunks.back().bounds = bounds;\n   }\n };\n@@ -196,12 +185,12 @@ TEST_F(PaintChunksToCcLayerTest, EffectGroupingSimple) {\n   // This test verifies effects are applied as a group.\n   auto e1 = CreateOpacityEffect(e0(), 0.5f);\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c0(), e1.get(), FloatRect(0, 0, 50, 50));\n-  chunks.AddChunk(t0(), c0(), e1.get(), FloatRect(20, 20, 70, 70));\n+  chunks.AddChunk(t0(), c0(), *e1, FloatRect(0, 0, 50, 50));\n+  chunks.AddChunk(t0(), c0(), *e1, FloatRect(20, 20, 70, 70));\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(\n@@ -216,15 +205,15 @@ TEST_F(PaintChunksToCcLayerTest, EffectGroupingSimple) {\n TEST_F(PaintChunksToCcLayerTest, EffectGroupingNested) {\n   // This test verifies nested effects are grouped properly.\n   auto e1 = CreateOpacityEffect(e0(), 0.5f);\n-  auto e2 = CreateOpacityEffect(e1, 0.5f);\n-  auto e3 = CreateOpacityEffect(e1, 0.5f);\n+  auto e2 = CreateOpacityEffect(*e1, 0.5f);\n+  auto e3 = CreateOpacityEffect(*e1, 0.5f);\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c0(), e2.get());\n-  chunks.AddChunk(t0(), c0(), e3.get(), FloatRect(111, 222, 333, 444));\n+  chunks.AddChunk(t0(), c0(), *e2);\n+  chunks.AddChunk(t0(), c0(), *e3, FloatRect(111, 222, 333, 444));\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(\n@@ -245,19 +234,19 @@ TEST_F(PaintChunksToCcLayerTest, EffectGroupingNested) {\n TEST_F(PaintChunksToCcLayerTest, EffectFilterGroupingNestedWithTransforms) {\n   // This test verifies nested effects with transforms are grouped properly.\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto t2 = CreateTransform(t1, TransformationMatrix().Translate(-50, -50));\n-  auto e1 = CreateOpacityEffect(e0(), t2, c0(), 0.5);\n+  auto t2 = CreateTransform(*t1, TransformationMatrix().Translate(-50, -50));\n+  auto e1 = CreateOpacityEffect(e0(), t2.get(), &c0(), 0.5);\n \n   CompositorFilterOperations filter;\n   filter.AppendBlurFilter(5);\n-  auto e2 = CreateFilterEffect(e1, filter, FloatPoint(60, 60));\n+  auto e2 = CreateFilterEffect(*e1, filter, FloatPoint(60, 60));\n   TestChunks chunks;\n-  chunks.AddChunk(t2.get(), c0(), e1.get(), FloatRect(0, 0, 50, 50));\n-  chunks.AddChunk(t1.get(), c0(), e2.get(), FloatRect(20, 20, 70, 70));\n+  chunks.AddChunk(*t2, c0(), *e1, FloatRect(0, 0, 50, 50));\n+  chunks.AddChunk(*t1, c0(), *e2, FloatRect(20, 20, 70, 70));\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(\n@@ -295,22 +284,22 @@ TEST_F(PaintChunksToCcLayerTest, InterleavedClipEffect) {\n   // ConversionContext.\n   // Refer to PaintChunksToCcLayer.cpp for detailed explanation.\n   // (Search \""State management example\"".)\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c2 = CreateClip(c1, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c3 = CreateClip(c2, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c4 = CreateClip(c3, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto e1 = CreateOpacityEffect(e0(), t0(), c2, 0.5);\n-  auto e2 = CreateOpacityEffect(e1, t0(), c4, 0.5);\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c2 = CreateClip(*c1, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c3 = CreateClip(*c2, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c4 = CreateClip(*c3, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto e1 = CreateOpacityEffect(e0(), &t0(), c2.get(), 0.5);\n+  auto e2 = CreateOpacityEffect(*e1, &t0(), c4.get(), 0.5);\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c2.get(), e0());\n-  chunks.AddChunk(t0(), c3.get(), e0());\n-  chunks.AddChunk(t0(), c4.get(), e2.get(), FloatRect(0, 0, 50, 50));\n-  chunks.AddChunk(t0(), c3.get(), e1.get(), FloatRect(20, 20, 70, 70));\n-  chunks.AddChunk(t0(), c4.get(), e0());\n+  chunks.AddChunk(t0(), *c2, e0());\n+  chunks.AddChunk(t0(), *c3, e0());\n+  chunks.AddChunk(t0(), *c4, *e2, FloatRect(0, 0, 50, 50));\n+  chunks.AddChunk(t0(), *c3, *e1, FloatRect(20, 20, 70, 70));\n+  chunks.AddChunk(t0(), *c4, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(*output, PaintRecordMatcher::Make(\n@@ -349,13 +338,13 @@ TEST_F(PaintChunksToCcLayerTest, ClipSpaceInversion) {\n   //     <div style=\""position:fixed;\"">Clipped but not scroll along.</div>\n   // </div>\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto c1 = CreateClip(c0(), t1, FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), t1.get(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e0());\n+  chunks.AddChunk(t0(), *c1, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(*output,\n@@ -377,14 +366,14 @@ TEST_F(PaintChunksToCcLayerTest, OpacityEffectSpaceInversion) {\n   //   </div>\n   // </div>\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto e1 = CreateOpacityEffect(e0(), t1, c0(), 0.5);\n+  auto e1 = CreateOpacityEffect(e0(), t1.get(), &c0(), 0.5);\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c0(), e1.get());\n-  chunks.AddChunk(t1.get(), c0(), e1.get());\n+  chunks.AddChunk(t0(), c0(), *e1);\n+  chunks.AddChunk(*t1, c0(), *e1);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(*output,\n@@ -413,13 +402,14 @@ TEST_F(PaintChunksToCcLayerTest, FilterEffectSpaceInversion) {\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n   CompositorFilterOperations filter;\n   filter.AppendBlurFilter(5);\n-  auto e1 = CreateFilterEffect(e0(), t1, c0(), filter, FloatPoint(66, 88));\n+  auto e1 =\n+      CreateFilterEffect(e0(), t1.get(), &c0(), filter, FloatPoint(66, 88));\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c0(), e1.get());\n+  chunks.AddChunk(t0(), c0(), *e1);\n \n   auto output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(\n@@ -446,10 +436,10 @@ TEST_F(PaintChunksToCcLayerTest, NonRootLayerSimple) {\n   // This test verifies a layer with composited property state does not\n   // apply properties again internally.\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   auto e1 = CreateOpacityEffect(e0(), 0.5f);\n   TestChunks chunks;\n-  chunks.AddChunk(t1.get(), c1.get(), e1.get());\n+  chunks.AddChunk(*t1, *c1, *e1);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n@@ -464,10 +454,10 @@ TEST_F(PaintChunksToCcLayerTest, NonRootLayerTransformEscape) {\n   // This test verifies chunks that have a shallower transform state than the\n   // layer can still be painted.\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   auto e1 = CreateOpacityEffect(e0(), 0.5f);\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e1.get());\n+  chunks.AddChunk(t0(), *c1, *e1);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n@@ -484,16 +474,16 @@ TEST_F(PaintChunksToCcLayerTest, NonRootLayerTransformEscape) {\n \n TEST_F(PaintChunksToCcLayerTest, EffectWithNoOutputClip) {\n   // This test verifies effect with no output clip can be correctly processed.\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c2 = CreateClip(c1, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto e1 = CreateOpacityEffect(e0(), t0(), nullptr, 0.5);\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c2 = CreateClip(*c1, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto e1 = CreateOpacityEffect(e0(), &t0(), nullptr, 0.5);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c2.get(), e1.get());\n+  chunks.AddChunk(t0(), *c2, *e1);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c1.get(), e0()),\n+          chunks.chunks, PropertyTreeState(&t0(), c1.get(), &e0()),\n           gfx::Vector2dF(), chunks.items,\n           cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n@@ -510,16 +500,16 @@ TEST_F(PaintChunksToCcLayerTest, EffectWithNoOutputClip) {\n \n TEST_F(PaintChunksToCcLayerTest,\n        EffectWithNoOutputClipNestedInDecompositedEffect) {\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   auto e1 = CreateOpacityEffect(e0(), 0.5);\n-  auto e2 = CreateOpacityEffect(e1, t0(), nullptr, 0.5);\n+  auto e2 = CreateOpacityEffect(*e1, &t0(), nullptr, 0.5);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e2.get());\n+  chunks.AddChunk(t0(), *c1, *e2);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n   EXPECT_THAT(\n@@ -538,16 +528,16 @@ TEST_F(PaintChunksToCcLayerTest,\n \n TEST_F(PaintChunksToCcLayerTest,\n        EffectWithNoOutputClipNestedInCompositedEffect) {\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   auto e1 = CreateOpacityEffect(e0(), 0.5);\n-  auto e2 = CreateOpacityEffect(e1, t0(), nullptr, 0.5);\n+  auto e2 = CreateOpacityEffect(*e1, &t0(), nullptr, 0.5);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e2.get());\n+  chunks.AddChunk(t0(), *c1, *e2);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e1.get()),\n+          chunks.chunks, PropertyTreeState(&t0(), &c0(), e1.get()),\n           gfx::Vector2dF(), chunks.items,\n           cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n@@ -564,16 +554,16 @@ TEST_F(PaintChunksToCcLayerTest,\n \n TEST_F(PaintChunksToCcLayerTest,\n        EffectWithNoOutputClipNestedInCompositedEffectAndClip) {\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n   auto e1 = CreateOpacityEffect(e0(), 0.5);\n-  auto e2 = CreateOpacityEffect(e1, t0(), nullptr, 0.5);\n+  auto e2 = CreateOpacityEffect(*e1, &t0(), nullptr, 0.5);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e2.get());\n+  chunks.AddChunk(t0(), *c1, *e2);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c1.get(), e1.get()),\n+          chunks.chunks, PropertyTreeState(&t0(), c1.get(), e1.get()),\n           gfx::Vector2dF(), chunks.items,\n           cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n@@ -589,15 +579,15 @@ TEST_F(PaintChunksToCcLayerTest, VisualRect) {\n   auto layer_transform =\n       CreateTransform(t0(), TransformationMatrix().Scale(20));\n   auto chunk_transform = CreateTransform(\n-      layer_transform, TransformationMatrix().Translate(50, 100));\n+      *layer_transform, TransformationMatrix().Translate(50, 100));\n \n   TestChunks chunks;\n-  chunks.AddChunk(chunk_transform.get(), c0(), e0());\n+  chunks.AddChunk(*chunk_transform, c0(), e0());\n \n   auto cc_list = base::MakeRefCounted<cc::DisplayItemList>(\n       cc::DisplayItemList::kTopLevelDisplayItemList);\n   PaintChunksToCcLayer::ConvertInto(\n-      chunks.chunks, PropertyTreeState(layer_transform.get(), c0(), e0()),\n+      chunks.chunks, PropertyTreeState(layer_transform.get(), &c0(), &e0()),\n       gfx::Vector2dF(100, 200), FloatSize(), chunks.items, *cc_list);\n   EXPECT_EQ(gfx::Rect(-50, -100, 100, 100), cc_list->VisualRectForTesting(4));\n \n@@ -613,15 +603,15 @@ TEST_F(PaintChunksToCcLayerTest, VisualRect) {\n }\n \n TEST_F(PaintChunksToCcLayerTest, NoncompositedClipPath) {\n-  auto c1 = CreateClipPathClip(c0(), t0(), FloatRoundedRect(1, 2, 3, 4));\n+  auto c1 = CreateClipPathClip(c0(), &t0(), FloatRoundedRect(1, 2, 3, 4));\n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c1.get(), e0());\n+  chunks.AddChunk(t0(), *c1, e0());\n \n   auto cc_list = base::MakeRefCounted<cc::DisplayItemList>(\n       cc::DisplayItemList::kTopLevelDisplayItemList);\n-  PaintChunksToCcLayer::ConvertInto(\n-      chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n-      FloatSize(), chunks.items, *cc_list);\n+  PaintChunksToCcLayer::ConvertInto(chunks.chunks, PropertyTreeState::Root(),\n+                                    gfx::Vector2dF(), FloatSize(), chunks.items,\n+                                    *cc_list);\n \n   EXPECT_THAT(\n       *cc_list->ReleaseAsRecord(),\n@@ -633,22 +623,22 @@ TEST_F(PaintChunksToCcLayerTest, NoncompositedClipPath) {\n }\n \n TEST_F(PaintChunksToCcLayerTest, EmptyClipsAreElided) {\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c1c2 = CreateClip(c1, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c2 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1c2 = CreateClip(*c1, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c2 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n \n   TestChunks chunks;\n-  chunks.AddChunk(nullptr, t0(), c1.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1c2.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1c2.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1c2.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1.get(), e0());\n+  chunks.AddChunk(nullptr, t0(), *c1, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1c2, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1c2, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1c2, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1, e0());\n   // D1\n-  chunks.AddChunk(t0(), c2.get(), e0());\n+  chunks.AddChunk(t0(), *c2, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -662,23 +652,23 @@ TEST_F(PaintChunksToCcLayerTest, EmptyClipsAreElided) {\n }\n \n TEST_F(PaintChunksToCcLayerTest, NonEmptyClipsAreStored) {\n-  auto c1 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c1c2 = CreateClip(c1, t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n-  auto c2 = CreateClip(c0(), t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c1c2 = CreateClip(*c1, &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n+  auto c2 = CreateClip(c0(), &t0(), FloatRoundedRect(0.f, 0.f, 1.f, 1.f));\n \n   TestChunks chunks;\n-  chunks.AddChunk(nullptr, t0(), c1.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1c2.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1c2.get(), e0());\n+  chunks.AddChunk(nullptr, t0(), *c1, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1c2, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1c2, e0());\n   // D1\n-  chunks.AddChunk(t0(), c1c2.get(), e0());\n-  chunks.AddChunk(nullptr, t0(), c1.get(), e0());\n+  chunks.AddChunk(t0(), *c1c2, e0());\n+  chunks.AddChunk(nullptr, t0(), *c1, e0());\n   // D2\n-  chunks.AddChunk(t0(), c2.get(), e0());\n+  chunks.AddChunk(t0(), *c2, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -698,11 +688,11 @@ TEST_F(PaintChunksToCcLayerTest, EmptyEffectsAreStored) {\n \n   TestChunks chunks;\n   chunks.AddChunk(nullptr, t0(), c0(), e0());\n-  chunks.AddChunk(nullptr, t0(), c0(), e1.get());\n+  chunks.AddChunk(nullptr, t0(), c0(), *e1);\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -716,20 +706,20 @@ TEST_F(PaintChunksToCcLayerTest, EmptyEffectsAreStored) {\n TEST_F(PaintChunksToCcLayerTest, CombineClips) {\n   FloatRoundedRect clip_rect(0, 0, 100, 100);\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto c1 = CreateClip(c0(), t0(), clip_rect);\n-  auto c2 = CreateClip(c1, t0(), clip_rect);\n-  auto c3 = CreateClip(c2, t1, clip_rect);\n-  auto c4 = CreateClip(c3, t1, clip_rect);\n-  auto c5 = CreateClipPathClip(c4, t1, clip_rect);\n-  auto c6 = CreateClip(c5, t1, clip_rect);\n+  auto c1 = CreateClip(c0(), &t0(), clip_rect);\n+  auto c2 = CreateClip(*c1, &t0(), clip_rect);\n+  auto c3 = CreateClip(*c2, t1.get(), clip_rect);\n+  auto c4 = CreateClip(*c3, t1.get(), clip_rect);\n+  auto c5 = CreateClipPathClip(*c4, t1.get(), clip_rect);\n+  auto c6 = CreateClip(*c5, t1.get(), clip_rect);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t1.get(), c6.get(), e0());\n-  chunks.AddChunk(t1.get(), c3.get(), e0());\n+  chunks.AddChunk(*t1, *c6, e0());\n+  chunks.AddChunk(*t1, *c3, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -758,20 +748,20 @@ TEST_F(PaintChunksToCcLayerTest, CombineClipsWithRoundedRects) {\n   FloatRoundedRect small_rounded_clip_rect(FloatRect(0, 0, 100, 100), corner,\n                                            corner, corner, corner);\n \n-  auto c1 = CreateClip(c0(), t0(), clip_rect);\n-  auto c2 = CreateClip(c1, t0(), small_rounded_clip_rect);\n-  auto c3 = CreateClip(c2, t0(), clip_rect);\n-  auto c4 = CreateClip(c3, t0(), big_rounded_clip_rect);\n-  auto c5 = CreateClip(c4, t0(), clip_rect);\n-  auto c6 = CreateClip(c5, t0(), big_rounded_clip_rect);\n-  auto c7 = CreateClip(c6, t0(), small_rounded_clip_rect);\n+  auto c1 = CreateClip(c0(), &t0(), clip_rect);\n+  auto c2 = CreateClip(*c1, &t0(), small_rounded_clip_rect);\n+  auto c3 = CreateClip(*c2, &t0(), clip_rect);\n+  auto c4 = CreateClip(*c3, &t0(), big_rounded_clip_rect);\n+  auto c5 = CreateClip(*c4, &t0(), clip_rect);\n+  auto c6 = CreateClip(*c5, &t0(), big_rounded_clip_rect);\n+  auto c7 = CreateClip(*c6, &t0(), small_rounded_clip_rect);\n \n   TestChunks chunks;\n-  chunks.AddChunk(t0(), c7.get(), e0());\n+  chunks.AddChunk(t0(), *c7, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -799,21 +789,21 @@ TEST_F(PaintChunksToCcLayerTest, CombineClipsWithRoundedRects) {\n \n TEST_F(PaintChunksToCcLayerTest, ChunksSamePropertyTreeState) {\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2.f));\n-  auto t2 = CreateTransform(t1, TransformationMatrix().Scale(3.f));\n-  auto c1 = CreateClip(c0(), t1, FloatRoundedRect(0, 0, 100, 100));\n+  auto t2 = CreateTransform(*t1, TransformationMatrix().Scale(3.f));\n+  auto c1 = CreateClip(c0(), t1.get(), FloatRoundedRect(0, 0, 100, 100));\n \n   TestChunks chunks;\n   chunks.AddChunk(t0(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c1.get(), e0());\n-  chunks.AddChunk(t1.get(), c1.get(), e0());\n-  chunks.AddChunk(t2.get(), c1.get(), e0());\n-  chunks.AddChunk(t2.get(), c1.get(), e0());\n+  chunks.AddChunk(*t1, c0(), e0());\n+  chunks.AddChunk(*t1, c0(), e0());\n+  chunks.AddChunk(*t1, *c1, e0());\n+  chunks.AddChunk(*t1, *c1, e0());\n+  chunks.AddChunk(*t2, *c1, e0());\n+  chunks.AddChunk(*t2, *c1, e0());\n \n   sk_sp<PaintRecord> output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -836,23 +826,23 @@ TEST_F(PaintChunksToCcLayerTest, ChunksSamePropertyTreeState) {\n \n TEST_F(PaintChunksToCcLayerTest, NoOpForIdentityTransforms) {\n   auto t1 = CreateTransform(t0(), TransformationMatrix());\n-  auto t2 = CreateTransform(t1, TransformationMatrix());\n-  auto t3 = CreateTransform(t2, TransformationMatrix());\n-  auto c1 = CreateClip(c0(), t2, FloatRoundedRect(0, 0, 100, 100));\n-  auto c2 = CreateClip(c1, t3, FloatRoundedRect(0, 0, 200, 50));\n+  auto t2 = CreateTransform(*t1, TransformationMatrix());\n+  auto t3 = CreateTransform(*t2, TransformationMatrix());\n+  auto c1 = CreateClip(c0(), t2.get(), FloatRoundedRect(0, 0, 100, 100));\n+  auto c2 = CreateClip(*c1, t3.get(), FloatRoundedRect(0, 0, 200, 50));\n \n   TestChunks chunks;\n   chunks.AddChunk(t0(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e0());\n+  chunks.AddChunk(*t1, c0(), e0());\n   chunks.AddChunk(t0(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e0());\n-  chunks.AddChunk(t2.get(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c2.get(), e0());\n+  chunks.AddChunk(*t1, c0(), e0());\n+  chunks.AddChunk(*t2, c0(), e0());\n+  chunks.AddChunk(*t1, c0(), e0());\n+  chunks.AddChunk(*t1, *c2, e0());\n \n   auto output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -871,17 +861,17 @@ TEST_F(PaintChunksToCcLayerTest, NoOpForIdentityTransforms) {\n \n TEST_F(PaintChunksToCcLayerTest, EffectsWithSameTransform) {\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2));\n-  auto e1 = CreateOpacityEffect(e0(), t1, c0(), 0.1f);\n-  auto e2 = CreateOpacityEffect(e0(), t1, c0(), 0.2f);\n+  auto e1 = CreateOpacityEffect(e0(), t1.get(), &c0(), 0.1f);\n+  auto e2 = CreateOpacityEffect(e0(), t1.get(), &c0(), 0.2f);\n \n   TestChunks chunks;\n   chunks.AddChunk(t0(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e1.get());\n-  chunks.AddChunk(t1.get(), c0(), e2.get());\n+  chunks.AddChunk(*t1, c0(), *e1);\n+  chunks.AddChunk(*t1, c0(), *e2);\n \n   auto output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n \n@@ -900,17 +890,17 @@ TEST_F(PaintChunksToCcLayerTest, EffectsWithSameTransform) {\n \n TEST_F(PaintChunksToCcLayerTest, NestedEffectsWithSameTransform) {\n   auto t1 = CreateTransform(t0(), TransformationMatrix().Scale(2));\n-  auto e1 = CreateOpacityEffect(e0(), t1, c0(), 0.1f);\n-  auto e2 = CreateOpacityEffect(e1, t1, c0(), 0.2f);\n+  auto e1 = CreateOpacityEffect(e0(), t1.get(), &c0(), 0.1f);\n+  auto e2 = CreateOpacityEffect(*e1, t1.get(), &c0(), 0.2f);\n \n   TestChunks chunks;\n   chunks.AddChunk(t0(), c0(), e0());\n-  chunks.AddChunk(t1.get(), c0(), e1.get());\n-  chunks.AddChunk(t1.get(), c0(), e2.get());\n+  chunks.AddChunk(*t1, c0(), *e1);\n+  chunks.AddChunk(*t1, c0(), *e2);\n \n   auto output =\n       PaintChunksToCcLayer::Convert(\n-          chunks.chunks, PropertyTreeState(t0(), c0(), e0()), gfx::Vector2dF(),\n+          chunks.chunks, PropertyTreeState::Root(), gfx::Vector2dF(),\n           chunks.items, cc::DisplayItemList::kToBeReleasedAsPaintOpBuffer)\n           ->ReleaseAsRecord();\n ""}<_**next**_>{""sha"": ""b414400b98c69ccdbdcc4af14263f5f3781b1870"", ""filename"": ""third_party/blink/renderer/platform/graphics/compositing/property_tree_manager.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 6, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/property_tree_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/compositing/property_tree_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/compositing/property_tree_manager.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -91,7 +91,7 @@ void PropertyTreeManager::SetupRootTransformNode() {\n   transform_tree.SetFromScreen(kRealRootNodeId, from_screen);\n   transform_tree.set_needs_update(true);\n \n-  transform_node_map_.Set(TransformPaintPropertyNode::Root(),\n+  transform_node_map_.Set(&TransformPaintPropertyNode::Root(),\n                           transform_node.id);\n   root_layer_->SetTransformTreeIndex(transform_node.id);\n }\n@@ -109,7 +109,7 @@ void PropertyTreeManager::SetupRootClipNode() {\n       gfx::SizeF(root_layer_->layer_tree_host()->device_viewport_size()));\n   clip_node.transform_id = kRealRootNodeId;\n \n-  clip_node_map_.Set(ClipPaintPropertyNode::Root(), clip_node.id);\n+  clip_node_map_.Set(&ClipPaintPropertyNode::Root(), clip_node.id);\n   root_layer_->SetClipTreeIndex(clip_node.id);\n }\n \n@@ -133,7 +133,7 @@ void PropertyTreeManager::SetupRootEffectNode() {\n \n   current_effect_id_ = effect_node.id;\n   current_effect_type_ = CcEffectType::kEffect;\n-  current_effect_ = EffectPaintPropertyNode::Root();\n+  current_effect_ = &EffectPaintPropertyNode::Root();\n   current_clip_ = current_effect_->OutputClip();\n }\n \n@@ -146,7 +146,7 @@ void PropertyTreeManager::SetupRootScrollNode() {\n   DCHECK_EQ(scroll_node.id, kSecondaryRootNodeId);\n   scroll_node.transform_id = kSecondaryRootNodeId;\n \n-  scroll_node_map_.Set(ScrollPaintPropertyNode::Root(), scroll_node.id);\n+  scroll_node_map_.Set(&ScrollPaintPropertyNode::Root(), scroll_node.id);\n   root_layer_->SetScrollTreeIndex(scroll_node.id);\n }\n \n@@ -314,8 +314,7 @@ void PropertyTreeManager::EmitClipMaskLayer() {\n   mask_effect.has_render_surface = true;\n   mask_effect.blend_mode = SkBlendMode::kDstIn;\n \n-  const TransformPaintPropertyNode* clip_space =\n-      current_clip_->LocalTransformSpace();\n+  const auto* clip_space = current_clip_->LocalTransformSpace();\n   root_layer_->AddChild(mask_layer);\n   mask_layer->set_property_tree_sequence_number(sequence_number_);\n   mask_layer->SetTransformTreeIndex(EnsureCompositorTransformNode(clip_space));""}<_**next**_>{""sha"": ""e7ffa52795ca1cb7d33ec55d323dbdc3383b8fb6"", ""filename"": ""third_party/blink/renderer/platform/graphics/graphics_layer_test.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/graphics_layer_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/graphics_layer_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/graphics_layer_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -223,11 +223,11 @@ TEST_P(GraphicsLayerTest, Paint) {\n \n TEST_P(GraphicsLayerTest, PaintRecursively) {\n   IntRect interest_rect(1, 2, 3, 4);\n-  auto* transform_root = TransformPaintPropertyNode::Root();\n+  const auto& transform_root = TransformPaintPropertyNode::Root();\n   auto transform1 =\n       CreateTransform(transform_root, TransformationMatrix().Translate(10, 20));\n   auto transform2 =\n-      CreateTransform(transform1, TransformationMatrix().Scale(2));\n+      CreateTransform(*transform1, TransformationMatrix().Scale(2));\n \n   client_.SetPainter([&](const GraphicsLayer* layer, GraphicsContext& context,\n                          GraphicsLayerPaintingPhase, const IntRect&) {\n@@ -250,13 +250,13 @@ TEST_P(GraphicsLayerTest, PaintRecursively) {\n   transform1->Update(transform_root,\n                      TransformPaintPropertyNode::State{\n                          TransformationMatrix().Translate(20, 30)});\n-  EXPECT_TRUE(transform1->Changed(*transform_root));\n-  EXPECT_TRUE(transform2->Changed(*transform_root));\n+  EXPECT_TRUE(transform1->Changed(transform_root));\n+  EXPECT_TRUE(transform2->Changed(transform_root));\n   client_.SetNeedsRepaint(true);\n   graphics_layer_->PaintRecursively();\n \n-  EXPECT_FALSE(transform1->Changed(*transform_root));\n-  EXPECT_FALSE(transform2->Changed(*transform_root));\n+  EXPECT_FALSE(transform1->Changed(transform_root));\n+  EXPECT_FALSE(transform2->Changed(transform_root));\n }\n \n TEST_P(GraphicsLayerTest, SetDrawsContentFalse) {""}<_**next**_>{""sha"": ""adf29b91f9205ec7e923b7b8442c7796304fe610"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 6, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -8,12 +8,11 @@\n \n namespace blink {\n \n-ClipPaintPropertyNode* ClipPaintPropertyNode::Root() {\n-  DEFINE_STATIC_REF(\n+const ClipPaintPropertyNode& ClipPaintPropertyNode::Root() {\n+  DEFINE_STATIC_LOCAL(\n       ClipPaintPropertyNode, root,\n-      (ClipPaintPropertyNode::Create(\n-          nullptr, State{TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(LayoutRect::InfiniteIntRect())})));\n+      (nullptr, State{&TransformPaintPropertyNode::Root(),\n+                      FloatRoundedRect(LayoutRect::InfiniteIntRect())}));\n   return root;\n }\n \n@@ -22,7 +21,7 @@ std::unique_ptr<JSONObject> ClipPaintPropertyNode::ToJSON() const {\n   if (Parent())\n     json->SetString(\""parent\"", String::Format(\""%p\"", Parent()));\n   json->SetString(\""localTransformSpace\"",\n-                  String::Format(\""%p\"", state_.local_transform_space.get()));\n+                  String::Format(\""%p\"", state_.local_transform_space));\n   json->SetString(\""rect\"", state_.clip_rect.ToString());\n   if (state_.clip_rect_excluding_overlay_scrollbars) {\n     json->SetString(\""rectExcludingOverlayScrollbars\"",""}<_**next**_>{""sha"": ""8cc614ea2ba078fcf1badd9fbcfa5f98891bd30f"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 18, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/clip_paint_property_node.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -5,6 +5,7 @@\n #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_CLIP_PAINT_PROPERTY_NODE_H_\n #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_CLIP_PAINT_PROPERTY_NODE_H_\n \n+#include \""base/memory/scoped_refptr.h\""\n #include \""base/optional.h\""\n #include \""third_party/blink/renderer/platform/geometry/float_rounded_rect.h\""\n #include \""third_party/blink/renderer/platform/graphics/paint/geometry_mapper_clip_cache.h\""\n@@ -29,7 +30,7 @@ class PLATFORM_EXPORT ClipPaintPropertyNode\n   // To make it less verbose and more readable to construct and update a node,\n   // a struct with default values is used to represent the state.\n   struct State {\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space;\n+    const TransformPaintPropertyNode* local_transform_space = nullptr;\n     FloatRoundedRect clip_rect;\n     base::Optional<FloatRoundedRect> clip_rect_excluding_overlay_scrollbars;\n     scoped_refptr<const RefCountedPath> clip_path;\n@@ -53,18 +54,17 @@ class PLATFORM_EXPORT ClipPaintPropertyNode\n   };\n \n   // This node is really a sentinel, and does not represent a real clip space.\n-  static ClipPaintPropertyNode* Root();\n+  static const ClipPaintPropertyNode& Root();\n \n-  static scoped_refptr<ClipPaintPropertyNode> Create(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n+  static std::unique_ptr<ClipPaintPropertyNode> Create(\n+      const ClipPaintPropertyNode& parent,\n       State&& state) {\n-    return base::AdoptRef(\n-        new ClipPaintPropertyNode(std::move(parent), std::move(state)));\n+    return base::WrapUnique(\n+        new ClipPaintPropertyNode(&parent, std::move(state)));\n   }\n \n-  bool Update(scoped_refptr<const ClipPaintPropertyNode> parent,\n-              State&& state) {\n-    bool parent_changed = SetParent(parent);\n+  bool Update(const ClipPaintPropertyNode& parent, State&& state) {\n+    bool parent_changed = SetParent(&parent);\n     if (state == state_)\n       return parent_changed;\n \n@@ -73,14 +73,13 @@ class PLATFORM_EXPORT ClipPaintPropertyNode\n     return true;\n   }\n \n-  bool EqualIgnoringHitTestRects(\n-      scoped_refptr<const ClipPaintPropertyNode> parent,\n-      const State& state) const {\n+  bool EqualIgnoringHitTestRects(const ClipPaintPropertyNode* parent,\n+                                 const State& state) const {\n     return parent == Parent() && state_.EqualIgnoringHitTestRects(state);\n   }\n \n   const TransformPaintPropertyNode* LocalTransformSpace() const {\n-    return state_.local_transform_space.get();\n+    return state_.local_transform_space;\n   }\n   const FloatRoundedRect& ClipRect() const { return state_.clip_rect; }\n   const FloatRoundedRect& ClipRectExcludingOverlayScrollbars() const {\n@@ -98,8 +97,8 @@ class PLATFORM_EXPORT ClipPaintPropertyNode\n #if DCHECK_IS_ON()\n   // The clone function is used by FindPropertiesNeedingUpdate.h for recording\n   // a clip node before it has been updated, to later detect changes.\n-  scoped_refptr<ClipPaintPropertyNode> Clone() const {\n-    return base::AdoptRef(new ClipPaintPropertyNode(Parent(), State(state_)));\n+  std::unique_ptr<ClipPaintPropertyNode> Clone() const {\n+    return base::WrapUnique(new ClipPaintPropertyNode(Parent(), State(state_)));\n   }\n \n   // The equality operator is used by FindPropertiesNeedingUpdate.h for checking\n@@ -115,9 +114,8 @@ class PLATFORM_EXPORT ClipPaintPropertyNode\n   size_t CacheMemoryUsageInBytes() const;\n \n  private:\n-  ClipPaintPropertyNode(scoped_refptr<const ClipPaintPropertyNode> parent,\n-                        State&& state)\n-      : PaintPropertyNode(std::move(parent)), state_(std::move(state)) {}\n+  ClipPaintPropertyNode(const ClipPaintPropertyNode* parent, State&& state)\n+      : PaintPropertyNode(parent), state_(std::move(state)) {}\n \n   // For access to GetClipCache();\n   friend class GeometryMapper;""}<_**next**_>{""sha"": ""0750252d6378e1e568860375f49f220eb9945e0a"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 7, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -6,11 +6,10 @@\n \n namespace blink {\n \n-EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {\n-  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,\n-                    (EffectPaintPropertyNode::Create(\n-                        nullptr, State{TransformPaintPropertyNode::Root(),\n-                                       ClipPaintPropertyNode::Root()})));\n+const EffectPaintPropertyNode& EffectPaintPropertyNode::Root() {\n+  DEFINE_STATIC_LOCAL(EffectPaintPropertyNode, root,\n+                      (nullptr, State{&TransformPaintPropertyNode::Root(),\n+                                      &ClipPaintPropertyNode::Root()}));\n   return root;\n }\n \n@@ -27,8 +26,8 @@ std::unique_ptr<JSONObject> EffectPaintPropertyNode::ToJSON() const {\n   if (Parent())\n     json->SetString(\""parent\"", String::Format(\""%p\"", Parent()));\n   json->SetString(\""localTransformSpace\"",\n-                  String::Format(\""%p\"", state_.local_transform_space.get()));\n-  json->SetString(\""outputClip\"", String::Format(\""%p\"", state_.output_clip.get()));\n+                  String::Format(\""%p\"", state_.local_transform_space));\n+  json->SetString(\""outputClip\"", String::Format(\""%p\"", state_.output_clip));\n   if (state_.color_filter != kColorFilterNone)\n     json->SetInteger(\""colorFilter\"", state_.color_filter);\n   if (!state_.filter.IsEmpty())""}<_**next**_>{""sha"": ""753e86297cb6a63c612e98ee3a41303ff793636a"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 19, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/effect_paint_property_node.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -32,10 +32,10 @@ class PLATFORM_EXPORT EffectPaintPropertyNode\n     //    and effects under the same parent.\n     // 2. Some effects are spatial (namely blur filter and reflection), the\n     //    effect parameters will be specified in the local space.\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space;\n+    const TransformPaintPropertyNode* local_transform_space = nullptr;\n     // The output of the effect can be optionally clipped when composited onto\n     // the current backdrop.\n-    scoped_refptr<const ClipPaintPropertyNode> output_clip;\n+    const ClipPaintPropertyNode* output_clip = nullptr;\n     // Optionally a number of effects can be applied to the composited output.\n     // The chain of effects will be applied in the following order:\n     // === Begin of effects ===\n@@ -63,18 +63,17 @@ class PLATFORM_EXPORT EffectPaintPropertyNode\n   };\n \n   // This node is really a sentinel, and does not represent a real effect.\n-  static EffectPaintPropertyNode* Root();\n+  static const EffectPaintPropertyNode& Root();\n \n-  static scoped_refptr<EffectPaintPropertyNode> Create(\n-      scoped_refptr<const EffectPaintPropertyNode> parent,\n+  static std::unique_ptr<EffectPaintPropertyNode> Create(\n+      const EffectPaintPropertyNode& parent,\n       State&& state) {\n-    return base::AdoptRef(\n-        new EffectPaintPropertyNode(std::move(parent), std::move(state)));\n+    return base::WrapUnique(\n+        new EffectPaintPropertyNode(&parent, std::move(state)));\n   }\n \n-  bool Update(scoped_refptr<const EffectPaintPropertyNode> parent,\n-              State&& state) {\n-    bool parent_changed = SetParent(parent);\n+  bool Update(const EffectPaintPropertyNode& parent, State&& state) {\n+    bool parent_changed = SetParent(&parent);\n     if (state == state_)\n       return parent_changed;\n \n@@ -84,11 +83,9 @@ class PLATFORM_EXPORT EffectPaintPropertyNode\n   }\n \n   const TransformPaintPropertyNode* LocalTransformSpace() const {\n-    return state_.local_transform_space.get();\n-  }\n-  const ClipPaintPropertyNode* OutputClip() const {\n-    return state_.output_clip.get();\n+    return state_.local_transform_space;\n   }\n+  const ClipPaintPropertyNode* OutputClip() const { return state_.output_clip; }\n \n   SkBlendMode BlendMode() const { return state_.blend_mode; }\n   float Opacity() const { return state_.opacity; }\n@@ -121,8 +118,9 @@ class PLATFORM_EXPORT EffectPaintPropertyNode\n #if DCHECK_IS_ON()\n   // The clone function is used by FindPropertiesNeedingUpdate.h for recording\n   // an effect node before it has been updated, to later detect changes.\n-  scoped_refptr<EffectPaintPropertyNode> Clone() const {\n-    return base::AdoptRef(new EffectPaintPropertyNode(Parent(), State(state_)));\n+  std::unique_ptr<EffectPaintPropertyNode> Clone() const {\n+    return base::WrapUnique(\n+        new EffectPaintPropertyNode(Parent(), State(state_)));\n   }\n \n   // The equality operator is used by FindPropertiesNeedingUpdate.h for checking\n@@ -138,9 +136,8 @@ class PLATFORM_EXPORT EffectPaintPropertyNode\n   size_t TreeMemoryUsageInBytes() const;\n \n  private:\n-  EffectPaintPropertyNode(scoped_refptr<const EffectPaintPropertyNode> parent,\n-                          State&& state)\n-      : PaintPropertyNode(std::move(parent)), state_(std::move(state)) {}\n+  EffectPaintPropertyNode(const EffectPaintPropertyNode* parent, State&& state)\n+      : PaintPropertyNode(parent), state_(std::move(state)) {}\n \n   State state_;\n };""}<_**next**_>{""sha"": ""dd38b4187f9be19f6786567ade573c1f6fe037da"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/geometry_mapper.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/geometry_mapper.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/geometry_mapper.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/geometry_mapper.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -101,7 +101,7 @@ GeometryMapper::SourceToDestinationProjectionInternal(\n \n   // Case 3: Compute:\n   // flatten(destination_to_screen)^-1 * flatten(source_to_screen)\n-  const auto* root = TransformPaintPropertyNode::Root();\n+  const auto* root = &TransformPaintPropertyNode::Root();\n   success = true;\n   if (source == root)\n     return destination_cache.projection_from_screen();""}<_**next**_>{""sha"": ""98c574fa6c52e3a9b843d8142e04410fc667c511"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/geometry_mapper_test.cc"", ""status"": ""modified"", ""additions"": 74, ""deletions"": 149, ""changes"": 223, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/geometry_mapper_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/geometry_mapper_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/geometry_mapper_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -157,8 +157,7 @@ TEST_P(GeometryMapperTest, Root) {\n }\n \n TEST_P(GeometryMapperTest, IdentityTransform) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix());\n+  auto transform = CreateTransform(t0(), TransformationMatrix());\n   local_state.SetTransform(transform.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -169,8 +168,7 @@ TEST_P(GeometryMapperTest, IdentityTransform) {\n \n TEST_P(GeometryMapperTest, TranslationTransform) {\n   expected_transform = TransformationMatrix().Translate(20, 10);\n-  auto transform =\n-      CreateTransform(TransformPaintPropertyNode::Root(), expected_transform);\n+  auto transform = CreateTransform(t0(), expected_transform);\n   local_state.SetTransform(transform.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -179,15 +177,13 @@ TEST_P(GeometryMapperTest, TranslationTransform) {\n   CHECK_MAPPINGS();\n \n   FloatRect rect = expected_transformed_rect;\n-  GeometryMapper::SourceToDestinationRect(TransformPaintPropertyNode::Root(),\n-                                          local_state.Transform(), rect);\n+  GeometryMapper::SourceToDestinationRect(&t0(), local_state.Transform(), rect);\n   EXPECT_FLOAT_RECT_NEAR(input_rect, rect);\n }\n \n TEST_P(GeometryMapperTest, RotationAndScaleTransform) {\n   expected_transform = TransformationMatrix().Rotate(45).Scale(2);\n-  auto transform =\n-      CreateTransform(TransformPaintPropertyNode::Root(), expected_transform);\n+  auto transform = CreateTransform(t0(), expected_transform);\n   local_state.SetTransform(transform.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -199,8 +195,8 @@ TEST_P(GeometryMapperTest, RotationAndScaleTransform) {\n \n TEST_P(GeometryMapperTest, RotationAndScaleTransformWithTransformOrigin) {\n   expected_transform = TransformationMatrix().Rotate(45).Scale(2);\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   expected_transform, FloatPoint3D(50, 50, 0));\n+  auto transform =\n+      CreateTransform(t0(), expected_transform, FloatPoint3D(50, 50, 0));\n   local_state.SetTransform(transform.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -213,11 +209,10 @@ TEST_P(GeometryMapperTest, RotationAndScaleTransformWithTransformOrigin) {\n \n TEST_P(GeometryMapperTest, NestedTransforms) {\n   auto rotate_transform = TransformationMatrix().Rotate(45);\n-  auto transform1 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform);\n+  auto transform1 = CreateTransform(t0(), rotate_transform);\n \n   auto scale_transform = TransformationMatrix().Scale(2);\n-  auto transform2 = CreateTransform(transform1, scale_transform);\n+  auto transform2 = CreateTransform(*transform1, scale_transform);\n   local_state.SetTransform(transform2.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -231,14 +226,14 @@ TEST_P(GeometryMapperTest, NestedTransforms) {\n TEST_P(GeometryMapperTest, NestedTransformsFlattening) {\n   TransformPaintPropertyNode::State rotate_transform;\n   rotate_transform.matrix.Rotate3d(45, 0, 0);\n-  auto transform1 = TransformPaintPropertyNode::Create(\n-      TransformPaintPropertyNode::Root(), std::move(rotate_transform));\n+  auto transform1 =\n+      TransformPaintPropertyNode::Create(t0(), std::move(rotate_transform));\n \n   TransformPaintPropertyNode::State inverse_rotate_transform;\n   inverse_rotate_transform.matrix.Rotate3d(-45, 0, 0);\n   inverse_rotate_transform.flattens_inherited_transform = true;\n   auto transform2 = TransformPaintPropertyNode::Create(\n-      transform1, std::move(inverse_rotate_transform));\n+      *transform1, std::move(inverse_rotate_transform));\n   local_state.SetTransform(transform2.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -254,11 +249,10 @@ TEST_P(GeometryMapperTest, NestedTransformsFlattening) {\n \n TEST_P(GeometryMapperTest, NestedTransformsScaleAndTranslation) {\n   auto scale_transform = TransformationMatrix().Scale(2);\n-  auto transform1 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), scale_transform);\n+  auto transform1 = CreateTransform(t0(), scale_transform);\n \n   auto translate_transform = TransformationMatrix().Translate(100, 0);\n-  auto transform2 = CreateTransform(transform1, translate_transform);\n+  auto transform2 = CreateTransform(*transform1, translate_transform);\n   local_state.SetTransform(transform2.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -273,11 +267,10 @@ TEST_P(GeometryMapperTest, NestedTransformsScaleAndTranslation) {\n \n TEST_P(GeometryMapperTest, NestedTransformsIntermediateDestination) {\n   auto rotate_transform = TransformationMatrix().Rotate(45);\n-  auto transform1 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform);\n+  auto transform1 = CreateTransform(t0(), rotate_transform);\n \n   auto scale_transform = TransformationMatrix().Translate(10, 20);\n-  auto transform2 = CreateTransform(transform1, scale_transform);\n+  auto transform2 = CreateTransform(*transform1, scale_transform);\n \n   local_state.SetTransform(transform2.get());\n   ancestor_state.SetTransform(transform1.get());\n@@ -290,9 +283,7 @@ TEST_P(GeometryMapperTest, NestedTransformsIntermediateDestination) {\n }\n \n TEST_P(GeometryMapperTest, SimpleClip) {\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 10, 50, 50));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 50, 50));\n   local_state.SetClip(clip.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -304,12 +295,11 @@ TEST_P(GeometryMapperTest, SimpleClip) {\n \n TEST_P(GeometryMapperTest, SimpleClipOverlayScrollbars) {\n   ClipPaintPropertyNode::State clip_state;\n-  clip_state.local_transform_space = TransformPaintPropertyNode::Root();\n+  clip_state.local_transform_space = &t0();\n   clip_state.clip_rect = FloatRoundedRect(10, 10, 50, 50);\n   clip_state.clip_rect_excluding_overlay_scrollbars =\n       FloatRoundedRect(10, 10, 45, 43);\n-  auto clip = ClipPaintPropertyNode::Create(ClipPaintPropertyNode::Root(),\n-                                            std::move(clip_state));\n+  auto clip = ClipPaintPropertyNode::Create(c0(), std::move(clip_state));\n   local_state.SetClip(clip.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -344,12 +334,7 @@ TEST_P(GeometryMapperTest, SimpleClipOverlayScrollbars) {\n }\n \n TEST_P(GeometryMapperTest, SimpleClipInclusiveIntersect) {\n-  ClipPaintPropertyNode::State clip_state;\n-  clip_state.local_transform_space = TransformPaintPropertyNode::Root();\n-  clip_state.clip_rect = FloatRoundedRect(10, 10, 50, 50);\n-  auto clip = ClipPaintPropertyNode::Create(ClipPaintPropertyNode::Root(),\n-                                            std::move(clip_state));\n-\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 50, 50));\n   local_state.SetClip(clip.get());\n \n   FloatClipRect actual_clip_rect(FloatRect(60, 10, 10, 10));\n@@ -372,8 +357,7 @@ TEST_P(GeometryMapperTest, RoundedClip) {\n   FloatRoundedRect rect(FloatRect(10, 10, 50, 50),\n                         FloatRoundedRect::Radii(FloatSize(1, 1), FloatSize(),\n                                                 FloatSize(), FloatSize()));\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(), rect);\n+  auto clip = CreateClip(c0(), &t0(), rect);\n   local_state.SetClip(clip.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -388,9 +372,7 @@ TEST_P(GeometryMapperTest, ClipPath) {\n   FloatRoundedRect rect(FloatRect(10, 10, 50, 50),\n                         FloatRoundedRect::Radii(FloatSize(1, 1), FloatSize(),\n                                                 FloatSize(), FloatSize()));\n-  auto clip = CreateClipPathClip(ClipPaintPropertyNode::Root(),\n-                                 TransformPaintPropertyNode::Root(),\n-                                 FloatRoundedRect(10, 10, 50, 50));\n+  auto clip = CreateClipPathClip(c0(), &t0(), FloatRoundedRect(10, 10, 50, 50));\n   local_state.SetClip(clip.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -407,11 +389,8 @@ TEST_P(GeometryMapperTest, TwoClips) {\n       FloatRoundedRect::Radii(FloatSize(1, 1), FloatSize(), FloatSize(),\n                               FloatSize()));\n \n-  auto clip1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(), clip_rect1);\n-\n-  auto clip2 = CreateClip(clip1, TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(10, 10, 50, 50));\n+  auto clip1 = CreateClip(c0(), &t0(), clip_rect1);\n+  auto clip2 = CreateClip(*clip1, &t0(), FloatRoundedRect(10, 10, 50, 50));\n   local_state.SetClip(clip2.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -428,19 +407,16 @@ TEST_P(GeometryMapperTest, TwoClips) {\n }\n \n TEST_P(GeometryMapperTest, TwoClipsTransformAbove) {\n-  auto transform = CreateTransform(TransformPaintPropertyNode::Root(),\n-                                   TransformationMatrix());\n+  auto transform = CreateTransform(t0(), TransformationMatrix());\n \n   FloatRoundedRect clip_rect1(\n       FloatRect(10, 10, 50, 50),\n       FloatRoundedRect::Radii(FloatSize(1, 1), FloatSize(), FloatSize(),\n                               FloatSize()));\n \n-  auto clip1 =\n-      CreateClip(ClipPaintPropertyNode::Root(), transform.get(), clip_rect1);\n-\n+  auto clip1 = CreateClip(c0(), transform.get(), clip_rect1);\n   auto clip2 =\n-      CreateClip(clip1, transform.get(), FloatRoundedRect(10, 10, 30, 40));\n+      CreateClip(*clip1, transform.get(), FloatRoundedRect(10, 10, 30, 40));\n   local_state.SetClip(clip2.get());\n \n   input_rect = FloatRect(0, 0, 100, 100);\n@@ -459,10 +435,9 @@ TEST_P(GeometryMapperTest, TwoClipsTransformAbove) {\n \n TEST_P(GeometryMapperTest, ClipBeforeTransform) {\n   expected_transform = TransformationMatrix().Rotate(45);\n-  auto transform =\n-      CreateTransform(TransformPaintPropertyNode::Root(), expected_transform);\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(), transform.get(),\n-                         FloatRoundedRect(10, 10, 50, 50));\n+  auto transform = CreateTransform(t0(), expected_transform);\n+  auto clip =\n+      CreateClip(c0(), transform.get(), FloatRoundedRect(10, 10, 50, 50));\n   local_state.SetClip(clip.get());\n   local_state.SetTransform(transform.get());\n \n@@ -480,11 +455,8 @@ TEST_P(GeometryMapperTest, ClipBeforeTransform) {\n \n TEST_P(GeometryMapperTest, ClipAfterTransform) {\n   expected_transform = TransformationMatrix().Rotate(45);\n-  auto transform =\n-      CreateTransform(TransformPaintPropertyNode::Root(), expected_transform);\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 10, 200, 200));\n+  auto transform = CreateTransform(t0(), expected_transform);\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 200, 200));\n   local_state.SetClip(clip.get());\n   local_state.SetTransform(transform.get());\n \n@@ -500,16 +472,11 @@ TEST_P(GeometryMapperTest, ClipAfterTransform) {\n }\n \n TEST_P(GeometryMapperTest, TwoClipsWithTransformBetween) {\n-  auto clip1 = CreateClip(ClipPaintPropertyNode::Root(),\n-                          TransformPaintPropertyNode::Root(),\n-                          FloatRoundedRect(10, 10, 200, 200));\n-\n+  auto clip1 = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 200, 200));\n   expected_transform = TransformationMatrix().Rotate(45);\n-  auto transform =\n-      CreateTransform(TransformPaintPropertyNode::Root(), expected_transform);\n-\n+  auto transform = CreateTransform(t0(), expected_transform);\n   auto clip2 =\n-      CreateClip(clip1, transform.get(), FloatRoundedRect(10, 10, 200, 200));\n+      CreateClip(*clip1, transform.get(), FloatRoundedRect(10, 10, 200, 200));\n \n   input_rect = FloatRect(0, 0, 100, 100);\n   expected_transformed_rect = expected_transform.MapRect(input_rect);\n@@ -553,12 +520,10 @@ TEST_P(GeometryMapperTest, SiblingTransforms) {\n   // These transforms are siblings. Thus mapping from one to the other requires\n   // going through the root.\n   auto rotate_transform1 = TransformationMatrix().Rotate(45);\n-  auto transform1 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform1);\n+  auto transform1 = CreateTransform(t0(), rotate_transform1);\n \n   auto rotate_transform2 = TransformationMatrix().Rotate(-45);\n-  auto transform2 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform2);\n+  auto transform2 = CreateTransform(t0(), rotate_transform2);\n \n   auto transform1_state = PropertyTreeState::Root();\n   transform1_state.SetTransform(transform1.get());\n@@ -597,15 +562,13 @@ TEST_P(GeometryMapperTest, SiblingTransformsWithClip) {\n   // These transforms are siblings. Thus mapping from one to the other requires\n   // going through the root.\n   auto rotate_transform1 = TransformationMatrix().Rotate(45);\n-  auto transform1 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform1);\n+  auto transform1 = CreateTransform(t0(), rotate_transform1);\n \n   auto rotate_transform2 = TransformationMatrix().Rotate(-45);\n-  auto transform2 =\n-      CreateTransform(TransformPaintPropertyNode::Root(), rotate_transform2);\n+  auto transform2 = CreateTransform(t0(), rotate_transform2);\n \n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(), transform2.get(),\n-                         FloatRoundedRect(10, 20, 30, 40));\n+  auto clip =\n+      CreateClip(c0(), transform2.get(), FloatRoundedRect(10, 20, 30, 40));\n \n   auto transform1_state = PropertyTreeState::Root();\n   transform1_state.SetTransform(transform1.get());\n@@ -642,24 +605,22 @@ TEST_P(GeometryMapperTest, SiblingTransformsWithClip) {\n \n TEST_P(GeometryMapperTest, FilterWithClipsAndTransforms) {\n   auto transform_above_effect =\n-      CreateTransform(TransformPaintPropertyNode::Root(),\n-                      TransformationMatrix().Translate(40, 50));\n+      CreateTransform(t0(), TransformationMatrix().Translate(40, 50));\n   auto transform_below_effect = CreateTransform(\n-      transform_above_effect, TransformationMatrix().Translate(20, 30));\n+      *transform_above_effect, TransformationMatrix().Translate(20, 30));\n \n   // This clip is between transformAboveEffect and the effect.\n-  auto clip_above_effect =\n-      CreateClip(ClipPaintPropertyNode::Root(), transform_above_effect,\n-                 FloatRoundedRect(-100, -100, 200, 200));\n+  auto clip_above_effect = CreateClip(c0(), transform_above_effect.get(),\n+                                      FloatRoundedRect(-100, -100, 200, 200));\n   // This clip is between the effect and transformBelowEffect.\n-  auto clip_below_effect = CreateClip(clip_above_effect, transform_above_effect,\n-                                      FloatRoundedRect(10, 10, 100, 100));\n+  auto clip_below_effect =\n+      CreateClip(*clip_above_effect, transform_above_effect.get(),\n+                 FloatRoundedRect(10, 10, 100, 100));\n \n   CompositorFilterOperations filters;\n   filters.AppendBlurFilter(20);\n-  auto effect =\n-      CreateFilterEffect(EffectPaintPropertyNode::Root(),\n-                         transform_above_effect, clip_above_effect, filters);\n+  auto effect = CreateFilterEffect(e0(), transform_above_effect.get(),\n+                                   clip_above_effect.get(), filters);\n \n   local_state = PropertyTreeState(transform_below_effect.get(),\n                                   clip_below_effect.get(), effect.get());\n@@ -694,8 +655,7 @@ TEST_P(GeometryMapperTest, ReflectionWithPaintOffset) {\n   CompositorFilterOperations filters;\n   filters.AppendReferenceFilter(PaintFilterBuilder::BuildBoxReflectFilter(\n       BoxReflection(BoxReflection::kHorizontalReflection, 0), nullptr));\n-  auto effect = CreateFilterEffect(EffectPaintPropertyNode::Root(), filters,\n-                                   FloatPoint(100, 100));\n+  auto effect = CreateFilterEffect(e0(), filters, FloatPoint(100, 100));\n   local_state.SetEffect(effect.get());\n \n   input_rect = FloatRect(100, 100, 50, 50);\n@@ -712,12 +672,8 @@ TEST_P(GeometryMapperTest, InvertedClip) {\n   if (RuntimeEnabledFeatures::SlimmingPaintV2Enabled())\n     return;\n \n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 10, 50, 50));\n-\n-  PropertyTreeState dest(TransformPaintPropertyNode::Root(), clip.get(),\n-                         EffectPaintPropertyNode::Root());\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 50, 50));\n+  PropertyTreeState dest(&t0(), clip.get(), &e0());\n \n   FloatClipRect visual_rect(FloatRect(0, 0, 10, 200));\n   GeometryMapper::LocalToAncestorVisualRect(PropertyTreeState::Root(), dest,\n@@ -731,16 +687,10 @@ TEST_P(GeometryMapperTest, InvertedClip) {\n }\n \n TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceSimpleClip) {\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(10, 10, 50, 50));\n-\n-  PropertyTreeState local_state(TransformPaintPropertyNode::Root(), clip.get(),\n-                                EffectPaintPropertyNode::Root());\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(10, 10, 50, 50));\n \n-  PropertyTreeState ancestor_state(TransformPaintPropertyNode::Root(),\n-                                   ClipPaintPropertyNode::Root(),\n-                                   EffectPaintPropertyNode::Root());\n+  PropertyTreeState local_state(&t0(), clip.get(), &e0());\n+  PropertyTreeState ancestor_state = PropertyTreeState::Root();\n \n   EXPECT_TRUE(GeometryMapper::PointVisibleInAncestorSpace(\n       local_state, ancestor_state, FloatPoint(30, 30)));\n@@ -757,15 +707,10 @@ TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceRoundedClip) {\n   FloatRoundedRect::Radii radii;\n   radii.SetTopLeft(FloatSize(8, 8));\n   clip_rect.SetRadii(radii);\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(), clip_rect);\n-\n-  PropertyTreeState local_state(TransformPaintPropertyNode::Root(), clip.get(),\n-                                EffectPaintPropertyNode::Root());\n+  auto clip = CreateClip(c0(), &t0(), clip_rect);\n \n-  PropertyTreeState ancestor_state(TransformPaintPropertyNode::Root(),\n-                                   ClipPaintPropertyNode::Root(),\n-                                   EffectPaintPropertyNode::Root());\n+  PropertyTreeState local_state(&t0(), clip.get(), &e0());\n+  PropertyTreeState ancestor_state = PropertyTreeState::Root();\n \n   EXPECT_TRUE(GeometryMapper::PointVisibleInAncestorSpace(\n       local_state, ancestor_state, FloatPoint(30, 30)));\n@@ -787,18 +732,13 @@ TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceClipPath) {\n   path->AddLineTo(FloatPoint(10, 10));\n \n   ClipPaintPropertyNode::State state;\n-  state.local_transform_space = TransformPaintPropertyNode::Root();\n+  state.local_transform_space = &t0();\n   state.clip_rect = FloatRoundedRect(FloatRect(0, 0, 500, 500));\n   state.clip_path = base::AdoptRef(path);\n-  auto clip = ClipPaintPropertyNode::Create(ClipPaintPropertyNode::Root(),\n-                                            std::move(state));\n-\n-  PropertyTreeState local_state(TransformPaintPropertyNode::Root(), clip.get(),\n-                                EffectPaintPropertyNode::Root());\n+  auto clip = ClipPaintPropertyNode::Create(c0(), std::move(state));\n \n-  PropertyTreeState ancestor_state(TransformPaintPropertyNode::Root(),\n-                                   ClipPaintPropertyNode::Root(),\n-                                   EffectPaintPropertyNode::Root());\n+  PropertyTreeState local_state(&t0(), clip.get(), &e0());\n+  PropertyTreeState ancestor_state = PropertyTreeState::Root();\n \n   EXPECT_TRUE(GeometryMapper::PointVisibleInAncestorSpace(\n       local_state, ancestor_state, FloatPoint(30, 30)));\n@@ -811,21 +751,13 @@ TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceClipPath) {\n }\n \n TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceSimpleClipWithTransform) {\n-  TransformPaintPropertyNode::State translate_transform;\n-  translate_transform.matrix.Translate(10, 10);\n-  auto transform = TransformPaintPropertyNode::Create(\n-      TransformPaintPropertyNode::Root(), std::move(translate_transform));\n-\n-  auto clip = CreateClip(ClipPaintPropertyNode::Root(),\n-                         TransformPaintPropertyNode::Root(),\n-                         FloatRoundedRect(FloatRect(20, 20, 50, 50)));\n-\n-  PropertyTreeState local_state(transform.get(), clip.get(),\n-                                EffectPaintPropertyNode::Root());\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(10, 10));\n+  auto clip =\n+      CreateClip(c0(), &t0(), FloatRoundedRect(FloatRect(20, 20, 50, 50)));\n \n-  PropertyTreeState ancestor_state(TransformPaintPropertyNode::Root(),\n-                                   ClipPaintPropertyNode::Root(),\n-                                   EffectPaintPropertyNode::Root());\n+  PropertyTreeState local_state(transform.get(), clip.get(), &e0());\n+  PropertyTreeState ancestor_state = PropertyTreeState::Root();\n \n   EXPECT_TRUE(GeometryMapper::PointVisibleInAncestorSpace(\n       local_state, ancestor_state, FloatPoint(30, 30)));\n@@ -838,10 +770,8 @@ TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceSimpleClipWithTransform) {\n }\n \n TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceClipPathWithTransform) {\n-  TransformPaintPropertyNode::State translate_transform;\n-  translate_transform.matrix.Translate(10, 10);\n-  auto transform = TransformPaintPropertyNode::Create(\n-      TransformPaintPropertyNode::Root(), std::move(translate_transform));\n+  auto transform =\n+      CreateTransform(t0(), TransformationMatrix().Translate(10, 10));\n \n   RefCountedPath* path = new RefCountedPath;\n   path->MoveTo(FloatPoint(20, 20));\n@@ -851,18 +781,13 @@ TEST_P(GeometryMapperTest, PointVisibleInAncestorSpaceClipPathWithTransform) {\n   path->AddLineTo(FloatPoint(20, 20));\n \n   ClipPaintPropertyNode::State state;\n-  state.local_transform_space = TransformPaintPropertyNode::Root();\n+  state.local_transform_space = &t0();\n   state.clip_rect = FloatRoundedRect(FloatRect(0, 0, 500, 500));\n   state.clip_path = base::AdoptRef(path);\n-  auto clip = ClipPaintPropertyNode::Create(ClipPaintPropertyNode::Root(),\n-                                            std::move(state));\n+  auto clip = ClipPaintPropertyNode::Create(c0(), std::move(state));\n \n-  PropertyTreeState local_state(transform.get(), clip.get(),\n-                                EffectPaintPropertyNode::Root());\n-\n-  PropertyTreeState ancestor_state(TransformPaintPropertyNode::Root(),\n-                                   ClipPaintPropertyNode::Root(),\n-                                   EffectPaintPropertyNode::Root());\n+  PropertyTreeState local_state(transform.get(), clip.get(), &e0());\n+  PropertyTreeState ancestor_state = PropertyTreeState::Root();\n \n   EXPECT_TRUE(GeometryMapper::PointVisibleInAncestorSpace(\n       local_state, ancestor_state, FloatPoint(30, 30)));""}<_**next**_>{""sha"": ""c0a28b6068e6cd7a9e65b99d85af56bfb78c597f"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_chunk.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_chunk.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_chunk.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_chunk.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -10,8 +10,8 @@\n #include \""third_party/blink/renderer/platform/geometry/float_rect.h\""\n #include \""third_party/blink/renderer/platform/graphics/paint/display_item.h\""\n #include \""third_party/blink/renderer/platform/graphics/paint/hit_test_data.h\""\n+#include \""third_party/blink/renderer/platform/graphics/paint/property_tree_state.h\""\n #include \""third_party/blink/renderer/platform/graphics/paint/raster_invalidation_tracking.h\""\n-#include \""third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h\""\n #include \""third_party/blink/renderer/platform/platform_export.h\""\n #include \""third_party/blink/renderer/platform/wtf/allocator.h\""\n #include \""third_party/blink/renderer/platform/wtf/forward.h\""\n@@ -100,7 +100,7 @@ struct PLATFORM_EXPORT PaintChunk {\n   Id id;\n \n   // The paint properties which apply to this chunk.\n-  RefCountedPropertyTreeState properties;\n+  PropertyTreeState properties;\n \n   // The total bounds of this paint chunk's contents, in the coordinate space of\n   // the containing transform node.""}<_**next**_>{""sha"": ""104fccdf4fac01c2300b2289296ff48d4b189183"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_chunker_test.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 12, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_chunker_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_chunker_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_chunker_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -100,7 +100,7 @@ TEST_F(PaintChunkerTest, BuildMultipleChunksWithSinglePropertyChanging) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto simple_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n   auto simple_transform = DefaultPaintChunkProperties();\n   simple_transform.SetTransform(simple_transform_node.get());\n \n@@ -109,7 +109,7 @@ TEST_F(PaintChunkerTest, BuildMultipleChunksWithSinglePropertyChanging) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto another_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n   auto another_transform = DefaultPaintChunkProperties();\n   another_transform.SetTransform(another_transform_node.get());\n   PaintChunk::Id id3(client_, DisplayItemType(3));\n@@ -130,16 +130,15 @@ TEST_F(PaintChunkerTest, BuildMultipleChunksWithDifferentPropertyChanges) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto simple_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 0, 0, 0, 0, 0), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 0, 0, 0, 0, 0), FloatPoint3D(9, 8, 7));\n   auto simple_transform = DefaultPaintChunkProperties();\n   simple_transform.SetTransform(simple_transform_node.get());\n   PaintChunk::Id id2(client_, DisplayItemType(2));\n   chunker.UpdateCurrentPaintChunkProperties(id2, simple_transform);\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n-  auto simple_effect_node =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5f);\n+  auto simple_effect_node = CreateOpacityEffect(e0(), 0.5f);\n   auto simple_transform_and_effect = DefaultPaintChunkProperties();\n   simple_transform_and_effect.SetTransform(simple_transform_node.get());\n   simple_transform_and_effect.SetEffect(simple_effect_node.get());\n@@ -149,11 +148,10 @@ TEST_F(PaintChunkerTest, BuildMultipleChunksWithDifferentPropertyChanges) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto new_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(1, 1, 0, 0, 0, 0), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(1, 1, 0, 0, 0, 0), FloatPoint3D(9, 8, 7));\n   auto simple_transform_and_effect_with_updated_transform =\n       DefaultPaintChunkProperties();\n-  auto new_effect_node =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5f);\n+  auto new_effect_node = CreateOpacityEffect(e0(), 0.5f);\n   simple_transform_and_effect_with_updated_transform.SetTransform(\n       new_transform_node.get());\n   simple_transform_and_effect_with_updated_transform.SetEffect(\n@@ -200,7 +198,7 @@ TEST_F(PaintChunkerTest, BuildChunksFromNestedTransforms) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto simple_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n   auto simple_transform = DefaultPaintChunkProperties();\n   simple_transform.SetTransform(simple_transform_node.get());\n   PaintChunk::Id id2(client_, DisplayItemType(2));\n@@ -229,14 +227,14 @@ TEST_F(PaintChunkerTest, ChangingPropertiesWithoutItems) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto first_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n   auto first_transform = DefaultPaintChunkProperties();\n   first_transform.SetTransform(first_transform_node.get());\n   PaintChunk::Id id2(client_, DisplayItemType(2));\n   chunker.UpdateCurrentPaintChunkProperties(base::nullopt, first_transform);\n \n   auto second_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(9, 8, 7, 6, 5, 4), FloatPoint3D(3, 2, 1));\n+      t0(), TransformationMatrix(9, 8, 7, 6, 5, 4), FloatPoint3D(3, 2, 1));\n   auto second_transform = DefaultPaintChunkProperties();\n   second_transform.SetTransform(second_transform_node.get());\n   PaintChunk::Id id3(client_, DisplayItemType(3));\n@@ -407,7 +405,7 @@ TEST_F(PaintChunkerTest, ChunkIdsSkippingCache) {\n   chunker.IncrementDisplayItemIndex(TestChunkerDisplayItem(client_));\n \n   auto simple_transform_node = CreateTransform(\n-      nullptr, TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n+      t0(), TransformationMatrix(0, 1, 2, 3, 4, 5), FloatPoint3D(9, 8, 7));\n   auto simple_transform = DefaultPaintChunkProperties();\n   simple_transform.SetTransform(simple_transform_node.get());\n   PaintChunk::Id id2(client_, DisplayItemType(2));""}<_**next**_>{""sha"": ""bcfa96f990a4bd927471c95b488c7371ed3dcadb"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_controller.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -517,7 +517,7 @@ void PaintController::CopyCachedSubsequence(size_t begin_index,\n     properties_before_subsequence =\n         new_paint_chunks_.CurrentPaintChunkProperties();\n     UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(\n-        cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());\n+        cached_chunk->id, cached_chunk->properties);\n   } else {\n     // Avoid uninitialized variable error on Windows.\n     cached_chunk = current_paint_artifact_.PaintChunks().begin();\n@@ -537,7 +537,7 @@ void PaintController::CopyCachedSubsequence(size_t begin_index,\n       DCHECK(cached_chunk != current_paint_artifact_.PaintChunks().end());\n       new_paint_chunks_.ForceNewChunk();\n       UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(\n-          cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());\n+          cached_chunk->id, cached_chunk->properties);\n     }\n \n #if DCHECK_IS_ON()""}<_**next**_>{""sha"": ""bb1ce228f2086a5647665cb935208d47618f84a5"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_controller_test.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 18, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_controller_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_controller_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_controller_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -482,7 +482,7 @@ TEST_P(PaintControllerTest, UpdateClip) {\n   FakeDisplayItemClient second(\""second\"", LayoutRect(100, 100, 200, 200));\n   GraphicsContext context(GetPaintController());\n \n-  auto clip = CreateClip(nullptr, nullptr, FloatRoundedRect(1, 1, 2, 2));\n+  auto clip = CreateClip(c0(), &t0(), FloatRoundedRect(1, 1, 2, 2));\n   auto properties = DefaultPaintChunkProperties();\n   properties.SetClip(clip.get());\n   GetPaintController().UpdateCurrentPaintChunkProperties(\n@@ -522,7 +522,7 @@ TEST_P(PaintControllerTest, UpdateClip) {\n   second.SetDisplayItemsUncached();\n   DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 150, 150));\n \n-  auto clip2 = CreateClip(nullptr, nullptr, FloatRoundedRect(1, 1, 2, 2));\n+  auto clip2 = CreateClip(c0(), &t0(), FloatRoundedRect(1, 1, 2, 2));\n   auto properties2 = DefaultPaintChunkProperties();\n   properties2.SetClip(clip2.get());\n   GetPaintController().UpdateCurrentPaintChunkProperties(\n@@ -798,13 +798,11 @@ TEST_P(PaintControllerTest, CachedSubsequenceSwapOrder) {\n   FakeDisplayItemClient content2(\""content2\"", LayoutRect(100, 200, 50, 200));\n   GraphicsContext context(GetPaintController());\n \n-  auto container1_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto container1_effect = CreateOpacityEffect(e0(), 0.5);\n   auto container1_properties = DefaultPaintChunkProperties();\n   container1_properties.SetEffect(container1_effect.get());\n \n-  auto container2_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto container2_effect = CreateOpacityEffect(e0(), 0.5);\n   auto container2_properties = DefaultPaintChunkProperties();\n   container2_properties.SetEffect(container2_effect.get());\n \n@@ -1117,13 +1115,11 @@ TEST_P(PaintControllerTest, UpdateSwapOrderCrossingChunks) {\n   FakeDisplayItemClient content2(\""content2\"", LayoutRect(100, 200, 50, 200));\n   GraphicsContext context(GetPaintController());\n \n-  auto container1_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto container1_effect = CreateOpacityEffect(e0(), 0.5);\n   auto container1_properties = DefaultPaintChunkProperties();\n   container1_properties.SetEffect(container1_effect.get());\n \n-  auto container2_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto container2_effect = CreateOpacityEffect(e0(), 0.5);\n   auto container2_properties = DefaultPaintChunkProperties();\n   container2_properties.SetEffect(container2_effect.get());\n \n@@ -1230,25 +1226,21 @@ TEST_P(PaintControllerTest, CachedNestedSubsequenceUpdate) {\n   FakeDisplayItemClient content2(\""content2\"", LayoutRect(100, 200, 50, 200));\n   GraphicsContext context(GetPaintController());\n \n-  auto container1_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.5);\n+  auto container1_effect = CreateOpacityEffect(e0(), 0.5);\n   auto container1_background_properties = DefaultPaintChunkProperties();\n   container1_background_properties.SetEffect(container1_effect.get());\n   auto container1_foreground_properties = DefaultPaintChunkProperties();\n   container1_foreground_properties.SetEffect(container1_effect.get());\n \n-  auto content1_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.6);\n+  auto content1_effect = CreateOpacityEffect(e0(), 0.6);\n   auto content1_properties = DefaultPaintChunkProperties();\n   content1_properties.SetEffect(content1_effect.get());\n \n-  auto container2_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.7);\n+  auto container2_effect = CreateOpacityEffect(e0(), 0.7);\n   auto container2_background_properties = DefaultPaintChunkProperties();\n   container2_background_properties.SetEffect(container2_effect.get());\n \n-  auto content2_effect =\n-      CreateOpacityEffect(EffectPaintPropertyNode::Root(), 0.8);\n+  auto content2_effect = CreateOpacityEffect(e0(), 0.8);\n   auto content2_properties = DefaultPaintChunkProperties();\n   content2_properties.SetEffect(content2_effect.get());\n ""}<_**next**_>{""sha"": ""4f4cd576375667d8f78d8dbd7d0a081b6a492fff"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_property_node.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 9, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_property_node.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_property_node.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_property_node.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -5,10 +5,8 @@\n #ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_PAINT_PROPERTY_NODE_H_\n #define THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_PAINT_PROPERTY_NODE_H_\n \n-#include \""base/memory/scoped_refptr.h\""\n #include \""third_party/blink/renderer/platform/json/json_values.h\""\n #include \""third_party/blink/renderer/platform/platform_export.h\""\n-#include \""third_party/blink/renderer/platform/wtf/ref_counted.h\""\n #include \""third_party/blink/renderer/platform/wtf/text/wtf_string.h\""\n \n #if DCHECK_IS_ON()\n@@ -55,10 +53,12 @@ PLATFORM_EXPORT const TransformPaintPropertyNode& LowestCommonAncestorInternal(\n     const TransformPaintPropertyNode&);\n \n template <typename NodeType>\n-class PaintPropertyNode : public RefCounted<NodeType> {\n+class PaintPropertyNode {\n+  USING_FAST_MALLOC(NodeType);\n+\n  public:\n   // Parent property node, or nullptr if this is the root node.\n-  const NodeType* Parent() const { return parent_.get(); }\n+  const NodeType* Parent() const { return parent_; }\n   bool IsRoot() const { return !parent_; }\n \n   bool IsAncestorOf(const NodeType& other) const {\n@@ -115,24 +115,23 @@ class PaintPropertyNode : public RefCounted<NodeType> {\n #endif\n \n  protected:\n-  PaintPropertyNode(scoped_refptr<const NodeType> parent)\n-      : parent_(std::move(parent)) {}\n+  PaintPropertyNode(const NodeType* parent) : parent_(parent) {}\n \n-  bool SetParent(scoped_refptr<const NodeType> parent) {\n+  bool SetParent(const NodeType* parent) {\n     DCHECK(!IsRoot());\n     DCHECK(parent != this);\n     if (parent == parent_)\n       return false;\n \n     SetChanged();\n-    parent_ = std::move(parent);\n+    parent_ = parent;\n     return true;\n   }\n \n   void SetChanged() { changed_ = true; }\n \n  private:\n-  scoped_refptr<const NodeType> parent_;\n+  const NodeType* parent_;\n   mutable bool changed_ = true;\n \n #if DCHECK_IS_ON()""}<_**next**_>{""sha"": ""072d4242265c2669e8daf3175c60637a3d962df9"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/paint_property_node_test.cc"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 27, ""changes"": 54, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_property_node_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/paint_property_node_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/paint_property_node_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -14,12 +14,12 @@ namespace blink {\n class PaintPropertyNodeTest : public testing::Test {\n  protected:\n   void SetUp() override {\n-    root = ClipPaintPropertyNode::Root();\n-    node = CreateClip(root, nullptr, FloatRoundedRect());\n-    child1 = CreateClip(node, nullptr, FloatRoundedRect());\n-    child2 = CreateClip(node, nullptr, FloatRoundedRect());\n-    grandchild1 = CreateClip(child1, nullptr, FloatRoundedRect());\n-    grandchild2 = CreateClip(child2, nullptr, FloatRoundedRect());\n+    root = &ClipPaintPropertyNode::Root();\n+    node = CreateClip(*root, nullptr, FloatRoundedRect());\n+    child1 = CreateClip(*node, nullptr, FloatRoundedRect());\n+    child2 = CreateClip(*node, nullptr, FloatRoundedRect());\n+    grandchild1 = CreateClip(*child1, nullptr, FloatRoundedRect());\n+    grandchild2 = CreateClip(*child2, nullptr, FloatRoundedRect());\n \n     //          root\n     //           |\n@@ -35,10 +35,10 @@ class PaintPropertyNodeTest : public testing::Test {\n     grandchild2->ClearChangedToRoot();\n   }\n \n-  static void Update(scoped_refptr<ClipPaintPropertyNode> node,\n-                     scoped_refptr<const ClipPaintPropertyNode> new_parent,\n+  static void Update(std::unique_ptr<ClipPaintPropertyNode>& node,\n+                     const ClipPaintPropertyNode& new_parent,\n                      const FloatRoundedRect& new_clip_rect) {\n-    node->Update(std::move(new_parent),\n+    node->Update(new_parent,\n                  ClipPaintPropertyNode::State{nullptr, new_clip_rect});\n   }\n \n@@ -60,30 +60,30 @@ class PaintPropertyNodeTest : public testing::Test {\n     EXPECT_FALSE(grandchild2->Changed(*root));\n   }\n \n-  scoped_refptr<ClipPaintPropertyNode> root;\n-  scoped_refptr<ClipPaintPropertyNode> node;\n-  scoped_refptr<ClipPaintPropertyNode> child1;\n-  scoped_refptr<ClipPaintPropertyNode> child2;\n-  scoped_refptr<ClipPaintPropertyNode> grandchild1;\n-  scoped_refptr<ClipPaintPropertyNode> grandchild2;\n+  const ClipPaintPropertyNode* root;\n+  std::unique_ptr<ClipPaintPropertyNode> node;\n+  std::unique_ptr<ClipPaintPropertyNode> child1;\n+  std::unique_ptr<ClipPaintPropertyNode> child2;\n+  std::unique_ptr<ClipPaintPropertyNode> grandchild1;\n+  std::unique_ptr<ClipPaintPropertyNode> grandchild2;\n };\n \n TEST_F(PaintPropertyNodeTest, LowestCommonAncestor) {\n-  EXPECT_EQ(node, &LowestCommonAncestor(*node, *node));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*node, *node));\n   EXPECT_EQ(root, &LowestCommonAncestor(*root, *root));\n \n-  EXPECT_EQ(node, &LowestCommonAncestor(*grandchild1, *grandchild2));\n-  EXPECT_EQ(node, &LowestCommonAncestor(*grandchild1, *child2));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*grandchild1, *grandchild2));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*grandchild1, *child2));\n   EXPECT_EQ(root, &LowestCommonAncestor(*grandchild1, *root));\n-  EXPECT_EQ(child1, &LowestCommonAncestor(*grandchild1, *child1));\n+  EXPECT_EQ(child1.get(), &LowestCommonAncestor(*grandchild1, *child1));\n \n-  EXPECT_EQ(node, &LowestCommonAncestor(*grandchild2, *grandchild1));\n-  EXPECT_EQ(node, &LowestCommonAncestor(*grandchild2, *child1));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*grandchild2, *grandchild1));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*grandchild2, *child1));\n   EXPECT_EQ(root, &LowestCommonAncestor(*grandchild2, *root));\n-  EXPECT_EQ(child2, &LowestCommonAncestor(*grandchild2, *child2));\n+  EXPECT_EQ(child2.get(), &LowestCommonAncestor(*grandchild2, *child2));\n \n-  EXPECT_EQ(node, &LowestCommonAncestor(*child1, *child2));\n-  EXPECT_EQ(node, &LowestCommonAncestor(*child2, *child1));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*child1, *child2));\n+  EXPECT_EQ(node.get(), &LowestCommonAncestor(*child2, *child1));\n }\n \n TEST_F(PaintPropertyNodeTest, InitialStateAndReset) {\n@@ -94,7 +94,7 @@ TEST_F(PaintPropertyNodeTest, InitialStateAndReset) {\n \n TEST_F(PaintPropertyNodeTest, ChangeNode) {\n   ResetAllChanged();\n-  Update(node, root, FloatRoundedRect(1, 2, 3, 4));\n+  Update(node, *root, FloatRoundedRect(1, 2, 3, 4));\n   EXPECT_TRUE(node->Changed(*root));\n   EXPECT_FALSE(node->Changed(*node));\n   EXPECT_TRUE(child1->Changed(*root));\n@@ -111,7 +111,7 @@ TEST_F(PaintPropertyNodeTest, ChangeNode) {\n \n TEST_F(PaintPropertyNodeTest, ChangeOneChild) {\n   ResetAllChanged();\n-  Update(child1, node, FloatRoundedRect(1, 2, 3, 4));\n+  Update(child1, *node, FloatRoundedRect(1, 2, 3, 4));\n   EXPECT_FALSE(node->Changed(*root));\n   EXPECT_FALSE(node->Changed(*node));\n   EXPECT_TRUE(child1->Changed(*root));\n@@ -136,7 +136,7 @@ TEST_F(PaintPropertyNodeTest, ChangeOneChild) {\n \n TEST_F(PaintPropertyNodeTest, Reparent) {\n   ResetAllChanged();\n-  Update(child1, child2, FloatRoundedRect(1, 2, 3, 4));\n+  Update(child1, *child2, FloatRoundedRect(1, 2, 3, 4));\n   EXPECT_FALSE(node->Changed(*root));\n   EXPECT_TRUE(child1->Changed(*node));\n   EXPECT_TRUE(child1->Changed(*child2));""}<_**next**_>{""sha"": ""8b0bfc878e950022a8ee6196d8c38990a1cd48ac"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/property_tree_state.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 5, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/property_tree_state.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/property_tree_state.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/property_tree_state.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -10,11 +10,10 @@ namespace blink {\n \n const PropertyTreeState& PropertyTreeState::Root() {\n   DEFINE_STATIC_LOCAL(\n-      std::unique_ptr<PropertyTreeState>, root,\n-      (std::make_unique<PropertyTreeState>(TransformPaintPropertyNode::Root(),\n-                                           ClipPaintPropertyNode::Root(),\n-                                           EffectPaintPropertyNode::Root())));\n-  return *root;\n+      PropertyTreeState, root,\n+      (&TransformPaintPropertyNode::Root(), &ClipPaintPropertyNode::Root(),\n+       &EffectPaintPropertyNode::Root()));\n+  return root;\n }\n \n const CompositorElementId PropertyTreeState::GetCompositorElementId(""}<_**next**_>{""sha"": ""6a91f0273406f5af31216b17e0f87e4ea9aa9b6d"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/property_tree_state_test.cc"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 18, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/property_tree_state_test.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/property_tree_state_test.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/property_tree_state_test.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -10,7 +10,7 @@ namespace blink {\n \n class PropertyTreeStateTest : public testing::Test {};\n \n-static scoped_refptr<TransformPaintPropertyNode>\n+static std::unique_ptr<TransformPaintPropertyNode>\n CreateTransformWithCompositorElementId(\n     const CompositorElementId& compositor_element_id) {\n   TransformPaintPropertyNode::State state;\n@@ -19,7 +19,7 @@ CreateTransformWithCompositorElementId(\n                                             std::move(state));\n }\n \n-static scoped_refptr<EffectPaintPropertyNode>\n+static std::unique_ptr<EffectPaintPropertyNode>\n CreateEffectWithCompositorElementId(\n     const CompositorElementId& compositor_element_id) {\n   EffectPaintPropertyNode::State state;\n@@ -29,40 +29,38 @@ CreateEffectWithCompositorElementId(\n }\n \n TEST_F(PropertyTreeStateTest, CompositorElementIdNoElementIdOnAnyNode) {\n-  PropertyTreeState state(TransformPaintPropertyNode::Root(),\n-                          ClipPaintPropertyNode::Root(),\n-                          EffectPaintPropertyNode::Root());\n   EXPECT_EQ(CompositorElementId(),\n-            state.GetCompositorElementId(CompositorElementIdSet()));\n+            PropertyTreeState::Root().GetCompositorElementId(\n+                CompositorElementIdSet()));\n }\n \n TEST_F(PropertyTreeStateTest, CompositorElementIdWithElementIdOnTransformNode) {\n   CompositorElementId expected_compositor_element_id = CompositorElementId(2);\n-  scoped_refptr<TransformPaintPropertyNode> transform =\n+  auto transform =\n       CreateTransformWithCompositorElementId(expected_compositor_element_id);\n-  PropertyTreeState state(transform.get(), ClipPaintPropertyNode::Root(),\n-                          EffectPaintPropertyNode::Root());\n+  PropertyTreeState state(transform.get(), &ClipPaintPropertyNode::Root(),\n+                          &EffectPaintPropertyNode::Root());\n   EXPECT_EQ(expected_compositor_element_id,\n             state.GetCompositorElementId(CompositorElementIdSet()));\n }\n \n TEST_F(PropertyTreeStateTest, CompositorElementIdWithElementIdOnEffectNode) {\n   CompositorElementId expected_compositor_element_id = CompositorElementId(2);\n-  scoped_refptr<EffectPaintPropertyNode> effect =\n+  auto effect =\n       CreateEffectWithCompositorElementId(expected_compositor_element_id);\n-  PropertyTreeState state(TransformPaintPropertyNode::Root(),\n-                          ClipPaintPropertyNode::Root(), effect.get());\n+  PropertyTreeState state(&TransformPaintPropertyNode::Root(),\n+                          &ClipPaintPropertyNode::Root(), effect.get());\n   EXPECT_EQ(expected_compositor_element_id,\n             state.GetCompositorElementId(CompositorElementIdSet()));\n }\n \n TEST_F(PropertyTreeStateTest, CompositorElementIdWithElementIdOnMultipleNodes) {\n   CompositorElementId expected_compositor_element_id = CompositorElementId(2);\n-  scoped_refptr<TransformPaintPropertyNode> transform =\n+  auto transform =\n       CreateTransformWithCompositorElementId(expected_compositor_element_id);\n-  scoped_refptr<EffectPaintPropertyNode> effect =\n+  auto effect =\n       CreateEffectWithCompositorElementId(expected_compositor_element_id);\n-  PropertyTreeState state(transform.get(), ClipPaintPropertyNode::Root(),\n+  PropertyTreeState state(transform.get(), &ClipPaintPropertyNode::Root(),\n                           effect.get());\n   EXPECT_EQ(expected_compositor_element_id,\n             state.GetCompositorElementId(CompositorElementIdSet()));\n@@ -71,11 +69,11 @@ TEST_F(PropertyTreeStateTest, CompositorElementIdWithElementIdOnMultipleNodes) {\n TEST_F(PropertyTreeStateTest, CompositorElementIdWithDifferingElementIds) {\n   CompositorElementId first_compositor_element_id = CompositorElementId(2);\n   CompositorElementId second_compositor_element_id = CompositorElementId(3);\n-  scoped_refptr<TransformPaintPropertyNode> transform =\n+  auto transform =\n       CreateTransformWithCompositorElementId(first_compositor_element_id);\n-  scoped_refptr<EffectPaintPropertyNode> effect =\n+  auto effect =\n       CreateEffectWithCompositorElementId(second_compositor_element_id);\n-  PropertyTreeState state(transform.get(), ClipPaintPropertyNode::Root(),\n+  PropertyTreeState state(transform.get(), &ClipPaintPropertyNode::Root(),\n                           effect.get());\n \n   CompositorElementIdSet composited_element_ids;""}<_**next**_>{""sha"": ""1003213e594206aa3c57faca67257c7b4de9cee1"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 43, ""changes"": 43, ""blob_url"": ""https://github.com/chromium/chromium/blob/95f5260501ac2660f29fb98ab5cb351a956c1dab/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/95f5260501ac2660f29fb98ab5cb351a956c1dab/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.cc?ref=95f5260501ac2660f29fb98ab5cb351a956c1dab"", ""patch"": ""@@ -1,43 +0,0 @@\n-// Copyright 2016 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include \""third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h\""\n-\n-#include <memory>\n-\n-namespace blink {\n-\n-const RefCountedPropertyTreeState& RefCountedPropertyTreeState::Root() {\n-  DEFINE_STATIC_LOCAL(\n-      std::unique_ptr<RefCountedPropertyTreeState>, root,\n-      (std::make_unique<RefCountedPropertyTreeState>(\n-          TransformPaintPropertyNode::Root(), ClipPaintPropertyNode::Root(),\n-          EffectPaintPropertyNode::Root())));\n-  return *root;\n-}\n-\n-const CompositorElementId RefCountedPropertyTreeState::GetCompositorElementId(\n-    const CompositorElementIdSet& element_ids) const {\n-  // The effect or transform nodes could have a compositor element id. The order\n-  // doesn't matter as the element id should be the same on all that have a\n-  // non-default CompositorElementId.\n-  //\n-  // Note that RefCountedPropertyTreeState acts as a context that accumulates\n-  // state as we traverse the tree building layers. This means that we could see\n-  // a compositor element id 'A' for a parent layer in conjunction with a\n-  // compositor element id 'B' for a child layer. To preserve uniqueness of\n-  // element ids, then, we check for presence in the |element_ids| set (which\n-  // represents element ids already previously attached to a layer). This is an\n-  // interim step while we pursue broader rework of animation subsystem noted in\n-  // http://crbug.com/709137.\n-  if (Effect()->GetCompositorElementId() &&\n-      !element_ids.Contains(Effect()->GetCompositorElementId()))\n-    return Effect()->GetCompositorElementId();\n-  if (Transform()->GetCompositorElementId() &&\n-      !element_ids.Contains(Transform()->GetCompositorElementId()))\n-    return Transform()->GetCompositorElementId();\n-  return CompositorElementId();\n-}\n-\n-}  // namespace blink""}<_**next**_>{""sha"": ""340d6e95116c3eb521dbadecf3b2706beeb6ba88"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 88, ""changes"": 88, ""blob_url"": ""https://github.com/chromium/chromium/blob/95f5260501ac2660f29fb98ab5cb351a956c1dab/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/95f5260501ac2660f29fb98ab5cb351a956c1dab/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/ref_counted_property_tree_state.h?ref=95f5260501ac2660f29fb98ab5cb351a956c1dab"", ""patch"": ""@@ -1,88 +0,0 @@\n-// Copyright 2016 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_REF_COUNTED_PROPERTY_TREE_STATE_H_\n-#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_REF_COUNTED_PROPERTY_TREE_STATE_H_\n-\n-#include \""third_party/blink/renderer/platform/graphics/paint/property_tree_state.h\""\n-#include \""third_party/blink/renderer/platform/wtf/hash_functions.h\""\n-#include \""third_party/blink/renderer/platform/wtf/hash_traits.h\""\n-#include \""third_party/blink/renderer/platform/wtf/text/string_builder.h\""\n-\n-namespace blink {\n-\n-// A complete set of paint properties including those that are inherited from\n-// other objects.  RefPtrs are used to guard against use-after-free bugs.\n-class PLATFORM_EXPORT RefCountedPropertyTreeState {\n-  USING_FAST_MALLOC(RefCountedPropertyTreeState);\n-\n- public:\n-  RefCountedPropertyTreeState(const TransformPaintPropertyNode* transform,\n-                              const ClipPaintPropertyNode* clip,\n-                              const EffectPaintPropertyNode* effect)\n-      : transform_(transform), clip_(clip), effect_(effect) {}\n-\n-  RefCountedPropertyTreeState(const PropertyTreeState& property_tree_state)\n-      : transform_(property_tree_state.Transform()),\n-        clip_(property_tree_state.Clip()),\n-        effect_(property_tree_state.Effect()) {}\n-\n-  bool HasDirectCompositingReasons() const;\n-\n-  const TransformPaintPropertyNode* Transform() const {\n-    return transform_.get();\n-  }\n-  void SetTransform(scoped_refptr<const TransformPaintPropertyNode> node) {\n-    transform_ = std::move(node);\n-  }\n-\n-  const ClipPaintPropertyNode* Clip() const { return clip_.get(); }\n-  void SetClip(scoped_refptr<const ClipPaintPropertyNode> node) {\n-    clip_ = std::move(node);\n-  }\n-\n-  const EffectPaintPropertyNode* Effect() const { return effect_.get(); }\n-  void SetEffect(scoped_refptr<const EffectPaintPropertyNode> node) {\n-    effect_ = std::move(node);\n-  }\n-\n-  static const RefCountedPropertyTreeState& Root();\n-\n-  PropertyTreeState GetPropertyTreeState() const {\n-    return PropertyTreeState(transform_.get(), clip_.get(), effect_.get());\n-  }\n-\n-  // Returns the compositor element id, if any, for this property state. If\n-  // neither the effect nor transform nodes have a compositor element id then a\n-  // default instance is returned.\n-  const CompositorElementId GetCompositorElementId(\n-      const CompositorElementIdSet& element_ids) const;\n-\n-  void ClearChangedToRoot() const {\n-    Transform()->ClearChangedToRoot();\n-    Clip()->ClearChangedToRoot();\n-    Effect()->ClearChangedToRoot();\n-  }\n-\n-  String ToString() const { return GetPropertyTreeState().ToString(); }\n-#if DCHECK_IS_ON()\n-  // Dumps the tree from this state up to the root as a string.\n-  String ToTreeString() const { return GetPropertyTreeState().ToTreeString(); }\n-#endif\n-\n- private:\n-  scoped_refptr<const TransformPaintPropertyNode> transform_;\n-  scoped_refptr<const ClipPaintPropertyNode> clip_;\n-  scoped_refptr<const EffectPaintPropertyNode> effect_;\n-};\n-\n-inline bool operator==(const RefCountedPropertyTreeState& a,\n-                       const RefCountedPropertyTreeState& b) {\n-  return a.Transform() == b.Transform() && a.Clip() == b.Clip() &&\n-         a.Effect() == b.Effect();\n-}\n-\n-}  // namespace blink\n-\n-#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_GRAPHICS_PAINT_REF_COUNTED_PROPERTY_TREE_STATE_H_""}<_**next**_>{""sha"": ""3420e60081216d8406b8043a18fd059e60c3be30"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -13,13 +13,13 @@ namespace blink {\n ScrollHitTestDisplayItem::ScrollHitTestDisplayItem(\n     const DisplayItemClient& client,\n     Type type,\n-    scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node)\n+    const TransformPaintPropertyNode& scroll_offset_node)\n     : DisplayItem(client, type, sizeof(*this)),\n-      scroll_offset_node_(std::move(scroll_offset_node)) {\n+      scroll_offset_node_(scroll_offset_node) {\n   DCHECK(RuntimeEnabledFeatures::SlimmingPaintV2Enabled());\n   DCHECK(IsScrollHitTestType(type));\n   // The scroll offset transform node should have an associated scroll node.\n-  DCHECK(scroll_offset_node_->ScrollNode());\n+  DCHECK(scroll_offset_node_.ScrollNode());\n }\n \n ScrollHitTestDisplayItem::~ScrollHitTestDisplayItem() = default;\n@@ -44,27 +44,27 @@ bool ScrollHitTestDisplayItem::Equals(const DisplayItem& other) const {\n void ScrollHitTestDisplayItem::PropertiesAsJSON(JSONObject& json) const {\n   DisplayItem::PropertiesAsJSON(json);\n   json.SetString(\""scrollOffsetNode\"",\n-                 String::Format(\""%p\"", scroll_offset_node_.get()));\n+                 String::Format(\""%p\"", &scroll_offset_node_));\n }\n #endif\n \n void ScrollHitTestDisplayItem::Record(\n     GraphicsContext& context,\n     const DisplayItemClient& client,\n     DisplayItem::Type type,\n-    scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node) {\n+    const TransformPaintPropertyNode& scroll_offset_node) {\n   PaintController& paint_controller = context.GetPaintController();\n \n   // The scroll hit test should be in the non-scrolled transform space and\n   // therefore should not be scrolled by the associated scroll offset.\n   DCHECK_NE(paint_controller.CurrentPaintChunkProperties().Transform(),\n-            scroll_offset_node.get());\n+            &scroll_offset_node);\n \n   if (paint_controller.DisplayItemConstructionIsDisabled())\n     return;\n \n   paint_controller.CreateAndAppend<ScrollHitTestDisplayItem>(\n-      client, type, std::move(scroll_offset_node));\n+      client, type, scroll_offset_node);\n }\n \n }  // namespace blink""}<_**next**_>{""sha"": ""ce222809b49efef7a9a1e963240b59e198ba41e5"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 9, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/scroll_hit_test_display_item.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -27,11 +27,11 @@ class PLATFORM_EXPORT ScrollHitTestDisplayItem final : public DisplayItem {\n   ScrollHitTestDisplayItem(\n       const DisplayItemClient&,\n       Type,\n-      scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node);\n+      const TransformPaintPropertyNode& scroll_offset_node);\n   ~ScrollHitTestDisplayItem() override;\n \n   const TransformPaintPropertyNode& scroll_offset_node() const {\n-    return *scroll_offset_node_;\n+    return scroll_offset_node_;\n   }\n \n   // DisplayItem\n@@ -46,18 +46,17 @@ class PLATFORM_EXPORT ScrollHitTestDisplayItem final : public DisplayItem {\n   // Create and append a ScrollHitTestDisplayItem onto the context. This is\n   // similar to a recorder class (e.g., DrawingRecorder) but just emits a single\n   // item.\n-  static void Record(\n-      GraphicsContext&,\n-      const DisplayItemClient&,\n-      DisplayItem::Type,\n-      scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node);\n+  static void Record(GraphicsContext&,\n+                     const DisplayItemClient&,\n+                     DisplayItem::Type,\n+                     const TransformPaintPropertyNode& scroll_offset_node);\n \n  private:\n   const ScrollPaintPropertyNode& scroll_node() const {\n-    return *scroll_offset_node_->ScrollNode();\n+    return *scroll_offset_node_.ScrollNode();\n   }\n \n-  scoped_refptr<const TransformPaintPropertyNode> scroll_offset_node_;\n+  const TransformPaintPropertyNode& scroll_offset_node_;\n };\n \n }  // namespace blink""}<_**next**_>{""sha"": ""b66fedb2a57060fe9c5a21b0fe03bf5e36c62868"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -6,9 +6,8 @@\n \n namespace blink {\n \n-ScrollPaintPropertyNode* ScrollPaintPropertyNode::Root() {\n-  DEFINE_STATIC_REF(ScrollPaintPropertyNode, root,\n-                    (ScrollPaintPropertyNode::Create(nullptr, State{})));\n+const ScrollPaintPropertyNode& ScrollPaintPropertyNode::Root() {\n+  DEFINE_STATIC_LOCAL(ScrollPaintPropertyNode, root, (nullptr, State{}));\n   return root;\n }\n ""}<_**next**_>{""sha"": ""e1a27b6668fb755db5d723ec2a7f7b2b2a86a440"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 13, ""changes"": 25, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/scroll_paint_property_node.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -56,18 +56,17 @@ class PLATFORM_EXPORT ScrollPaintPropertyNode\n   };\n \n   // This node is really a sentinel, and does not represent a real scroll.\n-  static ScrollPaintPropertyNode* Root();\n+  static const ScrollPaintPropertyNode& Root();\n \n-  static scoped_refptr<ScrollPaintPropertyNode> Create(\n-      scoped_refptr<const ScrollPaintPropertyNode> parent,\n+  static std::unique_ptr<ScrollPaintPropertyNode> Create(\n+      const ScrollPaintPropertyNode& parent,\n       State&& state) {\n-    return base::AdoptRef(\n-        new ScrollPaintPropertyNode(std::move(parent), std::move(state)));\n+    return base::WrapUnique(\n+        new ScrollPaintPropertyNode(&parent, std::move(state)));\n   }\n \n-  bool Update(scoped_refptr<const ScrollPaintPropertyNode> parent,\n-              State&& state) {\n-    bool parent_changed = SetParent(parent);\n+  bool Update(const ScrollPaintPropertyNode& parent, State&& state) {\n+    bool parent_changed = SetParent(&parent);\n     if (state == state_)\n       return parent_changed;\n \n@@ -118,8 +117,9 @@ class PLATFORM_EXPORT ScrollPaintPropertyNode\n #if DCHECK_IS_ON()\n   // The clone function is used by FindPropertiesNeedingUpdate.h for recording\n   // a scroll node before it has been updated, to later detect changes.\n-  scoped_refptr<ScrollPaintPropertyNode> Clone() const {\n-    return base::AdoptRef(new ScrollPaintPropertyNode(Parent(), State(state_)));\n+  std::unique_ptr<ScrollPaintPropertyNode> Clone() const {\n+    return base::WrapUnique(\n+        new ScrollPaintPropertyNode(Parent(), State(state_)));\n   }\n \n   // The equality operator is used by FindPropertiesNeedingUpdate.h for checking\n@@ -132,9 +132,8 @@ class PLATFORM_EXPORT ScrollPaintPropertyNode\n   std::unique_ptr<JSONObject> ToJSON() const;\n \n  private:\n-  ScrollPaintPropertyNode(scoped_refptr<const ScrollPaintPropertyNode> parent,\n-                          State&& state)\n-      : PaintPropertyNode(std::move(parent)), state_(std::move(state)) {\n+  ScrollPaintPropertyNode(const ScrollPaintPropertyNode* parent, State&& state)\n+      : PaintPropertyNode(parent), state_(std::move(state)) {\n     Validate();\n   }\n ""}<_**next**_>{""sha"": ""4cdd6e5fb2f54ed99dd3c9df5a69560b27a316ac"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 8, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -8,14 +8,13 @@ namespace blink {\n \n // The root of the transform tree. The root transform node references the root\n // scroll node.\n-TransformPaintPropertyNode* TransformPaintPropertyNode::Root() {\n-  DEFINE_STATIC_REF(\n+const TransformPaintPropertyNode& TransformPaintPropertyNode::Root() {\n+  DEFINE_STATIC_LOCAL(\n       TransformPaintPropertyNode, root,\n-      base::AdoptRef(new TransformPaintPropertyNode(\n-          nullptr,\n-          State{TransformationMatrix(), FloatPoint3D(), false,\n-                BackfaceVisibility::kVisible, 0, CompositingReason::kNone,\n-                CompositorElementId(), ScrollPaintPropertyNode::Root()})));\n+      (nullptr,\n+       State{TransformationMatrix(), FloatPoint3D(), false,\n+             BackfaceVisibility::kVisible, 0, CompositingReason::kNone,\n+             CompositorElementId(), &ScrollPaintPropertyNode::Root()}));\n   return root;\n }\n \n@@ -61,7 +60,7 @@ std::unique_ptr<JSONObject> TransformPaintPropertyNode::ToJSON() const {\n                     state_.compositor_element_id.ToString().c_str());\n   }\n   if (state_.scroll)\n-    json->SetString(\""scroll\"", String::Format(\""%p\"", state_.scroll.get()));\n+    json->SetString(\""scroll\"", String::Format(\""%p\"", state_.scroll));\n   return json;\n }\n ""}<_**next**_>{""sha"": ""4cd3696dbe798ca78bbf7b8be2749f013c6cff59"", ""filename"": ""third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 18, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/graphics/paint/transform_paint_property_node.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -48,7 +48,7 @@ class PLATFORM_EXPORT TransformPaintPropertyNode\n     unsigned rendering_context_id = 0;\n     CompositingReasons direct_compositing_reasons = CompositingReason::kNone;\n     CompositorElementId compositor_element_id;\n-    scoped_refptr<const ScrollPaintPropertyNode> scroll;\n+    const ScrollPaintPropertyNode* scroll = nullptr;\n \n     bool operator==(const State& o) const {\n       return matrix == o.matrix && origin == o.origin &&\n@@ -63,18 +63,17 @@ class PLATFORM_EXPORT TransformPaintPropertyNode\n \n   // This node is really a sentinel, and does not represent a real transform\n   // space.\n-  static TransformPaintPropertyNode* Root();\n+  static const TransformPaintPropertyNode& Root();\n \n-  static scoped_refptr<TransformPaintPropertyNode> Create(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n+  static std::unique_ptr<TransformPaintPropertyNode> Create(\n+      const TransformPaintPropertyNode& parent,\n       State&& state) {\n-    return base::AdoptRef(\n-        new TransformPaintPropertyNode(std::move(parent), std::move(state)));\n+    return base::WrapUnique(\n+        new TransformPaintPropertyNode(&parent, std::move(state)));\n   }\n \n-  bool Update(scoped_refptr<const TransformPaintPropertyNode> parent,\n-              State&& state) {\n-    bool parent_changed = SetParent(parent);\n+  bool Update(const TransformPaintPropertyNode& parent, State&& state) {\n+    bool parent_changed = SetParent(&parent);\n     if (state == state_)\n       return parent_changed;\n \n@@ -88,9 +87,7 @@ class PLATFORM_EXPORT TransformPaintPropertyNode\n   const FloatPoint3D& Origin() const { return state_.origin; }\n \n   // The associated scroll node, or nullptr otherwise.\n-  const ScrollPaintPropertyNode* ScrollNode() const {\n-    return state_.scroll.get();\n-  }\n+  const ScrollPaintPropertyNode* ScrollNode() const { return state_.scroll; }\n \n   // If this is a scroll offset translation (i.e., has an associated scroll\n   // node), returns this. Otherwise, returns the transform node that this node\n@@ -129,8 +126,8 @@ class PLATFORM_EXPORT TransformPaintPropertyNode\n #if DCHECK_IS_ON()\n   // The clone function is used by FindPropertiesNeedingUpdate.h for recording\n   // a transform node before it has been updated, to later detect changes.\n-  scoped_refptr<TransformPaintPropertyNode> Clone() const {\n-    return base::AdoptRef(\n+  std::unique_ptr<TransformPaintPropertyNode> Clone() const {\n+    return base::WrapUnique(\n         new TransformPaintPropertyNode(Parent(), State(state_)));\n   }\n \n@@ -147,10 +144,9 @@ class PLATFORM_EXPORT TransformPaintPropertyNode\n   size_t CacheMemoryUsageInBytes() const;\n \n  private:\n-  TransformPaintPropertyNode(\n-      scoped_refptr<const TransformPaintPropertyNode> parent,\n-      State&& state)\n-      : PaintPropertyNode(std::move(parent)), state_(std::move(state)) {\n+  TransformPaintPropertyNode(const TransformPaintPropertyNode* parent,\n+                             State&& state)\n+      : PaintPropertyNode(parent), state_(std::move(state)) {\n     Validate();\n   }\n ""}<_**next**_>{""sha"": ""945dbf1c43960e58a95456696520fcd9ef69f68f"", ""filename"": ""third_party/blink/renderer/platform/testing/paint_property_test_helpers.h"", ""status"": ""modified"", ""additions"": 41, ""deletions"": 31, ""changes"": 72, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/paint_property_test_helpers.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/paint_property_test_helpers.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/paint_property_test_helpers.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -12,33 +12,43 @@\n \n namespace blink {\n \n-inline scoped_refptr<EffectPaintPropertyNode> CreateOpacityEffect(\n-    scoped_refptr<const EffectPaintPropertyNode> parent,\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space,\n-    scoped_refptr<const ClipPaintPropertyNode> output_clip,\n+// Convenient shorthands.\n+inline const TransformPaintPropertyNode& t0() {\n+  return TransformPaintPropertyNode::Root();\n+}\n+inline const ClipPaintPropertyNode& c0() {\n+  return ClipPaintPropertyNode::Root();\n+}\n+inline const EffectPaintPropertyNode& e0() {\n+  return EffectPaintPropertyNode::Root();\n+}\n+\n+inline std::unique_ptr<EffectPaintPropertyNode> CreateOpacityEffect(\n+    const EffectPaintPropertyNode& parent,\n+    const TransformPaintPropertyNode* local_transform_space,\n+    const ClipPaintPropertyNode* output_clip,\n     float opacity,\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n   EffectPaintPropertyNode::State state;\n   state.local_transform_space = local_transform_space;\n   state.output_clip = output_clip;\n   state.opacity = opacity;\n   state.direct_compositing_reasons = compositing_reasons;\n-  return EffectPaintPropertyNode::Create(std::move(parent), std::move(state));\n+  return EffectPaintPropertyNode::Create(parent, std::move(state));\n }\n \n-inline scoped_refptr<EffectPaintPropertyNode> CreateOpacityEffect(\n-    scoped_refptr<const EffectPaintPropertyNode> parent,\n+inline std::unique_ptr<EffectPaintPropertyNode> CreateOpacityEffect(\n+    const EffectPaintPropertyNode& parent,\n     float opacity,\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n-  return CreateOpacityEffect(parent, parent->LocalTransformSpace(),\n-                             parent->OutputClip(), opacity,\n-                             compositing_reasons);\n+  return CreateOpacityEffect(parent, parent.LocalTransformSpace(),\n+                             parent.OutputClip(), opacity, compositing_reasons);\n }\n \n-inline scoped_refptr<EffectPaintPropertyNode> CreateFilterEffect(\n-    scoped_refptr<const EffectPaintPropertyNode> parent,\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space,\n-    scoped_refptr<const ClipPaintPropertyNode> output_clip,\n+inline std::unique_ptr<EffectPaintPropertyNode> CreateFilterEffect(\n+    const EffectPaintPropertyNode& parent,\n+    const TransformPaintPropertyNode* local_transform_space,\n+    const ClipPaintPropertyNode* output_clip,\n     CompositorFilterOperations filter,\n     const FloatPoint& paint_offset = FloatPoint(),\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n@@ -48,22 +58,22 @@ inline scoped_refptr<EffectPaintPropertyNode> CreateFilterEffect(\n   state.filter = std::move(filter);\n   state.paint_offset = paint_offset;\n   state.direct_compositing_reasons = compositing_reasons;\n-  return EffectPaintPropertyNode::Create(std::move(parent), std::move(state));\n+  return EffectPaintPropertyNode::Create(parent, std::move(state));\n }\n \n-inline scoped_refptr<EffectPaintPropertyNode> CreateFilterEffect(\n-    scoped_refptr<const EffectPaintPropertyNode> parent,\n+inline std::unique_ptr<EffectPaintPropertyNode> CreateFilterEffect(\n+    const EffectPaintPropertyNode& parent,\n     CompositorFilterOperations filter,\n     const FloatPoint& paint_offset = FloatPoint(),\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n-  return CreateFilterEffect(parent, parent->LocalTransformSpace(),\n-                            parent->OutputClip(), filter, paint_offset,\n+  return CreateFilterEffect(parent, parent.LocalTransformSpace(),\n+                            parent.OutputClip(), filter, paint_offset,\n                             compositing_reasons);\n }\n \n-inline scoped_refptr<ClipPaintPropertyNode> CreateClip(\n-    scoped_refptr<const ClipPaintPropertyNode> parent,\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space,\n+inline std::unique_ptr<ClipPaintPropertyNode> CreateClip(\n+    const ClipPaintPropertyNode& parent,\n+    const TransformPaintPropertyNode* local_transform_space,\n     const FloatRoundedRect& clip_rect,\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n   ClipPaintPropertyNode::State state;\n@@ -73,9 +83,9 @@ inline scoped_refptr<ClipPaintPropertyNode> CreateClip(\n   return ClipPaintPropertyNode::Create(parent, std::move(state));\n }\n \n-inline scoped_refptr<ClipPaintPropertyNode> CreateClipPathClip(\n-    scoped_refptr<const ClipPaintPropertyNode> parent,\n-    scoped_refptr<const TransformPaintPropertyNode> local_transform_space,\n+inline std::unique_ptr<ClipPaintPropertyNode> CreateClipPathClip(\n+    const ClipPaintPropertyNode& parent,\n+    const TransformPaintPropertyNode* local_transform_space,\n     const FloatRoundedRect& clip_rect) {\n   ClipPaintPropertyNode::State state;\n   state.local_transform_space = local_transform_space;\n@@ -84,8 +94,8 @@ inline scoped_refptr<ClipPaintPropertyNode> CreateClipPathClip(\n   return ClipPaintPropertyNode::Create(parent, std::move(state));\n }\n \n-inline scoped_refptr<TransformPaintPropertyNode> CreateTransform(\n-    scoped_refptr<const TransformPaintPropertyNode> parent,\n+inline std::unique_ptr<TransformPaintPropertyNode> CreateTransform(\n+    const TransformPaintPropertyNode& parent,\n     const TransformationMatrix& matrix,\n     const FloatPoint3D& origin = FloatPoint3D(),\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n@@ -96,16 +106,16 @@ inline scoped_refptr<TransformPaintPropertyNode> CreateTransform(\n   return TransformPaintPropertyNode::Create(parent, std::move(state));\n }\n \n-inline scoped_refptr<TransformPaintPropertyNode> CreateScrollTranslation(\n-    scoped_refptr<const TransformPaintPropertyNode> parent,\n+inline std::unique_ptr<TransformPaintPropertyNode> CreateScrollTranslation(\n+    const TransformPaintPropertyNode& parent,\n     float offset_x,\n     float offset_y,\n-    scoped_refptr<const ScrollPaintPropertyNode> scroll,\n+    const ScrollPaintPropertyNode& scroll,\n     CompositingReasons compositing_reasons = CompositingReason::kNone) {\n   TransformPaintPropertyNode::State state;\n   state.matrix.Translate(offset_x, offset_y);\n   state.direct_compositing_reasons = compositing_reasons;\n-  state.scroll = scroll;\n+  state.scroll = &scroll;\n   return TransformPaintPropertyNode::Create(parent, std::move(state));\n }\n ""}<_**next**_>{""sha"": ""85d12e9c14ed76cdd15d2cd8664d268816f3763b"", ""filename"": ""third_party/blink/renderer/platform/testing/test_paint_artifact.cc"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 11, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/test_paint_artifact.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/test_paint_artifact.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/test_paint_artifact.cc?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -44,19 +44,18 @@ TestPaintArtifact::TestPaintArtifact() : display_item_list_(0), built_(false) {}\n TestPaintArtifact::~TestPaintArtifact() = default;\n \n TestPaintArtifact& TestPaintArtifact::Chunk(\n-    scoped_refptr<const TransformPaintPropertyNode> transform,\n-    scoped_refptr<const ClipPaintPropertyNode> clip,\n-    scoped_refptr<const EffectPaintPropertyNode> effect) {\n+    const TransformPaintPropertyNode& transform,\n+    const ClipPaintPropertyNode& clip,\n+    const EffectPaintPropertyNode& effect) {\n   return Chunk(NewClient(), transform, clip, effect);\n }\n \n TestPaintArtifact& TestPaintArtifact::Chunk(\n     DisplayItemClient& client,\n-    scoped_refptr<const TransformPaintPropertyNode> transform,\n-    scoped_refptr<const ClipPaintPropertyNode> clip,\n-    scoped_refptr<const EffectPaintPropertyNode> effect) {\n-  return Chunk(client,\n-               PropertyTreeState(transform.get(), clip.get(), effect.get()));\n+    const TransformPaintPropertyNode& transform,\n+    const ClipPaintPropertyNode& clip,\n+    const EffectPaintPropertyNode& effect) {\n+  return Chunk(client, PropertyTreeState(&transform, &clip, &effect));\n }\n \n TestPaintArtifact& TestPaintArtifact::Chunk(\n@@ -112,15 +111,15 @@ TestPaintArtifact& TestPaintArtifact::ForeignLayer(\n }\n \n TestPaintArtifact& TestPaintArtifact::ScrollHitTest(\n-    scoped_refptr<const TransformPaintPropertyNode> scroll_offset) {\n+    const TransformPaintPropertyNode& scroll_offset) {\n   return ScrollHitTest(NewClient(), scroll_offset);\n }\n \n TestPaintArtifact& TestPaintArtifact::ScrollHitTest(\n     DisplayItemClient& client,\n-    scoped_refptr<const TransformPaintPropertyNode> scroll_offset) {\n+    const TransformPaintPropertyNode& scroll_offset) {\n   display_item_list_.AllocateAndConstruct<ScrollHitTestDisplayItem>(\n-      client, DisplayItem::kScrollHitTest, std::move(scroll_offset));\n+      client, DisplayItem::kScrollHitTest, scroll_offset);\n   return *this;\n }\n ""}<_**next**_>{""sha"": ""ec1f6592cd756ba7fceafaf50640ef43de05f31b"", ""filename"": ""third_party/blink/renderer/platform/testing/test_paint_artifact.h"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 8, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/test_paint_artifact.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f911e11e7f6b5c0d6f5ee694a9871de6619889f7/third_party/blink/renderer/platform/testing/test_paint_artifact.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/platform/testing/test_paint_artifact.h?ref=f911e11e7f6b5c0d6f5ee694a9871de6619889f7"", ""patch"": ""@@ -46,24 +46,24 @@ class TestPaintArtifact {\n   ~TestPaintArtifact();\n \n   // Add to the artifact.\n-  TestPaintArtifact& Chunk(scoped_refptr<const TransformPaintPropertyNode>,\n-                           scoped_refptr<const ClipPaintPropertyNode>,\n-                           scoped_refptr<const EffectPaintPropertyNode>);\n+  TestPaintArtifact& Chunk(const TransformPaintPropertyNode&,\n+                           const ClipPaintPropertyNode&,\n+                           const EffectPaintPropertyNode&);\n   TestPaintArtifact& Chunk(const PropertyTreeState&);\n   TestPaintArtifact& RectDrawing(const FloatRect& bounds, Color);\n   TestPaintArtifact& ForeignLayer(const FloatPoint&,\n                                   const IntSize&,\n                                   scoped_refptr<cc::Layer>);\n   TestPaintArtifact& ScrollHitTest(\n-      scoped_refptr<const TransformPaintPropertyNode> scroll_offset);\n+      const TransformPaintPropertyNode& scroll_offset);\n   TestPaintArtifact& KnownToBeOpaque();\n \n   // Add to the artifact, with specified display item client. These are used\n   // to test incremental paint artifact updates.\n   TestPaintArtifact& Chunk(DisplayItemClient&,\n-                           scoped_refptr<const TransformPaintPropertyNode>,\n-                           scoped_refptr<const ClipPaintPropertyNode>,\n-                           scoped_refptr<const EffectPaintPropertyNode>);\n+                           const TransformPaintPropertyNode&,\n+                           const ClipPaintPropertyNode&,\n+                           const EffectPaintPropertyNode&);\n   TestPaintArtifact& Chunk(DisplayItemClient&, const PropertyTreeState&);\n   TestPaintArtifact& RectDrawing(DisplayItemClient&,\n                                  const FloatRect& bounds,\n@@ -74,7 +74,7 @@ class TestPaintArtifact {\n                                   scoped_refptr<cc::Layer>);\n   TestPaintArtifact& ScrollHitTest(\n       DisplayItemClient&,\n-      scoped_refptr<const TransformPaintPropertyNode> scroll_offset);\n+      const TransformPaintPropertyNode& scroll_offset);\n \n   // Can't add more things once this is called.\n   const PaintArtifact& Build();""}","const DisplayItem* PaintController::LastDisplayItem(unsigned offset) {
  if (offset < new_display_item_list_.size())
    return &new_display_item_list_[new_display_item_list_.size() - offset - 1];
  return nullptr;
}
","const DisplayItem* PaintController::LastDisplayItem(unsigned offset) {
  if (offset < new_display_item_list_.size())
    return &new_display_item_list_[new_display_item_list_.size() - offset - 1];
  return nullptr;
}
",C,,,,"@@ -517,7 +517,7 @@ void PaintController::CopyCachedSubsequence(size_t begin_index,
     properties_before_subsequence =
         new_paint_chunks_.CurrentPaintChunkProperties();
     UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(
-        cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());
+        cached_chunk->id, cached_chunk->properties);
   } else {
     // Avoid uninitialized variable error on Windows.
     cached_chunk = current_paint_artifact_.PaintChunks().begin();
@@ -537,7 +537,7 @@ void PaintController::CopyCachedSubsequence(size_t begin_index,
       DCHECK(cached_chunk != current_paint_artifact_.PaintChunks().end());
       new_paint_chunks_.ForceNewChunk();
       UpdateCurrentPaintChunkPropertiesUsingIdWithFragment(
-          cached_chunk->id, cached_chunk->properties.GetPropertyTreeState());
+          cached_chunk->id, cached_chunk->properties);
     }
 
 #if DCHECK_IS_ON()",Chrome,f911e11e7f6b5c0d6f5ee694a9871de6619889f7,95f5260501ac2660f29fb98ab5cb351a956c1dab,0,"const DisplayItem* PaintController::LastDisplayItem(unsigned offset) {
  if (offset < new_display_item_list_.size())
    return &new_display_item_list_[new_display_item_list_.size() - offset - 1];
  return nullptr;
}
"
151912,,Remote,Not required,Partial,CVE-2017-5019,https://www.cvedetails.com/cve/CVE-2017-5019/,CWE-416,Medium,Partial,Partial,,2017-02-17,6.8,"A use after free in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.",2018-01-04,,0,https://github.com/chromium/chromium/commit/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,"Convert FrameHostMsg_DidAddMessageToConsole to Mojo.

Note: Since this required changing the test
RenderViewImplTest.DispatchBeforeUnloadCanDetachFrame, I manually
re-introduced https://crbug.com/666714 locally (the bug the test was
added for), and reran the test to confirm that it still covers the bug.

Bug: 786836
Change-Id: I110668fa6f0f261fd2ac36bb91a8d8b31c99f4f1
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1526270
Commit-Queue: Lowell Manners <lowell@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Cr-Commit-Position: refs/heads/master@{#653137}",0,content/browser/frame_host/render_frame_host_impl.cc,"{""sha"": ""f2bd60be6f35037de28774456df91833dd753f20"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 11, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1375,8 +1375,6 @@ bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n \n   handled = true;\n   IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n-    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,\n-                        OnDidAddMessageToConsole)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n@@ -1833,21 +1831,35 @@ void RenderFrameHostImpl::OnAudibleStateChanged(bool is_audible) {\n   is_audible_ = is_audible;\n }\n \n-void RenderFrameHostImpl::OnDidAddMessageToConsole(\n-    int32_t level,\n+void RenderFrameHostImpl::DidAddMessageToConsole(\n+    blink::mojom::ConsoleMessageLevel log_level,\n     const base::string16& message,\n     int32_t line_no,\n     const base::string16& source_id) {\n-  if (level < logging::LOG_VERBOSE || level > logging::LOG_FATAL) {\n-    bad_message::ReceivedBadMessage(\n-        GetProcess(), bad_message::RFH_DID_ADD_CONSOLE_MESSAGE_BAD_SEVERITY);\n-    return;\n+  // TODO(https://crbug.com/786836): Update downstream code to use\n+  // ConsoleMessageLevel everywhere to avoid this conversion.\n+  logging::LogSeverity log_severity = logging::LOG_VERBOSE;\n+  switch (log_level) {\n+    case blink::mojom::ConsoleMessageLevel::kVerbose:\n+      log_severity = logging::LOG_VERBOSE;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kInfo:\n+      log_severity = logging::LOG_INFO;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kWarning:\n+      log_severity = logging::LOG_WARNING;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kError:\n+      log_severity = logging::LOG_ERROR;\n+      break;\n   }\n \n-  if (delegate_->DidAddMessageToConsole(level, message, line_no, source_id))\n+  if (delegate_->DidAddMessageToConsole(log_severity, message, line_no,\n+                                        source_id)) {\n     return;\n+  }\n \n-  // Pass through log level only on builtin components pages to limit console\n+  // Pass through log severity only on builtin components pages to limit console\n   // spew.\n   const bool is_builtin_component =\n       HasWebUIScheme(delegate_->GetMainFrameLastCommittedURL()) ||\n@@ -1856,7 +1868,7 @@ void RenderFrameHostImpl::OnDidAddMessageToConsole(\n   const bool is_off_the_record =\n       GetSiteInstance()->GetBrowserContext()->IsOffTheRecord();\n \n-  LogConsoleMessage(level, message, line_no, is_builtin_component,\n+  LogConsoleMessage(log_severity, message, line_no, is_builtin_component,\n                     is_off_the_record, source_id);\n }\n ""}<_**next**_>{""sha"": ""bee010704ea0be084eb5752717d8dcaeb46c04c0"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1049,10 +1049,6 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   class DroppedInterfaceRequestLogger;\n \n   // IPC Message handlers.\n-  void OnDidAddMessageToConsole(int32_t level,\n-                                const base::string16& message,\n-                                int32_t line_no,\n-                                const base::string16& source_id);\n   void OnDetach();\n   void OnFrameFocused();\n   void OnOpenURL(const FrameHostMsg_OpenURL_Params& params);\n@@ -1206,6 +1202,11 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   void FullscreenStateChanged(bool is_fullscreen) override;\n   void DocumentOnLoadCompleted() override;\n   void UpdateActiveSchedulerTrackedFeatures(uint64_t features_mask) override;\n+  void DidAddMessageToConsole(blink::mojom::ConsoleMessageLevel log_level,\n+                              const base::string16& message,\n+                              int32_t line_no,\n+                              const base::string16& source_id) override;\n+\n #if defined(OS_ANDROID)\n   void UpdateUserGestureCarryoverInfo() override;\n #endif""}<_**next**_>{""sha"": ""35ad6ce3ce3aca5a9e47d54a8bcf1b3f381a00b5"", ""filename"": ""content/browser/service_worker/service_worker_context_core.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/service_worker/service_worker_context_core.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/service_worker/service_worker_context_core.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/service_worker/service_worker_context_core.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -786,7 +786,7 @@ void ServiceWorkerContextCore::OnReportConsoleMessage(\n     const GURL& source_url) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   // NOTE: This differs slightly from\n-  // RenderFrameHostImpl::OnDidAddMessageToConsole, which also asks the\n+  // RenderFrameHostImpl::DidAddMessageToConsole, which also asks the\n   // content embedder whether to classify the message as a builtin component.\n   // This is called on the IO thread, though, so we can't easily get a\n   // BrowserContext and call ContentBrowserClient::IsBuiltinComponent().""}<_**next**_>{""sha"": ""88471bc49cd5b00a9494cc3998ba9c44c2c87088"", ""filename"": ""content/common/frame.mojom"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/frame.mojom?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -21,6 +21,7 @@ import \""services/service_manager/public/mojom/interface_provider.mojom\"";\n import \""services/viz/public/interfaces/compositing/surface_id.mojom\"";\n import \""third_party/blink/public/mojom/blob/blob_url_store.mojom\"";\n import \""third_party/blink/public/mojom/commit_result/commit_result.mojom\"";\n+import \""third_party/blink/public/mojom/devtools/console_message.mojom\"";\n import \""third_party/blink/public/mojom/feature_policy/feature_policy.mojom\"";\n import \""third_party/blink/public/mojom/frame/lifecycle.mojom\"";\n import \""third_party/blink/public/mojom/frame/navigation_initiator.mojom\"";\n@@ -473,4 +474,12 @@ interface FrameHost {\n   // of the individual bits.\n   // TODO(altimin): Move into a separate scheduling interface.\n   UpdateActiveSchedulerTrackedFeatures(uint64 features_mask);\n+\n+  // Blink and JavaScript error messages to log to the console or debugger UI.\n+  DidAddMessageToConsole(\n+      blink.mojom.ConsoleMessageLevel log_level,\n+      mojo_base.mojom.BigString16 msg,\n+      int32 line_number,\n+      mojo_base.mojom.String16 source_id);\n+\n };""}<_**next**_>{""sha"": ""aa3530d1912f804ba01a29be9b4b2178ce996e86"", ""filename"": ""content/common/frame_messages.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 8, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/frame_messages.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1098,14 +1098,6 @@ IPC_MESSAGE_ROUTED0(FrameMsg_RenderFallbackContent)\n // -----------------------------------------------------------------------------\n // Messages sent from the renderer to the browser.\n \n-// Blink and JavaScript error messages to log to the console\n-// or debugger UI.\n-IPC_MESSAGE_ROUTED4(FrameHostMsg_DidAddMessageToConsole,\n-                    int32_t,        /* log level */\n-                    base::string16, /* msg */\n-                    int32_t,        /* line number */\n-                    base::string16 /* source id */)\n-\n // Sent by the renderer when a child frame is created in the renderer.\n //\n // Each of these messages will have a corresponding FrameHostMsg_Detach message""}<_**next**_>{""sha"": ""d103dd35fa8ce0773f0c3586d17beb2eaeaf8479"", ""filename"": ""content/renderer/render_frame_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_frame_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_frame_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_frame_impl.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -4545,9 +4545,9 @@ void RenderFrameImpl::DidAddMessageToConsole(\n     }\n   }\n \n-  Send(new FrameHostMsg_DidAddMessageToConsole(\n-      routing_id_, static_cast<int32_t>(log_severity), message.text.Utf16(),\n-      static_cast<int32_t>(source_line), source_name.Utf16()));\n+  GetFrameHost()->DidAddMessageToConsole(message.level, message.text.Utf16(),\n+                                         static_cast<int32_t>(source_line),\n+                                         source_name.Utf16());\n }\n \n void RenderFrameImpl::DownloadURL(""}<_**next**_>{""sha"": ""2c754dc7c905037b40d841c22103659b8a9cba35"", ""filename"": ""content/renderer/render_view_browsertest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 44, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_view_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_view_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_browsertest.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include <stddef.h>\n #include <stdint.h>\n+\n #include <tuple>\n \n #include \""base/bind.h\""\n@@ -17,6 +18,7 @@\n #include \""base/stl_util.h\""\n #include \""base/strings/string_util.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""base/test/bind_test_util.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""base/time/time.h\""\n #include \""base/values.h\""\n@@ -2486,62 +2488,36 @@ TEST_F(RenderViewImplTest, HistoryIsProperlyUpdatedOnShouldClearHistoryList) {\n                    view()->HistoryForwardListCount() + 1);\n }\n \n-// IPC Listener that runs a callback when a console.log() is executed from\n-// javascript.\n-class ConsoleCallbackFilter : public IPC::Listener {\n- public:\n-  explicit ConsoleCallbackFilter(\n-      base::Callback<void(const base::string16&)> callback)\n-      : callback_(callback) {}\n-\n-  bool OnMessageReceived(const IPC::Message& msg) override {\n-    bool handled = true;\n-    IPC_BEGIN_MESSAGE_MAP(ConsoleCallbackFilter, msg)\n-      IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,\n-                          OnDidAddMessageToConsole)\n-      IPC_MESSAGE_UNHANDLED(handled = false)\n-    IPC_END_MESSAGE_MAP()\n-    return handled;\n-  }\n-\n-  void OnDidAddMessageToConsole(int32_t,\n-                                const base::string16& message,\n-                                int32_t,\n-                                const base::string16&) {\n-    callback_.Run(message);\n-  }\n-\n- private:\n-  base::Callback<void(const base::string16&)> callback_;\n-};\n-\n // Tests that there's no UaF after dispatchBeforeUnloadEvent.\n // See https://crbug.com/666714.\n TEST_F(RenderViewImplTest, DispatchBeforeUnloadCanDetachFrame) {\n   LoadHTML(\n       \""<script>window.onbeforeunload = function() { \""\n       \""window.console.log('OnBeforeUnload called'); }</script>\"");\n \n-  // Creates a callback that swaps the frame when the 'OnBeforeUnload called'\n+  // Create a callback that swaps the frame when the 'OnBeforeUnload called'\n   // log is printed from the beforeunload handler.\n-  std::unique_ptr<ConsoleCallbackFilter> callback_filter(\n-      new ConsoleCallbackFilter(base::Bind(\n-          [](RenderFrameImpl* frame, const base::string16& msg) {\n-            // Makes sure this happens during the beforeunload handler.\n-            EXPECT_EQ(base::UTF8ToUTF16(\""OnBeforeUnload called\""), msg);\n-\n-            // Swaps the main frame.\n-            frame->OnMessageReceived(FrameMsg_SwapOut(\n-                frame->GetRoutingID(), 1, false, FrameReplicationState()));\n-          },\n-          base::Unretained(frame()))));\n-  render_thread_->sink().AddFilter(callback_filter.get());\n+  base::RunLoop run_loop;\n+  bool was_callback_run = false;\n+  frame()->SetDidAddMessageToConsoleCallback(\n+      base::BindOnce(base::BindLambdaForTesting([&](const base::string16& msg) {\n+        // Makes sure this happens during the beforeunload handler.\n+        EXPECT_EQ(base::UTF8ToUTF16(\""OnBeforeUnload called\""), msg);\n+\n+        // Swaps the main frame.\n+        frame()->OnMessageReceived(FrameMsg_SwapOut(\n+            frame()->GetRoutingID(), 1, false, FrameReplicationState()));\n+\n+        was_callback_run = true;\n+        run_loop.Quit();\n+      })));\n \n-  // Simulates a BeforeUnload IPC received from the browser.\n+  // Simulate a BeforeUnload IPC received from the browser.\n   frame()->OnMessageReceived(\n       FrameMsg_BeforeUnload(frame()->GetRoutingID(), false));\n \n-  render_thread_->sink().RemoveFilter(callback_filter.get());\n+  run_loop.Run();\n+  ASSERT_TRUE(was_callback_run);\n }\n \n // IPC Listener that runs a callback when a javascript modal dialog is""}<_**next**_>{""sha"": ""bdedd20f84277cc35ae59aec5e3cc2b62b75dc33"", ""filename"": ""content/test/test_render_frame.cc"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_frame.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -47,6 +47,11 @@ class MockFrameHost : public mojom::FrameHost {\n     return std::move(last_document_interface_broker_request_);\n   }\n \n+  void SetDidAddMessageToConsoleCallback(\n+      base::OnceCallback<void(const base::string16& msg)> callback) {\n+    did_add_message_to_console_callback_ = std::move(callback);\n+  }\n+\n   // Holds on to the request end of the InterfaceProvider interface whose client\n   // end is bound to the corresponding RenderFrame's |remote_interfaces_| to\n   // facilitate retrieving the most recent |interface_provider_request| in\n@@ -156,6 +161,15 @@ class MockFrameHost : public mojom::FrameHost {\n \n   void UpdateActiveSchedulerTrackedFeatures(uint64_t features_mask) override {}\n \n+  void DidAddMessageToConsole(blink::mojom::ConsoleMessageLevel log_level,\n+                              const base::string16& msg,\n+                              int32_t line_number,\n+                              const base::string16& source_id) override {\n+    if (did_add_message_to_console_callback_) {\n+      std::move(did_add_message_to_console_callback_).Run(msg);\n+    }\n+  }\n+\n #if defined(OS_ANDROID)\n   void UpdateUserGestureCarryoverInfo() override {}\n #endif\n@@ -168,6 +182,9 @@ class MockFrameHost : public mojom::FrameHost {\n   blink::mojom::DocumentInterfaceBrokerRequest\n       last_document_interface_broker_request_;\n \n+  base::OnceCallback<void(const base::string16& msg)>\n+      did_add_message_to_console_callback_;\n+\n   DISALLOW_COPY_AND_ASSIGN(MockFrameHost);\n };\n \n@@ -331,6 +348,11 @@ TestRenderFrame::TakeLastCommitParams() {\n   return mock_frame_host_->TakeLastCommitParams();\n }\n \n+void TestRenderFrame::SetDidAddMessageToConsoleCallback(\n+    base::OnceCallback<void(const base::string16& msg)> callback) {\n+  mock_frame_host_->SetDidAddMessageToConsoleCallback(std::move(callback));\n+}\n+\n service_manager::mojom::InterfaceProviderRequest\n TestRenderFrame::TakeLastInterfaceProviderRequest() {\n   return mock_frame_host_->TakeLastInterfaceProviderRequest();""}<_**next**_>{""sha"": ""7d719b24a9a6129485a09cbd2a9b6e3c68493b95"", ""filename"": ""content/test/test_render_frame.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_frame.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -68,6 +68,11 @@ class TestRenderFrame : public RenderFrameImpl {\n   std::unique_ptr<FrameHostMsg_DidCommitProvisionalLoad_Params>\n   TakeLastCommitParams();\n \n+  // Sets a callback to be run the next time DidAddMessageToConsole\n+  // is called (e.g. window.console.log() is called).\n+  void SetDidAddMessageToConsoleCallback(\n+      base::OnceCallback<void(const base::string16& msg)> callback);\n+\n   service_manager::mojom::InterfaceProviderRequest\n   TakeLastInterfaceProviderRequest();\n ""}<_**next**_>{""sha"": ""e27564fc7676757363d8d4035d81fdc5e5a1f196"", ""filename"": ""third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -44,7 +44,7 @@ bool NavigationRateLimiter::CanProceed() {\n   }\n \n   // Display an error message. Do it only once in a while, else it will flood\n-  // the browser process with the FrameHostMsg_DidAddMessageToConsole IPC.\n+  // the browser process with the DidAddMessageToConsole Mojo call.\n   if (!error_message_sent_) {\n     error_message_sent_ = true;\n     if (auto* local_frame = DynamicTo<LocalFrame>(frame_.Get())) {""}","bool RenderFrameHostImpl::CreateRenderFrame(int previous_routing_id,
                                            int opener_routing_id,
                                            int parent_routing_id,
                                            int previous_sibling_routing_id) {
  TRACE_EVENT0(""navigation"", ""RenderFrameHostImpl::CreateRenderFrame"");
  DCHECK(!IsRenderFrameLive()) << ""Creating frame twice"";

  if (!GetProcess()->Init())
    return false;

  DCHECK(GetProcess()->IsInitializedAndNotDead());

  service_manager::mojom::InterfaceProviderPtr interface_provider;
  BindInterfaceProviderRequest(mojo::MakeRequest(&interface_provider));

  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_content_info;
  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_blink_info;
  BindDocumentInterfaceBrokerRequest(
      mojo::MakeRequest(&document_interface_broker_content_info),
      mojo::MakeRequest(&document_interface_broker_blink_info));

  mojom::CreateFrameParamsPtr params = mojom::CreateFrameParams::New();
  params->interface_bundle = mojom::DocumentScopedInterfaceBundle::New(
      interface_provider.PassInterface(),
      std::move(document_interface_broker_content_info),
      std::move(document_interface_broker_blink_info));

  params->routing_id = routing_id_;
  params->previous_routing_id = previous_routing_id;
  params->opener_routing_id = opener_routing_id;
  params->parent_routing_id = parent_routing_id;
  params->previous_sibling_routing_id = previous_sibling_routing_id;
  params->replication_state = frame_tree_node()->current_replication_state();
  params->devtools_frame_token = frame_tree_node()->devtools_frame_token();

  params->replication_state.frame_policy =
      frame_tree_node()->pending_frame_policy();

  params->frame_owner_properties =
      FrameOwnerProperties(frame_tree_node()->frame_owner_properties());

  params->has_committed_real_load =
      frame_tree_node()->has_committed_real_load();

  params->widget_params = mojom::CreateFrameWidgetParams::New();
  if (render_widget_host_) {
    params->widget_params->routing_id = render_widget_host_->GetRoutingID();
    params->widget_params->hidden = render_widget_host_->is_hidden();
  } else {
    params->widget_params->routing_id = MSG_ROUTING_NONE;
    params->widget_params->hidden = true;
  }

  GetProcess()->GetRendererInterface()->CreateFrame(std::move(params));

  if (parent_routing_id != MSG_ROUTING_NONE && render_widget_host_) {
    RenderWidgetHostView* rwhv =
        RenderWidgetHostViewChildFrame::Create(render_widget_host_);
    rwhv->Hide();
  }

  if (previous_routing_id != MSG_ROUTING_NONE) {
    RenderFrameProxyHost* proxy = RenderFrameProxyHost::FromID(
        GetProcess()->GetID(), previous_routing_id);
    proxy->set_render_frame_proxy_created(true);
  }

  SetRenderFrameCreated(true);

  return true;
}
","bool RenderFrameHostImpl::CreateRenderFrame(int previous_routing_id,
                                            int opener_routing_id,
                                            int parent_routing_id,
                                            int previous_sibling_routing_id) {
  TRACE_EVENT0(""navigation"", ""RenderFrameHostImpl::CreateRenderFrame"");
  DCHECK(!IsRenderFrameLive()) << ""Creating frame twice"";

  if (!GetProcess()->Init())
    return false;

  DCHECK(GetProcess()->IsInitializedAndNotDead());

  service_manager::mojom::InterfaceProviderPtr interface_provider;
  BindInterfaceProviderRequest(mojo::MakeRequest(&interface_provider));

  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_content_info;
  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_blink_info;
  BindDocumentInterfaceBrokerRequest(
      mojo::MakeRequest(&document_interface_broker_content_info),
      mojo::MakeRequest(&document_interface_broker_blink_info));

  mojom::CreateFrameParamsPtr params = mojom::CreateFrameParams::New();
  params->interface_bundle = mojom::DocumentScopedInterfaceBundle::New(
      interface_provider.PassInterface(),
      std::move(document_interface_broker_content_info),
      std::move(document_interface_broker_blink_info));

  params->routing_id = routing_id_;
  params->previous_routing_id = previous_routing_id;
  params->opener_routing_id = opener_routing_id;
  params->parent_routing_id = parent_routing_id;
  params->previous_sibling_routing_id = previous_sibling_routing_id;
  params->replication_state = frame_tree_node()->current_replication_state();
  params->devtools_frame_token = frame_tree_node()->devtools_frame_token();

  params->replication_state.frame_policy =
      frame_tree_node()->pending_frame_policy();

  params->frame_owner_properties =
      FrameOwnerProperties(frame_tree_node()->frame_owner_properties());

  params->has_committed_real_load =
      frame_tree_node()->has_committed_real_load();

  params->widget_params = mojom::CreateFrameWidgetParams::New();
  if (render_widget_host_) {
    params->widget_params->routing_id = render_widget_host_->GetRoutingID();
    params->widget_params->hidden = render_widget_host_->is_hidden();
  } else {
    params->widget_params->routing_id = MSG_ROUTING_NONE;
    params->widget_params->hidden = true;
  }

  GetProcess()->GetRendererInterface()->CreateFrame(std::move(params));

  if (parent_routing_id != MSG_ROUTING_NONE && render_widget_host_) {
    RenderWidgetHostView* rwhv =
        RenderWidgetHostViewChildFrame::Create(render_widget_host_);
    rwhv->Hide();
  }

  if (previous_routing_id != MSG_ROUTING_NONE) {
    RenderFrameProxyHost* proxy = RenderFrameProxyHost::FromID(
        GetProcess()->GetID(), previous_routing_id);
    proxy->set_render_frame_proxy_created(true);
  }

  SetRenderFrameCreated(true);

  return true;
}
",C,,,,"@@ -1375,8 +1375,6 @@ bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {
 
   handled = true;
   IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)
-    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,
-                        OnDidAddMessageToConsole)
     IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)
     IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)
     IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,
@@ -1833,21 +1831,35 @@ void RenderFrameHostImpl::OnAudibleStateChanged(bool is_audible) {
   is_audible_ = is_audible;
 }
 
-void RenderFrameHostImpl::OnDidAddMessageToConsole(
-    int32_t level,
+void RenderFrameHostImpl::DidAddMessageToConsole(
+    blink::mojom::ConsoleMessageLevel log_level,
     const base::string16& message,
     int32_t line_no,
     const base::string16& source_id) {
-  if (level < logging::LOG_VERBOSE || level > logging::LOG_FATAL) {
-    bad_message::ReceivedBadMessage(
-        GetProcess(), bad_message::RFH_DID_ADD_CONSOLE_MESSAGE_BAD_SEVERITY);
-    return;
+  // TODO(https://crbug.com/786836): Update downstream code to use
+  // ConsoleMessageLevel everywhere to avoid this conversion.
+  logging::LogSeverity log_severity = logging::LOG_VERBOSE;
+  switch (log_level) {
+    case blink::mojom::ConsoleMessageLevel::kVerbose:
+      log_severity = logging::LOG_VERBOSE;
+      break;
+    case blink::mojom::ConsoleMessageLevel::kInfo:
+      log_severity = logging::LOG_INFO;
+      break;
+    case blink::mojom::ConsoleMessageLevel::kWarning:
+      log_severity = logging::LOG_WARNING;
+      break;
+    case blink::mojom::ConsoleMessageLevel::kError:
+      log_severity = logging::LOG_ERROR;
+      break;
   }
 
-  if (delegate_->DidAddMessageToConsole(level, message, line_no, source_id))
+  if (delegate_->DidAddMessageToConsole(log_severity, message, line_no,
+                                        source_id)) {
     return;
+  }
 
-  // Pass through log level only on builtin components pages to limit console
+  // Pass through log severity only on builtin components pages to limit console
   // spew.
   const bool is_builtin_component =
       HasWebUIScheme(delegate_->GetMainFrameLastCommittedURL()) ||
@@ -1856,7 +1868,7 @@ void RenderFrameHostImpl::OnDidAddMessageToConsole(
   const bool is_off_the_record =
       GetSiteInstance()->GetBrowserContext()->IsOffTheRecord();
 
-  LogConsoleMessage(level, message, line_no, is_builtin_component,
+  LogConsoleMessage(log_severity, message, line_no, is_builtin_component,
                     is_off_the_record, source_id);
 }
 ",Chrome,f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,c246049ec1b28d1af4fe3be886ac5904e1762026,0,"bool RenderFrameHostImpl::CreateRenderFrame(int previous_routing_id,
                                            int opener_routing_id,
                                            int parent_routing_id,
                                            int previous_sibling_routing_id) {
  TRACE_EVENT0(""navigation"", ""RenderFrameHostImpl::CreateRenderFrame"");
  DCHECK(!IsRenderFrameLive()) << ""Creating frame twice"";

  // The process may (if we're sharing a process with another host that already
  // initialized it) or may not (we have our own process or the old process
  // crashed) have been initialized. Calling Init multiple times will be
  // ignored, so this is safe.
  if (!GetProcess()->Init())
    return false;

  DCHECK(GetProcess()->IsInitializedAndNotDead());

  service_manager::mojom::InterfaceProviderPtr interface_provider;
  BindInterfaceProviderRequest(mojo::MakeRequest(&interface_provider));

  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_content_info;
  blink::mojom::DocumentInterfaceBrokerPtrInfo
      document_interface_broker_blink_info;
  BindDocumentInterfaceBrokerRequest(
      mojo::MakeRequest(&document_interface_broker_content_info),
      mojo::MakeRequest(&document_interface_broker_blink_info));

  mojom::CreateFrameParamsPtr params = mojom::CreateFrameParams::New();
  params->interface_bundle = mojom::DocumentScopedInterfaceBundle::New(
      interface_provider.PassInterface(),
      std::move(document_interface_broker_content_info),
      std::move(document_interface_broker_blink_info));

  params->routing_id = routing_id_;
  params->previous_routing_id = previous_routing_id;
  params->opener_routing_id = opener_routing_id;
  params->parent_routing_id = parent_routing_id;
  params->previous_sibling_routing_id = previous_sibling_routing_id;
  params->replication_state = frame_tree_node()->current_replication_state();
  params->devtools_frame_token = frame_tree_node()->devtools_frame_token();

  // Normally, the replication state contains effective frame policy, excluding
  // sandbox flags and feature policy attributes that were updated but have not
  // taken effect. However, a new RenderFrame should use the pending frame
  // policy, since it is being created as part of the navigation that will
  // commit it. (I.e., the RenderFrame needs to know the policy to use when
  // initializing the new document once it commits).
  params->replication_state.frame_policy =
      frame_tree_node()->pending_frame_policy();

  params->frame_owner_properties =
      FrameOwnerProperties(frame_tree_node()->frame_owner_properties());

  params->has_committed_real_load =
      frame_tree_node()->has_committed_real_load();

  params->widget_params = mojom::CreateFrameWidgetParams::New();
  if (render_widget_host_) {
    params->widget_params->routing_id = render_widget_host_->GetRoutingID();
    params->widget_params->hidden = render_widget_host_->is_hidden();
  } else {
    // MSG_ROUTING_NONE will prevent a new RenderWidget from being created in
    // the renderer process.
    params->widget_params->routing_id = MSG_ROUTING_NONE;
    params->widget_params->hidden = true;
  }

  GetProcess()->GetRendererInterface()->CreateFrame(std::move(params));

  // The RenderWidgetHost takes ownership of its view. It is tied to the
  // lifetime of the current RenderProcessHost for this RenderFrameHost.
  // TODO(avi): This will need to change to initialize a
  // RenderWidgetHostViewAura for the main frame once RenderViewHostImpl has-a
  // RenderWidgetHostImpl. https://crbug.com/545684
  if (parent_routing_id != MSG_ROUTING_NONE && render_widget_host_) {
    RenderWidgetHostView* rwhv =
        RenderWidgetHostViewChildFrame::Create(render_widget_host_);
    rwhv->Hide();
  }

  if (previous_routing_id != MSG_ROUTING_NONE) {
    RenderFrameProxyHost* proxy = RenderFrameProxyHost::FromID(
        GetProcess()->GetID(), previous_routing_id);
    // We have also created a RenderFrameProxy in CreateFrame above, so
    // remember that.
    proxy->set_render_frame_proxy_created(true);
  }

  // The renderer now has a RenderFrame for this RenderFrameHost.  Note that
  // this path is only used for out-of-process iframes.  Main frame RenderFrames
  // are created with their RenderView, and same-site iframes are created at the
  // time of OnCreateChildFrame.
  SetRenderFrameCreated(true);

  return true;
}
"
176115,,Remote,Not required,Complete,CVE-2018-9497,https://www.cvedetails.com/cve/CVE-2018-9497/,CWE-787,Medium,Complete,Complete,,2018-10-02,9.3,In impeg2_fmt_conv_yuv420p_to_yuv420sp_uv_av8 of impeg2_format_conv.s there is a possible out of bounds write due to missing bounds check. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-74078669,2018-11-20,Exec Code ,0,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be,bef16671c891e16f25a7b174bc528eea109357be,"Adding check for min_width and min_height

Add check for min_wd and min_ht. Stride is updated if header
decode is done.

Bug: 74078669

Change-Id: Ided95395e1138335dbb4b05131a8551f6f7bbfcd
(cherry picked from commit 84eba4863dd50083951db83ea3cc81e015bf51da)
",0,decoder/impeg2d_dec_hdr.c,"{""filename"": ""decoder/impeg2d_dec_hdr.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be/decoder/impeg2d_dec_hdr.c"", ""patch"": ""@@ -167,10 +167,6 @@\n\n             /* This is the first time we are reading the resolution */\n             ps_dec->u2_horizontal_size = u2_width;\n             ps_dec->u2_vertical_size = u2_height;\n-            if (0 == ps_dec->u4_frm_buf_stride)\n-            {\n-                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);\n-            }\n         }\n         else\n         {\n@@ -193,6 +189,11 @@\n\n \n                 return e_error;\n             }\n+            else if((ps_dec->u2_horizontal_size < MIN_WIDTH)\n+                            || (ps_dec->u2_vertical_size < MIN_HEIGHT))\n+            {\n+                return IMPEG2D_UNSUPPORTED_DIMENSIONS;\n+            }\n             else\n             {\n                 /* The resolution has changed */\n@@ -210,6 +211,11 @@\n\n         return e_error;\n     }\n \n+    if((ps_dec->u2_horizontal_size < MIN_WIDTH)\n+                    || (ps_dec->u2_vertical_size < MIN_HEIGHT))\n+    {\n+        return IMPEG2D_UNSUPPORTED_DIMENSIONS;\n+    }\n \n     /*------------------------------------------------------------------------*/\n     /* Flush the following as they are not being used                         */\n""}<_**next**_>{""filename"": ""decoder/impeg2d_decoder.c"", ""raw_url"": ""https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be/decoder/impeg2d_decoder.c"", ""patch"": ""@@ -155,6 +155,12 @@\n\n             ps_op->s_ivd_video_decode_op_t.u4_num_bytes_consumed = ps_ip->s_ivd_video_decode_ip_t.u4_num_Bytes;\n         }\n         ps_op->s_ivd_video_decode_op_t.u4_frame_decoded_flag = 0;\n+\n+        /* Set the stride */\n+        if (0 == ps_dec->u4_frm_buf_stride)\n+        {\n+            ps_dec->u4_frm_buf_stride = ps_dec->u2_horizontal_size;\n+        }\n         /* MOD */\n         ps_dec->u2_header_done = 1;\n \n""}","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
 if (ps_dec->u2_forw_f_code < 1 || ps_dec->u2_forw_f_code > 7 ||
                        ps_dec->u2_back_f_code < 1 || ps_dec->u2_back_f_code > 7)
 {
 return IMPEG2D_UNKNOWN_ERROR;
 }
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
 if (ps_dec->u2_forw_f_code < 1 || ps_dec->u2_forw_f_code > 7 ||
                        ps_dec->u2_back_f_code < 1 || ps_dec->u2_back_f_code > 7)
 {
 return IMPEG2D_UNKNOWN_ERROR;
 }
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",C,,,,"@@ -167,10 +167,6 @@

             /* This is the first time we are reading the resolution */
             ps_dec->u2_horizontal_size = u2_width;
             ps_dec->u2_vertical_size = u2_height;
-            if (0 == ps_dec->u4_frm_buf_stride)
-            {
-                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);
-            }
         }
         else
         {
@@ -193,6 +189,11 @@

 
                 return e_error;
             }
+            else if((ps_dec->u2_horizontal_size < MIN_WIDTH)
+                            || (ps_dec->u2_vertical_size < MIN_HEIGHT))
+            {
+                return IMPEG2D_UNSUPPORTED_DIMENSIONS;
+            }
             else
             {
                 /* The resolution has changed */
@@ -210,6 +211,11 @@

         return e_error;
     }
 
+    if((ps_dec->u2_horizontal_size < MIN_WIDTH)
+                    || (ps_dec->u2_vertical_size < MIN_HEIGHT))
+    {
+        return IMPEG2D_UNSUPPORTED_DIMENSIONS;
+    }
 
     /*------------------------------------------------------------------------*/
     /* Flush the following as they are not being used                         */
",Android,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be/,https://android.googlesource.com/platform/external/libmpeg2/+/bef16671c891e16f25a7b174bc528eea109357be%5E/,0,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
 /* Flush temporal reference */
    impeg2d_bit_stream_get(ps_stream,10);

 /* Picture type */
    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);
 if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))
 {
        impeg2d_next_code(ps_dec, PICTURE_START_CODE);
 return IMPEG2D_INVALID_PIC_TYPE;
 }

 /* Flush vbv_delay */
    impeg2d_bit_stream_get(ps_stream,16);

 if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }
 if(ps_dec->e_pic_type == B_PIC)
 {
        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);
        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);
 }

 if(ps_dec->u2_is_mpeg2 == 0)
 {
 if (ps_dec->u2_forw_f_code < 1 || ps_dec->u2_forw_f_code > 7 ||
                        ps_dec->u2_back_f_code < 1 || ps_dec->u2_back_f_code > 7)
 {
 return IMPEG2D_UNKNOWN_ERROR;
 }
        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;
        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;
 }

 /*-----------------------------------------------------------------------*/
 /*  Flush the extra bit value                                            */
 /*                                                                       */
 /*  while(impeg2d_bit_stream_nxt() == '1')                                  */
 /*  {                                                                    */
 /*      extra_bit_picture         1                                      */
 /*      extra_information_picture 8                                      */
 /*  }                                                                    */
 /*  extra_bit_picture             1                                      */
 /*-----------------------------------------------------------------------*/
 while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&
           ps_stream->u4_offset < ps_stream->u4_max_offset)
 {
        impeg2d_bit_stream_get(ps_stream,9);
 }
    impeg2d_bit_stream_get_bit(ps_stream);
    impeg2d_next_start_code(ps_dec);

 return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
"
47636,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,0,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",0,drivers/s390/crypto/ap_bus.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","static inline int ap_test_config_card_id(unsigned int id)
{
	if (!ap_configuration)
		return 1;
	return ap_test_config(ap_configuration->apm, id);
}
","static inline int ap_test_config_card_id(unsigned int id)
{
	if (!ap_configuration)
		return 1;
	return ap_test_config(ap_configuration->apm, id);
}
",C,,,,"@@ -44,6 +44,7 @@
 #include <linux/hrtimer.h>
 #include <linux/ktime.h>
 #include <asm/facility.h>
+#include <linux/crypto.h>
 
 #include ""ap_bus.h""
 
@@ -71,7 +72,7 @@ MODULE_AUTHOR(""IBM Corporation"");
 MODULE_DESCRIPTION(""Adjunct Processor Bus driver, "" \
 		   ""Copyright IBM Corp. 2006, 2012"");
 MODULE_LICENSE(""GPL"");
-MODULE_ALIAS(""z90crypt"");
+MODULE_ALIAS_CRYPTO(""z90crypt"");
 
 /*
  * Module parameter",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,0,"static inline int ap_test_config_card_id(unsigned int id)
{
	if (!ap_configuration)
		return 1;
	return ap_test_config(ap_configuration->apm, id);
}
"
129313,,Remote,Not required,Partial,CVE-2014-3173,https://www.cvedetails.com/cve/CVE-2014-3173/,CWE-119,Low,,,,2014-08-26,5.0,"The WebGL implementation in Google Chrome before 37.0.2062.94 does not ensure that clear calls interact properly with the state of a draw buffer, which allows remote attackers to cause a denial of service (read of uninitialized memory) via a crafted CANVAS element, related to gpu/command_buffer/service/framebuffer_manager.cc and gpu/command_buffer/service/gles2_cmd_decoder.cc.",2017-08-28,DoS Overflow ,0,https://github.com/chromium/chromium/commit/ee7579229ff7e9e5ae28bf53aea069251499d7da,ee7579229ff7e9e5ae28bf53aea069251499d7da,"Framebuffer clear() needs to consider the situation some draw buffers are disabled.

This is when we expose DrawBuffers extension.

BUG=376951
TEST=the attached test case, webgl conformance
R=kbr@chromium.org,bajones@chromium.org

Review URL: https://codereview.chromium.org/315283002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@275338 0039d316-1c4b-4281-b951-d872f2087c98",0,gpu/command_buffer/service/gles2_cmd_decoder.cc,"{""sha"": ""4022b3defaa1e286e85e72f7ac6aa702fa1e9fb2"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager.cc"", ""status"": ""modified"", ""additions"": 51, ""deletions"": 0, ""changes"": 51, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -360,6 +360,55 @@ bool Framebuffer::HasUnclearedAttachment(\n   return false;\n }\n \n+bool Framebuffer::HasUnclearedColorAttachments() const {\n+  for (AttachmentMap::const_iterator it = attachments_.begin();\n+       it != attachments_.end(); ++it) {\n+    if (it->first >= GL_COLOR_ATTACHMENT0 &&\n+        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {\n+      const Attachment* attachment = it->second.get();\n+      if (!attachment->cleared())\n+        return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void Framebuffer::ChangeDrawBuffersHelper(bool recover) const {\n+  scoped_ptr<GLenum[]> buffers(new GLenum[manager_->max_draw_buffers_]);\n+  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i)\n+    buffers[i] = GL_NONE;\n+  for (AttachmentMap::const_iterator it = attachments_.begin();\n+       it != attachments_.end(); ++it) {\n+    if (it->first >= GL_COLOR_ATTACHMENT0 &&\n+        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {\n+      buffers[it->first - GL_COLOR_ATTACHMENT0] = it->first;\n+    }\n+  }\n+  bool different = false;\n+  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {\n+    if (buffers[i] != draw_buffers_[i]) {\n+      different = true;\n+      break;\n+    }\n+  }\n+  if (different) {\n+    if (recover)\n+      glDrawBuffersARB(manager_->max_draw_buffers_, draw_buffers_.get());\n+    else\n+      glDrawBuffersARB(manager_->max_draw_buffers_, buffers.get());\n+  }\n+}\n+\n+void Framebuffer::PrepareDrawBuffersForClear() const {\n+  bool recover = false;\n+  ChangeDrawBuffersHelper(recover);\n+}\n+\n+void Framebuffer::RestoreDrawBuffersAfterClear() const {\n+  bool recover = true;\n+  ChangeDrawBuffersHelper(recover);\n+}\n+\n void Framebuffer::MarkAttachmentAsCleared(\n       RenderbufferManager* renderbuffer_manager,\n       TextureManager* texture_manager,\n@@ -516,6 +565,8 @@ void Framebuffer::SetDrawBuffers(GLsizei n, const GLenum* bufs) {\n     draw_buffers_[i] = bufs[i];\n }\n \n+\n+\n bool Framebuffer::HasAlphaMRT() const {\n   for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {\n     if (draw_buffers_[i] != GL_NONE) {""}<_**next**_>{""sha"": ""b68ab7d9f1209710bc994d02bc1ebb7c9344e2a5"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager.h?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -64,6 +64,7 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n   }\n \n   bool HasUnclearedAttachment(GLenum attachment) const;\n+  bool HasUnclearedColorAttachments() const;\n \n   void MarkAttachmentAsCleared(\n     RenderbufferManager* renderbuffer_manager,\n@@ -129,6 +130,14 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n \n   void SetDrawBuffers(GLsizei n, const GLenum* bufs);\n \n+  // If a color buffer is attached to GL_COLOR_ATTACHMENTi, enable that\n+  // draw buffer for glClear().\n+  void PrepareDrawBuffersForClear() const;\n+\n+  // Restore draw buffers states that have been changed in\n+  // PrepareDrawBuffersForClear().\n+  void RestoreDrawBuffersAfterClear() const;\n+\n   // Return true if any draw buffers has an alpha channel.\n   bool HasAlphaMRT() const;\n \n@@ -163,6 +172,10 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n     return framebuffer_complete_state_count_id_;\n   }\n \n+  // Helper function for PrepareDrawBuffersForClear() and\n+  // RestoreDrawBuffersAfterClear().\n+  void ChangeDrawBuffersHelper(bool recover) const;\n+\n   // The managers that owns this.\n   FramebufferManager* manager_;\n ""}<_**next**_>{""sha"": ""a27e6aeb24bea82701b82229749a73acfafde2f0"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""status"": ""modified"", ""additions"": 97, ""deletions"": 1, ""changes"": 98, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager_unittest.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""testing/gtest/include/gtest/gtest.h\""\n #include \""ui/gl/gl_mock.h\""\n \n+using ::testing::_;\n using ::testing::Return;\n \n namespace gpu {\n@@ -21,6 +22,8 @@ const GLint kMaxTextureSize = 64;\n const GLint kMaxCubemapSize = 64;\n const GLint kMaxRenderbufferSize = 64;\n const GLint kMaxSamples = 4;\n+const uint32 kMaxDrawBuffers = 16;\n+const uint32 kMaxColorAttachments = 16;\n const bool kDepth24Supported = false;\n const bool kUseDefaultTextures = false;\n \n@@ -113,7 +116,7 @@ class FramebufferInfoTest : public testing::Test {\n   static const GLuint kService1Id = 11;\n \n   FramebufferInfoTest()\n-      : manager_(1, 1),\n+      : manager_(kMaxDrawBuffers,  kMaxColorAttachments),\n         feature_info_(new FeatureInfo()),\n         renderbuffer_manager_(NULL, kMaxRenderbufferSize, kMaxSamples,\n                               kDepth24Supported) {\n@@ -590,6 +593,99 @@ TEST_F(FramebufferInfoTest, AttachTexture) {\n   EXPECT_TRUE(framebuffer_->IsCleared());\n }\n \n+TEST_F(FramebufferInfoTest, DrawBuffers) {\n+  const GLuint kTextureClientId[] = { 33, 34 };\n+  const GLuint kTextureServiceId[] = { 333, 334 };\n+\n+  for (GLenum i = GL_COLOR_ATTACHMENT0;\n+       i < GL_COLOR_ATTACHMENT0 + kMaxColorAttachments; ++i) {\n+    EXPECT_FALSE(framebuffer_->HasUnclearedAttachment(i));\n+  }\n+  EXPECT_FALSE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT0),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER0_ARB));\n+  for (GLenum i = GL_DRAW_BUFFER1_ARB;\n+       i < GL_DRAW_BUFFER0_ARB + kMaxDrawBuffers; ++i) {\n+    EXPECT_EQ(static_cast<GLenum>(GL_NONE),\n+              framebuffer_->GetDrawBuffer(i));\n+  }\n+\n+  for (size_t ii = 0; ii < arraysize(kTextureClientId); ++ii) {\n+    texture_manager_->CreateTexture(\n+        kTextureClientId[ii], kTextureServiceId[ii]);\n+    scoped_refptr<TextureRef> texture(\n+        texture_manager_->GetTexture(kTextureClientId[ii]));\n+    ASSERT_TRUE(texture.get() != NULL);\n+\n+    framebuffer_->AttachTexture(\n+        GL_COLOR_ATTACHMENT0 + ii, texture.get(), GL_TEXTURE_2D, 0, 0);\n+    EXPECT_FALSE(\n+        framebuffer_->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0 + ii));\n+\n+    const Framebuffer::Attachment* attachment =\n+        framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT0 + ii);\n+    ASSERT_TRUE(attachment != NULL);\n+    EXPECT_TRUE(attachment->cleared());\n+  }\n+  EXPECT_TRUE(framebuffer_->IsCleared());\n+  EXPECT_FALSE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  // Set a texture as uncleared.\n+  scoped_refptr<TextureRef> texture1(\n+      texture_manager_->GetTexture(kTextureClientId[1]));\n+  texture_manager_->SetTarget(texture1.get(), GL_TEXTURE_2D);\n+  texture_manager_->SetLevelInfo(\n+      texture1.get(), GL_TEXTURE_2D, 0, GL_RGBA, 4, 4,\n+      1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);\n+\n+  const Framebuffer::Attachment* attachment1 =\n+      framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT1);\n+  ASSERT_TRUE(attachment1 != NULL);\n+  EXPECT_FALSE(attachment1->cleared());\n+  EXPECT_FALSE(framebuffer_->IsCleared());\n+  EXPECT_TRUE(framebuffer_->HasUnclearedAttachment(GL_COLOR_ATTACHMENT1));\n+  EXPECT_TRUE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  GLenum buffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };\n+  framebuffer_->SetDrawBuffers(2, buffers);\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT0),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER0_ARB));\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT1),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER1_ARB));\n+  for (GLenum i = GL_DRAW_BUFFER2_ARB;\n+       i < GL_DRAW_BUFFER0_ARB + kMaxDrawBuffers; ++i) {\n+    EXPECT_EQ(static_cast<GLenum>(GL_NONE),\n+              framebuffer_->GetDrawBuffer(i));\n+  }\n+\n+  // Nothing happens.\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+\n+  // Now we disable a draw buffer 1.\n+  buffers[1] = GL_NONE;\n+  framebuffer_->SetDrawBuffers(2, buffers);\n+  // We will enable the disabled draw buffer for clear(), and disable it\n+  // after the clear.\n+  EXPECT_CALL(*gl_, DrawBuffersARB(kMaxDrawBuffers, _))\n+      .Times(1)\n+      .RetiresOnSaturation();\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  EXPECT_CALL(*gl_, DrawBuffersARB(kMaxDrawBuffers, _))\n+      .Times(1)\n+      .RetiresOnSaturation();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+\n+  // Now remove draw buffer 1's attachment.\n+  framebuffer_->AttachTexture(GL_COLOR_ATTACHMENT1, NULL, 0, 0, 0);\n+  EXPECT_TRUE(framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT1) == NULL);\n+\n+  // Nothing happens.\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+}\n+\n class FramebufferInfoFloatTest : public FramebufferInfoTest {\n  public:\n   FramebufferInfoFloatTest()""}<_**next**_>{""sha"": ""f954189ff66863873048905935d0d0bac811a09c"", ""filename"": ""gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 1, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/gles2_cmd_decoder.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -3076,7 +3076,20 @@ bool GLES2DecoderImpl::CheckFramebufferValid(\n       glClearDepth(1.0f);\n       state_.SetDeviceDepthMask(GL_TRUE);\n       state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);\n+      bool reset_draw_buffer = false;\n+      if ((backbuffer_needs_clear_bits_ | GL_COLOR_BUFFER_BIT) != 0 &&\n+          group_->draw_buffer() == GL_NONE) {\n+        reset_draw_buffer = true;\n+        GLenum buf = GL_BACK;\n+        if (GetBackbufferServiceId() != 0)  // emulated backbuffer\n+          buf = GL_COLOR_ATTACHMENT0;\n+        glDrawBuffersARB(1, &buf);\n+      }\n       glClear(backbuffer_needs_clear_bits_);\n+      if (reset_draw_buffer) {\n+        GLenum buf = GL_NONE;\n+        glDrawBuffersARB(1, &buf);\n+      }\n       backbuffer_needs_clear_bits_ = 0;\n       RestoreClearState();\n     }\n@@ -5022,14 +5035,15 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(\n     glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, framebuffer->service_id());\n   }\n   GLbitfield clear_bits = 0;\n-  if (framebuffer->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {\n+  if (framebuffer->HasUnclearedColorAttachments()) {\n     glClearColor(\n         0.0f, 0.0f, 0.0f,\n         (GLES2Util::GetChannelsForFormat(\n              framebuffer->GetColorAttachmentFormat()) & 0x0008) != 0 ? 0.0f :\n                                                                        1.0f);\n     state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\n     clear_bits |= GL_COLOR_BUFFER_BIT;\n+    framebuffer->PrepareDrawBuffersForClear();\n   }\n \n   if (framebuffer->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||\n@@ -5050,6 +5064,9 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(\n   state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);\n   glClear(clear_bits);\n \n+  if ((clear_bits | GL_COLOR_BUFFER_BIT) != 0)\n+    framebuffer->RestoreDrawBuffersAfterClear();\n+\n   framebuffer_manager()->MarkAttachmentsAsCleared(\n       framebuffer, renderbuffer_manager(), texture_manager());\n ""}","void GLES2DecoderImpl::DoSwapBuffers() {
  bool is_offscreen = !!offscreen_target_frame_buffer_.get();

  int this_frame_number = frame_number_++;
  TRACE_EVENT_INSTANT2(""test_gpu"", ""SwapBuffersLatency"",
                       TRACE_EVENT_SCOPE_THREAD,
                       ""GLImpl"", static_cast<int>(gfx::GetGLImplementation()),
                       ""width"", (is_offscreen ? offscreen_size_.width() :
                                 surface_->GetSize().width()));
  TRACE_EVENT2(""gpu"", ""GLES2DecoderImpl::DoSwapBuffers"",
               ""offscreen"", is_offscreen,
               ""frame"", this_frame_number);
  {
    TRACE_EVENT_SYNTHETIC_DELAY(""gpu.PresentingFrame"");
  }

  bool is_tracing;
  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT(""gpu.debug""),
                                     &is_tracing);
  if (is_tracing) {
    ScopedFrameBufferBinder binder(this, GetBackbufferServiceId());
    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(
        is_offscreen ? offscreen_size_ : surface_->GetSize());
  }

  if (is_offscreen) {
    TRACE_EVENT2(""gpu"", ""Offscreen"",
        ""width"", offscreen_size_.width(), ""height"", offscreen_size_.height());
    if (offscreen_size_ != offscreen_saved_color_texture_->size()) {
      if (workarounds().needs_offscreen_buffer_workaround) {
        offscreen_saved_frame_buffer_->Create();
        glFinish();
      }

      DCHECK(offscreen_saved_color_format_);
      offscreen_saved_color_texture_->AllocateStorage(
          offscreen_size_, offscreen_saved_color_format_, false);

      offscreen_saved_frame_buffer_->AttachRenderTexture(
          offscreen_saved_color_texture_.get());
      if (offscreen_size_.width() != 0 && offscreen_size_.height() != 0) {
        if (offscreen_saved_frame_buffer_->CheckStatus() !=
            GL_FRAMEBUFFER_COMPLETE) {
          LOG(ERROR) << ""GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed ""
                     << ""because offscreen saved FBO was incomplete."";
          LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
          return;
        }

        {
          ScopedFrameBufferBinder binder(this,
                                         offscreen_saved_frame_buffer_->id());
          glClearColor(0, 0, 0, 0);
          state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
          state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
          glClear(GL_COLOR_BUFFER_BIT);
          RestoreClearState();
        }
      }

      UpdateParentTextureInfo();
    }

    if (offscreen_size_.width() == 0 || offscreen_size_.height() == 0)
      return;
    ScopedGLErrorSuppressor suppressor(
        ""GLES2DecoderImpl::DoSwapBuffers"", GetErrorState());

    if (IsOffscreenBufferMultisampled()) {
      ScopedResolvedFrameBufferBinder binder(this, true, false);
    } else {
      ScopedFrameBufferBinder binder(this,
                                     offscreen_target_frame_buffer_->id());

      if (offscreen_target_buffer_preserved_) {
        offscreen_saved_color_texture_->Copy(
            offscreen_saved_color_texture_->size(),
            offscreen_saved_color_format_);
      } else {
        if (!!offscreen_saved_color_texture_info_.get())
          offscreen_saved_color_texture_info_->texture()->
              SetServiceId(offscreen_target_color_texture_->id());

        offscreen_saved_color_texture_.swap(offscreen_target_color_texture_);
        offscreen_target_frame_buffer_->AttachRenderTexture(
            offscreen_target_color_texture_.get());
      }

      if (!feature_info_->feature_flags().is_angle)
        glFlush();
    }
  } else {
    if (!surface_->SwapBuffers()) {
      LOG(ERROR) << ""Context lost because SwapBuffers failed."";
      LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
    }
  }
}
","void GLES2DecoderImpl::DoSwapBuffers() {
  bool is_offscreen = !!offscreen_target_frame_buffer_.get();

  int this_frame_number = frame_number_++;
  TRACE_EVENT_INSTANT2(""test_gpu"", ""SwapBuffersLatency"",
                       TRACE_EVENT_SCOPE_THREAD,
                       ""GLImpl"", static_cast<int>(gfx::GetGLImplementation()),
                       ""width"", (is_offscreen ? offscreen_size_.width() :
                                 surface_->GetSize().width()));
  TRACE_EVENT2(""gpu"", ""GLES2DecoderImpl::DoSwapBuffers"",
               ""offscreen"", is_offscreen,
               ""frame"", this_frame_number);
  {
    TRACE_EVENT_SYNTHETIC_DELAY(""gpu.PresentingFrame"");
  }

  bool is_tracing;
  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT(""gpu.debug""),
                                     &is_tracing);
  if (is_tracing) {
    ScopedFrameBufferBinder binder(this, GetBackbufferServiceId());
    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(
        is_offscreen ? offscreen_size_ : surface_->GetSize());
  }

  if (is_offscreen) {
    TRACE_EVENT2(""gpu"", ""Offscreen"",
        ""width"", offscreen_size_.width(), ""height"", offscreen_size_.height());
    if (offscreen_size_ != offscreen_saved_color_texture_->size()) {
      if (workarounds().needs_offscreen_buffer_workaround) {
        offscreen_saved_frame_buffer_->Create();
        glFinish();
      }

      DCHECK(offscreen_saved_color_format_);
      offscreen_saved_color_texture_->AllocateStorage(
          offscreen_size_, offscreen_saved_color_format_, false);

      offscreen_saved_frame_buffer_->AttachRenderTexture(
          offscreen_saved_color_texture_.get());
      if (offscreen_size_.width() != 0 && offscreen_size_.height() != 0) {
        if (offscreen_saved_frame_buffer_->CheckStatus() !=
            GL_FRAMEBUFFER_COMPLETE) {
          LOG(ERROR) << ""GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed ""
                     << ""because offscreen saved FBO was incomplete."";
          LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
          return;
        }

        {
          ScopedFrameBufferBinder binder(this,
                                         offscreen_saved_frame_buffer_->id());
          glClearColor(0, 0, 0, 0);
          state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
          state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
          glClear(GL_COLOR_BUFFER_BIT);
          RestoreClearState();
        }
      }

      UpdateParentTextureInfo();
    }

    if (offscreen_size_.width() == 0 || offscreen_size_.height() == 0)
      return;
    ScopedGLErrorSuppressor suppressor(
        ""GLES2DecoderImpl::DoSwapBuffers"", GetErrorState());

    if (IsOffscreenBufferMultisampled()) {
      ScopedResolvedFrameBufferBinder binder(this, true, false);
    } else {
      ScopedFrameBufferBinder binder(this,
                                     offscreen_target_frame_buffer_->id());

      if (offscreen_target_buffer_preserved_) {
        offscreen_saved_color_texture_->Copy(
            offscreen_saved_color_texture_->size(),
            offscreen_saved_color_format_);
      } else {
        if (!!offscreen_saved_color_texture_info_.get())
          offscreen_saved_color_texture_info_->texture()->
              SetServiceId(offscreen_target_color_texture_->id());

        offscreen_saved_color_texture_.swap(offscreen_target_color_texture_);
        offscreen_target_frame_buffer_->AttachRenderTexture(
            offscreen_target_color_texture_.get());
      }

      if (!feature_info_->feature_flags().is_angle)
        glFlush();
    }
  } else {
    if (!surface_->SwapBuffers()) {
      LOG(ERROR) << ""Context lost because SwapBuffers failed."";
      LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
    }
  }
}
",C,,,,"@@ -3076,7 +3076,20 @@ bool GLES2DecoderImpl::CheckFramebufferValid(
       glClearDepth(1.0f);
       state_.SetDeviceDepthMask(GL_TRUE);
       state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
+      bool reset_draw_buffer = false;
+      if ((backbuffer_needs_clear_bits_ | GL_COLOR_BUFFER_BIT) != 0 &&
+          group_->draw_buffer() == GL_NONE) {
+        reset_draw_buffer = true;
+        GLenum buf = GL_BACK;
+        if (GetBackbufferServiceId() != 0)  // emulated backbuffer
+          buf = GL_COLOR_ATTACHMENT0;
+        glDrawBuffersARB(1, &buf);
+      }
       glClear(backbuffer_needs_clear_bits_);
+      if (reset_draw_buffer) {
+        GLenum buf = GL_NONE;
+        glDrawBuffersARB(1, &buf);
+      }
       backbuffer_needs_clear_bits_ = 0;
       RestoreClearState();
     }
@@ -5022,14 +5035,15 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(
     glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, framebuffer->service_id());
   }
   GLbitfield clear_bits = 0;
-  if (framebuffer->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {
+  if (framebuffer->HasUnclearedColorAttachments()) {
     glClearColor(
         0.0f, 0.0f, 0.0f,
         (GLES2Util::GetChannelsForFormat(
              framebuffer->GetColorAttachmentFormat()) & 0x0008) != 0 ? 0.0f :
                                                                        1.0f);
     state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
     clear_bits |= GL_COLOR_BUFFER_BIT;
+    framebuffer->PrepareDrawBuffersForClear();
   }
 
   if (framebuffer->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||
@@ -5050,6 +5064,9 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(
   state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
   glClear(clear_bits);
 
+  if ((clear_bits | GL_COLOR_BUFFER_BIT) != 0)
+    framebuffer->RestoreDrawBuffersAfterClear();
+
   framebuffer_manager()->MarkAttachmentsAsCleared(
       framebuffer, renderbuffer_manager(), texture_manager());
 ",Chrome,ee7579229ff7e9e5ae28bf53aea069251499d7da,38f4c0adff7b42decb912e5382a57e35729315a0,0,"void GLES2DecoderImpl::DoSwapBuffers() {
  bool is_offscreen = !!offscreen_target_frame_buffer_.get();

  int this_frame_number = frame_number_++;
  // TRACE_EVENT for gpu tests:
  TRACE_EVENT_INSTANT2(""test_gpu"", ""SwapBuffersLatency"",
                       TRACE_EVENT_SCOPE_THREAD,
                       ""GLImpl"", static_cast<int>(gfx::GetGLImplementation()),
                       ""width"", (is_offscreen ? offscreen_size_.width() :
                                 surface_->GetSize().width()));
  TRACE_EVENT2(""gpu"", ""GLES2DecoderImpl::DoSwapBuffers"",
               ""offscreen"", is_offscreen,
               ""frame"", this_frame_number);
  {
    TRACE_EVENT_SYNTHETIC_DELAY(""gpu.PresentingFrame"");
  }

  bool is_tracing;
  TRACE_EVENT_CATEGORY_GROUP_ENABLED(TRACE_DISABLED_BY_DEFAULT(""gpu.debug""),
                                     &is_tracing);
  if (is_tracing) {
    ScopedFrameBufferBinder binder(this, GetBackbufferServiceId());
    gpu_state_tracer_->TakeSnapshotWithCurrentFramebuffer(
        is_offscreen ? offscreen_size_ : surface_->GetSize());
  }

  // If offscreen then don't actually SwapBuffers to the display. Just copy
  // the rendered frame to another frame buffer.
  if (is_offscreen) {
    TRACE_EVENT2(""gpu"", ""Offscreen"",
        ""width"", offscreen_size_.width(), ""height"", offscreen_size_.height());
    if (offscreen_size_ != offscreen_saved_color_texture_->size()) {
      // Workaround for NVIDIA driver bug on OS X; crbug.com/89557,
      // crbug.com/94163. TODO(kbr): figure out reproduction so Apple will
      // fix this.
      if (workarounds().needs_offscreen_buffer_workaround) {
        offscreen_saved_frame_buffer_->Create();
        glFinish();
      }

      // Allocate the offscreen saved color texture.
      DCHECK(offscreen_saved_color_format_);
      offscreen_saved_color_texture_->AllocateStorage(
          offscreen_size_, offscreen_saved_color_format_, false);

      offscreen_saved_frame_buffer_->AttachRenderTexture(
          offscreen_saved_color_texture_.get());
      if (offscreen_size_.width() != 0 && offscreen_size_.height() != 0) {
        if (offscreen_saved_frame_buffer_->CheckStatus() !=
            GL_FRAMEBUFFER_COMPLETE) {
          LOG(ERROR) << ""GLES2DecoderImpl::ResizeOffscreenFrameBuffer failed ""
                     << ""because offscreen saved FBO was incomplete."";
          LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
          return;
        }

        // Clear the offscreen color texture.
        // TODO(piman): Is this still necessary?
        {
          ScopedFrameBufferBinder binder(this,
                                         offscreen_saved_frame_buffer_->id());
          glClearColor(0, 0, 0, 0);
          state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
          state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
          glClear(GL_COLOR_BUFFER_BIT);
          RestoreClearState();
        }
      }

      UpdateParentTextureInfo();
    }

    if (offscreen_size_.width() == 0 || offscreen_size_.height() == 0)
      return;
    ScopedGLErrorSuppressor suppressor(
        ""GLES2DecoderImpl::DoSwapBuffers"", GetErrorState());

    if (IsOffscreenBufferMultisampled()) {
      // For multisampled buffers, resolve the frame buffer.
      ScopedResolvedFrameBufferBinder binder(this, true, false);
    } else {
      ScopedFrameBufferBinder binder(this,
                                     offscreen_target_frame_buffer_->id());

      if (offscreen_target_buffer_preserved_) {
        // Copy the target frame buffer to the saved offscreen texture.
        offscreen_saved_color_texture_->Copy(
            offscreen_saved_color_texture_->size(),
            offscreen_saved_color_format_);
      } else {
        // Flip the textures in the parent context via the texture manager.
        if (!!offscreen_saved_color_texture_info_.get())
          offscreen_saved_color_texture_info_->texture()->
              SetServiceId(offscreen_target_color_texture_->id());

        offscreen_saved_color_texture_.swap(offscreen_target_color_texture_);
        offscreen_target_frame_buffer_->AttachRenderTexture(
            offscreen_target_color_texture_.get());
      }

      // Ensure the side effects of the copy are visible to the parent
      // context. There is no need to do this for ANGLE because it uses a
      // single D3D device for all contexts.
      if (!feature_info_->feature_flags().is_angle)
        glFlush();
    }
  } else {
    if (!surface_->SwapBuffers()) {
      LOG(ERROR) << ""Context lost because SwapBuffers failed."";
      LoseContext(GL_UNKNOWN_CONTEXT_RESET_ARB);
    }
  }
}
"
47265,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,0,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",0,crypto/lz4hc.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","static int lz4hc_decompress_crypto(struct crypto_tfm *tfm, const u8 *src,
			      unsigned int slen, u8 *dst, unsigned int *dlen)
{
	int err;
	size_t tmp_len = *dlen;
	size_t __slen = slen;

	err = lz4_decompress_unknownoutputsize(src, __slen, dst, &tmp_len);
	if (err < 0)
		return -EINVAL;

	*dlen = tmp_len;
	return err;
}
","static int lz4hc_decompress_crypto(struct crypto_tfm *tfm, const u8 *src,
			      unsigned int slen, u8 *dst, unsigned int *dlen)
{
	int err;
	size_t tmp_len = *dlen;
	size_t __slen = slen;

	err = lz4_decompress_unknownoutputsize(src, __slen, dst, &tmp_len);
	if (err < 0)
		return -EINVAL;

	*dlen = tmp_len;
	return err;
}
",C,,,,"@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);
 
 MODULE_LICENSE(""GPL"");
 MODULE_DESCRIPTION(""LZ4HC Compression Algorithm"");
+MODULE_ALIAS_CRYPTO(""lz4hc"");",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,0,"static int lz4hc_decompress_crypto(struct crypto_tfm *tfm, const u8 *src,
			      unsigned int slen, u8 *dst, unsigned int *dlen)
{
	int err;
	size_t tmp_len = *dlen;
	size_t __slen = slen;

	err = lz4_decompress_unknownoutputsize(src, __slen, dst, &tmp_len);
	if (err < 0)
		return -EINVAL;

	*dlen = tmp_len;
	return err;
}
"
45337,,Local,Not required,Complete,CVE-2014-9710,https://www.cvedetails.com/cve/CVE-2014-9710/,CWE-362,Medium,Complete,Complete,,2015-05-27,6.9,"The Btrfs implementation in the Linux kernel before 3.19 does not ensure that the visible xattr state is consistent with a requested replacement, which allows local users to bypass intended ACL settings and gain privileges via standard filesystem operations (1) during an xattr-replacement time window, related to a race condition, or (2) after an xattr-replacement attempt that fails because the data does not fit.",2016-12-30,+Priv Bypass ,0,https://github.com/torvalds/linux/commit/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339,5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339,"Btrfs: make xattr replace operations atomic

Replacing a xattr consists of doing a lookup for its existing value, delete
the current value from the respective leaf, release the search path and then
finally insert the new value. This leaves a time window where readers (getxattr,
listxattrs) won't see any value for the xattr. Xattrs are used to store ACLs,
so this has security implications.

This change also fixes 2 other existing issues which were:

*) Deleting the old xattr value without verifying first if the new xattr will
   fit in the existing leaf item (in case multiple xattrs are packed in the
   same item due to name hash collision);

*) Returning -EEXIST when the flag XATTR_CREATE is given and the xattr doesn't
   exist but we have have an existing item that packs muliple xattrs with
   the same name hash as the input xattr. In this case we should return ENOSPC.

A test case for xfstests follows soon.

Thanks to Alexandre Oliva for reporting the non-atomicity of the xattr replace
implementation.

Reported-by: Alexandre Oliva <oliva@gnu.org>
Signed-off-by: Filipe Manana <fdmanana@suse.com>
Signed-off-by: Chris Mason <clm@fb.com>",0,fs/btrfs/ctree.c,"{""sha"": ""817234168a7fc298c16ec624f82a7952ff60f488"", ""filename"": ""fs/btrfs/ctree.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/ctree.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/ctree.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.c?ref=5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339"", ""patch"": ""@@ -2939,7 +2939,7 @@ int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root\n \t */\n \tif (!p->leave_spinning)\n \t\tbtrfs_set_path_blocking(p);\n-\tif (ret < 0)\n+\tif (ret < 0 && !p->skip_release_on_error)\n \t\tbtrfs_release_path(p);\n \treturn ret;\n }""}<_**next**_>{""sha"": ""a9466e346358d5f12952409c475d1c508660f69e"", ""filename"": ""fs/btrfs/ctree.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/ctree.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/ctree.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/ctree.h?ref=5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339"", ""patch"": ""@@ -607,6 +607,7 @@ struct btrfs_path {\n \tunsigned int leave_spinning:1;\n \tunsigned int search_commit_root:1;\n \tunsigned int need_commit_sem:1;\n+\tunsigned int skip_release_on_error:1;\n };\n \n /*\n@@ -3690,6 +3691,10 @@ struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n int verify_dir_item(struct btrfs_root *root,\n \t\t    struct extent_buffer *leaf,\n \t\t    struct btrfs_dir_item *dir_item);\n+struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n+\t\t\t\t\t\t struct btrfs_path *path,\n+\t\t\t\t\t\t const char *name,\n+\t\t\t\t\t\t int name_len);\n \n /* orphan.c */\n int btrfs_insert_orphan_item(struct btrfs_trans_handle *trans,""}<_**next**_>{""sha"": ""1752625fb4dd67ed81ec6c24b07fff555d10c62d"", ""filename"": ""fs/btrfs/dir-item.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 7, ""changes"": 10, ""blob_url"": ""https://github.com/torvalds/linux/blob/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/dir-item.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/dir-item.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/dir-item.c?ref=5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339"", ""patch"": ""@@ -21,10 +21,6 @@\n #include \""hash.h\""\n #include \""transaction.h\""\n \n-static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n-\t\t\t      struct btrfs_path *path,\n-\t\t\t      const char *name, int name_len);\n-\n /*\n  * insert a name into a directory, doing overflow properly if there is a hash\n  * collision.  data_size indicates how big the item inserted should be.  On\n@@ -383,9 +379,9 @@ struct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\n  * this walks through all the entries in a dir item and finds one\n  * for a specific name.\n  */\n-static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n-\t\t\t      struct btrfs_path *path,\n-\t\t\t      const char *name, int name_len)\n+struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n+\t\t\t\t\t\t struct btrfs_path *path,\n+\t\t\t\t\t\t const char *name, int name_len)\n {\n \tstruct btrfs_dir_item *dir_item;\n \tunsigned long name_ptr;""}<_**next**_>{""sha"": ""47b19465f0dc64e85d00d99eaee50e88de9f1014"", ""filename"": ""fs/btrfs/xattr.c"", ""status"": ""modified"", ""additions"": 93, ""deletions"": 57, ""changes"": 150, ""blob_url"": ""https://github.com/torvalds/linux/blob/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/xattr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339/fs/btrfs/xattr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/btrfs/xattr.c?ref=5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""xattr.h\""\n #include \""disk-io.h\""\n #include \""props.h\""\n+#include \""locking.h\""\n \n \n ssize_t __btrfs_getxattr(struct inode *inode, const char *name,\n@@ -91,7 +92,7 @@ static int do_setxattr(struct btrfs_trans_handle *trans,\n \t\t       struct inode *inode, const char *name,\n \t\t       const void *value, size_t size, int flags)\n {\n-\tstruct btrfs_dir_item *di;\n+\tstruct btrfs_dir_item *di = NULL;\n \tstruct btrfs_root *root = BTRFS_I(inode)->root;\n \tstruct btrfs_path *path;\n \tsize_t name_len = strlen(name);\n@@ -103,84 +104,119 @@ static int do_setxattr(struct btrfs_trans_handle *trans,\n \tpath = btrfs_alloc_path();\n \tif (!path)\n \t\treturn -ENOMEM;\n+\tpath->skip_release_on_error = 1;\n+\n+\tif (!value) {\n+\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n+\t\t\t\t\tname, name_len, -1);\n+\t\tif (!di && (flags & XATTR_REPLACE))\n+\t\t\tret = -ENODATA;\n+\t\telse if (di)\n+\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n+\t\tgoto out;\n+\t}\n \n+\t/*\n+\t * For a replace we can't just do the insert blindly.\n+\t * Do a lookup first (read-only btrfs_search_slot), and return if xattr\n+\t * doesn't exist. If it exists, fall down below to the insert/replace\n+\t * path - we can't race with a concurrent xattr delete, because the VFS\n+\t * locks the inode's i_mutex before calling setxattr or removexattr.\n+\t */\n \tif (flags & XATTR_REPLACE) {\n-\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode), name,\n-\t\t\t\t\tname_len, -1);\n-\t\tif (IS_ERR(di)) {\n-\t\t\tret = PTR_ERR(di);\n-\t\t\tgoto out;\n-\t\t} else if (!di) {\n+\t\tASSERT(mutex_is_locked(&inode->i_mutex));\n+\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n+\t\t\t\t\tname, name_len, 0);\n+\t\tif (!di) {\n \t\t\tret = -ENODATA;\n \t\t\tgoto out;\n \t\t}\n-\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n-\t\tif (ret)\n-\t\t\tgoto out;\n \t\tbtrfs_release_path(path);\n+\t\tdi = NULL;\n+\t}\n \n+\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n+\t\t\t\t      name, name_len, value, size);\n+\tif (ret == -EOVERFLOW) {\n \t\t/*\n-\t\t * remove the attribute\n+\t\t * We have an existing item in a leaf, split_leaf couldn't\n+\t\t * expand it. That item might have or not a dir_item that\n+\t\t * matches our target xattr, so lets check.\n \t\t */\n-\t\tif (!value)\n-\t\t\tgoto out;\n-\t} else {\n-\t\tdi = btrfs_lookup_xattr(NULL, root, path, btrfs_ino(inode),\n-\t\t\t\t\tname, name_len, 0);\n-\t\tif (IS_ERR(di)) {\n-\t\t\tret = PTR_ERR(di);\n+\t\tret = 0;\n+\t\tbtrfs_assert_tree_locked(path->nodes[0]);\n+\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\t\tif (!di && !(flags & XATTR_REPLACE)) {\n+\t\t\tret = -ENOSPC;\n \t\t\tgoto out;\n \t\t}\n-\t\tif (!di && !value)\n-\t\t\tgoto out;\n-\t\tbtrfs_release_path(path);\n+\t} else if (ret == -EEXIST) {\n+\t\tret = 0;\n+\t\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n+\t\tASSERT(di); /* logic error */\n+\t} else if (ret) {\n+\t\tgoto out;\n \t}\n \n-again:\n-\tret = btrfs_insert_xattr_item(trans, root, path, btrfs_ino(inode),\n-\t\t\t\t      name, name_len, value, size);\n-\t/*\n-\t * If we're setting an xattr to a new value but the new value is say\n-\t * exactly BTRFS_MAX_XATTR_SIZE, we could end up with EOVERFLOW getting\n-\t * back from split_leaf.  This is because it thinks we'll be extending\n-\t * the existing item size, but we're asking for enough space to add the\n-\t * item itself.  So if we get EOVERFLOW just set ret to EEXIST and let\n-\t * the rest of the function figure it out.\n-\t */\n-\tif (ret == -EOVERFLOW)\n+\tif (di && (flags & XATTR_CREATE)) {\n \t\tret = -EEXIST;\n+\t\tgoto out;\n+\t}\n \n-\tif (ret == -EEXIST) {\n-\t\tif (flags & XATTR_CREATE)\n-\t\t\tgoto out;\n+\tif (di) {\n \t\t/*\n-\t\t * We can't use the path we already have since we won't have the\n-\t\t * proper locking for a delete, so release the path and\n-\t\t * re-lookup to delete the thing.\n+\t\t * We're doing a replace, and it must be atomic, that is, at\n+\t\t * any point in time we have either the old or the new xattr\n+\t\t * value in the tree. We don't want readers (getxattr and\n+\t\t * listxattrs) to miss a value, this is specially important\n+\t\t * for ACLs.\n \t\t */\n-\t\tbtrfs_release_path(path);\n-\t\tdi = btrfs_lookup_xattr(trans, root, path, btrfs_ino(inode),\n-\t\t\t\t\tname, name_len, -1);\n-\t\tif (IS_ERR(di)) {\n-\t\t\tret = PTR_ERR(di);\n-\t\t\tgoto out;\n-\t\t} else if (!di) {\n-\t\t\t/* Shouldn't happen but just in case... */\n-\t\t\tbtrfs_release_path(path);\n-\t\t\tgoto again;\n+\t\tconst int slot = path->slots[0];\n+\t\tstruct extent_buffer *leaf = path->nodes[0];\n+\t\tconst u16 old_data_len = btrfs_dir_data_len(leaf, di);\n+\t\tconst u32 item_size = btrfs_item_size_nr(leaf, slot);\n+\t\tconst u32 data_size = sizeof(*di) + name_len + size;\n+\t\tstruct btrfs_item *item;\n+\t\tunsigned long data_ptr;\n+\t\tchar *ptr;\n+\n+\t\tif (size > old_data_len) {\n+\t\t\tif (btrfs_leaf_free_space(root, leaf) <\n+\t\t\t    (size - old_data_len)) {\n+\t\t\t\tret = -ENOSPC;\n+\t\t\t\tgoto out;\n+\t\t\t}\n \t\t}\n \n-\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n-\t\tif (ret)\n-\t\t\tgoto out;\n+\t\tif (old_data_len + name_len + sizeof(*di) == item_size) {\n+\t\t\t/* No other xattrs packed in the same leaf item. */\n+\t\t\tif (size > old_data_len)\n+\t\t\t\tbtrfs_extend_item(root, path,\n+\t\t\t\t\t\t  size - old_data_len);\n+\t\t\telse if (size < old_data_len)\n+\t\t\t\tbtrfs_truncate_item(root, path, data_size, 1);\n+\t\t} else {\n+\t\t\t/* There are other xattrs packed in the same item. */\n+\t\t\tret = btrfs_delete_one_dir_name(trans, root, path, di);\n+\t\t\tif (ret)\n+\t\t\t\tgoto out;\n+\t\t\tbtrfs_extend_item(root, path, data_size);\n+\t\t}\n \n+\t\titem = btrfs_item_nr(slot);\n+\t\tptr = btrfs_item_ptr(leaf, slot, char);\n+\t\tptr += btrfs_item_size(leaf, item) - data_size;\n+\t\tdi = (struct btrfs_dir_item *)ptr;\n+\t\tbtrfs_set_dir_data_len(leaf, di, size);\n+\t\tdata_ptr = ((unsigned long)(di + 1)) + name_len;\n+\t\twrite_extent_buffer(leaf, value, data_ptr, size);\n+\t\tbtrfs_mark_buffer_dirty(leaf);\n+\t} else {\n \t\t/*\n-\t\t * We have a value to set, so go back and try to insert it now.\n+\t\t * Insert, and we had space for the xattr, so path->slots[0] is\n+\t\t * where our xattr dir_item is and btrfs_insert_xattr_item()\n+\t\t * filled it.\n \t\t */\n-\t\tif (value) {\n-\t\t\tbtrfs_release_path(path);\n-\t\t\tgoto again;\n-\t\t}\n \t}\n out:\n \tbtrfs_free_path(path);""}","static int key_search(struct extent_buffer *b, struct btrfs_key *key,
		      int level, int *prev_cmp, int *slot)
{
	if (*prev_cmp != 0) {
		*prev_cmp = bin_search(b, key, level, slot);
		return *prev_cmp;
	}

	key_search_validate(b, key, level);
	*slot = 0;

	return 0;
}
","static int key_search(struct extent_buffer *b, struct btrfs_key *key,
		      int level, int *prev_cmp, int *slot)
{
	if (*prev_cmp != 0) {
		*prev_cmp = bin_search(b, key, level, slot);
		return *prev_cmp;
	}

	key_search_validate(b, key, level);
	*slot = 0;

	return 0;
}
",C,,,,"@@ -2939,7 +2939,7 @@ int btrfs_search_slot(struct btrfs_trans_handle *trans, struct btrfs_root
 	 */
 	if (!p->leave_spinning)
 		btrfs_set_path_blocking(p);
-	if (ret < 0)
+	if (ret < 0 && !p->skip_release_on_error)
 		btrfs_release_path(p);
 	return ret;
 }",linux,5f5bc6b1e2d5a6f827bc860ef2dc5b6f365d1339,c7bc6319c59cc791743cf1b6e98f86be69444495,0,"static int key_search(struct extent_buffer *b, struct btrfs_key *key,
		      int level, int *prev_cmp, int *slot)
{
	if (*prev_cmp != 0) {
		*prev_cmp = bin_search(b, key, level, slot);
		return *prev_cmp;
	}

	key_search_validate(b, key, level);
	*slot = 0;

	return 0;
}
"
39199,,Local,Not required,Partial,CVE-2014-2038,https://www.cvedetails.com/cve/CVE-2014-2038/,CWE-20,High,Partial,Partial,,2014-02-28,3.7,"The nfs_can_extend_write function in fs/nfs/write.c in the Linux kernel before 3.13.3 relies on a write delegation to extend a write operation without a certain up-to-date verification, which allows local users to obtain sensitive information from kernel memory in opportunistic circumstances by writing to a file in an NFS filesystem and then reading the same file.",2014-03-16,+Info ,0,https://github.com/torvalds/linux/commit/263b4509ec4d47e0da3e753f85a39ea12d1eff24,263b4509ec4d47e0da3e753f85a39ea12d1eff24,"nfs: always make sure page is up-to-date before extending a write to cover the entire page

We should always make sure the cached page is up-to-date when we're
determining whether we can extend a write to cover the full page -- even
if we've received a write delegation from the server.

Commit c7559663 added logic to skip this check if we have a write
delegation, which can lead to data corruption such as the following
scenario if client B receives a write delegation from the NFS server:

Client A:
    # echo 123456789 > /mnt/file

Client B:
    # echo abcdefghi >> /mnt/file
    # cat /mnt/file
    0�D0�abcdefghi

Just because we hold a write delegation doesn't mean that we've read in
the entire page contents.

Cc: <stable@vger.kernel.org> # v3.11+
Signed-off-by: Scott Mayhew <smayhew@redhat.com>
Signed-off-by: Trond Myklebust <trond.myklebust@primarydata.com>",0,fs/nfs/write.c,"{""sha"": ""a44a87268a6ef640c454600873489cc4e4e1e058"", ""filename"": ""fs/nfs/write.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/torvalds/linux/blob/263b4509ec4d47e0da3e753f85a39ea12d1eff24/fs/nfs/write.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/263b4509ec4d47e0da3e753f85a39ea12d1eff24/fs/nfs/write.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/write.c?ref=263b4509ec4d47e0da3e753f85a39ea12d1eff24"", ""patch"": ""@@ -922,19 +922,20 @@ static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)\n  * extend the write to cover the entire page in order to avoid fragmentation\n  * inefficiencies.\n  *\n- * If the file is opened for synchronous writes or if we have a write delegation\n- * from the server then we can just skip the rest of the checks.\n+ * If the file is opened for synchronous writes then we can just skip the rest\n+ * of the checks.\n  */\n static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n+\tif (!nfs_write_pageuptodate(page, inode))\n+\t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n-\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n-\t\t\t(inode->i_flock->fl_start == 0 &&\n+\tif (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n-\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n+\t\t\tinode->i_flock->fl_type != F_RDLCK))\n \t\treturn 1;\n \treturn 0;\n }""}","int nfs_updatepage(struct file *file, struct page *page,
		unsigned int offset, unsigned int count)
{
	struct nfs_open_context *ctx = nfs_file_open_context(file);
	struct inode	*inode = page_file_mapping(page)->host;
	int		status = 0;

	nfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);

	dprintk(""NFS:       nfs_updatepage(%pD2 %d@%lld)\n"",
		file, count, (long long)(page_file_offset(page) + offset));

	if (nfs_can_extend_write(file, page, inode)) {
		count = max(count + offset, nfs_page_length(page));
		offset = 0;
	}

	status = nfs_writepage_setup(ctx, page, offset, count);
	if (status < 0)
		nfs_set_pageerror(page);
	else
		__set_page_dirty_nobuffers(page);

	dprintk(""NFS:       nfs_updatepage returns %d (isize %lld)\n"",
			status, (long long)i_size_read(inode));
	return status;
}
","int nfs_updatepage(struct file *file, struct page *page,
		unsigned int offset, unsigned int count)
{
	struct nfs_open_context *ctx = nfs_file_open_context(file);
	struct inode	*inode = page_file_mapping(page)->host;
	int		status = 0;

	nfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);

	dprintk(""NFS:       nfs_updatepage(%pD2 %d@%lld)\n"",
		file, count, (long long)(page_file_offset(page) + offset));

	if (nfs_can_extend_write(file, page, inode)) {
		count = max(count + offset, nfs_page_length(page));
		offset = 0;
	}

	status = nfs_writepage_setup(ctx, page, offset, count);
	if (status < 0)
		nfs_set_pageerror(page);
	else
		__set_page_dirty_nobuffers(page);

	dprintk(""NFS:       nfs_updatepage returns %d (isize %lld)\n"",
			status, (long long)i_size_read(inode));
	return status;
}
",C,,,,"@@ -922,19 +922,20 @@ static bool nfs_write_pageuptodate(struct page *page, struct inode *inode)
  * extend the write to cover the entire page in order to avoid fragmentation
  * inefficiencies.
  *
- * If the file is opened for synchronous writes or if we have a write delegation
- * from the server then we can just skip the rest of the checks.
+ * If the file is opened for synchronous writes then we can just skip the rest
+ * of the checks.
  */
 static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)
 {
 	if (file->f_flags & O_DSYNC)
 		return 0;
+	if (!nfs_write_pageuptodate(page, inode))
+		return 0;
 	if (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))
 		return 1;
-	if (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||
-			(inode->i_flock->fl_start == 0 &&
+	if (inode->i_flock == NULL || (inode->i_flock->fl_start == 0 &&
 			inode->i_flock->fl_end == OFFSET_MAX &&
-			inode->i_flock->fl_type != F_RDLCK)))
+			inode->i_flock->fl_type != F_RDLCK))
 		return 1;
 	return 0;
 }",linux,263b4509ec4d47e0da3e753f85a39ea12d1eff24,a9ab5e840669b19aca2974e2c771a77df2876434,0,"int nfs_updatepage(struct file *file, struct page *page,
		unsigned int offset, unsigned int count)
{
	struct nfs_open_context *ctx = nfs_file_open_context(file);
	struct inode	*inode = page_file_mapping(page)->host;
	int		status = 0;

	nfs_inc_stats(inode, NFSIOS_VFSUPDATEPAGE);

	dprintk(""NFS:       nfs_updatepage(%pD2 %d@%lld)\n"",
		file, count, (long long)(page_file_offset(page) + offset));

	if (nfs_can_extend_write(file, page, inode)) {
		count = max(count + offset, nfs_page_length(page));
		offset = 0;
	}

	status = nfs_writepage_setup(ctx, page, offset, count);
	if (status < 0)
		nfs_set_pageerror(page);
	else
		__set_page_dirty_nobuffers(page);

	dprintk(""NFS:       nfs_updatepage returns %d (isize %lld)\n"",
			status, (long long)i_size_read(inode));
	return status;
}
"
107110,,Remote,Not required,Partial,CVE-2011-1800,https://www.cvedetails.com/cve/CVE-2011-1800/,CWE-189,Medium,Partial,Partial,,2011-05-16,6.8,Multiple integer overflows in the SVG Filters implementation in WebCore in WebKit in Google Chrome before 11.0.696.68 allow remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,2017-09-18,DoS Overflow ,0,https://github.com/chromium/chromium/commit/1777aa6484af15014b8691082a8c3075418786f5,1777aa6484af15014b8691082a8c3075418786f5,"[Qt][WK2] Allow transparent WebViews
https://bugs.webkit.org/show_bug.cgi?id=80608

Reviewed by Tor Arne Vestbø.

Added support for transparentBackground in QQuickWebViewExperimental.
This uses the existing drawsTransparentBackground property in WebKit2.
Also, changed LayerTreeHostQt to set the contentsOpaque flag when the root layer changes,
otherwise the change doesn't take effect.

A new API test was added.

* UIProcess/API/qt/qquickwebview.cpp:
(QQuickWebViewPrivate::setTransparentBackground):
(QQuickWebViewPrivate::transparentBackground):
(QQuickWebViewExperimental::transparentBackground):
(QQuickWebViewExperimental::setTransparentBackground):
* UIProcess/API/qt/qquickwebview_p.h:
* UIProcess/API/qt/qquickwebview_p_p.h:
(QQuickWebViewPrivate):
* UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp:
(tst_QQuickWebView):
(tst_QQuickWebView::transparentWebViews):
* WebProcess/WebPage/qt/LayerTreeHostQt.cpp:
(WebKit::LayerTreeHostQt::LayerTreeHostQt):
(WebKit::LayerTreeHostQt::setRootCompositingLayer):


git-svn-id: svn://svn.chromium.org/blink/trunk@110254 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/WebKit2/UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp,"{""sha"": ""a13e871e7061ed9f9c834e7b10f14487b28f51d2"", ""filename"": ""third_party/WebKit/Source/WebKit2/ChangeLog"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 0, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/ChangeLog?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -1,3 +1,32 @@\n+2012-03-08  No'am Rosenthal  <noam.rosenthal@nokia.com>\n+\n+        [Qt][WK2] Allow transparent WebViews\n+        https://bugs.webkit.org/show_bug.cgi?id=80608\n+\n+        Reviewed by Tor Arne Vestb\u00f8.\n+\n+        Added support for transparentBackground in QQuickWebViewExperimental.\n+        This uses the existing drawsTransparentBackground property in WebKit2.\n+        Also, changed LayerTreeHostQt to set the contentsOpaque flag when the root layer changes,\n+        otherwise the change doesn't take effect.\n+\n+        A new API test was added.\n+\n+        * UIProcess/API/qt/qquickwebview.cpp:\n+        (QQuickWebViewPrivate::setTransparentBackground):\n+        (QQuickWebViewPrivate::transparentBackground):\n+        (QQuickWebViewExperimental::transparentBackground):\n+        (QQuickWebViewExperimental::setTransparentBackground):\n+        * UIProcess/API/qt/qquickwebview_p.h:\n+        * UIProcess/API/qt/qquickwebview_p_p.h:\n+        (QQuickWebViewPrivate):\n+        * UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp:\n+        (tst_QQuickWebView):\n+        (tst_QQuickWebView::transparentWebViews):\n+        * WebProcess/WebPage/qt/LayerTreeHostQt.cpp:\n+        (WebKit::LayerTreeHostQt::LayerTreeHostQt):\n+        (WebKit::LayerTreeHostQt::setRootCompositingLayer):\n+\n 2012-03-08  Gustavo Noronha Silva  <gns@gnome.org>\n \n         GTK+ build fix. Only try to get the backing from the layer in when""}<_**next**_>{""sha"": ""a1efba29d42a4d1f3ea90706da97f523d3fdbc65"", ""filename"": ""third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 0, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview.cpp?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -125,6 +125,16 @@ void QQuickWebViewPrivate::initialize(WKContextRef contextRef, WKPageGroupRef pa\n     webPageProxy->initializeWebPage();\n }\n \n+void QQuickWebViewPrivate::setTransparentBackground(bool enable)\n+{\n+    webPageProxy->setDrawsTransparentBackground(enable);\n+}\n+\n+bool QQuickWebViewPrivate::transparentBackground() const\n+{\n+    return webPageProxy->drawsTransparentBackground();\n+}\n+\n void QQuickWebViewPrivate::enableMouseEvents()\n {\n     Q_Q(QQuickWebView);\n@@ -812,6 +822,17 @@ bool QQuickWebViewExperimental::renderToOffscreenBuffer() const\n     return d->renderToOffscreenBuffer();\n }\n \n+bool QQuickWebViewExperimental::transparentBackground() const\n+{\n+    Q_D(const QQuickWebView);\n+    return d->transparentBackground();\n+}\n+void QQuickWebViewExperimental::setTransparentBackground(bool enable)\n+{\n+    Q_D(QQuickWebView);\n+    d->setTransparentBackground(enable);\n+}\n+\n void QQuickWebViewExperimental::setFlickableViewportEnabled(bool enable)\n {\n     s_flickableViewportEnabled = enable;""}<_**next**_>{""sha"": ""5302916ebc436021f667f6fa690f326dba36f17a"", ""filename"": ""third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p.h?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -238,6 +238,7 @@ class QWEBKIT_EXPORT QQuickWebViewExperimental : public QObject {\n     Q_PROPERTY(qreal contentY READ contentY WRITE setContentY NOTIFY contentYChanged)\n     Q_PROPERTY(QQuickItem* contentItem READ contentItem CONSTANT)\n     Q_PROPERTY(QDeclarativeListProperty<QObject> flickableData READ flickableData)\n+    Q_PROPERTY(bool transparentBackground WRITE setTransparentBackground READ transparentBackground)\n \n     Q_PROPERTY(QWebNavigationHistory* navigationHistory READ navigationHistory CONSTANT FINAL)\n     Q_PROPERTY(QDeclarativeComponent* alertDialog READ alertDialog WRITE setAlertDialog NOTIFY alertDialogChanged)\n@@ -299,6 +300,8 @@ class QWEBKIT_EXPORT QQuickWebViewExperimental : public QObject {\n     void setContentX(qreal);\n     qreal contentY() const;\n     void setContentY(qreal);\n+    bool transparentBackground() const;\n+    void setTransparentBackground(bool);\n \n     // C++ only\n     bool renderToOffscreenBuffer() const;""}<_**next**_>{""sha"": ""39a14a7a675bc5d367c226b3e42da99944edb052"", ""filename"": ""third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p_p.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p_p.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p_p.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/qquickwebview_p_p.h?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -112,11 +112,13 @@ class QQuickWebViewPrivate {\n     void execDialogRunner(QtDialogRunner&);\n \n     void setRenderToOffscreenBuffer(bool enable) { m_renderToOffscreenBuffer = enable; }\n+    void setTransparentBackground(bool);\n     void setViewInAttachedProperties(QObject*);\n     void setIcon(const QUrl&);\n \n     bool navigatorQtObjectEnabled() const;\n     bool renderToOffscreenBuffer() const { return m_renderToOffscreenBuffer; }\n+    bool transparentBackground() const;\n     void setNavigatorQtObjectEnabled(bool);\n \n     QRect visibleContentsRect() const;""}<_**next**_>{""sha"": ""2d12219dd0aa6d347155e032098dcb1289f8b9ac"", ""filename"": ""third_party/WebKit/Source/WebKit2/UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 0, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/UIProcess/API/qt/tests/qquickwebview/tst_qquickwebview.cpp?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -55,6 +55,7 @@ private slots:\n     void removeFromCanvas();\n     void multipleWebViewWindows();\n     void multipleWebViews();\n+    void transparentWebViews();\n \n private:\n     void prepareWebViewComponent();\n@@ -343,6 +344,33 @@ void tst_QQuickWebView::multipleWebViews()\n     QTest::qWait(200);\n }\n \n+void tst_QQuickWebView::transparentWebViews()\n+{\n+    showWebView();\n+\n+    // This should not crash.\n+    QScopedPointer<QQuickWebView> webView1(newWebView());\n+    webView1->setParentItem(m_window->rootItem());\n+    QScopedPointer<QQuickWebView> webView2(newWebView());\n+    webView2->setParentItem(m_window->rootItem());\n+    QVERIFY(!webView1->experimental()->transparentBackground());\n+    webView2->experimental()->setTransparentBackground(true);\n+    QVERIFY(webView2->experimental()->transparentBackground());\n+\n+    webView1->setSize(QSizeF(300, 400));\n+    webView1->loadHtml(\""<html><body bgcolor=\\\""red\\\""></body></html>\"");\n+    QVERIFY(waitForLoadSucceeded(webView1.data()));\n+    webView1->setVisible(true);\n+\n+    webView2->setSize(QSizeF(300, 400));\n+    webView2->setUrl(QUrl::fromLocalFile(QLatin1String(TESTS_SOURCE_DIR \""/html/basic_page.html\"")));\n+    QVERIFY(waitForLoadSucceeded(webView2.data()));\n+    webView2->setVisible(true);\n+\n+    QTest::qWait(200);\n+    // FIXME: test actual rendering results; https://bugs.webkit.org/show_bug.cgi?id=80609.\n+}\n+\n void tst_QQuickWebView::scrollRequest()\n {\n     webView()->setSize(QSizeF(300, 400));""}<_**next**_>{""sha"": ""213743003b7f2dcc3304b9019fe7aa7fed829d18"", ""filename"": ""third_party/WebKit/Source/WebKit2/WebProcess/WebPage/qt/LayerTreeHostQt.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/WebProcess/WebPage/qt/LayerTreeHostQt.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1777aa6484af15014b8691082a8c3075418786f5/third_party/WebKit/Source/WebKit2/WebProcess/WebPage/qt/LayerTreeHostQt.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebKit2/WebProcess/WebPage/qt/LayerTreeHostQt.cpp?ref=1777aa6484af15014b8691082a8c3075418786f5"", ""patch"": ""@@ -92,7 +92,6 @@ LayerTreeHostQt::LayerTreeHostQt(WebPage* webPage)\n     m_nonCompositedContentLayer->setName(\""LayerTreeHostQt non-composited content\"");\n #endif\n     m_nonCompositedContentLayer->setDrawsContent(true);\n-    m_nonCompositedContentLayer->setContentsOpaque(m_webPage->drawsBackground() && !m_webPage->drawsTransparentBackground());\n     m_nonCompositedContentLayer->setSize(m_webPage->size());\n \n     m_rootLayer->addChild(m_nonCompositedContentLayer.get());\n@@ -140,6 +139,7 @@ void LayerTreeHostQt::setShouldNotifyAfterNextScheduledLayerFlush(bool notifyAft\n void LayerTreeHostQt::setRootCompositingLayer(WebCore::GraphicsLayer* graphicsLayer)\n {\n     m_nonCompositedContentLayer->removeAllChildren();\n+    m_nonCompositedContentLayer->setContentsOpaque(m_webPage->drawsBackground() && !m_webPage->drawsTransparentBackground());\n \n     // Add the accelerated layer tree hierarchy.\n     if (graphicsLayer)""}","void tst_QQuickWebView::reload()
{
    webView()->setUrl(QUrl::fromLocalFile(QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html"")));
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));

    webView()->reload();
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));
}
","void tst_QQuickWebView::reload()
{
    webView()->setUrl(QUrl::fromLocalFile(QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html"")));
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));

    webView()->reload();
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));
}
",C,,,,"@@ -55,6 +55,7 @@ private slots:
     void removeFromCanvas();
     void multipleWebViewWindows();
     void multipleWebViews();
+    void transparentWebViews();
 
 private:
     void prepareWebViewComponent();
@@ -343,6 +344,33 @@ void tst_QQuickWebView::multipleWebViews()
     QTest::qWait(200);
 }
 
+void tst_QQuickWebView::transparentWebViews()
+{
+    showWebView();
+
+    // This should not crash.
+    QScopedPointer<QQuickWebView> webView1(newWebView());
+    webView1->setParentItem(m_window->rootItem());
+    QScopedPointer<QQuickWebView> webView2(newWebView());
+    webView2->setParentItem(m_window->rootItem());
+    QVERIFY(!webView1->experimental()->transparentBackground());
+    webView2->experimental()->setTransparentBackground(true);
+    QVERIFY(webView2->experimental()->transparentBackground());
+
+    webView1->setSize(QSizeF(300, 400));
+    webView1->loadHtml(""<html><body bgcolor=\""red\""></body></html>"");
+    QVERIFY(waitForLoadSucceeded(webView1.data()));
+    webView1->setVisible(true);
+
+    webView2->setSize(QSizeF(300, 400));
+    webView2->setUrl(QUrl::fromLocalFile(QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html"")));
+    QVERIFY(waitForLoadSucceeded(webView2.data()));
+    webView2->setVisible(true);
+
+    QTest::qWait(200);
+    // FIXME: test actual rendering results; https://bugs.webkit.org/show_bug.cgi?id=80609.
+}
+
 void tst_QQuickWebView::scrollRequest()
 {
     webView()->setSize(QSizeF(300, 400));",Chrome,1777aa6484af15014b8691082a8c3075418786f5,b139ec44e95431d3c04d9af575a0e2a019d02280,0,"void tst_QQuickWebView::reload()
{
    webView()->setUrl(QUrl::fromLocalFile(QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html"")));
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));

    webView()->reload();
    QVERIFY(waitForLoadSucceeded(webView()));

    QCOMPARE(webView()->url().path(), QLatin1String(TESTS_SOURCE_DIR ""/html/basic_page.html""));
}
"
50482,,Local,Not required,Complete,CVE-2016-6787,https://www.cvedetails.com/cve/CVE-2016-6787/,CWE-264,Medium,Complete,Complete,,2016-12-28,6.9,"kernel/events/core.c in the performance subsystem in the Linux kernel before 4.0 mismanages locks during certain migrations, which allows local users to gain privileges via a crafted application, aka Android internal bug 31095224.",2017-11-03,+Priv ,0,https://github.com/torvalds/linux/commit/f63a8daa5812afef4f06c962351687e1ff9ccb2b,f63a8daa5812afef4f06c962351687e1ff9ccb2b,"perf: Fix event->ctx locking

There have been a few reported issues wrt. the lack of locking around
changing event->ctx. This patch tries to address those.

It avoids the whole rwsem thing; and while it appears to work, please
give it some thought in review.

What I did fail at is sensible runtime checks on the use of
event->ctx, the RCU use makes it very hard.

Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Cc: Jiri Olsa <jolsa@redhat.com>
Cc: Arnaldo Carvalho de Melo <acme@kernel.org>
Cc: Linus Torvalds <torvalds@linux-foundation.org>
Link: http://lkml.kernel.org/r/20150123125834.209535886@infradead.org
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,kernel/events/core.c,"{""sha"": ""417a96bf3d417d9f38b4a74079165261d7958265"", ""filename"": ""kernel/events/core.c"", ""status"": ""modified"", ""additions"": 207, ""deletions"": 37, ""changes"": 244, ""blob_url"": ""https://github.com/torvalds/linux/blob/f63a8daa5812afef4f06c962351687e1ff9ccb2b/kernel/events/core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/f63a8daa5812afef4f06c962351687e1ff9ccb2b/kernel/events/core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/events/core.c?ref=f63a8daa5812afef4f06c962351687e1ff9ccb2b"", ""patch"": ""@@ -906,6 +906,77 @@ static void put_ctx(struct perf_event_context *ctx)\n \t}\n }\n \n+/*\n+ * Because of perf_event::ctx migration in sys_perf_event_open::move_group and\n+ * perf_pmu_migrate_context() we need some magic.\n+ *\n+ * Those places that change perf_event::ctx will hold both\n+ * perf_event_ctx::mutex of the 'old' and 'new' ctx value.\n+ *\n+ * Lock ordering is by mutex address. There is one other site where\n+ * perf_event_context::mutex nests and that is put_event(). But remember that\n+ * that is a parent<->child context relation, and migration does not affect\n+ * children, therefore these two orderings should not interact.\n+ *\n+ * The change in perf_event::ctx does not affect children (as claimed above)\n+ * because the sys_perf_event_open() case will install a new event and break\n+ * the ctx parent<->child relation, and perf_pmu_migrate_context() is only\n+ * concerned with cpuctx and that doesn't have children.\n+ *\n+ * The places that change perf_event::ctx will issue:\n+ *\n+ *   perf_remove_from_context();\n+ *   synchronize_rcu();\n+ *   perf_install_in_context();\n+ *\n+ * to affect the change. The remove_from_context() + synchronize_rcu() should\n+ * quiesce the event, after which we can install it in the new location. This\n+ * means that only external vectors (perf_fops, prctl) can perturb the event\n+ * while in transit. Therefore all such accessors should also acquire\n+ * perf_event_context::mutex to serialize against this.\n+ *\n+ * However; because event->ctx can change while we're waiting to acquire\n+ * ctx->mutex we must be careful and use the below perf_event_ctx_lock()\n+ * function.\n+ *\n+ * Lock order:\n+ *\ttask_struct::perf_event_mutex\n+ *\t  perf_event_context::mutex\n+ *\t    perf_event_context::lock\n+ *\t    perf_event::child_mutex;\n+ *\t    perf_event::mmap_mutex\n+ *\t    mmap_sem\n+ */\n+static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+again:\n+\trcu_read_lock();\n+\tctx = ACCESS_ONCE(event->ctx);\n+\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n+\t\trcu_read_unlock();\n+\t\tgoto again;\n+\t}\n+\trcu_read_unlock();\n+\n+\tmutex_lock(&ctx->mutex);\n+\tif (event->ctx != ctx) {\n+\t\tmutex_unlock(&ctx->mutex);\n+\t\tput_ctx(ctx);\n+\t\tgoto again;\n+\t}\n+\n+\treturn ctx;\n+}\n+\n+static void perf_event_ctx_unlock(struct perf_event *event,\n+\t\t\t\t  struct perf_event_context *ctx)\n+{\n+\tmutex_unlock(&ctx->mutex);\n+\tput_ctx(ctx);\n+}\n+\n /*\n  * This must be done under the ctx->lock, such as to serialize against\n  * context_equiv(), therefore we cannot call put_ctx() since that might end up\n@@ -1666,7 +1737,7 @@ int __perf_event_disable(void *info)\n  * is the current context on this CPU and preemption is disabled,\n  * hence we can't get into perf_event_task_sched_out for this context.\n  */\n-void perf_event_disable(struct perf_event *event)\n+static void _perf_event_disable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -1707,6 +1778,19 @@ void perf_event_disable(struct perf_event *event)\n \t}\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+/*\n+ * Strictly speaking kernel users cannot create groups and therefore this\n+ * interface does not need the perf_event_ctx_lock() magic.\n+ */\n+void perf_event_disable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_disable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_disable);\n \n static void perf_set_shadow_time(struct perf_event *event,\n@@ -2170,7 +2254,7 @@ static int __perf_event_enable(void *info)\n  * perf_event_for_each_child or perf_event_for_each as described\n  * for perf_event_disable.\n  */\n-void perf_event_enable(struct perf_event *event)\n+static void _perf_event_enable(struct perf_event *event)\n {\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct task_struct *task = ctx->task;\n@@ -2226,9 +2310,21 @@ void perf_event_enable(struct perf_event *event)\n out:\n \traw_spin_unlock_irq(&ctx->lock);\n }\n+\n+/*\n+ * See perf_event_disable();\n+ */\n+void perf_event_enable(struct perf_event *event)\n+{\n+\tstruct perf_event_context *ctx;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\t_perf_event_enable(event);\n+\tperf_event_ctx_unlock(event, ctx);\n+}\n EXPORT_SYMBOL_GPL(perf_event_enable);\n \n-int perf_event_refresh(struct perf_event *event, int refresh)\n+static int _perf_event_refresh(struct perf_event *event, int refresh)\n {\n \t/*\n \t * not supported on inherited events\n@@ -2237,10 +2333,25 @@ int perf_event_refresh(struct perf_event *event, int refresh)\n \t\treturn -EINVAL;\n \n \tatomic_add(refresh, &event->event_limit);\n-\tperf_event_enable(event);\n+\t_perf_event_enable(event);\n \n \treturn 0;\n }\n+\n+/*\n+ * See perf_event_disable()\n+ */\n+int perf_event_refresh(struct perf_event *event, int refresh)\n+{\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_event_refresh(event, refresh);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n EXPORT_SYMBOL_GPL(perf_event_refresh);\n \n static void ctx_sched_out(struct perf_event_context *ctx,\n@@ -3433,7 +3544,16 @@ static void perf_remove_from_owner(struct perf_event *event)\n \trcu_read_unlock();\n \n \tif (owner) {\n-\t\tmutex_lock(&owner->perf_event_mutex);\n+\t\t/*\n+\t\t * If we're here through perf_event_exit_task() we're already\n+\t\t * holding ctx->mutex which would be an inversion wrt. the\n+\t\t * normal lock order.\n+\t\t *\n+\t\t * However we can safely take this lock because its the child\n+\t\t * ctx->mutex.\n+\t\t */\n+\t\tmutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);\n+\n \t\t/*\n \t\t * We have to re-check the event->owner field, if it is cleared\n \t\t * we raced with perf_event_exit_task(), acquiring the mutex\n@@ -3559,12 +3679,13 @@ static int perf_event_read_group(struct perf_event *event,\n \t\t\t\t   u64 read_format, char __user *buf)\n {\n \tstruct perf_event *leader = event->group_leader, *sub;\n-\tint n = 0, size = 0, ret = -EFAULT;\n \tstruct perf_event_context *ctx = leader->ctx;\n-\tu64 values[5];\n+\tint n = 0, size = 0, ret;\n \tu64 count, enabled, running;\n+\tu64 values[5];\n+\n+\tlockdep_assert_held(&ctx->mutex);\n \n-\tmutex_lock(&ctx->mutex);\n \tcount = perf_event_read_value(leader, &enabled, &running);\n \n \tvalues[n++] = 1 + leader->nr_siblings;\n@@ -3579,7 +3700,7 @@ static int perf_event_read_group(struct perf_event *event,\n \tsize = n * sizeof(u64);\n \n \tif (copy_to_user(buf, values, size))\n-\t\tgoto unlock;\n+\t\treturn -EFAULT;\n \n \tret = size;\n \n@@ -3593,14 +3714,11 @@ static int perf_event_read_group(struct perf_event *event,\n \t\tsize = n * sizeof(u64);\n \n \t\tif (copy_to_user(buf + ret, values, size)) {\n-\t\t\tret = -EFAULT;\n-\t\t\tgoto unlock;\n+\t\t\treturn -EFAULT;\n \t\t}\n \n \t\tret += size;\n \t}\n-unlock:\n-\tmutex_unlock(&ctx->mutex);\n \n \treturn ret;\n }\n@@ -3672,8 +3790,14 @@ static ssize_t\n perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n \tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tint ret;\n \n-\treturn perf_read_hw(event, buf, count);\n+\tctx = perf_event_ctx_lock(event);\n+\tret = perf_read_hw(event, buf, count);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n }\n \n static unsigned int perf_poll(struct file *file, poll_table *wait)\n@@ -3699,7 +3823,7 @@ static unsigned int perf_poll(struct file *file, poll_table *wait)\n \treturn events;\n }\n \n-static void perf_event_reset(struct perf_event *event)\n+static void _perf_event_reset(struct perf_event *event)\n {\n \t(void)perf_event_read(event);\n \tlocal64_set(&event->count, 0);\n@@ -3718,6 +3842,7 @@ static void perf_event_for_each_child(struct perf_event *event,\n \tstruct perf_event *child;\n \n \tWARN_ON_ONCE(event->ctx->parent_ctx);\n+\n \tmutex_lock(&event->child_mutex);\n \tfunc(event);\n \tlist_for_each_entry(child, &event->child_list, child_list)\n@@ -3731,14 +3856,13 @@ static void perf_event_for_each(struct perf_event *event,\n \tstruct perf_event_context *ctx = event->ctx;\n \tstruct perf_event *sibling;\n \n-\tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n+\tlockdep_assert_held(&ctx->mutex);\n+\n \tevent = event->group_leader;\n \n \tperf_event_for_each_child(event, func);\n \tlist_for_each_entry(sibling, &event->sibling_list, group_entry)\n \t\tperf_event_for_each_child(sibling, func);\n-\tmutex_unlock(&ctx->mutex);\n }\n \n static int perf_event_period(struct perf_event *event, u64 __user *arg)\n@@ -3808,25 +3932,24 @@ static int perf_event_set_output(struct perf_event *event,\n \t\t\t\t struct perf_event *output_event);\n static int perf_event_set_filter(struct perf_event *event, void __user *arg);\n \n-static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)\n {\n-\tstruct perf_event *event = file->private_data;\n \tvoid (*func)(struct perf_event *);\n \tu32 flags = arg;\n \n \tswitch (cmd) {\n \tcase PERF_EVENT_IOC_ENABLE:\n-\t\tfunc = perf_event_enable;\n+\t\tfunc = _perf_event_enable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_DISABLE:\n-\t\tfunc = perf_event_disable;\n+\t\tfunc = _perf_event_disable;\n \t\tbreak;\n \tcase PERF_EVENT_IOC_RESET:\n-\t\tfunc = perf_event_reset;\n+\t\tfunc = _perf_event_reset;\n \t\tbreak;\n \n \tcase PERF_EVENT_IOC_REFRESH:\n-\t\treturn perf_event_refresh(event, arg);\n+\t\treturn _perf_event_refresh(event, arg);\n \n \tcase PERF_EVENT_IOC_PERIOD:\n \t\treturn perf_event_period(event, (u64 __user *)arg);\n@@ -3873,6 +3996,19 @@ static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n \treturn 0;\n }\n \n+static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tstruct perf_event *event = file->private_data;\n+\tstruct perf_event_context *ctx;\n+\tlong ret;\n+\n+\tctx = perf_event_ctx_lock(event);\n+\tret = _perf_ioctl(event, cmd, arg);\n+\tperf_event_ctx_unlock(event, ctx);\n+\n+\treturn ret;\n+}\n+\n #ifdef CONFIG_COMPAT\n static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \t\t\t\tunsigned long arg)\n@@ -3895,23 +4031,31 @@ static long perf_compat_ioctl(struct file *file, unsigned int cmd,\n \n int perf_event_task_enable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_enable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_enable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n }\n \n int perf_event_task_disable(void)\n {\n+\tstruct perf_event_context *ctx;\n \tstruct perf_event *event;\n \n \tmutex_lock(&current->perf_event_mutex);\n-\tlist_for_each_entry(event, &current->perf_event_list, owner_entry)\n-\t\tperf_event_for_each_child(event, perf_event_disable);\n+\tlist_for_each_entry(event, &current->perf_event_list, owner_entry) {\n+\t\tctx = perf_event_ctx_lock(event);\n+\t\tperf_event_for_each_child(event, _perf_event_disable);\n+\t\tperf_event_ctx_unlock(event, ctx);\n+\t}\n \tmutex_unlock(&current->perf_event_mutex);\n \n \treturn 0;\n@@ -7269,6 +7413,15 @@ perf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n \treturn ret;\n }\n \n+static void mutex_lock_double(struct mutex *a, struct mutex *b)\n+{\n+\tif (b < a)\n+\t\tswap(a, b);\n+\n+\tmutex_lock(a);\n+\tmutex_lock_nested(b, SINGLE_DEPTH_NESTING);\n+}\n+\n /**\n  * sys_perf_event_open - open a performance event, associate it to a task/cpu\n  *\n@@ -7284,7 +7437,7 @@ SYSCALL_DEFINE5(perf_event_open,\n \tstruct perf_event *group_leader = NULL, *output_event = NULL;\n \tstruct perf_event *event, *sibling;\n \tstruct perf_event_attr attr;\n-\tstruct perf_event_context *ctx;\n+\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n \tstruct file *event_file = NULL;\n \tstruct fd group = {NULL, 0};\n \tstruct task_struct *task = NULL;\n@@ -7482,9 +7635,14 @@ SYSCALL_DEFINE5(perf_event_open,\n \t}\n \n \tif (move_group) {\n-\t\tstruct perf_event_context *gctx = group_leader->ctx;\n+\t\tgctx = group_leader->ctx;\n+\n+\t\t/*\n+\t\t * See perf_event_ctx_lock() for comments on the details\n+\t\t * of swizzling perf_event::ctx.\n+\t\t */\n+\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n \n-\t\tmutex_lock(&gctx->mutex);\n \t\tperf_remove_from_context(group_leader, false);\n \n \t\t/*\n@@ -7499,15 +7657,19 @@ SYSCALL_DEFINE5(perf_event_open,\n \t\t\tperf_event__state_init(sibling);\n \t\t\tput_ctx(gctx);\n \t\t}\n-\t\tmutex_unlock(&gctx->mutex);\n-\t\tput_ctx(gctx);\n+\t} else {\n+\t\tmutex_lock(&ctx->mutex);\n \t}\n \n \tWARN_ON_ONCE(ctx->parent_ctx);\n-\tmutex_lock(&ctx->mutex);\n \n \tif (move_group) {\n+\t\t/*\n+\t\t * Wait for everybody to stop referencing the events through\n+\t\t * the old lists, before installing it on new lists.\n+\t\t */\n \t\tsynchronize_rcu();\n+\n \t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n \t\tget_ctx(ctx);\n \t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n@@ -7519,6 +7681,11 @@ SYSCALL_DEFINE5(perf_event_open,\n \n \tperf_install_in_context(ctx, event, event->cpu);\n \tperf_unpin_context(ctx);\n+\n+\tif (move_group) {\n+\t\tmutex_unlock(&gctx->mutex);\n+\t\tput_ctx(gctx);\n+\t}\n \tmutex_unlock(&ctx->mutex);\n \n \tput_online_cpus();\n@@ -7626,19 +7793,21 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n \tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n \n-\tmutex_lock(&src_ctx->mutex);\n+\t/*\n+\t * See perf_event_ctx_lock() for comments on the details\n+\t * of swizzling perf_event::ctx.\n+\t */\n+\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n \t\t\t\t event_entry) {\n \t\tperf_remove_from_context(event, false);\n \t\tunaccount_event_cpu(event, src_cpu);\n \t\tput_ctx(src_ctx);\n \t\tlist_add(&event->migrate_entry, &events);\n \t}\n-\tmutex_unlock(&src_ctx->mutex);\n \n \tsynchronize_rcu();\n \n-\tmutex_lock(&dst_ctx->mutex);\n \tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n \t\tlist_del(&event->migrate_entry);\n \t\tif (event->state >= PERF_EVENT_STATE_OFF)\n@@ -7648,6 +7817,7 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n \t\tget_ctx(dst_ctx);\n \t}\n \tmutex_unlock(&dst_ctx->mutex);\n+\tmutex_unlock(&src_ctx->mutex);\n }\n EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);\n ""}","static void perf_event_init_cpu(int cpu)
{
	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);

	mutex_lock(&swhash->hlist_mutex);
	swhash->online = true;
	if (swhash->hlist_refcount > 0) {
		struct swevent_hlist *hlist;

		hlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));
		WARN_ON(!hlist);
		rcu_assign_pointer(swhash->swevent_hlist, hlist);
	}
	mutex_unlock(&swhash->hlist_mutex);
}
","static void perf_event_init_cpu(int cpu)
{
	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);

	mutex_lock(&swhash->hlist_mutex);
	swhash->online = true;
	if (swhash->hlist_refcount > 0) {
		struct swevent_hlist *hlist;

		hlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));
		WARN_ON(!hlist);
		rcu_assign_pointer(swhash->swevent_hlist, hlist);
	}
	mutex_unlock(&swhash->hlist_mutex);
}
",C,,,,"@@ -906,6 +906,77 @@ static void put_ctx(struct perf_event_context *ctx)
 	}
 }
 
+/*
+ * Because of perf_event::ctx migration in sys_perf_event_open::move_group and
+ * perf_pmu_migrate_context() we need some magic.
+ *
+ * Those places that change perf_event::ctx will hold both
+ * perf_event_ctx::mutex of the 'old' and 'new' ctx value.
+ *
+ * Lock ordering is by mutex address. There is one other site where
+ * perf_event_context::mutex nests and that is put_event(). But remember that
+ * that is a parent<->child context relation, and migration does not affect
+ * children, therefore these two orderings should not interact.
+ *
+ * The change in perf_event::ctx does not affect children (as claimed above)
+ * because the sys_perf_event_open() case will install a new event and break
+ * the ctx parent<->child relation, and perf_pmu_migrate_context() is only
+ * concerned with cpuctx and that doesn't have children.
+ *
+ * The places that change perf_event::ctx will issue:
+ *
+ *   perf_remove_from_context();
+ *   synchronize_rcu();
+ *   perf_install_in_context();
+ *
+ * to affect the change. The remove_from_context() + synchronize_rcu() should
+ * quiesce the event, after which we can install it in the new location. This
+ * means that only external vectors (perf_fops, prctl) can perturb the event
+ * while in transit. Therefore all such accessors should also acquire
+ * perf_event_context::mutex to serialize against this.
+ *
+ * However; because event->ctx can change while we're waiting to acquire
+ * ctx->mutex we must be careful and use the below perf_event_ctx_lock()
+ * function.
+ *
+ * Lock order:
+ *	task_struct::perf_event_mutex
+ *	  perf_event_context::mutex
+ *	    perf_event_context::lock
+ *	    perf_event::child_mutex;
+ *	    perf_event::mmap_mutex
+ *	    mmap_sem
+ */
+static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)
+{
+	struct perf_event_context *ctx;
+
+again:
+	rcu_read_lock();
+	ctx = ACCESS_ONCE(event->ctx);
+	if (!atomic_inc_not_zero(&ctx->refcount)) {
+		rcu_read_unlock();
+		goto again;
+	}
+	rcu_read_unlock();
+
+	mutex_lock(&ctx->mutex);
+	if (event->ctx != ctx) {
+		mutex_unlock(&ctx->mutex);
+		put_ctx(ctx);
+		goto again;
+	}
+
+	return ctx;
+}
+
+static void perf_event_ctx_unlock(struct perf_event *event,
+				  struct perf_event_context *ctx)
+{
+	mutex_unlock(&ctx->mutex);
+	put_ctx(ctx);
+}
+
 /*
  * This must be done under the ctx->lock, such as to serialize against
  * context_equiv(), therefore we cannot call put_ctx() since that might end up
@@ -1666,7 +1737,7 @@ int __perf_event_disable(void *info)
  * is the current context on this CPU and preemption is disabled,
  * hence we can't get into perf_event_task_sched_out for this context.
  */
-void perf_event_disable(struct perf_event *event)
+static void _perf_event_disable(struct perf_event *event)
 {
 	struct perf_event_context *ctx = event->ctx;
 	struct task_struct *task = ctx->task;
@@ -1707,6 +1778,19 @@ void perf_event_disable(struct perf_event *event)
 	}
 	raw_spin_unlock_irq(&ctx->lock);
 }
+
+/*
+ * Strictly speaking kernel users cannot create groups and therefore this
+ * interface does not need the perf_event_ctx_lock() magic.
+ */
+void perf_event_disable(struct perf_event *event)
+{
+	struct perf_event_context *ctx;
+
+	ctx = perf_event_ctx_lock(event);
+	_perf_event_disable(event);
+	perf_event_ctx_unlock(event, ctx);
+}
 EXPORT_SYMBOL_GPL(perf_event_disable);
 
 static void perf_set_shadow_time(struct perf_event *event,
@@ -2170,7 +2254,7 @@ static int __perf_event_enable(void *info)
  * perf_event_for_each_child or perf_event_for_each as described
  * for perf_event_disable.
  */
-void perf_event_enable(struct perf_event *event)
+static void _perf_event_enable(struct perf_event *event)
 {
 	struct perf_event_context *ctx = event->ctx;
 	struct task_struct *task = ctx->task;
@@ -2226,9 +2310,21 @@ void perf_event_enable(struct perf_event *event)
 out:
 	raw_spin_unlock_irq(&ctx->lock);
 }
+
+/*
+ * See perf_event_disable();
+ */
+void perf_event_enable(struct perf_event *event)
+{
+	struct perf_event_context *ctx;
+
+	ctx = perf_event_ctx_lock(event);
+	_perf_event_enable(event);
+	perf_event_ctx_unlock(event, ctx);
+}
 EXPORT_SYMBOL_GPL(perf_event_enable);
 
-int perf_event_refresh(struct perf_event *event, int refresh)
+static int _perf_event_refresh(struct perf_event *event, int refresh)
 {
 	/*
 	 * not supported on inherited events
@@ -2237,10 +2333,25 @@ int perf_event_refresh(struct perf_event *event, int refresh)
 		return -EINVAL;
 
 	atomic_add(refresh, &event->event_limit);
-	perf_event_enable(event);
+	_perf_event_enable(event);
 
 	return 0;
 }
+
+/*
+ * See perf_event_disable()
+ */
+int perf_event_refresh(struct perf_event *event, int refresh)
+{
+	struct perf_event_context *ctx;
+	int ret;
+
+	ctx = perf_event_ctx_lock(event);
+	ret = _perf_event_refresh(event, refresh);
+	perf_event_ctx_unlock(event, ctx);
+
+	return ret;
+}
 EXPORT_SYMBOL_GPL(perf_event_refresh);
 
 static void ctx_sched_out(struct perf_event_context *ctx,
@@ -3433,7 +3544,16 @@ static void perf_remove_from_owner(struct perf_event *event)
 	rcu_read_unlock();
 
 	if (owner) {
-		mutex_lock(&owner->perf_event_mutex);
+		/*
+		 * If we're here through perf_event_exit_task() we're already
+		 * holding ctx->mutex which would be an inversion wrt. the
+		 * normal lock order.
+		 *
+		 * However we can safely take this lock because its the child
+		 * ctx->mutex.
+		 */
+		mutex_lock_nested(&owner->perf_event_mutex, SINGLE_DEPTH_NESTING);
+
 		/*
 		 * We have to re-check the event->owner field, if it is cleared
 		 * we raced with perf_event_exit_task(), acquiring the mutex
@@ -3559,12 +3679,13 @@ static int perf_event_read_group(struct perf_event *event,
 				   u64 read_format, char __user *buf)
 {
 	struct perf_event *leader = event->group_leader, *sub;
-	int n = 0, size = 0, ret = -EFAULT;
 	struct perf_event_context *ctx = leader->ctx;
-	u64 values[5];
+	int n = 0, size = 0, ret;
 	u64 count, enabled, running;
+	u64 values[5];
+
+	lockdep_assert_held(&ctx->mutex);
 
-	mutex_lock(&ctx->mutex);
 	count = perf_event_read_value(leader, &enabled, &running);
 
 	values[n++] = 1 + leader->nr_siblings;
@@ -3579,7 +3700,7 @@ static int perf_event_read_group(struct perf_event *event,
 	size = n * sizeof(u64);
 
 	if (copy_to_user(buf, values, size))
-		goto unlock;
+		return -EFAULT;
 
 	ret = size;
 
@@ -3593,14 +3714,11 @@ static int perf_event_read_group(struct perf_event *event,
 		size = n * sizeof(u64);
 
 		if (copy_to_user(buf + ret, values, size)) {
-			ret = -EFAULT;
-			goto unlock;
+			return -EFAULT;
 		}
 
 		ret += size;
 	}
-unlock:
-	mutex_unlock(&ctx->mutex);
 
 	return ret;
 }
@@ -3672,8 +3790,14 @@ static ssize_t
 perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
 	struct perf_event *event = file->private_data;
+	struct perf_event_context *ctx;
+	int ret;
 
-	return perf_read_hw(event, buf, count);
+	ctx = perf_event_ctx_lock(event);
+	ret = perf_read_hw(event, buf, count);
+	perf_event_ctx_unlock(event, ctx);
+
+	return ret;
 }
 
 static unsigned int perf_poll(struct file *file, poll_table *wait)
@@ -3699,7 +3823,7 @@ static unsigned int perf_poll(struct file *file, poll_table *wait)
 	return events;
 }
 
-static void perf_event_reset(struct perf_event *event)
+static void _perf_event_reset(struct perf_event *event)
 {
 	(void)perf_event_read(event);
 	local64_set(&event->count, 0);
@@ -3718,6 +3842,7 @@ static void perf_event_for_each_child(struct perf_event *event,
 	struct perf_event *child;
 
 	WARN_ON_ONCE(event->ctx->parent_ctx);
+
 	mutex_lock(&event->child_mutex);
 	func(event);
 	list_for_each_entry(child, &event->child_list, child_list)
@@ -3731,14 +3856,13 @@ static void perf_event_for_each(struct perf_event *event,
 	struct perf_event_context *ctx = event->ctx;
 	struct perf_event *sibling;
 
-	WARN_ON_ONCE(ctx->parent_ctx);
-	mutex_lock(&ctx->mutex);
+	lockdep_assert_held(&ctx->mutex);
+
 	event = event->group_leader;
 
 	perf_event_for_each_child(event, func);
 	list_for_each_entry(sibling, &event->sibling_list, group_entry)
 		perf_event_for_each_child(sibling, func);
-	mutex_unlock(&ctx->mutex);
 }
 
 static int perf_event_period(struct perf_event *event, u64 __user *arg)
@@ -3808,25 +3932,24 @@ static int perf_event_set_output(struct perf_event *event,
 				 struct perf_event *output_event);
 static int perf_event_set_filter(struct perf_event *event, void __user *arg);
 
-static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)
 {
-	struct perf_event *event = file->private_data;
 	void (*func)(struct perf_event *);
 	u32 flags = arg;
 
 	switch (cmd) {
 	case PERF_EVENT_IOC_ENABLE:
-		func = perf_event_enable;
+		func = _perf_event_enable;
 		break;
 	case PERF_EVENT_IOC_DISABLE:
-		func = perf_event_disable;
+		func = _perf_event_disable;
 		break;
 	case PERF_EVENT_IOC_RESET:
-		func = perf_event_reset;
+		func = _perf_event_reset;
 		break;
 
 	case PERF_EVENT_IOC_REFRESH:
-		return perf_event_refresh(event, arg);
+		return _perf_event_refresh(event, arg);
 
 	case PERF_EVENT_IOC_PERIOD:
 		return perf_event_period(event, (u64 __user *)arg);
@@ -3873,6 +3996,19 @@ static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	return 0;
 }
 
+static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct perf_event *event = file->private_data;
+	struct perf_event_context *ctx;
+	long ret;
+
+	ctx = perf_event_ctx_lock(event);
+	ret = _perf_ioctl(event, cmd, arg);
+	perf_event_ctx_unlock(event, ctx);
+
+	return ret;
+}
+
 #ifdef CONFIG_COMPAT
 static long perf_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
@@ -3895,23 +4031,31 @@ static long perf_compat_ioctl(struct file *file, unsigned int cmd,
 
 int perf_event_task_enable(void)
 {
+	struct perf_event_context *ctx;
 	struct perf_event *event;
 
 	mutex_lock(&current->perf_event_mutex);
-	list_for_each_entry(event, &current->perf_event_list, owner_entry)
-		perf_event_for_each_child(event, perf_event_enable);
+	list_for_each_entry(event, &current->perf_event_list, owner_entry) {
+		ctx = perf_event_ctx_lock(event);
+		perf_event_for_each_child(event, _perf_event_enable);
+		perf_event_ctx_unlock(event, ctx);
+	}
 	mutex_unlock(&current->perf_event_mutex);
 
 	return 0;
 }
 
 int perf_event_task_disable(void)
 {
+	struct perf_event_context *ctx;
 	struct perf_event *event;
 
 	mutex_lock(&current->perf_event_mutex);
-	list_for_each_entry(event, &current->perf_event_list, owner_entry)
-		perf_event_for_each_child(event, perf_event_disable);
+	list_for_each_entry(event, &current->perf_event_list, owner_entry) {
+		ctx = perf_event_ctx_lock(event);
+		perf_event_for_each_child(event, _perf_event_disable);
+		perf_event_ctx_unlock(event, ctx);
+	}
 	mutex_unlock(&current->perf_event_mutex);
 
 	return 0;
@@ -7269,6 +7413,15 @@ perf_event_set_output(struct perf_event *event, struct perf_event *output_event)
 	return ret;
 }
 
+static void mutex_lock_double(struct mutex *a, struct mutex *b)
+{
+	if (b < a)
+		swap(a, b);
+
+	mutex_lock(a);
+	mutex_lock_nested(b, SINGLE_DEPTH_NESTING);
+}
+
 /**
  * sys_perf_event_open - open a performance event, associate it to a task/cpu
  *
@@ -7284,7 +7437,7 @@ SYSCALL_DEFINE5(perf_event_open,
 	struct perf_event *group_leader = NULL, *output_event = NULL;
 	struct perf_event *event, *sibling;
 	struct perf_event_attr attr;
-	struct perf_event_context *ctx;
+	struct perf_event_context *ctx, *uninitialized_var(gctx);
 	struct file *event_file = NULL;
 	struct fd group = {NULL, 0};
 	struct task_struct *task = NULL;
@@ -7482,9 +7635,14 @@ SYSCALL_DEFINE5(perf_event_open,
 	}
 
 	if (move_group) {
-		struct perf_event_context *gctx = group_leader->ctx;
+		gctx = group_leader->ctx;
+
+		/*
+		 * See perf_event_ctx_lock() for comments on the details
+		 * of swizzling perf_event::ctx.
+		 */
+		mutex_lock_double(&gctx->mutex, &ctx->mutex);
 
-		mutex_lock(&gctx->mutex);
 		perf_remove_from_context(group_leader, false);
 
 		/*
@@ -7499,15 +7657,19 @@ SYSCALL_DEFINE5(perf_event_open,
 			perf_event__state_init(sibling);
 			put_ctx(gctx);
 		}
-		mutex_unlock(&gctx->mutex);
-		put_ctx(gctx);
+	} else {
+		mutex_lock(&ctx->mutex);
 	}
 
 	WARN_ON_ONCE(ctx->parent_ctx);
-	mutex_lock(&ctx->mutex);
 
 	if (move_group) {
+		/*
+		 * Wait for everybody to stop referencing the events through
+		 * the old lists, before installing it on new lists.
+		 */
 		synchronize_rcu();
+
 		perf_install_in_context(ctx, group_leader, group_leader->cpu);
 		get_ctx(ctx);
 		list_for_each_entry(sibling, &group_leader->sibling_list,
@@ -7519,6 +7681,11 @@ SYSCALL_DEFINE5(perf_event_open,
 
 	perf_install_in_context(ctx, event, event->cpu);
 	perf_unpin_context(ctx);
+
+	if (move_group) {
+		mutex_unlock(&gctx->mutex);
+		put_ctx(gctx);
+	}
 	mutex_unlock(&ctx->mutex);
 
 	put_online_cpus();
@@ -7626,19 +7793,21 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)
 	src_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;
 	dst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;
 
-	mutex_lock(&src_ctx->mutex);
+	/*
+	 * See perf_event_ctx_lock() for comments on the details
+	 * of swizzling perf_event::ctx.
+	 */
+	mutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);
 	list_for_each_entry_safe(event, tmp, &src_ctx->event_list,
 				 event_entry) {
 		perf_remove_from_context(event, false);
 		unaccount_event_cpu(event, src_cpu);
 		put_ctx(src_ctx);
 		list_add(&event->migrate_entry, &events);
 	}
-	mutex_unlock(&src_ctx->mutex);
 
 	synchronize_rcu();
 
-	mutex_lock(&dst_ctx->mutex);
 	list_for_each_entry_safe(event, tmp, &events, migrate_entry) {
 		list_del(&event->migrate_entry);
 		if (event->state >= PERF_EVENT_STATE_OFF)
@@ -7648,6 +7817,7 @@ void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)
 		get_ctx(dst_ctx);
 	}
 	mutex_unlock(&dst_ctx->mutex);
+	mutex_unlock(&src_ctx->mutex);
 }
 EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);
 ",linux,f63a8daa5812afef4f06c962351687e1ff9ccb2b,652884fe0c7bd57f534c5fe68d6def0dc8c4b7ed,0,"static void perf_event_init_cpu(int cpu)
{
	struct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);

	mutex_lock(&swhash->hlist_mutex);
	swhash->online = true;
	if (swhash->hlist_refcount > 0) {
		struct swevent_hlist *hlist;

		hlist = kzalloc_node(sizeof(*hlist), GFP_KERNEL, cpu_to_node(cpu));
		WARN_ON(!hlist);
		rcu_assign_pointer(swhash->swevent_hlist, hlist);
	}
	mutex_unlock(&swhash->hlist_mutex);
}
"
52376,,Local,Not required,Complete,CVE-2016-4997,https://www.cvedetails.com/cve/CVE-2016-4997/,CWE-264,Low,Complete,Complete,,2016-07-03,7.2,The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.,2018-01-04,DoS +Priv Mem. Corr. ,0,https://github.com/torvalds/linux/commit/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,"netfilter: x_tables: check for bogus target offset

We're currently asserting that targetoff + targetsize <= nextoff.

Extend it to also check that targetoff is >= sizeof(xt_entry).
Since this is generic code, add an argument pointing to the start of the
match/target, we can then derive the base structure size from the delta.

We also need the e->elems pointer in a followup change to validate matches.

Signed-off-by: Florian Westphal <fw@strlen.de>
Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",0,net/ipv4/netfilter/arp_tables.c,"{""sha"": ""30cfb1e943fb6309c216f1bee5c39e71000001a4"", ""filename"": ""include/linux/netfilter/x_tables.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/include/linux/netfilter/x_tables.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/include/linux/netfilter/x_tables.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/netfilter/x_tables.h?ref=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"", ""patch"": ""@@ -242,7 +242,7 @@ void xt_unregister_match(struct xt_match *target);\n int xt_register_matches(struct xt_match *match, unsigned int n);\n void xt_unregister_matches(struct xt_match *match, unsigned int n);\n \n-int xt_check_entry_offsets(const void *base,\n+int xt_check_entry_offsets(const void *base, const char *elems,\n \t\t\t   unsigned int target_offset,\n \t\t\t   unsigned int next_offset);\n \n@@ -494,7 +494,7 @@ void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n \t\t\t\tunsigned int *size);\n int xt_compat_target_to_user(const struct xt_entry_target *t,\n \t\t\t     void __user **dstptr, unsigned int *size);\n-int xt_compat_check_entry_offsets(const void *base,\n+int xt_compat_check_entry_offsets(const void *base, const char *elems,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset);\n ""}<_**next**_>{""sha"": ""95ed4e454c605f12aed8c88f174db381aef1e21a"", ""filename"": ""net/ipv4/netfilter/arp_tables.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv4/netfilter/arp_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv4/netfilter/arp_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/arp_tables.c?ref=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"", ""patch"": ""@@ -592,7 +592,8 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n \tif (!arp_checkentry(&e->arp))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1254,7 +1255,7 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n \tif (!arp_checkentry(&e->arp))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e, e->target_offset,\n+\tret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,\n \t\t\t\t\t    e->next_offset);\n \tif (ret)\n \t\treturn ret;""}<_**next**_>{""sha"": ""baab033d74e00cfb8e7ffd2fb6f14f12b2e72d15"", ""filename"": ""net/ipv4/netfilter/ip_tables.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv4/netfilter/ip_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv4/netfilter/ip_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/netfilter/ip_tables.c?ref=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"", ""patch"": ""@@ -754,7 +754,8 @@ check_entry_size_and_hooks(struct ipt_entry *e,\n \tif (!ip_checkentry(&e->ip))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1513,7 +1514,7 @@ check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n \tif (!ip_checkentry(&e->ip))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e,\n+\tret = xt_compat_check_entry_offsets(e, e->elems,\n \t\t\t\t\t    e->target_offset, e->next_offset);\n \tif (ret)\n \t\treturn ret;""}<_**next**_>{""sha"": ""6957627c793119311dc17d8ad6a562678ae59735"", ""filename"": ""net/ipv6/netfilter/ip6_tables.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv6/netfilter/ip6_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/ipv6/netfilter/ip6_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/ip6_tables.c?ref=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"", ""patch"": ""@@ -766,7 +766,8 @@ check_entry_size_and_hooks(struct ip6t_entry *e,\n \tif (!ip6_checkentry(&e->ipv6))\n \t\treturn -EINVAL;\n \n-\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n+\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n+\t\t\t\t     e->next_offset);\n \tif (err)\n \t\treturn err;\n \n@@ -1525,7 +1526,7 @@ check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,\n \tif (!ip6_checkentry(&e->ipv6))\n \t\treturn -EINVAL;\n \n-\tret = xt_compat_check_entry_offsets(e,\n+\tret = xt_compat_check_entry_offsets(e, e->elems,\n \t\t\t\t\t    e->target_offset, e->next_offset);\n \tif (ret)\n \t\treturn ret;""}<_**next**_>{""sha"": ""e2a6f2a9051b73e0a40e74904365019aad50cce2"", ""filename"": ""net/netfilter/x_tables.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 2, ""changes"": 17, ""blob_url"": ""https://github.com/torvalds/linux/blob/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/netfilter/x_tables.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ce683e5f9d045e5d67d1312a42b359cb2ab2a13c/net/netfilter/x_tables.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/netfilter/x_tables.c?ref=ce683e5f9d045e5d67d1312a42b359cb2ab2a13c"", ""patch"": ""@@ -546,14 +546,17 @@ struct compat_xt_standard_target {\n \tcompat_uint_t verdict;\n };\n \n-/* see xt_check_entry_offsets */\n-int xt_compat_check_entry_offsets(const void *base,\n+int xt_compat_check_entry_offsets(const void *base, const char *elems,\n \t\t\t\t  unsigned int target_offset,\n \t\t\t\t  unsigned int next_offset)\n {\n+\tlong size_of_base_struct = elems - (const char *)base;\n \tconst struct compat_xt_entry_target *t;\n \tconst char *e = base;\n \n+\tif (target_offset < size_of_base_struct)\n+\t\treturn -EINVAL;\n+\n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n \n@@ -577,12 +580,16 @@ EXPORT_SYMBOL(xt_compat_check_entry_offsets);\n  * xt_check_entry_offsets - validate arp/ip/ip6t_entry\n  *\n  * @base: pointer to arp/ip/ip6t_entry\n+ * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry->elems\n  * @target_offset: the arp/ip/ip6_t->target_offset\n  * @next_offset: the arp/ip/ip6_t->next_offset\n  *\n  * validates that target_offset and next_offset are sane.\n  * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.\n  *\n+ * This function does not validate the targets or matches themselves, it\n+ * only tests that all the offsets and sizes are correct.\n+ *\n  * The arp/ip/ip6t_entry structure @base must have passed following tests:\n  * - it must point to a valid memory location\n  * - base to base + next_offset must be accessible, i.e. not exceed allocated\n@@ -591,12 +598,18 @@ EXPORT_SYMBOL(xt_compat_check_entry_offsets);\n  * Return: 0 on success, negative errno on failure.\n  */\n int xt_check_entry_offsets(const void *base,\n+\t\t\t   const char *elems,\n \t\t\t   unsigned int target_offset,\n \t\t\t   unsigned int next_offset)\n {\n+\tlong size_of_base_struct = elems - (const char *)base;\n \tconst struct xt_entry_target *t;\n \tconst char *e = base;\n \n+\t/* target start is within the ip/ip6/arpt_entry struct */\n+\tif (target_offset < size_of_base_struct)\n+\t\treturn -EINVAL;\n+\n \tif (target_offset + sizeof(*t) > next_offset)\n \t\treturn -EINVAL;\n ""}","static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;

	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
","static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;

	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
",C,,,,"@@ -592,7 +592,8 @@ static inline int check_entry_size_and_hooks(struct arpt_entry *e,
 	if (!arp_checkentry(&e->arp))
 		return -EINVAL;
 
-	err = xt_check_entry_offsets(e, e->target_offset, e->next_offset);
+	err = xt_check_entry_offsets(e, e->elems, e->target_offset,
+				     e->next_offset);
 	if (err)
 		return err;
 
@@ -1254,7 +1255,7 @@ check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 	if (!arp_checkentry(&e->arp))
 		return -EINVAL;
 
-	ret = xt_compat_check_entry_offsets(e, e->target_offset,
+	ret = xt_compat_check_entry_offsets(e, e->elems, e->target_offset,
 					    e->next_offset);
 	if (ret)
 		return ret;",linux,ce683e5f9d045e5d67d1312a42b359cb2ab2a13c,7ed2abddd20cf8f6bd27f65bd218f26fa5bf7f44,0,"static bool check_underflow(const struct arpt_entry *e)
{
	const struct xt_entry_target *t;
	unsigned int verdict;

	if (!unconditional(e))
		return false;
	t = arpt_get_target_c(e);
	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
"
103000,,Remote,Not required,,CVE-2011-2840,https://www.cvedetails.com/cve/CVE-2011-2840/,CWE-20,Medium,Partial,Partial,,2011-09-19,5.8,Google Chrome before 14.0.835.163 allows user-assisted remote attackers to spoof the URL bar via vectors related to *unusual user interaction.*,2017-09-18,,0,https://github.com/chromium/chromium/commit/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,"chromeos: fix bug where ""aw snap"" page replaces first tab if it was a NTP when closing window with > 1 tab.

BUG=chromium-os:12088
TEST=verify bug per bug report.
Review URL: http://codereview.chromium.org/6882058

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@83031 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/tabs/tab_strip_model.cc,"{""sha"": ""81331e558ee2c3f6309ab69aa0a425d500e4daa4"", ""filename"": ""chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 0, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/tab_closeable_state_watcher.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -85,6 +85,48 @@ bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {\n       (can_close_tab_ || waiting_for_browser_);\n }\n \n+bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,\n+    std::vector<int>* indices) const {\n+  if (signing_off_ || waiting_for_browser_ || tabstrip_watchers_.size() > 1 ||\n+      browser->type() != Browser::TYPE_NORMAL ||\n+      (browser->profile()->IsOffTheRecord() && !guest_session_))\n+    return true;\n+\n+  if (!can_close_tab_) {\n+    indices->clear();\n+    return false;\n+  }\n+\n+  TabStripModel* tabstrip_model = browser->tabstrip_model();\n+  // If we're not closing all tabs, there's no restriction.\n+  if (static_cast<int>(indices->size()) != tabstrip_model->count())\n+    return true;\n+\n+  // If first tab is NTP, it can't be closed.\n+  // In TabStripModel::InternalCloseTabs (which calls\n+  // Browser::CanCloseContents which in turn calls this method), all\n+  // renderer processes of tabs could be terminated before the tabs are actually\n+  // closed.\n+  // As tabs are being closed, notification TabDetachedAt is called.\n+  // When this happens to the last second tab, we would prevent the last NTP\n+  // tab from being closed.\n+  // If we don't prevent this NTP tab from being closed now, its renderer\n+  // process would have been terminated but the tab won't be detached later,\n+  // resulting in the \""Aw, Snap\"" page replacing the first NTP.\n+  // This is the main purpose of this method CanCloseTabs.\n+  for (size_t i = 0; i < indices->size(); ++i) {\n+    if ((*indices)[i] == 0) {\n+      if (tabstrip_model->GetTabContentsAt(0)->tab_contents()->GetURL() ==\n+          GURL(chrome::kChromeUINewTabURL)) {  // First tab is NewTabPage.\n+        indices->erase(indices->begin() + i);  // Don't close it.\n+        return false;\n+      }\n+      break;\n+    }\n+  }\n+  return true;\n+}\n+\n bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {\n   BrowserActionType action_type;\n   bool can_close = CanCloseBrowserImpl(browser, &action_type);""}<_**next**_>{""sha"": ""b1d448f2488eec0afd41d2fe957a9ead276bf596"", ""filename"": ""chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/tab_closeable_state_watcher.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -48,6 +48,8 @@ class TabCloseableStateWatcher : public ::TabCloseableStateWatcher,\n \n   // TabCloseableStateWatcher implementation:\n   virtual bool CanCloseTab(const Browser* browser) const;\n+  virtual bool CanCloseTabs(const Browser* browser,\n+                            std::vector<int>* indices) const;\n   virtual bool CanCloseBrowser(Browser* browser);\n   virtual void OnWindowCloseCanceled(Browser* browser);\n ""}<_**next**_>{""sha"": ""8952542c9aabfceb94760586c9a974ea60d5d7c9"", ""filename"": ""chrome/browser/tab_closeable_state_watcher.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tab_closeable_state_watcher.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -32,6 +32,11 @@ bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {\n   return true;\n }\n \n+bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,\n+    std::vector<int>* indices) const {\n+  return true;\n+}\n+\n bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {\n   return true;\n }""}<_**next**_>{""sha"": ""9325b46ec790e3d778b61ce10b94da319c76c021"", ""filename"": ""chrome/browser/tab_closeable_state_watcher.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tab_closeable_state_watcher.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,11 +1,13 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n #ifndef CHROME_BROWSER_TAB_CLOSEABLE_STATE_WATCHER_H_\n #define CHROME_BROWSER_TAB_CLOSEABLE_STATE_WATCHER_H_\n #pragma once\n \n+#include <vector>\n+\n #include \""base/basictypes.h\""\n \n class Browser;\n@@ -34,6 +36,15 @@ class TabCloseableStateWatcher {\n   // - determining if accelerator keys to close tab should be processed\n   virtual bool CanCloseTab(const Browser* browser) const;\n \n+  // Called from Browser::CanCloseContents which overrides\n+  // TabStripModelDelegate::CanCloseContents, and is called in\n+  // TabStripModel::InternalCloseTabs.\n+  // Returns true if all contents in entire array of |indices| can be closed.\n+  // Returns false if one or more contents can't be closed.\n+  // Indices of contents that cannot be closed will be removed from |indices|.\n+  virtual bool CanCloseTabs(const Browser* browser,\n+                            std::vector<int>* indices) const;\n+\n   // Called from Browser::IsClosingPermitted which is in turn called from\n   // Browser::ShouldCloseWindow to check if |browser| can be closed.\n   virtual bool CanCloseBrowser(Browser* browser);""}<_**next**_>{""sha"": ""b81f0a2839b1d3ba49ec9139baa749bc1fa62582"", ""filename"": ""chrome/browser/tabs/default_tab_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/default_tab_handler.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -95,8 +95,8 @@ bool DefaultTabHandler::RunUnloadListenerBeforeClosing(\n   return delegate_->AsBrowser()->RunUnloadListenerBeforeClosing(contents);\n }\n \n-bool DefaultTabHandler::CanCloseContentsAt(int index) {\n-  return delegate_->AsBrowser()->CanCloseContentsAt(index);\n+bool DefaultTabHandler::CanCloseContents(std::vector<int>* indices) {\n+  return delegate_->AsBrowser()->CanCloseContents(indices);\n }\n \n bool DefaultTabHandler::CanBookmarkAllTabs() const {""}<_**next**_>{""sha"": ""09f779a9c62dc66508abb9d21cb27f2c431be487"", ""filename"": ""chrome/browser/tabs/default_tab_handler.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/default_tab_handler.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -6,6 +6,8 @@\n #define CHROME_BROWSER_TABS_DEFAULT_TAB_HANDLER_H_\n #pragma once\n \n+#include <vector>\n+\n #include \""base/memory/scoped_ptr.h\""\n #include \""chrome/browser/tabs/tab_handler.h\""\n #include \""chrome/browser/tabs/tab_strip_model_delegate.h\""\n@@ -45,7 +47,7 @@ class DefaultTabHandler : public TabHandler,\n   virtual void CloseFrameAfterDragSession();\n   virtual void CreateHistoricalTab(TabContentsWrapper* contents);\n   virtual bool RunUnloadListenerBeforeClosing(TabContentsWrapper* contents);\n-  virtual bool CanCloseContentsAt(int index);\n+  virtual bool CanCloseContents(std::vector<int>* indices);\n   virtual bool CanBookmarkAllTabs() const;\n   virtual void BookmarkAllTabs();\n   virtual bool CanCloseTab() const;""}<_**next**_>{""sha"": ""7acb656c557f26e31cc2c83dd9b1afaec5b7464c"", ""filename"": ""chrome/browser/tabs/tab_strip_model.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 13, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1100,12 +1100,15 @@ bool TabStripModel::IsNewTabAtEndOfTabStrip(\n       contents->controller().entry_count() == 1;\n }\n \n-bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n+bool TabStripModel::InternalCloseTabs(const std::vector<int>& in_indices,\n                                       uint32 close_types) {\n-  if (indices.empty())\n+  if (in_indices.empty())\n     return true;\n \n-  bool retval = true;\n+  std::vector<int> indices(in_indices);\n+  bool retval = delegate_->CanCloseContents(&indices);\n+  if (indices.empty())\n+    return retval;\n \n   // Map the indices to TabContents, that way if deleting a tab deletes other\n   // tabs we're ok. Crashes seem to indicate during tab deletion other tabs are\n@@ -1122,11 +1125,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n     // closing.\n     std::map<RenderProcessHost*, size_t> processes;\n     for (size_t i = 0; i < indices.size(); ++i) {\n-      if (!delegate_->CanCloseContentsAt(indices[i])) {\n-        retval = false;\n-        continue;\n-      }\n-\n       TabContentsWrapper* detached_contents = GetContentsAt(indices[i]);\n       RenderProcessHost* process =\n           detached_contents->tab_contents()->GetRenderProcessHost();\n@@ -1157,11 +1155,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n \n     detached_contents->tab_contents()->OnCloseStarted();\n \n-    if (!delegate_->CanCloseContentsAt(index)) {\n-      retval = false;\n-      continue;\n-    }\n-\n     // Update the explicitly closed state. If the unload handlers cancel the\n     // close the state is reset in Browser. We don't update the explicitly\n     // closed state if already marked as explicitly closed as unload handlers""}<_**next**_>{""sha"": ""f236e5f423dfc33376bf5a7c16a389e10b7ae19d"", ""filename"": ""chrome/browser/tabs/tab_strip_model.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -493,7 +493,8 @@ class TabStripModel : public NotificationObserver {\n   //\n   // Returns true if the TabContents were closed immediately, false if we are\n   // waiting for the result of an onunload handler.\n-  bool InternalCloseTabs(const std::vector<int>& indices, uint32 close_types);\n+  bool InternalCloseTabs(const std::vector<int>& in_indices,\n+                         uint32 close_types);\n \n   // Invoked from InternalCloseTabs and when an extension is removed for an app\n   // tab. Notifies observers of TabClosingAt and deletes |contents|. If""}<_**next**_>{""sha"": ""bae327e3d1474e5011c1e4cf03d83e02215c96b5"", ""filename"": ""chrome/browser/tabs/tab_strip_model_delegate.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model_delegate.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -97,8 +97,10 @@ class TabStripModelDelegate {\n   // Restores the last closed tab if CanRestoreTab would return true.\n   virtual void RestoreTab() = 0;\n \n-  // Returns whether some contents can be closed.\n-  virtual bool CanCloseContentsAt(int index) = 0;\n+  // Returns true if all contents in array of |indices| can be closed.\n+  // Returns false if one or more of the contents can't be closed.\n+  // Indices of contents that cannot be closed will be removed from |indices|.\n+  virtual bool CanCloseContents(std::vector<int>* indices) = 0;\n \n   // Returns true if we should allow \""bookmark all tabs\"" in this window; this is\n   // true when there is more than one bookmarkable tab open.""}<_**next**_>{""sha"": ""4c99a068e15a62e0a257dcfc8b1fc16f65313a92"", ""filename"": ""chrome/browser/tabs/tab_strip_model_unittest.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model_unittest.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -120,7 +120,11 @@ class TabStripDummyDelegate : public TabStripModelDelegate {\n   }\n   virtual bool CanRestoreTab() { return false; }\n   virtual void RestoreTab() {}\n-  virtual bool CanCloseContentsAt(int index) { return can_close_ ; }\n+  virtual bool CanCloseContents(std::vector<int>* indices) {\n+    if (!can_close_)\n+      indices->clear();\n+    return can_close_;\n+  }\n   virtual bool CanBookmarkAllTabs() const { return false; }\n   virtual void BookmarkAllTabs() {}\n   virtual bool CanCloseTab() const { return true; }""}<_**next**_>{""sha"": ""4d1777e99271ace15aef6e9ba0c8fc15b03fccc9"", ""filename"": ""chrome/browser/ui/browser.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 6, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -2635,16 +2635,25 @@ bool Browser::CanReloadContents(TabContents* source) const {\n   return type() != TYPE_DEVTOOLS;\n }\n \n-bool Browser::CanCloseContentsAt(int index) {\n-  if (!CanCloseTab())\n+bool Browser::CanCloseContents(std::vector<int>* indices) {\n+  DCHECK(!indices->empty());\n+  TabCloseableStateWatcher* watcher =\n+      g_browser_process->tab_closeable_state_watcher();\n+  bool can_close_all = !watcher || watcher->CanCloseTabs(this, indices);\n+  if (indices->empty())  // Cannot close any tab.\n     return false;\n-  if (tab_handler_->GetTabStripModel()->count() > 1)\n-    return true;\n-  // We are closing the last tab for this browser. Make sure to check for\n+  // Now, handle cases where at least one tab can be closed.\n+  // If we are closing all the tabs for this browser, make sure to check for\n   // in-progress downloads.\n   // Note that the next call when it returns false will ask the user for\n   // confirmation before closing the browser if the user decides so.\n-  return CanCloseWithInProgressDownloads();\n+  if (tab_handler_->GetTabStripModel()->count() ==\n+          static_cast<int>(indices->size()) &&\n+      !CanCloseWithInProgressDownloads()) {\n+    indices->clear();\n+    can_close_all = false;\n+  }\n+  return can_close_all;\n }\n \n bool Browser::CanBookmarkAllTabs() const {""}<_**next**_>{""sha"": ""51559099ebe21e10565e069abcb923204ef2a308"", ""filename"": ""chrome/browser/ui/browser.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -694,7 +694,7 @@ class Browser : public TabHandlerDelegate,\n   virtual void CloseFrameAfterDragSession();\n   virtual void CreateHistoricalTab(TabContentsWrapper* contents);\n   virtual bool RunUnloadListenerBeforeClosing(TabContentsWrapper* contents);\n-  virtual bool CanCloseContentsAt(int index);\n+  virtual bool CanCloseContents(std::vector<int>* indices);\n   virtual bool CanBookmarkAllTabs() const;\n   virtual void BookmarkAllTabs();\n   virtual bool CanCloseTab() const;""}<_**next**_>{""sha"": ""59c775775e520e8a013d3153b8e97746e171d143"", ""filename"": ""chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -4,6 +4,8 @@\n \n #import <Cocoa/Cocoa.h>\n \n+#include <vector>\n+\n #import \""chrome/browser/ui/browser_window.h\""\n #include \""chrome/browser/ui/cocoa/browser_test_helper.h\""\n #import \""chrome/browser/ui/cocoa/cocoa_test_helper.h\""\n@@ -78,7 +80,7 @@ virtual bool CanRestoreTab() {\n   }\n   virtual void RestoreTab() {}\n \n-  virtual bool CanCloseContentsAt(int index) { return true; }\n+  virtual bool CanCloseContents(std::vector<int>* indices) { return true; }\n \n   virtual bool CanBookmarkAllTabs() const { return false; }\n ""}","void TabStripModel::SelectRelativeTab(bool next) {
  if (contents_data_.empty())
    return;

  int index = active_index();
  int delta = next ? 1 : -1;
  index = (index + count() + delta) % count();
  ActivateTabAt(index, true);
}
","void TabStripModel::SelectRelativeTab(bool next) {
  if (contents_data_.empty())
    return;

  int index = active_index();
  int delta = next ? 1 : -1;
  index = (index + count() + delta) % count();
  ActivateTabAt(index, true);
}
",C,,,,"@@ -1100,12 +1100,15 @@ bool TabStripModel::IsNewTabAtEndOfTabStrip(
       contents->controller().entry_count() == 1;
 }
 
-bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,
+bool TabStripModel::InternalCloseTabs(const std::vector<int>& in_indices,
                                       uint32 close_types) {
-  if (indices.empty())
+  if (in_indices.empty())
     return true;
 
-  bool retval = true;
+  std::vector<int> indices(in_indices);
+  bool retval = delegate_->CanCloseContents(&indices);
+  if (indices.empty())
+    return retval;
 
   // Map the indices to TabContents, that way if deleting a tab deletes other
   // tabs we're ok. Crashes seem to indicate during tab deletion other tabs are
@@ -1122,11 +1125,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,
     // closing.
     std::map<RenderProcessHost*, size_t> processes;
     for (size_t i = 0; i < indices.size(); ++i) {
-      if (!delegate_->CanCloseContentsAt(indices[i])) {
-        retval = false;
-        continue;
-      }
-
       TabContentsWrapper* detached_contents = GetContentsAt(indices[i]);
       RenderProcessHost* process =
           detached_contents->tab_contents()->GetRenderProcessHost();
@@ -1157,11 +1155,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,
 
     detached_contents->tab_contents()->OnCloseStarted();
 
-    if (!delegate_->CanCloseContentsAt(index)) {
-      retval = false;
-      continue;
-    }
-
     // Update the explicitly closed state. If the unload handlers cancel the
     // close the state is reset in Browser. We don't update the explicitly
     // closed state if already marked as explicitly closed as unload handlers",Chrome,2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,5f1d4bfc647a6caf4d9bbc1ba7798a3ccdd4f3c4,0,"void TabStripModel::SelectRelativeTab(bool next) {
  // This may happen during automated testing or if a user somehow buffers
  // many key accelerators.
  if (contents_data_.empty())
    return;

  int index = active_index();
  int delta = next ? 1 : -1;
  index = (index + count() + delta) % count();
  ActivateTabAt(index, true);
}
"
113122,,Remote,Not required,Partial,CVE-2012-2895,https://www.cvedetails.com/cve/CVE-2012-2895/,CWE-119,Medium,Partial,Partial,,2012-09-26,6.8,The PDF functionality in Google Chrome before 22.0.1229.79 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger out-of-bounds write operations.,2017-09-18,DoS Overflow ,0,https://github.com/chromium/chromium/commit/16dcd30c215801941d9890859fd79a234128fc3e,16dcd30c215801941d9890859fd79a234128fc3e,"Refactors to simplify rename pathway in DownloadFileManager.

This is https://chromiumcodereview.appspot.com/10668004 / r144817 (reverted 
due to CrOS failure) with the completion logic moved to after the 
auto-opening.  The tests that test the auto-opening (for web store install) 
were waiting for download completion to check install, and hence were 
failing when completion was moved earlier.  

Doing this right would probably require another state (OPENED).  

BUG=123998
BUG-134930
R=asanka@chromium.org


Review URL: https://chromiumcodereview.appspot.com/10701040

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@145157 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/download/download_item_impl_unittest.cc,"{""sha"": ""37939e1000b4e0bcb423553053e738422d2e9378"", ""filename"": ""chrome/browser/download/chrome_download_manager_delegate.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/chrome/browser/download/chrome_download_manager_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/chrome/browser/download/chrome_download_manager_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/download/chrome_download_manager_delegate.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -793,7 +793,7 @@ void ChromeDownloadManagerDelegate::CheckIfSuggestedPathExists(\n     // Of the 6 categories above for which we overwrite the target, we only\n     // exclude \""Auto (Safe)\"" reliably. \""Prompt (Safe)\"" downloads will be\n     // excluded if the conflicting download has proceeded past\n-    // RenameInProgressDownloadFile.  Ditto for \""Forced\"" downloads. None of the\n+    // the in-progress rename.  Ditto for \""Forced\"" downloads. None of the\n     // \""Dangerous\"" types are excluded.\n     // TODO(asanka): Fix this.\n     int uniquifier =""}<_**next**_>{""sha"": ""f379823852d2f67db940032981d842e9cd03cb61"", ""filename"": ""content/browser/download/download_file_manager.cc"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 106, ""changes"": 135, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_file_manager.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -135,7 +135,8 @@ void DownloadFileManager::CancelDownload(DownloadId global_id) {\n   EraseDownload(global_id);\n }\n \n-void DownloadFileManager::CompleteDownload(DownloadId global_id) {\n+void DownloadFileManager::CompleteDownload(\n+    DownloadId global_id, const base::Closure& callback) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n \n   if (!ContainsKey(downloads_, global_id))\n@@ -147,9 +148,20 @@ void DownloadFileManager::CompleteDownload(DownloadId global_id) {\n            << \"" id = \"" << global_id\n            << \"" download_file = \"" << download_file->DebugString();\n \n+  // Done here on Windows so that anti-virus scanners invoked by\n+  // the attachment service actually see the data; see\n+  // http://crbug.com/127999.\n+  // Done here for mac because we only want to do this once; see\n+  // http://crbug.com/13120 for details.\n+  // Other platforms don't currently do source annotation.\n+  download_file->AnnotateWithSourceInformation();\n+\n   download_file->Detach();\n \n   EraseDownload(global_id);\n+\n+  // Notify our caller we've let it go.\n+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);\n }\n \n void DownloadFileManager::OnDownloadManagerShutdown(DownloadManager* manager) {\n@@ -176,34 +188,22 @@ void DownloadFileManager::OnDownloadManagerShutdown(DownloadManager* manager) {\n \n // Actions from the UI thread and run on the download thread\n \n-// The DownloadManager in the UI thread has provided an intermediate .crdownload\n-// name for the download specified by 'id'. Rename the in progress download.\n-//\n-// There are 2 possible rename cases where this method can be called:\n-// 1. tmp -> foo.crdownload (not final, safe)\n-// 2. tmp-> Unconfirmed.xxx.crdownload (not final, dangerous)\n-// TODO(asanka): Merge with RenameCompletingDownloadFile() and move\n-//               uniquification logic into DownloadFile.\n-void DownloadFileManager::RenameInProgressDownloadFile(\n+void DownloadFileManager::RenameDownloadFile(\n     DownloadId global_id,\n     const FilePath& full_path,\n     bool overwrite_existing_file,\n     const RenameCompletionCallback& callback) {\n-  VLOG(20) << __FUNCTION__ << \""()\"" << \"" id = \"" << global_id\n-           << \"" full_path = \\\""\"" << full_path.value() << \""\\\""\"";\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n-\n   DownloadFile* download_file = GetDownloadFile(global_id);\n   if (!download_file) {\n     BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                             base::Bind(callback, FilePath()));\n     return;\n   }\n \n-  VLOG(20) << __FUNCTION__ << \""()\""\n-           << \"" download_file = \"" << download_file->DebugString();\n   FilePath new_path(full_path);\n   if (!overwrite_existing_file) {\n+    // Make the file unique if requested.\n     int uniquifier =\n         file_util::GetUniquePathNumber(new_path, FILE_PATH_LITERAL(\""\""));\n     if (uniquifier > 0) {\n@@ -212,76 +212,25 @@ void DownloadFileManager::RenameInProgressDownloadFile(\n     }\n   }\n \n+  // Do the actual rename\n   net::Error rename_error = download_file->Rename(new_path);\n   if (net::OK != rename_error) {\n-    CancelDownloadOnRename(global_id, rename_error);\n-    new_path.clear();\n-  }\n-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n-                          base::Bind(callback, new_path));\n-}\n-\n-// The DownloadManager in the UI thread has provided a final name for the\n-// download specified by 'id'. Rename the download that's in the process\n-// of completing.\n-//\n-// There are 2 possible rename cases where this method can be called:\n-// 1. foo.crdownload -> foo (final, safe)\n-// 2. Unconfirmed.xxx.crdownload -> xxx (final, validated)\n-void DownloadFileManager::RenameCompletingDownloadFile(\n-    DownloadId global_id,\n-    const FilePath& full_path,\n-    bool overwrite_existing_file,\n-    const RenameCompletionCallback& callback) {\n-  VLOG(20) << __FUNCTION__ << \""()\"" << \"" id = \"" << global_id\n-           << \"" overwrite_existing_file = \"" << overwrite_existing_file\n-           << \"" full_path = \\\""\"" << full_path.value() << \""\\\""\"";\n-  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n-\n-  DownloadFile* download_file = GetDownloadFile(global_id);\n-  if (!download_file) {\n-    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n-                            base::Bind(callback, FilePath()));\n-    return;\n-  }\n+    DownloadManager* download_manager = download_file->GetDownloadManager();\n+    DCHECK(download_manager);\n+\n+    BrowserThread::PostTask(\n+        BrowserThread::UI, FROM_HERE,\n+        base::Bind(&DownloadManager::OnDownloadInterrupted,\n+                   download_manager,\n+                   global_id.local(),\n+                   download_file->BytesSoFar(),\n+                   download_file->GetHashState(),\n+                   content::ConvertNetErrorToInterruptReason(\n+                       rename_error,\n+                       content::DOWNLOAD_INTERRUPT_FROM_DISK)));\n \n-  VLOG(20) << __FUNCTION__ << \""()\""\n-           << \"" download_file = \"" << download_file->DebugString();\n-\n-  FilePath new_path = full_path;\n-  if (!overwrite_existing_file) {\n-    // Make our name unique at this point, as if a dangerous file is\n-    // downloading and a 2nd download is started for a file with the same\n-    // name, they would have the same path.  This is because we uniquify\n-    // the name on download start, and at that time the first file does\n-    // not exists yet, so the second file gets the same name.\n-    // This should not happen in the SAFE case, and we check for that in the UI\n-    // thread.\n-    int uniquifier =\n-        file_util::GetUniquePathNumber(new_path, FILE_PATH_LITERAL(\""\""));\n-    if (uniquifier > 0) {\n-      new_path = new_path.InsertBeforeExtensionASCII(\n-          StringPrintf(\"" (%d)\"", uniquifier));\n-    }\n-  }\n-\n-  // Rename the file, overwriting if necessary.\n-  net::Error rename_error = download_file->Rename(new_path);\n-  if (net::OK != rename_error) {\n-    // Error. Between the time the UI thread generated 'full_path' to the time\n-    // this code runs, something happened that prevents us from renaming.\n-    CancelDownloadOnRename(global_id, rename_error);\n     new_path.clear();\n-  } else {\n-    // Done here on Windows so that anti-virus scanners invoked by\n-    // the attachment service actually see the data; see\n-    // http://crbug.com/127999.\n-    // Done here for mac because we only want to do this once; see\n-    // http://crbug.com/13120 for details.\n-    // Other platforms don't currently do source annotation.\n-    download_file->AnnotateWithSourceInformation();\n   }\n-\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                           base::Bind(callback, new_path));\n }\n@@ -290,32 +239,6 @@ int DownloadFileManager::NumberOfActiveDownloads() const {\n   return downloads_.size();\n }\n \n-// Called only from RenameInProgressDownloadFile and\n-// RenameCompletingDownloadFile on the FILE thread.\n-// TODO(asanka): Use the RenameCompletionCallback instead of a separate\n-//               OnDownloadInterrupted call.\n-void DownloadFileManager::CancelDownloadOnRename(\n-    DownloadId global_id, net::Error rename_error) {\n-  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n-\n-  DownloadFile* download_file = GetDownloadFile(global_id);\n-  if (!download_file)\n-    return;\n-\n-  DownloadManager* download_manager = download_file->GetDownloadManager();\n-  DCHECK(download_manager);\n-  BrowserThread::PostTask(\n-      BrowserThread::UI, FROM_HERE,\n-      base::Bind(&DownloadManager::OnDownloadInterrupted,\n-                 download_manager,\n-                 global_id.local(),\n-                 download_file->BytesSoFar(),\n-                 download_file->GetHashState(),\n-                 content::ConvertNetErrorToInterruptReason(\n-                     rename_error,\n-                     content::DOWNLOAD_INTERRUPT_FROM_DISK)));\n-}\n-\n void DownloadFileManager::EraseDownload(DownloadId global_id) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n ""}<_**next**_>{""sha"": ""c7409667aa5d47c1e288ef6f97ded0c910c0faa0"", ""filename"": ""content/browser/download/download_file_manager.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 30, ""changes"": 37, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_file_manager.h?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -82,8 +82,7 @@ class CONTENT_EXPORT DownloadFileManager\n   typedef base::Callback<void(content::DownloadInterruptReason reason)>\n       CreateDownloadFileCallback;\n \n-  // Callback used with RenameInProgressDownloadFile() and\n-  // RenameCompletingDownloadFile().\n+  // Callback used with RenameDownloadFile().\n   typedef base::Callback<void(const FilePath&)> RenameCompletionCallback;\n \n   class DownloadFileFactory {\n@@ -120,33 +119,17 @@ class CONTENT_EXPORT DownloadFileManager\n   // download file, as far as the DownloadFileManager is concerned -- if\n   // anything happens to the download file after they are called, it will\n   // be ignored.\n+  // We call back to the UI thread in the case of CompleteDownload so that\n+  // we know when we can hand the file off to other consumers.\n   virtual void CancelDownload(content::DownloadId id);\n-  virtual void CompleteDownload(content::DownloadId id);\n+  virtual void CompleteDownload(content::DownloadId id,\n+                                const base::Closure& callback);\n \n   // Called on FILE thread by DownloadManager at the beginning of its shutdown.\n   virtual void OnDownloadManagerShutdown(content::DownloadManager* manager);\n \n-  // The DownloadManager in the UI thread has provided an intermediate name for\n-  // the download specified by |id|. |overwrite_existing_file| indicates whether\n-  // any existing file at |full_path| should be overwritten. If false, adds a\n-  // uniquifier to |full_path| and uses the resulting name as the intermediate\n-  // path for the download. Invokes |callback| with the new path on success. If\n-  // the rename fails, calls CancelDownloadOnRename() and invokes |callback|\n-  // with an empty FilePath().\n-  virtual void RenameInProgressDownloadFile(\n-      content::DownloadId id,\n-      const FilePath& full_path,\n-      bool overwrite_existing_file,\n-      const RenameCompletionCallback& callback);\n-\n-  // The DownloadManager in the UI thread has provided a final name for the\n-  // download specified by |id|. |overwrite_existing_file| prevents\n-  // uniquification, and is used for SAFE downloads, as the user may have\n-  // decided to overwrite the file.  Sent from the UI thread and run on the FILE\n-  // thread. Invokes |callback| with the new path on success. If the rename\n-  // fails, calls CancelDownloadOnRename() and invokes |callback| with an empty\n-  // FilePath().\n-  virtual void RenameCompletingDownloadFile(\n+  // Rename the download file, uniquifying if overwrite was not requested.\n+  virtual void RenameDownloadFile(\n       content::DownloadId id,\n       const FilePath& full_path,\n       bool overwrite_existing_file,\n@@ -179,12 +162,6 @@ class CONTENT_EXPORT DownloadFileManager\n   // Called only on the download thread.\n   content::DownloadFile* GetDownloadFile(content::DownloadId global_id);\n \n-  // Called only from RenameInProgressDownloadFile and\n-  // RenameCompletingDownloadFile on the FILE thread.\n-  // |rename_error| indicates what error caused the cancel.\n-  void CancelDownloadOnRename(content::DownloadId global_id,\n-                              net::Error rename_error);\n-\n   // Erases the download file with the given the download |id| and removes\n   // it from the maps.\n   void EraseDownload(content::DownloadId global_id);""}<_**next**_>{""sha"": ""7de706ed1a075dcee33a81b2b6ba28fe966084f5"", ""filename"": ""content/browser/download/download_file_manager_unittest.cc"", ""status"": ""modified"", ""additions"": 36, ""deletions"": 19, ""changes"": 55, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_file_manager_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_file_manager_unittest.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -31,6 +31,7 @@ using ::testing::_;\n using ::testing::AtLeast;\n using ::testing::Mock;\n using ::testing::Return;\n+using ::testing::StrictMock;\n using ::testing::StrEq;\n \n namespace {\n@@ -71,7 +72,7 @@ content::DownloadFile* MockDownloadFileFactory::CreateFile(\n     bool calculate_hash,\n     const net::BoundNetLog& bound_net_log) {\n   DCHECK(files_.end() == files_.find(info->download_id));\n-  MockDownloadFile* created_file = new MockDownloadFile();\n+  MockDownloadFile* created_file = new StrictMock<MockDownloadFile>();\n   files_[info->download_id] = created_file;\n \n   ON_CALL(*created_file, GetDownloadManager())\n@@ -104,6 +105,8 @@ content::DownloadManager* MockDownloadRequestHandle::GetDownloadManager()\n   return manager_;\n }\n \n+void NullCallback() { }\n+\n }  // namespace\n \n class DownloadFileManagerTest : public testing::Test {\n@@ -227,23 +230,12 @@ class DownloadFileManagerTest : public testing::Test {\n           .Times(AtLeast(1));\n       EXPECT_CALL(*file, GetDownloadManager())\n           .Times(AtLeast(1));\n-    } else if (state == COMPLETE) {\n-#if defined(OS_MACOSX)\n-      EXPECT_CALL(*file, AnnotateWithSourceInformation());\n-#endif\n     }\n \n-    if (state == IN_PROGRESS) {\n-      download_file_manager_->RenameInProgressDownloadFile(\n-          id, new_path, (should_overwrite == OVERWRITE),\n-          base::Bind(&TestDownloadManager::OnDownloadRenamed,\n-                     download_manager_, id.local()));\n-    } else {  // state == COMPLETE\n-      download_file_manager_->RenameCompletingDownloadFile(\n-          id, new_path, (should_overwrite == OVERWRITE),\n-          base::Bind(&TestDownloadManager::OnDownloadRenamed,\n-                     download_manager_, id.local()));\n-    }\n+    download_file_manager_->RenameDownloadFile(\n+        id, new_path, (should_overwrite == OVERWRITE),\n+        base::Bind(&TestDownloadManager::OnDownloadRenamed,\n+                   download_manager_, id.local()));\n \n     if (rename_error != net::OK) {\n       EXPECT_CALL(*download_manager_,\n@@ -265,6 +257,22 @@ class DownloadFileManagerTest : public testing::Test {\n     }\n   }\n \n+  void Complete(DownloadId id) {\n+    MockDownloadFile* file = download_file_factory_->GetExistingFile(id);\n+    ASSERT_TRUE(file != NULL);\n+\n+    EXPECT_CALL(*file, AnnotateWithSourceInformation())\n+        .WillOnce(Return());\n+    EXPECT_CALL(*file, Detach())\n+        .WillOnce(Return());\n+    int num_downloads = download_file_manager_->NumberOfActiveDownloads();\n+    EXPECT_LT(0, num_downloads);\n+    download_file_manager_->CompleteDownload(id, base::Bind(NullCallback));\n+    EXPECT_EQ(num_downloads - 1,\n+              download_file_manager_->NumberOfActiveDownloads());\n+    EXPECT_EQ(NULL, download_file_manager_->GetDownloadFile(id));\n+  }\n+\n   void CleanUp(DownloadId id) {\n     // Expected calls:\n     //  DownloadFileManager::CancelDownload\n@@ -279,7 +287,7 @@ class DownloadFileManagerTest : public testing::Test {\n \n     download_file_manager_->CancelDownload(id);\n \n-    EXPECT_TRUE(NULL == download_file_manager_->GetDownloadFile(id));\n+    EXPECT_EQ(NULL, download_file_manager_->GetDownloadFile(id));\n   }\n \n  protected:\n@@ -328,6 +336,16 @@ TEST_F(DownloadFileManagerTest, Cancel) {\n   CleanUp(dummy_id);\n }\n \n+TEST_F(DownloadFileManagerTest, Complete) {\n+  scoped_ptr<DownloadCreateInfo> info(new DownloadCreateInfo);\n+  DownloadId dummy_id(download_manager_.get(), kDummyDownloadId);\n+  info->download_id = dummy_id;\n+\n+  CreateDownloadFile(info.Pass());\n+\n+  Complete(dummy_id);\n+}\n+\n TEST_F(DownloadFileManagerTest, RenameInProgress) {\n   scoped_ptr<DownloadCreateInfo> info(new DownloadCreateInfo);\n   DownloadId dummy_id(download_manager_.get(), kDummyDownloadId);\n@@ -388,7 +406,7 @@ TEST_F(DownloadFileManagerTest, RenameWithUniquification) {\n   FilePath foo(download_dir.path().Append(FILE_PATH_LITERAL(\""foo.txt\"")));\n   FilePath unique_foo(foo.InsertBeforeExtension(FILE_PATH_LITERAL(\"" (1)\"")));\n   // Create a file at |foo|. Since we are specifying DONT_OVERWRITE,\n-  // RenameCompletingDownloadFile() should pick \""foo (1).txt\"" instead of\n+  // RenameDownloadFile() should pick \""foo (1).txt\"" instead of\n   // overwriting this file.\n   ASSERT_EQ(0, file_util::WriteFile(foo, \""\"", 0));\n   RenameFile(dummy_id, foo, unique_foo, net::OK, COMPLETE, DONT_OVERWRITE);\n@@ -449,7 +467,6 @@ TEST_F(DownloadFileManagerTest, TwoDownloads) {\n   CleanUp(dummy_id);\n }\n \n-\n // TODO(ahendrickson) -- A test for download manager shutdown.\n // Expected call sequence:\n //  OnDownloadManagerShutdown""}<_**next**_>{""sha"": ""24db071cfc9b489d2d09f1c2561999fb9f534511"", ""filename"": ""content/browser/download/download_item_impl.cc"", ""status"": ""modified"", ""additions"": 48, ""deletions"": 36, ""changes"": 84, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_item_impl.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -427,10 +427,28 @@ void DownloadItemImpl::ProgressComplete(int64 bytes_so_far,\n     total_bytes_ = 0;\n }\n \n+// Updates from the download thread may have been posted while this download\n+// was being cancelled in the UI thread, so we'll accept them unless we're\n+// complete.\n void DownloadItemImpl::UpdateProgress(int64 bytes_so_far,\n+                                      int64 bytes_per_sec,\n                                       const std::string& hash_state) {\n-  hash_state_ = hash_state;\n+  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n \n+  if (!IsInProgress()) {\n+    // Ignore if we're no longer in-progress.  This can happen if we race a\n+    // Cancel on the UI thread with an update on the FILE thread.\n+    //\n+    // TODO(rdsmith): Arguably we should let this go through, as this means\n+    // the download really did get further than we know before it was\n+    // cancelled.  But the gain isn't very large, and the code is more\n+    // fragile if it has to support in progress updates in a non-in-progress\n+    // state.  This issue should be readdressed when we revamp performance\n+    // reporting.\n+    return;\n+  }\n+  bytes_per_sec_ = bytes_per_sec;\n+  hash_state_ = hash_state;\n   received_bytes_ = bytes_so_far;\n \n   // If we've received more data than we were expecting (bad server info?),\n@@ -443,22 +461,7 @@ void DownloadItemImpl::UpdateProgress(int64 bytes_so_far,\n         net::NetLog::TYPE_DOWNLOAD_ITEM_UPDATED,\n         net::NetLog::Int64Callback(\""bytes_so_far\"", received_bytes_));\n   }\n-}\n-\n-// Updates from the download thread may have been posted while this download\n-// was being cancelled in the UI thread, so we'll accept them unless we're\n-// complete.\n-void DownloadItemImpl::UpdateProgress(int64 bytes_so_far,\n-                                      int64 bytes_per_sec,\n-                                      const std::string& hash_state) {\n-  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n \n-  if (!IsInProgress()) {\n-    NOTREACHED();\n-    return;\n-  }\n-  bytes_per_sec_ = bytes_per_sec;\n-  UpdateProgress(bytes_so_far, hash_state);\n   UpdateObservers();\n }\n \n@@ -713,9 +716,8 @@ void DownloadItemImpl::OnDownloadCompleting(DownloadFileManager* file_manager) {\n   DCHECK_NE(DANGEROUS, GetSafetyState());\n   DCHECK(file_manager);\n \n-  // TODO(asanka): Reduce code duplication across the NeedsRename() and\n-  //               !NeedsRename() completion pathways.\n   if (NeedsRename()) {\n+    // Rename the Download file and call back to OnDownloadRenamedToFinalName.\n     bool should_overwrite =\n         (GetTargetDisposition() != DownloadItem::TARGET_DISPOSITION_UNIQUIFY);\n     DownloadFileManager::RenameCompletionCallback callback =\n@@ -724,15 +726,17 @@ void DownloadItemImpl::OnDownloadCompleting(DownloadFileManager* file_manager) {\n                    base::Unretained(file_manager));\n     BrowserThread::PostTask(\n         BrowserThread::FILE, FROM_HERE,\n-        base::Bind(&DownloadFileManager::RenameCompletingDownloadFile,\n+        base::Bind(&DownloadFileManager::RenameDownloadFile,\n                    file_manager, GetGlobalId(), GetTargetFilePath(),\n                    should_overwrite, callback));\n   } else {\n-    Completed();\n+    // Complete the download and release the DownloadFile.\n     BrowserThread::PostTask(\n         BrowserThread::FILE, FROM_HERE,\n         base::Bind(&DownloadFileManager::CompleteDownload,\n-                   file_manager, download_id_));\n+                   file_manager, GetGlobalId(),\n+                   base::Bind(&DownloadItemImpl::OnDownloadFileReleased,\n+                              weak_ptr_factory_.GetWeakPtr())));\n   }\n }\n \n@@ -747,22 +751,30 @@ void DownloadItemImpl::OnDownloadRenamedToFinalName(\n            << \"" \"" << DebugString(false);\n   DCHECK(NeedsRename());\n \n-  if (!full_path.empty()) {\n-    // full_path is now the current and target file path.\n-    target_path_ = full_path;\n-    SetFullPath(full_path);\n-    delegate_->DownloadRenamedToFinalName(this);\n+  if (full_path.empty())\n+    // Indicates error; also reported\n+    // by DownloadManagerImpl::OnDownloadInterrupted.\n+    return;\n \n-    if (delegate_->ShouldOpenDownload(this))\n-      Completed();\n-    else\n-      delegate_delayed_complete_ = true;\n+  // full_path is now the current and target file path.\n+  target_path_ = full_path;\n+  SetFullPath(full_path);\n+  delegate_->DownloadRenamedToFinalName(this);\n \n-    BrowserThread::PostTask(\n-        BrowserThread::FILE, FROM_HERE,\n-        base::Bind(&DownloadFileManager::CompleteDownload,\n-                   file_manager, GetGlobalId()));\n-  }\n+  // Complete the download and release the DownloadFile.\n+  BrowserThread::PostTask(\n+      BrowserThread::FILE, FROM_HERE,\n+      base::Bind(&DownloadFileManager::CompleteDownload,\n+                 file_manager, GetGlobalId(),\n+                 base::Bind(&DownloadItemImpl::OnDownloadFileReleased,\n+                            weak_ptr_factory_.GetWeakPtr())));\n+}\n+\n+void DownloadItemImpl::OnDownloadFileReleased() {\n+  if (delegate_->ShouldOpenDownload(this))\n+    Completed();\n+  else\n+    delegate_delayed_complete_ = true;\n }\n \n void DownloadItemImpl::OnDownloadRenamedToIntermediateName(\n@@ -892,7 +904,7 @@ void DownloadItemImpl::OnIntermediatePathDetermined(\n                  weak_ptr_factory_.GetWeakPtr());\n   BrowserThread::PostTask(\n       BrowserThread::FILE, FROM_HERE,\n-      base::Bind(&DownloadFileManager::RenameInProgressDownloadFile,\n+      base::Bind(&DownloadFileManager::RenameDownloadFile,\n                  file_manager, GetGlobalId(), intermediate_path,\n                  ok_to_overwrite, callback));\n }""}<_**next**_>{""sha"": ""38f7cdcb0f58c8041e10e58e3f2da88c94b29990"", ""filename"": ""content/browser/download/download_item_impl.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 4, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_item_impl.h?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -229,10 +229,6 @@ class CONTENT_EXPORT DownloadItemImpl : public content::DownloadItem {\n   // GetTargetFilePath().\n   bool NeedsRename() const;\n \n-  // Internal helper for maintaining consistent received and total sizes, and\n-  // hash state.\n-  void UpdateProgress(int64 bytes_so_far, const std::string& hash_state);\n-\n   // If all pre-requisites have been met, complete download processing, i.e.  do\n   // internal cleanup, file rename, and potentially auto-open.  (Dangerous\n   // downloads still may block on user acceptance after this point.)\n@@ -265,6 +261,9 @@ class CONTENT_EXPORT DownloadItemImpl : public content::DownloadItem {\n   // name.\n   void OnDownloadRenamedToIntermediateName(const FilePath& full_path);\n \n+  // Callback from file thread when we release the DownloadFile.\n+  void OnDownloadFileReleased();\n+\n   // The handle to the request information.  Used for operations outside the\n   // download system.\n   scoped_ptr<DownloadRequestHandleInterface> request_handle_;""}<_**next**_>{""sha"": ""eb6607bb717a1334ad6bbf542dd305023a6247b3"", ""filename"": ""content/browser/download/download_item_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 15, ""changes"": 38, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_item_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_item_impl_unittest.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -26,6 +26,7 @@ using content::WebContents;\n using ::testing::_;\n using ::testing::AllOf;\n using ::testing::Property;\n+using ::testing::Return;\n \n DownloadId::Domain kValidDownloadItemIdDomain = \""valid DownloadId::Domain\"";\n \n@@ -84,14 +85,10 @@ class MockDownloadFileManager : public DownloadFileManager {\n   MockDownloadFileManager();\n   MOCK_METHOD0(Shutdown, void());\n   MOCK_METHOD1(CancelDownload, void(DownloadId));\n-  MOCK_METHOD1(CompleteDownload, void(DownloadId));\n+  MOCK_METHOD2(CompleteDownload, void(DownloadId, const base::Closure&));\n   MOCK_METHOD1(OnDownloadManagerShutdown, void(DownloadManager*));\n-  MOCK_METHOD4(RenameInProgressDownloadFile,\n-               void(DownloadId, const FilePath&, bool,\n-                    const RenameCompletionCallback&));\n-  MOCK_METHOD4(RenameCompletingDownloadFile,\n-               void(DownloadId, const FilePath&, bool,\n-                    const RenameCompletionCallback&));\n+  MOCK_METHOD4(RenameDownloadFile, void(DownloadId, const FilePath&, bool,\n+                                        const RenameCompletionCallback&));\n   MOCK_CONST_METHOD0(NumberOfActiveDownloads, int());\n  private:\n   ~MockDownloadFileManager() {}\n@@ -101,13 +98,18 @@ class MockDownloadFileManager : public DownloadFileManager {\n // the UI thread. Should only be used as the action for\n // MockDownloadFileManager::Rename*DownloadFile as follows:\n //   EXPECT_CALL(mock_download_file_manager,\n-//               RenameInProgressDownloadFile(_,_,_,_))\n+//               RenameDownloadFile(_,_,_,_))\n //       .WillOnce(ScheduleRenameCallback(new_path));\n ACTION_P(ScheduleRenameCallback, new_path) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                           base::Bind(arg3, new_path));\n }\n \n+// Similarly for scheduling a completion callback.\n+ACTION(ScheduleCompleteCallback) {\n+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, base::Bind(arg1));\n+}\n+\n MockDownloadFileManager::MockDownloadFileManager()\n     : DownloadFileManager(new MockDownloadFileFactory) {\n }\n@@ -372,7 +374,7 @@ TEST_F(DownloadItemTest, NotificationAfterOnContentCheckCompleted) {\n }\n \n // DownloadItemImpl::OnIntermediatePathDetermined will schedule a task to run\n-// DownloadFileManager::RenameInProgressDownloadFile(). Once the rename\n+// DownloadFileManager::RenameDownloadFile(). Once the rename\n // completes, DownloadItemImpl receives a notification with the new file\n // name. Check that observers are updated when the new filename is available and\n // not before.\n@@ -384,7 +386,7 @@ TEST_F(DownloadItemTest, NotificationAfterOnIntermediatePathDetermined) {\n   scoped_refptr<MockDownloadFileManager> file_manager(\n       new MockDownloadFileManager);\n   EXPECT_CALL(*file_manager.get(),\n-              RenameInProgressDownloadFile(_,intermediate_path,false,_))\n+              RenameDownloadFile(_,intermediate_path,false,_))\n       .WillOnce(ScheduleRenameCallback(new_intermediate_path));\n \n   item->OnIntermediatePathDetermined(file_manager.get(), intermediate_path,\n@@ -490,16 +492,16 @@ TEST_F(DownloadItemTest, ExternalData) {\n // download is renamed to the intermediate name.\n // Delegate::DownloadRenamedToFinalName() should be invoked after the final\n // rename.\n-TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {\n+TEST_F(DownloadItemTest, CallbackAfterRename) {\n   DownloadItem* item = CreateDownloadItem(DownloadItem::IN_PROGRESS);\n   FilePath intermediate_path(kDummyPath);\n   FilePath new_intermediate_path(intermediate_path.AppendASCII(\""foo\""));\n   FilePath final_path(intermediate_path.AppendASCII(\""bar\""));\n   scoped_refptr<MockDownloadFileManager> file_manager(\n       new MockDownloadFileManager);\n   EXPECT_CALL(*file_manager.get(),\n-              RenameInProgressDownloadFile(item->GetGlobalId(),\n-                                           intermediate_path, false, _))\n+              RenameDownloadFile(item->GetGlobalId(),\n+                                 intermediate_path, false, _))\n       .WillOnce(ScheduleRenameCallback(new_intermediate_path));\n   // DownloadItemImpl should invoke this callback on the delegate once the\n   // download is renamed to the intermediate name. Also check that GetFullPath()\n@@ -519,11 +521,14 @@ TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {\n   ::testing::Mock::VerifyAndClearExpectations(file_manager.get());\n   ::testing::Mock::VerifyAndClearExpectations(mock_delegate());\n \n+  item->OnAllDataSaved(10, \""\"");\n   EXPECT_CALL(*file_manager.get(),\n-              RenameCompletingDownloadFile(item->GetGlobalId(),\n+              RenameDownloadFile(item->GetGlobalId(),\n                                            final_path, true, _))\n       .WillOnce(ScheduleRenameCallback(final_path));\n-  EXPECT_CALL(*file_manager.get(), CompleteDownload(item->GetGlobalId()));\n+  EXPECT_CALL(*file_manager.get(),\n+              CompleteDownload(item->GetGlobalId(), _))\n+      .WillOnce(ScheduleCompleteCallback());\n   // DownloadItemImpl should invoke this callback on the delegate after the\n   // final rename has completed. Also check that GetFullPath() and\n   // GetTargetFilePath() return the final path at the time of the call.\n@@ -533,6 +538,9 @@ TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {\n                         Property(&DownloadItem::GetFullPath, final_path),\n                         Property(&DownloadItem::GetTargetFilePath,\n                                  final_path))));\n+  EXPECT_CALL(*mock_delegate(), DownloadCompleted(item));\n+  EXPECT_CALL(*mock_delegate(), ShouldOpenDownload(item))\n+      .WillOnce(Return(true));\n   item->OnDownloadCompleting(file_manager.get());\n   RunAllPendingInMessageLoops();\n   ::testing::Mock::VerifyAndClearExpectations(file_manager.get());""}<_**next**_>{""sha"": ""df2a5e7e8e1468d3c2817ccfaf69636780f124e8"", ""filename"": ""content/browser/download/download_manager_impl_unittest.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 11, ""changes"": 17, ""blob_url"": ""https://github.com/chromium/chromium/blob/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_manager_impl_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/16dcd30c215801941d9890859fd79a234128fc3e/content/browser/download/download_manager_impl_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/download/download_manager_impl_unittest.cc?ref=16dcd30c215801941d9890859fd79a234128fc3e"", ""patch"": ""@@ -114,18 +114,13 @@ class MockDownloadFileManager : public DownloadFileManager {\n       const CreateDownloadFileCallback& callback));\n   MOCK_METHOD0(Shutdown, void());\n   MOCK_METHOD1(CancelDownload, void(content::DownloadId));\n-  MOCK_METHOD1(CompleteDownload, void(content::DownloadId));\n+  MOCK_METHOD2(CompleteDownload, void(content::DownloadId,\n+                                      const base::Closure&));\n   MOCK_METHOD1(OnDownloadManagerShutdown, void(content::DownloadManager*));\n-  MOCK_METHOD4(RenameInProgressDownloadFile,\n-               void(content::DownloadId,\n-                    const FilePath&,\n-                    bool,\n-                    const RenameCompletionCallback&));\n-  MOCK_METHOD4(RenameCompletingDownloadFile,\n-               void(content::DownloadId,\n-                    const FilePath&,\n-                    bool,\n-                    const RenameCompletionCallback&));\n+  MOCK_METHOD4(RenameDownloadFile, void(content::DownloadId,\n+                                        const FilePath&,\n+                                        bool,\n+                                        const RenameCompletionCallback&));\n   MOCK_CONST_METHOD0(NumberOfActiveDownloads, int());\n  protected:\n   virtual ~MockDownloadFileManager();""}","  virtual void TearDown() {
    ui_thread_.DeprecatedGetThreadObject()->message_loop()->RunAllPending();
    STLDeleteElements(&allocated_downloads_);
    allocated_downloads_.clear();
  }
","  virtual void TearDown() {
    ui_thread_.DeprecatedGetThreadObject()->message_loop()->RunAllPending();
    STLDeleteElements(&allocated_downloads_);
    allocated_downloads_.clear();
  }
",C,,,,"@@ -26,6 +26,7 @@ using content::WebContents;
 using ::testing::_;
 using ::testing::AllOf;
 using ::testing::Property;
+using ::testing::Return;
 
 DownloadId::Domain kValidDownloadItemIdDomain = ""valid DownloadId::Domain"";
 
@@ -84,14 +85,10 @@ class MockDownloadFileManager : public DownloadFileManager {
   MockDownloadFileManager();
   MOCK_METHOD0(Shutdown, void());
   MOCK_METHOD1(CancelDownload, void(DownloadId));
-  MOCK_METHOD1(CompleteDownload, void(DownloadId));
+  MOCK_METHOD2(CompleteDownload, void(DownloadId, const base::Closure&));
   MOCK_METHOD1(OnDownloadManagerShutdown, void(DownloadManager*));
-  MOCK_METHOD4(RenameInProgressDownloadFile,
-               void(DownloadId, const FilePath&, bool,
-                    const RenameCompletionCallback&));
-  MOCK_METHOD4(RenameCompletingDownloadFile,
-               void(DownloadId, const FilePath&, bool,
-                    const RenameCompletionCallback&));
+  MOCK_METHOD4(RenameDownloadFile, void(DownloadId, const FilePath&, bool,
+                                        const RenameCompletionCallback&));
   MOCK_CONST_METHOD0(NumberOfActiveDownloads, int());
  private:
   ~MockDownloadFileManager() {}
@@ -101,13 +98,18 @@ class MockDownloadFileManager : public DownloadFileManager {
 // the UI thread. Should only be used as the action for
 // MockDownloadFileManager::Rename*DownloadFile as follows:
 //   EXPECT_CALL(mock_download_file_manager,
-//               RenameInProgressDownloadFile(_,_,_,_))
+//               RenameDownloadFile(_,_,_,_))
 //       .WillOnce(ScheduleRenameCallback(new_path));
 ACTION_P(ScheduleRenameCallback, new_path) {
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
                           base::Bind(arg3, new_path));
 }
 
+// Similarly for scheduling a completion callback.
+ACTION(ScheduleCompleteCallback) {
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, base::Bind(arg1));
+}
+
 MockDownloadFileManager::MockDownloadFileManager()
     : DownloadFileManager(new MockDownloadFileFactory) {
 }
@@ -372,7 +374,7 @@ TEST_F(DownloadItemTest, NotificationAfterOnContentCheckCompleted) {
 }
 
 // DownloadItemImpl::OnIntermediatePathDetermined will schedule a task to run
-// DownloadFileManager::RenameInProgressDownloadFile(). Once the rename
+// DownloadFileManager::RenameDownloadFile(). Once the rename
 // completes, DownloadItemImpl receives a notification with the new file
 // name. Check that observers are updated when the new filename is available and
 // not before.
@@ -384,7 +386,7 @@ TEST_F(DownloadItemTest, NotificationAfterOnIntermediatePathDetermined) {
   scoped_refptr<MockDownloadFileManager> file_manager(
       new MockDownloadFileManager);
   EXPECT_CALL(*file_manager.get(),
-              RenameInProgressDownloadFile(_,intermediate_path,false,_))
+              RenameDownloadFile(_,intermediate_path,false,_))
       .WillOnce(ScheduleRenameCallback(new_intermediate_path));
 
   item->OnIntermediatePathDetermined(file_manager.get(), intermediate_path,
@@ -490,16 +492,16 @@ TEST_F(DownloadItemTest, ExternalData) {
 // download is renamed to the intermediate name.
 // Delegate::DownloadRenamedToFinalName() should be invoked after the final
 // rename.
-TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {
+TEST_F(DownloadItemTest, CallbackAfterRename) {
   DownloadItem* item = CreateDownloadItem(DownloadItem::IN_PROGRESS);
   FilePath intermediate_path(kDummyPath);
   FilePath new_intermediate_path(intermediate_path.AppendASCII(""foo""));
   FilePath final_path(intermediate_path.AppendASCII(""bar""));
   scoped_refptr<MockDownloadFileManager> file_manager(
       new MockDownloadFileManager);
   EXPECT_CALL(*file_manager.get(),
-              RenameInProgressDownloadFile(item->GetGlobalId(),
-                                           intermediate_path, false, _))
+              RenameDownloadFile(item->GetGlobalId(),
+                                 intermediate_path, false, _))
       .WillOnce(ScheduleRenameCallback(new_intermediate_path));
   // DownloadItemImpl should invoke this callback on the delegate once the
   // download is renamed to the intermediate name. Also check that GetFullPath()
@@ -519,11 +521,14 @@ TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {
   ::testing::Mock::VerifyAndClearExpectations(file_manager.get());
   ::testing::Mock::VerifyAndClearExpectations(mock_delegate());
 
+  item->OnAllDataSaved(10, """");
   EXPECT_CALL(*file_manager.get(),
-              RenameCompletingDownloadFile(item->GetGlobalId(),
+              RenameDownloadFile(item->GetGlobalId(),
                                            final_path, true, _))
       .WillOnce(ScheduleRenameCallback(final_path));
-  EXPECT_CALL(*file_manager.get(), CompleteDownload(item->GetGlobalId()));
+  EXPECT_CALL(*file_manager.get(),
+              CompleteDownload(item->GetGlobalId(), _))
+      .WillOnce(ScheduleCompleteCallback());
   // DownloadItemImpl should invoke this callback on the delegate after the
   // final rename has completed. Also check that GetFullPath() and
   // GetTargetFilePath() return the final path at the time of the call.
@@ -533,6 +538,9 @@ TEST_F(DownloadItemTest, CallbackAfterRenameToIntermediateName) {
                         Property(&DownloadItem::GetFullPath, final_path),
                         Property(&DownloadItem::GetTargetFilePath,
                                  final_path))));
+  EXPECT_CALL(*mock_delegate(), DownloadCompleted(item));
+  EXPECT_CALL(*mock_delegate(), ShouldOpenDownload(item))
+      .WillOnce(Return(true));
   item->OnDownloadCompleting(file_manager.get());
   RunAllPendingInMessageLoops();
   ::testing::Mock::VerifyAndClearExpectations(file_manager.get());",Chrome,16dcd30c215801941d9890859fd79a234128fc3e,6e1fcd11156df08179d7d93c162c971d2bc79820,0,"  virtual void TearDown() {
    ui_thread_.DeprecatedGetThreadObject()->message_loop()->RunAllPending();
    STLDeleteElements(&allocated_downloads_);
    allocated_downloads_.clear();
  }
"
19622,,Remote,Not required,Complete,CVE-2012-2744,https://www.cvedetails.com/cve/CVE-2012-2744/,,Low,,,,2012-08-09,7.8,"net/ipv6/netfilter/nf_conntrack_reasm.c in the Linux kernel before 2.6.34, when the nf_conntrack_ipv6 module is enabled, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via certain types of fragmented IPv6 packets.",2013-03-21,DoS ,0,https://github.com/torvalds/linux/commit/9e2dcf72023d1447f09c47d77c99b0c49659e5ce,9e2dcf72023d1447f09c47d77c99b0c49659e5ce,"netfilter: nf_conntrack_reasm: properly handle packets fragmented into a single fragment

When an ICMPV6_PKT_TOOBIG message is received with a MTU below 1280,
all further packets include a fragment header.

Unlike regular defragmentation, conntrack also needs to ""reassemble""
those fragments in order to obtain a packet without the fragment
header for connection tracking. Currently nf_conntrack_reasm checks
whether a fragment has either IP6_MF set or an offset != 0, which
makes it ignore those fragments.

Remove the invalid check and make reassembly handle fragment queues
containing only a single fragment.

Reported-and-tested-by: Ulrich Weber <uweber@astaro.com>
Signed-off-by: Patrick McHardy <kaber@trash.net>",0,net/ipv6/netfilter/nf_conntrack_reasm.c,"{""sha"": ""f1171b744650e07f1e979a9575e5792ebaa10a9b"", ""filename"": ""net/ipv6/netfilter/nf_conntrack_reasm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 7, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/9e2dcf72023d1447f09c47d77c99b0c49659e5ce/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/9e2dcf72023d1447f09c47d77c99b0c49659e5ce/net/ipv6/netfilter/nf_conntrack_reasm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv6/netfilter/nf_conntrack_reasm.c?ref=9e2dcf72023d1447f09c47d77c99b0c49659e5ce"", ""patch"": ""@@ -469,7 +469,7 @@ nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)\n \n \t/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */\n \tfp = skb_shinfo(head)->frag_list;\n-\tif (NFCT_FRAG6_CB(fp)->orig == NULL)\n+\tif (fp && NFCT_FRAG6_CB(fp)->orig == NULL)\n \t\t/* at above code, head skb is divided into two skbs. */\n \t\tfp = fp->next;\n \n@@ -595,12 +595,6 @@ struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)\n \thdr = ipv6_hdr(clone);\n \tfhdr = (struct frag_hdr *)skb_transport_header(clone);\n \n-\tif (!(fhdr->frag_off & htons(0xFFF9))) {\n-\t\tpr_debug(\""Invalid fragment offset\\n\"");\n-\t\t/* It is not a fragmented frame */\n-\t\tgoto ret_orig;\n-\t}\n-\n \tif (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)\n \t\tnf_ct_frag6_evictor();\n ""}","fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)
{
	struct inet_frag_queue *q;
	struct ip6_create_arg arg;
	unsigned int hash;

	arg.id = id;
	arg.user = user;
	arg.src = src;
	arg.dst = dst;

	read_lock_bh(&nf_frags.lock);
	hash = inet6_hash_frag(id, src, dst, nf_frags.rnd);

	q = inet_frag_find(&nf_init_frags, &nf_frags, &arg, hash);
	local_bh_enable();
	if (q == NULL)
		goto oom;

	return container_of(q, struct nf_ct_frag6_queue, q);

oom:
	pr_debug(""Can't alloc new queue\n"");
	return NULL;
}
","fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)
{
	struct inet_frag_queue *q;
	struct ip6_create_arg arg;
	unsigned int hash;

	arg.id = id;
	arg.user = user;
	arg.src = src;
	arg.dst = dst;

	read_lock_bh(&nf_frags.lock);
	hash = inet6_hash_frag(id, src, dst, nf_frags.rnd);

	q = inet_frag_find(&nf_init_frags, &nf_frags, &arg, hash);
	local_bh_enable();
	if (q == NULL)
		goto oom;

	return container_of(q, struct nf_ct_frag6_queue, q);

oom:
	pr_debug(""Can't alloc new queue\n"");
	return NULL;
}
",C,,,,"@@ -469,7 +469,7 @@ nf_ct_frag6_reasm(struct nf_ct_frag6_queue *fq, struct net_device *dev)
 
 	/* all original skbs are linked into the NFCT_FRAG6_CB(head).orig */
 	fp = skb_shinfo(head)->frag_list;
-	if (NFCT_FRAG6_CB(fp)->orig == NULL)
+	if (fp && NFCT_FRAG6_CB(fp)->orig == NULL)
 		/* at above code, head skb is divided into two skbs. */
 		fp = fp->next;
 
@@ -595,12 +595,6 @@ struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)
 	hdr = ipv6_hdr(clone);
 	fhdr = (struct frag_hdr *)skb_transport_header(clone);
 
-	if (!(fhdr->frag_off & htons(0xFFF9))) {
-		pr_debug(""Invalid fragment offset\n"");
-		/* It is not a fragmented frame */
-		goto ret_orig;
-	}
-
 	if (atomic_read(&nf_init_frags.mem) > nf_init_frags.high_thresh)
 		nf_ct_frag6_evictor();
 ",linux,9e2dcf72023d1447f09c47d77c99b0c49659e5ce,64507fdbc29c3a622180378210ecea8659b14e40,0,"fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)
{
	struct inet_frag_queue *q;
	struct ip6_create_arg arg;
	unsigned int hash;

	arg.id = id;
	arg.user = user;
	arg.src = src;
	arg.dst = dst;

	read_lock_bh(&nf_frags.lock);
	hash = inet6_hash_frag(id, src, dst, nf_frags.rnd);

	q = inet_frag_find(&nf_init_frags, &nf_frags, &arg, hash);
	local_bh_enable();
	if (q == NULL)
		goto oom;

	return container_of(q, struct nf_ct_frag6_queue, q);

oom:
	pr_debug(""Can't alloc new queue\n"");
	return NULL;
}
"
178611,,Remote,Not required,Partial,CVE-2017-12183,https://www.cvedetails.com/cve/CVE-2017-12183/,CWE-20,Low,Partial,Partial,,2018-01-24,7.5,xorg-x11-server before 1.19.5 was missing length validation in XFIXES extension allowing malicious X client to cause X server to crash or possibly execute arbitrary code.,2019-10-09,Exec Code,1,https://cgit.freedesktop.org/xorg/xserver/commit/?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,55caa8b08c84af2b50fbc936cf334a5a93dd7db5,,1,,,"ProcXFixesSetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;

    REQUEST(xXFixesSetCursorNameReq);
     REQUEST(xXFixesSetCursorNameReq);
     Atom atom;
 
    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, TRUE);
        return BadAlloc;

    pCursor->name = atom;
    return Success;
}
","ProcXFixesSetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;

    REQUEST(xXFixesSetCursorNameReq);
     REQUEST(xXFixesSetCursorNameReq);
     Atom atom;
 
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, TRUE);
        return BadAlloc;

    pCursor->name = atom;
    return Success;
}
",C,"    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
","    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
",cad5a1050b7184d828aef9c1dd151c3ab649d37e,"@@ -281,6 +281,7 @@ int _X_COLD
 SProcXFixesSelectCursorInput(ClientPtr client)
 {
     REQUEST(xXFixesSelectCursorInputReq);
+    REQUEST_SIZE_MATCH(xXFixesSelectCursorInputReq);
 
     swaps(&stuff->length);
     swapl(&stuff->window);
@@ -414,7 +415,7 @@ ProcXFixesSetCursorName(ClientPtr client)
     REQUEST(xXFixesSetCursorNameReq);
     Atom atom;
 
-    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
+    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, TRUE);
@@ -1007,6 +1008,8 @@ SProcXFixesCreatePointerBarrier(ClientPtr client)
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
 
+    REQUEST_AT_LEAST_SIZE(xXFixesCreatePointerBarrierReq);
+
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));",xserver,https://cgit.freedesktop.org/xorg/xserver/tree/xfixes/cursor.c?id=55caa8b08c84af2b50fbc936cf334a5a93dd7db5,https://cgit.freedesktop.org/xorg/xserver/tree/xfixes/cursor.c?id=cad5a1050b7184d828aef9c1dd151c3ab649d37e,1,"ProcXFixesSetCursorName(ClientPtr client)
{
    CursorPtr pCursor;
    char *tchar;

    REQUEST(xXFixesSetCursorNameReq);
     REQUEST(xXFixesSetCursorNameReq);
     Atom atom;
 
//flaw_line_below:
    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);
//fix_flaw_line_below:
//    REQUEST_FIXED_SIZE(xXFixesSetCursorNameReq, stuff->nbytes);
     VERIFY_CURSOR(pCursor, stuff->cursor, client, DixSetAttrAccess);
     tchar = (char *) &stuff[1];
     atom = MakeAtom(tchar, stuff->nbytes, TRUE);
        return BadAlloc;

    pCursor->name = atom;
    return Success;
}
"
70579,,Remote,Not required,Partial,CVE-2016-10197,https://www.cvedetails.com/cve/CVE-2016-10197/,CWE-125,Low,,,,2017-03-15,5.0,The search_make_new function in evdns.c in libevent before 2.1.6-beta allows attackers to cause a denial of service (out-of-bounds read) via an empty hostname.,2018-01-04,DoS ,0,https://github.com/libevent/libevent/commit/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,"evdns: fix searching empty hostnames

From #332:
  Here follows a bug report by **Guido Vranken** via the _Tor bug bounty program_. Please credit Guido accordingly.

  ## Bug report

  The DNS code of Libevent contains this rather obvious OOB read:

  ```c
  static char *
  search_make_new(const struct search_state *const state, int n, const char *const base_name) {
      const size_t base_len = strlen(base_name);
      const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
  ```

  If the length of ```base_name``` is 0, then line 3125 reads 1 byte before the buffer. This will trigger a crash on ASAN-protected builds.

  To reproduce:

  Build libevent with ASAN:
  ```
  $ CFLAGS='-fomit-frame-pointer -fsanitize=address' ./configure && make -j4
  ```
  Put the attached ```resolv.conf``` and ```poc.c``` in the source directory and then do:

  ```
  $ gcc -fsanitize=address -fomit-frame-pointer poc.c .libs/libevent.a
  $ ./a.out
  =================================================================
  ==22201== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60060000efdf at pc 0x4429da bp 0x7ffe1ed47300 sp 0x7ffe1ed472f8
  READ of size 1 at 0x60060000efdf thread T0
  ```

P.S. we can add a check earlier, but since this is very uncommon, I didn't add it.

Fixes: #332",0,evdns.c,"{""sha"": ""e9dbc35c60662ccda395d21d95997193840b4b57"", ""filename"": ""evdns.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/libevent/libevent/blob/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e/evdns.c"", ""raw_url"": ""https://github.com/libevent/libevent/raw/ec65c42052d95d2c23d1d837136d1cf1d9ecef9e/evdns.c"", ""contents_url"": ""https://api.github.com/repos/libevent/libevent/contents/evdns.c?ref=ec65c42052d95d2c23d1d837136d1cf1d9ecef9e"", ""patch"": ""@@ -3175,9 +3175,12 @@ search_set_from_hostname(struct evdns_base *base) {\n static char *\n search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n \tconst size_t base_len = strlen(base_name);\n-\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n+\tchar need_to_append_dot;\n \tstruct search_domain *dom;\n \n+\tif (!base_len) return NULL;\n+\tneed_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n+\n \tfor (dom = state->head; dom; dom = dom->next) {\n \t\tif (!n--) {\n \t\t\t/* this is the postfix we want */""}","evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)
{
	struct nameserver *server, *server_next;
	struct search_domain *dom, *dom_next;
	int i;

	/* Requires that we hold the lock. */

	/* TODO(nickm) we might need to refcount here. */

	for (i = 0; i < base->n_req_heads; ++i) {
		while (base->req_heads[i]) {
			if (fail_requests)
				reply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);
			request_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);
		}
	}
	while (base->req_waiting_head) {
		if (fail_requests)
			reply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);
		request_finished(base->req_waiting_head, &base->req_waiting_head, 1);
	}
	base->global_requests_inflight = base->global_requests_waiting = 0;

	for (server = base->server_head; server; server = server_next) {
		server_next = server->next;
		/** already done something before */
		server->probe_request = NULL;
		evdns_nameserver_free(server);
		if (server_next == base->server_head)
			break;
	}
	base->server_head = NULL;
	base->global_good_nameservers = 0;

	if (base->global_search_state) {
		for (dom = base->global_search_state->head; dom; dom = dom_next) {
			dom_next = dom->next;
			mm_free(dom);
		}
		mm_free(base->global_search_state);
		base->global_search_state = NULL;
	}

	{
		struct hosts_entry *victim;
		while ((victim = TAILQ_FIRST(&base->hostsdb))) {
			TAILQ_REMOVE(&base->hostsdb, victim, next);
			mm_free(victim);
		}
	}

	mm_free(base->req_heads);

	EVDNS_UNLOCK(base);
	EVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);

	mm_free(base);
}
","evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)
{
	struct nameserver *server, *server_next;
	struct search_domain *dom, *dom_next;
	int i;

	/* Requires that we hold the lock. */

	/* TODO(nickm) we might need to refcount here. */

	for (i = 0; i < base->n_req_heads; ++i) {
		while (base->req_heads[i]) {
			if (fail_requests)
				reply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);
			request_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);
		}
	}
	while (base->req_waiting_head) {
		if (fail_requests)
			reply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);
		request_finished(base->req_waiting_head, &base->req_waiting_head, 1);
	}
	base->global_requests_inflight = base->global_requests_waiting = 0;

	for (server = base->server_head; server; server = server_next) {
		server_next = server->next;
		/** already done something before */
		server->probe_request = NULL;
		evdns_nameserver_free(server);
		if (server_next == base->server_head)
			break;
	}
	base->server_head = NULL;
	base->global_good_nameservers = 0;

	if (base->global_search_state) {
		for (dom = base->global_search_state->head; dom; dom = dom_next) {
			dom_next = dom->next;
			mm_free(dom);
		}
		mm_free(base->global_search_state);
		base->global_search_state = NULL;
	}

	{
		struct hosts_entry *victim;
		while ((victim = TAILQ_FIRST(&base->hostsdb))) {
			TAILQ_REMOVE(&base->hostsdb, victim, next);
			mm_free(victim);
		}
	}

	mm_free(base->req_heads);

	EVDNS_UNLOCK(base);
	EVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);

	mm_free(base);
}
",C,,,,"@@ -3175,9 +3175,12 @@ search_set_from_hostname(struct evdns_base *base) {
 static char *
 search_make_new(const struct search_state *const state, int n, const char *const base_name) {
 	const size_t base_len = strlen(base_name);
-	const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
+	char need_to_append_dot;
 	struct search_domain *dom;
 
+	if (!base_len) return NULL;
+	need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;
+
 	for (dom = state->head; dom; dom = dom->next) {
 		if (!n--) {
 			/* this is the postfix we want */",libevent,ec65c42052d95d2c23d1d837136d1cf1d9ecef9e,d7348bab602cf4dbdf65b9eeba2fb9ce4646bc0b,0,"evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)
{
	struct nameserver *server, *server_next;
	struct search_domain *dom, *dom_next;
	int i;

	/* Requires that we hold the lock. */

	/* TODO(nickm) we might need to refcount here. */

	for (i = 0; i < base->n_req_heads; ++i) {
		while (base->req_heads[i]) {
			if (fail_requests)
				reply_schedule_callback(base->req_heads[i], 0, DNS_ERR_SHUTDOWN, NULL);
			request_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);
		}
	}
	while (base->req_waiting_head) {
		if (fail_requests)
			reply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);
		request_finished(base->req_waiting_head, &base->req_waiting_head, 1);
	}
	base->global_requests_inflight = base->global_requests_waiting = 0;

	for (server = base->server_head; server; server = server_next) {
		server_next = server->next;
		/** already done something before */
		server->probe_request = NULL;
		evdns_nameserver_free(server);
		if (server_next == base->server_head)
			break;
	}
	base->server_head = NULL;
	base->global_good_nameservers = 0;

	if (base->global_search_state) {
		for (dom = base->global_search_state->head; dom; dom = dom_next) {
			dom_next = dom->next;
			mm_free(dom);
		}
		mm_free(base->global_search_state);
		base->global_search_state = NULL;
	}

	{
		struct hosts_entry *victim;
		while ((victim = TAILQ_FIRST(&base->hostsdb))) {
			TAILQ_REMOVE(&base->hostsdb, victim, next);
			mm_free(victim);
		}
	}

	mm_free(base->req_heads);

	EVDNS_UNLOCK(base);
	EVTHREAD_FREE_LOCK(base->lock, EVTHREAD_LOCKTYPE_RECURSIVE);

	mm_free(base);
}
"
177932,,Remote,Not required,Partial,CVE-2015-2059,https://www.cvedetails.com/cve/CVE-2015-2059/,CWE-119,Low,Partial,Partial,,2015-08-12,7.5,"The stringprep_utf8_to_ucs4 function in libin before 1.31, as used in jabberd2, allows context-dependent attackers to read system memory and possibly have other unspecified impact via invalid UTF-8 characters in a string, which triggers an out-of-bounds read.",2018-10-30,Overflow,1,https://git.savannah.gnu.org/cgit/libidn.git/commit/?id=2e97c279,2e97c2796581c27213962c77f5a8571a598f9a2e,,1,,,"idna_strerror (Idna_rc rc)
{
  const char *p;

  bindtextdomain (PACKAGE, LOCALEDIR);

  switch (rc)
    {
    case IDNA_SUCCESS:
      p = _(""Success"");
      break;

    case IDNA_STRINGPREP_ERROR:
      p = _(""String preparation failed"");
      break;

    case IDNA_PUNYCODE_ERROR:
      p = _(""Punycode failed"");
      break;

    case IDNA_CONTAINS_NON_LDH:
      p = _(""Non-digit/letter/hyphen in input"");
      break;

    case IDNA_CONTAINS_MINUS:
      p = _(""Forbidden leading or trailing minus sign (`-')"");
      break;

    case IDNA_INVALID_LENGTH:
      p = _(""Output would be too large or too small"");
      break;

    case IDNA_NO_ACE_PREFIX:
      p = _(""Input does not start with ACE prefix (`xn--')"");
      break;

    case IDNA_ROUNDTRIP_VERIFY_ERROR:
      p = _(""String not idempotent under ToASCII"");
      break;

    case IDNA_CONTAINS_ACE_PREFIX:
      p = _(""Input already contain ACE prefix (`xn--')"");
       break;
 
     case IDNA_ICONV_ERROR:
      p = _(""Could not convert string in locale encoding"");
       break;
 
     case IDNA_MALLOC_ERROR:
      p = _(""Cannot allocate memory"");
      break;

    case IDNA_DLOPEN_ERROR:
      p = _(""System dlopen failed"");
      break;

    default:
      p = _(""Unknown error"");
      break;
    }

  return p;
}
","idna_strerror (Idna_rc rc)
{
  const char *p;

  bindtextdomain (PACKAGE, LOCALEDIR);

  switch (rc)
    {
    case IDNA_SUCCESS:
      p = _(""Success"");
      break;

    case IDNA_STRINGPREP_ERROR:
      p = _(""String preparation failed"");
      break;

    case IDNA_PUNYCODE_ERROR:
      p = _(""Punycode failed"");
      break;

    case IDNA_CONTAINS_NON_LDH:
      p = _(""Non-digit/letter/hyphen in input"");
      break;

    case IDNA_CONTAINS_MINUS:
      p = _(""Forbidden leading or trailing minus sign (`-')"");
      break;

    case IDNA_INVALID_LENGTH:
      p = _(""Output would be too large or too small"");
      break;

    case IDNA_NO_ACE_PREFIX:
      p = _(""Input does not start with ACE prefix (`xn--')"");
      break;

    case IDNA_ROUNDTRIP_VERIFY_ERROR:
      p = _(""String not idempotent under ToASCII"");
      break;

    case IDNA_CONTAINS_ACE_PREFIX:
      p = _(""Input already contain ACE prefix (`xn--')"");
       break;
 
     case IDNA_ICONV_ERROR:
      p = _(""System iconv failed"");
       break;
 
     case IDNA_MALLOC_ERROR:
      p = _(""Cannot allocate memory"");
      break;

    case IDNA_DLOPEN_ERROR:
      p = _(""System dlopen failed"");
      break;

    default:
      p = _(""Unknown error"");
      break;
    }

  return p;
}
",C,"      p = _(""Could not convert string in locale encoding"");
","      p = _(""System iconv failed"");
",a8dc72ad1cc0c666a99b472e7fbcee96fe9c5c96,"@@ -115,7 +115,7 @@ idna_strerror (Idna_rc rc)
       break;
 
     case IDNA_ICONV_ERROR:
-      p = _(""System iconv failed"");
+      p = _(""Could not convert string in locale encoding"");
       break;
 
     case IDNA_MALLOC_ERROR:",savannah,https://git.savannah.gnu.org/cgit/libidn.git/tree/lib/strerror-idna.c?id=2e97c2796581c27213962c77f5a8571a598f9a2e,https://git.savannah.gnu.org/cgit/libidn.git/tree/lib/strerror-idna.c?id=a8dc72ad1cc0c666a99b472e7fbcee96fe9c5c96,1,"idna_strerror (Idna_rc rc)
{
  const char *p;

  bindtextdomain (PACKAGE, LOCALEDIR);

  switch (rc)
    {
    case IDNA_SUCCESS:
      p = _(""Success"");
      break;

    case IDNA_STRINGPREP_ERROR:
      p = _(""String preparation failed"");
      break;

    case IDNA_PUNYCODE_ERROR:
      p = _(""Punycode failed"");
      break;

    case IDNA_CONTAINS_NON_LDH:
      p = _(""Non-digit/letter/hyphen in input"");
      break;

    case IDNA_CONTAINS_MINUS:
      p = _(""Forbidden leading or trailing minus sign (`-')"");
      break;

    case IDNA_INVALID_LENGTH:
      p = _(""Output would be too large or too small"");
      break;

    case IDNA_NO_ACE_PREFIX:
      p = _(""Input does not start with ACE prefix (`xn--')"");
      break;

    case IDNA_ROUNDTRIP_VERIFY_ERROR:
      p = _(""String not idempotent under ToASCII"");
      break;

    case IDNA_CONTAINS_ACE_PREFIX:
      p = _(""Input already contain ACE prefix (`xn--')"");
       break;
 
     case IDNA_ICONV_ERROR:
//flaw_line_below:
      p = _(""System iconv failed"");
//fix_flaw_line_below:
//      p = _(""Could not convert string in locale encoding"");
       break;
 
     case IDNA_MALLOC_ERROR:
      p = _(""Cannot allocate memory"");
      break;

    case IDNA_DLOPEN_ERROR:
      p = _(""System dlopen failed"");
      break;

    default:
      p = _(""Unknown error"");
      break;
    }

  return p;
}
"
135654,,Remote,Not required,Partial,CVE-2015-6773,https://www.cvedetails.com/cve/CVE-2015-6773/,CWE-119,Low,Partial,Partial,,2015-12-05,7.5,"The convolution implementation in Skia, as used in Google Chrome before 47.0.2526.73, does not properly constrain row lengths, which allows remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact via crafted graphics data.",2017-09-13,DoS Overflow ,0,https://github.com/chromium/chromium/commit/33827275411b33371e7bb750cce20f11de85002d,33827275411b33371e7bb750cce20f11de85002d,"Move SelectionTemplate::is_handle_visible_ to FrameSelection

This patch moves |is_handle_visible_| to |FrameSelection| from |SelectionTemplate|
since handle visibility is used only for setting |FrameSelection|, hence it is
a redundant member variable of |SelectionTemplate|.

Bug: 742093
Change-Id: I3add4da3844fb40be34dcb4d4b46b5fa6fed1d7e
Reviewed-on: https://chromium-review.googlesource.com/595389
Commit-Queue: Yoshifumi Inoue <yosin@chromium.org>
Reviewed-by: Xiaocheng Hu <xiaochengh@chromium.org>
Reviewed-by: Kent Tamura <tkent@chromium.org>
Cr-Commit-Position: refs/heads/master@{#491660}",0,third_party/WebKit/Source/core/editing/FrameSelection.cpp,"{""sha"": ""13ade5d3536ca28cfbedd7186d64a6d5846cb398"", ""filename"": ""third_party/WebKit/Source/core/editing/Editor.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/Editor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/Editor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/Editor.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -1494,10 +1494,10 @@ void Editor::ChangeSelectionAfterCommand(\n   bool selection_did_not_change_dom_position =\n       new_selection == GetFrame().Selection().GetSelectionInDOMTree();\n   GetFrame().Selection().SetSelection(\n-      SelectionInDOMTree::Builder(new_selection)\n-          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())\n-          .Build(),\n-      options);\n+      new_selection,\n+      SetSelectionData::Builder(options)\n+          .SetShouldShowHandle(GetFrame().Selection().IsHandleVisible())\n+          .Build());\n \n   // Some editing operations change the selection visually without affecting its\n   // position within the DOM. For example when you press return in the following""}<_**next**_>{""sha"": ""e01b253fc5f4a41cef97ee7cdfa7e713ce416583"", ""filename"": ""third_party/WebKit/Source/core/editing/FrameSelection.cpp"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 13, ""changes"": 28, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelection.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelection.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/FrameSelection.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -114,10 +114,6 @@ Document& FrameSelection::GetDocument() const {\n   return *LifecycleContext();\n }\n \n-bool FrameSelection::IsHandleVisible() const {\n-  return GetSelectionInDOMTree().IsHandleVisible();\n-}\n-\n const VisibleSelection& FrameSelection::ComputeVisibleSelectionInDOMTree()\n     const {\n   return selection_editor_->ComputeVisibleSelectionInDOMTree();\n@@ -175,13 +171,13 @@ void FrameSelection::MoveCaretSelection(const IntPoint& point) {\n       VisiblePositionForContentsPoint(point, GetFrame());\n   SelectionInDOMTree::Builder builder;\n   builder.SetIsDirectional(GetSelectionInDOMTree().IsDirectional());\n-  builder.SetIsHandleVisible(true);\n   if (position.IsNotNull())\n     builder.Collapse(position.ToPositionWithAffinity());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetSetSelectionBy(SetSelectionBy::kUser)\n+                                    .SetShouldShowHandle(true)\n                                     .Build());\n }\n \n@@ -222,9 +218,13 @@ bool FrameSelection::SetSelectionDeprecated(\n \n   const SelectionInDOMTree old_selection_in_dom_tree =\n       selection_editor_->GetSelectionInDOMTree();\n-  if (old_selection_in_dom_tree == new_selection)\n+  const bool is_changed = old_selection_in_dom_tree != new_selection;\n+  const bool should_show_handle = options.ShouldShowHandle();\n+  if (!is_changed && is_handle_visible_ == should_show_handle)\n     return false;\n-  selection_editor_->SetSelection(new_selection);\n+  if (is_changed)\n+    selection_editor_->SetSelection(new_selection);\n+  is_handle_visible_ = should_show_handle;\n   ScheduleVisualUpdateForPaintInvalidationIfNeeded();\n \n   const Document& current_document = GetDocument();\n@@ -397,6 +397,7 @@ void FrameSelection::Clear() {\n   if (granularity_strategy_)\n     granularity_strategy_->Clear();\n   SetSelection(SelectionInDOMTree());\n+  is_handle_visible_ = false;\n }\n \n bool FrameSelection::SelectionHasFocus() const {\n@@ -692,9 +693,11 @@ void FrameSelection::SelectAll(SetSelectionBy set_selection_by) {\n   }\n \n   // TODO(editing-dev): Should we pass in set_selection_by?\n-  SetSelection(SelectionInDOMTree::Builder()\n-                   .SelectAllChildren(*root)\n-                   .SetIsHandleVisible(IsHandleVisible())\n+  SetSelection(SelectionInDOMTree::Builder().SelectAllChildren(*root).Build(),\n+               SetSelectionData::Builder()\n+                   .SetShouldCloseTyping(true)\n+                   .SetShouldClearTypingStyle(true)\n+                   .SetShouldShowHandle(IsHandleVisible())\n                    .Build());\n   SelectFrameElementInParentIfFullySelected();\n   // TODO(editing-dev): Should we pass in set_selection_by?\n@@ -1089,13 +1092,13 @@ void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {\n   SetSelection(\n       SelectionInDOMTree::Builder(\n           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))\n-          .SetIsHandleVisible(true)\n           .Build(),\n       SetSelectionData::Builder()\n           .SetShouldCloseTyping(true)\n           .SetShouldClearTypingStyle(true)\n           .SetDoNotClearStrategy(true)\n           .SetSetSelectionBy(SetSelectionBy::kUser)\n+          .SetShouldShowHandle(true)\n           .Build());\n }\n \n@@ -1110,7 +1113,6 @@ void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),\n                                       extent_position.DeepEquivalent())\n           .SetAffinity(base_position.Affinity())\n-          .SetIsHandleVisible(IsHandleVisible())\n           .Build();\n \n   if (new_selection.IsNone())\n@@ -1130,11 +1132,11 @@ void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,\n                              visible_selection.Start());\n   }\n   builder.SetAffinity(visible_selection.Affinity());\n-  builder.SetIsHandleVisible(IsHandleVisible());\n   SetSelection(builder.Build(), SetSelectionData::Builder()\n                                     .SetShouldCloseTyping(true)\n                                     .SetShouldClearTypingStyle(true)\n                                     .SetGranularity(granularity)\n+                                    .SetShouldShowHandle(IsHandleVisible())\n                                     .Build());\n }\n ""}<_**next**_>{""sha"": ""4b62ae75d91aec57262f99bb5de66abe1a24a10c"", ""filename"": ""third_party/WebKit/Source/core/editing/FrameSelection.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelection.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelection.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/FrameSelection.h?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -177,7 +177,7 @@ class CORE_EXPORT FrameSelection final\n \n   void SetUseSecureKeyboardEntryWhenActive(bool);\n \n-  bool IsHandleVisible() const;\n+  bool IsHandleVisible() const { return is_handle_visible_; }\n \n   void UpdateSecureKeyboardEntryIfActive();\n \n@@ -272,6 +272,7 @@ class CORE_EXPORT FrameSelection final\n   LayoutUnit x_pos_for_vertical_arrow_navigation_;\n \n   bool focused_ : 1;\n+  bool is_handle_visible_ = false;\n \n   // Controls text granularity used to adjust the selection's extent in\n   // moveRangeSelectionExtent.""}<_**next**_>{""sha"": ""262c94d6db8c95e6e498f3803cde4cdc8dfea7d8"", ""filename"": ""third_party/WebKit/Source/core/editing/FrameSelectionTest.cpp"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 12, ""changes"": 31, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelectionTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/FrameSelectionTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/FrameSelectionTest.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -296,7 +296,6 @@ TEST_F(FrameSelectionTest, SelectAllPreservesHandle) {\n   const Position end_of_text(sample->firstChild(), 3);\n   Selection().SetSelection(SelectionInDOMTree::Builder()\n                                .Collapse(end_of_text)\n-                               .SetIsHandleVisible(false)\n                                .Build());\n   EXPECT_FALSE(Selection().IsHandleVisible());\n   Selection().SelectAll();\n@@ -305,10 +304,13 @@ TEST_F(FrameSelectionTest, SelectAllPreservesHandle) {\n          \""selectAll. Then they shouldn't be present \""\n          \""after it.\"";\n \n-  Selection().SetSelection(SelectionInDOMTree::Builder()\n-                               .Collapse(end_of_text)\n-                               .SetIsHandleVisible(true)\n-                               .Build());\n+  Selection().SetSelection(\n+      SelectionInDOMTree::Builder().Collapse(end_of_text).Build(),\n+      SetSelectionData::Builder()\n+          .SetShouldCloseTyping(true)\n+          .SetShouldClearTypingStyle(true)\n+          .SetShouldShowHandle(true)\n+          .Build());\n   EXPECT_TRUE(Selection().IsHandleVisible());\n   Selection().SelectAll();\n   EXPECT_TRUE(Selection().IsHandleVisible())\n@@ -323,7 +325,6 @@ TEST_F(FrameSelectionTest, BoldCommandPreservesHandle) {\n   const Position end_of_text(sample->firstChild(), 3);\n   Selection().SetSelection(SelectionInDOMTree::Builder()\n                                .Collapse(end_of_text)\n-                               .SetIsHandleVisible(false)\n                                .Build());\n   EXPECT_FALSE(Selection().IsHandleVisible());\n   Selection().SelectAll();\n@@ -333,10 +334,13 @@ TEST_F(FrameSelectionTest, BoldCommandPreservesHandle) {\n          \""bold command. Then they shouldn't \""\n          \""be present after it.\"";\n \n-  Selection().SetSelection(SelectionInDOMTree::Builder()\n-                               .Collapse(end_of_text)\n-                               .SetIsHandleVisible(true)\n-                               .Build());\n+  Selection().SetSelection(\n+      SelectionInDOMTree::Builder().Collapse(end_of_text).Build(),\n+      SetSelectionData::Builder()\n+          .SetShouldCloseTyping(true)\n+          .SetShouldClearTypingStyle(true)\n+          .SetShouldShowHandle(true)\n+          .Build());\n   EXPECT_TRUE(Selection().IsHandleVisible());\n   Selection().SelectAll();\n   GetDocument().execCommand(\""bold\"", false, \""\"", ASSERT_NO_EXCEPTION);\n@@ -352,7 +356,6 @@ TEST_F(FrameSelectionTest, SelectionOnRangeHidesHandles) {\n   Selection().SetSelection(\n       SelectionInDOMTree::Builder()\n           .SetBaseAndExtent(Position(text, 0), Position(text, 5))\n-          .SetIsHandleVisible(false)\n           .Build());\n \n   Selection().SetSelection(SelectionInDOMTree::Builder()\n@@ -367,7 +370,11 @@ TEST_F(FrameSelectionTest, SelectionOnRangeHidesHandles) {\n   Selection().SetSelection(\n       SelectionInDOMTree::Builder()\n           .SetBaseAndExtent(Position(text, 0), Position(text, 5))\n-          .SetIsHandleVisible(true)\n+          .Build(),\n+      SetSelectionData::Builder()\n+          .SetShouldCloseTyping(true)\n+          .SetShouldClearTypingStyle(true)\n+          .SetShouldShowHandle(true)\n           .Build());\n \n   Selection().SetSelection(SelectionInDOMTree::Builder()""}<_**next**_>{""sha"": ""d1bd23940b0645e047071e8d52a89c036e406f87"", ""filename"": ""third_party/WebKit/Source/core/editing/GranularityStrategyTest.cpp"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 4, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/GranularityStrategyTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/GranularityStrategyTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/GranularityStrategyTest.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -725,9 +725,13 @@ TEST_F(GranularityStrategyTest, UpdateExtentWithNullPositionForCharacter) {\n       SelectionInDOMTree::Builder()\n           .Collapse(Position(sample->firstChild(), 2))\n           .SetIsDirectional(true)\n-          .SetIsHandleVisible(true)\n           .Build();\n-  Selection().SetSelection(selection_in_dom_tree);\n+  Selection().SetSelection(selection_in_dom_tree,\n+                           SetSelectionData::Builder()\n+                               .SetShouldCloseTyping(true)\n+                               .SetShouldClearTypingStyle(true)\n+                               .SetShouldShowHandle(true)\n+                               .Build());\n \n   // Since, it is not obvious that |visiblePositionForContentsPoint()| returns\n   // null position, we verify here.\n@@ -757,9 +761,13 @@ TEST_F(GranularityStrategyTest, UpdateExtentWithNullPositionForDirectional) {\n       SelectionInDOMTree::Builder()\n           .Collapse(Position(sample->firstChild(), 2))\n           .SetIsDirectional(true)\n-          .SetIsHandleVisible(true)\n           .Build();\n-  Selection().SetSelection(selection_in_dom_tree);\n+  Selection().SetSelection(selection_in_dom_tree,\n+                           SetSelectionData::Builder()\n+                               .SetShouldCloseTyping(true)\n+                               .SetShouldClearTypingStyle(true)\n+                               .SetShouldShowHandle(true)\n+                               .Build());\n \n   // Since, it is not obvious that |visiblePositionForContentsPoint()| returns\n   // null position, we verify here.""}<_**next**_>{""sha"": ""2c313f93e7fe8bac4363902ffa67fc4704bb7470"", ""filename"": ""third_party/WebKit/Source/core/editing/InputMethodController.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/InputMethodController.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/InputMethodController.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/InputMethodController.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -394,11 +394,12 @@ bool InputMethodController::FinishComposingText(\n     const SelectionInDOMTree& selection =\n         SelectionInDOMTree::Builder()\n             .SetBaseAndExtent(old_selection_range)\n-            .SetIsHandleVisible(is_handle_visible)\n             .Build();\n     GetFrame().Selection().SetSelection(\n-        selection,\n-        SetSelectionData::Builder().SetShouldCloseTyping(true).Build());\n+        selection, SetSelectionData::Builder()\n+                       .SetShouldCloseTyping(true)\n+                       .SetShouldShowHandle(is_handle_visible)\n+                       .Build());\n     return true;\n   }\n ""}<_**next**_>{""sha"": ""0ac1de9d41e80507c35b8793fd2df0c9af1929fb"", ""filename"": ""third_party/WebKit/Source/core/editing/SelectionController.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionController.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionController.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SelectionController.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -81,7 +81,6 @@ SelectionInDOMTree ConvertToSelectionInDOMTree(\n       .SetBaseAndExtent(ToPositionInDOMTree(selection_in_flat_tree.Base()),\n                         ToPositionInDOMTree(selection_in_flat_tree.Extent()))\n       .SetIsDirectional(selection_in_flat_tree.IsDirectional())\n-      .SetIsHandleVisible(selection_in_flat_tree.IsHandleVisible())\n       .Build();\n }\n \n@@ -804,11 +803,12 @@ void SelectionController::SetNonDirectionalSelectionIfNeeded(\n     original_base_in_flat_tree_ = PositionInFlatTreeWithAffinity();\n   }\n \n-  builder.SetIsHandleVisible(handle_visibility == HandleVisibility::kVisible);\n   const SelectionInFlatTree& selection_in_flat_tree = builder.Build();\n+  const bool should_show_handle =\n+      handle_visibility == HandleVisibility::kVisible;\n   if (Selection().ComputeVisibleSelectionInFlatTree() ==\n           CreateVisibleSelection(selection_in_flat_tree) &&\n-      Selection().IsHandleVisible() == selection_in_flat_tree.IsHandleVisible())\n+      Selection().IsHandleVisible() == should_show_handle)\n     return;\n   Selection().SetSelection(\n       ConvertToSelectionInDOMTree(selection_in_flat_tree),\n@@ -817,6 +817,7 @@ void SelectionController::SetNonDirectionalSelectionIfNeeded(\n           .SetShouldClearTypingStyle(true)\n           .SetCursorAlignOnScroll(CursorAlignOnScroll::kIfNeeded)\n           .SetGranularity(granularity)\n+          .SetShouldShowHandle(should_show_handle)\n           .Build());\n }\n ""}<_**next**_>{""sha"": ""7d87872fca4c6cd3d1eea4b7e477455c60563729"", ""filename"": ""third_party/WebKit/Source/core/editing/SelectionEditor.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 2, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionEditor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionEditor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SelectionEditor.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -181,7 +181,6 @@ void SelectionEditor::NodeChildrenWillBeRemoved(ContainerNode& container) {\n     return;\n   selection_ = SelectionInDOMTree::Builder()\n                    .SetBaseAndExtent(new_base, new_extent)\n-                   .SetIsHandleVisible(selection_.IsHandleVisible())\n                    .Build();\n   MarkCacheDirty();\n }\n@@ -199,7 +198,6 @@ void SelectionEditor::NodeWillBeRemoved(Node& node_to_be_removed) {\n     return;\n   selection_ = SelectionInDOMTree::Builder()\n                    .SetBaseAndExtent(new_base, new_extent)\n-                   .SetIsHandleVisible(selection_.IsHandleVisible())\n                    .Build();\n   MarkCacheDirty();\n }""}<_**next**_>{""sha"": ""bfbf41f83a6d6335e535cd2f801e965f3b26dbf5"", ""filename"": ""third_party/WebKit/Source/core/editing/SelectionTemplate.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 12, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplate.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplate.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SelectionTemplate.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -14,8 +14,7 @@ SelectionTemplate<Strategy>::SelectionTemplate(const SelectionTemplate& other)\n     : base_(other.base_),\n       extent_(other.extent_),\n       affinity_(other.affinity_),\n-      is_directional_(other.is_directional_),\n-      is_handle_visible_(other.is_handle_visible_)\n+      is_directional_(other.is_directional_)\n #if DCHECK_IS_ON()\n       ,\n       dom_tree_version_(other.dom_tree_version_)\n@@ -39,8 +38,7 @@ bool SelectionTemplate<Strategy>::operator==(\n   DCHECK_EQ(base_.GetDocument(), other.GetDocument()) << *this << ' ' << other;\n   return base_ == other.base_ && extent_ == other.extent_ &&\n          affinity_ == other.affinity_ &&\n-         is_directional_ == other.is_directional_ &&\n-         is_handle_visible_ == other.is_handle_visible_;\n+         is_directional_ == other.is_directional_;\n }\n \n template <typename Strategy>\n@@ -305,14 +303,6 @@ SelectionTemplate<Strategy>::Builder::SetIsDirectional(bool is_directional) {\n   return *this;\n }\n \n-template <typename Strategy>\n-typename SelectionTemplate<Strategy>::Builder&\n-SelectionTemplate<Strategy>::Builder::SetIsHandleVisible(\n-    bool is_handle_visible) {\n-  selection_.is_handle_visible_ = is_handle_visible;\n-  return *this;\n-}\n-\n template class CORE_TEMPLATE_EXPORT SelectionTemplate<EditingStrategy>;\n template class CORE_TEMPLATE_EXPORT\n     SelectionTemplate<EditingInFlatTreeStrategy>;""}<_**next**_>{""sha"": ""c5984e910fbda01afc2eebae7cdafbe4abe5904a"", ""filename"": ""third_party/WebKit/Source/core/editing/SelectionTemplate.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SelectionTemplate.h?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -64,7 +64,6 @@ class CORE_EXPORT SelectionTemplate final {\n \n     Builder& SetAffinity(TextAffinity);\n     Builder& SetIsDirectional(bool);\n-    Builder& SetIsHandleVisible(bool);\n \n    private:\n     SelectionTemplate selection_;\n@@ -85,7 +84,6 @@ class CORE_EXPORT SelectionTemplate final {\n   TextAffinity Affinity() const { return affinity_; }\n   bool IsCaret() const;\n   bool IsDirectional() const { return is_directional_; }\n-  bool IsHandleVisible() const { return is_handle_visible_; }\n   bool IsNone() const { return base_.IsNull(); }\n   bool IsRange() const;\n \n@@ -116,7 +114,6 @@ class CORE_EXPORT SelectionTemplate final {\n   PositionTemplate<Strategy> extent_;\n   TextAffinity affinity_ = TextAffinity::kDownstream;\n   bool is_directional_ = false;\n-  bool is_handle_visible_ = false;\n #if DCHECK_IS_ON()\n   uint64_t dom_tree_version_;\n #endif""}<_**next**_>{""sha"": ""04c09315bbb0e1398f1c381648350bda9a2552c1"", ""filename"": ""third_party/WebKit/Source/core/editing/SelectionTemplateTest.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 10, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplateTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SelectionTemplateTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SelectionTemplateTest.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -16,7 +16,6 @@ TEST_F(SelectionTest, defaultConstructor) {\n \n   EXPECT_EQ(TextAffinity::kDownstream, selection.Affinity());\n   EXPECT_FALSE(selection.IsDirectional());\n-  EXPECT_FALSE(selection.IsHandleVisible());\n   EXPECT_TRUE(selection.IsNone());\n   EXPECT_EQ(Position(), selection.Base());\n   EXPECT_EQ(Position(), selection.Extent());\n@@ -33,7 +32,6 @@ TEST_F(SelectionTest, caret) {\n \n   EXPECT_EQ(TextAffinity::kDownstream, selection.Affinity());\n   EXPECT_FALSE(selection.IsDirectional());\n-  EXPECT_FALSE(selection.IsHandleVisible());\n   EXPECT_FALSE(selection.IsNone());\n   EXPECT_EQ(position, selection.Base());\n   EXPECT_EQ(position, selection.Extent());\n@@ -52,17 +50,9 @@ TEST_F(SelectionTest, range) {\n \n   EXPECT_EQ(TextAffinity::kDownstream, selection.Affinity());\n   EXPECT_FALSE(selection.IsDirectional());\n-  EXPECT_FALSE(selection.IsHandleVisible());\n   EXPECT_FALSE(selection.IsNone());\n   EXPECT_EQ(base, selection.Base());\n   EXPECT_EQ(extent, selection.Extent());\n }\n \n-TEST_F(SelectionTest, setIsHandleVisible) {\n-  SelectionInDOMTree::Builder builder;\n-  builder.SetIsHandleVisible(true);\n-  const SelectionInDOMTree& selection = builder.Build();\n-  EXPECT_TRUE(selection.IsHandleVisible());\n-}\n-\n }  // namespace blink""}<_**next**_>{""sha"": ""6bd50626a5fac46d234ea830cc52ba7bcdb51d0c"", ""filename"": ""third_party/WebKit/Source/core/editing/SetSelectionData.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SetSelectionData.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SetSelectionData.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SetSelectionData.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -54,6 +54,12 @@ SetSelectionData::Builder& SetSelectionData::Builder::SetShouldClearTypingStyle(\n   return *this;\n }\n \n+SetSelectionData::Builder& SetSelectionData::Builder::SetShouldShowHandle(\n+    bool new_value) {\n+  data_.should_show_handle_ = new_value;\n+  return *this;\n+}\n+\n SetSelectionData::Builder& SetSelectionData::Builder::SetSetSelectionBy(\n     SetSelectionBy new_value) {\n   data_.set_selection_by_ = new_value;""}<_**next**_>{""sha"": ""142eb354c2e26ddefd1368ae029ec64788bacc42"", ""filename"": ""third_party/WebKit/Source/core/editing/SetSelectionData.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SetSelectionData.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/editing/SetSelectionData.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/editing/SetSelectionData.h?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -33,6 +33,7 @@ class CORE_EXPORT SetSelectionData final {\n   bool DoNotClearStrategy() const { return do_not_clear_strategy_; }\n   bool ShouldCloseTyping() const { return should_close_typing_; }\n   bool ShouldClearTypingStyle() const { return should_clear_typing_style_; }\n+  bool ShouldShowHandle() const { return should_show_handle_; }\n \n  private:\n   CursorAlignOnScroll cursor_align_on_scroll_ = CursorAlignOnScroll::kIfNeeded;\n@@ -42,6 +43,7 @@ class CORE_EXPORT SetSelectionData final {\n   SetSelectionBy set_selection_by_ = SetSelectionBy::kSystem;\n   bool should_close_typing_ = false;\n   bool should_clear_typing_style_ = false;\n+  bool should_show_handle_ = false;\n };\n \n // This class is used for building |SelectionData| object.\n@@ -61,6 +63,7 @@ class CORE_EXPORT SetSelectionData::Builder final {\n   Builder& SetSetSelectionBy(SetSelectionBy);\n   Builder& SetShouldCloseTyping(bool);\n   Builder& SetShouldClearTypingStyle(bool);\n+  Builder& SetShouldShowHandle(bool);\n \n  private:\n   SetSelectionData data_;""}<_**next**_>{""sha"": ""c786b7ea78c27c5a7d4160762f788698b502ff2d"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/chromium/chromium/blob/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/33827275411b33371e7bb750cce20f11de85002d/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=33827275411b33371e7bb750cce20f11de85002d"", ""patch"": ""@@ -1210,13 +1210,13 @@ void WebLocalFrameImpl::SelectRange(\n       handle_visibility_behavior == kShowSelectionHandle ||\n       (handle_visibility_behavior == kPreserveHandleVisibility &&\n        selection.IsHandleVisible());\n-  selection.SetSelection(SelectionInDOMTree::Builder()\n-                             .SetBaseAndExtent(range)\n-                             .SetAffinity(VP_DEFAULT_AFFINITY)\n-                             .SetIsHandleVisible(show_handles)\n-                             .SetIsDirectional(false)\n-                             .Build(),\n-                         SetSelectionData());\n+  selection.SetSelection(\n+      SelectionInDOMTree::Builder()\n+          .SetBaseAndExtent(range)\n+          .SetAffinity(VP_DEFAULT_AFFINITY)\n+          .SetIsDirectional(false)\n+          .Build(),\n+      SetSelectionData::Builder().SetShouldShowHandle(show_handles).Build());\n }\n \n WebString WebLocalFrameImpl::RangeAsText(const WebRange& web_range) {""}","static Node* NonBoundaryShadowTreeRootNode(const Position& position) {
  return position.AnchorNode() && !position.AnchorNode()->IsShadowRoot()
             ? position.AnchorNode()->NonBoundaryShadowTreeRootNode()
             : nullptr;
}
","static Node* NonBoundaryShadowTreeRootNode(const Position& position) {
  return position.AnchorNode() && !position.AnchorNode()->IsShadowRoot()
             ? position.AnchorNode()->NonBoundaryShadowTreeRootNode()
             : nullptr;
}
",C,,,,"@@ -114,10 +114,6 @@ Document& FrameSelection::GetDocument() const {
   return *LifecycleContext();
 }
 
-bool FrameSelection::IsHandleVisible() const {
-  return GetSelectionInDOMTree().IsHandleVisible();
-}
-
 const VisibleSelection& FrameSelection::ComputeVisibleSelectionInDOMTree()
     const {
   return selection_editor_->ComputeVisibleSelectionInDOMTree();
@@ -175,13 +171,13 @@ void FrameSelection::MoveCaretSelection(const IntPoint& point) {
       VisiblePositionForContentsPoint(point, GetFrame());
   SelectionInDOMTree::Builder builder;
   builder.SetIsDirectional(GetSelectionInDOMTree().IsDirectional());
-  builder.SetIsHandleVisible(true);
   if (position.IsNotNull())
     builder.Collapse(position.ToPositionWithAffinity());
   SetSelection(builder.Build(), SetSelectionData::Builder()
                                     .SetShouldCloseTyping(true)
                                     .SetShouldClearTypingStyle(true)
                                     .SetSetSelectionBy(SetSelectionBy::kUser)
+                                    .SetShouldShowHandle(true)
                                     .Build());
 }
 
@@ -222,9 +218,13 @@ bool FrameSelection::SetSelectionDeprecated(
 
   const SelectionInDOMTree old_selection_in_dom_tree =
       selection_editor_->GetSelectionInDOMTree();
-  if (old_selection_in_dom_tree == new_selection)
+  const bool is_changed = old_selection_in_dom_tree != new_selection;
+  const bool should_show_handle = options.ShouldShowHandle();
+  if (!is_changed && is_handle_visible_ == should_show_handle)
     return false;
-  selection_editor_->SetSelection(new_selection);
+  if (is_changed)
+    selection_editor_->SetSelection(new_selection);
+  is_handle_visible_ = should_show_handle;
   ScheduleVisualUpdateForPaintInvalidationIfNeeded();
 
   const Document& current_document = GetDocument();
@@ -397,6 +397,7 @@ void FrameSelection::Clear() {
   if (granularity_strategy_)
     granularity_strategy_->Clear();
   SetSelection(SelectionInDOMTree());
+  is_handle_visible_ = false;
 }
 
 bool FrameSelection::SelectionHasFocus() const {
@@ -692,9 +693,11 @@ void FrameSelection::SelectAll(SetSelectionBy set_selection_by) {
   }
 
   // TODO(editing-dev): Should we pass in set_selection_by?
-  SetSelection(SelectionInDOMTree::Builder()
-                   .SelectAllChildren(*root)
-                   .SetIsHandleVisible(IsHandleVisible())
+  SetSelection(SelectionInDOMTree::Builder().SelectAllChildren(*root).Build(),
+               SetSelectionData::Builder()
+                   .SetShouldCloseTyping(true)
+                   .SetShouldClearTypingStyle(true)
+                   .SetShouldShowHandle(IsHandleVisible())
                    .Build());
   SelectFrameElementInParentIfFullySelected();
   // TODO(editing-dev): Should we pass in set_selection_by?
@@ -1089,13 +1092,13 @@ void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
-          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
+          .SetShouldShowHandle(true)
           .Build());
 }
 
@@ -1110,7 +1113,6 @@ void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,
           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),
                                       extent_position.DeepEquivalent())
           .SetAffinity(base_position.Affinity())
-          .SetIsHandleVisible(IsHandleVisible())
           .Build();
 
   if (new_selection.IsNone())
@@ -1130,11 +1132,11 @@ void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,
                              visible_selection.Start());
   }
   builder.SetAffinity(visible_selection.Affinity());
-  builder.SetIsHandleVisible(IsHandleVisible());
   SetSelection(builder.Build(), SetSelectionData::Builder()
                                     .SetShouldCloseTyping(true)
                                     .SetShouldClearTypingStyle(true)
                                     .SetGranularity(granularity)
+                                    .SetShouldShowHandle(IsHandleVisible())
                                     .Build());
 }
 ",Chrome,33827275411b33371e7bb750cce20f11de85002d,b9742d89a3c672a84d11191b89dc65b7ff7b547b,0,"static Node* NonBoundaryShadowTreeRootNode(const Position& position) {
  return position.AnchorNode() && !position.AnchorNode()->IsShadowRoot()
             ? position.AnchorNode()->NonBoundaryShadowTreeRootNode()
             : nullptr;
}
"
23333,,Local Network,Not required,Complete,CVE-2011-4131,https://www.cvedetails.com/cve/CVE-2011-4131/,CWE-189,High,,,,2012-05-17,4.6,"The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",2017-12-28,DoS ,0,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,bf118a342f10dafe44b14451a1392c3254629a1f,"NFSv4: include bitmap in nfsv4 get acl data

The NFSv4 bitmap size is unbounded: a server can return an arbitrary
sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the
nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server
with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data
xdr length to the (cached) acl page data.

This is a general solution to commit e5012d1f ""NFSv4.1: update
nfs4_fattr_bitmap_maxsz"" and fixes hitting a BUG_ON in xdr_shrink_bufhead
when getting ACLs.

Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr
was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.

Cc: stable@kernel.org
Signed-off-by: Andy Adamson <andros@netapp.com>
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",0,fs/nfs/nfs4xdr.c,"{""sha"": ""3b1080118452ba8d3b5fc860d9d99db8b900d8ad"", ""filename"": ""fs/nfs/nfs4proc.c"", ""status"": ""modified"", ""additions"": 57, ""deletions"": 39, ""changes"": 96, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4proc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4proc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/nfs4proc.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -3426,19 +3426,6 @@ static inline int nfs4_server_supports_acls(struct nfs_server *server)\n  */\n #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)\n \n-static void buf_to_pages(const void *buf, size_t buflen,\n-\t\tstruct page **pages, unsigned int *pgbase)\n-{\n-\tconst void *p = buf;\n-\n-\t*pgbase = offset_in_page(buf);\n-\tp -= *pgbase;\n-\twhile (p < buf + buflen) {\n-\t\t*(pages++) = virt_to_page(p);\n-\t\tp += PAGE_CACHE_SIZE;\n-\t}\n-}\n-\n static int buf_to_pages_noslab(const void *buf, size_t buflen,\n \t\tstruct page **pages, unsigned int *pgbase)\n {\n@@ -3535,9 +3522,19 @@ static void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t a\n \tnfs4_set_cached_acl(inode, acl);\n }\n \n+/*\n+ * The getxattr API returns the required buffer length when called with a\n+ * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n+ * the required buf.  On a NULL buf, we send a page of data to the server\n+ * guessing that the ACL request can be serviced by a page. If so, we cache\n+ * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n+ * the cache. If not so, we throw away the page, and cache the required\n+ * length. The next getxattr call will then produce another round trip to\n+ * the server, this time with the input buf of the required size.\n+ */\n static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n {\n-\tstruct page *pages[NFS4ACL_MAXPAGES];\n+\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n \tstruct nfs_getaclargs args = {\n \t\t.fh = NFS_FH(inode),\n \t\t.acl_pages = pages,\n@@ -3552,41 +3549,60 @@ static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu\n \t\t.rpc_argp = &args,\n \t\t.rpc_resp = &res,\n \t};\n-\tstruct page *localpage = NULL;\n-\tint ret;\n+\tint ret = -ENOMEM, npages, i, acl_len = 0;\n \n-\tif (buflen < PAGE_SIZE) {\n-\t\t/* As long as we're doing a round trip to the server anyway,\n-\t\t * let's be prepared for a page of acl data. */\n-\t\tlocalpage = alloc_page(GFP_KERNEL);\n-\t\tresp_buf = page_address(localpage);\n-\t\tif (localpage == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\targs.acl_pages[0] = localpage;\n-\t\targs.acl_pgbase = 0;\n-\t\targs.acl_len = PAGE_SIZE;\n-\t} else {\n-\t\tresp_buf = buf;\n-\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n+\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n+\t/* As long as we're doing a round trip to the server anyway,\n+\t * let's be prepared for a page of acl data. */\n+\tif (npages == 0)\n+\t\tnpages = 1;\n+\n+\tfor (i = 0; i < npages; i++) {\n+\t\tpages[i] = alloc_page(GFP_KERNEL);\n+\t\tif (!pages[i])\n+\t\t\tgoto out_free;\n+\t}\n+\tif (npages > 1) {\n+\t\t/* for decoding across pages */\n+\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n+\t\tif (!args.acl_scratch)\n+\t\t\tgoto out_free;\n \t}\n-\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n+\targs.acl_len = npages * PAGE_SIZE;\n+\targs.acl_pgbase = 0;\n+\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n+\t * the page we send as a guess */\n+\tif (buf == NULL)\n+\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n+\tresp_buf = page_address(pages[0]);\n+\n+\tdprintk(\""%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\"",\n+\t\t__func__, buf, buflen, npages, args.acl_len);\n+\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n+\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n \tif (ret)\n \t\tgoto out_free;\n-\tif (res.acl_len > args.acl_len)\n-\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n+\n+\tacl_len = res.acl_len - res.acl_data_offset;\n+\tif (acl_len > args.acl_len)\n+\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n \telse\n-\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n+\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n+\t\t\t\t      acl_len);\n \tif (buf) {\n \t\tret = -ERANGE;\n-\t\tif (res.acl_len > buflen)\n+\t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n-\t\tif (localpage)\n-\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n+\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n+\t\t\t\tres.acl_len);\n \t}\n-\tret = res.acl_len;\n+\tret = acl_len;\n out_free:\n-\tif (localpage)\n-\t\t__free_page(localpage);\n+\tfor (i = 0; i < npages; i++)\n+\t\tif (pages[i])\n+\t\t\t__free_page(pages[i]);\n+\tif (args.acl_scratch)\n+\t\t__free_page(args.acl_scratch);\n \treturn ret;\n }\n \n@@ -3617,6 +3633,8 @@ static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n \t\tnfs_zap_acl_cache(inode);\n \tret = nfs4_read_cached_acl(inode, buf, buflen);\n \tif (ret != -ENOENT)\n+\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n+\t\t * but no cached acl data, just the acl length */\n \t\treturn ret;\n \treturn nfs4_get_acl_uncached(inode, buf, buflen);\n }""}<_**next**_>{""sha"": ""dcaf69309d8eea153166084f2895c9a77a81564e"", ""filename"": ""fs/nfs/nfs4xdr.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 8, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4xdr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4xdr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/nfs4xdr.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -2517,11 +2517,13 @@ static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n \tencode_compound_hdr(xdr, req, &hdr);\n \tencode_sequence(xdr, &args->seq_args, &hdr);\n \tencode_putfh(xdr, args->fh, &hdr);\n-\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n+\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n \tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n \n \txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n \t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n+\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n+\n \tencode_nops(&hdr);\n }\n \n@@ -4957,17 +4959,18 @@ decode_restorefh(struct xdr_stream *xdr)\n }\n \n static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n-\t\tsize_t *acl_len)\n+\t\t\t struct nfs_getaclres *res)\n {\n-\t__be32 *savep;\n+\t__be32 *savep, *bm_p;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n-\t*acl_len = 0;\n+\tres->acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n+\tbm_p = xdr->p;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n@@ -4979,18 +4982,30 @@ static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n+\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n+\t\t * are stored with the acl data to handle the problem of\n+\t\t * variable length bitmaps.*/\n+\t\txdr->p = bm_p;\n+\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n+\t\tres->acl_data_offset <<= 2;\n+\n \t\t/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... */\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n+\t\tattrlen += res->acl_data_offset;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n-\t\t\tdprintk(\""NFS: server cheating in getattr\""\n-\t\t\t\t\t\"" acl reply: attrlen %u > recvd %u\\n\"",\n+\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n+\t\t\t\t/* getxattr interface called with a NULL buf */\n+\t\t\t\tres->acl_len = attrlen;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tdprintk(\""NFS: acl reply: attrlen %u > recvd %u\\n\"",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n-\t\t*acl_len = attrlen;\n+\t\tres->acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n \n@@ -6028,7 +6043,7 @@ nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n \tstatus = decode_putfh(xdr);\n \tif (status)\n \t\tgoto out;\n-\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n+\tstatus = decode_getacl(xdr, rqstp, res);\n \n out:\n \treturn status;""}<_**next**_>{""sha"": ""6c898afe60951dbef8175e3c8cfe1be8244c1d37"", ""filename"": ""include/linux/nfs_xdr.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/nfs_xdr.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/nfs_xdr.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/nfs_xdr.h?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -602,11 +602,16 @@ struct nfs_getaclargs {\n \tsize_t\t\t\t\tacl_len;\n \tunsigned int\t\t\tacl_pgbase;\n \tstruct page **\t\t\tacl_pages;\n+\tstruct page *\t\t\tacl_scratch;\n \tstruct nfs4_sequence_args \tseq_args;\n };\n \n+/* getxattr ACL interface flags */\n+#define NFS4_ACL_LEN_REQUEST\t0x0001\t/* zero length getxattr buffer */\n struct nfs_getaclres {\n \tsize_t\t\t\t\tacl_len;\n+\tsize_t\t\t\t\tacl_data_offset;\n+\tint\t\t\t\tacl_flags;\n \tstruct nfs4_sequence_res\tseq_res;\n };\n ""}<_**next**_>{""sha"": ""af70af3335461ee587d23a8567a9abdb9cc23eb9"", ""filename"": ""include/linux/sunrpc/xdr.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/sunrpc/xdr.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/sunrpc/xdr.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sunrpc/xdr.h?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -191,6 +191,8 @@ extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n+extern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,\n+\t\t\t     size_t len);\n \n /*\n  * Provide some simple tools for XDR buffer overflow-checking etc.""}<_**next**_>{""sha"": ""593f4c605305d7b0a51465ae42b09a7eaa6fcadd"", ""filename"": ""net/sunrpc/xdr.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/net/sunrpc/xdr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/net/sunrpc/xdr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sunrpc/xdr.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -296,7 +296,7 @@ _copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n  * Copies data into an arbitrary memory location from an array of pages\n  * The copy is assumed to be non-overlapping.\n  */\n-static void\n+void\n _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n {\n \tstruct page **pgfrom;\n@@ -324,6 +324,7 @@ _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n \n \t} while ((len -= copy) != 0);\n }\n+EXPORT_SYMBOL_GPL(_copy_from_pages);\n \n /*\n  * xdr_shrink_bufhead""}","static int decode_setattr(struct xdr_stream *xdr)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_SETATTR);
	if (status)
		return status;
	p = xdr_inline_decode(xdr, 4);
	if (unlikely(!p))
		goto out_overflow;
	bmlen = be32_to_cpup(p);
	p = xdr_inline_decode(xdr, bmlen << 2);
	if (likely(p))
		return 0;
out_overflow:
	print_overflow_msg(__func__, xdr);
	return -EIO;
}
","static int decode_setattr(struct xdr_stream *xdr)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_SETATTR);
	if (status)
		return status;
	p = xdr_inline_decode(xdr, 4);
	if (unlikely(!p))
		goto out_overflow;
	bmlen = be32_to_cpup(p);
	p = xdr_inline_decode(xdr, bmlen << 2);
	if (likely(p))
		return 0;
out_overflow:
	print_overflow_msg(__func__, xdr);
	return -EIO;
}
",C,,,,"@@ -2517,11 +2517,13 @@ static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,
 	encode_compound_hdr(xdr, req, &hdr);
 	encode_sequence(xdr, &args->seq_args, &hdr);
 	encode_putfh(xdr, args->fh, &hdr);
-	replen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;
+	replen = hdr.replen + op_decode_hdr_maxsz + 1;
 	encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);
 
 	xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
 		args->acl_pages, args->acl_pgbase, args->acl_len);
+	xdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);
+
 	encode_nops(&hdr);
 }
 
@@ -4957,17 +4959,18 @@ decode_restorefh(struct xdr_stream *xdr)
 }
 
 static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,
-		size_t *acl_len)
+			 struct nfs_getaclres *res)
 {
-	__be32 *savep;
+	__be32 *savep, *bm_p;
 	uint32_t attrlen,
 		 bitmap[3] = {0};
 	struct kvec *iov = req->rq_rcv_buf.head;
 	int status;
 
-	*acl_len = 0;
+	res->acl_len = 0;
 	if ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)
 		goto out;
+	bm_p = xdr->p;
 	if ((status = decode_attr_bitmap(xdr, bitmap)) != 0)
 		goto out;
 	if ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)
@@ -4979,18 +4982,30 @@ static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,
 		size_t hdrlen;
 		u32 recvd;
 
+		/* The bitmap (xdr len + bitmaps) and the attr xdr len words
+		 * are stored with the acl data to handle the problem of
+		 * variable length bitmaps.*/
+		xdr->p = bm_p;
+		res->acl_data_offset = be32_to_cpup(bm_p) + 2;
+		res->acl_data_offset <<= 2;
+
 		/* We ignore &savep and don't do consistency checks on
 		 * the attr length.  Let userspace figure it out.... */
 		hdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;
+		attrlen += res->acl_data_offset;
 		recvd = req->rq_rcv_buf.len - hdrlen;
 		if (attrlen > recvd) {
-			dprintk(""NFS: server cheating in getattr""
-					"" acl reply: attrlen %u > recvd %u\n"",
+			if (res->acl_flags & NFS4_ACL_LEN_REQUEST) {
+				/* getxattr interface called with a NULL buf */
+				res->acl_len = attrlen;
+				goto out;
+			}
+			dprintk(""NFS: acl reply: attrlen %u > recvd %u\n"",
 					attrlen, recvd);
 			return -EINVAL;
 		}
 		xdr_read_pages(xdr, attrlen);
-		*acl_len = attrlen;
+		res->acl_len = attrlen;
 	} else
 		status = -EOPNOTSUPP;
 
@@ -6028,7 +6043,7 @@ nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,
 	status = decode_putfh(xdr);
 	if (status)
 		goto out;
-	status = decode_getacl(xdr, rqstp, &res->acl_len);
+	status = decode_getacl(xdr, rqstp, res);
 
 out:
 	return status;",linux,bf118a342f10dafe44b14451a1392c3254629a1f,3476f114addb7b96912840a234702f660a1f460b,0,"static int decode_setattr(struct xdr_stream *xdr)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_SETATTR);
	if (status)
		return status;
	p = xdr_inline_decode(xdr, 4);
	if (unlikely(!p))
		goto out_overflow;
	bmlen = be32_to_cpup(p);
	p = xdr_inline_decode(xdr, bmlen << 2);
	if (likely(p))
		return 0;
out_overflow:
	print_overflow_msg(__func__, xdr);
	return -EIO;
}
"
135111,,Remote,Not required,Partial,CVE-2015-6767,https://www.cvedetails.com/cve/CVE-2015-6767/,,Low,Partial,Partial,,2015-12-05,7.5,Use-after-free vulnerability in content/browser/appcache/appcache_dispatcher_host.cc in the AppCache implementation in Google Chrome before 47.0.2526.73 allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging incorrect pointer maintenance associated with certain callbacks.,2017-09-13,DoS ,0,https://github.com/chromium/chromium/commit/4b5eefe562bd45c059f5dd93079450db5610788a,4b5eefe562bd45c059f5dd93079450db5610788a,"AppCache: Use WeakPtr<> to fix a potential uaf bug.

BUG=554908

Review URL: https://codereview.chromium.org/1441683004

Cr-Commit-Position: refs/heads/master@{#359930}",0,content/browser/appcache/appcache_dispatcher_host.cc,"{""sha"": ""6a864f7dff105ed03fa52a021c47f2388691b38a"", ""filename"": ""content/browser/appcache/appcache_dispatcher_host.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/4b5eefe562bd45c059f5dd93079450db5610788a/content/browser/appcache/appcache_dispatcher_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4b5eefe562bd45c059f5dd93079450db5610788a/content/browser/appcache/appcache_dispatcher_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/appcache/appcache_dispatcher_host.cc?ref=4b5eefe562bd45c059f5dd93079450db5610788a"", ""patch"": ""@@ -19,7 +19,8 @@ AppCacheDispatcherHost::AppCacheDispatcherHost(\n     : BrowserMessageFilter(AppCacheMsgStart),\n       appcache_service_(appcache_service),\n       frontend_proxy_(this),\n-      process_id_(process_id) {\n+      process_id_(process_id),\n+      weak_factory_(this) {\n }\n \n void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {\n@@ -28,13 +29,13 @@ void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {\n         appcache_service_.get(), &frontend_proxy_, process_id_);\n     get_status_callback_ =\n         base::Bind(&AppCacheDispatcherHost::GetStatusCallback,\n-                   base::Unretained(this));\n+                    weak_factory_.GetWeakPtr());\n     start_update_callback_ =\n         base::Bind(&AppCacheDispatcherHost::StartUpdateCallback,\n-                   base::Unretained(this));\n+                    weak_factory_.GetWeakPtr());\n     swap_cache_callback_ =\n         base::Bind(&AppCacheDispatcherHost::SwapCacheCallback,\n-                   base::Unretained(this));\n+                    weak_factory_.GetWeakPtr());\n   }\n }\n ""}<_**next**_>{""sha"": ""f8909a88125a49ffc17087eac6727398e4485890"", ""filename"": ""content/browser/appcache/appcache_dispatcher_host.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/4b5eefe562bd45c059f5dd93079450db5610788a/content/browser/appcache/appcache_dispatcher_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/4b5eefe562bd45c059f5dd93079450db5610788a/content/browser/appcache/appcache_dispatcher_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/appcache/appcache_dispatcher_host.h?ref=4b5eefe562bd45c059f5dd93079450db5610788a"", ""patch"": ""@@ -9,6 +9,7 @@\n \n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/process/process.h\""\n #include \""content/browser/appcache/appcache_backend_impl.h\""\n #include \""content/browser/appcache/appcache_frontend_proxy.h\""\n@@ -69,6 +70,8 @@ class AppCacheDispatcherHost : public BrowserMessageFilter {\n   // The corresponding ChildProcessHost object's id().\n   int process_id_;\n \n+  base::WeakPtrFactory<AppCacheDispatcherHost> weak_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(AppCacheDispatcherHost);\n };\n ""}","void AppCacheDispatcherHost::OnSelectCacheForWorker(
    int host_id, int parent_process_id, int parent_host_id) {
  if (appcache_service_.get()) {
    if (!backend_impl_.SelectCacheForWorker(
            host_id, parent_process_id, parent_host_id)) {
      bad_message::ReceivedBadMessage(
          this, bad_message::ACDH_SELECT_CACHE_FOR_WORKER);
    }
  } else {
    frontend_proxy_.OnCacheSelected(host_id, AppCacheInfo());
  }
}
","void AppCacheDispatcherHost::OnSelectCacheForWorker(
    int host_id, int parent_process_id, int parent_host_id) {
  if (appcache_service_.get()) {
    if (!backend_impl_.SelectCacheForWorker(
            host_id, parent_process_id, parent_host_id)) {
      bad_message::ReceivedBadMessage(
          this, bad_message::ACDH_SELECT_CACHE_FOR_WORKER);
    }
  } else {
    frontend_proxy_.OnCacheSelected(host_id, AppCacheInfo());
  }
}
",C,,,,"@@ -19,7 +19,8 @@ AppCacheDispatcherHost::AppCacheDispatcherHost(
     : BrowserMessageFilter(AppCacheMsgStart),
       appcache_service_(appcache_service),
       frontend_proxy_(this),
-      process_id_(process_id) {
+      process_id_(process_id),
+      weak_factory_(this) {
 }
 
 void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {
@@ -28,13 +29,13 @@ void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {
         appcache_service_.get(), &frontend_proxy_, process_id_);
     get_status_callback_ =
         base::Bind(&AppCacheDispatcherHost::GetStatusCallback,
-                   base::Unretained(this));
+                    weak_factory_.GetWeakPtr());
     start_update_callback_ =
         base::Bind(&AppCacheDispatcherHost::StartUpdateCallback,
-                   base::Unretained(this));
+                    weak_factory_.GetWeakPtr());
     swap_cache_callback_ =
         base::Bind(&AppCacheDispatcherHost::SwapCacheCallback,
-                   base::Unretained(this));
+                    weak_factory_.GetWeakPtr());
   }
 }
 ",Chrome,4b5eefe562bd45c059f5dd93079450db5610788a,161b6ce8abea9c3aaa5d07eda2b0767ae9d48f02,0,"void AppCacheDispatcherHost::OnSelectCacheForWorker(
    int host_id, int parent_process_id, int parent_host_id) {
  if (appcache_service_.get()) {
    if (!backend_impl_.SelectCacheForWorker(
            host_id, parent_process_id, parent_host_id)) {
      bad_message::ReceivedBadMessage(
          this, bad_message::ACDH_SELECT_CACHE_FOR_WORKER);
    }
  } else {
    frontend_proxy_.OnCacheSelected(host_id, AppCacheInfo());
  }
}
"
72177,,Local,Not required,Complete,CVE-2016-10012,https://www.cvedetails.com/cve/CVE-2016-10012/,CWE-119,Low,Complete,Complete,,2017-01-04,7.2,"The shared memory manager (associated with pre-authentication compression) in sshd in OpenSSH before 7.4 does not ensure that a bounds check is enforced by all compilers, which might allows local users to gain privileges by leveraging access to a sandboxed privilege-separation process, related to the m_zback and m_zlib data structures.",2018-09-11,Overflow +Priv ,0,https://github.com/openbsd/src/commit/3095060f479b86288e31c79ecbc5131a66bcd2f9,3095060f479b86288e31c79ecbc5131a66bcd2f9,"Remove support for pre-authentication compression. Doing compression
early in the protocol probably seemed reasonable in the 1990s, but
today it's clearly a bad idea in terms of both cryptography (cf.
multiple compression oracle attacks in TLS) and attack surface.

Moreover, to support it across privilege-separation zlib needed
the assistance of a complex shared-memory manager that made the
required attack surface considerably larger.

Prompted by Guido Vranken pointing out a compiler-elided security
check in the shared memory manager found by Stack
(http://css.csail.mit.edu/stack/); ok deraadt@ markus@

NB. pre-auth authentication has been disabled by default in sshd
for >10 years.",0,usr.bin/ssh/monitor.c,"{""sha"": ""8421659f9c5ff34f13065cbb531ff3c30c14b077"", ""filename"": ""usr.bin/ssh/monitor.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 47, ""changes"": 48, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/monitor.c?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: monitor.c,v 1.165 2016/09/05 13:57:31 djm Exp $ */\n+/* $OpenBSD: monitor.c,v 1.166 2016/09/28 16:33:06 djm Exp $ */\n /*\n  * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n  * Copyright 2002 Markus Friedl <markus@openbsd.org>\n@@ -70,7 +70,6 @@\n #include \""misc.h\""\n #include \""servconf.h\""\n #include \""monitor.h\""\n-#include \""monitor_mm.h\""\n #ifdef GSSAPI\n #include \""ssh-gss.h\""\n #endif\n@@ -335,31 +334,6 @@ monitor_child_postauth(struct monitor *pmonitor)\n \t\tmonitor_read(pmonitor, mon_dispatch, NULL);\n }\n \n-void\n-monitor_sync(struct monitor *pmonitor)\n-{\n-\tif (options.compression) {\n-\t\t/* The member allocation is not visible, so sync it */\n-\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n-\t}\n-}\n-\n-/* Allocation functions for zlib */\n-static void *\n-mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n-{\n-\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n-\t\tfatal(\""%s: mm_zalloc(%u, %u)\"", __func__, ncount, size);\n-\n-\treturn mm_malloc(mm, size * ncount);\n-}\n-\n-static void\n-mm_zfree(struct mm_master *mm, void *address)\n-{\n-\tmm_free(mm, address);\n-}\n-\n static int\n monitor_read_log(struct monitor *pmonitor)\n {\n@@ -1292,13 +1266,6 @@ monitor_apply_keystate(struct monitor *pmonitor)\n \t\tkex->host_key_index=&get_hostkey_index;\n \t\tkex->sign = sshd_hostkey_sign;\n \t}\n-\n-\t/* Update with new address */\n-\tif (options.compression) {\n-\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n-\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n-\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n-\t}\n }\n \n /* This function requries careful sanity checking */\n@@ -1351,24 +1318,11 @@ monitor_openfds(struct monitor *mon, int do_logfds)\n struct monitor *\n monitor_init(void)\n {\n-\tstruct ssh *ssh = active_state;\t\t\t/* XXX */\n \tstruct monitor *mon;\n \n \tmon = xcalloc(1, sizeof(*mon));\n-\n \tmonitor_openfds(mon, 1);\n \n-\t/* Used to share zlib space across processes */\n-\tif (options.compression) {\n-\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n-\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n-\n-\t\t/* Compression needs to share state across borders */\n-\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n-\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n-\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n-\t}\n-\n \treturn mon;\n }\n ""}<_**next**_>{""sha"": ""5350770e7f9ef946fb5d96d55d198671a5f6ac80"", ""filename"": ""usr.bin/ssh/monitor.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 5, ""changes"": 6, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/monitor.h?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: monitor.h,v 1.19 2015/01/19 19:52:16 markus Exp $ */\n+/* $OpenBSD: monitor.h,v 1.20 2016/09/28 16:33:07 djm Exp $ */\n \n /*\n  * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n@@ -58,21 +58,17 @@ enum monitor_reqtype {\n \tMONITOR_REQ_TERM = 50,\n };\n \n-struct mm_master;\n struct monitor {\n \tint\t\t\t m_recvfd;\n \tint\t\t\t m_sendfd;\n \tint\t\t\t m_log_recvfd;\n \tint\t\t\t m_log_sendfd;\n-\tstruct mm_master\t*m_zback;\n-\tstruct mm_master\t*m_zlib;\n \tstruct kex\t\t**m_pkex;\n \tpid_t\t\t\t m_pid;\n };\n \n struct monitor *monitor_init(void);\n void monitor_reinit(struct monitor *);\n-void monitor_sync(struct monitor *);\n \n struct Authctxt;\n void monitor_child_preauth(struct Authctxt *, struct monitor *);""}<_**next**_>{""sha"": ""a629165ed79ef88ab9c09e07b7d5113ba71af02d"", ""filename"": ""usr.bin/ssh/monitor_mm.c"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 347, ""changes"": 347, ""blob_url"": ""https://github.com/openbsd/src/blob/f9b0f55cad1a17c034205a84bfd39bc774726ffd/usr.bin/ssh/monitor_mm.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/f9b0f55cad1a17c034205a84bfd39bc774726ffd/usr.bin/ssh/monitor_mm.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/monitor_mm.c?ref=f9b0f55cad1a17c034205a84bfd39bc774726ffd"", ""patch"": ""@@ -1,347 +0,0 @@\n-/* $OpenBSD: monitor_mm.c,v 1.21 2015/02/06 23:21:59 millert Exp $ */\n-/*\n- * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-#include <sys/types.h>\n-#include <sys/mman.h>\n-#include <sys/tree.h>\n-\n-#include <errno.h>\n-#include <stdarg.h>\n-#include <stddef.h>\n-#include <stdint.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \""xmalloc.h\""\n-#include \""ssh.h\""\n-#include \""log.h\""\n-#include \""monitor_mm.h\""\n-\n-static int\n-mm_compare(struct mm_share *a, struct mm_share *b)\n-{\n-\tptrdiff_t diff = (char *)a->address - (char *)b->address;\n-\n-\tif (diff == 0)\n-\t\treturn (0);\n-\telse if (diff < 0)\n-\t\treturn (-1);\n-\telse\n-\t\treturn (1);\n-}\n-\n-RB_GENERATE(mmtree, mm_share, next, mm_compare)\n-\n-static struct mm_share *\n-mm_make_entry(struct mm_master *mm, struct mmtree *head,\n-    void *address, size_t size)\n-{\n-\tstruct mm_share *tmp, *tmp2;\n-\n-\tif (mm->mmalloc == NULL)\n-\t\ttmp = xcalloc(1, sizeof(struct mm_share));\n-\telse\n-\t\ttmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));\n-\ttmp->address = address;\n-\ttmp->size = size;\n-\n-\ttmp2 = RB_INSERT(mmtree, head, tmp);\n-\tif (tmp2 != NULL)\n-\t\tfatal(\""mm_make_entry(%p): double address %p->%p(%zu)\"",\n-\t\t    mm, tmp2, address, size);\n-\n-\treturn (tmp);\n-}\n-\n-/* Creates a shared memory area of a certain size */\n-\n-struct mm_master *\n-mm_create(struct mm_master *mmalloc, size_t size)\n-{\n-\tvoid *address;\n-\tstruct mm_master *mm;\n-\n-\tif (mmalloc == NULL)\n-\t\tmm = xcalloc(1, sizeof(struct mm_master));\n-\telse\n-\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n-\n-\t/*\n-\t * If the memory map has a mm_master it can be completely\n-\t * shared including authentication between the child\n-\t * and the client.\n-\t */\n-\tmm->mmalloc = mmalloc;\n-\n-\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n-\t    -1, 0);\n-\tif (address == MAP_FAILED)\n-\t\tfatal(\""mmap(%zu): %s\"", size, strerror(errno));\n-\n-\tmm->address = address;\n-\tmm->size = size;\n-\n-\tRB_INIT(&mm->rb_free);\n-\tRB_INIT(&mm->rb_allocated);\n-\n-\tmm_make_entry(mm, &mm->rb_free, address, size);\n-\n-\treturn (mm);\n-}\n-\n-/* Frees either the allocated or the free list */\n-\n-static void\n-mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n-{\n-\tstruct mm_share *mms, *next;\n-\n-\tfor (mms = RB_ROOT(head); mms; mms = next) {\n-\t\tnext = RB_NEXT(mmtree, head, mms);\n-\t\tRB_REMOVE(mmtree, head, mms);\n-\t\tif (mmalloc == NULL)\n-\t\t\tfree(mms);\n-\t\telse\n-\t\t\tmm_free(mmalloc, mms);\n-\t}\n-}\n-\n-/* Destroys a memory mapped area */\n-\n-void\n-mm_destroy(struct mm_master *mm)\n-{\n-\tmm_freelist(mm->mmalloc, &mm->rb_free);\n-\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n-\n-\tif (munmap(mm->address, mm->size) == -1)\n-\t\tfatal(\""munmap(%p, %zu): %s\"", mm->address, mm->size,\n-\t\t    strerror(errno));\n-\tif (mm->mmalloc == NULL)\n-\t\tfree(mm);\n-\telse\n-\t\tmm_free(mm->mmalloc, mm);\n-}\n-\n-void *\n-mm_xmalloc(struct mm_master *mm, size_t size)\n-{\n-\tvoid *address;\n-\n-\taddress = mm_malloc(mm, size);\n-\tif (address == NULL)\n-\t\tfatal(\""%s: mm_malloc(%zu)\"", __func__, size);\n-\tmemset(address, 0, size);\n-\treturn (address);\n-}\n-\n-\n-/* Allocates data from a memory mapped area */\n-\n-void *\n-mm_malloc(struct mm_master *mm, size_t size)\n-{\n-\tstruct mm_share *mms, *tmp;\n-\n-\tif (size == 0)\n-\t\tfatal(\""mm_malloc: try to allocate 0 space\"");\n-\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n-\t\tfatal(\""mm_malloc: size too big\"");\n-\n-\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n-\n-\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n-\t\tif (mms->size >= size)\n-\t\t\tbreak;\n-\t}\n-\n-\tif (mms == NULL)\n-\t\treturn (NULL);\n-\n-\t/* Debug */\n-\tmemset(mms->address, 0xd0, size);\n-\n-\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n-\n-\t/* Does not change order in RB tree */\n-\tmms->size -= size;\n-\tmms->address = (char *)mms->address + size;\n-\n-\tif (mms->size == 0) {\n-\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n-\t\tif (mm->mmalloc == NULL)\n-\t\t\tfree(mms);\n-\t\telse\n-\t\t\tmm_free(mm->mmalloc, mms);\n-\t}\n-\n-\treturn (tmp->address);\n-}\n-\n-/* Frees memory in a memory mapped area */\n-\n-void\n-mm_free(struct mm_master *mm, void *address)\n-{\n-\tstruct mm_share *mms, *prev, tmp;\n-\n-\ttmp.address = address;\n-\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n-\tif (mms == NULL)\n-\t\tfatal(\""mm_free(%p): can not find %p\"", mm, address);\n-\n-\t/* Debug */\n-\tmemset(mms->address, 0xd0, mms->size);\n-\n-\t/* Remove from allocated list and insert in free list */\n-\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n-\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n-\t\tfatal(\""mm_free(%p): double address %p\"", mm, address);\n-\n-\t/* Find previous entry */\n-\tprev = mms;\n-\tif (RB_LEFT(prev, next)) {\n-\t\tprev = RB_LEFT(prev, next);\n-\t\twhile (RB_RIGHT(prev, next))\n-\t\t\tprev = RB_RIGHT(prev, next);\n-\t} else {\n-\t\tif (RB_PARENT(prev, next) &&\n-\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n-\t\t\tprev = RB_PARENT(prev, next);\n-\t\telse {\n-\t\t\twhile (RB_PARENT(prev, next) &&\n-\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n-\t\t\t\tprev = RB_PARENT(prev, next);\n-\t\t\tprev = RB_PARENT(prev, next);\n-\t\t}\n-\t}\n-\n-\t/* Check if range does not overlap */\n-\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n-\t\tfatal(\""mm_free: memory corruption: %p(%zu) > %p\"",\n-\t\t    prev->address, prev->size, address);\n-\n-\t/* See if we can merge backwards */\n-\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n-\t\tprev->size += mms->size;\n-\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n-\t\tif (mm->mmalloc == NULL)\n-\t\t\tfree(mms);\n-\t\telse\n-\t\t\tmm_free(mm->mmalloc, mms);\n-\t} else\n-\t\tprev = mms;\n-\n-\tif (prev == NULL)\n-\t\treturn;\n-\n-\t/* Check if we can merge forwards */\n-\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n-\tif (mms == NULL)\n-\t\treturn;\n-\n-\tif (MM_ADDRESS_END(prev) > mms->address)\n-\t\tfatal(\""mm_free: memory corruption: %p < %p(%zu)\"",\n-\t\t    mms->address, prev->address, prev->size);\n-\tif (MM_ADDRESS_END(prev) != mms->address)\n-\t\treturn;\n-\n-\tprev->size += mms->size;\n-\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n-\n-\tif (mm->mmalloc == NULL)\n-\t\tfree(mms);\n-\telse\n-\t\tmm_free(mm->mmalloc, mms);\n-}\n-\n-static void\n-mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n-    struct mm_master *mm, struct mm_master *mmold)\n-{\n-\tstruct mm_master *mmalloc = mm->mmalloc;\n-\tstruct mm_share *mms, *new;\n-\n-\t/* Sync free list */\n-\tRB_FOREACH(mms, mmtree, oldtree) {\n-\t\t/* Check the values */\n-\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n-\t\tmm_memvalid(mm, mms->address, mms->size);\n-\n-\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n-\t\tmemcpy(new, mms, sizeof(struct mm_share));\n-\t\tRB_INSERT(mmtree, newtree, new);\n-\t}\n-}\n-\n-void\n-mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)\n-{\n-\tstruct mm_master *mm;\n-\tstruct mm_master *mmalloc;\n-\tstruct mm_master *mmold;\n-\tstruct mmtree rb_free, rb_allocated;\n-\n-\tdebug3(\""%s: Share sync\"", __func__);\n-\n-\tmm = *pmm;\n-\tmmold = mm->mmalloc;\n-\tmm_memvalid(mmold, mm, sizeof(*mm));\n-\n-\tmmalloc = mm_create(NULL, mm->size);\n-\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n-\tmemcpy(mm, *pmm, sizeof(struct mm_master));\n-\tmm->mmalloc = mmalloc;\n-\n-\trb_free = mm->rb_free;\n-\trb_allocated = mm->rb_allocated;\n-\n-\tRB_INIT(&mm->rb_free);\n-\tRB_INIT(&mm->rb_allocated);\n-\n-\tmm_sync_list(&rb_free, &mm->rb_free, mm, mmold);\n-\tmm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);\n-\n-\tmm_destroy(mmold);\n-\n-\t*pmm = mm;\n-\t*pmmalloc = mmalloc;\n-\n-\tdebug3(\""%s: Share sync end\"", __func__);\n-}\n-\n-void\n-mm_memvalid(struct mm_master *mm, void *address, size_t size)\n-{\n-\tvoid *end = (char *)address + size;\n-\n-\tif (address < mm->address)\n-\t\tfatal(\""mm_memvalid: address too small: %p\"", address);\n-\tif (end < address)\n-\t\tfatal(\""mm_memvalid: end < address: %p < %p\"", end, address);\n-\tif (end > MM_ADDRESS_END(mm))\n-\t\tfatal(\""mm_memvalid: address too large: %p\"", address);\n-}""}<_**next**_>{""sha"": ""f1fae7e3bf53377a630ea72bd635fa722c12fbc8"", ""filename"": ""usr.bin/ssh/monitor_mm.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 62, ""changes"": 62, ""blob_url"": ""https://github.com/openbsd/src/blob/f9b0f55cad1a17c034205a84bfd39bc774726ffd/usr.bin/ssh/monitor_mm.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/f9b0f55cad1a17c034205a84bfd39bc774726ffd/usr.bin/ssh/monitor_mm.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/monitor_mm.h?ref=f9b0f55cad1a17c034205a84bfd39bc774726ffd"", ""patch"": ""@@ -1,62 +0,0 @@\n-/* $OpenBSD: monitor_mm.h,v 1.6 2014/01/04 17:50:55 tedu Exp $ */\n-\n-/*\n- * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-#ifndef _MM_H_\n-#define _MM_H_\n-\n-struct mm_share {\n-\tRB_ENTRY(mm_share) next;\n-\tvoid *address;\n-\tsize_t size;\n-};\n-\n-struct mm_master {\n-\tRB_HEAD(mmtree, mm_share) rb_free;\n-\tstruct mmtree rb_allocated;\n-\tvoid *address;\n-\tsize_t size;\n-\n-\tstruct mm_master *mmalloc;\t/* Used to completely share */\n-};\n-\n-RB_PROTOTYPE(mmtree, mm_share, next, mm_compare)\n-\n-#define MM_MINSIZE\t\t128\n-\n-#define MM_ADDRESS_END(x)\t(void *)((char *)(x)->address + (x)->size)\n-\n-struct mm_master *mm_create(struct mm_master *, size_t);\n-void mm_destroy(struct mm_master *);\n-\n-void mm_share_sync(struct mm_master **, struct mm_master **);\n-\n-void *mm_malloc(struct mm_master *, size_t);\n-void *mm_xmalloc(struct mm_master *, size_t);\n-void mm_free(struct mm_master *, void *);\n-\n-void mm_memvalid(struct mm_master *, void *, size_t);\n-#endif /* _MM_H_ */""}<_**next**_>{""sha"": ""995584f4703748e923f047eb262d88146f6679d0"", ""filename"": ""usr.bin/ssh/monitor_wrap.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 4, ""changes"": 5, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor_wrap.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/monitor_wrap.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/monitor_wrap.h?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: monitor_wrap.h,v 1.31 2016/08/13 17:47:41 markus Exp $ */\n+/* $OpenBSD: monitor_wrap.h,v 1.32 2016/09/28 16:33:07 djm Exp $ */\n \n /*\n  * Copyright 2002 Niels Provos <provos@citi.umich.edu>\n@@ -76,7 +76,4 @@ void mm_send_keystate(struct monitor*);\n int mm_bsdauth_query(void *, char **, char **, u_int *, char ***, u_int **);\n int mm_bsdauth_respond(void *, u_int, char **);\n \n-/* zlib allocation hooks */\n-void mm_init_compression(struct mm_master *);\n-\n #endif /* _MM_WRAP_H_ */""}<_**next**_>{""sha"": ""908dd463ce95afa90b8004e52ab21fe6fca00ce6"", ""filename"": ""usr.bin/ssh/myproposal.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/myproposal.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/myproposal.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/myproposal.h?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: myproposal.h,v 1.53 2016/09/22 17:52:53 djm Exp $ */\n+/* $OpenBSD: myproposal.h,v 1.54 2016/09/28 16:33:07 djm Exp $ */\n \n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n@@ -110,7 +110,7 @@\n \n #endif /* WITH_OPENSSL */\n \n-#define\tKEX_DEFAULT_COMP\t\""none,zlib@openssh.com,zlib\""\n+#define\tKEX_DEFAULT_COMP\t\""none,zlib@openssh.com\""\n #define\tKEX_DEFAULT_LANG\t\""\""\n \n #define KEX_CLIENT \\""}<_**next**_>{""sha"": ""abb7b46725963ab404a271a64ee612657640ded8"", ""filename"": ""usr.bin/ssh/opacket.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/opacket.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/opacket.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/opacket.h?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -132,9 +132,6 @@ void\t packet_read_expect(int expected_type);\n \tssh_packet_get_input(active_state)\n #define packet_get_output() \\\n \tssh_packet_get_output(active_state)\n-#define packet_set_compress_hooks(ctx, allocfunc, freefunc) \\\n-\tssh_packet_set_compress_hooks(active_state, ctx, \\\n-\t    allocfunc, freefunc);\n #define packet_check_eom() \\\n \tssh_packet_check_eom(active_state)\n #define set_newkeys(mode) \\""}<_**next**_>{""sha"": ""36f7fdff61bc9b50135b81a57aa9ff8793745189"", ""filename"": ""usr.bin/ssh/packet.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 98, ""changes"": 104, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/packet.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/packet.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/packet.c?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: packet.c,v 1.238 2016/09/19 19:02:19 markus Exp $ */\n+/* $OpenBSD: packet.c,v 1.239 2016/09/28 16:33:07 djm Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -745,86 +745,6 @@ uncompress_buffer(struct ssh *ssh, struct sshbuf *in, struct sshbuf *out)\n \t/* NOTREACHED */\n }\n \n-/* Serialise compression state into a blob for privsep */\n-static int\n-ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)\n-{\n-\tstruct session_state *state = ssh->state;\n-\tstruct sshbuf *b;\n-\tint r;\n-\n-\tif ((b = sshbuf_new()) == NULL)\n-\t\treturn SSH_ERR_ALLOC_FAIL;\n-\tif (state->compression_in_started) {\n-\t\tif ((r = sshbuf_put_string(b, &state->compression_in_stream,\n-\t\t    sizeof(state->compression_in_stream))) != 0)\n-\t\t\tgoto out;\n-\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n-\t\tgoto out;\n-\tif (state->compression_out_started) {\n-\t\tif ((r = sshbuf_put_string(b, &state->compression_out_stream,\n-\t\t    sizeof(state->compression_out_stream))) != 0)\n-\t\t\tgoto out;\n-\t} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)\n-\t\tgoto out;\n-\tr = sshbuf_put_stringb(m, b);\n- out:\n-\tsshbuf_free(b);\n-\treturn r;\n-}\n-\n-/* Deserialise compression state from a blob for privsep */\n-static int\n-ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n-{\n-\tstruct session_state *state = ssh->state;\n-\tstruct sshbuf *b = NULL;\n-\tint r;\n-\tconst u_char *inblob, *outblob;\n-\tsize_t inl, outl;\n-\n-\tif ((r = sshbuf_froms(m, &b)) != 0)\n-\t\tgoto out;\n-\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n-\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n-\t\tgoto out;\n-\tif (inl == 0)\n-\t\tstate->compression_in_started = 0;\n-\telse if (inl != sizeof(state->compression_in_stream)) {\n-\t\tr = SSH_ERR_INTERNAL_ERROR;\n-\t\tgoto out;\n-\t} else {\n-\t\tstate->compression_in_started = 1;\n-\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n-\t}\n-\tif (outl == 0)\n-\t\tstate->compression_out_started = 0;\n-\telse if (outl != sizeof(state->compression_out_stream)) {\n-\t\tr = SSH_ERR_INTERNAL_ERROR;\n-\t\tgoto out;\n-\t} else {\n-\t\tstate->compression_out_started = 1;\n-\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n-\t}\n-\tr = 0;\n- out:\n-\tsshbuf_free(b);\n-\treturn r;\n-}\n-\n-void\n-ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n-    void *(*allocfunc)(void *, u_int, u_int),\n-    void (*freefunc)(void *, void *))\n-{\n-\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n-\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n-\tssh->state->compression_out_stream.opaque = ctx;\n-\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n-\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n-\tssh->state->compression_in_stream.opaque = ctx;\n-}\n-\n /*\n  * Causes any further packets to be encrypted using the given key.  The same\n  * key is used for both sending and reception.  However, both directions are\n@@ -2430,21 +2350,14 @@ ssh_packet_get_output(struct ssh *ssh)\n static int\n ssh_packet_set_postauth(struct ssh *ssh)\n {\n-\tstruct sshcomp *comp;\n-\tint r, mode;\n+\tint r;\n \n \tdebug(\""%s: called\"", __func__);\n \t/* This was set in net child, but is not visible in user child */\n \tssh->state->after_authentication = 1;\n \tssh->state->rekeying = 0;\n-\tfor (mode = 0; mode < MODE_MAX; mode++) {\n-\t\tif (ssh->state->newkeys[mode] == NULL)\n-\t\t\tcontinue;\n-\t\tcomp = &ssh->state->newkeys[mode]->comp;\n-\t\tif (comp && comp->enabled &&\n-\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n-\t\t\treturn r;\n-\t}\n+\tif ((r = ssh_packet_enable_delayed_compress(ssh)) != 0)\n+\t\treturn r;\n \treturn 0;\n }\n \n@@ -2508,7 +2421,6 @@ newkeys_to_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n \t\t\tgoto out;\n \t}\n \tif ((r = sshbuf_put_u32(b, comp->type)) != 0 ||\n-\t    (r = sshbuf_put_u32(b, comp->enabled)) != 0 ||\n \t    (r = sshbuf_put_cstring(b, comp->name)) != 0)\n \t\tgoto out;\n \tr = sshbuf_put_stringb(m, b);\n@@ -2569,9 +2481,7 @@ ssh_packet_get_state(struct ssh *ssh, struct sshbuf *m)\n \t\treturn r;\n \tif (cipher_get_keycontext(state->receive_context, p) != (int)rlen)\n \t\treturn SSH_ERR_INTERNAL_ERROR;\n-\n-\tif ((r = ssh_packet_get_compress_state(m, ssh)) != 0 ||\n-\t    (r = sshbuf_put_stringb(m, state->input)) != 0 ||\n+\tif ((r = sshbuf_put_stringb(m, state->input)) != 0 ||\n \t    (r = sshbuf_put_stringb(m, state->output)) != 0)\n \t\treturn r;\n \n@@ -2625,7 +2535,6 @@ newkeys_from_blob(struct sshbuf *m, struct ssh *ssh, int mode)\n \t\tmac->key_len = maclen;\n \t}\n \tif ((r = sshbuf_get_u32(b, &comp->type)) != 0 ||\n-\t    (r = sshbuf_get_u32(b, (u_int *)&comp->enabled)) != 0 ||\n \t    (r = sshbuf_get_cstring(b, &comp->name, NULL)) != 0)\n \t\tgoto out;\n \tif (enc->name == NULL ||\n@@ -2753,8 +2662,7 @@ ssh_packet_set_state(struct ssh *ssh, struct sshbuf *m)\n \tcipher_set_keycontext(state->send_context, keyout);\n \tcipher_set_keycontext(state->receive_context, keyin);\n \n-\tif ((r = ssh_packet_set_compress_state(ssh, m)) != 0 ||\n-\t    (r = ssh_packet_set_postauth(ssh)) != 0)\n+\tif ((r = ssh_packet_set_postauth(ssh)) != 0)\n \t\treturn r;\n \n \tsshbuf_reset(state->input);""}<_**next**_>{""sha"": ""200e37a4aced1b9aa189b43b6b6c4f5d6a3f8089"", ""filename"": ""usr.bin/ssh/packet.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 6, ""changes"": 7, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/packet.h"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/packet.h"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/packet.h?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: packet.h,v 1.71 2016/03/07 19:02:43 djm Exp $ */\n+/* $OpenBSD: packet.h,v 1.72 2016/09/28 16:33:07 djm Exp $ */\n \n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n@@ -106,11 +106,6 @@ void     ssh_packet_send_debug(struct ssh *, const char *fmt, ...) __attribute__\n int\t ssh_set_newkeys(struct ssh *, int mode);\n void\t ssh_packet_get_bytes(struct ssh *, u_int64_t *, u_int64_t *);\n \n-typedef void *(ssh_packet_comp_alloc_func)(void *, u_int, u_int);\n-typedef void (ssh_packet_comp_free_func)(void *, void *);\n-void\t ssh_packet_set_compress_hooks(struct ssh *, void *,\n-    ssh_packet_comp_alloc_func *, ssh_packet_comp_free_func *);\n-\n int\t ssh_packet_write_poll(struct ssh *);\n int\t ssh_packet_write_wait(struct ssh *);\n int      ssh_packet_have_data_to_write(struct ssh *);""}<_**next**_>{""sha"": ""33faabfaf36ae53c3d0efb465987ec6497f8270f"", ""filename"": ""usr.bin/ssh/servconf.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/servconf.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/servconf.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/servconf.c?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,5 +1,5 @@\n \n-/* $OpenBSD: servconf.c,v 1.295 2016/08/25 23:57:54 djm Exp $ */\n+/* $OpenBSD: servconf.c,v 1.296 2016/09/28 16:33:07 djm Exp $ */\n /*\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n  *                    All rights reserved\n@@ -875,7 +875,7 @@ static const struct multistate multistate_permitrootlogin[] = {\n };\n static const struct multistate multistate_compression[] = {\n \t{ \""delayed\"",\t\t\tCOMP_DELAYED },\n-\t{ \""yes\"",\t\t\tCOMP_ZLIB },\n+\t{ \""yes\"",\t\t\tCOMP_DELAYED },\n \t{ \""no\"",\t\t\t\tCOMP_NONE },\n \t{ NULL, -1 }\n };""}<_**next**_>{""sha"": ""f975accacdca3516a556de5169e62275576f3597"", ""filename"": ""usr.bin/ssh/sshconnect2.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshconnect2.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshconnect2.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sshconnect2.c?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: sshconnect2.c,v 1.248 2016/09/22 02:29:57 dtucker Exp $ */\n+/* $OpenBSD: sshconnect2.c,v 1.249 2016/09/28 16:33:07 djm Exp $ */\n /*\n  * Copyright (c) 2000 Markus Friedl.  All rights reserved.\n  * Copyright (c) 2008 Damien Miller.  All rights reserved.\n@@ -168,7 +168,7 @@ ssh_kex2(char *host, struct sockaddr *hostaddr, u_short port)\n \t    compat_cipher_proposal(options.ciphers);\n \tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n \t    myproposal[PROPOSAL_COMP_ALGS_STOC] = options.compression ?\n-\t    \""zlib@openssh.com,zlib,none\"" : \""none,zlib@openssh.com,zlib\"";\n+\t    \""zlib@openssh.com,none\"" : \""none,zlib@openssh.com\"";\n \tmyproposal[PROPOSAL_MAC_ALGS_CTOS] =\n \t    myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs;\n \tif (options.hostkeyalgorithms != NULL) {""}<_**next**_>{""sha"": ""f57e61869e2a3bce8fc537298ff8388207e5ace4"", ""filename"": ""usr.bin/ssh/sshd.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 9, ""changes"": 10, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshd.c"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshd.c"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sshd.c?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-/* $OpenBSD: sshd.c,v 1.475 2016/08/28 22:28:12 djm Exp $ */\n+/* $OpenBSD: sshd.c,v 1.476 2016/09/28 16:33:07 djm Exp $ */\n /*\n  * Author: Tatu Ylonen <ylo@cs.hut.fi>\n  * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n@@ -96,7 +96,6 @@\n #include \""dispatch.h\""\n #include \""channels.h\""\n #include \""session.h\""\n-#include \""monitor_mm.h\""\n #include \""monitor.h\""\n #ifdef GSSAPI\n #include \""ssh-gss.h\""\n@@ -559,9 +558,6 @@ privsep_preauth(Authctxt *authctxt)\n \t\t\tssh_sandbox_parent_preauth(box, pid);\n \t\tmonitor_child_preauth(authctxt, pmonitor);\n \n-\t\t/* Sync memory */\n-\t\tmonitor_sync(pmonitor);\n-\n \t\t/* Wait for the child's exit status */\n \t\twhile (waitpid(pid, &status, 0) < 0) {\n \t\t\tif (errno == EINTR)\n@@ -1972,10 +1968,6 @@ do_ssh2_kex(void)\n \tif (options.compression == COMP_NONE) {\n \t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n \t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] = \""none\"";\n-\t} else if (options.compression == COMP_DELAYED) {\n-\t\tmyproposal[PROPOSAL_COMP_ALGS_CTOS] =\n-\t\t    myproposal[PROPOSAL_COMP_ALGS_STOC] =\n-\t\t    \""none,zlib@openssh.com\"";\n \t}\n \n \tif (options.rekey_limit || options.rekey_interval)""}<_**next**_>{""sha"": ""979c06180013f768cc75f0208307d437fc35ca80"", ""filename"": ""usr.bin/ssh/sshd/Makefile"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/openbsd/src/blob/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshd/Makefile"", ""raw_url"": ""https://github.com/openbsd/src/raw/3095060f479b86288e31c79ecbc5131a66bcd2f9/usr.bin/ssh/sshd/Makefile"", ""contents_url"": ""https://api.github.com/repos/openbsd/src/contents/usr.bin/ssh/sshd/Makefile?ref=3095060f479b86288e31c79ecbc5131a66bcd2f9"", ""patch"": ""@@ -1,4 +1,4 @@\n-#\t$OpenBSD: Makefile,v 1.89 2016/08/13 17:47:41 markus Exp $\n+#\t$OpenBSD: Makefile,v 1.90 2016/09/28 16:33:07 djm Exp $\n \n .PATH:\t\t${.CURDIR}/..\n .include \""${.CURDIR}/../Makefile.inc\""\n@@ -15,7 +15,7 @@ SRCS=\tsshd.c auth-rhosts.c auth-passwd.c \\\n \tauth2-chall.c groupaccess.c \\\n \tauth-bsdauth.c auth2-hostbased.c auth2-kbdint.c \\\n \tauth2-none.c auth2-passwd.c auth2-pubkey.c \\\n-\tmonitor_mm.c monitor.c monitor_wrap.c \\\n+\tmonitor.c monitor_wrap.c \\\n \tsftp-server.c sftp-common.c \\\n \tsandbox-pledge.c\n ""}","mm_answer_gss_userok(int sock, Buffer *m)
{
	int authenticated;

	if (!options.gss_authentication)
		fatal(""%s: GSSAPI authentication not enabled"", __func__);

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3(""%s: sending result %d"", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);

	auth_method = ""gssapi-with-mic"";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
","mm_answer_gss_userok(int sock, Buffer *m)
{
	int authenticated;

	if (!options.gss_authentication)
		fatal(""%s: GSSAPI authentication not enabled"", __func__);

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3(""%s: sending result %d"", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);

	auth_method = ""gssapi-with-mic"";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
",C,,,,"@@ -1,4 +1,4 @@
-/* $OpenBSD: monitor.c,v 1.165 2016/09/05 13:57:31 djm Exp $ */
+/* $OpenBSD: monitor.c,v 1.166 2016/09/28 16:33:06 djm Exp $ */
 /*
  * Copyright 2002 Niels Provos <provos@citi.umich.edu>
  * Copyright 2002 Markus Friedl <markus@openbsd.org>
@@ -70,7 +70,6 @@
 #include ""misc.h""
 #include ""servconf.h""
 #include ""monitor.h""
-#include ""monitor_mm.h""
 #ifdef GSSAPI
 #include ""ssh-gss.h""
 #endif
@@ -335,31 +334,6 @@ monitor_child_postauth(struct monitor *pmonitor)
 		monitor_read(pmonitor, mon_dispatch, NULL);
 }
 
-void
-monitor_sync(struct monitor *pmonitor)
-{
-	if (options.compression) {
-		/* The member allocation is not visible, so sync it */
-		mm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);
-	}
-}
-
-/* Allocation functions for zlib */
-static void *
-mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)
-{
-	if (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)
-		fatal(""%s: mm_zalloc(%u, %u)"", __func__, ncount, size);
-
-	return mm_malloc(mm, size * ncount);
-}
-
-static void
-mm_zfree(struct mm_master *mm, void *address)
-{
-	mm_free(mm, address);
-}
-
 static int
 monitor_read_log(struct monitor *pmonitor)
 {
@@ -1292,13 +1266,6 @@ monitor_apply_keystate(struct monitor *pmonitor)
 		kex->host_key_index=&get_hostkey_index;
 		kex->sign = sshd_hostkey_sign;
 	}
-
-	/* Update with new address */
-	if (options.compression) {
-		ssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,
-		    (ssh_packet_comp_alloc_func *)mm_zalloc,
-		    (ssh_packet_comp_free_func *)mm_zfree);
-	}
 }
 
 /* This function requries careful sanity checking */
@@ -1351,24 +1318,11 @@ monitor_openfds(struct monitor *mon, int do_logfds)
 struct monitor *
 monitor_init(void)
 {
-	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
-
 	monitor_openfds(mon, 1);
 
-	/* Used to share zlib space across processes */
-	if (options.compression) {
-		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
-		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
-
-		/* Compression needs to share state across borders */
-		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
-		    (ssh_packet_comp_alloc_func *)mm_zalloc,
-		    (ssh_packet_comp_free_func *)mm_zfree);
-	}
-
 	return mon;
 }
 ",src,3095060f479b86288e31c79ecbc5131a66bcd2f9,f9b0f55cad1a17c034205a84bfd39bc774726ffd,0,"mm_answer_gss_userok(int sock, Buffer *m)
{
	int authenticated;

	if (!options.gss_authentication)
		fatal(""%s: GSSAPI authentication not enabled"", __func__);

	authenticated = authctxt->valid && ssh_gssapi_userok(authctxt->user);

	buffer_clear(m);
	buffer_put_int(m, authenticated);

	debug3(""%s: sending result %d"", __func__, authenticated);
	mm_request_send(sock, MONITOR_ANS_GSSUSEROK, m);

	auth_method = ""gssapi-with-mic"";

	/* Monitor loop will terminate if authenticated */
	return (authenticated);
}
"
87031,,Remote,Not required,Partial,CVE-2019-1010251,https://www.cvedetails.com/cve/CVE-2019-1010251/,CWE-20,Low,,,,2019-07-18,5.0,"Open Information Security Foundation Suricata prior to version 4.1.2 is affected by: Denial of Service - DNS detection bypass. The impact is: An attacker can evade a signature detection with a specialy formed network packet. The component is: app-layer-detect-proto.c, decode.c, decode-teredo.c and decode-ipv6.c (https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe, https://github.com/OISF/suricata/pull/3590/commits/8357ef3f8ffc7d99ef6571350724160de356158b). The attack vector is: An attacker can trigger the vulnerability by sending a specifically crafted network request. The fixed version is: 4.1.2.",2019-07-23,DoS Bypass ,0,https://github.com/OISF/suricata/pull/3590/commits/11f3659f64a4e42e90cb3c09fcef66894205aefe,11f3659f64a4e42e90cb3c09fcef66894205aefe,"teredo: be stricter on what to consider valid teredo

Invalid Teredo can lead to valid DNS traffic (or other UDP traffic)
being misdetected as Teredo. This leads to false negatives in the
UDP payload inspection.

Make the teredo code only consider a packet teredo if the encapsulated
data was decoded without any 'invalid' events being set.

Bug #2736.",0,src/decode.c,"{""sha"": ""3f8a52124e5a9f4024685f984c27bbfce75aede4"", ""filename"": ""src/decode-ipv6.c"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 20, ""changes"": 40, ""blob_url"": ""https://github.com/OISF/suricata/blob/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode-ipv6.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode-ipv6.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/decode-ipv6.c?ref=11f3659f64a4e42e90cb3c09fcef66894205aefe"", ""patch"": ""@@ -150,28 +150,28 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n     SCEnter();\n \n     uint8_t *orig_pkt = pkt;\n-    uint8_t nh = 0; /* careful, 0 is actually a real type */\n+    uint8_t nh = IPV6_GET_NH(p); /* careful, 0 is actually a real type */\n     uint16_t hdrextlen = 0;\n-    uint16_t plen;\n+    uint16_t plen = len;\n     char dstopts = 0;\n     char exthdr_fh_done = 0;\n     int hh = 0;\n     int rh = 0;\n     int eh = 0;\n     int ah = 0;\n \n-    nh = IPV6_GET_NH(p);\n-    plen = len;\n-\n     while(1)\n     {\n-        /* No upper layer, but we do have data. Suspicious. */\n-        if (nh == IPPROTO_NONE && plen > 0) {\n-            ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n+        if (nh == IPPROTO_NONE) {\n+            if (plen > 0) {\n+                /* No upper layer, but we do have data. Suspicious. */\n+                ENGINE_SET_EVENT(p, IPV6_DATA_AFTER_NONE_HEADER);\n+            }\n             SCReturn;\n         }\n \n         if (plen < 2) { /* minimal needed in a hdr */\n+            ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n             SCReturn;\n         }\n \n@@ -204,7 +204,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -243,7 +243,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen =  (*(pkt+1) + 1) << 3;\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -288,7 +288,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 if (optslen > plen) {\n                     /* since the packet is long enough (we checked\n                      * plen against hdrlen, the optlen must be malformed. */\n-                    ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                     /* skip past this extension so we can continue parsing the rest\n                      * of the packet */\n                     nh = *pkt;\n@@ -311,7 +311,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                     }\n \n                     if (offset + 1 >= optslen) {\n-                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n@@ -320,7 +320,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n \n                     /* see if the optlen from the packet fits the total optslen */\n                     if ((offset + 1 + ip6_optlen) > optslen) {\n-                        ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                        ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                         break;\n                     }\n \n@@ -339,7 +339,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                         ra->ip6ra_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(ra->ip6ra_value)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -355,7 +355,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                         jumbo->ip6j_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(jumbo->ip6j_payload_len)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -370,7 +370,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                         hao->ip6hao_len  = ip6_optlen;\n \n                         if (ip6_optlen < sizeof(hao->ip6hao_hoa)) {\n-                            ENGINE_SET_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n+                            ENGINE_SET_INVALID_EVENT(p, IPV6_EXTHDR_INVALID_OPTLEN);\n                             break;\n                         }\n \n@@ -422,7 +422,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 uint16_t prev_hdrextlen = hdrextlen;\n                 hdrextlen = sizeof(IPV6FragHdr);\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -468,7 +468,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 IPV6_SET_L4PROTO(p,nh);\n                 hdrextlen = sizeof(IPV6EspHdr);\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -497,7 +497,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n                 SCLogDebug(\""hdrextlen %\""PRIu8, hdrextlen);\n \n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n \n@@ -538,7 +538,7 @@ DecodeIPV6ExtHdrs(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt\n             case IPPROTO_SHIM6:\n                 hdrextlen = 8 + (*(pkt+1) * 8);  /* 8 bytes + length in 8 octet units */\n                 if (hdrextlen > plen) {\n-                    ENGINE_SET_EVENT(p, IPV6_TRUNC_EXTHDR);\n+                    ENGINE_SET_INVALID_EVENT(p, IPV6_TRUNC_EXTHDR);\n                     SCReturn;\n                 }\n                 nh = *pkt;""}<_**next**_>{""sha"": ""887366a61c99aa60574bd2efd7b9065d6f435e0a"", ""filename"": ""src/decode-teredo.c"", ""status"": ""modified"", ""additions"": 16, ""deletions"": 2, ""changes"": 18, ""blob_url"": ""https://github.com/OISF/suricata/blob/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode-teredo.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode-teredo.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/decode-teredo.c?ref=11f3659f64a4e42e90cb3c09fcef66894205aefe"", ""patch"": ""@@ -96,20 +96,34 @@ int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt,\n     /* There is no specific field that we can check to prove that the packet\n      * is a Teredo packet. We've zapped here all the possible Teredo header\n      * and we should have an IPv6 packet at the start pointer.\n-     * We then can only do two checks before sending the encapsulated packets\n+     * We then can only do a few checks before sending the encapsulated packets\n      * to decoding:\n      *  - The packet has a protocol version which is IPv6.\n      *  - The IPv6 length of the packet matches what remains in buffer.\n+     *  - HLIM is 0. This would technically be valid, but still weird.\n+     *  - NH 0 (HOP) and not enough data.\n+     *\n+     *  If all these conditions are met, the tunnel decoder will be called.\n+     *  If the packet gets an invalid event set, it will still be rejected.\n      */\n     if (IP_GET_RAW_VER(start) == 6) {\n         IPV6Hdr *thdr = (IPV6Hdr *)start;\n+\n+        /* ignore hoplimit 0 packets, most likely an artifact of bad detection */\n+        if (IPV6_GET_RAW_HLIM(thdr) == 0)\n+            return TM_ECODE_FAILED;\n+\n+        /* if nh is 0 (HOP) with little data we have a bogus packet */\n+        if (IPV6_GET_RAW_NH(thdr) == 0 && IPV6_GET_RAW_PLEN(thdr) < 8)\n+            return TM_ECODE_FAILED;\n+\n         if (len ==  IPV6_HEADER_LEN +\n                 IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {\n             if (pq != NULL) {\n                 int blen = len - (start - pkt);\n                 /* spawn off tunnel packet */\n                 Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,\n-                                                  DECODE_TUNNEL_IPV6, pq);\n+                                                  DECODE_TUNNEL_IPV6_TEREDO, pq);\n                 if (tp != NULL) {\n                     PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);\n                     /* add the tp to the packet queue. */""}<_**next**_>{""sha"": ""20e7a2cf24cfafb05b3b46a5697109d5a5cee2de"", ""filename"": ""src/decode.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 3, ""changes"": 11, ""blob_url"": ""https://github.com/OISF/suricata/blob/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode.c"", ""raw_url"": ""https://github.com/OISF/suricata/raw/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode.c"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/decode.c?ref=11f3659f64a4e42e90cb3c09fcef66894205aefe"", ""patch"": ""@@ -79,6 +79,7 @@ int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n         case DECODE_TUNNEL_IPV4:\n             return DecodeIPV4(tv, dtv, p, pkt, len, pq);\n         case DECODE_TUNNEL_IPV6:\n+        case DECODE_TUNNEL_IPV6_TEREDO:\n             return DecodeIPV6(tv, dtv, p, pkt, len, pq);\n         case DECODE_TUNNEL_VLAN:\n             return DecodeVLAN(tv, dtv, p, pkt, len, pq);\n@@ -87,7 +88,7 @@ int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,\n         case DECODE_TUNNEL_ERSPAN:\n             return DecodeERSPAN(tv, dtv, p, pkt, len, pq);\n         default:\n-            SCLogInfo(\""FIXME: DecodeTunnel: protocol %\"" PRIu32 \"" not supported.\"", proto);\n+            SCLogDebug(\""FIXME: DecodeTunnel: protocol %\"" PRIu32 \"" not supported.\"", proto);\n             break;\n     }\n     return TM_ECODE_OK;\n@@ -303,8 +304,12 @@ Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *pare\n     ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),\n                        GET_PKT_LEN(p), pq, proto);\n \n-    if (unlikely(ret != TM_ECODE_OK)) {\n-        /* Not a tunnel packet, just a pseudo packet */\n+    if (unlikely(ret != TM_ECODE_OK) ||\n+            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))\n+    {\n+        /* Not a (valid) tunnel packet */\n+        SCLogDebug(\""tunnel packet is invalid\"");\n+\n         p->root = NULL;\n         UNSET_TUNNEL_PKT(p);\n         TmqhOutputPacketpool(tv, p);""}<_**next**_>{""sha"": ""5931304b98a1e0907697e7f7df729aa29ee987cf"", ""filename"": ""src/decode.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/OISF/suricata/blob/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode.h"", ""raw_url"": ""https://github.com/OISF/suricata/raw/11f3659f64a4e42e90cb3c09fcef66894205aefe/src/decode.h"", ""contents_url"": ""https://api.github.com/repos/OISF/suricata/contents/src/decode.h?ref=11f3659f64a4e42e90cb3c09fcef66894205aefe"", ""patch"": ""@@ -905,6 +905,7 @@ enum DecodeTunnelProto {\n     DECODE_TUNNEL_VLAN,\n     DECODE_TUNNEL_IPV4,\n     DECODE_TUNNEL_IPV6,\n+    DECODE_TUNNEL_IPV6_TEREDO,  /**< separate protocol for stricter error handling */\n     DECODE_TUNNEL_PPP,\n };\n ""}","void DecodeUpdatePacketCounters(ThreadVars *tv,
                                const DecodeThreadVars *dtv, const Packet *p)
{
    StatsIncr(tv, dtv->counter_pkts);
    StatsAddUI64(tv, dtv->counter_bytes, GET_PKT_LEN(p));
    StatsAddUI64(tv, dtv->counter_avg_pkt_size, GET_PKT_LEN(p));
    StatsSetUI64(tv, dtv->counter_max_pkt_size, GET_PKT_LEN(p));
}
","void DecodeUpdatePacketCounters(ThreadVars *tv,
                                const DecodeThreadVars *dtv, const Packet *p)
{
    StatsIncr(tv, dtv->counter_pkts);
    StatsAddUI64(tv, dtv->counter_bytes, GET_PKT_LEN(p));
    StatsAddUI64(tv, dtv->counter_avg_pkt_size, GET_PKT_LEN(p));
    StatsSetUI64(tv, dtv->counter_max_pkt_size, GET_PKT_LEN(p));
}
",C,,,,"@@ -79,6 +79,7 @@ int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,
         case DECODE_TUNNEL_IPV4:
             return DecodeIPV4(tv, dtv, p, pkt, len, pq);
         case DECODE_TUNNEL_IPV6:
+        case DECODE_TUNNEL_IPV6_TEREDO:
             return DecodeIPV6(tv, dtv, p, pkt, len, pq);
         case DECODE_TUNNEL_VLAN:
             return DecodeVLAN(tv, dtv, p, pkt, len, pq);
@@ -87,7 +88,7 @@ int DecodeTunnel(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p,
         case DECODE_TUNNEL_ERSPAN:
             return DecodeERSPAN(tv, dtv, p, pkt, len, pq);
         default:
-            SCLogInfo(""FIXME: DecodeTunnel: protocol %"" PRIu32 "" not supported."", proto);
+            SCLogDebug(""FIXME: DecodeTunnel: protocol %"" PRIu32 "" not supported."", proto);
             break;
     }
     return TM_ECODE_OK;
@@ -303,8 +304,12 @@ Packet *PacketTunnelPktSetup(ThreadVars *tv, DecodeThreadVars *dtv, Packet *pare
     ret = DecodeTunnel(tv, dtv, p, GET_PKT_DATA(p),
                        GET_PKT_LEN(p), pq, proto);
 
-    if (unlikely(ret != TM_ECODE_OK)) {
-        /* Not a tunnel packet, just a pseudo packet */
+    if (unlikely(ret != TM_ECODE_OK) ||
+            (proto == DECODE_TUNNEL_IPV6_TEREDO && (p->flags & PKT_IS_INVALID)))
+    {
+        /* Not a (valid) tunnel packet */
+        SCLogDebug(""tunnel packet is invalid"");
+
         p->root = NULL;
         UNSET_TUNNEL_PKT(p);
         TmqhOutputPacketpool(tv, p);",suricata,11f3659f64a4e42e90cb3c09fcef66894205aefe,e30212c5d8b536f351927d943580b1fcac920fe9,0,"void DecodeUpdatePacketCounters(ThreadVars *tv,
                                const DecodeThreadVars *dtv, const Packet *p)
{
    StatsIncr(tv, dtv->counter_pkts);
    //StatsIncr(tv, dtv->counter_pkts_per_sec);
    StatsAddUI64(tv, dtv->counter_bytes, GET_PKT_LEN(p));
    StatsAddUI64(tv, dtv->counter_avg_pkt_size, GET_PKT_LEN(p));
    StatsSetUI64(tv, dtv->counter_max_pkt_size, GET_PKT_LEN(p));
}
"
60922,,Remote,Single system,,CVE-2017-14604,https://www.cvedetails.com/cve/CVE-2017-14604/,CWE-20,Low,,Partial,,2017-09-20,4.0,"GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious *sh -c* command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.",2018-01-26,Exec Code ,0,https://github.com/GNOME/nautilus/commit/1630f53481f445ada0a455e9979236d31a8d3bb0,1630f53481f445ada0a455e9979236d31a8d3bb0,"mime-actions: use file metadata for trusting desktop files

Currently we only trust desktop files that have the executable bit
set, and don't replace the displayed icon or the displayed name until
it's trusted, which prevents for running random programs by a malicious
desktop file.

However, the executable permission is preserved if the desktop file
comes from a compressed file.

To prevent this, add a metadata::trusted metadata to the file once the
user acknowledges the file as trusted. This adds metadata to the file,
which cannot be added unless it has access to the computer.

Also remove the SHEBANG ""trusted"" content we were putting inside the
desktop file, since that doesn't add more security since it can come
with the file itself.

https://bugzilla.gnome.org/show_bug.cgi?id=777991",0,src/nautilus-directory-async.c,"{""sha"": ""b02e3de87b10a1d07f6f8bdd3d9ec9febfe7a024"", ""filename"": ""src/nautilus-directory-async.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-directory-async.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-directory-async.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-directory-async.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -30,6 +30,7 @@\n #include \""nautilus-global-preferences.h\""\n #include \""nautilus-link.h\""\n #include \""nautilus-profile.h\""\n+#include \""nautilus-metadata.h\""\n #include <eel/eel-glib-extensions.h>\n #include <gtk/gtk.h>\n #include <libxml/parser.h>\n@@ -3580,13 +3581,17 @@ is_link_trusted (NautilusFile *file,\n {\n     GFile *location;\n     gboolean res;\n+    g_autofree gchar* trusted = NULL;\n \n     if (!is_launcher)\n     {\n         return TRUE;\n     }\n \n-    if (nautilus_file_can_execute (file))\n+    trusted = nautilus_file_get_metadata (file,\n+                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                          NULL);\n+    if (nautilus_file_can_execute (file) && trusted != NULL)\n     {\n         return TRUE;\n     }""}<_**next**_>{""sha"": ""cd8ea0bdc66e087f860df07126f3cbe71d0c9c38"", ""filename"": ""src/nautilus-file-operations.c"", ""status"": ""modified"", ""additions"": 31, ""deletions"": 122, ""changes"": 153, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-file-operations.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -235,10 +235,10 @@ typedef struct\n #define COPY_FORCE _(\""Copy _Anyway\"")\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive);\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive);\n \n static gboolean\n is_all_button_text (const char *button_text)\n@@ -5290,10 +5290,10 @@ copy_move_file (CopyMoveJob   *copy_job,\n             g_file_equal (copy_job->desktop_location, dest_dir) &&\n             is_trusted_desktop_file (src, job->cancellable))\n         {\n-            mark_desktop_file_trusted (job,\n-                                       job->cancellable,\n-                                       dest,\n-                                       FALSE);\n+            mark_desktop_file_executable (job,\n+                                          job->cancellable,\n+                                          dest,\n+                                          FALSE);\n         }\n \n         if (job->undo_info != NULL)\n@@ -7887,9 +7887,9 @@ nautilus_file_operations_empty_trash (GtkWidget *parent_view)\n }\n \n static void\n-mark_trusted_task_done (GObject      *source_object,\n-                        GAsyncResult *res,\n-                        gpointer      user_data)\n+mark_desktop_file_executable_task_done (GObject      *source_object,\n+                                        GAsyncResult *res,\n+                                        gpointer      user_data)\n {\n     MarkTrustedJob *job = user_data;\n \n@@ -7907,110 +7907,19 @@ mark_trusted_task_done (GObject      *source_object,\n #define TRUSTED_SHEBANG \""#!/usr/bin/env xdg-open\\n\""\n \n static void\n-mark_desktop_file_trusted (CommonJob    *common,\n-                           GCancellable *cancellable,\n-                           GFile        *file,\n-                           gboolean      interactive)\n+mark_desktop_file_executable (CommonJob    *common,\n+                              GCancellable *cancellable,\n+                              GFile        *file,\n+                              gboolean      interactive)\n {\n-    char *contents, *new_contents;\n-    gsize length, new_length;\n     GError *error;\n     guint32 current_perms, new_perms;\n     int response;\n     GFileInfo *info;\n \n retry:\n-    error = NULL;\n-    if (!g_file_load_contents (file,\n-                               cancellable,\n-                               &contents, &length,\n-                               NULL, &error))\n-    {\n-        if (interactive)\n-        {\n-            response = run_error (common,\n-                                  g_strdup (_(\""Unable to mark launcher trusted (executable)\"")),\n-                                  error->message,\n-                                  NULL,\n-                                  FALSE,\n-                                  CANCEL, RETRY,\n-                                  NULL);\n-        }\n-        else\n-        {\n-            response = 0;\n-        }\n-\n-\n-        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-        {\n-            abort_job (common);\n-        }\n-        else if (response == 1)\n-        {\n-            goto retry;\n-        }\n-        else\n-        {\n-            g_assert_not_reached ();\n-        }\n-\n-        goto out;\n-    }\n-\n-    if (!g_str_has_prefix (contents, \""#!\""))\n-    {\n-        new_length = length + strlen (TRUSTED_SHEBANG);\n-        new_contents = g_malloc (new_length);\n-\n-        strcpy (new_contents, TRUSTED_SHEBANG);\n-        memcpy (new_contents + strlen (TRUSTED_SHEBANG),\n-                contents, length);\n-\n-        if (!g_file_replace_contents (file,\n-                                      new_contents,\n-                                      new_length,\n-                                      NULL,\n-                                      FALSE, 0,\n-                                      NULL, cancellable, &error))\n-        {\n-            g_free (contents);\n-            g_free (new_contents);\n-\n-            if (interactive)\n-            {\n-                response = run_error (common,\n-                                      g_strdup (_(\""Unable to mark launcher trusted (executable)\"")),\n-                                      error->message,\n-                                      NULL,\n-                                      FALSE,\n-                                      CANCEL, RETRY,\n-                                      NULL);\n-            }\n-            else\n-            {\n-                response = 0;\n-            }\n-\n-            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n-            {\n-                abort_job (common);\n-            }\n-            else if (response == 1)\n-            {\n-                goto retry;\n-            }\n-            else\n-            {\n-                g_assert_not_reached ();\n-            }\n-\n-            goto out;\n-        }\n-        g_free (new_contents);\n-    }\n-    g_free (contents);\n \n+    error = NULL;\n     info = g_file_query_info (file,\n                               G_FILE_ATTRIBUTE_STANDARD_TYPE \"",\""\n                               G_FILE_ATTRIBUTE_UNIX_MODE,\n@@ -8101,10 +8010,10 @@ mark_desktop_file_trusted (CommonJob    *common,\n }\n \n static void\n-mark_trusted_task_thread_func (GTask        *task,\n-                               gpointer      source_object,\n-                               gpointer      task_data,\n-                               GCancellable *cancellable)\n+mark_desktop_file_executable_task_thread_func (GTask        *task,\n+                                               gpointer      source_object,\n+                                               gpointer      task_data,\n+                                               GCancellable *cancellable)\n {\n     MarkTrustedJob *job = task_data;\n     CommonJob *common;\n@@ -8113,18 +8022,18 @@ mark_trusted_task_thread_func (GTask        *task,\n \n     nautilus_progress_info_start (job->common.progress);\n \n-    mark_desktop_file_trusted (common,\n-                               cancellable,\n-                               job->file,\n-                               job->interactive);\n+    mark_desktop_file_executable (common,\n+                                  cancellable,\n+                                  job->file,\n+                                  job->interactive);\n }\n \n void\n-nautilus_file_mark_desktop_file_trusted (GFile              *file,\n-                                         GtkWindow          *parent_window,\n-                                         gboolean            interactive,\n-                                         NautilusOpCallback  done_callback,\n-                                         gpointer            done_callback_data)\n+nautilus_file_mark_desktop_file_executable (GFile              *file,\n+                                            GtkWindow          *parent_window,\n+                                            gboolean            interactive,\n+                                            NautilusOpCallback  done_callback,\n+                                            gpointer            done_callback_data)\n {\n     GTask *task;\n     MarkTrustedJob *job;\n@@ -8135,9 +8044,9 @@ nautilus_file_mark_desktop_file_trusted (GFile              *file,\n     job->done_callback = done_callback;\n     job->done_callback_data = done_callback_data;\n \n-    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n+    task = g_task_new (NULL, NULL, mark_desktop_file_executable_task_done, job);\n     g_task_set_task_data (task, job, NULL);\n-    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n+    g_task_run_in_thread (task, mark_desktop_file_executable_task_thread_func);\n     g_object_unref (task);\n }\n ""}<_**next**_>{""sha"": ""a479ee6e0232dad341a282a1771bcdc4a04173dc"", ""filename"": ""src/nautilus-file-operations.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 5, ""changes"": 10, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.h"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-file-operations.h"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-file-operations.h?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -146,11 +146,11 @@ void nautilus_file_operations_link      (GList                *files,\n \t\t\t\t\t GtkWindow            *parent_window,\n \t\t\t\t\t NautilusCopyCallback  done_callback,\n \t\t\t\t\t gpointer              done_callback_data);\n-void nautilus_file_mark_desktop_file_trusted (GFile           *file,\n-\t\t\t\t\t      GtkWindow        *parent_window,\n-\t\t\t\t\t      gboolean          interactive,\n-\t\t\t\t\t      NautilusOpCallback done_callback,\n-\t\t\t\t\t      gpointer          done_callback_data);\n+void nautilus_file_mark_desktop_file_executable (GFile           *file,\n+                                                 GtkWindow        *parent_window,\n+                                                 gboolean          interactive,\n+                                                 NautilusOpCallback done_callback,\n+                                                 gpointer          done_callback_data);\n void nautilus_file_operations_extract_files (GList                   *files,\n                                              GFile                   *destination_directory,\n                                              GtkWindow               *parent_window,""}<_**next**_>{""sha"": ""bee04e7ca5e3ac45884d9c265f2717d49a3d2f40"", ""filename"": ""src/nautilus-metadata.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-metadata.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -51,6 +51,7 @@ static char *used_metadata_names[] =\n     NAUTILUS_METADATA_KEY_CUSTOM_ICON_NAME,\n     NAUTILUS_METADATA_KEY_SCREEN,\n     NAUTILUS_METADATA_KEY_EMBLEMS,\n+    NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n     NULL\n };\n ""}<_**next**_>{""sha"": ""c4a303ec555ecfb1252bb44f7cd8261cfb2faea5"", ""filename"": ""src/nautilus-metadata.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.h"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-metadata.h"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-metadata.h?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -67,6 +67,8 @@\n #define NAUTILUS_METADATA_KEY_SCREEN\t\t\t\t\""screen\""\n #define NAUTILUS_METADATA_KEY_EMBLEMS\t\t\t\t\""emblems\""\n \n+#define NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED\t\t\t\t\""trusted\""\n+\n guint nautilus_metadata_get_id (const char *metadata);\n \n #endif /* NAUTILUS_METADATA_H */""}<_**next**_>{""sha"": ""14fe44bc39a40cfd3faf7119206145ed9968162f"", ""filename"": ""src/nautilus-mime-actions.c"", ""status"": ""modified"", ""additions"": 28, ""deletions"": 18, ""changes"": 46, ""blob_url"": ""https://github.com/GNOME/nautilus/blob/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-mime-actions.c"", ""raw_url"": ""https://github.com/GNOME/nautilus/raw/1630f53481f445ada0a455e9979236d31a8d3bb0/src/nautilus-mime-actions.c"", ""contents_url"": ""https://api.github.com/repos/GNOME/nautilus/contents/src/nautilus-mime-actions.c?ref=1630f53481f445ada0a455e9979236d31a8d3bb0"", ""patch"": ""@@ -42,6 +42,7 @@\n #include \""nautilus-program-choosing.h\""\n #include \""nautilus-global-preferences.h\""\n #include \""nautilus-signaller.h\""\n+#include \""nautilus-metadata.h\""\n \n #define DEBUG_FLAG NAUTILUS_DEBUG_MIME\n #include \""nautilus-debug.h\""\n@@ -221,7 +222,6 @@ struct\n #define RESPONSE_RUN 1000\n #define RESPONSE_DISPLAY 1001\n #define RESPONSE_RUN_IN_TERMINAL 1002\n-#define RESPONSE_MARK_TRUSTED 1003\n \n #define SILENT_WINDOW_OPEN_LIMIT 5\n #define SILENT_OPEN_LIMIT 5\n@@ -1517,24 +1517,35 @@ untrusted_launcher_response_callback (GtkDialog                 *dialog,\n \n     switch (response_id)\n     {\n-        case RESPONSE_RUN:\n+        case GTK_RESPONSE_OK:\n         {\n+            file = nautilus_file_get_location (parameters->file);\n+\n+            /* We need to do this in order to prevent malicious desktop files\n+             * with the executable bit already set.\n+             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991\n+             */\n+            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n+                                        NULL,\n+                                        \""yes\"");\n+\n+            nautilus_file_mark_desktop_file_executable (file,\n+                                                        parameters->parent_window,\n+                                                        TRUE,\n+                                                        NULL, NULL);\n+\n+            /* Need to force a reload of the attributes so is_trusted is marked\n+             * correctly. Not sure why the general monitor doesn't fire in this\n+             * case when setting the metadata\n+             */\n+            nautilus_file_invalidate_all_attributes (parameters->file);\n+\n             screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n             uri = nautilus_file_get_uri (parameters->file);\n             DEBUG (\""Launching untrusted launcher %s\"", uri);\n             nautilus_launch_desktop_file (screen, uri, NULL,\n                                           parameters->parent_window);\n             g_free (uri);\n-        }\n-        break;\n-\n-        case RESPONSE_MARK_TRUSTED:\n-        {\n-            file = nautilus_file_get_location (parameters->file);\n-            nautilus_file_mark_desktop_file_trusted (file,\n-                                                     parameters->parent_window,\n-                                                     TRUE,\n-                                                     NULL, NULL);\n             g_object_unref (file);\n         }\n         break;\n@@ -1590,17 +1601,16 @@ activate_desktop_file (ActivateParameters *parameters,\n                       \""text\"", primary,\n                       \""secondary-text\"", secondary,\n                       NULL);\n+\n         gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\""_Launch Anyway\""), RESPONSE_RUN);\n+                               _(\""_Cancel\""), GTK_RESPONSE_CANCEL);\n+\n+        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n         if (nautilus_file_can_set_permissions (file))\n         {\n             gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                                   _(\""Mark as _Trusted\""), RESPONSE_MARK_TRUSTED);\n+                                   _(\""Trust and _Launch\""), GTK_RESPONSE_OK);\n         }\n-        gtk_dialog_add_button (GTK_DIALOG (dialog),\n-                               _(\""_Cancel\""), GTK_RESPONSE_CANCEL);\n-        gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL);\n-\n         g_signal_connect (dialog, \""response\"",\n                           G_CALLBACK (untrusted_launcher_response_callback),\n                           parameters_desktop);""}","lacks_deep_count (NautilusFile *file)
{
    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;
}
","lacks_deep_count (NautilusFile *file)
{
    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;
}
",C,,,,"@@ -30,6 +30,7 @@
 #include ""nautilus-global-preferences.h""
 #include ""nautilus-link.h""
 #include ""nautilus-profile.h""
+#include ""nautilus-metadata.h""
 #include <eel/eel-glib-extensions.h>
 #include <gtk/gtk.h>
 #include <libxml/parser.h>
@@ -3580,13 +3581,17 @@ is_link_trusted (NautilusFile *file,
 {
     GFile *location;
     gboolean res;
+    g_autofree gchar* trusted = NULL;
 
     if (!is_launcher)
     {
         return TRUE;
     }
 
-    if (nautilus_file_can_execute (file))
+    trusted = nautilus_file_get_metadata (file,
+                                          NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,
+                                          NULL);
+    if (nautilus_file_can_execute (file) && trusted != NULL)
     {
         return TRUE;
     }",nautilus,1630f53481f445ada0a455e9979236d31a8d3bb0,cc6910ff6511a5a2939cf36a49ca81fb62005382,0,"lacks_deep_count (NautilusFile *file)
{
    return file->details->deep_counts_status != NAUTILUS_REQUEST_DONE;
}
"
68832,,Local,Not required,Complete,CVE-2017-5546,https://www.cvedetails.com/cve/CVE-2017-5546/,,Low,Complete,Complete,,2017-02-06,7.2,The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.,2019-10-02,DoS ,0,https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,"mm/slab.c: fix SLAB freelist randomization duplicate entries

This patch fixes a bug in the freelist randomization code.  When a high
random number is used, the freelist will contain duplicate entries.  It
will result in different allocations sharing the same chunk.

It will result in odd behaviours and crashes.  It should be uncommon but
it depends on the machines.  We saw it happening more often on some
machines (every few hours of running tests).

Fixes: c7ce4f60ac19 (""mm: SLAB freelist randomization"")
Link: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com
Signed-off-by: John Sperbeck <jsperbeck@google.com>
Signed-off-by: Thomas Garnier <thgarnie@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: David Rientjes <rientjes@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,mm/slab.c,"{""sha"": ""4f2ec6bb46ebe949d2e19ff154faddc7e2526f02"", ""filename"": ""mm/slab.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/mm/slab.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/mm/slab.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/slab.c?ref=c4e490cf148e85ead0d1b1c2caaba833f1d5b29f"", ""patch"": ""@@ -2457,7 +2457,6 @@ union freelist_init_state {\n \t\tunsigned int pos;\n \t\tunsigned int *list;\n \t\tunsigned int count;\n-\t\tunsigned int rand;\n \t};\n \tstruct rnd_state rnd_state;\n };\n@@ -2483,8 +2482,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n \t} else {\n \t\tstate->list = cachep->random_seq;\n \t\tstate->count = count;\n-\t\tstate->pos = 0;\n-\t\tstate->rand = rand;\n+\t\tstate->pos = rand % count;\n \t\tret = true;\n \t}\n \treturn ret;\n@@ -2493,7 +2491,9 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n /* Get the next entry on the list and randomize it using a random shift */\n static freelist_idx_t next_random_slot(union freelist_init_state *state)\n {\n-\treturn (state->list[state->pos++] + state->rand) % state->count;\n+\tif (state->pos >= state->count)\n+\t\tstate->pos = 0;\n+\treturn state->list[state->pos++];\n }\n \n /* Swap two freelist entries */""}","static struct array_cache __percpu *alloc_kmem_cache_cpus(
		struct kmem_cache *cachep, int entries, int batchcount)
{
	int cpu;
	size_t size;
	struct array_cache __percpu *cpu_cache;

	size = sizeof(void *) * entries + sizeof(struct array_cache);
	cpu_cache = __alloc_percpu(size, sizeof(void *));

	if (!cpu_cache)
		return NULL;

	for_each_possible_cpu(cpu) {
		init_arraycache(per_cpu_ptr(cpu_cache, cpu),
				entries, batchcount);
	}

	return cpu_cache;
}
","static struct array_cache __percpu *alloc_kmem_cache_cpus(
		struct kmem_cache *cachep, int entries, int batchcount)
{
	int cpu;
	size_t size;
	struct array_cache __percpu *cpu_cache;

	size = sizeof(void *) * entries + sizeof(struct array_cache);
	cpu_cache = __alloc_percpu(size, sizeof(void *));

	if (!cpu_cache)
		return NULL;

	for_each_possible_cpu(cpu) {
		init_arraycache(per_cpu_ptr(cpu_cache, cpu),
				entries, batchcount);
	}

	return cpu_cache;
}
",C,,,,"@@ -2457,7 +2457,6 @@ union freelist_init_state {
 		unsigned int pos;
 		unsigned int *list;
 		unsigned int count;
-		unsigned int rand;
 	};
 	struct rnd_state rnd_state;
 };
@@ -2483,8 +2482,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,
 	} else {
 		state->list = cachep->random_seq;
 		state->count = count;
-		state->pos = 0;
-		state->rand = rand;
+		state->pos = rand % count;
 		ret = true;
 	}
 	return ret;
@@ -2493,7 +2491,9 @@ static bool freelist_state_initialize(union freelist_init_state *state,
 /* Get the next entry on the list and randomize it using a random shift */
 static freelist_idx_t next_random_slot(union freelist_init_state *state)
 {
-	return (state->list[state->pos++] + state->rand) % state->count;
+	if (state->pos >= state->count)
+		state->pos = 0;
+	return state->list[state->pos++];
 }
 
 /* Swap two freelist entries */",linux,c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,b09ab054b69b07077bd3292f67e777861ac796e5,0,"static struct array_cache __percpu *alloc_kmem_cache_cpus(
		struct kmem_cache *cachep, int entries, int batchcount)
{
	int cpu;
	size_t size;
	struct array_cache __percpu *cpu_cache;

	size = sizeof(void *) * entries + sizeof(struct array_cache);
	cpu_cache = __alloc_percpu(size, sizeof(void *));

	if (!cpu_cache)
		return NULL;

	for_each_possible_cpu(cpu) {
		init_arraycache(per_cpu_ptr(cpu_cache, cpu),
				entries, batchcount);
	}

	return cpu_cache;
}
"
117703,,Remote,Not required,,CVE-2011-3054,https://www.cvedetails.com/cve/CVE-2011-3054/,CWE-264,Low,,Partial,,2012-03-22,5.0,"The WebUI privilege implementation in Google Chrome before 17.0.963.83 does not properly perform isolation, which allows remote attackers to bypass intended access restrictions via unspecified vectors.",2018-01-09,Bypass ,0,https://github.com/chromium/chromium/commit/8ae91350332f188ef711228aa61b7809b74aa3a7,8ae91350332f188ef711228aa61b7809b74aa3a7,"Add unit test for AllowBindings check.

BUG=117418
TEST=none


Review URL: http://codereview.chromium.org/9701038

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@126929 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/renderer_host/render_view_host_unittest.cc,"{""sha"": ""87a7be2fd9db3230c6fa7f9e8488cb3d41467d64"", ""filename"": ""content/browser/renderer_host/render_view_host_unittest.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 0, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/8ae91350332f188ef711228aa61b7809b74aa3a7/content/browser/renderer_host/render_view_host_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8ae91350332f188ef711228aa61b7809b74aa3a7/content/browser/renderer_host/render_view_host_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/render_view_host_unittest.cc?ref=8ae91350332f188ef711228aa61b7809b74aa3a7"", ""patch"": ""@@ -9,6 +9,7 @@\n #include \""content/browser/tab_contents/test_tab_contents.h\""\n #include \""content/common/view_messages.h\""\n #include \""content/public/browser/navigation_entry.h\""\n+#include \""content/public/common/bindings_policy.h\""\n #include \""content/public/common/page_transition_types.h\""\n #include \""third_party/WebKit/Source/WebKit/chromium/public/WebDragOperation.h\""\n #include \""webkit/glue/webdropdata.h\""\n@@ -63,6 +64,16 @@ TEST_F(RenderViewHostTest, ResetUnloadOnReload) {\n   EXPECT_FALSE(test_rvh()->is_waiting_for_unload_ack_for_testing());\n }\n \n+// Ensure we do not grant bindings to a process shared with unprivileged views.\n+TEST_F(RenderViewHostTest, DontGrantBindingsToSharedProcess) {\n+  // Create another view in the same process.\n+  scoped_ptr<TestTabContents> new_tab(\n+      new TestTabContents(browser_context(), rvh()->GetSiteInstance()));\n+\n+  rvh()->AllowBindings(content::BINDINGS_POLICY_WEB_UI);\n+  EXPECT_FALSE(rvh()->GetEnabledBindings() & content::BINDINGS_POLICY_WEB_UI);\n+}\n+\n class MockDraggingRenderViewHostDelegateView\n     : public content::RenderViewHostDelegate::View {\n  public:""}","  virtual void UpdateDragCursor(WebKit::WebDragOperation operation) {}
","  virtual void UpdateDragCursor(WebKit::WebDragOperation operation) {}
",C,,,,"@@ -9,6 +9,7 @@
 #include ""content/browser/tab_contents/test_tab_contents.h""
 #include ""content/common/view_messages.h""
 #include ""content/public/browser/navigation_entry.h""
+#include ""content/public/common/bindings_policy.h""
 #include ""content/public/common/page_transition_types.h""
 #include ""third_party/WebKit/Source/WebKit/chromium/public/WebDragOperation.h""
 #include ""webkit/glue/webdropdata.h""
@@ -63,6 +64,16 @@ TEST_F(RenderViewHostTest, ResetUnloadOnReload) {
   EXPECT_FALSE(test_rvh()->is_waiting_for_unload_ack_for_testing());
 }
 
+// Ensure we do not grant bindings to a process shared with unprivileged views.
+TEST_F(RenderViewHostTest, DontGrantBindingsToSharedProcess) {
+  // Create another view in the same process.
+  scoped_ptr<TestTabContents> new_tab(
+      new TestTabContents(browser_context(), rvh()->GetSiteInstance()));
+
+  rvh()->AllowBindings(content::BINDINGS_POLICY_WEB_UI);
+  EXPECT_FALSE(rvh()->GetEnabledBindings() & content::BINDINGS_POLICY_WEB_UI);
+}
+
 class MockDraggingRenderViewHostDelegateView
     : public content::RenderViewHostDelegate::View {
  public:",Chrome,8ae91350332f188ef711228aa61b7809b74aa3a7,367e32034e20ad96123d5522dda95e799297e19c,0,"  virtual void UpdateDragCursor(WebKit::WebDragOperation operation) {}
"
49041,,Local,Not required,Complete,CVE-2016-8658,https://www.cvedetails.com/cve/CVE-2016-8658/,CWE-119,Low,,Partial,,2016-10-16,5.6,Stack-based buffer overflow in the brcmf_cfg80211_start_ap function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.7.5 allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a long SSID Information Element in a command to a Netlink socket.,2017-01-06,DoS Overflow ,0,https://github.com/torvalds/linux/commit/ded89912156b1a47d940a0c954c43afbabd0c42c,ded89912156b1a47d940a0c954c43afbabd0c42c,"brcmfmac: avoid potential stack overflow in brcmf_cfg80211_start_ap()

User-space can choose to omit NL80211_ATTR_SSID and only provide raw
IE TLV data. When doing so it can provide SSID IE with length exceeding
the allowed size. The driver further processes this IE copying it
into a local variable without checking the length. Hence stack can be
corrupted and used as exploit.

Cc: stable@vger.kernel.org # v4.7
Reported-by: Daxing Guo <freener.gdx@gmail.com>
Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
Reviewed-by: Franky Lin <franky.lin@broadcom.com>
Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
Signed-off-by: Kalle Valo <kvalo@codeaurora.org>",0,drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c,"{""sha"": ""b8aec5e5ef93e28dfb70c95557d7388fd9b67bef"", ""filename"": ""drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/ded89912156b1a47d940a0c954c43afbabd0c42c/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/ded89912156b1a47d940a0c954c43afbabd0c42c/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c?ref=ded89912156b1a47d940a0c954c43afbabd0c42c"", ""patch"": ""@@ -4527,7 +4527,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\n \t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n \t\t\t\tsettings->beacon.head_len - ie_offset,\n \t\t\t\tWLAN_EID_SSID);\n-\t\tif (!ssid_ie)\n+\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n \t\t\treturn -EINVAL;\n \n \t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);""}","static int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
{
	struct brcmf_if *ifp = netdev_priv(ndev);
	s32 err;
	struct brcmf_fil_bss_enable_le bss_enable;
	struct brcmf_join_params join_params;

	brcmf_dbg(TRACE, ""Enter\n"");

	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {
		/* Due to most likely deauths outstanding we sleep */
		/* first to make sure they get processed by fw. */
		msleep(400);

		if (ifp->vif->mbss) {
			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
			return err;
		}

		/* First BSS doesn't get a full reset */
		if (ifp->bsscfgidx == 0)
			brcmf_fil_iovar_int_set(ifp, ""closednet"", 0);

		memset(&join_params, 0, sizeof(join_params));
		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
					     &join_params, sizeof(join_params));
		if (err < 0)
			brcmf_err(""SET SSID error (%d)\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_DOWN error %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
		if (err < 0)
			brcmf_err(""setting AP mode failed %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 0);
		if (err < 0)
			brcmf_err(""setting INFRA mode failed %d\n"", err);
		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
			brcmf_fil_iovar_int_set(ifp, ""mbss"", 0);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
					    ifp->vif->is_11d);
		if (err < 0)
			brcmf_err(""restoring REGULATORY setting failed %d\n"",
				  err);
		/* Bring device back up so it can be used again */
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_UP error %d\n"", err);
	} else {
		bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);
		bss_enable.enable = cpu_to_le32(0);
		err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable,
					       sizeof(bss_enable));
		if (err < 0)
			brcmf_err(""bss_enable config failed %d\n"", err);
	}
	brcmf_set_mpc(ifp, 1);
	brcmf_configure_arp_nd_offload(ifp, true);
	clear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
	brcmf_net_setcarrier(ifp, false);

	return err;
}
","static int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
{
	struct brcmf_if *ifp = netdev_priv(ndev);
	s32 err;
	struct brcmf_fil_bss_enable_le bss_enable;
	struct brcmf_join_params join_params;

	brcmf_dbg(TRACE, ""Enter\n"");

	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {
		/* Due to most likely deauths outstanding we sleep */
		/* first to make sure they get processed by fw. */
		msleep(400);

		if (ifp->vif->mbss) {
			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
			return err;
		}

		/* First BSS doesn't get a full reset */
		if (ifp->bsscfgidx == 0)
			brcmf_fil_iovar_int_set(ifp, ""closednet"", 0);

		memset(&join_params, 0, sizeof(join_params));
		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
					     &join_params, sizeof(join_params));
		if (err < 0)
			brcmf_err(""SET SSID error (%d)\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_DOWN error %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
		if (err < 0)
			brcmf_err(""setting AP mode failed %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 0);
		if (err < 0)
			brcmf_err(""setting INFRA mode failed %d\n"", err);
		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
			brcmf_fil_iovar_int_set(ifp, ""mbss"", 0);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
					    ifp->vif->is_11d);
		if (err < 0)
			brcmf_err(""restoring REGULATORY setting failed %d\n"",
				  err);
		/* Bring device back up so it can be used again */
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_UP error %d\n"", err);
	} else {
		bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);
		bss_enable.enable = cpu_to_le32(0);
		err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable,
					       sizeof(bss_enable));
		if (err < 0)
			brcmf_err(""bss_enable config failed %d\n"", err);
	}
	brcmf_set_mpc(ifp, 1);
	brcmf_configure_arp_nd_offload(ifp, true);
	clear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
	brcmf_net_setcarrier(ifp, false);

	return err;
}
",C,,,,"@@ -4527,7 +4527,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,
 				(u8 *)&settings->beacon.head[ie_offset],
 				settings->beacon.head_len - ie_offset,
 				WLAN_EID_SSID);
-		if (!ssid_ie)
+		if (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)
 			return -EINVAL;
 
 		memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);",linux,ded89912156b1a47d940a0c954c43afbabd0c42c,a9840c46ff9bb845d62d6f9592ab76c0e531c8f4,0,"static int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
{
	struct brcmf_if *ifp = netdev_priv(ndev);
	s32 err;
	struct brcmf_fil_bss_enable_le bss_enable;
	struct brcmf_join_params join_params;

	brcmf_dbg(TRACE, ""Enter\n"");

	if (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {
		/* Due to most likely deauths outstanding we sleep */
		/* first to make sure they get processed by fw. */
		msleep(400);

		if (ifp->vif->mbss) {
			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
			return err;
		}

		/* First BSS doesn't get a full reset */
		if (ifp->bsscfgidx == 0)
			brcmf_fil_iovar_int_set(ifp, ""closednet"", 0);

		memset(&join_params, 0, sizeof(join_params));
		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
					     &join_params, sizeof(join_params));
		if (err < 0)
			brcmf_err(""SET SSID error (%d)\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_DOWN error %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
		if (err < 0)
			brcmf_err(""setting AP mode failed %d\n"", err);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 0);
		if (err < 0)
			brcmf_err(""setting INFRA mode failed %d\n"", err);
		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
			brcmf_fil_iovar_int_set(ifp, ""mbss"", 0);
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
					    ifp->vif->is_11d);
		if (err < 0)
			brcmf_err(""restoring REGULATORY setting failed %d\n"",
				  err);
		/* Bring device back up so it can be used again */
		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
		if (err < 0)
			brcmf_err(""BRCMF_C_UP error %d\n"", err);
	} else {
		bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);
		bss_enable.enable = cpu_to_le32(0);
		err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable,
					       sizeof(bss_enable));
		if (err < 0)
			brcmf_err(""bss_enable config failed %d\n"", err);
	}
	brcmf_set_mpc(ifp, 1);
	brcmf_configure_arp_nd_offload(ifp, true);
	clear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);
	brcmf_net_setcarrier(ifp, false);

	return err;
}
"
129809,,Remote,Not required,Partial,CVE-2014-3156,https://www.cvedetails.com/cve/CVE-2014-3156/,CWE-119,Low,Partial,Partial,,2014-06-11,7.5,"Buffer overflow in the clipboard implementation in Google Chrome before 35.0.1916.153 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors that trigger unexpected bitmap data, related to content/renderer/renderer_clipboard_client.cc and content/renderer/webclipboard_impl.cc.",2017-12-28,DoS Overflow ,0,https://github.com/chromium/chromium/commit/0b694217046d6b2bfa5814676e8615c18e6a45ff,0b694217046d6b2bfa5814676e8615c18e6a45ff,"System Clipboard: Remove extraneous check for bitmap.getPixels()

Bug 369621 originally led to this check being introduced via
https://codereview.chromium.org/289573002/patch/40001/50002, but after
https://crrev.com/c/1345809, I'm not sure that it's still necessary.

This change succeeds when tested against the ""minimized test case"" provided in
crbug.com/369621 's description, but I'm unsure how to make the minimized test
case fail, so this doesn't prove that the change would succeed against the
fuzzer's test case (which originally filed the bug).

As I'm unable to view the relevant fuzzer test case, (see crbug.com/918705),
I don't know exactly what may have caused the fuzzer to fail. Therefore,
I've added a CHECK for the time being, so that we will be notified in canary
if my assumption was incorrect.

Bug: 369621
Change-Id: Ie9b47a4b38ba1ed47624de776015728e541d27f7
Reviewed-on: https://chromium-review.googlesource.com/c/1393436
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Kai Ninomiya <kainino@chromium.org>
Reviewed-by: Victor Costan <pwnall@chromium.org>
Commit-Queue: Victor Costan <pwnall@chromium.org>
Cr-Commit-Position: refs/heads/master@{#619591}",0,third_party/blink/renderer/core/clipboard/system_clipboard.cc,"{""sha"": ""58689cbdd3f159e10941ee01dab4f5bbf4820427"", ""filename"": ""third_party/blink/renderer/core/clipboard/system_clipboard.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/0b694217046d6b2bfa5814676e8615c18e6a45ff/third_party/blink/renderer/core/clipboard/system_clipboard.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0b694217046d6b2bfa5814676e8615c18e6a45ff/third_party/blink/renderer/core/clipboard/system_clipboard.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/clipboard/system_clipboard.cc?ref=0b694217046d6b2bfa5814676e8615c18e6a45ff"", ""patch"": ""@@ -172,9 +172,8 @@ void SystemClipboard::WriteImage(Image* image,\n   if (bitmap.isNull())\n     return;\n \n-  // TODO(piman): this should not be NULL, but it is. crbug.com/369621\n-  if (!bitmap.getPixels())\n-    return;\n+  // TODO(crbug.com/918717): Remove CHECK if no crashes occur on it in canary.\n+  CHECK(bitmap.getPixels());\n \n   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);\n ""}","void SystemClipboard::SetSelectionMode(bool selection_mode) {
  buffer_ = selection_mode ? mojom::ClipboardBuffer::kSelection
                           : mojom::ClipboardBuffer::kStandard;
}
","void SystemClipboard::SetSelectionMode(bool selection_mode) {
  buffer_ = selection_mode ? mojom::ClipboardBuffer::kSelection
                           : mojom::ClipboardBuffer::kStandard;
}
",C,,,,"@@ -172,9 +172,8 @@ void SystemClipboard::WriteImage(Image* image,
   if (bitmap.isNull())
     return;
 
-  // TODO(piman): this should not be NULL, but it is. crbug.com/369621
-  if (!bitmap.getPixels())
-    return;
+  // TODO(crbug.com/918717): Remove CHECK if no crashes occur on it in canary.
+  CHECK(bitmap.getPixels());
 
   clipboard_->WriteImage(mojom::ClipboardBuffer::kStandard, bitmap);
 ",Chrome,0b694217046d6b2bfa5814676e8615c18e6a45ff,1dd87f896364b429d038cfe689d2594b2a2d7ec0,0,"void SystemClipboard::SetSelectionMode(bool selection_mode) {
  buffer_ = selection_mode ? mojom::ClipboardBuffer::kSelection
                           : mojom::ClipboardBuffer::kStandard;
}
"
129444,,Remote,Not required,Partial,CVE-2014-3173,https://www.cvedetails.com/cve/CVE-2014-3173/,CWE-119,Low,,,,2014-08-26,5.0,"The WebGL implementation in Google Chrome before 37.0.2062.94 does not ensure that clear calls interact properly with the state of a draw buffer, which allows remote attackers to cause a denial of service (read of uninitialized memory) via a crafted CANVAS element, related to gpu/command_buffer/service/framebuffer_manager.cc and gpu/command_buffer/service/gles2_cmd_decoder.cc.",2017-08-28,DoS Overflow ,0,https://github.com/chromium/chromium/commit/ee7579229ff7e9e5ae28bf53aea069251499d7da,ee7579229ff7e9e5ae28bf53aea069251499d7da,"Framebuffer clear() needs to consider the situation some draw buffers are disabled.

This is when we expose DrawBuffers extension.

BUG=376951
TEST=the attached test case, webgl conformance
R=kbr@chromium.org,bajones@chromium.org

Review URL: https://codereview.chromium.org/315283002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@275338 0039d316-1c4b-4281-b951-d872f2087c98",0,gpu/command_buffer/service/gles2_cmd_decoder.cc,"{""sha"": ""4022b3defaa1e286e85e72f7ac6aa702fa1e9fb2"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager.cc"", ""status"": ""modified"", ""additions"": 51, ""deletions"": 0, ""changes"": 51, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -360,6 +360,55 @@ bool Framebuffer::HasUnclearedAttachment(\n   return false;\n }\n \n+bool Framebuffer::HasUnclearedColorAttachments() const {\n+  for (AttachmentMap::const_iterator it = attachments_.begin();\n+       it != attachments_.end(); ++it) {\n+    if (it->first >= GL_COLOR_ATTACHMENT0 &&\n+        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {\n+      const Attachment* attachment = it->second.get();\n+      if (!attachment->cleared())\n+        return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void Framebuffer::ChangeDrawBuffersHelper(bool recover) const {\n+  scoped_ptr<GLenum[]> buffers(new GLenum[manager_->max_draw_buffers_]);\n+  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i)\n+    buffers[i] = GL_NONE;\n+  for (AttachmentMap::const_iterator it = attachments_.begin();\n+       it != attachments_.end(); ++it) {\n+    if (it->first >= GL_COLOR_ATTACHMENT0 &&\n+        it->first < GL_COLOR_ATTACHMENT0 + manager_->max_draw_buffers_) {\n+      buffers[it->first - GL_COLOR_ATTACHMENT0] = it->first;\n+    }\n+  }\n+  bool different = false;\n+  for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {\n+    if (buffers[i] != draw_buffers_[i]) {\n+      different = true;\n+      break;\n+    }\n+  }\n+  if (different) {\n+    if (recover)\n+      glDrawBuffersARB(manager_->max_draw_buffers_, draw_buffers_.get());\n+    else\n+      glDrawBuffersARB(manager_->max_draw_buffers_, buffers.get());\n+  }\n+}\n+\n+void Framebuffer::PrepareDrawBuffersForClear() const {\n+  bool recover = false;\n+  ChangeDrawBuffersHelper(recover);\n+}\n+\n+void Framebuffer::RestoreDrawBuffersAfterClear() const {\n+  bool recover = true;\n+  ChangeDrawBuffersHelper(recover);\n+}\n+\n void Framebuffer::MarkAttachmentAsCleared(\n       RenderbufferManager* renderbuffer_manager,\n       TextureManager* texture_manager,\n@@ -516,6 +565,8 @@ void Framebuffer::SetDrawBuffers(GLsizei n, const GLenum* bufs) {\n     draw_buffers_[i] = bufs[i];\n }\n \n+\n+\n bool Framebuffer::HasAlphaMRT() const {\n   for (uint32 i = 0; i < manager_->max_draw_buffers_; ++i) {\n     if (draw_buffers_[i] != GL_NONE) {""}<_**next**_>{""sha"": ""b68ab7d9f1209710bc994d02bc1ebb7c9344e2a5"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager.h?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -64,6 +64,7 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n   }\n \n   bool HasUnclearedAttachment(GLenum attachment) const;\n+  bool HasUnclearedColorAttachments() const;\n \n   void MarkAttachmentAsCleared(\n     RenderbufferManager* renderbuffer_manager,\n@@ -129,6 +130,14 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n \n   void SetDrawBuffers(GLsizei n, const GLenum* bufs);\n \n+  // If a color buffer is attached to GL_COLOR_ATTACHMENTi, enable that\n+  // draw buffer for glClear().\n+  void PrepareDrawBuffersForClear() const;\n+\n+  // Restore draw buffers states that have been changed in\n+  // PrepareDrawBuffersForClear().\n+  void RestoreDrawBuffersAfterClear() const;\n+\n   // Return true if any draw buffers has an alpha channel.\n   bool HasAlphaMRT() const;\n \n@@ -163,6 +172,10 @@ class GPU_EXPORT Framebuffer : public base::RefCounted<Framebuffer> {\n     return framebuffer_complete_state_count_id_;\n   }\n \n+  // Helper function for PrepareDrawBuffersForClear() and\n+  // RestoreDrawBuffersAfterClear().\n+  void ChangeDrawBuffersHelper(bool recover) const;\n+\n   // The managers that owns this.\n   FramebufferManager* manager_;\n ""}<_**next**_>{""sha"": ""a27e6aeb24bea82701b82229749a73acfafde2f0"", ""filename"": ""gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""status"": ""modified"", ""additions"": 97, ""deletions"": 1, ""changes"": 98, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/framebuffer_manager_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/framebuffer_manager_unittest.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""testing/gtest/include/gtest/gtest.h\""\n #include \""ui/gl/gl_mock.h\""\n \n+using ::testing::_;\n using ::testing::Return;\n \n namespace gpu {\n@@ -21,6 +22,8 @@ const GLint kMaxTextureSize = 64;\n const GLint kMaxCubemapSize = 64;\n const GLint kMaxRenderbufferSize = 64;\n const GLint kMaxSamples = 4;\n+const uint32 kMaxDrawBuffers = 16;\n+const uint32 kMaxColorAttachments = 16;\n const bool kDepth24Supported = false;\n const bool kUseDefaultTextures = false;\n \n@@ -113,7 +116,7 @@ class FramebufferInfoTest : public testing::Test {\n   static const GLuint kService1Id = 11;\n \n   FramebufferInfoTest()\n-      : manager_(1, 1),\n+      : manager_(kMaxDrawBuffers,  kMaxColorAttachments),\n         feature_info_(new FeatureInfo()),\n         renderbuffer_manager_(NULL, kMaxRenderbufferSize, kMaxSamples,\n                               kDepth24Supported) {\n@@ -590,6 +593,99 @@ TEST_F(FramebufferInfoTest, AttachTexture) {\n   EXPECT_TRUE(framebuffer_->IsCleared());\n }\n \n+TEST_F(FramebufferInfoTest, DrawBuffers) {\n+  const GLuint kTextureClientId[] = { 33, 34 };\n+  const GLuint kTextureServiceId[] = { 333, 334 };\n+\n+  for (GLenum i = GL_COLOR_ATTACHMENT0;\n+       i < GL_COLOR_ATTACHMENT0 + kMaxColorAttachments; ++i) {\n+    EXPECT_FALSE(framebuffer_->HasUnclearedAttachment(i));\n+  }\n+  EXPECT_FALSE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT0),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER0_ARB));\n+  for (GLenum i = GL_DRAW_BUFFER1_ARB;\n+       i < GL_DRAW_BUFFER0_ARB + kMaxDrawBuffers; ++i) {\n+    EXPECT_EQ(static_cast<GLenum>(GL_NONE),\n+              framebuffer_->GetDrawBuffer(i));\n+  }\n+\n+  for (size_t ii = 0; ii < arraysize(kTextureClientId); ++ii) {\n+    texture_manager_->CreateTexture(\n+        kTextureClientId[ii], kTextureServiceId[ii]);\n+    scoped_refptr<TextureRef> texture(\n+        texture_manager_->GetTexture(kTextureClientId[ii]));\n+    ASSERT_TRUE(texture.get() != NULL);\n+\n+    framebuffer_->AttachTexture(\n+        GL_COLOR_ATTACHMENT0 + ii, texture.get(), GL_TEXTURE_2D, 0, 0);\n+    EXPECT_FALSE(\n+        framebuffer_->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0 + ii));\n+\n+    const Framebuffer::Attachment* attachment =\n+        framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT0 + ii);\n+    ASSERT_TRUE(attachment != NULL);\n+    EXPECT_TRUE(attachment->cleared());\n+  }\n+  EXPECT_TRUE(framebuffer_->IsCleared());\n+  EXPECT_FALSE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  // Set a texture as uncleared.\n+  scoped_refptr<TextureRef> texture1(\n+      texture_manager_->GetTexture(kTextureClientId[1]));\n+  texture_manager_->SetTarget(texture1.get(), GL_TEXTURE_2D);\n+  texture_manager_->SetLevelInfo(\n+      texture1.get(), GL_TEXTURE_2D, 0, GL_RGBA, 4, 4,\n+      1, 0, GL_RGBA, GL_UNSIGNED_BYTE, false);\n+\n+  const Framebuffer::Attachment* attachment1 =\n+      framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT1);\n+  ASSERT_TRUE(attachment1 != NULL);\n+  EXPECT_FALSE(attachment1->cleared());\n+  EXPECT_FALSE(framebuffer_->IsCleared());\n+  EXPECT_TRUE(framebuffer_->HasUnclearedAttachment(GL_COLOR_ATTACHMENT1));\n+  EXPECT_TRUE(framebuffer_->HasUnclearedColorAttachments());\n+\n+  GLenum buffers[] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 };\n+  framebuffer_->SetDrawBuffers(2, buffers);\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT0),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER0_ARB));\n+  EXPECT_EQ(static_cast<GLenum>(GL_COLOR_ATTACHMENT1),\n+            framebuffer_->GetDrawBuffer(GL_DRAW_BUFFER1_ARB));\n+  for (GLenum i = GL_DRAW_BUFFER2_ARB;\n+       i < GL_DRAW_BUFFER0_ARB + kMaxDrawBuffers; ++i) {\n+    EXPECT_EQ(static_cast<GLenum>(GL_NONE),\n+              framebuffer_->GetDrawBuffer(i));\n+  }\n+\n+  // Nothing happens.\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+\n+  // Now we disable a draw buffer 1.\n+  buffers[1] = GL_NONE;\n+  framebuffer_->SetDrawBuffers(2, buffers);\n+  // We will enable the disabled draw buffer for clear(), and disable it\n+  // after the clear.\n+  EXPECT_CALL(*gl_, DrawBuffersARB(kMaxDrawBuffers, _))\n+      .Times(1)\n+      .RetiresOnSaturation();\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  EXPECT_CALL(*gl_, DrawBuffersARB(kMaxDrawBuffers, _))\n+      .Times(1)\n+      .RetiresOnSaturation();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+\n+  // Now remove draw buffer 1's attachment.\n+  framebuffer_->AttachTexture(GL_COLOR_ATTACHMENT1, NULL, 0, 0, 0);\n+  EXPECT_TRUE(framebuffer_->GetAttachment(GL_COLOR_ATTACHMENT1) == NULL);\n+\n+  // Nothing happens.\n+  framebuffer_->PrepareDrawBuffersForClear();\n+  framebuffer_->RestoreDrawBuffersAfterClear();\n+}\n+\n class FramebufferInfoFloatTest : public FramebufferInfoTest {\n  public:\n   FramebufferInfoFloatTest()""}<_**next**_>{""sha"": ""f954189ff66863873048905935d0d0bac811a09c"", ""filename"": ""gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 1, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ee7579229ff7e9e5ae28bf53aea069251499d7da/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/gles2_cmd_decoder.cc?ref=ee7579229ff7e9e5ae28bf53aea069251499d7da"", ""patch"": ""@@ -3076,7 +3076,20 @@ bool GLES2DecoderImpl::CheckFramebufferValid(\n       glClearDepth(1.0f);\n       state_.SetDeviceDepthMask(GL_TRUE);\n       state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);\n+      bool reset_draw_buffer = false;\n+      if ((backbuffer_needs_clear_bits_ | GL_COLOR_BUFFER_BIT) != 0 &&\n+          group_->draw_buffer() == GL_NONE) {\n+        reset_draw_buffer = true;\n+        GLenum buf = GL_BACK;\n+        if (GetBackbufferServiceId() != 0)  // emulated backbuffer\n+          buf = GL_COLOR_ATTACHMENT0;\n+        glDrawBuffersARB(1, &buf);\n+      }\n       glClear(backbuffer_needs_clear_bits_);\n+      if (reset_draw_buffer) {\n+        GLenum buf = GL_NONE;\n+        glDrawBuffersARB(1, &buf);\n+      }\n       backbuffer_needs_clear_bits_ = 0;\n       RestoreClearState();\n     }\n@@ -5022,14 +5035,15 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(\n     glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, framebuffer->service_id());\n   }\n   GLbitfield clear_bits = 0;\n-  if (framebuffer->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {\n+  if (framebuffer->HasUnclearedColorAttachments()) {\n     glClearColor(\n         0.0f, 0.0f, 0.0f,\n         (GLES2Util::GetChannelsForFormat(\n              framebuffer->GetColorAttachmentFormat()) & 0x0008) != 0 ? 0.0f :\n                                                                        1.0f);\n     state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);\n     clear_bits |= GL_COLOR_BUFFER_BIT;\n+    framebuffer->PrepareDrawBuffersForClear();\n   }\n \n   if (framebuffer->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||\n@@ -5050,6 +5064,9 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(\n   state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);\n   glClear(clear_bits);\n \n+  if ((clear_bits | GL_COLOR_BUFFER_BIT) != 0)\n+    framebuffer->RestoreDrawBuffersAfterClear();\n+\n   framebuffer_manager()->MarkAttachmentsAsCleared(\n       framebuffer, renderbuffer_manager(), texture_manager());\n ""}","error::Error GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM(
    uint32 immediate_data_size, const cmds::WaitAsyncTexImage2DCHROMIUM& c) {
  TRACE_EVENT0(""gpu"", ""GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM"");
  GLenum target = static_cast<GLenum>(c.target);

  if (GL_TEXTURE_2D != target) {
    LOCAL_SET_GL_ERROR(
        GL_INVALID_ENUM, ""glWaitAsyncTexImage2DCHROMIUM"", ""target"");
    return error::kNoError;
  }
  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(
      &state_, target);
  if (!texture_ref) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""unknown texture"");
    return error::kNoError;
  }
  AsyncPixelTransferDelegate* delegate =
      async_pixel_transfer_manager_->GetPixelTransferDelegate(texture_ref);
  if (!delegate) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""No async transfer started"");
    return error::kNoError;
  }
  delegate->WaitForTransferCompletion();
  ProcessFinishedAsyncTransfers();
  return error::kNoError;
}
","error::Error GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM(
    uint32 immediate_data_size, const cmds::WaitAsyncTexImage2DCHROMIUM& c) {
  TRACE_EVENT0(""gpu"", ""GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM"");
  GLenum target = static_cast<GLenum>(c.target);

  if (GL_TEXTURE_2D != target) {
    LOCAL_SET_GL_ERROR(
        GL_INVALID_ENUM, ""glWaitAsyncTexImage2DCHROMIUM"", ""target"");
    return error::kNoError;
  }
  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(
      &state_, target);
  if (!texture_ref) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""unknown texture"");
    return error::kNoError;
  }
  AsyncPixelTransferDelegate* delegate =
      async_pixel_transfer_manager_->GetPixelTransferDelegate(texture_ref);
  if (!delegate) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""No async transfer started"");
    return error::kNoError;
  }
  delegate->WaitForTransferCompletion();
  ProcessFinishedAsyncTransfers();
  return error::kNoError;
}
",C,,,,"@@ -3076,7 +3076,20 @@ bool GLES2DecoderImpl::CheckFramebufferValid(
       glClearDepth(1.0f);
       state_.SetDeviceDepthMask(GL_TRUE);
       state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
+      bool reset_draw_buffer = false;
+      if ((backbuffer_needs_clear_bits_ | GL_COLOR_BUFFER_BIT) != 0 &&
+          group_->draw_buffer() == GL_NONE) {
+        reset_draw_buffer = true;
+        GLenum buf = GL_BACK;
+        if (GetBackbufferServiceId() != 0)  // emulated backbuffer
+          buf = GL_COLOR_ATTACHMENT0;
+        glDrawBuffersARB(1, &buf);
+      }
       glClear(backbuffer_needs_clear_bits_);
+      if (reset_draw_buffer) {
+        GLenum buf = GL_NONE;
+        glDrawBuffersARB(1, &buf);
+      }
       backbuffer_needs_clear_bits_ = 0;
       RestoreClearState();
     }
@@ -5022,14 +5035,15 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(
     glBindFramebufferEXT(GL_DRAW_FRAMEBUFFER_EXT, framebuffer->service_id());
   }
   GLbitfield clear_bits = 0;
-  if (framebuffer->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {
+  if (framebuffer->HasUnclearedColorAttachments()) {
     glClearColor(
         0.0f, 0.0f, 0.0f,
         (GLES2Util::GetChannelsForFormat(
              framebuffer->GetColorAttachmentFormat()) & 0x0008) != 0 ? 0.0f :
                                                                        1.0f);
     state_.SetDeviceColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
     clear_bits |= GL_COLOR_BUFFER_BIT;
+    framebuffer->PrepareDrawBuffersForClear();
   }
 
   if (framebuffer->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||
@@ -5050,6 +5064,9 @@ void GLES2DecoderImpl::ClearUnclearedAttachments(
   state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);
   glClear(clear_bits);
 
+  if ((clear_bits | GL_COLOR_BUFFER_BIT) != 0)
+    framebuffer->RestoreDrawBuffersAfterClear();
+
   framebuffer_manager()->MarkAttachmentsAsCleared(
       framebuffer, renderbuffer_manager(), texture_manager());
 ",Chrome,ee7579229ff7e9e5ae28bf53aea069251499d7da,38f4c0adff7b42decb912e5382a57e35729315a0,0,"error::Error GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM(
    uint32 immediate_data_size, const cmds::WaitAsyncTexImage2DCHROMIUM& c) {
  TRACE_EVENT0(""gpu"", ""GLES2DecoderImpl::HandleWaitAsyncTexImage2DCHROMIUM"");
  GLenum target = static_cast<GLenum>(c.target);

  if (GL_TEXTURE_2D != target) {
    LOCAL_SET_GL_ERROR(
        GL_INVALID_ENUM, ""glWaitAsyncTexImage2DCHROMIUM"", ""target"");
    return error::kNoError;
  }
  TextureRef* texture_ref = texture_manager()->GetTextureInfoForTarget(
      &state_, target);
  if (!texture_ref) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""unknown texture"");
    return error::kNoError;
  }
  AsyncPixelTransferDelegate* delegate =
      async_pixel_transfer_manager_->GetPixelTransferDelegate(texture_ref);
  if (!delegate) {
      LOCAL_SET_GL_ERROR(
          GL_INVALID_OPERATION,
          ""glWaitAsyncTexImage2DCHROMIUM"", ""No async transfer started"");
    return error::kNoError;
  }
  delegate->WaitForTransferCompletion();
  ProcessFinishedAsyncTransfers();
  return error::kNoError;
}
"
76041,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,0,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",0,keepalived/vrrp/vrrp_parser.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","vrrp_tfile_weight_handler(vector_t *strvec)
{
	int weight;
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);

	if (vector_size(strvec) < 2) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No weight specified for track file %s - ignoring"", tfile->fname);
		return;
	}
	if (tfile->weight != 1) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight already set for track file %s - ignoring %s"", tfile->fname, FMT_STR_VSLOT(strvec, 1));
		return;
	}

	if (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight (%s) for vrrp_track_file %s must be between ""
				 ""[-254..254] inclusive. Ignoring..."", FMT_STR_VSLOT(strvec, 1), tfile->fname);
		weight = 1;
	}

	tfile->weight = weight;
}
","vrrp_tfile_weight_handler(vector_t *strvec)
{
	int weight;
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);

	if (vector_size(strvec) < 2) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No weight specified for track file %s - ignoring"", tfile->fname);
		return;
	}
	if (tfile->weight != 1) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight already set for track file %s - ignoring %s"", tfile->fname, FMT_STR_VSLOT(strvec, 1));
		return;
	}

	if (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight (%s) for vrrp_track_file %s must be between ""
				 ""[-254..254] inclusive. Ignoring..."", FMT_STR_VSLOT(strvec, 1), tfile->fname);
		weight = 1;
	}

	tfile->weight = weight;
}
",C,,,,"@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)
 
 	if (!__test_bit(CONFIG_TEST_BIT, &debug)) {
 		/* Write the value to the file */
-		if ((tf = fopen(tfile->file_path, ""w""))) {
+		if ((tf = fopen_safe(tfile->file_path, ""w""))) {
 			fprintf(tf, ""%d\n"", track_file_init_value);
 			fclose(tf);
 		}",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,0,"vrrp_tfile_weight_handler(vector_t *strvec)
{
	int weight;
	vrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);

	if (vector_size(strvec) < 2) {
		report_config_error(CONFIG_GENERAL_ERROR, ""No weight specified for track file %s - ignoring"", tfile->fname);
		return;
	}
	if (tfile->weight != 1) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight already set for track file %s - ignoring %s"", tfile->fname, FMT_STR_VSLOT(strvec, 1));
		return;
	}

	if (!read_int_strvec(strvec, 1, &weight, -254, 254, true)) {
		report_config_error(CONFIG_GENERAL_ERROR, ""Weight (%s) for vrrp_track_file %s must be between ""
				 ""[-254..254] inclusive. Ignoring..."", FMT_STR_VSLOT(strvec, 1), tfile->fname);
		weight = 1;
	}

	tfile->weight = weight;
}
"
120982,,Remote,Not required,Complete,CVE-2013-2870,https://www.cvedetails.com/cve/CVE-2013-2870/,CWE-399,Medium,Complete,Complete,,2013-07-10,9.3,Use-after-free vulnerability in Google Chrome before 28.0.1500.71 allows remote servers to execute arbitrary code via crafted response traffic after a URL request.,2017-09-18,Exec Code ,0,https://github.com/chromium/chromium/commit/ca8cc70b2de822b939f87effc7c2b83bac280a44,ca8cc70b2de822b939f87effc7c2b83bac280a44,"Revert a workaround commit for a Use-After-Free crash.

Revert a workaround commit r20158 for a Use-After-Free issue (http://crbug.com/244746) because a cleaner CL r207218 is landed.
URLRequestContext does not inherit SupportsWeakPtr now.

R=mmenke
BUG=244746

Review URL: https://chromiumcodereview.appspot.com/16870008

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@207811 0039d316-1c4b-4281-b951-d872f2087c98",0,net/socket_stream/socket_stream_unittest.cc,"{""sha"": ""a52fb1a1e8479cfc27fe6e6bbbcafc2e6857e80b"", ""filename"": ""chrome/browser/net/chrome_url_request_context.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/chrome/browser/net/chrome_url_request_context.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/chrome/browser/net/chrome_url_request_context.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_url_request_context.cc?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -298,7 +298,8 @@ ChromeURLRequestContextGetter::CreateOffTheRecordForIsolatedApp(\n ChromeURLRequestContext::ChromeURLRequestContext(\n     ContextType type,\n     chrome_browser_net::LoadTimeStats* load_time_stats)\n-    : load_time_stats_(load_time_stats) {\n+    : weak_factory_(this),\n+      load_time_stats_(load_time_stats) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));\n   if (load_time_stats_)\n     load_time_stats_->RegisterURLRequestContext(this, type);""}<_**next**_>{""sha"": ""db099927979156f2f7aac8f29d10e0a1197a699a"", ""filename"": ""chrome/browser/net/chrome_url_request_context.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/chrome/browser/net/chrome_url_request_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/chrome/browser/net/chrome_url_request_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_url_request_context.h?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -41,13 +41,15 @@ class ChromeURLRequestContext : public net::URLRequestContext {\n   virtual ~ChromeURLRequestContext();\n \n   base::WeakPtr<ChromeURLRequestContext> GetWeakPtr() {\n-    return base::AsWeakPtr(this);\n+    return weak_factory_.GetWeakPtr();\n   }\n \n   // Copies the state from |other| into this context.\n   void CopyFrom(ChromeURLRequestContext* other);\n \n  private:\n+  base::WeakPtrFactory<ChromeURLRequestContext> weak_factory_;\n+\n   // ---------------------------------------------------------------------------\n   // Important: When adding any new members below, consider whether they need to\n   // be added to CopyFrom.""}<_**next**_>{""sha"": ""dcf0b0f75eed40f765d37d063cf9a80dafbaf7ef"", ""filename"": ""net/socket_stream/socket_stream.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 13, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/socket_stream/socket_stream.cc?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -90,6 +90,7 @@ SocketStream::SocketStream(const GURL& url, Delegate* delegate)\n     : delegate_(delegate),\n       url_(url),\n       max_pending_send_allowed_(kMaxPendingSendAllowed),\n+      context_(NULL),\n       next_state_(STATE_NONE),\n       factory_(ClientSocketFactory::GetDefaultFactory()),\n       proxy_mode_(kDirectConnection),\n@@ -130,13 +131,9 @@ bool SocketStream::is_secure() const {\n }\n \n void SocketStream::set_context(URLRequestContext* context) {\n-  const URLRequestContext* prev_context = context_.get();\n+  const URLRequestContext* prev_context = context_;\n \n-  if (context) {\n-    context_ = context->AsWeakPtr();\n-  } else {\n-    context_.reset();\n-  }\n+  context_ = context;\n \n   if (prev_context != context) {\n     if (prev_context && pac_request_) {\n@@ -158,7 +155,7 @@ void SocketStream::set_context(URLRequestContext* context) {\n }\n \n void SocketStream::CheckPrivacyMode() {\n-  if (context_.get() && context_->network_delegate()) {\n+  if (context_ && context_->network_delegate()) {\n     bool enable = context_->network_delegate()->CanEnablePrivacyMode(url_,\n                                                                      url_);\n     privacy_mode_ = enable ? kPrivacyModeEnabled : kPrivacyModeDisabled;\n@@ -173,7 +170,7 @@ void SocketStream::Connect() {\n       << \""The current base::MessageLoop must exist\"";\n   DCHECK_EQ(base::MessageLoop::TYPE_IO, base::MessageLoop::current()->type())\n       << \""The current base::MessageLoop must be TYPE_IO\"";\n-  if (context_.get()) {\n+  if (context_) {\n     context_->ssl_config_service()->GetSSLConfig(&server_ssl_config_);\n     proxy_ssl_config_ = server_ssl_config_;\n   }\n@@ -451,7 +448,7 @@ void SocketStream::OnWriteCompleted(int result) {\n \n void SocketStream::DoLoop(int result) {\n   // If context was not set, close immediately.\n-  if (!context_.get())\n+  if (!context_)\n     next_state_ = STATE_CLOSE;\n \n   if (next_state_ == STATE_NONE)\n@@ -577,10 +574,8 @@ void SocketStream::DoLoop(int result) {\n \n int SocketStream::DoBeforeConnect() {\n   next_state_ = STATE_BEFORE_CONNECT_COMPLETE;\n-  if (!context_.get() || !context_->network_delegate()) {\n-    // TODO(yhirano): This should not be OK.\n+  if (!context_ || !context_->network_delegate())\n     return OK;\n-  }\n \n   int result = context_->network_delegate()->NotifyBeforeSocketStreamConnect(\n       this, io_callback_);\n@@ -1294,7 +1289,7 @@ int SocketStream::HandleCertificateError(int result) {\n   SSLClientSocket* ssl_socket = static_cast<SSLClientSocket*>(socket_.get());\n   DCHECK(ssl_socket);\n \n-  if (!context_.get())\n+  if (!context_)\n     return result;\n \n   if (SSLClientSocket::IgnoreCertError(result, LOAD_IGNORE_ALL_CERT_ERRORS)) {""}<_**next**_>{""sha"": ""5004060df9a6856de2953d435c6d686376f2ee1d"", ""filename"": ""net/socket_stream/socket_stream.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/socket_stream/socket_stream.h?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -12,7 +12,6 @@\n #include \""base/memory/linked_ptr.h\""\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n-#include \""base/memory/weak_ptr.h\""\n #include \""net/base/address_list.h\""\n #include \""net/base/completion_callback.h\""\n #include \""net/base/io_buffer.h\""\n@@ -130,7 +129,7 @@ class NET_EXPORT SocketStream\n   Delegate* delegate() const { return delegate_; }\n   int max_pending_send_allowed() const { return max_pending_send_allowed_; }\n \n-  URLRequestContext* context() { return context_.get(); }\n+  URLRequestContext* context() { return context_; }\n   // There're some asynchronous operations and members that are constructed from\n   // |context|. Be careful when you use this for the second time or more.\n   void set_context(URLRequestContext* context);\n@@ -342,7 +341,7 @@ class NET_EXPORT SocketStream\n   //   sum of the size of buffers in |pending_write_bufs_|\n   // exceeds this limit, SendData() fails.\n   int max_pending_send_allowed_;\n-  base::WeakPtr<URLRequestContext> context_;\n+  URLRequestContext* context_;\n \n   UserDataMap user_data_;\n ""}<_**next**_>{""sha"": ""bd0a348b0ef0f028c976ada271843247dc81d056"", ""filename"": ""net/socket_stream/socket_stream_unittest.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 62, ""changes"": 62, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/socket_stream/socket_stream_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/socket_stream/socket_stream_unittest.cc?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -962,66 +962,4 @@ TEST_F(SocketStreamTest, OnErrorDetachDelegate) {\n   EXPECT_EQ(OK, test_callback.WaitForResult());\n }\n \n-// A test for the WeakPtr workaround patch which should be deleted\n-// in the future.\n-TEST_F(SocketStreamTest, ContextDestroyedBeforeDoBeforeConnect) {\n-  TestCompletionCallback test_callback;\n-\n-  scoped_ptr<SocketStreamEventRecorder> delegate(\n-      new SocketStreamEventRecorder(test_callback.callback()));\n-\n-  scoped_ptr<TestURLRequestContext> context(new TestURLRequestContext);\n-  TestSocketStreamNetworkDelegate network_delegate;\n-  network_delegate.SetBeforeConnectResult(OK);\n-  context->set_network_delegate(&network_delegate);\n-\n-  scoped_refptr<SocketStream> socket_stream(\n-      new SocketStream(GURL(\""ws://example.com/demo\""), delegate.get()));\n-\n-  socket_stream->set_context(context.get());\n-\n-  socket_stream->Connect();\n-  context.reset();\n-\n-  ASSERT_EQ(0U, delegate->GetSeenEvents().size());\n-\n-  test_callback.WaitForResult();\n-\n-  const std::vector<SocketStreamEvent>& events = delegate->GetSeenEvents();\n-  ASSERT_EQ(1U, events.size());\n-\n-  EXPECT_EQ(SocketStreamEvent::EVENT_CLOSE, events[0].event_type);\n-}\n-\n-// A test for the WeakPtr workaround patch which should be deleted\n-// in the future.\n-TEST_F(SocketStreamTest, SocketStreamResetBeforeDoBeforeConnect) {\n-  TestCompletionCallback test_callback;\n-\n-  scoped_ptr<SocketStreamEventRecorder> delegate(\n-      new SocketStreamEventRecorder(test_callback.callback()));\n-\n-  scoped_ptr<TestURLRequestContext> context(new TestURLRequestContext);\n-  TestSocketStreamNetworkDelegate network_delegate;\n-  network_delegate.SetBeforeConnectResult(OK);\n-  context->set_network_delegate(&network_delegate);\n-\n-  scoped_refptr<SocketStream> socket_stream(\n-      new SocketStream(GURL(\""ws://example.com/demo\""), delegate.get()));\n-\n-  socket_stream->set_context(context.get());\n-\n-  socket_stream->Connect();\n-  socket_stream = NULL;\n-  context.reset();\n-\n-  ASSERT_EQ(0U, delegate->GetSeenEvents().size());\n-  test_callback.WaitForResult();\n-\n-  const std::vector<SocketStreamEvent>& events = delegate->GetSeenEvents();\n-  ASSERT_EQ(1U, events.size());\n-\n-  EXPECT_EQ(SocketStreamEvent::EVENT_CLOSE, events[0].event_type);\n-}\n-\n }  // namespace net""}<_**next**_>{""sha"": ""53da67d7418b39e120bfd296b3fc5c6334d8ae1f"", ""filename"": ""net/url_request/url_request_context.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/url_request/url_request_context.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/ca8cc70b2de822b939f87effc7c2b83bac280a44/net/url_request/url_request_context.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/url_request/url_request_context.h?ref=ca8cc70b2de822b939f87effc7c2b83bac280a44"", ""patch"": ""@@ -45,8 +45,7 @@ class URLRequestThrottlerManager;\n // these member variables, since they may be shared. For the ones that aren't\n // shared, URLRequestContextStorage can be helpful in defining their storage.\n class NET_EXPORT URLRequestContext\n-    : NON_EXPORTED_BASE(public base::NonThreadSafe),\n-      public base::SupportsWeakPtr<URLRequestContext> {\n+    : NON_EXPORTED_BASE(public base::NonThreadSafe) {\n  public:\n   URLRequestContext();\n   virtual ~URLRequestContext();""}","  virtual int DoIOPending(SocketStreamEvent* event) {
    io_test_callback_.callback().Run(OK);
    return ERR_IO_PENDING;
  }
","  virtual int DoIOPending(SocketStreamEvent* event) {
    io_test_callback_.callback().Run(OK);
    return ERR_IO_PENDING;
  }
",C,,,,"@@ -962,66 +962,4 @@ TEST_F(SocketStreamTest, OnErrorDetachDelegate) {
   EXPECT_EQ(OK, test_callback.WaitForResult());
 }
 
-// A test for the WeakPtr workaround patch which should be deleted
-// in the future.
-TEST_F(SocketStreamTest, ContextDestroyedBeforeDoBeforeConnect) {
-  TestCompletionCallback test_callback;
-
-  scoped_ptr<SocketStreamEventRecorder> delegate(
-      new SocketStreamEventRecorder(test_callback.callback()));
-
-  scoped_ptr<TestURLRequestContext> context(new TestURLRequestContext);
-  TestSocketStreamNetworkDelegate network_delegate;
-  network_delegate.SetBeforeConnectResult(OK);
-  context->set_network_delegate(&network_delegate);
-
-  scoped_refptr<SocketStream> socket_stream(
-      new SocketStream(GURL(""ws://example.com/demo""), delegate.get()));
-
-  socket_stream->set_context(context.get());
-
-  socket_stream->Connect();
-  context.reset();
-
-  ASSERT_EQ(0U, delegate->GetSeenEvents().size());
-
-  test_callback.WaitForResult();
-
-  const std::vector<SocketStreamEvent>& events = delegate->GetSeenEvents();
-  ASSERT_EQ(1U, events.size());
-
-  EXPECT_EQ(SocketStreamEvent::EVENT_CLOSE, events[0].event_type);
-}
-
-// A test for the WeakPtr workaround patch which should be deleted
-// in the future.
-TEST_F(SocketStreamTest, SocketStreamResetBeforeDoBeforeConnect) {
-  TestCompletionCallback test_callback;
-
-  scoped_ptr<SocketStreamEventRecorder> delegate(
-      new SocketStreamEventRecorder(test_callback.callback()));
-
-  scoped_ptr<TestURLRequestContext> context(new TestURLRequestContext);
-  TestSocketStreamNetworkDelegate network_delegate;
-  network_delegate.SetBeforeConnectResult(OK);
-  context->set_network_delegate(&network_delegate);
-
-  scoped_refptr<SocketStream> socket_stream(
-      new SocketStream(GURL(""ws://example.com/demo""), delegate.get()));
-
-  socket_stream->set_context(context.get());
-
-  socket_stream->Connect();
-  socket_stream = NULL;
-  context.reset();
-
-  ASSERT_EQ(0U, delegate->GetSeenEvents().size());
-  test_callback.WaitForResult();
-
-  const std::vector<SocketStreamEvent>& events = delegate->GetSeenEvents();
-  ASSERT_EQ(1U, events.size());
-
-  EXPECT_EQ(SocketStreamEvent::EVENT_CLOSE, events[0].event_type);
-}
-
 }  // namespace net",Chrome,ca8cc70b2de822b939f87effc7c2b83bac280a44,12cac19b54cfe4dc6f20ae12ade7b4a05cbcb5fc,0,"  virtual int DoIOPending(SocketStreamEvent* event) {
    io_test_callback_.callback().Run(OK);
    return ERR_IO_PENDING;
  }
"
109918,,Remote,Not required,Partial,CVE-2012-2900,https://www.cvedetails.com/cve/CVE-2012-2900/,,Low,Partial,Partial,,2012-10-09,7.5,"Skia, as used in Google Chrome before 22.0.1229.92, does not properly render text, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via unknown vectors.",2017-09-18,DoS ,0,https://github.com/chromium/chromium/commit/9597042cad54926f50d58f5ada39205eb734d7be,9597042cad54926f50d58f5ada39205eb734d7be,"Revert 137988 - VAVDA is the hardware video decode accelerator for Chrome on Linux and ChromeOS for Intel CPUs (Sandy Bridge and newer).

This CL enables VAVDA acceleration for ChromeOS, both for HTML5 video and Flash.
    
The feature is currently hidden behind a command line flag and can be enabled by adding the --enable-vaapi parameter to command line.
    
BUG=117062
TEST=Manual runs of test streams.
    
Change-Id: I386e16739e2ef2230f52a0a434971b33d8654699


Review URL: https://chromiumcodereview.appspot.com/9814001


This is causing crbug.com/129103
TBR=posciak@chromium.org
Review URL: https://chromiumcodereview.appspot.com/10411066

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@138208 0039d316-1c4b-4281-b951-d872f2087c98",0,content/browser/gpu/gpu_process_host.cc,"{""sha"": ""305419b74cc1b720115a6e9f08226cf50dc6b9a4"", ""filename"": ""content/browser/gpu/gpu_process_host.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/browser/gpu/gpu_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/browser/gpu/gpu_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/gpu/gpu_process_host.cc?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -743,9 +743,6 @@ bool GpuProcessHost::LaunchGpuProcess(const std::string& channel_id) {\n     switches::kEnableLogging,\n #if defined(OS_MACOSX)\n     switches::kEnableSandboxLogging,\n-#endif\n-#if defined(OS_CHROMEOS)\n-    switches::kEnableVaapi,\n #endif\n     switches::kGpuNoContextLost,\n     switches::kGpuStartupDialog,""}<_**next**_>{""sha"": ""c3a5b96fc44d4dabd31a53ec0db441642bc2ceeb"", ""filename"": ""content/common/gpu/media/DEPS"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/common/gpu/media/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/common/gpu/media/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/DEPS?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -1,4 +1,3 @@\n include_rules = [\n   \""+media\"",\n-  \""+third_party/libva\"",\n ]""}<_**next**_>{""sha"": ""6ad1329446cbfa7450a667076c062f38998920c1"", ""filename"": ""content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 26, ""changes"": 33, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/common/gpu/media/gpu_video_decode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/gpu_video_decode_accelerator.cc?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -21,24 +21,15 @@\n #include \""ipc/ipc_message_macros.h\""\n #include \""ipc/ipc_message_utils.h\""\n \n+#if (defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)) || defined(OS_WIN)\n #if defined(OS_WIN)\n #include \""content/common/gpu/media/dxva_video_decode_accelerator.h\""\n-#endif  // OS_WIN\n-\n-#if defined(OS_CHROMEOS)\n-#if defined(ARCH_CPU_ARMEL)\n+#else  // OS_WIN\n #include \""content/common/gpu/media/omx_video_decode_accelerator.h\""\n-#elif defined(ARCH_CPU_X86_FAMILY)\n-#include \""ui/gl/gl_context_glx.h\""\n-#include \""ui/gl/gl_surface_glx.h\""\n-#include \""content/common/gpu/media/vaapi_video_decode_accelerator.h\""\n-#endif  // ARCH_CPU_ARMEL\n-#endif  // OS_CHROMEOS\n-\n-#if defined(OS_WIN) || defined(OS_CHROMEOS)\n+#endif  // OS_WIN\n #include \""ui/gl/gl_context.h\""\n #include \""ui/gl/gl_surface_egl.h\""\n-#endif  // OS_WIN || OS_CHROMEOS\n+#endif\n \n #include \""gpu/command_buffer/service/texture_manager.h\""\n #include \""ui/gfx/size.h\""\n@@ -131,7 +122,7 @@ void GpuVideoDecodeAccelerator::Initialize(\n   DCHECK(init_done_msg);\n   init_done_msg_ = init_done_msg;\n \n-#if defined(OS_CHROMEOS) || defined(OS_WIN)\n+#if (defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)) || defined(OS_WIN)\n   DCHECK(stub_ && stub_->decoder());\n #if defined(OS_WIN)\n   if (base::win::GetVersion() < base::win::VERSION_WIN7) {\n@@ -142,30 +133,20 @@ void GpuVideoDecodeAccelerator::Initialize(\n   DLOG(INFO) << \""Initializing DXVA HW decoder for windows.\"";\n   DXVAVideoDecodeAccelerator* video_decoder =\n       new DXVAVideoDecodeAccelerator(this);\n-#elif defined(OS_CHROMEOS)  // OS_WIN\n-#if defined(ARCH_CPU_ARMEL)\n+#else  // OS_WIN\n   OmxVideoDecodeAccelerator* video_decoder =\n       new OmxVideoDecodeAccelerator(this);\n   video_decoder->SetEglState(\n       gfx::GLSurfaceEGL::GetHardwareDisplay(),\n       stub_->decoder()->GetGLContext()->GetHandle());\n-#elif defined(ARCH_CPU_X86_FAMILY)\n-  VaapiVideoDecodeAccelerator* video_decoder =\n-      new VaapiVideoDecodeAccelerator(this);\n-  gfx::GLContextGLX* glx_context =\n-      static_cast<gfx::GLContextGLX*>(stub_->decoder()->GetGLContext());\n-  GLXContext glx_context_handle =\n-      static_cast<GLXContext>(glx_context->GetHandle());\n-  video_decoder->SetGlxState(glx_context->display(), glx_context_handle);\n-#endif  // ARCH_CPU_ARMEL\n #endif  // OS_WIN\n   video_decode_accelerator_ = video_decoder;\n   if (!video_decode_accelerator_->Initialize(profile))\n     NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n #else  // Update RenderViewImpl::createMediaPlayer when adding clauses.\n   NOTIMPLEMENTED() << \""HW video decode acceleration not available.\"";\n   NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);\n-#endif  // defined(OS_CHROMEOS) || defined(OS_WIN)\n+#endif  // defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)\n }\n \n void GpuVideoDecodeAccelerator::OnDecode(""}<_**next**_>{""sha"": ""56ef173b800a65354e4b854c49bb7bb3652cb945"", ""filename"": ""content/common/gpu/media/h264_dpb.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 118, ""changes"": 118, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/h264_dpb.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/h264_dpb.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/h264_dpb.cc?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,118 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include <algorithm>\n-\n-#include \""base/logging.h\""\n-#include \""base/stl_util.h\""\n-#include \""content/common/gpu/media/h264_dpb.h\""\n-\n-namespace content {\n-\n-H264DPB::H264DPB() {}\n-H264DPB::~H264DPB() {}\n-\n-void H264DPB::Clear() {\n-  pics_.reset();\n-}\n-\n-void H264DPB::RemoveByPOC(int poc) {\n-  for (Pictures::iterator it = pics_.begin(); it != pics_.end(); ++it) {\n-    if ((*it)->pic_order_cnt == poc) {\n-      pics_.erase(it);\n-      return;\n-    }\n-  }\n-  NOTREACHED() << \""Missing POC: \"" << poc;\n-}\n-\n-void H264DPB::RemoveUnused() {\n-  for (Pictures::iterator it = pics_.begin(); it != pics_.end(); ) {\n-    if ((*it)->outputted && !(*it)->ref)\n-      pics_.erase(it++);\n-    else\n-      ++it;\n-  }\n-}\n-\n-void H264DPB::StorePic(H264Picture* pic) {\n-  DCHECK_LT(pics_.size(), kDPBMaxSize);\n-  DVLOG(3) << \""Adding PicNum: \"" << pic->pic_num << \"" ref: \"" << (int)pic->ref\n-           << \"" longterm: \"" << (int)pic->long_term << \"" to DPB\"";\n-  pics_.push_back(pic);\n-}\n-\n-int H264DPB::CountRefPics() {\n-  int ret = 0;\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    if (pics_[i]->ref)\n-      ++ret;\n-  }\n-  return ret;\n-}\n-\n-void H264DPB::MarkAllUnusedForRef() {\n-  for (size_t i = 0; i < pics_.size(); ++i)\n-    pics_[i]->ref = false;\n-}\n-\n-H264Picture* H264DPB::GetShortRefPicByPicNum(int pic_num) {\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (pic->ref && !pic->long_term && pic->pic_num == pic_num)\n-      return pic;\n-  }\n-\n-  DVLOG(1) << \""Missing short ref pic num: \"" << pic_num;\n-  return NULL;\n-}\n-\n-H264Picture* H264DPB::GetLongRefPicByLongTermPicNum(int pic_num) {\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (pic->ref && pic->long_term && pic->long_term_pic_num == pic_num)\n-      return pic;\n-  }\n-\n-  DVLOG(1) << \""Missing long term pic num: \"" << pic_num;\n-  return NULL;\n-}\n-\n-H264Picture* H264DPB::GetLowestFrameNumWrapShortRefPic() {\n-  H264Picture* ret = NULL;\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (pic->ref && !pic->long_term &&\n-        (!ret || pic->frame_num_wrap < ret->frame_num_wrap))\n-      ret = pic;\n-  }\n-  return ret;\n-}\n-\n-void H264DPB::GetNotOutputtedPicsAppending(H264Picture::PtrVector& out) {\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (!pic->outputted)\n-      out.push_back(pic);\n-  }\n-}\n-\n-void H264DPB::GetShortTermRefPicsAppending(H264Picture::PtrVector& out) {\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (pic->ref && !pic->long_term)\n-      out.push_back(pic);\n-  }\n-}\n-\n-void H264DPB::GetLongTermRefPicsAppending(H264Picture::PtrVector& out) {\n-  for (size_t i = 0; i < pics_.size(); ++i) {\n-    H264Picture* pic = pics_[i];\n-    if (pic->ref && pic->long_term)\n-      out.push_back(pic);\n-  }\n-}\n-\n-}  // namespace content\n-""}<_**next**_>{""sha"": ""3fceaf4969980e31e106d80bf57b14e5fadc6bcf"", ""filename"": ""content/common/gpu/media/h264_dpb.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 134, ""changes"": 134, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/h264_dpb.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/h264_dpb.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/h264_dpb.h?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,134 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-//\n-// This file contains an implementation of an H.264 Decoded Picture Buffer\n-// used in H264 decoders.\n-\n-#ifndef CONTENT_COMMON_GPU_MEDIA_H264_DPB_H_\n-#define CONTENT_COMMON_GPU_MEDIA_H264_DPB_H_\n-\n-#include <vector>\n-\n-#include \""base/basictypes.h\""\n-#include \""base/memory/scoped_vector.h\""\n-#include \""content/common/gpu/media/h264_parser.h\""\n-\n-namespace content {\n-\n-// A picture (a frame or a field) in the H.264 spec sense.\n-// See spec at http://www.itu.int/rec/T-REC-H.264\n-struct H264Picture {\n-  enum Field {\n-    FIELD_NONE,\n-    FIELD_TOP,\n-    FIELD_BOTTOM,\n-  };\n-\n-  // Values calculated per H.264 specification or taken from slice header.\n-  // See spec for more details on each (some names have been converted from\n-  // CamelCase in spec to Chromium-style names).\n-  int top_field_order_cnt;\n-  int bottom_field_order_cnt;\n-  int pic_order_cnt;\n-  int pic_order_cnt_msb;\n-  int pic_order_cnt_lsb;\n-\n-  int pic_num;\n-  int long_term_pic_num;\n-  int frame_num;  // from slice header\n-  int frame_num_wrap;\n-  int long_term_frame_idx;\n-\n-  bool idr;  // IDR picture?\n-  bool ref;  // reference picture?\n-  bool long_term;  // long term reference picture?\n-  bool outputted;\n-  // Does memory management op 5 needs to be executed after this\n-  // picture has finished decoding?\n-  bool mem_mgmt_5;\n-\n-  Field field;\n-\n-  // Values from slice_hdr to be used during reference marking and\n-  // memory management after finishing this picture.\n-  bool long_term_reference_flag;\n-  bool adaptive_ref_pic_marking_mode_flag;\n-  H264DecRefPicMarking ref_pic_marking[H264SliceHeader::kRefListSize];\n-\n-  typedef std::vector<H264Picture*> PtrVector;\n-};\n-\n-// DPB - Decoded Picture Buffer.\n-// Stores decoded pictures that will be used for future display\n-// and/or reference.\n-class H264DPB {\n- public:\n-  H264DPB();\n-  ~H264DPB();\n-\n-  // Remove unused (not reference and already outputted) pictures from DPB.\n-  void RemoveUnused();\n-\n-  // Remove a picture by its pic_order_cnt.\n-  void RemoveByPOC(int poc);\n-\n-  // Clear DPB.\n-  void Clear();\n-\n-  // Store picture in DPB. DPB takes ownership of its resources.\n-  void StorePic(H264Picture* pic);\n-\n-  // Return the number of reference pictures in DPB.\n-  int CountRefPics();\n-\n-  // Mark all pictures in DPB as unused for reference.\n-  void MarkAllUnusedForRef();\n-\n-  // Return a short-term reference picture by its pic_num.\n-  H264Picture* GetShortRefPicByPicNum(int pic_num);\n-\n-  // Return a long-term reference picture by its long_term_pic_num.\n-  H264Picture* GetLongRefPicByLongTermPicNum(int pic_num);\n-\n-  // Return the short reference picture with lowest frame_num. Used for sliding\n-  // window memory management.\n-  H264Picture* GetLowestFrameNumWrapShortRefPic();\n-\n-  // Append all pictures that have not been outputted yet to the passed |out|\n-  // vector, sorted by lowest pic_order_cnt (in output order).\n-  void GetNotOutputtedPicsAppending(H264Picture::PtrVector& out);\n-\n-  // Append all short term reference pictures to the passed |out| vector.\n-  void GetShortTermRefPicsAppending(H264Picture::PtrVector& out);\n-\n-  // Append all long term reference pictures to the passed |out| vector.\n-  void GetLongTermRefPicsAppending(H264Picture::PtrVector& out);\n-\n-  // Iterators for direct access to DPB contents.\n-  // Will be invalidated after any of Remove* calls.\n-  typedef ScopedVector<H264Picture> Pictures;\n-  Pictures::iterator begin() { return pics_.begin(); }\n-  Pictures::iterator end() { return pics_.end(); }\n-  Pictures::reverse_iterator rbegin() { return pics_.rbegin(); }\n-  Pictures::reverse_iterator rend() { return pics_.rend(); }\n-\n-  size_t size() const { return pics_.size(); }\n-  bool IsFull() const { return pics_.size() == kDPBMaxSize; }\n-\n-  // Per H264 spec, increase to 32 if interlaced video is supported.\n-  enum { kDPBMaxSize = 16 };\n-\n- private:\n-  // Remove a picture from DPB, freeing its resources.\n-  void RemovePic(const Pictures::iterator iter);\n-\n-  Pictures pics_;\n-\n-  DISALLOW_COPY_AND_ASSIGN(H264DPB);\n-};\n-\n-}  // namespace content\n-\n-#endif  // CONTENT_COMMON_GPU_MEDIA_H264_DPB_H_\n-""}<_**next**_>{""sha"": ""e2a0fb4740ff5161a7abeccd8ea6ee785d1ea2e5"", ""filename"": ""content/common/gpu/media/vaapi_h264_decoder.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 2063, ""changes"": 2063, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_h264_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_h264_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/vaapi_h264_decoder.cc?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,2063 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include <dlfcn.h>\n-\n-#include <algorithm>\n-\n-#include \""base/bind.h\""\n-#include \""base/stl_util.h\""\n-#include \""content/common/gpu/media/vaapi_h264_decoder.h\""\n-#include \""third_party/libva/va/va.h\""\n-#include \""third_party/libva/va/va_x11.h\""\n-#include \""ui/gl/gl_bindings.h\""\n-\n-#define VA_LOG_ON_ERROR(va_res, err_msg)                   \\\n-  do {                                                     \\\n-    if ((va_res) != VA_STATUS_SUCCESS) {                   \\\n-      DVLOG(1) << err_msg                                  \\\n-               << \"" VA error: \"" << VAAPI_ErrorStr(va_res); \\\n-    }                                                      \\\n-  } while(0)\n-\n-#define VA_SUCCESS_OR_RETURN(va_res, err_msg, ret)         \\\n-  do {                                                     \\\n-    if ((va_res) != VA_STATUS_SUCCESS) {                   \\\n-      DVLOG(1) << err_msg                                  \\\n-               << \"" VA error: \"" << VAAPI_ErrorStr(va_res); \\\n-      return (ret);                                        \\\n-    }                                                      \\\n-  } while (0)\n-\n-namespace content {\n-\n-void *vaapi_handle = dlopen(\""libva.so\"", RTLD_NOW);\n-void *vaapi_x11_handle = dlopen(\""libva-x11.so\"", RTLD_NOW);\n-void *vaapi_glx_handle = dlopen(\""libva-glx.so\"", RTLD_NOW);\n-\n-typedef VADisplay (*VaapiGetDisplayGLX)(Display *dpy);\n-typedef int (*VaapiDisplayIsValid)(VADisplay dpy);\n-typedef VAStatus (*VaapiInitialize)(VADisplay dpy,\n-                                    int *major_version,\n-                                    int *minor_version);\n-typedef VAStatus (*VaapiTerminate)(VADisplay dpy);\n-typedef VAStatus (*VaapiGetConfigAttributes)(VADisplay dpy,\n-                                             VAProfile profile,\n-                                             VAEntrypoint entrypoint,\n-                                             VAConfigAttrib *attrib_list,\n-                                             int num_attribs);\n-typedef VAStatus (*VaapiCreateConfig)(VADisplay dpy,\n-                                      VAProfile profile,\n-                                      VAEntrypoint entrypoint,\n-                                      VAConfigAttrib *attrib_list,\n-                                      int num_attribs,\n-                                      VAConfigID *config_id);\n-typedef VAStatus (*VaapiDestroyConfig)(VADisplay dpy, VAConfigID config_id);\n-typedef VAStatus (*VaapiCreateSurfaces)(VADisplay dpy,\n-                                        int width,\n-                                        int height,\n-                                        int format,\n-                                        int num_surfaces,\n-                                        VASurfaceID *surfaces);\n-typedef VAStatus (*VaapiDestroySurfaces)(VADisplay dpy,\n-                                         VASurfaceID *surfaces,\n-                                         int num_surfaces);\n-typedef VAStatus (*VaapiCreateContext)(VADisplay dpy,\n-                                       VAConfigID config_id,\n-                                       int picture_width,\n-                                       int picture_height,\n-                                       int flag,\n-                                       VASurfaceID *render_targets,\n-                                       int num_render_targets,\n-                                       VAContextID *context);\n-typedef VAStatus (*VaapiDestroyContext)(VADisplay dpy, VAContextID context);\n-typedef VAStatus (*VaapiPutSurface)(VADisplay dpy,\n-                                    VASurfaceID surface,\n-                                    Drawable draw,\n-                                    short srcx,\n-                                    short srcy,\n-                                    unsigned short srcw,\n-                                    unsigned short srch,\n-                                    short destx,\n-                                    short desty,\n-                                    unsigned short destw,\n-                                    unsigned short desth,\n-                                    VARectangle *cliprects,\n-                                    unsigned int number_cliprects,\n-                                    unsigned int flags);\n-typedef VAStatus (*VaapiSyncSurface)(VADisplay dpy, VASurfaceID render_target);\n-typedef VAStatus (*VaapiBeginPicture)(VADisplay dpy,\n-                                      VAContextID context,\n-                                      VASurfaceID render_target);\n-typedef VAStatus (*VaapiRenderPicture)(VADisplay dpy,\n-                                       VAContextID context,\n-                                       VABufferID *buffers,\n-                                       int num_buffers);\n-typedef VAStatus (*VaapiEndPicture)(VADisplay dpy, VAContextID context);\n-typedef VAStatus (*VaapiCreateBuffer)(VADisplay dpy,\n-                                      VAContextID context,\n-                                      VABufferType type,\n-                                      unsigned int size,\n-                                      unsigned int num_elements,\n-                                      void *data,\n-                                      VABufferID *buf_id);\n-typedef VAStatus (*VaapiDestroyBuffer)(VADisplay dpy, VABufferID buffer_id);\n-typedef const char* (*VaapiErrorStr)(VAStatus error_status);\n-\n-#define VAAPI_DLSYM(name, handle)                                 \\\n-    Vaapi##name VAAPI_##name =                                    \\\n-        reinterpret_cast<Vaapi##name>(dlsym((handle), \""va\""#name))\n-\n-VAAPI_DLSYM(GetDisplayGLX, vaapi_glx_handle);\n-VAAPI_DLSYM(DisplayIsValid, vaapi_handle);\n-VAAPI_DLSYM(Initialize, vaapi_handle);\n-VAAPI_DLSYM(Terminate, vaapi_handle);\n-VAAPI_DLSYM(GetConfigAttributes, vaapi_handle);\n-VAAPI_DLSYM(CreateConfig, vaapi_handle);\n-VAAPI_DLSYM(DestroyConfig, vaapi_handle);\n-VAAPI_DLSYM(CreateSurfaces, vaapi_handle);\n-VAAPI_DLSYM(DestroySurfaces, vaapi_handle);\n-VAAPI_DLSYM(CreateContext, vaapi_handle);\n-VAAPI_DLSYM(DestroyContext, vaapi_handle);\n-VAAPI_DLSYM(PutSurface, vaapi_x11_handle);\n-VAAPI_DLSYM(SyncSurface, vaapi_x11_handle);\n-VAAPI_DLSYM(BeginPicture, vaapi_handle);\n-VAAPI_DLSYM(RenderPicture, vaapi_handle);\n-VAAPI_DLSYM(EndPicture, vaapi_handle);\n-VAAPI_DLSYM(CreateBuffer, vaapi_handle);\n-VAAPI_DLSYM(DestroyBuffer, vaapi_handle);\n-VAAPI_DLSYM(ErrorStr, vaapi_handle);\n-\n-static bool AreVaapiFunctionPointersInitialized() {\n-  return VAAPI_GetDisplayGLX &&\n-      VAAPI_DisplayIsValid &&\n-      VAAPI_Initialize &&\n-      VAAPI_Terminate &&\n-      VAAPI_GetConfigAttributes &&\n-      VAAPI_CreateConfig &&\n-      VAAPI_DestroyConfig &&\n-      VAAPI_CreateSurfaces &&\n-      VAAPI_DestroySurfaces &&\n-      VAAPI_CreateContext &&\n-      VAAPI_DestroyContext &&\n-      VAAPI_PutSurface &&\n-      VAAPI_SyncSurface &&\n-      VAAPI_BeginPicture &&\n-      VAAPI_RenderPicture &&\n-      VAAPI_EndPicture &&\n-      VAAPI_CreateBuffer &&\n-      VAAPI_DestroyBuffer &&\n-      VAAPI_ErrorStr;\n-}\n-\n-class VaapiH264Decoder::DecodeSurface {\n- public:\n-  DecodeSurface(const GLXFBConfig& fb_config,\n-                Display* x_display,\n-                VADisplay va_display,\n-                VASurfaceID va_surface_id,\n-                int32 picture_buffer_id,\n-                uint32 texture_id,\n-                int width, int height);\n-  ~DecodeSurface();\n-\n-  VASurfaceID va_surface_id() {\n-    return va_surface_id_;\n-  }\n-\n-  int32 picture_buffer_id() {\n-    return picture_buffer_id_;\n-  }\n-\n-  uint32 texture_id() {\n-    return texture_id_;\n-  }\n-\n-  bool available() {\n-    return available_;\n-  }\n-\n-  int32 input_id() {\n-    return input_id_;\n-  }\n-\n-  int poc() {\n-    return poc_;\n-  }\n-\n-  Pixmap x_pixmap() {\n-    return x_pixmap_;\n-  }\n-\n-  // Associate the surface with |input_id| and |poc|, and make it unavailable\n-  // (in use).\n-  void Acquire(int32 input_id, int poc);\n-\n-  // Make this surface available, ready to be reused.\n-  void Release();\n-\n-  // Has to be called before output to sync texture contents.\n-  // Returns true if successful.\n-  bool Sync();\n-\n- private:\n-  Display* x_display_;\n-  VADisplay va_display_;\n-  VASurfaceID va_surface_id_;\n-\n-  // Client-provided ids.\n-  int32 input_id_;\n-  int32 picture_buffer_id_;\n-  uint32 texture_id_;\n-\n-  int width_;\n-  int height_;\n-\n-  // Available for decoding (data no longer used for reference or output).\n-  bool available_;\n-\n-  // PicOrderCount\n-  int poc_;\n-\n-  // Pixmaps bound to this texture.\n-  Pixmap x_pixmap_;\n-  GLXPixmap glx_pixmap_;\n-\n-  DISALLOW_COPY_AND_ASSIGN(DecodeSurface);\n-};\n-\n-VaapiH264Decoder::DecodeSurface::DecodeSurface(const GLXFBConfig& fb_config,\n-                                               Display* x_display,\n-                                               VADisplay va_display,\n-                                               VASurfaceID va_surface_id,\n-                                               int32 picture_buffer_id,\n-                                               uint32 texture_id,\n-                                               int width, int height)\n-    : x_display_(x_display),\n-      va_display_(va_display),\n-      va_surface_id_(va_surface_id),\n-      picture_buffer_id_(picture_buffer_id),\n-      texture_id_(texture_id),\n-      width_(width),\n-      height_(height),\n-      available_(false) {\n-  // Bind the surface to a texture of the given width and height,\n-  // allocating pixmaps as needed.\n-  glEnable(GL_TEXTURE_2D);\n-  glBindTexture(GL_TEXTURE_2D, texture_id_);\n-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n-  glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n-\n-  XWindowAttributes win_attr;\n-  int screen = DefaultScreen(x_display_);\n-  XGetWindowAttributes(x_display_, RootWindow(x_display_, screen), &win_attr);\n-  x_pixmap_ = XCreatePixmap(x_display_, RootWindow(x_display_, screen),\n-                            width_, height_, win_attr.depth);\n-  if (!x_pixmap_) {\n-    DVLOG(1) << \""Failed creating an X Pixmap for TFP\"";\n-    return;\n-  }\n-\n-  static const int pixmap_attr[] = {\n-    GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,\n-    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGB_EXT,\n-    GL_NONE,\n-  };\n-\n-  glx_pixmap_ = glXCreatePixmap(x_display_, fb_config, x_pixmap_,\n-                                pixmap_attr);\n-\n-  glBindTexture(GL_TEXTURE_2D, texture_id_);\n-  glXBindTexImageEXT(x_display_, glx_pixmap_, GLX_FRONT_LEFT_EXT, NULL);\n-\n-  available_ = true;\n-}\n-\n-VaapiH264Decoder::DecodeSurface::~DecodeSurface() {\n-  // Unbind surface from texture and deallocate resources.\n-  glXReleaseTexImageEXT(x_display_, glx_pixmap_, GLX_FRONT_LEFT_EXT);\n-  glXDestroyGLXPixmap(x_display_, glx_pixmap_);\n-  XFreePixmap(x_display_, x_pixmap_);\n-}\n-\n-void VaapiH264Decoder::DecodeSurface::Acquire(int32 input_id, int poc) {\n-  DCHECK_EQ(available_, true);\n-  available_ = false;\n-  input_id_ = input_id;\n-  poc_ = poc;\n-}\n-\n-void VaapiH264Decoder::DecodeSurface::Release() {\n-  available_ = true;\n-}\n-\n-bool VaapiH264Decoder::DecodeSurface::Sync() {\n-  // Put the decoded data into XPixmap bound to the texture.\n-  VAStatus va_res = VAAPI_PutSurface(va_display_,\n-                                     va_surface_id_, x_pixmap_,\n-                                     0, 0, width_, height_,\n-                                     0, 0, width_, height_,\n-                                     NULL, 0, 0);\n-  VA_SUCCESS_OR_RETURN(va_res, \""Failed putting decoded picture to texture\"",\n-                       false);\n-\n-  // Wait for the data to be put into the buffer so it'd ready for output.\n-  va_res = VAAPI_SyncSurface(va_display_, va_surface_id_);\n-  VA_SUCCESS_OR_RETURN(va_res, \""Failed syncing decoded picture\"", false);\n-\n-  return true;\n-}\n-\n-VaapiH264Decoder::VaapiH264Decoder() {\n-  Reset();\n-  curr_sps_id_ = -1;\n-  curr_pps_id_ = -1;\n-  pic_width_ = -1;\n-  pic_height_ = -1;\n-  max_frame_num_ = 0;\n-  max_pic_num_ = 0;\n-  max_long_term_frame_idx_ = 0;\n-  max_pic_order_cnt_lsb_ = 0;\n-  state_ = kUninitialized;\n-  num_available_decode_surfaces_ = 0;\n-}\n-\n-VaapiH264Decoder::~VaapiH264Decoder() {\n-  Destroy();\n-}\n-\n-// This puts the decoder in state where it keeps stream data and is ready\n-// to resume playback from a random location in the stream, but drops all\n-// inputs and outputs and makes all surfaces available for use.\n-void VaapiH264Decoder::Reset() {\n-  frame_ready_at_hw_ = false;\n-\n-  curr_pic_.reset();\n-\n-  frame_num_ = 0;\n-  prev_frame_num_ = -1;\n-  prev_frame_num_offset_ = -1;\n-\n-  prev_ref_has_memmgmnt5_ = false;\n-  prev_ref_top_field_order_cnt_ = -1;\n-  prev_ref_pic_order_cnt_msb_ = -1;\n-  prev_ref_pic_order_cnt_lsb_ = -1;\n-  prev_ref_field_ = H264Picture::FIELD_NONE;\n-\n-  pending_slice_bufs_ = std::queue<VABufferID>();\n-  pending_va_bufs_ = std::queue<VABufferID>();\n-\n-  ref_pic_list0_.clear();\n-  ref_pic_list1_.clear();\n-\n-  for (POCToDecodeSurfaces::iterator it = poc_to_decode_surfaces_.begin();\n-       it != poc_to_decode_surfaces_.end(); ) {\n-    int poc = it->second->poc();\n-    // Must be incremented before UnassignSurfaceFromPoC as this call\n-    // invalidates |it|.\n-    ++it;\n-    DecodeSurface *dec_surface = UnassignSurfaceFromPoC(poc);\n-    if (dec_surface) {\n-      dec_surface->Release();\n-      ++num_available_decode_surfaces_;\n-    }\n-  }\n-  DCHECK(poc_to_decode_surfaces_.empty());\n-\n-  dpb_.Clear();\n-  parser_.Reset();\n-\n-  // Still initialized and ready to decode, unless called from constructor,\n-  // which will change it back.\n-  state_ = kAfterReset;\n-}\n-\n-void VaapiH264Decoder::Destroy() {\n-  VAStatus va_res;\n-\n-  if (state_ == kUninitialized)\n-    return;\n-\n-  switch (state_) {\n-    case kDecoding:\n-    case kAfterReset:\n-    case kError:\n-      DestroyVASurfaces();\n-      // fallthrough\n-    case kInitialized:\n-      va_res = VAAPI_DestroyConfig(va_display_, va_config_id_);\n-      VA_LOG_ON_ERROR(va_res, \""vaDestroyConfig failed\"");\n-      va_res = VAAPI_Terminate(va_display_);\n-      VA_LOG_ON_ERROR(va_res, \""vaTerminate failed\"");\n-      // fallthrough\n-    case kUninitialized:\n-      break;\n-  }\n-\n-  state_ = kUninitialized;\n-}\n-\n-// Maps Profile enum values to VaProfile values.\n-bool VaapiH264Decoder::SetProfile(media::VideoCodecProfile profile) {\n-  switch (profile) {\n-    case media::H264PROFILE_BASELINE:\n-      profile_ = VAProfileH264Baseline;\n-      break;\n-    case media::H264PROFILE_MAIN:\n-      profile_ = VAProfileH264Main;\n-      break;\n-    case media::H264PROFILE_HIGH:\n-      profile_ = VAProfileH264High;\n-      break;\n-    default:\n-      return false;\n-  }\n-  return true;\n-}\n-\n-class ScopedPtrXFree {\n- public:\n-  void operator()(void* x) const {\n-    ::XFree(x);\n-  }\n-};\n-\n-bool VaapiH264Decoder::InitializeFBConfig() {\n-  const int fbconfig_attr[] = {\n-    GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,\n-    GLX_BIND_TO_TEXTURE_TARGETS_EXT, GLX_TEXTURE_2D_BIT_EXT,\n-    GLX_BIND_TO_TEXTURE_RGB_EXT, GL_TRUE,\n-    GLX_Y_INVERTED_EXT, GL_TRUE,\n-    GL_NONE,\n-  };\n-\n-  int num_fbconfigs;\n-  scoped_ptr_malloc<GLXFBConfig, ScopedPtrXFree> glx_fb_configs(\n-      glXChooseFBConfig(x_display_, DefaultScreen(x_display_), fbconfig_attr,\n-                        &num_fbconfigs));\n-  if (!glx_fb_configs.get())\n-    return false;\n-  if (!num_fbconfigs)\n-    return false;\n-\n-  fb_config_ = glx_fb_configs.get()[0];\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::Initialize(media::VideoCodecProfile profile,\n-                                  Display* x_display,\n-                                  GLXContext glx_context,\n-                                  const OutputPicCB& output_pic_cb) {\n-  DCHECK_EQ(state_, kUninitialized);\n-\n-  output_pic_cb_ = output_pic_cb;\n-\n-  x_display_ = x_display;\n-  parent_glx_context_ = glx_context;\n-\n-  if (!SetProfile(profile)) {\n-    DVLOG(1) << \""Unsupported profile\"";\n-    return false;\n-  }\n-\n-  if (!AreVaapiFunctionPointersInitialized()) {\n-    DVLOG(1) << \""Could not load libva\"";\n-    return false;\n-  }\n-\n-  if (!InitializeFBConfig()) {\n-    DVLOG(1) << \""Could not get a usable FBConfig\"";\n-    return false;\n-  }\n-\n-  va_display_ = VAAPI_GetDisplayGLX(x_display_);\n-  if (!VAAPI_DisplayIsValid(va_display_)) {\n-    DVLOG(1) << \""Could not get a valid VA display\"";\n-    return false;\n-  }\n-\n-  int major_version, minor_version;\n-  VAStatus va_res;\n-  va_res = VAAPI_Initialize(va_display_, &major_version, &minor_version);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaInitialize failed\"", false);\n-  DVLOG(1) << \""VAAPI version: \"" << major_version << \"".\"" << minor_version;\n-\n-  VAConfigAttrib attrib;\n-  attrib.type = VAConfigAttribRTFormat;\n-\n-  VAEntrypoint entrypoint = VAEntrypointVLD;\n-  va_res = VAAPI_GetConfigAttributes(va_display_, profile_, entrypoint,\n-                                     &attrib, 1);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaGetConfigAttributes failed\"", false);\n-\n-  if (!(attrib.value & VA_RT_FORMAT_YUV420)) {\n-    DVLOG(1) << \""YUV420 not supported\"";\n-    return false;\n-  }\n-\n-  va_res = VAAPI_CreateConfig(va_display_, profile_, entrypoint,\n-                              &attrib, 1, &va_config_id_);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaCreateConfig failed\"", false);\n-\n-  state_ = kInitialized;\n-  return true;\n-}\n-\n-void VaapiH264Decoder::ReusePictureBuffer(int32 picture_buffer_id) {\n-  DecodeSurfaces::iterator it = decode_surfaces_.find(picture_buffer_id);\n-  if (it == decode_surfaces_.end() || it->second->available()) {\n-    DVLOG(1) << \""Asked to reuse an invalid/already available surface\"";\n-    return;\n-  }\n-  it->second->Release();\n-  ++num_available_decode_surfaces_;\n-}\n-\n-bool VaapiH264Decoder::AssignPictureBuffer(int32 picture_buffer_id,\n-                                           uint32 texture_id) {\n-  DCHECK_EQ(state_, kDecoding);\n-\n-  if (decode_surfaces_.size() >= GetRequiredNumOfPictures()) {\n-    DVLOG(1) << \""Got more surfaces than required\"";\n-    return false;\n-  }\n-\n-  // This will not work if we start using VDA.DismissPicture()\n-  linked_ptr<DecodeSurface> dec_surface(new DecodeSurface(\n-      fb_config_, x_display_, va_display_,\n-      va_surface_ids_[decode_surfaces_.size()], picture_buffer_id, texture_id,\n-      pic_width_, pic_height_));\n-  if (!dec_surface->available()) {\n-    DVLOG(1) << \""Error creating a decoding surface (binding to texture?)\"";\n-    return false;\n-  }\n-\n-  DVLOG(2) << \""New picture assigned, texture id: \"" << dec_surface->texture_id()\n-           << \"" pic buf id: \"" << dec_surface->picture_buffer_id()\n-           << \"" will use va surface \"" << dec_surface->va_surface_id();\n-\n-  bool inserted = decode_surfaces_.insert(std::make_pair(picture_buffer_id,\n-                                                         dec_surface)).second;\n-  DCHECK(inserted);\n-  ++num_available_decode_surfaces_;\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::CreateVASurfaces() {\n-  DCHECK_NE(pic_width_, -1);\n-  DCHECK_NE(pic_height_, -1);\n-  DCHECK_EQ(state_, kInitialized);\n-\n-  // Allocate VASurfaces in driver.\n-  VAStatus va_res = VAAPI_CreateSurfaces(va_display_, pic_width_,\n-                                         pic_height_, VA_RT_FORMAT_YUV420,\n-                                         GetRequiredNumOfPictures(),\n-                                         va_surface_ids_);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaCreateSurfaces failed\"", false);\n-\n-  DCHECK(decode_surfaces_.empty());\n-\n-  // And create a context associated with them.\n-  va_res = VAAPI_CreateContext(va_display_, va_config_id_,\n-                               pic_width_, pic_height_, VA_PROGRESSIVE,\n-                               va_surface_ids_, GetRequiredNumOfPictures(),\n-                               &va_context_id_);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaCreateContext failed\"", false);\n-\n-  return true;\n-}\n-\n-void VaapiH264Decoder::DestroyVASurfaces() {\n-  DCHECK(state_ == kDecoding || state_ == kError || state_ == kAfterReset);\n-\n-  decode_surfaces_.clear();\n-\n-  VAStatus va_res = VAAPI_DestroyContext(va_display_, va_context_id_);\n-  VA_LOG_ON_ERROR(va_res, \""vaDestroyContext failed\"");\n-\n-  va_res = VAAPI_DestroySurfaces(va_display_, va_surface_ids_,\n-                                 GetRequiredNumOfPictures());\n-  VA_LOG_ON_ERROR(va_res, \""vaDestroySurfaces failed\"");\n-}\n-\n-// Fill |va_pic| with default/neutral values.\n-static void InitVAPicture(VAPictureH264* va_pic) {\n-  memset(va_pic, 0, sizeof(*va_pic));\n-  va_pic->picture_id = VA_INVALID_ID;\n-  va_pic->flags = VA_PICTURE_H264_INVALID;\n-}\n-\n-void VaapiH264Decoder::FillVAPicture(VAPictureH264 *va_pic, H264Picture* pic) {\n-  POCToDecodeSurfaces::iterator iter = poc_to_decode_surfaces_.find(\n-      pic->pic_order_cnt);\n-  if (iter == poc_to_decode_surfaces_.end()) {\n-    DVLOG(1) << \""Could not find surface with POC: \"" << pic->pic_order_cnt;\n-    // Cannot provide a ref picture, will corrupt output, but may be able\n-    // to recover.\n-    InitVAPicture(va_pic);\n-    return;\n-  }\n-\n-  va_pic->picture_id = iter->second->va_surface_id();\n-  va_pic->frame_idx = pic->frame_num;\n-  va_pic->flags = 0;\n-\n-  switch (pic->field) {\n-    case H264Picture::FIELD_NONE:\n-      break;\n-    case H264Picture::FIELD_TOP:\n-      va_pic->flags |= VA_PICTURE_H264_TOP_FIELD;\n-      break;\n-    case H264Picture::FIELD_BOTTOM:\n-      va_pic->flags |= VA_PICTURE_H264_BOTTOM_FIELD;\n-      break;\n-  }\n-\n-  if (pic->ref) {\n-    va_pic->flags |= pic->long_term ? VA_PICTURE_H264_LONG_TERM_REFERENCE\n-                                    : VA_PICTURE_H264_SHORT_TERM_REFERENCE;\n-  }\n-\n-  va_pic->TopFieldOrderCnt = pic->top_field_order_cnt;\n-  va_pic->BottomFieldOrderCnt = pic->bottom_field_order_cnt;\n-}\n-\n-int VaapiH264Decoder::FillVARefFramesFromDPB(VAPictureH264 *va_pics,\n-                                             int num_pics) {\n-  H264DPB::Pictures::reverse_iterator rit;\n-  int i;\n-\n-  // Return reference frames in reverse order of insertion.\n-  // Libva does not document this, but other implementations (e.g. mplayer)\n-  // do it this way as well.\n-  for (rit = dpb_.rbegin(), i = 0; rit != dpb_.rend() && i < num_pics; ++rit) {\n-    if ((*rit)->ref)\n-      FillVAPicture(&va_pics[i++], *rit);\n-  }\n-\n-  return i;\n-}\n-\n-// Can only be called when all surfaces are already bound\n-// to textures (cannot be run at the same time as AssignPictureBuffer).\n-bool VaapiH264Decoder::AssignSurfaceToPoC(int poc) {\n-  // Find a surface not currently holding data used for reference and/or\n-  // to be displayed and mark it as used.\n-  DecodeSurfaces::iterator iter = decode_surfaces_.begin();\n-  for (; iter != decode_surfaces_.end(); ++iter) {\n-    if (iter->second->available()) {\n-      --num_available_decode_surfaces_;\n-      DCHECK_GE(num_available_decode_surfaces_, 0);\n-\n-      // Associate with input id and poc and mark as unavailable.\n-      iter->second->Acquire(curr_input_id_, poc);\n-      DVLOG(4) << \""Will use surface \"" << iter->second->va_surface_id()\n-               << \"" for POC \"" << iter->second->poc()\n-               << \"" input ID: \"" << iter->second->input_id();\n-      bool inserted = poc_to_decode_surfaces_.insert(std::make_pair(poc,\n-          iter->second.get())).second;\n-      DCHECK(inserted);\n-      return true;\n-    }\n-  }\n-\n-  // Could not find an available surface.\n-  return false;\n-}\n-\n-// Can only be called when all surfaces are already bound\n-// to textures (cannot be run at the same time as AssignPictureBuffer).\n-VaapiH264Decoder::DecodeSurface* VaapiH264Decoder::UnassignSurfaceFromPoC(\n-    int poc) {\n-  DecodeSurface* dec_surface;\n-  POCToDecodeSurfaces::iterator it = poc_to_decode_surfaces_.find(poc);\n-  if (it == poc_to_decode_surfaces_.end()) {\n-    DVLOG(1) << \""Asked to unassign an unassigned POC\"";\n-    return NULL;\n-  }\n-  dec_surface = it->second;\n-  DVLOG(4) << \""POC \"" << poc << \"" no longer using surface \""\n-           << dec_surface->va_surface_id();\n-  poc_to_decode_surfaces_.erase(it);\n-  return dec_surface;\n-}\n-\n-// Fill a VAPictureParameterBufferH264 to be later sent to the HW decoder.\n-bool VaapiH264Decoder::SendPPS() {\n-  const H264PPS* pps = parser_.GetPPS(curr_pps_id_);\n-  DCHECK(pps);\n-\n-  const H264SPS* sps = parser_.GetSPS(pps->seq_parameter_set_id);\n-  DCHECK(sps);\n-\n-  DCHECK(curr_pic_.get());\n-\n-  VAPictureParameterBufferH264 pic_param;\n-  memset(&pic_param, 0, sizeof(VAPictureParameterBufferH264));\n-\n-#define FROM_SPS_TO_PP(a) pic_param.a = sps->a;\n-#define FROM_SPS_TO_PP2(a, b) pic_param.b = sps->a;\n-  FROM_SPS_TO_PP2(pic_width_in_mbs_minus1, picture_width_in_mbs_minus1);\n-  // This assumes non-interlaced video\n-  FROM_SPS_TO_PP2(pic_height_in_map_units_minus1,\n-                  picture_height_in_mbs_minus1);\n-  FROM_SPS_TO_PP(bit_depth_luma_minus8);\n-  FROM_SPS_TO_PP(bit_depth_chroma_minus8);\n-#undef FROM_SPS_TO_PP\n-#undef FROM_SPS_TO_PP2\n-\n-#define FROM_SPS_TO_PP_SF(a) pic_param.seq_fields.bits.a = sps->a;\n-#define FROM_SPS_TO_PP_SF2(a, b) pic_param.seq_fields.bits.b = sps->a;\n-  FROM_SPS_TO_PP_SF(chroma_format_idc);\n-  FROM_SPS_TO_PP_SF2(separate_colour_plane_flag,\n-                     residual_colour_transform_flag);\n-  FROM_SPS_TO_PP_SF(gaps_in_frame_num_value_allowed_flag);\n-  FROM_SPS_TO_PP_SF(frame_mbs_only_flag);\n-  FROM_SPS_TO_PP_SF(mb_adaptive_frame_field_flag);\n-  FROM_SPS_TO_PP_SF(direct_8x8_inference_flag);\n-  pic_param.seq_fields.bits.MinLumaBiPredSize8x8 = (sps->level_idc >= 31);\n-  FROM_SPS_TO_PP_SF(log2_max_frame_num_minus4);\n-  FROM_SPS_TO_PP_SF(pic_order_cnt_type);\n-  FROM_SPS_TO_PP_SF(log2_max_pic_order_cnt_lsb_minus4);\n-  FROM_SPS_TO_PP_SF(delta_pic_order_always_zero_flag);\n-#undef FROM_SPS_TO_PP_SF\n-#undef FROM_SPS_TO_PP_SF2\n-\n-#define FROM_PPS_TO_PP(a) pic_param.a = pps->a;\n-  FROM_PPS_TO_PP(num_slice_groups_minus1);\n-  pic_param.slice_group_map_type = 0;\n-  pic_param.slice_group_change_rate_minus1 = 0;\n-  FROM_PPS_TO_PP(pic_init_qp_minus26);\n-  FROM_PPS_TO_PP(pic_init_qs_minus26);\n-  FROM_PPS_TO_PP(chroma_qp_index_offset);\n-  FROM_PPS_TO_PP(second_chroma_qp_index_offset);\n-#undef FROM_PPS_TO_PP\n-\n-#define FROM_PPS_TO_PP_PF(a) pic_param.pic_fields.bits.a = pps->a;\n-#define FROM_PPS_TO_PP_PF2(a, b) pic_param.pic_fields.bits.b = pps->a;\n-  FROM_PPS_TO_PP_PF(entropy_coding_mode_flag);\n-  FROM_PPS_TO_PP_PF(weighted_pred_flag);\n-  FROM_PPS_TO_PP_PF(weighted_bipred_idc);\n-  FROM_PPS_TO_PP_PF(transform_8x8_mode_flag);\n-\n-  pic_param.pic_fields.bits.field_pic_flag = 0;\n-  FROM_PPS_TO_PP_PF(constrained_intra_pred_flag);\n-  FROM_PPS_TO_PP_PF2(bottom_field_pic_order_in_frame_present_flag,\n-                pic_order_present_flag);\n-  FROM_PPS_TO_PP_PF(deblocking_filter_control_present_flag);\n-  FROM_PPS_TO_PP_PF(redundant_pic_cnt_present_flag);\n-  pic_param.pic_fields.bits.reference_pic_flag = curr_pic_->ref;\n-#undef FROM_PPS_TO_PP_PF\n-#undef FROM_PPS_TO_PP_PF2\n-\n-  pic_param.frame_num = curr_pic_->frame_num;\n-\n-  InitVAPicture(&pic_param.CurrPic);\n-  FillVAPicture(&pic_param.CurrPic, curr_pic_.get());\n-\n-  // Init reference pictures' array.\n-  for (int i = 0; i < 16; ++i)\n-    InitVAPicture(&pic_param.ReferenceFrames[i]);\n-\n-  // And fill it with picture info from DPB.\n-  FillVARefFramesFromDPB(pic_param.ReferenceFrames,\n-                         arraysize(pic_param.ReferenceFrames));\n-\n-  pic_param.num_ref_frames = sps->max_num_ref_frames;\n-\n-  // Allocate a buffer in driver for this parameter buffer and upload data.\n-  VABufferID pic_param_buf_id;\n-  VAStatus va_res = VAAPI_CreateBuffer(va_display_, va_context_id_,\n-                                       VAPictureParameterBufferType,\n-                                       sizeof(VAPictureParameterBufferH264),\n-                                       1, &pic_param, &pic_param_buf_id);\n-  VA_SUCCESS_OR_RETURN(va_res, \""Failed to create a buffer for PPS\"", false);\n-\n-  // Queue its VA buffer ID to be committed on HW decode run.\n-  pending_va_bufs_.push(pic_param_buf_id);\n-\n-  return true;\n-}\n-\n-// Fill a VAIQMatrixBufferH264 to be later sent to the HW decoder.\n-bool VaapiH264Decoder::SendIQMatrix() {\n-  const H264PPS* pps = parser_.GetPPS(curr_pps_id_);\n-  DCHECK(pps);\n-\n-  VAIQMatrixBufferH264 iq_matrix_buf;\n-  memset(&iq_matrix_buf, 0, sizeof(VAIQMatrixBufferH264));\n-\n-  if (pps->pic_scaling_matrix_present_flag) {\n-    for (int i = 0; i < 6; ++i) {\n-      for (int j = 0; j < 16; ++j)\n-        iq_matrix_buf.ScalingList4x4[i][j] = pps->scaling_list4x4[i][j];\n-    }\n-\n-    for (int i = 0; i < 2; ++i) {\n-      for (int j = 0; j < 64; ++j)\n-        iq_matrix_buf.ScalingList8x8[i][j] = pps->scaling_list8x8[i][j];\n-    }\n-  } else {\n-    const H264SPS* sps = parser_.GetSPS(pps->seq_parameter_set_id);\n-    DCHECK(sps);\n-    for (int i = 0; i < 6; ++i) {\n-      for (int j = 0; j < 16; ++j)\n-        iq_matrix_buf.ScalingList4x4[i][j] = sps->scaling_list4x4[i][j];\n-    }\n-\n-    for (int i = 0; i < 2; ++i) {\n-      for (int j = 0; j < 64; ++j)\n-        iq_matrix_buf.ScalingList8x8[i][j] = sps->scaling_list8x8[i][j];\n-    }\n-  }\n-\n-  // Allocate a buffer in driver for this parameter buffer and upload data.\n-  VABufferID iq_matrix_buf_id;\n-  VAStatus va_res = VAAPI_CreateBuffer(va_display_, va_context_id_,\n-                                       VAIQMatrixBufferType,\n-                                       sizeof(VAIQMatrixBufferH264), 1,\n-                                       &iq_matrix_buf, &iq_matrix_buf_id);\n-  VA_SUCCESS_OR_RETURN(va_res, \""Failed to create a buffer for IQMatrix\"",\n-                       false);\n-\n-  // Queue its VA buffer ID to be committed on HW decode run.\n-  pending_va_bufs_.push(iq_matrix_buf_id);\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::SendVASliceParam(H264SliceHeader* slice_hdr) {\n-  const H264PPS* pps = parser_.GetPPS(slice_hdr->pic_parameter_set_id);\n-  DCHECK(pps);\n-\n-  const H264SPS* sps = parser_.GetSPS(pps->seq_parameter_set_id);\n-  DCHECK(sps);\n-\n-  VASliceParameterBufferH264 slice_param;\n-  memset(&slice_param, 0, sizeof(VASliceParameterBufferH264));\n-\n-  slice_param.slice_data_size = slice_hdr->nalu_size;\n-  slice_param.slice_data_offset = 0;\n-  slice_param.slice_data_flag = VA_SLICE_DATA_FLAG_ALL;\n-  slice_param.slice_data_bit_offset = slice_hdr->header_bit_size;\n-\n-#define SHDRToSP(a) slice_param.a = slice_hdr->a;\n-  SHDRToSP(first_mb_in_slice);\n-  slice_param.slice_type = slice_hdr->slice_type % 5;\n-  SHDRToSP(direct_spatial_mv_pred_flag);\n-\n-  // TODO posciak: make sure parser sets those even when override flags\n-  // in slice header is off.\n-  SHDRToSP(num_ref_idx_l0_active_minus1);\n-  SHDRToSP(num_ref_idx_l1_active_minus1);\n-  SHDRToSP(cabac_init_idc);\n-  SHDRToSP(slice_qp_delta);\n-  SHDRToSP(disable_deblocking_filter_idc);\n-  SHDRToSP(slice_alpha_c0_offset_div2);\n-  SHDRToSP(slice_beta_offset_div2);\n-\n-  if (((slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) &&\n-        pps->weighted_pred_flag) ||\n-      (slice_hdr->IsBSlice() && pps->weighted_bipred_idc == 1)) {\n-    SHDRToSP(luma_log2_weight_denom);\n-    SHDRToSP(chroma_log2_weight_denom);\n-\n-    SHDRToSP(luma_weight_l0_flag);\n-    SHDRToSP(luma_weight_l1_flag);\n-\n-    SHDRToSP(chroma_weight_l0_flag);\n-    SHDRToSP(chroma_weight_l1_flag);\n-\n-    for (int i = 0; i <= slice_param.num_ref_idx_l0_active_minus1; ++i) {\n-      slice_param.luma_weight_l0[i] =\n-          slice_hdr->pred_weight_table_l0.luma_weight[i];\n-      slice_param.luma_offset_l0[i] =\n-          slice_hdr->pred_weight_table_l0.luma_offset[i];\n-\n-      for (int j = 0; j < 2; ++j) {\n-        slice_param.chroma_weight_l0[i][j] =\n-            slice_hdr->pred_weight_table_l0.chroma_weight[i][j];\n-        slice_param.chroma_offset_l0[i][j] =\n-            slice_hdr->pred_weight_table_l0.chroma_offset[i][j];\n-      }\n-    }\n-\n-    if (slice_hdr->IsBSlice()) {\n-      for (int i = 0; i <= slice_param.num_ref_idx_l1_active_minus1; ++i) {\n-        slice_param.luma_weight_l1[i] =\n-            slice_hdr->pred_weight_table_l1.luma_weight[i];\n-        slice_param.luma_offset_l1[i] =\n-            slice_hdr->pred_weight_table_l1.luma_offset[i];\n-\n-        for (int j = 0; j < 2; ++j) {\n-          slice_param.chroma_weight_l1[i][j] =\n-              slice_hdr->pred_weight_table_l1.chroma_weight[i][j];\n-          slice_param.chroma_offset_l1[i][j] =\n-              slice_hdr->pred_weight_table_l1.chroma_offset[i][j];\n-        }\n-      }\n-    }\n-  }\n-\n-  for (int i = 0; i < 32; ++i) {\n-    InitVAPicture(&slice_param.RefPicList0[i]);\n-    InitVAPicture(&slice_param.RefPicList1[i]);\n-  }\n-\n-  int i;\n-  H264Picture::PtrVector::iterator it;\n-  for (it = ref_pic_list0_.begin(), i = 0; it != ref_pic_list0_.end();\n-       ++it, ++i)\n-    FillVAPicture(&slice_param.RefPicList0[i], *it);\n-  for (it = ref_pic_list1_.begin(), i = 0; it != ref_pic_list1_.end();\n-       ++it, ++i)\n-    FillVAPicture(&slice_param.RefPicList1[i], *it);\n-\n-  // Allocate a buffer in driver for this parameter buffer and upload data.\n-  VABufferID slice_param_buf_id;\n-  VAStatus va_res = VAAPI_CreateBuffer(va_display_, va_context_id_,\n-                                       VASliceParameterBufferType,\n-                                       sizeof(VASliceParameterBufferH264),\n-                                       1, &slice_param, &slice_param_buf_id);\n-  VA_SUCCESS_OR_RETURN(va_res, \""Failed creating a buffer for slice param\"",\n-                       false);\n-\n-  // Queue its VA buffer ID to be committed on HW decode run.\n-  pending_slice_bufs_.push(slice_param_buf_id);\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::SendSliceData(const uint8* ptr, size_t size)\n-{\n-    // Can't help it, blame libva...\n-    void* non_const_ptr = const_cast<uint8*>(ptr);\n-\n-    VABufferID slice_data_buf_id;\n-    VAStatus va_res = VAAPI_CreateBuffer(va_display_, va_context_id_,\n-                                         VASliceDataBufferType, size, 1,\n-                                         non_const_ptr, &slice_data_buf_id);\n-    VA_SUCCESS_OR_RETURN(va_res, \""Failed creating a buffer for slice data\"",\n-                         false);\n-\n-    pending_slice_bufs_.push(slice_data_buf_id);\n-    return true;\n-}\n-\n-bool VaapiH264Decoder::QueueSlice(H264SliceHeader* slice_hdr) {\n-  DCHECK(curr_pic_.get());\n-\n-  if (!SendVASliceParam(slice_hdr))\n-    return false;\n-\n-  if (!SendSliceData(slice_hdr->nalu_data, slice_hdr->nalu_size))\n-    return false;\n-\n-  return true;\n-}\n-\n-// TODO(posciak) start using vaMapBuffer instead of vaCreateBuffer wherever\n-// possible.\n-\n-bool VaapiH264Decoder::DecodePicture() {\n-  DCHECK(!frame_ready_at_hw_);\n-  DCHECK(curr_pic_.get());\n-\n-  static const size_t kMaxVABuffers = 32;\n-  DCHECK_LE(pending_va_bufs_.size(), kMaxVABuffers);\n-  DCHECK_LE(pending_slice_bufs_.size(), kMaxVABuffers);\n-\n-  DVLOG(4) << \""Pending VA bufs to commit: \"" << pending_va_bufs_.size();\n-  DVLOG(4) << \""Pending slice bufs to commit: \"" << pending_slice_bufs_.size();\n-\n-  // Find the surface associated with the picture to be decoded.\n-  DCHECK(pending_slice_bufs_.size());\n-  DecodeSurface* dec_surface =\n-      poc_to_decode_surfaces_[curr_pic_->pic_order_cnt];\n-  DVLOG(4) << \""Decoding POC \"" << curr_pic_->pic_order_cnt\n-           << \"" into surface \"" << dec_surface->va_surface_id();\n-\n-  // Get ready to decode into surface.\n-  VAStatus va_res = VAAPI_BeginPicture(va_display_, va_context_id_,\n-                                       dec_surface->va_surface_id());\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaBeginPicture failed\"", false);\n-\n-  // Put buffer IDs for pending parameter buffers into buffers[].\n-  VABufferID buffers[kMaxVABuffers];\n-  size_t num_buffers = pending_va_bufs_.size();\n-  for (size_t i = 0; i < num_buffers && i < kMaxVABuffers; ++i) {\n-    buffers[i] = pending_va_bufs_.front();\n-    pending_va_bufs_.pop();\n-  }\n-\n-  // And send them to the HW decoder.\n-  va_res = VAAPI_RenderPicture(va_display_, va_context_id_, buffers,\n-                               num_buffers);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaRenderPicture for va_bufs failed\"", false);\n-\n-  DVLOG(4) << \""Committed \"" << num_buffers << \""VA buffers\"";\n-\n-  for (size_t i = 0; i < num_buffers; ++i) {\n-    va_res = VAAPI_DestroyBuffer(va_display_, buffers[i]);\n-    VA_SUCCESS_OR_RETURN(va_res, \""vaDestroyBuffer for va_bufs failed\"", false);\n-  }\n-\n-  // Put buffer IDs for pending slice data buffers into buffers[].\n-  num_buffers = pending_slice_bufs_.size();\n-  for (size_t i = 0; i < num_buffers && i < kMaxVABuffers; ++i) {\n-    buffers[i] = pending_slice_bufs_.front();\n-    pending_slice_bufs_.pop();\n-  }\n-\n-  // And send them to the Hw decoder.\n-  va_res = VAAPI_RenderPicture(va_display_, va_context_id_, buffers,\n-                               num_buffers);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaRenderPicture for slices failed\"", false);\n-\n-  DVLOG(4) << \""Committed \"" << num_buffers << \""slice buffers\"";\n-\n-  for (size_t i = 0; i < num_buffers; ++i) {\n-    va_res = VAAPI_DestroyBuffer(va_display_, buffers[i]);\n-    VA_SUCCESS_OR_RETURN(va_res, \""vaDestroyBuffer for slices failed\"", false);\n-  }\n-\n-  // Instruct HW decoder to start processing committed buffers (decode this\n-  // picture). This does not block until the end of decode.\n-  va_res = VAAPI_EndPicture(va_display_, va_context_id_);\n-  VA_SUCCESS_OR_RETURN(va_res, \""vaEndPicture failed\"", false);\n-\n-  // Used to notify clients that we had sufficient data to start decoding\n-  // a new frame.\n-  frame_ready_at_hw_ = true;\n-  return true;\n-}\n-\n-\n-bool VaapiH264Decoder::InitCurrPicture(H264SliceHeader* slice_hdr) {\n-  DCHECK(curr_pic_.get());\n-\n-  memset(curr_pic_.get(), 0, sizeof(H264Picture));\n-\n-  curr_pic_->idr = slice_hdr->idr_pic_flag;\n-\n-  if (slice_hdr->field_pic_flag) {\n-    curr_pic_->field = slice_hdr->bottom_field_flag ? H264Picture::FIELD_BOTTOM\n-                                                    : H264Picture::FIELD_TOP;\n-  } else {\n-    curr_pic_->field = H264Picture::FIELD_NONE;\n-  }\n-\n-  curr_pic_->ref = slice_hdr->nal_ref_idc != 0;\n-  // This assumes non-interlaced stream.\n-  curr_pic_->frame_num = curr_pic_->pic_num = slice_hdr->frame_num;\n-\n-  if (!CalculatePicOrderCounts(slice_hdr))\n-    return false;\n-\n-  // Try to get an empty surface to decode this picture to.\n-  if (!AssignSurfaceToPoC(curr_pic_->pic_order_cnt)) {\n-    DVLOG(1) << \""Failed getting a free surface for a picture\"";\n-    return false;\n-  }\n-\n-  curr_pic_->long_term_reference_flag = slice_hdr->long_term_reference_flag;\n-  curr_pic_->adaptive_ref_pic_marking_mode_flag =\n-      slice_hdr->adaptive_ref_pic_marking_mode_flag;\n-\n-  // If the slice header indicates we will have to perform reference marking\n-  // process after this picture is decoded, store required data for that\n-  // purpose.\n-  if (slice_hdr->adaptive_ref_pic_marking_mode_flag) {\n-    COMPILE_ASSERT(sizeof(curr_pic_->ref_pic_marking) ==\n-                   sizeof(slice_hdr->ref_pic_marking),\n-                   ref_pic_marking_array_sizes_do_not_match);\n-    memcpy(curr_pic_->ref_pic_marking, slice_hdr->ref_pic_marking,\n-           sizeof(curr_pic_->ref_pic_marking));\n-  }\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::CalculatePicOrderCounts(H264SliceHeader* slice_hdr) {\n-  DCHECK_NE(curr_sps_id_, -1);\n-\n-  int pic_order_cnt_lsb = slice_hdr->pic_order_cnt_lsb;\n-  curr_pic_->pic_order_cnt_lsb = pic_order_cnt_lsb;\n-  if (parser_.GetSPS(curr_sps_id_)->pic_order_cnt_type != 0) {\n-    DVLOG(1) << \""Unsupported pic_order_cnt_type\"";\n-    return false;\n-  }\n-\n-  // See spec 8.2.1.1.\n-  int prev_pic_order_cnt_msb, prev_pic_order_cnt_lsb;\n-  if (slice_hdr->idr_pic_flag) {\n-    prev_pic_order_cnt_msb = prev_pic_order_cnt_lsb = 0;\n-  } else {\n-    if (prev_ref_has_memmgmnt5_) {\n-      if (prev_ref_field_ != H264Picture::FIELD_BOTTOM) {\n-        prev_pic_order_cnt_msb = 0;\n-        prev_pic_order_cnt_lsb = prev_ref_top_field_order_cnt_;\n-      } else {\n-        prev_pic_order_cnt_msb = 0;\n-        prev_pic_order_cnt_lsb = 0;\n-      }\n-    } else {\n-      prev_pic_order_cnt_msb = prev_ref_pic_order_cnt_msb_;\n-      prev_pic_order_cnt_lsb = prev_ref_pic_order_cnt_lsb_;\n-    }\n-  }\n-\n-  DCHECK_NE(max_pic_order_cnt_lsb_, 0);\n-  if ((pic_order_cnt_lsb < prev_pic_order_cnt_lsb) &&\n-      (prev_pic_order_cnt_lsb - pic_order_cnt_lsb >=\n-       max_pic_order_cnt_lsb_ / 2)) {\n-    curr_pic_->pic_order_cnt_msb = prev_pic_order_cnt_msb +\n-        max_pic_order_cnt_lsb_;\n-  } else if ((pic_order_cnt_lsb > prev_pic_order_cnt_lsb) &&\n-      (pic_order_cnt_lsb - prev_pic_order_cnt_lsb >\n-       max_pic_order_cnt_lsb_ / 2)) {\n-    curr_pic_->pic_order_cnt_msb = prev_pic_order_cnt_msb -\n-        max_pic_order_cnt_lsb_;\n-  } else {\n-    curr_pic_->pic_order_cnt_msb = prev_pic_order_cnt_msb;\n-  }\n-\n-  if (curr_pic_->field != H264Picture::FIELD_BOTTOM) {\n-    curr_pic_->top_field_order_cnt = curr_pic_->pic_order_cnt_msb +\n-        pic_order_cnt_lsb;\n-  }\n-\n-  if (curr_pic_->field != H264Picture::FIELD_TOP) {\n-    // TODO posciak: perhaps replace with pic->field?\n-    if (!slice_hdr->field_pic_flag) {\n-      curr_pic_->bottom_field_order_cnt = curr_pic_->top_field_order_cnt +\n-          slice_hdr->delta_pic_order_cnt_bottom;\n-    } else {\n-      curr_pic_->bottom_field_order_cnt = curr_pic_->pic_order_cnt_msb +\n-          pic_order_cnt_lsb;\n-    }\n-  }\n-\n-  switch (curr_pic_->field) {\n-    case H264Picture::FIELD_NONE:\n-      curr_pic_->pic_order_cnt = std::min(curr_pic_->top_field_order_cnt,\n-                                          curr_pic_->bottom_field_order_cnt);\n-      break;\n-    case H264Picture::FIELD_TOP:\n-      curr_pic_->pic_order_cnt = curr_pic_->top_field_order_cnt;\n-      break;\n-    case H264Picture::FIELD_BOTTOM:\n-      curr_pic_->pic_order_cnt = curr_pic_->bottom_field_order_cnt;\n-      break;\n-  }\n-\n-  return true;\n-}\n-\n-void VaapiH264Decoder::UpdatePicNums() {\n-  for (H264DPB::Pictures::iterator it = dpb_.begin(); it != dpb_.end(); ++it) {\n-    H264Picture* pic = *it;\n-    DCHECK(pic);\n-    if (!pic->ref)\n-      continue;\n-\n-    // Below assumes non-interlaced stream.\n-    DCHECK_EQ(pic->field, H264Picture::FIELD_NONE);\n-    if (pic->long_term) {\n-      pic->long_term_pic_num = pic->long_term_frame_idx;\n-    } else {\n-      if (pic->frame_num > frame_num_)\n-        pic->frame_num_wrap = pic->frame_num - max_frame_num_;\n-      else\n-        pic->frame_num_wrap = pic->frame_num;\n-\n-      pic->pic_num = pic->frame_num_wrap;\n-    }\n-  }\n-}\n-\n-struct PicNumDescCompare {\n-  bool operator()(const H264Picture* a, const H264Picture* b) const {\n-    return a->pic_num > b->pic_num;\n-  }\n-};\n-\n-struct LongTermPicNumAscCompare {\n-  bool operator()(const H264Picture* a, const H264Picture* b) const {\n-    return a->long_term_pic_num < b->long_term_pic_num;\n-  }\n-};\n-\n-void VaapiH264Decoder::ConstructReferencePicListsP(H264SliceHeader* slice_hdr) {\n-  // RefPicList0 (8.2.4.2.1) [[1] [2]], where:\n-  // [1] shortterm ref pics sorted by descending pic_num,\n-  // [2] longterm ref pics by ascending long_term_pic_num.\n-  DCHECK(ref_pic_list0_.empty() && ref_pic_list1_.empty());\n-  // First get the short ref pics...\n-  dpb_.GetShortTermRefPicsAppending(ref_pic_list0_);\n-  size_t num_short_refs = ref_pic_list0_.size();\n-\n-  // and sort them to get [1].\n-  std::sort(ref_pic_list0_.begin(), ref_pic_list0_.end(), PicNumDescCompare());\n-\n-  // Now get long term pics and sort them by long_term_pic_num to get [2].\n-  dpb_.GetLongTermRefPicsAppending(ref_pic_list0_);\n-  std::sort(ref_pic_list0_.begin() + num_short_refs, ref_pic_list0_.end(),\n-            LongTermPicNumAscCompare());\n-\n-  // Cut off if we have more than requested in slice header.\n-  ref_pic_list0_.resize(slice_hdr->num_ref_idx_l0_active_minus1 + 1);\n-}\n-\n-struct POCAscCompare {\n-  bool operator()(const H264Picture* a, const H264Picture* b) const {\n-    return a->pic_order_cnt < b->pic_order_cnt;\n-  }\n-};\n-\n-struct POCDescCompare {\n-  bool operator()(const H264Picture* a, const H264Picture* b) const {\n-    return a->pic_order_cnt > b->pic_order_cnt;\n-  }\n-};\n-\n-void VaapiH264Decoder::ConstructReferencePicListsB(H264SliceHeader* slice_hdr) {\n-  // RefPicList0 (8.2.4.2.3) [[1] [2] [3]], where:\n-  // [1] shortterm ref pics with POC < curr_pic's POC sorted by descending POC,\n-  // [2] shortterm ref pics with POC > curr_pic's POC by ascending POC,\n-  // [3] longterm ref pics by ascending long_term_pic_num.\n-  DCHECK(ref_pic_list0_.empty() && ref_pic_list1_.empty());\n-  dpb_.GetShortTermRefPicsAppending(ref_pic_list0_);\n-  size_t num_short_refs = ref_pic_list0_.size();\n-\n-  // First sort ascending, this will put [1] in right place and finish [2].\n-  std::sort(ref_pic_list0_.begin(), ref_pic_list0_.end(), POCAscCompare());\n-\n-  // Find first with POC > curr_pic's POC to get first element in [2]...\n-  H264Picture::PtrVector::iterator iter;\n-  iter = std::upper_bound(ref_pic_list0_.begin(), ref_pic_list0_.end(),\n-                          curr_pic_.get(), POCAscCompare());\n-\n-  // and sort [1] descending, thus finishing sequence [1] [2].\n-  std::sort(ref_pic_list0_.begin(), iter, POCDescCompare());\n-\n-  // Now add [3] and sort by ascending long_term_pic_num.\n-  dpb_.GetLongTermRefPicsAppending(ref_pic_list0_);\n-  std::sort(ref_pic_list0_.begin() + num_short_refs, ref_pic_list0_.end(),\n-            LongTermPicNumAscCompare());\n-\n-  // RefPicList1 (8.2.4.2.4) [[1] [2] [3]], where:\n-  // [1] shortterm ref pics with POC > curr_pic's POC sorted by ascending POC,\n-  // [2] shortterm ref pics with POC < curr_pic's POC by descending POC,\n-  // [3] longterm ref pics by ascending long_term_pic_num.\n-\n-  dpb_.GetShortTermRefPicsAppending(ref_pic_list1_);\n-  num_short_refs = ref_pic_list1_.size();\n-\n-  // First sort by descending POC.\n-  std::sort(ref_pic_list1_.begin(), ref_pic_list1_.end(), POCDescCompare());\n-\n-  // Find first with POC < curr_pic's POC to get first element in [2]...\n-  iter = std::upper_bound(ref_pic_list1_.begin(), ref_pic_list1_.end(),\n-                          curr_pic_.get(), POCDescCompare());\n-\n-  // and sort [1] ascending.\n-  std::sort(ref_pic_list1_.begin(), iter, POCAscCompare());\n-\n-  // Now add [3] and sort by ascending long_term_pic_num\n-  dpb_.GetShortTermRefPicsAppending(ref_pic_list1_);\n-  std::sort(ref_pic_list1_.begin() + num_short_refs, ref_pic_list1_.end(),\n-            LongTermPicNumAscCompare());\n-\n-  // If lists identical, swap first two entries in RefPicList1 (spec 8.2.4.2.3)\n-  if (ref_pic_list1_.size() > 1 &&\n-      std::equal(ref_pic_list0_.begin(), ref_pic_list0_.end(),\n-                 ref_pic_list1_.begin()))\n-    std::swap(ref_pic_list1_[0], ref_pic_list1_[1]);\n-\n-  // Per 8.2.4.2 it's possible for num_ref_idx_lX_active_minus1 to indicate\n-  // there should be more ref pics on list than we constructed.\n-  // Those superfluous ones should be treated as non-reference.\n-  ref_pic_list0_.resize(slice_hdr->num_ref_idx_l0_active_minus1 + 1);\n-  ref_pic_list1_.resize(slice_hdr->num_ref_idx_l1_active_minus1 + 1);\n-}\n-\n-// See 8.2.4\n-int VaapiH264Decoder::PicNumF(H264Picture *pic) {\n-  if (!pic)\n-      return -1;\n-\n-  if (!pic->long_term)\n-      return pic->pic_num;\n-  else\n-      return max_pic_num_;\n-}\n-\n-// See 8.2.4\n-int VaapiH264Decoder::LongTermPicNumF(H264Picture *pic) {\n-  if (pic->ref && pic->long_term)\n-    return pic->long_term_pic_num;\n-  else\n-    return 2 * (max_long_term_frame_idx_ + 1);\n-}\n-\n-// Shift elements on the |v| starting from |from| to |to|, inclusive,\n-// one position to the right and insert pic at |from|.\n-static void ShiftRightAndInsert(H264Picture::PtrVector& v,\n-                                int from,\n-                                int to,\n-                                H264Picture* pic) {\n-  DCHECK(pic);\n-  for (int i = to + 1; i > from; --i)\n-    v[i] = v[i - 1];\n-\n-  v[from] = pic;\n-}\n-\n-bool VaapiH264Decoder::ModifyReferencePicList(H264SliceHeader *slice_hdr,\n-                                              int list) {\n-  int num_ref_idx_lX_active_minus1;\n-  H264Picture::PtrVector* ref_pic_listx;\n-  H264ModificationOfPicNum* list_mod;\n-\n-  // This can process either ref_pic_list0 or ref_pic_list1, depending on\n-  // the list argument. Set up pointers to proper list to be processed here.\n-  if (list == 0) {\n-    if (!slice_hdr->ref_pic_list_modification_flag_l0)\n-      return true;\n-\n-    list_mod = slice_hdr->ref_list_l0_modifications;\n-    num_ref_idx_lX_active_minus1 = ref_pic_list0_.size() - 1;\n-\n-    ref_pic_listx = &ref_pic_list0_;\n-  } else {\n-    if (!slice_hdr->ref_pic_list_modification_flag_l1)\n-      return true;\n-\n-    list_mod = slice_hdr->ref_list_l1_modifications;\n-    num_ref_idx_lX_active_minus1 = ref_pic_list1_.size() - 1;\n-\n-    ref_pic_listx = &ref_pic_list1_;\n-  }\n-\n-  DCHECK_GT(num_ref_idx_lX_active_minus1, 0);\n-\n-  // Spec 8.2.4.3:\n-  // Reorder pictures on the list in a way specified in the stream.\n-  int pic_num_lx_pred = curr_pic_->pic_num;\n-  int ref_idx_lx = 0;\n-  int pic_num_lx_no_wrap;\n-  int pic_num_lx;\n-  H264Picture *pic ;\n-  for (int i = 0; i < H264SliceHeader::kRefListModSize; ++i) {\n-    switch (list_mod->modification_of_pic_nums_idc) {\n-      case 0:\n-      case 1:\n-        // Modify short reference picture position.\n-        if (list_mod->modification_of_pic_nums_idc == 0) {\n-          // Subtract given value from predicted PicNum.\n-          pic_num_lx_no_wrap = pic_num_lx_pred -\n-              (static_cast<int>(list_mod->abs_diff_pic_num_minus1) + 1);\n-          // Wrap around max_pic_num_ if it becomes < 0 as result\n-          // of subtraction.\n-          if (pic_num_lx_no_wrap < 0)\n-            pic_num_lx_no_wrap += max_pic_num_;\n-        } else {\n-          // Add given value to predicted PicNum.\n-          pic_num_lx_no_wrap = pic_num_lx_pred +\n-              (static_cast<int>(list_mod->abs_diff_pic_num_minus1) + 1);\n-          // Wrap around max_pic_num_ if it becomes >= max_pic_num_ as result\n-          // of the addition.\n-          if (pic_num_lx_no_wrap >= max_pic_num_)\n-            pic_num_lx_no_wrap -= max_pic_num_;\n-        }\n-\n-        // For use in next iteration.\n-        pic_num_lx_pred = pic_num_lx_no_wrap;\n-\n-        if (pic_num_lx_no_wrap > curr_pic_->pic_num)\n-          pic_num_lx = pic_num_lx_no_wrap - max_pic_num_;\n-        else\n-          pic_num_lx = pic_num_lx_no_wrap;\n-\n-        DCHECK_LT(num_ref_idx_lX_active_minus1 + 1,\n-                  H264SliceHeader::kRefListModSize);\n-        pic = dpb_.GetShortRefPicByPicNum(pic_num_lx);\n-        if (!pic) {\n-          DVLOG(1) << \""Malformed stream, no pic num \"" << pic_num_lx;\n-          return false;\n-        }\n-        ShiftRightAndInsert(*ref_pic_listx, ref_idx_lx,\n-                            num_ref_idx_lX_active_minus1, pic);\n-        ref_idx_lx++;\n-\n-        for (int src = ref_idx_lx, dst = ref_idx_lx;\n-             src <= num_ref_idx_lX_active_minus1 + 1; ++src) {\n-          if (PicNumF((*ref_pic_listx)[src]) != pic_num_lx)\n-            (*ref_pic_listx)[dst++] = (*ref_pic_listx)[src];\n-        }\n-        break;\n-\n-      case 2:\n-        // Modify long term reference picture position.\n-        DCHECK_LT(num_ref_idx_lX_active_minus1 + 1,\n-                  H264SliceHeader::kRefListModSize);\n-        pic = dpb_.GetLongRefPicByLongTermPicNum(list_mod->long_term_pic_num);\n-        if (!pic) {\n-          DVLOG(1) << \""Malformed stream, no pic num \"" << pic_num_lx;\n-          return false;\n-        }\n-        ShiftRightAndInsert(*ref_pic_listx, ref_idx_lx,\n-                            num_ref_idx_lX_active_minus1, pic);\n-        ref_idx_lx++;\n-\n-        for (int src = ref_idx_lx, dst = ref_idx_lx;\n-             src <= num_ref_idx_lX_active_minus1 + 1; ++src) {\n-          if (LongTermPicNumF((*ref_pic_listx)[src])\n-              != static_cast<int>(list_mod->long_term_pic_num))\n-            (*ref_pic_listx)[dst++] = (*ref_pic_listx)[src];\n-        }\n-        break;\n-\n-      case 3:\n-        // End of modification list.\n-        return true;\n-\n-      default:\n-        // May be recoverable.\n-        DVLOG(1) << \""Invalid modification_of_pic_nums_idc=\""\n-                 << list_mod->modification_of_pic_nums_idc\n-                 << \"" in position \"" << i;\n-        break;\n-    }\n-\n-    ++list_mod;\n-  }\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::PutPicToTexture(int32 picture_buffer_id) {\n-  DecodeSurfaces::iterator it = decode_surfaces_.find(picture_buffer_id);\n-  if (it == decode_surfaces_.end()) {\n-    DVLOG(1) << \""Asked to put an invalid buffer\"";\n-    return false;\n-  }\n-\n-  DVLOG(3) << \""Will output from VASurface \"" << it->second->va_surface_id()\n-           << \"" to texture id \"" << it->second->texture_id();\n-\n-  return it->second->Sync();\n-}\n-\n-bool VaapiH264Decoder::OutputPic(H264Picture* pic) {\n-  // No longer need to keep POC->surface mapping, since for decoder this POC\n-  // is finished with. When the client returns this surface via\n-  // ReusePictureBuffer(), it will be marked back as available for use.\n-  DecodeSurface* dec_surface = UnassignSurfaceFromPoC(pic->pic_order_cnt);\n-  if (!dec_surface)\n-    return false;\n-\n-  // Notify the client that a picture can be output. The decoded picture may\n-  // not be synced with texture contents yet at this point. The client has\n-  // to use PutPicToTexture() to ensure that.\n-  DVLOG(4) << \""Posting output task for input_id: \"" << dec_surface->input_id()\n-           << \""output_id: \"" << dec_surface->picture_buffer_id();\n-  output_pic_cb_.Run(dec_surface->input_id(),\n-                     dec_surface->picture_buffer_id());\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::Flush() {\n-  // Output all pictures that are waiting to be outputted.\n-  H264Picture::PtrVector to_output;\n-  dpb_.GetNotOutputtedPicsAppending(to_output);\n-  // Sort them by ascending POC to output in order.\n-  std::sort(to_output.begin(), to_output.end(), POCAscCompare());\n-\n-  H264Picture::PtrVector::iterator it;\n-  for (it = to_output.begin(); it != to_output.end(); ++it) {\n-    if (!OutputPic(*it)) {\n-      DVLOG(1) << \""Failed to output pic POC: \"" << (*it)->pic_order_cnt;\n-      return false;\n-    }\n-  }\n-\n-  // And clear DPB contents.\n-  dpb_.Clear();\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::StartNewFrame(H264SliceHeader* slice_hdr) {\n-  // TODO posciak: add handling of max_num_ref_frames per spec.\n-\n-  // If the new frame is an IDR, output what's left to output and clear DPB\n-  if (slice_hdr->idr_pic_flag) {\n-    // (unless we are explicitly instructed not to do so).\n-    if (!slice_hdr->no_output_of_prior_pics_flag) {\n-      // Output DPB contents.\n-      if (!Flush())\n-        return false;\n-    }\n-    dpb_.Clear();\n-  }\n-\n-  // curr_pic_ should have either been added to DPB or discarded when finishing\n-  // the last frame. DPB is responsible for releasing that memory once it's\n-  // not needed anymore.\n-  DCHECK(!curr_pic_.get());\n-  curr_pic_.reset(new H264Picture);\n-  CHECK(curr_pic_.get());\n-\n-  if (!InitCurrPicture(slice_hdr))\n-    return false;\n-\n-  DCHECK_GT(max_frame_num_, 0);\n-\n-  UpdatePicNums();\n-\n-  // Prepare reference picture lists if required (B and S/SP slices).\n-  ref_pic_list0_.clear();\n-  ref_pic_list1_.clear();\n-  if (slice_hdr->IsPSlice() || slice_hdr->IsSPSlice()) {\n-    ConstructReferencePicListsP(slice_hdr);\n-    if (!ModifyReferencePicList(slice_hdr, 0))\n-      return false;\n-  } else if (slice_hdr->IsBSlice()) {\n-    ConstructReferencePicListsB(slice_hdr);\n-    if (!ModifyReferencePicList(slice_hdr, 0))\n-      return false;\n-    if (!ModifyReferencePicList(slice_hdr, 1))\n-      return false;\n-  }\n-\n-  // Send parameter buffers before each new picture, before the first slice.\n-  if (!SendPPS())\n-    return false;\n-\n-  if (!SendIQMatrix())\n-    return false;\n-\n-  if (!QueueSlice(slice_hdr))\n-    return false;\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::HandleMemoryManagementOps() {\n-  // 8.2.5.4\n-  for (unsigned int i = 0; i < arraysize(curr_pic_->ref_pic_marking); ++i) {\n-    // Code below does not support interlaced stream (per-field pictures).\n-    H264DecRefPicMarking* ref_pic_marking = &curr_pic_->ref_pic_marking[i];\n-    H264Picture* to_mark;\n-    int pic_num_x;\n-\n-    switch (ref_pic_marking->memory_mgmnt_control_operation) {\n-      case 0:\n-        // Normal end of operations' specification.\n-        return true;\n-\n-      case 1:\n-        // Mark a short term reference picture as unused so it can be removed\n-        // if outputted.\n-        pic_num_x = curr_pic_->pic_num -\n-            (ref_pic_marking->difference_of_pic_nums_minus1 + 1);\n-        to_mark = dpb_.GetShortRefPicByPicNum(pic_num_x);\n-        if (to_mark) {\n-          to_mark->ref = false;\n-        } else {\n-          DVLOG(1) << \""Invalid short ref pic num to unmark\"";\n-          return false;\n-        }\n-        break;\n-\n-      case 2:\n-        // Mark a long term reference picture as unused so it can be removed\n-        // if outputted.\n-        to_mark = dpb_.GetLongRefPicByLongTermPicNum(\n-            ref_pic_marking->long_term_pic_num);\n-        if (to_mark) {\n-          to_mark->ref = false;\n-        } else {\n-          DVLOG(1) << \""Invalid long term ref pic num to unmark\"";\n-          return false;\n-        }\n-        break;\n-\n-      case 3:\n-        // Mark a short term reference picture as long term reference.\n-        pic_num_x = curr_pic_->pic_num -\n-            (ref_pic_marking->difference_of_pic_nums_minus1 + 1);\n-        to_mark = dpb_.GetShortRefPicByPicNum(pic_num_x);\n-        if (to_mark) {\n-          DCHECK(to_mark->ref && !to_mark->long_term);\n-          to_mark->long_term = true;\n-          to_mark->long_term_frame_idx = ref_pic_marking->long_term_frame_idx;\n-        } else {\n-          DVLOG(1) << \""Invalid short term ref pic num to mark as long ref\"";\n-          return false;\n-        }\n-        break;\n-\n-      case 4: {\n-        // Unmark all reference pictures with long_term_frame_idx over new max.\n-        max_long_term_frame_idx_\n-            = ref_pic_marking->max_long_term_frame_idx_plus1 - 1;\n-        H264Picture::PtrVector long_terms;\n-        dpb_.GetLongTermRefPicsAppending(long_terms);\n-        for (size_t i = 0; i < long_terms.size(); ++i) {\n-          H264Picture* pic = long_terms[i];\n-          DCHECK(pic->ref && pic->long_term);\n-          // Ok to cast, max_long_term_frame_idx is much smaller than 16bit.\n-          if (pic->long_term_frame_idx >\n-              static_cast<int>(max_long_term_frame_idx_))\n-            pic->ref = false;\n-        }\n-        break;\n-      }\n-\n-      case 5:\n-        // Unmark all reference pictures.\n-        dpb_.MarkAllUnusedForRef();\n-        max_long_term_frame_idx_ = -1;\n-        curr_pic_->mem_mgmt_5 = true;\n-        break;\n-\n-      case 6: {\n-        // Replace long term reference pictures with current picture.\n-        // First unmark if any existing with this long_term_frame_idx...\n-        H264Picture::PtrVector long_terms;\n-        dpb_.GetLongTermRefPicsAppending(long_terms);\n-        for (size_t i = 0; i < long_terms.size(); ++i) {\n-          H264Picture* pic = long_terms[i];\n-          DCHECK(pic->ref && pic->long_term);\n-          // Ok to cast, long_term_frame_idx is much smaller than 16bit.\n-          if (pic->long_term_frame_idx ==\n-              static_cast<int>(ref_pic_marking->long_term_frame_idx))\n-            pic->ref = false;\n-        }\n-\n-        // and mark the current one instead.\n-        curr_pic_->ref = true;\n-        curr_pic_->long_term = true;\n-        curr_pic_->long_term_frame_idx = ref_pic_marking->long_term_frame_idx;\n-        break;\n-      }\n-\n-      default:\n-        // Would indicate a bug in parser.\n-        NOTREACHED();\n-    }\n-  }\n-\n-  return true;\n-}\n-\n-// This method ensures that DPB does not overflow, either by removing\n-// reference pictures as specified in the stream, or using a sliding window\n-// procedure to remove the oldest one.\n-// It also performs marking and unmarking pictures as reference.\n-// See spac 8.2.5.1.\n-void VaapiH264Decoder::ReferencePictureMarking() {\n-  if (curr_pic_->idr) {\n-    // If current picture is an IDR, all reference pictures are unmarked.\n-    dpb_.MarkAllUnusedForRef();\n-\n-    if (curr_pic_->long_term_reference_flag) {\n-      curr_pic_->long_term = true;\n-      curr_pic_->long_term_frame_idx = 0;\n-      max_long_term_frame_idx_ = 0;\n-    } else {\n-      curr_pic_->long_term = false;\n-      max_long_term_frame_idx_ = -1;\n-    }\n-  } else {\n-    if (!curr_pic_->adaptive_ref_pic_marking_mode_flag) {\n-      // If non-IDR, and the stream does not indicate what we should do to\n-      // ensure DPB doesn't overflow, discard oldest picture.\n-      // See spec 8.2.5.3.\n-      if (curr_pic_->field == H264Picture::FIELD_NONE) {\n-        DCHECK_LE(dpb_.CountRefPics(),\n-            std::max<int>(parser_.GetSPS(curr_sps_id_)->max_num_ref_frames,\n-                          1));\n-        if (dpb_.CountRefPics() ==\n-            std::max<int>(parser_.GetSPS(curr_sps_id_)->max_num_ref_frames,\n-                          1)) {\n-          // Max number of reference pics reached,\n-          // need to remove one of the short term ones.\n-          // Find smallest frame_num_wrap short reference picture and mark\n-          // it as unused.\n-          H264Picture* to_unmark = dpb_.GetLowestFrameNumWrapShortRefPic();\n-          if (to_unmark == NULL) {\n-            DVLOG(1) << \""Couldn't find a short ref picture to unmark\"";\n-            return;\n-          }\n-          to_unmark->ref = false;\n-        }\n-      } else {\n-        // Shouldn't get here.\n-        DVLOG(1) << \""Interlaced video not supported.\"";\n-      }\n-    } else {\n-      // Stream has instructions how to discard pictures from DPB and how\n-      // to mark/unmark existing reference pictures. Do it.\n-      // Spec 8.2.5.4.\n-      if (curr_pic_->field == H264Picture::FIELD_NONE) {\n-        HandleMemoryManagementOps();\n-      } else {\n-        // Shouldn't get here.\n-        DVLOG(1) << \""Interlaced video not supported.\"";\n-      }\n-    }\n-  }\n-}\n-\n-bool VaapiH264Decoder::FinishPicture() {\n-  DCHECK(curr_pic_.get());\n-\n-  // Finish processing previous picture.\n-  // Start by storing previous reference picture data for later use,\n-  // if picture being finished is a reference picture.\n-  if (curr_pic_->ref) {\n-    ReferencePictureMarking();\n-    prev_ref_has_memmgmnt5_ = curr_pic_->mem_mgmt_5;\n-    prev_ref_top_field_order_cnt_ = curr_pic_->top_field_order_cnt;\n-    prev_ref_pic_order_cnt_msb_ = curr_pic_->pic_order_cnt_msb;\n-    prev_ref_pic_order_cnt_lsb_ = curr_pic_->pic_order_cnt_lsb;\n-    prev_ref_field_ = curr_pic_->field;\n-  }\n-\n-  // Remove unused (for reference or later output) pictures from DPB.\n-  dpb_.RemoveUnused();\n-\n-  DVLOG(4) << \""Finishing picture, DPB entries: \"" << dpb_.size()\n-           << \"" Num available dec surfaces: \""\n-           << num_available_decode_surfaces_;\n-\n-  if (dpb_.IsFull()) {\n-    // DPB is full, we have to make space for the new picture.\n-    // Get all pictures that haven't been outputted yet.\n-    H264Picture::PtrVector not_outputted;\n-    dpb_.GetNotOutputtedPicsAppending(not_outputted);\n-    std::sort(not_outputted.begin(), not_outputted.end(), POCAscCompare());\n-    H264Picture::PtrVector::iterator output_candidate = not_outputted.begin();\n-\n-    // Keep outputting pictures until we can either output the picture being\n-    // finished and discard it (if it is not a reference picture), or until\n-    // we can discard an older picture that was just waiting for output and\n-    // is not a reference picture, thus making space for the current one.\n-    while (dpb_.IsFull()) {\n-      // Maybe outputted enough to output current picture.\n-      if (!curr_pic_->ref && (output_candidate == not_outputted.end() ||\n-          curr_pic_->pic_order_cnt < (*output_candidate)->pic_order_cnt)) {\n-        // curr_pic_ is not a reference picture and no preceding pictures are\n-        // waiting for output in DPB, so it can be outputted and discarded\n-        // without storing in DPB.\n-        if (!OutputPic(curr_pic_.get()))\n-          return false;\n-\n-        // Managed to output current picture, return without adding to DPB.\n-        return true;\n-      }\n-\n-      // Couldn't output current picture, so try to output the lowest PoC\n-      // from DPB.\n-      if (output_candidate != not_outputted.end()) {\n-        if (!OutputPic(*output_candidate))\n-          return false;\n-\n-        // If outputted picture wasn't a reference picture, it can be removed.\n-        if (!(*output_candidate)->ref)\n-          dpb_.RemoveByPOC((*output_candidate)->pic_order_cnt);\n-      } else {\n-        // Couldn't output current pic and couldn't do anything\n-        // with existing pictures in DPB, so we can't make space.\n-        // This should not happen.\n-        DVLOG(1) << \""Could not free up space in DPB!\"";\n-        return false;\n-      }\n-    }\n-    ++output_candidate;\n-  }\n-\n-  // Store current picture for later output and/or reference (ownership now\n-  // with the DPB).\n-  dpb_.StorePic(curr_pic_.release());\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::ProcessSPS(int sps_id) {\n-  const H264SPS* sps = parser_.GetSPS(sps_id);\n-  DCHECK(sps);\n-\n-  if (sps->frame_mbs_only_flag == 0) {\n-    // Fields/interlaced video not supported.\n-    DVLOG(1) << \""frame_mbs_only_flag != 1 not supported\"";\n-    return false;\n-  }\n-\n-  if (sps->gaps_in_frame_num_value_allowed_flag) {\n-    DVLOG(1) << \""Gaps in frame numbers not supported\"";\n-    return false;\n-  }\n-\n-  if (sps->pic_order_cnt_type != 0) {\n-    DVLOG(1) << \""Unsupported pic_order_cnt_type\"";\n-    return false;\n-  }\n-\n-  curr_sps_id_ = sps->seq_parameter_set_id;\n-\n-  // Calculate picture height/width (spec 7.4.2.1.1, 7.4.3).\n-  int width = 16 * (sps->pic_width_in_mbs_minus1 + 1);\n-  int height = 16 * (2 - sps->frame_mbs_only_flag) *\n-      (sps->pic_height_in_map_units_minus1 + 1);\n-\n-  if ((pic_width_ != -1 || pic_height_ != -1) &&\n-      (width != pic_width_ || height != pic_height_)) {\n-    DVLOG(1) << \""Picture size changed mid-stream\"";\n-    return false;\n-  }\n-\n-  pic_width_ = width;\n-  pic_height_ = height;\n-  DVLOG(1) << \""New picture size: \"" << pic_width_ << \""x\"" << pic_height_;\n-\n-  max_pic_order_cnt_lsb_ = 1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4);\n-  max_frame_num_ = 1 << (sps->log2_max_frame_num_minus4 + 4);\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::ProcessPPS(int pps_id) {\n-  const H264PPS* pps = parser_.GetPPS(pps_id);\n-  DCHECK(pps);\n-\n-  curr_pps_id_ = pps->pic_parameter_set_id;\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::FinishPrevFrameIfPresent() {\n-  // If we already have a frame waiting to be decoded, decode it and finish.\n-  if (curr_pic_ != NULL) {\n-    if (!DecodePicture())\n-      return false;\n-    return FinishPicture();\n-  }\n-\n-  return true;\n-}\n-\n-bool VaapiH264Decoder::ProcessSlice(H264SliceHeader* slice_hdr) {\n-  prev_frame_num_ = frame_num_;\n-  frame_num_ = slice_hdr->frame_num;\n-\n-  if (prev_frame_num_ > 0 && prev_frame_num_ < frame_num_ - 1) {\n-    DVLOG(1) << \""Gap in frame_num!\"";\n-    return false;\n-  }\n-\n-  if (slice_hdr->field_pic_flag == 0)\n-    max_pic_num_ = max_frame_num_;\n-  else\n-    max_pic_num_ = 2 * max_frame_num_;\n-\n-  // TODO posciak: switch to new picture detection per 7.4.1.2.4.\n-  if (curr_pic_ != NULL && slice_hdr->first_mb_in_slice != 0) {\n-    // This is just some more slice data of the current picture, so\n-    // just queue it and return.\n-    QueueSlice(slice_hdr);\n-    return true;\n-  } else {\n-    // A new frame, so first finish the previous one before processing it...\n-    if (!FinishPrevFrameIfPresent())\n-      return false;\n-\n-    // and then start a new one.\n-    return StartNewFrame(slice_hdr);\n-  }\n-}\n-\n-#define SET_ERROR_AND_RETURN()             \\\n-  do {                                     \\\n-    DVLOG(1) << \""Error during decode\"";     \\\n-    state_ = kError;                       \\\n-    return VaapiH264Decoder::kDecodeError; \\\n-  } while (0)\n-\n-VaapiH264Decoder::DecResult VaapiH264Decoder::DecodeInitial(int32 input_id) {\n-  // Decode enough to get required picture size (i.e. until we find an SPS),\n-  // if we get any slice data, we are missing the beginning of the stream.\n-  H264NALU nalu;\n-  H264Parser::Result res;\n-\n-  DCHECK_NE(state_, kUninitialized);\n-\n-  curr_input_id_ = input_id;\n-\n-  while (1) {\n-    // Get next NALU looking for SPS or IDR if after reset.\n-    res = parser_.AdvanceToNextNALU(&nalu);\n-    if (res == H264Parser::kEOStream) {\n-      DVLOG(1) << \""Could not find SPS before EOS\"";\n-      return kNeedMoreStreamData;\n-    } else if (res != H264Parser::kOk) {\n-      SET_ERROR_AND_RETURN();\n-    }\n-\n-    DVLOG(4) << \"" NALU found: \"" << static_cast<int>(nalu.nal_unit_type);\n-\n-    switch (nalu.nal_unit_type) {\n-      case H264NALU::kSPS:\n-        res = parser_.ParseSPS(&curr_sps_id_);\n-        if (res != H264Parser::kOk)\n-          SET_ERROR_AND_RETURN();\n-\n-        if (!ProcessSPS(curr_sps_id_))\n-          SET_ERROR_AND_RETURN();\n-\n-        // Just got information about the video size from SPS, so we can\n-        // now allocate surfaces and let the client now we are ready to\n-        // accept output buffers and decode.\n-        if (!CreateVASurfaces())\n-          SET_ERROR_AND_RETURN();\n-\n-        state_ = kDecoding;\n-        return kReadyToDecode;\n-\n-      case H264NALU::kIDRSlice:\n-        // If after reset, should be able to recover from an IDR.\n-        if (state_ == kAfterReset) {\n-          H264SliceHeader slice_hdr;\n-\n-          res = parser_.ParseSliceHeader(nalu, &slice_hdr);\n-          if (res != H264Parser::kOk)\n-            SET_ERROR_AND_RETURN();\n-\n-          if (!ProcessSlice(&slice_hdr))\n-            SET_ERROR_AND_RETURN();\n-\n-          state_ = kDecoding;\n-          return kReadyToDecode;\n-        }  // else fallthrough\n-      case H264NALU::kNonIDRSlice:\n-      case H264NALU::kPPS:\n-        // Non-IDR slices cannot be used as resume points, as we may not\n-        // have all reference pictures that they may require.\n-        // fallthrough\n-      default:\n-        // Skip everything unless it's PPS or an IDR slice (if after reset).\n-        DVLOG(4) << \""Skipping NALU\"";\n-        break;\n-    }\n-  }\n-}\n-\n-void VaapiH264Decoder::SetStream(uint8* ptr, size_t size) {\n-  DCHECK(ptr);\n-  DCHECK(size);\n-\n-  // Got new input stream data from the client.\n-  DVLOG(4) << \""New input stream chunk at \"" << (void*) ptr\n-           << \"" size:  \"" << size;\n-  parser_.SetStream(ptr, size);\n-}\n-\n-VaapiH264Decoder::DecResult VaapiH264Decoder::DecodeOneFrame(int32 input_id) {\n-  // Decode until one full frame is decoded or return it or until end\n-  // of stream (end of input data is reached).\n-  H264Parser::Result par_res;\n-  H264NALU nalu;\n-\n-  curr_input_id_ = input_id;\n-\n-  if (state_ != kDecoding) {\n-    DVLOG(1) << \""Decoder not ready: error in stream or not initialized\"";\n-    return kDecodeError;\n-  } else if (num_available_decode_surfaces_ < 1) {\n-    DVLOG(4) << \""No output surfaces available\"";\n-    return kNoOutputAvailable;\n-  }\n-\n-  // All of the actions below might result in decoding a picture from\n-  // previously parsed data, but we still have to handle/parse current input\n-  // first.\n-  // Note: this may drop some already decoded frames if there are errors\n-  // further in the stream, but we are OK with that.\n-  while (1) {\n-    par_res = parser_.AdvanceToNextNALU(&nalu);\n-    if (par_res == H264Parser::kEOStream)\n-      return kNeedMoreStreamData;\n-    else if (par_res != H264Parser::kOk)\n-      SET_ERROR_AND_RETURN();\n-\n-    DVLOG(4) << \""NALU found: \"" << static_cast<int>(nalu.nal_unit_type);\n-\n-    switch (nalu.nal_unit_type) {\n-      case H264NALU::kNonIDRSlice:\n-      case H264NALU::kIDRSlice: {\n-        H264SliceHeader slice_hdr;\n-\n-        par_res = parser_.ParseSliceHeader(nalu, &slice_hdr);\n-        if (par_res != H264Parser::kOk)\n-          SET_ERROR_AND_RETURN();\n-\n-        if (!ProcessSlice(&slice_hdr))\n-          SET_ERROR_AND_RETURN();\n-        break;\n-      }\n-\n-      case H264NALU::kSPS:\n-        int sps_id;\n-\n-        if (!FinishPrevFrameIfPresent())\n-          SET_ERROR_AND_RETURN();\n-\n-        par_res = parser_.ParseSPS(&sps_id);\n-        if (par_res != H264Parser::kOk)\n-          SET_ERROR_AND_RETURN();\n-\n-        if (!ProcessSPS(sps_id))\n-          SET_ERROR_AND_RETURN();\n-        break;\n-\n-      case H264NALU::kPPS:\n-        int pps_id;\n-\n-        if (!FinishPrevFrameIfPresent())\n-          SET_ERROR_AND_RETURN();\n-\n-        par_res = parser_.ParsePPS(&pps_id);\n-        if (par_res != H264Parser::kOk)\n-          SET_ERROR_AND_RETURN();\n-\n-        if (!ProcessPPS(pps_id))\n-          SET_ERROR_AND_RETURN();\n-        break;\n-\n-      default:\n-        // skip NALU\n-        break;\n-    }\n-\n-    // If the last action resulted in decoding a frame, possibly from older\n-    // data, return. Otherwise keep reading the stream.\n-    if (frame_ready_at_hw_) {\n-      frame_ready_at_hw_ = false;\n-      return kDecodedFrame;\n-    }\n-  }\n-}\n-\n-// static\n-size_t VaapiH264Decoder::GetRequiredNumOfPictures() {\n-  return kNumReqPictures;\n-}\n-\n-}  // namespace content\n-""}<_**next**_>{""sha"": ""abf67387ce2ce1d696d438694a22d471f88583a8"", ""filename"": ""content/common/gpu/media/vaapi_h264_decoder.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 335, ""changes"": 335, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_h264_decoder.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_h264_decoder.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/vaapi_h264_decoder.h?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,335 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-//\n-// This file contains an implementation of a class that provides H264 decode\n-// support for use with VAAPI hardware video decode acceleration on Intel\n-// systems.\n-\n-#ifndef CONTENT_COMMON_GPU_MEDIA_VAAPI_H264_DECODER_H_\n-#define CONTENT_COMMON_GPU_MEDIA_VAAPI_H264_DECODER_H_\n-\n-#include <GL/glx.h>\n-\n-#include <queue>\n-\n-#include \""base/callback_forward.h\""\n-#include \""base/lazy_instance.h\""\n-#include \""base/memory/linked_ptr.h\""\n-#include \""base/memory/scoped_ptr.h\""\n-#include \""content/common/gpu/media/h264_dpb.h\""\n-#include \""content/common/gpu/media/h264_parser.h\""\n-#include \""media/base/video_decoder_config.h\""\n-#include \""media/base/limits.h\""\n-#include \""third_party/libva/va/va.h\""\n-\n-namespace content {\n-\n-// An H264 decoder for use for VA-API-specific decoding. Provides features not\n-// supported by libva, including stream parsing, reference picture management\n-// and other operations not supported by the HW codec.\n-//\n-// Provides functionality to allow plugging VAAPI HW acceleration into the\n-// VDA framework.\n-//\n-// Clients of this class are expected to pass H264 Annex-B byte stream and\n-// will receive decoded pictures via client-provided |OutputPicCB|.\n-//\n-// If used in multi-threaded environment, some of the functions have to be\n-// called on the child thread, i.e. the main thread of the GPU process\n-// (the one that has the GLX context passed to Initialize() set as current).\n-// This is essential so that the GLX calls can work properly.\n-// Decoder thread, on the other hand, does not require a GLX context and should\n-// be the same as the one on which Decode*() functions are called.\n-class VaapiH264Decoder {\n- public:\n-  // Callback invoked on the client when a picture is to be displayed.\n-  // Callee has to call PutPicToTexture() for the given picture before\n-  // displaying it, to ensure the contents have been synced properly.\n-  // Arguments: input buffer id, output buffer id (both provided by the client\n-  // at the time of Decode() and AssignPictureBuffer() calls).\n-  typedef base::Callback<void(int32, int32)> OutputPicCB;\n-\n-  // Decode result codes.\n-  enum DecResult {\n-    kDecodeError,  // Error while decoding.\n-    // TODO posciak: unsupported streams are currently treated as error\n-    // in decoding; in future it could perhaps be possible to fall back\n-    // to software decoding instead.\n-    // kStreamError,  // Error in stream.\n-    kReadyToDecode,  // Successfully initialized.\n-    kDecodedFrame,  // Successfully decoded a frame.\n-    kNeedMoreStreamData,  // Need more stream data to decode the next frame.\n-    kNoOutputAvailable,  // Waiting for the client to free up output surfaces.\n-  };\n-\n-  VaapiH264Decoder();\n-  // Should be called on the GLX thread, for the surface cleanup to work\n-  // properly.\n-  ~VaapiH264Decoder();\n-\n-  // Initializes and sets up libva connection and GL/X11 resources.\n-  // Must be called on the GLX thread with |glx_context| being current and\n-  // with decoder thread not yet running.\n-  // |output_pic_cb| will be called to notify when a picture can be displayed.\n-  bool Initialize(media::VideoCodecProfile profile,\n-                  Display* x_display,\n-                  GLXContext glx_context,\n-                  const OutputPicCB& output_pic_cb) WARN_UNUSED_RESULT;\n-  void Destroy();\n-\n-  // Notify the decoder that this output buffer has been consumed and\n-  // can be reused (overwritten).\n-  // Must be run on the decoder thread.\n-  void ReusePictureBuffer(int32 picture_buffer_id);\n-\n-  // Give a new picture buffer (texture) to decoder for use.\n-  // Must be run on the GLX thread with decoder thread not yet running.\n-  bool AssignPictureBuffer(int32 picture_buffer_id, uint32 texture_id)\n-      WARN_UNUSED_RESULT;\n-\n-  // Sync the data so that the texture for given |picture_buffer_id| can\n-  // be displayed.\n-  // Must be run on the GLX thread.\n-  bool PutPicToTexture(int32 picture_buffer_id) WARN_UNUSED_RESULT;\n-\n-  // Have the decoder flush its state and trigger output of all previously\n-  // decoded pictures via OutputPicCB.\n-  // Returns false if any of the resulting invocations of the callback fail.\n-  bool Flush() WARN_UNUSED_RESULT;\n-\n-  // Called while decoding.\n-  // Stop decoding, discarding all remaining input/output, but do not flush\n-  // state, so the playback of the same stream can be resumed (possibly from\n-  // another location).\n-  void Reset();\n-\n-  // Set current stream data pointer to |ptr| and |size|.\n-  // Must be run on decoder thread.\n-  void SetStream(uint8* ptr, size_t size);\n-\n-  // Start parsing stream to detect picture sizes. Does not produce any\n-  // decoded pictures and can be called without providing output textures.\n-  // Also to be used after Reset() to find a suitable location in the\n-  // stream to resume playback from.\n-  DecResult DecodeInitial(int32 input_id) WARN_UNUSED_RESULT;\n-\n-  // Runs until a frame is decoded or end of provided stream data buffer\n-  // is reached. Decoded pictures will be returned asynchronously via\n-  // OutputPicCB.\n-  DecResult DecodeOneFrame(int32 input_id) WARN_UNUSED_RESULT;\n-\n-  // Return dimensions for output buffer (texture) allocation.\n-  // Valid only after a successful DecodeInitial().\n-  int pic_height() { return pic_height_; }\n-  int pic_width() { return pic_width_; }\n-\n-  // Return the number of output pictures required for decoding.\n-  // Valid after a successful DecodeInitial().\n-  static size_t GetRequiredNumOfPictures();\n-\n- private:\n-  // We need to keep at least kDPBMaxSize pictures in DPB for\n-  // reference/to display later and an additional one for the one currently\n-  // being decoded. We also ask for some additional ones since VDA needs\n-  // to accumulate a few ready-to-output pictures before it actually starts\n-  // displaying and giving them back. +2 instead of +1 because of subjective\n-  // smoothness improvement during testing.\n-  enum { kNumReqPictures = H264DPB::kDPBMaxSize +\n-      media::limits::kMaxVideoFrames + 2 };\n-\n-  // Internal state of the decoder.\n-  enum State {\n-    kUninitialized,  // Initialize() not yet called.\n-    kInitialized,  // Initialize() called, pictures requested.\n-    kDecoding,  // DecodeInitial() successful, output surfaces allocated.\n-    kAfterReset,  // After Reset() during decoding.\n-    kError,  // Error in kDecoding state.\n-  };\n-\n-  // Get usable framebuffer configuration for use in binding textures\n-  // or return false on failure.\n-  bool InitializeFBConfig();\n-\n-  // Process H264 stream structures.\n-  bool ProcessSPS(int sps_id);\n-  bool ProcessPPS(int pps_id);\n-  bool ProcessSlice(H264SliceHeader* slice_hdr);\n-\n-  // Initialize the current picture according to data in |slice_hdr|.\n-  bool InitCurrPicture(H264SliceHeader* slice_hdr);\n-\n-  // Calculate picture order counts for the new picture\n-  // on initialization of a new frame (see spec).\n-  bool CalculatePicOrderCounts(H264SliceHeader* slice_hdr);\n-\n-  // Update PicNum values in pictures stored in DPB on creation of new\n-  // frame (see spec).\n-  void UpdatePicNums();\n-\n-  // Construct initial reference picture lists for use in decoding of\n-  // P and B pictures (see 8.2.4 in spec).\n-  void ConstructReferencePicListsP(H264SliceHeader* slice_hdr);\n-  void ConstructReferencePicListsB(H264SliceHeader* slice_hdr);\n-\n-  // Helper functions for reference list construction, per spec.\n-  int PicNumF(H264Picture *pic);\n-  int LongTermPicNumF(H264Picture *pic);\n-\n-  // Perform the reference picture lists' modification (reordering), as\n-  // specified in spec (8.2.4).\n-  //\n-  // |list| indicates list number and should be either 0 or 1.\n-  bool ModifyReferencePicList(H264SliceHeader *slice_hdr, int list);\n-\n-  // Perform reference picture memory management operations (marking/unmarking\n-  // of reference pictures, long term picture management, discarding, etc.).\n-  // See 8.2.5 in spec.\n-  bool HandleMemoryManagementOps();\n-  void ReferencePictureMarking();\n-\n-  // Start processing a new frame.\n-  bool StartNewFrame(H264SliceHeader* slice_hdr);\n-\n-  // All data for a frame received, process it and decode.\n-  bool FinishPrevFrameIfPresent();\n-\n-  // Called after decoding, performs all operations to be done after decoding,\n-  // including DPB management, reference picture marking and memory management\n-  // operations.\n-  // This will also output a picture if one is ready for output.\n-  bool FinishPicture();\n-\n-  // Convert VideoCodecProfile to VAProfile and set it as active.\n-  bool SetProfile(media::VideoCodecProfile profile);\n-\n-  // Vaapi-related functions.\n-\n-  // Allocates VASurfaces and creates a VAContext for them.\n-  bool CreateVASurfaces();\n-\n-  // Destroys allocated VASurfaces and related VAContext.\n-  void DestroyVASurfaces();\n-\n-  // These queue up data for HW decoder to be committed on running HW decode.\n-  bool SendPPS();\n-  bool SendIQMatrix();\n-  bool SendVASliceParam(H264SliceHeader* slice_hdr);\n-  bool SendSliceData(const uint8* ptr, size_t size);\n-  bool QueueSlice(H264SliceHeader* slice_hdr);\n-\n-  // Helper methods for filling HW structures.\n-  void FillVAPicture(VAPictureH264 *va_pic, H264Picture* pic);\n-  int FillVARefFramesFromDPB(VAPictureH264 *va_pics, int num_pics);\n-\n-  // Commits all pending data for HW decoder and starts HW decoder.\n-  bool DecodePicture();\n-\n-  // Notifies client that a picture is ready for output.\n-  bool OutputPic(H264Picture* pic);\n-\n-  State state_;\n-\n-  // A frame has been sent to hardware as the result of the last\n-  // DecodeOneFrame() call.\n-  bool frame_ready_at_hw_;\n-\n-  // Parser in use.\n-  H264Parser parser_;\n-\n-  // DPB in use.\n-  H264DPB dpb_;\n-\n-  // Picture currently being processed/decoded.\n-  scoped_ptr<H264Picture> curr_pic_;\n-\n-  // Reference picture lists, constructed for each picture before decoding.\n-  // Those lists are not owners of the pointers (DPB is).\n-  H264Picture::PtrVector ref_pic_list0_;\n-  H264Picture::PtrVector ref_pic_list1_;\n-\n-  // Global state values, needed in decoding. See spec.\n-  int max_pic_order_cnt_lsb_;\n-  int max_frame_num_;\n-  int max_pic_num_;\n-  int max_long_term_frame_idx_;\n-\n-  int frame_num_;\n-  int prev_frame_num_;\n-  int prev_frame_num_offset_;\n-\n-  // Values related to previously decoded reference picture.\n-  bool prev_ref_has_memmgmnt5_;\n-  int prev_ref_top_field_order_cnt_;\n-  int prev_ref_pic_order_cnt_msb_;\n-  int prev_ref_pic_order_cnt_lsb_;\n-  H264Picture::Field prev_ref_field_;\n-\n-  // Currently active SPS and PPS.\n-  int curr_sps_id_;\n-  int curr_pps_id_;\n-\n-  // Output picture size.\n-  int pic_width_;\n-  int pic_height_;\n-\n-  // Data queued up for HW decoder, to be commited on next HW decode.\n-  std::queue<VABufferID> pending_slice_bufs_;\n-  std::queue<VABufferID> pending_va_bufs_;\n-\n-  // Manages binding of a client-provided output buffer (texture) to VASurface.\n-  class DecodeSurface;\n-\n-  // Maps output_buffer_id to a decode surface. Used to look up surfaces\n-  // on requests from the client.\n-  typedef std::map<int32, linked_ptr<DecodeSurface> > DecodeSurfaces;\n-  DecodeSurfaces decode_surfaces_;\n-\n-  // Number of decode surface currently available for decoding.\n-  int num_available_decode_surfaces_;\n-\n-  // Maps decode surfaces to PicOrderCount, used to look up output buffers\n-  // when a decision to output a picture has been made.\n-  typedef std::map<int, DecodeSurface*> POCToDecodeSurfaces;\n-  POCToDecodeSurfaces poc_to_decode_surfaces_;\n-\n-  // Find an available surface and assign it to given PicOrderCnt |poc|,\n-  // removing it from the available surfaces pool. Return true if a surface\n-  // has been found, false otherwise.\n-  bool AssignSurfaceToPoC(int poc);\n-\n-  // Unassign a surface from |poc| and return a pointer to it, or NULL if there\n-  // is no surface associated with given |poc|. Note that this does not make\n-  // the surface available for reuse - as this can only happen after client\n-  // returns the surface via ReusePictureBuffer() - but only removes its\n-  // association with given |poc|.\n-  DecodeSurface* UnassignSurfaceFromPoC(int poc);\n-\n-  // The id of current input buffer, which will be associated with an\n-  // output picture if a frame is decoded successfully.\n-  int32 curr_input_id_;\n-\n-  // X/GLX handles.\n-  Display* x_display_;\n-  GLXContext parent_glx_context_;\n-  GLXFBConfig fb_config_;\n-\n-  // VA handles.\n-  VADisplay va_display_;\n-  VAConfigID va_config_id_;\n-  VAContextID va_context_id_;\n-  VAProfile profile_;\n-\n-  // Allocated VASurfaces.\n-  VASurfaceID va_surface_ids_[kNumReqPictures];\n-\n-  // Called by decoder when a picture should be outputted.\n-  OutputPicCB output_pic_cb_;\n-\n-  DISALLOW_COPY_AND_ASSIGN(VaapiH264Decoder);\n-};\n-\n-}  // namespace content\n-\n-#endif  // CONTENT_COMMON_GPU_MEDIA_VAAPI_H264_DECODER_H_\n-""}<_**next**_>{""sha"": ""f53b33e09bf58a8dafecc72ea7d0ca6ca6602b7b"", ""filename"": ""content/common/gpu/media/vaapi_video_decode_accelerator.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 572, ""changes"": 572, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_video_decode_accelerator.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_video_decode_accelerator.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/vaapi_video_decode_accelerator.cc?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,572 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include \""base/bind.h\""\n-#include \""base/command_line.h\""\n-#include \""base/debug/trace_event.h\""\n-#include \""base/logging.h\""\n-#include \""base/stl_util.h\""\n-#include \""base/string_util.h\""\n-#include \""base/synchronization/waitable_event.h\""\n-#include \""gpu/command_buffer/service/gpu_switches.h\""\n-#include \""content/public/common/content_switches.h\""\n-#include \""content/common/gpu/gpu_channel.h\""\n-#include \""content/common/gpu/media/vaapi_video_decode_accelerator.h\""\n-#include \""media/video/picture.h\""\n-#include \""third_party/libva/va/va.h\""\n-#include \""ui/gl/gl_bindings.h\""\n-\n-#define RETURN_AND_NOTIFY_ON_FAILURE(result, log, error_code, ret)  \\\n-  do {                                                              \\\n-    if (!(result)) {                                                \\\n-      DVLOG(1) << log;                                              \\\n-      Destroy();                                                    \\\n-      NotifyError(error_code);                                      \\\n-      return ret;                                                   \\\n-    }                                                               \\\n-  } while (0)\n-\n-using content::VaapiH264Decoder;\n-\n-VaapiVideoDecodeAccelerator::InputBuffer::InputBuffer() {\n-}\n-\n-VaapiVideoDecodeAccelerator::InputBuffer::~InputBuffer() {\n-}\n-\n-void VaapiVideoDecodeAccelerator::NotifyError(Error error) {\n-  if (message_loop_ != MessageLoop::current()) {\n-    message_loop_->PostTask(FROM_HERE, base::Bind(\n-        &VaapiVideoDecodeAccelerator::NotifyError, this, error));\n-    return;\n-  }\n-\n-  DVLOG(1) << \""Notifying of error \"" << error;\n-\n-  if (client_)\n-    client_->NotifyError(error);\n-  client_ = NULL;\n-}\n-\n-VaapiVideoDecodeAccelerator::VaapiVideoDecodeAccelerator(Client* client)\n-    : state_(kUninitialized),\n-      input_ready_(&lock_),\n-      output_ready_(&lock_),\n-      message_loop_(MessageLoop::current()),\n-      client_(client),\n-      decoder_thread_(\""VaapiDecoderThread\"") {\n-  DCHECK(client_);\n-}\n-\n-VaapiVideoDecodeAccelerator::~VaapiVideoDecodeAccelerator() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-}\n-\n-bool VaapiVideoDecodeAccelerator::Initialize(\n-    media::VideoCodecProfile profile) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  DCHECK_EQ(state_, kUninitialized);\n-  DVLOG(2) << \""Initializing VAVDA, profile: \"" << profile;\n-\n-  // TODO(posciak): try moving the flag check up to higher layers, possibly\n-  // out of the GPU process.\n-  bool res = CommandLine::ForCurrentProcess()->HasSwitch(\n-      switches::kEnableVaapi);\n-  RETURN_AND_NOTIFY_ON_FAILURE(res, \""Vaapi HW acceleration disabled\"",\n-                               PLATFORM_FAILURE, false);\n-\n-  res = decoder_.Initialize(\n-      profile, x_display_, glx_context_,\n-      base::Bind(&VaapiVideoDecodeAccelerator::OutputPicCallback, this));\n-  RETURN_AND_NOTIFY_ON_FAILURE(res, \""Failed initializing decoder\"",\n-                               PLATFORM_FAILURE, false);\n-\n-  res = decoder_thread_.Start();\n-  RETURN_AND_NOTIFY_ON_FAILURE(res, \""Failed starting decoder thread\"",\n-                               PLATFORM_FAILURE, false);\n-\n-  state_ = kInitialized;\n-\n-  message_loop_->PostTask(FROM_HERE, base::Bind(\n-      &VaapiVideoDecodeAccelerator::NotifyInitializeDone, this));\n-  return true;\n-}\n-\n-void VaapiVideoDecodeAccelerator::NotifyInitializeDone() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  client_->NotifyInitializeDone();\n-}\n-\n-// TODO(posciak, fischman): try to move these to constructor parameters,\n-// but while removing SetEglState from OVDA as well for symmetry.\n-void VaapiVideoDecodeAccelerator::SetGlxState(Display* x_display,\n-                                              GLXContext glx_context) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  x_display_ = x_display;\n-  glx_context_ = glx_context;\n-}\n-\n-void VaapiVideoDecodeAccelerator::NotifyInputBufferRead(int input_buffer_id) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  DVLOG(4) << \""Notifying end of input buffer \"" << input_buffer_id;\n-  if (client_)\n-    client_->NotifyEndOfBitstreamBuffer(input_buffer_id);\n-}\n-\n-void VaapiVideoDecodeAccelerator::SyncAndNotifyPictureReady(int32 input_id,\n-                                                            int32 output_id) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  // Sync the contents of the texture.\n-  RETURN_AND_NOTIFY_ON_FAILURE(decoder_.PutPicToTexture(output_id),\n-                               \""Failed putting picture to texture\"",\n-                               PLATFORM_FAILURE, );\n-\n-  // And notify the client a picture is ready to be displayed.\n-  media::Picture picture(output_id, input_id);\n-  DVLOG(4) << \""Notifying output picture id \"" << output_id\n-           << \"" for input \""<< input_id << \"" is ready\"";\n-  if (client_)\n-    client_->PictureReady(picture);\n-}\n-\n-void VaapiVideoDecodeAccelerator::MapAndQueueNewInputBuffer(\n-    const media::BitstreamBuffer& bitstream_buffer) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  DVLOG(4) << \""Mapping new input buffer id: \"" << bitstream_buffer.id()\n-           << \"" size: \"" << (int)bitstream_buffer.size();\n-\n-  scoped_ptr<base::SharedMemory> shm(\n-      new base::SharedMemory(bitstream_buffer.handle(), true));\n-  RETURN_AND_NOTIFY_ON_FAILURE(shm->Map(bitstream_buffer.size()),\n-                              \""Failed to map input buffer\"", UNREADABLE_INPUT,);\n-\n-  // Set up a new input buffer and queue it for later.\n-  linked_ptr<InputBuffer> input_buffer(new InputBuffer());\n-  input_buffer->shm.reset(shm.release());\n-  input_buffer->id = bitstream_buffer.id();\n-  input_buffer->size = bitstream_buffer.size();\n-\n-  base::AutoLock auto_lock(lock_);\n-  input_buffers_.push(input_buffer);\n-  input_ready_.Signal();\n-}\n-\n-void VaapiVideoDecodeAccelerator::InitialDecodeTask() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  // Try to initialize or resume playback after reset.\n-  for (;;) {\n-    if (!GetInputBuffer())\n-      return;\n-    DCHECK(curr_input_buffer_.get());\n-\n-    VaapiH264Decoder::DecResult res = decoder_.DecodeInitial(\n-        curr_input_buffer_->id);\n-    switch (res) {\n-      case VaapiH264Decoder::kReadyToDecode:\n-        message_loop_->PostTask(FROM_HERE, base::Bind(\n-            &VaapiVideoDecodeAccelerator::ReadyToDecode, this,\n-                decoder_.GetRequiredNumOfPictures(),\n-                gfx::Size(decoder_.pic_width(), decoder_.pic_height())));\n-        return;\n-\n-      case VaapiH264Decoder::kNeedMoreStreamData:\n-        ReturnCurrInputBuffer();\n-        break;\n-\n-      case VaapiH264Decoder::kDecodeError:\n-        RETURN_AND_NOTIFY_ON_FAILURE(false, \""Error in decoding\"",\n-                                     PLATFORM_FAILURE, );\n-\n-      default:\n-        RETURN_AND_NOTIFY_ON_FAILURE(false,\n-                                     \""Unexpected result from decoder: \"" << res,\n-                                     PLATFORM_FAILURE, );\n-    }\n-  }\n-}\n-\n-bool VaapiVideoDecodeAccelerator::GetInputBuffer() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-\n-  if (curr_input_buffer_.get())\n-    return true;\n-\n-  // Will only wait if it is expected that in current state new buffers will\n-  // be queued from the client via Decode(). The state can change during wait.\n-  while (input_buffers_.empty() &&\n-         (state_ == kDecoding || state_ == kInitialized || state_ == kIdle)) {\n-    input_ready_.Wait();\n-  }\n-\n-  // We could have got woken up in a different state or never got to sleep\n-  // due to current state; check for that.\n-  switch (state_) {\n-    case kFlushing:\n-      // Here we are only interested in finishing up decoding buffers that are\n-      // already queued up. Otherwise will stop decoding.\n-      if (input_buffers_.empty())\n-        return false;\n-      // else fallthrough\n-    case kDecoding:\n-    case kInitialized:\n-    case kIdle:\n-      DCHECK(!input_buffers_.empty());\n-\n-      curr_input_buffer_ = input_buffers_.front();\n-      input_buffers_.pop();\n-\n-      DVLOG(4) << \""New current bitstream buffer, id: \""\n-               << curr_input_buffer_->id\n-               << \"" size: \"" << curr_input_buffer_->size;\n-\n-      decoder_.SetStream(\n-          static_cast<uint8*>(curr_input_buffer_->shm->memory()),\n-          curr_input_buffer_->size);\n-      return true;\n-\n-    default:\n-      // We got woken up due to being destroyed/reset, ignore any already\n-      // queued inputs.\n-      return false;\n-  }\n-}\n-\n-void VaapiVideoDecodeAccelerator::ReturnCurrInputBuffer() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  DCHECK(curr_input_buffer_.get());\n-  int32 id = curr_input_buffer_->id;\n-  curr_input_buffer_.reset();\n-  message_loop_->PostTask(FROM_HERE, base::Bind(\n-        &VaapiVideoDecodeAccelerator::NotifyInputBufferRead, this, id));\n-}\n-\n-bool VaapiVideoDecodeAccelerator::GetOutputBuffers() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-\n-  while (output_buffers_.empty() &&\n-         (state_ == kDecoding || state_ == kFlushing)) {\n-    output_ready_.Wait();\n-  }\n-\n-  if (state_ != kDecoding && state_ != kFlushing)\n-    return false;\n-\n-  while (!output_buffers_.empty()) {\n-    decoder_.ReusePictureBuffer(output_buffers_.front());\n-    output_buffers_.pop();\n-  }\n-\n-  return true;\n-}\n-\n-void VaapiVideoDecodeAccelerator::DecodeTask() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  // Main decode task.\n-  DVLOG(4) << \""Decode task\"";\n-\n-  // Try to decode what stream data is (still) in the decoder until we run out\n-  // of it.\n-  for (;;) {\n-    if (!GetInputBuffer())\n-      // Early exit requested.\n-      return;\n-    DCHECK(curr_input_buffer_.get());\n-\n-    VaapiH264Decoder::DecResult res =\n-        decoder_.DecodeOneFrame(curr_input_buffer_->id);\n-    switch (res) {\n-      case VaapiH264Decoder::kNeedMoreStreamData:\n-        ReturnCurrInputBuffer();\n-        break;\n-\n-      case VaapiH264Decoder::kDecodedFrame:\n-        // May still have more stream data, continue decoding.\n-        break;\n-\n-      case VaapiH264Decoder::kNoOutputAvailable:\n-        // No more output buffers in the decoder, try getting more or go to\n-        // sleep waiting for them.\n-        if (!GetOutputBuffers())\n-          return;\n-        break;\n-\n-      case VaapiH264Decoder::kDecodeError:\n-        RETURN_AND_NOTIFY_ON_FAILURE(false, \""Error decoding stream\"",\n-                                     PLATFORM_FAILURE, );\n-        return;\n-\n-      default:\n-        RETURN_AND_NOTIFY_ON_FAILURE(\n-            false, \""Unexpected result from the decoder: \"" << res,\n-            PLATFORM_FAILURE, );\n-        return;\n-    }\n-  }\n-}\n-\n-void VaapiVideoDecodeAccelerator::ReadyToDecode(int num_pics,\n-                                                const gfx::Size& size) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  switch (state_) {\n-    case kInitialized:\n-      DVLOG(1) << \""Requesting \"" << num_pics << \"" pictures of size: \""\n-               << size.width() << \""x\"" << size.height();\n-      if (client_)\n-        client_->ProvidePictureBuffers(num_pics, size);\n-      state_ = kPicturesRequested;\n-      break;\n-    case kIdle:\n-      state_ = kDecoding;\n-      decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-          base::Bind(&VaapiVideoDecodeAccelerator::DecodeTask, this));\n-      break;\n-    default:\n-      NOTREACHED() << \""Invalid state\"";\n-  }\n-}\n-\n-void VaapiVideoDecodeAccelerator::Decode(\n-    const media::BitstreamBuffer& bitstream_buffer) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  TRACE_EVENT1(\""Video Decoder\"", \""VAVDA::Decode\"", \""Buffer id\"",\n-               bitstream_buffer.id());\n-\n-  // We got a new input buffer from the client, map it and queue for later use.\n-  MapAndQueueNewInputBuffer(bitstream_buffer);\n-\n-  base::AutoLock auto_lock(lock_);\n-  switch (state_) {\n-    case kInitialized:\n-      // Initial decode to get the required size of output buffers.\n-      decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-          base::Bind(&VaapiVideoDecodeAccelerator::InitialDecodeTask, this));\n-      break;\n-\n-    case kPicturesRequested:\n-      // Waiting for pictures, return.\n-      break;\n-\n-    case kDecoding:\n-      break;\n-\n-    case kIdle:\n-      // Need to get decoder into suitable stream location to resume.\n-      decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-          base::Bind(&VaapiVideoDecodeAccelerator::InitialDecodeTask, this));\n-      break;\n-\n-    default:\n-      DVLOG(1) << \""Decode request from client in invalid state: \"" << state_;\n-      return;\n-  }\n-}\n-\n-void VaapiVideoDecodeAccelerator::AssignPictureBuffers(\n-    const std::vector<media::PictureBuffer>& buffers) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  DCHECK_EQ(state_, kPicturesRequested);\n-\n-  for (size_t i = 0; i < buffers.size(); ++i) {\n-    DVLOG(2) << \""Assigning picture id \"" << buffers[i].id()\n-             << \"" to texture id \"" << buffers[i].texture_id();\n-\n-    bool res = decoder_.AssignPictureBuffer(buffers[i].id(),\n-                                            buffers[i].texture_id());\n-    RETURN_AND_NOTIFY_ON_FAILURE(\n-        res, \""Failed assigning picture buffer id: \"" << buffers[i].id() <<\n-        \"", texture id: \"" << buffers[i].texture_id(), PLATFORM_FAILURE, );\n-  }\n-\n-  state_ = kDecoding;\n-  decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::DecodeTask, this));\n-}\n-\n-void VaapiVideoDecodeAccelerator::ReusePictureBuffer(int32 picture_buffer_id) {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  TRACE_EVENT1(\""Video Decoder\"", \""VAVDA::ReusePictureBuffer\"", \""Picture id\"",\n-               picture_buffer_id);\n-\n-  base::AutoLock auto_lock(lock_);\n-  output_buffers_.push(picture_buffer_id);\n-  output_ready_.Signal();\n-}\n-\n-void VaapiVideoDecodeAccelerator::FlushTask() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-  DVLOG(1) << \""Flush task\"";\n-\n-  // First flush all the pictures that haven't been outputted, notifying the\n-  // client to output them.\n-  bool res = decoder_.Flush();\n-  RETURN_AND_NOTIFY_ON_FAILURE(res, \""Failed flushing the decoder.\"",\n-                               PLATFORM_FAILURE, );\n-\n-  // Put the decoder in idle state, ready to resume.\n-  decoder_.Reset();\n-\n-  message_loop_->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::FinishFlush, this));\n-}\n-\n-void VaapiVideoDecodeAccelerator::Flush() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  DVLOG(1) << \""Got flush request\"";\n-\n-  base::AutoLock auto_lock(lock_);\n-  state_ = kFlushing;\n-  // Queue a flush task after all existing decoding tasks to clean up.\n-  decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::FlushTask, this));\n-\n-  input_ready_.Signal();\n-  output_ready_.Signal();\n-}\n-\n-void VaapiVideoDecodeAccelerator::FinishFlush() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  if (state_ != kFlushing) {\n-    DCHECK_EQ(state_, kDestroying);\n-    return;  // We could've gotten destroyed already.\n-  }\n-\n-  state_ = kIdle;\n-\n-  if (client_)\n-    client_->NotifyFlushDone();\n-\n-  DVLOG(1) << \""Flush finished\"";\n-}\n-\n-void VaapiVideoDecodeAccelerator::ResetTask() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  // All the decoding tasks from before the reset request from client are done\n-  // by now, as this task was scheduled after them and client is expected not\n-  // to call Decode() after Reset() and before NotifyResetDone.\n-  decoder_.Reset();\n-\n-  // Return current input buffer, if present.\n-  if (curr_input_buffer_.get())\n-    ReturnCurrInputBuffer();\n-\n-  // And let client know that we are done with reset.\n-  message_loop_->PostTask(FROM_HERE, base::Bind(\n-      &VaapiVideoDecodeAccelerator::FinishReset, this));\n-}\n-\n-void VaapiVideoDecodeAccelerator::Reset() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  DVLOG(1) << \""Got reset request\"";\n-\n-  // This will make any new decode tasks exit early.\n-  base::AutoLock auto_lock(lock_);\n-  state_ = kResetting;\n-\n-  decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::ResetTask, this));\n-\n-  input_ready_.Signal();\n-  output_ready_.Signal();\n-}\n-\n-void VaapiVideoDecodeAccelerator::FinishReset() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-\n-  base::AutoLock auto_lock(lock_);\n-  if (state_ != kResetting) {\n-    DCHECK_EQ(state_, kDestroying);\n-    return;  // We could've gotten destroyed already.\n-  }\n-\n-  // Drop all remaining input buffers, if present.\n-  while (!input_buffers_.empty())\n-    input_buffers_.pop();\n-\n-  state_ = kIdle;\n-\n-  if (client_)\n-    client_->NotifyResetDone();\n-\n-  DVLOG(1) << \""Reset finished\"";\n-}\n-\n-void VaapiVideoDecodeAccelerator::DestroyTask() {\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-\n-  DVLOG(1) << \""DestroyTask\"";\n-  base::AutoLock auto_lock(lock_);\n-\n-  // This is a dummy task to ensure that all tasks on decoder thread have\n-  // finished, so we can destroy it from ChildThread, as we need to do that\n-  // on the thread that has the GLX context.\n-\n-  message_loop_->PostTask(FROM_HERE, base::Bind(\n-      &VaapiVideoDecodeAccelerator::FinishDestroy, this));\n-}\n-\n-void VaapiVideoDecodeAccelerator::Destroy() {\n-  if (message_loop_ != MessageLoop::current()) {\n-    message_loop_->PostTask(FROM_HERE, base::Bind(\n-        &VaapiVideoDecodeAccelerator::Destroy, this));\n-    return;\n-  }\n-\n-  if (state_ == kUninitialized || state_ == kDestroying)\n-    return;\n-\n-  DVLOG(1) << \""Destroying VAVDA\"";\n-  base::AutoLock auto_lock(lock_);\n-  state_ = kDestroying;\n-  decoder_thread_.message_loop()->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::DestroyTask, this));\n-  client_ = NULL;\n-\n-  input_ready_.Signal();\n-  output_ready_.Signal();\n-}\n-\n-void VaapiVideoDecodeAccelerator::FinishDestroy() {\n-  DCHECK_EQ(message_loop_, MessageLoop::current());\n-  base::AutoLock auto_lock(lock_);\n-  // Called from here as we need to be on the thread that has the GLX context\n-  // as current.\n-  decoder_.Destroy();\n-  state_ = kUninitialized;\n-}\n-\n-void VaapiVideoDecodeAccelerator::OutputPicCallback(int32 input_id,\n-                                                    int32 output_id) {\n-  TRACE_EVENT2(\""Video Decoder\"", \""VAVDA::OutputPicCallback\"",\n-               \""Input id\"", input_id, \""Picture id\"", output_id);\n-  DVLOG(4) << \""Outputting picture, input id: \"" << input_id\n-           << \"" output id: \"" << output_id;\n-\n-  // Forward the request to the main thread.\n-  DCHECK_EQ(decoder_thread_.message_loop(), MessageLoop::current());\n-  message_loop_->PostTask(FROM_HERE,\n-      base::Bind(&VaapiVideoDecodeAccelerator::SyncAndNotifyPictureReady,\n-                 this, input_id, output_id));\n-}\n-""}<_**next**_>{""sha"": ""8b1d433db09ecf50e2360b683b53a97cfb6a8bf5"", ""filename"": ""content/common/gpu/media/vaapi_video_decode_accelerator.h"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 208, ""changes"": 208, ""blob_url"": ""https://github.com/chromium/chromium/blob/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_video_decode_accelerator.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/be2e89272359a5d078e45caa78830b99190d6bdf/content/common/gpu/media/vaapi_video_decode_accelerator.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/gpu/media/vaapi_video_decode_accelerator.h?ref=be2e89272359a5d078e45caa78830b99190d6bdf"", ""patch"": ""@@ -1,208 +0,0 @@\n-// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-//\n-// This file contains an implementation of VideoDecoderAccelerator\n-// that utilizes hardware video decoder present on Intel CPUs.\n-\n-#ifndef CONTENT_COMMON_GPU_MEDIA_VAAPI_VIDEO_DECODE_ACCELERATOR_H_\n-#define CONTENT_COMMON_GPU_MEDIA_VAAPI_VIDEO_DECODE_ACCELERATOR_H_\n-\n-#include <GL/glx.h>\n-\n-#include <queue>\n-#include <utility>\n-#include <vector>\n-\n-#include \""base/logging.h\""\n-#include \""base/memory/ref_counted.h\""\n-#include \""base/message_loop.h\""\n-#include \""base/shared_memory.h\""\n-#include \""base/synchronization/condition_variable.h\""\n-#include \""base/synchronization/lock.h\""\n-#include \""base/threading/non_thread_safe.h\""\n-#include \""base/threading/thread.h\""\n-#include \""content/common/gpu/media/vaapi_h264_decoder.h\""\n-#include \""media/base/bitstream_buffer.h\""\n-#include \""media/video/picture.h\""\n-#include \""media/video/video_decode_accelerator.h\""\n-\n-// Class to provide video decode acceleration for Intel systems with hardware\n-// support for it, and on which libva is available.\n-// Decoding tasks are performed in a separate decoding thread.\n-class VaapiVideoDecodeAccelerator : public media::VideoDecodeAccelerator {\n- public:\n-  VaapiVideoDecodeAccelerator(Client* client);\n-\n-  // media::VideoDecodeAccelerator implementation.\n-  virtual bool Initialize(media::VideoCodecProfile profile) OVERRIDE;\n-  virtual void Decode(const media::BitstreamBuffer& bitstream_buffer) OVERRIDE;\n-  virtual void AssignPictureBuffers(\n-      const std::vector<media::PictureBuffer>& buffers) OVERRIDE;\n-  virtual void ReusePictureBuffer(int32 picture_buffer_id) OVERRIDE;\n-  virtual void Flush() OVERRIDE;\n-  virtual void Reset() OVERRIDE;\n-  virtual void Destroy() OVERRIDE;\n-\n-  // Used by user of this class to pass X/GLX state.\n-  void SetGlxState(Display* x_display, GLXContext glx_context);\n-\n- private:\n-  virtual ~VaapiVideoDecodeAccelerator();\n-\n-  void NotifyInitializeDone();\n-\n-  // Notify the client that the input buffer has been consumed.\n-  void NotifyInputBufferRead(int input_buffer_id);\n-\n-  // Ensure data has been synced with the output texture and notify\n-  // the client it is ready for displaying.\n-  void SyncAndNotifyPictureReady(int32 input_id, int32 output_id);\n-\n-  // Posted by the decoder thread to notify VAVDA that the decoder has\n-  // initially parsed the stream and is ready to decode. If the pictures have\n-  // not yet been requested, it will request the client to provide |num_pics|\n-  // textures of given |size| and wait for them, otherwise will post\n-  // a DecodeTask directly.\n-  void ReadyToDecode(int num_pics, const gfx::Size& size);\n-\n-  // Notify the client that an error has occurred and decoding cannot continue.\n-  void NotifyError(Error error);\n-\n-  // Map the received input buffer into this process' address space and\n-  // queue it for decode.\n-  void MapAndQueueNewInputBuffer(\n-      const media::BitstreamBuffer& bitstream_buffer);\n-\n-  // Get a new input buffer from the queue and set it up in decoder. This will\n-  // sleep if no input buffers are available. Return true if a new buffer has\n-  // been set up, false if an early exit has been requested (due to initiated\n-  // reset/flush/destroy).\n-  bool GetInputBuffer();\n-\n-  // Signal the client that the current buffer has been read and can be\n-  // returned. Will also release the mapping.\n-  void ReturnCurrInputBuffer();\n-\n-  // Get and set up one or more output buffers in the decoder. This will sleep\n-  // if no buffers are available. Return true if buffers have been set up or\n-  // false if an early exit has been requested (due to initiated\n-  // reset/flush/destroy).\n-  bool GetOutputBuffers();\n-\n-  // Initial decode task: get the decoder to the point in the stream from which\n-  // it can start/continue decoding. Does not require output buffers and does\n-  // not produce output frames. Called either when starting with a new stream\n-  // or when playback is to be resumed following a seek.\n-  void InitialDecodeTask();\n-\n-  // Decoding task. Will continue decoding given input buffers and sleep\n-  // waiting for input/output as needed. Will exit if a reset/flush/destroy\n-  // is requested.\n-  void DecodeTask();\n-\n-  // Scheduled after receiving a flush request and executed after the current\n-  // decoding task finishes decoding pending inputs. Makes the decoder return\n-  // all remaining output pictures and puts it in an idle state, ready\n-  // to resume if needed and schedules a FinishFlush.\n-  void FlushTask();\n-\n-  // Scheduled by the FlushTask after decoder is flushed to put VAVDA into idle\n-  // state and notify the client that flushing has been finished.\n-  void FinishFlush();\n-\n-  // Scheduled after receiving a reset request and executed after the current\n-  // decoding task finishes decoding the current frame. Puts the decoder into\n-  // an idle state, ready to resume if needed, discarding decoded but not yet\n-  // outputted pictures (decoder keeps ownership of their associated picture\n-  // buffers). Schedules a FinishReset afterwards.\n-  void ResetTask();\n-\n-  // Scheduled by ResetTask after it's done putting VAVDA into an idle state.\n-  // Drops remaining input buffers and notifies the client that reset has been\n-  // finished.\n-  void FinishReset();\n-\n-  // Scheduled on the decoder thread after receiving a Destroy() call from the\n-  // client, executed after the current decoding task finishes decoding the\n-  // current frame, ignoring any remaining inputs. Cleans up the decoder and\n-  // frees all resources.\n-  void DestroyTask();\n-\n-  // Scheduled by DestroyTask after it's done destroying the decoder, puts\n-  // VAVDA into an uninitialized state.\n-  void FinishDestroy();\n-\n-  // Client-provided X/GLX state.\n-  Display* x_display_;\n-  GLXContext glx_context_;\n-\n-  // VAVDA state.\n-  enum State {\n-    // Initialize() not called yet or failed.\n-    kUninitialized,\n-    // Initialize() succeeded, no initial decode and no pictures requested.\n-    kInitialized,\n-    // Initial decode finished, requested pictures and waiting for them.\n-    kPicturesRequested,\n-    // Everything initialized, pictures received and assigned, in decoding.\n-    kDecoding,\n-    // Resetting, waiting for decoder to finish current task and cleanup.\n-    kResetting,\n-    // Flushing, waiting for decoder to finish current task and cleanup.\n-    kFlushing,\n-    // Idle, decoder in state ready to resume decoding.\n-    kIdle,\n-    // Destroying, waiting for the decoder to finish current task.\n-    kDestroying,\n-  };\n-\n-  State state_;\n-\n-  // Protects input and output buffer queues and state_.\n-  base::Lock lock_;\n-\n-  // An input buffer awaiting consumption, provided by the client.\n-  struct InputBuffer {\n-    InputBuffer();\n-    ~InputBuffer();\n-\n-    int32 id;\n-    size_t size;\n-    scoped_ptr<base::SharedMemory> shm;\n-  };\n-\n-  // Queue for incoming input buffers.\n-  typedef std::queue<linked_ptr<InputBuffer> > InputBuffers;\n-  InputBuffers input_buffers_;\n-  // Signalled when input buffers are queued onto the input_buffers_ queue.\n-  base::ConditionVariable input_ready_;\n-\n-  // Current input buffer at decoder.\n-  linked_ptr<InputBuffer> curr_input_buffer_;\n-\n-  // Queue for incoming input buffers.\n-  typedef std::queue<int32> OutputBuffers;\n-  OutputBuffers output_buffers_;\n-  // Signalled when output buffers are queued onto the output_buffers_ queue.\n-  base::ConditionVariable output_ready_;\n-\n-  // ChildThread's message loop\n-  MessageLoop* message_loop_;\n-\n-  // To expose client callbacks from VideoDecodeAccelerator.\n-  // NOTE: all calls to this object *MUST* be executed on message_loop_.\n-  Client* client_;\n-\n-  base::Thread decoder_thread_;\n-  content::VaapiH264Decoder decoder_;\n-\n-  // Callback passed to the decoder, which it will use to signal readiness\n-  // of an output picture to be displayed.\n-  void OutputPicCallback(int32 input_id, int32 output_id);\n-\n-  DISALLOW_COPY_AND_ASSIGN(VaapiVideoDecodeAccelerator);\n-};\n-\n-#endif  // CONTENT_COMMON_GPU_MEDIA_VAAPI_VIDEO_DECODE_ACCELERATOR_H_\n-""}<_**next**_>{""sha"": ""e7114b646eebbd2e7f5c1b31350fb4c8dede4415"", ""filename"": ""content/content_common.gypi"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 13, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/content_common.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/content_common.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/content_common.gypi?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -396,19 +396,6 @@\n         'common/gpu/media/h264_parser.h',\n       ],\n     }],\n-    ['chromeos == 1', {\n-      'sources': [\n-        'common/gpu/media/h264_dpb.cc',\n-        'common/gpu/media/h264_dpb.h',\n-        'common/gpu/media/vaapi_h264_decoder.cc',\n-        'common/gpu/media/vaapi_h264_decoder.h',\n-        'common/gpu/media/vaapi_video_decode_accelerator.cc',\n-        'common/gpu/media/vaapi_video_decode_accelerator.h',\n-      ],\n-      'include_dirs': [\n-        '<(DEPTH)/third_party/libva',\n-      ],\n-    }],\n     ['OS==\""win\""', {\n       'dependencies': [\n         '../media/media.gyp:media',""}<_**next**_>{""sha"": ""882da9754c8b5f0c89359de31cd7ee6583617354"", ""filename"": ""content/public/common/content_switches.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/public/common/content_switches.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/public/common/content_switches.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_switches.cc?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -334,10 +334,6 @@ const char kDisableThreadedCompositing[]     = \""disable-threaded-compositing\"";\n // SYN packet.\n const char kEnableTcpFastOpen[]             = \""enable-tcp-fastopen\"";\n \n-// Enables hardware acceleration for video decode on ChromeOS\n-// on Intel CPUs (mostly Sandy Bridge+) using VAAPI.\n-const char kEnableVaapi[]                   = \""enable-vaapi\"";\n-\n // Enables support for video tracks. Current implementation is\n // incomplete and this flag is used for development and testing.\n const char kEnableVideoTrack[]              = \""enable-video-track\"";""}<_**next**_>{""sha"": ""9eeaa360cfb9d7f32aeba9179fd7682ad2769f33"", ""filename"": ""content/public/common/content_switches.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/public/common/content_switches.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/public/common/content_switches.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/public/common/content_switches.h?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -109,7 +109,6 @@ extern const char kEnableStrictSiteIsolation[];\n CONTENT_EXPORT extern const char kEnableThreadedCompositing[];\n CONTENT_EXPORT extern const char kDisableThreadedCompositing[];\n CONTENT_EXPORT extern const char kEnableTcpFastOpen[];\n-CONTENT_EXPORT extern const char kEnableVaapi[];\n CONTENT_EXPORT extern const char kEnableVideoTrack[];\n extern const char kEnableViewport[];\n CONTENT_EXPORT extern const char kExperimentalLocationFeatures[];""}<_**next**_>{""sha"": ""7eb97d356cce4a61c69bef7c186e38ae3432ec12"", ""filename"": ""content/renderer/render_view_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/9597042cad54926f50d58f5ada39205eb734d7be/content/renderer/render_view_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9597042cad54926f50d58f5ada39205eb734d7be/content/renderer/render_view_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_impl.cc?ref=9597042cad54926f50d58f5ada39205eb734d7be"", ""patch"": ""@@ -2235,11 +2235,11 @@ WebMediaPlayer* RenderViewImpl::createMediaPlayer(\n     collection->AddAudioRenderer(audio_renderer);\n   }\n \n-  // Currently only cros has any HW video decode support in\n+  // Currently only cros/arm has any HW video decode support in\n   // GpuVideoDecodeAccelerator so we don't even try to use it on other\n   // platforms.  This is a startup-time optimization.  When new VDA\n-  // implementations are added, relax the #if below.\n-#if defined(OS_CHROMEOS)\n+  // implementations are added, relax the #if above.\n+#if defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)\n   // Note we don't actually use the result of this blind down-cast unless it's\n   // valid (not NULL and of the right type).\n   WebGraphicsContext3DCommandBufferImpl* context3d =""}","void GpuProcessHost::RouteOnUIThread(const IPC::Message& message) {
  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(&RouteToGpuProcessHostUIShimTask, host_id_, message));
}
","void GpuProcessHost::RouteOnUIThread(const IPC::Message& message) {
  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(&RouteToGpuProcessHostUIShimTask, host_id_, message));
}
",C,,,,"@@ -743,9 +743,6 @@ bool GpuProcessHost::LaunchGpuProcess(const std::string& channel_id) {
     switches::kEnableLogging,
 #if defined(OS_MACOSX)
     switches::kEnableSandboxLogging,
-#endif
-#if defined(OS_CHROMEOS)
-    switches::kEnableVaapi,
 #endif
     switches::kGpuNoContextLost,
     switches::kGpuStartupDialog,",Chrome,9597042cad54926f50d58f5ada39205eb734d7be,be2e89272359a5d078e45caa78830b99190d6bdf,0,"void GpuProcessHost::RouteOnUIThread(const IPC::Message& message) {
  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(&RouteToGpuProcessHostUIShimTask, host_id_, message));
}
"
106167,,Remote,Not required,Partial,CVE-2011-2350,https://www.cvedetails.com/cve/CVE-2011-2350/,CWE-20,Low,Partial,Partial,,2011-06-29,7.5,"The HTML parser in Google Chrome before 12.0.742.112 does not properly address *lifetime and re-entrancy issues,* which allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.",2017-09-18,DoS ,0,https://github.com/chromium/chromium/commit/b944f670bb7a8a919daac497a4ea0536c954c201,b944f670bb7a8a919daac497a4ea0536c954c201,"[JSC] Implement a helper method createNotEnoughArgumentsError()
https://bugs.webkit.org/show_bug.cgi?id=85102

Reviewed by Geoffrey Garen.

In bug 84787, kbr@ requested to avoid hard-coding
createTypeError(exec, ""Not enough arguments"") here and there.
This patch implements createNotEnoughArgumentsError(exec)
and uses it in JSC bindings.

c.f. a corresponding bug for V8 bindings is bug 85097.

Source/JavaScriptCore:

* runtime/Error.cpp:
(JSC::createNotEnoughArgumentsError):
(JSC):
* runtime/Error.h:
(JSC):

Source/WebCore:

Test: bindings/scripts/test/TestObj.idl

* bindings/scripts/CodeGeneratorJS.pm: Modified as described above.
(GenerateArgumentsCountCheck):

* bindings/js/JSDataViewCustom.cpp: Ditto.
(WebCore::getDataViewMember):
(WebCore::setDataViewMember):
* bindings/js/JSDeprecatedPeerConnectionCustom.cpp:
(WebCore::JSDeprecatedPeerConnectionConstructor::constructJSDeprecatedPeerConnection):
* bindings/js/JSDirectoryEntryCustom.cpp:
(WebCore::JSDirectoryEntry::getFile):
(WebCore::JSDirectoryEntry::getDirectory):
* bindings/js/JSSharedWorkerCustom.cpp:
(WebCore::JSSharedWorkerConstructor::constructJSSharedWorker):
* bindings/js/JSWebKitMutationObserverCustom.cpp:
(WebCore::JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver):
(WebCore::JSWebKitMutationObserver::observe):
* bindings/js/JSWorkerCustom.cpp:
(WebCore::JSWorkerConstructor::constructJSWorker):

* bindings/scripts/test/JS/JSFloat64Array.cpp: Updated run-bindings-tests.
(WebCore::jsFloat64ArrayPrototypeFunctionFoo):
* bindings/scripts/test/JS/JSTestActiveDOMObject.cpp:
(WebCore::jsTestActiveDOMObjectPrototypeFunctionExcitingFunction):
(WebCore::jsTestActiveDOMObjectPrototypeFunctionPostMessage):
* bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp:
(WebCore::jsTestCustomNamedGetterPrototypeFunctionAnotherFunction):
* bindings/scripts/test/JS/JSTestEventTarget.cpp:
(WebCore::jsTestEventTargetPrototypeFunctionItem):
(WebCore::jsTestEventTargetPrototypeFunctionAddEventListener):
(WebCore::jsTestEventTargetPrototypeFunctionRemoveEventListener):
(WebCore::jsTestEventTargetPrototypeFunctionDispatchEvent):
* bindings/scripts/test/JS/JSTestInterface.cpp:
(WebCore::JSTestInterfaceConstructor::constructJSTestInterface):
(WebCore::jsTestInterfacePrototypeFunctionSupplementalMethod2):
* bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp:
(WebCore::jsTestMediaQueryListListenerPrototypeFunctionMethod):
* bindings/scripts/test/JS/JSTestNamedConstructor.cpp:
(WebCore::JSTestNamedConstructorNamedConstructor::constructJSTestNamedConstructor):
* bindings/scripts/test/JS/JSTestObj.cpp:
(WebCore::JSTestObjConstructor::constructJSTestObj):
(WebCore::jsTestObjPrototypeFunctionVoidMethodWithArgs):
(WebCore::jsTestObjPrototypeFunctionIntMethodWithArgs):
(WebCore::jsTestObjPrototypeFunctionObjMethodWithArgs):
(WebCore::jsTestObjPrototypeFunctionMethodWithSequenceArg):
(WebCore::jsTestObjPrototypeFunctionMethodReturningSequence):
(WebCore::jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows):
(WebCore::jsTestObjPrototypeFunctionSerializedValue):
(WebCore::jsTestObjPrototypeFunctionIdbKey):
(WebCore::jsTestObjPrototypeFunctionOptionsObject):
(WebCore::jsTestObjPrototypeFunctionAddEventListener):
(WebCore::jsTestObjPrototypeFunctionRemoveEventListener):
(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg):
(WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndTwoOptionalArgs):
(WebCore::jsTestObjPrototypeFunctionMethodWithCallbackArg):
(WebCore::jsTestObjPrototypeFunctionMethodWithNonCallbackArgAndCallbackArg):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod1):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod2):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod3):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod4):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod5):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod6):
(WebCore::jsTestObjPrototypeFunctionOverloadedMethod7):
(WebCore::jsTestObjConstructorFunctionClassMethod2):
(WebCore::jsTestObjConstructorFunctionOverloadedMethod11):
(WebCore::jsTestObjConstructorFunctionOverloadedMethod12):
(WebCore::jsTestObjPrototypeFunctionMethodWithUnsignedLongArray):
(WebCore::jsTestObjPrototypeFunctionConvert1):
(WebCore::jsTestObjPrototypeFunctionConvert2):
(WebCore::jsTestObjPrototypeFunctionConvert3):
(WebCore::jsTestObjPrototypeFunctionConvert4):
(WebCore::jsTestObjPrototypeFunctionConvert5):
(WebCore::jsTestObjPrototypeFunctionStrictFunction):
* bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp:
(WebCore::JSTestSerializedScriptValueInterfaceConstructor::constructJSTestSerializedScriptValueInterface):
(WebCore::jsTestSerializedScriptValueInterfacePrototypeFunctionAcceptTransferList):


git-svn-id: svn://svn.chromium.org/blink/trunk@115536 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestObj.cpp,"{""sha"": ""cd2e9d4f114070aac1a4ba0a131ed07a694dffaf"", ""filename"": ""third_party/WebKit/Source/JavaScriptCore/ChangeLog"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 0, ""changes"": 20, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/JavaScriptCore/ChangeLog?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -1,3 +1,23 @@\n+2012-04-27  Kentaro Hara  <haraken@chromium.org>\n+\n+        [JSC] Implement a helper method createNotEnoughArgumentsError()\n+        https://bugs.webkit.org/show_bug.cgi?id=85102\n+\n+        Reviewed by Geoffrey Garen.\n+\n+        In bug 84787, kbr@ requested to avoid hard-coding\n+        createTypeError(exec, \""Not enough arguments\"") here and there.\n+        This patch implements createNotEnoughArgumentsError(exec)\n+        and uses it in JSC bindings.\n+\n+        c.f. a corresponding bug for V8 bindings is bug 85097.\n+\n+        * runtime/Error.cpp:\n+        (JSC::createNotEnoughArgumentsError):\n+        (JSC):\n+        * runtime/Error.h:\n+        (JSC):\n+\n 2012-04-27  Geoffrey Garen  <ggaren@apple.com>\n \n         Only allow non-null pointers in the WeakSet""}<_**next**_>{""sha"": ""61a994e90a91d1a2ed28b0c984b7354b1feb03fc"", ""filename"": ""third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/JavaScriptCore/JavaScriptCore.vcproj/JavaScriptCore/JavaScriptCore.def?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -120,6 +120,7 @@ EXPORTS\n     ?createThread@WTF@@YAIP6APAXPAX@Z0PBD@Z\n     ?createThread@WTF@@YAIP6AXPAX@Z0PBD@Z\n     ?createTypeError@JSC@@YAPAVJSObject@1@PAVExecState@1@ABVUString@1@@Z\n+    ?createNotEnoughArgumentsError@JSC@@YAPAVJSObject@1@PAVExecState@1@@Z\n     ?cryptographicallyRandomNumber@WTF@@YAIXZ\n     ?cryptographicallyRandomValues@WTF@@YAXPAXI@Z\n     ?currentThread@WTF@@YAIXZ""}<_**next**_>{""sha"": ""bae07448b3118892d933958864f3a48959fdaf3d"", ""filename"": ""third_party/WebKit/Source/JavaScriptCore/runtime/Error.cpp"", ""status"": ""modified"", ""additions"": 10, ""deletions"": 0, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/runtime/Error.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/runtime/Error.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/JavaScriptCore/runtime/Error.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -79,6 +79,11 @@ JSObject* createTypeError(JSGlobalObject* globalObject, const UString& message)\n     return ErrorInstance::create(globalObject->globalData(), globalObject->typeErrorConstructor()->errorStructure(), message);\n }\n \n+JSObject* createNotEnoughArgumentsError(JSGlobalObject* globalObject)\n+{\n+    return createTypeError(globalObject, \""Not enough arguments\"");\n+}\n+\n JSObject* createURIError(JSGlobalObject* globalObject, const UString& message)\n {\n     ASSERT(!message.isEmpty());\n@@ -115,6 +120,11 @@ JSObject* createTypeError(ExecState* exec, const UString& message)\n     return createTypeError(exec->lexicalGlobalObject(), message);\n }\n \n+JSObject* createNotEnoughArgumentsError(ExecState* exec)\n+{\n+    return createNotEnoughArgumentsError(exec->lexicalGlobalObject());\n+}\n+\n JSObject* createURIError(ExecState* exec, const UString& message)\n {\n     return createURIError(exec->lexicalGlobalObject(), message);""}<_**next**_>{""sha"": ""79617655e6cac15aa7c327c94f2514a405987a62"", ""filename"": ""third_party/WebKit/Source/JavaScriptCore/runtime/Error.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/runtime/Error.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/JavaScriptCore/runtime/Error.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/JavaScriptCore/runtime/Error.h?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -45,6 +45,7 @@ namespace JSC {\n     JSObject* createReferenceError(JSGlobalObject*, const UString&);\n     JSObject* createSyntaxError(JSGlobalObject*, const UString&);\n     JSObject* createTypeError(JSGlobalObject*, const UString&);\n+    JSObject* createNotEnoughArgumentsError(JSGlobalObject*);\n     JSObject* createURIError(JSGlobalObject*, const UString&);\n     // ExecState wrappers.\n     JS_EXPORT_PRIVATE JSObject* createError(ExecState*, const UString&);\n@@ -53,6 +54,7 @@ namespace JSC {\n     JS_EXPORT_PRIVATE JSObject* createReferenceError(ExecState*, const UString&);\n     JS_EXPORT_PRIVATE JSObject* createSyntaxError(ExecState*, const UString&);\n     JS_EXPORT_PRIVATE JSObject* createTypeError(ExecState*, const UString&);\n+    JS_EXPORT_PRIVATE JSObject* createNotEnoughArgumentsError(ExecState*);\n     JSObject* createURIError(ExecState*, const UString&);\n \n     // Methods to add ""}<_**next**_>{""sha"": ""d30835b6dafc0325793f91f001e5682c13415ed3"", ""filename"": ""third_party/WebKit/Source/WebCore/ChangeLog"", ""status"": ""modified"", ""additions"": 92, ""deletions"": 0, ""changes"": 92, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/ChangeLog"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/ChangeLog"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/ChangeLog?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -1,3 +1,95 @@\n+2012-04-27  Kentaro Hara  <haraken@chromium.org>\n+\n+        [JSC] Implement a helper method createNotEnoughArgumentsError()\n+        https://bugs.webkit.org/show_bug.cgi?id=85102\n+\n+        Reviewed by Geoffrey Garen.\n+\n+        In bug 84787, kbr@ requested to avoid hard-coding\n+        createTypeError(exec, \""Not enough arguments\"") here and there.\n+        This patch implements createNotEnoughArgumentsError(exec)\n+        and uses it in JSC bindings.\n+\n+        c.f. a corresponding bug for V8 bindings is bug 85097.\n+\n+        Test: bindings/scripts/test/TestObj.idl\n+\n+        * bindings/scripts/CodeGeneratorJS.pm: Modified as described above.\n+        (GenerateArgumentsCountCheck):\n+\n+        * bindings/js/JSDataViewCustom.cpp: Ditto.\n+        (WebCore::getDataViewMember):\n+        (WebCore::setDataViewMember):\n+        * bindings/js/JSDeprecatedPeerConnectionCustom.cpp:\n+        (WebCore::JSDeprecatedPeerConnectionConstructor::constructJSDeprecatedPeerConnection):\n+        * bindings/js/JSDirectoryEntryCustom.cpp:\n+        (WebCore::JSDirectoryEntry::getFile):\n+        (WebCore::JSDirectoryEntry::getDirectory):\n+        * bindings/js/JSSharedWorkerCustom.cpp:\n+        (WebCore::JSSharedWorkerConstructor::constructJSSharedWorker):\n+        * bindings/js/JSWebKitMutationObserverCustom.cpp:\n+        (WebCore::JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver):\n+        (WebCore::JSWebKitMutationObserver::observe):\n+        * bindings/js/JSWorkerCustom.cpp:\n+        (WebCore::JSWorkerConstructor::constructJSWorker):\n+\n+        * bindings/scripts/test/JS/JSFloat64Array.cpp: Updated run-bindings-tests.\n+        (WebCore::jsFloat64ArrayPrototypeFunctionFoo):\n+        * bindings/scripts/test/JS/JSTestActiveDOMObject.cpp:\n+        (WebCore::jsTestActiveDOMObjectPrototypeFunctionExcitingFunction):\n+        (WebCore::jsTestActiveDOMObjectPrototypeFunctionPostMessage):\n+        * bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp:\n+        (WebCore::jsTestCustomNamedGetterPrototypeFunctionAnotherFunction):\n+        * bindings/scripts/test/JS/JSTestEventTarget.cpp:\n+        (WebCore::jsTestEventTargetPrototypeFunctionItem):\n+        (WebCore::jsTestEventTargetPrototypeFunctionAddEventListener):\n+        (WebCore::jsTestEventTargetPrototypeFunctionRemoveEventListener):\n+        (WebCore::jsTestEventTargetPrototypeFunctionDispatchEvent):\n+        * bindings/scripts/test/JS/JSTestInterface.cpp:\n+        (WebCore::JSTestInterfaceConstructor::constructJSTestInterface):\n+        (WebCore::jsTestInterfacePrototypeFunctionSupplementalMethod2):\n+        * bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp:\n+        (WebCore::jsTestMediaQueryListListenerPrototypeFunctionMethod):\n+        * bindings/scripts/test/JS/JSTestNamedConstructor.cpp:\n+        (WebCore::JSTestNamedConstructorNamedConstructor::constructJSTestNamedConstructor):\n+        * bindings/scripts/test/JS/JSTestObj.cpp:\n+        (WebCore::JSTestObjConstructor::constructJSTestObj):\n+        (WebCore::jsTestObjPrototypeFunctionVoidMethodWithArgs):\n+        (WebCore::jsTestObjPrototypeFunctionIntMethodWithArgs):\n+        (WebCore::jsTestObjPrototypeFunctionObjMethodWithArgs):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithSequenceArg):\n+        (WebCore::jsTestObjPrototypeFunctionMethodReturningSequence):\n+        (WebCore::jsTestObjPrototypeFunctionMethodThatRequiresAllArgsAndThrows):\n+        (WebCore::jsTestObjPrototypeFunctionSerializedValue):\n+        (WebCore::jsTestObjPrototypeFunctionIdbKey):\n+        (WebCore::jsTestObjPrototypeFunctionOptionsObject):\n+        (WebCore::jsTestObjPrototypeFunctionAddEventListener):\n+        (WebCore::jsTestObjPrototypeFunctionRemoveEventListener):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndOptionalArg):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithNonOptionalArgAndTwoOptionalArgs):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithCallbackArg):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithNonCallbackArgAndCallbackArg):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod1):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod2):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod3):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod4):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod5):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod6):\n+        (WebCore::jsTestObjPrototypeFunctionOverloadedMethod7):\n+        (WebCore::jsTestObjConstructorFunctionClassMethod2):\n+        (WebCore::jsTestObjConstructorFunctionOverloadedMethod11):\n+        (WebCore::jsTestObjConstructorFunctionOverloadedMethod12):\n+        (WebCore::jsTestObjPrototypeFunctionMethodWithUnsignedLongArray):\n+        (WebCore::jsTestObjPrototypeFunctionConvert1):\n+        (WebCore::jsTestObjPrototypeFunctionConvert2):\n+        (WebCore::jsTestObjPrototypeFunctionConvert3):\n+        (WebCore::jsTestObjPrototypeFunctionConvert4):\n+        (WebCore::jsTestObjPrototypeFunctionConvert5):\n+        (WebCore::jsTestObjPrototypeFunctionStrictFunction):\n+        * bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp:\n+        (WebCore::JSTestSerializedScriptValueInterfaceConstructor::constructJSTestSerializedScriptValueInterface):\n+        (WebCore::jsTestSerializedScriptValueInterfacePrototypeFunctionAcceptTransferList):\n+\n 2012-04-27  Mark Pilgrim  <pilgrim@chromium.org>\n \n         [Chromium] Call highMemoryUsageMB directly""}<_**next**_>{""sha"": ""3eb7a3e1a4f27bc3d6bd8a65d764ca673fd06684"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSDataViewCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDataViewCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDataViewCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSDataViewCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -65,7 +65,7 @@ EncodedJSValue JSC_HOST_CALL JSDataViewConstructor::constructJSDataView(ExecStat\n static JSValue getDataViewMember(ExecState* exec, DataView* imp, DataViewAccessType type)\n {\n     if (exec->argumentCount() < 1)\n-        return throwError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     unsigned byteOffset = exec->argument(0).toUInt32(exec);\n     if (exec->hadException())\n@@ -122,7 +122,7 @@ JSValue JSDataView::getFloat64(ExecState* exec)\n static JSValue setDataViewMember(ExecState* exec, DataView* imp, DataViewAccessType type)\n {\n     if (exec->argumentCount() < 2)\n-        return throwError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     unsigned byteOffset = exec->argument(0).toUInt32(exec);\n     if (exec->hadException())""}<_**next**_>{""sha"": ""56d5ee7c0b934072d5b22b2aa9a9e95284261055"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSDeprecatedPeerConnectionCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDeprecatedPeerConnectionCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDeprecatedPeerConnectionCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSDeprecatedPeerConnectionCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -46,7 +46,7 @@ EncodedJSValue JSC_HOST_CALL JSDeprecatedPeerConnectionConstructor::constructJSD\n         return throwVMError(exec, createReferenceError(exec, \""DeprecatedPeerConnection constructor associated document is unavailable\""));\n \n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n \n     String serverConfiguration = ustringToString(exec->argument(0).toString(exec)->value(exec));\n     if (exec->hadException())""}<_**next**_>{""sha"": ""15fb3f5679b30168f7245759dc1d10b7ba95426d"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSDirectoryEntryCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDirectoryEntryCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSDirectoryEntryCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSDirectoryEntryCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -48,7 +48,7 @@ namespace WebCore {\n JSValue JSDirectoryEntry::getFile(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwError(exec, createNotEnoughArgumentsError(exec));\n \n     DirectoryEntry* imp = static_cast<DirectoryEntry*>(impl());\n     const String& path = valueToStringWithUndefinedOrNullCheck(exec, exec->argument(0));\n@@ -96,7 +96,7 @@ JSValue JSDirectoryEntry::getFile(ExecState* exec)\n JSValue JSDirectoryEntry::getDirectory(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwError(exec, createNotEnoughArgumentsError(exec));\n \n     DirectoryEntry* imp = static_cast<DirectoryEntry*>(impl());\n     const String& path = valueToStringWithUndefinedOrNullCheck(exec, exec->argument(0));""}<_**next**_>{""sha"": ""c79b793fa261fe2d86b28339269483ee8edd99da"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSSharedWorkerCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSSharedWorkerCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSSharedWorkerCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSSharedWorkerCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -60,7 +60,7 @@ EncodedJSValue JSC_HOST_CALL JSSharedWorkerConstructor::constructJSSharedWorker(\n     JSSharedWorkerConstructor* jsConstructor = jsCast<JSSharedWorkerConstructor*>(exec->callee());\n \n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n \n     UString scriptURL = exec->argument(0).toString(exec)->value(exec);\n     UString name;""}<_**next**_>{""sha"": ""39a246a15994ba098642bf522d8d56acb7d21af9"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSWebKitMutationObserverCustom.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSWebKitMutationObserverCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSWebKitMutationObserverCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSWebKitMutationObserverCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -51,7 +51,7 @@ namespace WebCore {\n EncodedJSValue JSC_HOST_CALL JSWebKitMutationObserverConstructor::constructJSWebKitMutationObserver(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n \n     JSObject* object = exec->argument(0).getObject();\n     if (!object) {\n@@ -83,7 +83,7 @@ static const size_t numBooleanOptions = sizeof(booleanOptions) / sizeof(BooleanO\n JSValue JSWebKitMutationObserver::observe(ExecState* exec)\n {\n     if (exec->argumentCount() < 2)\n-        return throwError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwError(exec, createNotEnoughArgumentsError(exec));\n     Node* target = toNode(exec->argument(0));\n     if (exec->hadException())\n         return jsUndefined();""}<_**next**_>{""sha"": ""7145fcf34590d8cd77fe798023c41107cf15fc1b"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/js/JSWorkerCustom.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSWorkerCustom.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/js/JSWorkerCustom.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/js/JSWorkerCustom.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -55,7 +55,7 @@ EncodedJSValue JSC_HOST_CALL JSWorkerConstructor::constructJSWorker(ExecState* e\n     JSWorkerConstructor* jsConstructor = jsCast<JSWorkerConstructor*>(exec->callee());\n \n     if (!exec->argumentCount())\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n \n     UString scriptURL = exec->argument(0).toString(exec)->value(exec);\n     if (exec->hadException())""}<_**next**_>{""sha"": ""1c2065816321c8426e622ee43bd974d05231aa81"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/CodeGeneratorJS.pm?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -2409,7 +2409,7 @@ sub GenerateArgumentsCountCheck\n     if ($numMandatoryParams >= 1)\n     {\n         push(@$outputArray, \""    if (exec->argumentCount() < $numMandatoryParams)\\n\"");\n-        push(@$outputArray, \""        return throwVMError(exec, createTypeError(exec, \\\""Not enough arguments\\\""));\\n\"");\n+        push(@$outputArray, \""        return throwVMError(exec, createNotEnoughArgumentsError(exec));\\n\"");\n     }\n }\n ""}<_**next**_>{""sha"": ""3b533f59d51a5352ab60470a47e9c9f747e5cb98"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSFloat64Array.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSFloat64Array.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSFloat64Array.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSFloat64Array.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -231,7 +231,7 @@ EncodedJSValue JSC_HOST_CALL jsFloat64ArrayPrototypeFunctionFoo(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSFloat64Array::s_info);\n     Float64Array* impl = static_cast<Float64Array*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     Float32Array* array(toFloat32Array(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());""}<_**next**_>{""sha"": ""ce8e623b942df6640838c5ece4d8d1cc2bee8337"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestActiveDOMObject.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestActiveDOMObject.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestActiveDOMObject.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestActiveDOMObject.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -186,7 +186,7 @@ EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionExcitingFunct\n         return JSValue::encode(jsUndefined());\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     Node* nextChild(toNode(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -203,7 +203,7 @@ EncodedJSValue JSC_HOST_CALL jsTestActiveDOMObjectPrototypeFunctionPostMessage(E\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestActiveDOMObject::s_info);\n     TestActiveDOMObject* impl = static_cast<TestActiveDOMObject*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     const String& message(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());""}<_**next**_>{""sha"": ""180f09e853efd27175f21172cdfc894d2993d236"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestCustomNamedGetter.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -176,7 +176,7 @@ EncodedJSValue JSC_HOST_CALL jsTestCustomNamedGetterPrototypeFunctionAnotherFunc\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestCustomNamedGetter::s_info);\n     TestCustomNamedGetter* impl = static_cast<TestCustomNamedGetter*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());""}<_**next**_>{""sha"": ""bfa872825adf71702e2127334c5f4afe374aad5d"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestEventTarget.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestEventTarget.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestEventTarget.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestEventTarget.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -231,7 +231,7 @@ EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionItem(ExecState* e\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int index(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toUInt32(exec));\n     if (index < 0) {\n         setDOMException(exec, INDEX_SIZE_ERR);\n@@ -253,7 +253,7 @@ EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionAddEventListener(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     JSValue listener = exec->argument(1);\n     if (!listener.isObject())\n         return JSValue::encode(jsUndefined());\n@@ -270,7 +270,7 @@ EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionRemoveEventListen\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     JSValue listener = exec->argument(1);\n     if (!listener.isObject())\n         return JSValue::encode(jsUndefined());\n@@ -287,7 +287,7 @@ EncodedJSValue JSC_HOST_CALL jsTestEventTargetPrototypeFunctionDispatchEvent(Exe\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestEventTarget::s_info);\n     TestEventTarget* impl = static_cast<TestEventTarget*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     Event* evt(toEvent(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())""}<_**next**_>{""sha"": ""ea2efa70771f73fd6544aed97bd5050fb2196154"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestInterface.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestInterface.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestInterface.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestInterface.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -124,7 +124,7 @@ EncodedJSValue JSC_HOST_CALL JSTestInterfaceConstructor::constructJSTestInterfac\n {\n     JSTestInterfaceConstructor* castedThis = jsCast<JSTestInterfaceConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     const String& str1(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n@@ -353,7 +353,7 @@ EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);\n     TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();\n     if (!scriptContext)""}<_**next**_>{""sha"": ""75121f192dd1c1e509b309b4f82ba3617ab9b603"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestMediaQueryListListener.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -166,7 +166,7 @@ EncodedJSValue JSC_HOST_CALL jsTestMediaQueryListListenerPrototypeFunctionMethod\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestMediaQueryListListener::s_info);\n     TestMediaQueryListListener* impl = static_cast<TestMediaQueryListListener*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     RefPtr<MediaQueryListListener> listener(MediaQueryListListener::create(ScriptValue(exec->globalData(), MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined))));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());""}<_**next**_>{""sha"": ""4b654e0e23f2c19c38c1044efb5e2c6457e8bde4"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestNamedConstructor.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestNamedConstructor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestNamedConstructor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestNamedConstructor.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -91,7 +91,7 @@ EncodedJSValue JSC_HOST_CALL JSTestNamedConstructorNamedConstructor::constructJS\n {\n     JSTestNamedConstructorNamedConstructor* castedThis = jsCast<JSTestNamedConstructorNamedConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     const String& str1(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())""}<_**next**_>{""sha"": ""06828a48ab077535f4c333182f96b871d7df5614"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestObj.cpp"", ""status"": ""modified"", ""additions"": 33, ""deletions"": 33, ""changes"": 66, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestObj.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestObj.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestObj.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -235,7 +235,7 @@ EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState*\n {\n     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n@@ -1577,7 +1577,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionVoidMethodWithArgs(ExecSt\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1613,7 +1613,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIntMethodWithArgs(ExecSta\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1650,7 +1650,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecSta\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1674,7 +1674,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithSequenceArg(Exe\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     sequence<ScriptProfile>* sequenceArg(toNativeArray<ScriptProfile>(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1691,7 +1691,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodReturningSequence(E\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1709,7 +1709,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgs\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n@@ -1732,7 +1732,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionSerializedValue(ExecState\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     RefPtr<SerializedScriptValue> serializedArg(SerializedScriptValue::create(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1749,7 +1749,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     PassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1766,7 +1766,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOptionsObject(ExecState*\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     Dictionary oo(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -1827,7 +1827,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionAddEventListener(ExecStat\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     JSValue listener = exec->argument(1);\n     if (!listener.isObject())\n         return JSValue::encode(jsUndefined());\n@@ -1844,7 +1844,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionRemoveEventListener(ExecS\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     JSValue listener = exec->argument(1);\n     if (!listener.isObject())\n         return JSValue::encode(jsUndefined());\n@@ -2023,7 +2023,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgA\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2050,7 +2050,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgA\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2137,7 +2137,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithCallbackArg(Exe\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n@@ -2156,7 +2156,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonCallbackArgA\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int nonCallback(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2244,7 +2244,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod1(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2264,7 +2264,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod2(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2291,7 +2291,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod3(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2308,7 +2308,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod4(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2325,7 +2325,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod5(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {\n         setDOMException(exec, TYPE_MISMATCH_ERR);\n         return JSValue::encode(jsUndefined());\n@@ -2344,7 +2344,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2361,7 +2361,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod7(\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     DOMStringList* arrayArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2418,15 +2418,15 @@ EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethodWithOptional\n EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethod2(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     return JSValue::encode(JSTestObj::classMethod2(exec));\n }\n \n #if ENABLE(Condition1)\n static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod11(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     int arg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2440,7 +2440,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod\n static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod12(ExecState* exec)\n {\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     const String& type(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2470,7 +2470,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithUnsignedLongArr\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     Vector<unsigned long> unsignedLongArray(jsUnsignedLongArrayToVector(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2504,7 +2504,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert1(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     a* (toa(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2521,7 +2521,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert2(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     b* (tob(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2538,7 +2538,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert3(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     c* (toc(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2555,7 +2555,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2572,7 +2572,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert5(ExecState* exec)\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     e* (toe(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -2627,7 +2627,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionStrictFunction(ExecState*\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n     TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n     if (exec->argumentCount() < 3)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     ExceptionCode ec = 0;\n     const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())""}<_**next**_>{""sha"": ""db5304973425b452f010e94ab4d2f4089b59b05e"", ""filename"": ""third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/b944f670bb7a8a919daac497a4ea0536c954c201/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/WebCore/bindings/scripts/test/JS/JSTestSerializedScriptValueInterface.cpp?ref=b944f670bb7a8a919daac497a4ea0536c954c201"", ""patch"": ""@@ -90,7 +90,7 @@ EncodedJSValue JSC_HOST_CALL JSTestSerializedScriptValueInterfaceConstructor::co\n {\n     JSTestSerializedScriptValueInterfaceConstructor* castedThis = jsCast<JSTestSerializedScriptValueInterfaceConstructor*>(exec->callee());\n     if (exec->argumentCount() < 2)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     const String& hello(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());\n@@ -282,7 +282,7 @@ EncodedJSValue JSC_HOST_CALL jsTestSerializedScriptValueInterfacePrototypeFuncti\n     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestSerializedScriptValueInterface::s_info);\n     TestSerializedScriptValueInterface* impl = static_cast<TestSerializedScriptValueInterface*>(castedThis->impl());\n     if (exec->argumentCount() < 1)\n-        return throwVMError(exec, createTypeError(exec, \""Not enough arguments\""));\n+        return throwVMError(exec, createNotEnoughArgumentsError(exec));\n     RefPtr<SerializedScriptValue> data(SerializedScriptValue::create(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));\n     if (exec->hadException())\n         return JSValue::encode(jsUndefined());""}","JSValue jsTestObjReflectedUnsignedIntegralAttr(ExecState* exec, JSValue slotBase, const Identifier&)
{
    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    TestObj* impl = static_cast<TestObj*>(castedThis->impl());
    JSValue result = jsNumber(std::max(0, impl->getIntegralAttribute(WebCore::HTMLNames::reflectedunsignedintegralattrAttr)));
    return result;
}
","JSValue jsTestObjReflectedUnsignedIntegralAttr(ExecState* exec, JSValue slotBase, const Identifier&)
{
    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    TestObj* impl = static_cast<TestObj*>(castedThis->impl());
    JSValue result = jsNumber(std::max(0, impl->getIntegralAttribute(WebCore::HTMLNames::reflectedunsignedintegralattrAttr)));
    return result;
}
",C,,,,"@@ -235,7 +235,7 @@ EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState*
 {
     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
         setDOMException(exec, TYPE_MISMATCH_ERR);
         return JSValue::encode(jsUndefined());
@@ -1577,7 +1577,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionVoidMethodWithArgs(ExecSt
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 3)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1613,7 +1613,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIntMethodWithArgs(ExecSta
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 3)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1650,7 +1650,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionObjMethodWithArgs(ExecSta
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 3)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1674,7 +1674,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithSequenceArg(Exe
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     sequence<ScriptProfile>* sequenceArg(toNativeArray<ScriptProfile>(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1691,7 +1691,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodReturningSequence(E
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1709,7 +1709,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodThatRequiresAllArgs
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 2)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     ExceptionCode ec = 0;
     const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
     if (exec->hadException())
@@ -1732,7 +1732,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionSerializedValue(ExecState
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     RefPtr<SerializedScriptValue> serializedArg(SerializedScriptValue::create(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1749,7 +1749,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionIdbKey(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     PassRefPtr<IDBKey> key(createIDBKeyFromValue(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1766,7 +1766,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOptionsObject(ExecState*
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     Dictionary oo(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -1827,7 +1827,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionAddEventListener(ExecStat
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 2)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     JSValue listener = exec->argument(1);
     if (!listener.isObject())
         return JSValue::encode(jsUndefined());
@@ -1844,7 +1844,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionRemoveEventListener(ExecS
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 2)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     JSValue listener = exec->argument(1);
     if (!listener.isObject())
         return JSValue::encode(jsUndefined());
@@ -2023,7 +2023,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgA
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2050,7 +2050,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonOptionalArgA
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int nonOpt(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2137,7 +2137,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithCallbackArg(Exe
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
         setDOMException(exec, TYPE_MISMATCH_ERR);
         return JSValue::encode(jsUndefined());
@@ -2156,7 +2156,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithNonCallbackArgA
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 2)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int nonCallback(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2244,7 +2244,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod1(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 2)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2264,7 +2264,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod2(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2291,7 +2291,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod3(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2308,7 +2308,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod4(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int intArg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2325,7 +2325,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod5(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
         setDOMException(exec, TYPE_MISMATCH_ERR);
         return JSValue::encode(jsUndefined());
@@ -2344,7 +2344,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2361,7 +2361,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod7(
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     DOMStringList* arrayArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2418,15 +2418,15 @@ EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethodWithOptional
 EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionClassMethod2(ExecState* exec)
 {
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     return JSValue::encode(JSTestObj::classMethod2(exec));
 }
 
 #if ENABLE(Condition1)
 static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod11(ExecState* exec)
 {
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     int arg(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toInt32(exec));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2440,7 +2440,7 @@ static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod
 static EncodedJSValue JSC_HOST_CALL jsTestObjConstructorFunctionOverloadedMethod12(ExecState* exec)
 {
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     const String& type(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2470,7 +2470,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionMethodWithUnsignedLongArr
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     Vector<unsigned long> unsignedLongArray(jsUnsignedLongArrayToVector(exec, MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2504,7 +2504,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert1(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     a* (toa(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2521,7 +2521,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert2(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     b* (tob(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2538,7 +2538,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert3(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     c* (toc(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2555,7 +2555,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert4(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     d* (tod(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2572,7 +2572,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionConvert5(ExecState* exec)
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     e* (toe(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
@@ -2627,7 +2627,7 @@ EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionStrictFunction(ExecState*
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 3)
-        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
+        return throwVMError(exec, createNotEnoughArgumentsError(exec));
     ExceptionCode ec = 0;
     const String& str(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
     if (exec->hadException())",Chrome,b944f670bb7a8a919daac497a4ea0536c954c201,c37d36f1289ae2b10d3cc1b2818d095ff403064b,0,"JSValue jsTestObjReflectedUnsignedIntegralAttr(ExecState* exec, JSValue slotBase, const Identifier&)
{
    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(slotBase));
    UNUSED_PARAM(exec);
    TestObj* impl = static_cast<TestObj*>(castedThis->impl());
    JSValue result = jsNumber(std::max(0, impl->getIntegralAttribute(WebCore::HTMLNames::reflectedunsignedintegralattrAttr)));
    return result;
}
"
64926,,Remote,Not required,Partial,CVE-2017-9203,https://www.cvedetails.com/cve/CVE-2017-9203/,CWE-787,Medium,,,,2017-05-23,4.3,"imagew-main.c:960:12 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (buffer underflow) via a crafted image, related to imagew-bmp.c.",2019-10-02,DoS ,0,https://github.com/jsummers/imageworsener/commit/a4f247707f08e322f0b41e82c3e06e224240a654,a4f247707f08e322f0b41e82c3e06e224240a654,"Fixed a bug that could cause invalid memory to be accessed

The bug could happen when transparency is removed from an image.
Also fixed a semi-related BMP error handling logic bug.
Fixes issue #21",0,src/imagew-main.c,"{""sha"": ""811da1d5704db5c6add2bc0ac3ec78a01be65e9b"", ""filename"": ""src/imagew-bmp.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/jsummers/imageworsener/blob/a4f247707f08e322f0b41e82c3e06e224240a654/src/imagew-bmp.c"", ""raw_url"": ""https://github.com/jsummers/imageworsener/raw/a4f247707f08e322f0b41e82c3e06e224240a654/src/imagew-bmp.c"", ""contents_url"": ""https://api.github.com/repos/jsummers/imageworsener/contents/src/imagew-bmp.c?ref=a4f247707f08e322f0b41e82c3e06e224240a654"", ""patch"": ""@@ -847,11 +847,13 @@ static int bmpr_read_rle(struct iwbmprcontext *rctx)\n \t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n \t{\n \t\tiw_set_error(rctx->ctx,\""Compression type incompatible with image type\"");\n+\t\tgoto done;\n \t}\n \n \tif(rctx->topdown) {\n \t\t// The documentation says that top-down images may not be compressed.\n \t\tiw_set_error(rctx->ctx,\""Compression not allowed with top-down images\"");\n+\t\tgoto done;\n \t}\n \n \t// RLE-compressed BMP images don't have to assign a color to every pixel,""}<_**next**_>{""sha"": ""5a59c05feb005642791b417a043a3419a9415008"", ""filename"": ""src/imagew-main.c"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 3, ""changes"": 18, ""blob_url"": ""https://github.com/jsummers/imageworsener/blob/a4f247707f08e322f0b41e82c3e06e224240a654/src/imagew-main.c"", ""raw_url"": ""https://github.com/jsummers/imageworsener/raw/a4f247707f08e322f0b41e82c3e06e224240a654/src/imagew-main.c"", ""contents_url"": ""https://api.github.com/repos/jsummers/imageworsener/contents/src/imagew-main.c?ref=a4f247707f08e322f0b41e82c3e06e224240a654"", ""patch"": ""@@ -922,8 +922,6 @@ static int iw_process_cols_to_intermediate(struct iw_context *ctx, int channel,\n \treturn retval;\n }\n \n-// 'handle_alpha_flag' must be set if an alpha channel exists and this is not\n-// the alpha channel.\n static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,\n \tconst struct iw_csdescr *out_csdescr)\n {\n@@ -951,13 +949,27 @@ static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int int\n \tiw_tmpsample *out_pix = NULL;\n \tint num_in_pix;\n \tint num_out_pix;\n+\tstruct iw_channelinfo_out default_ci_out;\n \n \tnum_in_pix = ctx->intermed_canvas_width;\n \tnum_out_pix = ctx->img2.width;\n \n \tint_ci = &ctx->intermed_ci[intermed_channel];\n \toutput_channel = int_ci->corresponding_output_channel;\n-\tout_ci = &ctx->img2_ci[output_channel];\n+\tif(output_channel>=0) {\n+\t\tout_ci = &ctx->img2_ci[output_channel];\n+\t}\n+\telse {\n+\t\t// If there is no output channelinfo struct, create a temporary one to\n+\t\t// use.\n+\t\t// TODO: This is admittedly ugly, but we use these settings for a few\n+\t\t// things even when there is no corresponding output channel, and I\n+\t\t// don't remember exactly why.\n+\t\tiw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));\n+\t\tdefault_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;\n+\t\tout_ci = &default_ci_out;\n+\t}\n+\n \tis_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);\n \tbkgd_has_transparency = iw_bkgd_has_transparency(ctx);\n ""}","static void iw_process_bkgd_label(struct iw_context *ctx)
{
	int ret;
	int k;
	struct iw_color clr;
	double maxcolor;
	unsigned int tmpu;

	if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
	{
		return;
	}

	ret = get_output_bkgd_label_lin(ctx,&clr);
	if(!ret) return;

	if(ctx->to_grayscale) {
		iw_tmpsample g;
		g = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
		clr.c[0] = clr.c[1] = clr.c[2] = g;
	}

	if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
		maxcolor=255.0;
	}
	else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
		maxcolor=65535.0;
	}
	else if(ctx->img2.bit_depth==8) {
		maxcolor=255.0;
	}
	else if(ctx->img2.bit_depth==16) {
		maxcolor=65535.0;
	}
	else {
		return;
	}

	for(k=0;k<3;k++) {
		tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, maxcolor);
		ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/maxcolor;
	}
	tmpu = iw_scale_to_int(clr.c[3],(unsigned int)maxcolor);
	ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/maxcolor;

	ctx->img2.has_bkgdlabel = 1;
}
","static void iw_process_bkgd_label(struct iw_context *ctx)
{
	int ret;
	int k;
	struct iw_color clr;
	double maxcolor;
	unsigned int tmpu;

	if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
	{
		return;
	}

	ret = get_output_bkgd_label_lin(ctx,&clr);
	if(!ret) return;

	if(ctx->to_grayscale) {
		iw_tmpsample g;
		g = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
		clr.c[0] = clr.c[1] = clr.c[2] = g;
	}

	if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
		maxcolor=255.0;
	}
	else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
		maxcolor=65535.0;
	}
	else if(ctx->img2.bit_depth==8) {
		maxcolor=255.0;
	}
	else if(ctx->img2.bit_depth==16) {
		maxcolor=65535.0;
	}
	else {
		return;
	}

	for(k=0;k<3;k++) {
		tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, maxcolor);
		ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/maxcolor;
	}
	tmpu = iw_scale_to_int(clr.c[3],(unsigned int)maxcolor);
	ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/maxcolor;

	ctx->img2.has_bkgdlabel = 1;
}
",C,,,,"@@ -922,8 +922,6 @@ static int iw_process_cols_to_intermediate(struct iw_context *ctx, int channel,
 	return retval;
 }
 
-// 'handle_alpha_flag' must be set if an alpha channel exists and this is not
-// the alpha channel.
 static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel,
 	const struct iw_csdescr *out_csdescr)
 {
@@ -951,13 +949,27 @@ static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int int
 	iw_tmpsample *out_pix = NULL;
 	int num_in_pix;
 	int num_out_pix;
+	struct iw_channelinfo_out default_ci_out;
 
 	num_in_pix = ctx->intermed_canvas_width;
 	num_out_pix = ctx->img2.width;
 
 	int_ci = &ctx->intermed_ci[intermed_channel];
 	output_channel = int_ci->corresponding_output_channel;
-	out_ci = &ctx->img2_ci[output_channel];
+	if(output_channel>=0) {
+		out_ci = &ctx->img2_ci[output_channel];
+	}
+	else {
+		// If there is no output channelinfo struct, create a temporary one to
+		// use.
+		// TODO: This is admittedly ugly, but we use these settings for a few
+		// things even when there is no corresponding output channel, and I
+		// don't remember exactly why.
+		iw_zeromem(&default_ci_out, sizeof(struct iw_channelinfo_out));
+		default_ci_out.channeltype = IW_CHANNELTYPE_NONALPHA;
+		out_ci = &default_ci_out;
+	}
+
 	is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA);
 	bkgd_has_transparency = iw_bkgd_has_transparency(ctx);
 ",imageworsener,a4f247707f08e322f0b41e82c3e06e224240a654,e2f74906e9cca95ee48e7f019436b9635eab30ba,0,"static void iw_process_bkgd_label(struct iw_context *ctx)
{
	int ret;
	int k;
	struct iw_color clr;
	double maxcolor;
	unsigned int tmpu;

	if(!(ctx->output_profile&IW_PROFILE_PNG_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB8_BKGD) &&
		!(ctx->output_profile&IW_PROFILE_RGB16_BKGD))
	{
		return;
	}

	ret = get_output_bkgd_label_lin(ctx,&clr);
	if(!ret) return;

	if(ctx->to_grayscale) {
		iw_tmpsample g;
		g = iw_color_to_grayscale(ctx, clr.c[0], clr.c[1], clr.c[2]);
		clr.c[0] = clr.c[1] = clr.c[2] = g;
	}

	if(ctx->output_profile&IW_PROFILE_RGB8_BKGD) {
		maxcolor=255.0;
	}
	else if(ctx->output_profile&IW_PROFILE_RGB16_BKGD) {
		maxcolor=65535.0;
	}
	else if(ctx->img2.bit_depth==8) {
		maxcolor=255.0;
	}
	else if(ctx->img2.bit_depth==16) {
		maxcolor=65535.0;
	}
	else {
		return;
	}

	// Although the bkgd label is stored as floating point, we're responsible for
	// making sure that, when scaled and rounded to a format suitable for the output
	// format, it will be the correct color.
	for(k=0;k<3;k++) {
		tmpu = calc_sample_convert_from_linear(ctx, clr.c[k], &ctx->img2cs, maxcolor);
		ctx->img2.bkgdlabel.c[k] = ((double)tmpu)/maxcolor;
	}
	// Alpha sample
	tmpu = iw_scale_to_int(clr.c[3],(unsigned int)maxcolor);
	ctx->img2.bkgdlabel.c[3] = ((double)tmpu)/maxcolor;

	ctx->img2.has_bkgdlabel = 1;
}
"
52170,,Remote,Not required,Partial,CVE-2016-5096,https://www.cvedetails.com/cve/CVE-2016-5096/,CWE-190,Low,Partial,Partial,,2016-08-07,7.5,Integer overflow in the fread function in ext/standard/file.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer in the second argument.,2018-01-04,DoS Overflow ,0,https://github.com/php/php-src/commit/abd159cce48f3e34f08e4751c568e09677d5ec9c?w=1,abd159cce48f3e34f08e4751c568e09677d5ec9c?w=1,Fix bug #72114 - int/size_t confusion in fread,0,ext/standard/file.c,"{""sha"": ""e39c84f1cd41e536a35b5069f74443d66bae87b5"", ""filename"": ""ext/standard/file.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/php/php-src/blob/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/file.c"", ""raw_url"": ""https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/file.c"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/file.c?ref=abd159cce48f3e34f08e4751c568e09677d5ec9c"", ""patch"": ""@@ -1758,6 +1758,12 @@ PHPAPI PHP_FUNCTION(fread)\n \t\tRETURN_FALSE;\n \t}\n \n+\tif (len > INT_MAX) {\n+\t\t/* string length is int in 5.x so we can not read more than int */\n+\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \""Length parameter must be no more than %d\"", INT_MAX);\n+\t\tRETURN_FALSE;\n+\t}\n+\n \tZ_STRVAL_P(return_value) = emalloc(len + 1);\n \tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n ""}<_**next**_>{""sha"": ""5e591ee478e83c1a7b7b856298c7130d25d5df63"", ""filename"": ""ext/standard/tests/file/bug72114.phpt"", ""status"": ""added"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/php/php-src/blob/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/tests/file/bug72114.phpt"", ""raw_url"": ""https://github.com/php/php-src/raw/abd159cce48f3e34f08e4751c568e09677d5ec9c/ext/standard/tests/file/bug72114.phpt"", ""contents_url"": ""https://api.github.com/repos/php/php-src/contents/ext/standard/tests/file/bug72114.phpt?ref=abd159cce48f3e34f08e4751c568e09677d5ec9c"", ""patch"": ""@@ -0,0 +1,12 @@\n+--TEST--\n+Bug #72114 (Integer underflow / arbitrary null write in fread/gzread)\n+--FILE--\n+<?php\n+ini_set('memory_limit', \""2500M\"");\n+$fp = fopen(\""/dev/zero\"", \""r\"");\n+fread($fp, 2147483648);\n+?>\n+Done\n+--EXPECTF--\n+Warning: fread(): Length parameter must be no more than 2147483647 in %s/bug72114.php on line %d\n+Done""}","PHP_FUNCTION(unlink)
{
	char *filename;
	int filename_len;
	php_stream_wrapper *wrapper;
	zval *zcontext = NULL;
	php_stream_context *context = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|r"", &filename, &filename_len, &zcontext) == FAILURE) {
		RETURN_FALSE;
	}

	context = php_stream_context_from_zval(zcontext, 0);

	wrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);

	if (!wrapper || !wrapper->wops) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to locate stream wrapper"");
		RETURN_FALSE;
	}

	if (!wrapper->wops->unlink) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s does not allow unlinking"", wrapper->wops->label ? wrapper->wops->label : ""Wrapper"");
		RETURN_FALSE;
	}
	RETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));
}
","PHP_FUNCTION(unlink)
{
	char *filename;
	int filename_len;
	php_stream_wrapper *wrapper;
	zval *zcontext = NULL;
	php_stream_context *context = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|r"", &filename, &filename_len, &zcontext) == FAILURE) {
		RETURN_FALSE;
	}

	context = php_stream_context_from_zval(zcontext, 0);

	wrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);

	if (!wrapper || !wrapper->wops) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to locate stream wrapper"");
		RETURN_FALSE;
	}

	if (!wrapper->wops->unlink) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s does not allow unlinking"", wrapper->wops->label ? wrapper->wops->label : ""Wrapper"");
		RETURN_FALSE;
	}
	RETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));
}
",C,,,,"@@ -1758,6 +1758,12 @@ PHPAPI PHP_FUNCTION(fread)
 		RETURN_FALSE;
 	}
 
+	if (len > INT_MAX) {
+		/* string length is int in 5.x so we can not read more than int */
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be no more than %d"", INT_MAX);
+		RETURN_FALSE;
+	}
+
 	Z_STRVAL_P(return_value) = emalloc(len + 1);
 	Z_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);
 ",php-src,abd159cce48f3e34f08e4751c568e09677d5ec9c?w=1,95ed19ae28009aa7b3ed42d5760478de82640560,0,"PHP_FUNCTION(unlink)
{
	char *filename;
	int filename_len;
	php_stream_wrapper *wrapper;
	zval *zcontext = NULL;
	php_stream_context *context = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|r"", &filename, &filename_len, &zcontext) == FAILURE) {
		RETURN_FALSE;
	}

	context = php_stream_context_from_zval(zcontext, 0);

	wrapper = php_stream_locate_url_wrapper(filename, NULL, 0 TSRMLS_CC);

	if (!wrapper || !wrapper->wops) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to locate stream wrapper"");
		RETURN_FALSE;
	}

	if (!wrapper->wops->unlink) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s does not allow unlinking"", wrapper->wops->label ? wrapper->wops->label : ""Wrapper"");
		RETURN_FALSE;
	}
	RETURN_BOOL(wrapper->wops->unlink(wrapper, filename, REPORT_ERRORS, context TSRMLS_CC));
}
"
102901,,Remote,Not required,,CVE-2011-2840,https://www.cvedetails.com/cve/CVE-2011-2840/,CWE-20,Medium,Partial,Partial,,2011-09-19,5.8,Google Chrome before 14.0.835.163 allows user-assisted remote attackers to spoof the URL bar via vectors related to *unusual user interaction.*,2017-09-18,,0,https://github.com/chromium/chromium/commit/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,"chromeos: fix bug where ""aw snap"" page replaces first tab if it was a NTP when closing window with > 1 tab.

BUG=chromium-os:12088
TEST=verify bug per bug report.
Review URL: http://codereview.chromium.org/6882058

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@83031 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/chromeos/tab_closeable_state_watcher.cc,"{""sha"": ""81331e558ee2c3f6309ab69aa0a425d500e4daa4"", ""filename"": ""chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 0, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/tab_closeable_state_watcher.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -85,6 +85,48 @@ bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {\n       (can_close_tab_ || waiting_for_browser_);\n }\n \n+bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,\n+    std::vector<int>* indices) const {\n+  if (signing_off_ || waiting_for_browser_ || tabstrip_watchers_.size() > 1 ||\n+      browser->type() != Browser::TYPE_NORMAL ||\n+      (browser->profile()->IsOffTheRecord() && !guest_session_))\n+    return true;\n+\n+  if (!can_close_tab_) {\n+    indices->clear();\n+    return false;\n+  }\n+\n+  TabStripModel* tabstrip_model = browser->tabstrip_model();\n+  // If we're not closing all tabs, there's no restriction.\n+  if (static_cast<int>(indices->size()) != tabstrip_model->count())\n+    return true;\n+\n+  // If first tab is NTP, it can't be closed.\n+  // In TabStripModel::InternalCloseTabs (which calls\n+  // Browser::CanCloseContents which in turn calls this method), all\n+  // renderer processes of tabs could be terminated before the tabs are actually\n+  // closed.\n+  // As tabs are being closed, notification TabDetachedAt is called.\n+  // When this happens to the last second tab, we would prevent the last NTP\n+  // tab from being closed.\n+  // If we don't prevent this NTP tab from being closed now, its renderer\n+  // process would have been terminated but the tab won't be detached later,\n+  // resulting in the \""Aw, Snap\"" page replacing the first NTP.\n+  // This is the main purpose of this method CanCloseTabs.\n+  for (size_t i = 0; i < indices->size(); ++i) {\n+    if ((*indices)[i] == 0) {\n+      if (tabstrip_model->GetTabContentsAt(0)->tab_contents()->GetURL() ==\n+          GURL(chrome::kChromeUINewTabURL)) {  // First tab is NewTabPage.\n+        indices->erase(indices->begin() + i);  // Don't close it.\n+        return false;\n+      }\n+      break;\n+    }\n+  }\n+  return true;\n+}\n+\n bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {\n   BrowserActionType action_type;\n   bool can_close = CanCloseBrowserImpl(browser, &action_type);""}<_**next**_>{""sha"": ""b1d448f2488eec0afd41d2fe957a9ead276bf596"", ""filename"": ""chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/chromeos/tab_closeable_state_watcher.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chromeos/tab_closeable_state_watcher.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -48,6 +48,8 @@ class TabCloseableStateWatcher : public ::TabCloseableStateWatcher,\n \n   // TabCloseableStateWatcher implementation:\n   virtual bool CanCloseTab(const Browser* browser) const;\n+  virtual bool CanCloseTabs(const Browser* browser,\n+                            std::vector<int>* indices) const;\n   virtual bool CanCloseBrowser(Browser* browser);\n   virtual void OnWindowCloseCanceled(Browser* browser);\n ""}<_**next**_>{""sha"": ""8952542c9aabfceb94760586c9a974ea60d5d7c9"", ""filename"": ""chrome/browser/tab_closeable_state_watcher.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tab_closeable_state_watcher.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -32,6 +32,11 @@ bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {\n   return true;\n }\n \n+bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,\n+    std::vector<int>* indices) const {\n+  return true;\n+}\n+\n bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {\n   return true;\n }""}<_**next**_>{""sha"": ""9325b46ec790e3d778b61ce10b94da319c76c021"", ""filename"": ""chrome/browser/tab_closeable_state_watcher.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 1, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tab_closeable_state_watcher.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tab_closeable_state_watcher.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,11 +1,13 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n #ifndef CHROME_BROWSER_TAB_CLOSEABLE_STATE_WATCHER_H_\n #define CHROME_BROWSER_TAB_CLOSEABLE_STATE_WATCHER_H_\n #pragma once\n \n+#include <vector>\n+\n #include \""base/basictypes.h\""\n \n class Browser;\n@@ -34,6 +36,15 @@ class TabCloseableStateWatcher {\n   // - determining if accelerator keys to close tab should be processed\n   virtual bool CanCloseTab(const Browser* browser) const;\n \n+  // Called from Browser::CanCloseContents which overrides\n+  // TabStripModelDelegate::CanCloseContents, and is called in\n+  // TabStripModel::InternalCloseTabs.\n+  // Returns true if all contents in entire array of |indices| can be closed.\n+  // Returns false if one or more contents can't be closed.\n+  // Indices of contents that cannot be closed will be removed from |indices|.\n+  virtual bool CanCloseTabs(const Browser* browser,\n+                            std::vector<int>* indices) const;\n+\n   // Called from Browser::IsClosingPermitted which is in turn called from\n   // Browser::ShouldCloseWindow to check if |browser| can be closed.\n   virtual bool CanCloseBrowser(Browser* browser);""}<_**next**_>{""sha"": ""b81f0a2839b1d3ba49ec9139baa749bc1fa62582"", ""filename"": ""chrome/browser/tabs/default_tab_handler.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/default_tab_handler.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -95,8 +95,8 @@ bool DefaultTabHandler::RunUnloadListenerBeforeClosing(\n   return delegate_->AsBrowser()->RunUnloadListenerBeforeClosing(contents);\n }\n \n-bool DefaultTabHandler::CanCloseContentsAt(int index) {\n-  return delegate_->AsBrowser()->CanCloseContentsAt(index);\n+bool DefaultTabHandler::CanCloseContents(std::vector<int>* indices) {\n+  return delegate_->AsBrowser()->CanCloseContents(indices);\n }\n \n bool DefaultTabHandler::CanBookmarkAllTabs() const {""}<_**next**_>{""sha"": ""09f779a9c62dc66508abb9d21cb27f2c431be487"", ""filename"": ""chrome/browser/tabs/default_tab_handler.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/default_tab_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/default_tab_handler.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -6,6 +6,8 @@\n #define CHROME_BROWSER_TABS_DEFAULT_TAB_HANDLER_H_\n #pragma once\n \n+#include <vector>\n+\n #include \""base/memory/scoped_ptr.h\""\n #include \""chrome/browser/tabs/tab_handler.h\""\n #include \""chrome/browser/tabs/tab_strip_model_delegate.h\""\n@@ -45,7 +47,7 @@ class DefaultTabHandler : public TabHandler,\n   virtual void CloseFrameAfterDragSession();\n   virtual void CreateHistoricalTab(TabContentsWrapper* contents);\n   virtual bool RunUnloadListenerBeforeClosing(TabContentsWrapper* contents);\n-  virtual bool CanCloseContentsAt(int index);\n+  virtual bool CanCloseContents(std::vector<int>* indices);\n   virtual bool CanBookmarkAllTabs() const;\n   virtual void BookmarkAllTabs();\n   virtual bool CanCloseTab() const;""}<_**next**_>{""sha"": ""7acb656c557f26e31cc2c83dd9b1afaec5b7464c"", ""filename"": ""chrome/browser/tabs/tab_strip_model.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 13, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1100,12 +1100,15 @@ bool TabStripModel::IsNewTabAtEndOfTabStrip(\n       contents->controller().entry_count() == 1;\n }\n \n-bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n+bool TabStripModel::InternalCloseTabs(const std::vector<int>& in_indices,\n                                       uint32 close_types) {\n-  if (indices.empty())\n+  if (in_indices.empty())\n     return true;\n \n-  bool retval = true;\n+  std::vector<int> indices(in_indices);\n+  bool retval = delegate_->CanCloseContents(&indices);\n+  if (indices.empty())\n+    return retval;\n \n   // Map the indices to TabContents, that way if deleting a tab deletes other\n   // tabs we're ok. Crashes seem to indicate during tab deletion other tabs are\n@@ -1122,11 +1125,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n     // closing.\n     std::map<RenderProcessHost*, size_t> processes;\n     for (size_t i = 0; i < indices.size(); ++i) {\n-      if (!delegate_->CanCloseContentsAt(indices[i])) {\n-        retval = false;\n-        continue;\n-      }\n-\n       TabContentsWrapper* detached_contents = GetContentsAt(indices[i]);\n       RenderProcessHost* process =\n           detached_contents->tab_contents()->GetRenderProcessHost();\n@@ -1157,11 +1155,6 @@ bool TabStripModel::InternalCloseTabs(const std::vector<int>& indices,\n \n     detached_contents->tab_contents()->OnCloseStarted();\n \n-    if (!delegate_->CanCloseContentsAt(index)) {\n-      retval = false;\n-      continue;\n-    }\n-\n     // Update the explicitly closed state. If the unload handlers cancel the\n     // close the state is reset in Browser. We don't update the explicitly\n     // closed state if already marked as explicitly closed as unload handlers""}<_**next**_>{""sha"": ""f236e5f423dfc33376bf5a7c16a389e10b7ae19d"", ""filename"": ""chrome/browser/tabs/tab_strip_model.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -493,7 +493,8 @@ class TabStripModel : public NotificationObserver {\n   //\n   // Returns true if the TabContents were closed immediately, false if we are\n   // waiting for the result of an onunload handler.\n-  bool InternalCloseTabs(const std::vector<int>& indices, uint32 close_types);\n+  bool InternalCloseTabs(const std::vector<int>& in_indices,\n+                         uint32 close_types);\n \n   // Invoked from InternalCloseTabs and when an extension is removed for an app\n   // tab. Notifies observers of TabClosingAt and deletes |contents|. If""}<_**next**_>{""sha"": ""bae327e3d1474e5011c1e4cf03d83e02215c96b5"", ""filename"": ""chrome/browser/tabs/tab_strip_model_delegate.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model_delegate.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -1,4 +1,4 @@\n-// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n+// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n@@ -97,8 +97,10 @@ class TabStripModelDelegate {\n   // Restores the last closed tab if CanRestoreTab would return true.\n   virtual void RestoreTab() = 0;\n \n-  // Returns whether some contents can be closed.\n-  virtual bool CanCloseContentsAt(int index) = 0;\n+  // Returns true if all contents in array of |indices| can be closed.\n+  // Returns false if one or more of the contents can't be closed.\n+  // Indices of contents that cannot be closed will be removed from |indices|.\n+  virtual bool CanCloseContents(std::vector<int>* indices) = 0;\n \n   // Returns true if we should allow \""bookmark all tabs\"" in this window; this is\n   // true when there is more than one bookmarkable tab open.""}<_**next**_>{""sha"": ""4c99a068e15a62e0a257dcfc8b1fc16f65313a92"", ""filename"": ""chrome/browser/tabs/tab_strip_model_unittest.cc"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 1, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/tabs/tab_strip_model_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/tabs/tab_strip_model_unittest.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -120,7 +120,11 @@ class TabStripDummyDelegate : public TabStripModelDelegate {\n   }\n   virtual bool CanRestoreTab() { return false; }\n   virtual void RestoreTab() {}\n-  virtual bool CanCloseContentsAt(int index) { return can_close_ ; }\n+  virtual bool CanCloseContents(std::vector<int>* indices) {\n+    if (!can_close_)\n+      indices->clear();\n+    return can_close_;\n+  }\n   virtual bool CanBookmarkAllTabs() const { return false; }\n   virtual void BookmarkAllTabs() {}\n   virtual bool CanCloseTab() const { return true; }""}<_**next**_>{""sha"": ""4d1777e99271ace15aef6e9ba0c8fc15b03fccc9"", ""filename"": ""chrome/browser/ui/browser.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 6, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser.cc?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -2635,16 +2635,25 @@ bool Browser::CanReloadContents(TabContents* source) const {\n   return type() != TYPE_DEVTOOLS;\n }\n \n-bool Browser::CanCloseContentsAt(int index) {\n-  if (!CanCloseTab())\n+bool Browser::CanCloseContents(std::vector<int>* indices) {\n+  DCHECK(!indices->empty());\n+  TabCloseableStateWatcher* watcher =\n+      g_browser_process->tab_closeable_state_watcher();\n+  bool can_close_all = !watcher || watcher->CanCloseTabs(this, indices);\n+  if (indices->empty())  // Cannot close any tab.\n     return false;\n-  if (tab_handler_->GetTabStripModel()->count() > 1)\n-    return true;\n-  // We are closing the last tab for this browser. Make sure to check for\n+  // Now, handle cases where at least one tab can be closed.\n+  // If we are closing all the tabs for this browser, make sure to check for\n   // in-progress downloads.\n   // Note that the next call when it returns false will ask the user for\n   // confirmation before closing the browser if the user decides so.\n-  return CanCloseWithInProgressDownloads();\n+  if (tab_handler_->GetTabStripModel()->count() ==\n+          static_cast<int>(indices->size()) &&\n+      !CanCloseWithInProgressDownloads()) {\n+    indices->clear();\n+    can_close_all = false;\n+  }\n+  return can_close_all;\n }\n \n bool Browser::CanBookmarkAllTabs() const {""}<_**next**_>{""sha"": ""51559099ebe21e10565e069abcb923204ef2a308"", ""filename"": ""chrome/browser/ui/browser.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/browser.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/browser.h?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -694,7 +694,7 @@ class Browser : public TabHandlerDelegate,\n   virtual void CloseFrameAfterDragSession();\n   virtual void CreateHistoricalTab(TabContentsWrapper* contents);\n   virtual bool RunUnloadListenerBeforeClosing(TabContentsWrapper* contents);\n-  virtual bool CanCloseContentsAt(int index);\n+  virtual bool CanCloseContents(std::vector<int>* indices);\n   virtual bool CanBookmarkAllTabs() const;\n   virtual void BookmarkAllTabs();\n   virtual bool CanCloseTab() const;""}<_**next**_>{""sha"": ""59c775775e520e8a013d3153b8e97746e171d143"", ""filename"": ""chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2db5a2048dfcacfe5ad4311c2b1e435c4c67febc/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/cocoa/tabs/tab_strip_controller_unittest.mm?ref=2db5a2048dfcacfe5ad4311c2b1e435c4c67febc"", ""patch"": ""@@ -4,6 +4,8 @@\n \n #import <Cocoa/Cocoa.h>\n \n+#include <vector>\n+\n #import \""chrome/browser/ui/browser_window.h\""\n #include \""chrome/browser/ui/cocoa/browser_test_helper.h\""\n #import \""chrome/browser/ui/cocoa/cocoa_test_helper.h\""\n@@ -78,7 +80,7 @@ virtual bool CanRestoreTab() {\n   }\n   virtual void RestoreTab() {}\n \n-  virtual bool CanCloseContentsAt(int index) { return true; }\n+  virtual bool CanCloseContents(std::vector<int>* indices) { return true; }\n \n   virtual bool CanBookmarkAllTabs() const { return false; }\n ""}","TabCloseableStateWatcher::TabCloseableStateWatcher()
    : can_close_tab_(true),
      signing_off_(false),
      guest_session_(
          CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kGuestSession)),
      waiting_for_browser_(false) {
  BrowserList::AddObserver(this);
  notification_registrar_.Add(this, NotificationType::APP_EXITING,
      NotificationService::AllSources());
}
","TabCloseableStateWatcher::TabCloseableStateWatcher()
    : can_close_tab_(true),
      signing_off_(false),
      guest_session_(
          CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kGuestSession)),
      waiting_for_browser_(false) {
  BrowserList::AddObserver(this);
  notification_registrar_.Add(this, NotificationType::APP_EXITING,
      NotificationService::AllSources());
}
",C,,,,"@@ -85,6 +85,48 @@ bool TabCloseableStateWatcher::CanCloseTab(const Browser* browser) const {
       (can_close_tab_ || waiting_for_browser_);
 }
 
+bool TabCloseableStateWatcher::CanCloseTabs(const Browser* browser,
+    std::vector<int>* indices) const {
+  if (signing_off_ || waiting_for_browser_ || tabstrip_watchers_.size() > 1 ||
+      browser->type() != Browser::TYPE_NORMAL ||
+      (browser->profile()->IsOffTheRecord() && !guest_session_))
+    return true;
+
+  if (!can_close_tab_) {
+    indices->clear();
+    return false;
+  }
+
+  TabStripModel* tabstrip_model = browser->tabstrip_model();
+  // If we're not closing all tabs, there's no restriction.
+  if (static_cast<int>(indices->size()) != tabstrip_model->count())
+    return true;
+
+  // If first tab is NTP, it can't be closed.
+  // In TabStripModel::InternalCloseTabs (which calls
+  // Browser::CanCloseContents which in turn calls this method), all
+  // renderer processes of tabs could be terminated before the tabs are actually
+  // closed.
+  // As tabs are being closed, notification TabDetachedAt is called.
+  // When this happens to the last second tab, we would prevent the last NTP
+  // tab from being closed.
+  // If we don't prevent this NTP tab from being closed now, its renderer
+  // process would have been terminated but the tab won't be detached later,
+  // resulting in the ""Aw, Snap"" page replacing the first NTP.
+  // This is the main purpose of this method CanCloseTabs.
+  for (size_t i = 0; i < indices->size(); ++i) {
+    if ((*indices)[i] == 0) {
+      if (tabstrip_model->GetTabContentsAt(0)->tab_contents()->GetURL() ==
+          GURL(chrome::kChromeUINewTabURL)) {  // First tab is NewTabPage.
+        indices->erase(indices->begin() + i);  // Don't close it.
+        return false;
+      }
+      break;
+    }
+  }
+  return true;
+}
+
 bool TabCloseableStateWatcher::CanCloseBrowser(Browser* browser) {
   BrowserActionType action_type;
   bool can_close = CanCloseBrowserImpl(browser, &action_type);",Chrome,2db5a2048dfcacfe5ad4311c2b1e435c4c67febc,5f1d4bfc647a6caf4d9bbc1ba7798a3ccdd4f3c4,0,"TabCloseableStateWatcher::TabCloseableStateWatcher()
    : can_close_tab_(true),
      signing_off_(false),
      guest_session_(
          CommandLine::ForCurrentProcess()->HasSwitch(
              switches::kGuestSession)),
      waiting_for_browser_(false) {
  BrowserList::AddObserver(this);
  notification_registrar_.Add(this, NotificationType::APP_EXITING,
      NotificationService::AllSources());
}
"
80782,,Remote,Not required,Partial,CVE-2018-13006,https://www.cvedetails.com/cve/CVE-2018-13006/,CWE-125,Low,Partial,Partial,,2018-06-29,7.5,An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,2019-03-29,,0,https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86,bceb03fd2be95097a7b409ea59914f332fb6bc86,fixed 2 possible heap overflows (inc. #1088),0,src/isomedia/box_dump.c,"{""sha"": ""0296626078712cd249ae511d4e704e6d8e26299b"", ""filename"": ""include/gpac/internal/isomedia_dev.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/include/gpac/internal/isomedia_dev.h"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/include/gpac/internal/isomedia_dev.h"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/include/gpac/internal/isomedia_dev.h?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -3710,7 +3710,7 @@ GF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *\n \t\tchar __ptype[5];\\\n \t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n \t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[iso file] extra box %s found in %s, deleting\\n\"", gf_4cc_to_str(__abox->type), __ptype)); \\\n-\t\tgf_isom_box_del(a);\\\n+\t\tgf_isom_box_del(__abox);\\\n \t\treturn GF_OK;\\\n \t}\n ""}<_**next**_>{""sha"": ""0f5b40f7fdc7874383638968abacc141ca0efcc3"", ""filename"": ""src/isomedia/box_code_base.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_code_base.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_code_base.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/isomedia/box_code_base.c?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -632,7 +632,7 @@ GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n \n \t//then get the break\n \ti = 0;\n-\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n+\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n \t\ti++;\n \t}\n \t//check the data is consistent""}<_**next**_>{""sha"": ""c77847928bd9abb73a631eb2f7c24500c77a9c3d"", ""filename"": ""src/isomedia/box_dump.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_dump.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_dump.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/isomedia/box_dump.c?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -484,7 +484,7 @@ GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \""HandlerBox\"", trace);\n-\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n+\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {\n \t\tfprintf(trace, \""hdlrType=\\\""%s\\\"" Name=\\\""%s\\\"" \"", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \""hdlrType=\\\""%s\\\"" Name=\\\""%s\\\"" \"", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n@@ -4157,9 +4157,9 @@ static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n \t\tfprintf(trace, \"" maxPicWidth=\\\""%u\\\"" maxPicHeight=\\\""%u\\\""\"", op->maxPicWidth, op->maxPicHeight);\n \t\tfprintf(trace, \"" maxChromaFormat=\\\""%u\\\"" maxBitDepth=\\\""%u\\\""\"", op->maxChromaFormat, op->maxBitDepth);\n \t\tfprintf(trace, \"" frame_rate_info_flag=\\\""%u\\\"" bit_rate_info_flag=\\\""%u\\\""\"", op->frame_rate_info_flag, op->bit_rate_info_flag);\n-\t\tif (op->frame_rate_info_flag) \n+\t\tif (op->frame_rate_info_flag)\n \t\t\tfprintf(trace, \"" avgFrameRate=\\\""%u\\\"" constantFrameRate=\\\""%u\\\""\"", op->avgFrameRate, op->constantFrameRate);\n-\t\tif (op->bit_rate_info_flag) \n+\t\tif (op->bit_rate_info_flag)\n \t\t\tfprintf(trace, \"" maxBitRate=\\\""%u\\\"" avgBitRate=\\\""%u\\\""\"", op->maxBitRate, op->avgBitRate);\n \t\tfprintf(trace, \""/>\\n\"");\n \t}\n@@ -4261,14 +4261,14 @@ static void nalm_dump(FILE * trace, char *data, u32 data_size)\n \t\tfprintf(trace, \""</NALUMap>\\n\"");\n \t\treturn;\n \t}\n-\t\n+\n \tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n \tgf_bs_read_int(bs, 6);\n \tlarge_size = gf_bs_read_int(bs, 1);\n \trle = gf_bs_read_int(bs, 1);\n \tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n \tfprintf(trace, \""<NALUMap rle=\\\""%d\\\"" large_size=\\\""%d\\\"">\\n\"", rle, large_size);\n-\t\n+\n \twhile (entry_count) {\n \t\tu32 ID;\n \t\tfprintf(trace, \""<NALUMapEntry \"");\n@@ -4338,7 +4338,7 @@ GF_Err sgpd_dump(GF_Box *a, FILE * trace)\n \t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n \t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n-\t\t\t\n+\n \t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n \t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n@@ -4507,7 +4507,7 @@ GF_Err tenc_dump(GF_Box *a, FILE * trace)\n \t\tfprintf(trace, \""\\\""  KID=\\\""\"");\n \t}\n \tdump_data_hex(trace, (char *) ptr->KID, 16);\n-\tif (ptr->version) \n+\tif (ptr->version)\n \t\tfprintf(trace, \""\\\"" crypt_byte_block=\\\""%d\\\"" skip_byte_block=\\\""%d\"", ptr->crypt_byte_block, ptr->skip_byte_block);\n \tfprintf(trace, \""\\\"">\\n\"");\n \tgf_isom_box_dump_done(\""TrackEncryptionBox\"", a, trace);""}","static void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)
{
	u32 i, count;
	if (!ptr) {
		fprintf(trace, ""<LayerInformation num_layers=\""\"">\n"");
		fprintf(trace, ""<LayerInfoItem layer_id=\""\"" min_temporalId=\""\"" max_temporalId=\""\"" sub_layer_presence_flags=\""\""/>\n"");
		fprintf(trace, ""</LayerInformation>\n"");
		return;
	}

	count = gf_list_count(ptr->num_layers_in_track);
	fprintf(trace, ""<LayerInformation num_layers=\""%d\"">\n"", count );
	for (i = 0; i < count; i++) {
		LHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);
		fprintf(trace, ""<LayerInfoItem layer_id=\""%d\"" min_temporalId=\""%d\"" max_temporalId=\""%d\"" sub_layer_presence_flags=\""%d\""/>\n"", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);
	}
	fprintf(trace, ""</LayerInformation>\n"");
	return;
}
","static void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)
{
	u32 i, count;
	if (!ptr) {
		fprintf(trace, ""<LayerInformation num_layers=\""\"">\n"");
		fprintf(trace, ""<LayerInfoItem layer_id=\""\"" min_temporalId=\""\"" max_temporalId=\""\"" sub_layer_presence_flags=\""\""/>\n"");
		fprintf(trace, ""</LayerInformation>\n"");
		return;
	}

	count = gf_list_count(ptr->num_layers_in_track);
	fprintf(trace, ""<LayerInformation num_layers=\""%d\"">\n"", count );
	for (i = 0; i < count; i++) {
		LHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);
		fprintf(trace, ""<LayerInfoItem layer_id=\""%d\"" min_temporalId=\""%d\"" max_temporalId=\""%d\"" sub_layer_presence_flags=\""%d\""/>\n"", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);
	}
	fprintf(trace, ""</LayerInformation>\n"");
	return;
}
",C,,,,"@@ -484,7 +484,7 @@ GF_Err hdlr_dump(GF_Box *a, FILE * trace)
 {
 	GF_HandlerBox *p = (GF_HandlerBox *)a;
 	gf_isom_box_dump_start(a, ""HandlerBox"", trace);
-	if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {
+	if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {
 		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);
 	} else {
 		fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8);
@@ -4157,9 +4157,9 @@ static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)
 		fprintf(trace, "" maxPicWidth=\""%u\"" maxPicHeight=\""%u\"""", op->maxPicWidth, op->maxPicHeight);
 		fprintf(trace, "" maxChromaFormat=\""%u\"" maxBitDepth=\""%u\"""", op->maxChromaFormat, op->maxBitDepth);
 		fprintf(trace, "" frame_rate_info_flag=\""%u\"" bit_rate_info_flag=\""%u\"""", op->frame_rate_info_flag, op->bit_rate_info_flag);
-		if (op->frame_rate_info_flag) 
+		if (op->frame_rate_info_flag)
 			fprintf(trace, "" avgFrameRate=\""%u\"" constantFrameRate=\""%u\"""", op->avgFrameRate, op->constantFrameRate);
-		if (op->bit_rate_info_flag) 
+		if (op->bit_rate_info_flag)
 			fprintf(trace, "" maxBitRate=\""%u\"" avgBitRate=\""%u\"""", op->maxBitRate, op->avgBitRate);
 		fprintf(trace, ""/>\n"");
 	}
@@ -4261,14 +4261,14 @@ static void nalm_dump(FILE * trace, char *data, u32 data_size)
 		fprintf(trace, ""</NALUMap>\n"");
 		return;
 	}
-	
+
 	bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
 	gf_bs_read_int(bs, 6);
 	large_size = gf_bs_read_int(bs, 1);
 	rle = gf_bs_read_int(bs, 1);
 	entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
 	fprintf(trace, ""<NALUMap rle=\""%d\"" large_size=\""%d\"">\n"", rle, large_size);
-	
+
 	while (entry_count) {
 		u32 ID;
 		fprintf(trace, ""<NALUMapEntry "");
@@ -4338,7 +4338,7 @@ GF_Err sgpd_dump(GF_Box *a, FILE * trace)
 		case GF_ISOM_SAMPLE_GROUP_TRIF:
 			trif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
 			break;
-			
+
 		case GF_ISOM_SAMPLE_GROUP_NALM:
 			nalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
 			break;
@@ -4507,7 +4507,7 @@ GF_Err tenc_dump(GF_Box *a, FILE * trace)
 		fprintf(trace, ""\""  KID=\"""");
 	}
 	dump_data_hex(trace, (char *) ptr->KID, 16);
-	if (ptr->version) 
+	if (ptr->version)
 		fprintf(trace, ""\"" crypt_byte_block=\""%d\"" skip_byte_block=\""%d"", ptr->crypt_byte_block, ptr->skip_byte_block);
 	fprintf(trace, ""\"">\n"");
 	gf_isom_box_dump_done(""TrackEncryptionBox"", a, trace);",gpac,bceb03fd2be95097a7b409ea59914f332fb6bc86,2ce4dcf583601a23ce328dfa44f9c57fe8ea6156,0,"static void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)
{
	u32 i, count;
	if (!ptr) {
		fprintf(trace, ""<LayerInformation num_layers=\""\"">\n"");
		fprintf(trace, ""<LayerInfoItem layer_id=\""\"" min_temporalId=\""\"" max_temporalId=\""\"" sub_layer_presence_flags=\""\""/>\n"");
		fprintf(trace, ""</LayerInformation>\n"");
		return;
	}

	count = gf_list_count(ptr->num_layers_in_track);
	fprintf(trace, ""<LayerInformation num_layers=\""%d\"">\n"", count );
	for (i = 0; i < count; i++) {
		LHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);
		fprintf(trace, ""<LayerInfoItem layer_id=\""%d\"" min_temporalId=\""%d\"" max_temporalId=\""%d\"" sub_layer_presence_flags=\""%d\""/>\n"", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);
	}
	fprintf(trace, ""</LayerInformation>\n"");
	return;
}
"
171537,,Remote,Not required,Complete,CVE-2016-3870,https://www.cvedetails.com/cve/CVE-2016-3870/,CWE-264,Medium,Complete,Complete,,2016-09-11,9.3,"omx/SimpleSoftOMXComponent.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not prevent input-port changes, which allows attackers to gain privileges via a crafted application, aka internal bug 29421804.",2017-08-12,+Priv ,0,https://android.googlesource.com/platform/frameworks/av/+/1e9801783770917728b7edbdeff3d0ec09c621ac,1e9801783770917728b7edbdeff3d0ec09c621ac,"omx: prevent input port enable/disable for software codecs

Bug: 29421804
Change-Id: Iba1011e9af942a6dff7f659af769a51e3f5ba66f
",0,media/libstagefright/omx/SimpleSoftOMXComponent.cpp,"{""filename"": ""media/libstagefright/omx/SimpleSoftOMXComponent.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/frameworks/av/+/1e9801783770917728b7edbdeff3d0ec09c621ac/media/libstagefright/omx/SimpleSoftOMXComponent.cpp"", ""patch"": ""@@ -469,6 +469,13 @@\n\n     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);\n     CHECK(port->mDef.bEnabled == !enable);\n \n+    if (port->mDef.eDir != OMX_DirOutput) {\n+        ALOGE(\""Port enable/disable allowed only on output ports.\"");\n+        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);\n+        android_errorWriteLog(0x534e4554, \""29421804\"");\n+        return;\n+    }\n+\n     if (!enable) {\n         port->mDef.bEnabled = OMX_FALSE;\n         port->mTransition = PortInfo::DISABLING;\n""}","void SimpleSoftOMXComponent::onQueueFilled(OMX_U32 portIndex __unused) {
}
","void SimpleSoftOMXComponent::onQueueFilled(OMX_U32 portIndex __unused) {
}
",C,,,,"@@ -469,6 +469,13 @@

     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);
     CHECK(port->mDef.bEnabled == !enable);
 
+    if (port->mDef.eDir != OMX_DirOutput) {
+        ALOGE(""Port enable/disable allowed only on output ports."");
+        notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL);
+        android_errorWriteLog(0x534e4554, ""29421804"");
+        return;
+    }
+
     if (!enable) {
         port->mDef.bEnabled = OMX_FALSE;
         port->mTransition = PortInfo::DISABLING;
",Android,https://android.googlesource.com/platform/frameworks/av/+/1e9801783770917728b7edbdeff3d0ec09c621ac/,https://android.googlesource.com/platform/frameworks/av/+/1e9801783770917728b7edbdeff3d0ec09c621ac%5E/,0,"void SimpleSoftOMXComponent::onQueueFilled(OMX_U32 portIndex __unused) {
}
"
23517,,Local Network,Not required,Complete,CVE-2011-4131,https://www.cvedetails.com/cve/CVE-2011-4131/,CWE-189,High,,,,2012-05-17,4.6,"The NFSv4 implementation in the Linux kernel before 3.2.2 does not properly handle bitmap sizes in GETACL replies, which allows remote NFS servers to cause a denial of service (OOPS) by sending an excessive number of bitmap words.",2017-12-28,DoS ,0,https://github.com/torvalds/linux/commit/bf118a342f10dafe44b14451a1392c3254629a1f,bf118a342f10dafe44b14451a1392c3254629a1f,"NFSv4: include bitmap in nfsv4 get acl data

The NFSv4 bitmap size is unbounded: a server can return an arbitrary
sized bitmap in an FATTR4_WORD0_ACL request.  Replace using the
nfs4_fattr_bitmap_maxsz as a guess to the maximum bitmask returned by a server
with the inclusion of the bitmap (xdr length plus bitmasks) and the acl data
xdr length to the (cached) acl page data.

This is a general solution to commit e5012d1f ""NFSv4.1: update
nfs4_fattr_bitmap_maxsz"" and fixes hitting a BUG_ON in xdr_shrink_bufhead
when getting ACLs.

Fix a bug in decode_getacl that returned -EINVAL on ACLs > page when getxattr
was called with a NULL buffer, preventing ACL > PAGE_SIZE from being retrieved.

Cc: stable@kernel.org
Signed-off-by: Andy Adamson <andros@netapp.com>
Signed-off-by: Trond Myklebust <Trond.Myklebust@netapp.com>",0,net/sunrpc/xdr.c,"{""sha"": ""3b1080118452ba8d3b5fc860d9d99db8b900d8ad"", ""filename"": ""fs/nfs/nfs4proc.c"", ""status"": ""modified"", ""additions"": 57, ""deletions"": 39, ""changes"": 96, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4proc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4proc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/nfs4proc.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -3426,19 +3426,6 @@ static inline int nfs4_server_supports_acls(struct nfs_server *server)\n  */\n #define NFS4ACL_MAXPAGES (XATTR_SIZE_MAX >> PAGE_CACHE_SHIFT)\n \n-static void buf_to_pages(const void *buf, size_t buflen,\n-\t\tstruct page **pages, unsigned int *pgbase)\n-{\n-\tconst void *p = buf;\n-\n-\t*pgbase = offset_in_page(buf);\n-\tp -= *pgbase;\n-\twhile (p < buf + buflen) {\n-\t\t*(pages++) = virt_to_page(p);\n-\t\tp += PAGE_CACHE_SIZE;\n-\t}\n-}\n-\n static int buf_to_pages_noslab(const void *buf, size_t buflen,\n \t\tstruct page **pages, unsigned int *pgbase)\n {\n@@ -3535,9 +3522,19 @@ static void nfs4_write_cached_acl(struct inode *inode, const char *buf, size_t a\n \tnfs4_set_cached_acl(inode, acl);\n }\n \n+/*\n+ * The getxattr API returns the required buffer length when called with a\n+ * NULL buf. The NFSv4 acl tool then calls getxattr again after allocating\n+ * the required buf.  On a NULL buf, we send a page of data to the server\n+ * guessing that the ACL request can be serviced by a page. If so, we cache\n+ * up to the page of ACL data, and the 2nd call to getxattr is serviced by\n+ * the cache. If not so, we throw away the page, and cache the required\n+ * length. The next getxattr call will then produce another round trip to\n+ * the server, this time with the input buf of the required size.\n+ */\n static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n {\n-\tstruct page *pages[NFS4ACL_MAXPAGES];\n+\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n \tstruct nfs_getaclargs args = {\n \t\t.fh = NFS_FH(inode),\n \t\t.acl_pages = pages,\n@@ -3552,41 +3549,60 @@ static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu\n \t\t.rpc_argp = &args,\n \t\t.rpc_resp = &res,\n \t};\n-\tstruct page *localpage = NULL;\n-\tint ret;\n+\tint ret = -ENOMEM, npages, i, acl_len = 0;\n \n-\tif (buflen < PAGE_SIZE) {\n-\t\t/* As long as we're doing a round trip to the server anyway,\n-\t\t * let's be prepared for a page of acl data. */\n-\t\tlocalpage = alloc_page(GFP_KERNEL);\n-\t\tresp_buf = page_address(localpage);\n-\t\tif (localpage == NULL)\n-\t\t\treturn -ENOMEM;\n-\t\targs.acl_pages[0] = localpage;\n-\t\targs.acl_pgbase = 0;\n-\t\targs.acl_len = PAGE_SIZE;\n-\t} else {\n-\t\tresp_buf = buf;\n-\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n+\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n+\t/* As long as we're doing a round trip to the server anyway,\n+\t * let's be prepared for a page of acl data. */\n+\tif (npages == 0)\n+\t\tnpages = 1;\n+\n+\tfor (i = 0; i < npages; i++) {\n+\t\tpages[i] = alloc_page(GFP_KERNEL);\n+\t\tif (!pages[i])\n+\t\t\tgoto out_free;\n+\t}\n+\tif (npages > 1) {\n+\t\t/* for decoding across pages */\n+\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n+\t\tif (!args.acl_scratch)\n+\t\t\tgoto out_free;\n \t}\n-\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n+\targs.acl_len = npages * PAGE_SIZE;\n+\targs.acl_pgbase = 0;\n+\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n+\t * the page we send as a guess */\n+\tif (buf == NULL)\n+\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n+\tresp_buf = page_address(pages[0]);\n+\n+\tdprintk(\""%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\"",\n+\t\t__func__, buf, buflen, npages, args.acl_len);\n+\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n+\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n \tif (ret)\n \t\tgoto out_free;\n-\tif (res.acl_len > args.acl_len)\n-\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n+\n+\tacl_len = res.acl_len - res.acl_data_offset;\n+\tif (acl_len > args.acl_len)\n+\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n \telse\n-\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n+\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n+\t\t\t\t      acl_len);\n \tif (buf) {\n \t\tret = -ERANGE;\n-\t\tif (res.acl_len > buflen)\n+\t\tif (acl_len > buflen)\n \t\t\tgoto out_free;\n-\t\tif (localpage)\n-\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n+\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n+\t\t\t\tres.acl_len);\n \t}\n-\tret = res.acl_len;\n+\tret = acl_len;\n out_free:\n-\tif (localpage)\n-\t\t__free_page(localpage);\n+\tfor (i = 0; i < npages; i++)\n+\t\tif (pages[i])\n+\t\t\t__free_page(pages[i]);\n+\tif (args.acl_scratch)\n+\t\t__free_page(args.acl_scratch);\n \treturn ret;\n }\n \n@@ -3617,6 +3633,8 @@ static ssize_t nfs4_proc_get_acl(struct inode *inode, void *buf, size_t buflen)\n \t\tnfs_zap_acl_cache(inode);\n \tret = nfs4_read_cached_acl(inode, buf, buflen);\n \tif (ret != -ENOENT)\n+\t\t/* -ENOENT is returned if there is no ACL or if there is an ACL\n+\t\t * but no cached acl data, just the acl length */\n \t\treturn ret;\n \treturn nfs4_get_acl_uncached(inode, buf, buflen);\n }""}<_**next**_>{""sha"": ""dcaf69309d8eea153166084f2895c9a77a81564e"", ""filename"": ""fs/nfs/nfs4xdr.c"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 8, ""changes"": 31, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4xdr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/fs/nfs/nfs4xdr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/nfs/nfs4xdr.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -2517,11 +2517,13 @@ static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,\n \tencode_compound_hdr(xdr, req, &hdr);\n \tencode_sequence(xdr, &args->seq_args, &hdr);\n \tencode_putfh(xdr, args->fh, &hdr);\n-\treplen = hdr.replen + op_decode_hdr_maxsz + nfs4_fattr_bitmap_maxsz + 1;\n+\treplen = hdr.replen + op_decode_hdr_maxsz + 1;\n \tencode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);\n \n \txdr_inline_pages(&req->rq_rcv_buf, replen << 2,\n \t\targs->acl_pages, args->acl_pgbase, args->acl_len);\n+\txdr_set_scratch_buffer(xdr, page_address(args->acl_scratch), PAGE_SIZE);\n+\n \tencode_nops(&hdr);\n }\n \n@@ -4957,17 +4959,18 @@ decode_restorefh(struct xdr_stream *xdr)\n }\n \n static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n-\t\tsize_t *acl_len)\n+\t\t\t struct nfs_getaclres *res)\n {\n-\t__be32 *savep;\n+\t__be32 *savep, *bm_p;\n \tuint32_t attrlen,\n \t\t bitmap[3] = {0};\n \tstruct kvec *iov = req->rq_rcv_buf.head;\n \tint status;\n \n-\t*acl_len = 0;\n+\tres->acl_len = 0;\n \tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n \t\tgoto out;\n+\tbm_p = xdr->p;\n \tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n \t\tgoto out;\n \tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n@@ -4979,18 +4982,30 @@ static int decode_getacl(struct xdr_stream *xdr, struct rpc_rqst *req,\n \t\tsize_t hdrlen;\n \t\tu32 recvd;\n \n+\t\t/* The bitmap (xdr len + bitmaps) and the attr xdr len words\n+\t\t * are stored with the acl data to handle the problem of\n+\t\t * variable length bitmaps.*/\n+\t\txdr->p = bm_p;\n+\t\tres->acl_data_offset = be32_to_cpup(bm_p) + 2;\n+\t\tres->acl_data_offset <<= 2;\n+\n \t\t/* We ignore &savep and don't do consistency checks on\n \t\t * the attr length.  Let userspace figure it out.... */\n \t\thdrlen = (u8 *)xdr->p - (u8 *)iov->iov_base;\n+\t\tattrlen += res->acl_data_offset;\n \t\trecvd = req->rq_rcv_buf.len - hdrlen;\n \t\tif (attrlen > recvd) {\n-\t\t\tdprintk(\""NFS: server cheating in getattr\""\n-\t\t\t\t\t\"" acl reply: attrlen %u > recvd %u\\n\"",\n+\t\t\tif (res->acl_flags & NFS4_ACL_LEN_REQUEST) {\n+\t\t\t\t/* getxattr interface called with a NULL buf */\n+\t\t\t\tres->acl_len = attrlen;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tdprintk(\""NFS: acl reply: attrlen %u > recvd %u\\n\"",\n \t\t\t\t\tattrlen, recvd);\n \t\t\treturn -EINVAL;\n \t\t}\n \t\txdr_read_pages(xdr, attrlen);\n-\t\t*acl_len = attrlen;\n+\t\tres->acl_len = attrlen;\n \t} else\n \t\tstatus = -EOPNOTSUPP;\n \n@@ -6028,7 +6043,7 @@ nfs4_xdr_dec_getacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n \tstatus = decode_putfh(xdr);\n \tif (status)\n \t\tgoto out;\n-\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n+\tstatus = decode_getacl(xdr, rqstp, res);\n \n out:\n \treturn status;""}<_**next**_>{""sha"": ""6c898afe60951dbef8175e3c8cfe1be8244c1d37"", ""filename"": ""include/linux/nfs_xdr.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/nfs_xdr.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/nfs_xdr.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/nfs_xdr.h?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -602,11 +602,16 @@ struct nfs_getaclargs {\n \tsize_t\t\t\t\tacl_len;\n \tunsigned int\t\t\tacl_pgbase;\n \tstruct page **\t\t\tacl_pages;\n+\tstruct page *\t\t\tacl_scratch;\n \tstruct nfs4_sequence_args \tseq_args;\n };\n \n+/* getxattr ACL interface flags */\n+#define NFS4_ACL_LEN_REQUEST\t0x0001\t/* zero length getxattr buffer */\n struct nfs_getaclres {\n \tsize_t\t\t\t\tacl_len;\n+\tsize_t\t\t\t\tacl_data_offset;\n+\tint\t\t\t\tacl_flags;\n \tstruct nfs4_sequence_res\tseq_res;\n };\n ""}<_**next**_>{""sha"": ""af70af3335461ee587d23a8567a9abdb9cc23eb9"", ""filename"": ""include/linux/sunrpc/xdr.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/sunrpc/xdr.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/include/linux/sunrpc/xdr.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sunrpc/xdr.h?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -191,6 +191,8 @@ extern int xdr_decode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n extern int xdr_encode_array2(struct xdr_buf *buf, unsigned int base,\n \t\t\t     struct xdr_array2_desc *desc);\n+extern void _copy_from_pages(char *p, struct page **pages, size_t pgbase,\n+\t\t\t     size_t len);\n \n /*\n  * Provide some simple tools for XDR buffer overflow-checking etc.""}<_**next**_>{""sha"": ""593f4c605305d7b0a51465ae42b09a7eaa6fcadd"", ""filename"": ""net/sunrpc/xdr.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/bf118a342f10dafe44b14451a1392c3254629a1f/net/sunrpc/xdr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/bf118a342f10dafe44b14451a1392c3254629a1f/net/sunrpc/xdr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sunrpc/xdr.c?ref=bf118a342f10dafe44b14451a1392c3254629a1f"", ""patch"": ""@@ -296,7 +296,7 @@ _copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)\n  * Copies data into an arbitrary memory location from an array of pages\n  * The copy is assumed to be non-overlapping.\n  */\n-static void\n+void\n _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n {\n \tstruct page **pgfrom;\n@@ -324,6 +324,7 @@ _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)\n \n \t} while ((len -= copy) != 0);\n }\n+EXPORT_SYMBOL_GPL(_copy_from_pages);\n \n /*\n  * xdr_shrink_bufhead""}","xdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)
{
	unsigned int	len;

	if ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)
		return NULL;
	obj->len  = len;
	obj->data = (u8 *) p;
	return p + XDR_QUADLEN(len);
}
","xdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)
{
	unsigned int	len;

	if ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)
		return NULL;
	obj->len  = len;
	obj->data = (u8 *) p;
	return p + XDR_QUADLEN(len);
}
",C,,,,"@@ -296,7 +296,7 @@ _copy_to_pages(struct page **pages, size_t pgbase, const char *p, size_t len)
  * Copies data into an arbitrary memory location from an array of pages
  * The copy is assumed to be non-overlapping.
  */
-static void
+void
 _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)
 {
 	struct page **pgfrom;
@@ -324,6 +324,7 @@ _copy_from_pages(char *p, struct page **pages, size_t pgbase, size_t len)
 
 	} while ((len -= copy) != 0);
 }
+EXPORT_SYMBOL_GPL(_copy_from_pages);
 
 /*
  * xdr_shrink_bufhead",linux,bf118a342f10dafe44b14451a1392c3254629a1f,3476f114addb7b96912840a234702f660a1f460b,0,"xdr_decode_netobj(__be32 *p, struct xdr_netobj *obj)
{
	unsigned int	len;

	if ((len = be32_to_cpu(*p++)) > XDR_MAX_NETOBJ)
		return NULL;
	obj->len  = len;
	obj->data = (u8 *) p;
	return p + XDR_QUADLEN(len);
}
"
109833,,Remote,Not required,Partial,CVE-2012-5136,https://www.cvedetails.com/cve/CVE-2012-5136/,CWE-20,Medium,Partial,Partial,,2012-11-27,6.8,"Google Chrome before 23.0.1271.91 does not properly perform a cast of an unspecified variable during handling of the INPUT element, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted HTML document.",2018-10-30,DoS ,0,https://github.com/chromium/chromium/commit/401d30ef93030afbf7e81e53a11b68fc36194502,401d30ef93030afbf7e81e53a11b68fc36194502,"Refactoring: Move m_mayDisplaySeamlesslyWithParent down to Document

The member is used only in Document, thus no reason to
stay in SecurityContext.

TEST=none
BUG=none
R=haraken@chromium.org, abarth, haraken, hayato

Review URL: https://codereview.chromium.org/27615003

git-svn-id: svn://svn.chromium.org/blink/trunk@159829 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/dom/Document.cpp,"{""sha"": ""ee239f82b1104c86c89055ff57b39404b17ac891"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=401d30ef93030afbf7e81e53a11b68fc36194502"", ""patch"": ""@@ -434,6 +434,7 @@ Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC\n     , m_sawElementsInKnownNamespaces(false)\n     , m_isSrcdocDocument(false)\n     , m_isMobileDocument(false)\n+    , m_mayDisplaySeamlesslyWithParent(false)\n     , m_renderer(0)\n     , m_eventQueue(DocumentEventQueue::create(this))\n     , m_weakFactory(this)""}<_**next**_>{""sha"": ""b78736b969d831877ee15869124ac0ce38457de8"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=401d30ef93030afbf7e81e53a11b68fc36194502"", ""patch"": ""@@ -1320,6 +1320,9 @@ class Document : public ContainerNode, public TreeScope, public ExecutionContext\n     bool m_sawElementsInKnownNamespaces;\n     bool m_isSrcdocDocument;\n     bool m_isMobileDocument;\n+    // Set in Document::initSecurityContext() at Document creation, per:\n+    // http://www.whatwg.org/specs/web-apps/current-work/#attr-iframe-seamless\n+    bool m_mayDisplaySeamlesslyWithParent;\n \n     RenderObject* m_renderer;\n     RefPtr<DocumentEventQueue> m_eventQueue;""}<_**next**_>{""sha"": ""305654330b2e73ac85adeae74f42defd34e1f4fb"", ""filename"": ""third_party/WebKit/Source/core/dom/SecurityContext.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 2, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/SecurityContext.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/SecurityContext.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/SecurityContext.cpp?ref=401d30ef93030afbf7e81e53a11b68fc36194502"", ""patch"": ""@@ -35,8 +35,7 @@\n namespace WebCore {\n \n SecurityContext::SecurityContext()\n-    : m_mayDisplaySeamlesslyWithParent(false)\n-    , m_haveInitializedSecurityOrigin(false)\n+    : m_haveInitializedSecurityOrigin(false)\n     , m_sandboxFlags(SandboxNone)\n {\n }""}<_**next**_>{""sha"": ""61f3fcc6f24f525ae9e77ef46ef1f1b7d1891f21"", ""filename"": ""third_party/WebKit/Source/core/dom/SecurityContext.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/SecurityContext.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/401d30ef93030afbf7e81e53a11b68fc36194502/third_party/WebKit/Source/core/dom/SecurityContext.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/SecurityContext.h?ref=401d30ef93030afbf7e81e53a11b68fc36194502"", ""patch"": ""@@ -84,10 +84,6 @@ class SecurityContext {\n     void didFailToInitializeSecurityOrigin() { m_haveInitializedSecurityOrigin = false; }\n     bool haveInitializedSecurityOrigin() const { return m_haveInitializedSecurityOrigin; }\n \n-    // Set in Document::initSecurityContext() at Document creation, per:\n-    // http://www.whatwg.org/specs/web-apps/current-work/#attr-iframe-seamless\n-    bool m_mayDisplaySeamlesslyWithParent;\n-\n private:\n     bool m_haveInitializedSecurityOrigin;\n     SandboxFlags m_sandboxFlags;""}","void Document::setXMLVersion(const String& version, ExceptionState& es)
{
    if (!implementation()->hasFeature(""XML"", String())) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    if (!XMLDocumentParser::supportsXMLVersion(version)) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    m_xmlVersion = version;
}
","void Document::setXMLVersion(const String& version, ExceptionState& es)
{
    if (!implementation()->hasFeature(""XML"", String())) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    if (!XMLDocumentParser::supportsXMLVersion(version)) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    m_xmlVersion = version;
}
",C,,,,"@@ -434,6 +434,7 @@ Document::Document(const DocumentInit& initializer, DocumentClassFlags documentC
     , m_sawElementsInKnownNamespaces(false)
     , m_isSrcdocDocument(false)
     , m_isMobileDocument(false)
+    , m_mayDisplaySeamlesslyWithParent(false)
     , m_renderer(0)
     , m_eventQueue(DocumentEventQueue::create(this))
     , m_weakFactory(this)",Chrome,401d30ef93030afbf7e81e53a11b68fc36194502,2d2e2574c4fe21c6cefe05de73cf23ffa2aff79b,0,"void Document::setXMLVersion(const String& version, ExceptionState& es)
{
    if (!implementation()->hasFeature(""XML"", String())) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    if (!XMLDocumentParser::supportsXMLVersion(version)) {
        es.throwUninformativeAndGenericDOMException(NotSupportedError);
        return;
    }

    m_xmlVersion = version;
}
"
73603,,Remote,Not required,Partial,CVE-2016-7514,https://www.cvedetails.com/cve/CVE-2016-7514/,CWE-125,Medium,,,,2017-04-20,4.3,The ReadPSDChannelPixels function in coders/psd.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PSD file.,2017-05-09,DoS ,0,https://github.com/ImageMagick/ImageMagick/commit/e14fd0a2801f73bdc123baf4fbab97dec55919eb,e14fd0a2801f73bdc123baf4fbab97dec55919eb,Added missing call to ConstrainColormapIndex.,0,coders/psd.c,"{""sha"": ""5a5c63380715088a33305e0c59f5e9f356bf6429"", ""filename"": ""coders/psd.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/ImageMagick/ImageMagick/blob/e14fd0a2801f73bdc123baf4fbab97dec55919eb/coders/psd.c"", ""raw_url"": ""https://github.com/ImageMagick/ImageMagick/raw/e14fd0a2801f73bdc123baf4fbab97dec55919eb/coders/psd.c"", ""contents_url"": ""https://api.github.com/repos/ImageMagick/ImageMagick/contents/coders/psd.c?ref=e14fd0a2801f73bdc123baf4fbab97dec55919eb"", ""patch"": ""@@ -835,7 +835,8 @@ static MagickBooleanType ReadPSDChannelPixels(Image *image,\n                   SetPixelIndex(image,(((unsigned char) pixel) &\n                     (0x01 << (7-bit))) != 0 ? 0 : 255,q);\n                   SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n-                    GetPixelIndex(image,q),q);\n+                    ConstrainColormapIndex(image,GetPixelIndex(image,q),\n+                      exception),q);\n                   q+=GetPixelChannels(image);\n                   x++;\n                 }""}","static ssize_t DecodePSDPixels(const size_t number_compact_pixels,
  const unsigned char *compact_pixels,const ssize_t depth,
  const size_t number_pixels,unsigned char *pixels)
{
#define CheckNumberCompactPixels \
  if (packets == 0) \
    return(i); \
  packets--

#define CheckNumberPixels(count) \
  if (((ssize_t) i + count) > (ssize_t) number_pixels) \
    return(i); \
  i+=count

  int
    pixel;

  register ssize_t
    i,
    j;

  size_t
    length;

  ssize_t
    packets;

  packets=(ssize_t) number_compact_pixels;
  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )
  {
    packets--;
    length=(size_t) (*compact_pixels++);
    if (length == 128)
      continue;
    if (length > 128)
      {
        length=256-length+1;
        CheckNumberCompactPixels;
        pixel=(*compact_pixels++);
        for (j=0; j < (ssize_t) length; j++)
        {
          switch (depth)
          {
            case 1:
            {
              CheckNumberPixels(8);
              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;
              break;
            }
            case 2:
            {
              CheckNumberPixels(4);
              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);
              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);
              break;
            }
            case 4:
            {
              CheckNumberPixels(2);
              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);
              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);
              break;
            }
            default:
            {
              CheckNumberPixels(1);
              *pixels++=(unsigned char) pixel;
              break;
            }
          }
        }
        continue;
      }
    length++;
    for (j=0; j < (ssize_t) length; j++)
    {
      switch (depth)
      {
        case 1:
        {
          CheckNumberPixels(8);
          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;
          break;
        }
        case 2:
        {
          CheckNumberPixels(4);
          *pixels++=(*compact_pixels >> 6) & 0x03;
          *pixels++=(*compact_pixels >> 4) & 0x03;
          *pixels++=(*compact_pixels >> 2) & 0x03;
          *pixels++=(*compact_pixels & 0x03) & 0x03;
          break;
        }
        case 4:
        {
          CheckNumberPixels(2);
          *pixels++=(*compact_pixels >> 4) & 0xff;
          *pixels++=(*compact_pixels & 0x0f) & 0xff;
          break;
        }
        default:
        {
          CheckNumberPixels(1);
          *pixels++=(*compact_pixels);
          break;
        }
      }
      CheckNumberCompactPixels;
      compact_pixels++;
    }
  }
  return(i);
}
","static ssize_t DecodePSDPixels(const size_t number_compact_pixels,
  const unsigned char *compact_pixels,const ssize_t depth,
  const size_t number_pixels,unsigned char *pixels)
{
#define CheckNumberCompactPixels \
  if (packets == 0) \
    return(i); \
  packets--

#define CheckNumberPixels(count) \
  if (((ssize_t) i + count) > (ssize_t) number_pixels) \
    return(i); \
  i+=count

  int
    pixel;

  register ssize_t
    i,
    j;

  size_t
    length;

  ssize_t
    packets;

  packets=(ssize_t) number_compact_pixels;
  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )
  {
    packets--;
    length=(size_t) (*compact_pixels++);
    if (length == 128)
      continue;
    if (length > 128)
      {
        length=256-length+1;
        CheckNumberCompactPixels;
        pixel=(*compact_pixels++);
        for (j=0; j < (ssize_t) length; j++)
        {
          switch (depth)
          {
            case 1:
            {
              CheckNumberPixels(8);
              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;
              break;
            }
            case 2:
            {
              CheckNumberPixels(4);
              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);
              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);
              break;
            }
            case 4:
            {
              CheckNumberPixels(2);
              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);
              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);
              break;
            }
            default:
            {
              CheckNumberPixels(1);
              *pixels++=(unsigned char) pixel;
              break;
            }
          }
        }
        continue;
      }
    length++;
    for (j=0; j < (ssize_t) length; j++)
    {
      switch (depth)
      {
        case 1:
        {
          CheckNumberPixels(8);
          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;
          break;
        }
        case 2:
        {
          CheckNumberPixels(4);
          *pixels++=(*compact_pixels >> 6) & 0x03;
          *pixels++=(*compact_pixels >> 4) & 0x03;
          *pixels++=(*compact_pixels >> 2) & 0x03;
          *pixels++=(*compact_pixels & 0x03) & 0x03;
          break;
        }
        case 4:
        {
          CheckNumberPixels(2);
          *pixels++=(*compact_pixels >> 4) & 0xff;
          *pixels++=(*compact_pixels & 0x0f) & 0xff;
          break;
        }
        default:
        {
          CheckNumberPixels(1);
          *pixels++=(*compact_pixels);
          break;
        }
      }
      CheckNumberCompactPixels;
      compact_pixels++;
    }
  }
  return(i);
}
",C,,,,"@@ -835,7 +835,8 @@ static MagickBooleanType ReadPSDChannelPixels(Image *image,
                   SetPixelIndex(image,(((unsigned char) pixel) &
                     (0x01 << (7-bit))) != 0 ? 0 : 255,q);
                   SetPixelViaPixelInfo(image,image->colormap+(ssize_t)
-                    GetPixelIndex(image,q),q);
+                    ConstrainColormapIndex(image,GetPixelIndex(image,q),
+                      exception),q);
                   q+=GetPixelChannels(image);
                   x++;
                 }",ImageMagick,e14fd0a2801f73bdc123baf4fbab97dec55919eb,6f1879d498bcc5cce12fe0c5decb8dbc0f608e5d,0,"static ssize_t DecodePSDPixels(const size_t number_compact_pixels,
  const unsigned char *compact_pixels,const ssize_t depth,
  const size_t number_pixels,unsigned char *pixels)
{
#define CheckNumberCompactPixels \
  if (packets == 0) \
    return(i); \
  packets--

#define CheckNumberPixels(count) \
  if (((ssize_t) i + count) > (ssize_t) number_pixels) \
    return(i); \
  i+=count

  int
    pixel;

  register ssize_t
    i,
    j;

  size_t
    length;

  ssize_t
    packets;

  packets=(ssize_t) number_compact_pixels;
  for (i=0; (packets > 1) && (i < (ssize_t) number_pixels); )
  {
    packets--;
    length=(size_t) (*compact_pixels++);
    if (length == 128)
      continue;
    if (length > 128)
      {
        length=256-length+1;
        CheckNumberCompactPixels;
        pixel=(*compact_pixels++);
        for (j=0; j < (ssize_t) length; j++)
        {
          switch (depth)
          {
            case 1:
            {
              CheckNumberPixels(8);
              *pixels++=(pixel >> 7) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 6) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 5) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 4) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 3) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 2) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 1) & 0x01 ? 0U : 255U;
              *pixels++=(pixel >> 0) & 0x01 ? 0U : 255U;
              break;
            }
            case 2:
            {
              CheckNumberPixels(4);
              *pixels++=(unsigned char) ((pixel >> 6) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 4) & 0x03);
              *pixels++=(unsigned char) ((pixel >> 2) & 0x03);
              *pixels++=(unsigned char) ((pixel & 0x03) & 0x03);
              break;
            }
            case 4:
            {
              CheckNumberPixels(2);
              *pixels++=(unsigned char) ((pixel >> 4) & 0xff);
              *pixels++=(unsigned char) ((pixel & 0x0f) & 0xff);
              break;
            }
            default:
            {
              CheckNumberPixels(1);
              *pixels++=(unsigned char) pixel;
              break;
            }
          }
        }
        continue;
      }
    length++;
    for (j=0; j < (ssize_t) length; j++)
    {
      switch (depth)
      {
        case 1:
        {
          CheckNumberPixels(8);
          *pixels++=(*compact_pixels >> 7) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 6) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 5) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 4) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 3) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 2) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 1) & 0x01 ? 0U : 255U;
          *pixels++=(*compact_pixels >> 0) & 0x01 ? 0U : 255U;
          break;
        }
        case 2:
        {
          CheckNumberPixels(4);
          *pixels++=(*compact_pixels >> 6) & 0x03;
          *pixels++=(*compact_pixels >> 4) & 0x03;
          *pixels++=(*compact_pixels >> 2) & 0x03;
          *pixels++=(*compact_pixels & 0x03) & 0x03;
          break;
        }
        case 4:
        {
          CheckNumberPixels(2);
          *pixels++=(*compact_pixels >> 4) & 0xff;
          *pixels++=(*compact_pixels & 0x0f) & 0xff;
          break;
        }
        default:
        {
          CheckNumberPixels(1);
          *pixels++=(*compact_pixels);
          break;
        }
      }
      CheckNumberCompactPixels;
      compact_pixels++;
    }
  }
  return(i);
}
"
28365,,Local,Single system,Complete,CVE-2013-6432,https://www.cvedetails.com/cve/CVE-2013-6432/,,Low,,,,2013-12-09,4.6,"The ping_recvmsg function in net/ipv4/ping.c in the Linux kernel before 3.12.4 does not properly interact with read system calls on ping sockets, which allows local users to cause a denial of service (NULL pointer dereference and system crash) by leveraging unspecified privileges to execute a crafted application.",2014-03-05,DoS ,0,https://github.com/torvalds/linux/commit/cf970c002d270c36202bd5b9c2804d3097a52da0,cf970c002d270c36202bd5b9c2804d3097a52da0,"ping: prevent NULL pointer dereference on write to msg_name

A plain read() on a socket does set msg->msg_name to NULL. So check for
NULL pointer first.

Signed-off-by: Hannes Frederic Sowa <hannes@stressinduktion.org>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/ipv4/ping.c,"{""sha"": ""91bfe0437e7a0123416103b95b274f7cd89aed02"", ""filename"": ""net/ipv4/ping.c"", ""status"": ""modified"", ""additions"": 19, ""deletions"": 15, ""changes"": 34, ""blob_url"": ""https://github.com/torvalds/linux/blob/cf970c002d270c36202bd5b9c2804d3097a52da0/net/ipv4/ping.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/cf970c002d270c36202bd5b9c2804d3097a52da0/net/ipv4/ping.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/ipv4/ping.c?ref=cf970c002d270c36202bd5b9c2804d3097a52da0"", ""patch"": ""@@ -870,11 +870,13 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \tif (family == AF_INET) {\n \t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n \n-\t\tsin->sin_family = AF_INET;\n-\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n-\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n-\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n-\t\t*addr_len = sizeof(*sin);\n+\t\tif (sin) {\n+\t\t\tsin->sin_family = AF_INET;\n+\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n+\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n+\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n+\t\t\t*addr_len = sizeof(*sin);\n+\t\t}\n \n \t\tif (isk->cmsg_flags)\n \t\t\tip_cmsg_recv(msg, skb);\n@@ -886,16 +888,18 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n \t\tstruct sockaddr_in6 *sin6 =\n \t\t\t(struct sockaddr_in6 *)msg->msg_name;\n \n-\t\tsin6->sin6_family = AF_INET6;\n-\t\tsin6->sin6_port = 0;\n-\t\tsin6->sin6_addr = ip6->saddr;\n-\t\tsin6->sin6_flowinfo = 0;\n-\t\tif (np->sndflow)\n-\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n-\n-\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n-\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n-\t\t*addr_len = sizeof(*sin6);\n+\t\tif (sin6) {\n+\t\t\tsin6->sin6_family = AF_INET6;\n+\t\t\tsin6->sin6_port = 0;\n+\t\t\tsin6->sin6_addr = ip6->saddr;\n+\t\t\tsin6->sin6_flowinfo = 0;\n+\t\t\tif (np->sndflow)\n+\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n+\t\t\tsin6->sin6_scope_id =\n+\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n+\t\t\t\t\t\t    IP6CB(skb)->iif);\n+\t\t\t*addr_len = sizeof(*sin6);\n+\t\t}\n \n \t\tif (inet6_sk(sk)->rxopt.all)\n \t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);""}","static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
{
	struct sock *sk = ping_get_first(seq, 0);

	if (sk)
		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
			--pos;
	return pos ? NULL : sk;
}
","static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
{
	struct sock *sk = ping_get_first(seq, 0);

	if (sk)
		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
			--pos;
	return pos ? NULL : sk;
}
",C,,,,"@@ -870,11 +870,13 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 	if (family == AF_INET) {
 		struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
 
-		sin->sin_family = AF_INET;
-		sin->sin_port = 0 /* skb->h.uh->source */;
-		sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
-		memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
-		*addr_len = sizeof(*sin);
+		if (sin) {
+			sin->sin_family = AF_INET;
+			sin->sin_port = 0 /* skb->h.uh->source */;
+			sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
+			memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
+			*addr_len = sizeof(*sin);
+		}
 
 		if (isk->cmsg_flags)
 			ip_cmsg_recv(msg, skb);
@@ -886,16 +888,18 @@ int ping_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		struct sockaddr_in6 *sin6 =
 			(struct sockaddr_in6 *)msg->msg_name;
 
-		sin6->sin6_family = AF_INET6;
-		sin6->sin6_port = 0;
-		sin6->sin6_addr = ip6->saddr;
-		sin6->sin6_flowinfo = 0;
-		if (np->sndflow)
-			sin6->sin6_flowinfo = ip6_flowinfo(ip6);
-
-		sin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,
-							  IP6CB(skb)->iif);
-		*addr_len = sizeof(*sin6);
+		if (sin6) {
+			sin6->sin6_family = AF_INET6;
+			sin6->sin6_port = 0;
+			sin6->sin6_addr = ip6->saddr;
+			sin6->sin6_flowinfo = 0;
+			if (np->sndflow)
+				sin6->sin6_flowinfo = ip6_flowinfo(ip6);
+			sin6->sin6_scope_id =
+				ipv6_iface_scope_id(&sin6->sin6_addr,
+						    IP6CB(skb)->iif);
+			*addr_len = sizeof(*sin6);
+		}
 
 		if (inet6_sk(sk)->rxopt.all)
 			pingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);",linux,cf970c002d270c36202bd5b9c2804d3097a52da0,4861292f730d7c461758575e2557e285a1d4521e,0,"static struct sock *ping_get_idx(struct seq_file *seq, loff_t pos)
{
	struct sock *sk = ping_get_first(seq, 0);

	if (sk)
		while (pos && (sk = ping_get_next(seq, sk)) != NULL)
			--pos;
	return pos ? NULL : sk;
}
"
147129,,Remote,Not required,,CVE-2017-5118,https://www.cvedetails.com/cve/CVE-2017-5118/,CWE-732,Medium,,Partial,,2017-10-27,4.3,"Blink in Google Chrome prior to 61.0.3163.79 for Mac, Windows, and Linux, and 61.0.3163.81 for Android, failed to correctly propagate CSP restrictions to javascript scheme pages, which allowed a remote attacker to bypass content security policy via a crafted HTML page.",2019-10-02,Bypass ,0,https://github.com/chromium/chromium/commit/0ab2412a104d2f235d7b9fe19d30ef605a410832,0ab2412a104d2f235d7b9fe19d30ef605a410832,"Inherit CSP when we inherit the security origin

This prevents attacks that use main window navigation to get out of the
existing csp constraints such as the related bug

Bug: 747847
Change-Id: I1e57b50da17f65d38088205b0a3c7c49ef2ae4d8
Reviewed-on: https://chromium-review.googlesource.com/592027
Reviewed-by: Mike West <mkwst@chromium.org>
Commit-Queue: Andy Paicu <andypaicu@chromium.org>
Cr-Commit-Position: refs/heads/master@{#492333}",0,third_party/WebKit/Source/core/loader/DocumentLoader.cpp,"{""sha"": ""21c4fb33ce2d66db750d92a892e3871bd5d9b576"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""status"": ""added"", ""additions"": 16, ""deletions"": 0, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/javascript-url-navigation-inherits-csp.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,16 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = encodeURIComponent(\""javascript:'<iframe src=/content-security-policy/support/fail.js />'\"");\n+  var report_cookie_name = encodeURIComponent(\""javascript-url-navigation-inherits-csp\"");\n+  window.open(\""support/test_csp_self_window.sub.html?window_url=\"" + window_url + \""&report_cookie_name=\"" + report_cookie_name);\n+  setTimeout(function() {\n+    var s = document.createElement('script');\n+    s.async = true;\n+    s.defer = true;\n+    s.src = \""../support/checkReport.sub.js?reportField=violated-directive&reportValue=frame-src%20%27none%27\"";\n+    document.body.appendChild(s);\n+  }, 2000);\n+</script>""}<_**next**_>{""sha"": ""ab0f8f82e3951a412824d066f670af17377dcec5"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""status"": ""added"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,8 @@\n+<!DOCTYPE html>\n+<script src=\""/resources/testharness.js\""></script>\n+<script src=\""/resources/testharnessreport.js\""></script>\n+\n+<script>\n+  var window_url = decodeURIComponent(\""{{GET[window_url]}}\"").replace('&lt;', '<').replace('&gt;', '>');\n+  window.open(window_url, \""_self\"");\n+</script>""}<_**next**_>{""sha"": ""dd418ec7648ba3f5603b0e070460ac171b8bc4d4"", ""filename"": ""third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""status"": ""added"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/external/wpt/content-security-policy/navigation/support/test_csp_self_window.sub.html.sub.headers?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -0,0 +1,6 @@\n+Expires: Mon, 26 Jul 1997 05:00:00 GMT\n+Cache-Control: no-store, no-cache, must-revalidate\n+Cache-Control: post-check=0, pre-check=0, false\n+Pragma: no-cache\n+Set-Cookie: {{GET[report_cookie_name]}}={{$id:uuid()}}; Path=/content-security-policy/navigation/\n+Content-Security-Policy: default-src 'none'; script-src 'self' 'unsafe-inline'; report-uri  ../../support/report.py?op=put&reportID={{$id}}""}<_**next**_>{""sha"": ""12245ff457031d6ccac563310d652a7fe83c88aa"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/security/contentSecurityPolicy/script-src-in-iframe-expected.txt?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1,5 +1,4 @@\n CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n-CONSOLE ERROR: The 'allow' directive has been replaced with 'default-src'. Please use that directive instead, as 'allow' has no effect.\n Loads an iframe (a) which loads an iframe (b) which in turns tries to load an external script. The iframe (a) has a content security policy disabling external scripts. As this policy does not apply to (b), the script should be executed.\n \n ""}<_**next**_>{""sha"": ""c74e6c8893bb027a7928a49ca50a59062dc91319"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.cpp"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 8, ""changes"": 29, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -5839,6 +5839,8 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n       AddInsecureNavigationUpgrade(to_upgrade);\n   }\n \n+  ContentSecurityPolicy* policy_to_inherit = nullptr;\n+\n   if (IsSandboxed(kSandboxOrigin)) {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::CreateUnique());\n@@ -5854,12 +5856,14 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n         GetSecurityOrigin()->SetUniqueOriginIsPotentiallyTrustworthy(true);\n       if (owner->GetSecurityOrigin()->CanLoadLocalResources())\n         GetSecurityOrigin()->GrantLoadLocalResources();\n+      policy_to_inherit = owner->GetContentSecurityPolicy();\n     }\n   } else if (Document* owner = initializer.OwnerDocument()) {\n     cookie_url_ = owner->CookieURL();\n     // We alias the SecurityOrigins to match Firefox, see Bug 15313\n     // https://bugs.webkit.org/show_bug.cgi?id=15313\n     SetSecurityOrigin(owner->GetSecurityOrigin());\n+    policy_to_inherit = owner->GetContentSecurityPolicy();\n   } else {\n     cookie_url_ = url_;\n     SetSecurityOrigin(SecurityOrigin::Create(url_));\n@@ -5891,7 +5895,7 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n     SetContentSecurityPolicy(\n         ImportsController()->Master()->GetContentSecurityPolicy());\n   } else {\n-    InitContentSecurityPolicy();\n+    InitContentSecurityPolicy(nullptr, policy_to_inherit);\n   }\n \n   if (GetSecurityOrigin()->HasSuborigin())\n@@ -5926,7 +5930,13 @@ void Document::InitSecurityContext(const DocumentInit& initializer) {\n   SetFeaturePolicy(g_empty_string);\n }\n \n-void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n+// the first parameter specifies a policy to use as the document csp meaning\n+// the document will take ownership of the policy\n+// the second parameter specifies a policy to inherit meaning the document\n+// will attempt to copy over the policy\n+void Document::InitContentSecurityPolicy(\n+    ContentSecurityPolicy* csp,\n+    const ContentSecurityPolicy* policy_to_inherit) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   // We inherit the parent/opener's CSP for documents with \""local\"" schemes:\n@@ -5938,24 +5948,27 @@ void Document::InitContentSecurityPolicy(ContentSecurityPolicy* csp) {\n   //\n   // TODO(dcheng): This is similar enough to work we're doing in\n   // 'DocumentLoader::ensureWriter' that it might make sense to combine them.\n-  if (frame_) {\n+  if (policy_to_inherit) {\n+    GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n+  } else if (frame_) {\n     Frame* inherit_from = frame_->Tree().Parent() ? frame_->Tree().Parent()\n                                                   : frame_->Client()->Opener();\n     if (inherit_from && frame_ != inherit_from) {\n       DCHECK(inherit_from->GetSecurityContext() &&\n              inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n-      ContentSecurityPolicy* policy_to_inherit =\n+      policy_to_inherit =\n           inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       if (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n           url_.ProtocolIs(\""blob\"") || url_.ProtocolIs(\""filesystem\"")) {\n         GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n       }\n-      // Plugin documents inherit their parent/opener's 'plugin-types' directive\n-      // regardless of URL.\n-      if (IsPluginDocument())\n-        GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n     }\n   }\n+  // Plugin documents inherit their parent/opener's 'plugin-types' directive\n+  // regardless of URL.\n+  if (policy_to_inherit && IsPluginDocument())\n+    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n+\n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n }\n ""}<_**next**_>{""sha"": ""0667c0c51ea98b13f4266c913e99c34dea484190"", ""filename"": ""third_party/WebKit/Source/core/dom/Document.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 1, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/dom/Document.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/dom/Document.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1037,7 +1037,13 @@ class CORE_EXPORT Document : public ContainerNode,\n   const SVGDocumentExtensions* SvgExtensions();\n   SVGDocumentExtensions& AccessSVGExtensions();\n \n-  void InitContentSecurityPolicy(ContentSecurityPolicy* = nullptr);\n+  // the first parameter specifies a policy to use as the document csp meaning\n+  // the document will take ownership of the policy\n+  // the second parameter specifies a policy to inherit meaning the document\n+  // will attempt to copy over the policy\n+  void InitContentSecurityPolicy(\n+      ContentSecurityPolicy* = nullptr,\n+      const ContentSecurityPolicy* policy_to_inherit = nullptr);\n \n   bool IsSecureTransitionTo(const KURL&) const;\n ""}<_**next**_>{""sha"": ""bd46b9d507b12455c4beae30363baf11e9ef08ec"", ""filename"": ""third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/WebLocalFrameImpl.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -1818,7 +1818,6 @@ void WebLocalFrameImpl::SetInputEventsScaleForEmulation(\n \n void WebLocalFrameImpl::LoadJavaScriptURL(const KURL& url) {\n   DCHECK(GetFrame());\n-\n   // This is copied from ScriptController::executeScriptIfJavaScriptURL.\n   // Unfortunately, we cannot just use that method since it is private, and\n   // it also doesn't quite behave as we require it to for bookmarklets. The""}<_**next**_>{""sha"": ""a11d1147135855cfaec5c2f0da99aa2b9b233fa3"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 3, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.cpp?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {\n   writer_.Clear();\n }\n \n-void DocumentLoader::DidInstallNewDocument(Document* document) {\n+void DocumentLoader::DidInstallNewDocument(Document* document,\n+                                           InstallNewDocumentReason reason) {\n   document->SetReadyState(Document::kLoading);\n-  document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  if (content_security_policy_) {\n+    document->InitContentSecurityPolicy(content_security_policy_.Release());\n+  }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n     document->SetStateForNewFormElements(history_item_->GetDocumentState());\n@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(\n   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);\n   if (!overriding_url.IsEmpty())\n     document->SetBaseURLOverride(overriding_url);\n-  DidInstallNewDocument(document);\n+  DidInstallNewDocument(document, reason);\n \n   // This must be called before DocumentWriter is created, otherwise HTML parser\n   // will use stale values from HTMLParserOption.""}<_**next**_>{""sha"": ""e5f59fd0c5ce7e5ce4b5a052fc75e6ec845ad9f5"", ""filename"": ""third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/0ab2412a104d2f235d7b9fe19d30ef605a410832/third_party/WebKit/Source/core/loader/DocumentLoader.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/DocumentLoader.h?ref=0ab2412a104d2f235d7b9fe19d30ef605a410832"", ""patch"": ""@@ -244,7 +244,7 @@ class CORE_EXPORT DocumentLoader\n                           InstallNewDocumentReason,\n                           ParserSynchronizationPolicy,\n                           const KURL& overriding_url);\n-  void DidInstallNewDocument(Document*);\n+  void DidInstallNewDocument(Document*, InstallNewDocumentReason);\n   void WillCommitNavigation();\n   void DidCommitNavigation();\n ""}","const AtomicString& DocumentLoader::MimeType() const {
  if (writer_)
    return writer_->MimeType();
  return response_.MimeType();
}
","const AtomicString& DocumentLoader::MimeType() const {
  if (writer_)
    return writer_->MimeType();
  return response_.MimeType();
}
",C,,,,"@@ -898,9 +898,12 @@ void DocumentLoader::EndWriting() {
   writer_.Clear();
 }
 
-void DocumentLoader::DidInstallNewDocument(Document* document) {
+void DocumentLoader::DidInstallNewDocument(Document* document,
+                                           InstallNewDocumentReason reason) {
   document->SetReadyState(Document::kLoading);
-  document->InitContentSecurityPolicy(content_security_policy_.Release());
+  if (content_security_policy_) {
+    document->InitContentSecurityPolicy(content_security_policy_.Release());
+  }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
     document->SetStateForNewFormElements(history_item_->GetDocumentState());
@@ -1116,7 +1119,7 @@ void DocumentLoader::InstallNewDocument(
   frame_->GetPage()->GetChromeClient().InstallSupplements(*frame_);
   if (!overriding_url.IsEmpty())
     document->SetBaseURLOverride(overriding_url);
-  DidInstallNewDocument(document);
+  DidInstallNewDocument(document, reason);
 
   // This must be called before DocumentWriter is created, otherwise HTML parser
   // will use stale values from HTMLParserOption.",Chrome,0ab2412a104d2f235d7b9fe19d30ef605a410832,fb6b7d43431f6a142d53150d14f441cbf1f3e461,0,"const AtomicString& DocumentLoader::MimeType() const {
  if (writer_)
    return writer_->MimeType();
  return response_.MimeType();
}
"
7299,,Remote,Not required,Partial,CVE-2012-5534,https://www.cvedetails.com/cve/CVE-2012-5534/,CWE-20,Low,Partial,Partial,,2012-12-03,7.5,"The hook_process function in the plugin API for WeeChat 0.3.0 through 0.3.9.1 allows remote attackers to execute arbitrary commands via shell metacharacters in a command from a plugin, related to ""shell expansion.""",2014-02-06,Exec Code,0,https://git.savannah.gnu.org/gitweb/?p=weechat.git;a=commitdiff_plain;h=efb795c74fe954b9544074aafcebb1be4452b03a,efb795c74fe954b9544074aafcebb1be4452b03a,,0,,,"hook_hdata (struct t_weechat_plugin *plugin, const char *hdata_name,
            const char *description,
            t_hook_callback_hdata *callback, void *callback_data)
{
    struct t_hook *new_hook;
    struct t_hook_hdata *new_hook_hdata;
    int priority;
    const char *ptr_hdata_name;

    if (!hdata_name || !hdata_name[0] || !callback)
        return NULL;

    new_hook = malloc (sizeof (*new_hook));
    if (!new_hook)
        return NULL;
    new_hook_hdata = malloc (sizeof (*new_hook_hdata));
    if (!new_hook_hdata)
    {
        free (new_hook);
        return NULL;
    }

    hook_get_priority_and_name (hdata_name, &priority, &ptr_hdata_name);
    hook_init_data (new_hook, plugin, HOOK_TYPE_HDATA, priority,
                    callback_data);

    new_hook->hook_data = new_hook_hdata;
    new_hook_hdata->callback = callback;
    new_hook_hdata->hdata_name = strdup ((ptr_hdata_name) ?
                                         ptr_hdata_name : hdata_name);
    new_hook_hdata->description = strdup ((description) ? description : """");

    hook_add_to_list (new_hook);

    return new_hook;
}
","hook_hdata (struct t_weechat_plugin *plugin, const char *hdata_name,
            const char *description,
            t_hook_callback_hdata *callback, void *callback_data)
{
    struct t_hook *new_hook;
    struct t_hook_hdata *new_hook_hdata;
    int priority;
    const char *ptr_hdata_name;

    if (!hdata_name || !hdata_name[0] || !callback)
        return NULL;

    new_hook = malloc (sizeof (*new_hook));
    if (!new_hook)
        return NULL;
    new_hook_hdata = malloc (sizeof (*new_hook_hdata));
    if (!new_hook_hdata)
    {
        free (new_hook);
        return NULL;
    }

    hook_get_priority_and_name (hdata_name, &priority, &ptr_hdata_name);
    hook_init_data (new_hook, plugin, HOOK_TYPE_HDATA, priority,
                    callback_data);

    new_hook->hook_data = new_hook_hdata;
    new_hook_hdata->callback = callback;
    new_hook_hdata->hdata_name = strdup ((ptr_hdata_name) ?
                                         ptr_hdata_name : hdata_name);
    new_hook_hdata->description = strdup ((description) ? description : """");

    hook_add_to_list (new_hook);

    return new_hook;
}
",C,,,c1389f8fe19068790d29e39c3f94b71b8c33ea03,"@@ -1388,9 +1388,9 @@ hook_process (struct t_weechat_plugin *plugin,
 void
 hook_process_child (struct t_hook *hook_process)
 {
-    char *exec_args[4] = { ""sh"", ""-c"", NULL, NULL };
+    char **exec_args;
     const char *ptr_url;
-    int rc;
+    int rc, i;
 
     /*
      * close stdin, so that process will fail to read stdin (process reading
@@ -1429,10 +1429,24 @@ hook_process_child (struct t_hook *hook_process)
     else
     {
         /* launch command */
-        exec_args[2] = HOOK_PROCESS(hook_process, command);
-        execvp (exec_args[0], exec_args);
+        exec_args = string_split_shell (HOOK_PROCESS(hook_process, command));
+        if (exec_args)
+        {
+            if (weechat_debug_core >= 1)
+            {
+                log_printf (""hook_process, command='%s'"",
+                            HOOK_PROCESS(hook_process, command));
+                for (i = 0; exec_args[i]; i++)
+                {
+                    log_printf (""  args[%02d] == '%s'"", i, exec_args[i]);
+                }
+            }
+            execvp (exec_args[0], exec_args);
+        }
 
         /* should not be executed if execvp was ok */
+        if (exec_args)
+            string_free_split (exec_args);
         fprintf (stderr, ""Error with command '%s'\n"",
                  HOOK_PROCESS(hook_process, command));
         rc = EXIT_FAILURE;",savannah,https://git.savannah.gnu.org/gitweb/?p=weechat.git;a=blob;f=src/core/wee-hook.c;h=5e708d0d62593e8f659a3742feb54fe009efb9fe;hb=efb795c74fe954b9544074aafcebb1be4452b03a,https://git.savannah.gnu.org/gitweb/?p=weechat.git;a=blob;f=src/core/wee-hook.c;h=d2d77da314414be589f735a95a118fc7ffa69797,0,"hook_hdata (struct t_weechat_plugin *plugin, const char *hdata_name,
            const char *description,
            t_hook_callback_hdata *callback, void *callback_data)
{
    struct t_hook *new_hook;
    struct t_hook_hdata *new_hook_hdata;
    int priority;
    const char *ptr_hdata_name;

    if (!hdata_name || !hdata_name[0] || !callback)
        return NULL;

    new_hook = malloc (sizeof (*new_hook));
    if (!new_hook)
        return NULL;
    new_hook_hdata = malloc (sizeof (*new_hook_hdata));
    if (!new_hook_hdata)
    {
        free (new_hook);
        return NULL;
    }

    hook_get_priority_and_name (hdata_name, &priority, &ptr_hdata_name);
    hook_init_data (new_hook, plugin, HOOK_TYPE_HDATA, priority,
                    callback_data);

    new_hook->hook_data = new_hook_hdata;
    new_hook_hdata->callback = callback;
    new_hook_hdata->hdata_name = strdup ((ptr_hdata_name) ?
                                         ptr_hdata_name : hdata_name);
    new_hook_hdata->description = strdup ((description) ? description : """");

    hook_add_to_list (new_hook);

    return new_hook;
}
"
160159,,Remote,Not required,Partial,CVE-2018-6085,https://www.cvedetails.com/cve/CVE-2018-6085/,CWE-20,Medium,Partial,Partial,,2018-12-04,6.8,Re-entry of a destructor in Networking Disk Cache in Google Chrome prior to 66.0.3359.117 allowed a remote attacker to execute arbitrary code via a crafted HTML page.,2019-01-09,Exec Code ,0,https://github.com/chromium/chromium/commit/df5b1e1f88e013bc96107cc52c4a4f33a8238444,df5b1e1f88e013bc96107cc52c4a4f33a8238444,"Blockfile cache: fix long-standing sparse + evict reentrancy problem

Thanks to nedwilliamson@ (on gmail) for an alternative perspective
plus a reduction to make fixing this much easier.

Bug: 826626, 518908, 537063, 802886
Change-Id: Ibfa01416f9a8e7f7b361e4f93b4b6b134728b85f
Reviewed-on: https://chromium-review.googlesource.com/985052
Reviewed-by: Matt Menke <mmenke@chromium.org>
Commit-Queue: Maks Orlovich <morlovich@chromium.org>
Cr-Commit-Position: refs/heads/master@{#547103}",0,net/disk_cache/blockfile/in_flight_backend_io.cc,"{""sha"": ""65eeab7e3847c6faf3998984649b992476e065b3"", ""filename"": ""net/disk_cache/backend_unittest.cc"", ""status"": ""modified"", ""additions"": 32, ""deletions"": 0, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/backend_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/backend_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/backend_unittest.cc?ref=df5b1e1f88e013bc96107cc52c4a4f33a8238444"", ""patch"": ""@@ -4311,3 +4311,35 @@ TEST_F(DiskCacheBackendTest, SimpleFdLimit) {\n   histogram_tester.ExpectBucketCount(\""SimpleCache.FileDescriptorLimiterAction\"",\n                                      disk_cache::FD_LIMIT_FAIL_REOPEN_FILE, 0);\n }\n+\n+TEST_F(DiskCacheBackendTest, SparseEvict) {\n+  const int kMaxSize = 512;\n+\n+  SetMaxSize(kMaxSize);\n+  InitCache();\n+\n+  scoped_refptr<net::IOBuffer> buffer(new net::IOBuffer(64));\n+\n+  disk_cache::Entry* entry0 = nullptr;\n+  ASSERT_THAT(CreateEntry(\""http://www.0.com/\"", &entry0), IsOk());\n+\n+  disk_cache::Entry* entry1 = nullptr;\n+  ASSERT_THAT(CreateEntry(\""http://www.1.com/\"", &entry1), IsOk());\n+\n+  disk_cache::Entry* entry2 = nullptr;\n+  // This strange looking domain name affects cache trim order\n+  // due to hashing\n+  ASSERT_THAT(CreateEntry(\""http://www.15360.com/\"", &entry2), IsOk());\n+\n+  // Write sparse data to put us over the eviction threshold\n+  ASSERT_EQ(64, WriteSparseData(entry0, 0, buffer.get(), 64));\n+  ASSERT_EQ(1, WriteSparseData(entry0, 67108923, buffer.get(), 1));\n+  ASSERT_EQ(1, WriteSparseData(entry1, 53, buffer.get(), 1));\n+  ASSERT_EQ(1, WriteSparseData(entry2, 0, buffer.get(), 1));\n+\n+  // Closing these in a special order should not lead to buggy reentrant\n+  // eviction.\n+  entry1->Close();\n+  entry2->Close();\n+  entry0->Close();\n+}""}<_**next**_>{""sha"": ""601f46ac889e93d6d8e88b9ddf7503643864dcfc"", ""filename"": ""net/disk_cache/blockfile/backend_impl.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 3, ""changes"": 15, ""blob_url"": ""https://github.com/chromium/chromium/blob/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/backend_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/backend_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/blockfile/backend_impl.cc?ref=df5b1e1f88e013bc96107cc52c4a4f33a8238444"", ""patch"": ""@@ -168,6 +168,7 @@ BackendImpl::BackendImpl(\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n+      consider_evicting_at_op_end_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n@@ -195,6 +196,7 @@ BackendImpl::BackendImpl(\n       new_eviction_(false),\n       first_timer_(true),\n       user_load_(false),\n+      consider_evicting_at_op_end_(false),\n       net_log_(net_log),\n       done_(base::WaitableEvent::ResetPolicy::MANUAL,\n             base::WaitableEvent::InitialState::NOT_SIGNALED),\n@@ -913,9 +915,16 @@ void BackendImpl::OnEntryDestroyBegin(Addr address) {\n \n void BackendImpl::OnEntryDestroyEnd() {\n   DecreaseNumRefs();\n-  if (data_->header.num_bytes > max_size_ && !read_only_ &&\n-      (up_ticks_ > kTrimDelay || user_flags_ & kNoRandom))\n-    eviction_.TrimCache(false);\n+  consider_evicting_at_op_end_ = true;\n+}\n+\n+void BackendImpl::OnSyncBackendOpComplete() {\n+  if (consider_evicting_at_op_end_) {\n+    if (data_->header.num_bytes > max_size_ && !read_only_ &&\n+        (up_ticks_ > kTrimDelay || user_flags_ & kNoRandom))\n+      eviction_.TrimCache(false);\n+    consider_evicting_at_op_end_ = false;\n+  }\n }\n \n EntryImpl* BackendImpl::GetOpenEntry(CacheRankingsBlock* rankings) const {""}<_**next**_>{""sha"": ""26b4ab27fbbf15f31ba845278446ed1e570a4bb5"", ""filename"": ""net/disk_cache/blockfile/backend_impl.h"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/backend_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/backend_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/blockfile/backend_impl.h?ref=df5b1e1f88e013bc96107cc52c4a4f33a8238444"", ""patch"": ""@@ -89,6 +89,9 @@ class NET_EXPORT_PRIVATE BackendImpl : public Backend {\n   void SyncEndEnumeration(std::unique_ptr<Rankings::Iterator> iterator);\n   void SyncOnExternalCacheHit(const std::string& key);\n \n+  // Called at end of any backend operation on the background thread.\n+  void OnSyncBackendOpComplete();\n+\n   // Open or create an entry for the given |key| or |iter|.\n   scoped_refptr<EntryImpl> OpenEntryImpl(const std::string& key);\n   scoped_refptr<EntryImpl> CreateEntryImpl(const std::string& key);\n@@ -418,6 +421,9 @@ class NET_EXPORT_PRIVATE BackendImpl : public Backend {\n   bool first_timer_;  // True if the timer has not been called.\n   bool user_load_;  // True if we see a high load coming from the caller.\n \n+  // True if we should consider doing eviction at end of current operation.\n+  bool consider_evicting_at_op_end_;\n+\n   net::NetLog* net_log_;\n \n   Stats stats_;  // Usage statistics.""}<_**next**_>{""sha"": ""fc2037811ec02c6167c6d03fef644f13b7f6c478"", ""filename"": ""net/disk_cache/blockfile/in_flight_backend_io.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/in_flight_backend_io.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/df5b1e1f88e013bc96107cc52c4a4f33a8238444/net/disk_cache/blockfile/in_flight_backend_io.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/net/disk_cache/blockfile/in_flight_backend_io.cc?ref=df5b1e1f88e013bc96107cc52c4a4f33a8238444"", ""patch"": ""@@ -310,6 +310,7 @@ void BackendIO::ExecuteBackendOperation() {\n   }\n   DCHECK_NE(net::ERR_IO_PENDING, result_);\n   NotifyController();\n+  backend_->OnSyncBackendOpComplete();\n }\n \n // Runs on the background thread.""}","void BackendIO::ReadyForSparseIO(EntryImpl* entry) {
  operation_ = OP_IS_READY;
  entry_ = entry;
}
","void BackendIO::ReadyForSparseIO(EntryImpl* entry) {
  operation_ = OP_IS_READY;
  entry_ = entry;
}
",C,,,,"@@ -310,6 +310,7 @@ void BackendIO::ExecuteBackendOperation() {
   }
   DCHECK_NE(net::ERR_IO_PENDING, result_);
   NotifyController();
+  backend_->OnSyncBackendOpComplete();
 }
 
 // Runs on the background thread.",Chrome,df5b1e1f88e013bc96107cc52c4a4f33a8238444,bc611587d59c74fc0ac0749bff47b4dc96a171c5,0,"void BackendIO::ReadyForSparseIO(EntryImpl* entry) {
  operation_ = OP_IS_READY;
  entry_ = entry;
}
"
121846,,Remote,Not required,Partial,CVE-2013-2858,https://www.cvedetails.com/cve/CVE-2013-2858/,CWE-416,Low,Partial,Partial,,2013-06-04,7.5,Use-after-free vulnerability in the HTML5 Audio implementation in Google Chrome before 27.0.1453.110 allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,2017-09-18,DoS ,0,https://github.com/chromium/chromium/commit/828eab2216a765dea92575c290421c115b8ad028,828eab2216a765dea92575c290421c115b8ad028,"Added daily UMA for non-data-reduction-proxy data usage when the proxy is enabled.

BUG=325325

Review URL: https://codereview.chromium.org/106113002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@239897 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/io_thread.cc,"{""sha"": ""337adfe3c22efe7d045f5149c967d91d0634dd58"", ""filename"": ""chrome/browser/io_thread.cc"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 0, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/io_thread.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/io_thread.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/io_thread.cc?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -879,6 +879,14 @@ void IOThread::RegisterPrefs(PrefRegistrySimple* registry) {\n       prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled);\n   registry->RegisterListPref(\n       prefs::kDailyContentLengthWithDataReductionProxyEnabled);\n+  registry->RegisterListPref(\n+      prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled);\n+  registry->RegisterListPref(\n+      prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled);\n+  registry->RegisterListPref(\n+      prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled);\n+  registry->RegisterListPref(\n+      prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled);\n   registry->RegisterListPref(\n       prefs::kDailyOriginalContentLengthViaDataReductionProxy);\n   registry->RegisterListPref(""}<_**next**_>{""sha"": ""bf8dfcfabd2c8a518581efdfafd8d57c4da9be11"", ""filename"": ""chrome/browser/net/chrome_network_data_saving_metrics.cc"", ""status"": ""modified"", ""additions"": 287, ""deletions"": 73, ""changes"": 360, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_network_data_saving_metrics.cc?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -8,11 +8,24 @@\n #include \""base/prefs/pref_service.h\""\n #include \""base/prefs/scoped_user_pref_update.h\""\n #include \""base/strings/string_number_conversions.h\""\n+#include \""base/strings/string_util.h\""\n+#include \""chrome/browser/net/spdyproxy/data_reduction_proxy_settings.h\""\n+#include \""chrome/browser/profiles/profile.h\""\n #include \""chrome/common/pref_names.h\""\n+#include \""content/public/common/url_constants.h\""\n+#include \""net/base/host_port_pair.h\""\n+#include \""net/http/http_response_headers.h\""\n+#include \""net/proxy/proxy_retry_info.h\""\n+#include \""net/proxy/proxy_service.h\""\n+#include \""net/url_request/url_request_context.h\""\n \n-#if defined(OS_ANDROID) || defined(OS_IOS)\n namespace {\n \n+// A bypass delay more than this is treated as a long delay.\n+const int kLongBypassDelayInSeconds = 30 * 60;\n+\n+#if defined(OS_ANDROID) || defined(OS_IOS)\n+\n // The number of days of history stored in the content lengths prefs.\n const size_t kNumDaysInHistory = 60;\n \n@@ -54,7 +67,11 @@ void RecordDailyContentLengthHistograms(\n     int64 original_length_with_data_reduction_enabled,\n     int64 received_length_with_data_reduction_enabled,\n     int64 original_length_via_data_reduction_proxy,\n-    int64 received_length_via_data_reduction_proxy) {\n+    int64 received_length_via_data_reduction_proxy,\n+    int64 https_length_with_data_reduction_enabled,\n+    int64 short_bypass_length_with_data_reduction_enabled,\n+    int64 long_bypass_length_with_data_reduction_enabled,\n+    int64 unknown_length_with_data_reduction_enabled) {\n   // Report daily UMA only for days having received content.\n   if (original_length <= 0 || received_length <= 0)\n     return;\n@@ -100,6 +117,45 @@ void RecordDailyContentLengthHistograms(\n       \""Net.DailyContentPercent_DataReductionProxyEnabled\"",\n       (100 * received_length_with_data_reduction_enabled) / received_length);\n \n+  if (https_length_with_data_reduction_enabled > 0) {\n+    UMA_HISTOGRAM_COUNTS(\n+        \""Net.DailyContentLength_DataReductionProxyEnabled_Https\"",\n+        https_length_with_data_reduction_enabled >> 10);\n+    UMA_HISTOGRAM_PERCENTAGE(\n+        \""Net.DailyContentPercent_DataReductionProxyEnabled_Https\"",\n+        (100 * https_length_with_data_reduction_enabled) / received_length);\n+  }\n+\n+  if (short_bypass_length_with_data_reduction_enabled > 0) {\n+    UMA_HISTOGRAM_COUNTS(\n+        \""Net.DailyContentLength_DataReductionProxyEnabled_ShortBypass\"",\n+        short_bypass_length_with_data_reduction_enabled >> 10);\n+    UMA_HISTOGRAM_PERCENTAGE(\n+        \""Net.DailyContentPercent_DataReductionProxyEnabled_ShortBypass\"",\n+        ((100 * short_bypass_length_with_data_reduction_enabled) /\n+         received_length));\n+  }\n+\n+  if (long_bypass_length_with_data_reduction_enabled > 0) {\n+    UMA_HISTOGRAM_COUNTS(\n+        \""Net.DailyContentLength_DataReductionProxyEnabled_LongBypass\"",\n+        long_bypass_length_with_data_reduction_enabled >> 10);\n+    UMA_HISTOGRAM_PERCENTAGE(\n+        \""Net.DailyContentPercent_DataReductionProxyEnabled_LongBypass\"",\n+        ((100 * long_bypass_length_with_data_reduction_enabled) /\n+         received_length));\n+  }\n+\n+  if (unknown_length_with_data_reduction_enabled > 0) {\n+    UMA_HISTOGRAM_COUNTS(\n+        \""Net.DailyContentLength_DataReductionProxyEnabled_Unknown\"",\n+        unknown_length_with_data_reduction_enabled >> 10);\n+    UMA_HISTOGRAM_PERCENTAGE(\n+        \""Net.DailyContentPercent_DataReductionProxyEnabled_Unknown\"",\n+        ((100 * unknown_length_with_data_reduction_enabled) /\n+         received_length));\n+  }\n+\n   if (original_length_via_data_reduction_proxy <= 0 ||\n       received_length_via_data_reduction_proxy <= 0) {\n     return;\n@@ -140,44 +196,72 @@ void MaintainContentLengthPrefsWindow(base::ListValue* list, size_t length) {\n   DCHECK_EQ(length, list->GetSize());\n }\n \n-// Update list for date change and ensure list has exactly |length| elements.\n-// The last entry in each list will be for the current day after the update.\n-void MaintainContentLengthPrefsForDateChange(\n-    base::ListValue* original_update,\n-    base::ListValue* received_update,\n-    int days_since_last_update) {\n-  if (days_since_last_update == -1) {\n-    // The system may go backwards in time by up to a day for legitimate\n-    // reasons, such as with changes to the time zone. In such cases, we\n-    // keep adding to the current day.\n-    // Note: we accept the fact that some reported data is shifted to\n-    // the adjacent day if users travel back and forth across time zones.\n-    days_since_last_update = 0;\n-  } else if (days_since_last_update < -1) {\n-    // Erase all entries if the system went backwards in time by more than\n-    // a day.\n-    original_update->Clear();\n-    received_update->Clear();\n-\n-    days_since_last_update = kNumDaysInHistory;\n+// DailyContentLengthUpdate maintains a data saving pref. The pref is a list\n+// of |kNumDaysInHistory| elements of daily total content lengths for the past\n+// |kNumDaysInHistory| days.\n+class DailyContentLengthUpdate {\n+ public:\n+  DailyContentLengthUpdate(\n+      const char* pref,\n+      PrefService* pref_service)\n+      : update_(pref_service, pref) {\n   }\n-  DCHECK_GE(days_since_last_update, 0);\n-\n-  // Add entries for days since last update event. This will make the\n-  // lists longer than kNumDaysInHistory. The additional items will be cut off\n-  // from the head of the lists by |MaintainContentLengthPrefsWindow|, below.\n-  for (int i = 0;\n-       i < days_since_last_update && i < static_cast<int>(kNumDaysInHistory);\n-       ++i) {\n-    original_update->AppendString(base::Int64ToString(0));\n-    received_update->AppendString(base::Int64ToString(0));\n+\n+  void UpdateForDataChange(int days_since_last_update) {\n+    // New empty lists may have been created. Maintain the invariant that\n+    // there should be exactly |kNumDaysInHistory| days in the histories.\n+    MaintainContentLengthPrefsWindow(update_.Get(), kNumDaysInHistory);\n+    if (days_since_last_update) {\n+      MaintainContentLengthPrefForDateChange(days_since_last_update);\n+    }\n   }\n \n-  // Entries for new days may have been appended. Maintain the invariant that\n-  // there should be exactly |kNumDaysInHistory| days in the histories.\n-  MaintainContentLengthPrefsWindow(original_update, kNumDaysInHistory);\n-  MaintainContentLengthPrefsWindow(received_update, kNumDaysInHistory);\n-}\n+  // Update the lengths for the current day.\n+  void Add(int content_length) {\n+    AddInt64ToListPref(kNumDaysInHistory - 1, content_length, update_.Get());\n+  }\n+\n+  int64 GetListPrefValue(size_t index) {\n+    return ListPrefInt64Value(*update_, index);\n+  }\n+\n+ private:\n+  // Update the list for date change and ensure the list has exactly |length|\n+  // elements. The last entry in the list will be for the current day after\n+  // the update.\n+  void MaintainContentLengthPrefForDateChange(int days_since_last_update) {\n+    if (days_since_last_update == -1) {\n+      // The system may go backwards in time by up to a day for legitimate\n+      // reasons, such as with changes to the time zone. In such cases, we\n+      // keep adding to the current day.\n+      // Note: we accept the fact that some reported data is shifted to\n+      // the adjacent day if users travel back and forth across time zones.\n+      days_since_last_update = 0;\n+    } else if (days_since_last_update < -1) {\n+      // Erase all entries if the system went backwards in time by more than\n+      // a day.\n+      update_->Clear();\n+\n+      days_since_last_update = kNumDaysInHistory;\n+    }\n+    DCHECK_GE(days_since_last_update, 0);\n+\n+    // Add entries for days since last update event. This will make the\n+    // lists longer than kNumDaysInHistory. The additional items will be cut off\n+    // from the head of the lists by |MaintainContentLengthPrefsWindow|, below.\n+    for (int i = 0;\n+         i < days_since_last_update && i < static_cast<int>(kNumDaysInHistory);\n+         ++i) {\n+      update_->AppendString(base::Int64ToString(0));\n+    }\n+\n+    // Entries for new days may have been appended. Maintain the invariant that\n+    // there should be exactly |kNumDaysInHistory| days in the histories.\n+    MaintainContentLengthPrefsWindow(update_.Get(), kNumDaysInHistory);\n+  }\n+\n+  ListPrefUpdate update_;\n+};\n \n // DailyDataSavingUpdate maintains a pair of data saving prefs, original_update_\n // and received_update_. pref_original is a list of |kNumDaysInHistory| elements\n@@ -187,57 +271,147 @@ void MaintainContentLengthPrefsForDateChange(\n class DailyDataSavingUpdate {\n  public:\n   DailyDataSavingUpdate(\n-      const char* pref_original, const char* pref_received,\n+      const char* pref_original,\n+      const char* pref_received,\n       PrefService* pref_service)\n-      : pref_original_(pref_original),\n-        pref_received_(pref_received),\n-        original_update_(pref_service, pref_original_),\n-        received_update_(pref_service, pref_received_) {\n+      : original_(pref_original, pref_service),\n+        received_(pref_received, pref_service) {\n   }\n \n   void UpdateForDataChange(int days_since_last_update) {\n-    // New empty lists may have been created. Maintain the invariant that\n-    // there should be exactly |kNumDaysInHistory| days in the histories.\n-    MaintainContentLengthPrefsWindow(original_update_.Get(), kNumDaysInHistory);\n-    MaintainContentLengthPrefsWindow(received_update_.Get(), kNumDaysInHistory);\n-    if (days_since_last_update) {\n-      MaintainContentLengthPrefsForDateChange(\n-          original_update_.Get(), received_update_.Get(),\n-          days_since_last_update);\n-    }\n+    original_.UpdateForDataChange(days_since_last_update);\n+    received_.UpdateForDataChange(days_since_last_update);\n   }\n \n   // Update the lengths for the current day.\n   void Add(int original_content_length, int received_content_length) {\n-    AddInt64ToListPref(\n-        kNumDaysInHistory - 1, original_content_length, original_update_.Get());\n-    AddInt64ToListPref(\n-        kNumDaysInHistory - 1, received_content_length, received_update_.Get());\n+    original_.Add(original_content_length);\n+    received_.Add(received_content_length);\n   }\n \n   int64 GetOriginalListPrefValue(size_t index) {\n-    return ListPrefInt64Value(*original_update_, index);\n+    return original_.GetListPrefValue(index);\n   }\n   int64 GetReceivedListPrefValue(size_t index) {\n-    return ListPrefInt64Value(*received_update_, index);\n+    return received_.GetListPrefValue(index);\n   }\n \n  private:\n-  const char* pref_original_;\n-  const char* pref_received_;\n-  ListPrefUpdate original_update_;\n-  ListPrefUpdate received_update_;\n+  DailyContentLengthUpdate original_;\n+  DailyContentLengthUpdate received_;\n };\n \n-}  // namespace\n #endif  // defined(OS_ANDROID) || defined(OS_IOS)\n \n+// Returns true if the request is bypassed by all configured data reduction\n+// proxies. It returns the bypass delay in delay_seconds (if not NULL). If\n+// the request is bypassed by more than one proxy, delay_seconds returns\n+// shortest delay.\n+bool IsBypassRequest(const net::URLRequest* request, int64* delay_seconds) {\n+#if defined(OS_ANDROID) || defined(OS_IOS)\n+  DataReductionProxySettings::DataReductionProxyList proxies =\n+      DataReductionProxySettings::GetDataReductionProxies();\n+  if (proxies.size() == 0)\n+    return false;\n+\n+  if (request == NULL || request->context() == NULL ||\n+      request->context()->proxy_service() == NULL) {\n+    return false;\n+  }\n+\n+  const net::ProxyRetryInfoMap& retry_map =\n+      request->context()->proxy_service()->proxy_retry_info();\n+  if (retry_map.size() == 0)\n+    return false;\n+\n+  int64 shortest_delay = 0;\n+  // The request is bypassed if all configured proxies are in the retry map.\n+  for (size_t i = 0; i < proxies.size(); ++i) {\n+    std::string proxy = net::HostPortPair::FromURL(proxies[i]).ToString();\n+    // The retry list has the scheme prefix for https but not for http.\n+    if (proxies[i].SchemeIs(content::kHttpsScheme))\n+      proxy = std::string(content::kHttpsScheme) + \""://\"" + proxy;\n+\n+    net::ProxyRetryInfoMap::const_iterator found = retry_map.find(proxy);\n+    if (found == retry_map.end())\n+      return false;\n+    if (shortest_delay == 0 ||\n+        shortest_delay > found->second.current_delay.InSeconds()) {\n+      shortest_delay = found->second.current_delay.InSeconds();\n+    }\n+  }\n+  if (delay_seconds != NULL)\n+    *delay_seconds = shortest_delay;\n+  return true;\n+#else\n+  return false;\n+#endif  // defined(OS_ANDROID) || defined(OS_IOS)\n+}\n+\n+// IsDataReductionProxyReponse returns true if response_headers contains the\n+// data reduction proxy Via header value.\n+bool IsDataReductionProxyReponse(\n+    const net::HttpResponseHeaders* response_headers) {\n+  const char kDatReductionProxyViaValue[] = \""1.1 Chrome Compression Proxy\"";\n+  size_t value_len = strlen(kDatReductionProxyViaValue);\n+  void* iter = NULL;\n+  std::string temp;\n+  while (response_headers->EnumerateHeader(&iter, \""Via\"", &temp)) {\n+    string::const_iterator it =\n+        std::search(temp.begin(),\n+                    temp.end(),\n+                    kDatReductionProxyViaValue,\n+                    kDatReductionProxyViaValue + value_len,\n+                    base::CaseInsensitiveCompareASCII<char>());\n+    if (it != temp.end()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+}  // namespace\n+\n namespace chrome_browser_net {\n \n+DataReductionRequestType GetDataReductionRequestType(\n+    const Profile* profile, const net::URLRequest* request) {\n+  if (profile != NULL && profile->IsOffTheRecord())\n+    return OFF_THE_RECORD;\n+  if (request->url().SchemeIs(content::kHttpsScheme))\n+    return HTTPS;\n+  if (!request->url().SchemeIs(content::kHttpScheme)) {\n+    NOTREACHED();\n+    return UNKNOWN_TYPE;\n+  }\n+  int64 bypass_delay = 0;\n+  if (IsBypassRequest(request, &bypass_delay)) {\n+    return (bypass_delay > kLongBypassDelayInSeconds) ?\n+      LONG_BYPASS : SHORT_BYPASS;\n+  }\n+  return IsDataReductionProxyReponse(request->response_info().headers) ?\n+    VIA_DATA_REDUCTION_PROXY: UNKNOWN_TYPE;\n+}\n+\n+int64 GetAdjustedOriginalContentLength(\n+    DataReductionRequestType data_reduction_type,\n+    int64 original_content_length,\n+    int64 received_content_length) {\n+  // Since there was no indication of the original content length, presume\n+  // it is no different from the number of bytes read.\n+  if (original_content_length == -1 ||\n+      data_reduction_type != chrome_browser_net::VIA_DATA_REDUCTION_PROXY) {\n+    return received_content_length;\n+  }\n+  return original_content_length;\n+}\n+\n #if defined(OS_ANDROID) || defined(OS_IOS)\n void UpdateContentLengthPrefsForDataReductionProxy(\n-    int received_content_length, int original_content_length,\n-    bool with_data_reduction_proxy_enabled, bool via_data_reduction_proxy,\n+    int received_content_length,\n+    int original_content_length,\n+    bool with_data_reduction_proxy_enabled,\n+    DataReductionRequestType data_reduction_type,\n     base::Time now, PrefService* prefs) {\n   // TODO(bengr): Remove this check once the underlying cause of\n   // http://crbug.com/287821 is fixed. For now, only continue if the current\n@@ -282,14 +456,47 @@ void UpdateContentLengthPrefsForDataReductionProxy(\n       prefs);\n   via_proxy.UpdateForDataChange(days_since_last_update);\n \n+  DailyContentLengthUpdate https(\n+      prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled, prefs);\n+  https.UpdateForDataChange(days_since_last_update);\n+\n+  DailyContentLengthUpdate short_bypass(\n+      prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled,\n+      prefs);\n+  short_bypass.UpdateForDataChange(days_since_last_update);\n+\n+  DailyContentLengthUpdate long_bypass(\n+      prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled, prefs);\n+  long_bypass.UpdateForDataChange(days_since_last_update);\n+\n+  DailyContentLengthUpdate unknown(\n+      prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled, prefs);\n+  unknown.UpdateForDataChange(days_since_last_update);\n+\n   total.Add(original_content_length, received_content_length);\n   if (with_data_reduction_proxy_enabled) {\n     proxy_enabled.Add(original_content_length, received_content_length);\n-    // Ignore cases, if exist, when\n-    // \""with_data_reduction_proxy_enabled == false\"", and\n-    // \""via_data_reduction_proxy == true\""\n-    if (via_data_reduction_proxy) {\n-      via_proxy.Add(original_content_length, received_content_length);\n+    // Ignore data source cases, if exist, when\n+    // \""with_data_reduction_proxy_enabled == false\""\n+    switch (data_reduction_type) {\n+      case VIA_DATA_REDUCTION_PROXY:\n+        via_proxy.Add(original_content_length, received_content_length);\n+        break;\n+      case OFF_THE_RECORD:\n+        // We don't measure off-the-record data.\n+        break;\n+      case HTTPS:\n+        https.Add(received_content_length);\n+        break;\n+      case SHORT_BYPASS:\n+        short_bypass.Add(received_content_length);\n+        break;\n+      case LONG_BYPASS:\n+        long_bypass.Add(received_content_length);\n+        break;\n+      case UNKNOWN_TYPE:\n+        unknown.Add(received_content_length);\n+        break;\n     }\n   }\n \n@@ -304,21 +511,28 @@ void UpdateContentLengthPrefsForDataReductionProxy(\n     // associated with an accurate date.\n     if (days_since_last_update == 1) {\n       // The previous day's data point is the second one from the tail.\n+      // Therefore (kNumDaysInHistory - 2) below.\n       RecordDailyContentLengthHistograms(\n           total.GetOriginalListPrefValue(kNumDaysInHistory - 2),\n           total.GetReceivedListPrefValue(kNumDaysInHistory - 2),\n           proxy_enabled.GetOriginalListPrefValue(kNumDaysInHistory - 2),\n           proxy_enabled.GetReceivedListPrefValue(kNumDaysInHistory - 2),\n           via_proxy.GetOriginalListPrefValue(kNumDaysInHistory - 2),\n-          via_proxy.GetReceivedListPrefValue(kNumDaysInHistory - 2));\n+          via_proxy.GetReceivedListPrefValue(kNumDaysInHistory - 2),\n+          https.GetListPrefValue(kNumDaysInHistory - 2),\n+          short_bypass.GetListPrefValue(kNumDaysInHistory - 2),\n+          long_bypass.GetListPrefValue(kNumDaysInHistory - 2),\n+          unknown.GetListPrefValue(kNumDaysInHistory - 2));\n     }\n   }\n }\n #endif  // defined(OS_ANDROID) || defined(OS_IOS)\n \n void UpdateContentLengthPrefs(\n-    int received_content_length, int original_content_length,\n-    bool with_data_reduction_proxy_enabled, bool via_data_reduction_proxy,\n+    int received_content_length,\n+    int original_content_length,\n+    bool with_data_reduction_proxy_enabled,\n+    DataReductionRequestType data_reduction_type,\n     PrefService* prefs) {\n   int64 total_received = prefs->GetInt64(prefs::kHttpReceivedContentLength);\n   int64 total_original = prefs->GetInt64(prefs::kHttpOriginalContentLength);\n@@ -332,7 +546,7 @@ void UpdateContentLengthPrefs(\n       received_content_length,\n       original_content_length,\n       with_data_reduction_proxy_enabled,\n-      via_data_reduction_proxy,\n+      data_reduction_type,\n       base::Time::Now(),\n       prefs);\n #endif  // defined(OS_ANDROID) || defined(OS_IOS)""}<_**next**_>{""sha"": ""241471745dbaa20e92f4a8f7e6c2733ebadc6968"", ""filename"": ""chrome/browser/net/chrome_network_data_saving_metrics.h"", ""status"": ""modified"", ""additions"": 37, ""deletions"": 3, ""changes"": 40, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_network_data_saving_metrics.h?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -7,16 +7,50 @@\n \n #include \""base/time/time.h\""\n \n+namespace net {\n+class URLRequest;\n+}\n+\n class PrefService;\n+class Profile;\n \n namespace chrome_browser_net {\n \n+enum DataReductionRequestType {\n+  VIA_DATA_REDUCTION_PROXY,  // A request served by the data reduction proxy.\n+\n+  // Below are reasons why a request is not served by the enabled data\n+  // saving proxy.\n+  OFF_THE_RECORD,  // An off-the-record (incognito) request, either http\n+                   // or https.\n+  HTTPS,  // An https request that is not from an off-the-record profile.\n+  SHORT_BYPASS,  // The client is bypassed by the proxy for a short time.\n+  LONG_BYPASS,  // The client is bypassed by the proxy for a long time (due\n+                // to country bypass policy, for example).\n+  UNKNOWN_TYPE,  // Any other reason not listed above.\n+};\n+\n+// Returns DataReductionRequestType for |request|.\n+DataReductionRequestType GetDataReductionRequestType(\n+    const Profile* profile,\n+    const net::URLRequest* request);\n+\n+// Returns |received_content_length| as adjusted original content length if\n+// |original_content_length| has the invalid value (-1) or |data_reduction_type|\n+// is not |VIA_DATA_REDUCTION_PROXY|.\n+int64 GetAdjustedOriginalContentLength(\n+    DataReductionRequestType data_reduction_type,\n+    int64 original_content_length,\n+    int64 received_content_length);\n+\n #if defined(OS_ANDROID) || defined(OS_IOS)\n // This is only exposed for testing. It is normally called by\n // UpdateContentLengthPrefs.\n void UpdateContentLengthPrefsForDataReductionProxy(\n-    int received_content_length, int original_content_length,\n-    bool with_data_reduction_proxy_enabled, bool via_data_reduction_proxy,\n+    int received_content_length,\n+    int original_content_length,\n+    bool with_data_reduction_proxy_enabled,\n+    DataReductionRequestType data_reduction_type,\n     base::Time now, PrefService* prefs);\n #endif\n \n@@ -25,7 +59,7 @@ void UpdateContentLengthPrefs(\n     int received_content_length,\n     int original_content_length,\n     bool with_data_reduction_proxy_enabled,\n-    bool via_data_reduction_proxy,\n+    DataReductionRequestType data_reduction_type,\n     PrefService* prefs);\n \n }  // namespace chrome_browser_net""}<_**next**_>{""sha"": ""63562e429a6b57fe1d6f72692a340543d8dd8fbf"", ""filename"": ""chrome/browser/net/chrome_network_data_saving_metrics_unittest.cc"", ""status"": ""modified"", ""additions"": 214, ""deletions"": 46, ""changes"": 260, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_data_saving_metrics_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_network_data_saving_metrics_unittest.cc?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -47,6 +47,14 @@ class ChromeNetworkDataSavingMetricsTest : public testing::Test {\n         prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled);\n     registry->RegisterListPref(\n         prefs::kDailyContentLengthWithDataReductionProxyEnabled);\n+    registry->RegisterListPref(\n+        prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled);\n+    registry->RegisterListPref(\n+        prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled);\n+    registry->RegisterListPref(\n+        prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled);\n+    registry->RegisterListPref(\n+        prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled);\n     registry->RegisterListPref(\n         prefs::kDailyOriginalContentLengthViaDataReductionProxy);\n     registry->RegisterListPref(\n@@ -65,7 +73,7 @@ TEST_F(ChromeNetworkDataSavingMetricsTest, TotalLengths) {\n \n   chrome_browser_net::UpdateContentLengthPrefs(\n       kReceivedLength, kOriginalLength,\n-      false, false, &pref_service_);\n+      false, chrome_browser_net::UNKNOWN_TYPE, &pref_service_);\n   EXPECT_EQ(kReceivedLength,\n             pref_service_.GetInt64(prefs::kHttpReceivedContentLength));\n   EXPECT_EQ(kOriginalLength,\n@@ -74,7 +82,7 @@ TEST_F(ChromeNetworkDataSavingMetricsTest, TotalLengths) {\n   // Record the same numbers again, and total lengths should be dobuled.\n   chrome_browser_net::UpdateContentLengthPrefs(\n       kReceivedLength, kOriginalLength,\n-      false, false, &pref_service_);\n+      false, chrome_browser_net::UNKNOWN_TYPE, &pref_service_);\n   EXPECT_EQ(kReceivedLength * 2,\n             pref_service_.GetInt64(prefs::kHttpReceivedContentLength));\n   EXPECT_EQ(kOriginalLength * 2,\n@@ -144,8 +152,8 @@ class ChromeNetworkDailyDataSavingMetricsTest\n     }\n   }\n \n-  // Verify all daily pref list values.\n-  void VerifyDailyContentLengthPrefLists(\n+  // Verify all daily data saving pref list values.\n+  void VerifyDailyDataSavingContentLengthPrefLists(\n       const int64* original_values, size_t original_count,\n       const int64* received_values, size_t received_count,\n       const int64* original_with_data_reduction_proxy_enabled_values,\n@@ -178,6 +186,52 @@ class ChromeNetworkDailyDataSavingMetricsTest\n         received_via_data_reduction_proxy_count);\n   }\n \n+  // Verify daily data saving pref for request types.\n+  void VerifyDailyRequestTypeContentLengthPrefLists(\n+      const int64* original_values, size_t original_count,\n+      const int64* received_values, size_t received_count,\n+      const int64* original_with_data_reduction_proxy_enabled_values,\n+      size_t original_with_data_reduction_proxy_enabled_count,\n+      const int64* received_with_data_reduction_proxy_enabled_values,\n+      size_t received_with_data_reduction_proxy_count,\n+      const int64* https_with_data_reduction_proxy_enabled_values,\n+      size_t https_with_data_reduction_proxy_enabled_count,\n+      const int64* short_bypass_with_data_reduction_proxy_enabled_values,\n+      size_t short_bypass_with_data_reduction_proxy_enabled_count,\n+      const int64* long_bypass_with_data_reduction_proxy_enabled_values,\n+      size_t long_bypass_with_data_reduction_proxy_enabled_count,\n+      const int64* unknown_with_data_reduction_proxy_enabled_values,\n+      size_t unknown_with_data_reduction_proxy_enabled_count) {\n+    VerifyPrefList(prefs::kDailyHttpOriginalContentLength,\n+                   original_values, original_count);\n+    VerifyPrefList(prefs::kDailyHttpReceivedContentLength,\n+                   received_values, received_count);\n+    VerifyPrefList(\n+        prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled,\n+        original_with_data_reduction_proxy_enabled_values,\n+        original_with_data_reduction_proxy_enabled_count);\n+    VerifyPrefList(\n+        prefs::kDailyContentLengthWithDataReductionProxyEnabled,\n+        received_with_data_reduction_proxy_enabled_values,\n+        received_with_data_reduction_proxy_count);\n+    VerifyPrefList(\n+        prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled,\n+        https_with_data_reduction_proxy_enabled_values,\n+        https_with_data_reduction_proxy_enabled_count);\n+    VerifyPrefList(\n+        prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled,\n+        short_bypass_with_data_reduction_proxy_enabled_values,\n+        short_bypass_with_data_reduction_proxy_enabled_count);\n+    VerifyPrefList(\n+        prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled,\n+        long_bypass_with_data_reduction_proxy_enabled_values,\n+        long_bypass_with_data_reduction_proxy_enabled_count);\n+    VerifyPrefList(\n+        prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled,\n+        unknown_with_data_reduction_proxy_enabled_values,\n+        unknown_with_data_reduction_proxy_enabled_count);\n+  }\n+\n  private:\n   base::Time now_;\n   base::TimeDelta now_delta_;\n@@ -191,8 +245,9 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, OneResponse) {\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n-  VerifyDailyContentLengthPrefLists(\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original, 1, received, 1,\n       original, 1, received, 1);\n@@ -205,83 +260,182 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, MultipleResponses) {\n   int64 received[] = {kReceivedLength};\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      false, false, FakeNow(), &pref_service_);\n-  VerifyDailyContentLengthPrefLists(\n+      false, chrome_browser_net::UNKNOWN_TYPE,\n+      FakeNow(), &pref_service_);\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       NULL, 0, NULL, 0, NULL, 0, NULL, 0);\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, false, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::UNKNOWN_TYPE,\n+      FakeNow(), &pref_service_);\n   original[0] += kOriginalLength;\n   received[0] += kReceivedLength;\n   int64 original_proxy_enabled[] = {kOriginalLength};\n   int64 received_proxy_enabled[] = {kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original_proxy_enabled, 1, received_proxy_enabled, 1,\n       NULL, 0, NULL, 0);\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   original[0] += kOriginalLength;\n   received[0] += kReceivedLength;\n   original_proxy_enabled[0] += kOriginalLength;\n   received_proxy_enabled[0] += kReceivedLength;\n   int64 original_via_proxy[] = {kOriginalLength};\n   int64 received_via_proxy[] = {kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original_proxy_enabled, 1, received_proxy_enabled, 1,\n       original_via_proxy, 1, received_via_proxy, 1);\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, false, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::UNKNOWN_TYPE, FakeNow(), &pref_service_);\n   original[0] += kOriginalLength;\n   received[0] += kReceivedLength;\n   original_proxy_enabled[0] += kOriginalLength;\n   received_proxy_enabled[0] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original_proxy_enabled, 1, received_proxy_enabled, 1,\n       original_via_proxy, 1, received_via_proxy, 1);\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      false, false, FakeNow(), &pref_service_);\n+      false, chrome_browser_net::UNKNOWN_TYPE, FakeNow(), &pref_service_);\n   original[0] += kOriginalLength;\n   received[0] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original_proxy_enabled, 1, received_proxy_enabled, 1,\n       original_via_proxy, 1, received_via_proxy, 1);\n }\n \n+TEST_F(ChromeNetworkDailyDataSavingMetricsTest, RequestType) {\n+  const int64 kContentLength = 200;\n+  int64 received[] = {0};\n+  int64 https_received[] = {0};\n+  int64 total_received[] = {0};\n+  int64 proxy_enabled_received[] = {0};\n+\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      true, chrome_browser_net::HTTPS,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  proxy_enabled_received[0] += kContentLength;\n+  https_received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 0,  // short bypass\n+      received, 0,  // long bypass\n+      received, 0);  // unknown\n+\n+  // Data reduction proxy is not enabled.\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      false, chrome_browser_net::HTTPS,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 0,  // short bypass\n+      received, 0,  // long bypass\n+      received, 0);  // unknown\n+\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      true, chrome_browser_net::HTTPS,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  proxy_enabled_received[0] += kContentLength;\n+  https_received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 0,  // short bypass\n+      received, 0,  // long bypass\n+      received, 0);  // unknown\n+\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      true, chrome_browser_net::SHORT_BYPASS,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  proxy_enabled_received[0] += kContentLength;\n+  received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 1,  // short bypass\n+      received, 0,  // long bypass\n+      received, 0);  // unknown\n+\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      true, chrome_browser_net::LONG_BYPASS,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  proxy_enabled_received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,  // total\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 1,  // short bypass\n+      received, 1,  // long bypass\n+      received, 0);  // unknown\n+\n+  chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n+      kContentLength, kContentLength,\n+      true, chrome_browser_net::UNKNOWN_TYPE,\n+      FakeNow(), &pref_service_);\n+  total_received[0] += kContentLength;\n+  proxy_enabled_received[0] += kContentLength;\n+  VerifyDailyRequestTypeContentLengthPrefLists(\n+      total_received, 1, total_received, 1,\n+      proxy_enabled_received, 1, proxy_enabled_received, 1,\n+      https_received, 1,\n+      received, 1,  // short bypass\n+      received, 1,  // long bypass\n+      received, 1);  // unknown\n+}\n+\n TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardOneDay) {\n   const int64 kOriginalLength = 200;\n   const int64 kReceivedLength = 100;\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n \n   // Forward one day.\n   SetFakeTimeDeltaInHours(24);\n \n   // Proxy not enabled. Not via proxy.\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      false, false, FakeNow(), &pref_service_);\n+      false, chrome_browser_net::UNKNOWN_TYPE, FakeNow(), &pref_service_);\n \n   int64 original[] = {kOriginalLength, kOriginalLength};\n   int64 received[] = {kReceivedLength, kReceivedLength};\n   int64 original_with_data_reduction_proxy_enabled[] = {kOriginalLength, 0};\n   int64 received_with_data_reduction_proxy_enabled[] = {kReceivedLength, 0};\n   int64 original_via_data_reduction_proxy[] = {kOriginalLength, 0};\n   int64 received_via_data_reduction_proxy[] = {kReceivedLength, 0};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 2,\n       received, 2,\n       original_with_data_reduction_proxy_enabled, 2,\n@@ -292,12 +446,12 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardOneDay) {\n   // Proxy enabled. Not via proxy.\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, false, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::UNKNOWN_TYPE, FakeNow(), &pref_service_);\n   original[1] += kOriginalLength;\n   received[1] += kReceivedLength;\n   original_with_data_reduction_proxy_enabled[1] += kOriginalLength;\n   received_with_data_reduction_proxy_enabled[1] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 2,\n       received, 2,\n       original_with_data_reduction_proxy_enabled, 2,\n@@ -308,14 +462,15 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardOneDay) {\n   // Proxy enabled and via proxy.\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   original[1] += kOriginalLength;\n   received[1] += kReceivedLength;\n   original_with_data_reduction_proxy_enabled[1] += kOriginalLength;\n   received_with_data_reduction_proxy_enabled[1] += kReceivedLength;\n   original_via_data_reduction_proxy[1] += kOriginalLength;\n   received_via_data_reduction_proxy[1] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 2,\n       received, 2,\n       original_with_data_reduction_proxy_enabled, 2,\n@@ -332,8 +487,9 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, PartialDayTimeChange) {\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n-  VerifyDailyContentLengthPrefLists(\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 2, received, 2,\n       original, 2, received, 2,\n       original, 2, received, 2);\n@@ -343,10 +499,11 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, PartialDayTimeChange) {\n   SetFakeTimeDeltaInHours(10);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   original[1] += kOriginalLength;\n   received[1] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 2, received, 2,\n       original, 2, received, 2,\n       original, 2, received, 2);\n@@ -355,10 +512,11 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, PartialDayTimeChange) {\n   AddFakeTimeDeltaInHours(11);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   int64 original2[] = {kOriginalLength * 2, kOriginalLength};\n   int64 received2[] = {kReceivedLength * 2, kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original2, 2, received2, 2,\n       original2, 2, received2, 2,\n       original2, 2, received2, 2);\n@@ -369,18 +527,20 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardMultipleDays) {\n   const int64 kReceivedLength = 100;\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n \n   // Forward three days.\n   SetFakeTimeDeltaInHours(3 * 24);\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n \n   int64 original[] = {kOriginalLength, 0, 0, kOriginalLength};\n   int64 received[] = {kReceivedLength, 0, 0, kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 4, received, 4,\n       original, 4, received, 4,\n       original, 4, received, 4);\n@@ -389,14 +549,15 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardMultipleDays) {\n   AddFakeTimeDeltaInHours(4 * 24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   int64 original2[] = {\n     kOriginalLength, 0, 0, kOriginalLength, 0, 0, 0, kOriginalLength,\n   };\n   int64 received2[] = {\n     kReceivedLength, 0, 0, kReceivedLength, 0, 0, 0, kReceivedLength,\n   };\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original2, 8, received2, 8,\n       original2, 8, received2, 8,\n       original2, 8, received2, 8);\n@@ -405,10 +566,11 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardMultipleDays) {\n   AddFakeTimeDeltaInHours(kNumDaysInHistory * 24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   int64 original3[] = {kOriginalLength};\n   int64 received3[] = {kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original3, 1, received3, 1,\n       original3, 1, received3, 1,\n       original3, 1, received3, 1);\n@@ -417,8 +579,9 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, ForwardMultipleDays) {\n   AddFakeTimeDeltaInHours((kNumDaysInHistory + 1)* 24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n-  VerifyDailyContentLengthPrefLists(\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original3, 1, received3, 1,\n       original3, 1, received3, 1,\n       original3, 1, received3, 1);\n@@ -432,16 +595,18 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, BackwardAndForwardOneDay) {\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n \n   // Backward one day.\n   SetFakeTimeDeltaInHours(-24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   original[0] += kOriginalLength;\n   received[0] += kReceivedLength;\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original, 1, received, 1,\n       original, 1, received, 1);\n@@ -450,10 +615,11 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, BackwardAndForwardOneDay) {\n   AddFakeTimeDeltaInHours(24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   int64 original2[] = {kOriginalLength * 2, kOriginalLength};\n   int64 received2[] = {kReceivedLength * 2, kReceivedLength};\n-  VerifyDailyContentLengthPrefLists(\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original2, 2, received2, 2,\n       original2, 2, received2, 2,\n       original2, 2, received2, 2);\n@@ -467,13 +633,15 @@ TEST_F(ChromeNetworkDailyDataSavingMetricsTest, BackwardTwoDays) {\n \n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n   // Backward two days.\n   SetFakeTimeDeltaInHours(-2 * 24);\n   chrome_browser_net::UpdateContentLengthPrefsForDataReductionProxy(\n       kReceivedLength, kOriginalLength,\n-      true, true, FakeNow(), &pref_service_);\n-  VerifyDailyContentLengthPrefLists(\n+      true, chrome_browser_net::VIA_DATA_REDUCTION_PROXY,\n+      FakeNow(), &pref_service_);\n+  VerifyDailyDataSavingContentLengthPrefLists(\n       original, 1, received, 1,\n       original, 1, received, 1,\n       original, 1, received, 1);""}<_**next**_>{""sha"": ""240c1274cf6734980ee2eb0e70b9f81a62c4bdbe"", ""filename"": ""chrome/browser/net/chrome_network_delegate.cc"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 20, ""changes"": 41, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_network_delegate.cc?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -215,9 +215,10 @@ void ForwardRequestStatus(\n   }\n }\n \n-void UpdateContentLengthPrefs(int received_content_length,\n-                              int original_content_length,\n-                              bool via_data_reduction_proxy) {\n+void UpdateContentLengthPrefs(\n+    int received_content_length,\n+    int original_content_length,\n+    chrome_browser_net::DataReductionRequestType data_reduction_type) {\n   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n   DCHECK_GE(received_content_length, 0);\n   DCHECK_GE(original_content_length, 0);\n@@ -242,16 +243,17 @@ void UpdateContentLengthPrefs(int received_content_length,\n       received_content_length,\n       original_content_length,\n       with_data_reduction_proxy_enabled,\n-      via_data_reduction_proxy, prefs);\n+      data_reduction_type, prefs);\n }\n \n-void StoreAccumulatedContentLength(int received_content_length,\n-                                   int original_content_length,\n-                                   bool data_reduction_proxy_was_used) {\n+void StoreAccumulatedContentLength(\n+    int received_content_length,\n+    int original_content_length,\n+    chrome_browser_net::DataReductionRequestType data_reduction_type) {\n   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n       base::Bind(&UpdateContentLengthPrefs,\n                  received_content_length, original_content_length,\n-                 data_reduction_proxy_was_used));\n+                 data_reduction_type));\n }\n \n void RecordContentLengthHistograms(\n@@ -525,21 +527,20 @@ void ChromeNetworkDelegate::OnCompleted(net::URLRequest* request,\n       int64 original_content_length =\n           request->response_info().headers->GetInt64HeaderValue(\n               \""x-original-content-length\"");\n-      bool via_data_reduction_proxy =\n-          request->response_info().headers->HasHeaderValue(\n-              \""via\"", \""1.1 Chrome Compression Proxy\"");\n-\n-      // Since there was no indication of the original content length, presume\n-      // it is no different from the number of bytes read.\n-      int64 adjusted_original_content_length = original_content_length;\n-      if (adjusted_original_content_length == -1)\n-        adjusted_original_content_length = received_content_length;\n+      chrome_browser_net::DataReductionRequestType data_reduction_type =\n+          chrome_browser_net::GetDataReductionRequestType(\n+              reinterpret_cast<Profile*>(profile_), request);\n+\n       base::TimeDelta freshness_lifetime =\n           request->response_info().headers->GetFreshnessLifetime(\n               request->response_info().response_time);\n+      int64 adjusted_original_content_length =\n+          chrome_browser_net::GetAdjustedOriginalContentLength(\n+              data_reduction_type, original_content_length,\n+              received_content_length);\n       AccumulateContentLength(received_content_length,\n                               adjusted_original_content_length,\n-                              via_data_reduction_proxy);\n+                              data_reduction_type);\n       RecordContentLengthHistograms(received_content_length,\n                                     original_content_length,\n                                     freshness_lifetime);\n@@ -759,12 +760,12 @@ void ChromeNetworkDelegate::OnRequestWaitStateChange(\n \n void ChromeNetworkDelegate::AccumulateContentLength(\n     int64 received_content_length, int64 original_content_length,\n-    bool via_data_reduction_proxy) {\n+    chrome_browser_net::DataReductionRequestType data_reduction_type) {\n   DCHECK_GE(received_content_length, 0);\n   DCHECK_GE(original_content_length, 0);\n   StoreAccumulatedContentLength(received_content_length,\n                                 original_content_length,\n-                                via_data_reduction_proxy);\n+                                data_reduction_type);\n   received_content_length_ += received_content_length;\n   original_content_length_ += original_content_length;\n }""}<_**next**_>{""sha"": ""6d268b6f2d5d5c312719dc2b92386e1d13a7661a"", ""filename"": ""chrome/browser/net/chrome_network_delegate.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_delegate.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/browser/net/chrome_network_delegate.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/net/chrome_network_delegate.h?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -13,6 +13,7 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/scoped_ptr.h\""\n #include \""base/values.h\""\n+#include \""chrome/browser/net/chrome_network_data_saving_metrics.h\""\n #include \""net/base/network_delegate.h\""\n \n class ClientHints;\n@@ -181,7 +182,7 @@ class ChromeNetworkDelegate : public net::NetworkDelegate {\n \n   void AccumulateContentLength(\n       int64 received_payload_byte_count, int64 original_payload_byte_count,\n-      bool data_reduction_proxy_was_used);\n+      chrome_browser_net::DataReductionRequestType data_reduction_type);\n \n   scoped_refptr<extensions::EventRouterForwarder> event_router_;\n   void* profile_;""}<_**next**_>{""sha"": ""6bb3d91269d01e9e898869613674c68be98d0d55"", ""filename"": ""chrome/common/pref_names.cc"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/common/pref_names.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/common/pref_names.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/pref_names.cc?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -2065,6 +2065,19 @@ const char kDailyOriginalContentLengthWithDataReductionProxyEnabled[] =\n const char kDailyContentLengthWithDataReductionProxyEnabled[] =\n     \""data_reduction.daily_received_length_with_data_reduction_proxy_enabled\"";\n \n+const char kDailyContentLengthHttpsWithDataReductionProxyEnabled[] =\n+    \""data_reduction.daily_received_length_https_with_\""\n+    \""data_reduction_proxy_enabled\"";\n+const char kDailyContentLengthShortBypassWithDataReductionProxyEnabled[] =\n+    \""data_reduction.daily_received_length_short_bypass_with_\""\n+    \""data_reduction_proxy_enabled\"";\n+const char kDailyContentLengthLongBypassWithDataReductionProxyEnabled[] =\n+    \""data_reduction.daily_received_length_long_bypass_with_\""\n+    \""data_reduction_proxy_enabled\"";\n+const char kDailyContentLengthUnknownWithDataReductionProxyEnabled[] =\n+    \""data_reduction.daily_received_length_unknown_with_\""\n+    \""data_reduction_proxy_enabled\"";\n+\n // A List pref that contains daily totals of the original size of all HTTP/HTTPS\n // that was received via the data reduction proxy.\n const char kDailyOriginalContentLengthViaDataReductionProxy[] =""}<_**next**_>{""sha"": ""a47c2831a7f9b3c32d298a67670e880533a4c3be"", ""filename"": ""chrome/common/pref_names.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/chrome/common/pref_names.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/chrome/common/pref_names.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/pref_names.h?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -807,6 +807,10 @@ extern const char kDailyHttpOriginalContentLength[];\n extern const char kDailyHttpReceivedContentLength[];\n extern const char kDailyOriginalContentLengthWithDataReductionProxyEnabled[];\n extern const char kDailyContentLengthWithDataReductionProxyEnabled[];\n+extern const char kDailyContentLengthHttpsWithDataReductionProxyEnabled[];\n+extern const char kDailyContentLengthShortBypassWithDataReductionProxyEnabled[];\n+extern const char kDailyContentLengthLongBypassWithDataReductionProxyEnabled[];\n+extern const char kDailyContentLengthUnknownWithDataReductionProxyEnabled[];\n extern const char kDailyOriginalContentLengthViaDataReductionProxy[];\n extern const char kDailyContentLengthViaDataReductionProxy[];\n extern const char kDailyHttpContentLengthLastUpdateDate[];""}<_**next**_>{""sha"": ""8a23b401a41e29d385ca0f99a5b02137f945b0b4"", ""filename"": ""tools/metrics/histograms/histograms.xml"", ""status"": ""modified"", ""additions"": 81, ""deletions"": 0, ""changes"": 81, ""blob_url"": ""https://github.com/chromium/chromium/blob/828eab2216a765dea92575c290421c115b8ad028/tools/metrics/histograms/histograms.xml"", ""raw_url"": ""https://github.com/chromium/chromium/raw/828eab2216a765dea92575c290421c115b8ad028/tools/metrics/histograms/histograms.xml"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/tools/metrics/histograms/histograms.xml?ref=828eab2216a765dea92575c290421c115b8ad028"", ""patch"": ""@@ -7755,6 +7755,46 @@ other types of suffix sets.\n   </summary>\n </histogram>\n \n+<histogram name=\""Net.DailyContentLength_DataReductionProxyEnabled_Https\""\n+    units=\""KB\"">\n+  <summary>\n+    The total content size in KB of all HTTPS response bodies in the previous\n+    calendar day while the data reduction proxy setting was enabled. The metric\n+    is reported when the first response in the current day is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentLength_DataReductionProxyEnabled_LongBypass\""\n+    units=\""KB\"">\n+  <summary>\n+    The total content size in KB of all long-bypassed HTTP response bodies in\n+    the  previous calendar day while the data reduction proxy setting was\n+    enabled. The metric is reported when the first response in the current day\n+    is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentLength_DataReductionProxyEnabled_ShortBypass\""\n+    units=\""KB\"">\n+  <summary>\n+    The total content size in KB of all short-bypassed HTTP response bodies in\n+    the previous calendar day while the data reduction proxy setting was\n+    enabled. The metric is reported when the first response in the current day\n+    is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentLength_DataReductionProxyEnabled_Unknown\""\n+    units=\""KB\"">\n+  <summary>\n+    The total content size in KB of all HTTP response bodies for requests that\n+    were not served by the enabled data reduction proxy for unknown reasons in\n+    the previous calendar day while the data reduction proxy setting was\n+    enabled. The metric is reported when the first response in the current day\n+    is received.\n+  </summary>\n+</histogram>\n+\n <histogram name=\""Net.DailyContentLength_ViaDataReductionProxy\"" units=\""KB\"">\n   <summary>\n     The total content size in KB of all HTTP/HTTPS response bodies in the\n@@ -7773,6 +7813,47 @@ other types of suffix sets.\n   </summary>\n </histogram>\n \n+<histogram name=\""Net.DailyContentPercent_DataReductionProxyEnabled_Https\""\n+    units=\""Percent\"">\n+  <summary>\n+    The percentage of total HTTPS response body size while the data reduction\n+    proxy is enabled to total HTTP/HTTPS response body size in the previous\n+    calendar day. The metric is reported when the first response in the current\n+    day is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentPercent_DataReductionProxyEnabled_LongBypass\""\n+    units=\""Percent\"">\n+  <summary>\n+    The percentage of total long-bypassed response body size while the data\n+    reduction proxy is enabled to total HTTP/HTTPS response body size in the\n+    previous calendar day. The metric is reported when the first response in the\n+    current day is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentPercent_DataReductionProxyEnabled_ShortBypass\""\n+    units=\""Percent\"">\n+  <summary>\n+    The percentage of total short-bypassed response body size while the data\n+    reduction proxy is enabled to total HTTP/HTTPS response body size in the\n+    previous calendar day. The metric is reported when the first response in the\n+    current day is received.\n+  </summary>\n+</histogram>\n+\n+<histogram name=\""Net.DailyContentPercent_DataReductionProxyEnabled_Unknown\""\n+    units=\""Percent\"">\n+  <summary>\n+    The percentage of total body size of responses that were not served by the\n+    data reduction proxy for unknown reason while the data reduction proxy is\n+    enabled to total HTTP/HTTPS response body size in the previous calendar day.\n+    The metric is reported when the first response in the current day is\n+    received.\n+  </summary>\n+</histogram>\n+\n <histogram name=\""Net.DailyContentPercent_ViaDataReductionProxy\"" units=\""Percent\"">\n   <summary>\n     The percentage of total HTTP/HTTPS response body size via the data reduction""}","void IOThread::ChangedToOnTheRecordOnIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  ClearHostCache();
}
","void IOThread::ChangedToOnTheRecordOnIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  ClearHostCache();
}
",C,,,,"@@ -879,6 +879,14 @@ void IOThread::RegisterPrefs(PrefRegistrySimple* registry) {
       prefs::kDailyOriginalContentLengthWithDataReductionProxyEnabled);
   registry->RegisterListPref(
       prefs::kDailyContentLengthWithDataReductionProxyEnabled);
+  registry->RegisterListPref(
+      prefs::kDailyContentLengthHttpsWithDataReductionProxyEnabled);
+  registry->RegisterListPref(
+      prefs::kDailyContentLengthShortBypassWithDataReductionProxyEnabled);
+  registry->RegisterListPref(
+      prefs::kDailyContentLengthLongBypassWithDataReductionProxyEnabled);
+  registry->RegisterListPref(
+      prefs::kDailyContentLengthUnknownWithDataReductionProxyEnabled);
   registry->RegisterListPref(
       prefs::kDailyOriginalContentLengthViaDataReductionProxy);
   registry->RegisterListPref(",Chrome,828eab2216a765dea92575c290421c115b8ad028,bdba991c95e4fbd364a83112fe6ebbe8640b51be,0,"void IOThread::ChangedToOnTheRecordOnIOThread() {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

  // Clear the host cache to avoid showing entries from the OTR session
  // in about:net-internals.
  ClearHostCache();
}
"
151280,,Remote,Not required,Partial,CVE-2017-5009,https://www.cvedetails.com/cve/CVE-2017-5009/,CWE-119,Medium,Partial,Partial,,2017-02-17,6.8,"WebRTC in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, failed to perform proper bounds checking, which allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.",2018-01-04,Overflow ,0,https://github.com/chromium/chromium/commit/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60,1c40f9042ae2d6ee7483d72998aabb5e73b2ff60,"DevTools: send proper resource type in Network.RequestWillBeSent

This patch plumbs resoure type into the DispatchWillSendRequest
instrumenation. This allows us to report accurate type in
Network.RequestWillBeSent event, instead of ""Other"", that we report
today.

BUG=765501
R=dgozman

Change-Id: I0134c08b841e8dd247fdc8ff208bfd51e462709c
Reviewed-on: https://chromium-review.googlesource.com/667504
Reviewed-by: Pavel Feldman <pfeldman@chromium.org>
Reviewed-by: Dmitry Gozman <dgozman@chromium.org>
Commit-Queue: Andrey Lushnikov <lushnikov@chromium.org>
Cr-Commit-Position: refs/heads/master@{#507936}",0,third_party/WebKit/Source/core/inspector/InspectorPageAgent.cpp,"{""sha"": ""e0315835867b0b88b2fac25e800f67fc9c9ce7b2"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/devtools/network/network-imported-resource-content-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-imported-resource-content-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-imported-resource-content-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-imported-resource-content-expected.txt?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -1,7 +1,7 @@\n Tests content is available for imported resource request.\n \n http://127.0.0.1:8000/devtools/network/resources/imported.html\n-resource.type: other\n+resource.type: document\n resource.content after requesting content: Imported Resource\n \n ""}<_**next**_>{""sha"": ""0b33d5ac6006f5bc07ca28405f268f9e1352c270"", ""filename"": ""third_party/WebKit/LayoutTests/http/tests/devtools/network/network-request-type-expected.txt"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-request-type-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-request-type-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/http/tests/devtools/network/network-request-type-expected.txt?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -2,7 +2,7 @@ Tests that XHR request type is detected on send.\n \n \n Request: empty-script.js\n-Type: other\n+Type: script\n \n Request: empty.html?xhr\n Type: xhr""}<_**next**_>{""sha"": ""12490483010df8ccec38f4a8e347c7ea8ad37329"", ""filename"": ""third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type-expected.txt"", ""status"": ""modified"", ""additions"": 39, ""deletions"": 8, ""changes"": 47, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type-expected.txt"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type-expected.txt"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type-expected.txt?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -1,12 +1,43 @@\n Tests that responseReceived contains the documented resource types.\n Test started\n Network agent enabled\n-Resource /resources-page.html got type: Document, responseAvailable: false\n-Resource /stylesheet.css got type: Stylesheet, responseAvailable: true, responseEncoded: false\n-Resource /script.js got type: Script, responseAvailable: true, responseEncoded: false\n-Resource /abe.png got type: Image, responseAvailable: true, responseEncoded: true\n-Resource /test.wav got type: Media, responseAvailable: true, responseEncoded: true\n-Resource /test.ogv got type: Media, responseAvailable: true, responseEncoded: true\n-Resource /simple-captions.vtt got type: TextTrack, responseAvailable: true, responseEncoded: true\n-Resource /greenbox.png got type: XHR, responseAvailable: true, responseEncoded: true\n+Resource /resources-page.html:\n+  - request type: Document\n+  - response type: Document\n+  - responseAvailable: false\n+Resource /stylesheet.css:\n+  - request type: Stylesheet\n+  - response type: Stylesheet\n+  - responseAvailable: true\n+  - responseEncoded: false\n+Resource /script.js:\n+  - request type: Script\n+  - response type: Script\n+  - responseAvailable: true\n+  - responseEncoded: false\n+Resource /abe.png:\n+  - request type: Image\n+  - response type: Image\n+  - responseAvailable: true\n+  - responseEncoded: true\n+Resource /test.wav:\n+  - request type: Media\n+  - response type: Media\n+  - responseAvailable: true\n+  - responseEncoded: true\n+Resource /test.ogv:\n+  - request type: Media\n+  - response type: Media\n+  - responseAvailable: true\n+  - responseEncoded: true\n+Resource /simple-captions.vtt:\n+  - request type: TextTrack\n+  - response type: TextTrack\n+  - responseAvailable: true\n+  - responseEncoded: true\n+Resource /greenbox.png:\n+  - request type: XHR\n+  - response type: XHR\n+  - responseAvailable: true\n+  - responseEncoded: true\n ""}<_**next**_>{""sha"": ""9b599eda963c2360fcf59edaa5ad0c0e68be8c23"", ""filename"": ""third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type.js"", ""status"": ""modified"", ""additions"": 27, ""deletions"": 5, ""changes"": 32, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/inspector-protocol/network/resource-type.js?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -22,6 +22,23 @@\n   }\n   testRunner.log('Network agent enabled');\n \n+  dp.Network.onRequestWillBeSent(event => {\n+    var url = event.params.request.url;\n+    if (url.startsWith('blob'))\n+      return;\n+\n+    var type = event.params.type;\n+    for (var resource of resources) {\n+      if (!url.endsWith(resource.url))\n+        continue;\n+      if (resource.gotRequestType)\n+        testRunner.fail('FAIL: Requested resource ' + url + ' twice.');\n+      resource.gotRequestType = type;\n+      return;\n+    }\n+    testRunner.fail('FAIL: Requested unexpected resource ' + url);\n+  });\n+\n   dp.Network.onResponseReceived(event => {\n     var url = event.params.response.url;\n     if (url.indexOf('blob') === 0)\n@@ -35,7 +52,6 @@\n       if (resource.gotType)\n         testRunner.fail('FAIL: Received resource ' + url + ' twice.');\n       resource.gotType = type;\n-      resource.gotUrl = url;\n       resource.requestId = requestId;\n       return;\n     }\n@@ -64,10 +80,16 @@\n \n   function receivedAllResources() {\n     for (var resource of resources) {\n-        var description = 'Resource ' + resource.url + ' got type: ' + resource.gotType +  ', responseAvailable: ' + resource.responseAvailable;\n-        if (resource.responseAvailable)\n-            description += ', responseEncoded: ' + resource.responseEncoded;\n-        testRunner.log(description);\n+      var description = [\n+        'Resource ' + resource.url + ':',\n+        '  - request type: ' + resource.gotRequestType,\n+        '  - response type: ' + resource.gotType,\n+        '  - responseAvailable: ' + resource.responseAvailable\n+      ];\n+      if (resource.responseAvailable)\n+        description.push('  - responseEncoded: ' + resource.responseEncoded);\n+\n+      testRunner.log(description.join('\\n'));\n     }\n     testRunner.completeTest();\n   }""}<_**next**_>{""sha"": ""9ec2787fa02309b9692ada3e8f991d0c09cab597"", ""filename"": ""third_party/WebKit/Source/core/frame/PerformanceMonitor.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/frame/PerformanceMonitor.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/frame/PerformanceMonitor.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/frame/PerformanceMonitor.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -10,6 +10,7 @@\n #include \""core/frame/LocalFrame.h\""\n #include \""core/timing/SubTaskAttribution.h\""\n #include \""platform/heap/Handle.h\""\n+#include \""platform/loader/fetch/Resource.h\""\n #include \""platform/scheduler/base/task_time_observer.h\""\n #include \""platform/wtf/text/AtomicString.h\""\n #include \""public/platform/WebThread.h\""""}<_**next**_>{""sha"": ""2c2db350571e4eef34f4be5a1f3461b09e1965c5"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.cpp"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 15, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -581,10 +581,14 @@ void InspectorNetworkAgent::DidBlockRequest(\n     const ResourceRequest& request,\n     DocumentLoader* loader,\n     const FetchInitiatorInfo& initiator_info,\n-    ResourceRequestBlockedReason reason) {\n+    ResourceRequestBlockedReason reason,\n+    Resource::Type resource_type) {\n   unsigned long identifier = CreateUniqueIdentifier();\n+  InspectorPageAgent::ResourceType type =\n+      InspectorPageAgent::ToResourceType(resource_type);\n+\n   WillSendRequestInternal(execution_context, identifier, loader, request,\n-                          ResourceResponse(), initiator_info);\n+                          ResourceResponse(), initiator_info, type);\n \n   String request_id = IdentifiersFactory::RequestId(identifier);\n   String protocol_reason = BuildBlockedReason(reason);\n@@ -610,19 +614,15 @@ void InspectorNetworkAgent::WillSendRequestInternal(\n     DocumentLoader* loader,\n     const ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n-    const FetchInitiatorInfo& initiator_info) {\n+    const FetchInitiatorInfo& initiator_info,\n+    InspectorPageAgent::ResourceType type) {\n   String request_id = IdentifiersFactory::RequestId(identifier);\n   String loader_id = loader ? IdentifiersFactory::LoaderId(loader) : \""\"";\n   resources_data_->ResourceCreated(request_id, loader_id, request.Url());\n-\n-  InspectorPageAgent::ResourceType type = InspectorPageAgent::kOtherResource;\n-  if (initiator_info.name == FetchInitiatorTypeNames::xmlhttprequest) {\n+  if (initiator_info.name == FetchInitiatorTypeNames::xmlhttprequest)\n     type = InspectorPageAgent::kXHRResource;\n-    resources_data_->SetResourceType(request_id, type);\n-  } else if (initiator_info.name == FetchInitiatorTypeNames::document) {\n-    type = InspectorPageAgent::kDocumentResource;\n-    resources_data_->SetResourceType(request_id, type);\n-  }\n+\n+  resources_data_->SetResourceType(request_id, type);\n \n   String frame_id = loader && loader->GetFrame()\n                         ? IdentifiersFactory::FrameId(loader->GetFrame())\n@@ -678,7 +678,8 @@ void InspectorNetworkAgent::WillSendRequest(\n     DocumentLoader* loader,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n-    const FetchInitiatorInfo& initiator_info) {\n+    const FetchInitiatorInfo& initiator_info,\n+    Resource::Type resource_type) {\n   // Ignore the request initiated internally.\n   if (initiator_info.name == FetchInitiatorTypeNames::internal)\n     return;\n@@ -713,8 +714,11 @@ void InspectorNetworkAgent::WillSendRequest(\n   if (state_->booleanProperty(NetworkAgentState::kBypassServiceWorker, false))\n     request.SetServiceWorkerMode(WebURLRequest::ServiceWorkerMode::kNone);\n \n+  InspectorPageAgent::ResourceType type =\n+      InspectorPageAgent::ToResourceType(resource_type);\n+\n   WillSendRequestInternal(execution_context, identifier, loader, request,\n-                          redirect_response, initiator_info);\n+                          redirect_response, initiator_info, type);\n \n   if (!host_id_.IsEmpty()) {\n     request.AddHTTPHeaderField(\n@@ -742,8 +746,9 @@ void InspectorNetworkAgent::DidReceiveResourceResponse(\n                                      &resource_is_empty);\n \n   InspectorPageAgent::ResourceType type =\n-      cached_resource ? InspectorPageAgent::CachedResourceType(*cached_resource)\n-                      : InspectorPageAgent::kOtherResource;\n+      cached_resource\n+          ? InspectorPageAgent::ToResourceType(cached_resource->GetType())\n+          : InspectorPageAgent::kOtherResource;\n   // Override with already discovered resource type.\n   InspectorPageAgent::ResourceType saved_type =\n       resources_data_->GetResourceType(request_id);""}<_**next**_>{""sha"": ""058a85e393e622113a2431a37a21515db4cfd80f"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 3, ""changes"": 10, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorNetworkAgent.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""core/inspector/InspectorPageAgent.h\""\n #include \""core/inspector/protocol/Network.h\""\n #include \""platform/heap/Handle.h\""\n+#include \""platform/loader/fetch/Resource.h\""\n #include \""platform/wtf/text/WTFString.h\""\n \n namespace blink {\n@@ -84,15 +85,17 @@ class CORE_EXPORT InspectorNetworkAgent final\n                        const ResourceRequest&,\n                        DocumentLoader*,\n                        const FetchInitiatorInfo&,\n-                       ResourceRequestBlockedReason);\n+                       ResourceRequestBlockedReason,\n+                       Resource::Type);\n   void DidChangeResourcePriority(unsigned long identifier,\n                                  ResourceLoadPriority);\n   void WillSendRequest(ExecutionContext*,\n                        unsigned long identifier,\n                        DocumentLoader*,\n                        ResourceRequest&,\n                        const ResourceResponse& redirect_response,\n-                       const FetchInitiatorInfo&);\n+                       const FetchInitiatorInfo&,\n+                       Resource::Type);\n   void MarkResourceAsCached(unsigned long identifier);\n   void DidReceiveResourceResponse(unsigned long identifier,\n                                   DocumentLoader*,\n@@ -246,7 +249,8 @@ class CORE_EXPORT InspectorNetworkAgent final\n                                DocumentLoader*,\n                                const ResourceRequest&,\n                                const ResourceResponse& redirect_response,\n-                               const FetchInitiatorInfo&);\n+                               const FetchInitiatorInfo&,\n+                               InspectorPageAgent::ResourceType);\n   void DelayedRemoveReplayXHR(XMLHttpRequest*);\n   void RemoveFinishedReplayXHRFired(TimerBase*);\n   void DidFinishXHRInternal(ExecutionContext*,""}<_**next**_>{""sha"": ""1a6fed53c058a9ec9819a063191e2e4c6214d56e"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorPageAgent.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorPageAgent.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorPageAgent.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorPageAgent.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -363,9 +363,9 @@ String InspectorPageAgent::ResourceTypeJson(\n   return protocol::Page::ResourceTypeEnum::Other;\n }\n \n-InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType(\n-    const Resource& cached_resource) {\n-  switch (cached_resource.GetType()) {\n+InspectorPageAgent::ResourceType InspectorPageAgent::ToResourceType(\n+    const Resource::Type resource_type) {\n+  switch (resource_type) {\n     case Resource::kImage:\n       return InspectorPageAgent::kImageResource;\n     case Resource::kFont:\n@@ -394,7 +394,7 @@ InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType(\n \n String InspectorPageAgent::CachedResourceTypeJson(\n     const Resource& cached_resource) {\n-  return ResourceTypeJson(CachedResourceType(cached_resource));\n+  return ResourceTypeJson(ToResourceType(cached_resource.GetType()));\n }\n \n InspectorPageAgent::InspectorPageAgent(""}<_**next**_>{""sha"": ""0c893acaa79fb3af8dd1e8af4c7521c45b39ed24"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorPageAgent.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorPageAgent.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorPageAgent.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorPageAgent.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -35,6 +35,7 @@\n #include \""core/inspector/InspectorBaseAgent.h\""\n #include \""core/inspector/protocol/Page.h\""\n #include \""core/page/ChromeClient.h\""\n+#include \""platform/loader/fetch/Resource.h\""\n #include \""platform/wtf/HashMap.h\""\n #include \""platform/wtf/text/WTFString.h\""\n #include \""v8/include/v8-inspector.h\""\n@@ -101,7 +102,7 @@ class CORE_EXPORT InspectorPageAgent final\n                                   bool* base64_encoded);\n \n   static String ResourceTypeJson(ResourceType);\n-  static ResourceType CachedResourceType(const Resource&);\n+  static ResourceType ToResourceType(const Resource::Type);\n   static String CachedResourceTypeJson(const Resource&);\n \n   // Page API for frontend""}<_**next**_>{""sha"": ""36828b7d5da9c9705b570802753dc07068f97457"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorTraceEvents.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -114,7 +114,8 @@ void InspectorTraceEvents::WillSendRequest(\n     DocumentLoader* loader,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n-    const FetchInitiatorInfo&) {\n+    const FetchInitiatorInfo&,\n+    Resource::Type) {\n   LocalFrame* frame = loader ? loader->GetFrame() : nullptr;\n   TRACE_EVENT_INSTANT1(\n       \""devtools.timeline\"", \""ResourceSendRequest\"", TRACE_EVENT_SCOPE_THREAD,""}<_**next**_>{""sha"": ""b2d151df4fbed92c4256a4b827fda4819ed4fb61"", ""filename"": ""third_party/WebKit/Source/core/inspector/InspectorTraceEvents.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/inspector/InspectorTraceEvents.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -13,6 +13,7 @@\n #include \""platform/heap/Handle.h\""\n #include \""platform/instrumentation/tracing/TraceEvent.h\""\n #include \""platform/instrumentation/tracing/TracedValue.h\""\n+#include \""platform/loader/fetch/Resource.h\""\n #include \""platform/loader/fetch/ResourceLoadPriority.h\""\n #include \""platform/wtf/Forward.h\""\n #include \""platform/wtf/Functional.h\""\n@@ -81,7 +82,8 @@ class CORE_EXPORT InspectorTraceEvents : public InspectorAgent {\n                        DocumentLoader*,\n                        ResourceRequest&,\n                        const ResourceResponse& redirect_response,\n-                       const FetchInitiatorInfo&);\n+                       const FetchInitiatorInfo&,\n+                       Resource::Type);\n   void DidReceiveResourceResponse(unsigned long identifier,\n                                   DocumentLoader*,\n                                   const ResourceResponse&,""}<_**next**_>{""sha"": ""b3295082cde715e4b6f1e5910461ccbcfca34575"", ""filename"": ""third_party/WebKit/Source/core/loader/BaseFetchContext.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContext.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContext.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/BaseFetchContext.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -58,7 +58,7 @@ ResourceRequestBlockedReason BaseFetchContext::CanRequest(\n   if (blocked_reason != ResourceRequestBlockedReason::kNone &&\n       reporting_policy == SecurityViolationReportingPolicy::kReport) {\n     DispatchDidBlockRequest(resource_request, options.initiator_info,\n-                            blocked_reason);\n+                            blocked_reason, type);\n   }\n   return blocked_reason;\n }""}<_**next**_>{""sha"": ""cc193e1d530b7791d0f62a08e815c99693fe2053"", ""filename"": ""third_party/WebKit/Source/core/loader/BaseFetchContext.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContext.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContext.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/BaseFetchContext.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -64,7 +64,8 @@ class CORE_EXPORT BaseFetchContext : public FetchContext {\n   virtual bool ShouldBlockRequestByInspector(const KURL&) const = 0;\n   virtual void DispatchDidBlockRequest(const ResourceRequest&,\n                                        const FetchInitiatorInfo&,\n-                                       ResourceRequestBlockedReason) const = 0;\n+                                       ResourceRequestBlockedReason,\n+                                       Resource::Type) const = 0;\n   virtual bool ShouldBypassMainWorldCSP() const = 0;\n   virtual bool IsSVGImageChromeClient() const = 0;\n   virtual bool ShouldBlockFetchByMixedContentCheck(""}<_**next**_>{""sha"": ""8a4b910ab89174d8309c272bcc268445649ab69a"", ""filename"": ""third_party/WebKit/Source/core/loader/BaseFetchContextTest.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContextTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/BaseFetchContextTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/BaseFetchContextTest.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -52,7 +52,8 @@ class MockBaseFetchContext final : public BaseFetchContext {\n   }\n   void DispatchDidBlockRequest(const ResourceRequest&,\n                                const FetchInitiatorInfo&,\n-                               ResourceRequestBlockedReason) const override {}\n+                               ResourceRequestBlockedReason,\n+                               Resource::Type) const override {}\n   bool ShouldBypassMainWorldCSP() const override { return false; }\n   bool IsSVGImageChromeClient() const override { return false; }\n   void CountUsage(WebFeature) const override {}""}<_**next**_>{""sha"": ""a3c9b3a8c577033c07685feeb87eaa3ac54cf285"", ""filename"": ""third_party/WebKit/Source/core/loader/FrameFetchContext.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/FrameFetchContext.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -448,6 +448,7 @@ void FrameFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n+    Resource::Type resource_type,\n     const FetchInitiatorInfo& initiator_info) {\n   if (IsDetached())\n     return;\n@@ -460,7 +461,7 @@ void FrameFetchContext::DispatchWillSendRequest(\n   }\n   probe::willSendRequest(GetFrame()->GetDocument(), identifier,\n                          MasterDocumentLoader(), request, redirect_response,\n-                         initiator_info);\n+                         initiator_info, resource_type);\n   if (IdlenessDetector* idleness_detector = GetFrame()->GetIdlenessDetector())\n     idleness_detector->OnWillSendRequest();\n   if (GetFrame()->FrameScheduler())\n@@ -931,12 +932,13 @@ bool FrameFetchContext::ShouldBlockRequestByInspector(const KURL& url) const {\n void FrameFetchContext::DispatchDidBlockRequest(\n     const ResourceRequest& resource_request,\n     const FetchInitiatorInfo& fetch_initiator_info,\n-    ResourceRequestBlockedReason blocked_reason) const {\n+    ResourceRequestBlockedReason blocked_reason,\n+    Resource::Type resource_type) const {\n   if (IsDetached())\n     return;\n   probe::didBlockRequest(GetFrame()->GetDocument(), resource_request,\n                          MasterDocumentLoader(), fetch_initiator_info,\n-                         blocked_reason);\n+                         blocked_reason, resource_type);\n }\n \n bool FrameFetchContext::ShouldBypassMainWorldCSP() const {""}<_**next**_>{""sha"": ""28c69fd0de724a65c101cf5255435fc4a35dc8e2"", ""filename"": ""third_party/WebKit/Source/core/loader/FrameFetchContext.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContext.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContext.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/FrameFetchContext.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -88,6 +88,7 @@ class CORE_EXPORT FrameFetchContext final : public BaseFetchContext {\n       unsigned long identifier,\n       ResourceRequest&,\n       const ResourceResponse& redirect_response,\n+      Resource::Type,\n       const FetchInitiatorInfo& = FetchInitiatorInfo()) override;\n   void DispatchDidLoadResourceFromMemoryCache(unsigned long identifier,\n                                               const ResourceRequest&,\n@@ -187,7 +188,8 @@ class CORE_EXPORT FrameFetchContext final : public BaseFetchContext {\n   bool ShouldBlockRequestByInspector(const KURL&) const override;\n   void DispatchDidBlockRequest(const ResourceRequest&,\n                                const FetchInitiatorInfo&,\n-                               ResourceRequestBlockedReason) const override;\n+                               ResourceRequestBlockedReason,\n+                               Resource::Type) const override;\n   bool ShouldBypassMainWorldCSP() const override;\n   bool IsSVGImageChromeClient() const override;\n   void CountUsage(WebFeature) const override;""}<_**next**_>{""sha"": ""53f7490da151e72c441ed8501478187fe3a0b6b8"", ""filename"": ""third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/FrameFetchContextTest.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -1020,7 +1020,8 @@ TEST_F(FrameFetchContextTest, DispatchWillSendRequestWhenDetached) {\n \n   dummy_page_holder = nullptr;\n \n-  fetch_context->DispatchWillSendRequest(1, request, response, initiator_info);\n+  fetch_context->DispatchWillSendRequest(1, request, response, Resource::kRaw,\n+                                         initiator_info);\n   // Should not crash.\n }\n ""}<_**next**_>{""sha"": ""41bca30425ea1c9cc211ca9e247300aca3c0bb98"", ""filename"": ""third_party/WebKit/Source/core/loader/WorkerFetchContext.cpp"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/WorkerFetchContext.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/WorkerFetchContext.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/WorkerFetchContext.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -123,9 +123,10 @@ bool WorkerFetchContext::ShouldBlockRequestByInspector(const KURL& url) const {\n void WorkerFetchContext::DispatchDidBlockRequest(\n     const ResourceRequest& resource_request,\n     const FetchInitiatorInfo& fetch_initiator_info,\n-    ResourceRequestBlockedReason blocked_reason) const {\n+    ResourceRequestBlockedReason blocked_reason,\n+    Resource::Type resource_type) const {\n   probe::didBlockRequest(global_scope_, resource_request, nullptr,\n-                         fetch_initiator_info, blocked_reason);\n+                         fetch_initiator_info, blocked_reason, resource_type);\n }\n \n bool WorkerFetchContext::ShouldBypassMainWorldCSP() const {\n@@ -259,9 +260,10 @@ void WorkerFetchContext::DispatchWillSendRequest(\n     unsigned long identifier,\n     ResourceRequest& request,\n     const ResourceResponse& redirect_response,\n+    Resource::Type resource_type,\n     const FetchInitiatorInfo& initiator_info) {\n   probe::willSendRequest(global_scope_, identifier, nullptr, request,\n-                         redirect_response, initiator_info);\n+                         redirect_response, initiator_info, resource_type);\n }\n \n void WorkerFetchContext::DispatchDidReceiveResponse(""}<_**next**_>{""sha"": ""7e4c2068233a81a9c41813f846edc21bd980774e"", ""filename"": ""third_party/WebKit/Source/core/loader/WorkerFetchContext.h"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 1, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/WorkerFetchContext.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/loader/WorkerFetchContext.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/loader/WorkerFetchContext.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -39,7 +39,8 @@ class WorkerFetchContext final : public BaseFetchContext {\n   bool ShouldBlockRequestByInspector(const KURL&) const override;\n   void DispatchDidBlockRequest(const ResourceRequest&,\n                                const FetchInitiatorInfo&,\n-                               ResourceRequestBlockedReason) const override;\n+                               ResourceRequestBlockedReason,\n+                               Resource::Type) const override;\n   bool ShouldBypassMainWorldCSP() const override;\n   bool IsSVGImageChromeClient() const override;\n   void CountUsage(WebFeature) const override;\n@@ -72,6 +73,7 @@ class WorkerFetchContext final : public BaseFetchContext {\n   void DispatchWillSendRequest(unsigned long,\n                                ResourceRequest&,\n                                const ResourceResponse&,\n+                               Resource::Type,\n                                const FetchInitiatorInfo&) override;\n   void DispatchDidReceiveResponse(unsigned long identifier,\n                                   const ResourceResponse&,""}<_**next**_>{""sha"": ""270667c0c6c88a1f7df1eae4681af8d5dd1abd4f"", ""filename"": ""third_party/WebKit/Source/core/probe/CoreProbes.pidl"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/probe/CoreProbes.pidl"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/core/probe/CoreProbes.pidl"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/probe/CoreProbes.pidl?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -87,9 +87,9 @@ interface CoreProbes {\n   void didResizeMainFrame(LocalFrame*);\n   void didPaint(LocalFrame*, const GraphicsLayer*, GraphicsContext&, const LayoutRect&);\n   void applyUserAgentOverride(ExecutionContext*, String* userAgent);\n-  void didBlockRequest([Keep] ExecutionContext*, const ResourceRequest&, DocumentLoader*, const FetchInitiatorInfo&, ResourceRequestBlockedReason);\n+  void didBlockRequest([Keep] ExecutionContext*, const ResourceRequest&, DocumentLoader*, const FetchInitiatorInfo&, ResourceRequestBlockedReason, Resource::Type);\n   void didChangeResourcePriority(LocalFrame*, unsigned long identifier, ResourceLoadPriority loadPriority);\n-  void willSendRequest([Keep] ExecutionContext*, unsigned long identifier, DocumentLoader*, ResourceRequest&, const ResourceResponse& redirectResponse, const FetchInitiatorInfo&);\n+  void willSendRequest([Keep] ExecutionContext*, unsigned long identifier, DocumentLoader*, ResourceRequest&, const ResourceResponse& redirectResponse, const FetchInitiatorInfo&, Resource::Type);\n   void markResourceAsCached(LocalFrame*, unsigned long identifier);\n   void didReceiveResourceResponse(ExecutionContext*, unsigned long identifier, DocumentLoader*, const ResourceResponse&, Resource*);\n   void didReceiveData(ExecutionContext*, unsigned long identifier, DocumentLoader*, const char* data, int dataLength);""}<_**next**_>{""sha"": ""c8c99ea41697028ec81bbd68158659004bef02b0"", ""filename"": ""third_party/WebKit/Source/platform/loader/fetch/FetchContext.cpp"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/FetchContext.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/FetchContext.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/loader/fetch/FetchContext.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -69,6 +69,7 @@ void FetchContext::PrepareRequest(ResourceRequest&, RedirectType) {}\n void FetchContext::DispatchWillSendRequest(unsigned long,\n                                            ResourceRequest&,\n                                            const ResourceResponse&,\n+                                           Resource::Type,\n                                            const FetchInitiatorInfo&) {}\n \n void FetchContext::DispatchDidLoadResourceFromMemoryCache(""}<_**next**_>{""sha"": ""5b6db73befec12e3f4147ab759ddbfeb160a5c6e"", ""filename"": ""third_party/WebKit/Source/platform/loader/fetch/FetchContext.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/FetchContext.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/FetchContext.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/loader/fetch/FetchContext.h?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -118,6 +118,7 @@ class PLATFORM_EXPORT FetchContext\n       unsigned long identifier,\n       ResourceRequest&,\n       const ResourceResponse& redirect_response,\n+      Resource::Type,\n       const FetchInitiatorInfo& = FetchInitiatorInfo());\n   virtual void DispatchDidLoadResourceFromMemoryCache(unsigned long identifier,\n                                                       const ResourceRequest&,""}<_**next**_>{""sha"": ""466135acb0c3235164c6d753b3b3053b1b19b10a"", ""filename"": ""third_party/WebKit/Source/platform/loader/fetch/ResourceFetcher.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 3, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/ResourceFetcher.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/ResourceFetcher.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/loader/fetch/ResourceFetcher.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -368,9 +368,9 @@ void ResourceFetcher::DidLoadResourceFromMemoryCache(\n       original_resource_request.GetRequestContext());\n   Context().DispatchDidLoadResourceFromMemoryCache(identifier, resource_request,\n                                                    resource->GetResponse());\n-  Context().DispatchWillSendRequest(identifier, resource_request,\n-                                    ResourceResponse() /* redirects */,\n-                                    resource->Options().initiator_info);\n+  Context().DispatchWillSendRequest(\n+      identifier, resource_request, ResourceResponse() /* redirects */,\n+      resource->GetType(), resource->Options().initiator_info);\n   Context().DispatchDidReceiveResponse(\n       identifier, resource->GetResponse(), resource_request.GetFrameType(),\n       resource_request.GetRequestContext(), resource,\n@@ -1430,6 +1430,7 @@ bool ResourceFetcher::StartLoad(Resource* resource) {\n                                             resource->Options().initiator_info);\n \n     Context().DispatchWillSendRequest(resource->Identifier(), request, response,\n+                                      resource->GetType(),\n                                       resource->Options().initiator_info);\n \n     // Resource requests from suborigins should not be intercepted by the""}<_**next**_>{""sha"": ""ed56f4092c53c54dddd409ac5d0ab94543cf9726"", ""filename"": ""third_party/WebKit/Source/platform/loader/fetch/ResourceLoader.cpp"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/ResourceLoader.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/1c40f9042ae2d6ee7483d72998aabb5e73b2ff60/third_party/WebKit/Source/platform/loader/fetch/ResourceLoader.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/platform/loader/fetch/ResourceLoader.cpp?ref=1c40f9042ae2d6ee7483d72998aabb5e73b2ff60"", ""patch"": ""@@ -364,7 +364,8 @@ bool ResourceLoader::WillFollowRedirect(\n   Context().PrepareRequest(new_request,\n                            FetchContext::RedirectType::kForRedirect);\n   Context().DispatchWillSendRequest(resource_->Identifier(), new_request,\n-                                    redirect_response, options.initiator_info);\n+                                    redirect_response, resource_->GetType(),\n+                                    options.initiator_info);\n \n   // First-party cookie logic moved from DocumentLoader in Blink to\n   // net::URLRequest in the browser. Assert that Blink didn't try to change it""}","Response InspectorPageAgent::setAutoAttachToCreatedPages(bool auto_attach) {
  state_->setBoolean(PageAgentState::kAutoAttachToCreatedPages, auto_attach);
  return Response::OK();
}
","Response InspectorPageAgent::setAutoAttachToCreatedPages(bool auto_attach) {
  state_->setBoolean(PageAgentState::kAutoAttachToCreatedPages, auto_attach);
  return Response::OK();
}
",C,,,,"@@ -363,9 +363,9 @@ String InspectorPageAgent::ResourceTypeJson(
   return protocol::Page::ResourceTypeEnum::Other;
 }
 
-InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType(
-    const Resource& cached_resource) {
-  switch (cached_resource.GetType()) {
+InspectorPageAgent::ResourceType InspectorPageAgent::ToResourceType(
+    const Resource::Type resource_type) {
+  switch (resource_type) {
     case Resource::kImage:
       return InspectorPageAgent::kImageResource;
     case Resource::kFont:
@@ -394,7 +394,7 @@ InspectorPageAgent::ResourceType InspectorPageAgent::CachedResourceType(
 
 String InspectorPageAgent::CachedResourceTypeJson(
     const Resource& cached_resource) {
-  return ResourceTypeJson(CachedResourceType(cached_resource));
+  return ResourceTypeJson(ToResourceType(cached_resource.GetType()));
 }
 
 InspectorPageAgent::InspectorPageAgent(",Chrome,1c40f9042ae2d6ee7483d72998aabb5e73b2ff60,1fab25bdd1a38c7f760dee27b06348257e0d0971,0,"Response InspectorPageAgent::setAutoAttachToCreatedPages(bool auto_attach) {
  state_->setBoolean(PageAgentState::kAutoAttachToCreatedPages, auto_attach);
  return Response::OK();
}
"
6213,,Remote,Not required,Partial,CVE-2015-0286,https://www.cvedetails.com/cve/CVE-2015-0286/,CWE-17,Low,,,,2015-03-19,5.0,"The ASN1_TYPE_cmp function in crypto/asn1/a_type.c in OpenSSL before 0.9.8zf, 1.0.0 before 1.0.0r, 1.0.1 before 1.0.1m, and 1.0.2 before 1.0.2a does not properly perform boolean-type comparisons, which allows remote attackers to cause a denial of service (invalid read operation and application crash) via a crafted X.509 certificate to an endpoint that uses the certificate-verification feature.",2018-01-04,DoS,0,https://git.openssl.org/?p=openssl.git;a=commit;h=c3c7fb07dc975dc3c9de0eddb7d8fd79fc9c67c1,c3c7fb07dc975dc3c9de0eddb7d8fd79fc9c67c1,,0,,,"int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)
{
    if (!value || (type == V_ASN1_BOOLEAN)) {
        void *p = (void *)value;
        ASN1_TYPE_set(a, type, p);
    } else if (type == V_ASN1_OBJECT) {
        ASN1_OBJECT *odup;
        odup = OBJ_dup(value);
        if (!odup)
            return 0;
        ASN1_TYPE_set(a, type, odup);
    } else {
        ASN1_STRING *sdup;
        sdup = ASN1_STRING_dup(value);
        if (!sdup)
            return 0;
        ASN1_TYPE_set(a, type, sdup);
    }
    return 1;
}
","int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)
{
    if (!value || (type == V_ASN1_BOOLEAN)) {
        void *p = (void *)value;
        ASN1_TYPE_set(a, type, p);
    } else if (type == V_ASN1_OBJECT) {
        ASN1_OBJECT *odup;
        odup = OBJ_dup(value);
        if (!odup)
            return 0;
        ASN1_TYPE_set(a, type, odup);
    } else {
        ASN1_STRING *sdup;
        sdup = ASN1_STRING_dup(value);
        if (!sdup)
            return 0;
        ASN1_TYPE_set(a, type, sdup);
    }
    return 1;
}
",C,,,b19d8143212ae5fbc9cebfd51c01f802fabccd33,"@@ -119,6 +119,9 @@ int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b)
     case V_ASN1_OBJECT:
         result = OBJ_cmp(a->value.object, b->value.object);
         break;
+    case V_ASN1_BOOLEAN:
+        result = a->value.boolean - b->value.boolean;
+        break;
     case V_ASN1_NULL:
         result = 0;             /* They do not have content. */
         break;",openssl,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/a_type.c;h=af795306b5bf58da19fbd53328992eee8baee44a;hb=af795306b5bf58da19fbd53328992eee8baee44a,https://git.openssl.org/?p=openssl.git;a=blob;f=crypto/asn1/a_type.c;h=4a36aff6acc099e7dd18abdf3297bce35588f307;hb=4a36aff6acc099e7dd18abdf3297bce35588f307,0,"int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value)
{
    if (!value || (type == V_ASN1_BOOLEAN)) {
        void *p = (void *)value;
        ASN1_TYPE_set(a, type, p);
    } else if (type == V_ASN1_OBJECT) {
        ASN1_OBJECT *odup;
        odup = OBJ_dup(value);
        if (!odup)
            return 0;
        ASN1_TYPE_set(a, type, odup);
    } else {
        ASN1_STRING *sdup;
        sdup = ASN1_STRING_dup(value);
        if (!sdup)
            return 0;
        ASN1_TYPE_set(a, type, sdup);
    }
    return 1;
}
"
92717,,Remote,Not required,Partial,CVE-2018-20784,https://www.cvedetails.com/cve/CVE-2018-20784/,CWE-400,Low,Partial,Partial,,2019-02-22,7.5,"In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.",2019-07-30,DoS ,0,https://github.com/torvalds/linux/commit/c40f7d74c741a907cfaeb73a7697081881c497d0,c40f7d74c741a907cfaeb73a7697081881c497d0,"sched/fair: Fix infinite loop in update_blocked_averages() by reverting a9e7f6544b9c

Zhipeng Xie, Xie XiuQi and Sargun Dhillon reported lockups in the
scheduler under high loads, starting at around the v4.18 time frame,
and Zhipeng Xie tracked it down to bugs in the rq->leaf_cfs_rq_list
manipulation.

Do a (manual) revert of:

  a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")

It turns out that the list_del_leaf_cfs_rq() introduced by this commit
is a surprising property that was not considered in followup commits
such as:

  9c2791f936ef (""sched/fair: Fix hierarchical order in rq->leaf_cfs_rq_list"")

As Vincent Guittot explains:

 ""I think that there is a bigger problem with commit a9e7f6544b9c and
  cfs_rq throttling:

  Let take the example of the following topology TG2 --> TG1 --> root:

   1) The 1st time a task is enqueued, we will add TG2 cfs_rq then TG1
      cfs_rq to leaf_cfs_rq_list and we are sure to do the whole branch in
      one path because it has never been used and can't be throttled so
      tmp_alone_branch will point to leaf_cfs_rq_list at the end.

   2) Then TG1 is throttled

   3) and we add TG3 as a new child of TG1.

   4) The 1st enqueue of a task on TG3 will add TG3 cfs_rq just before TG1
      cfs_rq and tmp_alone_branch will stay  on rq->leaf_cfs_rq_list.

  With commit a9e7f6544b9c, we can del a cfs_rq from rq->leaf_cfs_rq_list.
  So if the load of TG1 cfs_rq becomes NULL before step 2) above, TG1
  cfs_rq is removed from the list.
  Then at step 4), TG3 cfs_rq is added at the beginning of rq->leaf_cfs_rq_list
  but tmp_alone_branch still points to TG3 cfs_rq because its throttled
  parent can't be enqueued when the lock is released.
  tmp_alone_branch doesn't point to rq->leaf_cfs_rq_list whereas it should.

  So if TG3 cfs_rq is removed or destroyed before tmp_alone_branch
  points on another TG cfs_rq, the next TG cfs_rq that will be added,
  will be linked outside rq->leaf_cfs_rq_list - which is bad.

  In addition, we can break the ordering of the cfs_rq in
  rq->leaf_cfs_rq_list but this ordering is used to update and
  propagate the update from leaf down to root.""

Instead of trying to work through all these cases and trying to reproduce
the very high loads that produced the lockup to begin with, simplify
the code temporarily by reverting a9e7f6544b9c - which change was clearly
not thought through completely.

This (hopefully) gives us a kernel that doesn't lock up so people
can continue to enjoy their holidays without worrying about regressions. ;-)

[ mingo: Wrote changelog, fixed weird spelling in code comment while at it. ]

Analyzed-by: Xie XiuQi <xiexiuqi@huawei.com>
Analyzed-by: Vincent Guittot <vincent.guittot@linaro.org>
Reported-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Reported-by: Sargun Dhillon <sargun@sargun.me>
Reported-by: Xie XiuQi <xiexiuqi@huawei.com>
Tested-by: Zhipeng Xie <xiezhipeng1@huawei.com>
Tested-by: Sargun Dhillon <sargun@sargun.me>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Acked-by: Vincent Guittot <vincent.guittot@linaro.org>
Cc: <stable@vger.kernel.org> # v4.13+
Cc: Bin Li <huawei.libin@huawei.com>
Cc: Mike Galbraith <efault@gmx.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Tejun Heo <tj@kernel.org>
Cc: Thomas Gleixner <tglx@linutronix.de>
Fixes: a9e7f6544b9c (""sched/fair: Fix O(nr_cgroups) in load balance path"")
Link: http://lkml.kernel.org/r/1545879866-27809-1-git-send-email-xiexiuqi@huawei.com
Signed-off-by: Ingo Molnar <mingo@kernel.org>",0,kernel/sched/fair.c,"{""sha"": ""6483834f12788f80633c96e89d5cf874525a52e7"", ""filename"": ""kernel/sched/fair.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 34, ""changes"": 43, ""blob_url"": ""https://github.com/torvalds/linux/blob/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c40f7d74c741a907cfaeb73a7697081881c497d0/kernel/sched/fair.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/kernel/sched/fair.c?ref=c40f7d74c741a907cfaeb73a7697081881c497d0"", ""patch"": ""@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n \t}\n }\n \n-/* Iterate thr' all leaf cfs_rq's on a runqueue */\n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\t\t\\\n-\tlist_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,\t\\\n-\t\t\t\t leaf_cfs_rq_list)\n+/* Iterate through all leaf cfs_rq's on a runqueue: */\n+#define for_each_leaf_cfs_rq(rq, cfs_rq) \\\n+\tlist_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)\n \n /* Do the two (enqueued) entities belong to the same group ? */\n static inline struct cfs_rq *\n@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n {\n }\n \n-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)\t\\\n-\t\tfor (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)\n+#define for_each_leaf_cfs_rq(rq, cfs_rq)\t\\\n+\t\tfor (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)\n \n static inline struct sched_entity *parent_entity(struct sched_entity *se)\n {\n@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)\n \n #ifdef CONFIG_FAIR_GROUP_SCHED\n \n-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n-{\n-\tif (cfs_rq->load.weight)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.load_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.util_sum)\n-\t\treturn false;\n-\n-\tif (cfs_rq->avg.runnable_load_sum)\n-\t\treturn false;\n-\n-\treturn true;\n-}\n-\n static void update_blocked_averages(int cpu)\n {\n \tstruct rq *rq = cpu_rq(cpu);\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \tconst struct sched_class *curr_class;\n \tstruct rq_flags rf;\n \tbool done = true;\n@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)\n \t * Iterates the task_group tree in a bottom up fashion, see\n \t * list_add_leaf_cfs_rq() for details.\n \t */\n-\tfor_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {\n+\tfor_each_leaf_cfs_rq(rq, cfs_rq) {\n \t\tstruct sched_entity *se;\n \n \t\t/* throttled entities do not contribute to load */\n@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)\n \t\tif (se && !skip_blocked_update(se))\n \t\t\tupdate_load_avg(cfs_rq_of(se), se, 0);\n \n-\t\t/*\n-\t\t * There can be a lot of idle CPU cgroups.  Don't let fully\n-\t\t * decayed cfs_rqs linger on the list.\n-\t\t */\n-\t\tif (cfs_rq_is_decayed(cfs_rq))\n-\t\t\tlist_del_leaf_cfs_rq(cfs_rq);\n-\n \t\t/* Don't need periodic decay once load/util_avg are null */\n \t\tif (cfs_rq_has_blocked(cfs_rq))\n \t\t\tdone = false;\n@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {\n #ifdef CONFIG_SCHED_DEBUG\n void print_cfs_stats(struct seq_file *m, int cpu)\n {\n-\tstruct cfs_rq *cfs_rq, *pos;\n+\tstruct cfs_rq *cfs_rq;\n \n \trcu_read_lock();\n-\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n+\tfor_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)\n \t\tprint_cfs_rq(m, cpu, cfs_rq);\n \trcu_read_unlock();\n }""}","static void task_numa_placement(struct task_struct *p)
{
	int seq, nid, max_nid = -1;
	unsigned long max_faults = 0;
	unsigned long fault_types[2] = { 0, 0 };
	unsigned long total_faults;
	u64 runtime, period;
	spinlock_t *group_lock = NULL;

	/*
	 * The p->mm->numa_scan_seq field gets updated without
	 * exclusive access. Use READ_ONCE() here to ensure
	 * that the field is read in a single access:
	 */
	seq = READ_ONCE(p->mm->numa_scan_seq);
	if (p->numa_scan_seq == seq)
		return;
	p->numa_scan_seq = seq;
	p->numa_scan_period_max = task_scan_max(p);

	total_faults = p->numa_faults_locality[0] +
		       p->numa_faults_locality[1];
	runtime = numa_get_avg_runtime(p, &period);

	/* If the task is part of a group prevent parallel updates to group stats */
	if (p->numa_group) {
		group_lock = &p->numa_group->lock;
		spin_lock_irq(group_lock);
	}

	/* Find the node with the highest number of faults */
	for_each_online_node(nid) {
		/* Keep track of the offsets in numa_faults array */
		int mem_idx, membuf_idx, cpu_idx, cpubuf_idx;
		unsigned long faults = 0, group_faults = 0;
		int priv;

		for (priv = 0; priv < NR_NUMA_HINT_FAULT_TYPES; priv++) {
			long diff, f_diff, f_weight;

			mem_idx = task_faults_idx(NUMA_MEM, nid, priv);
			membuf_idx = task_faults_idx(NUMA_MEMBUF, nid, priv);
			cpu_idx = task_faults_idx(NUMA_CPU, nid, priv);
			cpubuf_idx = task_faults_idx(NUMA_CPUBUF, nid, priv);

			/* Decay existing window, copy faults since last scan */
			diff = p->numa_faults[membuf_idx] - p->numa_faults[mem_idx] / 2;
			fault_types[priv] += p->numa_faults[membuf_idx];
			p->numa_faults[membuf_idx] = 0;

			/*
			 * Normalize the faults_from, so all tasks in a group
			 * count according to CPU use, instead of by the raw
			 * number of faults. Tasks with little runtime have
			 * little over-all impact on throughput, and thus their
			 * faults are less important.
			 */
			f_weight = div64_u64(runtime << 16, period + 1);
			f_weight = (f_weight * p->numa_faults[cpubuf_idx]) /
				   (total_faults + 1);
			f_diff = f_weight - p->numa_faults[cpu_idx] / 2;
			p->numa_faults[cpubuf_idx] = 0;

			p->numa_faults[mem_idx] += diff;
			p->numa_faults[cpu_idx] += f_diff;
			faults += p->numa_faults[mem_idx];
			p->total_numa_faults += diff;
			if (p->numa_group) {
				/*
				 * safe because we can only change our own group
				 *
				 * mem_idx represents the offset for a given
				 * nid and priv in a specific region because it
				 * is at the beginning of the numa_faults array.
				 */
				p->numa_group->faults[mem_idx] += diff;
				p->numa_group->faults_cpu[mem_idx] += f_diff;
				p->numa_group->total_faults += diff;
				group_faults += p->numa_group->faults[mem_idx];
			}
		}

		if (!p->numa_group) {
			if (faults > max_faults) {
				max_faults = faults;
				max_nid = nid;
			}
		} else if (group_faults > max_faults) {
			max_faults = group_faults;
			max_nid = nid;
		}
	}

	if (p->numa_group) {
		numa_group_count_active_nodes(p->numa_group);
		spin_unlock_irq(group_lock);
		max_nid = preferred_group_nid(p, max_nid);
	}

	if (max_faults) {
		/* Set the new preferred node */
		if (max_nid != p->numa_preferred_nid)
			sched_setnuma(p, max_nid);
	}

	update_task_scan_period(p, fault_types[0], fault_types[1]);
}
","static void task_numa_placement(struct task_struct *p)
{
	int seq, nid, max_nid = -1;
	unsigned long max_faults = 0;
	unsigned long fault_types[2] = { 0, 0 };
	unsigned long total_faults;
	u64 runtime, period;
	spinlock_t *group_lock = NULL;

	/*
	 * The p->mm->numa_scan_seq field gets updated without
	 * exclusive access. Use READ_ONCE() here to ensure
	 * that the field is read in a single access:
	 */
	seq = READ_ONCE(p->mm->numa_scan_seq);
	if (p->numa_scan_seq == seq)
		return;
	p->numa_scan_seq = seq;
	p->numa_scan_period_max = task_scan_max(p);

	total_faults = p->numa_faults_locality[0] +
		       p->numa_faults_locality[1];
	runtime = numa_get_avg_runtime(p, &period);

	/* If the task is part of a group prevent parallel updates to group stats */
	if (p->numa_group) {
		group_lock = &p->numa_group->lock;
		spin_lock_irq(group_lock);
	}

	/* Find the node with the highest number of faults */
	for_each_online_node(nid) {
		/* Keep track of the offsets in numa_faults array */
		int mem_idx, membuf_idx, cpu_idx, cpubuf_idx;
		unsigned long faults = 0, group_faults = 0;
		int priv;

		for (priv = 0; priv < NR_NUMA_HINT_FAULT_TYPES; priv++) {
			long diff, f_diff, f_weight;

			mem_idx = task_faults_idx(NUMA_MEM, nid, priv);
			membuf_idx = task_faults_idx(NUMA_MEMBUF, nid, priv);
			cpu_idx = task_faults_idx(NUMA_CPU, nid, priv);
			cpubuf_idx = task_faults_idx(NUMA_CPUBUF, nid, priv);

			/* Decay existing window, copy faults since last scan */
			diff = p->numa_faults[membuf_idx] - p->numa_faults[mem_idx] / 2;
			fault_types[priv] += p->numa_faults[membuf_idx];
			p->numa_faults[membuf_idx] = 0;

			/*
			 * Normalize the faults_from, so all tasks in a group
			 * count according to CPU use, instead of by the raw
			 * number of faults. Tasks with little runtime have
			 * little over-all impact on throughput, and thus their
			 * faults are less important.
			 */
			f_weight = div64_u64(runtime << 16, period + 1);
			f_weight = (f_weight * p->numa_faults[cpubuf_idx]) /
				   (total_faults + 1);
			f_diff = f_weight - p->numa_faults[cpu_idx] / 2;
			p->numa_faults[cpubuf_idx] = 0;

			p->numa_faults[mem_idx] += diff;
			p->numa_faults[cpu_idx] += f_diff;
			faults += p->numa_faults[mem_idx];
			p->total_numa_faults += diff;
			if (p->numa_group) {
				/*
				 * safe because we can only change our own group
				 *
				 * mem_idx represents the offset for a given
				 * nid and priv in a specific region because it
				 * is at the beginning of the numa_faults array.
				 */
				p->numa_group->faults[mem_idx] += diff;
				p->numa_group->faults_cpu[mem_idx] += f_diff;
				p->numa_group->total_faults += diff;
				group_faults += p->numa_group->faults[mem_idx];
			}
		}

		if (!p->numa_group) {
			if (faults > max_faults) {
				max_faults = faults;
				max_nid = nid;
			}
		} else if (group_faults > max_faults) {
			max_faults = group_faults;
			max_nid = nid;
		}
	}

	if (p->numa_group) {
		numa_group_count_active_nodes(p->numa_group);
		spin_unlock_irq(group_lock);
		max_nid = preferred_group_nid(p, max_nid);
	}

	if (max_faults) {
		/* Set the new preferred node */
		if (max_nid != p->numa_preferred_nid)
			sched_setnuma(p, max_nid);
	}

	update_task_scan_period(p, fault_types[0], fault_types[1]);
}
",C,,,,"@@ -352,10 +352,9 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 	}
 }
 
-/* Iterate thr' all leaf cfs_rq's on a runqueue */
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)			\
-	list_for_each_entry_safe(cfs_rq, pos, &rq->leaf_cfs_rq_list,	\
-				 leaf_cfs_rq_list)
+/* Iterate through all leaf cfs_rq's on a runqueue: */
+#define for_each_leaf_cfs_rq(rq, cfs_rq) \
+	list_for_each_entry_rcu(cfs_rq, &rq->leaf_cfs_rq_list, leaf_cfs_rq_list)
 
 /* Do the two (enqueued) entities belong to the same group ? */
 static inline struct cfs_rq *
@@ -447,8 +446,8 @@ static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)
 {
 }
 
-#define for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos)	\
-		for (cfs_rq = &rq->cfs, pos = NULL; cfs_rq; cfs_rq = pos)
+#define for_each_leaf_cfs_rq(rq, cfs_rq)	\
+		for (cfs_rq = &rq->cfs; cfs_rq; cfs_rq = NULL)
 
 static inline struct sched_entity *parent_entity(struct sched_entity *se)
 {
@@ -7647,27 +7646,10 @@ static inline bool others_have_blocked(struct rq *rq)
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
 
-static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)
-{
-	if (cfs_rq->load.weight)
-		return false;
-
-	if (cfs_rq->avg.load_sum)
-		return false;
-
-	if (cfs_rq->avg.util_sum)
-		return false;
-
-	if (cfs_rq->avg.runnable_load_sum)
-		return false;
-
-	return true;
-}
-
 static void update_blocked_averages(int cpu)
 {
 	struct rq *rq = cpu_rq(cpu);
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 	const struct sched_class *curr_class;
 	struct rq_flags rf;
 	bool done = true;
@@ -7679,7 +7661,7 @@ static void update_blocked_averages(int cpu)
 	 * Iterates the task_group tree in a bottom up fashion, see
 	 * list_add_leaf_cfs_rq() for details.
 	 */
-	for_each_leaf_cfs_rq_safe(rq, cfs_rq, pos) {
+	for_each_leaf_cfs_rq(rq, cfs_rq) {
 		struct sched_entity *se;
 
 		/* throttled entities do not contribute to load */
@@ -7694,13 +7676,6 @@ static void update_blocked_averages(int cpu)
 		if (se && !skip_blocked_update(se))
 			update_load_avg(cfs_rq_of(se), se, 0);
 
-		/*
-		 * There can be a lot of idle CPU cgroups.  Don't let fully
-		 * decayed cfs_rqs linger on the list.
-		 */
-		if (cfs_rq_is_decayed(cfs_rq))
-			list_del_leaf_cfs_rq(cfs_rq);
-
 		/* Don't need periodic decay once load/util_avg are null */
 		if (cfs_rq_has_blocked(cfs_rq))
 			done = false;
@@ -10570,10 +10545,10 @@ const struct sched_class fair_sched_class = {
 #ifdef CONFIG_SCHED_DEBUG
 void print_cfs_stats(struct seq_file *m, int cpu)
 {
-	struct cfs_rq *cfs_rq, *pos;
+	struct cfs_rq *cfs_rq;
 
 	rcu_read_lock();
-	for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)
+	for_each_leaf_cfs_rq(cpu_rq(cpu), cfs_rq)
 		print_cfs_rq(m, cpu, cfs_rq);
 	rcu_read_unlock();
 }",linux,c40f7d74c741a907cfaeb73a7697081881c497d0,6d101ba6be2a26a3e1f513b5e293f0fd2b79ec5c,0,"static void task_numa_placement(struct task_struct *p)
{
	int seq, nid, max_nid = -1;
	unsigned long max_faults = 0;
	unsigned long fault_types[2] = { 0, 0 };
	unsigned long total_faults;
	u64 runtime, period;
	spinlock_t *group_lock = NULL;

	/*
	 * The p->mm->numa_scan_seq field gets updated without
	 * exclusive access. Use READ_ONCE() here to ensure
	 * that the field is read in a single access:
	 */
	seq = READ_ONCE(p->mm->numa_scan_seq);
	if (p->numa_scan_seq == seq)
		return;
	p->numa_scan_seq = seq;
	p->numa_scan_period_max = task_scan_max(p);

	total_faults = p->numa_faults_locality[0] +
		       p->numa_faults_locality[1];
	runtime = numa_get_avg_runtime(p, &period);

	/* If the task is part of a group prevent parallel updates to group stats */
	if (p->numa_group) {
		group_lock = &p->numa_group->lock;
		spin_lock_irq(group_lock);
	}

	/* Find the node with the highest number of faults */
	for_each_online_node(nid) {
		/* Keep track of the offsets in numa_faults array */
		int mem_idx, membuf_idx, cpu_idx, cpubuf_idx;
		unsigned long faults = 0, group_faults = 0;
		int priv;

		for (priv = 0; priv < NR_NUMA_HINT_FAULT_TYPES; priv++) {
			long diff, f_diff, f_weight;

			mem_idx = task_faults_idx(NUMA_MEM, nid, priv);
			membuf_idx = task_faults_idx(NUMA_MEMBUF, nid, priv);
			cpu_idx = task_faults_idx(NUMA_CPU, nid, priv);
			cpubuf_idx = task_faults_idx(NUMA_CPUBUF, nid, priv);

			/* Decay existing window, copy faults since last scan */
			diff = p->numa_faults[membuf_idx] - p->numa_faults[mem_idx] / 2;
			fault_types[priv] += p->numa_faults[membuf_idx];
			p->numa_faults[membuf_idx] = 0;

			/*
			 * Normalize the faults_from, so all tasks in a group
			 * count according to CPU use, instead of by the raw
			 * number of faults. Tasks with little runtime have
			 * little over-all impact on throughput, and thus their
			 * faults are less important.
			 */
			f_weight = div64_u64(runtime << 16, period + 1);
			f_weight = (f_weight * p->numa_faults[cpubuf_idx]) /
				   (total_faults + 1);
			f_diff = f_weight - p->numa_faults[cpu_idx] / 2;
			p->numa_faults[cpubuf_idx] = 0;

			p->numa_faults[mem_idx] += diff;
			p->numa_faults[cpu_idx] += f_diff;
			faults += p->numa_faults[mem_idx];
			p->total_numa_faults += diff;
			if (p->numa_group) {
				/*
				 * safe because we can only change our own group
				 *
				 * mem_idx represents the offset for a given
				 * nid and priv in a specific region because it
				 * is at the beginning of the numa_faults array.
				 */
				p->numa_group->faults[mem_idx] += diff;
				p->numa_group->faults_cpu[mem_idx] += f_diff;
				p->numa_group->total_faults += diff;
				group_faults += p->numa_group->faults[mem_idx];
			}
		}

		if (!p->numa_group) {
			if (faults > max_faults) {
				max_faults = faults;
				max_nid = nid;
			}
		} else if (group_faults > max_faults) {
			max_faults = group_faults;
			max_nid = nid;
		}
	}

	if (p->numa_group) {
		numa_group_count_active_nodes(p->numa_group);
		spin_unlock_irq(group_lock);
		max_nid = preferred_group_nid(p, max_nid);
	}

	if (max_faults) {
		/* Set the new preferred node */
		if (max_nid != p->numa_preferred_nid)
			sched_setnuma(p, max_nid);
	}

	update_task_scan_period(p, fault_types[0], fault_types[1]);
}
"
78845,,Local,Not required,Partial,CVE-2018-16425,https://www.cvedetails.com/cve/CVE-2018-16425/,CWE-415,Low,Partial,Partial,,2018-09-03,4.6,A double free when handling responses from an HSM Card in sc_pkcs15emu_sc_hsm_init in libopensc/pkcs15-sc-hsm.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.,2019-09-11,DoS ,0,https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,"fixed out of bounds writes

Thanks to Eric Sesterhenn from X41 D-SEC GmbH
for reporting the problems.",0,src/libopensc/sc.c,"{""sha"": ""756788a0fbbbed8487e8cf33b6115bb4d4f58860"", ""filename"": ""src/libopensc/card-cac.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-cac.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-cac.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -794,7 +794,7 @@ static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* seri\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);""}<_**next**_>{""sha"": ""65a58f6740d38e6fd6204cbacb5015995067334f"", ""filename"": ""src/libopensc/card-epass2003.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-epass2003.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-epass2003.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -951,7 +951,7 @@ decrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);\n@@ -977,6 +977,7 @@ epass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apd\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}""}<_**next**_>{""sha"": ""d247efabc9fd2d7978e4a24dc42bcaccd42f3bee"", ""filename"": ""src/libopensc/card-muscle.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 2, ""changes"": 7, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-muscle.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-muscle.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -518,7 +518,9 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\""FILE: %02X%02X%02X%02X\\n\"",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -527,7 +529,8 @@ static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;""}<_**next**_>{""sha"": ""3c86b1f4838a5837341ae9cfc9b7fdb5334fe138"", ""filename"": ""src/libopensc/card-tcos.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/card-tcos.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/card-tcos.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -408,7 +408,7 @@ static int tcos_select_file(sc_card_t *card,\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -432,8 +432,8 @@ static int tcos_select_file(sc_card_t *card,\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ""}<_**next**_>{""sha"": ""2b8d66b913b0d3ce3c92c0578c43ae847f98d2c7"", ""filename"": ""src/libopensc/pkcs15-esteid.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-esteid.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-esteid.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -79,7 +79,7 @@ sc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \""read document number failed\"");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION""}<_**next**_>{""sha"": ""3b220f7a5b37ea236b58ef543d01ca08c815b826"", ""filename"": ""src/libopensc/pkcs15-gemsafeV1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-gemsafeV1.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-gemsafeV1.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -208,7 +208,7 @@ static int gemsafe_get_cert_len(sc_card_t *card)\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \""Key container %d is allocated and uses key_ref %d\"",""}<_**next**_>{""sha"": ""1391bea15370cd020dfdf1cfb0d9c24db950a0c4"", ""filename"": ""src/libopensc/pkcs15-sc-hsm.c"", ""status"": ""modified"", ""additions"": 8, ""deletions"": 6, ""changes"": 14, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/pkcs15-sc-hsm.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/pkcs15-sc-hsm.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -837,12 +837,14 @@ static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n \t\tr = read_file(p15card, (u8 *) \""\\x2F\\x02\"", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \""Skipping optional EF.C_DevAut\"");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;""}<_**next**_>{""sha"": ""53fefb3e68eac554ed608a5a960cf3dd5f5b8dcb"", ""filename"": ""src/libopensc/sc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/libopensc/sc.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/libopensc/sc.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;""}<_**next**_>{""sha"": ""662a028222a909f431f31c60bc421fa83d86d5b6"", ""filename"": ""src/tools/cryptoflex-tool.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/cryptoflex-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/cryptoflex-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -21,6 +21,7 @@\n #include \""config.h\""\n \n #include \""libopensc/sc-ossl-compat.h\""\n+#include \""libopensc/internal.h\""\n #include <openssl/bn.h>\n #include <openssl/rsa.h>\n #include <openssl/x509.h>\n@@ -331,7 +332,7 @@ static int read_public_key(RSA *rsa)\n \t\tfprintf(stderr, \""Unable to select public key file: %s\\n\"", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n@@ -382,7 +383,7 @@ static int read_private_key(RSA *rsa)\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {""}<_**next**_>{""sha"": ""31360833b5284915ae8d93babeb3fdb1b279a0f3"", ""filename"": ""src/tools/egk-tool.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/egk-tool.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/egk-tool.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -149,7 +149,7 @@ int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;""}<_**next**_>{""sha"": ""e49647a472e921663b2952ef5cf213c9fc974beb"", ""filename"": ""src/tools/util.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 2, ""changes"": 5, ""blob_url"": ""https://github.com/OpenSC/OpenSC/blob/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""raw_url"": ""https://github.com/OpenSC/OpenSC/raw/360e95d45ac4123255a4c796db96337f332160ad/src/tools/util.c"", ""contents_url"": ""https://api.github.com/repos/OpenSC/OpenSC/contents/src/tools/util.c?ref=360e95d45ac4123255a4c796db96337f332160ad"", ""patch"": ""@@ -339,10 +339,11 @@ const char * util_acl_to_str(const sc_acl_entry_t *e)\n \t\t\tstrcpy(buf, \""????\"");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \"" \"");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \"" \"", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }""}","const char *sc_get_version(void)
{
    return sc_version;
}
","const char *sc_get_version(void)
{
    return sc_version;
}
",C,,,,"@@ -628,7 +628,7 @@ int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,
 		return SC_ERROR_INVALID_ARGUMENTS;
 	}
 
-	if (sec_attr == NULL) {
+	if (sec_attr == NULL || sec_attr_len) {
 		if (file->sec_attr != NULL)
 			free(file->sec_attr);
 		file->sec_attr = NULL;",OpenSC,360e95d45ac4123255a4c796db96337f332160ad#diff-d643a0fa169471dbf2912f4866dc49c5,8fe377e93b4b56060e5bbfb6f3142ceaeca744fa,0,"const char *sc_get_version(void)
{
    return sc_version;
}
"
110657,,Remote,Not required,Partial,CVE-2012-2896,https://www.cvedetails.com/cve/CVE-2012-2896/,CWE-189,Low,Partial,Partial,,2012-09-26,7.5,Integer overflow in the WebGL implementation in Google Chrome before 22.0.1229.79 on Mac OS X allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors.,2017-08-28,DoS Overflow ,0,https://github.com/chromium/chromium/commit/3aad1a37affb1ab70d1897f2b03eb8c077264984,3aad1a37affb1ab70d1897f2b03eb8c077264984,"Fix SafeAdd and SafeMultiply

BUG=145648,145544


Review URL: https://chromiumcodereview.appspot.com/10916165

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@155478 0039d316-1c4b-4281-b951-d872f2087c98",0,gpu/command_buffer/service/texture_manager.cc,"{""sha"": ""68ff41b655c3f35ab33de086cfd418f16b62359f"", ""filename"": ""gpu/command_buffer/common/gles2_cmd_utils.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 13, ""changes"": 27, ""blob_url"": ""https://github.com/chromium/chromium/blob/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/common/gles2_cmd_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/common/gles2_cmd_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/common/gles2_cmd_utils.h?ref=3aad1a37affb1ab70d1897f2b03eb8c077264984"", ""patch"": ""@@ -8,6 +8,7 @@\n #ifndef GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_UTILS_H_\n #define GPU_COMMAND_BUFFER_COMMON_GLES2_CMD_UTILS_H_\n \n+#include <limits>\n #include <string>\n #include <vector>\n \n@@ -19,13 +20,15 @@ namespace gles2 {\n \n // Does a multiply and checks for overflow.  If the multiply did not overflow\n // returns true.\n-template <typename T>\n-inline bool SafeMultiply(T a, T b, T* dst) {\n+\n+// Multiplies 2 32 bit unsigned numbers checking for overflow.\n+// If there was no overflow returns true.\n+inline bool SafeMultiplyUint32(uint32 a, uint32 b, uint32* dst) {\n   if (b == 0) {\n     *dst = 0;\n     return true;\n   }\n-  T v = a * b;\n+  uint32 v = a * b;\n   if (v / b != a) {\n     *dst = 0;\n     return false;\n@@ -34,14 +37,8 @@ inline bool SafeMultiply(T a, T b, T* dst) {\n   return true;\n }\n \n-// A wrapper for SafeMultiply to remove the need to cast.\n-inline bool SafeMultiplyUint32(uint32 a, uint32 b, uint32* dst) {\n-  return SafeMultiply(a, b, dst);\n-}\n-\n // Does an add checking for overflow.  If there was no overflow returns true.\n-template <typename T>\n-inline bool SafeAdd(T a, T b, T* dst) {\n+inline bool SafeAddUint32(uint32 a, uint32 b, uint32* dst) {\n   if (a + b < a) {\n     *dst = 0;\n     return false;\n@@ -50,9 +47,13 @@ inline bool SafeAdd(T a, T b, T* dst) {\n   return true;\n }\n \n-// A wrapper for SafeAdd to remove the need to cast.\n-inline bool SafeAddUint32(uint32 a, uint32 b, uint32* dst) {\n-  return SafeAdd(a, b, dst);\n+// Does an add checking for overflow.  If there was no overflow returns true.\n+inline bool SafeAddInt32(int32 a, int32 b, int32* dst) {\n+  int64 sum64 = static_cast<int64>(a) + b;\n+  int32 sum32 = static_cast<int32>(sum64);\n+  bool safe = sum64 == static_cast<int64>(sum32);\n+  *dst = safe ? sum32 : 0;\n+  return safe;\n }\n \n // Utilties for GLES2 support.""}<_**next**_>{""sha"": ""0e157dbfcac32ff6d3ad73060ade6c489c869d66"", ""filename"": ""gpu/command_buffer/common/gles2_cmd_utils_unittest.cc"", ""status"": ""modified"", ""additions"": 53, ""deletions"": 0, ""changes"": 53, ""blob_url"": ""https://github.com/chromium/chromium/blob/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/common/gles2_cmd_utils_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/common/gles2_cmd_utils_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/common/gles2_cmd_utils_unittest.cc?ref=3aad1a37affb1ab70d1897f2b03eb8c077264984"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""gpu/command_buffer/common/gles2_cmd_utils.h\""\n \n+#include <limits>\n #include <GLES2/gl2.h>\n #include <GLES2/gl2ext.h>\n \n@@ -17,6 +18,58 @@ class GLES2UtilTest : public testing:: Test {\n   GLES2Util util_;\n };\n \n+TEST_F(GLES2UtilTest, SafeMultiplyUint32) {\n+  uint32 result = 0;\n+  EXPECT_TRUE(SafeMultiplyUint32(2u, 3u, &result));\n+  EXPECT_EQ(6u, result);\n+  EXPECT_FALSE(SafeMultiplyUint32(0x80000000u, 2u, &result));\n+  EXPECT_EQ(0u, result);\n+  EXPECT_TRUE(SafeMultiplyUint32(0x2u, 0x7FFFFFFFu, &result));\n+  EXPECT_EQ(0xFFFFFFFEu, result);\n+  EXPECT_FALSE(SafeMultiplyUint32(2u, 0x80000000u, &result));\n+  EXPECT_EQ(0u, result);\n+}\n+\n+TEST_F(GLES2UtilTest, SafeAddUint32) {\n+  uint32 result = 0;\n+  EXPECT_TRUE(SafeAddUint32(2u, 3u, &result));\n+  EXPECT_EQ(5u, result);\n+  EXPECT_FALSE(SafeAddUint32(0x80000000u, 0x80000000u, &result));\n+  EXPECT_EQ(0u, result);\n+  EXPECT_TRUE(SafeAddUint32(0xFFFFFFFEu, 0x1u, &result));\n+  EXPECT_EQ(0xFFFFFFFFu, result);\n+  EXPECT_FALSE(SafeAddUint32(0xFFFFFFFEu, 0x2u, &result));\n+  EXPECT_EQ(0u, result);\n+  EXPECT_TRUE(SafeAddUint32(0x1u, 0xFFFFFFFEu, &result));\n+  EXPECT_EQ(0xFFFFFFFFu, result);\n+  EXPECT_FALSE(SafeAddUint32(0x2u, 0xFFFFFFFEu, &result));\n+  EXPECT_EQ(0u, result);\n+}\n+\n+TEST_F(GLES2UtilTest, SafeAddInt32) {\n+  int32 result = 0;\n+  const int32 kMax = std::numeric_limits<int32>::max();\n+  const int32 kMin = std::numeric_limits<int32>::min();\n+  EXPECT_TRUE(SafeAddInt32(2, 3, &result));\n+  EXPECT_EQ(5, result);\n+  EXPECT_FALSE(SafeAddInt32(kMax, 1, &result));\n+  EXPECT_EQ(0, result);\n+  EXPECT_TRUE(SafeAddInt32(kMin + 1, -1, &result));\n+  EXPECT_EQ(kMin, result);\n+  EXPECT_FALSE(SafeAddInt32(kMin, -1, &result));\n+  EXPECT_EQ(0, result);\n+  EXPECT_TRUE(SafeAddInt32(kMax - 1, 1, &result));\n+  EXPECT_EQ(kMax, result);\n+  EXPECT_FALSE(SafeAddInt32(1, kMax, &result));\n+  EXPECT_EQ(0, result);\n+  EXPECT_TRUE(SafeAddInt32(-1, kMin + 1, &result));\n+  EXPECT_EQ(kMin, result);\n+  EXPECT_FALSE(SafeAddInt32(-1, kMin, &result));\n+  EXPECT_EQ(0, result);\n+  EXPECT_TRUE(SafeAddInt32(1, kMax - 1, &result));\n+  EXPECT_EQ(kMax, result);\n+}\n+\n TEST_F(GLES2UtilTest, GLGetNumValuesReturned) {\n   EXPECT_EQ(0, util_.GLGetNumValuesReturned(GL_COMPRESSED_TEXTURE_FORMATS));\n   EXPECT_EQ(0, util_.GLGetNumValuesReturned(GL_SHADER_BINARY_FORMATS));""}<_**next**_>{""sha"": ""b1af943a65e112b39fca03dcbe7a924cf0955a07"", ""filename"": ""gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 14, ""changes"": 26, ""blob_url"": ""https://github.com/chromium/chromium/blob/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/service/gles2_cmd_decoder.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/gles2_cmd_decoder.cc?ref=3aad1a37affb1ab70d1897f2b03eb8c077264984"", ""patch"": ""@@ -5435,11 +5435,10 @@ bool GLES2DecoderImpl::SimulateAttrib0(\n   typedef VertexAttribManager::VertexAttribInfo::Vec4 Vec4;\n \n   GLuint num_vertices = max_vertex_accessed + 1;\n-  GLuint size_needed = 0;\n+  uint32 size_needed = 0;\n \n   if (num_vertices == 0 ||\n-      !SafeMultiply(num_vertices, static_cast<GLuint>(sizeof(Vec4)),\n-                    &size_needed) ||\n+      !SafeMultiplyUint32(num_vertices, sizeof(Vec4), &size_needed) ||\n       size_needed > 0x7FFFFFFFU) {\n     SetGLError(GL_OUT_OF_MEMORY, function_name, \""Simulating attrib 0\"");\n     return false;\n@@ -5549,20 +5548,19 @@ bool GLES2DecoderImpl::SimulateFixedAttribs(\n     if (attrib_info &&\n         info->CanAccess(max_accessed) &&\n         info->type() == GL_FIXED) {\n-      GLuint elements_used = 0;\n-      if (!SafeMultiply(num_vertices,\n-                        static_cast<GLuint>(info->size()), &elements_used) ||\n-          !SafeAdd(elements_needed, elements_used, &elements_needed)) {\n+      uint32 elements_used = 0;\n+      if (!SafeMultiplyUint32(num_vertices, info->size(), &elements_used) ||\n+          !SafeAddUint32(elements_needed, elements_used, &elements_needed)) {\n         SetGLError(\n             GL_OUT_OF_MEMORY, function_name, \""simulating GL_FIXED attribs\"");\n         return false;\n       }\n     }\n   }\n \n-  const GLuint kSizeOfFloat = sizeof(float);  // NOLINT\n-  GLuint size_needed = 0;\n-  if (!SafeMultiply(elements_needed, kSizeOfFloat, &size_needed) ||\n+  const uint32 kSizeOfFloat = sizeof(float);  // NOLINT\n+  uint32 size_needed = 0;\n+  if (!SafeMultiplyUint32(elements_needed, kSizeOfFloat, &size_needed) ||\n       size_needed > 0x7FFFFFFFU) {\n     SetGLError(GL_OUT_OF_MEMORY, function_name, \""simulating GL_FIXED attribs\"");\n     return false;\n@@ -6481,9 +6479,9 @@ error::Error GLES2DecoderImpl::HandleReadPixels(\n   // Get the size of the current fbo or backbuffer.\n   gfx::Size max_size = GetBoundReadFrameBufferSize();\n \n-  GLint max_x;\n-  GLint max_y;\n-  if (!SafeAdd(x, width, &max_x) || !SafeAdd(y, height, &max_y)) {\n+  int32 max_x;\n+  int32 max_y;\n+  if (!SafeAddInt32(x, width, &max_x) || !SafeAddInt32(y, height, &max_y)) {\n     SetGLError(GL_INVALID_VALUE, \""glReadPixels\"", \""dimensions out of range\"");\n     return error::kNoError;\n   }\n@@ -8536,7 +8534,7 @@ error::Error GLES2DecoderImpl::HandleGetMultipleIntegervCHROMIUM(\n     }\n     // Num will never be more than 4.\n     DCHECK_LE(num, 4u);\n-    if (!SafeAdd(num_results, num, &num_results)) {\n+    if (!SafeAddUint32(num_results, num, &num_results)) {\n       return error::kOutOfBounds;\n     }\n   }""}<_**next**_>{""sha"": ""41fea807da0ad0cc31cdb64188373eff6c06bd82"", ""filename"": ""gpu/command_buffer/service/texture_manager.cc"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/service/texture_manager.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/3aad1a37affb1ab70d1897f2b03eb8c077264984/gpu/command_buffer/service/texture_manager.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/gpu/command_buffer/service/texture_manager.cc?ref=3aad1a37affb1ab70d1897f2b03eb8c077264984"", ""patch"": ""@@ -359,10 +359,10 @@ bool TextureManager::TextureInfo::ValidForTexture(\n   if (level >= 0 && face_index < level_infos_.size() &&\n       static_cast<size_t>(level) < level_infos_[face_index].size()) {\n     const LevelInfo& info = level_infos_[GLTargetToFaceIndex(face)][level];\n-    GLint right;\n-    GLint top;\n-    return SafeAdd(xoffset, width, &right) &&\n-           SafeAdd(yoffset, height, &top) &&\n+    int32 right;\n+    int32 top;\n+    return SafeAddInt32(xoffset, width, &right) &&\n+           SafeAddInt32(yoffset, height, &top) &&\n            xoffset >= 0 &&\n            yoffset >= 0 &&\n            right <= info.width &&""}","bool TextureManager::TextureInfo::CanGenerateMipmaps(
    const FeatureInfo* feature_info) const {
  if ((npot() && !feature_info->feature_flags().npot_ok) ||
      level_infos_.empty() ||
      target_ == GL_TEXTURE_EXTERNAL_OES ||
      target_ == GL_TEXTURE_RECTANGLE_ARB) {
    return false;
  }

  const TextureInfo::LevelInfo& first = level_infos_[0][0];
  uint32 channels = GLES2Util::GetChannelsForFormat(first.format);
  if (channels & (GLES2Util::kDepth | GLES2Util::kStencil)) {
    return false;
  }

  for (size_t ii = 0; ii < level_infos_.size(); ++ii) {
    const LevelInfo& info = level_infos_[ii][0];
    if ((info.target == 0) ||
        (info.width != first.width) ||
        (info.height != first.height) ||
        (info.depth != 1) ||
        (info.format != first.format) ||
        (info.internal_format != first.internal_format) ||
        (info.type != first.type) ||
        feature_info->validators()->compressed_texture_format.IsValid(
            info.internal_format)) {
        return false;
    }
  }
  return true;
}
","bool TextureManager::TextureInfo::CanGenerateMipmaps(
    const FeatureInfo* feature_info) const {
  if ((npot() && !feature_info->feature_flags().npot_ok) ||
      level_infos_.empty() ||
      target_ == GL_TEXTURE_EXTERNAL_OES ||
      target_ == GL_TEXTURE_RECTANGLE_ARB) {
    return false;
  }

  const TextureInfo::LevelInfo& first = level_infos_[0][0];
  uint32 channels = GLES2Util::GetChannelsForFormat(first.format);
  if (channels & (GLES2Util::kDepth | GLES2Util::kStencil)) {
    return false;
  }

  for (size_t ii = 0; ii < level_infos_.size(); ++ii) {
    const LevelInfo& info = level_infos_[ii][0];
    if ((info.target == 0) ||
        (info.width != first.width) ||
        (info.height != first.height) ||
        (info.depth != 1) ||
        (info.format != first.format) ||
        (info.internal_format != first.internal_format) ||
        (info.type != first.type) ||
        feature_info->validators()->compressed_texture_format.IsValid(
            info.internal_format)) {
        return false;
    }
  }
  return true;
}
",C,,,,"@@ -359,10 +359,10 @@ bool TextureManager::TextureInfo::ValidForTexture(
   if (level >= 0 && face_index < level_infos_.size() &&
       static_cast<size_t>(level) < level_infos_[face_index].size()) {
     const LevelInfo& info = level_infos_[GLTargetToFaceIndex(face)][level];
-    GLint right;
-    GLint top;
-    return SafeAdd(xoffset, width, &right) &&
-           SafeAdd(yoffset, height, &top) &&
+    int32 right;
+    int32 top;
+    return SafeAddInt32(xoffset, width, &right) &&
+           SafeAddInt32(yoffset, height, &top) &&
            xoffset >= 0 &&
            yoffset >= 0 &&
            right <= info.width &&",Chrome,3aad1a37affb1ab70d1897f2b03eb8c077264984,07c674cd5a7d9f79cd2be1d04437bf97717f79a0,0,"bool TextureManager::TextureInfo::CanGenerateMipmaps(
    const FeatureInfo* feature_info) const {
  if ((npot() && !feature_info->feature_flags().npot_ok) ||
      level_infos_.empty() ||
      target_ == GL_TEXTURE_EXTERNAL_OES ||
      target_ == GL_TEXTURE_RECTANGLE_ARB) {
    return false;
  }

  // Can't generate mips for depth or stencil textures.
  const TextureInfo::LevelInfo& first = level_infos_[0][0];
  uint32 channels = GLES2Util::GetChannelsForFormat(first.format);
  if (channels & (GLES2Util::kDepth | GLES2Util::kStencil)) {
    return false;
  }

  // TODO(gman): Check internal_format, format and type.
  for (size_t ii = 0; ii < level_infos_.size(); ++ii) {
    const LevelInfo& info = level_infos_[ii][0];
    if ((info.target == 0) ||
        (info.width != first.width) ||
        (info.height != first.height) ||
        (info.depth != 1) ||
        (info.format != first.format) ||
        (info.internal_format != first.internal_format) ||
        (info.type != first.type) ||
        feature_info->validators()->compressed_texture_format.IsValid(
            info.internal_format)) {
        return false;
    }
  }
  return true;
}
"
3970,,Remote,Not required,Partial,CVE-2013-1790,https://www.cvedetails.com/cve/CVE-2013-1790/,CWE-119,Medium,Partial,Partial,,2013-04-09,6.8,poppler/Stream.cc in poppler before 0.22.1 allows context-dependent attackers to have an unspecified impact via vectors that trigger a read of uninitialized memory by the CCITTFaxStream::lookChar function.,2014-01-27,Overflow,0,https://cgit.freedesktop.org/poppler/poppler/commit/?h=poppler-0.22&id=b1026b5978c385328f2a15a2185c599a563edf91,b1026b5978c385328f2a15a2185c599a563edf91,,0,,,"int FlateStream::getRawChar() {
  return doGetRawChar();
}
","int FlateStream::getRawChar() {
  return doGetRawChar();
}
",CPP,,,bef2c42f381c74fdb8bbb43babe1a93a0e229fb0,"@@ -14,7 +14,7 @@
 // under GPL version 2 or later
 //
 // Copyright (C) 2005 Jeff Muizelaar <jeff@infidigm.net>
-// Copyright (C) 2006-2010, 2012 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2006-2010, 2012, 2013 Albert Astals Cid <aacid@kde.org>
 // Copyright (C) 2007 Krzysztof Kowalczyk <kkowalczyk@gmail.com>
 // Copyright (C) 2008 Julien Rebetez <julien@fhtagn.net>
 // Copyright (C) 2009 Carlos Garcia Campos <carlosgc@gnome.org>
@@ -1712,8 +1712,9 @@ int CCITTFaxStream::lookChar() {
       for (i = 0; i < columns && codingLine[i] < columns; ++i) {
 	refLine[i] = codingLine[i];
       }
-      refLine[i++] = columns;
-      refLine[i] = columns;
+      for (; i < columns + 2; ++i) {
+	refLine[i] = columns;
+      }
       codingLine[0] = 0;
       a0i = 0;
       b1i = 0;",poppler,https://cgit.freedesktop.org/poppler/poppler/tree/poppler/Stream.cc?h=poppler-0.22&id=b1026b5978c385328f2a15a2185c599a563edf91,https://cgit.freedesktop.org/poppler/poppler/tree/poppler/Stream.cc?h=poppler-0.22&id=bef2c42f381c74fdb8bbb43babe1a93a0e229fb0,0,"int FlateStream::getRawChar() {
  return doGetRawChar();
}
"
121488,,Remote,Not required,,CVE-2013-2876,https://www.cvedetails.com/cve/CVE-2013-2876/,CWE-264,Low,Partial,,,2013-07-10,5.0,"browser/extensions/api/tabs/tabs_api.cc in Google Chrome before 28.0.1500.71 does not properly enforce restrictions on the capture of screenshots by extensions, which allows remote attackers to obtain sensitive information about the content of a previous page via vectors involving an interstitial page.",2017-09-18,+Info ,0,https://github.com/chromium/chromium/commit/016da29386308754274675e65fdb73cf9d59dc2d,016da29386308754274675e65fdb73cf9d59dc2d,"Don't allow extensions to take screenshots of interstitial pages. Branched from
https://codereview.chromium.org/14885004/ which is trying to test it.

BUG=229504

Review URL: https://chromiumcodereview.appspot.com/14954004

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@198297 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/extensions/api/tabs/tabs_api.cc,"{""sha"": ""445857fa0029392571ed26bee157c0b441e2cbf9"", ""filename"": ""chrome/browser/extensions/api/tabs/tabs_api.cc"", ""status"": ""modified"", ""additions"": 15, ""deletions"": 7, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/016da29386308754274675e65fdb73cf9d59dc2d/chrome/browser/extensions/api/tabs/tabs_api.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/extensions/api/tabs/tabs_api.cc?ref=016da29386308754274675e65fdb73cf9d59dc2d"", ""patch"": ""@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {\n     }\n   }\n \n-  // captureVisibleTab() can return an image containing sensitive information\n-  // that the browser would otherwise protect.  Ensure the extension has\n-  // permission to do this.\n-  if (!GetExtension()->CanCaptureVisiblePage(\n-        web_contents->GetURL(),\n-        SessionID::IdForTab(web_contents),\n-        &error_)) {\n+  // Use the last committed URL rather than the active URL for permissions\n+  // checking, since the visible page won't be updated until it has been\n+  // committed. A canonical example of this is interstitials, which show the\n+  // URL of the new/loading page (active) but would capture the content of the\n+  // old page (last committed).\n+  //\n+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.\n+  // http://crbug.com/237908.\n+  NavigationEntry* last_committed_entry =\n+      web_contents->GetController().GetLastCommittedEntry();\n+  GURL last_committed_url = last_committed_entry ?\n+      last_committed_entry->GetURL() : GURL();\n+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,\n+                                             SessionID::IdForTab(web_contents),\n+                                             &error_)) {\n     return false;\n   }\n ""}","bool GetBrowserFromWindowID(
    UIThreadExtensionFunction* function, int window_id, Browser** browser) {
  if (window_id == extension_misc::kCurrentWindowId) {
    *browser = function->GetCurrentBrowser();
    if (!(*browser) || !(*browser)->window()) {
      function->SetError(keys::kNoCurrentWindowError);
      return false;
    }
  } else {
    std::string error;
    *browser = GetBrowserInProfileWithId(
        function->profile(), window_id, function->include_incognito(), &error);
    if (!*browser) {
      function->SetError(error);
      return false;
    }
  }
  return true;
}
","bool GetBrowserFromWindowID(
    UIThreadExtensionFunction* function, int window_id, Browser** browser) {
  if (window_id == extension_misc::kCurrentWindowId) {
    *browser = function->GetCurrentBrowser();
    if (!(*browser) || !(*browser)->window()) {
      function->SetError(keys::kNoCurrentWindowError);
      return false;
    }
  } else {
    std::string error;
    *browser = GetBrowserInProfileWithId(
        function->profile(), window_id, function->include_incognito(), &error);
    if (!*browser) {
      function->SetError(error);
      return false;
    }
  }
  return true;
}
",C,,,,"@@ -1728,13 +1728,21 @@ bool TabsCaptureVisibleTabFunction::RunImpl() {
     }
   }
 
-  // captureVisibleTab() can return an image containing sensitive information
-  // that the browser would otherwise protect.  Ensure the extension has
-  // permission to do this.
-  if (!GetExtension()->CanCaptureVisiblePage(
-        web_contents->GetURL(),
-        SessionID::IdForTab(web_contents),
-        &error_)) {
+  // Use the last committed URL rather than the active URL for permissions
+  // checking, since the visible page won't be updated until it has been
+  // committed. A canonical example of this is interstitials, which show the
+  // URL of the new/loading page (active) but would capture the content of the
+  // old page (last committed).
+  //
+  // TODO(creis): Use WebContents::GetLastCommittedURL instead.
+  // http://crbug.com/237908.
+  NavigationEntry* last_committed_entry =
+      web_contents->GetController().GetLastCommittedEntry();
+  GURL last_committed_url = last_committed_entry ?
+      last_committed_entry->GetURL() : GURL();
+  if (!GetExtension()->CanCaptureVisiblePage(last_committed_url,
+                                             SessionID::IdForTab(web_contents),
+                                             &error_)) {
     return false;
   }
 ",Chrome,016da29386308754274675e65fdb73cf9d59dc2d,7b97cf95eb604105998ab67571c30725fe015ba8,0,"bool GetBrowserFromWindowID(
    UIThreadExtensionFunction* function, int window_id, Browser** browser) {
  if (window_id == extension_misc::kCurrentWindowId) {
    *browser = function->GetCurrentBrowser();
    if (!(*browser) || !(*browser)->window()) {
      function->SetError(keys::kNoCurrentWindowError);
      return false;
    }
  } else {
    std::string error;
    *browser = GetBrowserInProfileWithId(
        function->profile(), window_id, function->include_incognito(), &error);
    if (!*browser) {
      function->SetError(error);
      return false;
    }
  }
  return true;
}
"
35888,,Remote,Not required,Partial,CVE-2014-7841,https://www.cvedetails.com/cve/CVE-2014-7841/,CWE-399,Low,,,,2014-11-29,5.0,"The sctp_process_param function in net/sctp/sm_make_chunk.c in the SCTP implementation in the Linux kernel before 3.17.4, when ASCONF is used, allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via a malformed INIT chunk.",2017-01-02,DoS ,0,https://github.com/torvalds/linux/commit/e40607cbe270a9e8360907cb1e62ddf0736e4864,e40607cbe270a9e8360907cb1e62ddf0736e4864,"net: sctp: fix NULL pointer dereference in af->from_addr_param on malformed packet

An SCTP server doing ASCONF will panic on malformed INIT ping-of-death
in the form of:

  ------------ INIT[PARAM: SET_PRIMARY_IP] ------------>

While the INIT chunk parameter verification dissects through many things
in order to detect malformed input, it misses to actually check parameters
inside of parameters. E.g. RFC5061, section 4.2.4 proposes a 'set primary
IP address' parameter in ASCONF, which has as a subparameter an address
parameter.

So an attacker may send a parameter type other than SCTP_PARAM_IPV4_ADDRESS
or SCTP_PARAM_IPV6_ADDRESS, param_type2af() will subsequently return 0
and thus sctp_get_af_specific() returns NULL, too, which we then happily
dereference unconditionally through af->from_addr_param().

The trace for the log:

BUG: unable to handle kernel NULL pointer dereference at 0000000000000078
IP: [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]
PGD 0
Oops: 0000 [#1] SMP
[...]
Pid: 0, comm: swapper Not tainted 2.6.32-504.el6.x86_64 #1 Bochs Bochs
RIP: 0010:[<ffffffffa01e9c62>]  [<ffffffffa01e9c62>] sctp_process_init+0x492/0x990 [sctp]
[...]
Call Trace:
 <IRQ>
 [<ffffffffa01f2add>] ? sctp_bind_addr_copy+0x5d/0xe0 [sctp]
 [<ffffffffa01e1fcb>] sctp_sf_do_5_1B_init+0x21b/0x340 [sctp]
 [<ffffffffa01e3751>] sctp_do_sm+0x71/0x1210 [sctp]
 [<ffffffffa01e5c09>] ? sctp_endpoint_lookup_assoc+0xc9/0xf0 [sctp]
 [<ffffffffa01e61f6>] sctp_endpoint_bh_rcv+0x116/0x230 [sctp]
 [<ffffffffa01ee986>] sctp_inq_push+0x56/0x80 [sctp]
 [<ffffffffa01fcc42>] sctp_rcv+0x982/0xa10 [sctp]
 [<ffffffffa01d5123>] ? ipt_local_in_hook+0x23/0x28 [iptable_filter]
 [<ffffffff8148bdc9>] ? nf_iterate+0x69/0xb0
 [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
 [<ffffffff8148bf86>] ? nf_hook_slow+0x76/0x120
 [<ffffffff81496d10>] ? ip_local_deliver_finish+0x0/0x2d0
[...]

A minimal way to address this is to check for NULL as we do on all
other such occasions where we know sctp_get_af_specific() could
possibly return with NULL.

Fixes: d6de3097592b (""[SCTP]: Add the handling of ""Set Primary IP Address"" parameter to INIT"")
Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
Cc: Vlad Yasevich <vyasevich@gmail.com>
Acked-by: Neil Horman <nhorman@tuxdriver.com>
Signed-off-by: David S. Miller <davem@davemloft.net>",0,net/sctp/sm_make_chunk.c,"{""sha"": ""9f32741abb1c7b142265297dc2fac78b74b3d195"", ""filename"": ""net/sctp/sm_make_chunk.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/e40607cbe270a9e8360907cb1e62ddf0736e4864/net/sctp/sm_make_chunk.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/e40607cbe270a9e8360907cb1e62ddf0736e4864/net/sctp/sm_make_chunk.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/net/sctp/sm_make_chunk.c?ref=e40607cbe270a9e8360907cb1e62ddf0736e4864"", ""patch"": ""@@ -2609,6 +2609,9 @@ static int sctp_process_param(struct sctp_association *asoc,\n \t\taddr_param = param.v + sizeof(sctp_addip_param_t);\n \n \t\taf = sctp_get_af_specific(param_type2af(param.p->type));\n+\t\tif (af == NULL)\n+\t\t\tbreak;\n+\n \t\taf->from_addr_param(&addr, addr_param,\n \t\t\t\t    htons(asoc->peer.port), 0);\n ""}","static int sctp_process_inv_mandatory(const struct sctp_association *asoc,
				      struct sctp_chunk *chunk,
				      struct sctp_chunk **errp)
{
	/* Invalid Mandatory Parameter Error has no payload. */

	if (!*errp)
		*errp = sctp_make_op_error_space(asoc, chunk, 0);

	if (*errp)
		sctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);

	/* Stop processing this chunk. */
	return 0;
}
","static int sctp_process_inv_mandatory(const struct sctp_association *asoc,
				      struct sctp_chunk *chunk,
				      struct sctp_chunk **errp)
{
	/* Invalid Mandatory Parameter Error has no payload. */

	if (!*errp)
		*errp = sctp_make_op_error_space(asoc, chunk, 0);

	if (*errp)
		sctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);

	/* Stop processing this chunk. */
	return 0;
}
",C,,,,"@@ -2609,6 +2609,9 @@ static int sctp_process_param(struct sctp_association *asoc,
 		addr_param = param.v + sizeof(sctp_addip_param_t);
 
 		af = sctp_get_af_specific(param_type2af(param.p->type));
+		if (af == NULL)
+			break;
+
 		af->from_addr_param(&addr, addr_param,
 				    htons(asoc->peer.port), 0);
 ",linux,e40607cbe270a9e8360907cb1e62ddf0736e4864,5748eb8f8e989a9da1ac7c96dc73d68cbdedf7df,0,"static int sctp_process_inv_mandatory(const struct sctp_association *asoc,
				      struct sctp_chunk *chunk,
				      struct sctp_chunk **errp)
{
	/* Invalid Mandatory Parameter Error has no payload. */

	if (!*errp)
		*errp = sctp_make_op_error_space(asoc, chunk, 0);

	if (*errp)
		sctp_init_cause(*errp, SCTP_ERROR_INV_PARAM, 0);

	/* Stop processing this chunk. */
	return 0;
}
"
90611,,Local,Not required,Complete,CVE-2019-11599,https://www.cvedetails.com/cve/CVE-2019-11599/,CWE-362,Medium,Complete,Complete,,2019-04-29,6.9,"The coredump implementation in the Linux kernel before 5.0.10 does not use locking or other mechanisms to prevent vma layout or vma flags changes while it runs, which allows local users to obtain sensitive information, cause a denial of service, or possibly have unspecified other impact by triggering a race condition with mmget_not_zero or get_task_mm calls. This is related to fs/userfaultfd.c, mm/mmap.c, fs/proc/task_mmu.c, and drivers/infiniband/core/uverbs_main.c.",2019-05-28,DoS +Info ,0,https://github.com/torvalds/linux/commit/04f5866e41fb70690e28397487d8bd8eea7d712a,04f5866e41fb70690e28397487d8bd8eea7d712a,"coredump: fix race condition between mmget_not_zero()/get_task_mm() and core dumping

The core dumping code has always run without holding the mmap_sem for
writing, despite that is the only way to ensure that the entire vma
layout will not change from under it.  Only using some signal
serialization on the processes belonging to the mm is not nearly enough.
This was pointed out earlier.  For example in Hugh's post from Jul 2017:

  https://lkml.kernel.org/r/alpine.LSU.2.11.1707191716030.2055@eggly.anvils

  ""Not strictly relevant here, but a related note: I was very surprised
   to discover, only quite recently, how handle_mm_fault() may be called
   without down_read(mmap_sem) - when core dumping. That seems a
   misguided optimization to me, which would also be nice to correct""

In particular because the growsdown and growsup can move the
vm_start/vm_end the various loops the core dump does around the vma will
not be consistent if page faults can happen concurrently.

Pretty much all users calling mmget_not_zero()/get_task_mm() and then
taking the mmap_sem had the potential to introduce unexpected side
effects in the core dumping code.

Adding mmap_sem for writing around the ->core_dump invocation is a
viable long term fix, but it requires removing all copy user and page
faults and to replace them with get_dump_page() for all binary formats
which is not suitable as a short term fix.

For the time being this solution manually covers the places that can
confuse the core dump either by altering the vma layout or the vma flags
while it runs.  Once ->core_dump runs under mmap_sem for writing the
function mmget_still_valid() can be dropped.

Allowing mmap_sem protected sections to run in parallel with the
coredump provides some minor parallelism advantage to the swapoff code
(which seems to be safe enough by never mangling any vma field and can
keep doing swapins in parallel to the core dumping) and to some other
corner case.

In order to facilitate the backporting I added ""Fixes: 86039bd3b4e6""
however the side effect of this same race condition in /proc/pid/mem
should be reproducible since before 2.6.12-rc2 so I couldn't add any
other ""Fixes:"" because there's no hash beyond the git genesis commit.

Because find_extend_vma() is the only location outside of the process
context that could modify the ""mm"" structures under mmap_sem for
reading, by adding the mmget_still_valid() check to it, all other cases
that take the mmap_sem for reading don't need the new check after
mmget_not_zero()/get_task_mm().  The expand_stack() in page fault
context also doesn't need the new check, because all tasks under core
dumping are frozen.

Link: http://lkml.kernel.org/r/20190325224949.11068-1-aarcange@redhat.com
Fixes: 86039bd3b4e6 (""userfaultfd: add new syscall to provide memory externalization"")
Signed-off-by: Andrea Arcangeli <aarcange@redhat.com>
Reported-by: Jann Horn <jannh@google.com>
Suggested-by: Oleg Nesterov <oleg@redhat.com>
Acked-by: Peter Xu <peterx@redhat.com>
Reviewed-by: Mike Rapoport <rppt@linux.ibm.com>
Reviewed-by: Oleg Nesterov <oleg@redhat.com>
Reviewed-by: Jann Horn <jannh@google.com>
Acked-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Michal Hocko <mhocko@suse.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,mm/mmap.c,"{""sha"": ""f2e7ffe6fc546612f62da9cde853b9c1bf37d8bb"", ""filename"": ""drivers/infiniband/core/uverbs_main.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/04f5866e41fb70690e28397487d8bd8eea7d712a/drivers/infiniband/core/uverbs_main.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/04f5866e41fb70690e28397487d8bd8eea7d712a/drivers/infiniband/core/uverbs_main.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/infiniband/core/uverbs_main.c?ref=04f5866e41fb70690e28397487d8bd8eea7d712a"", ""patch"": ""@@ -993,6 +993,8 @@ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n \t\t * will only be one mm, so no big deal.\n \t\t */\n \t\tdown_write(&mm->mmap_sem);\n+\t\tif (!mmget_still_valid(mm))\n+\t\t\tgoto skip_mm;\n \t\tmutex_lock(&ufile->umap_lock);\n \t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n \t\t\t\t\t  list) {\n@@ -1007,6 +1009,7 @@ void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n \t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n \t\t}\n \t\tmutex_unlock(&ufile->umap_lock);\n+\tskip_mm:\n \t\tup_write(&mm->mmap_sem);\n \t\tmmput(mm);\n \t}""}<_**next**_>{""sha"": ""95ca1fe7283cff265247c6f3a84e5fa573299fca"", ""filename"": ""fs/proc/task_mmu.c"", ""status"": ""modified"", ""additions"": 18, ""deletions"": 0, ""changes"": 18, ""blob_url"": ""https://github.com/torvalds/linux/blob/04f5866e41fb70690e28397487d8bd8eea7d712a/fs/proc/task_mmu.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/04f5866e41fb70690e28397487d8bd8eea7d712a/fs/proc/task_mmu.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/proc/task_mmu.c?ref=04f5866e41fb70690e28397487d8bd8eea7d712a"", ""patch"": ""@@ -1143,6 +1143,24 @@ static ssize_t clear_refs_write(struct file *file, const char __user *buf,\n \t\t\t\t\tcount = -EINTR;\n \t\t\t\t\tgoto out_mm;\n \t\t\t\t}\n+\t\t\t\t/*\n+\t\t\t\t * Avoid to modify vma->vm_flags\n+\t\t\t\t * without locked ops while the\n+\t\t\t\t * coredump reads the vm_flags.\n+\t\t\t\t */\n+\t\t\t\tif (!mmget_still_valid(mm)) {\n+\t\t\t\t\t/*\n+\t\t\t\t\t * Silently return \""count\""\n+\t\t\t\t\t * like if get_task_mm()\n+\t\t\t\t\t * failed. FIXME: should this\n+\t\t\t\t\t * function have returned\n+\t\t\t\t\t * -ESRCH if get_task_mm()\n+\t\t\t\t\t * failed like if\n+\t\t\t\t\t * get_proc_task() fails?\n+\t\t\t\t\t */\n+\t\t\t\t\tup_write(&mm->mmap_sem);\n+\t\t\t\t\tgoto out_mm;\n+\t\t\t\t}\n \t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n \t\t\t\t\tvma->vm_flags &= ~VM_SOFTDIRTY;\n \t\t\t\t\tvma_set_page_prot(vma);""}<_**next**_>{""sha"": ""f5de1e726356a51c27ff529f98d99032650eb839"", ""filename"": ""fs/userfaultfd.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/torvalds/linux/blob/04f5866e41fb70690e28397487d8bd8eea7d712a/fs/userfaultfd.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/04f5866e41fb70690e28397487d8bd8eea7d712a/fs/userfaultfd.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/userfaultfd.c?ref=04f5866e41fb70690e28397487d8bd8eea7d712a"", ""patch"": ""@@ -629,6 +629,8 @@ static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n \n \t\t/* the various vma->vm_userfaultfd_ctx still points to it */\n \t\tdown_write(&mm->mmap_sem);\n+\t\t/* no task can run (and in turn coredump) yet */\n+\t\tVM_WARN_ON(!mmget_still_valid(mm));\n \t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n \t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n \t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n@@ -883,6 +885,8 @@ static int userfaultfd_release(struct inode *inode, struct file *file)\n \t * taking the mmap_sem for writing.\n \t */\n \tdown_write(&mm->mmap_sem);\n+\tif (!mmget_still_valid(mm))\n+\t\tgoto skip_mm;\n \tprev = NULL;\n \tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n \t\tcond_resched();\n@@ -905,6 +909,7 @@ static int userfaultfd_release(struct inode *inode, struct file *file)\n \t\tvma->vm_flags = new_flags;\n \t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n \t}\n+skip_mm:\n \tup_write(&mm->mmap_sem);\n \tmmput(mm);\n wakeup:\n@@ -1333,6 +1338,8 @@ static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n \t\tgoto out;\n \n \tdown_write(&mm->mmap_sem);\n+\tif (!mmget_still_valid(mm))\n+\t\tgoto out_unlock;\n \tvma = find_vma_prev(mm, start, &prev);\n \tif (!vma)\n \t\tgoto out_unlock;\n@@ -1520,6 +1527,8 @@ static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n \t\tgoto out;\n \n \tdown_write(&mm->mmap_sem);\n+\tif (!mmget_still_valid(mm))\n+\t\tgoto out_unlock;\n \tvma = find_vma_prev(mm, start, &prev);\n \tif (!vma)\n \t\tgoto out_unlock;""}<_**next**_>{""sha"": ""a3fda9f024c3c1988b6ff60954d7f7e74a9c1ecf"", ""filename"": ""include/linux/sched/mm.h"", ""status"": ""modified"", ""additions"": 21, ""deletions"": 0, ""changes"": 21, ""blob_url"": ""https://github.com/torvalds/linux/blob/04f5866e41fb70690e28397487d8bd8eea7d712a/include/linux/sched/mm.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/04f5866e41fb70690e28397487d8bd8eea7d712a/include/linux/sched/mm.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/sched/mm.h?ref=04f5866e41fb70690e28397487d8bd8eea7d712a"", ""patch"": ""@@ -49,6 +49,27 @@ static inline void mmdrop(struct mm_struct *mm)\n \t\t__mmdrop(mm);\n }\n \n+/*\n+ * This has to be called after a get_task_mm()/mmget_not_zero()\n+ * followed by taking the mmap_sem for writing before modifying the\n+ * vmas or anything the coredump pretends not to change from under it.\n+ *\n+ * NOTE: find_extend_vma() called from GUP context is the only place\n+ * that can modify the \""mm\"" (notably the vm_start/end) under mmap_sem\n+ * for reading and outside the context of the process, so it is also\n+ * the only case that holds the mmap_sem for reading that must call\n+ * this function. Generally if the mmap_sem is hold for reading\n+ * there's no need of this check after get_task_mm()/mmget_not_zero().\n+ *\n+ * This function can be obsoleted and the check can be removed, after\n+ * the coredump code will hold the mmap_sem for writing before\n+ * invoking the ->core_dump methods.\n+ */\n+static inline bool mmget_still_valid(struct mm_struct *mm)\n+{\n+\treturn likely(!mm->core_state);\n+}\n+\n /**\n  * mmget() - Pin the address space associated with a &struct mm_struct.\n  * @mm: The address space to pin.""}<_**next**_>{""sha"": ""bd7b9f293b391f22b85810e48bc7c0679b217f05"", ""filename"": ""mm/mmap.c"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 1, ""changes"": 7, ""blob_url"": ""https://github.com/torvalds/linux/blob/04f5866e41fb70690e28397487d8bd8eea7d712a/mm/mmap.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/04f5866e41fb70690e28397487d8bd8eea7d712a/mm/mmap.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/mmap.c?ref=04f5866e41fb70690e28397487d8bd8eea7d712a"", ""patch"": ""@@ -45,6 +45,7 @@\n #include <linux/moduleparam.h>\n #include <linux/pkeys.h>\n #include <linux/oom.h>\n+#include <linux/sched/mm.h>\n \n #include <linux/uaccess.h>\n #include <asm/cacheflush.h>\n@@ -2525,7 +2526,8 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)\n \tvma = find_vma_prev(mm, addr, &prev);\n \tif (vma && (vma->vm_start <= addr))\n \t\treturn vma;\n-\tif (!prev || expand_stack(prev, addr))\n+\t/* don't alter vm_end if the coredump is running */\n+\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n \t\treturn NULL;\n \tif (prev->vm_flags & VM_LOCKED)\n \t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n@@ -2551,6 +2553,9 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)\n \t\treturn vma;\n \tif (!(vma->vm_flags & VM_GROWSDOWN))\n \t\treturn NULL;\n+\t/* don't alter vm_start if the coredump is running */\n+\tif (!mmget_still_valid(mm))\n+\t\treturn NULL;\n \tstart = vma->vm_start;\n \tif (expand_stack(vma, addr))\n \t\treturn NULL;""}","struct vm_area_struct *vma_merge(struct mm_struct *mm,
			struct vm_area_struct *prev, unsigned long addr,
			unsigned long end, unsigned long vm_flags,
			struct anon_vma *anon_vma, struct file *file,
			pgoff_t pgoff, struct mempolicy *policy,
			struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
{
	pgoff_t pglen = (end - addr) >> PAGE_SHIFT;
	struct vm_area_struct *area, *next;
	int err;

	/*
	 * We later require that vma->vm_flags == vm_flags,
	 * so this tests vma->vm_flags & VM_SPECIAL, too.
	 */
	if (vm_flags & VM_SPECIAL)
		return NULL;

	if (prev)
		next = prev->vm_next;
	else
		next = mm->mmap;
	area = next;
	if (area && area->vm_end == end)		/* cases 6, 7, 8 */
		next = next->vm_next;

	/* verify some invariant that must be enforced by the caller */
	VM_WARN_ON(prev && addr <= prev->vm_start);
	VM_WARN_ON(area && end > area->vm_end);
	VM_WARN_ON(addr >= end);

	/*
	 * Can it merge with the predecessor?
	 */
	if (prev && prev->vm_end == addr &&
			mpol_equal(vma_policy(prev), policy) &&
			can_vma_merge_after(prev, vm_flags,
					    anon_vma, file, pgoff,
					    vm_userfaultfd_ctx)) {
		/*
		 * OK, it can.  Can we now merge in the successor as well?
		 */
		if (next && end == next->vm_start &&
				mpol_equal(policy, vma_policy(next)) &&
				can_vma_merge_before(next, vm_flags,
						     anon_vma, file,
						     pgoff+pglen,
						     vm_userfaultfd_ctx) &&
				is_mergeable_anon_vma(prev->anon_vma,
						      next->anon_vma, NULL)) {
							/* cases 1, 6 */
			err = __vma_adjust(prev, prev->vm_start,
					 next->vm_end, prev->vm_pgoff, NULL,
					 prev);
		} else					/* cases 2, 5, 7 */
			err = __vma_adjust(prev, prev->vm_start,
					 end, prev->vm_pgoff, NULL, prev);
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(prev, vm_flags);
		return prev;
	}

	/*
	 * Can this new request be merged in front of next?
	 */
	if (next && end == next->vm_start &&
			mpol_equal(policy, vma_policy(next)) &&
			can_vma_merge_before(next, vm_flags,
					     anon_vma, file, pgoff+pglen,
					     vm_userfaultfd_ctx)) {
		if (prev && addr < prev->vm_end)	/* case 4 */
			err = __vma_adjust(prev, prev->vm_start,
					 addr, prev->vm_pgoff, NULL, next);
		else {					/* cases 3, 8 */
			err = __vma_adjust(area, addr, next->vm_end,
					 next->vm_pgoff - pglen, NULL, next);
			/*
			 * In case 3 area is already equal to next and
			 * this is a noop, but in case 8 ""area"" has
			 * been removed and next was expanded over it.
			 */
			area = next;
		}
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(area, vm_flags);
		return area;
	}

	return NULL;
}
","struct vm_area_struct *vma_merge(struct mm_struct *mm,
			struct vm_area_struct *prev, unsigned long addr,
			unsigned long end, unsigned long vm_flags,
			struct anon_vma *anon_vma, struct file *file,
			pgoff_t pgoff, struct mempolicy *policy,
			struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
{
	pgoff_t pglen = (end - addr) >> PAGE_SHIFT;
	struct vm_area_struct *area, *next;
	int err;

	/*
	 * We later require that vma->vm_flags == vm_flags,
	 * so this tests vma->vm_flags & VM_SPECIAL, too.
	 */
	if (vm_flags & VM_SPECIAL)
		return NULL;

	if (prev)
		next = prev->vm_next;
	else
		next = mm->mmap;
	area = next;
	if (area && area->vm_end == end)		/* cases 6, 7, 8 */
		next = next->vm_next;

	/* verify some invariant that must be enforced by the caller */
	VM_WARN_ON(prev && addr <= prev->vm_start);
	VM_WARN_ON(area && end > area->vm_end);
	VM_WARN_ON(addr >= end);

	/*
	 * Can it merge with the predecessor?
	 */
	if (prev && prev->vm_end == addr &&
			mpol_equal(vma_policy(prev), policy) &&
			can_vma_merge_after(prev, vm_flags,
					    anon_vma, file, pgoff,
					    vm_userfaultfd_ctx)) {
		/*
		 * OK, it can.  Can we now merge in the successor as well?
		 */
		if (next && end == next->vm_start &&
				mpol_equal(policy, vma_policy(next)) &&
				can_vma_merge_before(next, vm_flags,
						     anon_vma, file,
						     pgoff+pglen,
						     vm_userfaultfd_ctx) &&
				is_mergeable_anon_vma(prev->anon_vma,
						      next->anon_vma, NULL)) {
							/* cases 1, 6 */
			err = __vma_adjust(prev, prev->vm_start,
					 next->vm_end, prev->vm_pgoff, NULL,
					 prev);
		} else					/* cases 2, 5, 7 */
			err = __vma_adjust(prev, prev->vm_start,
					 end, prev->vm_pgoff, NULL, prev);
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(prev, vm_flags);
		return prev;
	}

	/*
	 * Can this new request be merged in front of next?
	 */
	if (next && end == next->vm_start &&
			mpol_equal(policy, vma_policy(next)) &&
			can_vma_merge_before(next, vm_flags,
					     anon_vma, file, pgoff+pglen,
					     vm_userfaultfd_ctx)) {
		if (prev && addr < prev->vm_end)	/* case 4 */
			err = __vma_adjust(prev, prev->vm_start,
					 addr, prev->vm_pgoff, NULL, next);
		else {					/* cases 3, 8 */
			err = __vma_adjust(area, addr, next->vm_end,
					 next->vm_pgoff - pglen, NULL, next);
			/*
			 * In case 3 area is already equal to next and
			 * this is a noop, but in case 8 ""area"" has
			 * been removed and next was expanded over it.
			 */
			area = next;
		}
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(area, vm_flags);
		return area;
	}

	return NULL;
}
",C,,,,"@@ -45,6 +45,7 @@
 #include <linux/moduleparam.h>
 #include <linux/pkeys.h>
 #include <linux/oom.h>
+#include <linux/sched/mm.h>
 
 #include <linux/uaccess.h>
 #include <asm/cacheflush.h>
@@ -2525,7 +2526,8 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)
 	vma = find_vma_prev(mm, addr, &prev);
 	if (vma && (vma->vm_start <= addr))
 		return vma;
-	if (!prev || expand_stack(prev, addr))
+	/* don't alter vm_end if the coredump is running */
+	if (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))
 		return NULL;
 	if (prev->vm_flags & VM_LOCKED)
 		populate_vma_page_range(prev, addr, prev->vm_end, NULL);
@@ -2551,6 +2553,9 @@ find_extend_vma(struct mm_struct *mm, unsigned long addr)
 		return vma;
 	if (!(vma->vm_flags & VM_GROWSDOWN))
 		return NULL;
+	/* don't alter vm_start if the coredump is running */
+	if (!mmget_still_valid(mm))
+		return NULL;
 	start = vma->vm_start;
 	if (expand_stack(vma, addr))
 		return NULL;",linux,04f5866e41fb70690e28397487d8bd8eea7d712a,dce5b0bdeec61bdbee56121ceb1d014151d5cab1,0,"struct vm_area_struct *vma_merge(struct mm_struct *mm,
			struct vm_area_struct *prev, unsigned long addr,
			unsigned long end, unsigned long vm_flags,
			struct anon_vma *anon_vma, struct file *file,
			pgoff_t pgoff, struct mempolicy *policy,
			struct vm_userfaultfd_ctx vm_userfaultfd_ctx)
{
	pgoff_t pglen = (end - addr) >> PAGE_SHIFT;
	struct vm_area_struct *area, *next;
	int err;

	/*
	 * We later require that vma->vm_flags == vm_flags,
	 * so this tests vma->vm_flags & VM_SPECIAL, too.
	 */
	if (vm_flags & VM_SPECIAL)
		return NULL;

	if (prev)
		next = prev->vm_next;
	else
		next = mm->mmap;
	area = next;
	if (area && area->vm_end == end)		/* cases 6, 7, 8 */
		next = next->vm_next;

	/* verify some invariant that must be enforced by the caller */
	VM_WARN_ON(prev && addr <= prev->vm_start);
	VM_WARN_ON(area && end > area->vm_end);
	VM_WARN_ON(addr >= end);

	/*
	 * Can it merge with the predecessor?
	 */
	if (prev && prev->vm_end == addr &&
			mpol_equal(vma_policy(prev), policy) &&
			can_vma_merge_after(prev, vm_flags,
					    anon_vma, file, pgoff,
					    vm_userfaultfd_ctx)) {
		/*
		 * OK, it can.  Can we now merge in the successor as well?
		 */
		if (next && end == next->vm_start &&
				mpol_equal(policy, vma_policy(next)) &&
				can_vma_merge_before(next, vm_flags,
						     anon_vma, file,
						     pgoff+pglen,
						     vm_userfaultfd_ctx) &&
				is_mergeable_anon_vma(prev->anon_vma,
						      next->anon_vma, NULL)) {
							/* cases 1, 6 */
			err = __vma_adjust(prev, prev->vm_start,
					 next->vm_end, prev->vm_pgoff, NULL,
					 prev);
		} else					/* cases 2, 5, 7 */
			err = __vma_adjust(prev, prev->vm_start,
					 end, prev->vm_pgoff, NULL, prev);
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(prev, vm_flags);
		return prev;
	}

	/*
	 * Can this new request be merged in front of next?
	 */
	if (next && end == next->vm_start &&
			mpol_equal(policy, vma_policy(next)) &&
			can_vma_merge_before(next, vm_flags,
					     anon_vma, file, pgoff+pglen,
					     vm_userfaultfd_ctx)) {
		if (prev && addr < prev->vm_end)	/* case 4 */
			err = __vma_adjust(prev, prev->vm_start,
					 addr, prev->vm_pgoff, NULL, next);
		else {					/* cases 3, 8 */
			err = __vma_adjust(area, addr, next->vm_end,
					 next->vm_pgoff - pglen, NULL, next);
			/*
			 * In case 3 area is already equal to next and
			 * this is a noop, but in case 8 ""area"" has
			 * been removed and next was expanded over it.
			 */
			area = next;
		}
		if (err)
			return NULL;
		khugepaged_enter_vma_merge(area, vm_flags);
		return area;
	}

	return NULL;
}
"
46951,,Local,Not required,,CVE-2013-7421,https://www.cvedetails.com/cve/CVE-2013-7421/,CWE-264,Low,,Partial,,2015-03-02,2.1,"The Crypto API in the Linux kernel before 3.18.5 allows local users to load arbitrary kernel modules via a bind system call for an AF_ALG socket with a module name in the salg_name field, a different vulnerability than CVE-2014-9644.",2018-01-04,,0,https://github.com/torvalds/linux/commit/5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,"crypto: prefix module autoloading with ""crypto-""

This prefixes all crypto module loading with ""crypto-"" so we never run
the risk of exposing module auto-loading to userspace via a crypto API,
as demonstrated by Mathias Krause:

https://lkml.org/lkml/2013/3/4/70

Signed-off-by: Kees Cook <keescook@chromium.org>
Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>",0,arch/x86/crypto/crct10dif-pclmul_glue.c,"{""sha"": ""0409b8f897823f815af5581f0c9a73e29f80eaf8"", ""filename"": ""arch/arm/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -93,6 +93,6 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm (ASM)\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""e31b0440c6139dc932b0efd4b98aaab077cb862d"", ""filename"": ""arch/arm/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -171,5 +171,5 @@ module_exit(sha1_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm (ARM)\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_AUTHOR(\""David McCullough <ucdevel@gmail.com>\"");""}<_**next**_>{""sha"": ""0b0083757d477f4aef8bca9e82cfb155b6eecbfb"", ""filename"": ""arch/arm/crypto/sha1_neon_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha1_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha1_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -194,4 +194,4 @@ module_exit(sha1_neon_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, NEON accelerated\"");\n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""f3452c66059d57a045b0de6d4b6de6d242cb480c"", ""filename"": ""arch/arm/crypto/sha512_neon_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm/crypto/sha512_neon_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm/crypto/sha512_neon_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -301,5 +301,5 @@ module_exit(sha512_neon_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, NEON accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""0156a268e163f63e0f352a2dc91efe14adf0526c"", ""filename"": ""arch/arm64/crypto/aes-ce-ccm-glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-ce-ccm-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-ce-ccm-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -294,4 +294,4 @@ module_exit(aes_mod_exit);\n MODULE_DESCRIPTION(\""Synchronous AES in CCM mode using ARMv8 Crypto Extensions\"");\n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");\n MODULE_LICENSE(\""GPL v2\"");\n-MODULE_ALIAS(\""ccm(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ccm(aes)\"");""}<_**next**_>{""sha"": ""5f63a791b2fb58b6ae93a49c7dceca14421e0c12"", ""filename"": ""arch/arm64/crypto/aes-glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/arm64/crypto/aes-glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/arm64/crypto/aes-glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -38,10 +38,10 @@ MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 Crypto Extensions\"");\n #define aes_xts_encrypt\t\tneon_aes_xts_encrypt\n #define aes_xts_decrypt\t\tneon_aes_xts_decrypt\n MODULE_DESCRIPTION(\""AES-ECB/CBC/CTR/XTS using ARMv8 NEON\"");\n-MODULE_ALIAS(\""ecb(aes)\"");\n-MODULE_ALIAS(\""cbc(aes)\"");\n-MODULE_ALIAS(\""ctr(aes)\"");\n-MODULE_ALIAS(\""xts(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ecb(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""cbc(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""ctr(aes)\"");\n+MODULE_ALIAS_CRYPTO(\""xts(aes)\"");\n #endif\n \n MODULE_AUTHOR(\""Ard Biesheuvel <ard.biesheuvel@linaro.org>\"");""}<_**next**_>{""sha"": ""0f88c7b411196beeb3eb9d717ea24bf0cc958f00"", ""filename"": ""arch/powerpc/crypto/sha1.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/powerpc/crypto/sha1.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/powerpc/crypto/sha1.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -154,4 +154,4 @@ module_exit(sha1_powerpc_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1-powerpc\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-powerpc\"");""}<_**next**_>{""sha"": ""1f272b24fc0bf9393d44939ea2b225a84e36ea2a"", ""filename"": ""arch/s390/crypto/aes_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/aes_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/aes_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -979,7 +979,7 @@ static void __exit aes_s390_fini(void)\n module_init(aes_s390_init);\n module_exit(aes_s390_fini);\n \n-MODULE_ALIAS(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""9e05cc453a40d5fd946ecf56f1063f2446812695"", ""filename"": ""arch/s390/crypto/des_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/des_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/des_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -619,8 +619,8 @@ static void __exit des_s390_exit(void)\n module_init(des_s390_init);\n module_exit(des_s390_exit);\n \n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms\"");""}<_**next**_>{""sha"": ""7940dc90e80bc6729371ab565bad743b1087ef72"", ""filename"": ""arch/s390/crypto/ghash_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/ghash_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/ghash_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -160,7 +160,7 @@ static void __exit ghash_mod_exit(void)\n module_init(ghash_mod_init);\n module_exit(ghash_mod_exit);\n \n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, s390 implementation\"");""}<_**next**_>{""sha"": ""5b2bee323694b2144c382dd9af85126b81b311a8"", ""filename"": ""arch/s390/crypto/sha1_s390.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha1_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha1_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -103,6 +103,6 @@ static void __exit sha1_s390_fini(void)\n module_init(sha1_s390_init);\n module_exit(sha1_s390_fini);\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""b74ff158108c9421a25b26a02f3a1f1669d1f69d"", ""filename"": ""arch/s390/crypto/sha256_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha256_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha256_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -143,7 +143,7 @@ static void __exit sha256_s390_fini(void)\n module_init(sha256_s390_init);\n module_exit(sha256_s390_fini);\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 and SHA224 Secure Hash Algorithm\"");""}<_**next**_>{""sha"": ""0c36989ba182b1e411b56c3018ab610622cfe6ff"", ""filename"": ""arch/s390/crypto/sha512_s390.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/s390/crypto/sha512_s390.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/s390/crypto/sha512_s390.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -86,7 +86,7 @@ static struct shash_alg sha512_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n static int sha384_init(struct shash_desc *desc)\n {\n@@ -126,7 +126,7 @@ static struct shash_alg sha384_alg = {\n \t}\n };\n \n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n \n static int __init init(void)\n {""}<_**next**_>{""sha"": ""705408766ab0c07adcdd3d9e12c69b3bd3a9a20b"", ""filename"": ""arch/sparc/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -499,6 +499,6 @@ module_exit(aes_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""AES Secure Hash Algorithm, sparc64 aes opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""641f55cb61c3a89a9a8eabe12577170a6e62e572"", ""filename"": ""arch/sparc/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -322,6 +322,6 @@ module_exit(camellia_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, sparc64 camellia opcode accelerated\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1064e46efe8bea0b83d573e4b6eb0e35aef3596"", ""filename"": ""arch/sparc/crypto/crc32c_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/crc32c_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/crc32c_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -176,6 +176,6 @@ module_exit(crc32c_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli), sparc64 crc32c opcode accelerated\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""d1150097299479224e99f143e6657422cd4db157"", ""filename"": ""arch/sparc/crypto/des_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/des_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/des_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -532,6 +532,6 @@ module_exit(des_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""DES & Triple DES EDE Cipher Algorithms, sparc64 des opcode accelerated\"");\n \n-MODULE_ALIAS(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""64c7ff5f72a9f68fd19832eb6d4238e05b80c114"", ""filename"": ""arch/sparc/crypto/md5_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/md5_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/md5_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -185,6 +185,6 @@ module_exit(md5_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Secure Hash Algorithm, sparc64 md5 opcode accelerated\"");\n \n-MODULE_ALIAS(\""md5\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""1b3e47accc7466a90fb5729321df4e48273d7f31"", ""filename"": ""arch/sparc/crypto/sha1_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha1_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha1_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,6 +180,6 @@ module_exit(sha1_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, sparc64 sha1 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""41f27cca2a225ffd2d9d1bcd301e72287c3d42ae"", ""filename"": ""arch/sparc/crypto/sha256_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha256_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha256_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -237,7 +237,7 @@ module_exit(sha256_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm, sparc64 sha256 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""9fff88541b8c0fabedba624d9c135926eff64fb8"", ""filename"": ""arch/sparc/crypto/sha512_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/sparc/crypto/sha512_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/sparc/crypto/sha512_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,7 +222,7 @@ module_exit(sha512_sparc64_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-384 and SHA-512 Secure Hash Algorithm, sparc64 sha512 opcode accelerated\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n \n #include \""crop_devid.c\""""}<_**next**_>{""sha"": ""e26984f7ab8d2fa838168be1893c5eacdc375d33"", ""filename"": ""arch/x86/crypto/aes_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aes_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aes_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -66,5 +66,5 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, asm optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n-MODULE_ALIAS(\""aes-asm\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes-asm\"");""}<_**next**_>{""sha"": ""ae855f4f64b7755410701753f79608d0408880f9"", ""filename"": ""arch/x86/crypto/aesni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/aesni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/aesni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1546,4 +1546,4 @@ module_exit(aesni_exit);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm, Intel AES-NI instructions optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""17c05531dfd1752234eb9b6835f848b12ed07817"", ""filename"": ""arch/x86/crypto/blowfish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/blowfish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/blowfish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -478,5 +478,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""blowfish\"");\n-MODULE_ALIAS(\""blowfish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish-asm\"");""}<_**next**_>{""sha"": ""9a07fafe3831394c86da42758d3a1407628f03ab"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -582,5 +582,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX2 optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""ed38d959add6a8aa09f3e32285de6372eea3a7e8"", ""filename"": ""arch/x86/crypto/camellia_aesni_avx_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_aesni_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_aesni_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -574,5 +574,5 @@ module_exit(camellia_aesni_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, AES-NI/AVX optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""5c8b6266a394b45d4317d91b05adb6cc12b15219"", ""filename"": ""arch/x86/crypto/camellia_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/camellia_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/camellia_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1725,5 +1725,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""camellia\"");\n-MODULE_ALIAS(\""camellia-asm\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia-asm\"");""}<_**next**_>{""sha"": ""60ada677a92874e7d24fe00f1f309ce9c9a9a8bf"", ""filename"": ""arch/x86/crypto/cast5_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast5_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast5_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -491,4 +491,4 @@ module_exit(cast5_exit);\n \n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""0160f68a57ff33113c1a1b030d7919b56d86669e"", ""filename"": ""arch/x86/crypto/cast6_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/cast6_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/cast6_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -611,4 +611,4 @@ module_exit(cast6_exit);\n \n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""1937fc1d876338aa0aa9bb5fddea9e0aa3541707"", ""filename"": ""arch/x86/crypto/crc32-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -197,5 +197,5 @@ module_exit(crc32_pclmul_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32\"");\n-MODULE_ALIAS(\""crc32-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");\n+MODULE_ALIAS_CRYPTO(\""crc32-pclmul\"");""}<_**next**_>{""sha"": ""28640c3d6af7f6172a8fe39d4553c98019614e24"", ""filename"": ""arch/x86/crypto/crc32c-intel_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crc32c-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crc32c-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -280,5 +280,5 @@ MODULE_AUTHOR(\""Austin Zhang <austin.zhang@intel.com>, Kent Liu <kent.liu@intel.c\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) optimization using Intel Hardware.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crc32c\"");\n-MODULE_ALIAS(\""crc32c-intel\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c-intel\"");""}<_**next**_>{""sha"": ""b6c67bf30fdf6704f6d83b093ee73ae7d9b77fcf"", ""filename"": ""arch/x86/crypto/crct10dif-pclmul_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/crct10dif-pclmul_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/crct10dif-pclmul_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -147,5 +147,5 @@ MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation accelerated with PCLMULQDQ.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""crct10dif\"");\n-MODULE_ALIAS(\""crct10dif-pclmul\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif-pclmul\"");""}<_**next**_>{""sha"": ""38a14f818ef13f27cf7a7bb4b1de4064fbedf3f4"", ""filename"": ""arch/x86/crypto/des3_ede_glue.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/des3_ede_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/des3_ede_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -502,8 +502,8 @@ module_exit(des3_ede_x86_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Triple DES EDE Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""des3_ede\"");\n-MODULE_ALIAS(\""des3_ede-asm\"");\n-MODULE_ALIAS(\""des\"");\n-MODULE_ALIAS(\""des-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede-asm\"");\n+MODULE_ALIAS_CRYPTO(\""des\"");\n+MODULE_ALIAS_CRYPTO(\""des-asm\"");\n MODULE_AUTHOR(\""Jussi Kivilinna <jussi.kivilinna@iki.fi>\"");""}<_**next**_>{""sha"": ""8253d85aa16508f19249e1f3cee91356c565d1e3"", ""filename"": ""arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/ghash-clmulni-intel_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/ghash-clmulni-intel_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -341,4 +341,4 @@ module_exit(ghash_pclmulqdqni_mod_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm, \""\n \t\t   \""acclerated by PCLMULQDQ-NI\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""399a29d067d6367603714633fb8c4de6ab77275a"", ""filename"": ""arch/x86/crypto/salsa20_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/salsa20_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/salsa20_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -119,5 +119,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm (optimized assembly version)\"");\n-MODULE_ALIAS(\""salsa20\"");\n-MODULE_ALIAS(\""salsa20-asm\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20-asm\"");""}<_**next**_>{""sha"": ""437e47a4d302f584dfbeb3fef6ab76fc6e39008a"", ""filename"": ""arch/x86/crypto/serpent_avx2_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -558,5 +558,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX2 optimized\"");\n-MODULE_ALIAS(\""serpent\"");\n-MODULE_ALIAS(\""serpent-asm\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent-asm\"");""}<_**next**_>{""sha"": ""7e217398b4eb1d4656f59b1a90f707bd6028fe94"", ""filename"": ""arch/x86/crypto/serpent_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -617,4 +617,4 @@ module_exit(serpent_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""bf025adaea01bba090a09867490bd960a7674290"", ""filename"": ""arch/x86/crypto/serpent_sse2_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/serpent_sse2_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/serpent_sse2_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -618,4 +618,4 @@ module_exit(serpent_sse2_exit);\n \n MODULE_DESCRIPTION(\""Serpent Cipher Algorithm, SSE2 optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""6c20fe04a738df08e5428fb714e7c93770fcf748"", ""filename"": ""arch/x86/crypto/sha1_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha1_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha1_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -278,4 +278,4 @@ module_exit(sha1_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""4dc100d829025d86fcb2f5dc4d90148cd8db4270"", ""filename"": ""arch/x86/crypto/sha256_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha256_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha256_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -318,5 +318,5 @@ module_exit(sha256_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA256 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha256\"");\n-MODULE_ALIAS(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");""}<_**next**_>{""sha"": ""26a5898a6f2662c0407eb7bc0e20eadb08a03107"", ""filename"": ""arch/x86/crypto/sha512_ssse3_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/sha512_ssse3_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/sha512_ssse3_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -326,5 +326,5 @@ module_exit(sha512_ssse3_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA512 Secure Hash Algorithm, Supplemental SSE3 accelerated\"");\n \n-MODULE_ALIAS(\""sha512\"");\n-MODULE_ALIAS(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");""}<_**next**_>{""sha"": ""1ac531ea9bccca4d4eca5af299e54ff2bd6aa514"", ""filename"": ""arch/x86/crypto/twofish_avx_glue.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_avx_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_avx_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -579,4 +579,4 @@ module_exit(twofish_exit);\n \n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, AVX optimized\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""77e06c2da83d0ec5a9e468759727c0c25baca5b5"", ""filename"": ""arch/x86/crypto/twofish_glue.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -96,5 +96,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm, asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""56d8a08ee47908d06c80975428655629b5749c24"", ""filename"": ""arch/x86/crypto/twofish_glue_3way.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/arch/x86/crypto/twofish_glue_3way.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/crypto/twofish_glue_3way.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -495,5 +495,5 @@ module_exit(fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Twofish Cipher Algorithm, 3-way parallel asm optimized\"");\n-MODULE_ALIAS(\""twofish\"");\n-MODULE_ALIAS(\""twofish-asm\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish-asm\"");""}<_**next**_>{""sha"": ""b48f4f108c474104d484ceb316099ef78b20f5d3"", ""filename"": ""crypto/842.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/842.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/842.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -180,3 +180,4 @@ module_exit(nx842_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""842 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""842\"");""}<_**next**_>{""sha"": ""9b3c54c1cbe826a8cb031a9affb9079f0961d1c4"", ""filename"": ""crypto/aes_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/aes_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/aes_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1474,4 +1474,4 @@ module_exit(aes_fini);\n \n MODULE_DESCRIPTION(\""Rijndael (AES) Cipher Algorithm\"");\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""b4485a108389a2f13b0ca28949e4f6b932818277"", ""filename"": ""crypto/ansi_cprng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ansi_cprng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ansi_cprng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,4 +476,4 @@ module_param(dbg, int, 0);\n MODULE_PARM_DESC(dbg, \""Boolean to enable debugging (0/1 == off/on)\"");\n module_init(prng_mod_init);\n module_exit(prng_mod_fini);\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""4bb187c2a9027bab28e82370bd54f128602a25f1"", ""filename"": ""crypto/anubis.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/anubis.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/anubis.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -704,3 +704,4 @@ module_exit(anubis_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Anubis Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""anubis\"");""}<_**next**_>{""sha"": ""2a81e98a0021074b9ce8e2ac54eb876c1dcf7607"", ""filename"": ""crypto/api.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/api.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/api.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -216,11 +216,11 @@ struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n \n \talg = crypto_alg_lookup(name, type, mask);\n \tif (!alg) {\n-\t\trequest_module(\""%s\"", name);\n+\t\trequest_module(\""crypto-%s\"", name);\n \n \t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n \t\t      CRYPTO_ALG_NEED_FALLBACK))\n-\t\t\trequest_module(\""%s-all\"", name);\n+\t\t\trequest_module(\""crypto-%s-all\"", name);\n \n \t\talg = crypto_alg_lookup(name, type, mask);\n \t}""}<_**next**_>{""sha"": ""f1a81925558fa196650e3973daa44315caa613b0"", ""filename"": ""crypto/arc4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/arc4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/arc4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -166,3 +166,4 @@ module_exit(arc4_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""ARC4 Cipher Algorithm\"");\n MODULE_AUTHOR(\""Jon Oberheide <jon@oberheide.org>\"");\n+MODULE_ALIAS_CRYPTO(\""arc4\"");""}<_**next**_>{""sha"": ""7bd71f02d0dde233939716f3b0059cc758ab788c"", ""filename"": ""crypto/blowfish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/blowfish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/blowfish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -138,4 +138,4 @@ module_exit(blowfish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Blowfish Cipher Algorithm\"");\n-MODULE_ALIAS(\""blowfish\"");\n+MODULE_ALIAS_CRYPTO(\""blowfish\"");""}<_**next**_>{""sha"": ""1b74c5a3e8910741cac8c92e292b041eff40e714"", ""filename"": ""crypto/camellia_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/camellia_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/camellia_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1098,4 +1098,4 @@ module_exit(camellia_fini);\n \n MODULE_DESCRIPTION(\""Camellia Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""camellia\"");\n+MODULE_ALIAS_CRYPTO(\""camellia\"");""}<_**next**_>{""sha"": ""84c86db67ec7a88a85fd92a93ad07af6eb935564"", ""filename"": ""crypto/cast5_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast5_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast5_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -549,4 +549,4 @@ module_exit(cast5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast5 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast5\"");\n+MODULE_ALIAS_CRYPTO(\""cast5\"");""}<_**next**_>{""sha"": ""f408f0bd8de2525ac369ae68c4bd5a5187b22e1d"", ""filename"": ""crypto/cast6_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/cast6_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/cast6_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -291,4 +291,4 @@ module_exit(cast6_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Cast6 Cipher Algorithm\"");\n-MODULE_ALIAS(\""cast6\"");\n+MODULE_ALIAS_CRYPTO(\""cast6\"");""}<_**next**_>{""sha"": ""647575b412815f6ee672846117e6b23deef72d07"", ""filename"": ""crypto/ccm.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ccm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ccm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -879,5 +879,5 @@ module_exit(crypto_ccm_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Counter with CBC MAC\"");\n-MODULE_ALIAS(\""ccm_base\"");\n-MODULE_ALIAS(\""rfc4309\"");\n+MODULE_ALIAS_CRYPTO(\""ccm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4309\"");""}<_**next**_>{""sha"": ""187ded28cb0bd76825475dfd3b4684d8043de752"", ""filename"": ""crypto/crc32.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -156,3 +156,4 @@ module_exit(crc32_mod_fini);\n MODULE_AUTHOR(\""Alexander Boyko <alexander_boyko@xyratex.com>\"");\n MODULE_DESCRIPTION(\""CRC32 calculations wrapper for lib/crc32\"");\n MODULE_LICENSE(\""GPL\"");\n+MODULE_ALIAS_CRYPTO(\""crc32\"");""}<_**next**_>{""sha"": ""2a062025749d925f858939933ebe67283f158562"", ""filename"": ""crypto/crc32c_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crc32c_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crc32c_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -170,5 +170,5 @@ module_exit(crc32c_mod_fini);\n MODULE_AUTHOR(\""Clay Haapala <chaapala@cisco.com>\"");\n MODULE_DESCRIPTION(\""CRC32c (Castagnoli) calculations wrapper for lib/crc32c\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crc32c\"");\n+MODULE_ALIAS_CRYPTO(\""crc32c\"");\n MODULE_SOFTDEP(\""pre: crc32c\"");""}<_**next**_>{""sha"": ""08bb4f50452085b65c0ed263a84f5c8298142149"", ""filename"": ""crypto/crct10dif_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crct10dif_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crct10dif_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -124,4 +124,4 @@ module_exit(crct10dif_mod_fini);\n MODULE_AUTHOR(\""Tim Chen <tim.c.chen@linux.intel.com>\"");\n MODULE_DESCRIPTION(\""T10 DIF CRC calculation.\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""crct10dif\"");\n+MODULE_ALIAS_CRYPTO(\""crct10dif\"");""}<_**next**_>{""sha"": ""a20319132e338e7a8e606f9f8d04b3d310741857"", ""filename"": ""crypto/crypto_null.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/crypto_null.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/crypto_null.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -145,9 +145,9 @@ static struct crypto_alg null_algs[3] = { {\n \t.coa_decompress\t\t=\tnull_compress } }\n } };\n \n-MODULE_ALIAS(\""compress_null\"");\n-MODULE_ALIAS(\""digest_null\"");\n-MODULE_ALIAS(\""cipher_null\"");\n+MODULE_ALIAS_CRYPTO(\""compress_null\"");\n+MODULE_ALIAS_CRYPTO(\""digest_null\"");\n+MODULE_ALIAS_CRYPTO(\""cipher_null\"");\n \n static int __init crypto_null_mod_init(void)\n {""}<_**next**_>{""sha"": ""3d81ff7e6b4894fa34072db80cf069ea966f1537"", ""filename"": ""crypto/ctr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ctr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ctr.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -466,4 +466,4 @@ module_exit(crypto_ctr_module_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""CTR Counter block mode\"");\n-MODULE_ALIAS(\""rfc3686\"");\n+MODULE_ALIAS_CRYPTO(\""rfc3686\"");""}<_**next**_>{""sha"": ""95d8d37c502183b9e426925928aa5c578523cb7d"", ""filename"": ""crypto/deflate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/deflate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/deflate.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -222,4 +222,4 @@ module_exit(deflate_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Deflate Compression Algorithm for IPCOMP\"");\n MODULE_AUTHOR(\""James Morris <jmorris@intercode.com.au>\"");\n-\n+MODULE_ALIAS_CRYPTO(\""deflate\"");""}<_**next**_>{""sha"": ""42912948776b1426ec71f2e6fe3d5debd3d67e72"", ""filename"": ""crypto/des_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/des_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/des_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -983,7 +983,7 @@ static struct crypto_alg des_algs[2] = { {\n \t.cia_decrypt\t\t=\tdes3_ede_decrypt } }\n } };\n \n-MODULE_ALIAS(\""des3_ede\"");\n+MODULE_ALIAS_CRYPTO(\""des3_ede\"");\n \n static int __init des_generic_mod_init(void)\n {""}<_**next**_>{""sha"": ""77286ea28865bf4ce5d97f4a556b8aeeed443b14"", ""filename"": ""crypto/fcrypt.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/fcrypt.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/fcrypt.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -420,3 +420,4 @@ module_exit(fcrypt_mod_fini);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_DESCRIPTION(\""FCrypt Cipher Algorithm\"");\n MODULE_AUTHOR(\""David Howells <dhowells@redhat.com>\"");\n+MODULE_ALIAS_CRYPTO(\""fcrypt\"");""}<_**next**_>{""sha"": ""aefb74a3f522babbebe18f69c9eaf03ed5e179e6"", ""filename"": ""crypto/gcm.c"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/gcm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/gcm.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1441,6 +1441,6 @@ module_exit(crypto_gcm_module_exit);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Galois/Counter Mode\"");\n MODULE_AUTHOR(\""Mikko Herranen <mh1@iki.fi>\"");\n-MODULE_ALIAS(\""gcm_base\"");\n-MODULE_ALIAS(\""rfc4106\"");\n-MODULE_ALIAS(\""rfc4543\"");\n+MODULE_ALIAS_CRYPTO(\""gcm_base\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4106\"");\n+MODULE_ALIAS_CRYPTO(\""rfc4543\"");""}<_**next**_>{""sha"": ""4e97fae9666f6fd549235ea60c93f999ad00699c"", ""filename"": ""crypto/ghash-generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/ghash-generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/ghash-generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -172,4 +172,4 @@ module_exit(ghash_mod_exit);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""GHASH Message Digest Algorithm\"");\n-MODULE_ALIAS(\""ghash\"");\n+MODULE_ALIAS_CRYPTO(\""ghash\"");""}<_**next**_>{""sha"": ""873eb5ded6d7ae2f24e96221a131d5936d4101bd"", ""filename"": ""crypto/khazad.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/khazad.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/khazad.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -880,3 +880,4 @@ module_exit(khazad_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Khazad Cryptographic Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""khazad\"");""}<_**next**_>{""sha"": ""67c88b3312107c7c16e9732fa9ffba38172629f4"", ""filename"": ""crypto/krng.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/krng.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/krng.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -62,4 +62,4 @@ module_exit(krng_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Kernel Random Number Generator\"");\n-MODULE_ALIAS(\""stdrng\"");\n+MODULE_ALIAS_CRYPTO(\""stdrng\"");""}<_**next**_>{""sha"": ""aefbceaf3104f0df1904dbae4d0c193152f62c07"", ""filename"": ""crypto/lz4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4 Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4\"");""}<_**next**_>{""sha"": ""a1d3b5bd3d85118c681098382fb2dd00adc1dac8"", ""filename"": ""crypto/lz4hc.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lz4hc.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lz4hc.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -104,3 +104,4 @@ module_exit(lz4hc_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZ4HC Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lz4hc\"");""}<_**next**_>{""sha"": ""4b3e92525dac5a47f3415f46c9eb403813b44275"", ""filename"": ""crypto/lzo.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/lzo.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/lzo.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -107,3 +107,4 @@ module_exit(lzo_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""LZO Compression Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""lzo\"");""}<_**next**_>{""sha"": ""3515af425cc917b60669c6dbb1a460f1da1919c4"", ""filename"": ""crypto/md4.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md4.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md4.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -255,4 +255,4 @@ module_exit(md4_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD4 Message Digest Algorithm\"");\n-\n+MODULE_ALIAS_CRYPTO(\""md4\"");""}<_**next**_>{""sha"": ""36f5e5b103f302dbeda611466fb97ab94b87511f"", ""filename"": ""crypto/md5.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/md5.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/md5.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -168,3 +168,4 @@ module_exit(md5_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""MD5 Message Digest Algorithm\"");\n+MODULE_ALIAS_CRYPTO(\""md5\"");""}<_**next**_>{""sha"": ""46195e0d0f4d1d30dd20b3bdc8f987ea14176643"", ""filename"": ""crypto/michael_mic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/michael_mic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/michael_mic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -184,3 +184,4 @@ module_exit(michael_mic_exit);\n MODULE_LICENSE(\""GPL v2\"");\n MODULE_DESCRIPTION(\""Michael MIC\"");\n MODULE_AUTHOR(\""Jouni Malinen <j@w1.fi>\"");\n+MODULE_ALIAS_CRYPTO(\""michael_mic\"");""}<_**next**_>{""sha"": ""049486ede938faa3ecc5254d91d3da529467d388"", ""filename"": ""crypto/rmd128.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd128.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd128.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -327,3 +327,4 @@ module_exit(rmd128_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-128 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd128\"");""}<_**next**_>{""sha"": ""de585e51d455f9a5070b62a59540b01cf096b8ec"", ""filename"": ""crypto/rmd160.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd160.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd160.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -371,3 +371,4 @@ module_exit(rmd160_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-160 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd160\"");""}<_**next**_>{""sha"": ""4ec02a754e0992e5700fe683f89dde754fa1d1b8"", ""filename"": ""crypto/rmd256.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd256.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd256.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -346,3 +346,4 @@ module_exit(rmd256_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-256 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd256\"");""}<_**next**_>{""sha"": ""770f2cb369f870a74d2c19fdf943be5ecf5ae54a"", ""filename"": ""crypto/rmd320.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/rmd320.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/rmd320.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -395,3 +395,4 @@ module_exit(rmd320_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Adrian-Ken Rueegsegger <ken@codelabs.ch>\"");\n MODULE_DESCRIPTION(\""RIPEMD-320 Message Digest\"");\n+MODULE_ALIAS_CRYPTO(\""rmd320\"");""}<_**next**_>{""sha"": ""3d0f9df30ac9fe368baa63598db9426c2cd8657a"", ""filename"": ""crypto/salsa20_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/salsa20_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/salsa20_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -248,4 +248,4 @@ module_exit(salsa20_generic_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Salsa20 stream cipher algorithm\"");\n-MODULE_ALIAS(\""salsa20\"");\n+MODULE_ALIAS_CRYPTO(\""salsa20\"");""}<_**next**_>{""sha"": ""c6ba8438be430f59988e52a158d306dcb832c5fe"", ""filename"": ""crypto/seed.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/seed.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/seed.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -476,3 +476,4 @@ module_exit(seed_fini);\n MODULE_DESCRIPTION(\""SEED Cipher Algorithm\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Hye-Shik Chang <perky@FreeBSD.org>, Kim Hyun <hkim@kisa.or.kr>\"");\n+MODULE_ALIAS_CRYPTO(\""seed\"");""}<_**next**_>{""sha"": ""a53b5e2af335c95d046b85c0162dd0a5bb25e5e4"", ""filename"": ""crypto/serpent_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/serpent_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/serpent_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -665,5 +665,5 @@ module_exit(serpent_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Serpent and tnepres (kerneli compatible serpent reversed) Cipher Algorithm\"");\n MODULE_AUTHOR(\""Dag Arne Osvik <osvik@ii.uib.no>\"");\n-MODULE_ALIAS(\""tnepres\"");\n-MODULE_ALIAS(\""serpent\"");\n+MODULE_ALIAS_CRYPTO(\""tnepres\"");\n+MODULE_ALIAS_CRYPTO(\""serpent\"");""}<_**next**_>{""sha"": ""039e58cfa155655f42aec3ddcb8d2761aa22b264"", ""filename"": ""crypto/sha1_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha1_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha1_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -153,4 +153,4 @@ module_exit(sha1_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA1 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha1\"");\n+MODULE_ALIAS_CRYPTO(\""sha1\"");""}<_**next**_>{""sha"": ""5eb21b1200333e95c73f11d3343183c37331544c"", ""filename"": ""crypto/sha256_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha256_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha256_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -384,5 +384,5 @@ module_exit(sha256_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-224 and SHA-256 Secure Hash Algorithm\"");\n \n-MODULE_ALIAS(\""sha224\"");\n-MODULE_ALIAS(\""sha256\"");\n+MODULE_ALIAS_CRYPTO(\""sha224\"");\n+MODULE_ALIAS_CRYPTO(\""sha256\"");""}<_**next**_>{""sha"": ""8d0b19ed4f4b3fb90df2266132f5877a488b1e1c"", ""filename"": ""crypto/sha512_generic.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/sha512_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/sha512_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -288,5 +288,5 @@ module_exit(sha512_generic_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""SHA-512 and SHA-384 Secure Hash Algorithms\"");\n \n-MODULE_ALIAS(\""sha384\"");\n-MODULE_ALIAS(\""sha512\"");\n+MODULE_ALIAS_CRYPTO(\""sha384\"");\n+MODULE_ALIAS_CRYPTO(\""sha512\"");""}<_**next**_>{""sha"": ""495be2d0077d4a2828323d2d9ec187964cd74948"", ""filename"": ""crypto/tea.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tea.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tea.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -270,8 +270,8 @@ static void __exit tea_mod_fini(void)\n \tcrypto_unregister_algs(tea_algs, ARRAY_SIZE(tea_algs));\n }\n \n-MODULE_ALIAS(\""xtea\"");\n-MODULE_ALIAS(\""xeta\"");\n+MODULE_ALIAS_CRYPTO(\""xtea\"");\n+MODULE_ALIAS_CRYPTO(\""xeta\"");\n \n module_init(tea_mod_init);\n module_exit(tea_mod_fini);""}<_**next**_>{""sha"": ""6e5651c66cf8a783b235e1f8551154e8e01641de"", ""filename"": ""crypto/tgr192.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/tgr192.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/tgr192.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -676,8 +676,8 @@ static void __exit tgr192_mod_fini(void)\n \tcrypto_unregister_shashes(tgr_algs, ARRAY_SIZE(tgr_algs));\n }\n \n-MODULE_ALIAS(\""tgr160\"");\n-MODULE_ALIAS(\""tgr128\"");\n+MODULE_ALIAS_CRYPTO(\""tgr160\"");\n+MODULE_ALIAS_CRYPTO(\""tgr128\"");\n \n module_init(tgr192_mod_init);\n module_exit(tgr192_mod_fini);""}<_**next**_>{""sha"": ""523ad8c4e35918329cc08ef979d58a678f52dc5d"", ""filename"": ""crypto/twofish_generic.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/twofish_generic.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/twofish_generic.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -211,4 +211,4 @@ module_exit(twofish_mod_fini);\n \n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION (\""Twofish Cipher Algorithm\"");\n-MODULE_ALIAS(\""twofish\"");\n+MODULE_ALIAS_CRYPTO(\""twofish\"");""}<_**next**_>{""sha"": ""0de42eb3d0400b895de0cf8e70e1015dd137ff87"", ""filename"": ""crypto/wp512.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/wp512.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/wp512.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1167,8 +1167,8 @@ static void __exit wp512_mod_fini(void)\n \tcrypto_unregister_shashes(wp_algs, ARRAY_SIZE(wp_algs));\n }\n \n-MODULE_ALIAS(\""wp384\"");\n-MODULE_ALIAS(\""wp256\"");\n+MODULE_ALIAS_CRYPTO(\""wp384\"");\n+MODULE_ALIAS_CRYPTO(\""wp256\"");\n \n module_init(wp512_mod_init);\n module_exit(wp512_mod_fini);""}<_**next**_>{""sha"": ""0eefa9d237ace7f3b607bbfcc4f657580eaa60a0"", ""filename"": ""crypto/zlib.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/crypto/zlib.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/crypto/zlib.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -378,3 +378,4 @@ module_exit(zlib_mod_fini);\n MODULE_LICENSE(\""GPL\"");\n MODULE_DESCRIPTION(\""Zlib Compression Algorithm\"");\n MODULE_AUTHOR(\""Sony Corporation\"");\n+MODULE_ALIAS_CRYPTO(\""zlib\"");""}<_**next**_>{""sha"": ""c178ed8c3908d3a92e55432aecb86e0e6e1501ee"", ""filename"": ""drivers/crypto/padlock-aes.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-aes.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-aes.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -563,4 +563,4 @@ MODULE_DESCRIPTION(\""VIA PadLock AES algorithm support\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""aes\"");\n+MODULE_ALIAS_CRYPTO(\""aes\"");""}<_**next**_>{""sha"": ""95f7d27ce491f000458a257e5dfa55a6105b433b"", ""filename"": ""drivers/crypto/padlock-sha.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/padlock-sha.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/padlock-sha.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -593,7 +593,7 @@ MODULE_DESCRIPTION(\""VIA PadLock SHA1/SHA256 algorithms support.\"");\n MODULE_LICENSE(\""GPL\"");\n MODULE_AUTHOR(\""Michal Ludvig\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""sha1-padlock\"");\n-MODULE_ALIAS(\""sha256-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-padlock\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-padlock\"");""}<_**next**_>{""sha"": ""7ee93f881db698af823bbd5d94fe0a01abcd900f"", ""filename"": ""drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/qat/qat_common/adf_ctl_drv.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/qat/qat_common/adf_ctl_drv.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -52,6 +52,7 @@\n #include <linux/pci.h>\n #include <linux/cdev.h>\n #include <linux/uaccess.h>\n+#include <linux/crypto.h>\n \n #include \""adf_accel_devices.h\""\n #include \""adf_common_drv.h\""\n@@ -487,4 +488,4 @@ module_exit(adf_unregister_ctl_device_driver);\n MODULE_LICENSE(\""Dual BSD/GPL\"");\n MODULE_AUTHOR(\""Intel\"");\n MODULE_DESCRIPTION(\""Intel(R) QuickAssist Technology\"");\n-MODULE_ALIAS(\""intel_qat\"");\n+MODULE_ALIAS_CRYPTO(\""intel_qat\"");""}<_**next**_>{""sha"": ""7c035de9055e51548003dbb6c8770ce833e3f492"", ""filename"": ""drivers/crypto/ux500/cryp/cryp_core.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/cryp/cryp_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/cryp/cryp_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1812,7 +1812,7 @@ module_exit(ux500_cryp_mod_fini);\n module_param(cryp_mode, int, 0);\n \n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 CRYP crypto engine.\"");\n-MODULE_ALIAS(\""aes-all\"");\n-MODULE_ALIAS(\""des-all\"");\n+MODULE_ALIAS_CRYPTO(\""aes-all\"");\n+MODULE_ALIAS_CRYPTO(\""des-all\"");\n \n MODULE_LICENSE(\""GPL\"");""}<_**next**_>{""sha"": ""76ecc8d143d0f674c29618da5a86df788671845d"", ""filename"": ""drivers/crypto/ux500/hash/hash_core.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/crypto/ux500/hash/hash_core.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/crypto/ux500/hash/hash_core.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -1997,7 +1997,7 @@ module_exit(ux500_hash_mod_fini);\n MODULE_DESCRIPTION(\""Driver for ST-Ericsson UX500 HASH engine.\"");\n MODULE_LICENSE(\""GPL\"");\n \n-MODULE_ALIAS(\""sha1-all\"");\n-MODULE_ALIAS(\""sha256-all\"");\n-MODULE_ALIAS(\""hmac-sha1-all\"");\n-MODULE_ALIAS(\""hmac-sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""sha256-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha1-all\"");\n+MODULE_ALIAS_CRYPTO(\""hmac-sha256-all\"");""}<_**next**_>{""sha"": ""91e97ec0141892cbf4d1676480d5fda3223b0e6b"", ""filename"": ""drivers/s390/crypto/ap_bus.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/drivers/s390/crypto/ap_bus.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/s390/crypto/ap_bus.c?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -44,6 +44,7 @@\n #include <linux/hrtimer.h>\n #include <linux/ktime.h>\n #include <asm/facility.h>\n+#include <linux/crypto.h>\n \n #include \""ap_bus.h\""\n \n@@ -71,7 +72,7 @@ MODULE_AUTHOR(\""IBM Corporation\"");\n MODULE_DESCRIPTION(\""Adjunct Processor Bus driver, \"" \\\n \t\t   \""Copyright IBM Corp. 2006, 2012\"");\n MODULE_LICENSE(\""GPL\"");\n-MODULE_ALIAS(\""z90crypt\"");\n+MODULE_ALIAS_CRYPTO(\""z90crypt\"");\n \n /*\n  * Module parameter""}<_**next**_>{""sha"": ""9c8776d0ada87bcf9fa70bc401ce69e336b93d74"", ""filename"": ""include/linux/crypto.h"", ""status"": ""modified"", ""additions"": 13, ""deletions"": 0, ""changes"": 13, ""blob_url"": ""https://github.com/torvalds/linux/blob/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/5d26a105b5a73e5635eae0629b42fa0a90e07b7b/include/linux/crypto.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/include/linux/crypto.h?ref=5d26a105b5a73e5635eae0629b42fa0a90e07b7b"", ""patch"": ""@@ -25,6 +25,19 @@\n #include <linux/string.h>\n #include <linux/uaccess.h>\n \n+/*\n+ * Autoloaded crypto modules should only use a prefixed name to avoid allowing\n+ * arbitrary modules to be loaded. Loading from userspace may still need the\n+ * unprefixed names, so retains those aliases as well.\n+ * This uses __MODULE_INFO directly instead of MODULE_ALIAS because pre-4.3\n+ * gcc (e.g. avr32 toolchain) uses __LINE__ for uniqueness, and this macro\n+ * expands twice on the same line. Instead, use a separate base name for the\n+ * alias.\n+ */\n+#define MODULE_ALIAS_CRYPTO(name)\t\\\n+\t\t__MODULE_INFO(alias, alias_userspace, name);\t\\\n+\t\t__MODULE_INFO(alias, alias_crypto, \""crypto-\"" name)\n+\n /*\n  * Algorithm masks and types.\n  */""}","static int chksum_finup(struct shash_desc *desc, const u8 *data,
			unsigned int len, u8 *out)
{
	struct chksum_desc_ctx *ctx = shash_desc_ctx(desc);

	return __chksum_finup(&ctx->crc, data, len, out);
}
","static int chksum_finup(struct shash_desc *desc, const u8 *data,
			unsigned int len, u8 *out)
{
	struct chksum_desc_ctx *ctx = shash_desc_ctx(desc);

	return __chksum_finup(&ctx->crc, data, len, out);
}
",C,,,,"@@ -147,5 +147,5 @@ MODULE_AUTHOR(""Tim Chen <tim.c.chen@linux.intel.com>"");
 MODULE_DESCRIPTION(""T10 DIF CRC calculation accelerated with PCLMULQDQ."");
 MODULE_LICENSE(""GPL"");
 
-MODULE_ALIAS(""crct10dif"");
-MODULE_ALIAS(""crct10dif-pclmul"");
+MODULE_ALIAS_CRYPTO(""crct10dif"");
+MODULE_ALIAS_CRYPTO(""crct10dif-pclmul"");",linux,5d26a105b5a73e5635eae0629b42fa0a90e07b7b,5d4a5e770d97d87082067886e7097c920b338da5,0,"static int chksum_finup(struct shash_desc *desc, const u8 *data,
			unsigned int len, u8 *out)
{
	struct chksum_desc_ctx *ctx = shash_desc_ctx(desc);

	return __chksum_finup(&ctx->crc, data, len, out);
}
"
36439,,Remote,Not required,Partial,CVE-2014-4668,https://www.cvedetails.com/cve/CVE-2014-4668/,CWE-287,Medium,Partial,Partial,,2014-07-02,6.8,"The cherokee_validator_ldap_check function in validator_ldap.c in Cherokee 1.2.103 and earlier, when LDAP is used, does not properly consider unauthenticated-bind semantics, which allows remote attackers to bypass authentication via an empty password.",2017-01-02,Bypass ,0,https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88,fbda667221c51f0aa476a02366e0cf66cb012f88,Prevent the LDAP validator from accepting an empty password.,0,cherokee/validator_ldap.c,"{""sha"": ""417fd9e4bc44b50c98e90e1aeeaa0022cf56b960"", ""filename"": ""cherokee/validator_ldap.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/cherokee/webserver/blob/fbda667221c51f0aa476a02366e0cf66cb012f88/cherokee/validator_ldap.c"", ""raw_url"": ""https://github.com/cherokee/webserver/raw/fbda667221c51f0aa476a02366e0cf66cb012f88/cherokee/validator_ldap.c"", ""contents_url"": ""https://api.github.com/repos/cherokee/webserver/contents/cherokee/validator_ldap.c?ref=fbda667221c51f0aa476a02366e0cf66cb012f88"", ""patch"": ""@@ -335,7 +335,8 @@ cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n \t/* Sanity checks\n \t */\n \tif ((conn->validator == NULL) ||\n-\t    cherokee_buffer_is_empty (&conn->validator->user))\n+\t    cherokee_buffer_is_empty (&conn->validator->user) ||\n+\t    cherokee_buffer_is_empty (&conn->validator->passwd))\n \t\treturn ret_error;\n \n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \""*()\"");""}","props_free (cherokee_validator_ldap_props_t *props)
{
	cherokee_buffer_mrproper (&props->server);
	cherokee_buffer_mrproper (&props->binddn);
	cherokee_buffer_mrproper (&props->bindpw);
	cherokee_buffer_mrproper (&props->basedn);
	cherokee_buffer_mrproper (&props->filter);
	cherokee_buffer_mrproper (&props->ca_file);

	return cherokee_validator_props_free_base (VALIDATOR_PROPS(props));
}
","props_free (cherokee_validator_ldap_props_t *props)
{
	cherokee_buffer_mrproper (&props->server);
	cherokee_buffer_mrproper (&props->binddn);
	cherokee_buffer_mrproper (&props->bindpw);
	cherokee_buffer_mrproper (&props->basedn);
	cherokee_buffer_mrproper (&props->filter);
	cherokee_buffer_mrproper (&props->ca_file);

	return cherokee_validator_props_free_base (VALIDATOR_PROPS(props));
}
",C,,,,"@@ -335,7 +335,8 @@ cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,
 	/* Sanity checks
 	 */
 	if ((conn->validator == NULL) ||
-	    cherokee_buffer_is_empty (&conn->validator->user))
+	    cherokee_buffer_is_empty (&conn->validator->user) ||
+	    cherokee_buffer_is_empty (&conn->validator->passwd))
 		return ret_error;
 
 	size = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, ""*()"");",webserver,fbda667221c51f0aa476a02366e0cf66cb012f88,dc1f76f32ef6a9b982a27ca4748ee9b030913323,0,"props_free (cherokee_validator_ldap_props_t *props)
{
	cherokee_buffer_mrproper (&props->server);
	cherokee_buffer_mrproper (&props->binddn);
	cherokee_buffer_mrproper (&props->bindpw);
	cherokee_buffer_mrproper (&props->basedn);
	cherokee_buffer_mrproper (&props->filter);
	cherokee_buffer_mrproper (&props->ca_file);

	return cherokee_validator_props_free_base (VALIDATOR_PROPS(props));
}
"
128671,,Remote,Not required,Partial,CVE-2014-3200,https://www.cvedetails.com/cve/CVE-2014-3200/,,Low,Partial,Partial,,2014-10-08,7.5,Multiple unspecified vulnerabilities in Google Chrome before 38.0.2125.101 allow attackers to cause a denial of service or possibly have other impact via unknown vectors.,2016-11-28,DoS ,0,https://github.com/chromium/chromium/commit/c0947dabeaa10da67798c1bbc668dca4b280cad5,c0947dabeaa10da67798c1bbc668dca4b280cad5,"[Contextual Search] Change ""Now on Tap"" to ""Contextual Cards""

BUG=644934

Review-Url: https://codereview.chromium.org/2361163003
Cr-Commit-Position: refs/heads/master@{#420899}",0,chrome/browser/android/contextualsearch/contextual_search_field_trial.cc,"{""sha"": ""a18e61a3926d3556fef7bc0c69bd016fc59a8f6f"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/ChromeSwitches.java"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/android/java/src/org/chromium/chrome/browser/ChromeSwitches.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/android/java/src/org/chromium/chrome/browser/ChromeSwitches.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/ChromeSwitches.java?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -57,9 +57,9 @@\n     /** Enable Contextual Search. */\n     public static final String ENABLE_CONTEXTUAL_SEARCH = \""enable-contextual-search\"";\n \n-    /** Contextual Search UI integration with Now on Tap data.*/\n-    public static final String CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION =\n-            \""cs-now-on-tap-bar-integration\"";\n+    /** Contextual Search UI integration with Contextual Cards data.*/\n+    public static final String CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION =\n+            \""cs-contextual-cards-bar-integration\"";\n \n     // How many thumbnails should we allow in the cache (per tab stack)?\n     public static final String THUMBNAILS = \""thumbnails\"";""}<_**next**_>{""sha"": ""b39e1b0421e16b210fb685dc77ea874cd626ce55"", ""filename"": ""chrome/android/java/src/org/chromium/chrome/browser/contextualsearch/ContextualSearchFieldTrial.java"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/android/java/src/org/chromium/chrome/browser/contextualsearch/ContextualSearchFieldTrial.java"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/android/java/src/org/chromium/chrome/browser/contextualsearch/ContextualSearchFieldTrial.java"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/android/java/src/org/chromium/chrome/browser/contextualsearch/ContextualSearchFieldTrial.java?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -94,7 +94,7 @@\n     private static Boolean sIsBarOverlapCollectionEnabled;\n     private static Boolean sIsBarOverlapSuppressionEnabled;\n     private static Integer sSuppressionTaps;\n-    private static Boolean sIsNowOnTapBarIntegrationEnabled;\n+    private static Boolean sIsContextualCardsBarIntegrationEnabled;\n \n     /**\n      * Don't instantiate.\n@@ -367,12 +367,12 @@ static int getSuppressionTaps() {\n     }\n \n     // TODO(donnd): Remove once bar-integration is fully landed if still unused (native only).\n-    static boolean isNowOnTapBarIntegrationEnabled() {\n-        if (sIsNowOnTapBarIntegrationEnabled == null) {\n-            sIsNowOnTapBarIntegrationEnabled = getBooleanParam(\n-                    ChromeSwitches.CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION);\n+    static boolean isContextualCardsBarIntegrationEnabled() {\n+        if (sIsContextualCardsBarIntegrationEnabled == null) {\n+            sIsContextualCardsBarIntegrationEnabled = getBooleanParam(\n+                    ChromeSwitches.CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION);\n         }\n-        return sIsNowOnTapBarIntegrationEnabled;\n+        return sIsContextualCardsBarIntegrationEnabled;\n     }\n \n     // --------------------------------------------------------------------------------------------""}<_**next**_>{""sha"": ""5feec59a3ca01e9ee7f52b99c25f0dbac12c5332"", ""filename"": ""chrome/app/generated_resources.grd"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/app/generated_resources.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/app/generated_resources.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/app/generated_resources.grd?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -5529,11 +5529,11 @@ Keep your key file in a safe place. You will need it to create new versions of y\n         <message name=\""IDS_FLAGS_CONTEXTUAL_SEARCH_DESCRIPTION\"" desc=\""Description for the flag to enable Contextual Search.\"" translateable=\""false\"">\n           Whether or not Contextual Search is enabled.\n         </message>\n-       <message name=\""IDS_FLAGS_CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION\"" desc=\""Title for the flag to enable Contextual Search integration with Now on Tap data in the bar.\"" translateable=\""false\"">\n-          Contextual Search Now on Tap Bar Integration\n+       <message name=\""IDS_FLAGS_CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION\"" desc=\""Title for the flag to enable Contextual Search integration with Contextual Cards data in the bar.\"" translateable=\""false\"">\n+          Contextual Search - Contextual Cards Integration\n         </message>\n-        <message name=\""IDS_FLAGS_CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION_DESCRIPTION\"" desc=\""Description for the flag to enable Contextual Search integration with Now on Tap data in the bar.\"" translateable=\""false\"">\n-          Whether or not integration of Now on Tap data in the Contextual Search Bar is enabled.\n+        <message name=\""IDS_FLAGS_CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION_DESCRIPTION\"" desc=\""Description for the flag to enable Contextual Search integration with Contextual Cards data in the bar.\"" translateable=\""false\"">\n+          Whether or not integration of Contextual Cards data in the Contextual Search Bar is enabled.\n         </message>\n       </if>\n       <message name=\""IDS_FLAGS_GESTURE_TAP_HIGHLIGHTING_NAME\"" desc=\""Title for the flag to turn on gesture tap highlighting\"">""}<_**next**_>{""sha"": ""7d8ce4b37778751152923f1acdece23621d39767"", ""filename"": ""chrome/browser/about_flags.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 5, ""changes"": 11, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/about_flags.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/about_flags.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/about_flags.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -774,11 +774,12 @@ const FeatureEntry kFeatureEntries[] = {\n      IDS_FLAGS_CONTEXTUAL_SEARCH_DESCRIPTION, kOsAndroid,\n      ENABLE_DISABLE_VALUE_TYPE(switches::kEnableContextualSearch,\n                                switches::kDisableContextualSearch)},\n-    {\""cs-now-on-tap-bar-integration\"",\n-     IDS_FLAGS_CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION,\n-     IDS_FLAGS_CONTEXTUAL_SEARCH_NOW_ON_TAP_BAR_INTEGRATION_DESCRIPTION,\n-     kOsAndroid, SINGLE_VALUE_TYPE(\n-                     switches::kEnableContextualSearchNowOnTapBarIntegration)},\n+    {\""cs-contextual-cards-bar-integration\"",\n+     IDS_FLAGS_CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION,\n+     IDS_FLAGS_CONTEXTUAL_SEARCH_CONTEXTUAL_CARDS_BAR_INTEGRATION_DESCRIPTION,\n+     kOsAndroid,\n+     SINGLE_VALUE_TYPE(\n+         switches::kEnableContextualSearchContextualCardsBarIntegration)},\n #endif\n     {\""show-autofill-type-predictions\"",\n      IDS_FLAGS_SHOW_AUTOFILL_TYPE_PREDICTIONS_NAME,""}<_**next**_>{""sha"": ""e2dfe1c036ef21aaddf0605255522b500c07518a"", ""filename"": ""chrome/browser/android/contextualsearch/contextual_search_delegate.cc"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 7, ""changes"": 16, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_delegate.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_delegate.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/contextualsearch/contextual_search_delegate.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -57,8 +57,8 @@ const char kDoPreventPreloadValue[] = \""1\"";\n // The number of characters that should be shown after the selected expression.\n const int kSurroundingSizeForUI = 60;\n \n-// The version of the Now on Tap API that we want to invoke.\n-const int kNowOnTapVersion = 1;\n+// The version of the Contextual Cards API that we want to invoke.\n+const int kContextualCardsVersion = 1;\n \n } // namespace\n \n@@ -212,12 +212,13 @@ std::string ContextualSearchDelegate::BuildRequestUrl(std::string selection) {\n   TemplateURLRef::SearchTermsArgs search_terms_args =\n       TemplateURLRef::SearchTermsArgs(base::string16());\n \n-  int now_on_tap_version =\n-      field_trial_->IsNowOnTapBarIntegrationEnabled() ? kNowOnTapVersion : 0;\n+  int contextual_cards_version =\n+      field_trial_->IsContextualCardsBarIntegrationEnabled()\n+      ? kContextualCardsVersion : 0;\n \n   TemplateURLRef::SearchTermsArgs::ContextualSearchParams params(\n       kContextualSearchRequestVersion, selected_text, std::string(),\n-      now_on_tap_version);\n+      contextual_cards_version);\n \n   search_terms_args.contextual_search_params = params;\n \n@@ -497,8 +498,9 @@ void ContextualSearchDelegate::DecodeSearchTermFromJsonResponse(\n     }\n   }\n \n-  if (field_trial_->IsNowOnTapBarIntegrationEnabled()) {\n-    // Get the basic Bar data for Now on Tap integration directly from the root.\n+  if (field_trial_->IsContextualCardsBarIntegrationEnabled()) {\n+    // Get the basic Bar data for Contextual Cards integration directly\n+    // from the root.\n     dict->GetString(kContextualSearchCaption, caption);\n     dict->GetString(kContextualSearchThumbnail, thumbnail_url);\n   }""}<_**next**_>{""sha"": ""aea2ae1bc1b7b7638ff8cef9c29757b608a27ef8"", ""filename"": ""chrome/browser/android/contextualsearch/contextual_search_delegate_unittest.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_delegate_unittest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_delegate_unittest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/contextualsearch/contextual_search_delegate_unittest.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -44,7 +44,7 @@ class ContextualSearchDelegateTest : public testing::Test {\n  protected:\n   void SetUp() override {\n     base::CommandLine::ForCurrentProcess()->AppendSwitch(\n-        switches::kEnableContextualSearchNowOnTapBarIntegration);\n+        switches::kEnableContextualSearchContextualCardsBarIntegration);\n     request_context_ =\n         new net::TestURLRequestContextGetter(io_message_loop_.task_runner());\n     template_url_service_.reset(CreateTemplateURLService());""}<_**next**_>{""sha"": ""d139053cd68db4a93a6f077e254a7cbe181ff289"", ""filename"": ""chrome/browser/android/contextualsearch/contextual_search_field_trial.cc"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 6, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_field_trial.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_field_trial.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/contextualsearch/contextual_search_field_trial.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -42,8 +42,8 @@ ContextualSearchFieldTrial::ContextualSearchFieldTrial()\n       is_send_base_page_url_disabled_(false),\n       is_decode_mentions_disabled_cached_(false),\n       is_decode_mentions_disabled_(false),\n-      is_now_on_tap_bar_integration_enabled_cached_(false),\n-      is_now_on_tap_bar_integration_enabled_(false) {}\n+      is_contextual_cards_bar_integration_enabled_cached_(false),\n+      is_contextual_cards_bar_integration_enabled_(false) {}\n \n ContextualSearchFieldTrial::~ContextualSearchFieldTrial() {}\n \n@@ -83,11 +83,11 @@ bool ContextualSearchFieldTrial::IsDecodeMentionsDisabled() {\n                          &is_decode_mentions_disabled_);\n }\n \n-bool ContextualSearchFieldTrial::IsNowOnTapBarIntegrationEnabled() {\n+bool ContextualSearchFieldTrial::IsContextualCardsBarIntegrationEnabled() {\n   return GetBooleanParam(\n-      switches::kEnableContextualSearchNowOnTapBarIntegration,\n-      &is_now_on_tap_bar_integration_enabled_cached_,\n-      &is_now_on_tap_bar_integration_enabled_);\n+      switches::kEnableContextualSearchContextualCardsBarIntegration,\n+      &is_contextual_cards_bar_integration_enabled_cached_,\n+      &is_contextual_cards_bar_integration_enabled_);\n }\n \n bool ContextualSearchFieldTrial::GetBooleanParam(const std::string& name,""}<_**next**_>{""sha"": ""bcaa594b687840a172ab3ef5c9e5d68dbbbac83f"", ""filename"": ""chrome/browser/android/contextualsearch/contextual_search_field_trial.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_field_trial.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/browser/android/contextualsearch/contextual_search_field_trial.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/android/contextualsearch/contextual_search_field_trial.h?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -35,8 +35,8 @@ class ContextualSearchFieldTrial {\n   // Gets whether decoding the mentions fields in the Resolve is disabled.\n   bool IsDecodeMentionsDisabled();\n \n-  // Gets whether Bar integration with Now on Tap data is enabled.\n-  bool IsNowOnTapBarIntegrationEnabled();\n+  // Gets whether Bar integration with Contextual Cards data is enabled.\n+  bool IsContextualCardsBarIntegrationEnabled();\n \n   // Disables the cache.\n   void DisableCache();\n@@ -82,8 +82,8 @@ class ContextualSearchFieldTrial {\n   bool is_send_base_page_url_disabled_;\n   bool is_decode_mentions_disabled_cached_;\n   bool is_decode_mentions_disabled_;\n-  bool is_now_on_tap_bar_integration_enabled_cached_;\n-  bool is_now_on_tap_bar_integration_enabled_;\n+  bool is_contextual_cards_bar_integration_enabled_cached_;\n+  bool is_contextual_cards_bar_integration_enabled_;\n \n   DISALLOW_COPY_AND_ASSIGN(ContextualSearchFieldTrial);\n };""}<_**next**_>{""sha"": ""9e456c6ad8682ff42088c707877a2e25da3dd99c"", ""filename"": ""chrome/common/chrome_switches.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/common/chrome_switches.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/common/chrome_switches.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/chrome_switches.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -1052,9 +1052,9 @@ const char kEnableAppLink[] = \""enable-app-link\"";\n // Enables Contextual Search.\n const char kEnableContextualSearch[] = \""enable-contextual-search\"";\n \n-// Enables Contextual Search UI integration with Now on Tap data.\n-const char kEnableContextualSearchNowOnTapBarIntegration[] =\n-    \""cs-now-on-tap-bar-integration\"";\n+// Enables Contextual Search UI integration with Contextual Cards data.\n+const char kEnableContextualSearchContextualCardsBarIntegration[] =\n+    \""cs-contextual-cards-bar-integration\"";\n \n // Enables chrome hosted mode for Android.\n const char kEnableHostedMode[] = \""enable-hosted-mode\"";""}<_**next**_>{""sha"": ""68b641c6c2119eebe51da2eb16a19b84b4b409d7"", ""filename"": ""chrome/common/chrome_switches.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/common/chrome_switches.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/chrome/common/chrome_switches.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/chrome_switches.h?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -297,7 +297,7 @@ extern const char kDisableVrShell[];\n extern const char kEnableAccessibilityTabSwitcher[];\n extern const char kEnableAppLink[];\n extern const char kEnableContextualSearch[];\n-extern const char kEnableContextualSearchNowOnTapBarIntegration[];\n+extern const char kEnableContextualSearchContextualCardsBarIntegration[];\n extern const char kEnableHostedMode[];\n extern const char kEnableHungRendererInfoBar[];\n extern const char kEnableVrShell[];""}<_**next**_>{""sha"": ""a058755ca3f303693054413b0a4142279fe2c8cb"", ""filename"": ""components/search_engines/template_url.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 6, ""changes"": 13, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/components/search_engines/template_url.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/components/search_engines/template_url.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/search_engines/template_url.cc?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -188,19 +188,19 @@ TemplateURLRef::SearchTermsArgs::ContextualSearchParams::\n     : version(-1),\n       start(base::string16::npos),\n       end(base::string16::npos),\n-      now_on_tap_version(0) {}\n+      contextual_cards_version(0) {}\n \n TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     int version,\n     const std::string& selection,\n     const std::string& base_page_url,\n-    int now_on_tap_version)\n+    int contextual_cards_version)\n     : version(version),\n       start(base::string16::npos),\n       end(base::string16::npos),\n       selection(selection),\n       base_page_url(base_page_url),\n-      now_on_tap_version(now_on_tap_version) {}\n+      contextual_cards_version(contextual_cards_version) {}\n \n TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     int version,\n@@ -210,15 +210,15 @@ TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     const std::string& content,\n     const std::string& base_page_url,\n     const std::string& encoding,\n-    int now_on_tap_version)\n+    int contextual_cards_version)\n     : version(version),\n       start(start),\n       end(end),\n       selection(selection),\n       content(content),\n       base_page_url(base_page_url),\n       encoding(encoding),\n-      now_on_tap_version(now_on_tap_version) {}\n+      contextual_cards_version(contextual_cards_version) {}\n \n TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(\n     const ContextualSearchParams& other) = default;\n@@ -1018,7 +1018,8 @@ std::string TemplateURLRef::HandleReplacements(\n         // The above parameters all add a trailing \""&\"" so there must be one last\n         // parameter that's always added at the end.\n         context_data.append(\""ctxsl_coca=\"" +\n-                            base::IntToString(params.now_on_tap_version));\n+                            base::IntToString(\n+                                params.contextual_cards_version));\n \n         HandleReplacement(std::string(), context_data, *i, &url);\n         break;""}<_**next**_>{""sha"": ""fe4fc31300787093619c21743e8a80d450377e61"", ""filename"": ""components/search_engines/template_url.h"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/components/search_engines/template_url.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/components/search_engines/template_url.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/search_engines/template_url.h?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -86,7 +86,7 @@ class TemplateURLRef {\n       ContextualSearchParams(int version,\n                              const std::string& selection,\n                              const std::string& base_page_url,\n-                             int now_on_tap_version);\n+                             int contextual_cards_version);\n       // TODO(donnd): Delete constructor once Clank, iOS, and tests no\n       // longer depend on it.\n       ContextualSearchParams(int version,\n@@ -96,7 +96,7 @@ class TemplateURLRef {\n                              const std::string& content,\n                              const std::string& base_page_url,\n                              const std::string& encoding,\n-                             int now_on_tap_version);\n+                             int contextual_cards_version);\n       ContextualSearchParams(const ContextualSearchParams& other);\n       ~ContextualSearchParams();\n \n@@ -121,9 +121,9 @@ class TemplateURLRef {\n       // The encoding of content.\n       std::string encoding;\n \n-      // The version of Now on Tap data to request.\n+      // The version of Contextual Cards data to request.\n       // A value of 0 indicates no data needed.\n-      int now_on_tap_version;\n+      int contextual_cards_version;\n     };\n \n     // The search terms (query).""}<_**next**_>{""sha"": ""223ce11ed8c31e42170660972de4521a21075c06"", ""filename"": ""tools/metrics/histograms/histograms.xml"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/c0947dabeaa10da67798c1bbc668dca4b280cad5/tools/metrics/histograms/histograms.xml"", ""raw_url"": ""https://github.com/chromium/chromium/raw/c0947dabeaa10da67798c1bbc668dca4b280cad5/tools/metrics/histograms/histograms.xml"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/tools/metrics/histograms/histograms.xml?ref=c0947dabeaa10da67798c1bbc668dca4b280cad5"", ""patch"": ""@@ -87055,7 +87055,6 @@ To add a new entry, add it with any value and run test to compute valid value.\n   <int value=\""0\"" label=\""BAD_FLAG_FORMAT\"">\n     Command-line flag doesn't start with two dashes.\n   </int>\n-  <int value=\""2159633\"" label=\""cs-now-on-tap-bar-integration\""/>\n   <int value=\""7533886\"" label=\""disable-offer-store-unmasked-wallet-cards\""/>\n   <int value=\""10458238\"" label=\""disable-print-preview-simplify\""/>\n   <int value=\""11698808\"" label=\""enable-dom-distiller-button-animation\""/>\n@@ -87103,6 +87102,7 @@ To add a new entry, add it with any value and run test to compute valid value.\n   <int value=\""324631366\"" label=\""enable-drive-search-in-app-launcher\""/>\n   <int value=\""327045548\"" label=\""SafeSearchUrlReporting:enabled\""/>\n   <int value=\""330138076\"" label=\""enable-clear-browsing-data-counters\""/>\n+  <int value=\""332391072\"" label=\""cs-contextual-cards-bar-integration\""/>\n   <int value=\""346711293\"" label=\""enable-save-password-bubble\""/>\n   <int value=\""348854923\"" label=\""v8-cache-strategies-for-cache-storage\""/>\n   <int value=\""358399482\"" label=\""enable-high-dpi-fixed-position-compositing\""/>""}","int ContextualSearchFieldTrial::GetSurroundingSize() {
  return GetIntParamValueOrDefault(kContextualSearchSurroundingSizeParamName,
                                   kContextualSearchDefaultContentSize,
                                   &is_surrounding_size_cached_,
                                   &surrounding_size_);
}
","int ContextualSearchFieldTrial::GetSurroundingSize() {
  return GetIntParamValueOrDefault(kContextualSearchSurroundingSizeParamName,
                                   kContextualSearchDefaultContentSize,
                                   &is_surrounding_size_cached_,
                                   &surrounding_size_);
}
",C,,,,"@@ -42,8 +42,8 @@ ContextualSearchFieldTrial::ContextualSearchFieldTrial()
       is_send_base_page_url_disabled_(false),
       is_decode_mentions_disabled_cached_(false),
       is_decode_mentions_disabled_(false),
-      is_now_on_tap_bar_integration_enabled_cached_(false),
-      is_now_on_tap_bar_integration_enabled_(false) {}
+      is_contextual_cards_bar_integration_enabled_cached_(false),
+      is_contextual_cards_bar_integration_enabled_(false) {}
 
 ContextualSearchFieldTrial::~ContextualSearchFieldTrial() {}
 
@@ -83,11 +83,11 @@ bool ContextualSearchFieldTrial::IsDecodeMentionsDisabled() {
                          &is_decode_mentions_disabled_);
 }
 
-bool ContextualSearchFieldTrial::IsNowOnTapBarIntegrationEnabled() {
+bool ContextualSearchFieldTrial::IsContextualCardsBarIntegrationEnabled() {
   return GetBooleanParam(
-      switches::kEnableContextualSearchNowOnTapBarIntegration,
-      &is_now_on_tap_bar_integration_enabled_cached_,
-      &is_now_on_tap_bar_integration_enabled_);
+      switches::kEnableContextualSearchContextualCardsBarIntegration,
+      &is_contextual_cards_bar_integration_enabled_cached_,
+      &is_contextual_cards_bar_integration_enabled_);
 }
 
 bool ContextualSearchFieldTrial::GetBooleanParam(const std::string& name,",Chrome,c0947dabeaa10da67798c1bbc668dca4b280cad5,72fec99e143cd8fa697e04ad32bc6be4dc9c6c8e,0,"int ContextualSearchFieldTrial::GetSurroundingSize() {
  return GetIntParamValueOrDefault(kContextualSearchSurroundingSizeParamName,
                                   kContextualSearchDefaultContentSize,
                                   &is_surrounding_size_cached_,
                                   &surrounding_size_);
}
"
137723,,Remote,Not required,,CVE-2015-1300,https://www.cvedetails.com/cve/CVE-2015-1300/,CWE-254,Low,Partial,,,2015-09-03,5.0,"The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",2016-12-21,+Info ,0,https://github.com/chromium/chromium/commit/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,"Use pdf compositor service for printing when OOPIF is enabled

When OOPIF is enabled (by site-per-process flag or
top-document-isolation feature), use the pdf compositor service for
converting PaintRecord to PDF on renderers.

In the future, this will make compositing PDF from multiple renderers
possible.

TBR=jzfeng@chromium.org
BUG=455764

Change-Id: I3c28f03f4358e4228239fe1a33384f85e7716e8f
Reviewed-on: https://chromium-review.googlesource.com/699765
Commit-Queue: Wei Li <weili@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Lei Zhang <thestig@chromium.org>
Cr-Commit-Position: refs/heads/master@{#511616}",0,chrome/utility/chrome_content_utility_client.cc,"{""sha"": ""78193d61b9f59cdc78ed504e7a6939379d4f52d5"", ""filename"": ""chrome/browser/chrome_content_browser_manifest_overlay.json"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/chrome_content_browser_manifest_overlay.json"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_manifest_overlay.json?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -44,6 +44,7 @@\n         \""local_state\"": [ \""pref_client\"" ],\n         \""nacl_broker\"": [ \""browser\"" ],\n         \""nacl_loader\"": [ \""browser\"" ],\n+        \""pdf_compositor\"": [ \""compositor\"" ],\n         \""profile_import\"": [ \""import\"" ],\n         \""profiling\"": [ \""profiling\"" ],\n         \""proxy_resolver\"": [ \""factory\"" ],""}<_**next**_>{""sha"": ""449ec7465b049d91941d3413bafcb8ee1904d417"", ""filename"": ""chrome/browser/printing/print_preview_dialog_controller.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_dialog_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_dialog_controller.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -29,6 +29,7 @@\n #include \""chrome/common/chrome_paths.h\""\n #include \""chrome/common/url_constants.h\""\n #include \""components/guest_view/browser/guest_view_base.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/web_modal/web_contents_modal_dialog_host.h\""\n #include \""content/public/browser/host_zoom_map.h\""\n #include \""content/public/browser/navigation_controller.h\""\n@@ -376,6 +377,7 @@ WebContents* PrintPreviewDialogController::CreatePrintPreviewDialog(\n   content::HostZoomMap::Get(preview_dialog->GetSiteInstance())\n       ->SetZoomLevelForHostAndScheme(print_url.scheme(), print_url.host(), 0);\n   PrintViewManager::CreateForWebContents(preview_dialog);\n+  CreateCompositeClientIfNeeded(preview_dialog, true /* for_preview */);\n   extensions::ChromeExtensionWebContentsObserver::CreateForWebContents(\n       preview_dialog);\n ""}<_**next**_>{""sha"": ""cda7ad2e7612be69842877448291d3be54317a64"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.cc"", ""status"": ""modified"", ""additions"": 94, ""deletions"": 22, ""changes"": 116, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -14,18 +14,22 @@\n #include \""base/memory/ref_counted.h\""\n #include \""base/memory/ref_counted_memory.h\""\n #include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n #include \""chrome/browser/browser_process.h\""\n #include \""chrome/browser/printing/print_job_manager.h\""\n #include \""chrome/browser/printing/print_preview_dialog_controller.h\""\n #include \""chrome/browser/printing/print_view_manager.h\""\n #include \""chrome/browser/printing/printer_query.h\""\n #include \""chrome/browser/ui/webui/print_preview/print_preview_ui.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""content/public/browser/web_ui.h\""\n #include \""printing/page_size_margins.h\""\n #include \""printing/print_job_constants.h\""\n+#include \""printing/print_settings.h\""\n \n using content::BrowserThread;\n using content::WebContents;\n@@ -69,7 +73,7 @@ scoped_refptr<base::RefCountedBytes> GetDataFromHandle(\n \n PrintPreviewMessageHandler::PrintPreviewMessageHandler(\n     WebContents* web_contents)\n-    : content::WebContentsObserver(web_contents) {\n+    : content::WebContentsObserver(web_contents), weak_ptr_factory_(this) {\n   DCHECK(web_contents);\n }\n \n@@ -129,13 +133,21 @@ void PrintPreviewMessageHandler::OnDidPreviewPage(\n   if (!print_preview_ui)\n     return;\n \n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  DCHECK(data_bytes);\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnDidPreviewPage(page_number, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    // Use utility process to convert skia metafile to pdf.\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfPageDone,\n+                       weak_ptr_factory_.GetWeakPtr(), params.page_number,\n+                       params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewPageReady(\n+        page_number, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n@@ -152,18 +164,20 @@ void PrintPreviewMessageHandler::OnMetafileReadyForPrinting(\n   if (!print_preview_ui)\n     return;\n \n-  // TODO(joth): This seems like a good match for using RefCountedStaticMemory\n-  // to avoid the memory copy, but the SetPrintPreviewData call chain below\n-  // needs updating to accept the RefCountedMemory* base class.\n-  scoped_refptr<base::RefCountedBytes> data_bytes =\n-      GetDataFromHandle(params.metafile_data_handle, params.data_size);\n-  if (!data_bytes || !data_bytes->size())\n-    return;\n-\n-  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n-                                                std::move(data_bytes));\n-  print_preview_ui->OnPreviewDataIsAvailable(\n-      params.expected_pages_count, params.preview_request_id);\n+  if (IsOopifEnabled() && print_preview_ui->source_is_modifiable()) {\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    DCHECK(client);\n+\n+    client->DoComposite(\n+        params.metafile_data_handle, params.data_size,\n+        base::BindOnce(&PrintPreviewMessageHandler::OnCompositePdfDocumentDone,\n+                       weak_ptr_factory_.GetWeakPtr(),\n+                       params.expected_pages_count, params.preview_request_id));\n+  } else {\n+    NotifyUIPreviewDocumentReady(\n+        params.expected_pages_count, params.preview_request_id,\n+        GetDataFromHandle(params.metafile_data_handle, params.data_size));\n+  }\n }\n \n void PrintPreviewMessageHandler::OnPrintPreviewFailed(int document_cookie) {\n@@ -214,6 +228,65 @@ void PrintPreviewMessageHandler::OnSetOptionsFromDocument(\n   print_preview_ui->OnSetOptionsFromDocument(params);\n }\n \n+void PrintPreviewMessageHandler::NotifyUIPreviewPageReady(\n+    int page_number,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  DCHECK(data_bytes);\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(page_number,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnDidPreviewPage(page_number, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::NotifyUIPreviewDocumentReady(\n+    int page_count,\n+    int request_id,\n+    scoped_refptr<base::RefCountedBytes> data_bytes) {\n+  if (!data_bytes || !data_bytes->size())\n+    return;\n+\n+  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();\n+  if (!print_preview_ui)\n+    return;\n+  print_preview_ui->SetPrintPreviewDataForIndex(COMPLETE_PREVIEW_DOCUMENT_INDEX,\n+                                                std::move(data_bytes));\n+  print_preview_ui->OnPreviewDataIsAvailable(page_count, request_id);\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfPageDone(\n+    int page_number,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewPageReady(\n+      page_number, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n+void PrintPreviewMessageHandler::OnCompositePdfDocumentDone(\n+    int page_count,\n+    int request_id,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+  NotifyUIPreviewDocumentReady(\n+      page_count, request_id,\n+      PrintCompositeClient::GetDataFromMojoHandle(std::move(handle)));\n+}\n+\n bool PrintPreviewMessageHandler::OnMessageReceived(\n     const IPC::Message& message,\n     content::RenderFrameHost* render_frame_host) {\n@@ -231,8 +304,7 @@ bool PrintPreviewMessageHandler::OnMessageReceived(\n   IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                         OnDidGetPreviewPageCount)\n-    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,\n-                        OnDidPreviewPage)\n+    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,\n                         OnMetafileReadyForPrinting)\n     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,""}<_**next**_>{""sha"": ""71ca9d5bb1ee142ed3dbbfaa34cd8ab5d3018002"", ""filename"": ""chrome/browser/printing/print_preview_message_handler.h"", ""status"": ""modified"", ""additions"": 24, ""deletions"": 0, ""changes"": 24, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_preview_message_handler.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_preview_message_handler.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,6 +7,9 @@\n \n #include \""base/compiler_specific.h\""\n #include \""base/macros.h\""\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/weak_ptr.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/web_contents_observer.h\""\n #include \""content/public/browser/web_contents_user_data.h\""\n \n@@ -70,6 +73,27 @@ class PrintPreviewMessageHandler\n   void OnSetOptionsFromDocument(\n       const PrintHostMsg_SetOptionsFromDocument_Params& params);\n \n+  void NotifyUIPreviewPageReady(\n+      int page_number,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+  void NotifyUIPreviewDocumentReady(\n+      int page_count,\n+      int request_id,\n+      scoped_refptr<base::RefCountedBytes> data_bytes);\n+\n+  // Callbacks for pdf compositor client.\n+  void OnCompositePdfPageDone(int page_number,\n+                              int request_id,\n+                              mojom::PdfCompositor::Status status,\n+                              mojo::ScopedSharedBufferHandle handle);\n+  void OnCompositePdfDocumentDone(int page_count,\n+                                  int request_id,\n+                                  mojom::PdfCompositor::Status status,\n+                                  mojo::ScopedSharedBufferHandle handle);\n+\n+  base::WeakPtrFactory<PrintPreviewMessageHandler> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintPreviewMessageHandler);\n };\n ""}<_**next**_>{""sha"": ""f4fed9d2753dbd8b374dfb9b6f006cf51010d5cf"", ""filename"": ""chrome/browser/printing/print_view_manager_base.cc"", ""status"": ""modified"", ""additions"": 64, ""deletions"": 25, ""changes"": 89, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -11,6 +11,7 @@\n #include \""base/bind.h\""\n #include \""base/location.h\""\n #include \""base/memory/ptr_util.h\""\n+#include \""base/memory/shared_memory.h\""\n #include \""base/message_loop/message_loop.h\""\n #include \""base/run_loop.h\""\n #include \""base/single_thread_task_runner.h\""\n@@ -28,6 +29,8 @@\n #include \""chrome/common/pref_names.h\""\n #include \""chrome/grit/generated_resources.h\""\n #include \""components/prefs/pref_service.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""components/printing/common/print_messages.h\""\n #include \""content/public/browser/browser_thread.h\""\n #include \""content/public/browser/notification_details.h\""\n@@ -36,8 +39,10 @@\n #include \""content/public/browser/render_frame_host.h\""\n #include \""content/public/browser/render_view_host.h\""\n #include \""content/public/browser/web_contents.h\""\n+#include \""mojo/public/cpp/system/buffer.h\""\n #include \""printing/features/features.h\""\n #include \""printing/pdf_metafile_skia.h\""\n+#include \""printing/print_settings.h\""\n #include \""printing/printed_document.h\""\n #include \""ui/base/l10n/l10n_util.h\""\n \n@@ -78,7 +83,8 @@ PrintViewManagerBase::PrintViewManagerBase(content::WebContents* web_contents)\n #if !defined(OS_MACOSX)\n       expecting_first_page_(true),\n #endif\n-      queue_(g_browser_process->print_job_manager()->queue()) {\n+      queue_(g_browser_process->print_job_manager()->queue()),\n+      weak_ptr_factory_(this) {\n   DCHECK(queue_.get());\n   Profile* profile =\n       Profile::FromBrowserContext(web_contents->GetBrowserContext());\n@@ -127,8 +133,24 @@ void PrintViewManagerBase::OnDidGetPrintedPagesCount(int cookie,\n   OpportunisticallyCreatePrintJob(cookie);\n }\n \n+void PrintViewManagerBase::OnComposePdfDone(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    mojom::PdfCompositor::Status status,\n+    mojo::ScopedSharedBufferHandle handle) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  if (status != mojom::PdfCompositor::Status::SUCCESS) {\n+    DLOG(ERROR) << \""Compositing pdf failed with error \"" << status;\n+    return;\n+  }\n+\n+  UpdateForPrintedPage(\n+      params, true,\n+      PrintCompositeClient::GetShmFromMojoHandle(std::move(handle)));\n+}\n+\n void PrintViewManagerBase::OnDidPrintPage(\n-  const PrintHostMsg_DidPrintPage_Params& params) {\n+    const PrintHostMsg_DidPrintPage_Params& params) {\n+  // Ready to composite. Starting a print job.\n   if (!OpportunisticallyCreatePrintJob(params.document_cookie))\n     return;\n \n@@ -154,8 +176,18 @@ void PrintViewManagerBase::OnDidPrintPage(\n       web_contents()->Stop();\n       return;\n     }\n+\n+    auto* client = PrintCompositeClient::FromWebContents(web_contents());\n+    if (IsOopifEnabled() && !client->for_preview() &&\n+        !document->settings().is_modifiable()) {\n+      client->DoComposite(\n+          params.metafile_data_handle, params.data_size,\n+          base::BindOnce(&PrintViewManagerBase::OnComposePdfDone,\n+                         weak_ptr_factory_.GetWeakPtr(), params));\n+      return;\n+    }\n     shared_buf =\n-        base::MakeUnique<base::SharedMemory>(params.metafile_data_handle, true);\n+        std::make_unique<base::SharedMemory>(params.metafile_data_handle, true);\n     if (!shared_buf->Map(params.data_size)) {\n       NOTREACHED() << \""couldn't map\"";\n       web_contents()->Stop();\n@@ -170,22 +202,24 @@ void PrintViewManagerBase::OnDidPrintPage(\n     }\n   }\n \n-  std::unique_ptr<PdfMetafileSkia> metafile(\n-      new PdfMetafileSkia(SkiaDocumentType::PDF));\n-  if (metafile_must_be_valid) {\n-    if (!metafile->InitFromData(shared_buf->memory(), params.data_size)) {\n-      NOTREACHED() << \""Invalid metafile header\"";\n-      web_contents()->Stop();\n-      return;\n-    }\n-  }\n+  UpdateForPrintedPage(params, metafile_must_be_valid, std::move(shared_buf));\n+}\n+\n+void PrintViewManagerBase::UpdateForPrintedPage(\n+    const PrintHostMsg_DidPrintPage_Params& params,\n+    bool has_valid_page_data,\n+    std::unique_ptr<base::SharedMemory> shared_buf) {\n+  PrintedDocument* document = print_job_->document();\n+  if (!document)\n+    return;\n \n #if defined(OS_WIN)\n   print_job_->AppendPrintedPage(params.page_number);\n-  if (metafile_must_be_valid) {\n-    scoped_refptr<base::RefCountedBytes> bytes = new base::RefCountedBytes(\n+  if (has_valid_page_data) {\n+    scoped_refptr<base::RefCountedBytes> bytes(new base::RefCountedBytes(\n         reinterpret_cast<const unsigned char*>(shared_buf->memory()),\n-        params.data_size);\n+        shared_buf->mapped_size()));\n+\n     document->DebugDumpData(bytes.get(), FILE_PATH_LITERAL(\"".pdf\""));\n \n     const auto& settings = document->settings();\n@@ -203,22 +237,27 @@ void PrintViewManagerBase::OnDidPrintPage(\n       // Update : The missing letters seem to have been caused by the same\n       // problem as https://crbug.com/659604 which was resolved. GDI printing\n       // seems to work with the fix for this bug applied.\n-      bool print_text_with_gdi = settings.print_text_with_gdi() &&\n-                                 !settings.printer_is_xps() &&\n-                                 base::FeatureList::IsEnabled(\n-                                     features::kGdiTextPrinting);\n+      bool print_text_with_gdi =\n+          settings.print_text_with_gdi() && !settings.printer_is_xps() &&\n+          base::FeatureList::IsEnabled(features::kGdiTextPrinting);\n       print_job_->StartPdfToEmfConversion(\n           bytes, params.page_size, params.content_area, print_text_with_gdi);\n     }\n   }\n #else\n+  std::unique_ptr<PdfMetafileSkia> metafile =\n+      std::make_unique<PdfMetafileSkia>(SkiaDocumentType::PDF);\n+  if (has_valid_page_data) {\n+    if (!metafile->InitFromData(shared_buf->memory(),\n+                                shared_buf->mapped_size())) {\n+      NOTREACHED() << \""Invalid metafile header\"";\n+      web_contents()->Stop();\n+      return;\n+    }\n+  }\n+\n   // Update the rendered document. It will send notifications to the listener.\n-  document->SetPage(params.page_number,\n-                    std::move(metafile),\n-#if defined(OS_WIN)\n-                    0.0f /* dummy shrink_factor */,\n-#endif\n-                    params.page_size,\n+  document->SetPage(params.page_number, std::move(metafile), params.page_size,\n                     params.content_area);\n \n   ShouldQuitFromInnerMessageLoop();""}<_**next**_>{""sha"": ""e9706e34f8c96f224196aa8ffc993b44a9247cf9"", ""filename"": ""chrome/browser/printing/print_view_manager_base.h"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 1, ""changes"": 21, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/print_view_manager_base.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/print_view_manager_base.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -9,16 +9,23 @@\n \n #include \""base/macros.h\""\n #include \""base/memory/ref_counted.h\""\n+#include \""base/memory/weak_ptr.h\""\n #include \""base/strings/string16.h\""\n #include \""build/build_config.h\""\n #include \""components/prefs/pref_member.h\""\n #include \""components/printing/browser/print_manager.h\""\n+#include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""\n #include \""content/public/browser/notification_observer.h\""\n #include \""content/public/browser/notification_registrar.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n #include \""printing/features/features.h\""\n \n struct PrintHostMsg_DidPrintPage_Params;\n \n+namespace base {\n+class SharedMemory;\n+}\n+\n namespace content {\n class RenderFrameHost;\n }\n@@ -82,9 +89,19 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   // IPC Message handlers.\n   void OnDidGetPrintedPagesCount(int cookie, int number_pages) override;\n-  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n   void OnPrintingFailed(int cookie) override;\n   void OnShowInvalidPrinterSettingsError();\n+  void OnDidPrintPage(const PrintHostMsg_DidPrintPage_Params& params);\n+\n+  // Handle extra tasks once a page or doc is printed.\n+  void UpdateForPrintedPage(const PrintHostMsg_DidPrintPage_Params& params,\n+                            bool has_valid_page_data,\n+                            std::unique_ptr<base::SharedMemory> shared_buf);\n+\n+  // IPC message handlers for service.\n+  void OnComposePdfDone(const PrintHostMsg_DidPrintPage_Params& params,\n+                        mojom::PdfCompositor::Status status,\n+                        mojo::ScopedSharedBufferHandle handle);\n \n   // Processes a NOTIFY_PRINT_JOB_EVENT notification.\n   void OnNotifyPrintJobEvent(const JobEventDetails& event_details);\n@@ -163,6 +180,8 @@ class PrintViewManagerBase : public content::NotificationObserver,\n \n   scoped_refptr<printing::PrintQueriesQueue> queue_;\n \n+  base::WeakPtrFactory<PrintViewManagerBase> weak_ptr_factory_;\n+\n   DISALLOW_COPY_AND_ASSIGN(PrintViewManagerBase);\n };\n ""}<_**next**_>{""sha"": ""3560d1c793977a5c2fe67253c9cf9509dbe596a1"", ""filename"": ""chrome/browser/printing/printing_init.cc"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/printing/printing_init.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/printing/printing_init.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include \""chrome/browser/printing/printing_init.h\""\n \n+#include \""components/printing/browser/print_manager_utils.h\""\n #include \""content/public/browser/web_contents.h\""\n #include \""printing/features/features.h\""\n \n@@ -23,6 +24,7 @@ void InitializePrinting(content::WebContents* web_contents) {\n #else\n   printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n #endif  // BUILDFLAG(ENABLE_PRINT_PREVIEW)\n+  CreateCompositeClientIfNeeded(web_contents, false /* for_preview */);\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""84901e64744b737a1810f2e3c513498bfea57fb6"", ""filename"": ""chrome/browser/ui/BUILD.gn"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 1, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/browser/ui/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3475,7 +3475,10 @@ split_static_library(\""ui\"") {\n   }\n \n   if (enable_basic_printing || enable_print_preview) {\n-    deps += [ \""//printing\"" ]\n+    deps += [\n+      \""//components/printing/browser\"",\n+      \""//printing\"",\n+    ]\n     if (use_cups) {\n       configs += [ \""//printing:cups\"" ]\n     }""}<_**next**_>{""sha"": ""20c22c6758f1b3353627d510ee4cfe71ef980b8b"", ""filename"": ""chrome/utility/chrome_content_utility_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/chrome/utility/chrome_content_utility_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/utility/chrome_content_utility_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -73,7 +73,7 @@\n \n #if BUILDFLAG(ENABLE_PRINTING)\n #include \""chrome/common/chrome_content_client.h\""\n-#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_service_factory.h\""  // nogncheck\n #include \""components/printing/service/public/interfaces/pdf_compositor.mojom.h\""  // nogncheck\n #endif\n ""}<_**next**_>{""sha"": ""154e773645fadb49d560d3b3aa8cb4e1f3511e43"", ""filename"": ""components/printing/browser/BUILD.gn"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/BUILD.gn?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -4,6 +4,8 @@\n \n static_library(\""browser\"") {\n   sources = [\n+    \""print_composite_client.cc\"",\n+    \""print_composite_client.h\"",\n     \""print_manager.cc\"",\n     \""print_manager.h\"",\n     \""print_manager_utils.cc\"",\n@@ -17,6 +19,9 @@ static_library(\""browser\"") {\n   deps = [\n     \""//base\"",\n     \""//components/printing/common\"",\n+    \""//components/printing/service/public/cpp:client\"",\n+    \""//mojo/public/cpp/system:system\"",\n     \""//printing\"",\n+    \""//services/service_manager/public/cpp\"",\n   ]\n }""}<_**next**_>{""sha"": ""f67625c944f981351fc84c69ea9c9f156b285839"", ""filename"": ""components/printing/browser/DEPS"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/DEPS?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -1,3 +1,6 @@\n include_rules = [\n+  \""+components/printing/service/public/cpp\"",\n   \""+content/public/browser\"",\n+  \""+mojo/public/cpp/system\"",\n+  \""+services/service_manager/public/cpp\"",\n ]""}<_**next**_>{""sha"": ""e105223f7f9335c2aec939ac0fe4b4a5dbdfa97b"", ""filename"": ""components/printing/browser/print_composite_client.cc"", ""status"": ""added"", ""additions"": 79, ""deletions"": 0, ""changes"": 79, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,79 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#include \""components/printing/browser/print_composite_client.h\""\n+\n+#include <memory>\n+#include <utility>\n+\n+#include \""base/threading/thread_task_runner_handle.h\""\n+#include \""content/public/browser/browser_thread.h\""\n+#include \""content/public/common/service_manager_connection.h\""\n+#include \""mojo/public/cpp/system/platform_handle.h\""\n+#include \""services/service_manager/public/cpp/connector.h\""\n+\n+DEFINE_WEB_CONTENTS_USER_DATA_KEY(printing::PrintCompositeClient);\n+\n+namespace printing {\n+\n+PrintCompositeClient::PrintCompositeClient(content::WebContents* web_contents)\n+    : for_preview_(false) {}\n+\n+PrintCompositeClient::~PrintCompositeClient() {}\n+\n+void PrintCompositeClient::CreateConnectorRequest() {\n+  connector_ = service_manager::Connector::Create(&connector_request_);\n+  content::ServiceManagerConnection::GetForProcess()\n+      ->GetConnector()\n+      ->BindConnectorRequest(std::move(connector_request_));\n+}\n+\n+void PrintCompositeClient::DoComposite(\n+    base::SharedMemoryHandle handle,\n+    uint32_t data_size,\n+    mojom::PdfCompositor::CompositePdfCallback callback) {\n+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n+  DCHECK(data_size);\n+\n+  if (!connector_)\n+    CreateConnectorRequest();\n+  Composite(connector_.get(), handle, data_size, std::move(callback),\n+            base::ThreadTaskRunnerHandle::Get());\n+}\n+\n+std::unique_ptr<base::SharedMemory> PrintCompositeClient::GetShmFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  base::SharedMemoryHandle memory_handle;\n+  size_t memory_size = 0;\n+  bool read_only_flag = false;\n+\n+  const MojoResult result = mojo::UnwrapSharedMemoryHandle(\n+      std::move(handle), &memory_handle, &memory_size, &read_only_flag);\n+  if (result != MOJO_RESULT_OK)\n+    return nullptr;\n+  DCHECK_GT(memory_size, 0u);\n+\n+  std::unique_ptr<base::SharedMemory> shm =\n+      base::MakeUnique<base::SharedMemory>(memory_handle, true /* read_only */);\n+  if (!shm->Map(memory_size)) {\n+    DLOG(ERROR) << \""Map shared memory failed.\"";\n+    return nullptr;\n+  }\n+  return shm;\n+}\n+\n+scoped_refptr<base::RefCountedBytes>\n+PrintCompositeClient::GetDataFromMojoHandle(\n+    mojo::ScopedSharedBufferHandle handle) {\n+  std::unique_ptr<base::SharedMemory> shm =\n+      GetShmFromMojoHandle(std::move(handle));\n+  if (!shm)\n+    return nullptr;\n+\n+  return base::MakeRefCounted<base::RefCountedBytes>(\n+      reinterpret_cast<const unsigned char*>(shm->memory()),\n+      shm->mapped_size());\n+}\n+\n+}  // namespace printing""}<_**next**_>{""sha"": ""d63b34123520f5d66dbafe7c878c84f77725a91c"", ""filename"": ""components/printing/browser/print_composite_client.h"", ""status"": ""added"", ""additions"": 49, ""deletions"": 0, ""changes"": 49, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_composite_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_composite_client.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -0,0 +1,49 @@\n+// Copyright 2017 The Chromium Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file.\n+\n+#ifndef COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+#define COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_\n+\n+#include \""base/memory/ref_counted_memory.h\""\n+#include \""base/memory/shared_memory.h\""\n+#include \""base/memory/shared_memory_handle.h\""\n+#include \""components/printing/service/public/cpp/pdf_compositor_client.h\""\n+#include \""content/public/browser/web_contents_observer.h\""\n+#include \""content/public/browser/web_contents_user_data.h\""\n+\n+namespace printing {\n+\n+class PrintCompositeClient\n+    : public PdfCompositorClient,\n+      public content::WebContentsUserData<PrintCompositeClient> {\n+ public:\n+  explicit PrintCompositeClient(content::WebContents* web_contents);\n+  ~PrintCompositeClient() override;\n+\n+  void DoComposite(base::SharedMemoryHandle handle,\n+                   uint32_t data_size,\n+                   mojom::PdfCompositor::CompositePdfCallback callback);\n+\n+  void set_for_preview(bool for_preview) { for_preview_ = for_preview; }\n+  bool for_preview() const { return for_preview_; }\n+\n+  // Utility functions.\n+  static std::unique_ptr<base::SharedMemory> GetShmFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+  static scoped_refptr<base::RefCountedBytes> GetDataFromMojoHandle(\n+      mojo::ScopedSharedBufferHandle handle);\n+\n+ private:\n+  void CreateConnectorRequest();\n+\n+  service_manager::mojom::ConnectorRequest connector_request_;\n+  std::unique_ptr<service_manager::Connector> connector_;\n+  bool for_preview_;\n+\n+  DISALLOW_COPY_AND_ASSIGN(PrintCompositeClient);\n+};\n+\n+}  // namespace printing\n+\n+#endif  // COMPONENTS_PRINTING_BROWSER_PRINT_COMPOSITE_CLIENT_H_""}<_**next**_>{""sha"": ""844fcf5bd23513e52fa2a2eb7d9d958762e11ddf"", ""filename"": ""components/printing/browser/print_manager_utils.cc"", ""status"": ""modified"", ""additions"": 34, ""deletions"": 1, ""changes"": 35, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -3,11 +3,43 @@\n // found in the LICENSE file.\n \n #include \""components/printing/browser/print_manager_utils.h\""\n+\n+#include \""base/command_line.h\""\n+#include \""components/printing/browser/print_composite_client.h\""\n #include \""components/printing/common/print_messages.h\""\n+#include \""content/public/common/content_features.h\""\n+#include \""content/public/common/content_switches.h\""\n #include \""printing/print_settings.h\""\n \n namespace printing {\n \n+// A temporary flag which makes supporting both paths for OOPIF and non-OOPIF\n+// printing easier.\n+static bool g_oopif_enabled = false;\n+\n+void SetOopifEnabled() {\n+  g_oopif_enabled = true;\n+}\n+\n+bool IsOopifEnabled() {\n+  return g_oopif_enabled;\n+}\n+\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview) {\n+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(\n+          switches::kSitePerProcess) ||\n+      base::FeatureList::IsEnabled(features::kTopDocumentIsolation)) {\n+    // For cases need to support OOPIFs.\n+    PrintCompositeClient::CreateForWebContents(web_contents);\n+    if (for_preview) {\n+      PrintCompositeClient::FromWebContents(web_contents)\n+          ->set_for_preview(true);\n+    }\n+    SetOopifEnabled();\n+  }\n+}\n+\n void RenderParamsFromPrintSettings(const PrintSettings& settings,\n                                    PrintMsg_Print_Params* params) {\n   params->page_size = settings.page_setup_device_units().physical_size();\n@@ -32,7 +64,8 @@ void RenderParamsFromPrintSettings(const PrintSettings& settings,\n   params->display_header_footer = settings.display_header_footer();\n   params->title = settings.title();\n   params->url = settings.url();\n-  params->printed_doc_type = SkiaDocumentType::PDF;\n+  params->printed_doc_type =\n+      IsOopifEnabled() ? SkiaDocumentType::MSKP : SkiaDocumentType::PDF;\n }\n \n }  // namespace printing""}<_**next**_>{""sha"": ""5b2b62a7dbf5599fbb51940906b2ed4697c5d0a2"", ""filename"": ""components/printing/browser/print_manager_utils.h"", ""status"": ""modified"", ""additions"": 12, ""deletions"": 0, ""changes"": 12, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/components/printing/browser/print_manager_utils.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/components/printing/browser/print_manager_utils.h?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -7,10 +7,22 @@\n \n struct PrintMsg_Print_Params;\n \n+namespace content {\n+class WebContents;\n+}\n+\n namespace printing {\n \n class PrintSettings;\n \n+void SetOopifEnabled(bool enabled);\n+bool IsOopifEnabled();\n+\n+// Check on the current feature settings to decide whether we need to\n+// create a PDF compositor client for this |web_contents|.\n+void CreateCompositeClientIfNeeded(content::WebContents* web_contents,\n+                                   bool for_preview);\n+\n // Converts given settings to Print_Params and stores them in the output\n // parameter |params|.\n void RenderParamsFromPrintSettings(const PrintSettings& settings,""}<_**next**_>{""sha"": ""231fe97661ab55076dcd33cbc9dc12eeb29cbe83"", ""filename"": ""headless/lib/browser/headless_web_contents_impl.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/9c391ac04f9ac478c8b0e43b359c2b43a6c892ab/headless/lib/browser/headless_web_contents_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/headless/lib/browser/headless_web_contents_impl.cc?ref=9c391ac04f9ac478c8b0e43b359c2b43a6c892ab"", ""patch"": ""@@ -322,6 +322,7 @@ HeadlessWebContentsImpl::HeadlessWebContentsImpl(\n       weak_ptr_factory_(this) {\n #if BUILDFLAG(ENABLE_BASIC_PRINTING) && !defined(CHROME_MULTIPLE_DLL_CHILD)\n   HeadlessPrintManager::CreateForWebContents(web_contents);\n+// TODO(weili): Add support for printing OOPIFs.\n #endif\n   web_contents->GetMutableRendererPrefs()->accept_languages =\n       browser_context->options()->accept_language();""}","ChromeContentUtilityClient::ChromeContentUtilityClient()
    : utility_process_running_elevated_(false) {
#if BUILDFLAG(ENABLE_EXTENSIONS)
  extensions::InitExtensionsClient();
#endif

#if BUILDFLAG(ENABLE_PRINT_PREVIEW) || \
    (BUILDFLAG(ENABLE_BASIC_PRINTING) && defined(OS_WIN))
  handlers_.push_back(base::MakeUnique<printing::PrintingHandler>());
#endif
}
","ChromeContentUtilityClient::ChromeContentUtilityClient()
    : utility_process_running_elevated_(false) {
#if BUILDFLAG(ENABLE_EXTENSIONS)
  extensions::InitExtensionsClient();
#endif

#if BUILDFLAG(ENABLE_PRINT_PREVIEW) || \
    (BUILDFLAG(ENABLE_BASIC_PRINTING) && defined(OS_WIN))
  handlers_.push_back(base::MakeUnique<printing::PrintingHandler>());
#endif
}
",C,,,,"@@ -73,7 +73,7 @@
 
 #if BUILDFLAG(ENABLE_PRINTING)
 #include ""chrome/common/chrome_content_client.h""
-#include ""components/printing/service/public/cpp/pdf_compositor_service_factory.h""
+#include ""components/printing/service/public/cpp/pdf_compositor_service_factory.h""  // nogncheck
 #include ""components/printing/service/public/interfaces/pdf_compositor.mojom.h""  // nogncheck
 #endif
 ",Chrome,9c391ac04f9ac478c8b0e43b359c2b43a6c892ab,896aab1971cb86907e97ea09726b3872fbfde09a,0,"ChromeContentUtilityClient::ChromeContentUtilityClient()
    : utility_process_running_elevated_(false) {
#if BUILDFLAG(ENABLE_EXTENSIONS)
  extensions::InitExtensionsClient();
#endif

#if BUILDFLAG(ENABLE_PRINT_PREVIEW) || \
    (BUILDFLAG(ENABLE_BASIC_PRINTING) && defined(OS_WIN))
  handlers_.push_back(base::MakeUnique<printing::PrintingHandler>());
#endif
}
"
120185,,Remote,Not required,Partial,CVE-2013-2902,https://www.cvedetails.com/cve/CVE-2013-2902/,CWE-399,Low,Partial,Partial,,2013-08-21,7.5,"Use-after-free vulnerability in the XSLT ProcessingInstruction implementation in Blink, as used in Google Chrome before 29.0.1547.57, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to an applyXSLTransform call involving (1) an HTML document or (2) an xsl:processing-instruction element that is still in the process of loading.",2017-09-18,DoS ,0,https://github.com/chromium/chromium/commit/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c,87a082c5137a63dedb3fe5b1f48f75dcd1fd780c,"Removed pinch viewport scroll offset distribution

The associated change in Blink makes the pinch viewport a proper
ScrollableArea meaning the normal path for synchronizing layer scroll
offsets is used.

This is a 2 sided patch, the other CL:
https://codereview.chromium.org/199253002/

BUG=349941

Review URL: https://codereview.chromium.org/210543002

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@260105 0039d316-1c4b-4281-b951-d872f2087c98",0,cc/layers/layer.cc,"{""sha"": ""39528df81080dafae9c77e23448ecdc95aec7b01"", ""filename"": ""cc/cc_tests.gyp"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/cc_tests.gyp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/cc_tests.gyp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/cc/cc_tests.gyp?ref=87a082c5137a63dedb3fe5b1f48f75dcd1fd780c"", ""patch"": ""@@ -103,7 +103,6 @@\n       'trees/layer_tree_host_unittest_delegated.cc',\n       'trees/layer_tree_host_unittest_occlusion.cc',\n       'trees/layer_tree_host_unittest_picture.cc',\n-      'trees/layer_tree_host_unittest_pinch_zoom.cc',\n       'trees/layer_tree_host_unittest_scroll.cc',\n       'trees/layer_tree_host_unittest_video.cc',\n       'trees/occlusion_tracker_unittest.cc',""}<_**next**_>{""sha"": ""44c71e5f409e06c38d28eebf749a94c1ec08a65c"", ""filename"": ""cc/layers/layer.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 5, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/layers/layer.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/layers/layer.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/cc/layers/layer.cc?ref=87a082c5137a63dedb3fe5b1f48f75dcd1fd780c"", ""patch"": ""@@ -674,11 +674,6 @@ void Layer::RemoveClipChild(Layer* child) {\n void Layer::SetScrollOffset(gfx::Vector2d scroll_offset) {\n   DCHECK(IsPropertyChangeAllowed());\n \n-  if (layer_tree_host()) {\n-    scroll_offset = layer_tree_host()->DistributeScrollOffsetToViewports(\n-        scroll_offset, this);\n-  }\n-\n   if (scroll_offset_ == scroll_offset)\n     return;\n   scroll_offset_ = scroll_offset;""}<_**next**_>{""sha"": ""21772804c95e0b2e5192cf63bb9e83c930ea4c43"", ""filename"": ""cc/trees/layer_tree_host.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 44, ""changes"": 44, ""blob_url"": ""https://github.com/chromium/chromium/blob/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/trees/layer_tree_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/trees/layer_tree_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/cc/trees/layer_tree_host.cc?ref=87a082c5137a63dedb3fe5b1f48f75dcd1fd780c"", ""patch"": ""@@ -1059,50 +1059,6 @@ void LayerTreeHost::ApplyScrollAndScale(const ScrollAndScaleSet& info) {\n   }\n }\n \n-gfx::Vector2d LayerTreeHost::DistributeScrollOffsetToViewports(\n-    const gfx::Vector2d offset,\n-    Layer* layer) {\n-  DCHECK(layer);\n-  if (layer != outer_viewport_scroll_layer_.get())\n-    return offset;\n-\n-  gfx::Vector2d inner_viewport_offset =\n-      inner_viewport_scroll_layer_->scroll_offset();\n-  gfx::Vector2d outer_viewport_offset =\n-      outer_viewport_scroll_layer_->scroll_offset();\n-\n-  if (offset == inner_viewport_offset + outer_viewport_offset) {\n-    // In this case, nothing should change, so we just return to the outer\n-    // viewport the offset is already has.\n-    return outer_viewport_offset;\n-  }\n-\n-  // In the spirit of document-scrolls-first, we always want any change to\n-  // go to the outer viewport first.\n-  gfx::Vector2d max_outer_viewport_scroll_offset =\n-      outer_viewport_scroll_layer_->MaxScrollOffset();\n-  gfx::Vector2d max_inner_viewport_scroll_offset =\n-      inner_viewport_scroll_layer_->MaxScrollOffset();\n-\n-  // TODO(bokan): This trips on zoom-out due to how Blink orders scale-scroll.\n-  //              Disabled until that's sorted out: crbug.com/336574\n-  // gfx::Vector2d total_max_scroll_offset =\n-  //    max_outer_viewport_scroll_offset + max_inner_viewport_scroll_offset;\n-  // DCHECK(total_max_scroll_offset.x() >= offset.x() &&\n-  //       total_max_scroll_offset.y() >= offset.y());\n-\n-  outer_viewport_offset = offset - inner_viewport_offset;\n-  outer_viewport_offset.SetToMin(max_outer_viewport_scroll_offset);\n-  outer_viewport_offset.SetToMax(gfx::Vector2d());\n-\n-  inner_viewport_offset = offset - outer_viewport_offset;\n-  inner_viewport_offset.SetToMin(max_inner_viewport_scroll_offset);\n-  inner_viewport_offset.SetToMax(gfx::Vector2d());\n-  inner_viewport_scroll_layer_->SetScrollOffset(inner_viewport_offset);\n-\n-  return outer_viewport_offset;\n-}\n-\n void LayerTreeHost::StartRateLimiter() {\n   if (animating_)\n     return;""}<_**next**_>{""sha"": ""98ac83d13b154fb0e256340b0331b8eb5c06612f"", ""filename"": ""cc/trees/layer_tree_host.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/trees/layer_tree_host.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/87a082c5137a63dedb3fe5b1f48f75dcd1fd780c/cc/trees/layer_tree_host.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/cc/trees/layer_tree_host.h?ref=87a082c5137a63dedb3fe5b1f48f75dcd1fd780c"", ""patch"": ""@@ -239,9 +239,6 @@ class CC_EXPORT LayerTreeHost {\n                                base::TimeDelta duration);\n \n   void ApplyScrollAndScale(const ScrollAndScaleSet& info);\n-  gfx::Vector2d DistributeScrollOffsetToViewports(const gfx::Vector2d offset,\n-                                                  Layer* layer);\n-\n   void SetImplTransform(const gfx::Transform& transform);\n \n   // Virtual for tests.""}<_**next**_>{""sha"": ""a77cbdccb9febd5581c61c62733b26a9b0f2ebca"", ""filename"": ""cc/trees/layer_tree_host_unittest_pinch_zoom.cc"", ""status"": ""removed"", ""additions"": 0, ""deletions"": 122, ""changes"": 122, ""blob_url"": ""https://github.com/chromium/chromium/blob/2aa4ce2ef8e39f2bf93e82dc829991e9734a4091/cc/trees/layer_tree_host_unittest_pinch_zoom.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/2aa4ce2ef8e39f2bf93e82dc829991e9734a4091/cc/trees/layer_tree_host_unittest_pinch_zoom.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/cc/trees/layer_tree_host_unittest_pinch_zoom.cc?ref=2aa4ce2ef8e39f2bf93e82dc829991e9734a4091"", ""patch"": ""@@ -1,122 +0,0 @@\n-// Copyright 2014 The Chromium Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style license that can be\n-// found in the LICENSE file.\n-\n-#include \""cc/trees/layer_tree_host.h\""\n-\n-#include \""base/memory/scoped_ptr.h\""\n-#include \""cc/layers/layer.h\""\n-#include \""cc/test/geometry_test_utils.h\""\n-#include \""cc/test/layer_tree_test.h\""\n-#include \""testing/gmock/include/gmock/gmock.h\""\n-#include \""testing/gtest/include/gtest/gtest.h\""\n-\n-using gfx::Vector2d;\n-\n-namespace cc {\n-namespace {\n-\n-class LayerTreeHostPinchZoomTest : public LayerTreeTest {};\n-\n-// Ensure that the DistributeScrollOffsetToViewports() method of LayerTreeHost\n-// does not set values outside the scroll offset max.\n-class LayerTreeHostPinchZoomTestDistributeScrollOffsetToViewports\n-    : public LayerTreeHostPinchZoomTest {\n- public:\n-  // Sets up a 2X scale resulting in the following viewport configuration:\n-  //    +------------------------------------------------+\n-  //    |              |              |                  |\n-  //    |              |              |                  |\n-  //    |              |              |                  |\n-  //    |  InnerClip   |5px           |                  |\n-  //    |              |              |                  |\n-  //    |              |              |10px              |\n-  //    |--------------+              |                  |\n-  //    |      5px                    |                  |\n-  //    |                             |                  | 20px\n-  //    | Inner Scroll/Outer Clip     |                  |\n-  //    |                             |                  |\n-  //    |-----------------------------+                  |\n-  //    |             10px                               |\n-  //    |                                                |\n-  //    |                                                |\n-  //    |                 Outer Scroll Layer             |\n-  //    |                                                |\n-  //    |                                                |\n-  //    +------------------------------------------------+\n-  //                         20px\n-  //\n-  virtual void SetupTree() OVERRIDE {\n-    scoped_refptr<Layer> inner_viewport_clip_layer = Layer::Create();\n-    scoped_refptr<Layer> page_scale_layer = Layer::Create();\n-    scoped_refptr<Layer> inner_viewport_scroll_layer = Layer::Create();\n-    scoped_refptr<Layer> outer_viewport_clip_layer = Layer::Create();\n-    scoped_refptr<Layer> outer_viewport_scroll_layer = Layer::Create();\n-\n-    inner_viewport_scroll_layer->SetScrollClipLayerId(\n-        inner_viewport_clip_layer->id());\n-    inner_viewport_scroll_layer->SetUserScrollable(true, true);\n-\n-    inner_viewport_clip_layer->AddChild(page_scale_layer);\n-    page_scale_layer->AddChild(inner_viewport_scroll_layer);\n-\n-    inner_viewport_scroll_layer->AddChild(outer_viewport_clip_layer);\n-    outer_viewport_clip_layer->AddChild(outer_viewport_scroll_layer);\n-\n-    outer_viewport_scroll_layer->SetScrollClipLayerId(\n-        outer_viewport_clip_layer->id());\n-    outer_viewport_scroll_layer->SetUserScrollable(true, true);\n-\n-    layer_tree_host()->RegisterViewportLayers(page_scale_layer,\n-        inner_viewport_scroll_layer,\n-        outer_viewport_scroll_layer);\n-\n-    inner_viewport_clip_layer->SetBounds(gfx::Size(10, 10));\n-    outer_viewport_clip_layer->SetAnchorPoint(gfx::PointF());\n-    outer_viewport_clip_layer->SetBounds(gfx::Size(10, 10));\n-\n-    layer_tree_host()->SetRootLayer(inner_viewport_clip_layer);\n-\n-    inner_viewport_scroll_layer->SetBounds(gfx::Size(10, 10));\n-    outer_viewport_scroll_layer->SetBounds(gfx::Size(20, 20));\n-    layer_tree_host()->SetPageScaleFactorAndLimits(2.0f, 1.0f, 5.0f);\n-\n-    // Sanity check\n-    EXPECT_VECTOR_EQ(Vector2d(5, 5),\n-        inner_viewport_scroll_layer->MaxScrollOffset());\n-    EXPECT_VECTOR_EQ(Vector2d(10, 10),\n-        outer_viewport_scroll_layer->MaxScrollOffset());\n-    EXPECT_VECTOR_EQ(Vector2d(0, 0),\n-        inner_viewport_scroll_layer->scroll_offset());\n-    EXPECT_VECTOR_EQ(Vector2d(0, 0),\n-        outer_viewport_scroll_layer->scroll_offset());\n-  }\n-\n-  virtual void BeginTest() OVERRIDE {\n-    Layer *inner = layer_tree_host()->inner_viewport_scroll_layer();\n-    Layer *outer = layer_tree_host()->outer_viewport_scroll_layer();\n-\n-    // Try to scroll beyond offset minium\n-    gfx::Vector2d offset(-20, -20);\n-    outer->SetScrollOffset(offset);\n-    EXPECT_VECTOR_EQ(Vector2d(0, 0), inner->scroll_offset());\n-    EXPECT_VECTOR_EQ(Vector2d(0, 0), outer->scroll_offset());\n-\n-    // Try to scroll beyond offset maximum\n-    offset = gfx::Vector2d(20, 20);\n-    outer->SetScrollOffset(offset);\n-    EXPECT_VECTOR_EQ(Vector2d(5, 5), inner->scroll_offset());\n-    EXPECT_VECTOR_EQ(Vector2d(10, 10), outer->scroll_offset());\n-\n-    EndTest();\n-  }\n-\n-  virtual void AfterTest() OVERRIDE {}\n-};\n-\n-TEST_F(LayerTreeHostPinchZoomTestDistributeScrollOffsetToViewports, Test) {\n-    RunTest(true, false, false);\n-}\n-\n-}  // namespace\n-}  // namespace cc""}","void Layer::SetScrollClipLayerId(int clip_layer_id) {
  DCHECK(IsPropertyChangeAllowed());
  if (scroll_clip_layer_id_ == clip_layer_id)
    return;
  scroll_clip_layer_id_ = clip_layer_id;
  SetNeedsCommit();
}
","void Layer::SetScrollClipLayerId(int clip_layer_id) {
  DCHECK(IsPropertyChangeAllowed());
  if (scroll_clip_layer_id_ == clip_layer_id)
    return;
  scroll_clip_layer_id_ = clip_layer_id;
  SetNeedsCommit();
}
",C,,,,"@@ -674,11 +674,6 @@ void Layer::RemoveClipChild(Layer* child) {
 void Layer::SetScrollOffset(gfx::Vector2d scroll_offset) {
   DCHECK(IsPropertyChangeAllowed());
 
-  if (layer_tree_host()) {
-    scroll_offset = layer_tree_host()->DistributeScrollOffsetToViewports(
-        scroll_offset, this);
-  }
-
   if (scroll_offset_ == scroll_offset)
     return;
   scroll_offset_ = scroll_offset;",Chrome,87a082c5137a63dedb3fe5b1f48f75dcd1fd780c,2aa4ce2ef8e39f2bf93e82dc829991e9734a4091,0,"void Layer::SetScrollClipLayerId(int clip_layer_id) {
  DCHECK(IsPropertyChangeAllowed());
  if (scroll_clip_layer_id_ == clip_layer_id)
    return;
  scroll_clip_layer_id_ = clip_layer_id;
  SetNeedsCommit();
}
"
68905,,Local,Not required,Complete,CVE-2017-5546,https://www.cvedetails.com/cve/CVE-2017-5546/,,Low,Complete,Complete,,2017-02-06,7.2,The freelist-randomization feature in mm/slab.c in the Linux kernel 4.8.x and 4.9.x before 4.9.5 allows local users to cause a denial of service (duplicate freelist entries and system crash) or possibly have unspecified other impact in opportunistic circumstances by leveraging the selection of a large value for a random number.,2019-10-02,DoS ,0,https://github.com/torvalds/linux/commit/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,"mm/slab.c: fix SLAB freelist randomization duplicate entries

This patch fixes a bug in the freelist randomization code.  When a high
random number is used, the freelist will contain duplicate entries.  It
will result in different allocations sharing the same chunk.

It will result in odd behaviours and crashes.  It should be uncommon but
it depends on the machines.  We saw it happening more often on some
machines (every few hours of running tests).

Fixes: c7ce4f60ac19 (""mm: SLAB freelist randomization"")
Link: http://lkml.kernel.org/r/20170103181908.143178-1-thgarnie@google.com
Signed-off-by: John Sperbeck <jsperbeck@google.com>
Signed-off-by: Thomas Garnier <thgarnie@google.com>
Cc: Christoph Lameter <cl@linux.com>
Cc: Pekka Enberg <penberg@kernel.org>
Cc: David Rientjes <rientjes@google.com>
Cc: Joonsoo Kim <iamjoonsoo.kim@lge.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>",0,mm/slab.c,"{""sha"": ""4f2ec6bb46ebe949d2e19ff154faddc7e2526f02"", ""filename"": ""mm/slab.c"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/torvalds/linux/blob/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/mm/slab.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c4e490cf148e85ead0d1b1c2caaba833f1d5b29f/mm/slab.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/mm/slab.c?ref=c4e490cf148e85ead0d1b1c2caaba833f1d5b29f"", ""patch"": ""@@ -2457,7 +2457,6 @@ union freelist_init_state {\n \t\tunsigned int pos;\n \t\tunsigned int *list;\n \t\tunsigned int count;\n-\t\tunsigned int rand;\n \t};\n \tstruct rnd_state rnd_state;\n };\n@@ -2483,8 +2482,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n \t} else {\n \t\tstate->list = cachep->random_seq;\n \t\tstate->count = count;\n-\t\tstate->pos = 0;\n-\t\tstate->rand = rand;\n+\t\tstate->pos = rand % count;\n \t\tret = true;\n \t}\n \treturn ret;\n@@ -2493,7 +2491,9 @@ static bool freelist_state_initialize(union freelist_init_state *state,\n /* Get the next entry on the list and randomize it using a random shift */\n static freelist_idx_t next_random_slot(union freelist_init_state *state)\n {\n-\treturn (state->list[state->pos++] + state->rand) % state->count;\n+\tif (state->pos >= state->count)\n+\t\tstate->pos = 0;\n+\treturn state->list[state->pos++];\n }\n \n /* Swap two freelist entries */""}","void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)
{
	struct kmem_cache *s;
	size_t i;

	local_irq_disable();
	for (i = 0; i < size; i++) {
		void *objp = p[i];

		if (!orig_s) /* called via kfree_bulk */
			s = virt_to_cache(objp);
		else
			s = cache_from_obj(orig_s, objp);

		debug_check_no_locks_freed(objp, s->object_size);
		if (!(s->flags & SLAB_DEBUG_OBJECTS))
			debug_check_no_obj_freed(objp, s->object_size);

		__cache_free(s, objp, _RET_IP_);
	}
	local_irq_enable();

	/* FIXME: add tracing */
}
","void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)
{
	struct kmem_cache *s;
	size_t i;

	local_irq_disable();
	for (i = 0; i < size; i++) {
		void *objp = p[i];

		if (!orig_s) /* called via kfree_bulk */
			s = virt_to_cache(objp);
		else
			s = cache_from_obj(orig_s, objp);

		debug_check_no_locks_freed(objp, s->object_size);
		if (!(s->flags & SLAB_DEBUG_OBJECTS))
			debug_check_no_obj_freed(objp, s->object_size);

		__cache_free(s, objp, _RET_IP_);
	}
	local_irq_enable();

	/* FIXME: add tracing */
}
",C,,,,"@@ -2457,7 +2457,6 @@ union freelist_init_state {
 		unsigned int pos;
 		unsigned int *list;
 		unsigned int count;
-		unsigned int rand;
 	};
 	struct rnd_state rnd_state;
 };
@@ -2483,8 +2482,7 @@ static bool freelist_state_initialize(union freelist_init_state *state,
 	} else {
 		state->list = cachep->random_seq;
 		state->count = count;
-		state->pos = 0;
-		state->rand = rand;
+		state->pos = rand % count;
 		ret = true;
 	}
 	return ret;
@@ -2493,7 +2491,9 @@ static bool freelist_state_initialize(union freelist_init_state *state,
 /* Get the next entry on the list and randomize it using a random shift */
 static freelist_idx_t next_random_slot(union freelist_init_state *state)
 {
-	return (state->list[state->pos++] + state->rand) % state->count;
+	if (state->pos >= state->count)
+		state->pos = 0;
+	return state->list[state->pos++];
 }
 
 /* Swap two freelist entries */",linux,c4e490cf148e85ead0d1b1c2caaba833f1d5b29f,b09ab054b69b07077bd3292f67e777861ac796e5,0,"void kmem_cache_free_bulk(struct kmem_cache *orig_s, size_t size, void **p)
{
	struct kmem_cache *s;
	size_t i;

	local_irq_disable();
	for (i = 0; i < size; i++) {
		void *objp = p[i];

		if (!orig_s) /* called via kfree_bulk */
			s = virt_to_cache(objp);
		else
			s = cache_from_obj(orig_s, objp);

		debug_check_no_locks_freed(objp, s->object_size);
		if (!(s->flags & SLAB_DEBUG_OBJECTS))
			debug_check_no_obj_freed(objp, s->object_size);

		__cache_free(s, objp, _RET_IP_);
	}
	local_irq_enable();

	/* FIXME: add tracing */
}
"
66639,,Local,Not required,Complete,CVE-2017-8066,https://www.cvedetails.com/cve/CVE-2017-8066/,CWE-119,Low,Complete,Complete,,2017-04-23,7.2,"drivers/net/can/usb/gs_usb.c in the Linux kernel 4.9.x and 4.10.x before 4.10.2 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",2017-04-27,DoS Overflow Mem. Corr. ,0,https://github.com/torvalds/linux/commit/c919a3069c775c1c876bec55e00b2305d5125caa,c919a3069c775c1c876bec55e00b2305d5125caa,"can: gs_usb: Don't use stack memory for USB transfers

Fixes: 05ca5270005c can: gs_usb: add ethtool set_phys_id callback to locate physical device

The gs_usb driver is performing USB transfers using buffers allocated on
the stack. This causes the driver to not function with vmapped stacks.
Instead, allocate memory for the transfer buffers.

Signed-off-by: Ethan Zonca <e@ethanzonca.com>
Cc: linux-stable <stable@vger.kernel.org> # >= v4.8
Signed-off-by: Marc Kleine-Budde <mkl@pengutronix.de>",0,drivers/net/can/usb/gs_usb.c,"{""sha"": ""a0dabd4038ba350c6b26f2a53834cb342c17da46"", ""filename"": ""drivers/net/can/usb/gs_usb.c"", ""status"": ""modified"", ""additions"": 29, ""deletions"": 11, ""changes"": 40, ""blob_url"": ""https://github.com/torvalds/linux/blob/c919a3069c775c1c876bec55e00b2305d5125caa/drivers/net/can/usb/gs_usb.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/c919a3069c775c1c876bec55e00b2305d5125caa/drivers/net/can/usb/gs_usb.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/drivers/net/can/usb/gs_usb.c?ref=c919a3069c775c1c876bec55e00b2305d5125caa"", ""patch"": ""@@ -908,10 +908,14 @@ static int gs_usb_probe(struct usb_interface *intf,\n \tstruct gs_usb *dev;\n \tint rc = -ENOMEM;\n \tunsigned int icount, i;\n-\tstruct gs_host_config hconf = {\n-\t\t.byte_order = 0x0000beef,\n-\t};\n-\tstruct gs_device_config dconf;\n+\tstruct gs_host_config *hconf;\n+\tstruct gs_device_config *dconf;\n+\n+\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n+\tif (!hconf)\n+\t\treturn -ENOMEM;\n+\n+\thconf->byte_order = 0x0000beef;\n \n \t/* send host config */\n \trc = usb_control_msg(interface_to_usbdev(intf),\n@@ -920,45 +924,56 @@ static int gs_usb_probe(struct usb_interface *intf,\n \t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n \t\t\t     1,\n \t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n-\t\t\t     &hconf,\n-\t\t\t     sizeof(hconf),\n+\t\t\t     hconf,\n+\t\t\t     sizeof(*hconf),\n \t\t\t     1000);\n \n+\tkfree(hconf);\n+\n \tif (rc < 0) {\n \t\tdev_err(&intf->dev, \""Couldn't send data format (err=%d)\\n\"",\n \t\t\trc);\n \t\treturn rc;\n \t}\n \n+\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n+\tif (!dconf)\n+\t\treturn -ENOMEM;\n+\n \t/* read device config */\n \trc = usb_control_msg(interface_to_usbdev(intf),\n \t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n \t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n \t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n \t\t\t     1,\n \t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n-\t\t\t     &dconf,\n-\t\t\t     sizeof(dconf),\n+\t\t\t     dconf,\n+\t\t\t     sizeof(*dconf),\n \t\t\t     1000);\n \tif (rc < 0) {\n \t\tdev_err(&intf->dev, \""Couldn't get device config: (err=%d)\\n\"",\n \t\t\trc);\n+\t\tkfree(dconf);\n \t\treturn rc;\n \t}\n \n-\ticount = dconf.icount + 1;\n+\ticount = dconf->icount + 1;\n \tdev_info(&intf->dev, \""Configuring for %d interfaces\\n\"", icount);\n \n \tif (icount > GS_MAX_INTF) {\n \t\tdev_err(&intf->dev,\n \t\t\t\""Driver cannot handle more that %d CAN interfaces\\n\"",\n \t\t\tGS_MAX_INTF);\n+\t\tkfree(dconf);\n \t\treturn -EINVAL;\n \t}\n \n \tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n-\tif (!dev)\n+\tif (!dev) {\n+\t\tkfree(dconf);\n \t\treturn -ENOMEM;\n+\t}\n+\n \tinit_usb_anchor(&dev->rx_submitted);\n \n \tatomic_set(&dev->active_channels, 0);\n@@ -967,7 +982,7 @@ static int gs_usb_probe(struct usb_interface *intf,\n \tdev->udev = interface_to_usbdev(intf);\n \n \tfor (i = 0; i < icount; i++) {\n-\t\tdev->canch[i] = gs_make_candev(i, intf, &dconf);\n+\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n \t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n \t\t\t/* save error code to return later */\n \t\t\trc = PTR_ERR(dev->canch[i]);\n@@ -978,12 +993,15 @@ static int gs_usb_probe(struct usb_interface *intf,\n \t\t\t\tgs_destroy_candev(dev->canch[i]);\n \n \t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n+\t\t\tkfree(dconf);\n \t\t\tkfree(dev);\n \t\t\treturn rc;\n \t\t}\n \t\tdev->canch[i]->parent = dev;\n \t}\n \n+\tkfree(dconf);\n+\n \treturn 0;\n }\n ""}","static void gs_usb_disconnect(struct usb_interface *intf)
{
	unsigned i;
	struct gs_usb *dev = usb_get_intfdata(intf);
	usb_set_intfdata(intf, NULL);

	if (!dev) {
		dev_err(&intf->dev, ""Disconnect (nodata)\n"");
		return;
	}

	for (i = 0; i < GS_MAX_INTF; i++)
		if (dev->canch[i])
			gs_destroy_candev(dev->canch[i]);

	usb_kill_anchored_urbs(&dev->rx_submitted);
	kfree(dev);
}
","static void gs_usb_disconnect(struct usb_interface *intf)
{
	unsigned i;
	struct gs_usb *dev = usb_get_intfdata(intf);
	usb_set_intfdata(intf, NULL);

	if (!dev) {
		dev_err(&intf->dev, ""Disconnect (nodata)\n"");
		return;
	}

	for (i = 0; i < GS_MAX_INTF; i++)
		if (dev->canch[i])
			gs_destroy_candev(dev->canch[i]);

	usb_kill_anchored_urbs(&dev->rx_submitted);
	kfree(dev);
}
",C,,,,"@@ -908,10 +908,14 @@ static int gs_usb_probe(struct usb_interface *intf,
 	struct gs_usb *dev;
 	int rc = -ENOMEM;
 	unsigned int icount, i;
-	struct gs_host_config hconf = {
-		.byte_order = 0x0000beef,
-	};
-	struct gs_device_config dconf;
+	struct gs_host_config *hconf;
+	struct gs_device_config *dconf;
+
+	hconf = kmalloc(sizeof(*hconf), GFP_KERNEL);
+	if (!hconf)
+		return -ENOMEM;
+
+	hconf->byte_order = 0x0000beef;
 
 	/* send host config */
 	rc = usb_control_msg(interface_to_usbdev(intf),
@@ -920,45 +924,56 @@ static int gs_usb_probe(struct usb_interface *intf,
 			     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf->altsetting[0].desc.bInterfaceNumber,
-			     &hconf,
-			     sizeof(hconf),
+			     hconf,
+			     sizeof(*hconf),
 			     1000);
 
+	kfree(hconf);
+
 	if (rc < 0) {
 		dev_err(&intf->dev, ""Couldn't send data format (err=%d)\n"",
 			rc);
 		return rc;
 	}
 
+	dconf = kmalloc(sizeof(*dconf), GFP_KERNEL);
+	if (!dconf)
+		return -ENOMEM;
+
 	/* read device config */
 	rc = usb_control_msg(interface_to_usbdev(intf),
 			     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),
 			     GS_USB_BREQ_DEVICE_CONFIG,
 			     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf->altsetting[0].desc.bInterfaceNumber,
-			     &dconf,
-			     sizeof(dconf),
+			     dconf,
+			     sizeof(*dconf),
 			     1000);
 	if (rc < 0) {
 		dev_err(&intf->dev, ""Couldn't get device config: (err=%d)\n"",
 			rc);
+		kfree(dconf);
 		return rc;
 	}
 
-	icount = dconf.icount + 1;
+	icount = dconf->icount + 1;
 	dev_info(&intf->dev, ""Configuring for %d interfaces\n"", icount);
 
 	if (icount > GS_MAX_INTF) {
 		dev_err(&intf->dev,
 			""Driver cannot handle more that %d CAN interfaces\n"",
 			GS_MAX_INTF);
+		kfree(dconf);
 		return -EINVAL;
 	}
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-	if (!dev)
+	if (!dev) {
+		kfree(dconf);
 		return -ENOMEM;
+	}
+
 	init_usb_anchor(&dev->rx_submitted);
 
 	atomic_set(&dev->active_channels, 0);
@@ -967,7 +982,7 @@ static int gs_usb_probe(struct usb_interface *intf,
 	dev->udev = interface_to_usbdev(intf);
 
 	for (i = 0; i < icount; i++) {
-		dev->canch[i] = gs_make_candev(i, intf, &dconf);
+		dev->canch[i] = gs_make_candev(i, intf, dconf);
 		if (IS_ERR_OR_NULL(dev->canch[i])) {
 			/* save error code to return later */
 			rc = PTR_ERR(dev->canch[i]);
@@ -978,12 +993,15 @@ static int gs_usb_probe(struct usb_interface *intf,
 				gs_destroy_candev(dev->canch[i]);
 
 			usb_kill_anchored_urbs(&dev->rx_submitted);
+			kfree(dconf);
 			kfree(dev);
 			return rc;
 		}
 		dev->canch[i]->parent = dev;
 	}
 
+	kfree(dconf);
+
 	return 0;
 }
 ",linux,c919a3069c775c1c876bec55e00b2305d5125caa,9f674e48c13dcbc31ac903433727837795b81efe,0,"static void gs_usb_disconnect(struct usb_interface *intf)
{
	unsigned i;
	struct gs_usb *dev = usb_get_intfdata(intf);
	usb_set_intfdata(intf, NULL);

	if (!dev) {
		dev_err(&intf->dev, ""Disconnect (nodata)\n"");
		return;
	}

	for (i = 0; i < GS_MAX_INTF; i++)
		if (dev->canch[i])
			gs_destroy_candev(dev->canch[i]);

	usb_kill_anchored_urbs(&dev->rx_submitted);
	kfree(dev);
}
"
37877,,Local,Not required,Complete,CVE-2014-3610,https://www.cvedetails.com/cve/CVE-2014-3610/,CWE-264,Low,,,,2014-11-10,4.9,"The WRMSR processing functionality in the KVM subsystem in the Linux kernel through 3.17.2 does not properly handle the writing of a non-canonical address to a model-specific register, which allows guest OS users to cause a denial of service (host OS crash) by leveraging guest OS privileges, related to the wrmsr_interception function in arch/x86/kvm/svm.c and the handle_wrmsr function in arch/x86/kvm/vmx.c.",2017-01-02,DoS ,0,https://github.com/torvalds/linux/commit/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,"KVM: x86: Check non-canonical addresses upon WRMSR

Upon WRMSR, the CPU should inject #GP if a non-canonical value (address) is
written to certain MSRs. The behavior is ""almost"" identical for AMD and Intel
(ignoring MSRs that are not implemented in either architecture since they would
anyhow #GP). However, IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
non-canonical address is written on Intel but not on AMD (which ignores the top
32-bits).

Accordingly, this patch injects a #GP on the MSRs which behave identically on
Intel and AMD.  To eliminate the differences between the architecutres, the
value which is written to IA32_SYSENTER_ESP and IA32_SYSENTER_EIP is turned to
canonical value before writing instead of injecting a #GP.

Some references from Intel and AMD manuals:

According to Intel SDM description of WRMSR instruction #GP is expected on
WRMSR ""If the source register contains a non-canonical address and ECX
specifies one of the following MSRs: IA32_DS_AREA, IA32_FS_BASE, IA32_GS_BASE,
IA32_KERNEL_GS_BASE, IA32_LSTAR, IA32_SYSENTER_EIP, IA32_SYSENTER_ESP.""

According to AMD manual instruction manual:
LSTAR/CSTAR (SYSCALL): ""The WRMSR instruction loads the target RIP into the
LSTAR and CSTAR registers.  If an RIP written by WRMSR is not in canonical
form, a general-protection exception (#GP) occurs.""
IA32_GS_BASE and IA32_FS_BASE (WRFSBASE/WRGSBASE): ""The address written to the
base field must be in canonical form or a #GP fault will occur.""
IA32_KERNEL_GS_BASE (SWAPGS): ""The address stored in the KernelGSbase MSR must
be in canonical form.""

This patch fixes CVE-2014-3610.

Cc: stable@vger.kernel.org
Signed-off-by: Nadav Amit <namit@cs.technion.ac.il>
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",0,arch/x86/kvm/svm.c,"{""sha"": ""ccc94de4ac499db2681af23ae2b457ec5e813ff5"", ""filename"": ""arch/x86/include/asm/kvm_host.h"", ""status"": ""modified"", ""additions"": 14, ""deletions"": 0, ""changes"": 14, ""blob_url"": ""https://github.com/torvalds/linux/blob/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/include/asm/kvm_host.h"", ""raw_url"": ""https://github.com/torvalds/linux/raw/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/include/asm/kvm_host.h"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/include/asm/kvm_host.h?ref=854e8bb1aa06c578c2c9145fa6bfe3680ef63b23"", ""patch"": ""@@ -989,6 +989,20 @@ static inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n \tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n }\n \n+static inline u64 get_canonical(u64 la)\n+{\n+\treturn ((int64_t)la << 16) >> 16;\n+}\n+\n+static inline bool is_noncanonical_address(u64 la)\n+{\n+#ifdef CONFIG_X86_64\n+\treturn get_canonical(la) != la;\n+#else\n+\treturn false;\n+#endif\n+}\n+\n #define TSS_IOPB_BASE_OFFSET 0x66\n #define TSS_BASE_SIZE 0x68\n #define TSS_IOPB_SIZE (65536 / 8)""}<_**next**_>{""sha"": ""00bed2c5e948a1bdc7a58fbe345b0ce057ce4d64"", ""filename"": ""arch/x86/kvm/svm.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/svm.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/svm.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kvm/svm.c?ref=854e8bb1aa06c578c2c9145fa6bfe3680ef63b23"", ""patch"": ""@@ -3251,7 +3251,7 @@ static int wrmsr_interception(struct vcpu_svm *svm)\n \tmsr.host_initiated = false;\n \n \tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n-\tif (svm_set_msr(&svm->vcpu, &msr)) {\n+\tif (kvm_set_msr(&svm->vcpu, &msr)) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(&svm->vcpu, 0);\n \t} else {""}<_**next**_>{""sha"": ""148020a7dd980e061d31649cd46f70fa4e7e7228"", ""filename"": ""arch/x86/kvm/vmx.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/vmx.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/vmx.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kvm/vmx.c?ref=854e8bb1aa06c578c2c9145fa6bfe3680ef63b23"", ""patch"": ""@@ -5291,7 +5291,7 @@ static int handle_wrmsr(struct kvm_vcpu *vcpu)\n \tmsr.data = data;\n \tmsr.index = ecx;\n \tmsr.host_initiated = false;\n-\tif (vmx_set_msr(vcpu, &msr) != 0) {\n+\tif (kvm_set_msr(vcpu, &msr) != 0) {\n \t\ttrace_kvm_msr_write_ex(ecx, data);\n \t\tkvm_inject_gp(vcpu, 0);\n \t\treturn 1;""}<_**next**_>{""sha"": ""5a7195573a327b263aee6ded80c07a34714e784b"", ""filename"": ""arch/x86/kvm/x86.c"", ""status"": ""modified"", ""additions"": 26, ""deletions"": 1, ""changes"": 27, ""blob_url"": ""https://github.com/torvalds/linux/blob/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/x86.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/854e8bb1aa06c578c2c9145fa6bfe3680ef63b23/arch/x86/kvm/x86.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kvm/x86.c?ref=854e8bb1aa06c578c2c9145fa6bfe3680ef63b23"", ""patch"": ""@@ -987,16 +987,41 @@ void kvm_enable_efer_bits(u64 mask)\n }\n EXPORT_SYMBOL_GPL(kvm_enable_efer_bits);\n \n-\n /*\n  * Writes msr value into into the appropriate \""register\"".\n  * Returns 0 on success, non-0 otherwise.\n  * Assumes vcpu_load() was already called.\n  */\n int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n {\n+\tswitch (msr->index) {\n+\tcase MSR_FS_BASE:\n+\tcase MSR_GS_BASE:\n+\tcase MSR_KERNEL_GS_BASE:\n+\tcase MSR_CSTAR:\n+\tcase MSR_LSTAR:\n+\t\tif (is_noncanonical_address(msr->data))\n+\t\t\treturn 1;\n+\t\tbreak;\n+\tcase MSR_IA32_SYSENTER_EIP:\n+\tcase MSR_IA32_SYSENTER_ESP:\n+\t\t/*\n+\t\t * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if\n+\t\t * non-canonical address is written on Intel but not on\n+\t\t * AMD (which ignores the top 32-bits, because it does\n+\t\t * not implement 64-bit SYSENTER).\n+\t\t *\n+\t\t * 64-bit code should hence be able to write a non-canonical\n+\t\t * value on AMD.  Making the address canonical ensures that\n+\t\t * vmentry does not fail on Intel after writing a non-canonical\n+\t\t * value, and that something deterministic happens if the guest\n+\t\t * invokes 64-bit SYSENTER.\n+\t\t */\n+\t\tmsr->data = get_canonical(msr->data);\n+\t}\n \treturn kvm_x86_ops->set_msr(vcpu, msr);\n }\n+EXPORT_SYMBOL_GPL(kvm_set_msr);\n \n /*\n  * Adapt set_msr() to msr_io()'s calling convention""}","static int svm_nmi_allowed(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb *vmcb = svm->vmcb;
	int ret;
	ret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&
	      !(svm->vcpu.arch.hflags & HF_NMI_MASK);
	ret = ret && gif_set(svm) && nested_svm_nmi(svm);

	return ret;
}
","static int svm_nmi_allowed(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb *vmcb = svm->vmcb;
	int ret;
	ret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&
	      !(svm->vcpu.arch.hflags & HF_NMI_MASK);
	ret = ret && gif_set(svm) && nested_svm_nmi(svm);

	return ret;
}
",C,,,,"@@ -3251,7 +3251,7 @@ static int wrmsr_interception(struct vcpu_svm *svm)
 	msr.host_initiated = false;
 
 	svm->next_rip = kvm_rip_read(&svm->vcpu) + 2;
-	if (svm_set_msr(&svm->vcpu, &msr)) {
+	if (kvm_set_msr(&svm->vcpu, &msr)) {
 		trace_kvm_msr_write_ex(ecx, data);
 		kvm_inject_gp(&svm->vcpu, 0);
 	} else {",linux,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,c3351dfabf5c78fb5ddc79d0f7b65ebd9e441337,0,"static int svm_nmi_allowed(struct kvm_vcpu *vcpu)
{
	struct vcpu_svm *svm = to_svm(vcpu);
	struct vmcb *vmcb = svm->vmcb;
	int ret;
	ret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&
	      !(svm->vcpu.arch.hflags & HF_NMI_MASK);
	ret = ret && gif_set(svm) && nested_svm_nmi(svm);

	return ret;
}
"
132581,,Remote,Not required,Partial,CVE-2014-1700,https://www.cvedetails.com/cve/CVE-2014-1700/,CWE-399,Low,Partial,Partial,,2014-03-16,7.5,"Use-after-free vulnerability in modules/speech/SpeechSynthesis.cpp in Blink, as used in Google Chrome before 33.0.1750.149, allows remote attackers to cause a denial of service or possibly have unspecified other impact by leveraging improper handling of a certain utterance data structure.",2017-01-06,DoS ,0,https://github.com/chromium/chromium/commit/685c3980d31b5199924086b8c93a1ce751d24733,685c3980d31b5199924086b8c93a1ce751d24733,"content: Rename webkit_test_helpers.{cc,h} to blink_test_helpers.{cc,h}

Now that webkit/ is gone, we are preparing ourselves for the merge of
third_party/WebKit into //blink.

BUG=None
BUG=content_shell && content_unittests
R=avi@chromium.org

Review URL: https://codereview.chromium.org/1118183003

Cr-Commit-Position: refs/heads/master@{#328202}",0,content/shell/browser/webkit_test_controller.cc,"{""sha"": ""5a9805e6009278dfd2a1ad70452673ffee55947e"", ""filename"": ""content/DEPS"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/DEPS"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/DEPS"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/DEPS?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -113,7 +113,6 @@ include_rules = [\n \n   \""+storage/browser\"",\n   \""+storage/common\"",\n-  \""+webkit\"",\n \n   # For generated JNI includes.\n   \""+jni\"",""}<_**next**_>{""sha"": ""deb473fc529a5499802b0abedbbb59a0302ee135"", ""filename"": ""content/content_shell.gypi"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/content_shell.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/content_shell.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/content_shell.gypi?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -203,10 +203,10 @@\n         'shell/common/test_runner/test_preferences.h',\n         'shell/common/v8_breakpad_support_win.cc',\n         'shell/common/v8_breakpad_support_win.h',\n-        'shell/common/webkit_test_helpers.cc',\n-        'shell/common/webkit_test_helpers.h',\n         'shell/renderer/ipc_echo.cc',\n         'shell/renderer/ipc_echo.h',\n+        'shell/renderer/layout_test/blink_test_helpers.cc',\n+        'shell/renderer/layout_test/blink_test_helpers.h',\n         'shell/renderer/layout_test/blink_test_runner.cc',\n         'shell/renderer/layout_test/blink_test_runner.h',\n         'shell/renderer/layout_test/gc_controller.cc',""}<_**next**_>{""sha"": ""9f4e0a8db5e7b4b44bf34cce5efa9c18a990f945"", ""filename"": ""content/shell/BUILD.gn"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/BUILD.gn"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/BUILD.gn"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/BUILD.gn?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -144,10 +144,10 @@ static_library(\""content_shell_lib\"") {\n     \""common/shell_test_configuration.h\"",\n     \""common/test_runner/test_preferences.cc\"",\n     \""common/test_runner/test_preferences.h\"",\n-    \""common/webkit_test_helpers.cc\"",\n-    \""common/webkit_test_helpers.h\"",\n     \""renderer/ipc_echo.cc\"",\n     \""renderer/ipc_echo.h\"",\n+    \""renderer/layout_test/blink_test_helpers.cc\"",\n+    \""renderer/layout_test/blink_test_helpers.h\"",\n     \""renderer/layout_test/blink_test_runner.cc\"",\n     \""renderer/layout_test/blink_test_runner.h\"",\n     \""renderer/layout_test/gc_controller.cc\"",""}<_**next**_>{""sha"": ""970e0eaeb2bc31e53f78197d84524c201133e468"", ""filename"": ""content/shell/browser/layout_test/layout_test_browser_main.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/layout_test/layout_test_browser_main.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/layout_test/layout_test_browser_main.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/browser/layout_test/layout_test_browser_main.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -21,7 +21,7 @@\n #include \""content/shell/browser/shell.h\""\n #include \""content/shell/browser/webkit_test_controller.h\""\n #include \""content/shell/common/shell_switches.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n #include \""net/base/filename_util.h\""\n \n #if defined(OS_ANDROID)""}<_**next**_>{""sha"": ""9039997d14930d7caf01b4d2b8ac00a6d5bb5731"", ""filename"": ""content/shell/browser/layout_test/layout_test_content_browser_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/layout_test/layout_test_content_browser_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/layout_test/layout_test_content_browser_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/browser/layout_test/layout_test_content_browser_client.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -15,7 +15,7 @@\n #include \""content/shell/browser/layout_test/layout_test_notification_manager.h\""\n #include \""content/shell/browser/shell_browser_context.h\""\n #include \""content/shell/common/shell_messages.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n \n namespace content {\n namespace {""}<_**next**_>{""sha"": ""57974fb80801c9a5eb6c3874602aa557a205ad89"", ""filename"": ""content/shell/browser/shell_content_browser_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/shell_content_browser_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/shell_content_browser_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/browser/shell_content_browser_client.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -33,7 +33,7 @@\n #include \""content/shell/browser/webkit_test_controller.h\""\n #include \""content/shell/common/shell_messages.h\""\n #include \""content/shell/common/shell_switches.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n #include \""gin/v8_initializer.h\""\n #include \""net/url_request/url_request_context_getter.h\""\n #include \""url/gurl.h\""""}<_**next**_>{""sha"": ""1e31b911c3ac39b986f0086103d826b4353cf5da"", ""filename"": ""content/shell/browser/webkit_test_controller.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/webkit_test_controller.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/browser/webkit_test_controller.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/browser/webkit_test_controller.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -33,7 +33,7 @@\n #include \""content/shell/browser/shell_devtools_frontend.h\""\n #include \""content/shell/common/shell_messages.h\""\n #include \""content/shell/common/shell_switches.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n #include \""ui/gfx/codec/png_codec.h\""\n \n namespace content {""}<_**next**_>{""sha"": ""804b1e506dccc862fd03d921643951c2465d11b0"", ""filename"": ""content/shell/renderer/layout_test/blink_test_helpers.cc"", ""status"": ""renamed"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_helpers.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_helpers.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/renderer/layout_test/blink_test_helpers.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n \n #include \""base/command_line.h\""\n #include \""base/files/file_util.h\"""", ""previous_filename"": ""content/shell/common/webkit_test_helpers.cc""}<_**next**_>{""sha"": ""3350b926c9ab7883ea1bd6cb57def58f936c8ee1"", ""filename"": ""content/shell/renderer/layout_test/blink_test_helpers.h"", ""status"": ""renamed"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_helpers.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_helpers.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/renderer/layout_test/blink_test_helpers.h?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#ifndef CONTENT_SHELL_COMMON_WEBKIT_TEST_HELPERS_H_\n-#define CONTENT_SHELL_COMMON_WEBKIT_TEST_HELPERS_H_\n+#ifndef CONTENT_SHELL_RENDERER_LAYOUT_TEST_BLINK_TEST_HELPERS_H_\n+#define CONTENT_SHELL_RENDERER_LAYOUT_TEST_BLINK_TEST_HELPERS_H_\n \n #include <string>\n #include <vector>\n@@ -34,4 +34,4 @@ std::vector<std::string> GetSideloadFontFiles();\n \n }  // namespace content\n \n-#endif  // CONTENT_SHELL_COMMON_WEBKIT_TEST_HELPERS_H_\n+#endif  // CONTENT_SHELL_RENDERER_LAYOUT_TEST_BLINK_TEST_HELPERS_H_"", ""previous_filename"": ""content/shell/common/webkit_test_helpers.h""}<_**next**_>{""sha"": ""1881e2d4325dbdb4daf6d7261008cbedb8b8940e"", ""filename"": ""content/shell/renderer/layout_test/blink_test_runner.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_runner.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/blink_test_runner.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/renderer/layout_test/blink_test_runner.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -32,7 +32,7 @@\n #include \""content/shell/common/layout_test/layout_test_messages.h\""\n #include \""content/shell/common/shell_messages.h\""\n #include \""content/shell/common/shell_switches.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n #include \""content/shell/renderer/layout_test/gc_controller.h\""\n #include \""content/shell/renderer/layout_test/layout_test_render_process_observer.h\""\n #include \""content/shell/renderer/layout_test/leak_detector.h\""""}<_**next**_>{""sha"": ""ec8d4500f2dff986480959e7b9f1be56e20f8fa8"", ""filename"": ""content/shell/renderer/layout_test/layout_test_content_renderer_client.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/layout_test_content_renderer_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/685c3980d31b5199924086b8c93a1ce751d24733/content/shell/renderer/layout_test/layout_test_content_renderer_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/shell/renderer/layout_test/layout_test_content_renderer_client.cc?ref=685c3980d31b5199924086b8c93a1ce751d24733"", ""patch"": ""@@ -13,7 +13,7 @@\n #include \""content/public/renderer/render_view.h\""\n #include \""content/public/test/layouttest_support.h\""\n #include \""content/shell/common/shell_switches.h\""\n-#include \""content/shell/common/webkit_test_helpers.h\""\n+#include \""content/shell/renderer/layout_test/blink_test_helpers.h\""\n #include \""content/shell/renderer/layout_test/blink_test_runner.h\""\n #include \""content/shell/renderer/layout_test/layout_test_render_frame_observer.h\""\n #include \""content/shell/renderer/layout_test/layout_test_render_process_observer.h\""""}","void WebKitTestController::OnLoadURLForFrame(const GURL& url,
                                             const std::string& frame_name) {
  main_window_->LoadURLForFrame(url, frame_name);
}
","void WebKitTestController::OnLoadURLForFrame(const GURL& url,
                                             const std::string& frame_name) {
  main_window_->LoadURLForFrame(url, frame_name);
}
",C,,,,"@@ -33,7 +33,7 @@
 #include ""content/shell/browser/shell_devtools_frontend.h""
 #include ""content/shell/common/shell_messages.h""
 #include ""content/shell/common/shell_switches.h""
-#include ""content/shell/common/webkit_test_helpers.h""
+#include ""content/shell/renderer/layout_test/blink_test_helpers.h""
 #include ""ui/gfx/codec/png_codec.h""
 
 namespace content {",Chrome,685c3980d31b5199924086b8c93a1ce751d24733,0fa5b759d2bbd5c074277e2a13e6a765da031af4,0,"void WebKitTestController::OnLoadURLForFrame(const GURL& url,
                                             const std::string& frame_name) {
  main_window_->LoadURLForFrame(url, frame_name);
}
"
90045,,Remote,Not required,Partial,CVE-2019-11922,https://www.cvedetails.com/cve/CVE-2019-11922/,CWE-362,Medium,Partial,Partial,,2019-07-25,6.8,A race condition in the one-pass compression functions of Zstandard prior to version 1.3.8 could allow an attacker to write bytes out of bounds if an output buffer smaller than the recommended size was used.,2019-08-12,,0,https://github.com/facebook/zstd/pull/1404/commits/3e5cdf1b6a85843e991d7d10f6a2567c15580da0,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,fixed T36302429,0,lib/compress/zstd_compress.c,"{""sha"": ""7721325d78a9d31307e7311034c89c5d689ae010"", ""filename"": ""lib/compress/zstd_compress.c"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 2, ""changes"": 11, ""blob_url"": ""https://github.com/facebook/zstd/blob/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/lib/compress/zstd_compress.c"", ""raw_url"": ""https://github.com/facebook/zstd/raw/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/lib/compress/zstd_compress.c"", ""contents_url"": ""https://api.github.com/repos/facebook/zstd/contents/lib/compress/zstd_compress.c?ref=3e5cdf1b6a85843e991d7d10f6a2567c15580da0"", ""patch"": ""@@ -2008,11 +2008,13 @@ ZSTD_buildCTable(void* dst, size_t dstCapacity,\n {\n     BYTE* op = (BYTE*)dst;\n     const BYTE* const oend = op + dstCapacity;\n+    DEBUGLOG(6, \""ZSTD_buildCTable (dstCapacity=%u)\"", (unsigned)dstCapacity);\n \n     switch (type) {\n     case set_rle:\n-        *op = codeTable[0];\n         CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));\n+        if (dstCapacity==0) return ERROR(dstSize_tooSmall);\n+        *op = codeTable[0];\n         return 1;\n     case set_repeat:\n         memcpy(nextCTable, prevCTable, prevCTableSize);\n@@ -2054,6 +2056,9 @@ ZSTD_encodeSequences_body(\n     FSE_CState_t  stateLitLength;\n \n     CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); /* not enough space remaining */\n+    DEBUGLOG(6, \""available space for bitstream : %i  (dstCapacity=%u)\"",\n+                (int)(blockStream.endPtr - blockStream.startPtr),\n+                (unsigned)dstCapacity);\n \n     /* first symbols */\n     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);\n@@ -2113,6 +2118,7 @@ ZSTD_encodeSequences_body(\n                 BIT_addBits(&blockStream, sequences[n].offset, ofBits);     /* 31 */\n             }\n             BIT_flushBits(&blockStream);                                    /* (7)*/\n+            DEBUGLOG(7, \""remaining space : %i\"", (int)(blockStream.endPtr - blockStream.ptr));\n     }   }\n \n     DEBUGLOG(6, \""ZSTD_encodeSequences: flushing ML state with %u bits\"", stateMatchLength.stateLog);\n@@ -2170,6 +2176,7 @@ static size_t ZSTD_encodeSequences(\n             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,\n             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)\n {\n+    DEBUGLOG(5, \""ZSTD_encodeSequences: dstCapacity = %u\"", (unsigned)dstCapacity);\n #if DYNAMIC_BMI2\n     if (bmi2) {\n         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,\n@@ -2290,7 +2297,7 @@ ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,\n     /* build CTable for MatchLengths */\n     {   U32 max = MaxML;\n         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */\n-        DEBUGLOG(5, \""Building ML table\"");\n+        DEBUGLOG(5, \""Building ML table (remaining space : %i)\"", (int)(oend-op));\n         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;\n         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);\n         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */""}<_**next**_>{""sha"": ""eae7158894ef59e8b1605d05b52c35c6bfc01875"", ""filename"": ""tests/fuzzer.c"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 3, ""changes"": 8, ""blob_url"": ""https://github.com/facebook/zstd/blob/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/tests/fuzzer.c"", ""raw_url"": ""https://github.com/facebook/zstd/raw/3e5cdf1b6a85843e991d7d10f6a2567c15580da0/tests/fuzzer.c"", ""contents_url"": ""https://api.github.com/repos/facebook/zstd/contents/tests/fuzzer.c?ref=3e5cdf1b6a85843e991d7d10f6a2567c15580da0"", ""patch"": ""@@ -1742,15 +1742,17 @@ static int fuzzerTests(U32 seed, U32 nbTests, unsigned startTest, U32 const maxD\n             CHECK(ZSTD_isError(cSize), \""ZSTD_compressCCtx failed : %s\"", ZSTD_getErrorName(cSize));\n \n             /* compression failure test : too small dest buffer */\n-            if (cSize > 3) {\n-                const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;   /* no problem, as cSize > 4 (frameHeaderSizer) */\n+            assert(cSize > 3);\n+            {   const size_t missing = (FUZ_rand(&lseed) % (cSize-2)) + 1;\n                 const size_t tooSmallSize = cSize - missing;\n                 const U32 endMark = 0x4DC2B1A9;\n                 memcpy(dstBuffer+tooSmallSize, &endMark, 4);\n+                DISPLAYLEVEL(5, \""fuzzer t%u: compress into too small buffer of size %u (missing %u bytes) \\n\"",\n+                            testNb, (unsigned)tooSmallSize, (unsigned)missing);\n                 { size_t const errorCode = ZSTD_compressCCtx(ctx, dstBuffer, tooSmallSize, sampleBuffer, sampleSize, cLevel);\n                   CHECK(!ZSTD_isError(errorCode), \""ZSTD_compressCCtx should have failed ! (buffer too small : %u < %u)\"", (U32)tooSmallSize, (U32)cSize); }\n                 { U32 endCheck; memcpy(&endCheck, dstBuffer+tooSmallSize, 4);\n-                  CHECK(endCheck != endMark, \""ZSTD_compressCCtx : dst buffer overflow\""); }\n+                  CHECK(endCheck != endMark, \""ZSTD_compressCCtx : dst buffer overflow  (check.%08X != %08X.mark)\"", endCheck, endMark); }\n         }   }\n \n         /* frame header decompression test */""}","ZSTD_CDict* ZSTD_createCDict_byReference(const void* dict, size_t dictSize, int compressionLevel)
{
    ZSTD_compressionParameters cParams = ZSTD_getCParams(compressionLevel, 0, dictSize);
    return ZSTD_createCDict_advanced(dict, dictSize,
                                     ZSTD_dlm_byRef, ZSTD_dct_auto,
                                     cParams, ZSTD_defaultCMem);
}
","ZSTD_CDict* ZSTD_createCDict_byReference(const void* dict, size_t dictSize, int compressionLevel)
{
    ZSTD_compressionParameters cParams = ZSTD_getCParams(compressionLevel, 0, dictSize);
    return ZSTD_createCDict_advanced(dict, dictSize,
                                     ZSTD_dlm_byRef, ZSTD_dct_auto,
                                     cParams, ZSTD_defaultCMem);
}
",C,,,,"@@ -2008,11 +2008,13 @@ ZSTD_buildCTable(void* dst, size_t dstCapacity,
 {
     BYTE* op = (BYTE*)dst;
     const BYTE* const oend = op + dstCapacity;
+    DEBUGLOG(6, ""ZSTD_buildCTable (dstCapacity=%u)"", (unsigned)dstCapacity);
 
     switch (type) {
     case set_rle:
-        *op = codeTable[0];
         CHECK_F(FSE_buildCTable_rle(nextCTable, (BYTE)max));
+        if (dstCapacity==0) return ERROR(dstSize_tooSmall);
+        *op = codeTable[0];
         return 1;
     case set_repeat:
         memcpy(nextCTable, prevCTable, prevCTableSize);
@@ -2054,6 +2056,9 @@ ZSTD_encodeSequences_body(
     FSE_CState_t  stateLitLength;
 
     CHECK_E(BIT_initCStream(&blockStream, dst, dstCapacity), dstSize_tooSmall); /* not enough space remaining */
+    DEBUGLOG(6, ""available space for bitstream : %i  (dstCapacity=%u)"",
+                (int)(blockStream.endPtr - blockStream.startPtr),
+                (unsigned)dstCapacity);
 
     /* first symbols */
     FSE_initCState2(&stateMatchLength, CTable_MatchLength, mlCodeTable[nbSeq-1]);
@@ -2113,6 +2118,7 @@ ZSTD_encodeSequences_body(
                 BIT_addBits(&blockStream, sequences[n].offset, ofBits);     /* 31 */
             }
             BIT_flushBits(&blockStream);                                    /* (7)*/
+            DEBUGLOG(7, ""remaining space : %i"", (int)(blockStream.endPtr - blockStream.ptr));
     }   }
 
     DEBUGLOG(6, ""ZSTD_encodeSequences: flushing ML state with %u bits"", stateMatchLength.stateLog);
@@ -2170,6 +2176,7 @@ static size_t ZSTD_encodeSequences(
             FSE_CTable const* CTable_LitLength, BYTE const* llCodeTable,
             seqDef const* sequences, size_t nbSeq, int longOffsets, int bmi2)
 {
+    DEBUGLOG(5, ""ZSTD_encodeSequences: dstCapacity = %u"", (unsigned)dstCapacity);
 #if DYNAMIC_BMI2
     if (bmi2) {
         return ZSTD_encodeSequences_bmi2(dst, dstCapacity,
@@ -2290,7 +2297,7 @@ ZSTD_compressSequences_internal(seqStore_t* seqStorePtr,
     /* build CTable for MatchLengths */
     {   U32 max = MaxML;
         size_t const mostFrequent = HIST_countFast_wksp(count, &max, mlCodeTable, nbSeq, workspace, wkspSize);   /* can't fail */
-        DEBUGLOG(5, ""Building ML table"");
+        DEBUGLOG(5, ""Building ML table (remaining space : %i)"", (int)(oend-op));
         nextEntropy->fse.matchlength_repeatMode = prevEntropy->fse.matchlength_repeatMode;
         MLtype = ZSTD_selectEncodingType(&nextEntropy->fse.matchlength_repeatMode, count, max, mostFrequent, nbSeq, MLFSELog, prevEntropy->fse.matchlengthCTable, ML_defaultNorm, ML_defaultNormLog, ZSTD_defaultAllowed, strategy);
         assert(!(MLtype < set_compressed && nextEntropy->fse.matchlength_repeatMode != FSE_repeat_none)); /* We don't copy tables */",zstd,3e5cdf1b6a85843e991d7d10f6a2567c15580da0,3a90229616375980896ec0706151d8eef6b7551a,0,"ZSTD_CDict* ZSTD_createCDict_byReference(const void* dict, size_t dictSize, int compressionLevel)
{
    ZSTD_compressionParameters cParams = ZSTD_getCParams(compressionLevel, 0, dictSize);
    return ZSTD_createCDict_advanced(dict, dictSize,
                                     ZSTD_dlm_byRef, ZSTD_dct_auto,
                                     cParams, ZSTD_defaultCMem);
}
"
54738,,Local,Not required,Complete,CVE-2016-2543,https://www.cvedetails.com/cve/CVE-2016-2543/,,Low,,,,2016-04-27,4.9,"The snd_seq_ioctl_remove_events function in sound/core/seq/seq_clientmgr.c in the Linux kernel before 4.4.1 does not verify FIFO assignment before proceeding with FIFO clearing, which allows local users to cause a denial of service (NULL pointer dereference and OOPS) via a crafted ioctl call.",2017-09-06,DoS ,0,https://github.com/torvalds/linux/commit/030e2c78d3a91dd0d27fef37e91950dde333eba1,030e2c78d3a91dd0d27fef37e91950dde333eba1,"ALSA: seq: Fix missing NULL check at remove_events ioctl

snd_seq_ioctl_remove_events() calls snd_seq_fifo_clear()
unconditionally even if there is no FIFO assigned, and this leads to
an Oops due to NULL dereference.  The fix is just to add a proper NULL
check.

Reported-by: Dmitry Vyukov <dvyukov@google.com>
Tested-by: Dmitry Vyukov <dvyukov@google.com>
Cc: <stable@vger.kernel.org>
Signed-off-by: Takashi Iwai <tiwai@suse.de>",0,sound/core/seq/seq_clientmgr.c,"{""sha"": ""13cfa815732db759935f2daaf4c997c73016eb8c"", ""filename"": ""sound/core/seq/seq_clientmgr.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/030e2c78d3a91dd0d27fef37e91950dde333eba1/sound/core/seq/seq_clientmgr.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/030e2c78d3a91dd0d27fef37e91950dde333eba1/sound/core/seq/seq_clientmgr.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/sound/core/seq/seq_clientmgr.c?ref=030e2c78d3a91dd0d27fef37e91950dde333eba1"", ""patch"": ""@@ -1962,7 +1962,7 @@ static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,\n \t\t * No restrictions so for a user client we can clear\n \t\t * the whole fifo\n \t\t */\n-\t\tif (client->type == USER_CLIENT)\n+\t\tif (client->type == USER_CLIENT && client->data.user.fifo)\n \t\t\tsnd_seq_fifo_clear(client->data.user.fifo);\n \t}\n ""}","static int update_timestamp_of_queue(struct snd_seq_event *event,
				     int queue, int real_time)
{
	struct snd_seq_queue *q;

	q = queueptr(queue);
	if (! q)
		return 0;
	event->queue = queue;
	event->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;
	if (real_time) {
		event->time.time = snd_seq_timer_get_cur_time(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_REAL;
	} else {
		event->time.tick = snd_seq_timer_get_cur_tick(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_TICK;
	}
	queuefree(q);
	return 1;
}
","static int update_timestamp_of_queue(struct snd_seq_event *event,
				     int queue, int real_time)
{
	struct snd_seq_queue *q;

	q = queueptr(queue);
	if (! q)
		return 0;
	event->queue = queue;
	event->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;
	if (real_time) {
		event->time.time = snd_seq_timer_get_cur_time(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_REAL;
	} else {
		event->time.tick = snd_seq_timer_get_cur_tick(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_TICK;
	}
	queuefree(q);
	return 1;
}
",C,,,,"@@ -1962,7 +1962,7 @@ static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
-		if (client->type == USER_CLIENT)
+		if (client->type == USER_CLIENT && client->data.user.fifo)
 			snd_seq_fifo_clear(client->data.user.fifo);
 	}
 ",linux,030e2c78d3a91dd0d27fef37e91950dde333eba1,5c06d68bc2a174a6b82dce9f100f55173b9a5189,0,"static int update_timestamp_of_queue(struct snd_seq_event *event,
				     int queue, int real_time)
{
	struct snd_seq_queue *q;

	q = queueptr(queue);
	if (! q)
		return 0;
	event->queue = queue;
	event->flags &= ~SNDRV_SEQ_TIME_STAMP_MASK;
	if (real_time) {
		event->time.time = snd_seq_timer_get_cur_time(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_REAL;
	} else {
		event->time.tick = snd_seq_timer_get_cur_tick(q->timer);
		event->flags |= SNDRV_SEQ_TIME_STAMP_TICK;
	}
	queuefree(q);
	return 1;
}
"
35573,,Local,Not required,Complete,CVE-2014-8481,https://www.cvedetails.com/cve/CVE-2014-8481/,CWE-399,Low,,,,2014-11-10,4.9,"The instruction decoder in arch/x86/kvm/emulate.c in the KVM subsystem in the Linux kernel before 3.18-rc2 does not properly handle invalid instructions, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) via a crafted application that triggers (1) an improperly fetched instruction or (2) an instruction that occupies too many bytes.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2014-8480.",2015-11-20,DoS ,0,https://github.com/torvalds/linux/commit/a430c9166312e1aa3d80bce32374233bdbfeba32,a430c9166312e1aa3d80bce32374233bdbfeba32,"KVM: emulate: avoid accessing NULL ctxt->memopp

A failure to decode the instruction can cause a NULL pointer access.
This is fixed simply by moving the ""done"" label as close as possible
to the return.

This fixes CVE-2014-8481.

Reported-by: Andy Lutomirski <luto@amacapital.net>
Cc: stable@vger.kernel.org
Fixes: 41061cdb98a0bec464278b4db8e894a3121671f5
Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>",0,arch/x86/kvm/emulate.c,"{""sha"": ""eb3b1c46f995d17b242ff5d80d2cdc6d87336d0d"", ""filename"": ""arch/x86/kvm/emulate.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/torvalds/linux/blob/a430c9166312e1aa3d80bce32374233bdbfeba32/arch/x86/kvm/emulate.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/a430c9166312e1aa3d80bce32374233bdbfeba32/arch/x86/kvm/emulate.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/arch/x86/kvm/emulate.c?ref=a430c9166312e1aa3d80bce32374233bdbfeba32"", ""patch"": ""@@ -4580,10 +4580,10 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n \t/* Decode and fetch the destination operand: register or memory. */\n \trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n \n-done:\n \tif (ctxt->rip_relative)\n \t\tctxt->memopp->addr.mem.ea += ctxt->_eip;\n \n+done:\n \treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n }\n ""}","static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)
{
	long sv = 0, mask;

	if (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {
		mask = ~((long)ctxt->dst.bytes * 8 - 1);

		if (ctxt->src.bytes == 2)
			sv = (s16)ctxt->src.val & (s16)mask;
		else if (ctxt->src.bytes == 4)
			sv = (s32)ctxt->src.val & (s32)mask;
		else
			sv = (s64)ctxt->src.val & (s64)mask;

		ctxt->dst.addr.mem.ea += (sv >> 3);
	}

	/* only subword offset */
	ctxt->src.val &= (ctxt->dst.bytes << 3) - 1;
}
","static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)
{
	long sv = 0, mask;

	if (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {
		mask = ~((long)ctxt->dst.bytes * 8 - 1);

		if (ctxt->src.bytes == 2)
			sv = (s16)ctxt->src.val & (s16)mask;
		else if (ctxt->src.bytes == 4)
			sv = (s32)ctxt->src.val & (s32)mask;
		else
			sv = (s64)ctxt->src.val & (s64)mask;

		ctxt->dst.addr.mem.ea += (sv >> 3);
	}

	/* only subword offset */
	ctxt->src.val &= (ctxt->dst.bytes << 3) - 1;
}
",C,,,,"@@ -4580,10 +4580,10 @@ int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)
 	/* Decode and fetch the destination operand: register or memory. */
 	rc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);
 
-done:
 	if (ctxt->rip_relative)
 		ctxt->memopp->addr.mem.ea += ctxt->_eip;
 
+done:
 	return (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;
 }
 ",linux,a430c9166312e1aa3d80bce32374233bdbfeba32,08da44aedba0f493e10695fa334348a7a4f72eb3,0,"static void fetch_bit_operand(struct x86_emulate_ctxt *ctxt)
{
	long sv = 0, mask;

	if (ctxt->dst.type == OP_MEM && ctxt->src.type == OP_REG) {
		mask = ~((long)ctxt->dst.bytes * 8 - 1);

		if (ctxt->src.bytes == 2)
			sv = (s16)ctxt->src.val & (s16)mask;
		else if (ctxt->src.bytes == 4)
			sv = (s32)ctxt->src.val & (s32)mask;
		else
			sv = (s64)ctxt->src.val & (s64)mask;

		ctxt->dst.addr.mem.ea += (sv >> 3);
	}

	/* only subword offset */
	ctxt->src.val &= (ctxt->dst.bytes << 3) - 1;
}
"
187518,,Remote,Not required,Partial,CVE-2016-3839,https://www.cvedetails.com/cve/CVE-2016-3839/,CWE-284,Medium,,,,2016-08-05,4.3,"Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 allows attackers to cause a denial of service (loss of Bluetooth 911 functionality) via a crafted application that sends a signal to a Bluetooth process, aka internal bug 28885210.",2016-11-28,DoS ,1,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c,472271b153c5dc53c28beac55480a8d8434b2d5c,"DO NOT MERGE Fix potential DoS caused by delivering signal to BT process

Bug: 28885210
Change-Id: I63866d894bfca47464d6e42e3fb0357c4f94d360

 Conflicts:
	btif/co/bta_hh_co.c
	btif/src/btif_core.c
Merge conflict resolution of ag/1161415 (referencing ag/1164670)
- Directly into mnc-mr2-release
",1,udrv/ulinux/uipc.c,"{""filename"": ""audio_a2dp_hw/audio_a2dp_hw.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/audio_a2dp_hw/audio_a2dp_hw.c"", ""patch"": ""@@ -244,7 +244,7 @@\n\n \n     ts_log(\""skt_read recv\"", len, NULL);\n \n-    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)\n+    if ((read = TEMP_FAILURE_RETRY(recv(fd, p, len, MSG_NOSIGNAL))) == -1)\n     {\n         ERROR(\""write failed with errno=%d\\n\"", errno);\n         return -1;\n@@ -266,12 +266,12 @@\n\n     /* poll for 500 ms */\n \n     /* send time out */\n-    if (poll(&pfd, 1, 500) == 0)\n+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 500)) == 0)\n         return 0;\n \n     ts_log(\""skt_write\"", len, NULL);\n \n-    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)\n+    if ((sent = TEMP_FAILURE_RETRY(send(fd, p, len, MSG_NOSIGNAL))) == -1)\n     {\n         ERROR(\""write failed with errno=%d\\n\"", errno);\n         return -1;\n@@ -302,14 +302,14 @@\n\n \n static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)\n {\n-    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n+    int ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));\n     if (ret < 0)\n     {\n         ERROR(\""ack failed (%s)\"", strerror(errno));\n         if (errno == EINTR)\n         {\n             /* retry again */\n-            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);\n+            ret = TEMP_FAILURE_RETRY(recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL));\n             if (ret < 0)\n             {\n                ERROR(\""ack failed (%s)\"", strerror(errno));\n@@ -336,7 +336,7 @@\n\n     DEBUG(\""A2DP COMMAND %s\"", dump_a2dp_ctrl_event(cmd));\n \n     /* send command */\n-    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)\n+    if (TEMP_FAILURE_RETRY(send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL)) == -1)\n     {\n         ERROR(\""cmd failed (%s)\"", strerror(errno));\n         skt_disconnect(common->ctrl_fd);\n@@ -409,13 +409,13 @@\n\n                 break;\n \n             ERROR(\""error : a2dp not ready, wait 250 ms and retry\"");\n-            usleep(250000);\n+            TEMP_FAILURE_RETRY(usleep(250000));\n             skt_disconnect(common->ctrl_fd);\n             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;\n         }\n \n         /* ctrl channel not ready, wait a bit */\n-        usleep(250000);\n+        TEMP_FAILURE_RETRY(usleep(250000));\n     }\n }\n \n@@ -578,7 +578,7 @@\n\n \n             DEBUG(\""emulate a2dp write delay (%d us)\"", us_delay);\n \n-            usleep(us_delay);\n+            TEMP_FAILURE_RETRY(usleep(us_delay));\n             pthread_mutex_unlock(&out->common.lock);\n             return -1;\n         }\n@@ -985,7 +985,7 @@\n\n \n             DEBUG(\""emulate a2dp read delay (%d us)\"", us_delay);\n \n-            usleep(us_delay);\n+            TEMP_FAILURE_RETRY(usleep(us_delay));\n             pthread_mutex_unlock(&in->common.lock);\n             return -1;\n         }\n@@ -1114,7 +1114,7 @@\n\n     DEBUG(\""success\"");\n     /* Delay to ensure Headset is in proper state when START is initiated\n        from DUT immediately after the connection due to ongoing music playback. */\n-    usleep(250000);\n+    TEMP_FAILURE_RETRY(usleep(250000));\n     return 0;\n \n err_open:\n""}<_**next**_>{""filename"": ""btif/co/bta_hh_co.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/co/bta_hh_co.c"", ""patch"": ""@@ -58,8 +58,7 @@\n\n /*Internal function to perform UHID write and error checking*/\n static int uhid_write(int fd, const struct uhid_event *ev)\n {\n-    ssize_t ret = write(fd, ev, sizeof(*ev));\n-\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, ev, sizeof(*ev)));\n     if (ret < 0){\n         int rtn = -errno;\n         APPL_TRACE_ERROR(\""%s: Cannot write to uhid:%s\"",\n@@ -85,7 +84,7 @@\n\n         APPL_TRACE_ERROR(\""%s: Device not found\"",__FUNCTION__)\n         return -1;\n     }\n-    ret = read(p_dev->fd, &ev, sizeof(ev));\n+    ret = TEMP_FAILURE_RETRY(read(p_dev->fd, &ev, sizeof(ev)));\n     if (ret == 0) {\n         APPL_TRACE_ERROR(\""%s: Read HUP on uhid-cdev %s\"", __FUNCTION__,\n                                                  strerror(errno));\n@@ -206,7 +205,7 @@\n\n     uhid_set_non_blocking(p_dev->fd);\n \n     while(p_dev->hh_keep_polling){\n-        ret = poll(pfds, 1, 50);\n+        ret = TEMP_FAILURE_RETRY(poll(pfds, 1, 50));\n         if (ret < 0) {\n             APPL_TRACE_ERROR(\""%s: Cannot poll for fds: %s\\n\"", __FUNCTION__, strerror(errno));\n             break;\n@@ -300,7 +299,7 @@\n\n                                   __FUNCTION__, p_dev->attr_mask, p_dev->sub_class, p_dev->app_id);\n \n             if(p_dev->fd<0) {\n-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\""%s: Error: failed to open uhid, err:%s\"",\n                                                                     __FUNCTION__,strerror(errno));\n@@ -329,7 +328,7 @@\n\n \n                 btif_hh_cb.device_num++;\n                 // This is a new device,open the uhid driver now.\n-                p_dev->fd = open(dev_path, O_RDWR | O_CLOEXEC);\n+                p_dev->fd = TEMP_FAILURE_RETRY(open(dev_path, O_RDWR | O_CLOEXEC));\n                 if (p_dev->fd < 0){\n                     APPL_TRACE_ERROR(\""%s: Error: failed to open uhid, err:%s\"",\n                                                                     __FUNCTION__,strerror(errno));\n""}<_**next**_>{""filename"": ""btif/co/bta_hl_co.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/co/bta_hl_co.c"", ""patch"": ""@@ -34,6 +34,7 @@\n\n #include <fcntl.h>\n #include <ctype.h>\n #include <cutils/sockets.h>\n+#include <unistd.h>\n #include \""bta_api.h\""\n #include \""btm_api.h\""\n #include \""bta_sys.h\""\n@@ -384,7 +385,7 @@\n\n             {\n                 BTIF_TRACE_DEBUG(\""app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d\"",\n                                   app_idx, mcl_idx, mdl_idx, data_size);\n-                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);\n+                r = TEMP_FAILURE_RETRY(send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0));\n \n                 if (r == data_size)\n                 {\n""}<_**next**_>{""filename"": ""btif/src/btif_core.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_core.c"", ""patch"": ""@@ -29,6 +29,7 @@\n\n #include <ctype.h>\n #include <cutils/properties.h>\n #include <dirent.h>\n+#include <errno.h>\n #include <fcntl.h>\n #include <hardware/bluetooth.h>\n #include <stdlib.h>\n@@ -344,10 +345,10 @@\n\n \n         BTIF_TRACE_DEBUG(\""%s, local bdaddr is stored in %s\"", __func__, val);\n \n-        if ((addr_fd = open(val, O_RDONLY)) != -1)\n+        if ((addr_fd = TEMP_FAILURE_RETRY(open(val, O_RDONLY))) != -1)\n         {\n             memset(val, 0, sizeof(val));\n-            read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN);\n+            TEMP_FAILURE_RETRY(read(addr_fd, val, FACTORY_BT_BDADDR_STORAGE_LEN));\n             /* If this is not a reserved/special bda, then use it */\n             if ((string_to_bdaddr(val, local_addr)) &&\n                 (memcmp(local_addr->address, null_bdaddr, BD_ADDR_LEN) != 0))\n""}<_**next**_>{""filename"": ""btif/src/btif_dm.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_dm.c"", ""patch"": ""@@ -28,6 +28,7 @@\n\n #define LOG_TAG \""bt_btif_dm\""\n \n #include <assert.h>\n+#include <errno.h>\n #include <signal.h>\n #include <stdio.h>\n #include <stdlib.h>\n@@ -1782,7 +1783,7 @@\n\n             BTIF_TRACE_ERROR(\""Received H/W Error. \"");\n             /* Flush storage data */\n             btif_config_flush();\n-            usleep(100000); /* 100milliseconds */\n+            TEMP_FAILURE_RETRY(usleep(100000)); /* 100milliseconds */\n             /* Killing the process to force a restart as part of fault tolerance */\n             kill(getpid(), SIGKILL);\n             break;\n""}<_**next**_>{""filename"": ""btif/src/btif_hh.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_hh.c"", ""patch"": ""@@ -234,7 +234,7 @@\n\n     BTIF_TRACE_DEBUG(\""%s:  %x %x %x\"", __FUNCTION__,\n          hidreport[6], hidreport[7], hidreport[8]);\n     bta_hh_co_write(fd , hidreport, sizeof(hidreport));\n-    usleep(200000);\n+    TEMP_FAILURE_RETRY(usleep(200000));\n     memset(hidreport,0,9);\n     hidreport[0]=1;\n     BTIF_TRACE_DEBUG(\""Writing hidreport #2 to os: \""\\\n@@ -329,7 +329,7 @@\n\n         BTIF_TRACE_DEBUG(\""%s: Sending hid report to kernel \""\\\n             \""indicating lock key state 0x%x\"",__FUNCTION__,\n             keylockstates);\n-        usleep(200000);\n+        TEMP_FAILURE_RETRY(usleep(200000));\n         toggle_os_keylockstates(p_dev->fd, keylockstates);\n     }\n     else\n""}<_**next**_>{""filename"": ""btif/src/btif_hl.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_hl.c"", ""patch"": ""@@ -4795,8 +4795,8 @@\n\n                 }\n                 p_dcb->p_tx_pkt = btif_hl_get_buf (p_dcb->mtu);\n                 if (p_dcb) {\n-                    int r = (int)recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,\n-                            p_dcb->mtu, MSG_DONTWAIT);\n+                    int r = (int)TEMP_FAILURE_RETRY(recv(p_scb->socket_id[1], p_dcb->p_tx_pkt,\n+                            p_dcb->mtu, MSG_DONTWAIT));\n                     if (r > 0) {\n                         BTIF_TRACE_DEBUG(\""btif_hl_select_monitor_callback send data r =%d\"", r);\n                         p_dcb->tx_size = r;\n@@ -4852,7 +4852,7 @@\n\n static inline int btif_hl_select_wakeup(void){\n     char sig_on = btif_hl_signal_select_wakeup;\n     BTIF_TRACE_DEBUG(\""btif_hl_select_wakeup\"");\n-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n /*******************************************************************************\n@@ -4867,7 +4867,7 @@\n\n static inline int btif_hl_select_close_connected(void){\n     char sig_on = btif_hl_signal_select_close_connected;\n     BTIF_TRACE_DEBUG(\""btif_hl_select_close_connected\"");\n-    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    return TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n /*******************************************************************************\n@@ -4884,7 +4884,7 @@\n\n     int result = 0;\n     char sig_on = btif_hl_signal_select_exit;\n     BTIF_TRACE_DEBUG(\""btif_hl_signal_select_exit\"");\n-    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    result = TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), 0));\n     if (btif_is_enabled())\n     {\n         /* Wait for the select_thread_id to exit if BT is still enabled\n@@ -4911,7 +4911,7 @@\n\n     char sig_recv = 0;\n \n     BTIF_TRACE_DEBUG(\""btif_hl_select_wake_reset\"");\n-    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n+    TEMP_FAILURE_RETRY(recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));\n     return(int)sig_recv;\n }\n /*******************************************************************************\n@@ -4972,7 +4972,7 @@\n\n         BTIF_TRACE_DEBUG(\""set curr_set = org_set \"");\n         curr_set = org_set;\n         max_curr_s = max_org_s;\n-        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);\n+        int ret = TEMP_FAILURE_RETRY(select((max_curr_s + 1), &curr_set, NULL, NULL, NULL));\n         BTIF_TRACE_DEBUG(\""select unblocked ret=%d\"", ret);\n         if (ret == -1)\n         {\n""}<_**next**_>{""filename"": ""btif/src/btif_pan.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_pan.c"", ""patch"": ""@@ -312,7 +312,7 @@\n\n     //set mac addr\n     memset(&ifr, 0, sizeof(ifr));\n     strncpy(ifr.ifr_name, devname, IFNAMSIZ - 1);\n-    err = ioctl(sk, SIOCGIFHWADDR, &ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCGIFHWADDR, &ifr));\n     if (err < 0)\n     {\n         BTIF_TRACE_ERROR(\""Could not get network hardware for interface:%s, errno:%s\"", devname, strerror(errno));\n@@ -333,7 +333,7 @@\n\n         ifr.ifr_hwaddr.sa_data[0] &= ~0x01;\n     }\n \n-    err = ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFHWADDR, (caddr_t)&ifr));\n \n     if (err < 0) {\n         BTIF_TRACE_ERROR(\""Could not set bt address for interface:%s, errno:%s\"", devname, strerror(errno));\n@@ -348,7 +348,7 @@\n\n     ifr.ifr_flags |= IFF_UP;\n     ifr.ifr_flags |= IFF_MULTICAST;\n \n-    err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n+    err = TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));\n \n \n     if (err < 0) {\n@@ -375,7 +375,7 @@\n\n \n     ifr.ifr_flags &= ~IFF_UP;\n \n-    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n+    TEMP_FAILURE_RETRY(ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr));\n \n     close(sk);\n \n@@ -401,7 +401,7 @@\n\n \n     /* open the clone device */\n \n-    if ((fd = open(clonedev, O_RDWR)) < 0)\n+    if ((fd = TEMP_FAILURE_RETRY(open(clonedev, O_RDWR))) < 0)\n     {\n         BTIF_TRACE_DEBUG(\""could not open %s, err:%d\"", clonedev, errno);\n         return fd;\n@@ -413,7 +413,7 @@\n\n     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);\n \n     /* try to create the device */\n-    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)\n+    if ((err = TEMP_FAILURE_RETRY(ioctl(fd, TUNSETIFF, (void *) &ifr))) < 0)\n     {\n         BTIF_TRACE_DEBUG(\""ioctl error:%d, errno:%s\"", err, strerror(errno));\n         close(fd);\n@@ -421,8 +421,8 @@\n\n     }\n     if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)\n     {\n-        int flags = fcntl(fd, F_GETFL, 0);\n-        fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n+        int flags = TEMP_FAILURE_RETRY(fcntl(fd, F_GETFL, 0));\n+        TEMP_FAILURE_RETRY(fcntl(fd, F_SETFL, flags | O_NONBLOCK));\n         return fd;\n     }\n     BTIF_TRACE_ERROR(\""can not bring up tap interface:%s\"", TAP_IF_NAME);\n@@ -451,7 +451,7 @@\n\n         memcpy(packet + sizeof(tETH_HDR), buf, len);\n \n         /* Send data to network interface */\n-        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));\n+        int ret = TEMP_FAILURE_RETRY(write(tap_fd, packet, len + sizeof(tETH_HDR)));\n         BTIF_TRACE_DEBUG(\""ret:%d\"", ret);\n         return ret;\n     }\n@@ -740,7 +740,7 @@\n\n         // We save it in the congest_packet right away in case we can't deliver it in this\n         // attempt.\n         if (!btpan_cb.congest_packet_size) {\n-            ssize_t ret = read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet));\n+            ssize_t ret = TEMP_FAILURE_RETRY(read(fd, btpan_cb.congest_packet, sizeof(btpan_cb.congest_packet)));\n             switch (ret) {\n                 case -1:\n                     BTIF_TRACE_ERROR(\""%s unable to read from driver: %s\"", __func__, strerror(errno));\n@@ -784,7 +784,7 @@\n\n         ufd.fd = fd;\n         ufd.events = POLLIN;\n         ufd.revents = 0;\n-        if (poll(&ufd, 1, 0) <= 0 || IS_EXCEPTION(ufd.revents))\n+        if (TEMP_FAILURE_RETRY(poll(&ufd, 1, 0)) <= 0 || IS_EXCEPTION(ufd.revents))\n             break;\n     }\n     //add fd back to monitor thread\n""}<_**next**_>{""filename"": ""btif/src/btif_rc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_rc.c"", ""patch"": ""@@ -24,6 +24,7 @@\n\n  *  Description:   Bluetooth AVRC implementation\n  *\n  *****************************************************************************/\n+#include <errno.h>\n #include <hardware/bluetooth.h>\n #include <fcntl.h>\n #include <string.h>\n@@ -213,7 +214,7 @@\n\n     event.code  = code;\n     event.value = value;\n \n-    return write(fd, &event, sizeof(event));\n+    return TEMP_FAILURE_RETRY(write(fd, &event, sizeof(event)));\n }\n \n void send_key (int fd, uint16_t key, int pressed)\n@@ -252,7 +253,7 @@\n\n \n     for(x=0; x < MAX_UINPUT_PATHS; x++)\n     {\n-        fd = open(uinput_dev_path[x], O_RDWR);\n+        fd = TEMP_FAILURE_RETRY(open(uinput_dev_path[x], O_RDWR));\n         if (fd < 0)\n             continue;\n         break;\n@@ -270,20 +271,20 @@\n\n     dev.id.product = 0x0000;\n     dev.id.version = 0x0000;\n \n-    if (write(fd, &dev, sizeof(dev)) < 0) {\n+    if (TEMP_FAILURE_RETRY(write(fd, &dev, sizeof(dev))) < 0) {\n         BTIF_TRACE_ERROR(\""%s Unable to write device information\"", __FUNCTION__);\n         close(fd);\n         return -1;\n     }\n \n-    ioctl(fd, UI_SET_EVBIT, EV_KEY);\n-    ioctl(fd, UI_SET_EVBIT, EV_REL);\n-    ioctl(fd, UI_SET_EVBIT, EV_SYN);\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_KEY));\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_REL));\n+    TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_EVBIT, EV_SYN));\n \n     for (x = 0; key_map[x].name != NULL; x++)\n-        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);\n+        TEMP_FAILURE_RETRY(ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id));\n \n-    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n+    if (TEMP_FAILURE_RETRY(ioctl(fd, UI_DEV_CREATE, NULL)) < 0) {\n         BTIF_TRACE_ERROR(\""%s Unable to create uinput device\"", __FUNCTION__);\n         close(fd);\n         return -1;\n@@ -311,7 +312,7 @@\n\n {\n     BTIF_TRACE_DEBUG(\""%s\"", __FUNCTION__);\n     if (uinput_fd > 0) {\n-        ioctl(uinput_fd, UI_DEV_DESTROY);\n+        TEMP_FAILURE_RETRY(ioctl(uinput_fd, UI_DEV_DESTROY));\n \n         close(uinput_fd);\n         uinput_fd = -1;\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_l2cap.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_l2cap.c"", ""patch"": ""@@ -968,7 +968,7 @@\n\n     uint32_t len;\n \n     while (packet_get_head_l(sock, &buf, &len)) {\n-        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);\n+        int sent = TEMP_FAILURE_RETRY(send(sock->our_fd, buf, len, MSG_DONTWAIT));\n \n         if (sent == (signed)len)\n             osi_free(buf);\n@@ -1002,7 +1002,7 @@\n\n             if (sock->connected) {\n                 int size = 0;\n \n-                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(sock->our_fd, FIONREAD, &size)\n+                if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size))\n                         == 0 && size)) {\n                     uint8_t *buffer = osi_malloc(L2CAP_MAX_SDU_LENGTH);\n                     //uint8_t *buffer = (uint8_t*)GKI_getbuf(L2CAP_MAX_SDU_LENGTH);\n@@ -1028,8 +1028,8 @@\n\n                          * UPDATE: Since we are responsible for freeing the buffer in the\n                          * write_complete_ind, it is OK to use malloc. */\n \n-                        int count = recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,\n-                                MSG_NOSIGNAL | MSG_DONTWAIT);\n+                        int count = TEMP_FAILURE_RETRY(recv(fd, buffer, L2CAP_MAX_SDU_LENGTH,\n+                                MSG_NOSIGNAL | MSG_DONTWAIT));\n                         APPL_TRACE_DEBUG(\""btsock_l2cap_signaled - %d bytes received from socket\"",\n                                 count);\n                         if (sock->fixed_chan) {\n@@ -1061,7 +1061,7 @@\n\n         }\n         if (drop_it || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n             int size = 0;\n-            if (drop_it || ioctl(sock->our_fd, FIONREAD, &size) != 0 || size == 0)\n+            if (drop_it || TEMP_FAILURE_RETRY(ioctl(sock->our_fd, FIONREAD, &size)) != 0 || size == 0)\n                 btsock_l2cap_free_l(sock);\n         }\n     }\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_rfc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_rfc.c"", ""patch"": ""@@ -720,7 +720,7 @@\n\n   if (p_buf->len == 0)\n     return SENT_ALL;\n \n-  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);\n+  ssize_t sent = TEMP_FAILURE_RETRY(send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT));\n \n   if (sent == -1) {\n     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n@@ -783,11 +783,9 @@\n\n     if (slot->f.connected) {\n       // Make sure there's data pending in case the peer closed the socket.\n       int size = 0;\n-      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))\n-        //unlock before BTA_JvRfcommWrite to avoid deadlock on concurrnet multi rfcomm connectoins\n-        //concurrnet multi rfcomm connectoins\n-        pthread_mutex_unlock(&slot_lock);\n+      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) == 0 && size)) {\n         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);\n+      }\n     } else {\n       LOG_ERROR(\""%s socket signaled for read while disconnected, slot: %d, channel: %d\"", __func__, slot->id, slot->scn);\n       need_close = true;\n@@ -805,7 +803,7 @@\n\n   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {\n     // Clean up if there's no data pending.\n     int size = 0;\n-    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)\n+    if (need_close || TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, &size)) != 0 || !size)\n       cleanup_rfc_slot(slot);\n   }\n \n@@ -859,7 +857,7 @@\n\n   if (!slot)\n     goto out;\n \n-  if (ioctl(slot->fd, FIONREAD, size) == 0) {\n+  if (TEMP_FAILURE_RETRY(ioctl(slot->fd, FIONREAD, size)) == 0) {\n     ret = true;\n   } else {\n     LOG_ERROR(\""%s unable to determine bytes remaining to be read on fd %d: %s\"", __func__, slot->fd, strerror(errno));\n@@ -880,7 +878,7 @@\n\n   if (!slot)\n     goto out;\n \n-  int received = recv(slot->fd, buf, size, 0);\n+  int received = TEMP_FAILURE_RETRY(recv(slot->fd, buf, size, 0));\n   if(received == size) {\n     ret = true;\n   } else {\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_thread.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_thread.c"", ""patch"": ""@@ -114,12 +114,12 @@\n\n static inline void set_socket_blocking(int s, int blocking)\n {\n     int opts;\n-    opts = fcntl(s, F_GETFL);\n+    opts = TEMP_FAILURE_RETRY(fcntl(s, F_GETFL));\n     if (opts<0) APPL_TRACE_ERROR(\""set blocking (%s)\"", strerror(errno));\n     if(blocking)\n         opts &= ~O_NONBLOCK;\n     else opts |= O_NONBLOCK;\n-    if (fcntl(s, F_SETFL, opts) < 0)\n+    if (TEMP_FAILURE_RETRY(fcntl(s, F_SETFL, opts)) < 0)\n         APPL_TRACE_ERROR(\""set blocking (%s)\"", strerror(errno));\n }\n \n@@ -161,7 +161,7 @@\n\n {\n     struct sockaddr_un client_address;\n     socklen_t clen;\n-    int fd = accept(s, (struct sockaddr*)&client_address, &clen);\n+    int fd = TEMP_FAILURE_RETRY(accept(s, (struct sockaddr*)&client_address, &clen));\n     APPL_TRACE_DEBUG(\""accepted fd:%d for server fd:%d\"", fd, s);\n     return fd;\n }\n@@ -325,7 +325,7 @@\n\n     }\n     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};\n     APPL_TRACE_DEBUG(\""adding fd:%d, flags:0x%x\"", fd, flags);\n-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n \n bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)\n@@ -342,7 +342,7 @@\n\n     }\n \n     sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};\n-    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n \n int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)\n@@ -376,7 +376,7 @@\n\n             return FALSE;\n         }\n     }\n-    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, cmd_send, size_send, 0)) == size_send;\n }\n int btsock_thread_wakeup(int h)\n {\n@@ -391,7 +391,7 @@\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};\n-    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);\n+    return TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd);\n }\n int btsock_thread_exit(int h)\n {\n@@ -406,7 +406,7 @@\n\n         return FALSE;\n     }\n     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};\n-    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))\n+    if(TEMP_FAILURE_RETRY(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0)) == sizeof(cmd))\n     {\n         pthread_join(ts[h].thread_id, 0);\n         pthread_mutex_lock(&thread_slot_lock);\n@@ -501,7 +501,7 @@\n\n {\n     sock_cmd_t cmd = {-1, 0, 0, 0, 0};\n     int fd = ts[h].cmd_fdr;\n-    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))\n+    if(TEMP_FAILURE_RETRY(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL)) != sizeof(cmd))\n     {\n         APPL_TRACE_ERROR(\""recv cmd errno:%d\"", errno);\n         return FALSE;\n@@ -608,7 +608,7 @@\n\n     for(;;)\n     {\n         prepare_poll_fds(h, pfds);\n-        int ret = poll(pfds, ts[h].poll_count, -1);\n+        int ret = TEMP_FAILURE_RETRY(poll(pfds, ts[h].poll_count, -1));\n         if(ret == -1)\n         {\n             APPL_TRACE_ERROR(\""poll ret -1, exit the thread, errno:%d, err:%s\"", errno, strerror(errno));\n""}<_**next**_>{""filename"": ""btif/src/btif_sock_util.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/btif/src/btif_sock_util.c"", ""patch"": ""@@ -74,7 +74,7 @@\n\n     int ret;\n     while(s)\n     {\n-        do ret = send(sock_fd, buf, s, 0);\n+        do ret = TEMP_FAILURE_RETRY(send(sock_fd, buf, s, 0));\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n@@ -92,7 +92,7 @@\n\n     int ret = -1;\n     while(r)\n     {\n-        do ret = recv(sock_fd, buf, r, MSG_WAITALL);\n+        do ret = TEMP_FAILURE_RETRY(recv(sock_fd, buf, r, MSG_WAITALL));\n         while(ret < 0 && errno == EINTR);\n         if(ret <= 0)\n         {\n@@ -140,7 +140,7 @@\n\n         msg.msg_iovlen = 1;\n \n         do {\n-            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);\n+            ret = TEMP_FAILURE_RETRY(sendmsg(sock_fd, &msg, MSG_NOSIGNAL));\n         } while (ret < 0 && errno == EINTR);\n \n         if (ret < 0) {\n""}<_**next**_>{""filename"": ""gki/ulinux/gki_ulinux.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/gki/ulinux/gki_ulinux.c"", ""patch"": ""@@ -76,7 +76,7 @@\n\n \n   int err;\n   do {\n-    err = nanosleep(&delay, &delay);\n+    err = TEMP_FAILURE_RETRY(nanosleep(&delay, &delay));\n   } while (err == -1 && errno == EINTR);\n }\n \n""}<_**next**_>{""filename"": ""hci/src/btsnoop.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/btsnoop.c"", ""patch"": ""@@ -169,14 +169,14 @@\n\n         LOG_ERROR(\""%s unable to rename '%s' to '%s': %s\"", __func__, log_path, last_log_path, strerror(errno));\n     }\n \n-    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);\n+    logfile_fd = TEMP_FAILURE_RETRY(open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH));\n     if (logfile_fd == INVALID_FD) {\n       LOG_ERROR(\""%s unable to open '%s': %s\"", __func__, log_path, strerror(errno));\n       is_logging = false;\n       return;\n     }\n \n-    write(logfile_fd, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16);\n+    TEMP_FAILURE_RETRY(write(logfile_fd, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16));\n   } else {\n     if (logfile_fd != INVALID_FD)\n       close(logfile_fd);\n@@ -188,7 +188,7 @@\n\n \n static void btsnoop_write(const void *data, size_t length) {\n   if (logfile_fd != INVALID_FD)\n-    write(logfile_fd, data, length);\n+    TEMP_FAILURE_RETRY(write(logfile_fd, data, length));\n \n   btsnoop_net_write(data, length);\n }\n""}<_**next**_>{""filename"": ""hci/src/btsnoop_net.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/btsnoop_net.c"", ""patch"": ""@@ -77,7 +77,7 @@\n\n \n   pthread_mutex_lock(&client_socket_lock_);\n   if (client_socket_ != -1) {\n-    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {\n+    if (TEMP_FAILURE_RETRY(send(client_socket_, data, length, 0)) == -1 && errno == ECONNRESET) {\n       safe_close_(&client_socket_);\n     }\n   }\n@@ -115,7 +115,7 @@\n\n   }\n \n   for (;;) {\n-    int client_socket = accept(listen_socket_, NULL, NULL);\n+    int client_socket = TEMP_FAILURE_RETRY(accept(listen_socket_, NULL, NULL));\n     if (client_socket == -1) {\n       if (errno == EINVAL || errno == EBADF) {\n         break;\n@@ -129,7 +129,7 @@\n\n     pthread_mutex_lock(&client_socket_lock_);\n     safe_close_(&client_socket_);\n     client_socket_ = client_socket;\n-    send(client_socket_, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16, 0);\n+    TEMP_FAILURE_RETRY(send(client_socket_, \""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea\"", 16, 0));\n     pthread_mutex_unlock(&client_socket_lock_);\n   }\n \n""}<_**next**_>{""filename"": ""hci/src/hci_hal_h4.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_hal_h4.c"", ""patch"": ""@@ -153,7 +153,7 @@\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n-    ssize_t ret = write(uart_fd, data + transmitted_length, length);\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(uart_fd, data + transmitted_length, length));\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\""In %s, error writing to the uart serial port: %s\"", __func__, strerror(errno));\n""}<_**next**_>{""filename"": ""hci/src/hci_hal_mct.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_hal_mct.c"", ""patch"": ""@@ -159,7 +159,7 @@\n\n \n   uint16_t transmitted_length = 0;\n   while (length > 0) {\n-    ssize_t ret = write(fd, data + transmitted_length, length);\n+    ssize_t ret = TEMP_FAILURE_RETRY(write(fd, data + transmitted_length, length));\n     switch (ret) {\n       case -1:\n         LOG_ERROR(\""In %s, error writing to the serial port with fd %d: %s\"", __func__, fd, strerror(errno));\n""}<_**next**_>{""filename"": ""hci/src/hci_layer.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/src/hci_layer.c"", ""patch"": ""@@ -20,6 +20,7 @@\n\n \n #include <assert.h>\n #include <cutils/properties.h>\n+#include <errno.h>\n #include <string.h>\n #include <signal.h>\n #include <string.h>\n@@ -517,7 +518,7 @@\n\n   }\n \n   LOG_ERROR(\""%s restarting the bluetooth process.\"", __func__);\n-  usleep(10000);\n+  TEMP_FAILURE_RETRY(usleep(10000));\n   kill(getpid(), SIGKILL);\n }\n \n""}<_**next**_>{""filename"": ""hci/test/hci_hal_h4_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/test/hci_hal_h4_test.cpp"", ""patch"": ""@@ -183,26 +183,26 @@\n\n     fd_set read_fds;\n     FD_ZERO(&read_fds);\n     FD_SET(fd, &read_fds);\n-    select(fd + 1, &read_fds, NULL, NULL, NULL);\n+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));\n \n     char byte;\n-    read(fd, &byte, 1);\n+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));\n \n     EXPECT_EQ(i == 0 ? first_byte : data[i - 1], byte);\n   }\n }\n \n static void write_packet(int fd, char first_byte, char *data) {\n-  write(fd, &first_byte, 1);\n-  write(fd, data, strlen(data));\n+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));\n+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));\n }\n \n static void write_packet_reentry(int fd, char first_byte, char *data) {\n-  write(fd, &first_byte, 1);\n+  TEMP_FAILURE_RETRY(write(fd, &first_byte, 1));\n \n   int length = strlen(data);\n   for (int i = 0; i < length; i++) {\n-    write(fd, &data[i], 1);\n+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));\n     semaphore_wait(reentry_semaphore);\n   }\n }\n@@ -252,7 +252,7 @@\n\n   reset_for(type_byte_only);\n \n   char byte = DATA_TYPE_ACL;\n-  write(sockfd[1], &byte, 1);\n+  TEMP_FAILURE_RETRY(write(sockfd[1], &byte, 1));\n \n   fd_set read_fds;\n \n@@ -265,6 +265,6 @@\n\n     timeout.tv_sec = 0;\n     timeout.tv_usec = 0;\n \n-    select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout);\n+    TEMP_FAILURE_RETRY(select(sockfd[0] + 1, &read_fds, NULL, NULL, &timeout));\n   } while(FD_ISSET(sockfd[0], &read_fds));\n }\n""}<_**next**_>{""filename"": ""hci/test/hci_hal_mct_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/hci/test/hci_hal_mct_test.cpp"", ""patch"": ""@@ -186,23 +186,23 @@\n\n     fd_set read_fds;\n     FD_ZERO(&read_fds);\n     FD_SET(fd, &read_fds);\n-    select(fd + 1, &read_fds, NULL, NULL, NULL);\n+    TEMP_FAILURE_RETRY(select(fd + 1, &read_fds, NULL, NULL, NULL));\n \n     char byte;\n-    read(fd, &byte, 1);\n+    TEMP_FAILURE_RETRY(read(fd, &byte, 1));\n \n     EXPECT_EQ(data[i], byte);\n   }\n }\n \n static void write_packet(int fd, char *data) {\n-  write(fd, data, strlen(data));\n+  TEMP_FAILURE_RETRY(write(fd, data, strlen(data)));\n }\n \n static void write_packet_reentry(int fd, char *data) {\n   int length = strlen(data);\n   for (int i = 0; i < length; i++) {\n-    write(fd, &data[i], 1);\n+    TEMP_FAILURE_RETRY(write(fd, &data[i], 1));\n     semaphore_wait(reentry_semaphore);\n   }\n }\n""}<_**next**_>{""filename"": ""osi/src/config.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/config.c"", ""patch"": ""@@ -21,10 +21,13 @@\n\n #include <assert.h>\n #include <ctype.h>\n #include <errno.h>\n+#include <fcntl.h>\n+#include <libgen.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n #include <sys/stat.h>\n+#include <sys/types.h>\n \n #include \""osi/include/allocator.h\""\n #include \""osi/include/config.h\""\n@@ -275,16 +278,39 @@\n\n   assert(filename != NULL);\n   assert(*filename != '\\0');\n \n-  char *temp_filename = osi_calloc(strlen(filename) + 5);\n-  if (!temp_filename) {\n-    LOG_ERROR(\""%s unable to allocate memory for filename.\"", __func__);\n-    return false;\n+  // Steps to ensure content of config file gets to disk:\n+  //\n+  // 1) Open and write to temp file (e.g. bt_config.conf.new).\n+  // 2) Sync the temp file to disk with fsync().\n+  // 3) Rename temp file to actual config file (e.g. bt_config.conf).\n+  //    This ensures atomic update.\n+  // 4) Sync directory that has the conf file with fsync().\n+  //    This ensures directory entries are up-to-date.\n+  int dir_fd = -1;\n+  FILE *fp = NULL;\n+\n+  // Build temp config file based on config file (e.g. bt_config.conf.new).\n+  static const char *temp_file_ext = \"".new\"";\n+  const int filename_len = strlen(filename);\n+  const int temp_filename_len = filename_len + strlen(temp_file_ext) + 1;\n+  char *temp_filename = osi_calloc(temp_filename_len);\n+  snprintf(temp_filename, temp_filename_len, \""%s%s\"", filename, temp_file_ext);\n+\n+  // Extract directory from file path (e.g. /data/misc/bluedroid).\n+  char *temp_dirname = osi_strdup(filename);\n+  const char *directoryname = dirname(temp_dirname);\n+  if (!directoryname) {\n+    LOG_ERROR(\""%s error extracting directory from '%s': %s\"", __func__, filename, strerror(errno));\n+    goto error;\n   }\n \n-  strcpy(temp_filename, filename);\n-  strcat(temp_filename, \"".new\"");\n+  dir_fd = TEMP_FAILURE_RETRY(open(directoryname, O_RDONLY));\n+  if (dir_fd < 0) {\n+    LOG_ERROR(\""%s unable to open dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+    goto error;\n+  }\n \n-  FILE *fp = fopen(temp_filename, \""wt\"");\n+  fp = fopen(temp_filename, \""wt\"");\n   if (!fp) {\n     LOG_ERROR(\""%s unable to write file '%s': %s\"", __func__, temp_filename, strerror(errno));\n     goto error;\n@@ -292,20 +318,38 @@\n\n \n   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {\n     const section_t *section = (const section_t *)list_node(node);\n-    fprintf(fp, \""[%s]\\n\"", section->name);\n+    if (fprintf(fp, \""[%s]\\n\"", section->name) < 0) {\n+      LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+      goto error;\n+    }\n \n     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {\n       const entry_t *entry = (const entry_t *)list_node(enode);\n-      fprintf(fp, \""%s = %s\\n\"", entry->key, entry->value);\n+      if (fprintf(fp, \""%s = %s\\n\"", entry->key, entry->value) < 0) {\n+        LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+        goto error;\n+      }\n     }\n \n     // Only add a separating newline if there are more sections.\n-    if (list_next(node) != list_end(config->sections))\n-      fputc('\\n', fp);\n+    if (list_next(node) != list_end(config->sections)) {\n+      if (fputc('\\n', fp) == EOF) {\n+        LOG_ERROR(\""%s unable to write to file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+        goto error;\n+      }\n+    }\n   }\n \n-  fflush(fp);\n-  fclose(fp);\n+  // Sync written temp file out to disk. fsync() is blocking until data makes it to disk.\n+  if (fsync(fileno(fp)) < 0) {\n+    LOG_WARN(\""%s unable to fsync file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+  }\n+\n+  if (fclose(fp) == EOF) {\n+    LOG_ERROR(\""%s unable to close file '%s': %s\"", __func__, temp_filename, strerror(errno));\n+    goto error;\n+  }\n+  fp = NULL;\n \n   // Change the file's permissions to Read/Write by User and Group\n   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {\n@@ -313,17 +357,35 @@\n\n     goto error;\n   }\n \n+  // Rename written temp file to the actual config file.\n   if (rename(temp_filename, filename) == -1) {\n     LOG_ERROR(\""%s unable to commit file '%s': %s\"", __func__, filename, strerror(errno));\n     goto error;\n   }\n \n+  // This should ensure the directory is updated as well.\n+  if (fsync(dir_fd) < 0) {\n+    LOG_WARN(\""%s unable to fsync dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+  }\n+\n+  if (close(dir_fd) < 0) {\n+    LOG_ERROR(\""%s unable to close dir '%s': %s\"", __func__, directoryname, strerror(errno));\n+    goto error;\n+  }\n+\n   osi_free(temp_filename);\n+  osi_free(temp_dirname);\n   return true;\n \n-error:;\n+error:\n+  // This indicates there is a write issue.  Unlink as partial data is not acceptable.\n   unlink(temp_filename);\n+  if (fp)\n+    fclose(fp);\n+  if (dir_fd != -1)\n+    close(dir_fd);\n   osi_free(temp_filename);\n+  osi_free(temp_dirname);\n   return false;\n }\n \n""}<_**next**_>{""filename"": ""osi/src/eager_reader.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/eager_reader.c"", ""patch"": ""@@ -228,7 +228,7 @@\n\n   timeout.tv_sec = 0;\n   timeout.tv_usec = 0;\n \n-  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);\n+  TEMP_FAILURE_RETRY(select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout));\n   return FD_ISSET(reader->bytes_available_fd, &read_fds);\n }\n \n@@ -244,7 +244,7 @@\n\n   buffer->length = 0;\n   buffer->offset = 0;\n \n-  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);\n+  int bytes_read = TEMP_FAILURE_RETRY(read(reader->inbound_fd, buffer->data, reader->buffer_size));\n   if (bytes_read > 0) {\n     // Save the data for later\n     buffer->length = bytes_read;\n""}<_**next**_>{""filename"": ""osi/src/reactor.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/reactor.c"", ""patch"": ""@@ -241,7 +241,7 @@\n\n \n     int ret;\n     do {\n-      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);\n+      ret = TEMP_FAILURE_RETRY(epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1));\n     } while (ret == -1 && errno == EINTR);\n \n     if (ret == -1) {\n""}<_**next**_>{""filename"": ""osi/src/semaphore.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/semaphore.c"", ""patch"": ""@@ -73,12 +73,12 @@\n\n   assert(semaphore != NULL);\n   assert(semaphore->fd != INVALID_FD);\n \n-  int flags = fcntl(semaphore->fd, F_GETFL);\n+  int flags = TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_GETFL));\n   if (flags == -1) {\n     LOG_ERROR(\""%s unable to get flags for semaphore fd: %s\"", __func__, strerror(errno));\n     return false;\n   }\n-  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {\n+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK)) == -1) {\n     LOG_ERROR(\""%s unable to set O_NONBLOCK for semaphore fd: %s\"", __func__, strerror(errno));\n     return false;\n   }\n@@ -87,7 +87,7 @@\n\n   if (eventfd_read(semaphore->fd, &value) == -1)\n     return false;\n \n-  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)\n+  if (TEMP_FAILURE_RETRY(fcntl(semaphore->fd, F_SETFL, flags)) == -1)\n     LOG_ERROR(\""%s unable to resetore flags for semaphore fd: %s\"", __func__, strerror(errno));\n   return true;\n }\n""}<_**next**_>{""filename"": ""osi/src/socket.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/src/socket.c"", ""patch"": ""@@ -121,7 +121,7 @@\n\n socket_t *socket_accept(const socket_t *socket) {\n   assert(socket != NULL);\n \n-  int fd = accept(socket->fd, NULL, NULL);\n+  int fd = TEMP_FAILURE_RETRY(accept(socket->fd, NULL, NULL));\n   if (fd == INVALID_FD) {\n     LOG_ERROR(\""%s unable to accept socket: %s\"", __func__, strerror(errno));\n     return NULL;\n@@ -142,14 +142,14 @@\n\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n-  return recv(socket->fd, buf, count, MSG_DONTWAIT);\n+  return TEMP_FAILURE_RETRY(recv(socket->fd, buf, count, MSG_DONTWAIT));\n }\n \n ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {\n   assert(socket != NULL);\n   assert(buf != NULL);\n \n-  return send(socket->fd, buf, count, MSG_DONTWAIT);\n+  return TEMP_FAILURE_RETRY(send(socket->fd, buf, count, MSG_DONTWAIT));\n }\n \n ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {\n@@ -179,7 +179,7 @@\n\n   header->cmsg_len = CMSG_LEN(sizeof(int));\n   *(int *)CMSG_DATA(header) = fd;\n \n-  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);\n+  ssize_t ret = TEMP_FAILURE_RETRY(sendmsg(socket->fd, &msg, MSG_DONTWAIT));\n   close(fd);\n   return ret;\n }\n@@ -188,7 +188,7 @@\n\n   assert(socket != NULL);\n \n   int size = 0;\n-  if (ioctl(socket->fd, FIONREAD, &size) == -1)\n+  if (TEMP_FAILURE_RETRY(ioctl(socket->fd, FIONREAD, &size)) == -1)\n     return -1;\n   return size;\n }\n""}<_**next**_>{""filename"": ""osi/test/alarm_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/alarm_test.cpp"", ""patch"": ""@@ -32,7 +32,7 @@\n\n static const uint64_t EPSILON_MS = 5;\n \n static void msleep(uint64_t ms) {\n-  usleep(ms * 1000);\n+  TEMP_FAILURE_RETRY(usleep(ms * 1000));\n }\n \n class AlarmTest : public AlarmTestHarness {\n""}<_**next**_>{""filename"": ""osi/test/atomic_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/atomic_test.cpp"", ""patch"": ""@@ -17,7 +17,7 @@\n\n void *atomic_thread(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_inc_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n@@ -26,9 +26,9 @@\n\n void *atomic_thread_inc_dec(void *context) {\n   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;\n   for (int i = 0; i < at->max_val; i++) {\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_inc_prefix_s32(&at->data[i]);\n-    usleep(1);\n+    TEMP_FAILURE_RETRY(usleep(1));\n     atomic_dec_prefix_s32(&at->data[i]);\n   }\n   return NULL;\n""}<_**next**_>{""filename"": ""osi/test/eager_reader_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/eager_reader_test.cpp"", ""patch"": ""@@ -126,7 +126,7 @@\n\n   thread_t *read_thread = thread_new(\""read_thread\"");\n   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data, (void *)small_data);\n \n-  write(pipefd[1], small_data, strlen(small_data));\n+  TEMP_FAILURE_RETRY(write(pipefd[1], small_data, strlen(small_data)));\n \n   semaphore_wait(done);\n   eager_reader_free(reader);\n@@ -139,7 +139,7 @@\n\n   thread_t *read_thread = thread_new(\""read_thread\"");\n   eager_reader_register(reader, thread_get_reactor(read_thread), expect_data_multibyte, (void *)large_data);\n \n-  write(pipefd[1], large_data, strlen(large_data));\n+  TEMP_FAILURE_RETRY(write(pipefd[1], large_data, strlen(large_data)));\n \n   semaphore_wait(done);\n   eager_reader_free(reader);\n""}<_**next**_>{""filename"": ""osi/test/reactor_test.cpp"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/osi/test/reactor_test.cpp"", ""patch"": ""@@ -64,7 +64,7 @@\n\n   reactor_t *reactor = reactor_new();\n \n   spawn_reactor_thread(reactor);\n-  usleep(50 * 1000);\n+  TEMP_FAILURE_RETRY(usleep(50 * 1000));\n   EXPECT_TRUE(thread_running);\n \n   reactor_stop(reactor);\n@@ -108,7 +108,7 @@\n\n \n   reactor_object_t *object = reactor_register(reactor, fd, NULL, NULL, NULL);\n   spawn_reactor_thread(reactor);\n-  usleep(50 * 1000);\n+  TEMP_FAILURE_RETRY(usleep(50 * 1000));\n   reactor_unregister(object);\n \n   reactor_stop(reactor);\n""}<_**next**_>{""filename"": ""test/suite/support/callbacks.h"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/test/suite/support/callbacks.h"", ""patch"": ""@@ -20,12 +20,14 @@\n\n \n #include \""base.h\""\n \n+#include <errno.h>\n #include <semaphore.h>\n+#include <unistd.h>\n \n #define WAIT(callback) \\\n   do { \\\n     sem_t *semaphore = callbacks_get_semaphore(#callback); \\\n-    sem_wait(semaphore); \\\n+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \\\n   } while (0)\n \n #define CALL_AND_WAIT(expression, callback) \\\n@@ -33,7 +35,7 @@\n\n     sem_t *semaphore = callbacks_get_semaphore(#callback); \\\n     while (!sem_trywait(semaphore)); \\\n     expression; \\\n-    sem_wait(semaphore); \\\n+    TEMP_FAILURE_RETRY(sem_wait(semaphore)); \\\n   } while(0)\n \n // To be called from every exit point of the callback. This macro\n""}<_**next**_>{""filename"": ""tools/hci/main.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/tools/hci/main.c"", ""patch"": ""@@ -1,3 +1,4 @@\n\n+#include <errno.h>\n #include <hardware/bluetooth.h>\n #include <netinet/in.h>\n #include <stdio.h>\n@@ -149,16 +150,16 @@\n\n   addr.sin_family = AF_INET;\n   addr.sin_addr.s_addr = htonl(0x7F000001);\n   addr.sin_port = htons(8873);\n-  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)\n+  if (TEMP_FAILURE_RETRY(connect(sock, (const struct sockaddr *)&addr, sizeof(addr))) == -1)\n     goto error;\n \n-  if (send(sock, &type, 1, 0) != 1)\n+  if (TEMP_FAILURE_RETRY(send(sock, &type, 1, 0)) != 1)\n     goto error;\n \n-  if (send(sock, &length, 2, 0) != 2)\n+  if (TEMP_FAILURE_RETRY(send(sock, &length, 2, 0)) != 2)\n     goto error;\n \n-  if (send(sock, packet, length, 0) != (ssize_t)length)\n+  if (TEMP_FAILURE_RETRY(send(sock, packet, length, 0)) != (ssize_t)length)\n     goto error;\n \n   close(sock);\n""}<_**next**_>{""filename"": ""udrv/ulinux/uipc.c"", ""raw_url"": ""https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/udrv/ulinux/uipc.c"", ""patch"": ""@@ -184,7 +184,7 @@\n\n     pfd.fd = sfd;\n     pfd.events = POLLIN;\n \n-    if (poll(&pfd, 1, 0) == 0)\n+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)\n     {\n         BTIF_TRACE_EVENT(\""accept poll timeout\"");\n         return -1;\n@@ -192,7 +192,7 @@\n\n \n     //BTIF_TRACE_EVENT(\""poll revents 0x%x\"", pfd.revents);\n \n-    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)\n+    if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)\n     {\n          BTIF_TRACE_ERROR(\""sock accept failed (%s)\"", strerror(errno));\n          return -1;\n@@ -330,7 +330,7 @@\n\n     {\n         char sig_recv = 0;\n         //BTIF_TRACE_EVENT(\""UIPC INTERRUPT\"");\n-        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);\n+        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));\n     }\n }\n \n@@ -338,7 +338,7 @@\n\n {\n     char sig_on = 1;\n     BTIF_TRACE_EVENT(\""UIPC SEND WAKE UP\"");\n-    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);\n+    TEMP_FAILURE_RETRY(send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0));\n }\n \n static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)\n@@ -394,7 +394,7 @@\n\n \n     while (1)\n     {\n-        ret = poll(&pfd, 1, 1);\n+        ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, 1));\n         BTIF_TRACE_VERBOSE(\""%s() - polling fd %d, revents: 0x%x, ret %d\"",\n                 __FUNCTION__, pfd.fd, pfd.revents, ret);\n \n@@ -412,7 +412,7 @@\n\n \n         /* read sufficiently large buffer to ensure flush empties socket faster than\n            it is getting refilled */\n-        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);\n+        TEMP_FAILURE_RETRY(read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE));\n     }\n }\n \n@@ -502,7 +502,7 @@\n\n     {\n         uipc_main.read_set = uipc_main.active_set;\n \n-        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);\n+        result = TEMP_FAILURE_RETRY(select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL));\n \n         if (result == 0)\n         {\n@@ -715,7 +715,7 @@\n\n \n     UIPC_LOCK();\n \n-    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)\n+    if (TEMP_FAILURE_RETRY(write(uipc_main.ch[ch_id].fd, p_buf, msglen)) < 0)\n     {\n         BTIF_TRACE_ERROR(\""failed to write (%s)\"", strerror(errno));\n     }\n@@ -784,7 +784,7 @@\n\n \n         /* make sure there is data prior to attempting read to avoid blocking\n            a read for more than poll timeout */\n-        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)\n+        if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)\n         {\n             BTIF_TRACE_EVENT(\""poll timeout (%d ms)\"", uipc_main.ch[ch_id].read_poll_tmo_ms);\n             break;\n@@ -801,7 +801,7 @@\n\n             return 0;\n         }\n \n-        n = recv(fd, p_buf+n_read, len-n_read, 0);\n+        n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));\n \n         //BTIF_TRACE_EVENT(\""read %d bytes\"", n);\n \n""}","static void uipc_check_interrupt_locked(void)
{
 if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))

     {
         char sig_recv = 0;
        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
     }
 }
","static void uipc_check_interrupt_locked(void)
{
 if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))

     {
         char sig_recv = 0;
        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     }
 }
",C,"        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
","        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
",,"@@ -184,7 +184,7 @@

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
-    if (poll(&pfd, 1, 0) == 0)
+    if (TEMP_FAILURE_RETRY(poll(&pfd, 1, 0)) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
@@ -192,7 +192,7 @@

 
     //BTIF_TRACE_EVENT(""poll revents 0x%x"", pfd.revents);
 
-    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
+    if ((fd = TEMP_FAILURE_RETRY(accept(sfd, (struct sockaddr *)&remote, &len))) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
@@ -330,7 +330,7 @@

     {
         char sig_recv = 0;
         //BTIF_TRACE_EVENT(""UIPC INTERRUPT"");
-        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
+        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
     }
 }
 
@@ -338,7 +338,7 @@

 {
     char sig_on = 1;
     BTIF_TRACE_EVENT(""UIPC SEND WAKE UP"");
-    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);
+    TEMP_FAILURE_RETRY(send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0));
 }
 
 static int uipc_setup_server_locked(tUIPC_CH_ID ch_id, char *name, tUIPC_RCV_CBACK *cback)
@@ -394,7 +394,7 @@

 
     while (1)
     {
-        ret = poll(&pfd, 1, 1);
+        ret = TEMP_FAILURE_RETRY(poll(&pfd, 1, 1));
         BTIF_TRACE_VERBOSE(""%s() - polling fd %d, revents: 0x%x, ret %d"",
                 __FUNCTION__, pfd.fd, pfd.revents, ret);
 
@@ -412,7 +412,7 @@

 
         /* read sufficiently large buffer to ensure flush empties socket faster than
            it is getting refilled */
-        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);
+        TEMP_FAILURE_RETRY(read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE));
     }
 }
 
@@ -502,7 +502,7 @@

     {
         uipc_main.read_set = uipc_main.active_set;
 
-        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);
+        result = TEMP_FAILURE_RETRY(select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL));
 
         if (result == 0)
         {
@@ -715,7 +715,7 @@

 
     UIPC_LOCK();
 
-    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
+    if (TEMP_FAILURE_RETRY(write(uipc_main.ch[ch_id].fd, p_buf, msglen)) < 0)
     {
         BTIF_TRACE_ERROR(""failed to write (%s)"", strerror(errno));
     }
@@ -784,7 +784,7 @@

 
         /* make sure there is data prior to attempting read to avoid blocking
            a read for more than poll timeout */
-        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
+        if (TEMP_FAILURE_RETRY(poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms)) == 0)
         {
             BTIF_TRACE_EVENT(""poll timeout (%d ms)"", uipc_main.ch[ch_id].read_poll_tmo_ms);
             break;
@@ -801,7 +801,7 @@

             return 0;
         }
 
-        n = recv(fd, p_buf+n_read, len-n_read, 0);
+        n = TEMP_FAILURE_RETRY(recv(fd, p_buf+n_read, len-n_read, 0));
 
         //BTIF_TRACE_EVENT(""read %d bytes"", n);
 
",Android,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c/,https://android.googlesource.com/platform/system/bt/+/472271b153c5dc53c28beac55480a8d8434b2d5c%5E/,1,"static void uipc_check_interrupt_locked(void)
{
 if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))

     {
         char sig_recv = 0;
         //BTIF_TRACE_EVENT(""UIPC INTERRUPT"");
//flaw_line_below:
        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
//fix_flaw_line_below:
//        TEMP_FAILURE_RETRY(recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL));
     }
 }
"
80167,,Remote,Not required,Partial,CVE-2018-13006,https://www.cvedetails.com/cve/CVE-2018-13006/,CWE-125,Low,Partial,Partial,,2018-06-29,7.5,An issue was discovered in MP4Box in GPAC 0.7.1. There is a heap-based buffer over-read in the isomedia/box_dump.c function hdlr_dump.,2019-03-29,,0,https://github.com/gpac/gpac/commit/bceb03fd2be95097a7b409ea59914f332fb6bc86,bceb03fd2be95097a7b409ea59914f332fb6bc86,fixed 2 possible heap overflows (inc. #1088),0,src/isomedia/box_code_base.c,"{""sha"": ""0296626078712cd249ae511d4e704e6d8e26299b"", ""filename"": ""include/gpac/internal/isomedia_dev.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/include/gpac/internal/isomedia_dev.h"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/include/gpac/internal/isomedia_dev.h"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/include/gpac/internal/isomedia_dev.h?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -3710,7 +3710,7 @@ GF_GenericSubtitleSample *gf_isom_parse_generic_subtitle_sample_from_data(char *\n \t\tchar __ptype[5];\\\n \t\tstrcpy(__ptype, gf_4cc_to_str(__parent->type) );\\\n \t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\""[iso file] extra box %s found in %s, deleting\\n\"", gf_4cc_to_str(__abox->type), __ptype)); \\\n-\t\tgf_isom_box_del(a);\\\n+\t\tgf_isom_box_del(__abox);\\\n \t\treturn GF_OK;\\\n \t}\n ""}<_**next**_>{""sha"": ""0f5b40f7fdc7874383638968abacc141ca0efcc3"", ""filename"": ""src/isomedia/box_code_base.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_code_base.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_code_base.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/isomedia/box_code_base.c?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -632,7 +632,7 @@ GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n \n \t//then get the break\n \ti = 0;\n-\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n+\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n \t\ti++;\n \t}\n \t//check the data is consistent""}<_**next**_>{""sha"": ""c77847928bd9abb73a631eb2f7c24500c77a9c3d"", ""filename"": ""src/isomedia/box_dump.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 7, ""changes"": 14, ""blob_url"": ""https://github.com/gpac/gpac/blob/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_dump.c"", ""raw_url"": ""https://github.com/gpac/gpac/raw/bceb03fd2be95097a7b409ea59914f332fb6bc86/src/isomedia/box_dump.c"", ""contents_url"": ""https://api.github.com/repos/gpac/gpac/contents/src/isomedia/box_dump.c?ref=bceb03fd2be95097a7b409ea59914f332fb6bc86"", ""patch"": ""@@ -484,7 +484,7 @@ GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n {\n \tGF_HandlerBox *p = (GF_HandlerBox *)a;\n \tgf_isom_box_dump_start(a, \""HandlerBox\"", trace);\n-\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n+\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8)-1) {\n \t\tfprintf(trace, \""hdlrType=\\\""%s\\\"" Name=\\\""%s\\\"" \"", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n \t} else {\n \t\tfprintf(trace, \""hdlrType=\\\""%s\\\"" Name=\\\""%s\\\"" \"", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n@@ -4157,9 +4157,9 @@ static void oinf_entry_dump(GF_OperatingPointsInformation *ptr, FILE * trace)\n \t\tfprintf(trace, \"" maxPicWidth=\\\""%u\\\"" maxPicHeight=\\\""%u\\\""\"", op->maxPicWidth, op->maxPicHeight);\n \t\tfprintf(trace, \"" maxChromaFormat=\\\""%u\\\"" maxBitDepth=\\\""%u\\\""\"", op->maxChromaFormat, op->maxBitDepth);\n \t\tfprintf(trace, \"" frame_rate_info_flag=\\\""%u\\\"" bit_rate_info_flag=\\\""%u\\\""\"", op->frame_rate_info_flag, op->bit_rate_info_flag);\n-\t\tif (op->frame_rate_info_flag) \n+\t\tif (op->frame_rate_info_flag)\n \t\t\tfprintf(trace, \"" avgFrameRate=\\\""%u\\\"" constantFrameRate=\\\""%u\\\""\"", op->avgFrameRate, op->constantFrameRate);\n-\t\tif (op->bit_rate_info_flag) \n+\t\tif (op->bit_rate_info_flag)\n \t\t\tfprintf(trace, \"" maxBitRate=\\\""%u\\\"" avgBitRate=\\\""%u\\\""\"", op->maxBitRate, op->avgBitRate);\n \t\tfprintf(trace, \""/>\\n\"");\n \t}\n@@ -4261,14 +4261,14 @@ static void nalm_dump(FILE * trace, char *data, u32 data_size)\n \t\tfprintf(trace, \""</NALUMap>\\n\"");\n \t\treturn;\n \t}\n-\t\n+\n \tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n \tgf_bs_read_int(bs, 6);\n \tlarge_size = gf_bs_read_int(bs, 1);\n \trle = gf_bs_read_int(bs, 1);\n \tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n \tfprintf(trace, \""<NALUMap rle=\\\""%d\\\"" large_size=\\\""%d\\\"">\\n\"", rle, large_size);\n-\t\n+\n \twhile (entry_count) {\n \t\tu32 ID;\n \t\tfprintf(trace, \""<NALUMapEntry \"");\n@@ -4338,7 +4338,7 @@ GF_Err sgpd_dump(GF_Box *a, FILE * trace)\n \t\tcase GF_ISOM_SAMPLE_GROUP_TRIF:\n \t\t\ttrif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n-\t\t\t\n+\n \t\tcase GF_ISOM_SAMPLE_GROUP_NALM:\n \t\t\tnalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);\n \t\t\tbreak;\n@@ -4507,7 +4507,7 @@ GF_Err tenc_dump(GF_Box *a, FILE * trace)\n \t\tfprintf(trace, \""\\\""  KID=\\\""\"");\n \t}\n \tdump_data_hex(trace, (char *) ptr->KID, 16);\n-\tif (ptr->version) \n+\tif (ptr->version)\n \t\tfprintf(trace, \""\\\"" crypt_byte_block=\\\""%d\\\"" skip_byte_block=\\\""%d\"", ptr->crypt_byte_block, ptr->skip_byte_block);\n \tfprintf(trace, \""\\\"">\\n\"");\n \tgf_isom_box_dump_done(\""TrackEncryptionBox\"", a, trace);""}","GF_Err hinf_Read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs, hinf_AddBox);
}
","GF_Err hinf_Read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs, hinf_AddBox);
}
",C,,,,"@@ -632,7 +632,7 @@ GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)
 
 	//then get the break
 	i = 0;
-	while ( (tmpName[i] != 0) && (i < to_read) ) {
+	while ( (i < to_read) && (tmpName[i] != 0) ) {
 		i++;
 	}
 	//check the data is consistent",gpac,bceb03fd2be95097a7b409ea59914f332fb6bc86,2ce4dcf583601a23ce328dfa44f9c57fe8ea6156,0,"GF_Err hinf_Read(GF_Box *s, GF_BitStream *bs)
{
	return gf_isom_box_array_read(s, bs, hinf_AddBox);
}
"
122118,,Remote,Not required,Partial,CVE-2013-0881,https://www.cvedetails.com/cve/CVE-2013-0881/,CWE-20,Low,,,,2013-02-23,5.0,"Google Chrome before 25.0.1364.97 on Windows and Linux, and before 25.0.1364.99 on Mac OS X, allows remote attackers to cause a denial of service (incorrect read operation) via crafted data in the Matroska container format.",2018-10-30,DoS ,0,https://github.com/chromium/chromium/commit/634c5943f46abe8c6280079f6d394dfee08c3c8f,634c5943f46abe8c6280079f6d394dfee08c3c8f,"Disable some more query compositingState asserts.

This gets the tests passing again on Mac. See the bug for the stacktrace.
A future patch will need to actually fix the incorrect reading of
compositingState.

BUG=343179

Review URL: https://codereview.chromium.org/162153002

git-svn-id: svn://svn.chromium.org/blink/trunk@167069 bbb929c8-8fbe-4397-9dbb-9b2b20218538",0,third_party/WebKit/Source/core/rendering/RenderLayerCompositor.cpp,"{""sha"": ""001a64f3f576a0a20cf5444fbc7cdb6c2f575661"", ""filename"": ""third_party/WebKit/LayoutTests/TestExpectations"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/634c5943f46abe8c6280079f6d394dfee08c3c8f/third_party/WebKit/LayoutTests/TestExpectations"", ""raw_url"": ""https://github.com/chromium/chromium/raw/634c5943f46abe8c6280079f6d394dfee08c3c8f/third_party/WebKit/LayoutTests/TestExpectations"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/LayoutTests/TestExpectations?ref=634c5943f46abe8c6280079f6d394dfee08c3c8f"", ""patch"": ""@@ -507,9 +507,6 @@ crbug.com/282634 [ SnowLeopard Debug ] svg/as-object/embedded-svg-size-changes-n\n crbug.com/282634 [ SnowLeopard Debug ] svg/as-object/nested-embedded-svg-size-changes-no-layout-triggers-1.html [ Pass ImageOnlyFailure ]\n crbug.com/282634 [ SnowLeopard Debug ] svg/as-object/nested-embedded-svg-size-changes-no-layout-triggers-2.html [ Pass ImageOnlyFailure ]\n \n-crbug.com/343179 [ Mac Debug ] compositing/fixed-background-negative-z-index-fixed.html [ Crash ]\n-crbug.com/343179 [ Mac Debug ] compositing/fixed-background-composited-html.html [ Crash ]\n-\n crbug.com/343185 transitions/3d/interrupted-transition.html [ Pass Crash ]\n crbug.com/343185 virtual/threaded/transitions/3d/interrupted-transition.html [ Pass Crash ]\n ""}<_**next**_>{""sha"": ""6e9868b5b1661bbcafa35b3ada60c170203b83fb"", ""filename"": ""third_party/WebKit/Source/core/rendering/RenderLayerCompositor.cpp"", ""status"": ""modified"", ""additions"": 4, ""deletions"": 0, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/634c5943f46abe8c6280079f6d394dfee08c3c8f/third_party/WebKit/Source/core/rendering/RenderLayerCompositor.cpp"", ""raw_url"": ""https://github.com/chromium/chromium/raw/634c5943f46abe8c6280079f6d394dfee08c3c8f/third_party/WebKit/Source/core/rendering/RenderLayerCompositor.cpp"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/WebKit/Source/core/rendering/RenderLayerCompositor.cpp?ref=634c5943f46abe8c6280079f6d394dfee08c3c8f"", ""patch"": ""@@ -1437,6 +1437,10 @@ void RenderLayerCompositor::frameViewDidScroll()\n     if (!m_renderView->rootBackgroundIsEntirelyFixed())\n         return;\n \n+    // FIXME: fixedRootBackgroundLayer calls compositingState, which is not necessarily up to date here on mac.\n+    // See crbug.com/343179.\n+    DisableCompositingQueryAsserts disabler;\n+\n     blink::Platform::current()->histogramEnumeration(\""Renderer.AcceleratedFixedRootBackground\"",\n         !!fixedRootBackgroundLayer()\n             ? ScrolledMainFrameWithAcceleratedFixedRootBackground""}","void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
{
    if (!m_rootContentLayer)
        return;

    switch (attachment) {
        case RootLayerUnattached:
            ASSERT_NOT_REACHED();
            break;
        case RootLayerAttachedViaChromeClient: {
            Frame& frame = m_renderView->frameView()->frame();
            Page* page = frame.page();
            if (!page)
                return;
            page->chrome().client().attachRootGraphicsLayer(&frame, rootGraphicsLayer());
            break;
        }
        case RootLayerAttachedViaEnclosingFrame: {
            HTMLFrameOwnerElement* ownerElement = m_renderView->document().ownerElement();
            ASSERT(ownerElement);
            DeprecatedScheduleStyleRecalcDuringCompositingUpdate marker(ownerElement->document().lifecycle());
            ownerElement->scheduleLayerUpdate();
            break;
        }
    }

    m_rootLayerAttachment = attachment;
}
","void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
{
    if (!m_rootContentLayer)
        return;

    switch (attachment) {
        case RootLayerUnattached:
            ASSERT_NOT_REACHED();
            break;
        case RootLayerAttachedViaChromeClient: {
            Frame& frame = m_renderView->frameView()->frame();
            Page* page = frame.page();
            if (!page)
                return;
            page->chrome().client().attachRootGraphicsLayer(&frame, rootGraphicsLayer());
            break;
        }
        case RootLayerAttachedViaEnclosingFrame: {
            HTMLFrameOwnerElement* ownerElement = m_renderView->document().ownerElement();
            ASSERT(ownerElement);
            DeprecatedScheduleStyleRecalcDuringCompositingUpdate marker(ownerElement->document().lifecycle());
            ownerElement->scheduleLayerUpdate();
            break;
        }
    }

    m_rootLayerAttachment = attachment;
}
",C,,,,"@@ -1437,6 +1437,10 @@ void RenderLayerCompositor::frameViewDidScroll()
     if (!m_renderView->rootBackgroundIsEntirelyFixed())
         return;
 
+    // FIXME: fixedRootBackgroundLayer calls compositingState, which is not necessarily up to date here on mac.
+    // See crbug.com/343179.
+    DisableCompositingQueryAsserts disabler;
+
     blink::Platform::current()->histogramEnumeration(""Renderer.AcceleratedFixedRootBackground"",
         !!fixedRootBackgroundLayer()
             ? ScrolledMainFrameWithAcceleratedFixedRootBackground",Chrome,634c5943f46abe8c6280079f6d394dfee08c3c8f,6e76d1cf20a22226a7e07b4b374c0886b809a2e2,0,"void RenderLayerCompositor::attachRootLayer(RootLayerAttachment attachment)
{
    if (!m_rootContentLayer)
        return;

    switch (attachment) {
        case RootLayerUnattached:
            ASSERT_NOT_REACHED();
            break;
        case RootLayerAttachedViaChromeClient: {
            Frame& frame = m_renderView->frameView()->frame();
            Page* page = frame.page();
            if (!page)
                return;
            page->chrome().client().attachRootGraphicsLayer(&frame, rootGraphicsLayer());
            break;
        }
        case RootLayerAttachedViaEnclosingFrame: {
            HTMLFrameOwnerElement* ownerElement = m_renderView->document().ownerElement();
            ASSERT(ownerElement);
            DeprecatedScheduleStyleRecalcDuringCompositingUpdate marker(ownerElement->document().lifecycle());
            // The layer will get hooked up via CompositedLayerMapping::updateGraphicsLayerConfiguration()
            // for the frame's renderer in the parent document.
            ownerElement->scheduleLayerUpdate();
            break;
        }
    }

    m_rootLayerAttachment = attachment;
}
"
182166,,Local,Not required,Partial,CVE-2018-19044,https://www.cvedetails.com/cve/CVE-2018-19044/,CWE-59,Medium,,Partial,,2018-11-08,3.3,"keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",2019-08-06,,1,https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306,04f2d32871bb3b11d7dc024039952f2fe2750306,"When opening files for write, ensure they aren't symbolic links

Issue #1048 identified that if, for example, a non privileged user
created a symbolic link from /etc/keepalvied.data to /etc/passwd,
writing to /etc/keepalived.data (which could be invoked via DBus)
would cause /etc/passwd to be overwritten.

This commit stops keepalived writing to pathnames where the ultimate
component is a symbolic link, by setting O_NOFOLLOW whenever opening
a file for writing.

This might break some setups, where, for example, /etc/keepalived.data
was a symbolic link to /home/fred/keepalived.data. If this was the case,
instead create a symbolic link from /home/fred/keepalived.data to
/tmp/keepalived.data, so that the file is still accessible via
/home/fred/keepalived.data.

There doesn't appear to be a way around this backward incompatibility,
since even checking if the pathname is a symbolic link prior to opening
for writing would create a race condition.

Signed-off-by: Quentin Armitage <quentin@armitage.org.uk>",1,lib/logger.c,"{""sha"": ""e494976f50b4eddbab13a2704287a14541c9043b"", ""filename"": ""keepalived/core/main.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/main.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/main.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1399,7 +1399,7 @@ parse_cmdline(int argc, char **argv)\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \""Unable to open config-test log file %s\\n\"", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);""}<_**next**_>{""sha"": ""83f6f2fa4c1f3f7e1704c4e32b7cb9f6aafb766e"", ""filename"": ""keepalived/core/pidfile.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/pidfile.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/pidfile.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -60,7 +60,7 @@ int\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \""w\"");\n ""}<_**next**_>{""sha"": ""d16ef3d9a6e624e724b34e6c58c7cc8878c0da5a"", ""filename"": ""keepalived/core/smtp.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/core/smtp.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/core/smtp.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -570,7 +570,7 @@ smtp_connect(smtp_t * smtp)\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\""/tmp/smtp-alert.log\"", \""a\"");\n+\tFILE *fp = fopen_safe(\""/tmp/smtp-alert.log\"", \""a\"");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];""}<_**next**_>{""sha"": ""4cfb16366fa244d607b85bfe2ecf613495c74eb3"", ""filename"": ""keepalived/vrrp/vrrp_dbus.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_dbus.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_dbus.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -594,7 +594,7 @@ read_file(gchar* filepath)\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \""rb\"");\n+\tf = fopen(filepath, \""r\"");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);""}<_**next**_>{""sha"": ""1a6ea873a250f9958d52e649399ef1398f7a2087"", ""filename"": ""keepalived/vrrp/vrrp_json.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_json.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_json.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -37,6 +37,7 @@\n #include \""vrrp_iprule.h\""\n #include \""logger.h\""\n #include \""timer.h\""\n+#include \""utils.h\""\n \n static inline double\n timeval_to_double(const timeval_t *t)\n@@ -55,7 +56,7 @@ vrrp_print_json(void)\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\""/tmp/keepalived.json\"",\""w\"");\n+\tfile = fopen_safe(\""/tmp/keepalived.json\"", \""w\"");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open /tmp/keepalived.json (%d: %s)\"",\n \t\t\terrno, strerror(errno));""}<_**next**_>{""sha"": ""84704b415db95999319d3ecfe3ef8c650f20e083"", ""filename"": ""keepalived/vrrp/vrrp_parser.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1205,7 +1205,7 @@ vrrp_tfile_end_handler(void)\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \""w\""))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \""w\""))) {\n \t\t\tfprintf(tf, \""%d\\n\"", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}""}<_**next**_>{""sha"": ""aeb74bcbf5dca2f2f71faa32cf1ca91ffebed75b"", ""filename"": ""keepalived/vrrp/vrrp_print.c"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 10, ""changes"": 17, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_print.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_print.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -32,14 +32,15 @@\n #include \""vrrp.h\""\n #include \""vrrp_data.h\""\n #include \""vrrp_print.h\""\n+#include \""utils.h\""\n \n static const char *dump_file = \""/tmp/keepalived.data\"";\n static const char *stats_file = \""/tmp/keepalived.stats\"";\n \n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \""w\"");\n+\tFILE *file = fopen_safe(dump_file, \""w\"");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n@@ -55,28 +56,24 @@ vrrp_print_data(void)\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \""w\"");\n+\tFILE *file = fopen_safe(stats_file, \""w\"");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \""Can't open %s (%d: %s)\"",\n \t\t\tstats_file, errno, strerror(errno));\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \""VRRP Instance: %s\\n\"", vrrp->iname);\n \t\tfprintf(file, \""  Advertisements:\\n\"");\n \t\tfprintf(file, \""    Received: %\"" PRIu64 \""\\n\"", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \""    Sent: %d\\n\"", vrrp->stats->advert_sent);\n \t\tfprintf(file, \""  Became master: %d\\n\"", vrrp->stats->become_master);\n-\t\tfprintf(file, \""  Released master: %d\\n\"",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \""  Released master: %d\\n\"", vrrp->stats->release_master);\n \t\tfprintf(file, \""  Packet Errors:\\n\"");\n \t\tfprintf(file, \""    Length: %\"" PRIu64 \""\\n\"", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \""    TTL: %\"" PRIu64 \""\\n\"", vrrp->stats->ip_ttl_err);""}<_**next**_>{""sha"": ""59217c6303694449716ba3308169b6a09539e821"", ""filename"": ""keepalived/vrrp/vrrp_scheduler.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/keepalived/vrrp/vrrp_scheduler.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/keepalived/vrrp/vrrp_scheduler.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -1134,7 +1134,7 @@ dump_threads(void)\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \""a\"");\n+\tfp = fopen_safe(file_name, \""a\"");\n \tFREE(file_name);\n \n \tset_time_now();""}<_**next**_>{""sha"": ""20153c800f219bb6f9c512f6970caf537e1ce5f0"", ""filename"": ""lib/logger.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/logger.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/logger.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \""a\"");\n+\tlog_file = fopen_safe(file_name, \""a\"");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));""}<_**next**_>{""sha"": ""3001f3ebdcd9a411edb91ee8352f4f910b54e900"", ""filename"": ""lib/memory.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/memory.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/memory.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -621,7 +621,7 @@ mem_log_init(const char* prog_name, const char *banner)\n \t}\n \n \tsnprintf(log_name, log_name_len, \""/tmp/%s_mem.%d.log\"", prog_name, getpid());\n-\tlog_op = fopen(log_name, \""a\"");\n+\tlog_op = fopen_safe(log_name, \""a\"");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \""Unable to open %s for appending\"", log_name);\n \t\tlog_op = stderr;""}<_**next**_>{""sha"": ""3a8c0662a4e7a61bcbdf175f0f35c704d8e7e446"", ""filename"": ""lib/notify.c"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/notify.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/notify.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -236,7 +236,7 @@ fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \""Unable to open %snotify fifo %s - errno %d\"", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);""}<_**next**_>{""sha"": ""1d53595c0e876c459f5677f01ffeca9c99403e84"", ""filename"": ""lib/parser.c"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/parser.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/parser.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -455,11 +455,11 @@ dump_keywords(vector_t *keydump, int level, FILE *fp)\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \""/tmp/keywords.%d\"", getpid());\n-\t\tfp = fopen(file_name, \""w\"");\n+\t\tfp = fopen_safe(file_name, \""w\"");\n \t\tif (!fp)\n \t\t\treturn;\n \t}""}<_**next**_>{""sha"": ""4aac594454bb3fddec3b72bbe4b8b099638ef5c8"", ""filename"": ""lib/utils.c"", ""status"": ""modified"", ""additions"": 42, ""deletions"": 1, ""changes"": 43, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.c"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.c?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -123,7 +123,7 @@ write_stacktrace(const char *file_name, const char *str)\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \""%s\\n\"", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n@@ -788,6 +788,47 @@ string_equal(const char *str1, const char *str2)\n \treturn !strcmp(str1, str2);\n }\n \n+/* We need to use O_NOFOLLOW if opening a file for write, so that a non privileged user can't\n+ * create a symbolic link from the path to a system file and cause a system file to be overwritten. */\n+FILE *fopen_safe(const char *path, const char *mode)\n+{\n+\tint fd;\n+\tFILE *file;\n+\tint flags = O_NOFOLLOW | O_CREAT;\n+\n+\tif (mode[0] == 'r')\n+\t\treturn fopen(path, mode);\n+\n+\tif (mode[0] != 'a' && mode[0] != 'w')\n+\t\treturn NULL;\n+\n+\tif (mode[1] &&\n+\t    (mode[1] != '+' || mode[2]))\n+\t\treturn NULL;\n+\n+\tif (mode[0] == 'w')\n+\t\tflags |= O_TRUNC;\n+\telse\n+\t\tflags |= O_APPEND;\n+\n+\tif (mode[1])\n+\t\tflags |= O_RDWR;\n+\telse\n+\t\tflags |= O_WRONLY;\n+\n+\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n+\tif (fd == -1)\n+\t\treturn NULL;\n+\n+\tfile = fdopen (fd, \""w\"");\n+\tif (!file) {\n+\t\tclose(fd);\n+\t\treturn NULL;\n+\t}\n+\n+\treturn file;\n+}\n+\n void\n set_std_fd(bool force)\n {""}<_**next**_>{""sha"": ""19682d02546d7329c410a77ad1c9569a144b5434"", ""filename"": ""lib/utils.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/acassen/keepalived/blob/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""raw_url"": ""https://github.com/acassen/keepalived/raw/04f2d32871bb3b11d7dc024039952f2fe2750306/lib/utils.h"", ""contents_url"": ""https://api.github.com/repos/acassen/keepalived/contents/lib/utils.h?ref=04f2d32871bb3b11d7dc024039952f2fe2750306"", ""patch"": ""@@ -182,6 +182,7 @@ extern int inet_inaddrcmp(int, const void *, const void *);\n extern int inet_sockaddrcmp(const struct sockaddr_storage *, const struct sockaddr_storage *);\n extern char *get_local_name(void);\n extern bool string_equal(const char *, const char *);\n+extern FILE *fopen_safe(const char *, const char *);\n extern void set_std_fd(bool);\n extern void close_std_fd(void);\n #if !defined _HAVE_LIBIPTC_ || defined _LIBIPTC_DYNAMIC_""}","open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
","open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
	log_file = fopen(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
",C,"	log_file = fopen_safe(file_name, ""a"");
","	log_file = fopen(file_name, ""a"");
",,"@@ -78,7 +78,7 @@ open_log_file(const char *name, const char *prog, const char *namespace, const c
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
-	log_file = fopen(file_name, ""a"");
+	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));",keepalived,04f2d32871bb3b11d7dc024039952f2fe2750306,5241e4d7b177d0b6f073cfc9ed5444bf51ec89d6,1,"open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)
{
	char *file_name;

	if (log_file) {
		fclose(log_file);
		log_file = NULL;
	}

	if (!name)
		return;
 
 	file_name = make_file_name(name, prog, namespace, instance);
 
//flaw_line_below:
	log_file = fopen(file_name, ""a"");
//fix_flaw_line_below:
//	log_file = fopen_safe(file_name, ""a"");
 	if (log_file) {
 		int n = fileno(log_file);
 		fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));
		fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));
	}

	FREE(file_name);
}
"
51072,,Local,Not required,Complete,CVE-2016-6197,https://www.cvedetails.com/cve/CVE-2016-6197/,CWE-20,Low,,,,2016-08-06,4.9,"fs/overlayfs/dir.c in the OverlayFS filesystem implementation in the Linux kernel before 4.6 does not properly verify the upper dentry before proceeding with unlink and rename system-call processing, which allows local users to cause a denial of service (system crash) via a rename system call that specifies a self-hardlink.",2018-01-04,DoS ,0,https://github.com/torvalds/linux/commit/11f3710417d026ea2f4fcf362d866342c5274185,11f3710417d026ea2f4fcf362d866342c5274185,"ovl: verify upper dentry before unlink and rename

Unlink and rename in overlayfs checked the upper dentry for staleness by
verifying upper->d_parent against upperdir.  However the dentry can go
stale also by being unhashed, for example.

Expand the verification to actually look up the name again (under parent
lock) and check if it matches the upper dentry.  This matches what the VFS
does before passing the dentry to filesytem's unlink/rename methods, which
excludes any inconsistency caused by overlayfs.

Signed-off-by: Miklos Szeredi <mszeredi@redhat.com>",0,fs/overlayfs/dir.c,"{""sha"": ""bc1758a160f6d7e857d43294c2c6656ca122a537"", ""filename"": ""fs/overlayfs/dir.c"", ""status"": ""modified"", ""additions"": 38, ""deletions"": 21, ""changes"": 59, ""blob_url"": ""https://github.com/torvalds/linux/blob/11f3710417d026ea2f4fcf362d866342c5274185/fs/overlayfs/dir.c"", ""raw_url"": ""https://github.com/torvalds/linux/raw/11f3710417d026ea2f4fcf362d866342c5274185/fs/overlayfs/dir.c"", ""contents_url"": ""https://api.github.com/repos/torvalds/linux/contents/fs/overlayfs/dir.c?ref=11f3710417d026ea2f4fcf362d866342c5274185"", ""patch"": ""@@ -596,21 +596,25 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n {\n \tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n \tstruct inode *dir = upperdir->d_inode;\n-\tstruct dentry *upper = ovl_dentry_upper(dentry);\n+\tstruct dentry *upper;\n \tint err;\n \n \tinode_lock_nested(dir, I_MUTEX_PARENT);\n+\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n+\t\t\t       dentry->d_name.len);\n+\terr = PTR_ERR(upper);\n+\tif (IS_ERR(upper))\n+\t\tgoto out_unlock;\n+\n \terr = -ESTALE;\n-\tif (upper->d_parent == upperdir) {\n-\t\t/* Don't let d_delete() think it can reset d_inode */\n-\t\tdget(upper);\n+\tif (upper == ovl_dentry_upper(dentry)) {\n \t\tif (is_dir)\n \t\t\terr = vfs_rmdir(dir, upper);\n \t\telse\n \t\t\terr = vfs_unlink(dir, upper, NULL);\n-\t\tdput(upper);\n \t\tovl_dentry_version_inc(dentry->d_parent);\n \t}\n+\tdput(upper);\n \n \t/*\n \t * Keeping this dentry hashed would mean having to release\n@@ -620,6 +624,7 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n \t */\n \tif (!err)\n \t\td_drop(dentry);\n+out_unlock:\n \tinode_unlock(dir);\n \n \treturn err;\n@@ -840,29 +845,39 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n \ttrap = lock_rename(new_upperdir, old_upperdir);\n \n-\tolddentry = ovl_dentry_upper(old);\n-\tnewdentry = ovl_dentry_upper(new);\n-\tif (newdentry) {\n+\n+\tolddentry = lookup_one_len(old->d_name.name, old_upperdir,\n+\t\t\t\t   old->d_name.len);\n+\terr = PTR_ERR(olddentry);\n+\tif (IS_ERR(olddentry))\n+\t\tgoto out_unlock;\n+\n+\terr = -ESTALE;\n+\tif (olddentry != ovl_dentry_upper(old))\n+\t\tgoto out_dput_old;\n+\n+\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n+\t\t\t\t   new->d_name.len);\n+\terr = PTR_ERR(newdentry);\n+\tif (IS_ERR(newdentry))\n+\t\tgoto out_dput_old;\n+\n+\terr = -ESTALE;\n+\tif (ovl_dentry_upper(new)) {\n \t\tif (opaquedir) {\n-\t\t\tnewdentry = opaquedir;\n-\t\t\topaquedir = NULL;\n+\t\t\tif (newdentry != opaquedir)\n+\t\t\t\tgoto out_dput;\n \t\t} else {\n-\t\t\tdget(newdentry);\n+\t\t\tif (newdentry != ovl_dentry_upper(new))\n+\t\t\t\tgoto out_dput;\n \t\t}\n \t} else {\n \t\tnew_create = true;\n-\t\tnewdentry = lookup_one_len(new->d_name.name, new_upperdir,\n-\t\t\t\t\t   new->d_name.len);\n-\t\terr = PTR_ERR(newdentry);\n-\t\tif (IS_ERR(newdentry))\n-\t\t\tgoto out_unlock;\n+\t\tif (!d_is_negative(newdentry) &&\n+\t\t    (!new_opaque || !ovl_is_whiteout(newdentry)))\n+\t\t\tgoto out_dput;\n \t}\n \n-\terr = -ESTALE;\n-\tif (olddentry->d_parent != old_upperdir)\n-\t\tgoto out_dput;\n-\tif (newdentry->d_parent != new_upperdir)\n-\t\tgoto out_dput;\n \tif (olddentry == trap)\n \t\tgoto out_dput;\n \tif (newdentry == trap)\n@@ -925,6 +940,8 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,\n \n out_dput:\n \tdput(newdentry);\n+out_dput_old:\n+\tdput(olddentry);\n out_unlock:\n \tunlock_rename(new_upperdir, old_upperdir);\n out_revert_creds:""}","static int ovl_unlink(struct inode *dir, struct dentry *dentry)
{
	return ovl_do_remove(dentry, false);
}
","static int ovl_unlink(struct inode *dir, struct dentry *dentry)
{
	return ovl_do_remove(dentry, false);
}
",C,,,,"@@ -596,21 +596,25 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)
 {
 	struct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);
 	struct inode *dir = upperdir->d_inode;
-	struct dentry *upper = ovl_dentry_upper(dentry);
+	struct dentry *upper;
 	int err;
 
 	inode_lock_nested(dir, I_MUTEX_PARENT);
+	upper = lookup_one_len(dentry->d_name.name, upperdir,
+			       dentry->d_name.len);
+	err = PTR_ERR(upper);
+	if (IS_ERR(upper))
+		goto out_unlock;
+
 	err = -ESTALE;
-	if (upper->d_parent == upperdir) {
-		/* Don't let d_delete() think it can reset d_inode */
-		dget(upper);
+	if (upper == ovl_dentry_upper(dentry)) {
 		if (is_dir)
 			err = vfs_rmdir(dir, upper);
 		else
 			err = vfs_unlink(dir, upper, NULL);
-		dput(upper);
 		ovl_dentry_version_inc(dentry->d_parent);
 	}
+	dput(upper);
 
 	/*
 	 * Keeping this dentry hashed would mean having to release
@@ -620,6 +624,7 @@ static int ovl_remove_upper(struct dentry *dentry, bool is_dir)
 	 */
 	if (!err)
 		d_drop(dentry);
+out_unlock:
 	inode_unlock(dir);
 
 	return err;
@@ -840,29 +845,39 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,
 
 	trap = lock_rename(new_upperdir, old_upperdir);
 
-	olddentry = ovl_dentry_upper(old);
-	newdentry = ovl_dentry_upper(new);
-	if (newdentry) {
+
+	olddentry = lookup_one_len(old->d_name.name, old_upperdir,
+				   old->d_name.len);
+	err = PTR_ERR(olddentry);
+	if (IS_ERR(olddentry))
+		goto out_unlock;
+
+	err = -ESTALE;
+	if (olddentry != ovl_dentry_upper(old))
+		goto out_dput_old;
+
+	newdentry = lookup_one_len(new->d_name.name, new_upperdir,
+				   new->d_name.len);
+	err = PTR_ERR(newdentry);
+	if (IS_ERR(newdentry))
+		goto out_dput_old;
+
+	err = -ESTALE;
+	if (ovl_dentry_upper(new)) {
 		if (opaquedir) {
-			newdentry = opaquedir;
-			opaquedir = NULL;
+			if (newdentry != opaquedir)
+				goto out_dput;
 		} else {
-			dget(newdentry);
+			if (newdentry != ovl_dentry_upper(new))
+				goto out_dput;
 		}
 	} else {
 		new_create = true;
-		newdentry = lookup_one_len(new->d_name.name, new_upperdir,
-					   new->d_name.len);
-		err = PTR_ERR(newdentry);
-		if (IS_ERR(newdentry))
-			goto out_unlock;
+		if (!d_is_negative(newdentry) &&
+		    (!new_opaque || !ovl_is_whiteout(newdentry)))
+			goto out_dput;
 	}
 
-	err = -ESTALE;
-	if (olddentry->d_parent != old_upperdir)
-		goto out_dput;
-	if (newdentry->d_parent != new_upperdir)
-		goto out_dput;
 	if (olddentry == trap)
 		goto out_dput;
 	if (newdentry == trap)
@@ -925,6 +940,8 @@ static int ovl_rename2(struct inode *olddir, struct dentry *old,
 
 out_dput:
 	dput(newdentry);
+out_dput_old:
+	dput(olddentry);
 out_unlock:
 	unlock_rename(new_upperdir, old_upperdir);
 out_revert_creds:",linux,11f3710417d026ea2f4fcf362d866342c5274185,3c2de27d793bf55167804fc47954711e94f27be7,0,"static int ovl_unlink(struct inode *dir, struct dentry *dentry)
{
	return ovl_do_remove(dentry, false);
}
"
103911,,Remote,Not required,Partial,CVE-2011-2861,https://www.cvedetails.com/cve/CVE-2011-2861/,CWE-20,Medium,Partial,Partial,,2011-09-19,6.8,"Google Chrome before 14.0.835.163 does not properly handle strings in PDF documents, which allows remote attackers to have an unspecified impact via a crafted document that triggers an incorrect read operation.",2017-09-18,,0,https://github.com/chromium/chromium/commit/8262245d384be025f13e2a5b3a03b7e5c98374ce,8262245d384be025f13e2a5b3a03b7e5c98374ce,"DevTools: move DevToolsAgent/Client into content.

BUG=84078
TEST=

Review URL: http://codereview.chromium.org/7461019

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@93596 0039d316-1c4b-4281-b951-d872f2087c98",0,content/renderer/render_view.cc,"{""sha"": ""24059d48a3bcbe447efb7408f77415576f0c36a4"", ""filename"": ""chrome/browser/chrome_content_browser_client.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/browser/chrome_content_browser_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/browser/chrome_content_browser_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/chrome_content_browser_client.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -351,7 +351,6 @@ void ChromeContentBrowserClient::AppendExtraCommandLineSwitches(\n       switches::kProfilingAtStart,\n       switches::kProfilingFile,\n       switches::kProfilingFlush,\n-      switches::kRemoteShellPort,\n       switches::kSilentDumpOnDCHECK,\n     };\n ""}<_**next**_>{""sha"": ""4a98d54069325017a29a4b1cf9e03e5d66a17536"", ""filename"": ""chrome/chrome_renderer.gypi"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 6, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/chrome_renderer.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/chrome_renderer.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/chrome_renderer.gypi?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -105,12 +105,6 @@\n         'renderer/chrome_render_view_observer.h',\n         'renderer/content_settings_observer.cc',\n         'renderer/content_settings_observer.h',\n-        'renderer/devtools_agent.cc',\n-        'renderer/devtools_agent.h',\n-        'renderer/devtools_agent_filter.cc',\n-        'renderer/devtools_agent_filter.h',\n-        'renderer/devtools_client.cc',\n-        'renderer/devtools_client.h',\n         'renderer/external_host_bindings.cc',\n         'renderer/external_host_bindings.h',\n         'renderer/external_extension.cc',""}<_**next**_>{""sha"": ""e86db41c3e000620a991df2df27878edcac769a4"", ""filename"": ""chrome/common/chrome_switches.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 3, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/common/chrome_switches.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/common/chrome_switches.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/chrome_switches.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -877,9 +877,6 @@ const char kReloadKilledTabs[]              = \""reload-killed-tabs\"";\n // Enable remote debug over HTTP on the specified port.\n const char kRemoteDebuggingPort[]           = \""remote-debugging-port\"";\n \n-// Enable remote debug / automation shell on the specified port.\n-const char kRemoteShellPort[]               = \""remote-shell-port\"";\n-\n // Indicates the last session should be restored on startup. This overrides\n // the preferences value and is primarily intended for testing. The value of\n // this switch is the number of tabs to wait until loaded before""}<_**next**_>{""sha"": ""3ef16d6c21feaf47dd978af130a3b353dc9cc954"", ""filename"": ""chrome/common/chrome_switches.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 1, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/common/chrome_switches.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/common/chrome_switches.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/common/chrome_switches.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -240,7 +240,6 @@ extern const char kProxyServer[];\n extern const char kPurgeMemoryButton[];\n extern const char kReloadKilledTabs[];\n extern const char kRemoteDebuggingPort[];\n-extern const char kRemoteShellPort[];\n extern const char kRestoreLastSession[];\n extern const char kRestrictInstantToSearch[];\n extern const char kSbInfoURLPrefix[];""}<_**next**_>{""sha"": ""770f6ae9b6698e2a3332354c8b9abb036af12173"", ""filename"": ""chrome/renderer/chrome_content_renderer_client.cc"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 4, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/renderer/chrome_content_renderer_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/chrome/renderer/chrome_content_renderer_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/renderer/chrome_content_renderer_client.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -33,8 +33,6 @@\n #include \""chrome/renderer/chrome_render_process_observer.h\""\n #include \""chrome/renderer/chrome_render_view_observer.h\""\n #include \""chrome/renderer/content_settings_observer.h\""\n-#include \""chrome/renderer/devtools_agent.h\""\n-#include \""chrome/renderer/devtools_agent_filter.h\""\n #include \""chrome/renderer/extensions/bindings_utils.h\""\n #include \""chrome/renderer/extensions/event_bindings.h\""\n #include \""chrome/renderer/extensions/extension_dispatcher.h\""\n@@ -165,7 +163,6 @@ void ChromeContentRendererClient::RenderThreadStarted() {\n #endif\n \n   RenderThread* thread = RenderThread::current();\n-  thread->AddFilter(new DevToolsAgentFilter());\n \n   thread->AddObserver(chrome_observer_.get());\n   thread->AddObserver(extension_dispatcher_.get());\n@@ -214,7 +211,6 @@ void ChromeContentRendererClient::RenderThreadStarted() {\n void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {\n   ContentSettingsObserver* content_settings =\n       new ContentSettingsObserver(render_view);\n-  new DevToolsAgent(render_view);\n   new ExtensionHelper(render_view, extension_dispatcher_.get());\n   new PageLoadHistograms(render_view, histogram_snapshots_.get());\n   new PrintWebViewHelper(render_view);""}<_**next**_>{""sha"": ""d93f0f2070b6455063c5447b4a3331ab85a4e09c"", ""filename"": ""content/browser/renderer_host/browser_render_process_host.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/browser/renderer_host/browser_render_process_host.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/browser/renderer_host/browser_render_process_host.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/renderer_host/browser_render_process_host.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -576,6 +576,7 @@ void BrowserRenderProcessHost::PropagateBrowserCommandLineToRenderer(\n     switches::kPpapiOutOfProcess,\n     switches::kRecordMode,\n     switches::kRegisterPepperPlugins,\n+    switches::kRemoteShellPort,\n     switches::kRendererAssertTest,\n #if !defined(OFFICIAL_BUILD)\n     switches::kRendererCheckFalseTest,""}<_**next**_>{""sha"": ""20dca2a52f782de05afc03043399ee8ac289aeff"", ""filename"": ""content/common/content_switches.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/common/content_switches.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/common/content_switches.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/content_switches.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -371,6 +371,9 @@ const char kProfileImportProcess[]          = \""profile-import\"";\n // Register Pepper plugins (see pepper_plugin_registry.cc for its format).\n const char kRegisterPepperPlugins[]         = \""register-pepper-plugins\"";\n \n+// Enable remote debug / automation shell on the specified port.\n+const char kRemoteShellPort[]               = \""remote-shell-port\"";\n+\n // Causes the renderer process to throw an assertion on launch.\n const char kRendererAssertTest[]            = \""renderer-assert-test\"";\n ""}<_**next**_>{""sha"": ""a61a35ba30d402f78bc0af6004c7d1fb2090ceb9"", ""filename"": ""content/common/content_switches.h"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/common/content_switches.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/common/content_switches.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/content_switches.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -120,6 +120,7 @@ extern const char kProcessType[];\n extern const char kProfileImportProcess[];\n extern const char kRecordMode[];\n extern const char kRegisterPepperPlugins[];\n+extern const char kRemoteShellPort[];\n extern const char kRendererAssertTest[];\n extern const char kRendererCmdPrefix[];\n extern const char kRendererCrashTest[];""}<_**next**_>{""sha"": ""64c2f8ae2060f9f3658baaeb62e35b5c1eda69d3"", ""filename"": ""content/content_renderer.gypi"", ""status"": ""modified"", ""additions"": 6, ""deletions"": 0, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/content_renderer.gypi"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/content_renderer.gypi"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/content_renderer.gypi?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -36,6 +36,12 @@\n         'renderer/content_renderer_client.h',\n         'renderer/device_orientation_dispatcher.cc',\n         'renderer/device_orientation_dispatcher.h',\n+        'renderer/devtools_agent.cc',\n+        'renderer/devtools_agent.h',\n+        'renderer/devtools_agent_filter.cc',\n+        'renderer/devtools_agent_filter.h',\n+        'renderer/devtools_client.cc',\n+        'renderer/devtools_client.h',\n         'renderer/external_popup_menu.cc',\n         'renderer/external_popup_menu.h',\n         'renderer/geolocation_dispatcher.cc',""}<_**next**_>{""sha"": ""b1548131164e0c628b03b4831629e28f09258c01"", ""filename"": ""content/renderer/devtools_agent.cc"", ""status"": ""renamed"", ""additions"": 4, ""deletions"": 4, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_agent.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,17 +2,17 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/renderer/devtools_agent.h\""\n+#include \""content/renderer/devtools_agent.h\""\n \n #include <map>\n \n #include \""base/command_line.h\""\n #include \""base/message_loop.h\""\n #include \""base/process.h\""\n #include \""base/string_number_conversions.h\""\n-#include \""chrome/common/chrome_switches.h\""\n-#include \""chrome/renderer/devtools_agent_filter.h\""\n-#include \""chrome/renderer/devtools_client.h\""\n+#include \""content/common/content_switches.h\""\n+#include \""content/renderer/devtools_agent_filter.h\""\n+#include \""content/renderer/devtools_client.h\""\n #include \""content/common/devtools_messages.h\""\n #include \""content/common/view_messages.h\""\n #include \""content/renderer/render_view.h\"""", ""previous_filename"": ""chrome/renderer/devtools_agent.cc""}<_**next**_>{""sha"": ""a1693b52d7440a53da6c94e40e14d0cb54662c0e"", ""filename"": ""content/renderer/devtools_agent.h"", ""status"": ""renamed"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_agent.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#ifndef CHROME_RENDERER_DEVTOOLS_AGENT_H_\n-#define CHROME_RENDERER_DEVTOOLS_AGENT_H_\n+#ifndef CONTENT_RENDERER_DEVTOOLS_AGENT_H_\n+#define CONTENT_RENDERER_DEVTOOLS_AGENT_H_\n #pragma once\n \n #include <map>\n@@ -73,4 +73,4 @@ class DevToolsAgent : public RenderViewObserver,\n   DISALLOW_COPY_AND_ASSIGN(DevToolsAgent);\n };\n \n-#endif  // CHROME_RENDERER_DEVTOOLS_AGENT_H_\n+#endif  // CONTENT_RENDERER_DEVTOOLS_AGENT_H_"", ""previous_filename"": ""chrome/renderer/devtools_agent.h""}<_**next**_>{""sha"": ""4890a36420eda9b95b5d409f327d82942749d61e"", ""filename"": ""content/renderer/devtools_agent_filter.cc"", ""status"": ""renamed"", ""additions"": 2, ""deletions"": 3, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent_filter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent_filter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_agent_filter.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,12 +2,11 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/renderer/devtools_agent_filter.h\""\n+#include \""content/renderer/devtools_agent_filter.h\""\n \n #include \""base/message_loop.h\""\n-#include \""chrome/common/render_messages.h\""\n-#include \""chrome/renderer/devtools_agent.h\""\n #include \""content/common/devtools_messages.h\""\n+#include \""content/renderer/devtools_agent.h\""\n #include \""content/renderer/plugin_channel_host.h\""\n #include \""content/renderer/render_view.h\""\n #include \""third_party/WebKit/Source/WebKit/chromium/public/WebDevToolsAgent.h\"""", ""previous_filename"": ""chrome/renderer/devtools_agent_filter.cc""}<_**next**_>{""sha"": ""05838859de469c4f476ede1c429b40d0943ae272"", ""filename"": ""content/renderer/devtools_agent_filter.h"", ""status"": ""renamed"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent_filter.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_agent_filter.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_agent_filter.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#ifndef CHROME_RENDERER_DEVTOOLS_AGENT_FILTER_H_\n-#define CHROME_RENDERER_DEVTOOLS_AGENT_FILTER_H_\n+#ifndef CONTENT_RENDERER_DEVTOOLS_AGENT_FILTER_H_\n+#define CONTENT_RENDERER_DEVTOOLS_AGENT_FILTER_H_\n #pragma once\n \n #include <string>\n@@ -51,4 +51,4 @@ class DevToolsAgentFilter : public IPC::ChannelProxy::MessageFilter {\n   DISALLOW_COPY_AND_ASSIGN(DevToolsAgentFilter);\n };\n \n-#endif  // CHROME_RENDERER_DEVTOOLS_AGENT_FILTER_H_\n+#endif  // CONTENT_RENDERER_DEVTOOLS_AGENT_FILTER_H_"", ""previous_filename"": ""chrome/renderer/devtools_agent_filter.h""}<_**next**_>{""sha"": ""cdebbba44281cff4f729272d5641f7ec3c601f3f"", ""filename"": ""content/renderer/devtools_client.cc"", ""status"": ""renamed"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_client.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_client.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_client.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,12 +2,12 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#include \""chrome/renderer/devtools_client.h\""\n+#include \""content/renderer/devtools_client.h\""\n \n #include \""base/command_line.h\""\n #include \""base/message_loop.h\""\n #include \""base/utf_string_conversions.h\""\n-#include \""chrome/common/chrome_switches.h\""\n+#include \""content/common/content_switches.h\""\n #include \""content/common/devtools_messages.h\""\n #include \""content/renderer/render_thread.h\""\n #include \""content/renderer/render_view.h\"""", ""previous_filename"": ""chrome/renderer/devtools_client.cc""}<_**next**_>{""sha"": ""d00d33f4035fbc82ef540b00f7e2fb547c759805"", ""filename"": ""content/renderer/devtools_client.h"", ""status"": ""renamed"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_client.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/devtools_client.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/devtools_client.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style license that can be\n // found in the LICENSE file.\n \n-#ifndef CHROME_RENDERER_DEVTOOLS_CLIENT_H_\n-#define CHROME_RENDERER_DEVTOOLS_CLIENT_H_\n+#ifndef CONTENT_RENDERER_DEVTOOLS_CLIENT_H_\n+#define CONTENT_RENDERER_DEVTOOLS_CLIENT_H_\n #pragma once\n \n #include <string>\n@@ -62,4 +62,4 @@ class DevToolsClient : public RenderViewObserver,\n   DISALLOW_COPY_AND_ASSIGN(DevToolsClient);\n };\n \n-#endif  // CHROME_RENDERER_DEVTOOLS_CLIENT_H_\n+#endif  // CONTENT_RENDERER_DEVTOOLS_CLIENT_H_"", ""previous_filename"": ""chrome/renderer/devtools_client.h""}<_**next**_>{""sha"": ""ba95709592052ee4aac890d5942567c9ca3262a8"", ""filename"": ""content/renderer/render_thread.cc"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_thread.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_thread.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_thread.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -34,6 +34,7 @@\n #include \""content/common/web_database_observer_impl.h\""\n #include \""content/plugin/npobject_util.h\""\n #include \""content/renderer/content_renderer_client.h\""\n+#include \""content/renderer/devtools_agent_filter.h\""\n #include \""content/renderer/gpu/gpu_channel_host.h\""\n #include \""content/renderer/indexed_db_dispatcher.h\""\n #include \""content/renderer/media/audio_input_message_filter.h\""\n@@ -183,6 +184,9 @@ void RenderThread::Init() {\n   audio_message_filter_ = new AudioMessageFilter();\n   AddFilter(audio_message_filter_.get());\n \n+  devtools_agent_message_filter_ = new DevToolsAgentFilter();\n+  AddFilter(devtools_agent_message_filter_.get());\n+\n   content::GetContentClient()->renderer()->RenderThreadStarted();\n \n   TRACE_EVENT_END_ETW(\""RenderThread::Init\"", 0, \""\"");\n@@ -197,6 +201,9 @@ RenderThread::~RenderThread() {\n     web_database_observer_impl_->WaitForAllDatabasesToClose();\n \n   // Shutdown in reverse of the initialization order.\n+  RemoveFilter(devtools_agent_message_filter_.get());\n+  devtools_agent_message_filter_ = NULL;\n+\n   RemoveFilter(audio_input_message_filter_.get());\n   audio_input_message_filter_ = NULL;\n ""}<_**next**_>{""sha"": ""d8042c93d5b99f83404af8de069859d95ae355d7"", ""filename"": ""content/renderer/render_thread.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 0, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_thread.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_thread.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_thread.h?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -25,6 +25,7 @@ class AppCacheDispatcher;\n class AudioInputMessageFilter;\n class AudioMessageFilter;\n class DBMessageFilter;\n+class DevToolsAgentFilter;\n class FilePath;\n class GpuChannelHost;\n class IndexedDBDispatcher;\n@@ -264,6 +265,7 @@ class RenderThread : public RenderThreadBase,\n   scoped_refptr<DBMessageFilter> db_message_filter_;\n   scoped_refptr<AudioInputMessageFilter> audio_input_message_filter_;\n   scoped_refptr<AudioMessageFilter> audio_message_filter_;\n+  scoped_refptr<DevToolsAgentFilter> devtools_agent_message_filter_;\n \n   // Used on multiple threads.\n   scoped_refptr<VideoCaptureImplManager> vc_manager_;""}<_**next**_>{""sha"": ""1eeeb773153494d3cd70102a1a9d02fc0e50842a"", ""filename"": ""content/renderer/render_view.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 0, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_view.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/8262245d384be025f13e2a5b3a03b7e5c98374ce/content/renderer/render_view.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view.cc?ref=8262245d384be025f13e2a5b3a03b7e5c98374ce"", ""patch"": ""@@ -40,6 +40,7 @@\n #include \""content/common/url_constants.h\""\n #include \""content/common/view_messages.h\""\n #include \""content/renderer/content_renderer_client.h\""\n+#include \""content/renderer/devtools_agent.h\""\n #include \""content/renderer/device_orientation_dispatcher.h\""\n #include \""content/renderer/mhtml_generator.h\""\n #include \""content/renderer/external_popup_menu.h\""\n@@ -409,6 +410,8 @@ RenderView::RenderView(RenderThreadBase* render_thread,\n \n   new MHTMLGenerator(this);\n \n+  new DevToolsAgent(this);\n+\n   if (command_line.HasSwitch(switches::kEnableMediaStream)) {\n     media_stream_impl_ = new MediaStreamImpl(\n         RenderThread::current()->video_capture_impl_manager());""}","void RenderView::queryStorageUsageAndQuota(
    WebFrame* frame,
    WebStorageQuotaType type,
    WebStorageQuotaCallbacks* callbacks) {
  DCHECK(frame);
  WebSecurityOrigin origin = frame->document().securityOrigin();
  if (origin.isEmpty()) {
    callbacks->didFail(WebKit::WebStorageQuotaErrorAbort);
    return;
  }
  ChildThread::current()->quota_dispatcher()->QueryStorageUsageAndQuota(
      GURL(origin.toString()), type, callbacks);
}
","void RenderView::queryStorageUsageAndQuota(
    WebFrame* frame,
    WebStorageQuotaType type,
    WebStorageQuotaCallbacks* callbacks) {
  DCHECK(frame);
  WebSecurityOrigin origin = frame->document().securityOrigin();
  if (origin.isEmpty()) {
    callbacks->didFail(WebKit::WebStorageQuotaErrorAbort);
    return;
  }
  ChildThread::current()->quota_dispatcher()->QueryStorageUsageAndQuota(
      GURL(origin.toString()), type, callbacks);
}
",C,,,,"@@ -40,6 +40,7 @@
 #include ""content/common/url_constants.h""
 #include ""content/common/view_messages.h""
 #include ""content/renderer/content_renderer_client.h""
+#include ""content/renderer/devtools_agent.h""
 #include ""content/renderer/device_orientation_dispatcher.h""
 #include ""content/renderer/mhtml_generator.h""
 #include ""content/renderer/external_popup_menu.h""
@@ -409,6 +410,8 @@ RenderView::RenderView(RenderThreadBase* render_thread,
 
   new MHTMLGenerator(this);
 
+  new DevToolsAgent(this);
+
   if (command_line.HasSwitch(switches::kEnableMediaStream)) {
     media_stream_impl_ = new MediaStreamImpl(
         RenderThread::current()->video_capture_impl_manager());",Chrome,8262245d384be025f13e2a5b3a03b7e5c98374ce,2469a22063c3539147f55fe899a8dabc12901c01,0,"void RenderView::queryStorageUsageAndQuota(
    WebFrame* frame,
    WebStorageQuotaType type,
    WebStorageQuotaCallbacks* callbacks) {
  DCHECK(frame);
  WebSecurityOrigin origin = frame->document().securityOrigin();
  if (origin.isEmpty()) {
    // Uninitialized document?
    callbacks->didFail(WebKit::WebStorageQuotaErrorAbort);
    return;
  }
  ChildThread::current()->quota_dispatcher()->QueryStorageUsageAndQuota(
      GURL(origin.toString()), type, callbacks);
}
"
104399,,Remote,Not required,Partial,CVE-2011-2828,https://www.cvedetails.com/cve/CVE-2011-2828/,CWE-119,Low,Partial,Partial,,2011-08-29,7.5,"Google V8, as used in Google Chrome before 13.0.782.215, allows remote attackers to cause a denial of service or possibly have unspecified other impact via unknown vectors that trigger an out-of-bounds write.",2017-09-18,DoS Overflow ,0,https://github.com/chromium/chromium/commit/abbd2f4b36da8c89e6f3002eb84f60064a6ff067,abbd2f4b36da8c89e6f3002eb84f60064a6ff067,"ntp4: show larger favicons in most visited page

extend favicon source to provide larger icons. For now, larger means at most 32x32. Also, the only icon we actually support at this resolution is the default (globe).

BUG=none
TEST=manual

Review URL: http://codereview.chromium.org/7300017

git-svn-id: svn://svn.chromium.org/chrome/trunk/src@91517 0039d316-1c4b-4281-b951-d872f2087c98",0,chrome/browser/ui/webui/favicon_source.cc,"{""sha"": ""575308585216d7e79604b200d849c38d0825978d"", ""filename"": ""chrome/browser/favicon/favicon_service.h"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/favicon/favicon_service.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/favicon/favicon_service.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/favicon/favicon_service.h?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -46,7 +46,8 @@ class FaviconService : public CancelableRequestProvider,\n   typedef CancelableRequest<FaviconDataCallback> GetFaviconRequest;\n \n   // Requests the |icon_type| of favicon. |consumer| is notified when the bits\n-  // have been fetched.\n+  // have been fetched. |icon_url| is the URL of the icon itself, e.g.\n+  // <http://www.google.com/favicon.ico>.\n   Handle GetFavicon(const GURL& icon_url,\n                     history::IconType icon_type,\n                     CancelableRequestConsumerBase* consumer,""}<_**next**_>{""sha"": ""49f0af7d8af0f447d1b7ddec4b721bd67ec86f2a"", ""filename"": ""chrome/browser/resources/ntp4/most_visited_page.css"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 2, ""changes"": 4, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/resources/ntp4/most_visited_page.css"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/resources/ntp4/most_visited_page.css"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/ntp4/most_visited_page.css?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -136,11 +136,11 @@\n \n .most-visited .favicon {\n   background: no-repeat 5px 50%;\n-  background-size: 16px;\n+  background-size: 32px;\n   bottom: 7px;\n   box-sizing: border-box;\n   display: block;\n-  height: 16px;\n+  height: 32px;\n   position: absolute;\n   width: 100%;\n }""}<_**next**_>{""sha"": ""89495effea3a9e5233c2e3720754003e9dac6563"", ""filename"": ""chrome/browser/resources/ntp4/most_visited_page.js"", ""status"": ""modified"", ""additions"": 2, ""deletions"": 1, ""changes"": 3, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/resources/ntp4/most_visited_page.js"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/resources/ntp4/most_visited_page.js"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/resources/ntp4/most_visited_page.js?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -89,7 +89,8 @@ cr.define('ntp4', function() {\n       this.classList.remove('filler');\n \n       var faviconDiv = this.querySelector('.favicon');\n-      var faviconUrl = data.faviconUrl || 'chrome://favicon/' + data.url;\n+      var faviconUrl = data.faviconUrl ||\n+          'chrome://favicon/size/32/' + data.url;\n       faviconDiv.style.backgroundImage = url(faviconUrl);\n       faviconDiv.dir = data.direction;\n       if (data.faviconDominantColor)""}<_**next**_>{""sha"": ""7b66fb737e2d935253c043e34b555944c3d520dd"", ""filename"": ""chrome/browser/ui/webui/favicon_source.cc"", ""status"": ""modified"", ""additions"": 35, ""deletions"": 7, ""changes"": 42, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/favicon_source.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/favicon_source.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/webui/favicon_source.cc?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -29,12 +29,12 @@ void FaviconSource::StartDataRequest(const std::string& path,\n   FaviconService* favicon_service =\n       profile_->GetFaviconService(Profile::EXPLICIT_ACCESS);\n   if (favicon_service) {\n-    FaviconService::Handle handle;\n     if (path.empty()) {\n       SendDefaultResponse(request_id);\n       return;\n     }\n \n+    FaviconService::Handle handle;\n     if (path.size() > 8 && path.substr(0, 8) == \""iconurl/\"") {\n       // TODO : Change GetFavicon to support combination of IconType.\n       handle = favicon_service->GetFavicon(\n@@ -43,8 +43,24 @@ void FaviconSource::StartDataRequest(const std::string& path,\n           &cancelable_consumer_,\n           NewCallback(this, &FaviconSource::OnFaviconDataAvailable));\n     } else {\n+      GURL url;\n+\n+      if (path.size() > 5 && path.substr(0, 5) == \""size/\"") {\n+        size_t slash = path.find(\""/\"", 5);\n+        std::string size = path.substr(5, slash - 5);\n+        int pixel_size = atoi(size.c_str());\n+        CHECK(pixel_size == 32 || pixel_size == 16) <<\n+            \""only 32x32 and 16x16 icons are supported\"";\n+        request_size_map_[request_id] = pixel_size;\n+        url = GURL(path.substr(slash + 1));\n+      } else {\n+        request_size_map_[request_id] = 16;\n+        url = GURL(path);\n+      }\n+\n+      // TODO(estade): fetch the requested size.\n       handle = favicon_service->GetFaviconForURL(\n-          GURL(path),\n+          url,\n           icon_types_,\n           &cancelable_consumer_,\n           NewCallback(this, &FaviconSource::OnFaviconDataAvailable));\n@@ -85,11 +101,23 @@ void FaviconSource::OnFaviconDataAvailable(\n }\n \n void FaviconSource::SendDefaultResponse(int request_id) {\n-  if (!default_favicon_.get()) {\n-    default_favicon_ =\n-        ResourceBundle::GetSharedInstance().LoadDataResourceBytes(\n-            IDR_DEFAULT_FAVICON);\n+  RefCountedMemory* bytes = NULL;\n+  if (request_size_map_[request_id] == 32) {\n+    if (!default_favicon_large_.get()) {\n+      default_favicon_large_ =\n+          ResourceBundle::GetSharedInstance().LoadDataResourceBytes(\n+              IDR_DEFAULT_LARGE_FAVICON);\n+    }\n+    bytes = default_favicon_large_;\n+  } else {\n+    if (!default_favicon_.get()) {\n+      default_favicon_ =\n+          ResourceBundle::GetSharedInstance().LoadDataResourceBytes(\n+              IDR_DEFAULT_FAVICON);\n+    }\n+    bytes = default_favicon_;\n   }\n+  request_size_map_.erase(request_id);\n \n-  SendResponse(request_id, default_favicon_);\n+  SendResponse(request_id, bytes);\n }""}<_**next**_>{""sha"": ""1692d962501516b6cc5a25b2ad219a74b70e699f"", ""filename"": ""chrome/browser/ui/webui/favicon_source.h"", ""status"": ""modified"", ""additions"": 7, ""deletions"": 0, ""changes"": 7, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/favicon_source.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/favicon_source.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/webui/favicon_source.h?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -54,9 +54,16 @@ class FaviconSource : public ChromeURLDataManager::DataSource {\n   Profile* profile_;\n   CancelableRequestConsumerT<int, 0> cancelable_consumer_;\n \n+  // Map from request ID to size requested (in pixels). TODO(estade): Get rid of\n+  // this map when we properly support multiple favicon sizes.\n+  std::map<int, int> request_size_map_;\n+\n   // Raw PNG representation of the favicon to show when the favicon\n   // database doesn't have a favicon for a webpage.\n+  // 16x16\n   scoped_refptr<RefCountedMemory> default_favicon_;\n+  // 32x32\n+  scoped_refptr<RefCountedMemory> default_favicon_large_;\n \n   // The history::IconTypes of icon that this FaviconSource handles.\n   const int icon_types_;""}<_**next**_>{""sha"": ""72466c4e3b6da7625aef726d45d2d473dfcc9c26"", ""filename"": ""chrome/browser/ui/webui/ntp/favicon_webui_handler.cc"", ""status"": ""modified"", ""additions"": 11, ""deletions"": 8, ""changes"": 19, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/ntp/favicon_webui_handler.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/chrome/browser/ui/webui/ntp/favicon_webui_handler.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/chrome/browser/ui/webui/ntp/favicon_webui_handler.cc?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -28,9 +28,9 @@ void FaviconWebUIHandler::RegisterMessages() {\n void FaviconWebUIHandler::HandleGetFaviconDominantColor(const ListValue* args) {\n   std::string path;\n   CHECK(args->GetString(0, &path));\n-  DCHECK(StartsWithASCII(path, \""chrome://favicon/\"", false)) << \""path is \""\n-                                                            << path;\n-  path = path.substr(arraysize(\""chrome://favicon/\"") - 1);\n+  DCHECK(StartsWithASCII(path, \""chrome://favicon/size/32/\"", false)) <<\n+      \""path is \"" << path;\n+  path = path.substr(arraysize(\""chrome://favicon/size/32/\"") - 1);\n \n   double id;\n   CHECK(args->GetDouble(1, &id));\n@@ -54,11 +54,11 @@ void FaviconWebUIHandler::OnFaviconDataAvailable(\n   FaviconService* favicon_service =\n       web_ui_->GetProfile()->GetFaviconService(Profile::EXPLICIT_ACCESS);\n   int id = consumer_.GetClientData(favicon_service, request_handle);\n+  FundamentalValue id_value(id);\n+  scoped_ptr<StringValue> color_value;\n \n   if (favicon.is_valid()) {\n     // TODO(estade): cache the response\n-    FundamentalValue id_value(id);\n-\n     color_utils::GridSampler sampler;\n     SkColor color =\n         color_utils::CalculateKMeanColorOfPNG(favicon.image_data, 100, 665,\n@@ -67,8 +67,11 @@ void FaviconWebUIHandler::OnFaviconDataAvailable(\n                                                SkColorGetR(color),\n                                                SkColorGetG(color),\n                                                SkColorGetB(color));\n-    StringValue color_value(css_color);\n-    web_ui_->CallJavascriptFunction(\""ntp4.setFaviconDominantColor\"",\n-                                    id_value, color_value);\n+    color_value.reset(new StringValue(css_color));\n+  } else {\n+    color_value.reset(new StringValue(\""#919191\""));\n   }\n+\n+  web_ui_->CallJavascriptFunction(\""ntp4.setFaviconDominantColor\"",\n+                                  id_value, *color_value);\n }""}<_**next**_>{""sha"": ""15dfaac62a404b199acfd3fae928e8c508bb4cfd"", ""filename"": ""ui/resources/ui_resources.grd"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 0, ""changes"": 1, ""blob_url"": ""https://github.com/chromium/chromium/blob/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/ui/resources/ui_resources.grd"", ""raw_url"": ""https://github.com/chromium/chromium/raw/abbd2f4b36da8c89e6f3002eb84f60064a6ff067/ui/resources/ui_resources.grd"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/ui/resources/ui_resources.grd?ref=abbd2f4b36da8c89e6f3002eb84f60064a6ff067"", ""patch"": ""@@ -30,6 +30,7 @@\n       <include name=\""IDR_CONTENT_RIGHT_SIDE\"" file=\""content_right_side.png\"" type=\""BINDATA\"" />\n       <if expr=\""not pp_ifdef('touchui')\"">\n         <include name=\""IDR_DEFAULT_FAVICON\"" file=\""default_favicon.png\"" type=\""BINDATA\"" />\n+        <include name=\""IDR_DEFAULT_LARGE_FAVICON\"" file=\""default_large_favicon.png\"" type=\""BINDATA\"" />\n       </if>\n       <if expr=\""pp_ifdef('touchui')\"">\n         <include name=\""IDR_DEFAULT_FAVICON\"" file=\""default_large_favicon.png\"" type=\""BINDATA\"" />""}","std::string FaviconSource::GetMimeType(const std::string&) const {
  return ""image/png"";
}
","std::string FaviconSource::GetMimeType(const std::string&) const {
  return ""image/png"";
}
",C,,,,"@@ -29,12 +29,12 @@ void FaviconSource::StartDataRequest(const std::string& path,
   FaviconService* favicon_service =
       profile_->GetFaviconService(Profile::EXPLICIT_ACCESS);
   if (favicon_service) {
-    FaviconService::Handle handle;
     if (path.empty()) {
       SendDefaultResponse(request_id);
       return;
     }
 
+    FaviconService::Handle handle;
     if (path.size() > 8 && path.substr(0, 8) == ""iconurl/"") {
       // TODO : Change GetFavicon to support combination of IconType.
       handle = favicon_service->GetFavicon(
@@ -43,8 +43,24 @@ void FaviconSource::StartDataRequest(const std::string& path,
           &cancelable_consumer_,
           NewCallback(this, &FaviconSource::OnFaviconDataAvailable));
     } else {
+      GURL url;
+
+      if (path.size() > 5 && path.substr(0, 5) == ""size/"") {
+        size_t slash = path.find(""/"", 5);
+        std::string size = path.substr(5, slash - 5);
+        int pixel_size = atoi(size.c_str());
+        CHECK(pixel_size == 32 || pixel_size == 16) <<
+            ""only 32x32 and 16x16 icons are supported"";
+        request_size_map_[request_id] = pixel_size;
+        url = GURL(path.substr(slash + 1));
+      } else {
+        request_size_map_[request_id] = 16;
+        url = GURL(path);
+      }
+
+      // TODO(estade): fetch the requested size.
       handle = favicon_service->GetFaviconForURL(
-          GURL(path),
+          url,
           icon_types_,
           &cancelable_consumer_,
           NewCallback(this, &FaviconSource::OnFaviconDataAvailable));
@@ -85,11 +101,23 @@ void FaviconSource::OnFaviconDataAvailable(
 }
 
 void FaviconSource::SendDefaultResponse(int request_id) {
-  if (!default_favicon_.get()) {
-    default_favicon_ =
-        ResourceBundle::GetSharedInstance().LoadDataResourceBytes(
-            IDR_DEFAULT_FAVICON);
+  RefCountedMemory* bytes = NULL;
+  if (request_size_map_[request_id] == 32) {
+    if (!default_favicon_large_.get()) {
+      default_favicon_large_ =
+          ResourceBundle::GetSharedInstance().LoadDataResourceBytes(
+              IDR_DEFAULT_LARGE_FAVICON);
+    }
+    bytes = default_favicon_large_;
+  } else {
+    if (!default_favicon_.get()) {
+      default_favicon_ =
+          ResourceBundle::GetSharedInstance().LoadDataResourceBytes(
+              IDR_DEFAULT_FAVICON);
+    }
+    bytes = default_favicon_;
   }
+  request_size_map_.erase(request_id);
 
-  SendResponse(request_id, default_favicon_);
+  SendResponse(request_id, bytes);
 }",Chrome,abbd2f4b36da8c89e6f3002eb84f60064a6ff067,8ecb8f9598f0b3ee1117e14b5eb6cd020eda6b6a,0,"std::string FaviconSource::GetMimeType(const std::string&) const {
  // We need to explicitly return a mime type, otherwise if the user tries to
  // drag the image they get no extension.
  return ""image/png"";
}
"
17942,,Remote,Not required,Partial,CVE-2016-10708,https://www.cvedetails.com/cve/CVE-2016-10708/,CWE-476,Low,,,,2018-01-21,5.0,"sshd in OpenSSH before 7.4 allows remote attackers to cause a denial of service (NULL pointer dereference and daemon crash) via an out-of-sequence NEWKEYS message, as demonstrated by Honggfuzz, related to kex.c and packet.c.",2019-06-26,DoS,0,https://anongit.mindrot.org/openssh.git/commit/?id=28652bca29046f62c7045e933e6b931de1d16737,28652bca29046f62c7045e933e6b931de1d16737,,0,,,"choose_enc(struct sshenc *enc, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_CIPHER_ALG_MATCH;
	if ((enc->cipher = cipher_by_name(name)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	enc->name = name;
	enc->enabled = 0;
	enc->iv = NULL;
	enc->iv_len = cipher_ivlen(enc->cipher);
	enc->key = NULL;
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
	return 0;
}
","choose_enc(struct sshenc *enc, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_CIPHER_ALG_MATCH;
	if ((enc->cipher = cipher_by_name(name)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	enc->name = name;
	enc->enabled = 0;
	enc->iv = NULL;
	enc->iv_len = cipher_ivlen(enc->cipher);
	enc->key = NULL;
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
	return 0;
}
",C,,,492710894acfcc2f173d14d1d45bd2e688df605d,"@@ -1,4 +1,4 @@
-/* $OpenBSD: kex.c,v 1.121 2016/09/12 23:31:27 djm Exp $ */
+/* $OpenBSD: kex.c,v 1.122 2016/09/19 19:02:19 markus Exp $ */
 /*
  * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.
  *
@@ -425,6 +425,8 @@ kex_input_newkeys(int type, u_int32_t seq, void *ctxt)
 	ssh_dispatch_set(ssh, SSH2_MSG_NEWKEYS, &kex_protocol_error);
 	if ((r = sshpkt_get_end(ssh)) != 0)
 		return r;
+	if ((r = ssh_set_newkeys(ssh, MODE_IN)) != 0)
+		return r;
 	kex->done = 1;
 	sshbuf_reset(kex->peer);
 	/* sshbuf_reset(kex->my); */",mindrot,https://anongit.mindrot.org/openssh.git/tree/kex.c?id=28652bca29046f62c7045e933e6b931de1d16737,https://anongit.mindrot.org/openssh.git/tree/kex.c?id=492710894acfcc2f173d14d1d45bd2e688df605d,0,"choose_enc(struct sshenc *enc, char *client, char *server)
{
	char *name = match_list(client, server, NULL);

	if (name == NULL)
		return SSH_ERR_NO_CIPHER_ALG_MATCH;
	if ((enc->cipher = cipher_by_name(name)) == NULL)
		return SSH_ERR_INTERNAL_ERROR;
	enc->name = name;
	enc->enabled = 0;
	enc->iv = NULL;
	enc->iv_len = cipher_ivlen(enc->cipher);
	enc->key = NULL;
	enc->key_len = cipher_keylen(enc->cipher);
	enc->block_size = cipher_blocksize(enc->cipher);
	return 0;
}
"
152489,,Remote,Not required,Partial,CVE-2017-5019,https://www.cvedetails.com/cve/CVE-2017-5019/,CWE-416,Medium,Partial,Partial,,2017-02-17,6.8,"A use after free in Google Chrome prior to 56.0.2924.76 for Linux, Windows and Mac, and 56.0.2924.87 for Android, allowed a remote attacker to potentially exploit heap corruption via a crafted HTML page.",2018-01-04,,0,https://github.com/chromium/chromium/commit/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,"Convert FrameHostMsg_DidAddMessageToConsole to Mojo.

Note: Since this required changing the test
RenderViewImplTest.DispatchBeforeUnloadCanDetachFrame, I manually
re-introduced https://crbug.com/666714 locally (the bug the test was
added for), and reran the test to confirm that it still covers the bug.

Bug: 786836
Change-Id: I110668fa6f0f261fd2ac36bb91a8d8b31c99f4f1
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1526270
Commit-Queue: Lowell Manners <lowell@chromium.org>
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Camille Lamy <clamy@chromium.org>
Cr-Commit-Position: refs/heads/master@{#653137}",0,content/renderer/render_frame_impl.cc,"{""sha"": ""f2bd60be6f35037de28774456df91833dd753f20"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.cc"", ""status"": ""modified"", ""additions"": 23, ""deletions"": 11, ""changes"": 34, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1375,8 +1375,6 @@ bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n \n   handled = true;\n   IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg)\n-    IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,\n-                        OnDidAddMessageToConsole)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n     IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n@@ -1833,21 +1831,35 @@ void RenderFrameHostImpl::OnAudibleStateChanged(bool is_audible) {\n   is_audible_ = is_audible;\n }\n \n-void RenderFrameHostImpl::OnDidAddMessageToConsole(\n-    int32_t level,\n+void RenderFrameHostImpl::DidAddMessageToConsole(\n+    blink::mojom::ConsoleMessageLevel log_level,\n     const base::string16& message,\n     int32_t line_no,\n     const base::string16& source_id) {\n-  if (level < logging::LOG_VERBOSE || level > logging::LOG_FATAL) {\n-    bad_message::ReceivedBadMessage(\n-        GetProcess(), bad_message::RFH_DID_ADD_CONSOLE_MESSAGE_BAD_SEVERITY);\n-    return;\n+  // TODO(https://crbug.com/786836): Update downstream code to use\n+  // ConsoleMessageLevel everywhere to avoid this conversion.\n+  logging::LogSeverity log_severity = logging::LOG_VERBOSE;\n+  switch (log_level) {\n+    case blink::mojom::ConsoleMessageLevel::kVerbose:\n+      log_severity = logging::LOG_VERBOSE;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kInfo:\n+      log_severity = logging::LOG_INFO;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kWarning:\n+      log_severity = logging::LOG_WARNING;\n+      break;\n+    case blink::mojom::ConsoleMessageLevel::kError:\n+      log_severity = logging::LOG_ERROR;\n+      break;\n   }\n \n-  if (delegate_->DidAddMessageToConsole(level, message, line_no, source_id))\n+  if (delegate_->DidAddMessageToConsole(log_severity, message, line_no,\n+                                        source_id)) {\n     return;\n+  }\n \n-  // Pass through log level only on builtin components pages to limit console\n+  // Pass through log severity only on builtin components pages to limit console\n   // spew.\n   const bool is_builtin_component =\n       HasWebUIScheme(delegate_->GetMainFrameLastCommittedURL()) ||\n@@ -1856,7 +1868,7 @@ void RenderFrameHostImpl::OnDidAddMessageToConsole(\n   const bool is_off_the_record =\n       GetSiteInstance()->GetBrowserContext()->IsOffTheRecord();\n \n-  LogConsoleMessage(level, message, line_no, is_builtin_component,\n+  LogConsoleMessage(log_severity, message, line_no, is_builtin_component,\n                     is_off_the_record, source_id);\n }\n ""}<_**next**_>{""sha"": ""bee010704ea0be084eb5752717d8dcaeb46c04c0"", ""filename"": ""content/browser/frame_host/render_frame_host_impl.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 4, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/frame_host/render_frame_host_impl.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/frame_host/render_frame_host_impl.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1049,10 +1049,6 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   class DroppedInterfaceRequestLogger;\n \n   // IPC Message handlers.\n-  void OnDidAddMessageToConsole(int32_t level,\n-                                const base::string16& message,\n-                                int32_t line_no,\n-                                const base::string16& source_id);\n   void OnDetach();\n   void OnFrameFocused();\n   void OnOpenURL(const FrameHostMsg_OpenURL_Params& params);\n@@ -1206,6 +1202,11 @@ class CONTENT_EXPORT RenderFrameHostImpl\n   void FullscreenStateChanged(bool is_fullscreen) override;\n   void DocumentOnLoadCompleted() override;\n   void UpdateActiveSchedulerTrackedFeatures(uint64_t features_mask) override;\n+  void DidAddMessageToConsole(blink::mojom::ConsoleMessageLevel log_level,\n+                              const base::string16& message,\n+                              int32_t line_no,\n+                              const base::string16& source_id) override;\n+\n #if defined(OS_ANDROID)\n   void UpdateUserGestureCarryoverInfo() override;\n #endif""}<_**next**_>{""sha"": ""35ad6ce3ce3aca5a9e47d54a8bcf1b3f381a00b5"", ""filename"": ""content/browser/service_worker/service_worker_context_core.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/service_worker/service_worker_context_core.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/browser/service_worker/service_worker_context_core.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/browser/service_worker/service_worker_context_core.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -786,7 +786,7 @@ void ServiceWorkerContextCore::OnReportConsoleMessage(\n     const GURL& source_url) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   // NOTE: This differs slightly from\n-  // RenderFrameHostImpl::OnDidAddMessageToConsole, which also asks the\n+  // RenderFrameHostImpl::DidAddMessageToConsole, which also asks the\n   // content embedder whether to classify the message as a builtin component.\n   // This is called on the IO thread, though, so we can't easily get a\n   // BrowserContext and call ContentBrowserClient::IsBuiltinComponent().""}<_**next**_>{""sha"": ""88471bc49cd5b00a9494cc3998ba9c44c2c87088"", ""filename"": ""content/common/frame.mojom"", ""status"": ""modified"", ""additions"": 9, ""deletions"": 0, ""changes"": 9, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame.mojom"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame.mojom"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/frame.mojom?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -21,6 +21,7 @@ import \""services/service_manager/public/mojom/interface_provider.mojom\"";\n import \""services/viz/public/interfaces/compositing/surface_id.mojom\"";\n import \""third_party/blink/public/mojom/blob/blob_url_store.mojom\"";\n import \""third_party/blink/public/mojom/commit_result/commit_result.mojom\"";\n+import \""third_party/blink/public/mojom/devtools/console_message.mojom\"";\n import \""third_party/blink/public/mojom/feature_policy/feature_policy.mojom\"";\n import \""third_party/blink/public/mojom/frame/lifecycle.mojom\"";\n import \""third_party/blink/public/mojom/frame/navigation_initiator.mojom\"";\n@@ -473,4 +474,12 @@ interface FrameHost {\n   // of the individual bits.\n   // TODO(altimin): Move into a separate scheduling interface.\n   UpdateActiveSchedulerTrackedFeatures(uint64 features_mask);\n+\n+  // Blink and JavaScript error messages to log to the console or debugger UI.\n+  DidAddMessageToConsole(\n+      blink.mojom.ConsoleMessageLevel log_level,\n+      mojo_base.mojom.BigString16 msg,\n+      int32 line_number,\n+      mojo_base.mojom.String16 source_id);\n+\n };""}<_**next**_>{""sha"": ""aa3530d1912f804ba01a29be9b4b2178ce996e86"", ""filename"": ""content/common/frame_messages.h"", ""status"": ""modified"", ""additions"": 0, ""deletions"": 8, ""changes"": 8, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame_messages.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/common/frame_messages.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/common/frame_messages.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -1098,14 +1098,6 @@ IPC_MESSAGE_ROUTED0(FrameMsg_RenderFallbackContent)\n // -----------------------------------------------------------------------------\n // Messages sent from the renderer to the browser.\n \n-// Blink and JavaScript error messages to log to the console\n-// or debugger UI.\n-IPC_MESSAGE_ROUTED4(FrameHostMsg_DidAddMessageToConsole,\n-                    int32_t,        /* log level */\n-                    base::string16, /* msg */\n-                    int32_t,        /* line number */\n-                    base::string16 /* source id */)\n-\n // Sent by the renderer when a child frame is created in the renderer.\n //\n // Each of these messages will have a corresponding FrameHostMsg_Detach message""}<_**next**_>{""sha"": ""d103dd35fa8ce0773f0c3586d17beb2eaeaf8479"", ""filename"": ""content/renderer/render_frame_impl.cc"", ""status"": ""modified"", ""additions"": 3, ""deletions"": 3, ""changes"": 6, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_frame_impl.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_frame_impl.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_frame_impl.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -4545,9 +4545,9 @@ void RenderFrameImpl::DidAddMessageToConsole(\n     }\n   }\n \n-  Send(new FrameHostMsg_DidAddMessageToConsole(\n-      routing_id_, static_cast<int32_t>(log_severity), message.text.Utf16(),\n-      static_cast<int32_t>(source_line), source_name.Utf16()));\n+  GetFrameHost()->DidAddMessageToConsole(message.level, message.text.Utf16(),\n+                                         static_cast<int32_t>(source_line),\n+                                         source_name.Utf16());\n }\n \n void RenderFrameImpl::DownloadURL(""}<_**next**_>{""sha"": ""2c754dc7c905037b40d841c22103659b8a9cba35"", ""filename"": ""content/renderer/render_view_browsertest.cc"", ""status"": ""modified"", ""additions"": 20, ""deletions"": 44, ""changes"": 64, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_view_browsertest.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/renderer/render_view_browsertest.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/renderer/render_view_browsertest.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -4,6 +4,7 @@\n \n #include <stddef.h>\n #include <stdint.h>\n+\n #include <tuple>\n \n #include \""base/bind.h\""\n@@ -17,6 +18,7 @@\n #include \""base/stl_util.h\""\n #include \""base/strings/string_util.h\""\n #include \""base/strings/utf_string_conversions.h\""\n+#include \""base/test/bind_test_util.h\""\n #include \""base/threading/thread_task_runner_handle.h\""\n #include \""base/time/time.h\""\n #include \""base/values.h\""\n@@ -2486,62 +2488,36 @@ TEST_F(RenderViewImplTest, HistoryIsProperlyUpdatedOnShouldClearHistoryList) {\n                    view()->HistoryForwardListCount() + 1);\n }\n \n-// IPC Listener that runs a callback when a console.log() is executed from\n-// javascript.\n-class ConsoleCallbackFilter : public IPC::Listener {\n- public:\n-  explicit ConsoleCallbackFilter(\n-      base::Callback<void(const base::string16&)> callback)\n-      : callback_(callback) {}\n-\n-  bool OnMessageReceived(const IPC::Message& msg) override {\n-    bool handled = true;\n-    IPC_BEGIN_MESSAGE_MAP(ConsoleCallbackFilter, msg)\n-      IPC_MESSAGE_HANDLER(FrameHostMsg_DidAddMessageToConsole,\n-                          OnDidAddMessageToConsole)\n-      IPC_MESSAGE_UNHANDLED(handled = false)\n-    IPC_END_MESSAGE_MAP()\n-    return handled;\n-  }\n-\n-  void OnDidAddMessageToConsole(int32_t,\n-                                const base::string16& message,\n-                                int32_t,\n-                                const base::string16&) {\n-    callback_.Run(message);\n-  }\n-\n- private:\n-  base::Callback<void(const base::string16&)> callback_;\n-};\n-\n // Tests that there's no UaF after dispatchBeforeUnloadEvent.\n // See https://crbug.com/666714.\n TEST_F(RenderViewImplTest, DispatchBeforeUnloadCanDetachFrame) {\n   LoadHTML(\n       \""<script>window.onbeforeunload = function() { \""\n       \""window.console.log('OnBeforeUnload called'); }</script>\"");\n \n-  // Creates a callback that swaps the frame when the 'OnBeforeUnload called'\n+  // Create a callback that swaps the frame when the 'OnBeforeUnload called'\n   // log is printed from the beforeunload handler.\n-  std::unique_ptr<ConsoleCallbackFilter> callback_filter(\n-      new ConsoleCallbackFilter(base::Bind(\n-          [](RenderFrameImpl* frame, const base::string16& msg) {\n-            // Makes sure this happens during the beforeunload handler.\n-            EXPECT_EQ(base::UTF8ToUTF16(\""OnBeforeUnload called\""), msg);\n-\n-            // Swaps the main frame.\n-            frame->OnMessageReceived(FrameMsg_SwapOut(\n-                frame->GetRoutingID(), 1, false, FrameReplicationState()));\n-          },\n-          base::Unretained(frame()))));\n-  render_thread_->sink().AddFilter(callback_filter.get());\n+  base::RunLoop run_loop;\n+  bool was_callback_run = false;\n+  frame()->SetDidAddMessageToConsoleCallback(\n+      base::BindOnce(base::BindLambdaForTesting([&](const base::string16& msg) {\n+        // Makes sure this happens during the beforeunload handler.\n+        EXPECT_EQ(base::UTF8ToUTF16(\""OnBeforeUnload called\""), msg);\n+\n+        // Swaps the main frame.\n+        frame()->OnMessageReceived(FrameMsg_SwapOut(\n+            frame()->GetRoutingID(), 1, false, FrameReplicationState()));\n+\n+        was_callback_run = true;\n+        run_loop.Quit();\n+      })));\n \n-  // Simulates a BeforeUnload IPC received from the browser.\n+  // Simulate a BeforeUnload IPC received from the browser.\n   frame()->OnMessageReceived(\n       FrameMsg_BeforeUnload(frame()->GetRoutingID(), false));\n \n-  render_thread_->sink().RemoveFilter(callback_filter.get());\n+  run_loop.Run();\n+  ASSERT_TRUE(was_callback_run);\n }\n \n // IPC Listener that runs a callback when a javascript modal dialog is""}<_**next**_>{""sha"": ""bdedd20f84277cc35ae59aec5e3cc2b62b75dc33"", ""filename"": ""content/test/test_render_frame.cc"", ""status"": ""modified"", ""additions"": 22, ""deletions"": 0, ""changes"": 22, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_frame.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -47,6 +47,11 @@ class MockFrameHost : public mojom::FrameHost {\n     return std::move(last_document_interface_broker_request_);\n   }\n \n+  void SetDidAddMessageToConsoleCallback(\n+      base::OnceCallback<void(const base::string16& msg)> callback) {\n+    did_add_message_to_console_callback_ = std::move(callback);\n+  }\n+\n   // Holds on to the request end of the InterfaceProvider interface whose client\n   // end is bound to the corresponding RenderFrame's |remote_interfaces_| to\n   // facilitate retrieving the most recent |interface_provider_request| in\n@@ -156,6 +161,15 @@ class MockFrameHost : public mojom::FrameHost {\n \n   void UpdateActiveSchedulerTrackedFeatures(uint64_t features_mask) override {}\n \n+  void DidAddMessageToConsole(blink::mojom::ConsoleMessageLevel log_level,\n+                              const base::string16& msg,\n+                              int32_t line_number,\n+                              const base::string16& source_id) override {\n+    if (did_add_message_to_console_callback_) {\n+      std::move(did_add_message_to_console_callback_).Run(msg);\n+    }\n+  }\n+\n #if defined(OS_ANDROID)\n   void UpdateUserGestureCarryoverInfo() override {}\n #endif\n@@ -168,6 +182,9 @@ class MockFrameHost : public mojom::FrameHost {\n   blink::mojom::DocumentInterfaceBrokerRequest\n       last_document_interface_broker_request_;\n \n+  base::OnceCallback<void(const base::string16& msg)>\n+      did_add_message_to_console_callback_;\n+\n   DISALLOW_COPY_AND_ASSIGN(MockFrameHost);\n };\n \n@@ -331,6 +348,11 @@ TestRenderFrame::TakeLastCommitParams() {\n   return mock_frame_host_->TakeLastCommitParams();\n }\n \n+void TestRenderFrame::SetDidAddMessageToConsoleCallback(\n+    base::OnceCallback<void(const base::string16& msg)> callback) {\n+  mock_frame_host_->SetDidAddMessageToConsoleCallback(std::move(callback));\n+}\n+\n service_manager::mojom::InterfaceProviderRequest\n TestRenderFrame::TakeLastInterfaceProviderRequest() {\n   return mock_frame_host_->TakeLastInterfaceProviderRequest();""}<_**next**_>{""sha"": ""7d719b24a9a6129485a09cbd2a9b6e3c68493b95"", ""filename"": ""content/test/test_render_frame.h"", ""status"": ""modified"", ""additions"": 5, ""deletions"": 0, ""changes"": 5, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.h"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/content/test/test_render_frame.h"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/content/test/test_render_frame.h?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -68,6 +68,11 @@ class TestRenderFrame : public RenderFrameImpl {\n   std::unique_ptr<FrameHostMsg_DidCommitProvisionalLoad_Params>\n   TakeLastCommitParams();\n \n+  // Sets a callback to be run the next time DidAddMessageToConsole\n+  // is called (e.g. window.console.log() is called).\n+  void SetDidAddMessageToConsoleCallback(\n+      base::OnceCallback<void(const base::string16& msg)> callback);\n+\n   service_manager::mojom::InterfaceProviderRequest\n   TakeLastInterfaceProviderRequest();\n ""}<_**next**_>{""sha"": ""e27564fc7676757363d8d4035d81fdc5e5a1f196"", ""filename"": ""third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""status"": ""modified"", ""additions"": 1, ""deletions"": 1, ""changes"": 2, ""blob_url"": ""https://github.com/chromium/chromium/blob/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""raw_url"": ""https://github.com/chromium/chromium/raw/f03ea5a5c2ff26e239dfd23e263b15da2d9cee93/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc"", ""contents_url"": ""https://api.github.com/repos/chromium/chromium/contents/third_party/blink/renderer/core/frame/navigation_rate_limiter.cc?ref=f03ea5a5c2ff26e239dfd23e263b15da2d9cee93"", ""patch"": ""@@ -44,7 +44,7 @@ bool NavigationRateLimiter::CanProceed() {\n   }\n \n   // Display an error message. Do it only once in a while, else it will flood\n-  // the browser process with the FrameHostMsg_DidAddMessageToConsole IPC.\n+  // the browser process with the DidAddMessageToConsole Mojo call.\n   if (!error_message_sent_) {\n     error_message_sent_ = true;\n     if (auto* local_frame = DynamicTo<LocalFrame>(frame_.Get())) {""}","void RecordSuffixedRendererMemoryMetrics(
    const RenderThreadImpl::RendererMemoryMetrics& memory_metrics,
    base::StringPiece suffix) {
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.PartitionAlloc"",
                                  suffix,
                                  memory_metrics.partition_alloc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.BlinkGC"",
                                  suffix, memory_metrics.blink_gc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Malloc"", suffix,
                                  memory_metrics.malloc_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Discardable"",
                                  suffix, memory_metrics.discardable_kb / 1024);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.V8MainThreadIsolate"", suffix,
      memory_metrics.v8_main_thread_isolate_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.TotalAllocated"",
                                  suffix, memory_metrics.total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.NonDiscardableTotalAllocated"", suffix,
      memory_metrics.non_discardable_total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.TotalAllocatedPerRenderView"", suffix,
      memory_metrics.total_allocated_per_render_view_mb);
}
","void RecordSuffixedRendererMemoryMetrics(
    const RenderThreadImpl::RendererMemoryMetrics& memory_metrics,
    base::StringPiece suffix) {
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.PartitionAlloc"",
                                  suffix,
                                  memory_metrics.partition_alloc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.BlinkGC"",
                                  suffix, memory_metrics.blink_gc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Malloc"", suffix,
                                  memory_metrics.malloc_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Discardable"",
                                  suffix, memory_metrics.discardable_kb / 1024);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.V8MainThreadIsolate"", suffix,
      memory_metrics.v8_main_thread_isolate_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.TotalAllocated"",
                                  suffix, memory_metrics.total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.NonDiscardableTotalAllocated"", suffix,
      memory_metrics.non_discardable_total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.TotalAllocatedPerRenderView"", suffix,
      memory_metrics.total_allocated_per_render_view_mb);
}
",C,,,,"@@ -4545,9 +4545,9 @@ void RenderFrameImpl::DidAddMessageToConsole(
     }
   }
 
-  Send(new FrameHostMsg_DidAddMessageToConsole(
-      routing_id_, static_cast<int32_t>(log_severity), message.text.Utf16(),
-      static_cast<int32_t>(source_line), source_name.Utf16()));
+  GetFrameHost()->DidAddMessageToConsole(message.level, message.text.Utf16(),
+                                         static_cast<int32_t>(source_line),
+                                         source_name.Utf16());
 }
 
 void RenderFrameImpl::DownloadURL(",Chrome,f03ea5a5c2ff26e239dfd23e263b15da2d9cee93,c246049ec1b28d1af4fe3be886ac5904e1762026,0,"void RecordSuffixedRendererMemoryMetrics(
    const RenderThreadImpl::RendererMemoryMetrics& memory_metrics,
    base::StringPiece suffix) {
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.PartitionAlloc"",
                                  suffix,
                                  memory_metrics.partition_alloc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.BlinkGC"",
                                  suffix, memory_metrics.blink_gc_kb / 1024);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Malloc"", suffix,
                                  memory_metrics.malloc_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.Discardable"",
                                  suffix, memory_metrics.discardable_kb / 1024);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.V8MainThreadIsolate"", suffix,
      memory_metrics.v8_main_thread_isolate_mb);
  RecordSuffixedMemoryMBHistogram(""Memory.Experimental.Renderer.TotalAllocated"",
                                  suffix, memory_metrics.total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.NonDiscardableTotalAllocated"", suffix,
      memory_metrics.non_discardable_total_allocated_mb);
  RecordSuffixedMemoryMBHistogram(
      ""Memory.Experimental.Renderer.TotalAllocatedPerRenderView"", suffix,
      memory_metrics.total_allocated_per_render_view_mb);
}
"
