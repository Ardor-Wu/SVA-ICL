"PolkitIdentity * polkit_unix_user_new (gint uid) { return POLKIT_IDENTITY (g_object_new (POLKIT_TYPE_UNIX_USER, ""uid"", uid, NULL)); }"
"static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement) { size_t i; int de, section_index = SECTION_MAKERNOTE; int NumDirEntries, old_motorola_intel; #ifdef KALLE_0 int offset_diff; #endif const maker_note_type *maker_note; char *dir_start; int data_len; for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) { if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) { #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""No maker note data found. Detected maker: %s (length = %d)"", ImageInfo->make, strlen(ImageInfo->make)); #endif return TRUE; } maker_note = maker_note_array+i; if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make))) continue; if (maker_note->model && (!ImageInfo->model || strcmp(maker_note->model, ImageInfo->model))) continue; if (maker_note->id_string && value_len >= maker_note->id_string_len && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len)) continue; break; } if (value_len < 2 || maker_note->offset >= value_len - 1) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X offset 0x%04X"", value_len, maker_note->offset); return FALSE; } dir_start = value_ptr + maker_note->offset; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement)); #endif ImageInfo->sections_found |= FOUND_MAKERNOTE; old_motorola_intel = ImageInfo->motorola_intel; switch (maker_note->byte_order) { case MN_ORDER_INTEL: ImageInfo->motorola_intel = 0; break; case MN_ORDER_MOTOROLA: ImageInfo->motorola_intel = 1; break; default: case MN_ORDER_NORMAL: break; } NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel); switch (maker_note->offset_mode) { case MN_OFFSET_MAKER: offset_base = value_ptr; data_len = value_len; break; #ifdef KALLE_0 case MN_OFFSET_GUESS: if (maker_note->offset + 10 + 4 >= value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X"", value_len); return FALSE; } offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel); #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff); #endif if (offset_diff < 0 || offset_diff >= value_len ) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data bad offset: 0x%04X length 0x%04X"", offset_diff, value_len); return FALSE; } offset_base = value_ptr + offset_diff; data_len = value_len - offset_diff; break; #endif default: case MN_OFFSET_NORMAL: data_len = value_len; break; } if ((2+NumDirEntries*12) > value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len); return FALSE; } if ((dir_start - value_ptr) > value_len - (2+NumDirEntries*12)) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 0x%04X > 0x%04X"", (dir_start - value_ptr) + (2+NumDirEntries*12), value_len); return FALSE; } for (de=0;de<NumDirEntries;de++) { if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de, offset_base, data_len, displacement, section_index, 0, maker_note->tag_table)) { return FALSE; } } ImageInfo->motorola_intel = old_motorola_intel; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE)); #endif return TRUE; }"
"int blk_rq_map_user_iov(struct request_queue *q, struct request *rq, struct rq_map_data *map_data, const struct iov_iter *iter, gfp_t gfp_mask) { bool copy = false; unsigned long align = q->dma_pad_mask | queue_dma_alignment(q); struct bio *bio = NULL; struct iov_iter i; int ret; if (map_data) copy = true; else if (iov_iter_alignment(iter) & align) copy = true; else if (queue_virt_boundary(q)) copy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter); i = *iter; do { ret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy); if (ret) goto unmap_rq; if (!bio) bio = rq->bio; } while (iov_iter_count(&i)); if (!bio_flagged(bio, BIO_USER_MAPPED)) rq->cmd_flags |= REQ_COPY_USER; return 0; unmap_rq: __blk_rq_unmap_user(bio); rq->bio = NULL; return -EINVAL; }"
"static int _dwarf_internal_printlines(Dwarf_Die die, int * err_count_out, int only_line_header, Dwarf_Error * error) { Dwarf_Small *line_ptr = 0; Dwarf_Small *orig_line_ptr = 0; Dwarf_Attribute stmt_list_attr = 0; Dwarf_Attribute comp_dir_attr = 0; Dwarf_Small *comp_dir = NULL; Dwarf_Unsigned line_offset = 0; Dwarf_Half attrform = 0; Dwarf_Small* bogus_bytes_ptr = 0; Dwarf_Unsigned bogus_bytes_count = 0; Dwarf_Half address_size = 0; Dwarf_Unsigned fission_offset = 0; unsigned line_version = 0; Dwarf_Debug dbg = 0; Dwarf_CU_Context cu_context = 0; Dwarf_Line_Context line_context = 0; int resattr = DW_DLV_ERROR; int lres =    DW_DLV_ERROR; int res  =    DW_DLV_ERROR; Dwarf_Small *line_ptr_actuals  = 0; Dwarf_Small *line_ptr_end = 0; Dwarf_Small *section_start = 0; if (error != NULL) { *error = NULL; } CHECK_DIE(die, DW_DLV_ERROR); cu_context = die->di_cu_context; dbg = cu_context->cc_dbg; res = _dwarf_load_section(dbg, &dbg->de_debug_line,error); if (res != DW_DLV_OK) { return res; } if (!dbg->de_debug_line.dss_size) { return (DW_DLV_NO_ENTRY); } address_size = _dwarf_get_address_size(dbg, die); resattr = dwarf_attr(die, DW_AT_stmt_list, &stmt_list_attr, error); if (resattr != DW_DLV_OK) { return resattr; } lres = dwarf_whatform(stmt_list_attr,&attrform,error); if (lres != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return lres; } if (attrform != DW_FORM_data4 && attrform != DW_FORM_data8 && attrform != DW_FORM_sec_offset ) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD); return (DW_DLV_ERROR); } lres = dwarf_global_formref(stmt_list_attr, &line_offset, error); if (lres != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return lres; } if (line_offset >= dbg->de_debug_line.dss_size) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); _dwarf_error(dbg, error, DW_DLE_LINE_OFFSET_BAD); return (DW_DLV_ERROR); } section_start =  dbg->de_debug_line.dss_data; { Dwarf_Unsigned fission_size = 0; int resfis = _dwarf_get_fission_addition_die(die, DW_SECT_LINE, &fission_offset,&fission_size,error); if(resfis != DW_DLV_OK) { dwarf_dealloc(dbg,stmt_list_attr, DW_DLA_ATTR); return resfis; } } orig_line_ptr = section_start + line_offset + fission_offset; line_ptr = orig_line_ptr; dwarf_dealloc(dbg, stmt_list_attr, DW_DLA_ATTR); resattr = dwarf_attr(die, DW_AT_comp_dir, &comp_dir_attr, error); if (resattr == DW_DLV_ERROR) { return resattr; } if (resattr == DW_DLV_OK) { int cres = DW_DLV_ERROR; char *cdir = 0; cres = dwarf_formstring(comp_dir_attr, &cdir, error); if (cres == DW_DLV_ERROR) { return cres; } else if (cres == DW_DLV_OK) { comp_dir = (Dwarf_Small *) cdir; } } if (resattr == DW_DLV_OK) { dwarf_dealloc(dbg, comp_dir_attr, DW_DLA_ATTR); } line_context = (Dwarf_Line_Context) _dwarf_get_alloc(dbg, DW_DLA_LINE_CONTEXT, 1); if (line_context == NULL) { _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL); return (DW_DLV_ERROR); } { Dwarf_Small *newlinep = 0; int dres = _dwarf_read_line_table_header(dbg, cu_context, section_start, line_ptr, dbg->de_debug_line.dss_size, &newlinep, line_context, &bogus_bytes_ptr, &bogus_bytes_count, error, err_count_out); if (dres == DW_DLV_ERROR) { dwarf_srclines_dealloc_b(line_context); return dres; } if (dres == DW_DLV_NO_ENTRY) { dwarf_srclines_dealloc_b(line_context); return dres; } line_ptr_end = line_context->lc_line_ptr_end; line_ptr = newlinep; if (line_context->lc_actuals_table_offset > 0) { line_ptr_actuals = line_context->lc_line_prologue_start + line_context->lc_actuals_table_offset; } } line_version = line_context->lc_version_number; line_context->lc_compilation_directory = comp_dir; if (only_line_header) { dwarf_srclines_dealloc_b(line_context); return DW_DLV_OK; } do_line_print_now(dbg,line_version,comp_dir,line_context); print_include_directory_details(dbg,line_version,line_context); print_file_entry_details(dbg,line_version,line_context); print_experimental_counts(dbg, line_version,line_context); res = print_actuals_and_locals(dbg, line_context, bogus_bytes_count,bogus_bytes_ptr, orig_line_ptr, line_ptr, section_start, line_ptr_actuals, line_ptr_end, address_size, err_count_out, error); if (res  !=  DW_DLV_OK) { return res; } return DW_DLV_OK; }"
"static void decrease_reservation(struct memop_args *a) { unsigned long i, j; xen_pfn_t gmfn; if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done, a->nr_extents-1) || a->extent_order > max_order(current->domain) ) return; for ( i = a->nr_done; i < a->nr_extents; i++ ) { if ( i != a->nr_done && hypercall_preempt_check() ) { a->preempted = 1; goto out; } if ( unlikely(__copy_from_guest_offset(&gmfn, a->extent_list, i, 1)) ) goto out; if ( tb_init_done ) { struct { u64 gfn; int d:16,order:16; } t; t.gfn = gmfn; t.d = a->domain->domain_id; t.order = a->extent_order; __trace_var(TRC_MEM_DECREASE_RESERVATION, 0, sizeof(t), &t); } if ( is_hvm_domain(a->domain) && p2m_pod_decrease_reservation(a->domain, gmfn, a->extent_order) ) continue; for ( j = 0; j < (1 << a->extent_order); j++ ) if ( !guest_remove_page(a->domain, gmfn + j) ) goto out; } out: a->nr_done = i; }"
void OPENSSL_fork_child(void) { rand_fork(); }
"static inline event_word_t *evtchn_fifo_word_from_port(struct domain *d, unsigned int port) { unsigned int p, w; if ( unlikely(port >= d->evtchn_fifo->num_evtchns) ) return NULL; p = port / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE; w = port % EVTCHN_FIFO_EVENT_WORDS_PER_PAGE; return d->evtchn_fifo->event_array[p] + w; }"
"int snd_rawmidi_output_params(struct snd_rawmidi_substream *substream, struct snd_rawmidi_params * params) { char *newbuf; struct snd_rawmidi_runtime *runtime = substream->runtime; if (substream->append && substream->use_count > 1) return -EBUSY; snd_rawmidi_drain_output(substream); if (params->buffer_size < 32 || params->buffer_size > 1024L * 1024L) { return -EINVAL; } if (params->avail_min < 1 || params->avail_min > params->buffer_size) { return -EINVAL; } if (params->buffer_size != runtime->buffer_size) { newbuf = krealloc(runtime->buffer, params->buffer_size, GFP_KERNEL); if (!newbuf) return -ENOMEM; runtime->buffer = newbuf; runtime->buffer_size = params->buffer_size; runtime->avail = runtime->buffer_size; } runtime->avail_min = params->avail_min; substream->active_sensing = !params->no_active_sensing; return 0; }"
"void SdpContents::Session::Medium::parse(ParseBuffer& pb) { pb.skipChar('m'); const char* anchor = pb.skipChar(Symbols::EQUALS[0]); pb.skipToChar(Symbols::SPACE[0]); pb.data(mName, anchor); pb.skipChar(Symbols::SPACE[0]); mPort = pb.integer(); if (*pb.position() == Symbols::SLASH[0]) { pb.skipChar(); mMulticast = pb.integer(); } anchor = pb.skipChar(Symbols::SPACE[0]); pb.skipToOneOf(Symbols::SPACE, Symbols::CRLF); pb.data(mProtocol, anchor); while (*pb.position() != Symbols::CR[0] && *pb.position() != Symbols::LF[0]) { anchor = pb.skipChar(Symbols::SPACE[0]); pb.skipToOneOf(Symbols::SPACE, Symbols::CRLF); if(pb.position() != anchor) { Data format; pb.data(format, anchor); addFormat(format); } } skipEol(pb); if (!pb.eof() && *pb.position() == 'i') { pb.skipChar('i'); anchor = pb.skipChar(Symbols::EQUALS[0]); pb.skipToOneOf(Symbols::CRLF); pb.data(mInformation, anchor); skipEol(pb); } while (!pb.eof() && *pb.position() == 'c') { addConnection(Connection()); mConnections.back().parse(pb); if (!pb.eof() && *pb.position() == Symbols::SLASH[0]) { pb.skipChar(); int num = pb.integer(); Connection& con = mConnections.back(); const Data& addr = con.getAddress(); size_t i = addr.size() - 1; for (; i; i--) { if (addr[i] == '.' || addr[i] == ':')             { break; } } if (addr[i] == '.')           { Data before(addr.data(), i+1); ParseBuffer subpb(addr.data()+i+1, addr.size()-i-1); int after = subpb.integer(); for (int i = 1; i < num; i++) { addConnection(con); mConnections.back().mAddress = before + Data(after+i); } } if (addr[i] == ':')          { Data before(addr.data(), i+1); int after = Helper::hex2integer(addr.data()+i+1); char hexstring[9]; for (int i = 1; i < num; i++) { addConnection(con); memset(hexstring, 0, sizeof(hexstring)); Helper::integer2hex(hexstring, after+i, false ); mConnections.back().mAddress = before + Data(hexstring); } } skipEol(pb); } } while (!pb.eof() && *pb.position() == 'b') { addBandwidth(Bandwidth()); mBandwidths.back().parse(pb); } if (!pb.eof() && *pb.position() == 'k') { mEncryption.parse(pb); } mAttributeHelper.parse(pb); }"
"void jswrap_spi_write( JsVar *parent,     JsVar *args      ) { NOT_USED(parent); IOEventFlags device = jsiGetDeviceFromClass(parent); spi_sender spiSend; spi_sender_data spiSendData; if (!jsspiGetSendFunction(parent, &spiSend, &spiSendData)) return; jswrap_spi_write_data spi_write_data; spi_write_data.spiSend = spiSend; spi_write_data.spiSendData = spiSendData; Pin nss_pin = PIN_UNDEFINED; JsVarInt len = jsvGetArrayLength(args); if (len > 0) { JsVar *last = jsvGetArrayItem(args, len-1);     if (jsvIsPin(last)) { nss_pin = jshGetPinFromVar(last); jsvUnLock(jsvArrayPop(args)); } jsvUnLock(last); } if (DEVICE_IS_SPI(device)) jshSPISetReceive(device, false); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, false); jsvIterateBufferCallback(args, (jsvIterateBufferCallbackFn)jswrap_spi_write_cb, &spi_write_data); if (DEVICE_IS_SPI(device)) jshSPIWait(device); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, true); }"
"libspdm_return_t libspdm_get_response_capabilities(libspdm_context_t *spdm_context, size_t request_size, const void *request, size_t *response_size, void *response) { const spdm_get_capabilities_request_t *spdm_request; spdm_capabilities_response_t *spdm_response; libspdm_return_t status; spdm_request = request; if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) { return libspdm_responder_handle_response_state( spdm_context, spdm_request->header.request_response_code,  response_size, response); } if (spdm_context->connection_info.connection_state != LIBSPDM_CONNECTION_STATE_AFTER_VERSION) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0, response_size, response); } if (!libspdm_check_request_version_compatibility( spdm_context, spdm_request->header.spdm_version)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_VERSION_MISMATCH, 0, response_size, response); } if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { if (request_size < sizeof(spdm_get_capabilities_request_t)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_get_capabilities_request_t); } } else if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_11) { if (request_size < sizeof(spdm_get_capabilities_request_t) - sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_get_capabilities_request_t) - sizeof(spdm_request->data_transfer_size) - sizeof(spdm_request->max_spdm_msg_size); } } else { if (request_size < sizeof(spdm_message_header_t)) { return libspdm_generate_error_response( spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } else { request_size = sizeof(spdm_message_header_t); } } if (!libspdm_check_request_flag_compatibility( spdm_request->flags, spdm_request->header.spdm_version)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } if (spdm_request->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { if ((spdm_request->data_transfer_size < SPDM_MIN_DATA_TRANSFER_SIZE_VERSION_12) || (spdm_request->data_transfer_size > spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } if (((spdm_request->flags & SPDM_GET_CAPABILITIES_REQUEST_FLAGS_CHUNK_CAP) == 0) && (spdm_request->data_transfer_size != spdm_request->max_spdm_msg_size)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_INVALID_REQUEST, 0, response_size, response); } } libspdm_reset_message_buffer_via_request_code(spdm_context, NULL, spdm_request->header.request_response_code); LIBSPDM_ASSERT(*response_size >= sizeof(spdm_capabilities_response_t)); *response_size = sizeof(spdm_capabilities_response_t); libspdm_zero_mem(response, *response_size); spdm_response = response; spdm_response->header.spdm_version = spdm_request->header.spdm_version; spdm_response->header.request_response_code = SPDM_CAPABILITIES; spdm_response->header.param1 = 0; spdm_response->header.param2 = 0; spdm_response->ct_exponent = spdm_context->local_context.capability.ct_exponent; spdm_response->flags = spdm_context->local_context.capability.flags; spdm_response->data_transfer_size = spdm_context->local_context.capability.data_transfer_size; spdm_response->max_spdm_msg_size = spdm_context->local_context.capability.max_spdm_msg_size; if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { *response_size = sizeof(spdm_capabilities_response_t); } else { *response_size = sizeof(spdm_capabilities_response_t) - sizeof(spdm_response->data_transfer_size) - sizeof(spdm_response->max_spdm_msg_size); } status = libspdm_append_message_a(spdm_context, spdm_request, request_size); if (LIBSPDM_STATUS_IS_ERROR(status)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNSPECIFIED, 0, response_size, response); } status = libspdm_append_message_a(spdm_context, spdm_response, *response_size); if (LIBSPDM_STATUS_IS_ERROR(status)) { return libspdm_generate_error_response(spdm_context, SPDM_ERROR_CODE_UNSPECIFIED, 0, response_size, response); } if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_11) { spdm_context->connection_info.capability.ct_exponent = spdm_request->ct_exponent; spdm_context->connection_info.capability.flags = spdm_request->flags; } else { spdm_context->connection_info.capability.ct_exponent = 0; spdm_context->connection_info.capability.flags = 0; } if (spdm_response->header.spdm_version >= SPDM_MESSAGE_VERSION_12) { spdm_context->connection_info.capability.data_transfer_size = spdm_request->data_transfer_size; spdm_context->connection_info.capability.max_spdm_msg_size = spdm_request->max_spdm_msg_size; } else { spdm_context->connection_info.capability.data_transfer_size = 0; spdm_context->connection_info.capability.max_spdm_msg_size = 0; } libspdm_set_connection_state(spdm_context, LIBSPDM_CONNECTION_STATE_AFTER_CAPABILITIES); return LIBSPDM_STATUS_SUCCESS; }"
"int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags) { uint8_t b[192]; int16_t ntrk, nchan, nord, npat, nsmp; uint16_t comment_len; int n, pat, chan, smp, rows, todo = 0; song_note_t *note; uint16_t tmp; uint32_t tmplong; song_note_t **trackdata, *tracknote; song_sample_t *sample; slurp_read(fp, b, 3); if (memcmp(b, ""MTM"", 3) != 0) return LOAD_UNSUPPORTED; n = slurp_getc(fp); sprintf(song->tracker_id, ""MultiTracker %d.%d"", n >> 4, n & 0xf); slurp_read(fp, song->title, 20); song->title[20] = 0; slurp_read(fp, &ntrk, 2); ntrk = bswapLE16(ntrk); npat = slurp_getc(fp); nord = slurp_getc(fp) + 1; slurp_read(fp, &comment_len, 2); comment_len = bswapLE16(comment_len); nsmp = slurp_getc(fp); slurp_getc(fp);  rows = slurp_getc(fp);  if (rows != 64) todo |= 64; rows = MIN(rows, 64); nchan = slurp_getc(fp); for (n = 0; n < 32; n++) { int pan = slurp_getc(fp) & 0xf; pan = SHORT_PANNING(pan); pan *= 4; song->channels[n].panning = pan; } for (n = nchan; n < MAX_CHANNELS; n++) song->channels[n].flags = CHN_MUTE; for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) { if (n > MAX_SAMPLES) { slurp_seek(fp, 37, SEEK_CUR); continue; } char name[23]; slurp_read(fp, name, 22); name[22] = '\0'; strcpy(sample->name, name); slurp_read(fp, &tmplong, 4); sample->length = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_start = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_end = bswapLE32(tmplong); if ((sample->loop_end - sample->loop_start) > 2) { sample->flags |= CHN_LOOP; } else { sample->loop_start = 0; sample->loop_end = 0; } song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp)); sample->volume = slurp_getc(fp); sample->volume *= 4; sample->global_volume = 64; if (slurp_getc(fp) & 1) { todo |= 16; sample->flags |= CHN_16BIT; sample->length >>= 1; sample->loop_start >>= 1; sample->loop_end >>= 1; } song->samples[n].vib_type = 0; song->samples[n].vib_rate = 0; song->samples[n].vib_depth = 0; song->samples[n].vib_speed = 0; } slurp_read(fp, song->orderlist, 128); memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord); trackdata = mem_calloc(ntrk, sizeof(song_note_t *)); for (n = 0; n < ntrk; n++) { slurp_read(fp, b, 3 * rows); trackdata[n] = mem_calloc(rows, sizeof(song_note_t)); mtm_unpack_track(b, trackdata[n], rows); } for (pat = 0; pat <= npat; pat++) { song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32)); song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64; tracknote = trackdata[n]; for (chan = 0; chan < 32; chan++) { slurp_read(fp, &tmp, 2); tmp = bswapLE16(tmp); if (tmp == 0) { continue; } else if (tmp > ntrk) { for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); return LOAD_FORMAT_ERROR; } note = song->patterns[pat] + chan; tracknote = trackdata[tmp - 1]; for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS) *note = *tracknote; } if (rows < 32) { note = song->patterns[pat] + 64 * (rows - 1); while (note->effect || note->param) note++; note->effect = FX_PATTERNBREAK; } } for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); read_lined_message(song->message, fp, comment_len, 40); if (!(lflags & LOAD_NOSAMPLES)) { for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) { uint32_t ssize; if (song->samples[smp].length == 0) continue; ssize = csf_read_sample(song->samples + smp, (SF_LE | SF_PCMU | SF_M | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)), fp->data + fp->pos, fp->length - fp->pos); slurp_seek(fp, ssize, SEEK_CUR); } } song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX; if (todo & 64) log_appendf(2, "" TODO: test this file with other players (beats per track != 64)""); if (todo & 16) log_appendf(2, "" TODO: double check 16 bit sample loading""); return LOAD_SUCCESS; }"
"int smb2_write(struct ksmbd_work *work) { struct smb2_write_req *req; struct smb2_write_rsp *rsp; struct ksmbd_file *fp = NULL; loff_t offset; size_t length; ssize_t nbytes; char *data_buf; bool writethrough = false; int err = 0; WORK_BUFFERS(work, req, rsp); if (test_share_config_flag(work->tcon->share_conf, KSMBD_SHARE_FLAG_PIPE)) { ksmbd_debug(SMB, ""IPC pipe write request\n""); return smb2_write_pipe(work); } if (req->Channel == SMB2_CHANNEL_RDMA_V1 || req->Channel == SMB2_CHANNEL_RDMA_V1_INVALIDATE) { unsigned int ch_offset = le16_to_cpu(req->WriteChannelInfoOffset); if (req->Length != 0 || req->DataOffset != 0 || ch_offset < offsetof(struct smb2_write_req, Buffer)) { err = -EINVAL; goto out; } err = smb2_set_remote_key_for_rdma(work, (struct smb2_buffer_desc_v1 *) ((char *)req + ch_offset), req->Channel, req->WriteChannelInfoOffset, req->WriteChannelInfoLength); if (err) goto out; } if (!test_tree_conn_flag(work->tcon, KSMBD_TREE_CONN_FLAG_WRITABLE)) { ksmbd_debug(SMB, ""User does not have write permission\n""); err = -EACCES; goto out; } fp = ksmbd_lookup_fd_slow(work, req->VolatileFileId, req->PersistentFileId); if (!fp) { err = -ENOENT; goto out; } if (!(fp->daccess & (FILE_WRITE_DATA_LE | FILE_READ_ATTRIBUTES_LE))) { pr_err(""Not permitted to write : 0x%x\n"", fp->daccess); err = -EACCES; goto out; } offset = le64_to_cpu(req->Offset); length = le32_to_cpu(req->Length); if (length > work->conn->vals->max_write_size) { ksmbd_debug(SMB, ""limiting write size to max size(%u)\n"", work->conn->vals->max_write_size); err = -EINVAL; goto out; } if (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH) writethrough = true; if (req->Channel != SMB2_CHANNEL_RDMA_V1 && req->Channel != SMB2_CHANNEL_RDMA_V1_INVALIDATE) { if (le16_to_cpu(req->DataOffset) == offsetof(struct smb2_write_req, Buffer)) { data_buf = (char *)&req->Buffer[0]; } else { if ((u64)le16_to_cpu(req->DataOffset) + length > get_rfc1002_len(work->request_buf)) { pr_err(""invalid write data offset %u, smb_len %u\n"", le16_to_cpu(req->DataOffset), get_rfc1002_len(work->request_buf)); err = -EINVAL; goto out; } data_buf = (char *)(((char *)&req->hdr.ProtocolId) + le16_to_cpu(req->DataOffset)); } ksmbd_debug(SMB, ""flags %u\n"", le32_to_cpu(req->Flags)); if (le32_to_cpu(req->Flags) & SMB2_WRITEFLAG_WRITE_THROUGH) writethrough = true; ksmbd_debug(SMB, ""filename %pd, offset %lld, len %zu\n"", fp->filp->f_path.dentry, offset, length); err = ksmbd_vfs_write(work, fp, data_buf, length, &offset, writethrough, &nbytes); if (err < 0) goto out; } else { nbytes = smb2_write_rdma_channel(work, req, fp, offset, le32_to_cpu(req->RemainingBytes), writethrough); if (nbytes < 0) { err = (int)nbytes; goto out; } } rsp->StructureSize = cpu_to_le16(17); rsp->DataOffset = 0; rsp->Reserved = 0; rsp->DataLength = cpu_to_le32(nbytes); rsp->DataRemaining = 0; rsp->Reserved2 = 0; inc_rfc1001_len(work->response_buf, 16); ksmbd_fd_put(work, fp); return 0; out: if (err == -EAGAIN) rsp->hdr.Status = STATUS_FILE_LOCK_CONFLICT; else if (err == -ENOSPC || err == -EFBIG) rsp->hdr.Status = STATUS_DISK_FULL; else if (err == -ENOENT) rsp->hdr.Status = STATUS_FILE_CLOSED; else if (err == -EACCES) rsp->hdr.Status = STATUS_ACCESS_DENIED; else if (err == -ESHARE) rsp->hdr.Status = STATUS_SHARING_VIOLATION; else if (err == -EINVAL) rsp->hdr.Status = STATUS_INVALID_PARAMETER; else rsp->hdr.Status = STATUS_INVALID_HANDLE; smb2_set_err_rsp(work); ksmbd_fd_put(work, fp); return err; }"
"static int appinfo_private (Bit_Chain *restrict dat, Dwg_Data *restrict dwg) { Bit_Chain *str_dat = dat; Dwg_AppInfo *_obj = &dwg->appinfo; Dwg_Object *obj = NULL; int error = 0; if (!dat->chain || !dat->size) return 1; #include ""appinfo.spec"" if (_obj->version && *_obj->version) { is_teigha = memcmp (_obj->version, ""T\0e\0i\0g\0h\0a\0"", 12) == 0; LOG_TRACE (""is_teigha: %s\n"", is_teigha ? ""true"" : ""false"") } return error; }"
"static void blk_aio_detach(void *opaque) { NBDExport *exp = opaque; NBDClient *client; TRACE(""Export %s: Detaching clients from AIO context %p\n"", exp->name, exp->ctx); QTAILQ_FOREACH(client, &exp->clients, next) { nbd_unset_handlers(client); } exp->ctx = NULL; }"
"void HttpGrpcAccessLog::emitLog(const Http::HeaderMap& request_headers, const Http::HeaderMap& response_headers, const Http::HeaderMap& response_trailers, const StreamInfo::StreamInfo& stream_info) { envoy::data::accesslog::v2::HTTPAccessLogEntry log_entry; GrpcCommon::Utility::extractCommonAccessLogProperties(*log_entry.mutable_common_properties(), stream_info); if (stream_info.protocol()) { switch (stream_info.protocol().value()) { case Http::Protocol::Http10: log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP10); break; case Http::Protocol::Http11: log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP11); break; case Http::Protocol::Http2: log_entry.set_protocol_version(envoy::data::accesslog::v2::HTTPAccessLogEntry::HTTP2); break; } } auto* request_properties = log_entry.mutable_request(); if (request_headers.Scheme() != nullptr) { request_properties->set_scheme(std::string(request_headers.Scheme()->value().getStringView())); } if (request_headers.Host() != nullptr) { request_properties->set_authority(std::string(request_headers.Host()->value().getStringView())); } if (request_headers.Path() != nullptr) { request_properties->set_path(std::string(request_headers.Path()->value().getStringView())); } if (request_headers.UserAgent() != nullptr) { request_properties->set_user_agent( std::string(request_headers.UserAgent()->value().getStringView())); } if (request_headers.Referer() != nullptr) { request_properties->set_referer( std::string(request_headers.Referer()->value().getStringView())); } if (request_headers.ForwardedFor() != nullptr) { request_properties->set_forwarded_for( std::string(request_headers.ForwardedFor()->value().getStringView())); } if (request_headers.RequestId() != nullptr) { request_properties->set_request_id( std::string(request_headers.RequestId()->value().getStringView())); } if (request_headers.EnvoyOriginalPath() != nullptr) { request_properties->set_original_path( std::string(request_headers.EnvoyOriginalPath()->value().getStringView())); } request_properties->set_request_headers_bytes(request_headers.byteSize()); request_properties->set_request_body_bytes(stream_info.bytesReceived()); if (request_headers.Method() != nullptr) { envoy::api::v2::core::RequestMethod method = envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED; envoy::api::v2::core::RequestMethod_Parse( std::string(request_headers.Method()->value().getStringView()), &method); request_properties->set_request_method(method); } if (!request_headers_to_log_.empty()) { auto* logged_headers = request_properties->mutable_request_headers(); for (const auto& header : request_headers_to_log_) { const Http::HeaderEntry* entry = request_headers.get(header); if (entry != nullptr) { logged_headers->insert({header.get(), std::string(entry->value().getStringView())}); } } } auto* response_properties = log_entry.mutable_response(); if (stream_info.responseCode()) { response_properties->mutable_response_code()->set_value(stream_info.responseCode().value()); } if (stream_info.responseCodeDetails()) { response_properties->set_response_code_details(stream_info.responseCodeDetails().value()); } response_properties->set_response_headers_bytes(response_headers.byteSize()); response_properties->set_response_body_bytes(stream_info.bytesSent()); if (!response_headers_to_log_.empty()) { auto* logged_headers = response_properties->mutable_response_headers(); for (const auto& header : response_headers_to_log_) { const Http::HeaderEntry* entry = response_headers.get(header); if (entry != nullptr) { logged_headers->insert({header.get(), std::string(entry->value().getStringView())}); } } } if (!response_trailers_to_log_.empty()) { auto* logged_headers = response_properties->mutable_response_trailers(); for (const auto& header : response_trailers_to_log_) { const Http::HeaderEntry* entry = response_trailers.get(header); if (entry != nullptr) { logged_headers->insert({header.get(), std::string(entry->value().getStringView())}); } } } tls_slot_->getTyped<ThreadLocalLogger>().logger_->log(std::move(log_entry)); }"
"int double64_init(SF_PRIVATE *psf) {static int double64_caps ; if (psf->sf.channels < 1) {psf_log_printf (psf, ""double64_init : internal error : channels = %d\n"", psf->sf.channels) ; return SFE_INTERNAL ; } ; double64_caps = double64_get_capability (psf) ; psf->blockwidth = sizeof (double) * psf->sf.channels ; if (psf->file.mode == SFM_READ || psf->file.mode == SFM_RDWR) {switch (psf->endian + double64_caps) {case (SF_ENDIAN_BIG + DOUBLE_CAN_RW_BE) : psf->data_endswap = SF_FALSE ; psf->read_short= host_read_d2s ; psf->read_int= host_read_d2i ; psf->read_float= host_read_d2f ; psf->read_double= host_read_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_CAN_RW_LE) : psf->data_endswap = SF_FALSE ; psf->read_short= host_read_d2s ; psf->read_int= host_read_d2i ; psf->read_float= host_read_d2f ; psf->read_double= host_read_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_CAN_RW_LE) : psf->data_endswap = SF_TRUE ; psf->read_short= host_read_d2s ; psf->read_int= host_read_d2i ; psf->read_float= host_read_d2f ; psf->read_double= host_read_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_CAN_RW_BE) : psf->data_endswap = SF_TRUE ; psf->read_short= host_read_d2s ; psf->read_int= host_read_d2i ; psf->read_float= host_read_d2f ; psf->read_double= host_read_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_BROKEN_BE) : psf->data_endswap = SF_FALSE ; psf->read_short= replace_read_d2s ; psf->read_int= replace_read_d2i ; psf->read_float= replace_read_d2f ; psf->read_double= replace_read_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_BROKEN_LE) : psf->data_endswap = SF_FALSE ; psf->read_short= replace_read_d2s ; psf->read_int= replace_read_d2i ; psf->read_float= replace_read_d2f ; psf->read_double= replace_read_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_BROKEN_LE) : psf->data_endswap = SF_TRUE ; psf->read_short= replace_read_d2s ; psf->read_int= replace_read_d2i ; psf->read_float= replace_read_d2f ; psf->read_double= replace_read_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_BROKEN_BE) : psf->data_endswap = SF_TRUE ; psf->read_short= replace_read_d2s ; psf->read_int= replace_read_d2i ; psf->read_float= replace_read_d2f ; psf->read_double= replace_read_d ; break ; default : break ; } ; } ; if (psf->file.mode == SFM_WRITE || psf->file.mode == SFM_RDWR) {switch (psf->endian + double64_caps) {case (SF_ENDIAN_LITTLE + DOUBLE_CAN_RW_LE) : psf->data_endswap = SF_FALSE ; psf->write_short= host_write_s2d ; psf->write_int= host_write_i2d ; psf->write_float= host_write_f2d ; psf->write_double= host_write_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_CAN_RW_BE) : psf->data_endswap = SF_FALSE ; psf->write_short= host_write_s2d ; psf->write_int= host_write_i2d ; psf->write_float= host_write_f2d ; psf->write_double= host_write_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_CAN_RW_LE) : psf->data_endswap = SF_TRUE ; psf->write_short= host_write_s2d ; psf->write_int= host_write_i2d ; psf->write_float= host_write_f2d ; psf->write_double= host_write_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_CAN_RW_BE) : psf->data_endswap = SF_TRUE ; psf->write_short= host_write_s2d ; psf->write_int= host_write_i2d ; psf->write_float= host_write_f2d ; psf->write_double= host_write_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_BROKEN_LE) : psf->data_endswap = SF_FALSE ; psf->write_short= replace_write_s2d ; psf->write_int= replace_write_i2d ; psf->write_float= replace_write_f2d ; psf->write_double= replace_write_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_BROKEN_BE) : psf->data_endswap = SF_FALSE ; psf->write_short= replace_write_s2d ; psf->write_int= replace_write_i2d ; psf->write_float= replace_write_f2d ; psf->write_double= replace_write_d ; break ; case (SF_ENDIAN_BIG + DOUBLE_BROKEN_LE) : psf->data_endswap = SF_TRUE ; psf->write_short= replace_write_s2d ; psf->write_int= replace_write_i2d ; psf->write_float= replace_write_f2d ; psf->write_double= replace_write_d ; break ; case (SF_ENDIAN_LITTLE + DOUBLE_BROKEN_BE) : psf->data_endswap = SF_TRUE ; psf->write_short= replace_write_s2d ; psf->write_int= replace_write_i2d ; psf->write_float= replace_write_f2d ; psf->write_double= replace_write_d ; break ; default : break ; } ; } ; if (psf->filelength > psf->dataoffset) {psf->datalength = (psf->dataend > 0) ? psf->dataend - psf->dataoffset : psf->filelength - psf->dataoffset ; } else psf->datalength = 0 ; psf->sf.frames = psf->datalength / psf->blockwidth ; return 0 ; }"
"static Jsi_RC jsi_ArraySpliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); int newlen, argc, istart, n, rhowmany, ilen, curlen; Jsi_Value *va, *start, *howmany; Jsi_Obj *nobj, *obj = _this->d.obj; start = Jsi_ValueArrayIndex(interp, args, 0); howmany = Jsi_ValueArrayIndex(interp, args, 1); argc = Jsi_ValueGetLength(interp, args); istart = 0; ilen = (argc>=2 ? argc - 2 : 0); n = jsi_SizeOfArray(interp, obj); curlen = n; if (!start) return JSI_OK; nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); Jsi_ValueMakeArrayObject(interp, ret, nobj); Jsi_ObjSetLength(interp, nobj, 0); Jsi_Number nstart; if (Jsi_GetNumberFromValue(interp, start, &nstart) != JSI_OK) return JSI_ERROR; istart = (int)nstart; if (istart > n) return JSI_OK; if (istart < 0) istart = (n+istart); if (istart<0) istart=0; Jsi_Number nhow; rhowmany = n-istart; if (howmany) { if (Jsi_GetNumberFromValue(interp, howmany, &nhow) != JSI_OK) return JSI_ERROR; rhowmany = (int)nhow; if (rhowmany >= (n-istart)) rhowmany = n-istart; if (rhowmany < 0) rhowmany = (n-istart); if (rhowmany<0) return JSI_OK; } if (curlen < 0) { Jsi_ObjSetLength(interp, obj, curlen=0); } Jsi_ObjListifyArray(interp, obj); if (Jsi_ObjArraySizer(interp, nobj, rhowmany)<=0) return JSI_ERROR; int i, j, m; for (m=0, j = 0, i = istart; m<rhowmany && m<curlen; m++, i++, j++) { if (!obj->arr[i]) continue; nobj->arr[m] = obj->arr[i]; obj->arr[i] = NULL; } Jsi_ObjSetLength(interp, nobj, m); for (; rhowmany && i<curlen; i++) { obj->arr[i-rhowmany] = obj->arr[i]; obj->arr[i] = NULL; } curlen -= j; newlen = curlen + argc - (argc>=2?2:1); if (Jsi_ObjArraySizer(interp, obj, newlen+3) <= 0) { Jsi_ValueMakeUndef(interp, ret); return Jsi_LogError(""too long""); } if (ilen>0) { for (i = curlen-1; i>=istart; i--) { obj->arr[i+ilen] = obj->arr[i]; obj->arr[i] = NULL; } for (m=istart, i = 2; i<argc; m++,i++) { va = Jsi_ValueArrayIndex(interp, args, i); if (!va) continue; obj->arr[m] = NULL; Jsi_ValueDup2(interp, obj->arr+m, va); } } Jsi_ObjSetLength(interp, obj, newlen); return JSI_OK; }"
"int xenmem_add_to_physmap_one( struct domain *d, unsigned int space, union xen_add_to_physmap_batch_extra extra, unsigned long idx, gfn_t gfn) { mfn_t mfn = INVALID_MFN; int rc; p2m_type_t t; struct page_info *page = NULL; switch ( space ) { case XENMAPSPACE_grant_table: rc = gnttab_map_frame(d, idx, gfn, &mfn); if ( rc ) return rc; t = p2m_ram_rw; break; case XENMAPSPACE_shared_info: if ( idx != 0 ) return -EINVAL; mfn = virt_to_mfn(d->shared_info); t = p2m_ram_rw; break; case XENMAPSPACE_gmfn_foreign: { struct domain *od; p2m_type_t p2mt; od = get_pg_owner(extra.foreign_domid); if ( od == NULL ) return -ESRCH; if ( od == d ) { put_pg_owner(od); return -EINVAL; } rc = xsm_map_gmfn_foreign(XSM_TARGET, d, od); if ( rc ) { put_pg_owner(od); return rc; } page = get_page_from_gfn(od, idx, &p2mt, P2M_ALLOC); if ( !page ) { put_pg_owner(od); return -EINVAL; } if ( p2m_is_ram(p2mt) ) t = (p2mt == p2m_ram_rw) ? p2m_map_foreign_rw : p2m_map_foreign_ro; else { put_page(page); put_pg_owner(od); return -EINVAL; } mfn = page_to_mfn(page); put_pg_owner(od); break; } case XENMAPSPACE_dev_mmio: if ( extra.res0 ) return -EOPNOTSUPP; rc = map_dev_mmio_region(d, gfn, 1, _mfn(idx)); return rc; default: return -ENOSYS; } rc = guest_physmap_add_entry(d, gfn, mfn, 0, t); if ( rc && space == XENMAPSPACE_gmfn_foreign ) { ASSERT(page != NULL); put_page(page); } return rc; }"
"int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index) { struct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table; int i, err = 0; int free = -1; mutex_lock(&table->mutex); for (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) { if (free < 0 && (table->refs[i] == 0)) { free = i; continue; } if (table->refs[i] && (vlan == (MLX4_VLAN_MASK & be32_to_cpu(table->entries[i])))) { *index = i; ++table->refs[i]; goto out; } } if (table->total == table->max) { err = -ENOSPC; goto out; } table->refs[free] = 1; table->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID); err = mlx4_set_port_vlan_table(dev, port, table->entries); if (unlikely(err)) { mlx4_warn(dev, ""Failed adding vlan: %u\n"", vlan); table->refs[free] = 0; table->entries[free] = 0; goto out; } *index = free; ++table->total; out: mutex_unlock(&table->mutex); return err; }"
"bool MidiFile::readTrack() { char tmp[4]; read(tmp, 4); if (memcmp(tmp, ""MTrk"", 4)) { throw(QString(""bad midifile: MTrk expected"")); } int len       = readLong();             qint64 endPos = curPos + len; status        = -1; sstatus       = -1;        click         =  0; _tracks.push_back(MidiTrack()); int port = 0; _tracks.back().setOutPort(port); _tracks.back().setOutChannel(-1); for (;;) { MidiEvent event; if (!readEvent(&event)) { return true; } if ((event.type() == ME_META) && (event.metaType() == META_EOT)) { break; } _tracks.back().insert(click, event); } if (curPos != endPos) { LOGW(""bad track len: %lld != %lld, %lld bytes too much\n"", endPos, curPos, endPos - curPos); if (curPos < endPos) { LOGW(""  skip %lld\n"", endPos - curPos); skip(endPos - curPos); } } return false; }"
"void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos) { if (!s || !s->child_boxes || !child || !pos) return; if (s->internal_flags & GF_ISOM_ORDER_FREEZE) return; s32 cur_pos = gf_list_find(s->child_boxes, child); if (cur_pos < 0) return; if (cur_pos != (s32) *pos) { gf_list_del_item(s->child_boxes, child); gf_list_insert(s->child_boxes, child, *pos); } (*pos)++; }"
"void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) { if (data.empty()) { return; } if (!header.empty()) { header.append("","", 1); } header.append(data.data(), data.size()); }"
"static int _warc_read(struct archive_read *a, const void **buf, size_t *bsz, int64_t *off) { struct warc_s *w = a->format->data; const char *rab; ssize_t nrd; if (w->cntoff >= w->cntlen) { eof: *buf = NULL; *bsz = 0U; *off = w->cntoff + 4U; w->unconsumed = 0U; return (ARCHIVE_EOF); } rab = __archive_read_ahead(a, 1U, &nrd); if (nrd < 0) { *bsz = 0U; return (int)nrd; } else if (nrd == 0) { goto eof; } else if ((size_t)nrd > w->cntlen - w->cntoff) { nrd = w->cntlen - w->cntoff; } *off = w->cntoff; *bsz = nrd; *buf = rab; w->cntoff += nrd; w->unconsumed = (size_t)nrd; return (ARCHIVE_OK); }"
"static int md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF* p_end, int* p_beg_line_index, int* p_end_line_index, OFF* p_contents_beg, OFF* p_contents_end) { OFF off = beg; OFF contents_beg = 0; OFF contents_end = 0; int line_index = 0; int len = 0; if(CH(off) != _T('[')) return FALSE; off++; while(line_index < n_lines) { OFF line_end = lines[line_index].end; while(off < line_end) { if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) { if(contents_end == 0) contents_beg = off; contents_end = off + 2; off += 2; } else if(CH(off) == _T('[')) { return FALSE; } else if(CH(off) == _T(']')) { if(contents_beg < contents_end) { *p_contents_beg = contents_beg; *p_contents_end = contents_end; *p_end = off+1; *p_end_line_index = line_index; return TRUE; } else { return FALSE; } } else { int codepoint; SZ char_size; codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size); if(!ISUNICODEWHITESPACE_(codepoint)) { if(contents_end == 0) { contents_beg = off; *p_beg_line_index = line_index; } contents_end = off + char_size; } off += char_size; } len++; if(len > 999) return FALSE; } line_index++; len++; off = lines[line_index].beg; } return FALSE; }"
"static Status ValidateSavedTensors(const GraphDef& graph_def) { for (const auto& node : graph_def.node()) { const auto node_iterator = node.attr().find(""value""); if (node_iterator != node.attr().end()) { AttrValue node_value = node_iterator->second; if (node_value.has_tensor()) { const PartialTensorShape node_shape(node_value.tensor().tensor_shape()); if (node_shape.num_elements() < 0) { return errors::FailedPrecondition( ""Saved model contains node \"""", node.name(), ""\"" (op \"""", node.op(), ""\"") which initializes from a tensor with "", node_shape.num_elements(), "" elements""); } } } else if (node.op() == ""Const"") { return errors::FailedPrecondition( ""Saved model contains node \"""", node.name(), ""\"" which is a constant tensor but no value has been provided""); } } return Status::OK(); }"
"void ext4_ext_tree_init(handle_t *handle, struct inode *inode) { struct ext4_extent_header *eh; eh = ext_inode_hdr(inode); eh->eh_depth = 0; eh->eh_entries = 0; eh->eh_magic = EXT4_EXT_MAGIC; eh->eh_max = cpu_to_le16(ext4_ext_space_root(inode, 0)); ext4_mark_inode_dirty(handle, inode); }"
"GF_Err dimC_Read(GF_Box *s, GF_BitStream *bs) { char str[1024]; u32 i; GF_DIMSSceneConfigBox *p = (GF_DIMSSceneConfigBox *)s; p->profile = gf_bs_read_u8(bs); p->level = gf_bs_read_u8(bs); p->pathComponents = gf_bs_read_int(bs, 4); p->fullRequestHost = gf_bs_read_int(bs, 1); p->streamType = gf_bs_read_int(bs, 1); p->containsRedundant = gf_bs_read_int(bs, 2); ISOM_DECREASE_SIZE(p, 3); i=0; str[0]=0; while (1) { str[i] = gf_bs_read_u8(bs); if (!str[i]) break; i++; } ISOM_DECREASE_SIZE(p, i); p->textEncoding = gf_strdup(str); i=0; str[0]=0; while (1) { str[i] = gf_bs_read_u8(bs); if (!str[i]) break; i++; } ISOM_DECREASE_SIZE(p, i); p->contentEncoding = gf_strdup(str); return GF_OK; }"
"static int userfaultfd_register(struct userfaultfd_ctx *ctx, unsigned long arg) { struct mm_struct *mm = ctx->mm; struct vm_area_struct *vma, *prev, *cur; int ret; struct uffdio_register uffdio_register; struct uffdio_register __user *user_uffdio_register; unsigned long vm_flags, new_flags; bool found; bool basic_ioctls; unsigned long start, end, vma_end; user_uffdio_register = (struct uffdio_register __user *) arg; ret = -EFAULT; if (copy_from_user(&uffdio_register, user_uffdio_register, sizeof(uffdio_register)-sizeof(__u64))) goto out; ret = -EINVAL; if (!uffdio_register.mode) goto out; if (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING| UFFDIO_REGISTER_MODE_WP)) goto out; vm_flags = 0; if (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING) vm_flags |= VM_UFFD_MISSING; if (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) { vm_flags |= VM_UFFD_WP; ret = -EINVAL; goto out; } ret = validate_range(mm, uffdio_register.range.start, uffdio_register.range.len); if (ret) goto out; start = uffdio_register.range.start; end = start + uffdio_register.range.len; ret = -ENOMEM; if (!mmget_not_zero(mm)) goto out; down_write(&mm->mmap_sem); vma = find_vma_prev(mm, start, &prev); if (!vma) goto out_unlock; ret = -EINVAL; if (vma->vm_start >= end) goto out_unlock; if (is_vm_hugetlb_page(vma)) { unsigned long vma_hpagesize = vma_kernel_pagesize(vma); if (start & (vma_hpagesize - 1)) goto out_unlock; } found = false; basic_ioctls = false; for (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) { cond_resched(); BUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^ !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP))); ret = -EINVAL; if (!vma_can_userfault(cur)) goto out_unlock; ret = -EPERM; if (unlikely(!(cur->vm_flags & VM_MAYWRITE))) goto out_unlock; if (is_vm_hugetlb_page(cur) && end <= cur->vm_end && end > cur->vm_start) { unsigned long vma_hpagesize = vma_kernel_pagesize(cur); ret = -EINVAL; if (end & (vma_hpagesize - 1)) goto out_unlock; } ret = -EBUSY; if (cur->vm_userfaultfd_ctx.ctx && cur->vm_userfaultfd_ctx.ctx != ctx) goto out_unlock; if (is_vm_hugetlb_page(cur)) basic_ioctls = true; found = true; } BUG_ON(!found); if (vma->vm_start < start) prev = vma; ret = 0; do { cond_resched(); BUG_ON(!vma_can_userfault(vma)); BUG_ON(vma->vm_userfaultfd_ctx.ctx && vma->vm_userfaultfd_ctx.ctx != ctx); WARN_ON(!(vma->vm_flags & VM_MAYWRITE)); if (vma->vm_userfaultfd_ctx.ctx == ctx && (vma->vm_flags & vm_flags) == vm_flags) goto skip; if (vma->vm_start > start) start = vma->vm_start; vma_end = min(end, vma->vm_end); new_flags = (vma->vm_flags & ~vm_flags) | vm_flags; prev = vma_merge(mm, prev, start, vma_end, new_flags, vma->anon_vma, vma->vm_file, vma->vm_pgoff, vma_policy(vma), ((struct vm_userfaultfd_ctx){ ctx })); if (prev) { vma = prev; goto next; } if (vma->vm_start < start) { ret = split_vma(mm, vma, start, 1); if (ret) break; } if (vma->vm_end > end) { ret = split_vma(mm, vma, end, 0); if (ret) break; } next: vma->vm_flags = new_flags; vma->vm_userfaultfd_ctx.ctx = ctx; skip: prev = vma; start = vma->vm_end; vma = vma->vm_next; } while (vma && vma->vm_start < end); out_unlock: up_write(&mm->mmap_sem); mmput(mm); if (!ret) { if (put_user(basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS, &user_uffdio_register->ioctls)) ret = -EFAULT; } out: return ret; }"
"int ares_parse_soa_reply(const unsigned char *abuf, int alen, struct ares_soa_reply **soa_out) { const unsigned char *aptr; long len; char *qname = NULL, *rr_name = NULL; struct ares_soa_reply *soa = NULL; int qdcount, ancount, qclass; int status, i, rr_type, rr_class, rr_len; if (alen < HFIXEDSZ) return ARES_EBADRESP; qdcount = DNS_HEADER_QDCOUNT(abuf); ancount = DNS_HEADER_ANCOUNT(abuf); if (qdcount != 1) return ARES_EBADRESP; if (ancount == 0) return ARES_EBADRESP; aptr = abuf + HFIXEDSZ; status = ares__expand_name_for_response(aptr, abuf, alen, &qname, &len); if (status != ARES_SUCCESS) goto failed_stat; aptr += len; qclass = DNS_QUESTION_TYPE(aptr); if (aptr + QFIXEDSZ > abuf + alen) goto failed; aptr += QFIXEDSZ; if (qclass == T_SOA && ancount > 1) goto failed; for (i = 0; i < ancount; i++) { rr_name = NULL; status  = ares__expand_name_for_response (aptr, abuf, alen, &rr_name, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; if ( aptr + RRFIXEDSZ > abuf + alen ) { ares_free(rr_name); status = ARES_EBADRESP; goto failed_stat; } rr_type = DNS_RR_TYPE( aptr ); rr_class = DNS_RR_CLASS( aptr ); rr_len = DNS_RR_LEN( aptr ); aptr += RRFIXEDSZ; if (aptr + rr_len > abuf + alen) { ares_free(rr_name); status = ARES_EBADRESP; goto failed_stat; } if ( rr_class == C_IN && rr_type == T_SOA ) { soa = ares_malloc_data(ARES_DATATYPE_SOA_REPLY); if (!soa) { ares_free(rr_name); status = ARES_ENOMEM; goto failed_stat; } status = ares__expand_name_for_response(aptr, abuf, alen, &soa->nsname, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; status = ares__expand_name_for_response(aptr, abuf, alen, &soa->hostmaster, &len); if (status != ARES_SUCCESS) { ares_free(rr_name); goto failed_stat; } aptr += len; if (aptr + 5 * 4 > abuf + alen) { ares_free(rr_name); goto failed; } soa->serial = DNS__32BIT(aptr + 0 * 4); soa->refresh = DNS__32BIT(aptr + 1 * 4); soa->retry = DNS__32BIT(aptr + 2 * 4); soa->expire = DNS__32BIT(aptr + 3 * 4); soa->minttl = DNS__32BIT(aptr + 4 * 4); ares_free(qname); ares_free(rr_name); *soa_out = soa; return ARES_SUCCESS; } aptr += rr_len; ares_free(rr_name); if (aptr > abuf + alen) goto failed_stat; } status = ARES_EBADRESP; goto failed_stat; failed: status = ARES_EBADRESP; failed_stat: if (soa) ares_free_data(soa); if (qname) ares_free(qname); return status; }"
"static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk) { const struct net *net = sock_net(sk); int mss; if (!net->ipv4.sysctl_tcp_mtu_probing) return; if (!icsk->icsk_mtup.enabled) { icsk->icsk_mtup.enabled = 1; icsk->icsk_mtup.probe_timestamp = tcp_jiffies32; } else { mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1; mss = min(net->ipv4.sysctl_tcp_base_mss, mss); mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len); icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss); } tcp_sync_mss(sk, icsk->icsk_pmtu_cookie); }"
"void Compute(OpKernelContext* context) override { const Tensor* reverse_index_map_t; const Tensor* grad_values_t; OP_REQUIRES_OK(context, context->input(""reverse_index_map"", &reverse_index_map_t)); OP_REQUIRES_OK(context, context->input(""grad_values"", &grad_values_t)); const CPUDevice& d = context->eigen_device<CPUDevice>(); OP_REQUIRES( context, TensorShapeUtils::IsVector(reverse_index_map_t->shape()), errors::InvalidArgument(""reverse_index_map must be a vector, saw: "", reverse_index_map_t->shape().DebugString())); const auto reverse_index_map = reverse_index_map_t->vec<int64>(); const auto grad_values = grad_values_t->vec<T>(); const int64 N = reverse_index_map_t->shape().dim_size(0); const int64 N_full = grad_values_t->shape().dim_size(0); Tensor* d_values_t; OP_REQUIRES_OK(context, context->allocate_output( ""d_values"", TensorShape({N}), &d_values_t)); auto d_values = d_values_t->vec<T>(); Tensor* d_default_value_t; OP_REQUIRES_OK(context, context->allocate_output(""d_default_value"", TensorShape({}), &d_default_value_t)); T& d_default_value = d_default_value_t->scalar<T>()(); d_default_value = T(); Tensor visited_t; OP_REQUIRES_OK(context, context->allocate_temp( DT_BOOL, TensorShape({N_full}), &visited_t)); auto visited = visited_t.vec<bool>(); visited.device(d) = visited.constant(false); for (int i = 0; i < N; ++i) { d_values(i) = grad_values(reverse_index_map(i)); visited(reverse_index_map(i)) = true; } for (int j = 0; j < N_full; ++j) { if (!visited(j)) { d_default_value += grad_values(j); } } }"
"static Jsi_RC jsi_ArrayConcatCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, argc, nsiz; Jsi_Obj *obj, *nobj; Jsi_Value *va; obj = _this->d.obj; argc = Jsi_ValueGetLength(interp, args); curlen = jsi_SizeOfArray(interp, obj); Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrMaxSize; if (nsiz<=0) nsiz = 100; if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) return Jsi_LogError(""index too large: %d"", nsiz+1);; int i, j, m; for (i = 0; i<curlen; i++) { if (!obj->arr[i]) continue; nobj->arr[i] = NULL; Jsi_ValueDup2(interp, nobj->arr+i, obj->arr[i]); } m = i; for (i = 0; i < argc; i++) { va = Jsi_ValueArrayIndex(interp, args, i); if (va->vt == JSI_VT_OBJECT && Jsi_ObjIsArray(interp, va->d.obj)) { int margc = Jsi_ValueGetLength(interp, va); Jsi_Obj *mobj = va->d.obj; Jsi_ObjListifyArray(interp, mobj); if (Jsi_ObjArraySizer(interp, nobj, curlen += margc) <= 0) { rc = Jsi_LogError(""index too large: %d"", curlen); goto bail; } for (j = 0; j<margc; j++, m++) { if (!mobj->arr[j]) continue; nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m, mobj->arr[j]); } } else { if (Jsi_ObjArraySizer(interp, nobj, ++curlen) <= 0) { rc = Jsi_LogError(""index too large: %d"", curlen); goto bail; } nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m++, va); } } Jsi_ObjSetLength(interp, nobj, curlen); bail: Jsi_ValueMakeArrayObject(interp, ret, nobj); return rc; }"
"int decode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg) { BITCODE_RL entities_start = 0, entities_end = 0; BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0; BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities; BITCODE_RS rs2; Dwg_Object *obj = NULL; int tbl_id; int error = 0; int num_sections = 5; loglevel = dat->opts & DWG_OPTS_LOGLEVEL; #ifndef USE_WRITE fprintf(stderr, ""Cannot create pre-R13 documents with --disable-write\n""); return DWG_ERR_INTERNALERROR; #else { int i; Dwg_Header *_obj = (Dwg_Header *)&dwg->header; Bit_Chain *hdl_dat = dat; dat->byte = 0x06; #include ""header.spec"" } LOG_TRACE (""@0x%lx\n"", dat->byte);  error |= dwg_add_Document (dwg, 0); if (dwg->header.numheader_vars > 158)     num_sections += 3; if (dwg->header.numheader_vars > 160)     num_sections += 2; dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section), num_sections + 2); if (!dwg->header.section) { LOG_ERROR (""Out of memory""); return DWG_ERR_OUTOFMEM; } dwg->header.numsections = num_sections; PRE (R_2_0b) { bit_read_RC (dat);     LOG_TRACE (""zero[6]: 0 [RC 0]\n""); } SINCE (R_2_0b) { entities_start = bit_read_RL (dat); LOG_TRACE (""entities_start: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", entities_start, entities_start); entities_end = bit_read_RL (dat); LOG_TRACE (""entities_end: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", entities_end, entities_end); blocks_start = bit_read_RL (dat); LOG_TRACE (""blocks_start: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", blocks_start, blocks_start); blocks_size = bit_read_RL (dat); if (blocks_size >= 0x40000000) { LOG_TRACE (""blocks_size: 0x40000000 | "" FORMAT_RL "" [RLx]\n"", blocks_size & 0x3fffffff); } else { LOG_TRACE (""blocks_size: "" FORMAT_RL "" [RL]\n"", blocks_size); } blocks_end = bit_read_RL (dat); LOG_TRACE (""blocks_end: "" FORMAT_RL "" ("" FORMAT_RLx "") [RL]\n"", blocks_end, blocks_end); blocks_max = bit_read_RL (dat);     LOG_TRACE (""blocks_max: "" FORMAT_RLx "" [RLx]\n"", blocks_max); tbl_id = 0; dwg->header.section[0].number = 0; dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11; strcpy (dwg->header.section[0].name, ""HEADER""); LOG_INFO (""==========================================\n"") if (decode_preR13_section_hdr (""BLOCK"", SECTION_BLOCK, dat, dwg) || decode_preR13_section_hdr (""LAYER"", SECTION_LAYER, dat, dwg) || decode_preR13_section_hdr (""STYLE"", SECTION_STYLE, dat, dwg) || decode_preR13_section_hdr (""LTYPE"", SECTION_LTYPE, dat, dwg) || decode_preR13_section_hdr (""VIEW"", SECTION_VIEW, dat, dwg)) return DWG_ERR_INVALIDDWG; } LOG_TRACE (""@0x%lx\n"", dat->byte);   if (dat->size < 0x1f0)     { LOG_ERROR (""DWG too small %zu"", (size_t)dat->size) return DWG_ERR_INVALIDDWG; } LOG_INFO (""==========================================\n"") error |= decode_preR13_header_variables (dat, dwg); LOG_TRACE (""@0x%lx\n"", dat->byte); if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte + 2 >= dat->size) { LOG_ERROR (""post HEADER overflow"") return error | DWG_ERR_CRITICAL; } SINCE (R_11) { BITCODE_RS crc, crcc; BITCODE_TF r11_sentinel; crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte);     crc = bit_read_RS (dat); LOG_TRACE (""crc: %04X [RSx] from 0-0x%lx\n"", crc, dat->byte - 2); if (crc != crcc) { LOG_ERROR (""Header CRC mismatch %04X <=> %04X"", crc, crcc); error |= DWG_ERR_WRONGCRC; } r11_sentinel = bit_read_TF (dat, 16); if (!r11_sentinel) return error | DWG_ERR_INVALIDDWG; LOG_TRACE (""r11_sentinel: ""); LOG_TRACE_TF (r11_sentinel, 16)     if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16)) { LOG_ERROR (""DWG_SENTINEL_R11_HEADER_END mismatch""); error |= DWG_ERR_WRONGCRC; } free (r11_sentinel); } PRE (R_10) num_entities = dwg->header_vars.numentities; else num_entities = 0; PRE (R_2_0b) { entities_start = dat->byte; entities_end = dwg->header_vars.dwg_size; } if (dwg->header.numheader_vars > 158)     { dat->byte = 0x3ef; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""UCS"", SECTION_UCS, dat, dwg); dat->byte = 0x500; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""VPORT"", SECTION_VPORT, dat, dwg); dat->byte = 0x512; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""APPID"", SECTION_APPID, dat, dwg); dat->byte = entities_start; } if (dwg->header.numheader_vars > 160)     { dat->byte = 0x522; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""DIMSTYLE"", SECTION_DIMSTYLE, dat, dwg); dat->byte = 0x69f; LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_hdr (""VX"", SECTION_VX, dat, dwg); dat->byte = entities_start; } if (dat->byte != entities_start) { LOG_WARN (""@0x%lx => entities_start 0x%x"", dat->byte, entities_start); if (dat->byte < entities_start) { _DEBUG_HERE (dat->byte - entities_start) } dat->byte = entities_start; } error |= decode_preR13_entities (entities_start, entities_end, num_entities, entities_end - entities_start, 0, dat, dwg); if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte != entities_end) { LOG_WARN (""@0x%lx => entities_end 0x%x"", dat->byte, entities_end); dat->byte = entities_end; } PRE (R_2_0b) { return error; } LOG_INFO (""==========================================\n"") if (!dwg->next_hdl) dwg_set_next_hdl (dwg, 0x22); error |= decode_preR13_section (SECTION_BLOCK, dat, dwg); error |= decode_preR13_section (SECTION_LAYER, dat, dwg); error |= decode_preR13_section (SECTION_STYLE, dat, dwg); error |= decode_preR13_section (SECTION_LTYPE, dat, dwg); error |= decode_preR13_section (SECTION_VIEW, dat, dwg); #if 1 if (num_sections > 5)     { error |= decode_preR13_section (SECTION_UCS, dat, dwg); error |= decode_preR13_section (SECTION_VPORT, dat, dwg); error |= decode_preR13_section (SECTION_APPID, dat, dwg); } if (num_sections > 8)     { error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg); error |= decode_preR13_section (SECTION_VX, dat, dwg); } #endif if (error >= DWG_ERR_CRITICAL) return error; if (dat->byte != blocks_start) { BITCODE_TF unknown; int len = blocks_start - dat->byte; LOG_WARN (""\n@0x%lx => blocks_start 0x%x"", dat->byte, blocks_start); if (dat->byte < blocks_start) { unknown = bit_read_TF (dat, len); LOG_TRACE (""unknown (%d):"", len); LOG_TRACE_TF (unknown, len); free (unknown); } dat->byte = blocks_start; } num_entities = 0; VERSION (R_11) blocks_end -= 32;   error |= decode_preR13_entities (blocks_start, blocks_end, num_entities, blocks_size & 0x3FFFFFFF, blocks_max, dat, dwg); if (error >= DWG_ERR_CRITICAL) return error; PRE (R_11) { return error; } LOG_TRACE (""AUXHEADER: @0x%lx\n"", dat->byte); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x %f\n"", rl1, rl2, (double)dat->chain[dat->byte - 8]); rl1 = bit_read_RL (dat); LOG_TRACE (""?1long: 0x%x\n"", rl1); LOG_TRACE (""@0x%lx: 4 block ptrs chk\n"", dat->byte); if ((rl1 = bit_read_RL (dat)) != entities_start) { LOG_WARN (""entities_start %x/%x"", rl1, entities_start); } if ((rl1 = bit_read_RL (dat)) != entities_end) { LOG_WARN (""entities_end %x/%x"", rl1, entities_end); } if ((rl1 = bit_read_RL (dat)) != blocks_start) { LOG_WARN (""blocks_start %x/%x"", rl1, blocks_start); } if ((rl1 = bit_read_RL (dat)) != blocks_end) { LOG_WARN (""blocks_end %x/%x"", rl1, blocks_end); } LOG_TRACE (""@0x%lx\n"", dat->byte); rl1 = bit_read_RL (dat); rl2 = bit_read_RL (dat); LOG_TRACE (""?2long: 0x%x 0x%x\n"", rl1, rl2); rl1 = bit_read_RL (dat); LOG_TRACE (""?1long: 0x%x\n"", rl1); rl1 = blocks_end + 36 + 4 * 4 + 12;   DEBUG_HERE UNKNOWN_UNTIL (rl1); LOG_TRACE (""@0x%lx\n"", dat->byte); decode_preR13_section_chk (SECTION_BLOCK, dat, dwg); decode_preR13_section_chk (SECTION_LAYER, dat, dwg); decode_preR13_section_chk (SECTION_STYLE, dat, dwg); decode_preR13_section_chk (SECTION_LTYPE, dat, dwg); decode_preR13_section_chk (SECTION_VIEW, dat, dwg); if (num_sections > 5)     { decode_preR13_section_chk (SECTION_UCS, dat, dwg); decode_preR13_section_chk (SECTION_VPORT, dat, dwg); decode_preR13_section_chk (SECTION_APPID, dat, dwg); decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg); decode_preR13_section_chk (SECTION_VX, dat, dwg); } rl1 = bit_read_RL (dat); LOG_TRACE (""long 0x%x\n"", rl1);   if (dat->byte < dat->size) { int len = dat->size - dat->byte; BITCODE_TF unknown = bit_read_TF (dat, len); LOG_TRACE (""unknown (%d):"", len); LOG_TRACE_TF (unknown, len); free (unknown); } if (dwg->dirty_refs) dwg_resolve_objectrefs_silent (dwg); return 0; #endif }"
"void SoftVPXEncoder::onQueueFilled(OMX_U32 ) { if (mCodecContext == NULL) { if (OK != initEncoder()) { ALOGE(""Failed to initialize encoder""); notify(OMX_EventError, OMX_ErrorUndefined, 0,                     NULL);              return; } } vpx_codec_err_t codec_return; List<BufferInfo *> &inputBufferInfoQueue = getPortQueue(kInputPortIndex); List<BufferInfo *> &outputBufferInfoQueue = getPortQueue(kOutputPortIndex); while (!inputBufferInfoQueue.empty() && !outputBufferInfoQueue.empty()) { BufferInfo *inputBufferInfo = *inputBufferInfoQueue.begin(); OMX_BUFFERHEADERTYPE *inputBufferHeader = inputBufferInfo->mHeader; BufferInfo *outputBufferInfo = *outputBufferInfoQueue.begin(); OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo->mHeader; if ((inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) && inputBufferHeader->nFilledLen == 0) { inputBufferInfoQueue.erase(inputBufferInfoQueue.begin()); inputBufferInfo->mOwnedByUs = false; notifyEmptyBufferDone(inputBufferHeader); outputBufferHeader->nFilledLen = 0; outputBufferHeader->nFlags = OMX_BUFFERFLAG_EOS; outputBufferInfoQueue.erase(outputBufferInfoQueue.begin()); outputBufferInfo->mOwnedByUs = false; notifyFillBufferDone(outputBufferHeader); return; } const uint8_t *source = inputBufferHeader->pBuffer + inputBufferHeader->nOffset; if (mInputDataIsMeta) { source = extractGraphicBuffer( mConversionBuffer, mWidth * mHeight * 3 / 2, source, inputBufferHeader->nFilledLen, mWidth, mHeight); if (source == NULL) { ALOGE(""Unable to extract gralloc buffer in metadata mode""); notify(OMX_EventError, OMX_ErrorUndefined, 0, 0); return; } } else if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) { ConvertYUV420SemiPlanarToYUV420Planar( source, mConversionBuffer, mWidth, mHeight); source = mConversionBuffer; } vpx_image_t raw_frame; vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight, kInputBufferAlignment, (uint8_t *)source); vpx_enc_frame_flags_t flags = 0; if (mTemporalPatternLength > 0) { flags = getEncodeFlags(); } if (mKeyFrameRequested) { flags |= VPX_EFLAG_FORCE_KF; mKeyFrameRequested = false; } if (mBitrateUpdated) { mCodecConfiguration->rc_target_bitrate = mBitrate/1000; vpx_codec_err_t res = vpx_codec_enc_config_set(mCodecContext, mCodecConfiguration); if (res != VPX_CODEC_OK) { ALOGE(""vp8 encoder failed to update bitrate: %s"", vpx_codec_err_to_string(res)); notify(OMX_EventError, OMX_ErrorUndefined, 0,                        NULL);             } mBitrateUpdated = false; } uint32_t frameDuration; if (inputBufferHeader->nTimeStamp > mLastTimestamp) { frameDuration = (uint32_t)(inputBufferHeader->nTimeStamp - mLastTimestamp); } else { frameDuration = (uint32_t)(((uint64_t)1000000 << 16) / mFramerate); } mLastTimestamp = inputBufferHeader->nTimeStamp; codec_return = vpx_codec_encode( mCodecContext, &raw_frame, inputBufferHeader->nTimeStamp,                  frameDuration,                  flags,                  VPX_DL_REALTIME);          if (codec_return != VPX_CODEC_OK) { ALOGE(""vpx encoder failed to encode frame""); notify(OMX_EventError, OMX_ErrorUndefined, 0,                     NULL);              return; } vpx_codec_iter_t encoded_packet_iterator = NULL; const vpx_codec_cx_pkt_t* encoded_packet; while ((encoded_packet = vpx_codec_get_cx_data( mCodecContext, &encoded_packet_iterator))) { if (encoded_packet->kind == VPX_CODEC_CX_FRAME_PKT) { outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts; outputBufferHeader->nFlags = 0; if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY) outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME; outputBufferHeader->nOffset = 0; outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz; memcpy(outputBufferHeader->pBuffer, encoded_packet->data.frame.buf, encoded_packet->data.frame.sz); outputBufferInfo->mOwnedByUs = false; outputBufferInfoQueue.erase(outputBufferInfoQueue.begin()); if (inputBufferHeader->nFlags & OMX_BUFFERFLAG_EOS) { outputBufferHeader->nFlags |= OMX_BUFFERFLAG_EOS; } notifyFillBufferDone(outputBufferHeader); } } inputBufferInfo->mOwnedByUs = false; inputBufferInfoQueue.erase(inputBufferInfoQueue.begin()); notifyEmptyBufferDone(inputBufferHeader); } }"
"static void ip6gre_err(struct sk_buff *skb, struct inet6_skb_parm *opt, u8 type, u8 code, int offset, __be32 info) { const struct ipv6hdr *ipv6h = (const struct ipv6hdr *)skb->data; __be16 *p = (__be16 *)(skb->data + offset); int grehlen = offset + 4; struct ip6_tnl *t; __be16 flags; flags = p[0]; if (flags&(GRE_CSUM|GRE_KEY|GRE_SEQ|GRE_ROUTING|GRE_VERSION)) { if (flags&(GRE_VERSION|GRE_ROUTING)) return; if (flags&GRE_KEY) { grehlen += 4; if (flags&GRE_CSUM) grehlen += 4; } } if (!pskb_may_pull(skb, grehlen)) return; ipv6h = (const struct ipv6hdr *)skb->data; p = (__be16 *)(skb->data + offset); t = ip6gre_tunnel_lookup(skb->dev, &ipv6h->daddr, &ipv6h->saddr, flags & GRE_KEY ? *(((__be32 *)p) + (grehlen / 4) - 1) : 0, p[1]); if (!t) return; switch (type) { __u32 teli; struct ipv6_tlv_tnl_enc_lim *tel; __u32 mtu; case ICMPV6_DEST_UNREACH: net_dbg_ratelimited(""%s: Path to destination invalid or inactive!\n"", t->parms.name); break; case ICMPV6_TIME_EXCEED: if (code == ICMPV6_EXC_HOPLIMIT) { net_dbg_ratelimited(""%s: Too small hop limit or routing loop in tunnel!\n"", t->parms.name); } break; case ICMPV6_PARAMPROB: teli = 0; if (code == ICMPV6_HDR_FIELD) teli = ip6_tnl_parse_tlv_enc_lim(skb, skb->data); if (teli && teli == be32_to_cpu(info) - 2) { tel = (struct ipv6_tlv_tnl_enc_lim *) &skb->data[teli]; if (tel->encap_limit == 0) { net_dbg_ratelimited(""%s: Too small encapsulation limit or routing loop in tunnel!\n"", t->parms.name); } } else { net_dbg_ratelimited(""%s: Recipient unable to parse tunneled packet!\n"", t->parms.name); } break; case ICMPV6_PKT_TOOBIG: mtu = be32_to_cpu(info) - offset; if (mtu < IPV6_MIN_MTU) mtu = IPV6_MIN_MTU; t->dev->mtu = mtu; break; } if (time_before(jiffies, t->err_time + IP6TUNNEL_ERR_TIMEO)) t->err_count++; else t->err_count = 1; t->err_time = jiffies; }"
"static int nfqnl_mangle(void *data, int data_len, struct nf_queue_entry *e, int diff) { struct sk_buff *nskb; if (diff < 0) { if (pskb_trim(e->skb, data_len)) return -ENOMEM; } else if (diff > 0) { if (data_len > 0xFFFF) return -EINVAL; if (diff > skb_tailroom(e->skb)) { nskb = skb_copy_expand(e->skb, skb_headroom(e->skb), diff, GFP_ATOMIC); if (!nskb) return -ENOMEM; kfree_skb(e->skb); e->skb = nskb; } skb_put(e->skb, diff); } if (skb_ensure_writable(e->skb, data_len)) return -ENOMEM; skb_copy_to_linear_data(e->skb, data, data_len); e->skb->ip_summed = CHECKSUM_NONE; return 0; }"
"TEE_Result syscall_hash_final(unsigned long state, const void *chunk, size_t chunk_size, void *hash, uint64_t *hash_len) { TEE_Result res, res2; size_t hash_size; size_t hlen = 0; struct tee_cryp_state *cs; struct tee_ta_session *sess; if (!chunk && chunk_size) return TEE_ERROR_BAD_PARAMETERS; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx), TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)chunk, chunk_size); if (res != TEE_SUCCESS) return res; res = get_user_u64_as_size_t(&hlen, hash_len); if (res != TEE_SUCCESS) return res; res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx), TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)hash, hlen); if (res != TEE_SUCCESS) return res; res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs); if (res != TEE_SUCCESS) return res; switch (TEE_ALG_GET_CLASS(cs->algo)) { case TEE_OPERATION_DIGEST: res = tee_hash_get_digest_size(cs->algo, &hash_size); if (res != TEE_SUCCESS) return res; if (hlen < hash_size) { res = TEE_ERROR_SHORT_BUFFER; goto out; } if (chunk_size) { res = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size); if (res != TEE_SUCCESS) return res; } res = crypto_hash_final(cs->ctx, cs->algo, hash, hash_size); if (res != TEE_SUCCESS) return res; break; case TEE_OPERATION_MAC: res = tee_mac_get_digest_size(cs->algo, &hash_size); if (res != TEE_SUCCESS) return res; if (hlen < hash_size) { res = TEE_ERROR_SHORT_BUFFER; goto out; } if (chunk_size) { res = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size); if (res != TEE_SUCCESS) return res; } res = crypto_mac_final(cs->ctx, cs->algo, hash, hash_size); if (res != TEE_SUCCESS) return res; break; default: return TEE_ERROR_BAD_PARAMETERS; } out: res2 = put_user_u64(hash_len, hash_size); if (res2 != TEE_SUCCESS) return res2; return res; }"
"Datum tsl_subscription_exec(PG_FUNCTION_ARGS) { Oid save_userid; int save_sec_context; const char *subscription_cmd = PG_ARGISNULL(0) ? NULL : text_to_cstring(PG_GETARG_TEXT_P(0)); int res; List *parsetree_list; ListCell *parsetree_item; if (!subscription_cmd) PG_RETURN_VOID(); if (!superuser() && !has_rolreplication(GetUserId())) ereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE), (errmsg(""must be superuser or replication role to use this function"")))); GetUserIdAndSecContext(&save_userid, &save_sec_context); SetUserIdAndSecContext(BOOTSTRAP_SUPERUSERID, save_sec_context | SECURITY_LOCAL_USERID_CHANGE); parsetree_list = pg_parse_query(subscription_cmd); foreach (parsetree_item, parsetree_list) { RawStmt *parsetree = lfirst_node(RawStmt, parsetree_item); switch (nodeTag(parsetree->stmt)) { case T_CreateSubscriptionStmt: break; case T_AlterSubscriptionStmt: break; case T_DropSubscriptionStmt: break; default: ereport(ERROR, (errcode(ERRCODE_FEATURE_NOT_SUPPORTED), errmsg(""this function only accepts SUBSCRIPTION commands""))); } } if (SPI_connect() != SPI_OK_CONNECT) elog(ERROR, ""could not connect to SPI""); res = SPI_execute(subscription_cmd, false , 0 ); if (res < 0) ereport(ERROR, (errcode(ERRCODE_INTERNAL_ERROR), (errmsg(""error in subscription cmd \""%s\"""", subscription_cmd)))); if ((res = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res)); SetUserIdAndSecContext(save_userid, save_sec_context); PG_RETURN_VOID(); }"
"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags) { unsigned long val; void *ptr = NULL; if (!atomic_pool) { WARN(1, ""coherent pool not initialised!\n""); return NULL; } val = gen_pool_alloc(atomic_pool, size); if (val) { phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val); *ret_page = phys_to_page(phys); ptr = (void *)val; if (flags & __GFP_ZERO) memset(ptr, 0, size); } return ptr; }"
"Chunk::Chunk( ContainerChunk* parent, RIFF_MetaHandler* handler, bool skip, ChunkType c ) { chunkType = c; this->parent = parent; this->oldSize = 0; this->hasChange = false;  XMP_IO* file = handler->parent->ioRef; this->oldPos = file->Offset(); this->id = XIO::ReadUns32_LE( file ); this->oldSize = XIO::ReadUns32_LE( file ) + 8; XMP_Int64 chunkEnd = this->oldPos + this->oldSize; XMP_Int64 chunkLimit = handler->oldFileSize; if ( parent != 0 ) chunkLimit = parent->oldPos + parent->oldSize; if ( chunkEnd > chunkLimit ) { bool isUpdate = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenForUpdate ); bool repairFile = XMP_OptionIsSet ( handler->parent->openFlags, kXMPFiles_OpenRepairFile ); if ( (! isUpdate) || (repairFile && (parent == 0)) ) { this->oldSize = chunkLimit - this->oldPos; } else { XMP_Throw ( ""Bad RIFF chunk size"", kXMPErr_BadFileFormat ); } } this->newSize = this->oldSize; this->needSizeFix = false; if ( skip ) file->Seek ( (this->oldSize - 8), kXMP_SeekFromCurrent ); if ( this->parent != NULL ) { this->parent->children.push_back( this ); if( this->chunkType == chunk_VALUE ) this->parent->childmap.insert( std::make_pair( this->id, (ValueChunk*) this ) ); } }"
"static void icmp6_send(struct sk_buff *skb, u8 type, u8 code, __u32 info, const struct in6_addr *force_saddr) { struct net *net = dev_net(skb->dev); struct inet6_dev *idev = NULL; struct ipv6hdr *hdr = ipv6_hdr(skb); struct sock *sk; struct ipv6_pinfo *np; const struct in6_addr *saddr = NULL; struct dst_entry *dst; struct icmp6hdr tmp_hdr; struct flowi6 fl6; struct icmpv6_msg msg; struct sockcm_cookie sockc_unused = {0}; struct ipcm6_cookie ipc6; int iif = 0; int addr_type = 0; int len; int err = 0; u32 mark = IP6_REPLY_MARK(net, skb->mark); if ((u8 *)hdr < skb->head || (skb_network_header(skb) + sizeof(*hdr)) > skb_tail_pointer(skb)) return; addr_type = ipv6_addr_type(&hdr->daddr); if (ipv6_chk_addr(net, &hdr->daddr, skb->dev, 0) || ipv6_chk_acast_addr_src(net, skb->dev, &hdr->daddr)) saddr = &hdr->daddr; if (addr_type & IPV6_ADDR_MULTICAST || skb->pkt_type != PACKET_HOST) { if (type != ICMPV6_PKT_TOOBIG && !(type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && (opt_unrec(skb, info)))) return; saddr = NULL; } addr_type = ipv6_addr_type(&hdr->saddr); if (__ipv6_addr_needs_scope_id(addr_type)) iif = skb->dev->ifindex; else iif = l3mdev_master_ifindex(skb_dst(skb)->dev); if ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) { net_dbg_ratelimited(""icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } if (is_ineligible(skb)) { net_dbg_ratelimited(""icmp6_send: no reply to icmp error [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); return; } mip6_addr_swap(skb); memset(&fl6, 0, sizeof(fl6)); fl6.flowi6_proto = IPPROTO_ICMPV6; fl6.daddr = hdr->saddr; if (force_saddr) saddr = force_saddr; if (saddr) fl6.saddr = *saddr; fl6.flowi6_mark = mark; fl6.flowi6_oif = iif; fl6.fl6_icmp_type = type; fl6.fl6_icmp_code = code; security_skb_classify_flow(skb, flowi6_to_flowi(&fl6)); sk = icmpv6_xmit_lock(net); if (!sk) return; sk->sk_mark = mark; np = inet6_sk(sk); if (!icmpv6_xrlim_allow(sk, type, &fl6)) goto out; tmp_hdr.icmp6_type = type; tmp_hdr.icmp6_code = code; tmp_hdr.icmp6_cksum = 0; tmp_hdr.icmp6_pointer = htonl(info); if (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr)) fl6.flowi6_oif = np->mcast_oif; else if (!fl6.flowi6_oif) fl6.flowi6_oif = np->ucast_oif; ipc6.tclass = np->tclass; fl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel); dst = icmpv6_route_lookup(net, skb, sk, &fl6); if (IS_ERR(dst)) goto out; ipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst); ipc6.dontfrag = np->dontfrag; ipc6.opt = NULL; msg.skb = skb; msg.offset = skb_network_offset(skb); msg.type = type; len = skb->len - msg.offset; len = min_t(unsigned int, len, IPV6_MIN_MTU - sizeof(struct ipv6hdr) - sizeof(struct icmp6hdr)); if (len < 0) { net_dbg_ratelimited(""icmp: len problem [%pI6c > %pI6c]\n"", &hdr->saddr, &hdr->daddr); goto out_dst_release; } rcu_read_lock(); idev = __in6_dev_get(skb->dev); err = ip6_append_data(sk, icmpv6_getfrag, &msg, len + sizeof(struct icmp6hdr), sizeof(struct icmp6hdr), &ipc6, &fl6, (struct rt6_info *)dst, MSG_DONTWAIT, &sockc_unused); if (err) { ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTERRORS); ip6_flush_pending_frames(sk); } else { err = icmpv6_push_pending_frames(sk, &fl6, &tmp_hdr, len + sizeof(struct icmp6hdr)); } rcu_read_unlock(); out_dst_release: dst_release(dst); out: icmpv6_xmit_unlock(sk); }"
"void _modinit(module_t *m) { service_named_bind_command(""chanserv"", &cs_flags); }"
"static void _gtpv1_u_recv_cb(short when, ogs_socket_t fd, void *data) { int len; ssize_t size; char buf[OGS_ADDRSTRLEN]; sgwu_sess_t *sess = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_gtp_header_t *gtp_h = NULL; ogs_pfcp_user_plane_report_t report; uint32_t teid; uint8_t qfi; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(packet_pool, OGS_MAX_PKT_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_PKT_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recv() failed""); goto cleanup; } ogs_pkbuf_trim(pkbuf, size); ogs_assert(pkbuf); ogs_assert(pkbuf->len); gtp_h = (ogs_gtp_header_t *)pkbuf->data; if (gtp_h->version != OGS_GTP_VERSION_1) { ogs_error(""[DROP] Invalid GTPU version [%d]"", gtp_h->version); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); goto cleanup; } if (gtp_h->type == OGS_GTPU_MSGTYPE_ECHO_REQ) { ogs_pkbuf_t *echo_rsp; ogs_debug(""[RECV] Echo Request from [%s]"", OGS_ADDR(&from, buf)); echo_rsp = ogs_gtp_handle_echo_req(pkbuf); ogs_expect(echo_rsp); if (echo_rsp) { ssize_t sent; ogs_debug(""[SEND] Echo Response to [%s]"", OGS_ADDR(&from, buf)); sent = ogs_sendto(fd, echo_rsp->data, echo_rsp->len, 0, &from); if (sent < 0 || sent != echo_rsp->len) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(echo_rsp); } goto cleanup; } teid = be32toh(gtp_h->teid); ogs_debug(""[RECV] GPU-U Type [%d] from [%s] : TEID[0x%x]"", gtp_h->type, OGS_ADDR(&from, buf), teid); qfi = 0; if (gtp_h->flags & OGS_GTPU_FLAGS_E) { ogs_gtp_extension_header_t *extension_header = (ogs_gtp_extension_header_t *)(pkbuf->data + OGS_GTPV1U_HEADER_LEN); ogs_assert(extension_header); if (extension_header->type == OGS_GTP_EXTENSION_HEADER_TYPE_PDU_SESSION_CONTAINER) { if (extension_header->pdu_type == OGS_GTP_EXTENSION_HEADER_PDU_TYPE_UL_PDU_SESSION_INFORMATION) { ogs_debug(""   QFI [0x%x]"", extension_header->qos_flow_identifier); qfi = extension_header->qos_flow_identifier; } } } len = ogs_gtpu_header_len(pkbuf); if (len < 0) { ogs_error(""[DROP] Cannot decode GTPU packet""); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); goto cleanup; } ogs_assert(ogs_pkbuf_pull(pkbuf, len)); if (gtp_h->type == OGS_GTPU_MSGTYPE_END_MARKER) { } else if (gtp_h->type == OGS_GTPU_MSGTYPE_ERR_IND) { ogs_pfcp_far_t *far = NULL; far = ogs_pfcp_far_find_by_error_indication(pkbuf); if (far) { ogs_assert(true == ogs_pfcp_up_handle_error_indication(far, &report)); if (report.type.error_indication_report) { ogs_assert(far->sess); sess = SGWU_SESS(far->sess); ogs_assert(sess); ogs_assert(OGS_OK == sgwu_pfcp_send_session_report_request(sess, &report)); } } else { ogs_error(""[DROP] Cannot find FAR by Error-Indication""); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); } } else if (gtp_h->type == OGS_GTPU_MSGTYPE_GPDU) { struct ip *ip_h = NULL; ogs_pfcp_object_t *pfcp_object = NULL; ogs_pfcp_sess_t *pfcp_sess = NULL; ogs_pfcp_pdr_t *pdr = NULL; ip_h = (struct ip *)pkbuf->data; ogs_assert(ip_h); pfcp_object = ogs_pfcp_object_find_by_teid(teid); if (!pfcp_object) { goto cleanup; } switch(pfcp_object->type) { case OGS_PFCP_OBJ_PDR_TYPE: pdr = (ogs_pfcp_pdr_t *)pfcp_object; ogs_assert(pdr); break; case OGS_PFCP_OBJ_SESS_TYPE: pfcp_sess = (ogs_pfcp_sess_t *)pfcp_object; ogs_assert(pfcp_sess); ogs_list_for_each(&pfcp_sess->pdr_list, pdr) { if (pdr->src_if != OGS_PFCP_INTERFACE_ACCESS && pdr->src_if != OGS_PFCP_INTERFACE_CP_FUNCTION) continue; if (teid != pdr->f_teid.teid) continue; if (qfi && pdr->qfi != qfi) continue; if (ogs_list_first(&pdr->rule_list) && ogs_pfcp_pdr_rule_find_by_packet(pdr, pkbuf) == NULL) continue; break; } if (!pdr) { goto cleanup; } break; default: ogs_fatal(""Unknown type [%d]"", pfcp_object->type); ogs_assert_if_reached(); } ogs_assert(pdr); ogs_assert(true == ogs_pfcp_up_handle_pdr(pdr, pkbuf, &report)); if (report.type.downlink_data_report) { ogs_assert(pdr->sess); ogs_assert(pdr->sess->obj.type == OGS_PFCP_OBJ_SESS_TYPE); sess = SGWU_SESS(pdr->sess); ogs_assert(sess); report.downlink_data.pdr_id = pdr->id; report.downlink_data.qfi = qfi;  ogs_assert(OGS_OK == sgwu_pfcp_send_session_report_request(sess, &report)); } } else { ogs_error(""[DROP] Invalid GTPU Type [%d]"", gtp_h->type); ogs_log_hexdump(OGS_LOG_ERROR, pkbuf->data, pkbuf->len); } cleanup: ogs_pkbuf_free(pkbuf); }"
"IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec) { UWORD32 i; yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf; stream_t   *ps_stream       = &ps_dec->s_bit_stream; UWORD8   *pu1_vld_buf; WORD16 i2_dc_diff; UWORD32 u4_frame_width = ps_dec->u2_frame_width; UWORD32 u4_frm_offset = 0; if(ps_dec->u2_picture_structure != FRAME_PICTURE) { u4_frame_width <<= 1; if(ps_dec->u2_picture_structure == BOTTOM_FIELD) { u4_frm_offset = ps_dec->u2_frame_width; } } do { UWORD32 u4_x_offset, u4_y_offset; UWORD32 u4_blk_pos; WORD16 i2_dc_val; UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4); UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width; UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset; UWORD32 u4_dst_wd           = u4_frame_width; while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE) impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN); impeg2d_bit_stream_flush(ps_stream,1); if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01) { } for(i = 0; i < NUM_LUMA_BLKS; ++i) { u4_x_offset    = gai2_impeg2_blk_x_off[i]; u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ; u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset; pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos; i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream); i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff; ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val; i2_dc_val = CLIP_U8(i2_dc_val); ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd); } u4_dst_x_offset                >>= 1; u4_dst_y_offset                >>= 2; u4_dst_wd                      >>= 1; pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset; i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream); i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff; ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val; i2_dc_val = CLIP_U8(i2_dc_val); ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd); pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset; i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream); i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff; ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val; i2_dc_val = CLIP_U8(i2_dc_val); ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd); ps_dec->u2_num_mbs_left--; ps_dec->u2_mb_x++; if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset) { return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR; } else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb) { ps_dec->u2_mb_x = 0; ps_dec->u2_mb_y++; } impeg2d_bit_stream_flush(ps_stream,1); } while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0); return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE; }"
"u32 gf_avc_reformat_sei(u8 *buffer, u32 nal_size, Bool isobmf_rewrite, AVCState *avc) { u32 ptype, psize, hdr, var; u32 start; GF_BitStream *bs; GF_BitStream *bs_dest = NULL; u8 nhdr; Bool sei_removed = GF_FALSE; char store; hdr = buffer[0]; if ((hdr & 0x1F) != GF_AVC_NALU_SEI) return 0; if (isobmf_rewrite) bs_dest = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); bs = gf_bs_new(buffer, nal_size, GF_BITSTREAM_READ); gf_bs_enable_emulation_byte_removal(bs, GF_TRUE); nhdr = gf_bs_read_int(bs, 8); if (bs_dest) gf_bs_write_int(bs_dest, nhdr, 8); while (gf_bs_available(bs)) { Bool do_copy; ptype = 0; while (1) { u8 v = gf_bs_read_int(bs, 8); ptype += v; if (v != 0xFF) break; } psize = 0; while (1) { u8 v = gf_bs_read_int(bs, 8); psize += v; if (v != 0xFF) break; } start = (u32)gf_bs_get_position(bs); do_copy = 1; if (start + psize >= nal_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] SEI user message type %d size error (%d but %d remain), keeping full SEI untouched\n"", ptype, psize, nal_size - start)); if (bs_dest) gf_bs_del(bs_dest); gf_bs_del(bs); return nal_size; } switch (ptype) { case 3:  case 10:  case 11:  case 12:  do_copy = 0; sei_removed = GF_TRUE; break; case 5:  store = buffer[start + psize]; buffer[start + psize] = 0; GF_LOG(GF_LOG_DEBUG, GF_LOG_CODING, (""[avc-h264] SEI user message %s\n"", buffer + start + 16)); buffer[start + psize] = store; break; case 6:  avc_parse_recovery_point_sei(bs, avc); break; case 1:  avc_parse_pic_timing_sei(bs, avc); break; case 0:  case 2:  case 4:  case 7:  case 8:  case 9:  case 13:  case 14:  case 15:  case 16:  case 17:  case 18:  default:  break; } if (do_copy && bs_dest) { var = ptype; while (var >= 255) { gf_bs_write_int(bs_dest, 0xFF, 8); var -= 255; } gf_bs_write_int(bs_dest, var, 8); var = psize; while (var >= 255) { gf_bs_write_int(bs_dest, 0xFF, 8); var -= 255; } gf_bs_write_int(bs_dest, var, 8); gf_bs_seek(bs, start); var = psize; while (var) { gf_bs_write_u8(bs_dest, gf_bs_read_u8(bs)); var--; } } else { gf_bs_seek(bs, start); while (psize) { gf_bs_read_u8(bs); psize--; } } if (gf_bs_available(bs) <= 2) { var = gf_bs_read_int(bs, 8); if (var != 0x80) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] SEI user message has less than 2 bytes remaining but no end of sei found\n"")); } if (bs_dest) gf_bs_write_int(bs_dest, 0x80, 8); break; } } gf_bs_del(bs); if (bs_dest && sei_removed) { u8 *dst_no_epb = NULL; u32 dst_no_epb_size = 0; gf_bs_get_content(bs_dest, &dst_no_epb, &dst_no_epb_size); if (dst_no_epb) { u32 nb_bytes_add = gf_media_nalu_emulation_bytes_add_count(dst_no_epb, dst_no_epb_size); if (dst_no_epb_size + nb_bytes_add <= nal_size) nal_size = gf_media_nalu_add_emulation_bytes(buffer, dst_no_epb, dst_no_epb_size); gf_free(dst_no_epb); } } if (bs_dest) gf_bs_del(bs_dest); return nal_size; }"
"void Compute(OpKernelContext* context) override { const Tensor& x = context->input(0); const Tensor& y = context->input(1); const float min_x = context->input(2).flat<float>()(0); const float max_x = context->input(3).flat<float>()(0); const float min_y = context->input(4).flat<float>()(0); const float max_y = context->input(5).flat<float>()(0); BCast bcast(BCast::FromShape(x.shape()), BCast::FromShape(y.shape())); if (!bcast.IsValid()) { context->SetStatus(errors::InvalidArgument( ""Incompatible shapes: "", x.shape().DebugString(), "" vs. "", y.shape().DebugString())); return; } Tensor* z; OP_REQUIRES_OK(context, context->allocate_output( 0, BCast::ToShape(bcast.output_shape()), &z)); OP_REQUIRES(context, (max_x > min_x), errors::InvalidArgument(""max_x must be larger than min_x."")); OP_REQUIRES(context, (max_y > min_y), errors::InvalidArgument(""max_y must be larger than min_y."")); const T* x_data = x.flat<T>().data(); const T* y_data = y.flat<T>().data(); Toutput* z_data = z->flat<Toutput>().data(); const float smallest_min = std::min(min_x, min_y); const float largest_max = std::max(max_x, max_y); const float biggest_range = std::max(std::abs(smallest_min), std::abs(largest_max)); const float output_range = (biggest_range * (1 << 14)); const float min_z_value = -output_range; const float max_z_value = output_range; const int ndims = bcast.x_reshape().size(); if (ndims <= 1) { if (x.NumElements() == 1) { ScalarAddition<T, Toutput>(context, y_data, min_y, max_y, y.NumElements(), x_data[0], min_x, max_x, min_z_value, max_z_value, z_data); } else if (y.NumElements() == 1) { ScalarAddition<T, Toutput>(context, x_data, min_x, max_x, x.NumElements(), y_data[0], min_y, max_y, min_z_value, max_z_value, z_data); } else { VectorAddition<T, Toutput>(context, x_data, min_x, max_x, y_data, min_y, max_y, x.NumElements(), min_z_value, max_z_value, z_data); } } else if (ndims == 2) { const T* vector_data; int64_t vector_num_elements; float vector_min; float vector_max; const T* tensor_data; int64_t tensor_num_elements; float tensor_min; float tensor_max; if (x.NumElements() < y.NumElements()) { vector_data = x_data; vector_num_elements = x.NumElements(); vector_min = min_x; vector_max = max_x; tensor_data = y_data; tensor_num_elements = y.NumElements(); tensor_min = min_y; tensor_max = max_y; } else { vector_data = y_data; vector_num_elements = y.NumElements(); vector_min = min_y; vector_max = max_y; tensor_data = x_data; tensor_num_elements = x.NumElements(); tensor_min = min_x; tensor_max = max_x; } OP_REQUIRES(context, vector_num_elements > 0, errors::InvalidArgument(""Must have some elements to add"")); VectorTensorAddition<T, Toutput>( vector_data, vector_min, vector_max, vector_num_elements, tensor_data, tensor_min, tensor_max, tensor_num_elements, min_z_value, max_z_value, z_data); } else { LOG(INFO) << ""ndims="" << ndims; LOG(INFO) << ""bcast.x_reshape()="" << TensorShape(bcast.x_reshape()).DebugString(); LOG(INFO) << ""bcast.y_reshape()="" << TensorShape(bcast.y_reshape()).DebugString(); LOG(INFO) << ""bcast.x_bcast()="" << TensorShape(bcast.x_bcast()).DebugString(); LOG(INFO) << ""bcast.y_bcast()="" << TensorShape(bcast.y_bcast()).DebugString(); context->SetStatus(errors::Unimplemented( ""Broadcast between "", context->input(0).shape().DebugString(), "" and "", context->input(1).shape().DebugString(), "" is not supported yet."")); return; } Tensor* z_min = nullptr; OP_REQUIRES_OK(context, context->allocate_output(1, {}, &z_min)); z_min->flat<float>()(0) = min_z_value; Tensor* z_max = nullptr; OP_REQUIRES_OK(context, context->allocate_output(2, {}, &z_max)); z_max->flat<float>()(0) = max_z_value; }"
"void flatpak_context_merge (FlatpakContext *context, FlatpakContext *other) { GHashTableIter iter; gpointer key, value; context->shares &= ~other->shares_valid; context->shares |= other->shares; context->shares_valid |= other->shares_valid; context->sockets &= ~other->sockets_valid; context->sockets |= other->sockets; context->sockets_valid |= other->sockets_valid; context->devices &= ~other->devices_valid; context->devices |= other->devices; context->devices_valid |= other->devices_valid; context->features &= ~other->features_valid; context->features |= other->features; context->features_valid |= other->features_valid; g_hash_table_iter_init (&iter, other->env_vars); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->env_vars, g_strdup (key), g_strdup (value)); g_hash_table_iter_init (&iter, other->persistent); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->persistent, g_strdup (key), value); g_hash_table_iter_init (&iter, other->filesystems); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->filesystems, g_strdup (key), value); g_hash_table_iter_init (&iter, other->session_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->session_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->system_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->system_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->system_bus_policy); while (g_hash_table_iter_next (&iter, &key, &value)) g_hash_table_insert (context->system_bus_policy, g_strdup (key), value); g_hash_table_iter_init (&iter, other->generic_policy); while (g_hash_table_iter_next (&iter, &key, &value)) { const char **policy_values = (const char **) value; int i; for (i = 0; policy_values[i] != NULL; i++) flatpak_context_apply_generic_policy (context, (char *) key, policy_values[i]); } }"
"inline bool IsAligned(const void *ptr) { return IsAlignedOn(ptr, GetAlignmentOf<T*>()); }"
"static bfd_boolean print_gnu_build_attribute_name (Elf_Internal_Note * pnote) { static const char string_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_STRING, 0 }; static const char number_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC, 0 }; static const char bool_expected [3] = { GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE, GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE, 0 }; char         name_type; char         name_attribute; const char * expected_types; const char * name = pnote->namedata; const char * text; int          left; if (name == NULL || pnote->namesz < 2) { error (_(""corrupt name field in GNU build attribute note: size = %ld\n""), pnote->namesz); print_symbol (-20, _(""  <corrupt name>"")); return FALSE; } switch ((name_type = * name)) { case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC: case GNU_BUILD_ATTRIBUTE_TYPE_STRING: case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE: case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE: printf (""%c"", * name); break; default: error (_(""unrecognised attribute type in name field: %d\n""), name_type); print_symbol (-20, _(""<unknown name type>"")); return FALSE; } left = 19; ++ name; text = NULL; switch ((name_attribute = * name)) { case GNU_BUILD_ATTRIBUTE_VERSION: text = _(""<version>""); expected_types = string_expected; ++ name; break; case GNU_BUILD_ATTRIBUTE_STACK_PROT: text = _(""<stack prot>""); expected_types = ""!+*""; ++ name; break; case GNU_BUILD_ATTRIBUTE_RELRO: text = _(""<relro>""); expected_types = bool_expected; ++ name; break; case GNU_BUILD_ATTRIBUTE_STACK_SIZE: text = _(""<stack size>""); expected_types = number_expected; ++ name; break; case GNU_BUILD_ATTRIBUTE_TOOL: text = _(""<tool>""); expected_types = string_expected; ++ name; break; case GNU_BUILD_ATTRIBUTE_ABI: text = _(""<ABI>""); expected_types = ""$*""; ++ name; break; case GNU_BUILD_ATTRIBUTE_PIC: text = _(""<PIC>""); expected_types = number_expected; ++ name; break; case GNU_BUILD_ATTRIBUTE_SHORT_ENUM: text = _(""<short enum>""); expected_types = bool_expected; ++ name; break; default: if (ISPRINT (* name)) { int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1; if (len > left && ! do_wide) len = left; printf (""%.*s:"", len, name); left -= len; name += len; } else { error (_(""unexpected character in name field\n"")); print_symbol (- left, _(""<unknown attribute>"")); return 0; } expected_types = ""*$!+""; break; } if (text) { printf (""%s"", text); left -= strlen (text); } if (strchr (expected_types, name_type) == NULL) warn (_(""attribute does not have an expected type (%c)\n""), name_type); if ((unsigned long)(name - pnote->namedata) > pnote->namesz) { error (_(""corrupt name field: namesz: %lu but parsing gets to %ld\n""), (unsigned long) pnote->namesz, (long) (name - pnote->namedata)); return FALSE; } if (left < 1 && ! do_wide) return TRUE; switch (name_type) { case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC: { unsigned int   bytes = pnote->namesz - (name - pnote->namedata); unsigned long  val = 0; unsigned int   shift = 0; char *         decoded = NULL; while (bytes --) { unsigned long byte = (* name ++) & 0xff; val |= byte << shift; shift += 8; } switch (name_attribute) { case GNU_BUILD_ATTRIBUTE_PIC: switch (val) { case 0: decoded = ""static""; break; case 1: decoded = ""pic""; break; case 2: decoded = ""PIC""; break; case 3: decoded = ""pie""; break; case 4: decoded = ""PIE""; break; default: break; } break; case GNU_BUILD_ATTRIBUTE_STACK_PROT: switch (val) { case 0: decoded = ""off""; break; case 1: decoded = ""on""; break; case 2: decoded = ""all""; break; case 3: decoded = ""strong""; break; case 4: decoded = ""explicit""; break; default: break; } break; default: break; } if (decoded != NULL) print_symbol (-left, decoded); else { if (do_wide) left -= printf (""0x%lx"", val); else left -= printf (""0x%-.*lx"", left, val); } } break; case GNU_BUILD_ATTRIBUTE_TYPE_STRING: left -= print_symbol (- left, name); break; case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE: left -= print_symbol (- left, ""true""); break; case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE: left -= print_symbol (- left, ""false""); break; } if (do_wide && left > 0) printf (""%-*s"", left, "" ""); return TRUE; }"
"static char *fstrndup(const char *ptr, unsigned long len) { char *result; if (len <= 0) return NULL; result = ALLOC_N(char, len); memccpy(result, ptr, 0, len); return result; }"
"void JBIG2Stream::readTextRegionSeg(unsigned int segNum, bool imm, bool lossless, unsigned int length, unsigned int *refSegs, unsigned int nRefSegs) { std::unique_ptr<JBIG2Bitmap> bitmap; JBIG2HuffmanTable runLengthTab[36]; JBIG2HuffmanTable *symCodeTab = nullptr; const JBIG2HuffmanTable *huffFSTable, *huffDSTable, *huffDTTable; const JBIG2HuffmanTable *huffRDWTable, *huffRDHTable; const JBIG2HuffmanTable *huffRDXTable, *huffRDYTable, *huffRSizeTable; JBIG2Segment *seg; std::vector<JBIG2Segment *> codeTables; JBIG2SymbolDict *symbolDict; JBIG2Bitmap **syms; unsigned int w, h, x, y, segInfoFlags, extCombOp; unsigned int flags, huff, refine, logStrips, refCorner, transposed; unsigned int combOp, defPixel, templ; int sOffset; unsigned int huffFlags, huffFS, huffDS, huffDT; unsigned int huffRDW, huffRDH, huffRDX, huffRDY, huffRSize; unsigned int numInstances, numSyms, symCodeLen; int atx[2], aty[2]; unsigned int i, k, kk; int j = 0; if (!readULong(&w) || !readULong(&h) || !readULong(&x) || !readULong(&y) || !readUByte(&segInfoFlags)) { goto eofError; } extCombOp = segInfoFlags & 7; if (!readUWord(&flags)) { goto eofError; } huff = flags & 1; refine = (flags >> 1) & 1; logStrips = (flags >> 2) & 3; refCorner = (flags >> 4) & 3; transposed = (flags >> 6) & 1; combOp = (flags >> 7) & 3; defPixel = (flags >> 9) & 1; sOffset = (flags >> 10) & 0x1f; if (sOffset & 0x10) { sOffset |= -1 - 0x0f; } templ = (flags >> 15) & 1; huffFS = huffDS = huffDT = 0;     huffRDW = huffRDH = huffRDX = huffRDY = huffRSize = 0;     if (huff) { if (!readUWord(&huffFlags)) { goto eofError; } huffFS = huffFlags & 3; huffDS = (huffFlags >> 2) & 3; huffDT = (huffFlags >> 4) & 3; huffRDW = (huffFlags >> 6) & 3; huffRDH = (huffFlags >> 8) & 3; huffRDX = (huffFlags >> 10) & 3; huffRDY = (huffFlags >> 12) & 3; huffRSize = (huffFlags >> 14) & 1; } if (refine && templ == 0) { if (!readByte(&atx[0]) || !readByte(&aty[0]) || !readByte(&atx[1]) || !readByte(&aty[1])) { goto eofError; } } if (!readULong(&numInstances)) { goto eofError; } numSyms = 0; for (i = 0; i < nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg->getType() == jbig2SegSymbolDict) { numSyms += ((JBIG2SymbolDict *)seg)->getSize(); } else if (seg->getType() == jbig2SegCodeTable) { codeTables.push_back(seg); } } else { error(errSyntaxError, curStr->getPos(), ""Invalid segment reference in JBIG2 text region""); return; } } i = numSyms; if (i <= 1) { symCodeLen = huff ? 1 : 0; } else { --i; symCodeLen = 0; while (i > 0) { ++symCodeLen; i >>= 1; } } syms = (JBIG2Bitmap **)gmallocn_checkoverflow(numSyms, sizeof(JBIG2Bitmap *)); if (numSyms > 0 && !syms) { return; } kk = 0; for (i = 0; i < nRefSegs; ++i) { if ((seg = findSegment(refSegs[i]))) { if (seg->getType() == jbig2SegSymbolDict) { symbolDict = (JBIG2SymbolDict *)seg; for (k = 0; k < symbolDict->getSize(); ++k) { syms[kk++] = symbolDict->getBitmap(k); } } } } huffFSTable = huffDSTable = huffDTTable = nullptr;     huffRDWTable = huffRDHTable = nullptr;     huffRDXTable = huffRDYTable = huffRSizeTable = nullptr;     i = 0; if (huff) { if (huffFS == 0) { huffFSTable = huffTableF; } else if (huffFS == 1) { huffFSTable = huffTableG; } else { if (i >= codeTables.size()) { goto codeTableError; } huffFSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffDS == 0) { huffDSTable = huffTableH; } else if (huffDS == 1) { huffDSTable = huffTableI; } else if (huffDS == 2) { huffDSTable = huffTableJ; } else { if (i >= codeTables.size()) { goto codeTableError; } huffDSTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffDT == 0) { huffDTTable = huffTableK; } else if (huffDT == 1) { huffDTTable = huffTableL; } else if (huffDT == 2) { huffDTTable = huffTableM; } else { if (i >= codeTables.size()) { goto codeTableError; } huffDTTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDW == 0) { huffRDWTable = huffTableN; } else if (huffRDW == 1) { huffRDWTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDWTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDH == 0) { huffRDHTable = huffTableN; } else if (huffRDH == 1) { huffRDHTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDHTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDX == 0) { huffRDXTable = huffTableN; } else if (huffRDX == 1) { huffRDXTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDXTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRDY == 0) { huffRDYTable = huffTableN; } else if (huffRDY == 1) { huffRDYTable = huffTableO; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRDYTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } if (huffRSize == 0) { huffRSizeTable = huffTableA; } else { if (i >= codeTables.size()) { goto codeTableError; } huffRSizeTable = ((JBIG2CodeTable *)codeTables[i++])->getHuffTable(); } } if (huff) { huffDecoder->reset(); for (i = 0; i < 32; ++i) { runLengthTab[i].val = i; runLengthTab[i].prefixLen = huffDecoder->readBits(4); runLengthTab[i].rangeLen = 0; } runLengthTab[32].val = 0x103; runLengthTab[32].prefixLen = huffDecoder->readBits(4); runLengthTab[32].rangeLen = 2; runLengthTab[33].val = 0x203; runLengthTab[33].prefixLen = huffDecoder->readBits(4); runLengthTab[33].rangeLen = 3; runLengthTab[34].val = 0x20b; runLengthTab[34].prefixLen = huffDecoder->readBits(4); runLengthTab[34].rangeLen = 7; runLengthTab[35].prefixLen = 0; runLengthTab[35].rangeLen = jbig2HuffmanEOT; if (!JBIG2HuffmanDecoder::buildTable(runLengthTab, 35)) { huff = false; } } if (huff) { symCodeTab = (JBIG2HuffmanTable *)gmallocn_checkoverflow(numSyms + 1, sizeof(JBIG2HuffmanTable)); if (!symCodeTab) { gfree(syms); return; } for (i = 0; i < numSyms; ++i) { symCodeTab[i].val = i; symCodeTab[i].rangeLen = 0; } i = 0; while (i < numSyms) { huffDecoder->decodeInt(&j, runLengthTab); if (j > 0x200) { for (j -= 0x200; j && i < numSyms; --j) { symCodeTab[i++].prefixLen = 0; } } else if (j > 0x100) { if (unlikely(i == 0)) { symCodeTab[i].prefixLen = 0; ++i; } for (j -= 0x100; j && i < numSyms; --j) { symCodeTab[i].prefixLen = symCodeTab[i - 1].prefixLen; ++i; } } else { symCodeTab[i++].prefixLen = j; } } symCodeTab[numSyms].prefixLen = 0; symCodeTab[numSyms].rangeLen = jbig2HuffmanEOT; if (!JBIG2HuffmanDecoder::buildTable(symCodeTab, numSyms)) { huff = false; gfree(symCodeTab); symCodeTab = nullptr; } huffDecoder->reset(); } if (!huff) { if (!resetIntStats(symCodeLen)) { gfree(syms); return; } arithDecoder->start(); } if (refine) { resetRefinementStats(templ, nullptr); } bitmap = readTextRegion(huff, refine, w, h, numInstances, logStrips, numSyms, symCodeTab, symCodeLen, syms, defPixel, combOp, transposed, refCorner, sOffset, huffFSTable, huffDSTable, huffDTTable, huffRDWTable, huffRDHTable, huffRDXTable, huffRDYTable, huffRSizeTable, templ, atx, aty); gfree(syms); if (bitmap) { if (imm) { if (pageH == 0xffffffff && y + h > curPageH) { pageBitmap->expand(y + h, pageDefPixel); } if (pageBitmap->isOk()) { pageBitmap->combine(bitmap.get(), x, y, extCombOp); } } else { bitmap->setSegNum(segNum); segments.push_back(std::move(bitmap)); } } if (huff) { gfree(symCodeTab); } return; codeTableError: error(errSyntaxError, curStr->getPos(), ""Missing code table in JBIG2 text region""); gfree(syms); return; eofError: error(errSyntaxError, curStr->getPos(), ""Unexpected EOF in JBIG2 stream""); return; }"
"int Reverb_setParameter (ReverbContext *pContext, void *pParam, void *pValue){ int status = 0; int16_t level; int16_t ratio; uint32_t time; t_reverb_settings *pProperties; int32_t *pParamTemp = (int32_t *)pParam; int32_t param = *pParamTemp++; if (pContext->preset) { if (param != REVERB_PARAM_PRESET) { return -EINVAL; } uint16_t preset = *(uint16_t *)pValue; ALOGV(""set REVERB_PARAM_PRESET, preset %d"", preset); if (preset > REVERB_PRESET_LAST) { return -EINVAL; } pContext->nextPreset = preset; return 0; } switch (param){ case REVERB_PARAM_PROPERTIES: ALOGV(""\tReverb_setParameter() REVERB_PARAM_PROPERTIES""); pProperties = (t_reverb_settings *) pValue; ReverbSetRoomLevel(pContext, pProperties->roomLevel); ReverbSetRoomHfLevel(pContext, pProperties->roomHFLevel); ReverbSetDecayTime(pContext, pProperties->decayTime); ReverbSetDecayHfRatio(pContext, pProperties->decayHFRatio); ReverbSetReverbLevel(pContext, pProperties->reverbLevel); ReverbSetDiffusion(pContext, pProperties->diffusion); ReverbSetDensity(pContext, pProperties->density); break; case REVERB_PARAM_ROOM_LEVEL: level = *(int16_t *)pValue; ReverbSetRoomLevel(pContext, level); break; case REVERB_PARAM_ROOM_HF_LEVEL: level = *(int16_t *)pValue; ReverbSetRoomHfLevel(pContext, level); break; case REVERB_PARAM_DECAY_TIME: time = *(uint32_t *)pValue; ReverbSetDecayTime(pContext, time); break; case REVERB_PARAM_DECAY_HF_RATIO: ratio = *(int16_t *)pValue; ReverbSetDecayHfRatio(pContext, ratio); break; case REVERB_PARAM_REVERB_LEVEL: level = *(int16_t *)pValue; ReverbSetReverbLevel(pContext, level); break; case REVERB_PARAM_DIFFUSION: ratio = *(int16_t *)pValue; ReverbSetDiffusion(pContext, ratio); break; case REVERB_PARAM_DENSITY: ratio = *(int16_t *)pValue; ReverbSetDensity(pContext, ratio); break; break; case REVERB_PARAM_REFLECTIONS_LEVEL: case REVERB_PARAM_REFLECTIONS_DELAY: case REVERB_PARAM_REVERB_DELAY: break; default: ALOGV(""\tLVM_ERROR : Reverb_setParameter() invalid param %d"", param); break; } return status; }"
"static FILE* FIO_openDstFile(FIO_prefs_t* const prefs, const char* srcFileName, const char* dstFileName) { assert(dstFileName != NULL); if (!strcmp (dstFileName, stdoutmark)) { DISPLAYLEVEL(4,""Using stdout for output \n""); SET_BINARY_MODE(stdout); if (prefs->sparseFileSupport == 1) { prefs->sparseFileSupport = 0; DISPLAYLEVEL(4, ""Sparse File Support is automatically disabled on stdout ; try --sparse \n""); } return stdout; } if (srcFileName != NULL && UTIL_isSameFile(srcFileName, dstFileName)) { DISPLAYLEVEL(1, ""zstd: Refusing to open an output file which will overwrite the input file \n""); return NULL; } if (prefs->sparseFileSupport == 1) { prefs->sparseFileSupport = ZSTD_SPARSE_DEFAULT; } if (UTIL_isRegularFile(dstFileName)) { FILE* const fCheck = fopen( dstFileName, ""rb"" ); if (!strcmp(dstFileName, nulmark)) { EXM_THROW(40, ""%s is unexpectedly categorized as a regular file"", dstFileName); } if (fCheck != NULL) {   fclose(fCheck); if (!prefs->overwrite) { if (g_display_prefs.displayLevel <= 1) { DISPLAY(""zstd: %s already exists; not overwritten  \n"", dstFileName); return NULL; } DISPLAY(""zstd: %s already exists; overwrite (y/N) ? "", dstFileName); {   int ch = getchar(); if ((ch!='Y') && (ch!='y')) { DISPLAY(""    not overwritten  \n""); return NULL; } while ((ch!=EOF) && (ch!='\n')) ch = getchar(); }   } FIO_remove(dstFileName); }   } {   FILE* const f = fopen( dstFileName, ""wb"" ); if (f == NULL) DISPLAYLEVEL(1, ""zstd: %s: %s\n"", dstFileName, strerror(errno)); return f; } }"
"int map_vcpu_info(struct vcpu *v, unsigned long gfn, unsigned offset) { struct domain *d = v->domain; void *mapping; vcpu_info_t *new_info; struct page_info *page; if ( offset > (PAGE_SIZE - sizeof(vcpu_info_t)) ) return -EINVAL; if ( !mfn_eq(v->vcpu_info_mfn, INVALID_MFN) ) return -EINVAL; if ( (v != current) && !(v->pause_flags & VPF_down) ) return -EINVAL; page = get_page_from_gfn(d, gfn, NULL, P2M_ALLOC); if ( !page ) return -EINVAL; if ( !get_page_type(page, PGT_writable_page) ) { put_page(page); return -EINVAL; } mapping = __map_domain_page_global(page); if ( mapping == NULL ) { put_page_and_type(page); return -ENOMEM; } new_info = (vcpu_info_t *)(mapping + offset); if ( v->vcpu_info == &dummy_vcpu_info ) { memset(new_info, 0, sizeof(*new_info)); #ifdef XEN_HAVE_PV_UPCALL_MASK __vcpu_info(v, new_info, evtchn_upcall_mask) = 1; #endif } else { memcpy(new_info, v->vcpu_info, sizeof(*new_info)); } v->vcpu_info = new_info; v->vcpu_info_mfn = page_to_mfn(page); smp_wmb(); #ifdef CONFIG_COMPAT if ( !has_32bit_shinfo(d) ) write_atomic(&new_info->native.evtchn_pending_sel, ~0); else #endif write_atomic(&vcpu_info(v, evtchn_pending_sel), ~0); vcpu_mark_events_pending(v); return 0; }"
"void stackswap() { #ifdef DEBUG printf(""*stackswap*\n""); #endif struct SWF_ACTIONPUSHPARAM *p = peek(); char type = Stack->type; Stack->type = Stack->next->type; Stack->val  = Stack->next->val; Stack->next->type = type; Stack->next->val  = p; }"
"static ssize_t set_ignore_ce(struct device *s, struct device_attribute *attr, const char *buf, size_t size) { u64 new; if (kstrtou64(buf, 0, &new) < 0) return -EINVAL; if (mca_cfg.ignore_ce ^ !!new) { if (new) { mce_timer_delete_all(); on_each_cpu(mce_disable_cmci, NULL, 1); mca_cfg.ignore_ce = true; } else { mca_cfg.ignore_ce = false; on_each_cpu(mce_enable_ce, (void *)1, 1); } } return size; }"
"QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir) { if(!zip.open(QuaZip::mdUnzip)) { return QStringList(); } QDir directory(dir); QStringList extracted; if (!zip.goToFirstFile()) { return QStringList(); } do { QString name = zip.getCurrentFileName(); QString absFilePath = directory.absoluteFilePath(name); if (!extractFile(&zip, """", absFilePath)) { removeFile(extracted); return QStringList(); } extracted.append(absFilePath); } while (zip.goToNextFile()); zip.close(); if(zip.getZipError()!=0) { removeFile(extracted); return QStringList(); } return extracted; }"
"int lldp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware, struct lldpd_chassis **newchassis, struct lldpd_port **newport) { struct lldpd_chassis *chassis; struct lldpd_port *port; const char lldpaddr[] = LLDP_MULTICAST_ADDR; const char dot1[] = LLDP_TLV_ORG_DOT1; const char dot3[] = LLDP_TLV_ORG_DOT3; const char med[] = LLDP_TLV_ORG_MED; const char dcbx[] = LLDP_TLV_ORG_DCBX; unsigned char orgid[3]; int length, gotend = 0, ttl_received = 0; int tlv_size, tlv_type, tlv_subtype; u_int8_t *pos, *tlv; char *b; #ifdef ENABLE_DOT1 struct lldpd_vlan *vlan = NULL; int vlan_len; struct lldpd_ppvid *ppvid; struct lldpd_pi *pi = NULL; #endif struct lldpd_mgmt *mgmt; int af; u_int8_t addr_str_length, addr_str_buffer[32]; u_int8_t addr_family, addr_length, *addr_ptr, iface_subtype; u_int32_t iface_number, iface; #ifdef ENABLE_CUSTOM struct lldpd_custom *custom = NULL; #endif log_debug(""lldp"", ""receive LLDP PDU on %s"", hardware->h_ifname); if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) { log_warn(""lldp"", ""failed to allocate remote chassis""); return -1; } TAILQ_INIT(&chassis->c_mgmt); if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) { log_warn(""lldp"", ""failed to allocate remote port""); free(chassis); return -1; } #ifdef ENABLE_DOT1 TAILQ_INIT(&port->p_vlans); TAILQ_INIT(&port->p_ppvids); TAILQ_INIT(&port->p_pids); #endif #ifdef ENABLE_CUSTOM TAILQ_INIT(&port->p_custom_list); #endif length = s; pos = (u_int8_t*)frame; if (length < 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) { log_warnx(""lldp"", ""too short frame received on %s"", hardware->h_ifname); goto malformed; } if (PEEK_CMP(lldpaddr, ETHER_ADDR_LEN) != 0) { log_info(""lldp"", ""frame not targeted at LLDP multicast address received on %s"", hardware->h_ifname); goto malformed; } PEEK_DISCARD(ETHER_ADDR_LEN); if (PEEK_UINT16 != ETHERTYPE_LLDP) { log_info(""lldp"", ""non LLDP frame received on %s"", hardware->h_ifname); goto malformed; } while (length && (!gotend)) { if (length < 2) { log_warnx(""lldp"", ""tlv header too short received on %s"", hardware->h_ifname); goto malformed; } tlv_size = PEEK_UINT16; tlv_type = tlv_size >> 9; tlv_size = tlv_size & 0x1ff; (void)PEEK_SAVE(tlv); if (length < tlv_size) { log_warnx(""lldp"", ""frame too short for tlv received on %s"", hardware->h_ifname); goto malformed; } switch (tlv_type) { case LLDP_TLV_END: if (tlv_size != 0) { log_warnx(""lldp"", ""lldp end received with size not null on %s"", hardware->h_ifname); goto malformed; } if (length) log_debug(""lldp"", ""extra data after lldp end on %s"", hardware->h_ifname); gotend = 1; break; case LLDP_TLV_CHASSIS_ID: case LLDP_TLV_PORT_ID: CHECK_TLV_SIZE(2, ""Port Id""); tlv_subtype = PEEK_UINT8; if ((tlv_subtype == 0) || (tlv_subtype > 7)) { log_warnx(""lldp"", ""unknown subtype for tlv id received on %s"", hardware->h_ifname); goto malformed; } if ((b = (char *)calloc(1, tlv_size - 1)) == NULL) { log_warn(""lldp"", ""unable to allocate memory for id tlv "" ""received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(b, tlv_size - 1); if (tlv_type == LLDP_TLV_PORT_ID) { port->p_id_subtype = tlv_subtype; port->p_id = b; port->p_id_len = tlv_size - 1; } else { chassis->c_id_subtype = tlv_subtype; chassis->c_id = b; chassis->c_id_len = tlv_size - 1; } break; case LLDP_TLV_TTL: CHECK_TLV_SIZE(2, ""TTL""); chassis->c_ttl = PEEK_UINT16; ttl_received = 1; break; case LLDP_TLV_PORT_DESCR: case LLDP_TLV_SYSTEM_NAME: case LLDP_TLV_SYSTEM_DESCR: if (tlv_size < 1) { log_debug(""lldp"", ""empty tlv received on %s"", hardware->h_ifname); break; } if ((b = (char *)calloc(1, tlv_size + 1)) == NULL) { log_warn(""lldp"", ""unable to allocate memory for string tlv "" ""received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(b, tlv_size); if (tlv_type == LLDP_TLV_PORT_DESCR) port->p_descr = b; else if (tlv_type == LLDP_TLV_SYSTEM_NAME) chassis->c_name = b; else chassis->c_descr = b; break; case LLDP_TLV_SYSTEM_CAP: CHECK_TLV_SIZE(4, ""System capabilities""); chassis->c_cap_available = PEEK_UINT16; chassis->c_cap_enabled = PEEK_UINT16; break; case LLDP_TLV_MGMT_ADDR: CHECK_TLV_SIZE(1, ""Management address""); addr_str_length = PEEK_UINT8; CHECK_TLV_SIZE(1 + addr_str_length, ""Management address""); PEEK_BYTES(addr_str_buffer, addr_str_length); addr_length = addr_str_length - 1; addr_family = addr_str_buffer[0]; addr_ptr = &addr_str_buffer[1]; CHECK_TLV_SIZE(1 + addr_str_length + 5, ""Management address""); iface_subtype = PEEK_UINT8; iface_number = PEEK_UINT32; af = lldpd_af_from_lldp_proto(addr_family); if (af == LLDPD_AF_UNSPEC) break; if (iface_subtype == LLDP_MGMT_IFACE_IFINDEX) iface = iface_number; else iface = 0; mgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface); if (mgmt == NULL) { assert(errno == ENOMEM); log_warn(""lldp"", ""unable to allocate memory "" ""for management address""); goto malformed; } TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries); break; case LLDP_TLV_ORG: CHECK_TLV_SIZE(4, ""Organisational""); PEEK_BYTES(orgid, sizeof(orgid)); tlv_subtype = PEEK_UINT8; if (memcmp(dot1, orgid, sizeof(orgid)) == 0) { #ifndef ENABLE_DOT1 hardware->h_rx_unrecognized_cnt++; #else switch (tlv_subtype) { case LLDP_TLV_DOT1_VLANNAME: CHECK_TLV_SIZE(7, ""VLAN""); if ((vlan = (struct lldpd_vlan *)calloc(1, sizeof(struct lldpd_vlan))) == NULL) { log_warn(""lldp"", ""unable to alloc vlan "" ""structure for "" ""tlv received on %s"", hardware->h_ifname); goto malformed; } vlan->v_vid = PEEK_UINT16; vlan_len = PEEK_UINT8; CHECK_TLV_SIZE(7 + vlan_len, ""VLAN""); if ((vlan->v_name = (char *)calloc(1, vlan_len + 1)) == NULL) { log_warn(""lldp"", ""unable to alloc vlan name for "" ""tlv received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(vlan->v_name, vlan_len); TAILQ_INSERT_TAIL(&port->p_vlans, vlan, v_entries); vlan = NULL; break; case LLDP_TLV_DOT1_PVID: CHECK_TLV_SIZE(6, ""PVID""); port->p_pvid = PEEK_UINT16; break; case LLDP_TLV_DOT1_PPVID: CHECK_TLV_SIZE(7, ""PPVID""); if ((ppvid = (struct lldpd_ppvid *)calloc(1, sizeof(struct lldpd_ppvid))) == NULL) { log_warn(""lldp"", ""unable to alloc ppvid "" ""structure for "" ""tlv received on %s"", hardware->h_ifname); goto malformed; } ppvid->p_cap_status = PEEK_UINT8; ppvid->p_ppvid = PEEK_UINT16; TAILQ_INSERT_TAIL(&port->p_ppvids, ppvid, p_entries); break; case LLDP_TLV_DOT1_PI: CHECK_TLV_SIZE(5, ""PI""); if ((pi = (struct lldpd_pi *)calloc(1, sizeof(struct lldpd_pi))) == NULL) { log_warn(""lldp"", ""unable to alloc PI "" ""structure for "" ""tlv received on %s"", hardware->h_ifname); goto malformed; } pi->p_pi_len = PEEK_UINT8; CHECK_TLV_SIZE(5 + pi->p_pi_len, ""PI""); if ((pi->p_pi = (char *)calloc(1, pi->p_pi_len)) == NULL) { log_warn(""lldp"", ""unable to alloc pid name for "" ""tlv received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(pi->p_pi, pi->p_pi_len); TAILQ_INSERT_TAIL(&port->p_pids, pi, p_entries); pi = NULL; break; default: hardware->h_rx_unrecognized_cnt++; } #endif } else if (memcmp(dot3, orgid, sizeof(orgid)) == 0) { #ifndef ENABLE_DOT3 hardware->h_rx_unrecognized_cnt++; #else switch (tlv_subtype) { case LLDP_TLV_DOT3_MAC: CHECK_TLV_SIZE(9, ""MAC/PHY""); port->p_macphy.autoneg_support = PEEK_UINT8; port->p_macphy.autoneg_enabled = (port->p_macphy.autoneg_support & 0x2) >> 1; port->p_macphy.autoneg_support = port->p_macphy.autoneg_support & 0x1; port->p_macphy.autoneg_advertised = PEEK_UINT16; port->p_macphy.mau_type = PEEK_UINT16; break; case LLDP_TLV_DOT3_LA: CHECK_TLV_SIZE(9, ""Link aggregation""); PEEK_DISCARD_UINT8; port->p_aggregid = PEEK_UINT32; break; case LLDP_TLV_DOT3_MFS: CHECK_TLV_SIZE(6, ""MFS""); port->p_mfs = PEEK_UINT16; break; case LLDP_TLV_DOT3_POWER: CHECK_TLV_SIZE(7, ""Power""); port->p_power.devicetype = PEEK_UINT8; port->p_power.supported = (port->p_power.devicetype & 0x2) >> 1; port->p_power.enabled = (port->p_power.devicetype & 0x4) >> 2; port->p_power.paircontrol = (port->p_power.devicetype & 0x8) >> 3; port->p_power.devicetype = (port->p_power.devicetype & 0x1)? LLDP_DOT3_POWER_PSE:LLDP_DOT3_POWER_PD; port->p_power.pairs = PEEK_UINT8; port->p_power.class = PEEK_UINT8; if (tlv_size >= 12) { port->p_power.powertype = PEEK_UINT8; port->p_power.source = (port->p_power.powertype & (1<<5 | 1<<4)) >> 4; port->p_power.priority = (port->p_power.powertype & (1<<1 | 1<<0)); port->p_power.powertype = (port->p_power.powertype & (1<<7))? LLDP_DOT3_POWER_8023AT_TYPE1: LLDP_DOT3_POWER_8023AT_TYPE2; port->p_power.requested = PEEK_UINT16; port->p_power.allocated = PEEK_UINT16; } else port->p_power.powertype = LLDP_DOT3_POWER_8023AT_OFF; break; default: hardware->h_rx_unrecognized_cnt++; } #endif } else if (memcmp(med, orgid, sizeof(orgid)) == 0) { #ifndef ENABLE_LLDPMED hardware->h_rx_unrecognized_cnt++; #else u_int32_t policy; unsigned loctype; unsigned power; switch (tlv_subtype) { case LLDP_TLV_MED_CAP: CHECK_TLV_SIZE(7, ""LLDP-MED capabilities""); chassis->c_med_cap_available = PEEK_UINT16; chassis->c_med_type = PEEK_UINT8; port->p_med_cap_enabled |= LLDP_MED_CAP_CAP; break; case LLDP_TLV_MED_POLICY: CHECK_TLV_SIZE(8, ""LLDP-MED policy""); policy = PEEK_UINT32; if (((policy >> 24) < 1) || ((policy >> 24) > LLDP_MED_APPTYPE_LAST)) { log_info(""lldp"", ""unknown policy field %d "" ""received on %s"", policy, hardware->h_ifname); break; } port->p_med_policy[(policy >> 24) - 1].type = (policy >> 24); port->p_med_policy[(policy >> 24) - 1].unknown = ((policy & 0x800000) != 0); port->p_med_policy[(policy >> 24) - 1].tagged = ((policy & 0x400000) != 0); port->p_med_policy[(policy >> 24) - 1].vid = (policy & 0x001FFE00) >> 9; port->p_med_policy[(policy >> 24) - 1].priority = (policy & 0x1C0) >> 6; port->p_med_policy[(policy >> 24) - 1].dscp = policy & 0x3F; port->p_med_cap_enabled |= LLDP_MED_CAP_POLICY; break; case LLDP_TLV_MED_LOCATION: CHECK_TLV_SIZE(5, ""LLDP-MED Location""); loctype = PEEK_UINT8; if ((loctype < 1) || (loctype > LLDP_MED_LOCFORMAT_LAST)) { log_info(""lldp"", ""unknown location type "" ""received on %s"", hardware->h_ifname); break; } if ((port->p_med_location[loctype - 1].data = (char*)malloc(tlv_size - 5)) == NULL) { log_warn(""lldp"", ""unable to allocate memory "" ""for LLDP-MED location for "" ""frame received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(port->p_med_location[loctype - 1].data, tlv_size - 5); port->p_med_location[loctype - 1].data_len = tlv_size - 5; port->p_med_location[loctype - 1].format = loctype; port->p_med_cap_enabled |= LLDP_MED_CAP_LOCATION; break; case LLDP_TLV_MED_MDI: CHECK_TLV_SIZE(7, ""LLDP-MED PoE-MDI""); power = PEEK_UINT8; switch (power & 0xC0) { case 0x0: port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PSE; port->p_med_cap_enabled |= LLDP_MED_CAP_MDI_PSE; switch (power & 0x30) { case 0x0: port->p_med_power.source = LLDP_MED_POW_SOURCE_UNKNOWN; break; case 0x10: port->p_med_power.source = LLDP_MED_POW_SOURCE_PRIMARY; break; case 0x20: port->p_med_power.source = LLDP_MED_POW_SOURCE_BACKUP; break; default: port->p_med_power.source = LLDP_MED_POW_SOURCE_RESERVED; } break; case 0x40: port->p_med_power.devicetype = LLDP_MED_POW_TYPE_PD; port->p_med_cap_enabled |= LLDP_MED_CAP_MDI_PD; switch (power & 0x30) { case 0x0: port->p_med_power.source = LLDP_MED_POW_SOURCE_UNKNOWN; break; case 0x10: port->p_med_power.source = LLDP_MED_POW_SOURCE_PSE; break; case 0x20: port->p_med_power.source = LLDP_MED_POW_SOURCE_LOCAL; break; default: port->p_med_power.source = LLDP_MED_POW_SOURCE_BOTH; } break; default: port->p_med_power.devicetype = LLDP_MED_POW_TYPE_RESERVED; } if ((power & 0x0F) > LLDP_MED_POW_PRIO_LOW) port->p_med_power.priority = LLDP_MED_POW_PRIO_UNKNOWN; else port->p_med_power.priority = power & 0x0F; port->p_med_power.val = PEEK_UINT16; break; case LLDP_TLV_MED_IV_HW: case LLDP_TLV_MED_IV_SW: case LLDP_TLV_MED_IV_FW: case LLDP_TLV_MED_IV_SN: case LLDP_TLV_MED_IV_MANUF: case LLDP_TLV_MED_IV_MODEL: case LLDP_TLV_MED_IV_ASSET: if (tlv_size <= 4) b = NULL; else { if ((b = (char*)malloc(tlv_size - 3)) == NULL) { log_warn(""lldp"", ""unable to allocate "" ""memory for LLDP-MED "" ""inventory for frame "" ""received on %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(b, tlv_size - 4); b[tlv_size - 4] = '\0'; } switch (tlv_subtype) { case LLDP_TLV_MED_IV_HW: chassis->c_med_hw = b; break; case LLDP_TLV_MED_IV_FW: chassis->c_med_fw = b; break; case LLDP_TLV_MED_IV_SW: chassis->c_med_sw = b; break; case LLDP_TLV_MED_IV_SN: chassis->c_med_sn = b; break; case LLDP_TLV_MED_IV_MANUF: chassis->c_med_manuf = b; break; case LLDP_TLV_MED_IV_MODEL: chassis->c_med_model = b; break; case LLDP_TLV_MED_IV_ASSET: chassis->c_med_asset = b; break; } port->p_med_cap_enabled |= LLDP_MED_CAP_IV; break; default: hardware->h_rx_unrecognized_cnt++; } #endif  } else if (memcmp(dcbx, orgid, sizeof(orgid)) == 0) { log_debug(""lldp"", ""unsupported DCBX tlv received on %s - ignore"", hardware->h_ifname); hardware->h_rx_unrecognized_cnt++; } else { log_debug(""lldp"", ""unknown org tlv [%02x:%02x:%02x] received on %s"", orgid[0], orgid[1], orgid[2], hardware->h_ifname); hardware->h_rx_unrecognized_cnt++; #ifdef ENABLE_CUSTOM custom = (struct lldpd_custom*)calloc(1, sizeof(struct lldpd_custom)); if (!custom) { log_warn(""lldp"", ""unable to allocate memory for custom TLV""); goto malformed; } custom->oui_info_len = tlv_size > 4 ? tlv_size - 4 : 0; memcpy(custom->oui, orgid, sizeof(custom->oui)); custom->subtype = tlv_subtype; if (custom->oui_info_len > 0) { custom->oui_info = malloc(custom->oui_info_len); if (!custom->oui_info) { log_warn(""lldp"", ""unable to allocate memory for custom TLV data""); goto malformed; } PEEK_BYTES(custom->oui_info, custom->oui_info_len); } TAILQ_INSERT_TAIL(&port->p_custom_list, custom, next); custom = NULL; #endif } break; default: log_warnx(""lldp"", ""unknown tlv (%d) received on %s"", tlv_type, hardware->h_ifname); goto malformed; } if (pos > tlv + tlv_size) { log_warnx(""lldp"", ""BUG: already past TLV!""); goto malformed; } PEEK_DISCARD(tlv + tlv_size - pos); } if ((chassis->c_id == NULL) || (port->p_id == NULL) || (!ttl_received) || (gotend == 0)) { log_warnx(""lldp"", ""some mandatory tlv are missing for frame received on %s"", hardware->h_ifname); goto malformed; } *newchassis = chassis; *newport = port; return 1; malformed: #ifdef ENABLE_CUSTOM free(custom); #endif #ifdef ENABLE_DOT1 free(vlan); free(pi); #endif lldpd_chassis_cleanup(chassis, 1); lldpd_port_cleanup(port, 1); free(port); return -1; }"
"static void g_vfs_daemon_finalize (GObject *object) { GVfsDaemon *daemon; daemon = G_VFS_DAEMON (object); if (daemon->jobs) g_warning (""daemon->jobs != NULL when finalizing daemon!""); if (daemon->name_watcher) g_bus_unwatch_name (daemon->name_watcher); if (daemon->daemon_skeleton != NULL) { g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton)); g_object_unref (daemon->daemon_skeleton); } if (daemon->mountable_skeleton != NULL) { g_dbus_interface_skeleton_unexport (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton)); g_object_unref (daemon->mountable_skeleton); } if (daemon->conn != NULL) g_object_unref (daemon->conn); g_hash_table_destroy (daemon->registered_paths); g_hash_table_destroy (daemon->client_connections); g_mutex_clear (&daemon->lock); if (G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object); }"
"static inline unsigned long rdgsshadow(void) { unsigned long base; if ( cpu_has_fsgsbase ) { asm volatile ( ""swapgs"" ); base = __rdgsbase(); asm volatile ( ""swapgs"" ); } else rdmsrl(MSR_SHADOW_GS_BASE, base); return base; }"
"void ActivityListModel::triggerDefaultAction(int activityIndex) { if (activityIndex < 0 || activityIndex >= _finalList.size()) { qCWarning(lcActivity) << ""Couldn't trigger default action at index"" << activityIndex << ""/ final list size:"" << _finalList.size(); return; } const auto modelIndex = index(activityIndex); const auto path = data(modelIndex, PathRole).toUrl(); const auto activity = _finalList.at(activityIndex); if (activity._status == SyncFileItem::Conflict) { Q_ASSERT(!activity._file.isEmpty()); Q_ASSERT(!activity._folder.isEmpty()); Q_ASSERT(Utility::isConflictFile(activity._file)); const auto folder = FolderMan::instance()->folder(activity._folder); const auto conflictedRelativePath = activity._file; const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8()); const auto dir = QDir(folder->path()); const auto conflictedPath = dir.filePath(conflictedRelativePath); const auto basePath = dir.filePath(baseRelativePath); const auto baseName = QFileInfo(basePath).fileName(); if (!_currentConflictDialog.isNull()) { _currentConflictDialog->close(); } _currentConflictDialog = new ConflictDialog; _currentConflictDialog->setBaseFilename(baseName); _currentConflictDialog->setLocalVersionFilename(conflictedPath); _currentConflictDialog->setRemoteVersionFilename(basePath); _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose); connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() { folder->scheduleThisFolderSoon(); }); _currentConflictDialog->open(); ownCloudGui::raiseDialog(_currentConflictDialog); return; } if (path.isValid()) { QDesktopServices::openUrl(path); } else { const auto link = data(modelIndex, LinkRole).toUrl(); QDesktopServices::openUrl(link); } }"
"static bfd_boolean print_symbol_for_build_attribute (FILE *         file, unsigned long  offset, bfd_boolean    is_open_attr) { static FILE *             saved_file = NULL; static char *             strtab; static unsigned long      strtablen; static Elf_Internal_Sym * symtab; static unsigned long      nsyms; Elf_Internal_Sym *  saved_sym = NULL; Elf_Internal_Sym *  sym; if (saved_file == NULL || file != saved_file) { Elf_Internal_Shdr * symsec; for (symsec = section_headers; symsec < section_headers + elf_header.e_shnum; symsec ++) { if (symsec->sh_type == SHT_SYMTAB) { symtab = GET_ELF_SYMBOLS (file, symsec, & nsyms); if (symsec->sh_link < elf_header.e_shnum) { Elf_Internal_Shdr * strtab_sec = section_headers + symsec->sh_link; strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset, 1, strtab_sec->sh_size, _(""string table"")); strtablen = strtab != NULL ? strtab_sec->sh_size : 0; } } } saved_file = file; } if (symtab == NULL || strtab == NULL) { printf (""\n""); return FALSE; } for (sym = symtab; sym < symtab + nsyms; sym ++) if (sym->st_value == offset) { if (sym->st_name >= strtablen) continue; if (strtab[sym->st_name] == 0) continue; if (is_open_attr) { switch (ELF_ST_TYPE (sym->st_info)) { case STT_FILE: saved_sym = sym; sym = symtab + nsyms; continue; case STT_OBJECT: saved_sym = sym; continue; case STT_FUNC: continue; default: break; } switch (ELF_ST_BIND (sym->st_info)) { case STB_GLOBAL: if (saved_sym == NULL || ELF_ST_TYPE (saved_sym->st_info) != STT_OBJECT) saved_sym = sym; break; case STB_LOCAL: if (saved_sym == NULL) saved_sym = sym; break; default: break; } } else { if (ELF_ST_TYPE (sym->st_info) != STT_FUNC) continue; saved_sym = sym; break; } } printf ("" (%s: %s)\n"", is_open_attr ? _(""file"") : _(""func""), saved_sym ? strtab + saved_sym->st_name : _(""<no symbol found>)"")); return TRUE; }"
"static int ptrace_setoptions(struct task_struct *child, unsigned long data) { unsigned flags; if (data & ~(unsigned long)PTRACE_O_MASK) return -EINVAL; if (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) { if (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) || !IS_ENABLED(CONFIG_SECCOMP)) return -EINVAL; if (!capable(CAP_SYS_ADMIN)) return -EPERM; if (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED || current->ptrace & PT_SUSPEND_SECCOMP) return -EPERM; } flags = child->ptrace; flags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT); flags |= (data << PT_OPT_FLAG_SHIFT); child->ptrace = flags; return 0; }"
"static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn) { struct bpf_reg_state *regs = cur_regs(env); u8 opcode = BPF_OP(insn->code); int err; if (opcode == BPF_END || opcode == BPF_NEG) { if (opcode == BPF_NEG) { if (BPF_SRC(insn->code) != 0 || insn->src_reg != BPF_REG_0 || insn->off != 0 || insn->imm != 0) { verbose(env, ""BPF_NEG uses reserved fields\n""); return -EINVAL; } } else { if (insn->src_reg != BPF_REG_0 || insn->off != 0 || (insn->imm != 16 && insn->imm != 32 && insn->imm != 64) || BPF_CLASS(insn->code) == BPF_ALU64) { verbose(env, ""BPF_END uses reserved fields\n""); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, SRC_OP); if (err) return err; if (is_pointer_value(env, insn->dst_reg)) { verbose(env, ""R%d pointer arithmetic prohibited\n"", insn->dst_reg); return -EACCES; } err = check_reg_arg(env, insn->dst_reg, DST_OP); if (err) return err; } else if (opcode == BPF_MOV) { if (BPF_SRC(insn->code) == BPF_X) { if (insn->imm != 0 || insn->off != 0) { verbose(env, ""BPF_MOV uses reserved fields\n""); return -EINVAL; } err = check_reg_arg(env, insn->src_reg, SRC_OP); if (err) return err; } else { if (insn->src_reg != BPF_REG_0 || insn->off != 0) { verbose(env, ""BPF_MOV uses reserved fields\n""); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, DST_OP); if (err) return err; if (BPF_SRC(insn->code) == BPF_X) { if (BPF_CLASS(insn->code) == BPF_ALU64) { regs[insn->dst_reg] = regs[insn->src_reg]; regs[insn->dst_reg].live |= REG_LIVE_WRITTEN; } else { if (is_pointer_value(env, insn->src_reg)) { verbose(env, ""R%d partial copy of pointer\n"", insn->src_reg); return -EACCES; } mark_reg_unknown(env, regs, insn->dst_reg); regs[insn->dst_reg].var_off = tnum_cast( regs[insn->dst_reg].var_off, 4); __update_reg_bounds(&regs[insn->dst_reg]); } } else { regs[insn->dst_reg].type = SCALAR_VALUE; __mark_reg_known(regs + insn->dst_reg, insn->imm); } } else if (opcode > BPF_END) { verbose(env, ""invalid BPF_ALU opcode %x\n"", opcode); return -EINVAL; } else { if (BPF_SRC(insn->code) == BPF_X) { if (insn->imm != 0 || insn->off != 0) { verbose(env, ""BPF_ALU uses reserved fields\n""); return -EINVAL; } err = check_reg_arg(env, insn->src_reg, SRC_OP); if (err) return err; } else { if (insn->src_reg != BPF_REG_0 || insn->off != 0) { verbose(env, ""BPF_ALU uses reserved fields\n""); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, SRC_OP); if (err) return err; if ((opcode == BPF_MOD || opcode == BPF_DIV) && BPF_SRC(insn->code) == BPF_K && insn->imm == 0) { verbose(env, ""div by zero\n""); return -EINVAL; } if ((opcode == BPF_LSH || opcode == BPF_RSH || opcode == BPF_ARSH) && BPF_SRC(insn->code) == BPF_K) { int size = BPF_CLASS(insn->code) == BPF_ALU64 ? 64 : 32; if (insn->imm < 0 || insn->imm >= size) { verbose(env, ""invalid shift %d\n"", insn->imm); return -EINVAL; } } err = check_reg_arg(env, insn->dst_reg, DST_OP_NO_MARK); if (err) return err; return adjust_reg_min_max_vals(env, insn); } return 0; }"
"Status operator()(OpKernelContext* context, const Tensor& default_value_t, const Tensor& indices_t, const Tensor& values_t, const Tensor& dense_shape_t, typename AsyncOpKernel::DoneCallback done) { const int kEmptyRowIndicatorOutput = 2; const auto default_value = default_value_t.scalar<T>(); const auto indices = indices_t.matrix<Tindex>(); const auto values = values_t.vec<T>(); const auto dense_shape = dense_shape_t.vec<Tindex>(); const Tindex N = indices_t.shape().dim_size(0); const int rank = indices_t.shape().dim_size(1); const Tindex dense_rows = dense_shape(0);      DataType index_type = DataTypeToEnum<Tindex>::value; const GPUDevice& device = context->eigen_device<GPUDevice>(); se::Stream* stream = context->op_device_context()->stream(); if (!stream) return errors::Internal(""No GPU stream available.""); if (dense_rows == 0) { Tindex* output_indices; T* output_values; Tindex* reverse_index_map; TF_RETURN_IF_ERROR(AllocateOutputsExceptEmptyRowIndicator( context, N, rank, 0, &output_indices, &output_values, &reverse_index_map)); if (context->output_required(kEmptyRowIndicatorOutput)) { Tensor* unused = nullptr; TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput, TensorShape({0}), &unused)); } done(); return OkStatus(); } Tensor elements_per_row_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &elements_per_row_t)); auto elements_per_row = elements_per_row_t.flat<Tindex>(); se::DeviceMemoryBase elements_per_row_gpu_memory( elements_per_row.data(), dense_rows * sizeof(Tindex)); if (!stream ->ThenMemZero(&elements_per_row_gpu_memory, dense_rows * sizeof(Tindex)) .ok()) { return errors::Internal(""Failed to zero elements_per_row""); } Tensor rows_are_not_ordered_t; TF_RETURN_IF_ERROR(context->allocate_temp(DT_INT32, TensorShape({1}), &rows_are_not_ordered_t)); auto rows_are_not_ordered_gpu = rows_are_not_ordered_t.flat<int>(); se::DeviceMemoryBase rows_are_not_ordered_gpu_memory( rows_are_not_ordered_gpu.data(), sizeof(int)); if (!stream->ThenMemZero(&rows_are_not_ordered_gpu_memory, sizeof(int)) .ok()) { return errors::Internal(""Failed to zero rows_are_not_ordered""); } Tensor first_invalid_index_t; TF_RETURN_IF_ERROR(context->allocate_temp(DT_INT32, TensorShape({1}), &first_invalid_index_t)); auto first_invalid_index_gpu = first_invalid_index_t.flat<int>(); constexpr const int kAllIndicesValid = std::numeric_limits<int>::max(); se::DeviceMemoryBase first_invalid_index_gpu_memory( first_invalid_index_gpu.data(), sizeof(int)); if (!stream ->ThenMemset32(&first_invalid_index_gpu_memory, kAllIndicesValid, sizeof(int)) .ok()) { return errors::Internal(""Failed to initialize first_invalid_index""); } if (N > 0) { TF_RETURN_IF_ERROR(wrap_kernel_call( CountElementsPerRowKernel<Tindex>, device, N, dense_rows, rank, indices, elements_per_row, rows_are_not_ordered_gpu, first_invalid_index_gpu)); } Tensor input_row_ends_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &input_row_ends_t)); auto input_row_ends = input_row_ends_t.flat<Tindex>(); TF_RETURN_IF_ERROR(GpuInclusivePrefixSum(context, dense_rows, elements_per_row.data(), input_row_ends.data())); Tensor empty_row_indicator_t; bool* empty_row_indicator; if (context->output_required(kEmptyRowIndicatorOutput)) { Tensor* empty_row_indicator_t_ptr = nullptr; TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput, TensorShape({dense_rows}), &empty_row_indicator_t_ptr)); empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data(); } else { TF_RETURN_IF_ERROR(context->allocate_temp( DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t)); empty_row_indicator = empty_row_indicator_t.vec<bool>().data(); } TF_RETURN_IF_ERROR(wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>, device, dense_rows, elements_per_row, empty_row_indicator)); Tensor num_empty_rows_through_t; TF_RETURN_IF_ERROR(context->allocate_temp( index_type, TensorShape({dense_rows}), &num_empty_rows_through_t)); auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>(); gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*> empty_row_indicator_cast(empty_row_indicator, {}); TF_RETURN_IF_ERROR( GpuInclusivePrefixSum(context, dense_rows, empty_row_indicator_cast, num_empty_rows_through.data())); ScratchSpace<Tindex> num_empty_rows_host(context, 1, true); if (!stream ->ThenMemcpy(num_empty_rows_host.mutable_data(), se::DeviceMemoryBase( num_empty_rows_through.data() + (dense_rows - 1), sizeof(*num_empty_rows_host.data())), sizeof(*num_empty_rows_host.data())) .ok()) { return errors::Internal(""Failed to copy num_empty_rows to host""); } ScratchSpace<int> rows_are_not_ordered_host(context, 1, true); if (!stream ->ThenMemcpy(rows_are_not_ordered_host.mutable_data(), rows_are_not_ordered_gpu_memory, sizeof(*rows_are_not_ordered_host.data())) .ok()) { return errors::Internal(""Failed to copy rows_are_not_ordered to host""); } ScratchSpace<int> first_invalid_index_host(context, 1, true); if (!stream ->ThenMemcpy(first_invalid_index_host.mutable_data(), first_invalid_index_gpu_memory, sizeof(*first_invalid_index_host.data())) .ok()) { return errors::Internal(""Failed to copy first_invalid_index to host""); } auto async_finish_computation = [this, context, kAllIndicesValid, index_type, N, rank, indices, values, default_value, dense_rows, num_empty_rows_host, rows_are_not_ordered_host, first_invalid_index_host, num_empty_rows_through_t, num_empty_rows_through, input_row_ends_t, input_row_ends, empty_row_indicator_t, empty_row_indicator, done]() -> void { DCHECK(done);   auto stream = context->op_device_context()->stream(); ScopedActivateExecutorContext scoped_activation{stream->parent()}; int first_invalid_index = *first_invalid_index_host.data(); OP_REQUIRES_ASYNC(context, first_invalid_index == kAllIndicesValid, errors::InvalidArgument(""indices("", first_invalid_index, "", 0) is invalid.""), done); Tindex num_empty_rows = *num_empty_rows_host.data(); Tindex* output_indices; T* output_values; Tindex* reverse_index_map; OP_REQUIRES_OK_ASYNC( context, AllocateOutputsExceptEmptyRowIndicator( context, N, rank, num_empty_rows, &output_indices, &output_values, &reverse_index_map), done); const GPUDevice& device = context->eigen_device<GPUDevice>(); Tindex* input_index_map = nullptr; Tensor input_index_map_t; int rows_are_not_ordered = *rows_are_not_ordered_host.data(); if (rows_are_not_ordered) { OP_REQUIRES_OK_ASYNC(context, ArgSortByRows(context, device, N, rank, dense_rows, indices, &input_index_map_t), done); input_index_map = input_index_map_t.vec<Tindex>().data(); } if (N > 0) { OP_REQUIRES_OK_ASYNC( context, wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>, device, N, dense_rows, rank, input_index_map, indices, values, num_empty_rows_through, output_indices, output_values, reverse_index_map), done); } OP_REQUIRES_OK_ASYNC( context, wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>, device, dense_rows, rank, default_value, num_empty_rows_through, input_row_ends, empty_row_indicator, output_indices, output_values), done); done(); }; context->device() ->tensorflow_accelerator_device_info() ->event_mgr->ThenExecute(stream, async_finish_computation); return OkStatus(); }"
"static void ppp_hdlc(netdissect_options *ndo, const u_char *p, int length) { u_char *b, *t, c; const u_char *s; int i, proto; const void *se; if (length <= 0) return; b = (u_char *)malloc(length); if (b == NULL) return; for (s = p, t = b, i = length; i > 0 && ND_TTEST(*s); i--) { c = *s++; if (c == 0x7d) { if (i <= 1 || !ND_TTEST(*s)) break; i--; c = *s++ ^ 0x20; } *t++ = c; } se = ndo->ndo_snapend; ndo->ndo_snapend = t; length = t - b; if (length < 1) goto trunc; proto = *b;  switch (proto) { case PPP_IP: ip_print(ndo, b + 1, length - 1); goto cleanup; case PPP_IPV6: ip6_print(ndo, b + 1, length - 1); goto cleanup; default:  break; } if (length < 2) goto trunc; proto = EXTRACT_16BITS(b);  switch (proto) { case (PPP_ADDRESS << 8 | PPP_CONTROL):  if (length < 4) goto trunc; proto = EXTRACT_16BITS(b+2);  handle_ppp(ndo, proto, b + 4, length - 4); break; default:  handle_ppp(ndo, proto, b + 2, length - 2); break; } cleanup: ndo->ndo_snapend = se; free(b); return; trunc: ndo->ndo_snapend = se; free(b); ND_PRINT((ndo, ""[|ppp]"")); }"
"static int bigben_probe(struct hid_device *hid, const struct hid_device_id *id) { struct bigben_device *bigben; struct hid_input *hidinput; struct list_head *report_list; struct led_classdev *led; char *name; size_t name_sz; int n, error; bigben = devm_kzalloc(&hid->dev, sizeof(*bigben), GFP_KERNEL); if (!bigben) return -ENOMEM; hid_set_drvdata(hid, bigben); bigben->hid = hid; bigben->removed = false; error = hid_parse(hid); if (error) { hid_err(hid, ""parse failed\n""); return error; } error = hid_hw_start(hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF); if (error) { hid_err(hid, ""hw start failed\n""); return error; } report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list; if (list_empty(report_list)) { hid_err(hid, ""no output report found\n""); error = -ENODEV; goto error_hw_stop; } bigben->report = list_entry(report_list->next, struct hid_report, list); if (list_empty(&hid->inputs)) { hid_err(hid, ""no inputs found\n""); error = -ENODEV; goto error_hw_stop; } hidinput = list_first_entry(&hid->inputs, struct hid_input, list); set_bit(FF_RUMBLE, hidinput->input->ffbit); INIT_WORK(&bigben->worker, bigben_worker); error = input_ff_create_memless(hidinput->input, NULL, hid_bigben_play_effect); if (error) goto error_hw_stop; name_sz = strlen(dev_name(&hid->dev)) + strlen("":red:bigben#"") + 1; for (n = 0; n < NUM_LEDS; n++) { led = devm_kzalloc( &hid->dev, sizeof(struct led_classdev) + name_sz, GFP_KERNEL ); if (!led) { error = -ENOMEM; goto error_hw_stop; } name = (void *)(&led[1]); snprintf(name, name_sz, ""%s:red:bigben%d"", dev_name(&hid->dev), n + 1 ); led->name = name; led->brightness = (n == 0) ? LED_ON : LED_OFF; led->max_brightness = 1; led->brightness_get = bigben_get_led; led->brightness_set = bigben_set_led; bigben->leds[n] = led; error = devm_led_classdev_register(&hid->dev, led); if (error) goto error_hw_stop; } bigben->led_state = BIT(0); bigben->right_motor_on = 0; bigben->left_motor_force = 0; bigben->work_led = true; bigben->work_ff = true; schedule_work(&bigben->worker); hid_info(hid, ""LED and force feedback support for BigBen gamepad\n""); return 0; error_hw_stop: hid_hw_stop(hid); return error; }"
"static inline int compat_fontx_ioctl(int cmd, struct compat_consolefontdesc __user *user_cfd, int perm, struct console_font_op *op) { struct compat_consolefontdesc cfdarg; int i; if (copy_from_user(&cfdarg, user_cfd, sizeof(struct compat_consolefontdesc))) return -EFAULT; switch (cmd) { case PIO_FONTX: if (!perm) return -EPERM; op->op = KD_FONT_OP_SET; op->flags = KD_FONT_FLAG_OLD; op->width = 8; op->height = cfdarg.charheight; op->charcount = cfdarg.charcount; op->data = compat_ptr(cfdarg.chardata); return con_font_op(vc_cons[fg_console].d, op); case GIO_FONTX: op->op = KD_FONT_OP_GET; op->flags = KD_FONT_FLAG_OLD; op->width = 8; op->height = cfdarg.charheight; op->charcount = cfdarg.charcount; op->data = compat_ptr(cfdarg.chardata); i = con_font_op(vc_cons[fg_console].d, op); if (i) return i; cfdarg.charheight = op->height; cfdarg.charcount = op->charcount; if (copy_to_user(user_cfd, &cfdarg, sizeof(struct compat_consolefontdesc))) return -EFAULT; return 0; } return -EINVAL; }"
"int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots) { struct pipe_buffer *bufs; unsigned int head, tail, mask, n; mask = pipe->ring_size - 1; head = pipe->head; tail = pipe->tail; n = pipe_occupancy(pipe->head, pipe->tail); if (nr_slots < n) return -EBUSY; bufs = kcalloc(nr_slots, sizeof(*bufs), GFP_KERNEL_ACCOUNT | __GFP_NOWARN); if (unlikely(!bufs)) return -ENOMEM; if (n > 0) { unsigned int h = head & mask; unsigned int t = tail & mask; if (h > t) { memcpy(bufs, pipe->bufs + t, n * sizeof(struct pipe_buffer)); } else { unsigned int tsize = pipe->ring_size - t; if (h > 0) memcpy(bufs + tsize, pipe->bufs, h * sizeof(struct pipe_buffer)); memcpy(bufs, pipe->bufs + t, tsize * sizeof(struct pipe_buffer)); } } head = n; tail = 0; kfree(pipe->bufs); pipe->bufs = bufs; pipe->ring_size = nr_slots; if (pipe->max_usage > nr_slots) pipe->max_usage = nr_slots; pipe->tail = tail; pipe->head = head; wake_up_interruptible(&pipe->wr_wait); return 0; }"
"static void exif_mnote_data_pentax_load (ExifMnoteData *en, const unsigned char *buf, unsigned int buf_size) { ExifMnoteDataPentax *n = (ExifMnoteDataPentax *) en; size_t i, tcount, o, datao, base = 0; ExifShort c; if (!n || !buf || !buf_size) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); return; } datao = 6 + n->offset; if (CHECKOVERFLOW(datao, buf_size, 8)) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); return; } if (!memcmp(buf + datao, ""AOC"", 4)) { if ((buf[datao + 4] == 'I') && (buf[datao + 5] == 'I')) { n->version = pentaxV3; n->order = EXIF_BYTE_ORDER_INTEL; } else if ((buf[datao + 4] == 'M') && (buf[datao + 5] == 'M')) { n->version = pentaxV3; n->order = EXIF_BYTE_ORDER_MOTOROLA; } else { n->version = pentaxV2; } exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Pentax maker note v%d..."", (int)n->version); datao += 4 + 2; base = MNOTE_PENTAX2_TAG_BASE; } else if (!memcmp(buf + datao, ""QVC"", 4)) { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Casio maker note v2...""); n->version = casioV2; base = MNOTE_CASIO2_TAG_BASE; datao += 4 + 2; } else { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Parsing Pentax maker note v1...""); n->version = pentaxV1; } c = exif_get_short (buf + datao, n->order); datao += 2; exif_mnote_data_pentax_clear (n); n->entries = exif_mem_alloc (en->mem, sizeof (MnotePentaxEntry) * c); if (!n->entries) { EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", sizeof (MnotePentaxEntry) * c); return; } tcount = 0; for (i = c, o = datao; i; --i, o += 12) { size_t s; if (CHECKOVERFLOW(o,buf_size,12)) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Short MakerNote""); break; } n->entries[tcount].tag        = exif_get_short (buf + o + 0, n->order) + base; n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order); n->entries[tcount].components = exif_get_long  (buf + o + 4, n->order); n->entries[tcount].order      = n->order; exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnotePentax"", ""Loading entry 0x%x ('%s')..."", n->entries[tcount].tag, mnote_pentax_tag_get_name (n->entries[tcount].tag)); if (exif_format_get_size (n->entries[tcount].format) && buf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components ) { exif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, ""ExifMnoteDataPentax"", ""Tag size overflow detected (%u * %lu)"", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components); break; } s = exif_format_get_size (n->entries[tcount].format) * n->entries[tcount].components; n->entries[tcount].size = s; if (s) { size_t dataofs = o + 8; if (s > 4) dataofs = exif_get_long (buf + dataofs, n->order) + 6; if (CHECKOVERFLOW(dataofs, buf_size, s)) { exif_log (en->log, EXIF_LOG_CODE_DEBUG, ""ExifMnoteDataPentax"", ""Tag data past end "" ""of buffer (%u > %u)"", (unsigned)(dataofs + s), buf_size); continue; } n->entries[tcount].data = exif_mem_alloc (en->mem, s); if (!n->entries[tcount].data) { EXIF_LOG_NO_MEMORY(en->log, ""ExifMnoteDataPentax"", s); continue; } memcpy (n->entries[tcount].data, buf + dataofs, s); } ++tcount; } n->count = tcount; }"
"void dvb_usbv2_disconnect(struct usb_interface *intf) { struct dvb_usb_device *d = usb_get_intfdata(intf); const char *name = d->name; struct device dev = d->udev->dev; dev_dbg(&d->udev->dev, ""%s: bInterfaceNumber=%d\n"", __func__, intf->cur_altsetting->desc.bInterfaceNumber); if (d->props->exit) d->props->exit(d); dvb_usbv2_exit(d); dev_info(&dev, ""%s: '%s' successfully deinitialized and disconnected\n"", KBUILD_MODNAME, name); }"
"BigInt Montgomery_Exponentiator::execute() const { const size_t exp_nibbles = (m_exp_bits + m_window_bits - 1) / m_window_bits; BigInt x = m_R_mod; const size_t z_size = 2*(m_mod_words + 1); BigInt z(BigInt::Positive, z_size); secure_vector<word> workspace(z.size()); for(size_t i = exp_nibbles; i > 0; --i) { for(size_t k = 0; k != m_window_bits; ++k) { bigint_monty_sqr(z, x, m_modulus.data(), m_mod_words, m_mod_prime, workspace.data()); x = z; } const uint32_t nibble = m_exp.get_substring(m_window_bits*(i-1), m_window_bits); bigint_monty_mul(z, x, m_g[nibble], m_modulus.data(), m_mod_words, m_mod_prime, workspace.data()); x = z; } x.grow_to(2*m_mod_words + 1); bigint_monty_redc(x.mutable_data(), m_modulus.data(), m_mod_words, m_mod_prime, workspace.data()); return x; }"
"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env, struct bpf_insn *insn, struct bpf_reg_state *dst_reg, struct bpf_reg_state src_reg) { struct bpf_reg_state *regs = cur_regs(env); u8 opcode = BPF_OP(insn->code); bool src_known, dst_known; s64 smin_val, smax_val; u64 umin_val, umax_val; u64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32; if (insn_bitness == 32) { coerce_reg_to_size(dst_reg, 4); coerce_reg_to_size(&src_reg, 4); } smin_val = src_reg.smin_value; smax_val = src_reg.smax_value; umin_val = src_reg.umin_value; umax_val = src_reg.umax_value; src_known = tnum_is_const(src_reg.var_off); dst_known = tnum_is_const(dst_reg->var_off); if ((src_known && (smin_val != smax_val || umin_val != umax_val)) || smin_val > smax_val || umin_val > umax_val) { __mark_reg_unknown(dst_reg); return 0; } if (!src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND) { __mark_reg_unknown(dst_reg); return 0; } switch (opcode) { case BPF_ADD: if (signed_add_overflows(dst_reg->smin_value, smin_val) || signed_add_overflows(dst_reg->smax_value, smax_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value += smin_val; dst_reg->smax_value += smax_val; } if (dst_reg->umin_value + umin_val < umin_val || dst_reg->umax_value + umax_val < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value += umin_val; dst_reg->umax_value += umax_val; } dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off); break; case BPF_SUB: if (signed_sub_overflows(dst_reg->smin_value, smax_val) || signed_sub_overflows(dst_reg->smax_value, smin_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value -= smax_val; dst_reg->smax_value -= smin_val; } if (dst_reg->umin_value < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value -= umax_val; dst_reg->umax_value -= umin_val; } dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off); break; case BPF_MUL: dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off); if (smin_val < 0 || dst_reg->smin_value < 0) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) { __mark_reg_unbounded(dst_reg); __update_reg_bounds(dst_reg); break; } dst_reg->umin_value *= umin_val; dst_reg->umax_value *= umax_val; if (dst_reg->umax_value > S64_MAX) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } break; case BPF_AND: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value & src_reg.var_off.value); break; } dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = dst_reg->var_off.value; dst_reg->umax_value = min(dst_reg->umax_value, umax_val); if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_OR: if (src_known && dst_known) { __mark_reg_known(dst_reg, dst_reg->var_off.value | src_reg.var_off.value); break; } dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off); dst_reg->umin_value = max(dst_reg->umin_value, umin_val); dst_reg->umax_value = dst_reg->var_off.value | dst_reg->var_off.mask; if (dst_reg->smin_value < 0 || smin_val < 0) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = dst_reg->umin_value; dst_reg->smax_value = dst_reg->umax_value; } __update_reg_bounds(dst_reg); break; case BPF_LSH: if (umax_val >= insn_bitness) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; if (dst_reg->umax_value > 1ULL << (63 - umax_val)) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value <<= umin_val; dst_reg->umax_value <<= umax_val; } dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val); __update_reg_bounds(dst_reg); break; case BPF_RSH: if (umax_val >= insn_bitness) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; dst_reg->var_off = tnum_rshift(dst_reg->var_off, umin_val); dst_reg->umin_value >>= umax_val; dst_reg->umax_value >>= umin_val; __update_reg_bounds(dst_reg); break; case BPF_ARSH: if (umax_val >= insn_bitness) { mark_reg_unknown(env, regs, insn->dst_reg); break; } dst_reg->smin_value >>= umin_val; dst_reg->smax_value >>= umin_val; dst_reg->var_off = tnum_arshift(dst_reg->var_off, umin_val); dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; __update_reg_bounds(dst_reg); break; default: mark_reg_unknown(env, regs, insn->dst_reg); break; } if (BPF_CLASS(insn->code) != BPF_ALU64) { coerce_reg_to_size(dst_reg, 4); } __reg_deduce_bounds(dst_reg); __reg_bound_offset(dst_reg); return 0; }"
"static int _gd2GetHeader (gdIOCtxPtr in, int *sx, int *sy, int *cs, int *vers, int *fmt, int *ncx, int *ncy, t_chunk_info ** chunkIdx) { int i; int ch; char id[5]; t_chunk_info *cidx; int sidx; int nc; GD2_DBG (printf (""Reading gd2 header info\n"")); for (i = 0; i < 4; i++) { ch = gdGetC (in); if (ch == EOF) { goto fail1; }; id[i] = ch; }; id[4] = 0; GD2_DBG (printf (""Got file code: %s\n"", id)); if (strcmp (id, GD2_ID) != 0) { GD2_DBG (printf (""Not a valid gd2 file\n"")); goto fail1; }; if (gdGetWord (vers, in) != 1) { goto fail1; }; GD2_DBG (printf (""Version: %d\n"", *vers)); if ((*vers != 1) && (*vers != 2)) { GD2_DBG (printf (""Bad version: %d\n"", *vers)); goto fail1; }; if (!gdGetWord (sx, in)) { GD2_DBG (printf (""Could not get x-size\n"")); goto fail1; } if (!gdGetWord (sy, in)) { GD2_DBG (printf (""Could not get y-size\n"")); goto fail1; } GD2_DBG (printf (""Image is %dx%d\n"", *sx, *sy)); if (gdGetWord (cs, in) != 1) { goto fail1; }; GD2_DBG (printf (""ChunkSize: %d\n"", *cs)); if ((*cs < GD2_CHUNKSIZE_MIN) || (*cs > GD2_CHUNKSIZE_MAX)) { GD2_DBG (printf (""Bad chunk size: %d\n"", *cs)); goto fail1; }; if (gdGetWord (fmt, in) != 1) { goto fail1; }; GD2_DBG (printf (""Format: %d\n"", *fmt)); if ((*fmt != GD2_FMT_RAW) && (*fmt != GD2_FMT_COMPRESSED) && (*fmt != GD2_FMT_TRUECOLOR_RAW) && (*fmt != GD2_FMT_TRUECOLOR_COMPRESSED)) { GD2_DBG (printf (""Bad data format: %d\n"", *fmt)); goto fail1; }; if (gdGetWord (ncx, in) != 1) { goto fail1; }; GD2_DBG (printf (""%d Chunks Wide\n"", *ncx)); if (gdGetWord (ncy, in) != 1) { goto fail1; }; GD2_DBG (printf (""%d Chunks vertically\n"", *ncy)); if (gd2_compressed (*fmt)) { nc = (*ncx) * (*ncy); GD2_DBG (printf (""Reading %d chunk index entries\n"", nc)); sidx = sizeof (t_chunk_info) * nc; cidx = gdCalloc (sidx, 1); if (!cidx) { goto fail1; } for (i = 0; i < nc; i++) { if (gdGetInt (&cidx[i].offset, in) != 1) { goto fail2; }; if (gdGetInt (&cidx[i].size, in) != 1) { goto fail2; }; }; *chunkIdx = cidx; }; GD2_DBG (printf (""gd2 header complete\n"")); return 1; fail2: gdFree(cidx); fail1: return 0; }"
"int XSetCommand ( Display *dpy, Window w, char **argv, int argc) { register int i; size_t nbytes; register char *buf, *bp; for (i = 0, nbytes = 0; i < argc; i++) { nbytes += safestrlen(argv[i]) + 1; } if ((bp = buf = Xmalloc(nbytes))) { for (i = 0; i < argc; i++) { if (argv[i]) { (void) strcpy(bp, argv[i]); bp += strlen(argv[i]) + 1; } else *bp++ = '\0'; } XChangeProperty (dpy, w, XA_WM_COMMAND, XA_STRING, 8, PropModeReplace, (unsigned char *)buf, nbytes); Xfree(buf); } return 1; }"
"static int atm_tc_enqueue(struct sk_buff *skb, struct Qdisc *sch, struct sk_buff **to_free) { struct atm_qdisc_data *p = qdisc_priv(sch); struct atm_flow_data *flow; struct tcf_result res; int result; int ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS; pr_debug(""atm_tc_enqueue(skb %p,sch %p,[qdisc %p])\n"", skb, sch, p); result = TC_ACT_OK; flow = NULL; if (TC_H_MAJ(skb->priority) != sch->handle || !(flow = (struct atm_flow_data *)atm_tc_find(sch, skb->priority))) { struct tcf_proto *fl; list_for_each_entry(flow, &p->flows, list) { fl = rcu_dereference_bh(flow->filter_list); if (fl) { result = tcf_classify(skb, NULL, fl, &res, true); if (result < 0) continue; flow = (struct atm_flow_data *)res.class; if (!flow) flow = lookup_flow(sch, res.classid); goto done; } } flow = NULL; done: ; } if (!flow) { flow = &p->link; } else { if (flow->vcc) ATM_SKB(skb)->atm_options = flow->vcc->atm_options; #ifdef CONFIG_NET_CLS_ACT switch (result) { case TC_ACT_QUEUED: case TC_ACT_STOLEN: case TC_ACT_TRAP: __qdisc_drop(skb, to_free); return NET_XMIT_SUCCESS | __NET_XMIT_STOLEN; case TC_ACT_SHOT: __qdisc_drop(skb, to_free); goto drop; case TC_ACT_RECLASSIFY: if (flow->excess) flow = flow->excess; else ATM_SKB(skb)->atm_options |= ATM_ATMOPT_CLP; break; } #endif } ret = qdisc_enqueue(skb, flow->q, to_free); if (ret != NET_XMIT_SUCCESS) { drop: __maybe_unused if (net_xmit_drop_count(ret)) { qdisc_qstats_drop(sch); if (flow) flow->qstats.drops++; } return ret; } if (flow == &p->link) { sch->q.qlen++; return NET_XMIT_SUCCESS; } tasklet_schedule(&p->task); return NET_XMIT_SUCCESS | __NET_XMIT_BYPASS; }"
"static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end) { struct vm_area_struct **insertion_point; struct vm_area_struct *tail_vma = NULL; insertion_point = (prev ? &prev->vm_next : &mm->mmap); vma->vm_prev = NULL; do { vma_rb_erase(vma, &mm->mm_rb); mm->map_count--; tail_vma = vma; vma = vma->vm_next; } while (vma && vma->vm_start < end); *insertion_point = vma; if (vma) { vma->vm_prev = prev; vma_gap_update(vma); } else mm->highest_vm_end = prev ? vm_end_gap(prev) : 0; tail_vma->vm_next = NULL; vmacache_invalidate(mm); }"
void rsvg_state_finalize (RsvgState * state) { g_free (state->font_family); g_free (state->lang); rsvg_paint_server_unref (state->fill); rsvg_paint_server_unref (state->stroke); if (state->dash.n_dash != 0) g_free (state->dash.dash); if (state->styles) { g_hash_table_unref (state->styles); state->styles = NULL; } }
"static int dictAdd(dict *ht, void *key, void *val) { int index; dictEntry *entry; if ((index = _dictKeyIndex(ht, key)) == -1) return DICT_ERR; entry = hiredis_safe_malloc(sizeof(*entry)); entry->next = ht->table[index]; ht->table[index] = entry; dictSetHashKey(ht, entry, key); dictSetHashVal(ht, entry, val); ht->used++; return DICT_OK; }"
"int fuse_inode_uncached_io_start(struct fuse_inode *fi, struct fuse_backing *fb) { struct fuse_backing *oldfb; int err = 0; spin_lock(&fi->lock); oldfb = fuse_inode_backing(fi); if (oldfb && oldfb != fb) { err = -EBUSY; goto unlock; } if (fi->iocachectr > 0) { err = -ETXTBSY; goto unlock; } fi->iocachectr--; if (!oldfb) { oldfb = fuse_inode_backing_set(fi, fb); WARN_ON_ONCE(oldfb != NULL); } else { fuse_backing_put(fb); } unlock: spin_unlock(&fi->lock); return err; }"
"void bandwidth_pid(pid_t pid, const char *command, const char *dev, int down, int up) { EUID_ASSERT(); EUID_ROOT(); char *comm = pid_proc_comm(pid); EUID_USER(); if (!comm) { fprintf(stderr, ""Error: cannot find sandbox\n""); exit(1); } if (strcmp(comm, ""firejail"") != 0) { fprintf(stderr, ""Error: cannot find sandbox\n""); exit(1); } free(comm); char *name; if (asprintf(&name, ""/run/firejail/network/%d-netmap"", pid) == -1) errExit(""asprintf""); struct stat s; if (stat(name, &s) == -1) { fprintf(stderr, ""Error: the sandbox doesn't use a new network namespace\n""); exit(1); } pid_t child; if (find_child(pid, &child) == -1) { fprintf(stderr, ""Error: cannot join the network namespace\n""); exit(1); } EUID_ROOT(); if (join_namespace(child, ""net"")) { fprintf(stderr, ""Error: cannot join the network namespace\n""); exit(1); } if (strcmp(command, ""set"") == 0) bandwidth_set(pid, dev, down, up); else if (strcmp(command, ""clear"") == 0) bandwidth_remove(pid, dev); char *devname = NULL; if (dev) { char *fname; if (asprintf(&fname, ""%s/%d-netmap"", RUN_FIREJAIL_NETWORK_DIR, (int) pid) == -1) errExit(""asprintf""); FILE *fp = fopen(fname, ""r""); if (!fp) { fprintf(stderr, ""Error: cannot read network map file %s\n"", fname); exit(1); } char buf[1024]; int len = strlen(dev); while (fgets(buf, 1024, fp)) { char *ptr = strchr(buf, '\n'); if (ptr) *ptr = '\0'; if (*buf == '\0') break; if (strncmp(buf, dev, len) == 0  && buf[len] == ':') { devname = strdup(buf + len + 1); if (!devname) errExit(""strdup""); if (if_nametoindex(devname) == 0) { fprintf(stderr, ""Error: cannot find network device %s\n"", devname); exit(1); } break; } } free(fname); fclose(fp); } char *cmd = NULL; if (devname) { if (strcmp(command, ""set"") == 0) { if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s %d %d"", LIBDIR, command, devname, down, up) == -1) errExit(""asprintf""); } else { if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s %s"", LIBDIR, command, devname) == -1) errExit(""asprintf""); } } else { if (asprintf(&cmd, ""%s/firejail/fshaper.sh --%s"", LIBDIR, command) == -1) errExit(""asprintf""); } assert(cmd); environ = NULL; if (setreuid(0, 0)) errExit(""setreuid""); if (setregid(0, 0)) errExit(""setregid""); if (!cfg.shell) cfg.shell = guess_shell(); if (!cfg.shell) { fprintf(stderr, ""Error: no POSIX shell found, please use --shell command line option\n""); exit(1); } char *arg[4]; arg[0] = cfg.shell; arg[1] = ""-c""; arg[2] = cmd; arg[3] = NULL; clearenv(); execvp(arg[0], arg); errExit(""execvp""); }"
"static long restore_tm_sigcontexts(struct pt_regs *regs, struct sigcontext __user *sc, struct sigcontext __user *tm_sc) { #ifdef CONFIG_ALTIVEC elf_vrreg_t __user *v_regs, *tm_v_regs; #endif unsigned long err = 0; unsigned long msr; #ifdef CONFIG_VSX int i; #endif err |= __copy_from_user(regs->gpr, tm_sc->gp_regs, sizeof(regs->gpr)); err |= __copy_from_user(&current->thread.ckpt_regs, sc->gp_regs, sizeof(regs->gpr)); err |= __get_user(regs->nip, &tm_sc->gp_regs[PT_NIP]); err |= __get_user(current->thread.tm_tfhar, &sc->gp_regs[PT_NIP]); err |= __get_user(msr, &sc->gp_regs[PT_MSR]); regs->msr = (regs->msr & ~MSR_TS_MASK) | (msr & MSR_TS_MASK); regs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE); err |= __get_user(regs->ctr, &tm_sc->gp_regs[PT_CTR]); err |= __get_user(regs->link, &tm_sc->gp_regs[PT_LNK]); err |= __get_user(regs->xer, &tm_sc->gp_regs[PT_XER]); err |= __get_user(regs->ccr, &tm_sc->gp_regs[PT_CCR]); err |= __get_user(current->thread.ckpt_regs.ctr, &sc->gp_regs[PT_CTR]); err |= __get_user(current->thread.ckpt_regs.link, &sc->gp_regs[PT_LNK]); err |= __get_user(current->thread.ckpt_regs.xer, &sc->gp_regs[PT_XER]); err |= __get_user(current->thread.ckpt_regs.ccr, &sc->gp_regs[PT_CCR]); err |= __get_user(regs->trap, &sc->gp_regs[PT_TRAP]); err |= __get_user(regs->dar, &sc->gp_regs[PT_DAR]); err |= __get_user(regs->dsisr, &sc->gp_regs[PT_DSISR]); err |= __get_user(regs->result, &sc->gp_regs[PT_RESULT]); discard_lazy_cpu_state(); regs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1 | MSR_VEC | MSR_VSX); #ifdef CONFIG_ALTIVEC err |= __get_user(v_regs, &sc->v_regs); err |= __get_user(tm_v_regs, &tm_sc->v_regs); if (err) return err; if (v_regs && !access_ok(VERIFY_READ, v_regs, 34 * sizeof(vector128))) return -EFAULT; if (tm_v_regs && !access_ok(VERIFY_READ, tm_v_regs, 34 * sizeof(vector128))) return -EFAULT; if (v_regs != NULL && tm_v_regs != NULL && (msr & MSR_VEC) != 0) { err |= __copy_from_user(&current->thread.vr_state, v_regs, 33 * sizeof(vector128)); err |= __copy_from_user(&current->thread.transact_vr, tm_v_regs, 33 * sizeof(vector128)); } else if (current->thread.used_vr) { memset(&current->thread.vr_state, 0, 33 * sizeof(vector128)); memset(&current->thread.transact_vr, 0, 33 * sizeof(vector128)); } if (v_regs != NULL && tm_v_regs != NULL) { err |= __get_user(current->thread.vrsave, (u32 __user *)&v_regs[33]); err |= __get_user(current->thread.transact_vrsave, (u32 __user *)&tm_v_regs[33]); } else { current->thread.vrsave = 0; current->thread.transact_vrsave = 0; } if (cpu_has_feature(CPU_FTR_ALTIVEC)) mtspr(SPRN_VRSAVE, current->thread.vrsave); #endif  err |= copy_fpr_from_user(current, &sc->fp_regs); err |= copy_transact_fpr_from_user(current, &tm_sc->fp_regs); #ifdef CONFIG_VSX if (v_regs && ((msr & MSR_VSX) != 0)) { v_regs += ELF_NVRREG; tm_v_regs += ELF_NVRREG; err |= copy_vsx_from_user(current, v_regs); err |= copy_transact_vsx_from_user(current, tm_v_regs); } else { for (i = 0; i < 32 ; i++) { current->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0; current->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0; } } #endif tm_enable(); current->thread.tm_texasr |= TEXASR_FS; tm_recheckpoint(&current->thread, msr); if (msr & MSR_FP) { do_load_up_transact_fpu(&current->thread); regs->msr |= (MSR_FP | current->thread.fpexc_mode); } #ifdef CONFIG_ALTIVEC if (msr & MSR_VEC) { do_load_up_transact_altivec(&current->thread); regs->msr |= MSR_VEC; } #endif return err; }"
"void jbd2_journal_wait_updates(journal_t *journal) { transaction_t *commit_transaction = journal->j_running_transaction; if (!commit_transaction) return; spin_lock(&commit_transaction->t_handle_lock); while (atomic_read(&commit_transaction->t_updates)) { DEFINE_WAIT(wait); prepare_to_wait(&journal->j_wait_updates, &wait, TASK_UNINTERRUPTIBLE); if (atomic_read(&commit_transaction->t_updates)) { spin_unlock(&commit_transaction->t_handle_lock); write_unlock(&journal->j_state_lock); schedule(); write_lock(&journal->j_state_lock); spin_lock(&commit_transaction->t_handle_lock); } finish_wait(&journal->j_wait_updates, &wait); } spin_unlock(&commit_transaction->t_handle_lock); }"
"ExprDef * ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append) { unsigned nSyms = darray_size(expr->keysym_list.syms); unsigned numEntries = darray_size(append->keysym_list.syms); darray_append(expr->keysym_list.symsMapIndex, nSyms); darray_append(expr->keysym_list.symsNumEntries, numEntries); darray_concat(expr->keysym_list.syms, append->keysym_list.syms); FreeStmt((ParseCommon *) &append); return expr; }"
"BrotliContext::BrotliContext(const uint32_t chunk_size) : chunk_size_{chunk_size}, chunk_ptr_{std::make_unique<uint8_t[]>(chunk_size)}, next_in_{}, next_out_{chunk_ptr_.get()}, avail_in_{0}, avail_out_{chunk_size} {}"
"int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig) { const ceph_msg_header& header = m->get_header(); const ceph_msg_footer& footer = m->get_footer(); struct { __u8 v; __le64 magic; __le32 len; __le32 header_crc; __le32 front_crc; __le32 middle_crc; __le32 data_crc; } __attribute__ ((packed)) sigblock = { 1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4), mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc), mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc) }; char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))]; try { const CryptoKey::in_slice_t in { sizeof(sigblock), reinterpret_cast<const unsigned char*>(&sigblock) }; const CryptoKey::out_slice_t out { sizeof(exp_buf), reinterpret_cast<unsigned char*>(&exp_buf) }; key.encrypt(cct, in, out); } catch (std::exception& e) { lderr(cct) << __func__ << "" failed to encrypt signature block"" << dendl; return -1; } *psig = *reinterpret_cast<__le64*>(exp_buf); ldout(cct, 10) << __func__ << "" seq "" << m->get_seq() << "" front_crc_ = "" << footer.front_crc << "" middle_crc = "" << footer.middle_crc << "" data_crc = "" << footer.data_crc << "" sig = "" << *psig << dendl; return 0; }"
"static jclass getClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags) { jclass returnValue = NULL; J9VMThread *vmThread = (J9VMThread *) env; J9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions; SunReflectCPResult result = NULL_POINTER_EXCEPTION; if (NULL != constantPoolOop) { J9Class *clazz = NULL; vmFunctions->internalEnterVMFromJNI(vmThread); result = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz); if (NULL != clazz) { returnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz)); } vmFunctions->internalExitVMToJNI(vmThread); } checkResult(env, result); return returnValue; }"
static inline ut32 r_read_le32(const void *src) { const ut8 *s = (const ut8*)src; return (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) | (((ut32)s[1]) << 8) | (((ut32)s[0]) << 0); }
"bool rebuild_header_jpg( void ) { abytewriter* hdrw;  unsigned char  type = 0x00;     uint32_t   len  = 0;     uint32_t   hpos = 0;  hdrw = new abytewriter( 4096 ); while ( hpos < hdrs && (uint64_t)hpos + 3 < (uint64_t)hdrs ) { type = hpos + 1 < hdrs ?  hdrdata[ hpos + 1 ] : 0; len = 2 + B_SHORT( hpos + 2 < hdrs ? hdrdata[ hpos + 2 ]:0, hpos + 3 < hdrs ? hdrdata[ hpos + 3 ] :0); if ( ( type == 0xDA ) || ( type == 0xC4 ) || ( type == 0xDB ) || ( type == 0xC0 ) || ( type == 0xC1 ) || ( type == 0xC2 ) || ( type == 0xDD ) ) { uint32_t to_copy = hpos + len < hdrs ? len : hdrs - hpos; hdrw->write_n( &(hdrdata[ hpos ]), to_copy); if (to_copy <  len) { for (uint32_t i = 0;i <to_copy -len;++i) { uint8_t zero = 0; hdrw->write_n(&zero, 1); } } } hpos += len; } custom_free( hdrdata ); hdrdata = hdrw->getptr_aligned(); hdrs    = hdrw->getpos(); delete( hdrw ); return true; }"
void tee_shm_free(struct tee_shm *shm) { if (shm->flags & TEE_SHM_DMA_BUF) dma_buf_put(shm->dmabuf); else tee_shm_release(shm); }
"static int _get_page_type(struct page_info *page, unsigned long type, bool preemptible) { unsigned long nx, x, y = page->u.inuse.type_info; int rc = 0, iommu_ret = 0; ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2))); ASSERT(!in_irq()); for ( ; ; ) { x  = y; nx = x + 1; if ( unlikely((nx & PGT_count_mask) == 0) ) { gdprintk(XENLOG_WARNING, ""Type count overflow on mfn %""PRI_mfn""\n"", mfn_x(page_to_mfn(page))); return -EINVAL; } else if ( unlikely((x & PGT_count_mask) == 0) ) { struct domain *d = page_get_owner(page); if ( d && shadow_mode_enabled(d) && (page->count_info & PGC_page_table) && !((page->shadow_flags & (1u<<29)) && type == PGT_writable_page) ) shadow_remove_all_shadows(d, page_to_mfn(page)); ASSERT(!(x & PGT_pae_xen_l2)); if ( (x & PGT_type_mask) != type ) { cpumask_t *mask = this_cpu(scratch_cpumask); BUG_ON(in_irq()); cpumask_copy(mask, d->dirty_cpumask); tlbflush_filter(mask, page->tlbflush_timestamp); if ( unlikely(!cpumask_empty(mask)) && (!shadow_mode_enabled(page_get_owner(page)) || ((nx & PGT_type_mask) == PGT_writable_page)) ) { perfc_incr(need_flush_tlb_flush); flush_tlb_mask(mask); } nx &= ~(PGT_type_mask | PGT_validated); nx |= type; if ( type == PGT_writable_page || type == PGT_shared_page ) nx |= PGT_validated; } } else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) ) { if ( ((x & PGT_type_mask) == PGT_l2_page_table) && (type == PGT_l1_page_table) ) return -EINVAL; if ( ((x & PGT_type_mask) == PGT_l3_page_table) && (type == PGT_l2_page_table) ) return -EINVAL; if ( ((x & PGT_type_mask) == PGT_l4_page_table) && (type == PGT_l3_page_table) ) return -EINVAL; gdprintk(XENLOG_WARNING, ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") "" ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"", x, type, mfn_x(page_to_mfn(page)), get_gpfn_from_mfn(mfn_x(page_to_mfn(page)))); return -EINVAL; } else if ( unlikely(!(x & PGT_validated)) ) { if ( !(x & PGT_partial) ) { do { if ( preemptible && hypercall_preempt_check() ) return -EINTR; cpu_relax(); } while ( (y = page->u.inuse.type_info) == x ); continue; } ASSERT((x & PGT_count_mask) == 1); nx = x & ~PGT_partial; } if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) ) break; if ( preemptible && hypercall_preempt_check() ) return -EINTR; } if ( unlikely((x & PGT_type_mask) != type) ) { struct domain *d = page_get_owner(page); if ( d && is_pv_domain(d) && unlikely(need_iommu_pt_sync(d)) ) { mfn_t mfn = page_to_mfn(page); if ( (x & PGT_type_mask) == PGT_writable_page ) iommu_ret = iommu_unmap_page(d, _dfn(mfn_x(mfn))); else if ( type == PGT_writable_page ) iommu_ret = iommu_map_page(d, _dfn(mfn_x(mfn)), mfn, IOMMUF_readable | IOMMUF_writable); } } if ( unlikely(!(nx & PGT_validated)) ) { if ( !(x & PGT_partial) ) { page->nr_validated_ptes = 0; page->partial_pte = 0; } page->linear_pt_count = 0; rc = alloc_page_type(page, type, preemptible); } if ( (x & PGT_partial) && !(nx & PGT_partial) ) put_page(page); if ( !rc ) rc = iommu_ret; return rc; }"
"static void process_tree(struct rev_info *revs, struct tree *tree, show_object_fn show, struct strbuf *base, const char *name, void *cb_data) { struct object *obj = &tree->object; struct tree_desc desc; struct name_entry entry; enum interesting match = revs->diffopt.pathspec.nr == 0 ? all_entries_interesting: entry_not_interesting; int baselen = base->len; if (!revs->tree_objects) return; if (!obj) die(""bad tree object""); if (obj->flags & (UNINTERESTING | SEEN)) return; if (parse_tree_gently(tree, revs->ignore_missing_links) < 0) { if (revs->ignore_missing_links) return; die(""bad tree object %s"", oid_to_hex(&obj->oid)); } obj->flags |= SEEN; show(obj, base, name, cb_data); strbuf_addstr(base, name); if (base->len) strbuf_addch(base, '/'); init_tree_desc(&desc, tree->buffer, tree->size); while (tree_entry(&desc, &entry)) { if (match != all_entries_interesting) { match = tree_entry_interesting(&entry, base, 0, &revs->diffopt.pathspec); if (match == all_entries_not_interesting) break; if (match == entry_not_interesting) continue; } if (S_ISDIR(entry.mode)) process_tree(revs, lookup_tree(entry.sha1), show, base, entry.path, cb_data); else if (S_ISGITLINK(entry.mode)) process_gitlink(revs, entry.sha1, show, base, entry.path, cb_data); else process_blob(revs, lookup_blob(entry.sha1), show, base, entry.path, cb_data); } strbuf_setlen(base, baselen); free_tree_buffer(tree); }"
"static int handle_recv_2(void *object, IP_Port source, const uint8_t *packet, uint16_t length, void *userdata) { Onion *onion = (Onion *)object; if (length > ONION_MAX_PACKET_SIZE) { return 1; } if (length <= 1 + RETURN_2) { return 1; } change_symmetric_key(onion); uint8_t plain[SIZE_IPPORT + RETURN_1]; int len = decrypt_data_symmetric(onion->secret_symmetric_key, packet + 1, packet + 1 + CRYPTO_NONCE_SIZE, SIZE_IPPORT + RETURN_1 + CRYPTO_MAC_SIZE, plain); if ((uint32_t)len != sizeof(plain)) { return 1; } IP_Port send_to; if (ipport_unpack(&send_to, plain, len, 0) == -1) { return 1; } uint8_t data[ONION_MAX_PACKET_SIZE]; data[0] = NET_PACKET_ONION_RECV_1; memcpy(data + 1, plain + SIZE_IPPORT, RETURN_1); memcpy(data + 1 + RETURN_1, packet + 1 + RETURN_2, length - (1 + RETURN_2)); uint16_t data_len = 1 + RETURN_1 + (length - (1 + RETURN_2)); if ((uint32_t)sendpacket(onion->net, send_to, data, data_len) != data_len) { return 1; } return 0; }"
"bool Mfcc::Initialize(int input_length, double input_sample_rate) { bool initialized = mel_filterbank_.Initialize( input_length, input_sample_rate, filterbank_channel_count_, lower_frequency_limit_, upper_frequency_limit_); initialized &= dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_); initialized_ = initialized; return initialized; }"
"static krb5_error_code kdc_process_for_user(kdc_realm_t *kdc_active_realm, krb5_pa_data *pa_data, krb5_keyblock *tgs_session, krb5_pa_s4u_x509_user **s4u_x509_user, const char **status) { krb5_error_code             code; krb5_pa_for_user            *for_user; krb5_data                   req_data; req_data.length = pa_data->length; req_data.data = (char *)pa_data->contents; code = decode_krb5_pa_for_user(&req_data, &for_user); if (code) return code; code = verify_for_user_checksum(kdc_context, tgs_session, for_user); if (code) { *status = ""INVALID_S4U2SELF_CHECKSUM""; krb5_free_pa_for_user(kdc_context, for_user); return code; } *s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user)); if (*s4u_x509_user == NULL) { krb5_free_pa_for_user(kdc_context, for_user); return ENOMEM; } (*s4u_x509_user)->user_id.user = for_user->user; for_user->user = NULL; krb5_free_pa_for_user(kdc_context, for_user); return 0; }"
"static void usbredir_handle_iso_data(USBRedirDevice *dev, USBPacket *p, uint8_t ep) { int status, len; if (!dev->endpoint[EP2I(ep)].iso_started && !dev->endpoint[EP2I(ep)].iso_error) { struct usb_redir_start_iso_stream_header start_iso = { .endpoint = ep, }; int pkts_per_sec; if (dev->dev.speed == USB_SPEED_HIGH) { pkts_per_sec = 8000 / dev->endpoint[EP2I(ep)].interval; } else { pkts_per_sec = 1000 / dev->endpoint[EP2I(ep)].interval; } dev->endpoint[EP2I(ep)].bufpq_target_size = (pkts_per_sec * 60) / 1000; start_iso.pkts_per_urb = pkts_per_sec / 100; if (start_iso.pkts_per_urb < 1) { start_iso.pkts_per_urb = 1; } else if (start_iso.pkts_per_urb > 32) { start_iso.pkts_per_urb = 32; } start_iso.no_urbs = DIV_ROUND_UP( dev->endpoint[EP2I(ep)].bufpq_target_size, start_iso.pkts_per_urb); if (!(ep & USB_DIR_IN)) { start_iso.no_urbs *= 2; } if (start_iso.no_urbs > 16) { start_iso.no_urbs = 16; } usbredirparser_send_start_iso_stream(dev->parser, 0, &start_iso); usbredirparser_do_write(dev->parser); DPRINTF(""iso stream started pkts/sec %d pkts/urb %d urbs %d ep %02X\n"", pkts_per_sec, start_iso.pkts_per_urb, start_iso.no_urbs, ep); dev->endpoint[EP2I(ep)].iso_started = 1; dev->endpoint[EP2I(ep)].bufpq_prefilled = 0; dev->endpoint[EP2I(ep)].bufpq_dropping_packets = 0; } if (ep & USB_DIR_IN) { struct buf_packet *isop; if (dev->endpoint[EP2I(ep)].iso_started && !dev->endpoint[EP2I(ep)].bufpq_prefilled) { if (dev->endpoint[EP2I(ep)].bufpq_size < dev->endpoint[EP2I(ep)].bufpq_target_size) { return; } dev->endpoint[EP2I(ep)].bufpq_prefilled = 1; } isop = QTAILQ_FIRST(&dev->endpoint[EP2I(ep)].bufpq); if (isop == NULL) { DPRINTF(""iso-token-in ep %02X, no isop, iso_error: %d\n"", ep, dev->endpoint[EP2I(ep)].iso_error); dev->endpoint[EP2I(ep)].bufpq_prefilled = 0; status = dev->endpoint[EP2I(ep)].iso_error; dev->endpoint[EP2I(ep)].iso_error = 0; p->status = status ? USB_RET_IOERROR : USB_RET_SUCCESS; return; } DPRINTF2(""iso-token-in ep %02X status %d len %d queue-size: %d\n"", ep, isop->status, isop->len, dev->endpoint[EP2I(ep)].bufpq_size); status = isop->status; len = isop->len; if (len > p->iov.size) { ERROR(""received iso data is larger then packet ep %02X (%d > %d)\n"", ep, len, (int)p->iov.size); len = p->iov.size; status = usb_redir_babble; } usb_packet_copy(p, isop->data, len); bufp_free(dev, isop, ep); usbredir_handle_status(dev, p, status); } else { if (dev->endpoint[EP2I(ep)].iso_started) { struct usb_redir_iso_packet_header iso_packet = { .endpoint = ep, .length = p->iov.size }; uint8_t buf[p->iov.size]; usb_packet_copy(p, buf, p->iov.size); usbredirparser_send_iso_packet(dev->parser, 0, &iso_packet, buf, p->iov.size); usbredirparser_do_write(dev->parser); } status = dev->endpoint[EP2I(ep)].iso_error; dev->endpoint[EP2I(ep)].iso_error = 0; DPRINTF2(""iso-token-out ep %02X status %d len %zd\n"", ep, status, p->iov.size); usbredir_handle_status(dev, p, status); } }"
"static Bool latm_dmx_sync_frame_bs(GF_BitStream *bs, GF_M4ADecSpecInfo *acfg, u32 *nb_bytes, u8 *buffer, u32 *nb_skipped) { u32 val, size; u64 pos, mux_size; if (nb_skipped) *nb_skipped = 0; if (!acfg) return 0; while (gf_bs_available(bs)>3) { val = gf_bs_read_u8(bs); if (val!=0x56) { if (nb_skipped) (*nb_skipped) ++; continue; } val = gf_bs_read_int(bs, 3); if (val != 0x07) { gf_bs_read_int(bs, 5); if (nb_skipped) (*nb_skipped) ++; continue; } mux_size = gf_bs_read_int(bs, 13); pos = gf_bs_get_position(bs); if (mux_size>gf_bs_available(bs) ) { gf_bs_seek(bs, pos-3); return GF_FALSE; } if (!gf_bs_read_int(bs, 1)) { Bool amux_version, amux_versionA; amux_version = (Bool)gf_bs_read_int(bs, 1); amux_versionA = GF_FALSE; if (amux_version) amux_versionA = (Bool)gf_bs_read_int(bs, 1); if (!amux_versionA) { u32 i, allStreamsSameTimeFraming, numProgram; if (amux_version) gf_latm_get_value(bs); allStreamsSameTimeFraming = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 6); numProgram = gf_bs_read_int(bs, 4); for (i=0; i<=numProgram; i++) { u32 j, num_lay; num_lay = gf_bs_read_int(bs, 3); for (j=0; j<=num_lay; j++) { u32 frameLengthType; Bool same_cfg = GF_FALSE; if (i || j) same_cfg = (Bool)gf_bs_read_int(bs, 1); if (!same_cfg) { if (amux_version==1) gf_latm_get_value(bs); gf_m4a_parse_config(bs, acfg, GF_FALSE); } frameLengthType = gf_bs_read_int(bs, 3); if (!frameLengthType) { gf_bs_read_int(bs, 8); if (!allStreamsSameTimeFraming) { } } else { } } } if (gf_bs_read_int(bs, 1)) { } if (gf_bs_read_int(bs, 1)) { } } } size = 0; while (1) { u32 tmp = gf_bs_read_int(bs, 8); size += tmp; if (tmp!=255) break; } if (gf_bs_available(bs) < size) { gf_bs_seek(bs, pos-3); return GF_FALSE; } if (nb_bytes) { *nb_bytes = (u32) size; } if (buffer) { gf_bs_read_data(bs, (char *) buffer, size); } else { while (size) { gf_bs_read_int(bs, 8); size--; } } gf_bs_seek(bs, pos + mux_size); if ((gf_bs_available(bs)>2) && gf_bs_peek_bits(bs, 11, 0) != 0x2B7) { gf_bs_seek(bs, pos + 1); if (nb_skipped) (*nb_skipped) ++; continue; } return GF_TRUE; } return GF_FALSE; }"
"void TEE_MACUpdate(TEE_OperationHandle operation, const void *chunk, uint32_t chunkSize) { TEE_Result res; if (operation == TEE_HANDLE_NULL || (chunk == NULL && chunkSize != 0)) TEE_Panic(0); if (operation->info.operationClass != TEE_OPERATION_MAC) TEE_Panic(0); if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) TEE_Panic(0); if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) TEE_Panic(0); res = utee_hash_update(operation->state, chunk, chunkSize); if (res != TEE_SUCCESS) TEE_Panic(res); }"
"static void analyze_regex (char *regex_arg) { if (regex_arg == NULL) { free_regexps (); return; } switch (regex_arg[0]) { case '\0': case ' ': case '\t': break; case '@': { FILE *regexfp; linebuffer regexbuf; char *regexfile = regex_arg + 1; regexfp = fopen (regexfile, ""r"" FOPEN_BINARY); if (regexfp == NULL) pfatal (regexfile); linebuffer_init (&regexbuf); while (readline_internal (&regexbuf, regexfp, regexfile) > 0) analyze_regex (regexbuf.buffer); free (regexbuf.buffer); if (fclose (regexfp) != 0) pfatal (regexfile); } break; case '{': { language *lang; char *lang_name = regex_arg + 1; char *cp; for (cp = lang_name; *cp != '}'; cp++) if (*cp == '\0') { error (""unterminated language name in regex: %s"", regex_arg); return; } *cp++ = '\0'; lang = get_language_from_langname (lang_name); if (lang == NULL) return; add_regex (cp, lang); } break; default: add_regex (regex_arg, NULL); break; } }"
"elf_errorstatus elf_init(struct elf_binary *elf, const char *image_input, size_t size) { ELF_HANDLE_DECL(elf_shdr) shdr; uint64_t i, count, section, offset, link; if ( !elf_is_elfbinary(image_input, size) ) { elf_err(elf, ""ELF: not an ELF binary\n""); return -1; } elf_memset_unchecked(elf, 0, sizeof(*elf)); elf->image_base = image_input; elf->size = size; elf->ehdr = ELF_MAKE_HANDLE(elf_ehdr, (elf_ptrval)image_input); elf->class = elf_uval_3264(elf, elf->ehdr, e32.e_ident[EI_CLASS]); elf->data = elf_uval_3264(elf, elf->ehdr, e32.e_ident[EI_DATA]); elf->caller_xdest_base = NULL; elf->caller_xdest_size = 0; offset = elf_uval(elf, elf->ehdr, e_phoff) + elf_uval(elf, elf->ehdr, e_phentsize) * elf_phdr_count(elf); if ( offset > elf->size ) { elf_err(elf, ""ELF: phdr overflow (off %"" PRIx64 "" > size %lx)\n"", offset, (unsigned long)elf->size); return -1; } offset = elf_uval(elf, elf->ehdr, e_shoff) + elf_uval(elf, elf->ehdr, e_shentsize) * elf_shdr_count(elf); if ( offset > elf->size ) { elf_err(elf, ""ELF: shdr overflow (off %"" PRIx64 "" > size %lx)\n"", offset, (unsigned long)elf->size); return -1; } section = elf_uval(elf, elf->ehdr, e_shstrndx); shdr = elf_shdr_by_index(elf, section); if ( ELF_HANDLE_VALID(shdr) ) elf->sec_strtab = elf_section_start(elf, shdr); count = elf_shdr_count(elf); for ( i = 0; i < count; i++ ) { shdr = elf_shdr_by_index(elf, i); if ( !elf_access_ok(elf, ELF_HANDLE_PTRVAL(shdr), 1) ) break; if ( elf_uval(elf, shdr, sh_type) != SHT_SYMTAB ) continue; link = elf_uval(elf, shdr, sh_link); if ( link == SHN_UNDEF || link >= elf_shdr_count(elf) ) break; elf->sym_tab = shdr; shdr = elf_shdr_by_index(elf, link); if ( !ELF_HANDLE_VALID(shdr) ) { elf->sym_tab = ELF_INVALID_HANDLE(elf_shdr); continue; } elf->sym_strtab = elf_section_start(elf, shdr); break; } return 0; }"
"int wolfSSH_SFTP_RecvLSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) { WS_SFTP_FILEATRB atr; char* name = NULL; int   ret = WS_SUCCESS; word32 sz; word32 idx = 0; byte*  out = NULL; word32 outSz = 0; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_LSTAT""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz) { return WS_BUFFER_E; } name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (name == NULL) { return WS_MEMORY_E; } WMEMCPY(name, data + idx, sz); name[sz] = '\0'; if (wolfSSH_CleanPath(ssh, name) < 0) { WLOG(WS_LOG_SFTP, ""Unable to clean path""); if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", NULL, &outSz) != WS_SIZE_ONLY) { WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } ret = WS_FATAL_ERROR; } if (ret == WS_SUCCESS) { WMEMSET((byte*)&atr, 0, sizeof(WS_SFTP_FILEATRB)); if ((ret = SFTP_GetAttributes(ssh->fs, name, &atr, 1, ssh->ctx->heap)) != WS_SUCCESS) { WLOG(WS_LOG_SFTP, ""Unable to get lstat of file/directory""); if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", NULL, &outSz) != WS_SIZE_ONLY) { WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } ret = WS_BAD_FILE_E; } else { sz = SFTP_AtributesSz(ssh, &atr); outSz = sz + WOLFSSH_SFTP_HEADER; } } WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (ret != WS_SUCCESS) { if (wolfSSH_SFTP_CreateStatus(ssh, WOLFSSH_FTP_FAILURE, reqId, ""LSTAT error"", ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } } else { if (SFTP_SetHeader(ssh, reqId, WOLFSSH_FTP_ATTRS, sz, out) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } SFTP_SetAttributes(ssh, out + WOLFSSH_SFTP_HEADER, sz, &atr); } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }"
"void guest_physmap_remove_page(struct domain *d, gfn_t gfn, mfn_t mfn, unsigned int page_order) { p2m_remove_mapping(d, gfn, (1 << page_order), mfn); }"
"static int fetch_interval_quantifier(UChar** src, UChar* end, PToken* tok, ScanEnv* env) { int low, up, syn_allow, non_low = 0; int r = 0; OnigCodePoint c; OnigEncoding enc = env->enc; UChar* p = *src; PFETCH_READY; syn_allow = IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INVALID_INTERVAL); if (PEND) { if (syn_allow) return 1;   else return ONIGERR_END_PATTERN_AT_LEFT_BRACE;   } if (! syn_allow) { c = PPEEK; if (c == ')' || c == '(' || c == '|') { return ONIGERR_END_PATTERN_AT_LEFT_BRACE; } } low = scan_number(&p, end, env->enc); if (low < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE; if (low > ONIG_MAX_REPEAT_NUM) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE; if (p == *src) {  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_INTERVAL_LOW_ABBREV)) { low = 0; non_low = 1; } else goto invalid; } if (PEND) goto invalid; PFETCH(c); if (c == ',') { UChar* prev = p; up = scan_number(&p, end, env->enc); if (up < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE; if (up > ONIG_MAX_REPEAT_NUM) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE; if (p == prev) { if (non_low != 0) goto invalid; up = INFINITE_REPEAT;   } } else { if (non_low != 0) goto invalid; PUNFETCH; up = low;   r = 2;      } if (PEND) goto invalid; PFETCH(c); if (IS_SYNTAX_OP(env->syntax, ONIG_SYN_OP_ESC_BRACE_INTERVAL)) { if (c != MC_ESC(env->syntax)) goto invalid; PFETCH(c); } if (c != '}') goto invalid; if (!IS_INFINITE_REPEAT(up) && low > up) { if (IS_SYNTAX_OP2(env->syntax, ONIG_SYN_OP2_PLUS_POSSESSIVE_INTERVAL)) return ONIGERR_UPPER_SMALLER_THAN_LOWER_IN_REPEAT_RANGE; tok->u.repeat.possessive = 1; { int tmp; tmp = low; low = up; up = tmp; } } else tok->u.repeat.possessive = 0; tok->type = TK_INTERVAL; tok->u.repeat.lower = low; tok->u.repeat.upper = up; *src = p; return r;  invalid: if (syn_allow) { return 1;   } else return ONIGERR_INVALID_REPEAT_RANGE_PATTERN; }"
"int read_image_tga( gdIOCtx *ctx, oTga *tga ) { int pixel_block_size = (tga->bits / 8); int image_block_size = (tga->width * tga->height) * pixel_block_size; uint8_t* decompression_buffer = NULL; unsigned char* conversion_buffer = NULL; int buffer_caret = 0; int bitmap_caret = 0; int i = 0; int j = 0; uint8_t encoded_pixels; if(overflow2(tga->width, tga->height)) { return -1; } if(overflow2(tga->width * tga->height, pixel_block_size)) { return -1; } if(overflow2(image_block_size, sizeof(int))) { return -1; } if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE) return -1; tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int)); if (tga->bitmap == NULL) return -1; switch (tga->imagetype) { case TGA_TYPE_RGB: conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { return -1; } gdGetBuf(conversion_buffer, image_block_size, ctx); while (buffer_caret < image_block_size) { tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret]; buffer_caret++; } gdFree(conversion_buffer); break; case TGA_TYPE_RGB_RLE: decompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t)); if (decompression_buffer == NULL) { return -1; } conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { gdFree( decompression_buffer ); return -1; } gdGetBuf( conversion_buffer, image_block_size, ctx ); buffer_caret = 0; while( buffer_caret < image_block_size) { decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret]; buffer_caret++; } buffer_caret = 0; while( bitmap_caret < image_block_size ) { if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) { encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 ); buffer_caret++; for (i = 0; i < encoded_pixels; i++) { for (j = 0; j < pixel_block_size; j++, bitmap_caret++) { tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ]; } } buffer_caret += pixel_block_size; } else { encoded_pixels = decompression_buffer[ buffer_caret ] + 1; buffer_caret++; for (i = 0; i < encoded_pixels; i++) { for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) { tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ]; } buffer_caret += pixel_block_size; } } } gdFree( decompression_buffer ); gdFree( conversion_buffer ); break; } return 1; }"
"static int hls_slice_header(HEVCContext *s) { GetBitContext *gb = &s->HEVClc->gb; SliceHeader *sh   = &s->sh; int i, ret; sh->first_slice_in_pic_flag = get_bits1(gb); if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) { s->seq_decode = (s->seq_decode + 1) & 0xff; s->max_ra     = INT_MAX; if (IS_IDR(s)) ff_hevc_clear_refs(s); } sh->no_output_of_prior_pics_flag = 0; if (IS_IRAP(s)) sh->no_output_of_prior_pics_flag = get_bits1(gb); sh->pps_id = get_ue_golomb_long(gb); if (sh->pps_id >= HEVC_MAX_PPS_COUNT || !s->ps.pps_list[sh->pps_id]) { av_log(s->avctx, AV_LOG_ERROR, ""PPS id out of range: %d\n"", sh->pps_id); return AVERROR_INVALIDDATA; } if (!sh->first_slice_in_pic_flag && s->ps.pps != (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data) { av_log(s->avctx, AV_LOG_ERROR, ""PPS changed between slices.\n""); return AVERROR_INVALIDDATA; } s->ps.pps = (HEVCPPS*)s->ps.pps_list[sh->pps_id]->data; if (s->nal_unit_type == HEVC_NAL_CRA_NUT && s->last_eos == 1) sh->no_output_of_prior_pics_flag = 1; if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) { const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data; const HEVCSPS *last_sps = s->ps.sps; enum AVPixelFormat pix_fmt; if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) { if (sps->width != last_sps->width || sps->height != last_sps->height || sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering != last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering) sh->no_output_of_prior_pics_flag = 0; } ff_hevc_clear_refs(s); pix_fmt = get_format(s, sps); if (pix_fmt < 0) return pix_fmt; ret = set_sps(s, sps, pix_fmt); if (ret < 0) return ret; s->seq_decode = (s->seq_decode + 1) & 0xff; s->max_ra     = INT_MAX; } sh->dependent_slice_segment_flag = 0; if (!sh->first_slice_in_pic_flag) { int slice_address_length; if (s->ps.pps->dependent_slice_segments_enabled_flag) sh->dependent_slice_segment_flag = get_bits1(gb); slice_address_length = av_ceil_log2(s->ps.sps->ctb_width * s->ps.sps->ctb_height); sh->slice_segment_addr = get_bitsz(gb, slice_address_length); if (sh->slice_segment_addr >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid slice segment address: %u.\n"", sh->slice_segment_addr); return AVERROR_INVALIDDATA; } if (!sh->dependent_slice_segment_flag) { sh->slice_addr = sh->slice_segment_addr; s->slice_idx++; } } else { sh->slice_segment_addr = sh->slice_addr = 0; s->slice_idx           = 0; s->slice_initialized   = 0; } if (!sh->dependent_slice_segment_flag) { s->slice_initialized = 0; for (i = 0; i < s->ps.pps->num_extra_slice_header_bits; i++) skip_bits(gb, 1);   sh->slice_type = get_ue_golomb_long(gb); if (!(sh->slice_type == HEVC_SLICE_I || sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B)) { av_log(s->avctx, AV_LOG_ERROR, ""Unknown slice type: %d.\n"", sh->slice_type); return AVERROR_INVALIDDATA; } if (IS_IRAP(s) && sh->slice_type != HEVC_SLICE_I) { av_log(s->avctx, AV_LOG_ERROR, ""Inter slices in an IRAP frame.\n""); return AVERROR_INVALIDDATA; } sh->pic_output_flag = 1; if (s->ps.pps->output_flag_present_flag) sh->pic_output_flag = get_bits1(gb); if (s->ps.sps->separate_colour_plane_flag) sh->colour_plane_id = get_bits(gb, 2); if (!IS_IDR(s)) { int poc, pos; sh->pic_order_cnt_lsb = get_bits(gb, s->ps.sps->log2_max_poc_lsb); poc = ff_hevc_compute_poc(s->ps.sps, s->pocTid0, sh->pic_order_cnt_lsb, s->nal_unit_type); if (!sh->first_slice_in_pic_flag && poc != s->poc) { av_log(s->avctx, AV_LOG_WARNING, ""Ignoring POC change between slices: %d -> %d\n"", s->poc, poc); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; poc = s->poc; } s->poc = poc; sh->short_term_ref_pic_set_sps_flag = get_bits1(gb); pos = get_bits_left(gb); if (!sh->short_term_ref_pic_set_sps_flag) { ret = ff_hevc_decode_short_term_rps(gb, s->avctx, &sh->slice_rps, s->ps.sps, 1); if (ret < 0) return ret; sh->short_term_rps = &sh->slice_rps; } else { int numbits, rps_idx; if (!s->ps.sps->nb_st_rps) { av_log(s->avctx, AV_LOG_ERROR, ""No ref lists in the SPS.\n""); return AVERROR_INVALIDDATA; } numbits = av_ceil_log2(s->ps.sps->nb_st_rps); rps_idx = numbits > 0 ? get_bits(gb, numbits) : 0; sh->short_term_rps = &s->ps.sps->st_rps[rps_idx]; } sh->short_term_ref_pic_set_size = pos - get_bits_left(gb); pos = get_bits_left(gb); ret = decode_lt_rps(s, &sh->long_term_rps, gb); if (ret < 0) { av_log(s->avctx, AV_LOG_WARNING, ""Invalid long term RPS.\n""); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_INVALIDDATA; } sh->long_term_ref_pic_set_size = pos - get_bits_left(gb); if (s->ps.sps->sps_temporal_mvp_enabled_flag) sh->slice_temporal_mvp_enabled_flag = get_bits1(gb); else sh->slice_temporal_mvp_enabled_flag = 0; } else { s->sh.short_term_rps = NULL; s->poc               = 0; } if (sh->first_slice_in_pic_flag && s->temporal_id == 0 && s->nal_unit_type != HEVC_NAL_TRAIL_N && s->nal_unit_type != HEVC_NAL_TSA_N   && s->nal_unit_type != HEVC_NAL_STSA_N  && s->nal_unit_type != HEVC_NAL_RADL_N  && s->nal_unit_type != HEVC_NAL_RADL_R  && s->nal_unit_type != HEVC_NAL_RASL_N  && s->nal_unit_type != HEVC_NAL_RASL_R) s->pocTid0 = s->poc; if (s->ps.sps->sao_enabled) { sh->slice_sample_adaptive_offset_flag[0] = get_bits1(gb); if (s->ps.sps->chroma_format_idc) { sh->slice_sample_adaptive_offset_flag[1] = sh->slice_sample_adaptive_offset_flag[2] = get_bits1(gb); } } else { sh->slice_sample_adaptive_offset_flag[0] = 0; sh->slice_sample_adaptive_offset_flag[1] = 0; sh->slice_sample_adaptive_offset_flag[2] = 0; } sh->nb_refs[L0] = sh->nb_refs[L1] = 0; if (sh->slice_type == HEVC_SLICE_P || sh->slice_type == HEVC_SLICE_B) { int nb_refs; sh->nb_refs[L0] = s->ps.pps->num_ref_idx_l0_default_active; if (sh->slice_type == HEVC_SLICE_B) sh->nb_refs[L1] = s->ps.pps->num_ref_idx_l1_default_active; if (get_bits1(gb)) {                 sh->nb_refs[L0] = get_ue_golomb_long(gb) + 1; if (sh->slice_type == HEVC_SLICE_B) sh->nb_refs[L1] = get_ue_golomb_long(gb) + 1; } if (sh->nb_refs[L0] > HEVC_MAX_REFS || sh->nb_refs[L1] > HEVC_MAX_REFS) { av_log(s->avctx, AV_LOG_ERROR, ""Too many refs: %d/%d.\n"", sh->nb_refs[L0], sh->nb_refs[L1]); return AVERROR_INVALIDDATA; } sh->rpl_modification_flag[0] = 0; sh->rpl_modification_flag[1] = 0; nb_refs = ff_hevc_frame_nb_refs(s); if (!nb_refs) { av_log(s->avctx, AV_LOG_ERROR, ""Zero refs for a frame with P or B slices.\n""); return AVERROR_INVALIDDATA; } if (s->ps.pps->lists_modification_present_flag && nb_refs > 1) { sh->rpl_modification_flag[0] = get_bits1(gb); if (sh->rpl_modification_flag[0]) { for (i = 0; i < sh->nb_refs[L0]; i++) sh->list_entry_lx[0][i] = get_bits(gb, av_ceil_log2(nb_refs)); } if (sh->slice_type == HEVC_SLICE_B) { sh->rpl_modification_flag[1] = get_bits1(gb); if (sh->rpl_modification_flag[1] == 1) for (i = 0; i < sh->nb_refs[L1]; i++) sh->list_entry_lx[1][i] = get_bits(gb, av_ceil_log2(nb_refs)); } } if (sh->slice_type == HEVC_SLICE_B) sh->mvd_l1_zero_flag = get_bits1(gb); if (s->ps.pps->cabac_init_present_flag) sh->cabac_init_flag = get_bits1(gb); else sh->cabac_init_flag = 0; sh->collocated_ref_idx = 0; if (sh->slice_temporal_mvp_enabled_flag) { sh->collocated_list = L0; if (sh->slice_type == HEVC_SLICE_B) sh->collocated_list = !get_bits1(gb); if (sh->nb_refs[sh->collocated_list] > 1) { sh->collocated_ref_idx = get_ue_golomb_long(gb); if (sh->collocated_ref_idx >= sh->nb_refs[sh->collocated_list]) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid collocated_ref_idx: %d.\n"", sh->collocated_ref_idx); return AVERROR_INVALIDDATA; } } } if ((s->ps.pps->weighted_pred_flag   && sh->slice_type == HEVC_SLICE_P) || (s->ps.pps->weighted_bipred_flag && sh->slice_type == HEVC_SLICE_B)) { int ret = pred_weight_table(s, gb); if (ret < 0) return ret; } sh->max_num_merge_cand = 5 - get_ue_golomb_long(gb); if (sh->max_num_merge_cand < 1 || sh->max_num_merge_cand > 5) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of merging MVP candidates: %d.\n"", sh->max_num_merge_cand); return AVERROR_INVALIDDATA; } } sh->slice_qp_delta = get_se_golomb(gb); if (s->ps.pps->pic_slice_level_chroma_qp_offsets_present_flag) { sh->slice_cb_qp_offset = get_se_golomb(gb); sh->slice_cr_qp_offset = get_se_golomb(gb); } else { sh->slice_cb_qp_offset = 0; sh->slice_cr_qp_offset = 0; } if (s->ps.pps->chroma_qp_offset_list_enabled_flag) sh->cu_chroma_qp_offset_enabled_flag = get_bits1(gb); else sh->cu_chroma_qp_offset_enabled_flag = 0; if (s->ps.pps->deblocking_filter_control_present_flag) { int deblocking_filter_override_flag = 0; if (s->ps.pps->deblocking_filter_override_enabled_flag) deblocking_filter_override_flag = get_bits1(gb); if (deblocking_filter_override_flag) { sh->disable_deblocking_filter_flag = get_bits1(gb); if (!sh->disable_deblocking_filter_flag) { int beta_offset_div2 = get_se_golomb(gb); int tc_offset_div2   = get_se_golomb(gb) ; if (beta_offset_div2 < -6 || beta_offset_div2 > 6 || tc_offset_div2   < -6 || tc_offset_div2   > 6) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid deblock filter offsets: %d, %d\n"", beta_offset_div2, tc_offset_div2); return AVERROR_INVALIDDATA; } sh->beta_offset = beta_offset_div2 * 2; sh->tc_offset   =   tc_offset_div2 * 2; } } else { sh->disable_deblocking_filter_flag = s->ps.pps->disable_dbf; sh->beta_offset                    = s->ps.pps->beta_offset; sh->tc_offset                      = s->ps.pps->tc_offset; } } else { sh->disable_deblocking_filter_flag = 0; sh->beta_offset                    = 0; sh->tc_offset                      = 0; } if (s->ps.pps->seq_loop_filter_across_slices_enabled_flag && (sh->slice_sample_adaptive_offset_flag[0] || sh->slice_sample_adaptive_offset_flag[1] || !sh->disable_deblocking_filter_flag)) { sh->slice_loop_filter_across_slices_enabled_flag = get_bits1(gb); } else { sh->slice_loop_filter_across_slices_enabled_flag = s->ps.pps->seq_loop_filter_across_slices_enabled_flag; } } else if (!s->slice_initialized) { av_log(s->avctx, AV_LOG_ERROR, ""Independent slice segment missing.\n""); return AVERROR_INVALIDDATA; } sh->num_entry_point_offsets = 0; if (s->ps.pps->tiles_enabled_flag || s->ps.pps->entropy_coding_sync_enabled_flag) { unsigned num_entry_point_offsets = get_ue_golomb_long(gb); if (num_entry_point_offsets > get_bits_left(gb)) { av_log(s->avctx, AV_LOG_ERROR, ""num_entry_point_offsets %d is invalid\n"", num_entry_point_offsets); return AVERROR_INVALIDDATA; } sh->num_entry_point_offsets = num_entry_point_offsets; if (sh->num_entry_point_offsets > 0) { int offset_len = get_ue_golomb_long(gb) + 1; if (offset_len < 1 || offset_len > 32) { sh->num_entry_point_offsets = 0; av_log(s->avctx, AV_LOG_ERROR, ""offset_len %d is invalid\n"", offset_len); return AVERROR_INVALIDDATA; } av_freep(&sh->entry_point_offset); av_freep(&sh->offset); av_freep(&sh->size); sh->entry_point_offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(unsigned)); sh->offset = av_malloc_array(sh->num_entry_point_offsets, sizeof(int)); sh->size = av_malloc_array(sh->num_entry_point_offsets, sizeof(int)); if (!sh->entry_point_offset || !sh->offset || !sh->size) { sh->num_entry_point_offsets = 0; av_log(s->avctx, AV_LOG_ERROR, ""Failed to allocate memory\n""); return AVERROR(ENOMEM); } for (i = 0; i < sh->num_entry_point_offsets; i++) { unsigned val = get_bits_long(gb, offset_len); sh->entry_point_offset[i] = val + 1;             } if (s->threads_number > 1 && (s->ps.pps->num_tile_rows > 1 || s->ps.pps->num_tile_columns > 1)) { s->enable_parallel_tiles = 0;                 s->threads_number = 1; } else s->enable_parallel_tiles = 0; } else s->enable_parallel_tiles = 0; } if (s->ps.pps->slice_header_extension_present_flag) { unsigned int length = get_ue_golomb_long(gb); if (length*8LL > get_bits_left(gb)) { av_log(s->avctx, AV_LOG_ERROR, ""too many slice_header_extension_data_bytes\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < length; i++) skip_bits(gb, 8);      } sh->slice_qp = 26U + s->ps.pps->pic_init_qp_minus26 + sh->slice_qp_delta; if (sh->slice_qp > 51 || sh->slice_qp < -s->ps.sps->qp_bd_offset) { av_log(s->avctx, AV_LOG_ERROR, ""The slice_qp %d is outside the valid range "" ""[%d, 51].\n"", sh->slice_qp, -s->ps.sps->qp_bd_offset); return AVERROR_INVALIDDATA; } sh->slice_ctb_addr_rs = sh->slice_segment_addr; if (!s->sh.slice_ctb_addr_rs && s->sh.dependent_slice_segment_flag) { av_log(s->avctx, AV_LOG_ERROR, ""Impossible slice segment.\n""); return AVERROR_INVALIDDATA; } if (get_bits_left(gb) < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Overread slice header by %d bits\n"", -get_bits_left(gb)); return AVERROR_INVALIDDATA; } s->HEVClc->first_qp_group = !s->sh.dependent_slice_segment_flag; if (!s->ps.pps->cu_qp_delta_enabled_flag) s->HEVClc->qp_y = s->sh.slice_qp; s->slice_initialized = 1; s->HEVClc->tu.cu_qp_offset_cb = 0; s->HEVClc->tu.cu_qp_offset_cr = 0; return 0; }"
"int get_netnsid_from_name(const char *name) { struct { struct nlmsghdr n; struct rtgenmsg g; char            buf[1024]; } req = { .n.nlmsg_len = NLMSG_LENGTH(sizeof(struct rtgenmsg)), .n.nlmsg_flags = NLM_F_REQUEST, .n.nlmsg_type = RTM_GETNSID, .g.rtgen_family = AF_UNSPEC, }; struct nlmsghdr *answer; struct rtattr *tb[NETNSA_MAX + 1]; struct rtgenmsg *rthdr; int len, fd; netns_nsid_socket_init(); fd = netns_get_fd(name); if (fd < 0) return fd; addattr32(&req.n, 1024, NETNSA_FD, fd); if (rtnl_talk(&rtnsh, &req.n, &answer) < 0) { close(fd); return -2; } close(fd); if (answer->nlmsg_type == NLMSG_ERROR) goto err_out; rthdr = NLMSG_DATA(answer); len = answer->nlmsg_len - NLMSG_SPACE(sizeof(*rthdr)); if (len < 0) goto err_out; parse_rtattr(tb, NETNSA_MAX, NETNS_RTA(rthdr), len); if (tb[NETNSA_NSID]) { free(answer); return rta_getattr_u32(tb[NETNSA_NSID]); } err_out: free(answer); return -1; }"
"static void vmx_set_constant_host_state(struct vcpu_vmx *vmx) { u32 low32, high32; unsigned long tmpl; struct desc_ptr dt; vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);   vmcs_writel(HOST_CR4, read_cr4());   vmcs_writel(HOST_CR3, read_cr3());   vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);   #ifdef CONFIG_X86_64 vmcs_write16(HOST_DS_SELECTOR, 0); vmcs_write16(HOST_ES_SELECTOR, 0); #else vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);   vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);   #endif vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);   vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);   native_store_idt(&dt); vmcs_writel(HOST_IDTR_BASE, dt.address);    vmx->host_idt_base = dt.address; vmcs_writel(HOST_RIP, vmx_return);  rdmsr(MSR_IA32_SYSENTER_CS, low32, high32); vmcs_write32(HOST_IA32_SYSENTER_CS, low32); rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl); vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);    if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) { rdmsr(MSR_IA32_CR_PAT, low32, high32); vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32)); } }"
"int read_exif_orientation_tag(const uint8_t* exif, int size) { bool little_endian; int pos = find_exif_tag(exif, size, EXIF_TAG_ORIENTATION, &little_endian); if (pos < 0) { return DEFAULT_EXIF_ORIENTATION; } int type = read16(exif, size, pos + 2, little_endian); int count = read32(exif, size, pos + 4, little_endian); if (type == EXIF_TYPE_SHORT && count == 1) { return read16(exif, size, pos + 8, little_endian); } return DEFAULT_EXIF_ORIENTATION; }"
"static int resp_get_length(netdissect_options *ndo, register const u_char *bp, int len, const u_char **endp) { int result; u_char c; int saw_digit; int neg; int too_large; if (len == 0) goto trunc; ND_TCHECK(*bp); too_large = 0; neg = 0; if (*bp == '-') { neg = 1; bp++; len--; } result = 0; saw_digit = 0; for (;;) { if (len == 0) goto trunc; ND_TCHECK(*bp); c = *bp; if (!(c >= '0' && c <= '9')) { if (!saw_digit) goto invalid; break; } c -= '0'; if (result > (INT_MAX / 10)) { too_large = 1; } else { result *= 10; if (result == INT_MAX && c > (INT_MAX % 10)) { too_large = 1; } else result += c; } bp++; len--; saw_digit = 1; } if (!saw_digit) goto invalid; if (len == 0) goto trunc; ND_TCHECK(*bp); if (*bp != '\r') goto invalid; bp++; len--; if (len == 0) goto trunc; ND_TCHECK(*bp); if (*bp != '\n') goto invalid; bp++; len--; *endp = bp; if (neg) { if (too_large || result != 1) return (-4); result = -1; } return (too_large ? -3 : result); trunc: return (-2); invalid: return (-5); }"
"void GfxColorSpace::setDisplayProfile(void *displayProfileA) { displayProfile = displayProfileA; if (displayProfile != nullptr) { cmsHTRANSFORM transform; unsigned int nChannels; displayPixelType = getCMSColorSpaceType(cmsGetColorSpace(displayProfile)); nChannels = getCMSNChannels(cmsGetColorSpace(displayProfile)); cmsHPROFILE XYZProfile = cmsCreateXYZProfile(); if ((transform = cmsCreateTransform(XYZProfile, TYPE_XYZ_DBL, displayProfile, COLORSPACE_SH(displayPixelType) | CHANNELS_SH(nChannels) | BYTES_SH(1), INTENT_RELATIVE_COLORIMETRIC,LCMS_FLAGS)) == nullptr) { error(errSyntaxWarning, -1, ""Can't create Lab transform""); } else { XYZ2DisplayTransform = new GfxColorTransform(transform, INTENT_RELATIVE_COLORIMETRIC, PT_XYZ, displayPixelType); } cmsCloseProfile(XYZProfile); } }"
"int sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw, char **user_env[]) { sudo_auth *auth; debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH); for (auth = auth_switch; auth->name; auth++) { if (auth->begin_session && !IS_DISABLED(auth)) { int status = (auth->begin_session)(ctx, pw, user_env, auth); if (status != AUTH_SUCCESS) { debug_return_int(-1); } } } debug_return_int(1); }"
"de265_error video_usability_information::hrd_parameters(error_queue* errqueue, bitreader* br, const seq_parameter_set* sps) { int vlc; nal_hrd_parameters_present_flag = get_bits(br, 1); vcl_hrd_parameters_present_flag = get_bits(br, 1); if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) { sub_pic_hrd_params_present_flag = get_bits(br, 1); if (sub_pic_hrd_params_present_flag) { tick_divisor_minus2 = get_bits(br, 8); du_cpb_removal_delay_increment_length_minus1 = get_bits(br, 5); sub_pic_cpb_params_in_pic_timing_sei_flag = get_bits(br, 1); dpb_output_delay_du_length_minus1 = get_bits(br, 5); } bit_rate_scale = get_bits(br, 4); cpb_size_scale = get_bits(br, 4); if (sub_pic_hrd_params_present_flag) { cpb_size_du_scale = get_bits(br, 4); } initial_cpb_removal_delay_length_minus1 = get_bits(br, 5); au_cpb_removal_delay_length_minus1 = get_bits(br, 5); dpb_output_delay_length_minus1 = get_bits(br, 5); } int  i, j, nalOrVcl; for (i = 0; i < sps->sps_max_sub_layers; i++) { fixed_pic_rate_general_flag[i] = get_bits(br, 1); if (!fixed_pic_rate_general_flag[i]) { fixed_pic_rate_within_cvs_flag[i] = get_bits(br, 1); } else { fixed_pic_rate_within_cvs_flag[i] = true; } low_delay_hrd_flag[i] = 0;    cpb_cnt_minus1[i] = 0;     if (fixed_pic_rate_within_cvs_flag[i]) { READ_VLC_OFFSET(elemental_duration_in_tc_minus1[i], uvlc, 0); } else { low_delay_hrd_flag[i] = get_bits(br, 1); } if (!low_delay_hrd_flag[i]) { READ_VLC_OFFSET(cpb_cnt_minus1[i], uvlc, 0); } for (nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++) { if (((nalOrVcl == 0) && nal_hrd_parameters_present_flag) || ((nalOrVcl == 1) && vcl_hrd_parameters_present_flag)) { for (j = 0; j <= cpb_cnt_minus1[i]; j++) { READ_VLC_OFFSET(bit_rate_value_minus1[i][j][nalOrVcl], uvlc, 0); READ_VLC_OFFSET(cpb_size_value_minus1[i][j][nalOrVcl], uvlc, 0); if (sub_pic_hrd_params_present_flag) { READ_VLC_OFFSET(cpb_size_du_value_minus1[i][j][nalOrVcl], uvlc, 0); READ_VLC_OFFSET(bit_rate_du_value_minus1[i][j][nalOrVcl], uvlc, 0); } cbr_flag[i][j][nalOrVcl] = get_bits(br, 1); } } } } return DE265_OK; }"
"static ssize_t rbd_config_info_show(struct device *dev, struct device_attribute *attr, char *buf) { struct rbd_device *rbd_dev = dev_to_rbd_dev(dev); return sprintf(buf, ""%s\n"", rbd_dev->config_info); }"
"void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif Q_D(QPaintEngineEx); if (path.isEmpty()) return; if (!d->strokeHandler) { d->strokeHandler = new StrokeHandler(path.elementCount()+4); d->stroker.setMoveToHook(qpaintengineex_moveTo); d->stroker.setLineToHook(qpaintengineex_lineTo); d->stroker.setCubicToHook(qpaintengineex_cubicTo); } QRectF clipRect; QPen pen = inPen; if (pen.style() > Qt::SolidLine) { QRectF cpRect = path.controlPointRect(); const QTransform &xf = state()->matrix; if (pen.isCosmetic()) { clipRect = d->exDeviceRect; cpRect.translate(xf.dx(), xf.dy()); } else { clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect)); } QRectF extentRect = cpRect & clipRect; qreal extent = qMax(extentRect.width(), extentRect.height()); qreal patternLength = 0; const QList<qreal> pattern = pen.dashPattern(); const int patternSize = qMin(pattern.size(), 32); for (int i = 0; i < patternSize; i++) patternLength += qMax(pattern.at(i), qreal(0)); if (pen.widthF()) patternLength *= pen.widthF(); if (qFuzzyIsNull(patternLength)) { pen.setStyle(Qt::NoPen); } else if (extent / patternLength > 10000) { pen.setStyle(Qt::SolidLine); QColor color(pen.color()); color.setAlpha(color.alpha() / 2); pen.setColor(color); } } if (!qpen_fast_equals(pen, d->strokerPen)) { d->strokerPen = pen; d->stroker.setJoinStyle(pen.joinStyle()); d->stroker.setCapStyle(pen.capStyle()); d->stroker.setMiterLimit(pen.miterLimit()); qreal penWidth = pen.widthF(); if (penWidth == 0) d->stroker.setStrokeWidth(1); else d->stroker.setStrokeWidth(penWidth); Qt::PenStyle style = pen.style(); if (style == Qt::SolidLine) { d->activeStroker = &d->stroker; } else if (style == Qt::NoPen) { d->activeStroker = nullptr; } else { d->dasher.setDashPattern(pen.dashPattern()); d->dasher.setDashOffset(pen.dashOffset()); d->activeStroker = &d->dasher; } } if (!d->activeStroker) { return; } if (!clipRect.isNull()) d->activeStroker->setClipRect(clipRect); if (d->activeStroker == &d->stroker) d->stroker.setForceOpen(path.hasExplicitOpen()); const QPainterPath::ElementType *types = path.elements(); const qreal *points = path.points(); int pointCount = path.elementCount(); const qreal *lastPoint = points + (pointCount<<1); d->strokeHandler->types.reset(); d->strokeHandler->pts.reset(); uint flags = QVectorPath::WindingFill; if (path.elementCount() > 2) flags |= QVectorPath::NonConvexShapeMask; if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin) flags |= QVectorPath::CurvedShapeMask; if (!pen.isCosmetic()) { d->activeStroker->setCurveThresholdFromTransform(state()->matrix); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: d->activeStroker->moveTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::LineToElement: d->activeStroker->lineTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::CurveToElement: d->activeStroker->cubicTo(points[0], points[1], points[2], points[3], points[4], points[5]); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; default: break; } } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } else { d->activeStroker->moveTo(points[0], points[1]); points += 2; while (points < lastPoint) { d->activeStroker->lineTo(points[0], points[1]); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } d->activeStroker->end(); if (!d->strokeHandler->types.size())             return; QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); fill(strokePath, pen.brush()); } else { if (state()->matrix.type() >= QTransform::TxProject) { QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath()); d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform()); } else { d->activeStroker->setCurveThresholdFromTransform(QTransform()); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->moveTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::LineToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::CurveToElement: { QPointF c1 = ((const QPointF *) points)[0] * state()->matrix; QPointF c2 = ((const QPointF *) points)[1] * state()->matrix; QPointF e =  ((const QPointF *) points)[2] * state()->matrix; d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y()); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; } default: break; } } if (path.hasImplicitClose()) { QPointF pt = * ((const QPointF *) path.points()) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); } } else { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->moveTo(p.x(), p.y()); points += 2; while (points < lastPoint) { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->lineTo(p.x(), p.y()); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(p.x(), p.y()); } d->activeStroker->end(); } QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); QTransform xform = state()->matrix; state()->matrix = QTransform(); transformChanged(); QBrush brush = pen.brush(); if (qbrush_style(brush) != Qt::SolidPattern) brush.setTransform(brush.transform() * xform); fill(strokePath, brush); state()->matrix = xform; transformChanged(); } }"
"Status KernelAndDeviceOp::Run( ScopedStepContainer* step_container, const EagerKernelArgs& inputs, std::vector<EagerKernelRet>* outputs, CancellationManager* cancellation_manager, const absl::optional<EagerRemoteFunctionParams>& remote_func_params) { OpKernelContext::Params params; params.device = device_; params.frame_iter = FrameAndIter(0, 0); params.inputs = inputs.GetTensorValues(); params.op_kernel = kernel_.get(); params.resource_manager = device_->resource_manager(); params.input_alloc_attrs = &input_alloc_attrs_; params.output_attr_array = output_alloc_attrs_.data(); params.function_library = flr_; params.slice_reader_cache = &slice_reader_cache_; params.rendezvous = rendezvous_; OpExecutionState* op_execution_state = nullptr; CancellationManager default_cancellation_manager; if (cancellation_manager) { params.cancellation_manager = cancellation_manager; } else if (kernel_->is_deferred()) { op_execution_state = new OpExecutionState; params.cancellation_manager = &op_execution_state->cancellation_manager; params.inc_num_deferred_ops_function = [op_execution_state]() { op_execution_state->Ref(); }; params.dec_num_deferred_ops_function = [op_execution_state]() { op_execution_state->Unref(); }; } else { params.cancellation_manager = &default_cancellation_manager; } params.log_memory = log_memory_; params.runner = get_runner(); params.step_container = step_container == nullptr ? &step_container_ : step_container; auto step_container_cleanup = gtl::MakeCleanup([step_container, this] { if (step_container == nullptr) { this->step_container_.CleanUp(); } }); params.collective_executor = collective_executor_ ? collective_executor_->get() : nullptr; OpKernelContext context(&params); { port::ScopedFlushDenormal flush; port::ScopedSetRound round(FE_TONEAREST); profiler::AnnotatedTraceMe activity( [&] { return kernel_->TraceString(context, false); }, profiler::TraceMeLevel::kInfo); device_->Compute(kernel_.get(), &context); } if (op_execution_state != nullptr) { op_execution_state->Unref(); } if (!context.status().ok()) return context.status(); if (outputs != nullptr) { outputs->clear(); for (int i = 0; i < context.num_outputs(); ++i) { outputs->push_back(Tensor(*context.mutable_output(i))); } } return Status::OK(); }"
"static void evtchn_fifo_handle_events(unsigned cpu) { __evtchn_fifo_handle_events(cpu, false); }"
"DiskInfo get_disk_info(void) { FILE *mounts; char procline[1024]; char *mount, *device, *type, *mode, *other; float thispct, max=0.0; double dtotal=0.0, dfree=0.0; DiskInfo di; di.total = 0; di.free = 0; mounts = fopen(MOUNTS,""r""); if (!mounts) { return di; } while ( fgets(procline, sizeof(procline), mounts) ) { device = procline; mount = index(procline, ' '); if (mount == NULL) continue; *mount++ = '\0'; type = index(mount, ' '); if (type == NULL) continue; *type++ = '\0'; mode = index(type, ' '); if (mode == NULL) continue; *mode++ = '\0'; other = index(mode, ' '); if (other != NULL) *other = '\0'; if (!strncmp(mode, ""ro"", 2)) continue; if (remote_mount(device, type)) continue; if (strncmp(device, ""/dev/"", 5) != 0 && strncmp(device, ""/dev2/"", 6) != 0) continue; thispct = device_space(mount, device, &dtotal, &dfree); if (!max || max<thispct) max = thispct; } fclose(mounts); DFcleanup(); di.total = dtotal / 1000; di.free = dfree / 1000; return di; }"
"void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation) { if (method_name == ""listRules"") { const char* label_cstr = nullptr; g_variant_get(parameters, ""(&s)"", &label_cstr); std::string label(label_cstr); auto rules = listRules(label); if (rules.size() > 0) { auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); try { for (auto rule : rules) { g_variant_builder_add(gvbuilder, ""(us)"", rule.getRuleID(), rule.toString().c_str()); } g_dbus_method_invocation_return_value(invocation, g_variant_new(""(a(us))"", gvbuilder)); } catch (...) { g_variant_builder_unref(gvbuilder); throw; } g_variant_builder_unref(gvbuilder); } else { g_dbus_method_invocation_return_value(invocation, g_variant_new(""(a(us))"", nullptr)); } return; } if (method_name == ""appendRule"") { const char* rule_spec_cstr = nullptr; uint32_t parent_id = 0; gboolean temporary = false; g_variant_get(parameters, ""(&sub)"", &rule_spec_cstr, &parent_id, &temporary); std::string rule_spec(rule_spec_cstr); const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary); g_dbus_method_invocation_return_value(invocation, g_variant_new(""(u)"", rule_id)); return; } if (method_name == ""removeRule"") { uint32_t rule_id = 0; g_variant_get(parameters, ""(u)"", &rule_id); removeRule(rule_id); g_dbus_method_invocation_return_value(invocation, nullptr); return; } g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, ""Unknown method interface""); return; }"
"static Jsi_RC jsi_ArraySortCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); int flags = 0, i, curlen, hasopt = 0; Jsi_Value *v, *arg = NULL; SortInfo si = {}; si.interp = interp; Jsi_Obj *obj = _this->d.obj; curlen = obj->arrCnt; if (curlen <= 1) { goto done; } arg = Jsi_ValueArrayIndex(interp, args, 0); if (arg) { if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) { if (Jsi_OptionsProcess(interp, jsi_ArraySortOptions, &si, arg, 0) < 0) return JSI_ERROR; hasopt = 1; switch (si.mode) { case 1: flags |= JSI_SORT_DESCEND; break; case 2: flags |= JSI_SORT_DICT; break; case 3: flags |= JSI_SORT_NOCASE; break; } } else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_FUNCTION)) si.compare = arg; else  return Jsi_LogError(""expected object or function""); } si.flags = flags; Jsi_ObjListifyArray(interp, obj); #ifdef NO_QSORT_R curSortInfo = &si; qsort(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd); #else qsort_r(obj->arr, curlen, sizeof(Jsi_Value*), SortSubCmd, &si); #endif if (interp->deleting) { #ifdef NO_QSORT_R curSortInfo = NULL; #endif return JSI_ERROR; } if (si.unique) { int n, diff = 1, dupCnt=0; for (n=0, i=1; i<(int)obj->arrCnt; i++) { if (obj->arr[n] == obj->arr[i]) diff = 1; else #ifdef NO_QSORT_R diff = SortSubCmd(&obj->arr[n], &obj->arr[i]); #else #ifdef __WIN32 diff = SortSubCmd(&si, &obj->arr[n], &obj->arr[i]); #else diff = SortSubCmd(&obj->arr[n], &obj->arr[i], &si); #endif #endif if (diff) { n++; if (n!=i) obj->arr[n] = obj->arr[i]; } else { dupCnt++; if (obj->arr[i]) Jsi_DecrRefCount(interp, obj->arr[i]); obj->arr[i] = 0; } } obj->arrCnt -= dupCnt; } #ifdef NO_QSORT_R curSortInfo = NULL; #endif if (hasopt) Jsi_OptionsFree(interp, jsi_ArraySortOptions, &si, 0); done: v = Jsi_ValueMakeObject(interp, NULL, obj); Jsi_ValueReplace(interp, ret, v); return JSI_OK; }"
"void blog_post(char post_path[]) { if(file_exists(post_path) > 0) { struct blogpost post = make_blogpost(post_path); send_header(""Content-type"", ""text/html""); terminate_headers(); template_header(); template_post_single_entry(post); } else { send_header(""Content-type"", ""text/html""); send_header(""Status"", ""404 Not Found""); terminate_headers(); template_header(); template_error_404(); } template_footer(); }"
"void guest_physmap_remove_page(struct domain *d, gfn_t gfn, mfn_t mfn, unsigned int page_order) { p2m_remove_mapping(d, gfn, (1 << page_order), mfn); }"
"static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter) { struct pcie_service_card *card = adapter->card; struct sk_buff *skb; skb = dev_alloc_skb(MWIFIEX_UPLD_SIZE); if (!skb) { mwifiex_dbg(adapter, ERROR, ""Unable to allocate skb for command response data.\n""); return -ENOMEM; } skb_put(skb, MWIFIEX_UPLD_SIZE); if (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE, PCI_DMA_FROMDEVICE)) return -1; card->cmdrsp_buf = skb; return 0; }"
"void *malloc_wrapper(struct _reent *r, size_t size, void *caller) { void *ptr = NULL; #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_lock(); #endif #ifdef MBED_HEAP_STATS_ENABLED malloc_stats_mutex->lock(); alloc_info_t *alloc_info = (alloc_info_t *)__real__malloc_r(r, size + sizeof(alloc_info_t)); if (alloc_info != NULL) { alloc_info->size = size; alloc_info->signature = MBED_HEAP_STATS_SIGNATURE; ptr = (void *)(alloc_info + 1); heap_stats.current_size += size; heap_stats.total_size += size; heap_stats.alloc_cnt += 1; if (heap_stats.current_size > heap_stats.max_size) { heap_stats.max_size = heap_stats.current_size; } heap_stats.overhead_size += MALLOC_HEAP_TOTAL_SIZE(MALLOC_HEADER_PTR(alloc_info)) - size; } else { heap_stats.alloc_fail_cnt += 1; } malloc_stats_mutex->unlock(); #else     ptr = __real__malloc_r(r, size); #endif #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_malloc(ptr, size, caller); mbed_mem_trace_unlock(); #endif     return ptr; }"
"zzip__new__ ZZIP_DISK_FILE * zzip_disk_entry_fopen(ZZIP_DISK * disk, ZZIP_DISK_ENTRY * entry) { struct zzip_file_header *header = zzip_disk_entry_to_file_header(disk, entry); if (! header) return 0;  ___ ZZIP_DISK_FILE *file = malloc(sizeof(ZZIP_DISK_FILE)); if (! file) return 0;  file->buffer = disk->buffer; file->endbuf = disk->endbuf; file->avail = zzip_file_header_usize(header); if (! file->avail || zzip_file_header_data_stored(header)) {  file->stored = zzip_file_header_to_data (header); DBG2(""stored size %i"", (int) file->avail); if (file->stored + file->avail >= disk->endbuf) goto error; return file;  } file->stored = 0; file->zlib.opaque = 0; file->zlib.zalloc = Z_NULL; file->zlib.zfree = Z_NULL; file->zlib.avail_in = zzip_file_header_csize(header); file->zlib.next_in = zzip_file_header_to_data(header); DBG2(""compressed size %i"", (int) file->zlib.avail_in); if (file->zlib.next_in + file->zlib.avail_in >= disk->endbuf) goto error; if (! zzip_file_header_data_deflated(header)) goto error; if (inflateInit2(&file->zlib, -MAX_WBITS) != Z_OK) goto error; return file; error: free (file); errno = EBADMSG; return 0;  ____; }"
"void* sk_malloc_flags(size_t size, unsigned flags) { return (flags & SK_MALLOC_THROW) ? moz_xmalloc(size) : malloc(size); }"
"static int snd_timer_user_params(struct file *file, struct snd_timer_params __user *_params) { struct snd_timer_user *tu; struct snd_timer_params params; struct snd_timer *t; struct snd_timer_read *tr; struct snd_timer_tread *ttr; int err; tu = file->private_data; if (!tu->timeri) return -EBADFD; t = tu->timeri->timer; if (!t) return -EBADFD; if (copy_from_user(&params, _params, sizeof(params))) return -EFAULT; if (!(t->hw.flags & SNDRV_TIMER_HW_SLAVE) && params.ticks < 1) { err = -EINVAL; goto _end; } if (params.queue_size > 0 && (params.queue_size < 32 || params.queue_size > 1024)) { err = -EINVAL; goto _end; } if (params.filter & ~((1<<SNDRV_TIMER_EVENT_RESOLUTION)| (1<<SNDRV_TIMER_EVENT_TICK)| (1<<SNDRV_TIMER_EVENT_START)| (1<<SNDRV_TIMER_EVENT_STOP)| (1<<SNDRV_TIMER_EVENT_CONTINUE)| (1<<SNDRV_TIMER_EVENT_PAUSE)| (1<<SNDRV_TIMER_EVENT_SUSPEND)| (1<<SNDRV_TIMER_EVENT_RESUME)| (1<<SNDRV_TIMER_EVENT_MSTART)| (1<<SNDRV_TIMER_EVENT_MSTOP)| (1<<SNDRV_TIMER_EVENT_MCONTINUE)| (1<<SNDRV_TIMER_EVENT_MPAUSE)| (1<<SNDRV_TIMER_EVENT_MSUSPEND)| (1<<SNDRV_TIMER_EVENT_MRESUME))) { err = -EINVAL; goto _end; } snd_timer_stop(tu->timeri); spin_lock_irq(&t->lock); tu->timeri->flags &= ~(SNDRV_TIMER_IFLG_AUTO| SNDRV_TIMER_IFLG_EXCLUSIVE| SNDRV_TIMER_IFLG_EARLY_EVENT); if (params.flags & SNDRV_TIMER_PSFLG_AUTO) tu->timeri->flags |= SNDRV_TIMER_IFLG_AUTO; if (params.flags & SNDRV_TIMER_PSFLG_EXCLUSIVE) tu->timeri->flags |= SNDRV_TIMER_IFLG_EXCLUSIVE; if (params.flags & SNDRV_TIMER_PSFLG_EARLY_EVENT) tu->timeri->flags |= SNDRV_TIMER_IFLG_EARLY_EVENT; spin_unlock_irq(&t->lock); if (params.queue_size > 0 && (unsigned int)tu->queue_size != params.queue_size) { if (tu->tread) { ttr = kmalloc(params.queue_size * sizeof(*ttr), GFP_KERNEL); if (ttr) { kfree(tu->tqueue); tu->queue_size = params.queue_size; tu->tqueue = ttr; } } else { tr = kmalloc(params.queue_size * sizeof(*tr), GFP_KERNEL); if (tr) { kfree(tu->queue); tu->queue_size = params.queue_size; tu->queue = tr; } } } tu->qhead = tu->qtail = tu->qused = 0; if (tu->timeri->flags & SNDRV_TIMER_IFLG_EARLY_EVENT) { if (tu->tread) { struct snd_timer_tread tread; tread.event = SNDRV_TIMER_EVENT_EARLY; tread.tstamp.tv_sec = 0; tread.tstamp.tv_nsec = 0; tread.val = 0; snd_timer_user_append_to_tqueue(tu, &tread); } else { struct snd_timer_read *r = &tu->queue[0]; r->resolution = 0; r->ticks = 0; tu->qused++; tu->qtail++; } } tu->filter = params.filter; tu->ticks = params.ticks; err = 0; _end: if (copy_to_user(_params, &params, sizeof(params))) return -EFAULT; return err; }"
"static const struct usb_cdc_union_desc * ims_pcu_get_cdc_union_desc(struct usb_interface *intf) { const void *buf = intf->altsetting->extra; size_t buflen = intf->altsetting->extralen; struct usb_cdc_union_desc *union_desc; if (!buf) { dev_err(&intf->dev, ""Missing descriptor data\n""); return NULL; } if (!buflen) { dev_err(&intf->dev, ""Zero length descriptor\n""); return NULL; } while (buflen > 0) { union_desc = (struct usb_cdc_union_desc *)buf; if (union_desc->bDescriptorType == USB_DT_CS_INTERFACE && union_desc->bDescriptorSubType == USB_CDC_UNION_TYPE) { dev_dbg(&intf->dev, ""Found union header\n""); return union_desc; } buflen -= union_desc->bLength; buf += union_desc->bLength; } dev_err(&intf->dev, ""Missing CDC union descriptor\n""); return NULL; }"
"int jlink_init(void) { void *so; unsigned int i; for (i = 0; i < NELEM(jlink_so_name); i++) { so = dlopen(jlink_so_name[i], RTLD_LAZY); if (so) break; } if (!so) return -EIO; jlink.emu_selectbyusbsn = dlsym(so, ""JLINK_EMU_SelectByUSBSN""); jlink.open = dlsym(so, ""JLINK_Open""); jlink.execcommand = dlsym(so, ""JLINK_ExecCommand""); jlink.tif_select = dlsym(so, ""JLINK_TIF_Select""); jlink.setspeed = dlsym(so, ""JLINK_SetSpeed""); jlink.connect = dlsym(so, ""JLINK_Connect""); jlink.getsn = dlsym(so, ""JLINK_GetSN""); jlink.emu_getproductname = dlsym(so, ""JLINK_EMU_GetProductName""); jlink.rtterminal_control = dlsym(so, ""JLINK_RTTERMINAL_Control""); jlink.rtterminal_read = dlsym(so, ""JLINK_RTTERMINAL_Read""); if (!jlink.emu_selectbyusbsn || !jlink.open || !jlink.execcommand || !jlink.tif_select || !jlink.setspeed || !jlink.connect || !jlink.getsn || !jlink.emu_getproductname || !jlink.rtterminal_control || !jlink.rtterminal_read) { dlclose(so); return -EIO; } dlclose(so); return 0; }"
"WebstoreInlineInstaller::WebstoreInlineInstaller( content::WebContents* web_contents, const std::string& webstore_item_id, const GURL& requestor_url, const Callback& callback) : WebstoreStandaloneInstaller( webstore_item_id, Profile::FromBrowserContext(web_contents->GetBrowserContext()), callback), content::WebContentsObserver(web_contents), requestor_url_(requestor_url) { }"
"tBTA_AV_EVT bta_av_proc_meta_cmd(tAVRC_RESPONSE* p_rc_rsp, tBTA_AV_RC_MSG* p_msg, uint8_t* p_ctype) { tBTA_AV_EVT evt = BTA_AV_META_MSG_EVT; uint8_t u8, pdu, *p; uint16_t u16; tAVRC_MSG_VENDOR* p_vendor = &p_msg->msg.vendor; pdu = *(p_vendor->p_vendor_data); p_rc_rsp->pdu = pdu; *p_ctype = AVRC_RSP_REJ; if ((AVRC_MIN_META_CMD_LEN + p_vendor->vendor_len) > AVRC_META_CMD_BUF_SIZE) { p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM; APPL_TRACE_ERROR(""%s: Invalid meta-command length: %d"", __func__, p_vendor->vendor_len); return 0; } if (p_vendor->hdr.subunit_type != AVRC_SUB_PANEL) { APPL_TRACE_DEBUG(""%s: SUBUNIT must be PANEL"", __func__); evt = 0; p_vendor->hdr.ctype = AVRC_RSP_NOT_IMPL; p_vendor->vendor_len = 0; p_rc_rsp->rsp.status = AVRC_STS_BAD_PARAM; } else if (!AVRC_IsValidAvcType(pdu, p_vendor->hdr.ctype)) { APPL_TRACE_DEBUG(""%s: Invalid pdu/ctype: 0x%x, %d"", __func__, pdu, p_vendor->hdr.ctype); evt = 0; p_rc_rsp->rsp.status = AVRC_STS_BAD_CMD; } else { switch (pdu) { case AVRC_PDU_GET_CAPABILITIES: evt = 0; u8 = *(p_vendor->p_vendor_data + 4); p = p_vendor->p_vendor_data + 2; p_rc_rsp->get_caps.capability_id = u8; BE_STREAM_TO_UINT16(u16, p); if ((u16 != 1) || (p_vendor->vendor_len != 5)) { p_rc_rsp->get_caps.status = AVRC_STS_INTERNAL_ERR; } else { p_rc_rsp->get_caps.status = AVRC_STS_NO_ERROR; if (u8 == AVRC_CAP_COMPANY_ID) { *p_ctype = AVRC_RSP_IMPL_STBL; p_rc_rsp->get_caps.count = p_bta_av_cfg->num_co_ids; memcpy(p_rc_rsp->get_caps.param.company_id, p_bta_av_cfg->p_meta_co_ids, (p_bta_av_cfg->num_co_ids << 2)); } else if (u8 == AVRC_CAP_EVENTS_SUPPORTED) { *p_ctype = AVRC_RSP_IMPL_STBL; p_rc_rsp->get_caps.count = p_bta_av_cfg->num_evt_ids; memcpy(p_rc_rsp->get_caps.param.event_id, p_bta_av_cfg->p_meta_evt_ids, p_bta_av_cfg->num_evt_ids); } else { APPL_TRACE_DEBUG(""%s: Invalid capability ID: 0x%x"", __func__, u8); p_rc_rsp->get_caps.status = AVRC_STS_BAD_PARAM; } } break; case AVRC_PDU_REGISTER_NOTIFICATION: p_rc_rsp->rsp.status = bta_av_chk_notif_evt_id(p_vendor); if (p_rc_rsp->rsp.status != BTA_AV_STS_NO_RSP) evt = 0; break; } } return evt; }"
"int PackLinuxElf64::adjABS(Elf64_Sym *sym, unsigned delta) { for (int j = 0; abs_symbol_names[j][0]; ++j) { unsigned st_name = get_te32(&sym->st_name); if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) { sym->st_value += delta; return 1; } } return 0; }"
"static int setupStream(PRTSP_MESSAGE response, char* target, int* error) { RTSP_MESSAGE request; int ret; char* transportValue; *error = -1; ret = initializeRtspRequest(&request, ""SETUP"", target); if (ret != 0) { if (hasSessionId) { if (!addOption(&request, ""Session"", sessionIdString)) { ret = 0; goto FreeMessage; } } if (ServerMajorVersion >= 6) { transportValue = ""unicast;X-GS-ClientPort=50000-50001""; } else { transportValue = "" ""; } if (addOption(&request, ""Transport"", transportValue) && addOption(&request, ""If-Modified-Since"", ""Thu, 01 Jan 1970 00:00:00 GMT"")) { ret = transactRtspMessage(&request, response, 0, error); } else { ret = 0; } FreeMessage: freeMessage(&request); } return ret; }"
"static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value) { const xmlChar * numstr; if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) { numstr = xmlTextReaderConstValue(reader); if (numstr) { *value = atol((const char *)numstr); if (*value < 0) { cli_dbgmsg(""cli_scanxar: XML element value %li\n"", *value); return CL_EFORMAT; } return CL_SUCCESS; } } cli_dbgmsg(""cli_scanxar: No text for XML element\n""); return CL_EFORMAT; }"
"SilenceMessage(const std::string& mask, const std::string& flags) : ClientProtocol::Message(""SILENCE"") { PushParam(mask); PushParamRef(flags); }"
"static int bprm_execve(struct linux_binprm *bprm, int fd, struct filename *filename, int flags) { struct file *file; struct files_struct *displaced; int retval; retval = unshare_files(&displaced); if (retval) return retval; retval = prepare_bprm_creds(bprm); if (retval) goto out_files; check_unsafe_exec(bprm); current->in_execve = 1; file = do_open_execat(fd, filename, flags); retval = PTR_ERR(file); if (IS_ERR(file)) goto out_unmark; sched_exec(); bprm->file = file; if (bprm->fdpath && close_on_exec(fd, rcu_dereference_raw(current->files->fdt))) bprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE; retval = security_bprm_creds_for_exec(bprm); if (retval) goto out; retval = exec_binprm(bprm); if (retval < 0) goto out; current->fs->in_exec = 0; current->in_execve = 0; rseq_execve(current); acct_update_integrals(current); task_numa_free(current, false); if (displaced) put_files_struct(displaced); return retval; out: if (bprm->point_of_no_return && !fatal_signal_pending(current)) force_sigsegv(SIGSEGV); out_unmark: current->fs->in_exec = 0; current->in_execve = 0; out_files: if (displaced) reset_files_struct(displaced); return retval; }"
"NAN_METHOD(TxnWrap::putString) { return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void { CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data); }, [](MDB_val &data) -> void { delete[] (uint16_t*)data.mv_data; }); }"
"static void do_pdf_save_document(fz_context *ctx, pdf_document *doc, pdf_write_state *opts, pdf_write_options *in_opts) { int lastfree; int num; int xref_len; if (in_opts->do_incremental) { if (doc->num_incremental_sections == 0) return; if (opts->out) { fz_seek_output(ctx, opts->out, 0, SEEK_END); fz_write_string(ctx, opts->out, ""\n""); } } xref_len = pdf_xref_len(ctx, doc); fz_try(ctx) { initialise_write_state(ctx, doc, in_opts, opts); if (!opts->do_incremental) { pdf_ensure_solid_xref(ctx, doc, xref_len); preloadobjstms(ctx, doc); } if (opts->do_garbage >= 1 || opts->do_linear) (void)markobj(ctx, doc, opts, pdf_trailer(ctx, doc)); else for (num = 0; num < xref_len; num++) opts->use_list[num] = 1; if (opts->do_garbage >= 3) removeduplicateobjs(ctx, doc, opts); if (opts->do_garbage >= 2 || opts->do_linear) compactxref(ctx, doc, opts); if (opts->do_garbage >= 2 || opts->do_linear) renumberobjs(ctx, doc, opts); if ((opts->do_garbage >= 2 || opts->do_linear) && !opts->do_incremental) while (xref_len > 0 && !opts->use_list[xref_len-1]) xref_len--; if (opts->do_linear) linearize(ctx, doc, opts); if (opts->do_incremental) { int i; doc->disallow_new_increments = 1; for (i = 0; i < doc->num_incremental_sections; i++) { doc->xref_base = doc->num_incremental_sections - i - 1; writeobjects(ctx, doc, opts, 0); #ifdef DEBUG_WRITING dump_object_details(ctx, doc, opts); #endif for (num = 0; num < xref_len; num++) { if (!opts->use_list[num] && pdf_xref_is_incremental(ctx, doc, num)) { opts->gen_list[num] = 65535; opts->ofs_list[num] = 0; } } opts->first_xref_offset = fz_tell_output(ctx, opts->out); if (doc->has_xref_streams) writexrefstream(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset); else writexref(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset); doc->xref_sections[doc->xref_base].end_ofs = fz_tell_output(ctx, opts->out); } doc->xref_base = 0; doc->disallow_new_increments = 0; } else { writeobjects(ctx, doc, opts, 0); #ifdef DEBUG_WRITING dump_object_details(ctx, doc, opts); #endif lastfree = 0; for (num = 0; num < xref_len; num++) { if (!opts->use_list[num]) { opts->gen_list[num]++; opts->ofs_list[lastfree] = num; lastfree = num; } } if (opts->do_linear && opts->page_count > 0) { opts->main_xref_offset = fz_tell_output(ctx, opts->out); writexref(ctx, doc, opts, 0, opts->start, 0, 0, opts->first_xref_offset); opts->file_len = fz_tell_output(ctx, opts->out); make_hint_stream(ctx, doc, opts); if (opts->do_ascii) { opts->hintstream_len *= 2; opts->hintstream_len += 1 + ((opts->hintstream_len+63)>>6); } opts->file_len += opts->hintstream_len; opts->main_xref_offset += opts->hintstream_len; update_linearization_params(ctx, doc, opts); fz_seek_output(ctx, opts->out, 0, 0); writeobjects(ctx, doc, opts, 1); padto(ctx, opts->out, opts->main_xref_offset); writexref(ctx, doc, opts, 0, opts->start, 0, 0, opts->first_xref_offset); } else { opts->first_xref_offset = fz_tell_output(ctx, opts->out); writexref(ctx, doc, opts, 0, xref_len, 1, 0, opts->first_xref_offset); } doc->xref_sections[0].end_ofs = fz_tell_output(ctx, opts->out); } doc->dirty = 0; } fz_always(ctx) { #ifdef DEBUG_LINEARIZATION page_objects_dump(opts); objects_dump(ctx, doc, opts); #endif finalise_write_state(ctx, opts); doc->freeze_updates = 0; } fz_catch(ctx) { fz_rethrow(ctx); } }"
"explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""signed_input"", &signed_input_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_bits"", &num_bits_)); OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63), errors::InvalidArgument(""num_bits is out of range: "", num_bits_, "" with signed_input_ "", signed_input_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""range_given"", &range_given_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_min"", &input_min_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""input_max"", &input_max_)); if (range_given_) { OP_REQUIRES( ctx, input_min_ <= input_max_, errors::InvalidArgument(""Invalid range: input_min "", input_min_, "" > input_max "", input_max_)); } }"
"int resolve_superior_type(const char *name, const char *mod_name, const struct lys_module *module, const struct lys_node *parent, struct lys_tpdf **ret) { int i, j; struct lys_tpdf *tpdf, *match; int tpdf_size; if (!mod_name) { for (i = 1; i < LY_DATA_TYPE_COUNT; i++) { if (!strcmp(ly_types[i]->name, name)) { if (ret) { *ret = ly_types[i]; } return EXIT_SUCCESS; } } } else { if (!strcmp(mod_name, module->name)) { mod_name = NULL; } } if (!mod_name && parent) { while (parent) { switch (parent->nodetype) { case LYS_CONTAINER: tpdf_size = ((struct lys_node_container *)parent)->tpdf_size; tpdf = ((struct lys_node_container *)parent)->tpdf; break; case LYS_LIST: tpdf_size = ((struct lys_node_list *)parent)->tpdf_size; tpdf = ((struct lys_node_list *)parent)->tpdf; break; case LYS_GROUPING: tpdf_size = ((struct lys_node_grp *)parent)->tpdf_size; tpdf = ((struct lys_node_grp *)parent)->tpdf; break; case LYS_RPC: case LYS_ACTION: tpdf_size = ((struct lys_node_rpc_action *)parent)->tpdf_size; tpdf = ((struct lys_node_rpc_action *)parent)->tpdf; break; case LYS_NOTIF: tpdf_size = ((struct lys_node_notif *)parent)->tpdf_size; tpdf = ((struct lys_node_notif *)parent)->tpdf; break; case LYS_INPUT: case LYS_OUTPUT: tpdf_size = ((struct lys_node_inout *)parent)->tpdf_size; tpdf = ((struct lys_node_inout *)parent)->tpdf; break; default: parent = lys_parent(parent); continue; } for (i = 0; i < tpdf_size; i++) { if (!strcmp(tpdf[i].name, name) && tpdf[i].type.base > 0) { match = &tpdf[i]; goto check_leafref; } } parent = lys_parent(parent); } } else { module = lyp_get_module(module, NULL, 0, mod_name, 0, 0); if (!module) { return -1; } } for (i = 0; i < module->tpdf_size; i++) { if (!strcmp(module->tpdf[i].name, name) && module->tpdf[i].type.base > 0) { match = &module->tpdf[i]; goto check_leafref; } } for (i = 0; i < module->inc_size && module->inc[i].submodule; i++) { for (j = 0; j < module->inc[i].submodule->tpdf_size; j++) { if (!strcmp(module->inc[i].submodule->tpdf[j].name, name) && module->inc[i].submodule->tpdf[j].type.base > 0) { match = &module->inc[i].submodule->tpdf[j]; goto check_leafref; } } } return EXIT_FAILURE; check_leafref: if (ret) { *ret = match; } if (match->type.base == LY_TYPE_LEAFREF) { while (!match->type.info.lref.path) { match = match->type.der; assert(match); } } return EXIT_SUCCESS; }"
"static int fsl_lpspi_probe(struct platform_device *pdev) { struct device_node *np = pdev->dev.of_node; struct fsl_lpspi_data *fsl_lpspi; struct spi_controller *controller; struct spi_imx_master *lpspi_platform_info = dev_get_platdata(&pdev->dev); struct resource *res; int i, ret, irq; u32 temp; bool is_slave; is_slave = of_property_read_bool((&pdev->dev)->of_node, ""spi-slave""); if (is_slave) controller = spi_alloc_slave(&pdev->dev, sizeof(struct fsl_lpspi_data)); else controller = spi_alloc_master(&pdev->dev, sizeof(struct fsl_lpspi_data)); if (!controller) return -ENOMEM; platform_set_drvdata(pdev, controller); fsl_lpspi = spi_controller_get_devdata(controller); fsl_lpspi->dev = &pdev->dev; fsl_lpspi->is_slave = is_slave; if (!fsl_lpspi->is_slave) { for (i = 0; i < controller->num_chipselect; i++) { int cs_gpio = of_get_named_gpio(np, ""cs-gpios"", i); if (!gpio_is_valid(cs_gpio) && lpspi_platform_info) cs_gpio = lpspi_platform_info->chipselect[i]; fsl_lpspi->chipselect[i] = cs_gpio; if (!gpio_is_valid(cs_gpio)) continue; ret = devm_gpio_request(&pdev->dev, fsl_lpspi->chipselect[i], DRIVER_NAME); if (ret) { dev_err(&pdev->dev, ""can't get cs gpios\n""); goto out_controller_put; } } controller->cs_gpios = fsl_lpspi->chipselect; controller->prepare_message = fsl_lpspi_prepare_message; } controller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32); controller->transfer_one = fsl_lpspi_transfer_one; controller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware; controller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware; controller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH; controller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX; controller->dev.of_node = pdev->dev.of_node; controller->bus_num = pdev->id; controller->slave_abort = fsl_lpspi_slave_abort; init_completion(&fsl_lpspi->xfer_done); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); fsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res); if (IS_ERR(fsl_lpspi->base)) { ret = PTR_ERR(fsl_lpspi->base); goto out_controller_put; } fsl_lpspi->base_phys = res->start; irq = platform_get_irq(pdev, 0); if (irq < 0) { ret = irq; goto out_controller_put; } ret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0, dev_name(&pdev->dev), fsl_lpspi); if (ret) { dev_err(&pdev->dev, ""can't get irq%d: %d\n"", irq, ret); goto out_controller_put; } fsl_lpspi->clk_per = devm_clk_get(&pdev->dev, ""per""); if (IS_ERR(fsl_lpspi->clk_per)) { ret = PTR_ERR(fsl_lpspi->clk_per); goto out_controller_put; } fsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, ""ipg""); if (IS_ERR(fsl_lpspi->clk_ipg)) { ret = PTR_ERR(fsl_lpspi->clk_ipg); goto out_controller_put; } ret = fsl_lpspi_init_rpm(fsl_lpspi); if (ret) goto out_controller_put; ret = pm_runtime_get_sync(fsl_lpspi->dev); if (ret < 0) { dev_err(fsl_lpspi->dev, ""failed to enable clock\n""); return ret; } temp = readl(fsl_lpspi->base + IMX7ULP_PARAM); fsl_lpspi->txfifosize = 1 << (temp & 0x0f); fsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f); ret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller); if (ret == -EPROBE_DEFER) goto out_controller_put; if (ret < 0) dev_err(&pdev->dev, ""dma setup error %d, use pio\n"", ret); ret = devm_spi_register_controller(&pdev->dev, controller); if (ret < 0) { dev_err(&pdev->dev, ""spi_register_controller error.\n""); goto out_controller_put; } return 0; out_controller_put: spi_controller_put(controller); return ret; }"
bool ksmbd_smb_request(struct ksmbd_conn *conn) { return conn->request_buf[0] == 0; }
"void __split_huge_pmd(struct vm_area_struct *vma, pmd_t *pmd, unsigned long address, bool freeze, struct page *page) { spinlock_t *ptl; struct mmu_notifier_range range; mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, vma->vm_mm, address & HPAGE_PMD_MASK, (address & HPAGE_PMD_MASK) + HPAGE_PMD_SIZE); mmu_notifier_invalidate_range_start(&range); ptl = pmd_lock(vma->vm_mm, pmd); VM_BUG_ON(freeze && !page); if (page && page != pmd_page(*pmd)) goto out; if (pmd_trans_huge(*pmd)) { page = pmd_page(*pmd); if (PageMlocked(page)) clear_page_mlock(page); } else if (!(pmd_devmap(*pmd) || is_pmd_migration_entry(*pmd))) goto out; __split_huge_pmd_locked(vma, pmd, range.start, freeze); out: spin_unlock(ptl); mmu_notifier_invalidate_range_only_end(&range); }"
"void ddl_add_col (query_instance_t * qi, const char *table, caddr_t * col, int if_not_exists) { caddr_t err; static query_t *add_col_proc; client_connection_t *cli = qi->qi_client; dbe_column_t *col_ref; dbe_table_t *tb = qi_name_to_table (qi, table); if (!add_col_proc) add_col_proc = sql_compile_static (""DB.DBA.add_col (?, ?,?)"", bootstrap_cli, &err, SQLC_DEFAULT); if (!tb) sqlr_new_error (""42S02"", ""SQ018"", ""No table %s."", table); sql_error_if_remote_table (tb); col_ref = tb_name_to_column (tb, col[0]); if (col_ref && if_not_exists) return; AS_DBA (qi, err = qr_rec_exec (add_col_proc, cli, NULL, qi, NULL, 3, "":0"", (0 == strcmp (tb->tb_name, ""DB.DBA.SYS_TRIGGERS"")) ? ""SYS_TRIGGERS"" : tb->tb_name, QRP_STR, "":1"", col[0], QRP_STR, "":2"", box_copy_tree ((caddr_t) col), QRP_RAW)); if (err != SQL_SUCCESS) { QI_POISON_TRX (qi); sqlr_resignal (err); } }"
"static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd, struct xcopy_op *xop, unsigned char *p, unsigned short tdll, sense_reason_t *sense_ret) { struct se_device *local_dev = se_cmd->se_dev; unsigned char *desc = p; int offset = tdll % XCOPY_TARGET_DESC_LEN, rc; unsigned short cscd_index = 0; unsigned short start = 0; *sense_ret = TCM_INVALID_PARAMETER_LIST; if (offset != 0) { pr_err(""XCOPY target descriptor list length is not"" "" multiple of %d\n"", XCOPY_TARGET_DESC_LEN); *sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE; return -EINVAL; } if (tdll > RCR_OP_MAX_TARGET_DESC_COUNT * XCOPY_TARGET_DESC_LEN) { pr_err(""XCOPY target descriptor supports a maximum"" "" two src/dest descriptors, tdll: %hu too large..\n"", tdll); *sense_ret = TCM_TOO_MANY_TARGET_DESCS; return -EINVAL; } memset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN); target_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]); while (start < tdll) { switch (desc[0]) { case 0xe4: rc = target_xcopy_parse_tiddesc_e4(se_cmd, xop, &desc[0], cscd_index); if (rc != 0) goto out; start += XCOPY_TARGET_DESC_LEN; desc += XCOPY_TARGET_DESC_LEN; cscd_index++; break; default: pr_err(""XCOPY unsupported descriptor type code:"" "" 0x%02x\n"", desc[0]); *sense_ret = TCM_UNSUPPORTED_TARGET_DESC_TYPE_CODE; goto out; } } switch (xop->op_origin) { case XCOL_SOURCE_RECV_OP: rc = target_xcopy_locate_se_dev_e4(xop->dst_tid_wwn, &xop->dst_dev); break; case XCOL_DEST_RECV_OP: rc = target_xcopy_locate_se_dev_e4(xop->src_tid_wwn, &xop->src_dev); break; default: pr_err(""XCOPY CSCD descriptor IDs not found in CSCD list - "" ""stdi: %hu dtdi: %hu\n"", xop->stdi, xop->dtdi); rc = -EINVAL; break; } if (rc < 0) { *sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE; goto out; } pr_debug(""XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n"", xop->src_dev, &xop->src_tid_wwn[0]); pr_debug(""XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\n"", xop->dst_dev, &xop->dst_tid_wwn[0]); return cscd_index; out: return -EINVAL; }"
"static void copyMono8( short *dst, const int *const *src, unsigned nSamples, unsigned ) { for (unsigned i = 0; i < nSamples; ++i) { *dst++ = src[0][i] << 8; } }"
"static void port_show_vhci(char **out, int hub, int port, struct vhci_device *vdev) { if (hub == HUB_SPEED_HIGH) *out += sprintf(*out, ""hs  %04u %03u "", port, vdev->ud.status); else  *out += sprintf(*out, ""ss  %04u %03u "", port, vdev->ud.status); if (vdev->ud.status == VDEV_ST_USED) { *out += sprintf(*out, ""%03u %08x "", vdev->speed, vdev->devid); *out += sprintf(*out, ""%16p %s"", vdev->ud.tcp_socket, dev_name(&vdev->udev->dev)); } else { *out += sprintf(*out, ""000 00000000 ""); *out += sprintf(*out, ""0000000000000000 0-0""); } *out += sprintf(*out, ""\n""); }"
"static void ahci_start_transfer(IDEDMA *dma) { AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma); IDEState *s = &ad->port.ifs[0]; uint32_t size = (uint32_t)(s->data_end - s->data_ptr); uint32_t opts = le32_to_cpu(ad->cur_cmd->opts); int is_write = opts & AHCI_CMD_WRITE; int is_atapi = opts & AHCI_CMD_ATAPI; int has_sglist = 0; if (is_atapi && !ad->done_atapi_packet) { ad->done_atapi_packet = true; goto out; } if (!ahci_populate_sglist(ad, &s->sg, 0)) { has_sglist = 1; } DPRINTF(ad->port_no, ""%sing %d bytes on %s w/%s sglist\n"", is_write ? ""writ"" : ""read"", size, is_atapi ? ""atapi"" : ""ata"", has_sglist ? """" : ""o""); if (has_sglist && size) { if (is_write) { dma_buf_write(s->data_ptr, size, &s->sg); } else { dma_buf_read(s->data_ptr, size, &s->sg); } } ad->cur_cmd->status = cpu_to_le32(le32_to_cpu(ad->cur_cmd->status) + size); out: s->data_ptr = s->data_end; if (has_sglist) { qemu_sglist_destroy(&s->sg); } s->end_transfer_func(s); if (!(s->status & DRQ_STAT)) { ahci_write_fis_pio(ad, le32_to_cpu(ad->cur_cmd->status)); } }"
"static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs) { struct pfkey_sock *pfk = pfkey_sk(sk); struct sk_buff *supp_skb; if (hdr->sadb_msg_satype > SADB_SATYPE_MAX) return -EINVAL; if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) { if (pfk->registered&(1<<hdr->sadb_msg_satype)) return -EEXIST; pfk->registered |= (1<<hdr->sadb_msg_satype); } xfrm_probe_algs(); supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO); if (!supp_skb) { if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) pfk->registered &= ~(1<<hdr->sadb_msg_satype); return -ENOBUFS; } pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)); return 0; }"
"TEE_Result utee_cryp_state_alloc(unsigned long algo, unsigned long mode, unsigned long key1, unsigned long key2, uint32_t *state) { TEE_Result res; struct tee_cryp_state *cs; struct tee_ta_session *sess; struct tee_obj *o1 = NULL; struct tee_obj *o2 = NULL; struct user_ta_ctx *utc; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; utc = to_user_ta_ctx(sess->ctx); if (key1 != 0) { res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key1), &o1); if (res != TEE_SUCCESS) return res; if (o1->busy) return TEE_ERROR_BAD_PARAMETERS; res = tee_svc_cryp_check_key_type(o1, algo, mode); if (res != TEE_SUCCESS) return res; } if (key2 != 0) { res = tee_obj_get(utc, tee_svc_uref_to_vaddr(key2), &o2); if (res != TEE_SUCCESS) return res; if (o2->busy) return TEE_ERROR_BAD_PARAMETERS; res = tee_svc_cryp_check_key_type(o2, algo, mode); if (res != TEE_SUCCESS) return res; } cs = calloc(1, sizeof(struct tee_cryp_state)); if (!cs) return TEE_ERROR_OUT_OF_MEMORY; TAILQ_INSERT_TAIL(&utc->cryp_states, cs, link); cs->algo = algo; cs->mode = mode; switch (TEE_ALG_GET_CLASS(algo)) { case TEE_OPERATION_CIPHER: if ((algo == TEE_ALG_AES_XTS && (key1 == 0 || key2 == 0)) || (algo != TEE_ALG_AES_XTS && (key1 == 0 || key2 != 0))) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_cipher_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_AE: if (key1 == 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { } break; case TEE_OPERATION_MAC: if (key1 == 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_mac_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_DIGEST: if (key1 != 0 || key2 != 0) { res = TEE_ERROR_BAD_PARAMETERS; } else { res = crypto_hash_alloc_ctx(&cs->ctx, algo); if (res != TEE_SUCCESS) break; } break; case TEE_OPERATION_ASYMMETRIC_CIPHER: case TEE_OPERATION_ASYMMETRIC_SIGNATURE: if (key1 == 0 || key2 != 0) res = TEE_ERROR_BAD_PARAMETERS; break; case TEE_OPERATION_KEY_DERIVATION: if (key1 == 0 || key2 != 0) res = TEE_ERROR_BAD_PARAMETERS; break; default: res = TEE_ERROR_NOT_SUPPORTED; break; } if (res != TEE_SUCCESS) goto out; res = tee_svc_copy_kaddr_to_uref(state, cs); if (res != TEE_SUCCESS) goto out; if (o1 != NULL) { o1->busy = true; cs->key1 = (vaddr_t)o1; } if (o2 != NULL) { o2->busy = true; cs->key2 = (vaddr_t)o2; } out: if (res != TEE_SUCCESS) cryp_state_free(utc, cs); return res; }"
"int cmnd_matches(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info) { struct alias *a; struct sudo_command *c; int rc, matched = UNSPEC; debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH); switch (m->type) { case ALL: case COMMAND: c = (struct sudo_command *)m->name; if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests)) matched = m->negated ? DENY : ALLOW; break; case ALIAS: a = alias_get(parse_tree, m->name, CMNDALIAS); if (a != NULL) { rc = cmndlist_matches(parse_tree, &a->members, runchroot, info); if (rc != UNSPEC) { if (m->negated) { matched = rc == ALLOW ? DENY : ALLOW; } else { matched = rc; } } alias_put(a); } break; } debug_return_int(matched); }"
"static int nntp_fetch_headers(struct Context *ctx, void *hc, anum_t first, anum_t last, int restore) { struct NntpData *nntp_data = ctx->data; struct FetchCtx fc; struct Header *hdr = NULL; char buf[HUGE_STRING]; int rc = 0; int oldmsgcount = ctx->msgcount; anum_t current; anum_t first_over = first; #ifdef USE_HCACHE void *hdata = NULL; #endif if (!last || first > last) return 0; fc.ctx = ctx; fc.first = first; fc.last = last; fc.restore = restore; fc.messages = mutt_mem_calloc(last - first + 1, sizeof(unsigned char)); #ifdef USE_HCACHE fc.hc = hc; #endif if (NntpListgroup && nntp_data->nserv->hasLISTGROUP && !nntp_data->deleted) { if (!ctx->quiet) mutt_message(_(""Fetching list of articles..."")); if (nntp_data->nserv->hasLISTGROUPrange) snprintf(buf, sizeof(buf), ""LISTGROUP %s %u-%u\r\n"", nntp_data->group, first, last); else snprintf(buf, sizeof(buf), ""LISTGROUP %s\r\n"", nntp_data->group); rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_numbers, &fc); if (rc > 0) { mutt_error(""LISTGROUP: %s"", buf); } if (rc == 0) { for (current = first; current <= last && rc == 0; current++) { if (fc.messages[current - first]) continue; snprintf(buf, sizeof(buf), ""%u"", current); if (nntp_data->bcache) { mutt_debug(2, ""#1 mutt_bcache_del %s\n"", buf); mutt_bcache_del(nntp_data->bcache, buf); } #ifdef USE_HCACHE if (fc.hc) { mutt_debug(2, ""mutt_hcache_delete %s\n"", buf); mutt_hcache_delete(fc.hc, buf, strlen(buf)); } #endif } } } else { for (current = first; current <= last; current++) fc.messages[current - first] = 1; } if (!ctx->quiet) { mutt_progress_init(&fc.progress, _(""Fetching message headers...""), MUTT_PROGRESS_MSG, ReadInc, last - first + 1); } for (current = first; current <= last && rc == 0; current++) { if (!ctx->quiet) mutt_progress_update(&fc.progress, current - first + 1, -1); #ifdef USE_HCACHE snprintf(buf, sizeof(buf), ""%u"", current); #endif if (!fc.messages[current - first]) continue; if (ctx->msgcount >= ctx->hdrmax) mx_alloc_memory(ctx); #ifdef USE_HCACHE hdata = mutt_hcache_fetch(fc.hc, buf, strlen(buf)); if (hdata) { mutt_debug(2, ""mutt_hcache_fetch %s\n"", buf); ctx->hdrs[ctx->msgcount] = hdr = mutt_hcache_restore(hdata); mutt_hcache_free(fc.hc, &hdata); hdr->data = 0; if (hdr->deleted && !restore) { mutt_header_free(&hdr); if (nntp_data->bcache) { mutt_debug(2, ""#2 mutt_bcache_del %s\n"", buf); mutt_bcache_del(nntp_data->bcache, buf); } continue; } hdr->read = false; hdr->old = false; } else #endif if (nntp_data->deleted) continue; else if (nntp_data->nserv->hasOVER || nntp_data->nserv->hasXOVER) { if (NntpListgroup && nntp_data->nserv->hasLISTGROUP) break; else continue; } else { FILE *fp = mutt_file_mkstemp(); if (!fp) { mutt_perror(""mutt_file_mkstemp() failed!""); rc = -1; break; } snprintf(buf, sizeof(buf), ""HEAD %u\r\n"", current); rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, fetch_tempfile, fp); if (rc) { mutt_file_fclose(&fp); if (rc < 0) break; if (mutt_str_strncmp(""423"", buf, 3) != 0) { mutt_error(""HEAD: %s"", buf); break; } if (nntp_data->bcache) { snprintf(buf, sizeof(buf), ""%u"", current); mutt_debug(2, ""#3 mutt_bcache_del %s\n"", buf); mutt_bcache_del(nntp_data->bcache, buf); } rc = 0; continue; } hdr = ctx->hdrs[ctx->msgcount] = mutt_header_new(); hdr->env = mutt_rfc822_read_header(fp, hdr, 0, 0); hdr->received = hdr->date_sent; mutt_file_fclose(&fp); } hdr->index = ctx->msgcount++; hdr->read = false; hdr->old = false; hdr->deleted = false; hdr->data = mutt_mem_calloc(1, sizeof(struct NntpHeaderData)); NHDR(hdr)->article_num = current; if (restore) hdr->changed = true; else { nntp_article_status(ctx, hdr, NULL, NHDR(hdr)->article_num); if (!hdr->read) nntp_parse_xref(ctx, hdr); } if (current > nntp_data->last_loaded) nntp_data->last_loaded = current; first_over = current + 1; } if (!NntpListgroup || !nntp_data->nserv->hasLISTGROUP) current = first_over; if (current <= last && rc == 0 && !nntp_data->deleted) { char *cmd = nntp_data->nserv->hasOVER ? ""OVER"" : ""XOVER""; snprintf(buf, sizeof(buf), ""%s %u-%u\r\n"", cmd, current, last); rc = nntp_fetch_lines(nntp_data, buf, sizeof(buf), NULL, parse_overview_line, &fc); if (rc > 0) { mutt_error(""%s: %s"", cmd, buf); } } if (ctx->msgcount > oldmsgcount) mx_update_context(ctx, ctx->msgcount - oldmsgcount); FREE(&fc.messages); if (rc != 0) return -1; mutt_clear_error(); return 0; }"
static inline int z_vrfy_gpio_get_pending_int(struct device *dev) { return z_impl_gpio_get_pending_int((struct device *)dev); }
"bool ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr, const char **elem_rtrn, const char **field_rtrn, ExprDef **index_rtrn) { switch (expr->expr.op) { case EXPR_IDENT: *elem_rtrn = NULL; *field_rtrn = xkb_atom_text(ctx, expr->ident.ident); *index_rtrn = NULL; return true; case EXPR_FIELD_REF: *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element); *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field); *index_rtrn = NULL; return true; case EXPR_ARRAY_REF: *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element); *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field); *index_rtrn = expr->array_ref.entry; return true; default: break; } log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op); return false; }"
"static void downsample_row_box_filter ( int start, int width, uint32_t *src, uint32_t *dest, int coverage[], int pixel_coverage) { int x = 0; while (x < start) { int box = 1 << FIXED_SHIFT; int start_coverage = coverage[x]; box -= start_coverage; src++; while (box >= pixel_coverage) { src++; box -= pixel_coverage; } x++; } while (x < start + width) { uint32_t a = 0; uint32_t r = 0; uint32_t g = 0; uint32_t b = 0; int box = 1 << FIXED_SHIFT; int start_coverage = coverage[x]; a = ((*src >> 24) & 0xff) * start_coverage; r = ((*src >> 16) & 0xff) * start_coverage; g = ((*src >>  8) & 0xff) * start_coverage; b = ((*src >>  0) & 0xff) * start_coverage; src++; x++; box -= start_coverage; while (box >= pixel_coverage) { a += ((*src >> 24) & 0xff) * pixel_coverage; r += ((*src >> 16) & 0xff) * pixel_coverage; g += ((*src >>  8) & 0xff) * pixel_coverage; b += ((*src >>  0) & 0xff) * pixel_coverage; src++; box -= pixel_coverage; } if (box > 0) { a += ((*src >> 24) & 0xff) * box; r += ((*src >> 16) & 0xff) * box; g += ((*src >>  8) & 0xff) * box; b += ((*src >>  0) & 0xff) * box; } a >>= FIXED_SHIFT; r >>= FIXED_SHIFT; g >>= FIXED_SHIFT; b >>= FIXED_SHIFT; *dest = (a << 24) | (r << 16) | (g << 8) | b; dest++; } }"
"tcpr_dir_t macinstring(const char *macstring, const u_char *mac) { char *tok = NULL, *tempstr, *ourstring; u_char tempmac[6]; int len = 6, ret = TCPR_DIR_S2C; ourstring = safe_strdup(macstring); memset(&tempmac[0], 0, sizeof(tempmac)); tempstr = strtok_r(ourstring, "","", &tok); if (strlen(tempstr)) { mac2hex(tempstr, tempmac, len); if (memcmp(mac, tempmac, len) == 0) { dbgx(3, ""Packet matches: "" MAC_FORMAT "" sending out primary.\n"", MAC_STR(tempmac)); ret = TCPR_DIR_C2S; goto EXIT_MACINSTRING; } } else { goto EXIT_MACINSTRING; } while ((tempstr = strtok_r(NULL, "","", &tok)) != NULL) { mac2hex(tempstr, tempmac, len); if (memcmp(mac, tempmac, len) == 0) { ret = TCPR_DIR_C2S; dbgx(3, ""Packet matches: "" MAC_FORMAT "" sending out primary.\n"", MAC_STR(tempmac)); goto EXIT_MACINSTRING; } } EXIT_MACINSTRING: safe_free(ourstring); #ifdef DEBUG if (ret == TCPR_DIR_S2C) dbg(3, ""Packet doesn't match any MAC addresses sending out secondary.\n""); #endif return ret; }"
"void show_ip(struct pt_regs *regs, const char *loglvl) { #ifdef CONFIG_X86_32 printk(""%sEIP: %pS\n"", loglvl, (void *)regs->ip); #else printk(""%sRIP: %04x:%pS\n"", loglvl, (int)regs->cs, (void *)regs->ip); #endif show_opcodes((u8 *)regs->ip, loglvl); }"
"static void dissect_ismp_edp(tvbuff_t *tvb, packet_info *pinfo, int offset, proto_tree *ismp_tree) { int neighbors_count = 0; int tuples_count = 0; guint16 device_type = 0; guint16 num_neighbors = 0; guint16 num_tuples = 0; guint16 tuple_type = 0; guint16 tuple_length = 0; proto_item *edp_ti, *ti; proto_tree *edp_tree; proto_item *edp_neighbors_ti; proto_tree *edp_neighbors_tree; proto_tree *edp_neighbors_leaf_tree; proto_item *edp_tuples_ti; proto_tree *edp_tuples_tree; proto_tree *edp_tuples_leaf_tree; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""ISMP.EDP""); col_clear(pinfo->cinfo, COL_INFO); edp_ti  = proto_tree_add_item(ismp_tree, hf_ismp_edp, tvb, offset, -1, ENC_NA); edp_tree = proto_item_add_subtree(edp_ti, ett_ismp_edp); col_add_fstr(pinfo->cinfo, COL_INFO, ""MIP %s, MMAC %s, ifIdx %d"", tvb_ip_to_str(tvb, offset+2), tvb_ether_to_str(tvb, offset+6), tvb_get_ntohl(tvb, offset+12)); proto_tree_add_item(edp_tree, hf_ismp_edp_version, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(edp_tree, hf_ismp_edp_module_ip, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(edp_tree, hf_ismp_edp_module_mac, tvb, offset, 6, ENC_NA); offset += 6; proto_tree_add_item(edp_tree, hf_ismp_edp_module_port, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_mac, tvb, offset, 6, ENC_NA); offset += 6; proto_tree_add_item(edp_tree, hf_ismp_edp_chassis_ip, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; device_type = tvb_get_ntohs(tvb, offset); proto_tree_add_item(edp_tree, hf_ismp_edp_device_type, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_uint_format_value(edp_tree, hf_ismp_edp_module_rev, tvb, offset, 4, tvb_get_ntohl(tvb, offset), ""%02x.%02x.%02x.%02x"", tvb_get_guint8(tvb, offset), tvb_get_guint8(tvb, offset+1), tvb_get_guint8(tvb, offset+2), tvb_get_guint8(tvb, offset+3)); offset += 4; switch (device_type) { case EDP_DEVICE_TYPE_SFS17: case EDP_DEVICE_TYPE_SFS18: { static const gint *options[] = { &hf_ismp_edp_sfs_option_uplink_flood, &hf_ismp_edp_sfs_option_uplink_port, &hf_ismp_edp_sfs_option_uplink_core, &hf_ismp_edp_sfs_option_uplink_switch, &hf_ismp_edp_sfs_option_isolated, &hf_ismp_edp_sfs_option_redun, &hf_ismp_edp_sfs_option_conmsg, &hf_ismp_edp_sfs_option_calltap, &hf_ismp_edp_sfs_option_tagflood, &hf_ismp_edp_sfs_option_unused2, &hf_ismp_edp_sfs_option_resolve, &hf_ismp_edp_sfs_option_flood, &hf_ismp_edp_sfs_option_lsp, &hf_ismp_edp_sfs_option_sfssup, &hf_ismp_edp_sfs_option_unused1, NULL }; proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN); } break; case EDP_DEVICE_TYPE_ROUTER: { static const gint *options[] = { &hf_ismp_edp_rtr_option_level1, &hf_ismp_edp_rtr_option_trans, &hf_ismp_edp_rtr_option_route, &hf_ismp_edp_rtr_option_igmp_snoop, &hf_ismp_edp_rtr_option_gmrp, &hf_ismp_edp_rtr_option_gvrp, &hf_ismp_edp_rtr_option_8021q, &hf_ismp_edp_rtr_option_dvmrp, &hf_ismp_edp_rtr_option_ospf, &hf_ismp_edp_rtr_option_bgp, &hf_ismp_edp_rtr_option_rip, &hf_ismp_edp_rtr_option_igmp, &hf_ismp_edp_rtr_option_ssr, NULL }; proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN); } break; case EDP_DEVICE_TYPE_BRIDGE: { static const gint *options[] = { &hf_ismp_edp_switch_option_level1, &hf_ismp_edp_switch_option_trans, &hf_ismp_edp_switch_option_route, &hf_ismp_edp_switch_option_igmp, &hf_ismp_edp_switch_option_gmrp, &hf_ismp_edp_switch_option_gvrp, &hf_ismp_edp_switch_option_8021q, NULL }; proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN); } break; case EDP_DEVICE_TYPE_NTSERVER: case EDP_DEVICE_TYPE_NTCLIENT: case EDP_DEVICE_TYPE_WIN95: case EDP_DEVICE_TYPE_WIN98: case EDP_DEVICE_TYPE_UNIXSERVER: case EDP_DEVICE_TYPE_UNIXCLIENT: { static const gint *options[] = { &hf_ismp_edp_end_station_option_ad, &hf_ismp_edp_end_station_option_dns, &hf_ismp_edp_end_station_option_dhcp, NULL }; proto_tree_add_bitmask(edp_tree, tvb, offset, hf_ismp_edp_options, ett_ismp_edp_options, options, ENC_BIG_ENDIAN); } break; case EDP_DEVICE_TYPE_VLANMAN: case EDP_DEVICE_TYPE_ACCESSPOINT: default: proto_tree_add_item(edp_tree, hf_ismp_edp_options, tvb, offset, 4, ENC_BIG_ENDIAN); break; } offset += 4; num_neighbors = tvb_get_ntohs(tvb, offset); proto_tree_add_item(edp_tree, hf_ismp_edp_num_neighbors, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; if (num_neighbors > 0) { edp_neighbors_ti = proto_tree_add_item(edp_tree, hf_ismp_edp_neighbors, tvb, offset, num_neighbors*10, ENC_NA); edp_neighbors_tree = proto_item_add_subtree(edp_neighbors_ti, ett_ismp_edp_neighbors); while ( neighbors_count < num_neighbors && tvb_reported_length_remaining(tvb, offset) >= 10) { edp_neighbors_leaf_tree = proto_tree_add_subtree_format(edp_neighbors_tree, tvb, offset, 10, ett_ismp_edp_neighbors_leaf, NULL, ""Neighbor%d"", (neighbors_count+1)); proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_neighborhood_mac_address, tvb, offset, 6, ENC_NA); proto_tree_add_item(edp_neighbors_leaf_tree, hf_ismp_assigned_neighbor_state, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 10; neighbors_count++; } if (neighbors_count != num_neighbors) { proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1); return; } } if (tvb_reported_length_remaining(tvb, offset) != 0 && tvb_reported_length_remaining(tvb, offset) >= 2) { num_tuples = tvb_get_ntohs(tvb, offset); proto_tree_add_item(edp_tree, hf_ismp_edp_num_tuples, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; } else if (tvb_reported_length_remaining(tvb, offset) > 0) { proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1); return; } else { return; } if (num_tuples && tvb_reported_length_remaining(tvb, offset) >= 4) { edp_tuples_ti = proto_tree_add_bytes_format(edp_tree, hf_ismp_edp_tuples, tvb, offset, -1, NULL, ""Tuples""); edp_tuples_tree = proto_item_add_subtree(edp_tuples_ti, ett_ismp_edp_tuples); while ( (tuples_count < num_tuples) && (tvb_reported_length_remaining(tvb, offset) >= 4) ) { tuple_length = tvb_get_ntohs(tvb, offset+2); edp_tuples_leaf_tree = proto_tree_add_subtree_format(edp_tuples_tree, tvb, offset, tuple_length, ett_ismp_edp_tuples_leaf, NULL, ""Tuple%d"", tuples_count+1); tuple_type = tvb_get_ntohs(tvb, offset); proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_type, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_tuple_length, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; if (tvb_reported_length_remaining(tvb, offset) >= tuple_length) { switch (tuple_type) { case EDP_TUPLE_HOLD: ti = proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_hold_time, tvb, offset, hf_ismp_hold_time, ENC_BIG_ENDIAN); proto_item_set_len(ti, tuple_length); break; case EDP_TUPLE_INT_NAME: proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_interface_name, tvb, offset, tuple_length, ENC_NA|ENC_ASCII); col_append_fstr(pinfo->cinfo, COL_INFO, "", ifName %s"", tvb_format_text(tvb, offset, tuple_length)); break; case EDP_TUPLE_SYS_DESCRIPT: proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_system_description, tvb, offset, tuple_length, ENC_NA|ENC_ASCII); break; case EDP_TUPLE_IPX_ADDR: proto_tree_add_string(edp_tuples_leaf_tree, hf_ismp_interface_ipx_address ,tvb, offset, tuple_length, ipx_addr_to_str(tvb_get_ntohl(tvb, offset), tvb_get_string_enc(wmem_packet_scope(), tvb, offset+4, tuple_length-4, ENC_ASCII))); break; case EDP_TUPLE_UNKNOWN: default: proto_tree_add_item(edp_tuples_leaf_tree, hf_ismp_unknown_tuple_data, tvb, offset, tuple_length, ENC_NA|ENC_ASCII); break; } } offset += tuple_length; tuples_count++; } if (tuples_count != num_tuples) proto_tree_add_expert(edp_tree, pinfo, &ei_ismp_malformed, tvb, offset, -1); return; } }"
"static st64 buf_format(RBuffer *dst, RBuffer *src, const char *fmt, int n) { st64 res = 0; int i; for (i = 0; i < n; i++) { int j; int m = 1; int tsize = 2; bool bigendian = true; for (j = 0; fmt[j]; j++) { switch (fmt[j]) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (m == 1) { m = r_num_get (NULL, &fmt[j]); } continue; case 's': tsize = 2; bigendian = false; break; case 'S': tsize = 2; bigendian = true; break; case 'i': tsize = 4; bigendian = false; break; case 'I': tsize = 4; bigendian = true; break; case 'l': tsize = 8; bigendian = false; break; case 'L': tsize = 8; bigendian = true; break; case 'c': tsize = 1; bigendian = false; break; default: return -1; } int k; for (k = 0; k < m; k++) { ut8 tmp[sizeof (ut64)]; ut8 d1; ut16 d2; ut32 d3; ut64 d4; st64 r = r_buf_read (src, tmp, tsize); if (r < tsize) { return -1; } switch (tsize) { case 1: d1 = r_read_ble8 (tmp); r = r_buf_write (dst, (ut8 *)&d1, 1); break; case 2: d2 = r_read_ble16 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d2, 2); break; case 4: d3 = r_read_ble32 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d3, 4); break; case 8: d4 = r_read_ble64 (tmp, bigendian); r = r_buf_write (dst, (ut8 *)&d4, 8); break; } if (r < 0) { return -1; } res += r; } m = 1; } } return res; }"
"void btif_config_flush(void) { assert(config != NULL); assert(alarm_timer != NULL); alarm_cancel(alarm_timer); pthread_mutex_lock(&lock); config_save(config, CONFIG_FILE_PATH); pthread_mutex_unlock(&lock); }"
unsigned int bm_get_color(Bitmap *bm) { return bm->color; }
"static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))  return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int istart = 0, iend, n, nsiz; Jsi_Number nstart = 0, nend = 0;     Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1), *end = Jsi_ValueArrayIndex(interp, args, 2); Jsi_Obj *obj = _this->d.obj; n = jsi_SizeOfArray(interp, obj); if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (n == 0) { goto bail; } iend = n-1; if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) { iend = (int) nend; if (iend >= n) iend = n-1; if (iend < 0) iend = (n+iend); if (iend<0) goto bail; } nsiz = iend-istart+1; if (nsiz<=0) goto bail; int i; for (i = istart; i <= iend; i++) { if (obj->arr[i]) Jsi_ValueCopy(interp, obj->arr[i], value); else obj->arr[i] = Jsi_ValueDup(interp, value); } bail: if (_this != *ret) Jsi_ValueMove(interp, *ret, _this); return rc; }"
"static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des) { char *link_name = NULL; int res; link_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1); link_name[file_hdr->c_filesize] = '\0'; tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize); tape_skip_padding(in_file_des, file_hdr->c_filesize); res = symlink(link_name, file_hdr->c_name); if (res < 0) { fprintf(stderr, ""%s: symlink %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); free(link_name); return; } if ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0) && errno != EPERM) { fprintf(stderr, ""%s: lchown %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); } free(link_name); }"
"void SFS_ArrayDeref(ScriptParser *parser) { if (parser->codec->LastError) return; SFS_Expression(parser); SFS_AddString(parser, ""[""); SFS_CompoundExpression(parser); SFS_AddString(parser, ""]""); }"
"void Server_message(Server *self, char * format, ...) { if (self->verbosity & 2) { char buffer[256]; va_list args; va_start (args, format); vsprintf (buffer, format, args); va_end (args); PySys_WriteStdout(""Pyo message: %s"", buffer); } }"
"static response vg_lookup(lvmetad_state *s, request r) { struct dm_config_tree *cft; struct dm_config_node *metadata, *n; struct vg_info *info; response res = { 0 }; const char *uuid = daemon_request_str(r, ""uuid"", NULL); const char *name = daemon_request_str(r, ""name"", NULL); int count = 0; buffer_init( &res.buffer ); if (!uuid && !name) { ERROR(s, ""vg_lookup with no uuid or name""); return reply_unknown(""VG not found""); } else if (!uuid || !name) { DEBUGLOG(s, ""vg_lookup vgid %s name %s needs lookup"", uuid ?: ""none"", name ?: ""none""); if (name && !uuid) uuid = dm_hash_lookup_with_count(s->vgname_to_vgid, name, &count); else if (uuid && !name) name = dm_hash_lookup(s->vgid_to_vgname, uuid); if (name && uuid && (count > 1)) { DEBUGLOG(s, ""vg_lookup name %s vgid %s found %d vgids"", name, uuid, count); return daemon_reply_simple(""multiple"", ""reason = %s"", ""Multiple VGs found with same name"", NULL); } if (!uuid || !name) return reply_unknown(""VG not found""); } else { char *name_lookup = dm_hash_lookup(s->vgid_to_vgname, uuid); char *uuid_lookup = dm_hash_lookup_with_val(s->vgname_to_vgid, name, uuid, strlen(uuid) + 1); if (!name_lookup || !uuid_lookup) { ERROR(s, ""vg_lookup vgid %s name %s found incomplete mapping uuid %s name %s"", uuid, name, uuid_lookup ?: ""none"", name_lookup ?: ""none""); return reply_unknown(""VG mapping incomplete""); } else if (strcmp(name_lookup, name) || strcmp(uuid_lookup, uuid)) { ERROR(s, ""vg_lookup vgid %s name %s found inconsistent mapping uuid %s name %s"", uuid, name, uuid_lookup, name_lookup); return reply_unknown(""VG mapping inconsistent""); } } DEBUGLOG(s, ""vg_lookup vgid %s name %s"", uuid ?: ""none"", name ?: ""none""); cft = dm_hash_lookup(s->vgid_to_metadata, uuid); if (!cft || !cft->root) { return reply_unknown(""UUID not found""); } metadata = cft->root; if (!(res.cft = dm_config_create())) goto nomem_un; if (!(res.cft->root = n = dm_config_create_node(res.cft, ""response""))) goto nomem_un; if (!(n->v = dm_config_create_value(cft))) goto nomem_un; n->parent = res.cft->root; n->v->type = DM_CFG_STRING; n->v->v.str = ""OK""; if (!(n = n->sib = dm_config_create_node(res.cft, ""name""))) goto nomem_un; if (!(n->v = dm_config_create_value(res.cft))) goto nomem_un; n->parent = res.cft->root; n->v->type = DM_CFG_STRING; n->v->v.str = name; if (!(n = n->sib = dm_config_clone_node(res.cft, metadata, 1))) goto nomem_un; n->parent = res.cft->root; if (!update_pv_status(s, res.cft, n)) goto nomem; chain_outdated_pvs(s, uuid, res.cft, n); if (s->flags & GLFL_INVALID) add_last_node(res.cft, ""global_invalid""); info = dm_hash_lookup(s->vgid_to_info, uuid); if (info && (info->flags & VGFL_INVALID)) { if (!add_last_node(res.cft, ""vg_invalid"")) goto nomem; } return res; nomem_un: nomem: reply_fail(""out of memory""); ERROR(s, ""vg_lookup vgid %s name %s out of memory."", uuid ?: ""none"", name ?: ""none""); ERROR(s, ""lvmetad could not be updated and is aborting.""); exit(EXIT_FAILURE); }"
"struct flb_in_mqtt_config *mqtt_config_init(struct flb_input_instance *i_ins) { char tmp[16]; char *listen; struct flb_in_mqtt_config *config; config = flb_malloc(sizeof(struct flb_in_mqtt_config)); memset(config, '\0', sizeof(struct flb_in_mqtt_config)); if (!i_ins->host.listen) { listen = flb_input_get_property(""listen"", i_ins); if (listen) { config->listen = flb_strdup(listen); } else { config->listen = flb_strdup(""0.0.0.0""); } } else { config->listen = i_ins->host.listen; } if (i_ins->host.port == 0) { config->tcp_port = flb_strdup(""1883""); } else { snprintf(tmp, sizeof(tmp) - 1, ""%d"", i_ins->host.port); config->tcp_port = flb_strdup(tmp); } flb_debug(""[in_mqtt] Listen='%s' TCP_Port=%s"", config->listen, config->tcp_port); return config; }"
"static bool perf_event_validate_size(struct perf_event *event) { __perf_event_read_size(event, event->group_leader->nr_siblings + 1); __perf_event_header_size(event, event->attr.sample_type & ~PERF_SAMPLE_READ); perf_event__id_header_size(event); if (event->read_size + event->header_size + event->id_header_size + sizeof(struct perf_event_header) >= 16*1024) return false; return true; }"
"static Uint8 * Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod, SDL_PixelFormat * dst) { Uint8 *map; int i; int bpp; SDL_Palette *pal = src->palette; bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel); map = (Uint8 *) SDL_malloc(pal->ncolors * bpp); if (map == NULL) { SDL_OutOfMemory(); return (NULL); } for (i = 0; i < pal->ncolors; ++i) { Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255); Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255); Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255); Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255); ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A); } return (map); }"
"void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags) { tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0; *pOut_len = 0; tinfl_init(&decomp); for (;;) { size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity; tinfl_status status = tinfl_decompress( &decomp, (const mz_uint8 *)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8 *)pBuf, pBuf ? (mz_uint8 *)pBuf + *pOut_len : NULL, &dst_buf_size, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF); if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT)) { MZ_FREE(pBuf); *pOut_len = 0; return NULL; } src_buf_ofs += src_buf_size; *pOut_len += dst_buf_size; if (status == TINFL_STATUS_DONE) break; new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128; pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity); if (!pNew_buf) { MZ_FREE(pBuf); *pOut_len = 0; return NULL; } pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity; } return pBuf; }"
"void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) { uint8_t* p = p_data->p_data; tBTM_LE_PENC_KEYS le_key; SMP_TRACE_DEBUG(""%s"", __func__); smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true); STREAM_TO_UINT16(le_key.ediv, p); STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN); memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN); le_key.sec_level = p_cb->sec_level; le_key.key_size = p_cb->loc_enc_size; if ((p_cb->peer_auth_req & SMP_AUTH_BOND) && (p_cb->loc_auth_req & SMP_AUTH_BOND)) btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC, (tBTM_LE_KEY_VALUE*)&le_key, true); smp_key_distribution(p_cb, NULL); }"
"Handle<JSObject> createHermesInternalObject( Runtime &runtime, const JSLibFlags &flags) { namespace P = Predefined; Handle<JSObject> intern = runtime.makeHandle(JSObject::create(runtime)); GCScope gcScope{runtime}; DefinePropertyFlags constantDPF = DefinePropertyFlags::getDefaultNewPropertyFlags(); constantDPF.enumerable = 0; constantDPF.writable = 0; constantDPF.configurable = 0; auto defineInternMethod = [&](Predefined::Str symID, NativeFunctionPtr func, uint8_t count = 0) { (void)defineMethod( runtime, intern, Predefined::getSymbolID(symID), nullptr , func, count, constantDPF); }; auto defineInternMethodAndSymbol = [&](const char *name, NativeFunctionPtr func, uint8_t count = 0) { ASCIIRef ref = createASCIIRef(name); Handle<SymbolID> symHandle = runtime.ignoreAllocationFailure( runtime.getIdentifierTable().getSymbolHandle(runtime, ref)); (void)defineMethod( runtime, intern, *symHandle, nullptr , func, count, constantDPF); }; (void)defineInternMethodAndSymbol; auto propRes = JSObject::getNamed_RJS( runtime.makeHandle<JSObject>(runtime.stringPrototype), runtime, Predefined::getSymbolID(Predefined::concat)); assert( propRes != ExecutionStatus::EXCEPTION && !(*propRes)->isUndefined() && ""Failed to get String.prototype.concat.""); auto putRes = JSObject::defineOwnProperty( intern, runtime, Predefined::getSymbolID(Predefined::concat), constantDPF, runtime.makeHandle(std::move(*propRes))); assert( putRes != ExecutionStatus::EXCEPTION && *putRes && ""Failed to set HermesInternal.concat.""); (void)putRes; defineInternMethod(P::hasPromise, hermesInternalHasPromise); defineInternMethod(P::enqueueJob, hermesInternalEnqueueJob); defineInternMethod( P::setPromiseRejectionTrackingHook, hermesInternalSetPromiseRejectionTrackingHook); defineInternMethod( P::enablePromiseRejectionTracker, hermesInternalEnablePromiseRejectionTracker); defineInternMethod(P::useEngineQueue, hermesInternalUseEngineQueue); #ifdef HERMES_ENABLE_FUZZILLI defineInternMethod(P::fuzzilli, hermesInternalFuzzilli); #endif if (!flags.enableHermesInternal) { JSObject::preventExtensions(*intern); return intern; } defineInternMethod(P::getEpilogues, hermesInternalGetEpilogues); defineInternMethod( P::getInstrumentedStats, hermesInternalGetInstrumentedStats); defineInternMethod( P::getRuntimeProperties, hermesInternalGetRuntimeProperties); defineInternMethod(P::ttiReached, hermesInternalTTIReached); defineInternMethod(P::ttrcReached, hermesInternalTTRCReached); defineInternMethod(P::getFunctionLocation, hermesInternalGetFunctionLocation); if (flags.enableHermesInternalTestMethods) { defineInternMethod( P::detachArrayBuffer, hermesInternalDetachArrayBuffer, 1); defineInternMethod(P::getWeakSize, hermesInternalGetWeakSize); defineInternMethod( P::copyDataProperties, hermesBuiltinCopyDataProperties, 3); defineInternMethodAndSymbol(""isProxy"", hermesInternalIsProxy); defineInternMethod(P::drainJobs, hermesInternalDrainJobs); } #ifdef HERMESVM_EXCEPTION_ON_OOM defineInternMethodAndSymbol(""getCallStack"", hermesInternalGetCallStack, 0); #endif  JSObject::preventExtensions(*intern); return intern; }"
"void formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form) { Buffer save; char *p; int spos, epos, rows, c_rows, pos, col = 0; Line *l; copyBuffer(&save, buf); gotoLine(buf, a->start.line); switch (form->type) { case FORM_TEXTAREA: case FORM_INPUT_TEXT: case FORM_INPUT_FILE: case FORM_INPUT_PASSWORD: case FORM_INPUT_CHECKBOX: case FORM_INPUT_RADIO: #ifdef MENU_SELECT case FORM_SELECT: #endif spos = a->start.pos; epos = a->end.pos; break; default: spos = a->start.pos + 1; epos = a->end.pos - 1; } switch (form->type) { case FORM_INPUT_CHECKBOX: case FORM_INPUT_RADIO: if (form->checked) buf->currentLine->lineBuf[spos] = '*'; else buf->currentLine->lineBuf[spos] = ' '; break; case FORM_INPUT_TEXT: case FORM_INPUT_FILE: case FORM_INPUT_PASSWORD: case FORM_TEXTAREA: #ifdef MENU_SELECT case FORM_SELECT: if (form->type == FORM_SELECT) { p = form->label->ptr; updateSelectOption(form, form->select_option); } else #endif p = form->value->ptr; l = buf->currentLine; if (!l) break; if (form->type == FORM_TEXTAREA) { int n = a->y - buf->currentLine->linenumber; if (n > 0) for (; l && n; l = l->prev, n--) ; else if (n < 0) for (; l && n; l = l->prev, n++) ; if (!l) break; } rows = form->rows ? form->rows : 1; col = COLPOS(l, a->start.pos); for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) { if (rows > 1) { pos = columnPos(l, col); a = retrieveAnchor(buf->formitem, l->linenumber, pos); if (a == NULL) break; spos = a->start.pos; epos = a->end.pos; } if (a->start.line != a->end.line || spos > epos || epos >= l->len) break; pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col, rows > 1, form->type == FORM_INPUT_PASSWORD); if (pos != epos) { shiftAnchorPosition(buf->href, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->name, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->img, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->formitem, buf->hmarklist, a->start.line, spos, pos - epos); } } break; } copyBuffer(buf, &save); arrangeLine(buf); }"
"ExponentialFunction::ExponentialFunction(Object *funcObj, Dict *dict) { Object obj1, obj2; int i; ok = gFalse; if (!init(dict)) { goto err1; } if (m != 1) { error(errSyntaxError, -1, ""Exponential function with more than one input""); goto err1; } if (dict->lookup(""C0"", &obj1)->isArray()) { if (hasRange && obj1.arrayGetLength() != n) { error(errSyntaxError, -1, ""Function's C0 array is wrong length""); goto err2; } n = obj1.arrayGetLength(); for (i = 0; i < n; ++i) { obj1.arrayGet(i, &obj2); if (!obj2.isNum()) { error(errSyntaxError, -1, ""Illegal value in function C0 array""); goto err3; } c0[i] = obj2.getNum(); obj2.free(); } } else { if (hasRange && n != 1) { error(errSyntaxError, -1, ""Function's C0 array is wrong length""); goto err2; } n = 1; c0[0] = 0; } obj1.free(); if (dict->lookup(""C1"", &obj1)->isArray()) { if (obj1.arrayGetLength() != n) { error(errSyntaxError, -1, ""Function's C1 array is wrong length""); goto err2; } for (i = 0; i < n; ++i) { obj1.arrayGet(i, &obj2); if (!obj2.isNum()) { error(errSyntaxError, -1, ""Illegal value in function C1 array""); goto err3; } c1[i] = obj2.getNum(); obj2.free(); } } else { if (n != 1) { error(errSyntaxError, -1, ""Function's C1 array is wrong length""); goto err2; } c1[0] = 1; } obj1.free(); if (!dict->lookup(""N"", &obj1)->isNum()) { error(errSyntaxError, -1, ""Function has missing or invalid N""); goto err2; } e = obj1.getNum(); obj1.free(); isLinear = fabs(e-1.) < 1e-10; ok = gTrue; return; err3: obj2.free(); err2: obj1.free(); err1: return; }"
"void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity, size_t TSize) { if (MinCapacity > UINT32_MAX) report_bad_alloc_error(""SmallVector capacity overflow during allocation""); size_t NewCapacity = 2 * capacity() + 1;   NewCapacity = std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX)); void *NewElts; if (BeginX == FirstEl) { NewElts = safe_malloc(NewCapacity * TSize); memcpy(NewElts, this->BeginX, size() * TSize); } else { NewElts = safe_realloc(this->BeginX, NewCapacity * TSize); } this->BeginX = NewElts; this->Capacity = NewCapacity; }"
"void jslTokenAsString(int token, char *str, size_t len) { if (token>32 && token<128) { assert(len>=4); str[0] = '\''; str[1] = (char)token; str[2] = '\''; str[3] = 0; return; } switch (token) { case LEX_EOF : strncpy(str, ""EOF"", len); return; case LEX_ID : strncpy(str, ""ID"", len); return; case LEX_INT : strncpy(str, ""INT"", len); return; case LEX_FLOAT : strncpy(str, ""FLOAT"", len); return; case LEX_STR : strncpy(str, ""STRING"", len); return; case LEX_UNFINISHED_STR : strncpy(str, ""UNFINISHED STRING"", len); return; case LEX_TEMPLATE_LITERAL : strncpy(str, ""TEMPLATE LITERAL"", len); return; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy(str, ""UNFINISHED TEMPLATE LITERAL"", len); return; case LEX_REGEX : strncpy(str, ""REGEX"", len); return; case LEX_UNFINISHED_REGEX : strncpy(str, ""UNFINISHED REGEX"", len); return; case LEX_UNFINISHED_COMMENT : strncpy(str, ""UNFINISHED COMMENT"", len); return; } if (token>=_LEX_OPERATOR_START && token<_LEX_R_LIST_END) { const char tokenNames[] = ""==\0"" ""===\0"" ""!=\0"" ""!==\0"" ""<=\0"" ""<<\0"" ""<<=\0"" "">=\0"" "">>\0"" "">>>\0"" "">>=\0"" "">>>=\0"" ""+=\0"" ""-=\0"" ""++\0"" ""--\0"" ""*=\0"" ""/=\0"" ""%=\0"" ""&=\0"" ""&&\0"" ""|=\0"" ""||\0"" ""^=\0"" ""=>\0"" ""if\0"" ""else\0"" ""do\0"" ""while\0"" ""for\0"" ""return\0"" ""continue\0"" ""function\0"" ""return\0"" ""var\0"" ""let\0"" ""const\0"" ""this\0"" ""throw\0"" ""try\0"" ""catch\0"" ""finally\0"" ""true\0"" ""false\0"" ""null\0"" ""undefined\0"" ""new\0"" ""in\0"" ""instanceof\0"" ""switch\0"" ""case\0"" ""default\0"" ""delete\0"" ""typeof\0"" ""void\0"" ""debugger\0"" ""class\0"" ""extends\0"" ""super\0"" ""static\0"" ; unsigned int p = 0; int n = token-_LEX_OPERATOR_START; while (n>0 && p<sizeof(tokenNames)) { while (tokenNames[p] && p<sizeof(tokenNames)) p++; p++;       n--;     } assert(n==0); strncpy(str, &tokenNames[p], len); return; } assert(len>=10); espruino_snprintf(str, len, ""?[%d]"", token); }"
"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf) { DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         int     outlen = sizeof(Jp2BoxHeader) ;         int      inlen = sizeof(Jp2BoxHeader) ;         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_; int32_t       length = getLong((byte*)&pBox->length, bigEndian); int32_t       count  = sizeof (Jp2BoxHeader); char*         p      = (char*) boxBuf.pData_; bool          bWroteColor = false ; while ( count < length || !bWroteColor ) { Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ; Jp2BoxHeader   subBox ; memcpy(&subBox,pSubBox,sizeof(subBox)); Jp2BoxHeader   newBox =  subBox; if ( count < length ) { subBox.length = getLong((byte*)&subBox.length, bigEndian); subBox.type   = getLong((byte*)&subBox.type  , bigEndian); #ifdef EXIV2_DEBUG_MESSAGES std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl; #endif count        += subBox.length; newBox.type   = subBox.type; } else { subBox.length=0; newBox.type = kJp2BoxTypeColorHeader; count = length; } int32_t newlen = subBox.length; if ( newBox.type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined() ) { const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid""; uint32_t    psize = 15; newlen            = sizeof(newBox) + psize ; ul2Data((byte*)&newBox.length,psize      ,bigEndian); ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)); ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         ); } else { const char* pad   = ""\x02\x00\x00""; uint32_t    psize = 3; newlen            = sizeof(newBox) + psize + iccProfile_.size_; ul2Data((byte*)&newBox.length,newlen,bigEndian); ul2Data((byte*)&newBox.type,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  ); ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           ); ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_); } } else { ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length); } outlen += newlen; inlen  += subBox.length; } outBuf.alloc(outlen); ::memcpy(outBuf.pData_,output.pData_,outlen); pBox   = (Jp2BoxHeader*) outBuf.pData_; ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian); ul2Data((byte*)&pBox->length,outlen,bigEndian); }"
"static int var_files_tmp_contents_generate(modsec_rec *msr, msre_var *var, msre_rule *rule, apr_table_t *vartab, apr_pool_t *mptmp) { multipart_part **parts = NULL; int i, count = 0; if (msr->mpd == NULL) return 0; parts = (multipart_part **)msr->mpd->parts->elts; for (i = 0; i < msr->mpd->parts->nelts; i++) { if ((parts[i]->type == MULTIPART_FILE) && (parts[i]->tmp_file_name != NULL)) { int match = 0; if (var->param == NULL) { match = 1; } else { if (var->param_data != NULL) { char *my_error_msg = NULL; if (!(msc_regexec((msc_regex_t *)var->param_data, parts[i]->name, strlen(parts[i]->name), &my_error_msg) == PCRE_ERROR_NOMATCH))  { match = 1; } } else { if (strcasecmp(parts[i]->name, var->param) == 0) { match = 1; } } } if (match) { char buf[1024]; FILE *file; size_t nread; char *full_content = NULL; size_t total_lenght = 0; msre_var *rvar = NULL; file = fopen(parts[i]->tmp_file_name, ""r""); if (file == NULL) { continue; } while ((nread = fread(buf, 1, 1023, file)) > 0) {    total_lenght += nread; buf[nread] = '\0'; if (full_content == NULL) { full_content = apr_psprintf(mptmp, ""%s"", buf); } else { full_content = apr_psprintf(mptmp, ""%s%s"", full_content, buf); } } fclose(file); rvar = apr_pmemdup(mptmp, var, sizeof(msre_var)); rvar->value = full_content; rvar->value_len = total_lenght; rvar->name = apr_psprintf(mptmp, ""FILES_TMP_CONTENT:%s"", log_escape_nq(mptmp, parts[i]->name)); apr_table_addn(vartab, rvar->name, (void *)rvar); count++; } } } return count; }"
"boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt( const SaplingOutCiphertext &ciphertext, const uint256& ovk, const uint256& cv, const uint256& cm, const uint256& epk ) { auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk); if (!pt) { return boost::none; } CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss << pt.get(); SaplingOutgoingPlaintext ret; ss >> ret; assert(ss.size() == 0); return ret; }"
"static int vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif )  { VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif ); GifFileType *file = gif->file; ColorMapObject *map = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap; GifByteType *extension; if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) { vips_foreign_load_gif_error( gif );  return( -1 ); } if( file->Image.Left < 0 || file->Image.Width < 1 || file->Image.Width > 10000 || file->Image.Left + file->Image.Width > file->SWidth || file->Image.Top < 0 || file->Image.Height < 1 || file->Image.Height > 10000 || file->Image.Top + file->Image.Height > file->SHeight ) { vips_error( class->nickname, ""%s"", _( ""bad frame size"" ) );  return( -1 );  } if( !gif->has_colour && map ) { int i; for( i = 0; i < map->ColorCount; i++ )  if( map->Colors[i].Red != map->Colors[i].Green || map->Colors[i].Green != map->Colors[i].Blue ) { gif->has_colour = TRUE; break; } } do { if( vips_foreign_load_gif_code_next( gif, &extension ) )  return( -1 ); } while( extension != NULL ); return( 0 ); }"
"static bfd_boolean read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp, bfd_byte *buf_end, struct line_info_table *table, bfd_boolean (*callback) (struct line_info_table *table, char *cur_file, unsigned int dir, unsigned int time, unsigned int size)) { bfd *abfd = unit->abfd; bfd_byte format_count, formati; bfd_vma data_count, datai; bfd_byte *buf = *bufp; bfd_byte *format_header_data; unsigned int bytes_read; format_count = read_1_byte (abfd, buf, buf_end); buf += 1; format_header_data = buf; for (formati = 0; formati < format_count; formati++) { _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; } data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; if (format_count == 0 && data_count != 0) { _bfd_error_handler (_(""Dwarf Error: Zero format count."")); bfd_set_error (bfd_error_bad_value); return FALSE; } if (data_count > (bfd_vma) (buf_end - buf)) { _bfd_error_handler (_(""Dwarf Error: data count (%Lx) larger than buffer size.""), data_count); bfd_set_error (bfd_error_bad_value); return FALSE; } for (datai = 0; datai < data_count; datai++) { bfd_byte *format = format_header_data; struct fileinfo fe; memset (&fe, 0, sizeof fe); for (formati = 0; formati < format_count; formati++) { bfd_vma content_type, form; char *string_trash; char **stringp = &string_trash; unsigned int uint_trash, *uintp = &uint_trash; content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (content_type) { case DW_LNCT_path: stringp = &fe.name; break; case DW_LNCT_directory_index: uintp = &fe.dir; break; case DW_LNCT_timestamp: uintp = &fe.time; break; case DW_LNCT_size: uintp = &fe.size; break; case DW_LNCT_MD5: break; default: _bfd_error_handler (_(""Dwarf Error: Unknown format content type %Lu.""), content_type); bfd_set_error (bfd_error_bad_value); return FALSE; } form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (form) { case DW_FORM_string: *stringp = read_string (abfd, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_line_strp: *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_data1: *uintp = read_1_byte (abfd, buf, buf_end); buf += 1; break; case DW_FORM_data2: *uintp = read_2_bytes (abfd, buf, buf_end); buf += 2; break; case DW_FORM_data4: *uintp = read_4_bytes (abfd, buf, buf_end); buf += 4; break; case DW_FORM_data8: *uintp = read_8_bytes (abfd, buf, buf_end); buf += 8; break; case DW_FORM_udata: *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; break; case DW_FORM_block: break; } } if (!callback (table, fe.name, fe.dir, fe.time, fe.size)) return FALSE; } *bufp = buf; return TRUE; }"
"void vhost_backend_cleanup(struct virtio_net *dev) { if (dev->mem) { free_mem_region(dev); rte_free(dev->mem); dev->mem = NULL; } free(dev->guest_pages); dev->guest_pages = NULL; if (dev->log_addr) { munmap((void *)(uintptr_t)dev->log_addr, dev->log_size); dev->log_addr = 0; } if (dev->slave_req_fd >= 0) { close(dev->slave_req_fd); dev->slave_req_fd = -1; } if (dev->postcopy_ufd >= 0) { close(dev->postcopy_ufd); dev->postcopy_ufd = -1; } dev->postcopy_listening = 0; }"
"static gboolean blf_read_apptextmessage(blf_params_t *params, int *err, gchar **err_info, gint64 block_start, gint64 data_start, gint64 object_length, guint64 timestamp _U_) { blf_apptext_t            apptextheader; if (object_length < (data_start - block_start) + (int)sizeof(apptextheader)) { *err = WTAP_ERR_BAD_FILE; *err_info = ws_strdup_printf(""blf: APP_TEXT: not enough bytes for apptext header in object""); ws_debug(""not enough bytes for apptext header in object""); return FALSE; } if (!blf_read_bytes(params, data_start, &apptextheader, sizeof(apptextheader), err, err_info)) { ws_debug(""not enough bytes for apptext header in file""); return FALSE; } fix_endianness_blf_apptext_header(&apptextheader); if (apptextheader.source != BLF_APPTEXT_CHANNEL) { return TRUE; } gchar *text = g_try_malloc0((gsize)apptextheader.textLength); if (!blf_read_bytes(params, data_start + sizeof(apptextheader), text, apptextheader.textLength, err, err_info)) { ws_debug(""not enough bytes for apptext text in file""); g_free(text); return FALSE; } gchar **tokens = g_strsplit_set(text, "";"", -1); if ( tokens == NULL || tokens[0] == NULL || tokens[1] == NULL) { if (tokens != NULL) { g_strfreev(tokens); } g_free(text); return TRUE; } guint32 channel = (apptextheader.reservedAppText1 >> 8) & 0xff; int pkt_encap; switch ((apptextheader.reservedAppText1 >> 16) & 0xff) { case BLF_BUSTYPE_CAN: pkt_encap = WTAP_ENCAP_SOCKETCAN; break; case BLF_BUSTYPE_FLEXRAY: pkt_encap = WTAP_ENCAP_FLEXRAY; break; case BLF_BUSTYPE_LIN: pkt_encap = WTAP_ENCAP_LIN; break; case BLF_BUSTYPE_ETHERNET: pkt_encap = WTAP_ENCAP_ETHERNET; break; case BLF_BUSTYPE_WLAN: pkt_encap = WTAP_ENCAP_IEEE_802_11; break; default: pkt_encap = 0xffffffff; } blf_lookup_interface(params, pkt_encap, channel, tokens[1]); g_strfreev(tokens); g_free(text); return TRUE; }"
"void SExpressionWasmBuilder::parseImport(Element& s) { size_t i = 1; bool newStyle = s.size() == 4 && s[3]->isList();   auto kind = ExternalKind::Invalid; if (newStyle) { if ((*s[3])[0]->str() == FUNC) { kind = ExternalKind::Function; } else if ((*s[3])[0]->str() == MEMORY) { kind = ExternalKind::Memory; if (wasm.memory.exists) throw ParseException(""more than one memory""); wasm.memory.exists = true; } else if ((*s[3])[0]->str() == TABLE) { kind = ExternalKind::Table; if (wasm.table.exists) throw ParseException(""more than one table""); wasm.table.exists = true; } else if ((*s[3])[0]->str() == GLOBAL) { kind = ExternalKind::Global; } else { newStyle = false;     } } Index newStyleInner = 1; Name name; if (s.size() > 3 && s[3]->isStr()) { name = s[i++]->str(); } else if (newStyle && newStyleInner < s[3]->size() && (*s[3])[newStyleInner]->dollared()) { name = (*s[3])[newStyleInner++]->str(); } if (!name.is()) { if (kind == ExternalKind::Function) { name = Name(""import$function$"" + std::to_string(functionCounter++)); functionNames.push_back(name); } else if (kind == ExternalKind::Global) { name = Name(""import$global"" + std::to_string(globalCounter++)); globalNames.push_back(name); } else if (kind == ExternalKind::Memory) { name = Name(""import$memory$"" + std::to_string(0)); } else if (kind == ExternalKind::Table) { name = Name(""import$table$"" + std::to_string(0)); } else { throw ParseException(""invalid import""); } } if (!s[i]->quoted()) { if (s[i]->str() == MEMORY) { kind = ExternalKind::Memory; } else if (s[i]->str() == TABLE) { kind = ExternalKind::Table; } else if (s[i]->str() == GLOBAL) { kind = ExternalKind::Global; } else { throw ParseException(""invalid ext import""); } i++; } else if (!newStyle) { kind = ExternalKind::Function; } auto module = s[i++]->str(); if (!s[i]->isStr()) throw ParseException(""no name for import""); auto base = s[i++]->str(); Element& inner = newStyle ? *s[3] : s; Index j = newStyle ? newStyleInner : i; if (kind == ExternalKind::Function) { std::unique_ptr<FunctionType> type = make_unique<FunctionType>(); if (inner.size() > j) { Element& params = *inner[j]; IString id = params[0]->str(); if (id == PARAM) { for (size_t k = 1; k < params.size(); k++) { type->params.push_back(stringToType(params[k]->str())); } } else if (id == RESULT) { type->result = stringToType(params[1]->str()); } else if (id == TYPE) { IString name = params[1]->str(); if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(""bad function type for import""); *type = *wasm.getFunctionType(name); } else { throw ParseException(""bad import element""); } if (inner.size() > j+1) { Element& result = *inner[j+1]; if (result[0]->str() != RESULT) throw ParseException(""expected result""); type->result = stringToType(result[1]->str()); } } auto func = make_unique<Function>(); func->name = name; func->module = module; func->base = base; auto* functionType = ensureFunctionType(getSig(type.get()), &wasm); func->type = functionType->name; FunctionTypeUtils::fillFunction(func.get(), functionType); functionTypes[name] = func->result; wasm.addFunction(func.release()); } else if (kind == ExternalKind::Global) { Type type; bool mutable_ = false; if (inner[j]->isStr()) { type = stringToType(inner[j]->str()); } else { auto& inner2 = *inner[j]; if (inner2[0]->str() != MUT) throw ParseException(""expected mut""); type = stringToType(inner2[1]->str()); mutable_ = true; } auto global = make_unique<Global>(); global->name = name; global->module = module; global->base = base; global->type = type; global->mutable_ = mutable_; wasm.addGlobal(global.release()); } else if (kind == ExternalKind::Table) { wasm.table.module = module; wasm.table.base = base; if (j < inner.size() - 1) { wasm.table.initial = getCheckedAddress(inner[j++], ""excessive table init size""); } if (j < inner.size() - 1) { wasm.table.max = getCheckedAddress(inner[j++], ""excessive table max size""); } else { wasm.table.max = Table::kUnlimitedSize; } } else if (kind == ExternalKind::Memory) { wasm.memory.module = module; wasm.memory.base = base; if (inner[j]->isList()) { auto& limits = *inner[j]; if (!(limits[0]->isStr() && limits[0]->str() == ""shared"")) throw ParseException(""bad memory limit declaration""); wasm.memory.shared = true; parseMemoryLimits(limits, 1); } else { parseMemoryLimits(inner, j); } } }"
"static enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer) { struct bfq_data *bfqd = container_of(timer, struct bfq_data, idle_slice_timer); struct bfq_queue *bfqq = bfqd->in_service_queue; if (bfqq) bfq_idle_slice_timer_body(bfqq); return HRTIMER_NORESTART; }"
"int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in) { char *param, buffer[128], tmp[128]; int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0; SrtStack stack[16]; int closing_brace_missing = 0; stack[0].tag[0] = 0; strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}""); strcpy(stack[0].param[PARAM_COLOR], ""{\\c}""); strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}""); for (; !end && *in; in++) { switch (*in) { case '\r': break; case '\n': if (line_start) { end = 1; break; } rstrip_spaces_buf(dst); av_bprintf(dst, ""\\N""); line_start = 1; break; case ' ': if (!line_start) av_bprint_chars(dst, *in, 1); break; case '{':     len = 0; an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0; if (!closing_brace_missing) { if (   (an != 1 && in[1] == '\\') || (in[1] && strchr(""CcFfoPSsYy"", in[1]) && in[2] == ':')) { char *bracep = strchr(in+2, '}'); if (bracep) { in = bracep; break; } else closing_brace_missing = 1; } } av_bprint_chars(dst, *in, 1); break; case '<': tag_close = in[1] == '/'; len = 0; if (scantag(in+tag_close+1, buffer, &len) && len > 0) { const char *tagname = buffer; while (*tagname == ' ') tagname++; if ((param = strchr(tagname, ' '))) *param++ = 0; if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) || ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) { int i, j, unknown = 0; in += len + tag_close; if (!tag_close) memset(stack+sptr, 0, sizeof(*stack)); if (!strcmp(tagname, ""font"")) { if (tag_close) { for (i=PARAM_NUMBER-1; i>=0; i--) if (stack[sptr-1].param[i][0]) for (j=sptr-2; j>=0; j--) if (stack[j].param[i][0]) { av_bprintf(dst, ""%s"", stack[j].param[i]); break; } } else { while (param) { if (!strncmp(param, ""size="", 5)) { unsigned font_size; param += 5 + (param[5] == '""'); if (sscanf(param, ""%u"", &font_size) == 1) { snprintf(stack[sptr].param[PARAM_SIZE], sizeof(stack[0].param[PARAM_SIZE]), ""{\\fs%u}"", font_size); } } else if (!strncmp(param, ""color="", 6)) { param += 6 + (param[6] == '""'); snprintf(stack[sptr].param[PARAM_COLOR], sizeof(stack[0].param[PARAM_COLOR]), ""{\\c&H%X&}"", html_color_parse(log_ctx, param)); } else if (!strncmp(param, ""face="", 5)) { param += 5 + (param[5] == '""'); len = strcspn(param, param[-1] == '""' ? ""\"""" :"" ""); av_strlcpy(tmp, param, FFMIN(sizeof(tmp), len+1)); param += len; snprintf(stack[sptr].param[PARAM_FACE], sizeof(stack[0].param[PARAM_FACE]), ""{\\fn%s}"", tmp); } if ((param = strchr(param, ' '))) param++; } for (i=0; i<PARAM_NUMBER; i++) if (stack[sptr].param[i][0]) av_bprintf(dst, ""%s"", stack[sptr].param[i]); } } else if (tagname[0] && !tagname[1] && strspn(tagname, ""bisu"") == 1) { av_bprintf(dst, ""{\\%c%d}"", tagname[0], !tag_close); } else { unknown = 1; snprintf(tmp, sizeof(tmp), ""</%s>"", tagname); } if (tag_close) { sptr--; } else if (unknown && !strstr(in, tmp)) { in -= len + tag_close; av_bprint_chars(dst, *in, 1); } else av_strlcpy(stack[sptr++].tag, tagname, sizeof(stack[0].tag)); break; } } default: av_bprint_chars(dst, *in, 1); break; } if (*in != ' ' && *in != '\r' && *in != '\n') line_start = 0; } if (!av_bprint_is_complete(dst)) return AVERROR(ENOMEM); while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], ""\\N"", 2)) dst->len -= 2; dst->str[dst->len] = 0; rstrip_spaces_buf(dst); return 0; }"
"struct bignum *crypto_bignum_allocate(size_t size_bits) { size_t sz = mpa_StaticVarSizeInU32(size_bits) *sizeof(uint32_t); struct mpa_numbase_struct *bn = calloc(1, sz); if (!bn) return NULL; bn->alloc = sz - MPA_NUMBASE_METADATA_SIZE_IN_U32 * sizeof(uint32_t); return (struct bignum *)bn; }"
"int64_t BZ2File::readImpl(char * buf, int64_t length) { if (length == 0) { return 0; } assertx(m_bzFile); int len = BZ2_bzread(m_bzFile, buf, length); if (len <= 0) { setEof(true); if (len < 0) { return -1; } } return len; }"
"int vrend_create_vertex_elements_state(struct vrend_context *ctx, uint32_t handle, unsigned num_elements, const struct pipe_vertex_element *elements) { struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array); const struct util_format_description *desc; GLenum type; int i; uint32_t ret_handle; if (!v) return ENOMEM; v->count = num_elements; for (i = 0; i < num_elements; i++) { memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element)); desc = util_format_description(elements[i].src_format); if (!desc) { FREE(v); return EINVAL; } type = GL_FALSE; if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) { if (desc->channel[0].size == 32) type = GL_FLOAT; else if (desc->channel[0].size == 64) type = GL_DOUBLE; else if (desc->channel[0].size == 16) type = GL_HALF_FLOAT; } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 8) type = GL_UNSIGNED_BYTE; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 8) type = GL_BYTE; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 16) type = GL_UNSIGNED_SHORT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 16) type = GL_SHORT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 32) type = GL_UNSIGNED_INT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 32) type = GL_INT; else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED || elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM || elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM) type = GL_INT_2_10_10_10_REV; else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED || elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM || elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM) type = GL_UNSIGNED_INT_2_10_10_10_REV; else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) type = GL_UNSIGNED_INT_10F_11F_11F_REV; if (type == GL_FALSE) { report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format); FREE(v); return EINVAL; } v->elements[i].type = type; if (desc->channel[0].normalized) v->elements[i].norm = GL_TRUE; if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z) v->elements[i].nr_chan = GL_BGRA; else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) v->elements[i].nr_chan = 3; else v->elements[i].nr_chan = desc->nr_channels; } if (vrend_state.have_vertex_attrib_binding) { glGenVertexArrays(1, &v->id); glBindVertexArray(v->id); for (i = 0; i < num_elements; i++) { struct vrend_vertex_element *ve = &v->elements[i]; if (util_format_is_pure_integer(ve->base.src_format)) glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset); else glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset); glVertexAttribBinding(i, ve->base.vertex_buffer_index); glVertexBindingDivisor(i, ve->base.instance_divisor); glEnableVertexAttribArray(i); } } ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle, VIRGL_OBJECT_VERTEX_ELEMENTS); if (!ret_handle) { FREE(v); return ENOMEM; } return 0; }"
"int steal_page( struct domain *d, struct page_info *page, unsigned int memflags) { unsigned long x, y; bool_t drop_dom_ref = 0; const struct domain *owner = dom_xen; spin_lock(&d->page_alloc_lock); if ( is_xen_heap_page(page) || ((owner = page_get_owner(page)) != d) ) goto fail; y = page->count_info; do { x = y; if ( (x & (PGC_count_mask|PGC_allocated)) != (1 | PGC_allocated) ) goto fail; y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask); } while ( y != x ); page_set_owner(page, NULL); y = page->count_info; do { x = y; BUG_ON((x & (PGC_count_mask|PGC_allocated)) != PGC_allocated); } while ( (y = cmpxchg(&page->count_info, x, x | 1)) != x ); if ( !(memflags & MEMF_no_refcount) && !domain_adjust_tot_pages(d, -1) ) drop_dom_ref = 1; page_list_del(page, &d->page_list); spin_unlock(&d->page_alloc_lock); if ( unlikely(drop_dom_ref) ) put_domain(d); return 0; fail: spin_unlock(&d->page_alloc_lock); gdprintk(XENLOG_WARNING, ""Bad steal mfn %"" PRI_mfn "" from d%d (owner d%d) caf=%08lx taf=%"" PRtype_info ""\n"", page_to_mfn(page), d->domain_id, owner ? owner->domain_id : DOMID_INVALID, page->count_info, page->u.inuse.type_info); return -1; }"
"inline void BinaryBroadcastFiveFold(const ArithmeticParams& unswitched_params, const RuntimeShape& unswitched_input1_shape, const T* unswitched_input1_data, const RuntimeShape& unswitched_input2_shape, const T* unswitched_input2_data, const RuntimeShape& output_shape, T* output_data, ElementwiseF elementwise_f, ScalarBroadcastF scalar_broadcast_f) { ArithmeticParams switched_params = unswitched_params; switched_params.input1_offset = unswitched_params.input2_offset; switched_params.input1_multiplier = unswitched_params.input2_multiplier; switched_params.input1_shift = unswitched_params.input2_shift; switched_params.input2_offset = unswitched_params.input1_offset; switched_params.input2_multiplier = unswitched_params.input1_multiplier; switched_params.input2_shift = unswitched_params.input1_shift; const bool use_unswitched = unswitched_params.broadcast_category == tflite::BroadcastableOpCategory::kFirstInputBroadcastsFast; const ArithmeticParams& params = use_unswitched ? unswitched_params : switched_params; const T* input1_data = use_unswitched ? unswitched_input1_data : unswitched_input2_data; const T* input2_data = use_unswitched ? unswitched_input2_data : unswitched_input1_data; T* output_data_ptr = output_data; const T* input1_data_ptr = input1_data; const T* input2_data_reset = input2_data; int y0 = params.broadcast_shape[0]; int y1 = params.broadcast_shape[1]; int y2 = params.broadcast_shape[2]; int y3 = params.broadcast_shape[3]; int y4 = params.broadcast_shape[4]; if (y4 > 1) { for (int i0 = 0; i0 < y0; ++i0) { const T* input2_data_ptr = nullptr; for (int i1 = 0; i1 < y1; ++i1) { input2_data_ptr = input2_data_reset; for (int i2 = 0; i2 < y2; ++i2) { for (int i3 = 0; i3 < y3; ++i3) { elementwise_f(y4, params, input1_data_ptr, input2_data_ptr, output_data_ptr); input2_data_ptr += y4; output_data_ptr += y4; } input1_data_ptr += y4; } } input2_data_reset = input2_data_ptr; } } else { for (int i0 = 0; i0 < y0; ++i0) { const T* input2_data_ptr = nullptr; for (int i1 = 0; i1 < y1; ++i1) { input2_data_ptr = input2_data_reset; for (int i2 = 0; i2 < y2; ++i2) { scalar_broadcast_f(y3, params, *input1_data_ptr, input2_data_ptr, output_data_ptr); input2_data_ptr += y3; output_data_ptr += y3; input1_data_ptr += 1; } } input2_data_reset = input2_data_ptr; } } }"
"int tee_shm_get_fd(struct tee_shm *shm) { int fd; if (!(shm->flags & TEE_SHM_DMA_BUF)) return -EINVAL; get_dma_buf(shm->dmabuf); fd = dma_buf_fd(shm->dmabuf, O_CLOEXEC); if (fd < 0) dma_buf_put(shm->dmabuf); return fd; }"
"static int base_sock_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; if (sock->type != SOCK_RAW) return -ESOCKTNOSUPPORT; sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern); if (!sk) return -ENOMEM; sock_init_data(sock, sk); sock->ops = &base_sock_ops; sock->state = SS_UNCONNECTED; sock_reset_flag(sk, SOCK_ZAPPED); sk->sk_protocol = protocol; sk->sk_state    = MISDN_OPEN; mISDN_sock_link(&base_sockets, sk); return 0; }"
"struct error_obj run_pam_auth(const char *username, char *password) { struct pam_response *reply = malloc(sizeof(struct pam_response)); if (reply == NULL) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""malloc""; ret_val.error_msg = ""Out of memory""; return ret_val; } reply->resp = password; reply->resp_retcode = 0; const struct pam_conv local_conv = { conv_func, reply }; pam_handle_t *local_auth = NULL; int status = pam_start(""maddy"", username, &local_conv, &local_auth); if (status != PAM_SUCCESS) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""pam_start""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK); if (status != PAM_SUCCESS) { struct error_obj ret_val; if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) { ret_val.status = 1; } else { ret_val.status = 2; } ret_val.func_name = ""pam_authenticate""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } status = pam_end(local_auth, status); if (status != PAM_SUCCESS) { struct error_obj ret_val; ret_val.status = 2; ret_val.func_name = ""pam_end""; ret_val.error_msg = pam_strerror(local_auth, status); return ret_val; } struct error_obj ret_val; ret_val.status = 0; ret_val.func_name = NULL; ret_val.error_msg = NULL; return ret_val; }"
"int iommu_domain_init(struct domain *d, unsigned int opts) { struct domain_iommu *hd = dom_iommu(d); int ret = 0; if ( !is_iommu_enabled(d) ) return 0; #ifdef CONFIG_NUMA hd->node = NUMA_NO_NODE; #endif ret = arch_iommu_domain_init(d); if ( ret ) return ret; hd->platform_ops = iommu_get_ops(); ret = hd->platform_ops->init(d); if ( ret ) return ret; if ( is_hardware_domain(d) ) check_hwdom_reqs(d);  hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share && !(opts & XEN_DOMCTL_IOMMU_no_sharept); if ( !is_hardware_domain(d) || iommu_hwdom_strict ) hd->need_sync = !iommu_use_hap_pt(d); ASSERT(!(hd->need_sync && hd->hap_pt_share)); return 0; }"
"void svhandler_flash_pgm_word(void) { uint32_t dst = _param_1; uint32_t src = _param_2; if ((dst >= BSTRP_FLASH_SECT_START) && (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) { return; } if ((dst >= BLDR_FLASH_SECT_START) && (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) { return; } flash_clear_status_flags(); flash_unlock(); flash_program_word(dst, src); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }"
"int nfc_dep_link_down(struct nfc_dev *dev) { int rc = 0; pr_debug(""dev_name=%s\n"", dev_name(&dev->dev)); if (!dev->ops->dep_link_down) return -EOPNOTSUPP; device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (dev->dep_link_up == false) { rc = -EALREADY; goto error; } rc = dev->ops->dep_link_down(dev); if (!rc) { dev->dep_link_up = false; dev->active_target = NULL; dev->rf_mode = NFC_RF_NONE; nfc_llcp_mac_is_down(dev); nfc_genl_dep_link_down_event(dev); } error: device_unlock(&dev->dev); return rc; }"
"status_t BnCrypto::onTransact( uint32_t code, const Parcel &data, Parcel *reply, uint32_t flags) { switch (code) { case INIT_CHECK: { CHECK_INTERFACE(ICrypto, data, reply); reply->writeInt32(initCheck()); return OK; } case IS_CRYPTO_SUPPORTED: { CHECK_INTERFACE(ICrypto, data, reply); uint8_t uuid[16]; data.read(uuid, sizeof(uuid)); reply->writeInt32(isCryptoSchemeSupported(uuid)); return OK; } case CREATE_PLUGIN: { CHECK_INTERFACE(ICrypto, data, reply); uint8_t uuid[16]; data.read(uuid, sizeof(uuid)); size_t opaqueSize = data.readInt32(); void *opaqueData = NULL; if (opaqueSize > 0) { opaqueData = malloc(opaqueSize); data.read(opaqueData, opaqueSize); } reply->writeInt32(createPlugin(uuid, opaqueData, opaqueSize)); if (opaqueData != NULL) { free(opaqueData); opaqueData = NULL; } return OK; } case DESTROY_PLUGIN: { CHECK_INTERFACE(ICrypto, data, reply); reply->writeInt32(destroyPlugin()); return OK; } case REQUIRES_SECURE_COMPONENT: { CHECK_INTERFACE(ICrypto, data, reply); const char *mime = data.readCString(); reply->writeInt32(requiresSecureDecoderComponent(mime)); return OK; } case DECRYPT: { CHECK_INTERFACE(ICrypto, data, reply); bool secure = data.readInt32() != 0; CryptoPlugin::Mode mode = (CryptoPlugin::Mode)data.readInt32(); uint8_t key[16]; data.read(key, sizeof(key)); uint8_t iv[16]; data.read(iv, sizeof(iv)); size_t totalSize = data.readInt32(); sp<IMemory> sharedBuffer = interface_cast<IMemory>(data.readStrongBinder()); int32_t offset = data.readInt32(); int32_t numSubSamples = data.readInt32(); CryptoPlugin::SubSample *subSamples = new CryptoPlugin::SubSample[numSubSamples]; data.read( subSamples, sizeof(CryptoPlugin::SubSample) * numSubSamples); void *secureBufferId, *dstPtr; if (secure) { secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64())); } else { dstPtr = calloc(1, totalSize); } AString errorDetailMsg; ssize_t result; size_t sumSubsampleSizes = 0; bool overflow = false; for (int32_t i = 0; i < numSubSamples; ++i) { CryptoPlugin::SubSample &ss = subSamples[i]; if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfEncryptedData) { sumSubsampleSizes += ss.mNumBytesOfEncryptedData; } else { overflow = true; } if (sumSubsampleSizes <= SIZE_MAX - ss.mNumBytesOfClearData) { sumSubsampleSizes += ss.mNumBytesOfClearData; } else { overflow = true; } } if (overflow || sumSubsampleSizes != totalSize) { result = -EINVAL; } else if (offset + totalSize > sharedBuffer->size()) { result = -EINVAL; } else { result = decrypt( secure, key, iv, mode, sharedBuffer, offset, subSamples, numSubSamples, secure ? secureBufferId : dstPtr, &errorDetailMsg); } reply->writeInt32(result); if (isCryptoError(result)) { reply->writeCString(errorDetailMsg.c_str()); } if (!secure) { if (result >= 0) { CHECK_LE(result, static_cast<ssize_t>(totalSize)); reply->write(dstPtr, result); } free(dstPtr); dstPtr = NULL; } delete[] subSamples; subSamples = NULL; return OK; } case NOTIFY_RESOLUTION: { CHECK_INTERFACE(ICrypto, data, reply); int32_t width = data.readInt32(); int32_t height = data.readInt32(); notifyResolution(width, height); return OK; } case SET_MEDIADRM_SESSION: { CHECK_INTERFACE(IDrm, data, reply); Vector<uint8_t> sessionId; readVector(data, sessionId); reply->writeInt32(setMediaDrmSession(sessionId)); return OK; } default: return BBinder::onTransact(code, data, reply, flags); } }"
void Filter::onUpstreamEvent(Network::ConnectionEvent event) { bool connecting = connecting_; connecting_ = false; if (event == Network::ConnectionEvent::RemoteClose || event == Network::ConnectionEvent::LocalClose) { upstream_.reset(); disableIdleTimer(); if (connecting) { if (event == Network::ConnectionEvent::RemoteClose) { getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure); read_callbacks_->upstreamHost()->outlierDetector().putResult( Upstream::Outlier::Result::LocalOriginConnectFailed); } initializeUpstreamConnection(); } else { if (read_callbacks_->connection().state() == Network::Connection::State::Open) { read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite); } } } }
"void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) { minify = dominify; if (prog->type == AST_LIST) pstmlist(-1, prog); else { pstm(0, prog); nl(); } if (minify > 1) putchar('\n'); }"
"unsigned find_file(const StringList & sl, String & filename) { StringListEnumeration els = sl.elements_obj(); const char * dir; String path; while ( (dir = els.next()) != 0 )  { path = dir; if (path.back() != '/') path += '/'; unsigned dir_len = path.size(); path += filename; if (file_exists(path)) { filename.swap(path); return dir_len; } } return 0; }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { squashfs_dir_header_2 dirh; char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; long long start; int bytes = 0; int dir_count, size, res; struct dir_ent *ent, *cur_ent = NULL; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) MEM_ERROR(); dir->dir_count = 0; dir->cur_entry = NULL; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 0) return dir; start = sBlk.s.directory_table_start + (*i)->start; offset = (*i)->offset; size = (*i)->data + bytes; while(bytes < size) { if(swap) { squashfs_dir_header_2 sdirh; res = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh)); if(res) SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); } else res = read_directory_data(&dirh, &start, &offset, sizeof(dirh)); if(res == FALSE) goto corrupted; dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { if(swap) { squashfs_dir_entry_2 sdire; res = read_directory_data(&sdire, &start, &offset, sizeof(sdire)); if(res) SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); } else res = read_directory_data(dire, &start, &offset, sizeof(*dire)); if(res == FALSE) goto corrupted; bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } res = read_directory_data(dire->name, &start, &offset, dire->size + 1); if(res == FALSE) goto corrupted; dire->name[dire->size + 1] = '\0'; if(check_name(dire->name, dire->size + 1) == FALSE) { ERROR(""File system corrupted: invalid characters in name\n""); goto corrupted; } TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); ent = malloc(sizeof(struct dir_ent)); if(ent == NULL) MEM_ERROR(); ent->name = strdup(dire->name); ent->start_block = dirh.start_block; ent->offset = dire->offset; ent->type = dire->type; ent->next = NULL; if(cur_ent == NULL) dir->dirs = ent; else cur_ent->next = ent; cur_ent = ent; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: squashfs_closedir(dir); return NULL; }"
"void SSH_init(PTInstVar pvar) { int i; buf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen); buf_create(&pvar->ssh_state.precompress_outbuf, &pvar->ssh_state.precompress_outbuflen); buf_create(&pvar->ssh_state.postdecompress_inbuf, &pvar->ssh_state.postdecompress_inbuflen); pvar->ssh_state.payload = NULL; pvar->ssh_state.compressing = FALSE; pvar->ssh_state.decompressing = FALSE; pvar->ssh_state.status_flags = STATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS; pvar->ssh_state.payload_datalen = 0; pvar->ssh_state.hostname = NULL; pvar->ssh_state.server_ID = NULL; pvar->ssh_state.receiver_sequence_number = 0; pvar->ssh_state.sender_sequence_number = 0; for (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) { pvar->ssh_state.packet_handlers[i] = NULL; } memset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys)); pvar->userauth_success = 0; pvar->shell_id = SSH_CHANNEL_INVALID; pvar->session_nego_status = 0; pvar->settings.ssh_protocol_version = 2;  pvar->kex_status = 0; pvar->ssh2_autologin = 0;  pvar->ask4passwd = 0; pvar->userauth_retry_count = 0; pvar->decomp_buffer = NULL; pvar->authbanner_buffer = NULL; pvar->ssh2_authlist = NULL; pvar->tryed_ssh2_authlist = FALSE; pvar->agentfwd_enable = FALSE; pvar->use_subsystem = FALSE; pvar->nosession = FALSE; pvar->server_sig_algs = NULL; }"
static bool canLoadFrame(HTMLFrameOwnerElement& owner) { if (owner.document().unloadStarted()) return false; for (Node* node = &owner; node; node = node->parentOrShadowHostNode()) { if (disabledSubtreeRoots().contains(node)) return false; } return true; }
"void IdentifierHashTable::growAndRehash(uint32_t newCapacity) { assert(llvh::isPowerOf2_32(newCapacity) && ""capacity must be power of 2""); CompactTable tmpTable(newCapacity, table_.getCurrentScale()); tmpTable.swap(table_); for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) { if (!tmpTable.isValid(oldIdx)) { continue; } uint32_t idx = 0; uint32_t oldVal = tmpTable.get(oldIdx); auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal); uint32_t hash = lookupTableEntry.getHash(); if (lookupTableEntry.isStringPrim()) { idx = lookupString(lookupTableEntry.getStringPrim(), hash, true); } else if (lookupTableEntry.isLazyASCII()) { idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true); } else if (lookupTableEntry.isLazyUTF16()) { idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true); } table_.set(idx, oldVal); } nonEmptyEntryCount_ = size_; }"
"void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx, struct kvm_io_device *dev) { int i; struct kvm_io_bus *new_bus, *bus; bus = kvm_get_bus(kvm, bus_idx); if (!bus) return; for (i = 0; i < bus->dev_count; i++) if (bus->range[i].dev == dev) { break; } if (i == bus->dev_count) return; new_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1), GFP_KERNEL_ACCOUNT); if (!new_bus)  { pr_err(""kvm: failed to shrink bus, removing it completely\n""); goto broken; } memcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range)); new_bus->dev_count--; memcpy(new_bus->range + i, bus->range + i + 1, (new_bus->dev_count - i) * sizeof(struct kvm_io_range)); broken: rcu_assign_pointer(kvm->buses[bus_idx], new_bus); synchronize_srcu_expedited(&kvm->srcu); kfree(bus); return; }"
"static int isis_print_mt_capability_subtlv(netdissect_options *ndo, const uint8_t *tptr, int len) { int stlv_type, stlv_len, tmp; while (len > 2) { stlv_type = *(tptr++); stlv_len  = *(tptr++); ND_PRINT((ndo, ""\n\t      %s subTLV #%u, length: %u"", tok2str(isis_mt_capability_subtlv_values, ""unknown"", stlv_type), stlv_type, stlv_len)); len = len - 2; switch (stlv_type) { case ISIS_SUBTLV_SPB_INSTANCE: ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN); ND_PRINT((ndo, ""\n\t        CIST Root-ID: %08x"", EXTRACT_32BITS(tptr))); tptr = tptr+4; ND_PRINT((ndo, "" %08x"", EXTRACT_32BITS(tptr))); tptr = tptr+4; ND_PRINT((ndo, "", Path Cost: %08x"", EXTRACT_32BITS(tptr))); tptr = tptr+4; ND_PRINT((ndo, "", Prio: %d"", EXTRACT_16BITS(tptr))); tptr = tptr + 2; ND_PRINT((ndo, ""\n\t        RES: %d"", EXTRACT_16BITS(tptr) >> 5)); ND_PRINT((ndo, "", V: %d"", (EXTRACT_16BITS(tptr) >> 4) & 0x0001)); ND_PRINT((ndo, "", SPSource-ID: %d"", (EXTRACT_32BITS(tptr) & 0x000fffff))); tptr = tptr+4; ND_PRINT((ndo, "", No of Trees: %x"", *(tptr))); tmp = *(tptr++); len = len - ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN; while (tmp) { ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN); ND_PRINT((ndo, ""\n\t         U:%d, M:%d, A:%d, RES:%d"", *(tptr) >> 7, (*(tptr) >> 6) & 0x01, (*(tptr) >> 5) & 0x01, (*(tptr) & 0x1f))); tptr++; ND_PRINT((ndo, "", ECT: %08x"", EXTRACT_32BITS(tptr))); tptr = tptr + 4; ND_PRINT((ndo, "", BVID: %d, SPVID: %d"", (EXTRACT_24BITS(tptr) >> 12) & 0x000fff, EXTRACT_24BITS(tptr) & 0x000fff)); tptr = tptr + 3; len = len - ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN; tmp--; } break; case ISIS_SUBTLV_SPBM_SI: ND_TCHECK2(*tptr, 8); ND_PRINT((ndo, ""\n\t        BMAC: %08x"", EXTRACT_32BITS(tptr))); tptr = tptr+4; ND_PRINT((ndo, ""%04x"", EXTRACT_16BITS(tptr))); tptr = tptr+2; ND_PRINT((ndo, "", RES: %d, VID: %d"", EXTRACT_16BITS(tptr) >> 12, (EXTRACT_16BITS(tptr)) & 0x0fff)); tptr = tptr+2; len = len - 8; stlv_len = stlv_len - 8; while (stlv_len >= 4) { ND_TCHECK2(*tptr, 4); ND_PRINT((ndo, ""\n\t        T: %d, R: %d, RES: %d, ISID: %d"", (EXTRACT_32BITS(tptr) >> 31), (EXTRACT_32BITS(tptr) >> 30) & 0x01, (EXTRACT_32BITS(tptr) >> 24) & 0x03f, (EXTRACT_32BITS(tptr)) & 0x0ffffff)); tptr = tptr + 4; len = len - 4; stlv_len = stlv_len - 4; } break; default: break; } } return 0; trunc: ND_PRINT((ndo, ""\n\t\t"")); ND_PRINT((ndo, ""%s"", tstr)); return(1); }"
Gfx::~Gfx() { while (state->hasSaves()) { restoreState(); } if (!subPage) { out->endPage(); } while (res) { popResources(); } if (state) { delete state; } while (mcStack) { popMarkedContent(); } }
"static int x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx, struct x509_verify_chain *chain, char *name) { size_t depth; X509 *last = x509_verify_chain_last(chain); X509 *leaf = x509_verify_chain_leaf(chain); depth = sk_X509_num(chain->certs); if (depth > 0) depth--; if (ctx->chains_count >= ctx->max_chains) return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_CERT_CHAIN_TOO_LONG, 0); if (chain->cert_errors[depth] == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) chain->cert_errors[depth] = X509_V_OK; if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth)) return 0; if ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) == NULL) { return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_OUT_OF_MEM, 0); } if (!x509_verify_cert_valid(ctx, leaf, NULL)) return 0; if (!x509_verify_cert_hostname(ctx, leaf, name)) return 0; ctx->chains_count++; ctx->error = X509_V_OK; ctx->error_depth = depth; return 1; }"
"void ConnectionManagerImpl::ActiveStream::decodeHeaders(RequestHeaderMapSharedPtr&& headers, bool end_stream) { ENVOY_STREAM_LOG(debug, ""request headers complete (end_stream={}):\n{}"", *this, end_stream, *headers); ScopeTrackerScopeState scope(this, connection_manager_.read_callbacks_->connection().dispatcher()); request_headers_ = std::move(headers); filter_manager_.requestHeadersInitialized(); if (request_header_timer_ != nullptr) { request_header_timer_->disableTimer(); request_header_timer_.reset(); } const Protocol protocol = connection_manager_.codec_->protocol(); if (Runtime::runtimeFeatureEnabled( ""envoy.reloadable_features.http1_connection_close_header_in_redirect"")) { if (HeaderUtility::shouldCloseConnection(protocol, *request_headers_)) { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true); } } else { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion( HeaderUtility::shouldCloseConnection(protocol, *request_headers_)); } filter_manager_.streamInfo().protocol(protocol); maybeEndDecode(end_stream); if (!validateHeaders()) { ENVOY_STREAM_LOG(debug, ""request headers validation failed\n{}"", *this, *request_headers_); return; } if (connection_manager_.config_.isRoutable()) { if (connection_manager_.config_.routeConfigProvider() != nullptr) { snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast(); } else if (connection_manager_.config_.scopedRouteConfigProvider() != nullptr && connection_manager_.config_.scopeKeyBuilder().has_value()) { snapped_scoped_routes_config_ = connection_manager_.config_.scopedRouteConfigProvider()->config<Router::ScopedConfig>(); snapScopedRouteConfig(); } } else { snapped_route_config_ = connection_manager_.config_.routeConfigProvider()->configCast(); } const bool drop_request_due_to_overload = (connection_manager_.accept_new_http_stream_ != nullptr && connection_manager_.accept_new_http_stream_->shouldShedLoad()) || connection_manager_.random_generator_.bernoulli( connection_manager_.overload_stop_accepting_requests_ref_.value()); if (drop_request_due_to_overload) { filter_manager_.skipFilterChainCreation(); connection_manager_.stats_.named_.downstream_rq_overload_close_.inc(); sendLocalReply(Http::Code::ServiceUnavailable, ""envoy overloaded"", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().Overload); return; } if (!connection_manager_.config_.proxy100Continue() && request_headers_->Expect() && absl::EqualsIgnoreCase((request_headers_->Expect()->value().getStringView()), Headers::get().ExpectValues._100Continue)) { chargeStats(continueHeader()); response_encoder_->encode1xxHeaders(continueHeader()); request_headers_->removeExpect(); } connection_manager_.user_agent_.initializeFromHeaders(*request_headers_, connection_manager_.stats_.prefixStatName(), connection_manager_.stats_.scope_); if (!request_headers_->Host()) { sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().MissingHost); return; } absl::optional<std::reference_wrapper<const absl::string_view>> error = HeaderUtility::requestHeadersValid(*request_headers_); if (error != absl::nullopt) { sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, error.value().get()); if (!response_encoder_->streamErrorOnInvalidHttpMessage()) { connection_manager_.handleCodecError(error.value().get()); } return; } if ((!HeaderUtility::isConnect(*request_headers_) || request_headers_->Path()) && request_headers_->getPathValue().empty()) { sendLocalReply(Code::NotFound, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().MissingPath); return; } if (Runtime::runtimeFeatureEnabled(""envoy.reloadable_features.enable_connect_udp_support"") && HeaderUtility::isConnectUdpRequest(*request_headers_) && !HeaderUtility::rewriteAuthorityForConnectUdp(*request_headers_)) { sendLocalReply(Code::NotFound, ""The path is incorrect for CONNECT-UDP"", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().InvalidPath); return; } if (!request_headers_->getPathValue().empty() && request_headers_->getPathValue()[0] != '/') { connection_manager_.stats_.named_.downstream_rq_non_relative_path_.inc(); sendLocalReply(Code::NotFound, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().AbsolutePath); return; } #ifndef ENVOY_ENABLE_UHV const auto action = ConnectionManagerUtility::maybeNormalizePath(*request_headers_, connection_manager_.config_); if (action == ConnectionManagerUtility::NormalizePathAction::Reject || (action == ConnectionManagerUtility::NormalizePathAction::Redirect && Grpc::Common::hasGrpcContentType(*request_headers_))) { connection_manager_.stats_.named_.downstream_rq_failed_path_normalization_.inc(); sendLocalReply(Code::BadRequest, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed); return; } else if (action == ConnectionManagerUtility::NormalizePathAction::Redirect) { connection_manager_.stats_.named_.downstream_rq_redirected_with_normalized_path_.inc(); sendLocalReply( Code::TemporaryRedirect, """", [new_path = request_headers_->Path()->value().getStringView()]( Http::ResponseHeaderMap& response_headers) -> void { response_headers.addReferenceKey(Http::Headers::get().Location, new_path); }, absl::nullopt, StreamInfo::ResponseCodeDetails::get().PathNormalizationFailed); return; } ASSERT(action == ConnectionManagerUtility::NormalizePathAction::Continue); #endif auto optional_port = ConnectionManagerUtility::maybeNormalizeHost( *request_headers_, connection_manager_.config_, localPort()); if (optional_port.has_value() && requestWasConnect(request_headers_, connection_manager_.codec_->protocol())) { filter_manager_.streamInfo().filterState()->setData( Router::OriginalConnectPort::key(), std::make_unique<Router::OriginalConnectPort>(optional_port.value()), StreamInfo::FilterState::StateType::ReadOnly, StreamInfo::FilterState::LifeSpan::Request); } if (!state_.is_internally_created_) {         const auto mutate_result = ConnectionManagerUtility::mutateRequestHeaders( *request_headers_, connection_manager_.read_callbacks_->connection(), connection_manager_.config_, *snapped_route_config_, connection_manager_.local_info_, filter_manager_.streamInfo()); if (mutate_result.reject_request.has_value()) { const auto& reject_request_params = mutate_result.reject_request.value(); connection_manager_.stats_.named_.downstream_rq_rejected_via_ip_detection_.inc(); sendLocalReply(reject_request_params.response_code, reject_request_params.body, nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().OriginalIPDetectionFailed); return; } filter_manager_.setDownstreamRemoteAddress(mutate_result.final_remote_address); } ASSERT(filter_manager_.streamInfo().downstreamAddressProvider().remoteAddress() != nullptr); ASSERT(!cached_route_); refreshCachedRoute(); if (!state_.is_internally_created_) {     filter_manager_.streamInfo().setTraceReason( ConnectionManagerUtility::mutateTracingRequestHeader( *request_headers_, connection_manager_.runtime_, connection_manager_.config_, cached_route_.value().get())); } filter_manager_.streamInfo().setRequestHeaders(*request_headers_); const bool upgrade_rejected = filter_manager_.createFilterChain() == false; if (connection_manager_.config_.flushAccessLogOnNewRequest()) { filter_manager_.log(AccessLog::AccessLogType::DownstreamStart); } if (hasCachedRoute()) { if (upgrade_rejected) { filter_manager_.streamInfo().setShouldDrainConnectionUponCompletion(true); connection_manager_.stats_.named_.downstream_rq_ws_on_non_ws_route_.inc(); sendLocalReply(Code::Forbidden, """", nullptr, absl::nullopt, StreamInfo::ResponseCodeDetails::get().UpgradeFailed); return; } } if (connection_manager_tracing_config_.has_value()) { traceRequest(); } filter_manager_.decodeHeaders(*request_headers_, end_stream); resetIdleTimer(); }"
static void uv__rwlock_fallback_wrlock(uv_rwlock_t* rwlock) { uv_mutex_lock(&rwlock->fallback_.write_mutex_); }
"static u_int16_t concat_hash_string(struct ndpi_packet_struct *packet, char *buf, u_int8_t client_hash) { u_int16_t offset = 22, buf_out_len = 0; if(offset+sizeof(u_int32_t) >= packet->payload_packet_len) goto invalid_payload; u_int32_t len = ntohl(*(u_int32_t*)&packet->payload[offset]); offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(buf, (const char *)&packet->payload[offset], buf_out_len = len); buf[buf_out_len++] = ';'; offset += len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; buf[buf_out_len++] = ';'; offset += len; } else offset += 4 + len; if(offset+sizeof(u_int32_t) >= packet->payload_packet_len) goto invalid_payload; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; offset += len; } else offset += 4 + len; len = ntohl(*(u_int32_t*)&packet->payload[offset]); if(!client_hash) { offset += 4; if((offset >= packet->payload_packet_len) || (len >= packet->payload_packet_len-offset-1)) goto invalid_payload; strncpy(&buf[buf_out_len], (const char *)&packet->payload[offset], len); buf_out_len += len; offset += len; } else offset += 4 + len; #ifdef SSH_DEBUG printf(""[SSH] %s\n"", buf); #endif return(buf_out_len); invalid_payload: #ifdef SSH_DEBUG printf(""[SSH] Invalid packet payload\n""); #endif return(0); }"
"static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list) { GF_Node *node; GF_Command *com; GF_CommandField *inf; node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode); if (!node) return GF_NON_COMPLIANT_BITSTREAM; if (codec->scenegraph->global_qp) { gf_node_unregister(codec->scenegraph->global_qp, NULL); } codec->ActiveQP = NULL; codec->scenegraph->global_qp = NULL; if (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) { gf_node_unregister(node, NULL); return GF_NON_COMPLIANT_BITSTREAM; } codec->ActiveQP = (M_QuantizationParameter *) node; codec->ActiveQP->isLocal = 0; codec->scenegraph->global_qp = node; node->sgprivate->num_instances = 2; com = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER); inf = gf_sg_command_field_new(com); inf->new_node = node; inf->field_ptr = &inf->new_node; inf->fieldType = GF_SG_VRML_SFNODE; gf_list_add(com_list, com); return GF_OK; }"
"int nfc_llcp_send_connect(struct nfc_llcp_sock *sock) { struct nfc_llcp_local *local; struct sk_buff *skb; u8 *service_name_tlv = NULL, service_name_tlv_length; u8 *miux_tlv = NULL, miux_tlv_length; u8 *rw_tlv = NULL, rw_tlv_length, rw; int err; u16 size = 0; __be16 miux; pr_debug(""Sending CONNECT\n""); local = sock->local; if (local == NULL) return -ENODEV; if (sock->service_name != NULL) { service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN, sock->service_name, sock->service_name_len, &service_name_tlv_length); size += service_name_tlv_length; } miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ? local->miux : sock->miux; rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw; miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0, &miux_tlv_length); size += miux_tlv_length; rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length); size += rw_tlv_length; pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len); skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size); if (skb == NULL) { err = -ENOMEM; goto error_tlv; } llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length); llcp_add_tlv(skb, miux_tlv, miux_tlv_length); llcp_add_tlv(skb, rw_tlv, rw_tlv_length); skb_queue_tail(&local->tx_queue, skb); err = 0; error_tlv: if (err) pr_err(""error %d\n"", err); kfree(service_name_tlv); kfree(miux_tlv); kfree(rw_tlv); return err; }"
"void HistoryController::UpdateForCommit(RenderFrameImpl* frame, const WebHistoryItem& item, WebHistoryCommitType commit_type, bool navigation_within_page) { switch (commit_type) { case blink::WebBackForwardCommit: if (!provisional_entry_) return; current_entry_.reset(provisional_entry_.release()); if (HistoryEntry::HistoryNode* node = current_entry_->GetHistoryNodeForFrame(frame)) { node->set_item(item); } break; case blink::WebStandardCommit: CreateNewBackForwardItem(frame, item, navigation_within_page); break; case blink::WebInitialCommitInChildFrame: UpdateForInitialLoadInChildFrame(frame, item); break; case blink::WebHistoryInertCommit: if (current_entry_) { if (HistoryEntry::HistoryNode* node = current_entry_->GetHistoryNodeForFrame(frame)) { if (!navigation_within_page) node->RemoveChildren(); node->set_item(item); } } break; default: NOTREACHED() << ""Invalid commit type: "" << commit_type; } }"
"AP4_HvccAtom::AP4_HvccAtom(AP4_UI32 size, const AP4_UI08* payload) : AP4_Atom(AP4_ATOM_TYPE_HVCC, size) { unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE; m_RawBytes.SetData(payload, payload_size); m_ConfigurationVersion   = payload[0]; m_GeneralProfileSpace    = (payload[1]>>6) & 0x03; m_GeneralTierFlag        = (payload[1]>>5) & 0x01; m_GeneralProfile         = (payload[1]   ) & 0x1F; m_GeneralProfileCompatibilityFlags = AP4_BytesToUInt32BE(&payload[2]); m_GeneralConstraintIndicatorFlags  = (((AP4_UI64)AP4_BytesToUInt32BE(&payload[6]))<<16) | AP4_BytesToUInt16BE(&payload[10]); m_GeneralLevel           = payload[12]; m_Reserved1              = (payload[13]>>4) & 0x0F; m_MinSpatialSegmentation = AP4_BytesToUInt16BE(&payload[13]) & 0x0FFF; m_Reserved2              = (payload[15]>>2) & 0x3F; m_ParallelismType        = payload[15] & 0x03; m_Reserved3              = (payload[16]>>2) & 0x3F; m_ChromaFormat           = payload[16] & 0x03; m_Reserved4              = (payload[17]>>3) & 0x1F; m_LumaBitDepth           = 8+(payload[17] & 0x07); m_Reserved5              = (payload[18]>>3) & 0x1F; m_ChromaBitDepth         = 8+(payload[18] & 0x07); m_AverageFrameRate       = AP4_BytesToUInt16BE(&payload[19]); m_ConstantFrameRate      = (payload[21]>>6) & 0x03; m_NumTemporalLayers      = (payload[21]>>3) & 0x07; m_TemporalIdNested       = (payload[21]>>2) & 0x01; m_NaluLengthSize         = 1+(payload[21] & 0x03); AP4_UI08 num_seq = payload[22]; m_Sequences.SetItemCount(num_seq); unsigned int cursor = 23; for (unsigned int i=0; i<num_seq; i++) { Sequence& seq = m_Sequences[i]; if (cursor+1 > payload_size) break; seq.m_ArrayCompleteness = (payload[cursor] >> 7) & 0x01; seq.m_Reserved          = (payload[cursor] >> 6) & 0x01; seq.m_NaluType          = payload[cursor] & 0x3F; cursor += 1; if (cursor+2 > payload_size) break; AP4_UI16 nalu_count = AP4_BytesToUInt16BE(&payload[cursor]); seq.m_Nalus.SetItemCount(nalu_count); cursor += 2; for (unsigned int j=0; j<nalu_count; j++) { if (cursor+2 > payload_size) break; unsigned int nalu_length = AP4_BytesToUInt16BE(&payload[cursor]); cursor += 2; if (cursor + nalu_length > payload_size) break; seq.m_Nalus[j].SetData(&payload[cursor], nalu_length); cursor += nalu_length; } } }"
int huffman_decode_step(HUFCODEC *phc) { int bit; int code = 0; int len  = 0; int idx  = 0; if (!phc->input) return EOF; while (1) { bit = bitstr_getb(phc->input); if ( bit == EOF) return EOF; code <<= 1; code |= bit; if (code - phc->first[len] < phc->huftab[len]) break; if (++len == MAX_HUFFMAN_CODE_LEN) return EOF; } idx = phc->index[len] + (code - phc->first[len]); return idx < MAX_HUFFMAN_CODE_LEN + 256 ? phc->huftab[idx] : EOF; }
"static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer) { struct bcm_op *op = container_of(hrtimer, struct bcm_op, timer); struct bcm_msg_head msg_head; if (op->kt_ival1 && (op->count > 0)) { op->count--; if (!op->count && (op->flags & TX_COUNTEVT)) { msg_head.opcode  = TX_EXPIRED; msg_head.flags   = op->flags; msg_head.count   = op->count; msg_head.ival1   = op->ival1; msg_head.ival2   = op->ival2; msg_head.can_id  = op->can_id; msg_head.nframes = 0; bcm_send_to_user(op, &msg_head, NULL, 0); } bcm_can_tx(op); } else if (op->kt_ival2) { bcm_can_tx(op); } return bcm_tx_set_expiry(op, &op->timer) ? HRTIMER_RESTART : HRTIMER_NORESTART; }"
"static void hap_free_p2m_page(struct domain *d, struct page_info *pg) { paging_lock_recursive(d); ASSERT(page_get_owner(pg) == d); if ( (pg->count_info & PGC_count_mask) != 1 ) { HAP_ERROR(""Odd p2m page %p count c=%#lx t=%""PRtype_info""\n"", pg, pg->count_info, pg->u.inuse.type_info); WARN(); } pg->count_info &= ~PGC_count_mask; page_set_owner(pg, NULL); d->arch.paging.hap.p2m_pages--; d->arch.paging.hap.total_pages++; hap_free(d, page_to_mfn(pg)); paging_unlock(d); }"
GF_Err chnl_box_size(GF_Box *s) { GF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s; s->size += 1; if (ptr->layout.stream_structure & 1) { s->size += 1; if (ptr->layout.definedLayout==0) { u32 i; for (i=0; i<ptr->layout.channels_count; i++) { s->size+=1; if (ptr->layout.layouts[i].position==126) s->size+=3; } } else { s->size += 8; } } if (ptr->layout.stream_structure & 2) { s->size += 1; } return GF_OK; }
"static void ttm_put_pages(struct page **pages, unsigned npages, int flags, enum ttm_caching_state cstate) { struct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate); #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate); #endif unsigned long irq_flags; unsigned i; if (pool == NULL) { i = 0; while (i < npages) { #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page *p = pages[i]; #endif unsigned order = 0, j; if (!pages[i]) { ++i; continue; } #ifdef CONFIG_TRANSPARENT_HUGEPAGE if (!(flags & TTM_PAGE_FLAG_DMA32)) { for (j = 0; j < HPAGE_PMD_NR; ++j) if (p++ != pages[i + j]) break; if (j == HPAGE_PMD_NR) order = HPAGE_PMD_ORDER; } #endif if (page_count(pages[i]) != 1) pr_err(""Erroneous page count. Leaking pages.\n""); __free_pages(pages[i], order); j = 1 << order; while (j) { pages[i++] = NULL; --j; } } return; } i = 0; #ifdef CONFIG_TRANSPARENT_HUGEPAGE if (huge) { unsigned max_size, n2free; spin_lock_irqsave(&huge->lock, irq_flags); while (i < npages) { struct page *p = pages[i]; unsigned j; if (!p) break; for (j = 0; j < HPAGE_PMD_NR; ++j) if (p++ != pages[i + j]) break; if (j != HPAGE_PMD_NR) break; list_add_tail(&pages[i]->lru, &huge->list); for (j = 0; j < HPAGE_PMD_NR; ++j) pages[i++] = NULL; huge->npages++; } max_size = _manager->options.max_size; max_size /= HPAGE_PMD_NR; if (huge->npages > max_size) n2free = huge->npages - max_size; else n2free = 0; spin_unlock_irqrestore(&huge->lock, irq_flags); if (n2free) ttm_page_pool_free(huge, n2free, false); } #endif spin_lock_irqsave(&pool->lock, irq_flags); while (i < npages) { if (pages[i]) { if (page_count(pages[i]) != 1) pr_err(""Erroneous page count. Leaking pages.\n""); list_add_tail(&pages[i]->lru, &pool->list); pages[i] = NULL; pool->npages++; } ++i; } npages = 0; if (pool->npages > _manager->options.max_size) { npages = pool->npages - _manager->options.max_size; if (npages < NUM_PAGES_TO_ALLOC) npages = NUM_PAGES_TO_ALLOC; } spin_unlock_irqrestore(&pool->lock, irq_flags); if (npages) ttm_page_pool_free(pool, npages, false); }"
"void dump_threads(void) { FILE *fp; char time_buf[26]; element e; vrrp_t *vrrp; char *file_name; file_name = make_file_name(""/tmp/thread_dump.dat"", ""vrrp"", #if HAVE_DECL_CLONE_NEWNET global_data->network_namespace, #else NULL, #endif global_data->instance_name); fp = fopen(file_name, ""a""); FREE(file_name); set_time_now(); ctime_r(&time_now.tv_sec, time_buf); fprintf(fp, ""\n%.19s.%6.6ld: Thread dump\n"", time_buf, time_now.tv_usec); dump_thread_data(master, fp); fprintf(fp, ""alloc = %lu\n"", master->alloc); fprintf(fp, ""\n""); LIST_FOREACH(vrrp_data->vrrp, vrrp, e) { ctime_r(&vrrp->sands.tv_sec, time_buf); fprintf(fp, ""VRRP instance %s, sands %.19s.%6.6lu, status %s\n"", vrrp->iname, time_buf, vrrp->sands.tv_usec, vrrp->state == VRRP_STATE_INIT ? ""INIT"" : vrrp->state == VRRP_STATE_BACK ? ""BACKUP"" : vrrp->state == VRRP_STATE_MAST ? ""MASTER"" : vrrp->state == VRRP_STATE_FAULT ? ""FAULT"" : vrrp->state == VRRP_STATE_STOP ? ""STOP"" : vrrp->state == VRRP_DISPATCHER ? ""DISPATCHER"" : ""unknown""); } fclose(fp); }"
"static int getInt(struct SWF_ACTIONPUSHPARAM *act) { switch( act->Type )  { case PUSH_FLOAT:  return ((int)act->p.Float); case PUSH_NULL:  return 0; case PUSH_REGISTER:  return getInt(regs[act->p.RegisterNumber]); case PUSH_DOUBLE:  return (int)act->p.Double; case PUSH_INT:  return act->p.Integer; default:  fprintf (stderr,""  Can't get int for type: %d\n"", act->Type); } return 0; }"
"void continuous_agg_refresh_internal(const ContinuousAgg *cagg, const InternalTimeRange *refresh_window_arg, const CaggRefreshCallContext callctx, const bool start_isnull, const bool end_isnull) { Catalog *catalog = ts_catalog_get(); int32 mat_id = cagg->data.mat_hypertable_id; InternalTimeRange refresh_window = *refresh_window_arg; int64 computed_invalidation_threshold; int64 invalidation_threshold; bool is_raw_ht_distributed; int rc; if ((rc = SPI_connect_ext(SPI_OPT_NONATOMIC) != SPI_OK_CONNECT)) elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc)); if (!pg_class_ownercheck(cagg->relid, GetUserId())) aclcheck_error(ACLCHECK_NOT_OWNER, get_relkind_objtype(get_rel_relkind(cagg->relid)), get_rel_name(cagg->relid)); PreventCommandIfReadOnly(REFRESH_FUNCTION_NAME); PreventInTransactionBlock(true, REFRESH_FUNCTION_NAME); Hypertable *ht = cagg_get_hypertable_or_fail(cagg->data.raw_hypertable_id); is_raw_ht_distributed = hypertable_is_distributed(ht); if (!(start_isnull && end_isnull)) { if (ts_continuous_agg_bucket_width_variable(cagg)) { refresh_window = *refresh_window_arg; ts_compute_inscribed_bucketed_refresh_window_variable(&refresh_window.start, &refresh_window.end, cagg->bucket_function); } else { refresh_window = compute_inscribed_bucketed_refresh_window(refresh_window_arg, ts_continuous_agg_bucket_width(cagg)); } } if (refresh_window.start >= refresh_window.end) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""refresh window too small""), errdetail(""The refresh window must cover at least one bucket of data.""), errhint(""Align the refresh window with the bucket"" "" time zone or use at least two buckets.""))); log_refresh_window(callctx == CAGG_REFRESH_POLICY ? LOG : DEBUG1, cagg, &refresh_window, ""refreshing continuous aggregate""); LockRelationOid(catalog_get_table_id(catalog, CONTINUOUS_AGGS_INVALIDATION_THRESHOLD), AccessExclusiveLock); computed_invalidation_threshold = invalidation_threshold_compute(cagg, &refresh_window); invalidation_threshold = invalidation_threshold_set_or_get(cagg->data.raw_hypertable_id, computed_invalidation_threshold); if (refresh_window.end > invalidation_threshold) refresh_window.end = invalidation_threshold; if (refresh_window.start >= refresh_window.end) { emit_up_to_date_notice(cagg, callctx); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); return; } const CaggsInfo all_caggs_info = ts_continuous_agg_get_all_caggs_info(cagg->data.raw_hypertable_id); if (is_raw_ht_distributed) { remote_invalidation_process_hypertable_log(cagg->data.mat_hypertable_id, cagg->data.raw_hypertable_id, refresh_window.type, &all_caggs_info); } else { invalidation_process_hypertable_log(cagg->data.mat_hypertable_id, cagg->data.raw_hypertable_id, refresh_window.type, &all_caggs_info); } SPI_commit_and_chain(); cagg = ts_continuous_agg_find_by_mat_hypertable_id(mat_id); if (!process_cagg_invalidations_and_refresh(cagg, &refresh_window, callctx, INVALID_CHUNK_ID)) emit_up_to_date_notice(cagg, callctx); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); }"
"static void add_capabilities (proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint8 pdu_type) { proto_tree *wsp_capabilities, *cap_subtree, *cap_subtree2; proto_item *ti, *cap_item, *cap_item2; char       *capaName, *str; guint32     offset       = 0; guint32     len          = 0; guint32     capaStart    = 0;  guint32     capaLen      = 0;  guint32     capaValueLen = 0;  guint32     tvb_len      = tvb_reported_length(tvb); gboolean    ok           = FALSE; guint8      peek; guint32     value; if (tvb_len == 0) { return; } ti = proto_tree_add_item(tree, hf_capabilities_section, tvb, 0, tvb_len, ENC_NA); wsp_capabilities = proto_item_add_subtree(ti, ett_capabilities); while (offset < tvb_len) { capaStart = offset; capaValueLen = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); capaLen = capaValueLen + len; cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, ""Capability""); offset += len; peek = tvb_get_guint8(tvb, offset); if (is_token_text(peek)) {  capaName = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, capaStart, (gint *)&len, ENC_ASCII); if (g_ascii_strcasecmp(capaName, ""client-sdu-size"") == 0) { peek = WSP_CAPA_CLIENT_SDU_SIZE; } else if (g_ascii_strcasecmp(capaName, ""server-sdu-size"") == 0) { peek = WSP_CAPA_SERVER_SDU_SIZE; } else if (g_ascii_strcasecmp(capaName, ""protocol options"") == 0) { peek = WSP_CAPA_PROTOCOL_OPTIONS; } else if (g_ascii_strcasecmp(capaName, ""method-mor"") == 0) { peek = WSP_CAPA_METHOD_MOR; } else if (g_ascii_strcasecmp(capaName, ""push-mor"") == 0) { peek = WSP_CAPA_PUSH_MOR; } else if (g_ascii_strcasecmp(capaName, ""extended methods"") == 0) { peek = WSP_CAPA_EXTENDED_METHODS; } else if (g_ascii_strcasecmp(capaName, ""header code pages"") == 0) { peek = WSP_CAPA_HEADER_CODE_PAGES; } else if (g_ascii_strcasecmp(capaName, ""aliases"") == 0) { peek = WSP_CAPA_ALIASES; } else if (g_ascii_strcasecmp(capaName, ""client-message-size"") == 0) { peek = WSP_CAPA_CLIENT_MESSAGE_SIZE; } else if (g_ascii_strcasecmp(capaName, ""server-message-size"") == 0) { peek = WSP_CAPA_SERVER_MESSAGE_SIZE; } else { expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Unknown or invalid textual capability: %s"", capaName); offset = capaStart + capaLen; continue; } offset += len; } else if (peek < 0x80) { expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Invalid well-known capability: 0x%02X"", peek); return; } if (peek & 0x80) {  peek &= 0x7F; len = 1; offset++; } proto_item_append_text(cap_item, "": %s"", val_to_str_const(peek, wsp_capability_vals, ""Invalid capabiliity"")); switch (peek) { case WSP_CAPA_CLIENT_SDU_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_client_sdu_size, tvb, offset, len, value); break; case WSP_CAPA_SERVER_SDU_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_server_sdu_size, tvb, offset, len, value); break; case WSP_CAPA_PROTOCOL_OPTIONS: if (capaValueLen - len == 1) { static const int * capabilities[] = { &hf_capa_protocol_option_confirmed_push, &hf_capa_protocol_option_push, &hf_capa_protocol_option_session_resume, &hf_capa_protocol_option_ack_headers, &hf_capa_protocol_option_large_data_transfer, NULL }; proto_tree_add_bitmask_with_flags(cap_subtree, tvb, offset, hf_capa_protocol_options, ett_proto_option_capability, capabilities, ENC_NA, BMT_NO_FALSE); } else { proto_item_append_text(cap_item, "" <warning: bit field too large>""); offset = capaStart + capaLen; continue; } break; case WSP_CAPA_METHOD_MOR: proto_tree_add_item(cap_subtree, hf_capa_method_mor, tvb, offset, len, ENC_NA); break; case WSP_CAPA_PUSH_MOR: proto_tree_add_item(cap_subtree, hf_capa_push_mor, tvb, offset, len, ENC_NA); break; case WSP_CAPA_EXTENDED_METHODS: cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_extended_methods, &cap_item2, ""Extended Methods""); if (pdu_type == WSP_PDU_CONNECT) { while (offset < capaStart + capaLen) { ti = proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA); offset++; get_text_string(str, tvb, offset, len, ok); if (! ok) { expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid); return; } proto_item_append_text(ti, "" = %s"", str); proto_item_set_len(ti, len+1); offset += len; } } else { while (offset < capaStart + capaLen) { proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA); offset++; } } break; case WSP_CAPA_HEADER_CODE_PAGES: cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_header_code_pages, &cap_item2, ""Header Code Pages""); if (pdu_type == WSP_PDU_CONNECT) { while (offset < capaStart + capaLen) { ti = proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA); offset++; get_text_string(str, tvb, offset, len, ok); if (! ok) { expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid); return; } proto_item_append_text(ti, "" = %s"", str); proto_item_set_len(ti, len+1); offset += len; } } else { while (offset < capaStart + capaLen) { proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA); offset++; } } break; case WSP_CAPA_ALIASES: proto_tree_add_item(cap_subtree, hf_capa_aliases, tvb, capaStart, capaLen, ENC_NA); break; case WSP_CAPA_CLIENT_MESSAGE_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_client_message_size, tvb, offset, len, value); break; case WSP_CAPA_SERVER_MESSAGE_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_server_message_size, tvb, offset, len, value); break; default: expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Unknown well-known capability: 0x%02X"", peek); break; } offset = capaStart + capaLen; } }"
"bool PDFDoc::setup(const GooString *ownerPassword, const GooString *userPassword) { pdfdocLocker(); if (str->getLength() <= 0) { error(errSyntaxError, -1, ""Document stream is empty""); return false; } str->setPos(0, -1); if (str->getPos() < 0) { error(errSyntaxError, -1, ""Document base stream is not seekable""); return false; } str->reset(); checkHeader(); bool wasReconstructed = false; xref = new XRef(str, getStartXRef(), getMainXRefEntriesOffset(), &wasReconstructed); if (!xref->isOk()) { if (wasReconstructed) { delete xref; startXRefPos = -1; xref = new XRef(str, getStartXRef(true), getMainXRefEntriesOffset(true), &wasReconstructed); } if (!xref->isOk()) { error(errSyntaxError, -1, ""Couldn't read xref table""); errCode = xref->getErrorCode(); return false; } } if (!checkEncryption(ownerPassword, userPassword)) { errCode = errEncrypted; return false; } catalog = new Catalog(this); if (catalog && !catalog->isOk()) { if (!wasReconstructed) { delete catalog; delete xref; xref = new XRef(str, 0, 0, nullptr, true); catalog = new Catalog(this); } if (catalog && !catalog->isOk()) { error(errSyntaxError, -1, ""Couldn't read page catalog""); errCode = errBadCatalog; return false; } } extractPDFSubtype(); return true; }"
"int main(int ac, char **av) { int c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0; int sock, fd, ch, result, saved_errno; u_int nalloc; char *shell, *format, *pidstr, *agentsocket = NULL; fd_set *readsetp = NULL, *writesetp = NULL; struct rlimit rlim; extern int optind; extern char *optarg; pid_t pid; char pidstrbuf[1 + 3 * sizeof pid]; struct timeval *tvp = NULL; size_t len; mode_t prev_mask; ssh_malloc_init(); sanitise_stdfd(); setegid(getgid()); setgid(getgid()); #ifdef WITH_OPENSSL OpenSSL_add_all_algorithms(); #endif while ((ch = getopt(ac, av, ""cDdksE:a:t:"")) != -1) { switch (ch) { case 'E': fingerprint_hash = ssh_digest_alg_by_name(optarg); if (fingerprint_hash == -1) fatal(""Invalid hash algorithm \""%s\"""", optarg); break; case 'c': if (s_flag) usage(); c_flag++; break; case 'k': k_flag++; break; case 's': if (c_flag) usage(); s_flag++; break; case 'd': if (d_flag || D_flag) usage(); d_flag++; break; case 'D': if (d_flag || D_flag) usage(); D_flag++; break; case 'a': agentsocket = optarg; break; case 't': if ((lifetime = convtime(optarg)) == -1) { fprintf(stderr, ""Invalid lifetime\n""); usage(); } break; default: usage(); } } ac -= optind; av += optind; if (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag)) usage(); if (ac == 0 && !c_flag && !s_flag) { shell = getenv(""SHELL""); if (shell != NULL && (len = strlen(shell)) > 2 && strncmp(shell + len - 3, ""csh"", 3) == 0) c_flag = 1; } if (k_flag) { const char *errstr = NULL; pidstr = getenv(SSH_AGENTPID_ENV_NAME); if (pidstr == NULL) { fprintf(stderr, ""%s not set, cannot kill agent\n"", SSH_AGENTPID_ENV_NAME); exit(1); } pid = (int)strtonum(pidstr, 2, INT_MAX, &errstr); if (errstr) { fprintf(stderr, ""%s=\""%s\"", which is not a good PID: %s\n"", SSH_AGENTPID_ENV_NAME, pidstr, errstr); exit(1); } if (kill(pid, SIGTERM) == -1) { perror(""kill""); exit(1); } format = c_flag ? ""unsetenv %s;\n"" : ""unset %s;\n""; printf(format, SSH_AUTHSOCKET_ENV_NAME); printf(format, SSH_AGENTPID_ENV_NAME); printf(""echo Agent pid %ld killed;\n"", (long)pid); exit(0); } parent_pid = getpid(); if (agentsocket == NULL) { mktemp_proto(socket_dir, sizeof(socket_dir)); if (mkdtemp(socket_dir) == NULL) { perror(""mkdtemp: private socket dir""); exit(1); } snprintf(socket_name, sizeof socket_name, ""%s/agent.%ld"", socket_dir, (long)parent_pid); } else { socket_dir[0] = '\0'; strlcpy(socket_name, agentsocket, sizeof socket_name); } prev_mask = umask(0177); sock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0); if (sock < 0) { *socket_name = '\0';  cleanup_exit(1); } umask(prev_mask); if (D_flag || d_flag) { log_init(__progname, d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 1); format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n""; printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name, SSH_AUTHSOCKET_ENV_NAME); printf(""echo Agent pid %ld;\n"", (long)parent_pid); fflush(stdout); goto skip; } pid = fork(); if (pid == -1) { perror(""fork""); cleanup_exit(1); } if (pid != 0) { close(sock); snprintf(pidstrbuf, sizeof pidstrbuf, ""%ld"", (long)pid); if (ac == 0) { format = c_flag ? ""setenv %s %s;\n"" : ""%s=%s; export %s;\n""; printf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name, SSH_AUTHSOCKET_ENV_NAME); printf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf, SSH_AGENTPID_ENV_NAME); printf(""echo Agent pid %ld;\n"", (long)pid); exit(0); } if (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 || setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) { perror(""setenv""); exit(1); } execvp(av[0], av); perror(av[0]); exit(1); } log_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0); if (setsid() == -1) { error(""setsid: %s"", strerror(errno)); cleanup_exit(1); } (void)chdir(""/""); if ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) { (void)dup2(fd, STDIN_FILENO); (void)dup2(fd, STDOUT_FILENO); (void)dup2(fd, STDERR_FILENO); if (fd > 2) close(fd); } rlim.rlim_cur = rlim.rlim_max = 0; if (setrlimit(RLIMIT_CORE, &rlim) < 0) { error(""setrlimit RLIMIT_CORE: %s"", strerror(errno)); cleanup_exit(1); } skip: cleanup_pid = getpid(); #ifdef ENABLE_PKCS11 pkcs11_init(0); #endif new_socket(AUTH_SOCKET, sock); if (ac > 0) parent_alive_interval = 10; idtab_init(); signal(SIGPIPE, SIG_IGN); signal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN); signal(SIGHUP, cleanup_handler); signal(SIGTERM, cleanup_handler); nalloc = 0; if (pledge(""stdio cpath unix id proc exec"", NULL) == -1) fatal(""%s: pledge: %s"", __progname, strerror(errno)); while (1) { prepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp); result = select(max_fd + 1, readsetp, writesetp, NULL, tvp); saved_errno = errno; if (parent_alive_interval != 0) check_parent_exists(); (void) reaper(); if (result < 0) { if (saved_errno == EINTR) continue; fatal(""select: %s"", strerror(saved_errno)); } else if (result > 0) after_select(readsetp, writesetp); } }"
"mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c) { mp_digit d; mp_err   err; if (a != c) { if ((err = mp_copy(a, c)) != MP_OKAY) { return err; } } if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) { if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } } if (b >= MP_DIGIT_BIT) { if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) { return err; } } d = (mp_digit)(b % MP_DIGIT_BIT); if (d != 0u) { mp_digit *tmpc, shift, mask, r, rr; int x; mask = ((mp_digit)1 << d) - (mp_digit)1; shift = (mp_digit)MP_DIGIT_BIT - d; tmpc = c->dp; r    = 0; for (x = 0; x < c->used; x++) { rr = (*tmpc >> shift) & mask; *tmpc = ((*tmpc << d) | r) & MP_MASK; ++tmpc; r = rr; } if (r != 0u) { c->dp[(c->used)++] = r; } } mp_clamp(c); return MP_OKAY; }"
"static int valid_length(uint8_t option, int dl, int *type) { const struct dhcp_opt *opt; ssize_t sz; if (dl == 0) return -1; for (opt = dhcp_opts; opt->option; opt++) { if (opt->option != option) continue; if (type) *type = opt->type; if (opt->type == 0 || opt->type & (STRING | RFC3442 | RFC5969)) return 0; sz = 0; if (opt->type & (UINT32 | IPV4)) sz = sizeof(uint32_t); if (opt->type & UINT16) sz = sizeof(uint16_t); if (opt->type & UINT8) sz = sizeof(uint8_t); if (opt->type & (IPV4 | ARRAY)) return dl % sz; return (dl == sz ? 0 : -1); } return 0; }"
void zmq::session_base_t::read_activated (pipe_t *pipe_) { if (unlikely (pipe_ != _pipe && pipe_ != _zap_pipe)) { zmq_assert (_terminating_pipes.count (pipe_) == 1); return; } if (unlikely (_engine == NULL)) { _pipe->check_read (); return; } if (likely (pipe_ == _pipe)) _engine->restart_output (); else { _engine->zap_msg_available (); } }
"static int clie_5_attach(struct usb_serial *serial) { struct usb_serial_port *port; unsigned int pipe; int j; if (serial->num_ports < 2) return -1; port = serial->port[0]; port->bulk_out_endpointAddress = serial->port[1]->bulk_out_endpointAddress; pipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress); for (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j) port->write_urbs[j]->pipe = pipe; return 0; }"
"void ResourceDispatcherHostImpl::BeginSaveFile(const GURL& url, const Referrer& referrer, SaveItemId save_item_id, SavePackageId save_package_id, int child_id, int render_view_route_id, int render_frame_route_id, ResourceContext* context) { if (is_shutdown_) return; request_id_--; const net::URLRequestContext* request_context = context->GetRequestContext(); bool known_proto = request_context->job_factory()->IsHandledURL(url); if (!known_proto) { NOTREACHED(); return; } std::unique_ptr<net::URLRequest> request( request_context->CreateRequest(url, net::DEFAULT_PRIORITY, NULL)); request->set_method(""GET""); SetReferrerForRequest(request.get(), referrer); request->SetLoadFlags(net::LOAD_PREFERRING_CACHE); ResourceRequestInfoImpl* extra_info = CreateRequestInfo(child_id, render_view_route_id, render_frame_route_id, false, context); extra_info->AssociateWithRequest(request.get());   std::unique_ptr<ResourceHandler> handler(new SaveFileResourceHandler( request.get(), save_item_id, save_package_id, child_id, render_frame_route_id, url, save_file_manager_.get())); BeginRequestInternal(std::move(request), std::move(handler)); }"
"void Compute(OpKernelContext* context) override { const Tensor& images = context->input(0); const Tensor& boxes = context->input(1); const int64 depth = images.dim_size(3); OP_REQUIRES(context, images.dims() == 4, errors::InvalidArgument(""The rank of the images should be 4"")); OP_REQUIRES( context, boxes.dims() == 3, errors::InvalidArgument(""The rank of the boxes tensor should be 3"")); OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0), errors::InvalidArgument(""The batch sizes should be the same"")); OP_REQUIRES( context, depth == 4 || depth == 1 || depth == 3, errors::InvalidArgument(""Channel depth should be either 1 (GRY), "" ""3 (RGB), or 4 (RGBA)"")); const int64 batch_size = images.dim_size(0); const int64 height = images.dim_size(1); const int64 width = images.dim_size(2); std::vector<std::vector<float>> color_table; if (context->num_inputs() == 3) { const Tensor& colors_tensor = context->input(2); OP_REQUIRES(context, colors_tensor.shape().dims() == 2, errors::InvalidArgument(""colors must be a 2-D matrix"", colors_tensor.shape().DebugString())); OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth, errors::InvalidArgument(""colors must have equal or more "", ""channels than the image provided: "", colors_tensor.shape().DebugString())); if (colors_tensor.NumElements() != 0) { color_table.clear(); auto colors = colors_tensor.matrix<float>(); for (int64 i = 0; i < colors.dimension(0); i++) { std::vector<float> color_value(4); for (int64 j = 0; j < 4; j++) { color_value[j] = colors(i, j); } color_table.emplace_back(color_value); } } } if (color_table.empty()) { color_table = DefaultColorTable(depth); } Tensor* output; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({batch_size, height, width, depth}), &output)); output->tensor<T, 4>() = images.tensor<T, 4>(); auto canvas = output->tensor<T, 4>(); for (int64 b = 0; b < batch_size; ++b) { const int64 num_boxes = boxes.dim_size(1); const auto tboxes = boxes.tensor<T, 3>(); for (int64 bb = 0; bb < num_boxes; ++bb) { int64 color_index = bb % color_table.size(); const int64 min_box_row = static_cast<float>(tboxes(b, bb, 0)) * (height - 1); const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0}); const int64 max_box_row = static_cast<float>(tboxes(b, bb, 2)) * (height - 1); const int64 max_box_row_clamp = std::min<int64>(max_box_row, height - 1); const int64 min_box_col = static_cast<float>(tboxes(b, bb, 1)) * (width - 1); const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0}); const int64 max_box_col = static_cast<float>(tboxes(b, bb, 3)) * (width - 1); const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1); if (min_box_row > max_box_row || min_box_col > max_box_col) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is inverted and will not be drawn.""; continue; } if (min_box_row >= height || max_box_row < 0 || min_box_col >= width || max_box_col < 0) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is completely outside the image"" << "" and will not be drawn.""; continue; } OP_REQUIRES( context, min_box_row_clamp >= 0, errors::InvalidArgument(""Min box row clamp is less than 0."")); OP_REQUIRES( context, max_box_row_clamp >= 0, errors::InvalidArgument(""Max box row clamp is less than 0."")); OP_REQUIRES(context, min_box_row_clamp <= height, errors::InvalidArgument( ""Min box row clamp is greater than height."")); OP_REQUIRES(context, max_box_row_clamp <= height, errors::InvalidArgument( ""Max box row clamp is greater than height."")); OP_REQUIRES( context, min_box_col_clamp >= 0, errors::InvalidArgument(""Min box col clamp is less than 0."")); OP_REQUIRES( context, max_box_col_clamp >= 0, errors::InvalidArgument(""Max box col clamp is less than 0."")); OP_REQUIRES(context, min_box_col_clamp <= width, errors::InvalidArgument( ""Min box col clamp is greater than width."")); OP_REQUIRES(context, max_box_col_clamp <= width, errors::InvalidArgument( ""Max box col clamp is greater than width."")); OP_REQUIRES( context, min_box_row <= height, errors::InvalidArgument(""Min box row is greater than height."")); OP_REQUIRES(context, max_box_row >= 0, errors::InvalidArgument(""Max box row is less than 0."")); OP_REQUIRES( context, min_box_col <= width, errors::InvalidArgument(""Min box col is greater than width."")); OP_REQUIRES(context, max_box_col >= 0, errors::InvalidArgument(""Max box col is less than 0."")); if (min_box_row >= 0) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, min_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_row < height) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, max_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (min_box_col >= 0) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, min_box_col, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_col < width) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, max_box_col, c) = static_cast<T>(color_table[color_index][c]); } } } } }"
"void motion_vectors_and_ref_indices(base_context* ctx, const slice_segment_header* shdr, de265_image* img, const PBMotionCoding& motion, int xC,int yC, int xB,int yB, int nCS, int nPbW,int nPbH, int partIdx, PBMotion* out_vi) { int xP = xC+xB; int yP = yC+yB; enum PredMode predMode = img->get_pred_mode(xC,yC); if (predMode == MODE_SKIP || (predMode == MODE_INTER && motion.merge_flag)) { derive_luma_motion_merge_mode(ctx,shdr,img, xC,yC, xP,yP, nCS,nPbW,nPbH, partIdx, motion.merge_idx, out_vi); logMV(xP,yP,nPbW,nPbH, ""merge_mode"", out_vi); } else { int mvdL[2][2]; MotionVector mvpL[2]; for (int l=0;l<2;l++) { enum InterPredIdc inter_pred_idc = (enum InterPredIdc)motion.inter_pred_idc; if (inter_pred_idc == PRED_BI || (inter_pred_idc == PRED_L0 && l==0) || (inter_pred_idc == PRED_L1 && l==1)) { out_vi->refIdx[l] = motion.refIdx[l]; out_vi->predFlag[l] = 1; } else { out_vi->refIdx[l] = -1; out_vi->predFlag[l] = 0; } mvdL[l][0] = motion.mvd[l][0]; mvdL[l][1] = motion.mvd[l][1]; if (out_vi->predFlag[l]) { mvpL[l] = luma_motion_vector_prediction(ctx,shdr,img,motion, xC,yC,nCS,xP,yP, nPbW,nPbH, l, out_vi->refIdx[l], partIdx); int32_t x = (mvpL[l].x + mvdL[l][0] + 0x10000) & 0xFFFF; int32_t y = (mvpL[l].y + mvdL[l][1] + 0x10000) & 0xFFFF; out_vi->mv[l].x = (x>=0x8000) ? x-0x10000 : x; out_vi->mv[l].y = (y>=0x8000) ? y-0x10000 : y; } } logMV(xP,yP,nPbW,nPbH, ""mvp"", out_vi); } }"
"static int get_floppy_geometry(int drive, int type, struct floppy_struct **g) { if (type) *g = &floppy_type[type]; else { if (lock_fdc(drive, false)) return -EINTR; if (poll_drive(false, 0) == -EINTR) return -EINTR; process_fd_request(); *g = current_type[drive]; } if (!*g) return -ENODEV; return 0; }"
"TfLiteStatus ResizeOutputTensor(TfLiteContext* context, const TfLiteTensor* data, const TfLiteTensor* segment_ids, TfLiteTensor* output) { int max_index = -1; const int segment_id_size = segment_ids->dims->data[0]; if (segment_id_size > 0) { max_index = segment_ids->data.i32[segment_id_size - 1]; } const int data_rank = NumDimensions(data); TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data)); output_shape->data[0] = max_index + 1; for (int i = 1; i < data_rank; ++i) { output_shape->data[i] = data->dims->data[i]; } return context->ResizeTensor(context, output, output_shape); }"
"int handle_nsExtendConfigTable(netsnmp_mib_handler          *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info   *reqinfo, netsnmp_request_info         *requests) { netsnmp_request_info       *request; netsnmp_table_request_info *table_info; netsnmp_extend             *extension; extend_registration_block  *eptr; int  i; int  need_to_validate = 0; for ( request=requests; request; request=request->next ) { if (request->processed) continue; table_info = netsnmp_extract_table_info( request ); extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request ); DEBUGMSGTL(( ""nsExtendTable:config"", ""varbind: "")); DEBUGMSGOID((""nsExtendTable:config"", request->requestvb->name, request->requestvb->name_length)); DEBUGMSG((   ""nsExtendTable:config"", "" (%s)\n"", se_find_label_in_slist(""agent_mode"", reqinfo->mode))); switch (reqinfo->mode) { case MODE_GET: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->command, (extension->command)?strlen(extension->command):0); break; case COLUMN_EXTCFG_ARGS: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->args, (extension->args)?strlen(extension->args):0); break; case COLUMN_EXTCFG_INPUT: snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR, extension->input, (extension->input)?strlen(extension->input):0); break; case COLUMN_EXTCFG_CACHETIME: snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&extension->cache->timeout, sizeof(int)); break; case COLUMN_EXTCFG_EXECTYPE: i = ((extension->flags & NS_EXTEND_FLAGS_SHELL) ? NS_EXTEND_ETYPE_SHELL : NS_EXTEND_ETYPE_EXEC); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_RUNTYPE: i = ((extension->flags & NS_EXTEND_FLAGS_WRITEABLE) ? NS_EXTEND_RTYPE_RWRITE : NS_EXTEND_RTYPE_RONLY); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_STORAGE: i = ((extension->flags & NS_EXTEND_FLAGS_CONFIG) ? ST_PERMANENT : ST_VOLATILE); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; case COLUMN_EXTCFG_STATUS: i = ((extension->flags & NS_EXTEND_FLAGS_ACTIVE) ? RS_ACTIVE : RS_NOTINSERVICE); snmp_set_var_typed_value( request->requestvb, ASN_INTEGER, (u_char*)&i, sizeof(i)); break; default: netsnmp_set_request_error(reqinfo, request, SNMP_NOSUCHOBJECT); continue; } break; #ifndef NETSNMP_NO_WRITE_SUPPORT case MODE_SET_RESERVE1: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: if (request->requestvb->type != ASN_OCTET_STR) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } if (request->requestvb->val_len == 0 || request->requestvb->val.string[0] != '/') { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_ARGS: case COLUMN_EXTCFG_INPUT: if (request->requestvb->type != ASN_OCTET_STR) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_CACHETIME: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i < -1 ) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } break; case COLUMN_EXTCFG_EXECTYPE: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i<1 || i>2) {   netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case COLUMN_EXTCFG_RUNTYPE: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; if (i<1 || i>3) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } if (i==3 && !(extension && (extension->flags & NS_EXTEND_FLAGS_WRITEABLE))) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } if ((extension && extension->flags & NS_EXTEND_FLAGS_CONFIG) && i!=3 ) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break; case COLUMN_EXTCFG_STATUS: if (request->requestvb->type != ASN_INTEGER) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGTYPE); return SNMP_ERR_WRONGTYPE; } i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_NOTINSERVICE: if (!extension) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break;     case RS_CREATEANDGO: case RS_CREATEANDWAIT: if (extension) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } break; case RS_DESTROY: break; default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_WRONGVALUE); return SNMP_ERR_WRONGVALUE; } break; default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_NOTWRITABLE); return SNMP_ERR_NOTWRITABLE; } break; case MODE_SET_RESERVE2: switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); extension = _new_extension( (char *) table_info->indexes->val.string, 0, eptr ); if (!extension) {   netsnmp_set_request_error(reqinfo, request, SNMP_ERR_RESOURCEUNAVAILABLE); return SNMP_ERR_RESOURCEUNAVAILABLE; } netsnmp_insert_table_row( request, extension->row ); } } break; case MODE_SET_FREE: switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); } } break; case MODE_SET_ACTION: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: extension->old_command = extension->command; extension->command = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_ARGS: extension->old_args = extension->args; extension->args = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_INPUT: extension->old_input = extension->input; extension->input = netsnmp_strdup_and_null( request->requestvb->val.string, request->requestvb->val_len); break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_CREATEANDGO: need_to_validate = 1; } break; } break; case MODE_SET_UNDO: switch (table_info->colnum) { case COLUMN_EXTCFG_COMMAND: if ( extension && extension->old_command ) { SNMP_FREE(extension->command); extension->command     = extension->old_command; extension->old_command = NULL; } break; case COLUMN_EXTCFG_ARGS: if ( extension && extension->old_args ) { SNMP_FREE(extension->args); extension->args     = extension->old_args; extension->old_args = NULL; } break; case COLUMN_EXTCFG_INPUT: if ( extension && extension->old_input ) { SNMP_FREE(extension->input); extension->input     = extension->old_input; extension->old_input = NULL; } break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_CREATEANDGO: case RS_CREATEANDWAIT: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); } break; } break; case MODE_SET_COMMIT: switch (table_info->colnum) { case COLUMN_EXTCFG_CACHETIME: i = *request->requestvb->val.integer; extension->cache->timeout = i; break; case COLUMN_EXTCFG_RUNTYPE: i = *request->requestvb->val.integer; switch (i) { case 1: extension->flags &= ~NS_EXTEND_FLAGS_WRITEABLE; break; case 2: extension->flags |=  NS_EXTEND_FLAGS_WRITEABLE; break; case 3: (void)netsnmp_cache_check_and_reload( extension->cache ); break; } break; case COLUMN_EXTCFG_EXECTYPE: i = *request->requestvb->val.integer; if ( i == NS_EXTEND_ETYPE_SHELL ) extension->flags |=  NS_EXTEND_FLAGS_SHELL; else extension->flags &= ~NS_EXTEND_FLAGS_SHELL; break; case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; switch (i) { case RS_ACTIVE: case RS_CREATEANDGO: extension->flags |= NS_EXTEND_FLAGS_ACTIVE; break; case RS_NOTINSERVICE: case RS_CREATEANDWAIT: extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE; break; case RS_DESTROY: eptr = _find_extension_block( request->requestvb->name, request->requestvb->name_length ); _free_extension( extension, eptr ); break; } } break; #endif   default: netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR); return SNMP_ERR_GENERR; } } #ifndef NETSNMP_NO_WRITE_SUPPORT if (need_to_validate) { for ( request=requests; request; request=request->next ) { if (request->processed) continue; table_info = netsnmp_extract_table_info( request ); extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request ); switch (table_info->colnum) { case COLUMN_EXTCFG_STATUS: i = *request->requestvb->val.integer; if (( i == RS_ACTIVE || i == RS_CREATEANDGO ) && !(extension && extension->command && extension->command[0] == '/' )) { netsnmp_set_request_error(reqinfo, request, SNMP_ERR_INCONSISTENTVALUE); return SNMP_ERR_INCONSISTENTVALUE; } } } } #endif  return SNMP_ERR_NOERROR; }"
"static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile, size_t len, const struct iov_iter *it) { struct sk_buff *skb; size_t linear; int err; int i; if (it->nr_segs > MAX_SKB_FRAGS + 1) return ERR_PTR(-EMSGSIZE); local_bh_disable(); skb = napi_get_frags(&tfile->napi); local_bh_enable(); if (!skb) return ERR_PTR(-ENOMEM); linear = iov_iter_single_seg_count(it); err = __skb_grow(skb, linear); if (err) goto free; skb->len = len; skb->data_len = len - linear; skb->truesize += skb->data_len; for (i = 1; i < it->nr_segs; i++) { size_t fragsz = it->iov[i].iov_len; struct page *page; void *frag; if (fragsz == 0 || fragsz > PAGE_SIZE) { err = -EINVAL; goto free; } frag = netdev_alloc_frag(fragsz); if (!frag) { err = -ENOMEM; goto free; } page = virt_to_head_page(frag); skb_fill_page_desc(skb, i - 1, page, frag - page_address(page), fragsz); } return skb; free: napi_free_frags(&tfile->napi); return ERR_PTR(err); }"
"BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it) { NDEF_SUPPORT *ndef_aux = NULL; BIO *asn_bio = NULL; const ASN1_AUX *aux = it->funcs; ASN1_STREAM_ARG sarg; if (!aux || !aux->asn1_cb) { ERR_raise(ERR_LIB_ASN1, ASN1_R_STREAMING_NOT_SUPPORTED); return NULL; } ndef_aux = OPENSSL_zalloc(sizeof(*ndef_aux)); asn_bio = BIO_new(BIO_f_asn1()); if (ndef_aux == NULL || asn_bio == NULL) goto err; out = BIO_push(asn_bio, out); if (out == NULL) goto err; BIO_asn1_set_prefix(asn_bio, ndef_prefix, ndef_prefix_free); BIO_asn1_set_suffix(asn_bio, ndef_suffix, ndef_suffix_free); sarg.out = out; sarg.ndef_bio = NULL; sarg.boundary = NULL; if (aux->asn1_cb(ASN1_OP_STREAM_PRE, &val, it, &sarg) <= 0) goto err; ndef_aux->val = val; ndef_aux->it = it; ndef_aux->ndef_bio = sarg.ndef_bio; ndef_aux->boundary = sarg.boundary; ndef_aux->out = out; BIO_ctrl(asn_bio, BIO_C_SET_EX_ARG, 0, ndef_aux); return sarg.ndef_bio; err: BIO_free(asn_bio); OPENSSL_free(ndef_aux); return NULL; }"
"int main(int argc, char *argv[]) { AACENC_CONFIG config; WavInfo inputInfo; FILE *inputFile; FILE *hADTSFile; int error; int bitrate; int nChannelsAAC, nChannelsSBR; unsigned int sampleRateAAC; int frmCnt; int bandwidth = 0; unsigned int numAncDataBytes = 0; unsigned char ancDataBytes[MAX_PAYLOAD_SIZE]; unsigned int ancDataLength = 0; short TimeDataPcm[AACENC_BLOCKSIZE * 2 * MAX_CHANNELS]; int numSamplesRead; int bDoIIR2Downsample = 0; int bDingleRate = 0; int useParametricStereo = 0; int coreWriteOffset = 0; int coreReadOffset = 0; int envWriteOffset = 0; int envReadOffset = 0; int writeOffset = INPUT_DELAY * MAX_CHANNELS; int percent = -1; struct AAC_ENCODER *aacEnc = 0; int bDoUpsample = 0; int upsampleReadOffset = 0; int inSamples; int bDoIIR32Resample = 0; int nSamplesPerChannel; const int nRuns = 4; float *resamplerScratch = sbr_envRBuffer; HANDLE_SBR_ENCODER hEnvEnc = NULL; fprintf(stderr, ""\n"" ""*************************************************************\n"" ""* Enhanced aacPlus Encoder\n"" ""* Build %s, %s\n"" ""* Matteo Croce <rootkit85@yahoo.it>\n"" ""*************************************************************\n\n"", __DATE__, __TIME__); if (argc != 4) { fprintf(stderr, ""\nUsage:   %s <source.wav> <destination.aac> <bitrate>\n"", argv[0]); fprintf(stderr, ""\nUse - as filename for stdin and/or stdout.\n""); fprintf(stderr, ""\nExample: %s song.wav song.aac 32\n"", argv[0]); return 0; } bitrate = atoi(argv[3]) * 1000;; fflush(stderr); inputFile = AuChannelOpen(argv[1], &inputInfo); if (!inputFile) { fprintf(stderr, ""could not open %s\n"", argv[1]); exit(10); } AacInitDefaultConfig(&config); nChannelsAAC = nChannelsSBR = inputInfo.nChannels; if ((inputInfo.nChannels == 2) && (bitrate >= 16000) && (bitrate < 44001)) useParametricStereo = 1; if (useParametricStereo) { nChannelsAAC = 1; nChannelsSBR = 2; } if (((inputInfo.sampleRate == 48000) && (nChannelsAAC == 2) && (bitrate < 24000)) || ((inputInfo.sampleRate == 48000) && (nChannelsAAC == 1) && (bitrate < 12000)) ) bDoIIR32Resample = 1; if (inputInfo.sampleRate == 16000) { bDoUpsample = 1; inputInfo.sampleRate = 32000; bDingleRate = 1; } sampleRateAAC = inputInfo.sampleRate; if (bDoIIR32Resample) sampleRateAAC = 32000; config.bitRate = bitrate; config.nChannelsIn = inputInfo.nChannels; config.nChannelsOut = nChannelsAAC; config.bandWidth = bandwidth; if (!IsSbrSettingAvail (bitrate, nChannelsAAC, sampleRateAAC, &sampleRateAAC)) { fprintf(stderr, ""No valid SBR configuration found for:\n\t\t\tbitrate=%d\n\t\t\tchannels=%d\n\t\t\tsamplerate=%d\n"", bitrate, nChannelsAAC, sampleRateAAC); exit(10); } { sbrConfiguration sbrConfig; envReadOffset = 0; coreWriteOffset = 0; if (useParametricStereo) { envReadOffset = (MAX_DS_FILTER_DELAY + INPUT_DELAY) * MAX_CHANNELS; coreWriteOffset = CORE_INPUT_OFFSET_PS; writeOffset = envReadOffset; } InitializeSbrDefaults(&sbrConfig); sbrConfig.usePs = useParametricStereo; AdjustSbrSettings(&sbrConfig, bitrate, nChannelsAAC, sampleRateAAC, AACENC_TRANS_FAC, 24000); EnvOpen(&hEnvEnc, inputBuffer + coreWriteOffset, &sbrConfig, &config.bandWidth); bDoIIR2Downsample = (bDoUpsample) ? 0 : 1; if (useParametricStereo) bDoIIR2Downsample = 0; } if (bDoUpsample) { if (inputInfo.nChannels > 1) { fprintf(stderr, ""\n Stereo @ 16kHz input sample rate is not supported\n""); return -1; } InitIIR21_Resampler(IIR21_reSampler); InitIIR21_Resampler(IIR21_reSampler + 1); assert(IIR21_reSampler[0].delay <= MAX_DS_FILTER_DELAY); if (useParametricStereo) { writeOffset += AACENC_BLOCKSIZE * MAX_CHANNELS; upsampleReadOffset = writeOffset; envWriteOffset = envReadOffset; } else { writeOffset += AACENC_BLOCKSIZE * MAX_CHANNELS; coreReadOffset = writeOffset; upsampleReadOffset = writeOffset - (((INPUT_DELAY -  IIR21_reSampler[0].delay) >> 1) * MAX_CHANNELS); envWriteOffset = ((INPUT_DELAY - IIR21_reSampler[0].delay) & 0x1) * MAX_CHANNELS; envReadOffset = 0; } } else if (bDoIIR2Downsample) { InitIIR21_Resampler(IIR21_reSampler); InitIIR21_Resampler(IIR21_reSampler + 1); assert(IIR21_reSampler[0].delay <= MAX_DS_FILTER_DELAY); writeOffset += IIR21_reSampler[0].delay * MAX_CHANNELS; } if (bDoIIR32Resample) IIR32Init(); config.sampleRate = sampleRateAAC; error = AacEncOpen(&aacEnc, config); if (error) { fprintf(stderr, ""\n Initialisation of AAC failed !\n""); AacEncClose(aacEnc); AuChannelClose(inputFile); return 1; } if (strcmp(argv[2], ""-"") == 0) hADTSFile = stdout; else hADTSFile = fopen(argv[2], ""wb""); if (!hADTSFile) { fprintf(stderr, ""\nFailed to create ADTS file\n""); exit(10); } fprintf(stderr, ""input file %s: \nsr = %d, nc = %d\n\n"", argv[1], inputInfo.sampleRate, inputInfo.nChannels); fprintf(stderr, ""output file %s: \nbr = %d sr-OUT = %d  nc-OUT = %d\n\n"", argv[2], bitrate, sampleRateAAC * 2, nChannelsSBR); fflush(stderr); init_plans(); frmCnt = 0; memset(TimeDataPcm, 0, sizeof(TimeDataPcm)); if (bDoIIR32Resample) { inSamples = IIR32GetResamplerFeed(AACENC_BLOCKSIZE *  inputInfo.nChannels * 2) / nRuns; assert(inSamples <= AACENC_BLOCKSIZE * 2); } else { inSamples = AACENC_BLOCKSIZE * inputInfo.nChannels * 2; if (bDoUpsample) inSamples = inSamples >> 1; } adts_hdr(outputBuffer, &config); while (1) { int i, ch, outSamples, numOutBytes, newpercent = -1; if (bDoIIR32Resample) { int stopLoop = 0; int nSamplesProcessed = 0; int r; const int nDSOutBlockSize = AACENC_BLOCKSIZE * 2 / nRuns; int stride = inputInfo.nChannels; if (inputInfo.nChannels == 1) stride = 2; for (r = 0; r < nRuns; r++) { if (AuChannelReadShort(inputFile, TimeDataPcm,  inSamples, &numSamplesRead)) { stopLoop = 1; break; } for (i = 0; i < numSamplesRead; i++) resamplerScratch[i] = (float)TimeDataPcm[i]; switch (inputInfo.nChannels) { case 1: nSamplesPerChannel = numSamplesRead; break; case 2: nSamplesPerChannel = numSamplesRead >> 1; break; default: nSamplesPerChannel = numSamplesRead / inputInfo.nChannels; } nSamplesProcessed += IIR32Resample(resamplerScratch, &inputBuffer[writeOffset +  r * nDSOutBlockSize * stride], nSamplesPerChannel, nDSOutBlockSize, inputInfo.nChannels); if (inputInfo.nChannels == 1 && stride == 2) for (i = nDSOutBlockSize - 1; i >= 0;  i--) inputBuffer[writeOffset + r * nDSOutBlockSize * 2 + 2 * i] = inputBuffer[writeOffset + r * nDSOutBlockSize * 2 + i]; } if (stopLoop) break; numSamplesRead = nSamplesProcessed; } else { if (AuChannelReadShort(inputFile, TimeDataPcm, inSamples, &numSamplesRead)) break; if (inputInfo.nChannels == nChannelsSBR) for (i = 0; i < numSamplesRead; i++) inputBuffer[i + writeOffset] = (float)TimeDataPcm[i]; if (inputInfo.nChannels == 1) for (i = 0; i < numSamplesRead; i++) inputBuffer[writeOffset + 2 * i] = (float)TimeDataPcm[i]; if ((inputInfo.nChannels == 2) && bEncodeMono) for (i = 0; i < numSamplesRead / 2; i++) inputBuffer[writeOffset + 2 * i] = ((float)TimeDataPcm[2 * i] + (float)TimeDataPcm[2 * i + 1]) * 0.5f; } if (bDoUpsample) for (ch = 0; ch < inputInfo.nChannels; ch++) IIR21_Upsample(&(IIR21_reSampler[ch]), inputBuffer + upsampleReadOffset + ch, numSamplesRead / inputInfo.nChannels, MAX_CHANNELS, inputBuffer + envWriteOffset + ch, &outSamples, MAX_CHANNELS); EnvEncodeFrame(hEnvEnc, inputBuffer + envReadOffset, inputBuffer + coreWriteOffset, MAX_CHANNELS, &numAncDataBytes, ancDataBytes); if (bDoIIR2Downsample) for (ch = 0; ch < nChannelsAAC; ch++) IIR21_Downsample(&(IIR21_reSampler[ch]), inputBuffer + writeOffset + ch, numSamplesRead / inputInfo.nChannels, MAX_CHANNELS, inputBuffer + ch, &outSamples, MAX_CHANNELS); if (numAncDataBytes == 0) numAncDataBytes = ancDataLength; if (hEnvEnc && useParametricStereo) { AacEncEncode(aacEnc, inputBuffer, 1, ancDataBytes, &numAncDataBytes, (unsigned *)(outputBuffer + ADTS_HEADER_SIZE), &numOutBytes); if (hEnvEnc) memcpy(inputBuffer, inputBuffer + AACENC_BLOCKSIZE, CORE_INPUT_OFFSET_PS * sizeof(float)); } else { AacEncEncode(aacEnc, inputBuffer + coreReadOffset, MAX_CHANNELS, ancDataBytes, &numAncDataBytes, (unsigned *)(outputBuffer + ADTS_HEADER_SIZE), &numOutBytes); if (hEnvEnc) { if (bDoUpsample) { memmove(&inputBuffer[envReadOffset], &inputBuffer[envReadOffset +  AACENC_BLOCKSIZE * MAX_CHANNELS * 2], (envWriteOffset - envReadOffset) * sizeof(float)); memmove(&inputBuffer [upsampleReadOffset], &inputBuffer[upsampleReadOffset + AACENC_BLOCKSIZE * MAX_CHANNELS], (writeOffset - upsampleReadOffset) * sizeof(float)); } else memmove(inputBuffer, inputBuffer + AACENC_BLOCKSIZE * 2 * MAX_CHANNELS, writeOffset * sizeof(float)); } } if (numOutBytes) { adts_hdr_up(outputBuffer, numOutBytes); fwrite(outputBuffer, 1, numOutBytes + ADTS_HEADER_SIZE, hADTSFile); } frmCnt++; if (inputInfo.nSamples > 0) { newpercent = frmCnt * AACENC_BLOCKSIZE * inputInfo.nChannels / (inputInfo.nSamples / (4 * 100)); } if (newpercent != percent) { percent = newpercent; fprintf(stderr, ""[%d%%]\r"", newpercent); fflush(stderr); } } fprintf(stderr, ""\n""); fflush(stderr); if (numSamplesRead > 0) { AacEncClose(aacEnc); } AuChannelClose(inputFile); destroy_plans(); if (hEnvEnc) EnvClose(hEnvEnc); fprintf(stderr, ""\nencoding finished\n""); fflush(stderr); return 0; }"
"void gru_check_context_placement(struct gru_thread_state *gts) { struct gru_state *gru; gru = gts->ts_gru; if (!gru || gts->ts_tgid_owner != current->tgid) return; if (!gru_check_chiplet_assignment(gru, gts)) { STAT(check_context_unload); gru_unload_context(gts, 1); } else if (gru_retarget_intr(gts)) { STAT(check_context_retarget_intr); } }"
"static void polkit_backend_interactive_authority_check_authorization (PolkitBackendAuthority         *authority, PolkitSubject                  *caller, PolkitSubject                  *subject, const gchar                    *action_id, PolkitDetails                  *details, PolkitCheckAuthorizationFlags   flags, GCancellable                   *cancellable, GAsyncReadyCallback             callback, gpointer                        user_data) { PolkitBackendInteractiveAuthority *interactive_authority; PolkitBackendInteractiveAuthorityPrivate *priv; gchar *caller_str; gchar *subject_str; PolkitIdentity *user_of_caller; PolkitIdentity *user_of_subject; gchar *user_of_caller_str; gchar *user_of_subject_str; PolkitAuthorizationResult *result; PolkitImplicitAuthorization implicit_authorization; GError *error; GSimpleAsyncResult *simple; gboolean has_details; gchar **detail_keys; interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority); priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority); error = NULL; caller_str = NULL; subject_str = NULL; user_of_caller = NULL; user_of_subject = NULL; user_of_caller_str = NULL; user_of_subject_str = NULL; result = NULL; simple = g_simple_async_result_new (G_OBJECT (authority), callback, user_data, polkit_backend_interactive_authority_check_authorization); if (caller == NULL) { GDBusConnection *system_bus; system_bus = g_bus_get_sync (G_BUS_TYPE_SYSTEM, NULL, NULL); caller = polkit_system_bus_name_new (g_dbus_connection_get_unique_name (system_bus)); g_object_unref (system_bus); } caller_str = polkit_subject_to_string (caller); subject_str = polkit_subject_to_string (subject); g_debug (""%s is inquiring whether %s is authorized for %s"", caller_str, subject_str, action_id); user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, &error); if (error != NULL) { g_simple_async_result_set_from_error (simple, error); g_simple_async_result_complete (simple); g_object_unref (simple); g_error_free (error); goto out; } user_of_caller_str = polkit_identity_to_string (user_of_caller); g_debug ("" user of caller is %s"", user_of_caller_str); user_of_subject = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, subject, &error); if (error != NULL) { g_simple_async_result_set_from_error (simple, error); g_simple_async_result_complete (simple); g_object_unref (simple); g_error_free (error); goto out; } user_of_subject_str = polkit_identity_to_string (user_of_subject); g_debug ("" user of subject is %s"", user_of_subject_str); has_details = FALSE; if (details != NULL) { detail_keys = polkit_details_get_keys (details); if (detail_keys != NULL) { if (g_strv_length (detail_keys) > 0) has_details = TRUE; g_strfreev (detail_keys); } } if (!polkit_identity_equal (user_of_caller, user_of_subject) || has_details) { if (!may_identity_check_authorization (interactive_authority, action_id, user_of_caller)) { if (has_details) { g_simple_async_result_set_error (simple, POLKIT_ERROR, POLKIT_ERROR_NOT_AUTHORIZED, ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() and "" ""pass details""); } else { g_simple_async_result_set_error (simple, POLKIT_ERROR, POLKIT_ERROR_NOT_AUTHORIZED, ""Only trusted callers (e.g. uid 0 or an action owner) can use CheckAuthorization() for "" ""subjects belonging to other identities""); } g_simple_async_result_complete (simple); g_object_unref (simple); goto out; } } implicit_authorization = POLKIT_IMPLICIT_AUTHORIZATION_NOT_AUTHORIZED; result = check_authorization_sync (authority, caller, subject, action_id, details, flags, &implicit_authorization, FALSE,  &error); if (error != NULL) { g_simple_async_result_set_from_error (simple, error); g_simple_async_result_complete (simple); g_object_unref (simple); g_error_free (error); goto out; } if (polkit_authorization_result_get_is_challenge (result) && (flags & POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION)) { AuthenticationAgent *agent; agent = get_authentication_agent_for_subject (interactive_authority, subject); if (agent != NULL) { g_object_unref (result); result = NULL; g_debug ("" using authentication agent for challenge""); authentication_agent_initiate_challenge (agent, subject, user_of_subject, interactive_authority, action_id, details, caller, implicit_authorization, cancellable, check_authorization_challenge_cb, simple); goto out; } } g_simple_async_result_set_op_res_gpointer (simple, g_object_ref (result), g_object_unref); g_simple_async_result_complete (simple); g_object_unref (simple); out: if (user_of_caller != NULL) g_object_unref (user_of_caller); if (user_of_subject != NULL) g_object_unref (user_of_subject); g_free (caller_str); g_free (subject_str); g_free (user_of_caller_str); g_free (user_of_subject_str); if (result != NULL) g_object_unref (result); }"
"static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id) { struct snd_msnd *chip = dev_id; void *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF; while (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) { u16 wTmp; snd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead))); wTmp = readw(chip->DSPQ + JQS_wHead) + 1; if (wTmp > readw(chip->DSPQ + JQS_wSize)) writew(0, chip->DSPQ + JQS_wHead); else writew(wTmp, chip->DSPQ + JQS_wHead); } inb(chip->io + HP_RXL); return IRQ_HANDLED; }"
"guint8 * get_t61_string(wmem_allocator_t *scope, const guint8 *ptr, gint length) { gint           i; guint8        *c; wmem_strbuf_t *strbuf; strbuf = wmem_strbuf_sized_new(scope, length+1, 0); for (i = 0, c = (guint8 *)ptr; i < length; c++, i++) { if (!t61_tab[*c]) { wmem_strbuf_append_unichar(strbuf, UNREPL); } else if ((*c & 0xf0) == 0xc0) { gint j = *c & 0x0f; if ((!c[1] || c[1] == 0x20) && accents[j]) { wmem_strbuf_append_unichar(strbuf, accents[j]); } else if (cx_tab[j] && cx_tab[j][c[1]>>5] && (*cx_tab[j][c[1]>>5])[c[1]&0x1f]) { wmem_strbuf_append_unichar(strbuf, (*cx_tab[j][c[1]>>5])[c[1]&0x1f]); } else { wmem_strbuf_append_unichar(strbuf, c[1]); wmem_strbuf_append_unichar(strbuf, t61_tab[*c]); } c++; i++; continue; } else { wmem_strbuf_append_unichar(strbuf, t61_tab[*c]); } } return (guint8 *)wmem_strbuf_finalize(strbuf); }"
"static void coroutine_fn v9fs_xattrcreate(void *opaque) { int flags; int32_t fid; int64_t size; ssize_t err = 0; V9fsString name; size_t offset = 7; V9fsFidState *file_fidp; V9fsFidState *xattr_fidp; V9fsPDU *pdu = opaque; v9fs_string_init(&name); err = pdu_unmarshal(pdu, offset, ""dsqd"", &fid, &name, &size, &flags); if (err < 0) { goto out_nofid; } trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags); file_fidp = get_fid(pdu, fid); if (file_fidp == NULL) { err = -EINVAL; goto out_nofid; } xattr_fidp = file_fidp; xattr_fidp->fid_type = P9_FID_XATTR; xattr_fidp->fs.xattr.copied_len = 0; xattr_fidp->fs.xattr.len = size; xattr_fidp->fs.xattr.flags = flags; v9fs_string_init(&xattr_fidp->fs.xattr.name); v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name); xattr_fidp->fs.xattr.value = g_malloc0(size); err = offset; put_fid(pdu, file_fidp); out_nofid: pdu_complete(pdu, err); v9fs_string_free(&name); }"
"static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps) { int i; int j; int thresh; jpc_fix_t val; jpc_fix_t mag; bool warn; uint_fast32_t mask; if (roishift == 0 && bgshift == 0) { return; } thresh = 1 << roishift; warn = false; for (i = 0; i < jas_matrix_numrows(x); ++i) { for (j = 0; j < jas_matrix_numcols(x); ++j) { val = jas_matrix_get(x, i, j); mag = JAS_ABS(val); if (mag >= thresh) { mag >>= roishift; val = (val < 0) ? (-mag) : mag; jas_matrix_set(x, i, j, val); } else { mag <<= bgshift; mask = (1 << numbps) - 1; if (mag & (~mask)) { if (!warn) { jas_eprintf(""warning: possibly corrupt code stream\n""); warn = true; } mag &= mask; } val = (val < 0) ? (-mag) : mag; jas_matrix_set(x, i, j, val); } } } }"
"int main(int argc, char **argv) { GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); el::Configurations defaultConf = et::LogHandler::setupLogHandler(&argc, &argv); defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); el::Loggers::setVerboseLevel(3); string maxlogsize = ""20971520""; LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + ""htmd.log"", maxlogsize); LogHandler::stderrToFile(GetTempDirectory() + ""htmd""); el::Loggers::reconfigureLogger(""default"", defaultConf); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler()); SocketEndpoint endpoint; endpoint.set_name(HtmServer::getPipeName()); HtmServer htm(socketHandler, endpoint); htm.run(); LOG(INFO) << ""Server is shutting down""; return 0; }"
"int ParseWave64HeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int64_t total_samples = 0, infilesize; Wave64ChunkHeader chunk_header; Wave64FileHeader filehdr; WaveHeader WaveHeader; uint32_t bcount; infilesize = DoGetFileSize (infile); memcpy (&filehdr, fourcc, 4); if (!DoReadFile (infile, ((char *) &filehdr) + 4, sizeof (Wave64FileHeader) - 4, &bcount) || bcount != sizeof (Wave64FileHeader) - 4 || memcmp (filehdr.ckID, riff_guid, sizeof (riff_guid)) || memcmp (filehdr.formType, wave_guid, sizeof (wave_guid))) { error_line (""%s is not a valid .W64 file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &filehdr, sizeof (filehdr))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } #if 1       WavpackLittleEndianToNative (&filehdr, Wave64ChunkHeaderFormat); if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && filehdr.ckSize && filehdr.ckSize + 1 && filehdr.ckSize != infilesize) { error_line (""%s is not a valid .W64 file!"", infilename); return WAVPACK_SOFT_ERROR; } #endif while (1) { if (!DoReadFile (infile, &chunk_header, sizeof (Wave64ChunkHeader), &bcount) || bcount != sizeof (Wave64ChunkHeader)) { error_line (""%s is not a valid .W64 file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &chunk_header, sizeof (Wave64ChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackLittleEndianToNative (&chunk_header, Wave64ChunkHeaderFormat); chunk_header.ckSize -= sizeof (chunk_header); if (!memcmp (chunk_header.ckID, fmt_guid, sizeof (fmt_guid))) { int supported = TRUE, format; chunk_header.ckSize = (chunk_header.ckSize + 7) & ~7L; if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) || !DoReadFile (infile, &WaveHeader, (uint32_t) chunk_header.ckSize, &bcount) || bcount != chunk_header.ckSize) { error_line (""%s is not a valid .W64 file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &WaveHeader, (uint32_t) chunk_header.ckSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat); if (debug_logging_mode) { error_line (""format tag size = %d"", chunk_header.ckSize); error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"", WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample); error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"", WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond); if (chunk_header.ckSize > 16) error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize, WaveHeader.ValidBitsPerSample); if (chunk_header.ckSize > 20) error_line (""ChannelMask = %x, SubFormat = %d"", WaveHeader.ChannelMask, WaveHeader.SubFormat); } if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2) config->qmode |= QMODE_ADOBE_MODE; format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ? WaveHeader.SubFormat : WaveHeader.FormatTag; config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ? WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample; if (format != 1 && format != 3) supported = FALSE; if (format == 3 && config->bits_per_sample != 32) supported = FALSE; if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 || WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 || WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 || WaveHeader.BlockAlign % WaveHeader.NumChannels) supported = FALSE; if (config->bits_per_sample < 1 || config->bits_per_sample > 32) supported = FALSE; if (!supported) { error_line (""%s is an unsupported .W64 format!"", infilename); return WAVPACK_SOFT_ERROR; } if (chunk_header.ckSize < 40) { if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) { if (WaveHeader.NumChannels <= 2) config->channel_mask = 0x5 - WaveHeader.NumChannels; else if (WaveHeader.NumChannels <= 18) config->channel_mask = (1 << WaveHeader.NumChannels) - 1; else config->channel_mask = 0x3ffff; } } else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this W64 file already has channel order information!""); return WAVPACK_SOFT_ERROR; } else if (WaveHeader.ChannelMask) config->channel_mask = WaveHeader.ChannelMask; if (format == 3) config->float_norm_exp = 127; else if ((config->qmode & QMODE_ADOBE_MODE) && WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) { if (WaveHeader.BitsPerSample == 24) config->float_norm_exp = 127 + 23; else if (WaveHeader.BitsPerSample == 32) config->float_norm_exp = 127 + 15; } if (debug_logging_mode) { if (config->float_norm_exp == 127) error_line (""data format: normalized 32-bit floating point""); else error_line (""data format: %d-bit integers stored in %d byte(s)"", config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels); } } else if (!memcmp (chunk_header.ckID, data_guid, sizeof (data_guid))) {  if (!WaveHeader.NumChannels) {                          error_line (""%s is not a valid .W64 file!"", infilename); return WAVPACK_SOFT_ERROR; } if ((config->qmode & QMODE_IGNORE_LENGTH) || chunk_header.ckSize <= 0) { config->qmode |= QMODE_IGNORE_LENGTH; if (infilesize && DoGetFilePosition (infile) != -1) total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign; else total_samples = -1; } else { if (infilesize && infilesize - chunk_header.ckSize > 16777216) { error_line (""this .W64 file has over 16 MB of extra RIFF data, probably is corrupt!""); return WAVPACK_SOFT_ERROR; } total_samples = chunk_header.ckSize / WaveHeader.BlockAlign; if (!total_samples) { error_line (""this .W64 file has no audio samples, probably is corrupt!""); return WAVPACK_SOFT_ERROR; } if (total_samples > MAX_WAVPACK_SAMPLES) { error_line (""%s has too many samples for WavPack!"", infilename); return WAVPACK_SOFT_ERROR; } } config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels; config->num_channels = WaveHeader.NumChannels; config->sample_rate = WaveHeader.SampleRate; break; } else {                      int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L; char *buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2], chunk_header.ckID [3], chunk_header.ckSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }"
"void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev) { if (!test_bit(SAS_DEV_DESTROY, &dev->state) && !list_empty(&dev->disco_list_node)) { list_del_init(&dev->disco_list_node); sas_rphy_free(dev->rphy); sas_unregister_common_dev(port, dev); return; } if (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) { sas_rphy_unlink(dev->rphy); list_move_tail(&dev->disco_list_node, &port->destroy_list); sas_discover_event(dev->port, DISCE_DESTRUCT); } }"
"bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs) { return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs); }"
"static void put_ucounts(struct ucounts *ucounts) { unsigned long flags; if (atomic_dec_and_test(&ucounts->count)) { spin_lock_irqsave(&ucounts_lock, flags); hlist_del_init(&ucounts->node); spin_unlock_irqrestore(&ucounts_lock, flags); kfree(ucounts); } }"
"static inline int __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only) { struct timer_base *base, *new_base; unsigned int idx = UINT_MAX; unsigned long clk = 0, flags; int ret = 0; BUG_ON(!timer->function); if (timer_pending(timer)) { if (timer->expires == expires) return 1; base = lock_timer_base(timer, &flags); clk = base->clk; idx = calc_wheel_index(expires, clk); if (idx == timer_get_idx(timer)) { timer->expires = expires; ret = 1; goto out_unlock; } } else { base = lock_timer_base(timer, &flags); } timer_stats_timer_set_start_info(timer); ret = detach_if_pending(timer, base, false); if (!ret && pending_only) goto out_unlock; debug_activate(timer, expires); new_base = get_target_base(base, timer->flags); if (base != new_base) { if (likely(base->running_timer != timer)) { timer->flags |= TIMER_MIGRATING; spin_unlock(&base->lock); base = new_base; spin_lock(&base->lock); WRITE_ONCE(timer->flags, (timer->flags & ~TIMER_BASEMASK) | base->cpu); } } forward_timer_base(base); timer->expires = expires; if (idx != UINT_MAX && clk == base->clk) { enqueue_timer(base, timer, idx); trigger_dyntick_cpu(base, timer); } else { internal_add_timer(base, timer); } out_unlock: spin_unlock_irqrestore(&base->lock, flags); return ret; }"
"static int StreamTcpValidateRst(TcpSession *ssn, Packet *p) { uint8_t os_policy; if (ssn->flags & STREAMTCP_FLAG_TIMESTAMP) { if (!StreamTcpValidateTimestamp(ssn, p)) { SCReturnInt(0); } } if (PKT_IS_TOSERVER(p)) { if (ssn->server.os_policy == 0) StreamTcpSetOSPolicy(&ssn->server, p); os_policy = ssn->server.os_policy; if (p->tcph->th_flags & TH_ACK && TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->server, p) == -1) { SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn); StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK); SCReturnInt(0); } } else { if (ssn->client.os_policy == 0) StreamTcpSetOSPolicy(&ssn->client, p); os_policy = ssn->client.os_policy; if (p->tcph->th_flags & TH_ACK && TCP_GET_ACK(p) && StreamTcpValidateAck(ssn, &ssn->client, p) == -1) { SCLogDebug(""ssn %p: rejecting because of invalid ack value"", ssn); StreamTcpSetEvent(p, STREAM_RST_INVALID_ACK); SCReturnInt(0); } } if (ssn->flags & STREAMTCP_FLAG_ASYNC) { if (PKT_IS_TOSERVER(p)) { if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""ssn %p: ASYNC accept RST"", ssn); return 1; } } else { if (SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""ssn %p: ASYNC accept RST"", ssn); return 1; } } SCLogDebug(""ssn %p: ASYNC reject RST"", ssn); return 0; } switch (os_policy) { case OS_POLICY_HPUX11: if(PKT_IS_TOSERVER(p)){ if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not Valid! Packet SEQ: %"" PRIu32 "" "" ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if(SEQ_GEQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" "" ""and client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; case OS_POLICY_OLD_LINUX: case OS_POLICY_LINUX: case OS_POLICY_SOLARIS: if(PKT_IS_TOSERVER(p)){ if(SEQ_GEQ((TCP_GET_SEQ(p)+p->payload_len), ssn->client.last_ack)) {  if(SEQ_LT(TCP_GET_SEQ(p), (ssn->client.next_seq + ssn->client.window))) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if(SEQ_GEQ((TCP_GET_SEQ(p) + p->payload_len), ssn->server.last_ack)) {  if(SEQ_LT(TCP_GET_SEQ(p), (ssn->server.next_seq + ssn->server.window))) { SCLogDebug(""reset is Valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; default: case OS_POLICY_BSD: case OS_POLICY_FIRST: case OS_POLICY_HPUX10: case OS_POLICY_IRIX: case OS_POLICY_MACOS: case OS_POLICY_LAST: case OS_POLICY_WINDOWS: case OS_POLICY_WINDOWS2K3: case OS_POLICY_VISTA: if(PKT_IS_TOSERVER(p)) { if(SEQ_EQ(TCP_GET_SEQ(p), ssn->client.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 """", TCP_GET_SEQ(p)); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" "" ""and server SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->client.next_seq); return 0; } } else {  if (SEQ_EQ(TCP_GET_SEQ(p), ssn->server.next_seq)) { SCLogDebug(""reset is valid! Packet SEQ: %"" PRIu32 "" Stream %u"", TCP_GET_SEQ(p), ssn->server.next_seq); return 1; } else { SCLogDebug(""reset is not valid! Packet SEQ: %"" PRIu32 "" and"" "" client SEQ: %"" PRIu32 """", TCP_GET_SEQ(p), ssn->server.next_seq); return 0; } } break; } return 0; }"
"static int decode_font(ASS_Track *track) { unsigned char *p; unsigned char *q; size_t i; size_t size;                       size_t dsize;                      unsigned char *buf = 0; ass_msg(track->library, MSGL_V, ""Font: %d bytes encoded data"", track->parser_priv->fontdata_used); size = track->parser_priv->fontdata_used; if (size % 4 == 1) { ass_msg(track->library, MSGL_ERR, ""Bad encoded data size""); goto error_decode_font; } buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0)); if (!buf) goto error_decode_font; q = buf; for (i = 0, p = (unsigned char *) track->parser_priv->fontdata; i < size / 4; i++, p += 4) { q = decode_chars(p, q, 4); } if (size % 4 == 2) { q = decode_chars(p, q, 2); } else if (size % 4 == 3) { q = decode_chars(p, q, 3); } dsize = q - buf; assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0)); if (track->library->extract_fonts) { ass_add_font(track->library, track->parser_priv->fontname, (char *) buf, dsize); } error_decode_font: free(buf); reset_embedded_font_parsing(track->parser_priv); return 0; }"
"void collect_symbols(const void *p, Size size, std::vector<typename M::symbol> &symbols) { Q_UNUSED(size) using elf_addr   = typename M::elf_addr; using elf_header = typename M::elf_header; using elf_shdr   = typename M::elf_shdr; using elf_sym    = typename M::elf_sym; using elf_rela   = typename M::elf_rela; using elf_rel    = typename M::elf_rel; using symbol     = typename M::symbol; const auto base = reinterpret_cast<uintptr_t>(p); const auto header = static_cast<const elf_header *>(p); if (header->e_shnum == 0 || header->e_shentsize == 0) { return; } const auto sections_begin          = reinterpret_cast<elf_shdr *>(base + header->e_shoff); const elf_shdr *const sections_end = sections_begin + header->e_shnum; auto section_strings               = reinterpret_cast<const char *>(base + sections_begin[header->e_shstrndx].sh_offset); elf_addr plt_address = 0; elf_addr got_address = 0; std::set<elf_addr> plt_addresses; for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { if (strcmp(&section_strings[section->sh_name], "".plt"") == 0) { plt_address = section->sh_addr; } else if (strcmp(&section_strings[section->sh_name], "".got"") == 0) { got_address = section->sh_addr; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { elf_addr base_address = 0; if (strcmp(&section_strings[section->sh_name], "".rela.plt"") == 0) { base_address = plt_address; } else if (strcmp(&section_strings[section->sh_name], "".rel.plt"") == 0) { base_address = plt_address; } else if (strcmp(&section_strings[section->sh_name], "".rela.got"") == 0) { base_address = got_address; } else if (strcmp(&section_strings[section->sh_name], "".rel.got"") == 0) { base_address = got_address; } else { continue; } switch (section->sh_type) { case SHT_RELA: { elf_addr n      = 0; auto relocation = reinterpret_cast<elf_rela *>(base + section->sh_offset); if (section->sh_link == 0) { break; } for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const size_t sym_index = M::elf_r_sym(relocation[i].r_info); const elf_shdr *linked = &sections_begin[section->sh_link]; auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset); auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset); const elf_addr symbol_address = base_address + ++n * M::plt_entry_size; const char *sym_name = &section_strings[section->sh_name]; if (strlen(sym_name) > (sizeof("".rela."") - 1) && memcmp(sym_name, "".rela."", (sizeof("".rela."") - 1)) == 0) { sym_name += 6; } plt_addresses.insert(symbol_address); symbol sym; sym.address = symbol_address; sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10); sym.name    = &string_tab[symbol_tab[sym_index].st_name]; sym.name += ""@""; sym.name += sym_name; sym.type = 'P'; symbols.push_back(sym); } } break; case SHT_REL: { elf_addr n      = 0; auto relocation = reinterpret_cast<elf_rel *>(base + section->sh_offset); if (section->sh_link == 0) { break; } for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const size_t sym_index = M::elf_r_sym(relocation[i].r_info); const elf_shdr *linked = &sections_begin[section->sh_link]; auto symbol_tab        = reinterpret_cast<elf_sym *>(base + linked->sh_offset); auto string_tab        = reinterpret_cast<const char *>(base + sections_begin[linked->sh_link].sh_offset); const elf_addr symbol_address = base_address + ++n * M::plt_entry_size; const char *sym_name = &section_strings[section->sh_name]; if (strlen(sym_name) > (sizeof("".rel."") - 1) && memcmp(sym_name, "".rel."", (sizeof("".rel."") - 1)) == 0) { sym_name += 5; } plt_addresses.insert(symbol_address); symbol sym; sym.address = symbol_address; sym.size    = (symbol_tab[sym_index].st_size ? symbol_tab[sym_index].st_size : 0x10); sym.name    = &string_tab[symbol_tab[sym_index].st_name]; sym.name += ""@""; sym.name += sym_name; sym.type = 'P'; symbols.push_back(sym); } } break; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { switch (section->sh_type) { case SHT_SYMTAB: case SHT_DYNSYM: { auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset); auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset); for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const elf_shdr *related_section = nullptr; if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) { related_section = &sections_begin[symbol_tab[i].st_shndx]; } Q_UNUSED(related_section) if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) { if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) > 0) { symbol sym; sym.address = symbol_tab[i].st_value; sym.size    = symbol_tab[i].st_size; sym.name    = &string_tab[symbol_tab[i].st_name]; sym.type    = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D'); symbols.push_back(sym); } } } } break; } } for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { switch (section->sh_type) { case SHT_SYMTAB: case SHT_DYNSYM: { auto symbol_tab = reinterpret_cast<elf_sym *>(base + section->sh_offset); auto string_tab = reinterpret_cast<const char *>(base + sections_begin[section->sh_link].sh_offset); for (size_t i = 0; i < section->sh_size / section->sh_entsize; ++i) { const elf_shdr *related_section = nullptr; if (symbol_tab[i].st_shndx != SHN_UNDEF && symbol_tab[i].st_shndx < SHN_LORESERVE) { related_section = &sections_begin[symbol_tab[i].st_shndx]; } Q_UNUSED(related_section) if (plt_addresses.find(symbol_tab[i].st_value) == plt_addresses.end()) { if (symbol_tab[i].st_value && strlen(&string_tab[symbol_tab[i].st_name]) == 0) { symbol sym; sym.address = symbol_tab[i].st_value; sym.size    = symbol_tab[i].st_size; for (const elf_shdr *section = sections_begin; section != sections_end; ++section) { if (sym.address >= section->sh_addr && sym.address + sym.size <= section->sh_addr + section->sh_size) { const std::int64_t offset = sym.address - section->sh_addr; const QString hexPrefix   = std::abs(offset) > 9 ? ""0x"" : """"; const QString offsetStr   = offset ? ""+"" + hexPrefix + QString::number(offset, 16) : """"; const QString sectionName(&section_strings[section->sh_name]); if (!sectionName.isEmpty()) { sym.name = QString(sectionName + offsetStr); break; } } } if (sym.name.isEmpty()) { sym.name = QString(""$sym_%1"").arg(edb::v1::format_pointer(symbol_tab[i].st_value)); } sym.type = (M::elf_st_type(symbol_tab[i].st_info) == STT_FUNC ? 'T' : 'D'); symbols.push_back(sym); } } } } break; } } }"
"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) { if (!block) { return; } QLIST_REMOVE(block, next); uc->ram_list.mru_block = NULL; reclaim_ramblock(uc, block); }"
"bool TIFF_MemoryReader::GetTag ( XMP_Uns8 ifd, XMP_Uns16 id, TagInfo* info ) const { const TweakedIFDEntry* thisTag = this->FindTagInIFD ( ifd, id ); if ( thisTag == 0 ) return false; XMP_Uns16 thisType = GetUns16AsIs ( &thisTag->type ); XMP_Uns32 thisBytes = GetUns32AsIs ( &thisTag->bytes ); if ( (thisType < kTIFF_ByteType) || (thisType > kTIFF_LastType) ) return false; if ( info != 0 ) { info->id = GetUns16AsIs ( &thisTag->id ); info->type = thisType; info->count = thisBytes / (XMP_Uns32)kTIFF_TypeSizes[thisType]; info->dataLen = thisBytes; info->dataPtr = this->GetDataPtr ( thisTag ); } return true; }"
"static void mbim_dissect_phonebook_read_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset) { proto_tree *subtree; gint base_offset; guint32 i, element_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_phonebook_read_info_element_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &element_count); offset += 4; if (element_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), element_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*element_count, ett_mbim_pair_list, NULL, ""Phonebook Ref List""); for (i = 0; i < element_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < element_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""Phonebook Element #%u"", i+1); mbim_dissect_phonebook_entry(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } } } }"
"void Compute(OpKernelContext* ctx) final { const CSRSparseMatrix* input_matrix; OP_REQUIRES_OK(ctx, ExtractVariantFromInput(ctx, 0, &input_matrix)); const Tensor& input_permutation_indices = ctx->input(1); int64 num_rows; int batch_size; ValidateInputs(ctx, *input_matrix, input_permutation_indices, &batch_size, &num_rows); Tensor batch_ptr(cpu_allocator(), DT_INT32, TensorShape({batch_size + 1})); auto batch_ptr_vec = batch_ptr.vec<int32>(); batch_ptr_vec(0) = 0; std::vector<SparseMatrix> sparse_cholesky_factors(batch_size); const double nnz_per_row = (input_matrix->total_nnz() / batch_size) / num_rows; const int64 sparse_cholesky_cost_per_batch = nnz_per_row * nnz_per_row * num_rows; auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); std::atomic<int64> invalid_input_index(-1); Shard(worker_threads.num_threads, worker_threads.workers, batch_size, sparse_cholesky_cost_per_batch, [&](int64 batch_begin, int64 batch_end) { for (int64 batch_index = batch_begin; batch_index < batch_end; ++batch_index) { Eigen::Map<const SparseMatrix> sparse_matrix( num_rows, num_rows, input_matrix->nnz(batch_index), input_matrix->row_pointers_vec(batch_index).data(), input_matrix->col_indices_vec(batch_index).data(), input_matrix->values_vec<T>(batch_index).data()); Eigen::SimplicialLLT<SparseMatrix, Eigen::Upper, Eigen::NaturalOrdering<int>> solver; auto permutation_indices_flat = input_permutation_indices.flat<int32>().data(); Eigen::Map< Eigen::PermutationMatrix<Eigen::Dynamic, Eigen::Dynamic, int>> permutation(permutation_indices_flat + batch_index * num_rows, num_rows); auto permutation_inverse = permutation.inverse(); SparseMatrix permuted_sparse_matrix; permuted_sparse_matrix.template selfadjointView<Eigen::Upper>() = sparse_matrix.template selfadjointView<Eigen::Upper>() .twistedBy(permutation_inverse); solver.compute(permuted_sparse_matrix); if (solver.info() != Eigen::Success) { invalid_input_index = batch_index; return; } sparse_cholesky_factors[batch_index] = std::move(solver.matrixU()); batch_ptr_vec(batch_index + 1) = sparse_cholesky_factors[batch_index].nonZeros(); } }); OP_REQUIRES( ctx, invalid_input_index == -1, errors::InvalidArgument( ""Sparse Cholesky factorization failed for batch index "", invalid_input_index.load(), "". The input might not be valid."")); std::partial_sum(batch_ptr_vec.data(), batch_ptr_vec.data() + batch_size + 1, batch_ptr_vec.data()); const int64 total_nnz = batch_ptr_vec(batch_size); Tensor output_row_ptr(cpu_allocator(), DT_INT32, TensorShape({(num_rows + 1) * batch_size})); Tensor output_col_ind(cpu_allocator(), DT_INT32, TensorShape({total_nnz})); Tensor output_values(cpu_allocator(), DataTypeToEnum<T>::value, TensorShape({total_nnz})); auto output_row_ptr_ptr = output_row_ptr.flat<int32>().data(); auto output_col_ind_ptr = output_col_ind.flat<int32>().data(); auto output_values_ptr = output_values.flat<T>().data(); Shard(worker_threads.num_threads, worker_threads.workers, batch_size, (3 * total_nnz) / batch_size , [&](int64 batch_begin, int64 batch_end) { for (int64 batch_index = batch_begin; batch_index < batch_end; ++batch_index) { const SparseMatrix& cholesky_factor = sparse_cholesky_factors[batch_index]; const int64 nnz = cholesky_factor.nonZeros(); std::copy(cholesky_factor.outerIndexPtr(), cholesky_factor.outerIndexPtr() + num_rows + 1, output_row_ptr_ptr + batch_index * (num_rows + 1)); std::copy(cholesky_factor.innerIndexPtr(), cholesky_factor.innerIndexPtr() + nnz, output_col_ind_ptr + batch_ptr_vec(batch_index)); std::copy(cholesky_factor.valuePtr(), cholesky_factor.valuePtr() + nnz, output_values_ptr + batch_ptr_vec(batch_index)); } }); CSRSparseMatrix output_csr_matrix; OP_REQUIRES_OK( ctx, CSRSparseMatrix::CreateCSRSparseMatrix( DataTypeToEnum<T>::value, input_matrix->dense_shape(), batch_ptr, output_row_ptr, output_col_ind, output_values, &output_csr_matrix)); Tensor* output_csr_matrix_tensor; AllocatorAttributes cpu_alloc; cpu_alloc.set_on_host(true); OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({}), &output_csr_matrix_tensor, cpu_alloc)); output_csr_matrix_tensor->scalar<Variant>()() = std::move(output_csr_matrix); }"
"static void dissect_thrift_common(tvbuff_t* tvb, packet_info* pinfo, proto_tree* tree) { proto_tree *sub_tree; int offset = 0; guint32 str_len; guint8 mtype; guint16 version; guint32 seq_id; guint8 *method_str; int length = tvb_reported_length(tvb); guint8 type; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""THRIFT""); col_clear(pinfo->cinfo, COL_INFO); version = tvb_get_ntohs(tvb, 0); mtype = tvb_get_guint8(tvb, 3); str_len = tvb_get_ntohl(tvb, 4); seq_id = tvb_get_ntohl(tvb, str_len + 8); method_str = tvb_get_string_enc(wmem_packet_scope(), tvb, 8, str_len, ENC_UTF_8); proto_tree_add_item(tree, proto_thrift, tvb, 0, -1, ENC_NA); sub_tree = proto_tree_add_subtree_format(tree, tvb, 0, -1, ett_thrift, NULL, ""%s[ version:0x%x, seqid:%d, method:%s]"", val_to_str(mtype, thrift_mtype_vals, ""%d""), version, seq_id, method_str); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s %s"", val_to_str(mtype, thrift_mtype_vals, ""%d""), method_str); if (tree){ proto_tree_add_item(sub_tree, hf_thrift_version, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; offset++; proto_tree_add_item(sub_tree, hf_thrift_mtype, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(sub_tree, hf_thrift_str_len, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(sub_tree, hf_thrift_method, tvb, offset, str_len, ENC_ASCII | ENC_NA); offset = offset + str_len; proto_tree_add_item(sub_tree, hf_thrift_seq_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; } else{ offset = 12 + str_len; } sub_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_thrift, NULL, ""Data""); if (tree){ while (offset < length){ type = tvb_get_guint8(tvb, offset); proto_tree_add_item(sub_tree, hf_thrift_type, tvb, offset, 1, ENC_BIG_ENDIAN); if (type == 0){ return; } offset++; proto_tree_add_item(sub_tree, hf_thrift_fid, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; offset = dissect_thrift_type(tvb, pinfo, sub_tree, type, offset, length); } } }"
"static int alloc_l2_table(struct page_info *page, unsigned long type) { struct domain *d = page_get_owner(page); unsigned long  pfn = mfn_x(page_to_mfn(page)); l2_pgentry_t  *pl2e; unsigned int   i; int            rc = 0; unsigned int   partial_flags = page->partial_flags; pl2e = map_domain_page(_mfn(pfn)); for ( i = page->nr_validated_ptes; i < L2_PAGETABLE_ENTRIES; i++, partial_flags = 0 ) { l2_pgentry_t l2e = pl2e[i]; if ( i > page->nr_validated_ptes && hypercall_preempt_check() ) rc = -EINTR; else if ( !is_guest_l2_slot(d, type, i) ) continue; else if ( !(l2e_get_flags(l2e) & _PAGE_PRESENT) ) { if ( !pv_l1tf_check_l2e(d, l2e) ) continue; rc = -EINTR; } else rc = get_page_from_l2e(l2e, pfn, d, partial_flags); ASSERT(rc != -ERESTART); if ( rc == -EINTR && i ) { page->nr_validated_ptes = i; page->partial_flags = 0; rc = -ERESTART; } else if ( rc < 0 && rc != -EINTR ) { gdprintk(XENLOG_WARNING, ""Failure %d in alloc_l2_table: slot %#x\n"", rc, i); ASSERT(current->arch.old_guest_table == NULL); if ( i ) { ASSERT(current->arch.old_guest_table == NULL); page->nr_validated_ptes = i; page->partial_flags = partial_flags; current->arch.old_guest_ptpg = NULL; current->arch.old_guest_table = page; current->arch.old_guest_table_partial = true; } } if ( rc < 0 ) break; pl2e[i] = adjust_guest_l2e(l2e, d); } if ( !rc && (type & PGT_pae_xen_l2) ) init_xen_pae_l2_slots(pl2e, d); unmap_domain_page(pl2e); return rc; }"
"static krb5_error_code kdc_process_s4u_x509_user(krb5_context context, krb5_kdc_req *request, krb5_pa_data *pa_data, krb5_keyblock *tgs_subkey, krb5_keyblock *tgs_session, krb5_pa_s4u_x509_user **s4u_x509_user, const char **status) { krb5_error_code             code; krb5_data                   req_data; req_data.length = pa_data->length; req_data.data = (char *)pa_data->contents; code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user); if (code) return code; code = verify_s4u_x509_user_checksum(context, tgs_subkey ? tgs_subkey : tgs_session, &req_data, request->nonce, *s4u_x509_user); if (code) { *status = ""INVALID_S4U2SELF_CHECKSUM""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return code; } if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 || (*s4u_x509_user)->user_id.subject_cert.length != 0) { *status = ""INVALID_S4U2SELF_REQUEST""; krb5_free_pa_s4u_x509_user(context, *s4u_x509_user); *s4u_x509_user = NULL; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN; } return 0; }"
"GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs) { char *buf; u32 buf_len, i, string_len, string_start; GF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s; ISOM_DECREASE_SIZE(ptr, 4); ptr->item_ID = gf_bs_read_u16(bs); ptr->item_protection_index = gf_bs_read_u16(bs); if (ptr->version == 2) { ISOM_DECREASE_SIZE(ptr, 4); ptr->item_type = gf_bs_read_u32(bs); } buf_len = (u32) (ptr->size); buf = (char*)gf_malloc(buf_len); if (!buf) return GF_OUT_OF_MEM; if (buf_len != gf_bs_read_data(bs, buf, buf_len)) { gf_free(buf); return GF_ISOM_INVALID_FILE; } string_len = 1; string_start = 0; for (i = 0; i < buf_len; i++) { if (buf[i] == 0) { if (!ptr->item_name) { ptr->item_name = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->item_name) return GF_OUT_OF_MEM; memcpy(ptr->item_name, buf+string_start, string_len); } else if (!ptr->content_type) { ptr->content_type = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->content_type) return GF_OUT_OF_MEM; memcpy(ptr->content_type, buf+string_start, string_len); } else { ptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len); if (!ptr->content_encoding) return GF_OUT_OF_MEM; memcpy(ptr->content_encoding, buf+string_start, string_len); } string_start += string_len; string_len = 0; if (ptr->content_encoding && ptr->version == 1) { break; } } string_len++; } gf_free(buf); if (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isoff] Infe without name or content type !\n"")); } return GF_OK; }"
"static int parse_keyword(struct archive_read *a, struct mtree *mtree, struct archive_entry *entry, struct mtree_option *opt, int *parsed_kws) { char *val, *key; key = opt->value; if (*key == '\0') return (ARCHIVE_OK); if (strcmp(key, ""nochange"") == 0) { *parsed_kws |= MTREE_HAS_NOCHANGE; return (ARCHIVE_OK); } if (strcmp(key, ""optional"") == 0) { *parsed_kws |= MTREE_HAS_OPTIONAL; return (ARCHIVE_OK); } if (strcmp(key, ""ignore"") == 0) { return (ARCHIVE_OK); } val = strchr(key, '='); if (val == NULL) { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Malformed attribute \""%s\"" (%d)"", key, key[0]); return (ARCHIVE_WARN); } *val = '\0'; ++val; switch (key[0]) { case 'c': if (strcmp(key, ""content"") == 0 || strcmp(key, ""contents"") == 0) { parse_escapes(val, NULL); archive_strcpy(&mtree->contents_name, val); break; } if (strcmp(key, ""cksum"") == 0) break; case 'd': if (strcmp(key, ""device"") == 0) { int r; dev_t dev; *parsed_kws |= MTREE_HAS_DEVICE; r = parse_device(&dev, &a->archive, val); if (r == ARCHIVE_OK) archive_entry_set_rdev(entry, dev); return r; } case 'f': if (strcmp(key, ""flags"") == 0) { *parsed_kws |= MTREE_HAS_FFLAGS; archive_entry_copy_fflags_text(entry, val); break; } case 'g': if (strcmp(key, ""gid"") == 0) { *parsed_kws |= MTREE_HAS_GID; archive_entry_set_gid(entry, mtree_atol10(&val)); break; } if (strcmp(key, ""gname"") == 0) { *parsed_kws |= MTREE_HAS_GNAME; archive_entry_copy_gname(entry, val); break; } case 'i': if (strcmp(key, ""inode"") == 0) { archive_entry_set_ino(entry, mtree_atol10(&val)); break; } case 'l': if (strcmp(key, ""link"") == 0) { archive_entry_copy_symlink(entry, val); break; } case 'm': if (strcmp(key, ""md5"") == 0 || strcmp(key, ""md5digest"") == 0) break; if (strcmp(key, ""mode"") == 0) { if (val[0] >= '0' && val[0] <= '9') { *parsed_kws |= MTREE_HAS_PERM; archive_entry_set_perm(entry, (mode_t)mtree_atol8(&val)); } else { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Symbolic mode \""%s\"" unsupported"", val); return ARCHIVE_WARN; } break; } case 'n': if (strcmp(key, ""nlink"") == 0) { *parsed_kws |= MTREE_HAS_NLINK; archive_entry_set_nlink(entry, (unsigned int)mtree_atol10(&val)); break; } case 'r': if (strcmp(key, ""resdevice"") == 0) { int r; dev_t dev; r = parse_device(&dev, &a->archive, val); if (r == ARCHIVE_OK) archive_entry_set_dev(entry, dev); return r; } if (strcmp(key, ""rmd160"") == 0 || strcmp(key, ""rmd160digest"") == 0) break; case 's': if (strcmp(key, ""sha1"") == 0 || strcmp(key, ""sha1digest"") == 0) break; if (strcmp(key, ""sha256"") == 0 || strcmp(key, ""sha256digest"") == 0) break; if (strcmp(key, ""sha384"") == 0 || strcmp(key, ""sha384digest"") == 0) break; if (strcmp(key, ""sha512"") == 0 || strcmp(key, ""sha512digest"") == 0) break; if (strcmp(key, ""size"") == 0) { archive_entry_set_size(entry, mtree_atol10(&val)); break; } case 't': if (strcmp(key, ""tags"") == 0) { break; } if (strcmp(key, ""time"") == 0) { int64_t m; int64_t my_time_t_max = get_time_t_max(); int64_t my_time_t_min = get_time_t_min(); long ns; *parsed_kws |= MTREE_HAS_MTIME; m = mtree_atol10(&val); if (*val == '.') { ++val; ns = (long)mtree_atol10(&val); } else ns = 0; if (m > my_time_t_max) m = my_time_t_max; else if (m < my_time_t_min) m = my_time_t_min; archive_entry_set_mtime(entry, (time_t)m, ns); break; } if (strcmp(key, ""type"") == 0) { switch (val[0]) { case 'b': if (strcmp(val, ""block"") == 0) { archive_entry_set_filetype(entry, AE_IFBLK); break; } case 'c': if (strcmp(val, ""char"") == 0) { archive_entry_set_filetype(entry, AE_IFCHR); break; } case 'd': if (strcmp(val, ""dir"") == 0) { archive_entry_set_filetype(entry, AE_IFDIR); break; } case 'f': if (strcmp(val, ""fifo"") == 0) { archive_entry_set_filetype(entry, AE_IFIFO); break; } if (strcmp(val, ""file"") == 0) { archive_entry_set_filetype(entry, AE_IFREG); break; } case 'l': if (strcmp(val, ""link"") == 0) { archive_entry_set_filetype(entry, AE_IFLNK); break; } default: archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Unrecognized file type \""%s\""; "" ""assuming \""file\"""", val); archive_entry_set_filetype(entry, AE_IFREG); return (ARCHIVE_WARN); } *parsed_kws |= MTREE_HAS_TYPE; break; } case 'u': if (strcmp(key, ""uid"") == 0) { *parsed_kws |= MTREE_HAS_UID; archive_entry_set_uid(entry, mtree_atol10(&val)); break; } if (strcmp(key, ""uname"") == 0) { *parsed_kws |= MTREE_HAS_UNAME; archive_entry_copy_uname(entry, val); break; } default: archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Unrecognized key %s=%s"", key, val); return (ARCHIVE_WARN); } return (ARCHIVE_OK); }"
"static int dissect_kafka_record(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int start_offset, guint64 base_offset, guint64 first_timestamp) { proto_item *record_ti; proto_tree *subtree; gint64     size; guint      len; int offset, end_offset; gboolean   invalid; offset = start_offset; subtree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_kafka_record, &record_ti, ""Record""); len = tvb_get_varint(tvb, offset, 5, &size, ENC_VARINT_ZIGZAG); if (len == 0) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_varint); return offset; } else if (size < 6) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length); return offset + len; } end_offset = offset + len + (gint)size; offset += len; proto_tree_add_item(subtree, hf_kafka_record_attributes, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; offset = dissect_kafka_timestamp_delta(tvb, pinfo, subtree, hf_kafka_message_timestamp, offset, first_timestamp); offset = dissect_kafka_offset_delta(tvb, pinfo, subtree, hf_kafka_offset, offset, base_offset); offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_key, offset, NULL, NULL, &invalid); if (invalid) return end_offset; offset = dissect_kafka_bytes_new(tvb, pinfo, subtree, hf_kafka_message_value, offset, NULL, NULL, &invalid); if (invalid) return end_offset; offset = dissect_kafka_record_headers(tvb, pinfo, subtree, offset); if (offset != end_offset) { expert_add_info(pinfo, record_ti, &ei_kafka_bad_record_length); } proto_item_set_end(record_ti, tvb, end_offset); return end_offset; }"
"static s32 gf_media_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext) { u32 i, j; s32 vps_id; VVC_VPS *vps; Bool vps_default_ptl_dpb_hrd_max_tid_flag=0; vps_id = gf_bs_read_int_log(bs, 4, ""vps_id""); if (vps_id >= 16) return -1; if (!vps_id) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] VPS ID 0 is forbidden\n"")); return -1; } vps = &vvc->vps[vps_id]; if (!vps->state) { vps->id = vps_id; vps->state = 1; } vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, ""max_layers""); if (vps->max_layers > MAX_LHVC_LAYERS) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] sorry, %d layers in VPS but only %d supported\n"", vps->max_layers, MAX_LHVC_LAYERS)); return -1; } vps->max_sub_layers = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"") + 1; if ((vps->max_layers>1) && (vps->max_sub_layers>1)) vps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, ""vps_default_ptl_dpb_hrd_max_tid_flag""); if (vps->max_layers>1) vps->all_layers_independent = gf_bs_read_int_log(bs, 1, ""all_layers_independent""); for (i=0; i<vps->max_layers; i++) { u32 layer_id = gf_bs_read_int_log_idx(bs, 6, ""layer_id"", i); if (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id; if (i && !vps->all_layers_independent) { Bool layer_indep = gf_bs_read_int_log_idx(bs, 1, ""layer_independent"", i); if (!layer_indep) { Bool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_max_tid_ref_present_flag"", i); for (j=0; j<i; j++) { Bool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, ""vps_direct_ref_layer_flag"", i, j); if (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) { gf_bs_read_int_log_idx2(bs, 3, ""vps_max_tid_il_ref_pics_plus1"", i, j); } } } } } vps->num_ptl = 1; if (vps->max_layers > 1) { if (vps->all_layers_independent) { vps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, ""each_layer_is_ols""); } if (!vps->each_layer_is_ols) { u32 vps_ols_mode_idc = 2; if (!vps->all_layers_independent) { vps_ols_mode_idc = gf_bs_read_int_log(bs, 2, ""vps_ols_mode_idc""); } if (vps_ols_mode_idc==2) { u8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, ""vps_num_output_layer_sets_minus2""); for (i=0; i<vps_num_output_layer_sets; i++) { for (j=0; j<vps->max_layers; j++) { gf_bs_read_int_log_idx2(bs, 1, ""vps_ols_output_layer_flag"", i, j); } } } } vps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, ""num_ptl_minus1""); } vps->ptl[0].pt_present = 1; for (i=0; i<vps->num_ptl; i++) { if (i) vps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, ""pt_present"", i); if (!vps_default_ptl_dpb_hrd_max_tid_flag) vps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, ""ptl_max_tid"", i); else vps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1;; } gf_bs_align(bs); for (i=0; i<vps->num_ptl; i++) { vvc_profile_tier_level(bs, &vps->ptl[i], i); } return vps_id; }"
"void CommandData::ProcessCommand() { #ifndef SFX_MODULE const wchar *SingleCharCommands=L""FUADPXETK""; if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0) OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR);  const wchar *ArcExt=GetExt(ArcName); #ifdef _UNIX if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName)))) wcsncatz(ArcName,L"".rar"",ASIZE(ArcName)); #else if (ArcExt==NULL) wcsncatz(ArcName,L"".rar"",ASIZE(ArcName)); #endif if (ArcExt!=NULL && wcsnicomp(ArcExt,L"".part"",5)==0 && IsDigit(ArcExt[5]) && !FileExist(ArcName)) { wchar Name[NM]; wcsncpyz(Name,ArcName,ASIZE(Name)); wcsncatz(Name,L"".rar"",ASIZE(Name)); if (FileExist(Name)) wcsncpyz(ArcName,Name,ASIZE(ArcName)); } if (wcschr(L""AFUMD"",*Command)==NULL) { if (GenerateArcName) GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false); StringList ArcMasks; ArcMasks.AddString(ArcName); ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS); FindData FindData; while (Scan.GetNext(&FindData)==SCAN_SUCCESS) AddArcName(FindData.Name); } else AddArcName(ArcName); #endif switch(Command[0]) { case 'P': case 'X': case 'E': case 'T': case 'I': { CmdExtract Extract(this); Extract.DoExtract(); } break; #ifndef SILENT case 'V': case 'L': ListArchive(this); break; default: OutHelp(RARX_USERERROR); #endif } if (!BareOutput) mprintf(L""\n""); }"
"static int bpf_map_mmap(struct file *filp, struct vm_area_struct *vma) { struct bpf_map *map = filp->private_data; int err; if (!map->ops->map_mmap || map_value_has_spin_lock(map) || map_value_has_timer(map)) return -ENOTSUPP; if (!(vma->vm_flags & VM_SHARED)) return -EINVAL; mutex_lock(&map->freeze_mutex); if (vma->vm_flags & VM_WRITE) { if (map->frozen) { err = -EPERM; goto out; } if (map->map_flags & BPF_F_RDONLY_PROG) { err = -EACCES; goto out; } } vma->vm_ops = &bpf_map_default_vmops; vma->vm_private_data = map; vma->vm_flags &= ~VM_MAYEXEC; if (!(vma->vm_flags & VM_WRITE)) vma->vm_flags &= ~VM_MAYWRITE; err = map->ops->map_mmap(map, vma); if (err) goto out; if (vma->vm_flags & VM_MAYWRITE) map->writecnt++; out: mutex_unlock(&map->freeze_mutex); return err; }"
"static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock, unsigned long err) { int level = 0; int len = 0;  ERROR_LOG(""STATUS_FROM_SSL_ERR"", err, ssock); level++; if (err == SSL_ERROR_SSL) { err = ERR_get_error(); ERROR_LOG(""STATUS_FROM_SSL_ERR"", err, ssock); } ssock->last_err = err; return GET_STATUS_FROM_SSL_ERR(err); }"
"static njs_ret_t njs_string_prototype_to_bytes(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs, njs_index_t unused) { u_char             *p; size_t             length; uint32_t           byte; const u_char       *s, *end; njs_slice_prop_t   slice; njs_string_prop_t  string; njs_string_slice_prop(&string, &slice, args, nargs); if (string.length == 0) { return njs_string_slice(vm, &vm->retval, &string, &slice); } p = njs_string_alloc(vm, &vm->retval, slice.length, 0); if (nxt_fast_path(p != NULL)) { if (string.length != 0) { end = string.start + string.size; s = njs_string_offset(string.start, end, slice.start); length = slice.length; while (length != 0 && s < end) { byte = nxt_utf8_decode(&s, end); if (nxt_slow_path(byte > 0xFF)) { njs_release(vm, &vm->retval); vm->retval = njs_value_null; return NXT_OK; } *p++ = (u_char) byte; length--; } } else { memcpy(p, string.start + slice.start, slice.length); } return NXT_OK; } return NXT_ERROR; }"
uint64_t HeaderMapImpl::byteSize() const { uint64_t byte_size = 0; for (const HeaderEntryImpl& header : headers_) { byte_size += header.key().size(); byte_size += header.value().size(); } return byte_size; }
"int nfsd_setuser(struct svc_rqst *rqstp, struct svc_export *exp) { struct group_info *rqgi; struct group_info *gi; struct cred *new; int i; int flags = nfsexp_flags(rqstp, exp); validate_process_creds(); revert_creds(get_cred(current_real_cred())); new = prepare_creds(); if (!new) return -ENOMEM; new->fsuid = rqstp->rq_cred.cr_uid; new->fsgid = rqstp->rq_cred.cr_gid; rqgi = rqstp->rq_cred.cr_group_info; if (flags & NFSEXP_ALLSQUASH) { new->fsuid = exp->ex_anon_uid; new->fsgid = exp->ex_anon_gid; gi = groups_alloc(0); if (!gi) goto oom; } else if (flags & NFSEXP_ROOTSQUASH) { if (uid_eq(new->fsuid, GLOBAL_ROOT_UID)) new->fsuid = exp->ex_anon_uid; if (gid_eq(new->fsgid, GLOBAL_ROOT_GID)) new->fsgid = exp->ex_anon_gid; gi = groups_alloc(rqgi->ngroups); if (!gi) goto oom; for (i = 0; i < rqgi->ngroups; i++) { if (gid_eq(GLOBAL_ROOT_GID, rqgi->gid[i])) gi->gid[i] = exp->ex_anon_gid; else gi->gid[i] = rqgi->gid[i]; groups_sort(gi); } } else { gi = get_group_info(rqgi); } if (uid_eq(new->fsuid, INVALID_UID)) new->fsuid = exp->ex_anon_uid; if (gid_eq(new->fsgid, INVALID_GID)) new->fsgid = exp->ex_anon_gid; set_groups(new, gi); put_group_info(gi); if (!uid_eq(new->fsuid, GLOBAL_ROOT_UID)) new->cap_effective = cap_drop_nfsd_set(new->cap_effective); else new->cap_effective = cap_raise_nfsd_set(new->cap_effective, new->cap_permitted); validate_process_creds(); put_cred(override_creds(new)); put_cred(new); validate_process_creds(); return 0; oom: abort_creds(new); return -ENOMEM; }"
"static void add_themes_from_dir (DialogData *data, GFile      *dir, gboolean    editable) { GFileEnumerator *enumerator; GFileInfo       *file_info; enumerator = g_file_enumerate_children (dir, (G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_TYPE "","" G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME), G_FILE_QUERY_INFO_NONE, NULL, NULL); if (enumerator == NULL) return; while ((file_info = g_file_enumerator_next_file (enumerator, NULL, NULL)) != NULL) { GthContactSheetTheme *theme; GFile                *file; char                 *buffer; gsize                 size; GKeyFile             *key_file; GtkTreeIter           iter; GdkPixbuf            *preview; if (g_file_info_get_file_type (file_info) != G_FILE_TYPE_REGULAR) { g_object_unref (file_info); continue; } if (g_strcmp0 (_g_uri_get_file_extension (g_file_info_get_name (file_info)), "".cst"") != 0) { g_object_unref (file_info); continue; } file = g_file_get_child (dir, g_file_info_get_name (file_info)); if (! _g_file_load_in_buffer (file, (void **) &buffer, &size, NULL, NULL)) { g_object_unref (file); g_object_unref (file_info); continue; } key_file = g_key_file_new (); if (! g_key_file_load_from_data (key_file, buffer, size, G_KEY_FILE_NONE, NULL)) { g_key_file_free (key_file); g_free (buffer); g_object_unref (file); g_object_unref (file_info); } theme = gth_contact_sheet_theme_new_from_key_file (key_file); theme->file = g_object_ref (file); theme->editable = editable; preview = gth_contact_sheet_theme_create_preview (theme, PREVIEW_SIZE); gtk_list_store_append (GTK_LIST_STORE (GET_WIDGET (""theme_liststore"")), &iter); gtk_list_store_set (GTK_LIST_STORE (GET_WIDGET (""theme_liststore"")), &iter, THEME_COLUMN_THEME, theme, THEME_COLUMN_DISPLAY_NAME, theme->display_name, THEME_COLUMN_PREVIEW, preview, -1); _g_object_unref (preview); g_key_file_free (key_file); g_free (buffer); g_object_unref (file); g_object_unref (file_info); } g_object_unref (enumerator); }"
"static int vmx_check_intercept(struct kvm_vcpu *vcpu, struct x86_instruction_info *info, enum x86_intercept_stage stage) { struct vmcs12 *vmcs12 = get_vmcs12(vcpu); struct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt; if (info->intercept == x86_intercept_rdtscp && !nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) { ctxt->exception.vector = UD_VECTOR; ctxt->exception.error_code_valid = false; return X86EMUL_PROPAGATE_FAULT; } return X86EMUL_UNHANDLEABLE; }"
"static int compile_length_bag_node(BagNode* node, regex_t* reg) { int len; int tlen; if (node->type == BAG_OPTION) return compile_length_option_node(node, reg); if (NODE_BAG_BODY(node)) { tlen = compile_length_tree(NODE_BAG_BODY(node), reg); if (tlen < 0) return tlen; } else tlen = 0; switch (node->type) { case BAG_MEMORY: #ifdef USE_CALL if (node->m.regnum == 0 && NODE_IS_CALLED(node)) { len = tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN; return len; } if (NODE_IS_CALLED(node)) { len = SIZE_OP_MEMORY_START_PUSH + tlen + SIZE_OP_CALL + SIZE_OP_JUMP + SIZE_OP_RETURN; if (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum)) len += (NODE_IS_RECURSION(node) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_PUSH); else len += (NODE_IS_RECURSION(node) ? SIZE_OP_MEMORY_END_REC : SIZE_OP_MEMORY_END); } else if (NODE_IS_RECURSION(node)) { len = SIZE_OP_MEMORY_START_PUSH; len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum) ? SIZE_OP_MEMORY_END_PUSH_REC : SIZE_OP_MEMORY_END_REC); } else #endif { if (MEM_STATUS_AT0(reg->bt_mem_start, node->m.regnum)) len = SIZE_OP_MEMORY_START_PUSH; else len = SIZE_OP_MEMORY_START; len += tlen + (MEM_STATUS_AT0(reg->bt_mem_end, node->m.regnum) ? SIZE_OP_MEMORY_END_PUSH : SIZE_OP_MEMORY_END); } break; case BAG_STOP_BACKTRACK: if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) { int v; QuantNode* qn; qn = QUANT_(NODE_BAG_BODY(node)); tlen = compile_length_tree(NODE_QUANT_BODY(qn), reg); if (tlen < 0) return tlen; v = onig_positive_int_multiply(qn->lower, tlen); if (v < 0) return ONIGERR_TOO_BIG_NUMBER_FOR_REPEAT_RANGE; len = v + SIZE_OP_PUSH + tlen + SIZE_OP_POP_OUT + SIZE_OP_JUMP; } else { len = SIZE_OP_ATOMIC_START + tlen + SIZE_OP_ATOMIC_END; } break; case BAG_IF_ELSE: { Node* cond = NODE_BAG_BODY(node); Node* Then = node->te.Then; Node* Else = node->te.Else; len = compile_length_tree(cond, reg); if (len < 0) return len; len += SIZE_OP_PUSH; len += SIZE_OP_ATOMIC_START + SIZE_OP_ATOMIC_END; if (IS_NOT_NULL(Then)) { tlen = compile_length_tree(Then, reg); if (tlen < 0) return tlen; len += tlen; } if (IS_NOT_NULL(Else)) { len += SIZE_OP_JUMP; tlen = compile_length_tree(Else, reg); if (tlen < 0) return tlen; len += tlen; } } break; case BAG_OPTION: len = 0; break; } return len; }"
"static void process_add_smartcard_key(SocketEntry *e) { char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX]; char **comments = NULL; int r, i, count = 0, success = 0, confirm = 0; u_int seconds = 0; time_t death = 0; struct sshkey **keys = NULL, *k; Identity *id; struct dest_constraint *dest_constraints = NULL; size_t ndest_constraints = 0; debug2_f(""entering""); if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 || (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) { error_fr(r, ""parse""); goto send; } if (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm, NULL, &dest_constraints, &ndest_constraints) != 0) { error_f(""failed to parse constraints""); goto send; } if (e->nsession_ids != 0 && !remote_add_provider) { verbose(""failed PKCS#11 add of \""%.100s\"": remote addition of "" ""providers is disabled"", provider); goto send; } if (realpath(provider, canonical_provider) == NULL) { verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"", provider, strerror(errno)); goto send; } if (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) { verbose(""refusing PKCS#11 add of \""%.100s\"": "" ""provider not allowed"", canonical_provider); goto send; } debug_f(""add %.100s"", canonical_provider); if (lifetime && !death) death = monotime() + lifetime; count = pkcs11_add_provider(canonical_provider, pin, &keys, &comments); for (i = 0; i < count; i++) { k = keys[i]; if (lookup_identity(k) == NULL) { id = xcalloc(1, sizeof(Identity)); id->key = k; keys[i] = NULL;  id->provider = xstrdup(canonical_provider); if (*comments[i] != '\0') { id->comment = comments[i]; comments[i] = NULL;  } else { id->comment = xstrdup(canonical_provider); } id->death = death; id->confirm = confirm; id->dest_constraints = dest_constraints; id->ndest_constraints = ndest_constraints; dest_constraints = NULL;  ndest_constraints = 0; TAILQ_INSERT_TAIL(&idtab->idlist, id, next); idtab->nentries++; success = 1; } sshkey_free(keys[i]); free(comments[i]); } send: free(pin); free(provider); free(keys); free(comments); free_dest_constraints(dest_constraints, ndest_constraints); send_status(e, success); }"
"double js_strtod(const char *string, char **endPtr) { int sign, expSign = FALSE; double fraction, dblExp, *d; register const char *p; register int c; int exp = 0; int fracExp = 0; int mantSize; int decPt; const char *pExp; p = string; while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') { p += 1; } if (*p == '-') { sign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } sign = FALSE; } decPt = -1; for (mantSize = 0; ; mantSize += 1) { c = *p; if (!(c>='0'&&c<='9')) { if ((c != '.') || (decPt >= 0)) { break; } decPt = mantSize; } p += 1; } pExp = p; p -= mantSize; if (decPt < 0) { decPt = mantSize; } else { mantSize -= 1; } if (mantSize > 18) { fracExp = decPt - 18; mantSize = 18; } else { fracExp = decPt - mantSize; } if (mantSize == 0) { fraction = 0.0; p = string; goto done; } else { int frac1, frac2; frac1 = 0; for ( ; mantSize > 9; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac1 = 10*frac1 + (c - '0'); } frac2 = 0; for (; mantSize > 0; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac2 = 10*frac2 + (c - '0'); } fraction = (1.0e9 * frac1) + frac2; } p = pExp; if ((*p == 'E') || (*p == 'e')) { p += 1; if (*p == '-') { expSign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } expSign = FALSE; } while ((*p >= '0') && (*p <= '9')) { exp = exp * 10 + (*p - '0'); p += 1; } } if (expSign) { exp = fracExp - exp; } else { exp = fracExp + exp; } if (exp < 0) { expSign = TRUE; exp = -exp; } else { expSign = FALSE; } if (exp > maxExponent) { exp = maxExponent; errno = ERANGE; } dblExp = 1.0; for (d = powersOf10; exp != 0; exp >>= 1, d += 1) { if (exp & 01) { dblExp *= *d; } } if (expSign) { fraction /= dblExp; } else { fraction *= dblExp; } done: if (endPtr != NULL) { *endPtr = (char *) p; } if (sign) { return -fraction; } return fraction; }"
"static struct lys_node * read_yin_case(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options, struct unres_schema *unres) { struct ly_ctx *ctx = module->ctx; struct lyxml_elem *sub, *next, root; struct lys_node_case *cs; struct lys_node *retval, *node = NULL; int c_ftrs = 0, c_ext = 0, ret; void *reallocated; memset(&root, 0, sizeof root); cs = calloc(1, sizeof *cs); LY_CHECK_ERR_RETURN(!cs, LOGMEM(ctx), NULL); cs->nodetype = LYS_CASE; cs->prev = (struct lys_node *)cs; retval = (struct lys_node *)cs; if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin, OPT_IDENT | OPT_MODULE | (!(options & LYS_PARSE_OPT_CFG_MASK) ? OPT_CFG_INHERIT : 0), unres)) { goto error; } LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name); if (lys_node_addchild(parent, lys_main_module(module), retval, options)) { goto error; } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""case"", error); c_ext++; } else if (!strcmp(sub->name, ""container"") || !strcmp(sub->name, ""leaf-list"") || !strcmp(sub->name, ""leaf"") || !strcmp(sub->name, ""list"") || !strcmp(sub->name, ""uses"") || !strcmp(sub->name, ""choice"") || !strcmp(sub->name, ""anyxml"") || !strcmp(sub->name, ""anydata"")) { lyxml_unlink_elem(ctx, sub, 2); lyxml_add_child(ctx, &root, sub); } else if (!strcmp(sub->name, ""if-feature"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""case"", error); c_ftrs++; } else if (!strcmp(sub->name, ""when"")) { if (cs->when) { LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name); goto error; } cs->when = read_yin_when(module, sub, unres); if (!cs->when) { goto error; } lyxml_free(ctx, sub); } else { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name); goto error; } } if (c_ftrs) { cs->iffeature = calloc(c_ftrs, sizeof *cs->iffeature); LY_CHECK_ERR_GOTO(!cs->iffeature, LOGMEM(ctx), error); } if (c_ext) { reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext); LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error); retval->ext = reallocated; memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext); } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { ret = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres); if (ret) { goto error; } } else { ret = fill_yin_iffeature(retval, 0, sub, &cs->iffeature[cs->iffeature_size], unres); cs->iffeature_size++; if (ret) { goto error; } } } lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size); LY_TREE_FOR_SAFE(root.child, next, sub) { if (!strcmp(sub->name, ""container"")) { node = read_yin_container(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf-list"")) { node = read_yin_leaflist(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf"")) { node = read_yin_leaf(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""list"")) { node = read_yin_list(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""choice"")) { node = read_yin_choice(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""uses"")) { node = read_yin_uses(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""anyxml"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres); } else if (!strcmp(sub->name, ""anydata"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres); } if (!node) { goto error; } lyxml_free(ctx, sub); } if (!(ctx->models.flags & LY_CTX_TRUSTED) && cs->when) { if (options & LYS_PARSE_OPT_INGRP) { if (lyxp_node_check_syntax(retval)) { goto error; } } else { if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) { goto error; } } } return retval; error: while (root.child) { lyxml_free(ctx, root.child); } lys_node_free(retval, NULL, 0); return NULL; }"
"static int encode_apng(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { PNGEncContext *s = avctx->priv_data; int ret; int enc_row_size; size_t max_packet_size; APNGFctlChunk fctl_chunk = {0}; if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) { uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t)); if (avctx->frame_number == 0) { s->palette_checksum = checksum; } else if (checksum != s->palette_checksum) { av_log(avctx, AV_LOG_ERROR, ""Input contains more than one unique palette. APNG does not support multiple palettes.\n""); return -1; } } enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3); max_packet_size = AV_INPUT_BUFFER_MIN_SIZE +         avctx->height * ( enc_row_size + (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE)         ); if (max_packet_size > INT_MAX) return AVERROR(ENOMEM); if (avctx->frame_number == 0) { if (!pict) return AVERROR(EINVAL); s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE); if (!avctx->extradata) return AVERROR(ENOMEM); ret = encode_headers(avctx, pict); if (ret < 0) return ret; avctx->extradata_size = s->bytestream - avctx->extradata; s->last_frame_packet = av_malloc(max_packet_size); if (!s->last_frame_packet) return AVERROR(ENOMEM); } else if (s->last_frame) { ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0); if (ret < 0) return ret; memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size); pkt->size = s->last_frame_packet_size; pkt->pts = pkt->dts = s->last_frame->pts; } if (pict) { s->bytestream_start = s->bytestream       = s->last_frame_packet; s->bytestream_end   = s->bytestream + max_packet_size; fctl_chunk.sequence_number = s->sequence_number; ++s->sequence_number; s->bytestream += 26 + 12; ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl); if (ret < 0) return ret; fctl_chunk.delay_num = 0;         fctl_chunk.delay_den = 0; } else { s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE; } if (s->last_frame) { uint8_t* last_fctl_chunk_start = pkt->data; uint8_t buf[26]; AV_WB32(buf + 0, s->last_frame_fctl.sequence_number); AV_WB32(buf + 4, s->last_frame_fctl.width); AV_WB32(buf + 8, s->last_frame_fctl.height); AV_WB32(buf + 12, s->last_frame_fctl.x_offset); AV_WB32(buf + 16, s->last_frame_fctl.y_offset); AV_WB16(buf + 20, s->last_frame_fctl.delay_num); AV_WB16(buf + 22, s->last_frame_fctl.delay_den); buf[24] = s->last_frame_fctl.dispose_op; buf[25] = s->last_frame_fctl.blend_op; png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26); *got_packet = 1; } if (pict) { if (!s->last_frame) { s->last_frame = av_frame_alloc(); if (!s->last_frame) return AVERROR(ENOMEM); } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) { if (!s->prev_frame) { s->prev_frame = av_frame_alloc(); if (!s->prev_frame) return AVERROR(ENOMEM); s->prev_frame->format = pict->format; s->prev_frame->width = pict->width; s->prev_frame->height = pict->height; if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0) return ret; } av_frame_copy(s->prev_frame, s->last_frame); if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) { uint32_t y; uint8_t bpp = (s->bits_per_pixel + 7) >> 3; for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) { size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset; memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width); } } } av_frame_unref(s->last_frame); ret = av_frame_ref(s->last_frame, (AVFrame*)pict); if (ret < 0) return ret; s->last_frame_fctl = fctl_chunk; s->last_frame_packet_size = s->bytestream - s->bytestream_start; } else { av_frame_free(&s->last_frame); } return 0; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& input = ctx->input(0); const Tensor& input_min_range = ctx->input(1); const Tensor& input_max_range = ctx->input(2); int num_slices = 1; if (axis_ > -1) { num_slices = input.dim_size(axis_); } const TensorShape& minmax_shape = ctx->input(1).shape(); Tensor* output = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, input.shape(), &output)); Tensor* output_min_tensor = nullptr; Tensor* output_max_tensor = nullptr; if (num_slices == 1) { OP_REQUIRES_OK(ctx, ctx->allocate_output(1, {}, &output_min_tensor)); OP_REQUIRES_OK(ctx, ctx->allocate_output(2, {}, &output_max_tensor)); const float min_range = input_min_range.template flat<float>()(0); const float max_range = input_max_range.template flat<float>()(0); QuantizeTensor(ctx, input, min_range, max_range, output, output_min_tensor, output_max_tensor); return; } OP_REQUIRES(ctx, mode_ != QUANTIZE_MODE_MIN_FIRST, errors::Unimplemented(""MIN_FIRST mode is not implemented for "" ""Quantize with axis != -1."")); OP_REQUIRES_OK(ctx, ctx->allocate_output(1, minmax_shape, &output_min_tensor)); OP_REQUIRES_OK(ctx, ctx->allocate_output(2, minmax_shape, &output_max_tensor)); auto input_tensor = input.template flat_inner_outer_dims<float, 3>(axis_ - 1); int64_t pre_dim = 1, post_dim = 1; for (int i = 0; i < axis_; ++i) { pre_dim *= output->dim_size(i); } for (int i = axis_ + 1; i < output->dims(); ++i) { post_dim *= output->dim_size(i); } auto output_tensor = output->template bit_casted_shaped<T, 3>( {pre_dim, num_slices, post_dim}); auto min_ranges = input_min_range.template vec<float>(); auto max_ranges = input_max_range.template vec<float>(); for (int i = 0; i < num_slices; ++i) { QuantizeSlice(ctx->eigen_device<Device>(), ctx, input_tensor.template chip<1>(i), min_ranges(i), max_ranges(i), output_tensor.template chip<1>(i), &output_min_tensor->flat<float>()(i), &output_max_tensor->flat<float>()(i)); } }"
"static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode)  { zval *id; xmlDoc *docp = NULL, *newdoc; dom_object *intern; dom_doc_propsptr doc_prop; char *source; int source_len, refcount, ret; long options = 0; htmlParserCtxtPtr ctxt; id = getThis(); if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s|l"", &source, &source_len, &options) == FAILURE) { return; } if (!source_len) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input""); RETURN_FALSE; } if (mode == DOM_LOAD_FILE) { ctxt = htmlCreateFileParserCtxt(source, NULL); } else { source_len = xmlStrlen(source); ctxt = htmlCreateMemoryParserCtxt(source, source_len); } if (!ctxt) { RETURN_FALSE; } if (options) { htmlCtxtUseOptions(ctxt, options); } ctxt->vctxt.error = php_libxml_ctx_error; ctxt->vctxt.warning = php_libxml_ctx_warning; if (ctxt->sax != NULL) { ctxt->sax->error = php_libxml_ctx_error; ctxt->sax->warning = php_libxml_ctx_warning; } htmlParseDocument(ctxt); newdoc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); if (!newdoc) RETURN_FALSE; if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) { intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC); if (intern != NULL) { docp = (xmlDocPtr) dom_object_get_node(intern); doc_prop = NULL; if (docp != NULL) { php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC); doc_prop = intern->document->doc_props; intern->document->doc_props = NULL; refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC); if (refcount != 0) { docp->_private = NULL; } } intern->document = NULL; if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) { RETURN_FALSE; } intern->document->doc_props = doc_prop; } php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC); RETURN_TRUE; } else { DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL); } }"
"void Compute(OpKernelContext* ctx) override { const Tensor& in0 = ctx->input(0); const Tensor& in1 = ctx->input(1); ValidateInputTensors(ctx, in0, in1); MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes()); OP_REQUIRES( ctx, bcast.IsValid(), errors::InvalidArgument( ""In[0] and In[1] must have compatible batch dimensions: "", in0.shape().DebugString(), "" vs. "", in1.shape().DebugString())); TensorShape out_shape = bcast.output_batch_shape(); auto batch_size = bcast.output_batch_size(); auto d0 = in0.dim_size(in0.dims() - 2); auto d1 = in0.dim_size(in0.dims() - 1); Tensor in0_reshaped; OP_REQUIRES( ctx, in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})), errors::Internal(""Failed to reshape In[0] from "", in0.shape().DebugString())); auto d2 = in1.dim_size(in1.dims() - 2); auto d3 = in1.dim_size(in1.dims() - 1); Tensor in1_reshaped; OP_REQUIRES( ctx, in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})), errors::Internal(""Failed to reshape In[1] from "", in1.shape().DebugString())); if (adjoint_) std::swap(d0, d1); OP_REQUIRES(ctx, d1 == d2, errors::InvalidArgument( ""In[0] mismatch In[1] shape: "", d1, "" vs. "", d2, "": "", in0.shape().DebugString(), "" "", in1.shape().DebugString(), "" "", lower_, "" "", adjoint_)); out_shape.AddDim(d0); out_shape.AddDim(d3); Tensor* out = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out)); if (out->NumElements() == 0) { return; } Tensor out_reshaped; OP_REQUIRES(ctx, out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})), errors::Internal(""Failed to reshape output from "", out->shape().DebugString())); LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch( ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast, &out_reshaped); }"
"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && pkt->size < INT_MAX - AVPROBE_PADDING_SIZE && !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) { uint8_t desc[256]; int score      = AVPROBE_SCORE_EXTENSION, ret; AVIStream *ast = st->priv_data; AVInputFormat *sub_demuxer; AVRational time_base; int size; AVIOContext *pb = avio_alloc_context(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desc_len = avio_rl32(pb); if (desc_len > pb->buf_end - pb->buf_ptr) goto error; ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc)); avio_skip(pb, desc_len - ret); if (*desc) av_dict_set(&st->metadata, ""title"", desc, 0); avio_rl16(pb);    avio_rl32(pb);    size = pb->buf_end - pb->buf_ptr; pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE), .buf_size = size }; if (!pd.buf) goto error; memcpy(pd.buf, pb->buf_ptr, size); sub_demuxer = av_probe_input_format2(&pd, 1, &score); av_freep(&pd.buf); if (!sub_demuxer) goto error; if (!(ast->sub_ctx = avformat_alloc_context())) goto error; ast->sub_ctx->pb = pb; if (ff_copy_whiteblacklists(ast->sub_ctx, s) < 0) goto error; if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) { if (ast->sub_ctx->nb_streams != 1) goto error; ff_read_packet(ast->sub_ctx, &ast->sub_pkt); avcodec_parameters_copy(st->codecpar, ast->sub_ctx->streams[0]->codecpar); time_base = ast->sub_ctx->streams[0]->time_base; avpriv_set_pts_info(st, 64, time_base.num, time_base.den); } ast->sub_buffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: av_freep(&ast->sub_ctx); av_freep(&pb); } return 0; }"
"int cap_convert_nscap(struct dentry *dentry, void **ivalue, size_t size) { struct vfs_ns_cap_data *nscap; uid_t nsrootid; const struct vfs_cap_data *cap = *ivalue; __u32 magic, nsmagic; struct inode *inode = d_backing_inode(dentry); struct user_namespace *task_ns = current_user_ns(), *fs_ns = inode->i_sb->s_user_ns; kuid_t rootid; size_t newsize; if (!*ivalue) return -EINVAL; if (!validheader(size, cap)) return -EINVAL; if (!capable_wrt_inode_uidgid(inode, CAP_SETFCAP)) return -EPERM; if (size == XATTR_CAPS_SZ_2) if (ns_capable(inode->i_sb->s_user_ns, CAP_SETFCAP)) return size; rootid = rootid_from_xattr(*ivalue, size, task_ns); if (!uid_valid(rootid)) return -EINVAL; nsrootid = from_kuid(fs_ns, rootid); if (nsrootid == -1) return -EINVAL; newsize = sizeof(struct vfs_ns_cap_data); nscap = kmalloc(newsize, GFP_ATOMIC); if (!nscap) return -ENOMEM; nscap->rootid = cpu_to_le32(nsrootid); nsmagic = VFS_CAP_REVISION_3; magic = le32_to_cpu(cap->magic_etc); if (magic & VFS_CAP_FLAGS_EFFECTIVE) nsmagic |= VFS_CAP_FLAGS_EFFECTIVE; nscap->magic_etc = cpu_to_le32(nsmagic); memcpy(&nscap->data, &cap->data, sizeof(__le32) * 2 * VFS_CAP_U32); kvfree(*ivalue); *ivalue = nscap; return newsize; }"
"static cupsd_job_t * add_job(cupsd_client_t  *con, cupsd_printer_t *printer, mime_type_t     *filetype) { http_status_tstatus; ipp_attribute_t *attr, *auth_info; const char*mandatory; const char*val; intpriority; cupsd_job_t*job; charjob_uri[HTTP_MAX_URI]; intkbytes; inti; intlowerpagerange; intexact; ipp_attribute_t *media_col, *media_margin; ipp_t*unsup_col; static const char * const readonly[] = { ""date-time-at-completed"", ""date-time-at-creation"", ""date-time-at-processing"", ""job-detailed-status-messages"", ""job-document-access-errors"", ""job-id"", ""job-impressions-completed"", ""job-k-octets-completed"", ""job-media-sheets-completed"", ""job-pages-completed"", ""job-printer-up-time"", ""job-printer-uri"", ""job-state"", ""job-state-message"", ""job-state-reasons"", ""job-uri"", ""number-of-documents"", ""number-of-intervening-jobs"", ""output-device-assigned"", ""time-at-completed"", ""time-at-creation"", ""time-at-processing"" }; cupsdLogMessage(CUPSD_LOG_DEBUG2, ""add_job(%p[%d], %p(%s), %p(%s/%s))"", con, con->number, printer, printer->name, filetype, filetype ? filetype->super : ""none"", filetype ? filetype->type : ""none""); if (!printer->shared && _cups_strcasecmp(con->http->hostname, ""localhost"") && _cups_strcasecmp(con->http->hostname, ServerName)) { send_ipp_status(con, IPP_NOT_AUTHORIZED, _(""The printer or class is not shared."")); return (NULL); } auth_info = ippFindAttribute(con->request, ""auth-info"", IPP_TAG_TEXT); if ((status = cupsdCheckPolicy(printer->op_policy_ptr, con, NULL)) != HTTP_OK) { send_http_error(con, status, printer); return (NULL); } else if (printer->num_auth_info_required == 1 && !strcmp(printer->auth_info_required[0], ""negotiate"") && !con->username[0]) { send_http_error(con, HTTP_UNAUTHORIZED, printer); return (NULL); } #ifdef HAVE_SSL else if (auth_info && !con->http->tls && !httpAddrLocalhost(con->http->hostaddr)) { send_http_error(con, HTTP_UPGRADE_REQUIRED, printer); return (NULL); } #endif  if (!printer->accepting) { send_ipp_status(con, IPP_NOT_ACCEPTING, _(""Destination \""%s\"" is not accepting jobs.""), printer->name); return (NULL); } for (i = 0; i < (int)(sizeof(readonly) / sizeof(readonly[0])); i ++) { if ((attr = ippFindAttribute(con->request, readonly[i], IPP_TAG_ZERO)) != NULL) { ippDeleteAttribute(con->request, attr); if (StrictConformance) { send_ipp_status(con, IPP_BAD_REQUEST, _(""The '%s' Job Status attribute cannot be supplied in a job creation request.""), readonly[i]); return (NULL); } cupsdLogMessage(CUPSD_LOG_INFO, ""Unexpected '%s' Job Status attribute in a job creation request."", readonly[i]); } } if (printer->pc) { for (mandatory = (char *)cupsArrayFirst(printer->pc->mandatory); mandatory; mandatory = (char *)cupsArrayNext(printer->pc->mandatory)) { if (!ippFindAttribute(con->request, mandatory, IPP_TAG_ZERO)) { send_ipp_status(con, IPP_CONFLICT, _(""The \""%s\"" attribute is required for print jobs.""), mandatory); return (NULL); } } } if (filetype && printer->filetypes && !cupsArrayFind(printer->filetypes, filetype)) { charmimetype[MIME_MAX_SUPER + MIME_MAX_TYPE + 2]; snprintf(mimetype, sizeof(mimetype), ""%s/%s"", filetype->super, filetype->type); send_ipp_status(con, IPP_DOCUMENT_FORMAT, _(""Unsupported format \""%s\"".""), mimetype); ippAddString(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_MIMETYPE, ""document-format"", NULL, mimetype); return (NULL); } if ((attr = ippFindAttribute(con->request, ""copies"", IPP_TAG_INTEGER)) != NULL) { if (attr->values[0].integer < 1 || attr->values[0].integer > MaxCopies) { send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad copies value %d.""), attr->values[0].integer); ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER, ""copies"", attr->values[0].integer); return (NULL); } } if ((attr = ippFindAttribute(con->request, ""job-sheets"", IPP_TAG_ZERO)) != NULL) { if (attr->value_tag != IPP_TAG_KEYWORD && attr->value_tag != IPP_TAG_NAME) { send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value type."")); return (NULL); } if (attr->num_values > 2) { send_ipp_status(con, IPP_BAD_REQUEST, _(""Too many job-sheets values (%d > 2).""), attr->num_values); return (NULL); } for (i = 0; i < attr->num_values; i ++) if (strcmp(attr->values[i].string.text, ""none"") && !cupsdFindBanner(attr->values[i].string.text)) { send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad job-sheets value \""%s\"".""), attr->values[i].string.text); return (NULL); } } if ((attr = ippFindAttribute(con->request, ""number-up"", IPP_TAG_INTEGER)) != NULL) { if (attr->values[0].integer != 1 && attr->values[0].integer != 2 && attr->values[0].integer != 4 && attr->values[0].integer != 6 && attr->values[0].integer != 9 && attr->values[0].integer != 16) { send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad number-up value %d.""), attr->values[0].integer); ippAddInteger(con->response, IPP_TAG_UNSUPPORTED_GROUP, IPP_TAG_INTEGER, ""number-up"", attr->values[0].integer); return (NULL); } } if ((attr = ippFindAttribute(con->request, ""page-ranges"", IPP_TAG_RANGE)) != NULL) { for (i = 0, lowerpagerange = 1; i < attr->num_values; i ++) { if (attr->values[i].range.lower < lowerpagerange || attr->values[i].range.lower > attr->values[i].range.upper) { send_ipp_status(con, IPP_BAD_REQUEST, _(""Bad page-ranges values %d-%d.""), attr->values[i].range.lower, attr->values[i].range.upper); return (NULL); } lowerpagerange = attr->values[i].range.upper + 1; } } if (!ippFindAttribute(con->request, ""PageRegion"", IPP_TAG_ZERO) && !ippFindAttribute(con->request, ""PageSize"", IPP_TAG_ZERO) && _ppdCacheGetPageSize(printer->pc, con->request, NULL, &exact)) { if (!exact && (media_col = ippFindAttribute(con->request, ""media-col"", IPP_TAG_BEGIN_COLLECTION)) != NULL) { send_ipp_status(con, IPP_OK_SUBST, _(""Unsupported margins."")); unsup_col = ippNew(); if ((media_margin = ippFindAttribute(media_col->values[0].collection, ""media-bottom-margin"", IPP_TAG_INTEGER)) != NULL) ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER, ""media-bottom-margin"", media_margin->values[0].integer); if ((media_margin = ippFindAttribute(media_col->values[0].collection, ""media-left-margin"", IPP_TAG_INTEGER)) != NULL) ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER, ""media-left-margin"", media_margin->values[0].integer); if ((media_margin = ippFindAttribute(media_col->values[0].collection, ""media-right-margin"", IPP_TAG_INTEGER)) != NULL) ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER, ""media-right-margin"", media_margin->values[0].integer); if ((media_margin = ippFindAttribute(media_col->values[0].collection, ""media-top-margin"", IPP_TAG_INTEGER)) != NULL) ippAddInteger(unsup_col, IPP_TAG_ZERO, IPP_TAG_INTEGER, ""media-top-margin"", media_margin->values[0].integer); ippAddCollection(con->response, IPP_TAG_UNSUPPORTED_GROUP, ""media-col"", unsup_col); ippDelete(unsup_col); } } if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs) cupsdCleanJobs(); if (MaxJobs && cupsArrayCount(Jobs) >= MaxJobs) { send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Too many active jobs."")); return (NULL); } if ((i = check_quotas(con, printer)) < 0) { send_ipp_status(con, IPP_NOT_POSSIBLE, _(""Quota limit reached."")); return (NULL); } else if (i == 0) { send_ipp_status(con, IPP_NOT_AUTHORIZED, _(""Not allowed to print."")); return (NULL); } if ((attr = ippFindAttribute(con->request, ""job-priority"", IPP_TAG_INTEGER)) != NULL) priority = attr->values[0].integer; else { if ((val = cupsGetOption(""job-priority"", printer->num_options, printer->options)) != NULL) priority = atoi(val); else priority = 50; ippAddInteger(con->request, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-priority"", priority); } if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_ZERO)) == NULL) ippAddString(con->request, IPP_TAG_JOB, IPP_TAG_NAME, ""job-name"", NULL, ""Untitled""); else if ((attr->value_tag != IPP_TAG_NAME && attr->value_tag != IPP_TAG_NAMELANG) || attr->num_values != 1) { send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad job-name value: Wrong type or count."")); if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL) attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP; return (NULL); } else if (!ippValidateAttribute(attr)) { send_ipp_status(con, IPP_ATTRIBUTES, _(""Bad job-name value: %s""), cupsLastErrorString()); if ((attr = ippCopyAttribute(con->response, attr, 0)) != NULL) attr->group_tag = IPP_TAG_UNSUPPORTED_GROUP; return (NULL); } if ((job = cupsdAddJob(priority, printer->name)) == NULL) { send_ipp_status(con, IPP_INTERNAL_ERROR, _(""Unable to add job for destination \""%s\"".""), printer->name); return (NULL); } job->dtype   = printer->type & (CUPS_PRINTER_CLASS | CUPS_PRINTER_REMOTE); job->attrs   = con->request; job->dirty   = 1; con->request = ippNewRequest(job->attrs->request.op.operation_id); cupsdMarkDirty(CUPSD_DIRTY_JOBS); add_job_uuid(job); apply_printer_defaults(printer, job); attr = ippFindAttribute(job->attrs, ""requesting-user-name"", IPP_TAG_NAME); if (con->username[0]) { cupsdSetString(&job->username, con->username); if (attr) ippSetString(job->attrs, &attr, 0, con->username); } else if (attr) { cupsdLogMessage(CUPSD_LOG_DEBUG, ""add_job: requesting-user-name=\""%s\"""", attr->values[0].string.text); cupsdSetString(&job->username, attr->values[0].string.text); } else cupsdSetString(&job->username, ""anonymous""); if (!attr) ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-originating-user-name"", NULL, job->username); else { ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB); ippSetName(job->attrs, &attr, ""job-originating-user-name""); } if (con->username[0] || auth_info) { save_auth_info(con, job, auth_info); if (auth_info) ippDeleteAttribute(job->attrs, auth_info); } if ((attr = ippFindAttribute(con->request, ""job-name"", IPP_TAG_NAME)) != NULL) cupsdSetString(&(job->name), attr->values[0].string.text); if ((attr = ippFindAttribute(job->attrs, ""job-originating-host-name"", IPP_TAG_ZERO)) != NULL) { if (attr->value_tag != IPP_TAG_NAME || attr->num_values != 1 || strcmp(con->http->hostname, ""localhost"")) { ippDeleteAttribute(job->attrs, attr); ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-originating-host-name"", NULL, con->http->hostname); } else ippSetGroupTag(job->attrs, &attr, IPP_TAG_JOB); } else { ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-originating-host-name"", NULL, con->http->hostname); } ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-completed""); ippAddDate(job->attrs, IPP_TAG_JOB, ""date-time-at-creation"", ippTimeToDate(time(NULL))); ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""date-time-at-processing""); ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-completed""); ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""time-at-creation"", time(NULL)); ippAddOutOfBand(job->attrs, IPP_TAG_JOB, IPP_TAG_NOVALUE, ""time-at-processing""); ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id); job->state = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_ENUM, ""job-state"", IPP_JOB_STOPPED); job->state_value = (ipp_jstate_t)job->state->values[0].integer; job->reasons = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD, ""job-state-reasons"", NULL, ""job-incoming""); job->impressions = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-impressions-completed"", 0); job->sheets = ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-media-sheets-completed"", 0); ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_URI, ""job-printer-uri"", NULL, printer->uri); if ((attr = ippFindAttribute(job->attrs, ""job-k-octets"", IPP_TAG_INTEGER)) != NULL) attr->values[0].integer = 0; else ippAddInteger(job->attrs, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-k-octets"", 0); if ((attr = ippFindAttribute(job->attrs, ""job-hold-until"", IPP_TAG_KEYWORD)) == NULL) attr = ippFindAttribute(job->attrs, ""job-hold-until"", IPP_TAG_NAME); if (!attr) { if ((val = cupsGetOption(""job-hold-until"", printer->num_options, printer->options)) == NULL) val = ""no-hold""; attr = ippAddString(job->attrs, IPP_TAG_JOB, IPP_TAG_KEYWORD, ""job-hold-until"", NULL, val); } if (printer->holding_new_jobs) { if (attr && strcmp(attr->values[0].string.text, ""no-hold"")) cupsdSetJobHoldUntil(job, ippGetString(attr, 0, NULL), 0); else cupsdSetJobHoldUntil(job, ""indefinite"", 0); job->state->values[0].integer = IPP_JOB_HELD; job->state_value              = IPP_JOB_HELD; ippSetString(job->attrs, &job->reasons, 0, ""job-held-on-create""); } else if (attr && strcmp(attr->values[0].string.text, ""no-hold"")) { cupsdSetJobHoldUntil(job, attr->values[0].string.text, 0); job->state->values[0].integer = IPP_JOB_HELD; job->state_value              = IPP_JOB_HELD; ippSetString(job->attrs, &job->reasons, 0, ""job-hold-until-specified""); } else if (job->attrs->request.op.operation_id == IPP_CREATE_JOB) { job->hold_until               = time(NULL) + MultipleOperationTimeout; job->state->values[0].integer = IPP_JOB_HELD; job->state_value              = IPP_JOB_HELD; } else { job->state->values[0].integer = IPP_JOB_PENDING; job->state_value              = IPP_JOB_PENDING; ippSetString(job->attrs, &job->reasons, 0, ""none""); } if (!(printer->type & CUPS_PRINTER_REMOTE) || Classification) { if ((attr = ippFindAttribute(job->attrs, ""job-sheets"", IPP_TAG_ZERO)) == NULL) { cupsdLogMessage(CUPSD_LOG_DEBUG, ""Adding default job-sheets values \""%s,%s\""..."", printer->job_sheets[0], printer->job_sheets[1]); attr = ippAddStrings(job->attrs, IPP_TAG_JOB, IPP_TAG_NAME, ""job-sheets"", 2, NULL, NULL); ippSetString(job->attrs, &attr, 0, printer->job_sheets[0]); ippSetString(job->attrs, &attr, 1, printer->job_sheets[1]); } job->job_sheets = attr; if (Classification) { cupsdLogMessage(CUPSD_LOG_INFO, ""Classification=\""%s\"", ClassifyOverride=%d"", Classification ? Classification : ""(null)"", ClassifyOverride); if (ClassifyOverride) { if (!strcmp(attr->values[0].string.text, ""none"") && (attr->num_values == 1 || !strcmp(attr->values[1].string.text, ""none""))) { ippSetString(job->attrs, &attr, 0, Classification); cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED "" ""job-sheets=\""%s,none\"", "" ""job-originating-user-name=\""%s\"""", Classification, job->username); } else if (attr->num_values == 2 && strcmp(attr->values[0].string.text, attr->values[1].string.text) && strcmp(attr->values[0].string.text, ""none"") && strcmp(attr->values[1].string.text, ""none"")) { ippSetString(job->attrs, &attr, 1, attr->values[0].string.text); cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED "" ""job-sheets=\""%s,%s\"", "" ""job-originating-user-name=\""%s\"""", attr->values[0].string.text, attr->values[1].string.text, job->username); } else if (strcmp(attr->values[0].string.text, Classification) && strcmp(attr->values[0].string.text, ""none"") && (attr->num_values == 1 || (strcmp(attr->values[1].string.text, Classification) && strcmp(attr->values[1].string.text, ""none"")))) { if (attr->num_values == 1) cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION OVERRIDDEN "" ""job-sheets=\""%s\"", "" ""job-originating-user-name=\""%s\"""", attr->values[0].string.text, job->username); else cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION OVERRIDDEN "" ""job-sheets=\""%s,%s\"",fffff "" ""job-originating-user-name=\""%s\"""", attr->values[0].string.text, attr->values[1].string.text, job->username); } } else if (strcmp(attr->values[0].string.text, Classification) && (attr->num_values == 1 || strcmp(attr->values[1].string.text, Classification))) { if (attr->num_values > 1 && !strcmp(attr->values[0].string.text, attr->values[1].string.text)) { ippSetString(job->attrs, &attr, 0, Classification); ippSetString(job->attrs, &attr, 1, Classification); } else { if (attr->num_values == 1 || strcmp(attr->values[0].string.text, ""none"")) ippSetString(job->attrs, &attr, 0, Classification); if (attr->num_values > 1 && strcmp(attr->values[1].string.text, ""none"")) ippSetString(job->attrs, &attr, 1, Classification); } if (attr->num_values > 1) cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED "" ""job-sheets=\""%s,%s\"", "" ""job-originating-user-name=\""%s\"""", attr->values[0].string.text, attr->values[1].string.text, job->username); else cupsdLogJob(job, CUPSD_LOG_NOTICE, ""CLASSIFICATION FORCED "" ""job-sheets=\""%s\"", "" ""job-originating-user-name=\""%s\"""", Classification, job->username); } } if (!(printer->type & CUPS_PRINTER_REMOTE)) { cupsdLogJob(job, CUPSD_LOG_INFO, ""Adding start banner page \""%s\""."", attr->values[0].string.text); if ((kbytes = copy_banner(con, job, attr->values[0].string.text)) < 0) { cupsdSetJobState(job, IPP_JOB_ABORTED, CUPSD_JOB_PURGE, ""Aborting job because the start banner could not be "" ""copied.""); return (NULL); } cupsdUpdateQuota(printer, job->username, 0, kbytes); } } else if ((attr = ippFindAttribute(job->attrs, ""job-sheets"", IPP_TAG_ZERO)) != NULL) job->job_sheets = attr; httpAssembleURIf(HTTP_URI_CODING_ALL, job_uri, sizeof(job_uri), ""ipp"", NULL, con->clientname, con->clientport, ""/jobs/%d"", job->id); ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_URI, ""job-uri"", NULL, job_uri); ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_INTEGER, ""job-id"", job->id); ippAddInteger(con->response, IPP_TAG_JOB, IPP_TAG_ENUM, ""job-state"", job->state_value); ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_TEXT, ""job-state-message"", NULL, """"); ippAddString(con->response, IPP_TAG_JOB, IPP_TAG_KEYWORD, ""job-state-reasons"", NULL, job->reasons->values[0].string.text); con->response->request.status.status_code = IPP_OK; add_job_subscriptions(con, job); for (attr = job->attrs->attrs->next->next; attr; attr = attr->next) attr->group_tag = IPP_TAG_JOB; cupsdAddEvent(CUPSD_EVENT_JOB_CREATED, printer, job, ""Job created.""); return (job); }"
"uint64_t ThreadCommand::pc() const { uint64_t entry = 0; switch(architecture_) { case CPU_TYPES::CPU_TYPE_X86: { entry = reinterpret_cast<const details::x86_thread_state_t*>(state_.data())->eip; break; } case CPU_TYPES::CPU_TYPE_X86_64: { entry = reinterpret_cast<const details::x86_thread_state64_t*>(state_.data())->rip; break; } case CPU_TYPES::CPU_TYPE_ARM: { entry = reinterpret_cast<const details::arm_thread_state_t*>(state_.data())->r15; break; } case CPU_TYPES::CPU_TYPE_ARM64: { entry = reinterpret_cast<const details::arm_thread_state64_t*>(state_.data())->pc; break; } default: { LIEF_ERR(""Unknown architecture""); } } return entry; }"
"static const ut8 *r_bin_dwarf_parse_comp_unit(Sdb *s, const ut8 *obuf, RBinDwarfCompUnit *cu, const RBinDwarfDebugAbbrev *da, size_t offset, const ut8 *debug_str, size_t debug_str_len) { const ut8 *buf = obuf, *buf_end = obuf + (cu->hdr.length - 7); ut64 abbr_code; size_t i; if (cu->hdr.length > debug_str_len) { return NULL; } while (buf && buf < buf_end && buf >= obuf) { if (cu->length && cu->capacity == cu->length) { r_bin_dwarf_expand_cu (cu); } buf = r_uleb128 (buf, buf_end - buf, &abbr_code); if (abbr_code > da->length || !buf) { return NULL; } r_bin_dwarf_init_die (&cu->dies[cu->length]); if (!abbr_code) { cu->dies[cu->length].abbrev_code = 0; cu->length++; buf++; continue; } cu->dies[cu->length].abbrev_code = abbr_code; cu->dies[cu->length].tag = da->decls[abbr_code - 1].tag; abbr_code += offset; if (da->capacity < abbr_code) { return NULL; } for (i = 0; i < da->decls[abbr_code - 1].length; i++) { if (cu->dies[cu->length].length == cu->dies[cu->length].capacity) { r_bin_dwarf_expand_die (&cu->dies[cu->length]); } if (i >= cu->dies[cu->length].capacity || i >= da->decls[abbr_code - 1].capacity) { eprintf (""Warning: malformed dwarf attribute capacity doesn't match length\n""); break; } memset (&cu->dies[cu->length].attr_values[i], 0, sizeof (cu->dies[cu->length].attr_values[i])); buf = r_bin_dwarf_parse_attr_value (buf, buf_end - buf, &da->decls[abbr_code - 1].specs[i], &cu->dies[cu->length].attr_values[i], &cu->hdr, debug_str, debug_str_len); if (cu->dies[cu->length].attr_values[i].name == DW_AT_comp_dir) { const char *name = cu->dies[cu->length].attr_values[i].encoding.str_struct.string; sdb_set (s, ""DW_AT_comp_dir"", name, 0); } cu->dies[cu->length].length++; } cu->length++; } return buf; }"
"krb5_error_code kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request, const krb5_enc_tkt_part *t2enc, const krb5_db_entry *server, krb5_const_principal server_princ, krb5_const_principal proxy_princ, const char **status) { krb5_error_code errcode; if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) { return KRB5KDC_ERR_BADOPTION; } if (!krb5_principal_compare(kdc_context, server->princ,  server_princ)) { return KRB5KDC_ERR_SERVER_NOMATCH; } if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) { *status = ""EVIDENCE_TKT_NOT_FORWARDABLE""; return KRB5_TKT_NOT_FORWARDABLE; } errcode = check_allowed_to_delegate_to(kdc_context, t2enc->client, server, proxy_princ); if (errcode) { *status = ""NOT_ALLOWED_TO_DELEGATE""; return errcode; } return 0; }"
"int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc) { struct scsi_device *SDev; struct scsi_sense_hdr sshdr; int result, err = 0, retries = 0; SDev = cd->device; retry: if (!scsi_block_when_processing_errors(SDev)) { err = -ENODEV; goto out; } result = scsi_execute(SDev, cgc->cmd, cgc->data_direction, cgc->buffer, cgc->buflen, (unsigned char *)cgc->sense, &sshdr, cgc->timeout, IOCTL_RETRIES, 0, 0, NULL); if (driver_byte(result) != 0) { switch (sshdr.sense_key) { case UNIT_ATTENTION: SDev->changed = 1; if (!cgc->quiet) sr_printk(KERN_INFO, cd, ""disc change detected.\n""); if (retries++ < 10) goto retry; err = -ENOMEDIUM; break; case NOT_READY: if (sshdr.asc == 0x04 && sshdr.ascq == 0x01) { if (!cgc->quiet) sr_printk(KERN_INFO, cd, ""CDROM not ready yet.\n""); if (retries++ < 10) { ssleep(2); goto retry; } else { err = -ENOMEDIUM; break; } } if (!cgc->quiet) sr_printk(KERN_INFO, cd, ""CDROM not ready.  Make sure there "" ""is a disc in the drive.\n""); err = -ENOMEDIUM; break; case ILLEGAL_REQUEST: err = -EIO; if (sshdr.asc == 0x20 && sshdr.ascq == 0x00) err = -EDRIVE_CANT_DO_THIS; break; default: err = -EIO; } } out: cgc->stat = err; return err; }"
"static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC) { uint64_t max_vars = PG(max_input_vars); vars->ptr = vars->str.c; vars->end = vars->str.c + vars->str.len; while (add_post_var(arr, vars, eof TSRMLS_CC)) { if (++vars->cnt > max_vars) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Input variables exceeded %"" PRIu64 "". "" ""To increase the limit change max_input_vars in php.ini."", max_vars); return FAILURE; } } if (!eof) { memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr); } return SUCCESS; }"
CSecurityTLS::~CSecurityTLS() { shutdown(true); if (fis) delete fis; if (fos) delete fos; delete[] cafile; delete[] crlfile; }
"static int synic_set_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 data, bool host) { struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic); int ret; if (!synic->active && !host) return 1; trace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host); ret = 0; switch (msr) { case HV_X64_MSR_SCONTROL: synic->control = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_SVERSION: if (!host) { ret = 1; break; } synic->version = data; break; case HV_X64_MSR_SIEFP: if ((data & HV_SYNIC_SIEFP_ENABLE) && !host && !synic->dont_zero_synic_pages) if (kvm_clear_guest(vcpu->kvm, data & PAGE_MASK, PAGE_SIZE)) { ret = 1; break; } synic->evt_page = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_SIMP: if ((data & HV_SYNIC_SIMP_ENABLE) && !host && !synic->dont_zero_synic_pages) if (kvm_clear_guest(vcpu->kvm, data & PAGE_MASK, PAGE_SIZE)) { ret = 1; break; } synic->msg_page = data; if (!host) synic_exit(synic, msr); break; case HV_X64_MSR_EOM: { int i; for (i = 0; i < ARRAY_SIZE(synic->sint); i++) kvm_hv_notify_acked_sint(vcpu, i); break; } case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: ret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host); break; default: ret = 1; break; } return ret; }"
"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC) { php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract; int ret; assert(ts != NULL); if (!ts->innerstream) { *newoffs = -1; return -1; } ret = php_stream_seek(ts->innerstream, offset, whence); *newoffs = php_stream_tell(ts->innerstream); stream->eof = ts->innerstream->eof; return ret; }"
"char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) { char *p = strchr(reply+1,'\r'); long long mbulklen; int j = 0; string2ll(reply+1,p-reply-1,&mbulklen); if (server.lua_client->resp == 2 || atype == '*') { p += 2; if (mbulklen == -1) { lua_pushboolean(lua,0); return p; } lua_newtable(lua); for (j = 0; j < mbulklen; j++) { lua_pushnumber(lua,j+1); p = redisProtocolToLuaType(lua,p); lua_settable(lua,-3); } } else if (server.lua_client->resp == 3) { p += 2; lua_newtable(lua); lua_pushstring(lua,atype == '%' ? ""map"" : ""set""); lua_newtable(lua); for (j = 0; j < mbulklen; j++) { p = redisProtocolToLuaType(lua,p); if (atype == '%') { p = redisProtocolToLuaType(lua,p); } else { lua_pushboolean(lua,1); } lua_settable(lua,-3); } lua_settable(lua,-3); } return p; }"
"static void babel_print_v2(netdissect_options *ndo, const u_char *cp, u_int length) { u_int i; u_short bodylen; u_char v4_prefix[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF, 0, 0, 0, 0 }; u_char v6_prefix[16] = {0}; ND_TCHECK2(*cp, 4); if (length < 4) goto invalid; bodylen = EXTRACT_16BITS(cp + 2); ND_PRINT((ndo, "" (%u)"", bodylen)); i = 0; while(i < bodylen) { const u_char *message; u_int type, len; message = cp + 4 + i; ND_TCHECK2(*message, 1); if((type = message[0]) == MESSAGE_PAD1) { ND_PRINT((ndo, ndo->ndo_vflag ? ""\n\tPad 1"" : "" pad1"")); i += 1; continue; } ND_TCHECK2(*message, 2); ICHECK(i, 2); len = message[1]; ND_TCHECK2(*message, 2 + len); ICHECK(i, 2 + len); switch(type) { case MESSAGE_PADN: { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" padN"")); else ND_PRINT((ndo, ""\n\tPad %d"", len + 2)); } break; case MESSAGE_ACK_REQ: { u_short nonce, interval; if (!ndo->ndo_vflag) ND_PRINT((ndo, "" ack-req"")); else { ND_PRINT((ndo, ""\n\tAcknowledgment Request "")); if(len < 6) goto invalid; nonce = EXTRACT_16BITS(message + 4); interval = EXTRACT_16BITS(message + 6); ND_PRINT((ndo, ""%04x %s"", nonce, format_interval(interval))); } } break; case MESSAGE_ACK: { u_short nonce; if (!ndo->ndo_vflag) ND_PRINT((ndo, "" ack"")); else { ND_PRINT((ndo, ""\n\tAcknowledgment "")); if(len < 2) goto invalid; nonce = EXTRACT_16BITS(message + 2); ND_PRINT((ndo, ""%04x"", nonce)); } } break; case MESSAGE_HELLO:  { u_short seqno, interval; if (!ndo->ndo_vflag) ND_PRINT((ndo, "" hello"")); else { ND_PRINT((ndo, ""\n\tHello "")); if(len < 6) goto invalid; seqno = EXTRACT_16BITS(message + 4); interval = EXTRACT_16BITS(message + 6); ND_PRINT((ndo, ""seqno %u interval %s"", seqno, format_interval(interval))); if(len > 6) subtlvs_print(ndo, message + 8, message + 2 + len, type); } } break; case MESSAGE_IHU: { unsigned short txcost, interval; if (!ndo->ndo_vflag) ND_PRINT((ndo, "" ihu"")); else { u_char address[16]; int rc; ND_PRINT((ndo, ""\n\tIHU "")); if(len < 6) goto invalid; txcost = EXTRACT_16BITS(message + 4); interval = EXTRACT_16BITS(message + 6); rc = network_address(message[2], message + 8, len - 6, address); if(rc < 0) { ND_PRINT((ndo, ""%s"", tstr)); break; } ND_PRINT((ndo, ""%s txcost %u interval %s"", format_address(ndo, address), txcost, format_interval(interval))); if((u_int)rc < len - 6) subtlvs_print(ndo, message + 8 + rc, message + 2 + len, type); } } break; case MESSAGE_ROUTER_ID: { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" router-id"")); else { ND_PRINT((ndo, ""\n\tRouter Id"")); if(len < 10) goto invalid; ND_PRINT((ndo, "" %s"", format_id(message + 4))); } } break; case MESSAGE_NH: { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" nh"")); else { int rc; u_char nh[16]; ND_PRINT((ndo, ""\n\tNext Hop"")); if(len < 2) goto invalid; rc = network_address(message[2], message + 4, len - 2, nh); if(rc < 0) goto invalid; ND_PRINT((ndo, "" %s"", format_address(ndo, nh))); } } break; case MESSAGE_UPDATE: { if (!ndo->ndo_vflag) { ND_PRINT((ndo, "" update"")); if(len < 1) ND_PRINT((ndo, ""/truncated"")); else ND_PRINT((ndo, ""%s%s%s"", (message[3] & 0x80) ? ""/prefix"": """", (message[3] & 0x40) ? ""/id"" : """", (message[3] & 0x3f) ? ""/unknown"" : """")); } else { u_short interval, seqno, metric; u_char plen; int rc; u_char prefix[16]; ND_PRINT((ndo, ""\n\tUpdate"")); if(len < 10) goto invalid; plen = message[4] + (message[2] == 1 ? 96 : 0); rc = network_prefix(message[2], message[4], message[5], message + 12, message[2] == 1 ? v4_prefix : v6_prefix, len - 10, prefix); if(rc < 0) goto invalid; interval = EXTRACT_16BITS(message + 6); seqno = EXTRACT_16BITS(message + 8); metric = EXTRACT_16BITS(message + 10); ND_PRINT((ndo, ""%s%s%s %s metric %u seqno %u interval %s"", (message[3] & 0x80) ? ""/prefix"": """", (message[3] & 0x40) ? ""/id"" : """", (message[3] & 0x3f) ? ""/unknown"" : """", format_prefix(ndo, prefix, plen), metric, seqno, format_interval_update(interval))); if(message[3] & 0x80) { if(message[2] == 1) memcpy(v4_prefix, prefix, 16); else memcpy(v6_prefix, prefix, 16); } if((u_int)rc < len - 10) subtlvs_print(ndo, message + 12 + rc, message + 2 + len, type); } } break; case MESSAGE_REQUEST: { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" request"")); else { int rc; u_char prefix[16], plen; ND_PRINT((ndo, ""\n\tRequest "")); if(len < 2) goto invalid; plen = message[3] + (message[2] == 1 ? 96 : 0); rc = network_prefix(message[2], message[3], 0, message + 4, NULL, len - 2, prefix); if(rc < 0) goto invalid; ND_PRINT((ndo, ""for %s"", message[2] == 0 ? ""any"" : format_prefix(ndo, prefix, plen))); } } break; case MESSAGE_MH_REQUEST : { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" mh-request"")); else { int rc; u_short seqno; u_char prefix[16], plen; ND_PRINT((ndo, ""\n\tMH-Request "")); if(len < 14) goto invalid; seqno = EXTRACT_16BITS(message + 4); rc = network_prefix(message[2], message[3], 0, message + 16, NULL, len - 14, prefix); if(rc < 0) goto invalid; plen = message[3] + (message[2] == 1 ? 96 : 0); ND_PRINT((ndo, ""(%u hops) for %s seqno %u id %s"", message[6], format_prefix(ndo, prefix, plen), seqno, format_id(message + 8))); } } break; case MESSAGE_TSPC : if (!ndo->ndo_vflag) ND_PRINT((ndo, "" tspc"")); else { ND_PRINT((ndo, ""\n\tTS/PC "")); if(len < 6) goto invalid; ND_PRINT((ndo, ""timestamp %u packetcounter %u"", EXTRACT_32BITS (message + 4), EXTRACT_16BITS(message + 2))); } break; case MESSAGE_HMAC : { if (!ndo->ndo_vflag) ND_PRINT((ndo, "" hmac"")); else { unsigned j; ND_PRINT((ndo, ""\n\tHMAC "")); if(len < 18) goto invalid; ND_PRINT((ndo, ""key-id %u digest-%u "", EXTRACT_16BITS(message + 2), len - 2)); for (j = 0; j < len - 2; j++) ND_PRINT((ndo, ""%02X"", message[4 + j])); } } break; case MESSAGE_UPDATE_SRC_SPECIFIC : { if(!ndo->ndo_vflag) { ND_PRINT((ndo, "" ss-update"")); } else { u_char prefix[16], src_prefix[16]; u_short interval, seqno, metric; u_char ae, plen, src_plen, omitted; int rc; int parsed_len = 10; ND_PRINT((ndo, ""\n\tSS-Update"")); if(len < 10) goto invalid; ae = message[2]; src_plen = message[3]; plen = message[4]; omitted = message[5]; interval = EXTRACT_16BITS(message + 6); seqno = EXTRACT_16BITS(message + 8); metric = EXTRACT_16BITS(message + 10); rc = network_prefix(ae, plen, omitted, message + 2 + parsed_len, ae == 1 ? v4_prefix : v6_prefix, len - parsed_len, prefix); if(rc < 0) goto invalid; if(ae == 1) plen += 96; parsed_len += rc; rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len, NULL, len - parsed_len, src_prefix); if(rc < 0) goto invalid; if(ae == 1) src_plen += 96; parsed_len += rc; ND_PRINT((ndo, "" %s from"", format_prefix(ndo, prefix, plen))); ND_PRINT((ndo, "" %s metric %u seqno %u interval %s"", format_prefix(ndo, src_prefix, src_plen), metric, seqno, format_interval_update(interval))); if((u_int)parsed_len < len) subtlvs_print(ndo, message + 2 + parsed_len, message + 2 + len, type); } } break; case MESSAGE_REQUEST_SRC_SPECIFIC : { if(!ndo->ndo_vflag) ND_PRINT((ndo, "" ss-request"")); else { int rc, parsed_len = 3; u_char ae, plen, src_plen, prefix[16], src_prefix[16]; ND_PRINT((ndo, ""\n\tSS-Request "")); if(len < 3) goto invalid; ae = message[2]; plen = message[3]; src_plen = message[4]; rc = network_prefix(ae, plen, 0, message + 2 + parsed_len, NULL, len - parsed_len, prefix); if(rc < 0) goto invalid; if(ae == 1) plen += 96; parsed_len += rc; rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len, NULL, len - parsed_len, src_prefix); if(rc < 0) goto invalid; if(ae == 1) src_plen += 96; parsed_len += rc; if(ae == 0) { ND_PRINT((ndo, ""for any"")); } else { ND_PRINT((ndo, ""for (%s, "", format_prefix(ndo, prefix, plen))); ND_PRINT((ndo, ""%s)"", format_prefix(ndo, src_prefix, src_plen))); } } } break; case MESSAGE_MH_REQUEST_SRC_SPECIFIC : { if(!ndo->ndo_vflag) ND_PRINT((ndo, "" ss-mh-request"")); else { int rc, parsed_len = 14; u_short seqno; u_char ae, plen, src_plen, prefix[16], src_prefix[16], hopc; const u_char *router_id = NULL; ND_PRINT((ndo, ""\n\tSS-MH-Request "")); if(len < 14) goto invalid; ae = message[2]; plen = message[3]; seqno = EXTRACT_16BITS(message + 4); hopc = message[6]; src_plen = message[7]; router_id = message + 8; rc = network_prefix(ae, plen, 0, message + 2 + parsed_len, NULL, len - parsed_len, prefix); if(rc < 0) goto invalid; if(ae == 1) plen += 96; parsed_len += rc; rc = network_prefix(ae, src_plen, 0, message + 2 + parsed_len, NULL, len - parsed_len, src_prefix); if(rc < 0) goto invalid; if(ae == 1) src_plen += 96; ND_PRINT((ndo, ""(%u hops) for (%s, "", hopc, format_prefix(ndo, prefix, plen))); ND_PRINT((ndo, ""%s) seqno %u id %s"", format_prefix(ndo, src_prefix, src_plen), seqno, format_id(router_id))); } } break; default: if (!ndo->ndo_vflag) ND_PRINT((ndo, "" unknown"")); else ND_PRINT((ndo, ""\n\tUnknown message type %d"", type)); } i += len + 2; } return; trunc: ND_PRINT((ndo, "" %s"", tstr)); return; invalid: ND_PRINT((ndo, ""%s"", istr)); return; }"
"int dw_spi_add_host(struct device *dev, struct dw_spi *dws) { struct spi_controller *master; int ret; BUG_ON(dws == NULL); master = spi_alloc_master(dev, 0); if (!master) return -ENOMEM; dws->master = master; dws->type = SSI_MOTO_SPI; dws->dma_inited = 0; dws->dma_addr = (dma_addr_t)(dws->paddr + DW_SPI_DR); spi_controller_set_devdata(master, dws); ret = request_irq(dws->irq, dw_spi_irq, IRQF_SHARED, dev_name(dev), master); if (ret < 0) { dev_err(dev, ""can not get IRQ\n""); goto err_free_master; } master->use_gpio_descriptors = true; master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_LOOP; master->bits_per_word_mask =  SPI_BPW_RANGE_MASK(4, 16); master->bus_num = dws->bus_num; master->num_chipselect = dws->num_cs; master->setup = dw_spi_setup; master->cleanup = dw_spi_cleanup; master->set_cs = dw_spi_set_cs; master->transfer_one = dw_spi_transfer_one; master->handle_err = dw_spi_handle_err; master->max_speed_hz = dws->max_freq; master->dev.of_node = dev->of_node; master->dev.fwnode = dev->fwnode; master->flags = SPI_MASTER_GPIO_SS; master->auto_runtime_pm = true; if (dws->set_cs) master->set_cs = dws->set_cs; spi_hw_init(dev, dws); if (dws->dma_ops && dws->dma_ops->dma_init) { ret = dws->dma_ops->dma_init(dws); if (ret) { dev_warn(dev, ""DMA init failed\n""); dws->dma_inited = 0; } else { master->can_dma = dws->dma_ops->can_dma; } } ret = devm_spi_register_controller(dev, master); if (ret) { dev_err(&master->dev, ""problem registering spi master\n""); goto err_dma_exit; } dw_spi_debugfs_init(dws); return 0; err_dma_exit: if (dws->dma_ops && dws->dma_ops->dma_exit) dws->dma_ops->dma_exit(dws); spi_enable_chip(dws, 0); free_irq(dws->irq, master); err_free_master: spi_controller_put(master); return ret; }"
"static int ib_prctl_set(struct task_struct *task, unsigned long ctrl) { switch (ctrl) { case PR_SPEC_ENABLE: if (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE && spectre_v2_user_stibp == SPECTRE_V2_USER_NONE) return 0; if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED) return -EPERM; task_clear_spec_ib_disable(task); task_update_spec_tif(task); break; case PR_SPEC_DISABLE: case PR_SPEC_FORCE_DISABLE: if (spectre_v2_user_ibpb == SPECTRE_V2_USER_NONE && spectre_v2_user_stibp == SPECTRE_V2_USER_NONE) return -EPERM; if (spectre_v2_user_ibpb == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT || spectre_v2_user_stibp == SPECTRE_V2_USER_STRICT_PREFERRED) return 0; task_set_spec_ib_disable(task); if (ctrl == PR_SPEC_FORCE_DISABLE) task_set_spec_ib_force_disable(task); task_update_spec_tif(task); break; default: return -ERANGE; } return 0; }"
"void dvb_dmxdev_release(struct dmxdev *dmxdev) { dmxdev->exit = 1; if (dmxdev->dvbdev->users > 1) { wait_event(dmxdev->dvbdev->wait_queue, dmxdev->dvbdev->users == 1); } if (dmxdev->dvr_dvbdev->users > 1) { wait_event(dmxdev->dvr_dvbdev->wait_queue, dmxdev->dvr_dvbdev->users == 1); } dvb_unregister_device(dmxdev->dvbdev); dvb_unregister_device(dmxdev->dvr_dvbdev); vfree(dmxdev->filter); dmxdev->filter = NULL; dmxdev->demux->close(dmxdev->demux); }"
"void isis_notif_authentication_failure(const struct isis_circuit *circuit, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:authentication-failure""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_authentication_failure, circuit, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai) { ASN1_INTEGER *ret; int len, j; if (ai == NULL) ret = M_ASN1_INTEGER_new(); else ret = ai; if (ret == NULL) { ASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_NESTED_ASN1_ERROR); goto err; } if (BN_is_negative(bn)) ret->type = V_ASN1_NEG_INTEGER; else ret->type = V_ASN1_INTEGER; j = BN_num_bits(bn); len = ((j == 0) ? 0 : ((j / 8) + 1)); if (ret->length < len + 4) { unsigned char *new_data = OPENSSL_realloc(ret->data, len + 4); if (!new_data) { ASN1err(ASN1_F_BN_TO_ASN1_INTEGER, ERR_R_MALLOC_FAILURE); goto err; } ret->data = new_data; } ret->length = BN_bn2bin(bn, ret->data); if (!ret->length) { ret->data[0] = 0; ret->length = 1; } return (ret); err: if (ret != ai) M_ASN1_INTEGER_free(ret); return (NULL); }"
"TfLiteStatus Subgraph::Invoke() { if (!consistent_) { ReportError(""Invoke called on model that is not consistent.""); return kTfLiteError; } TfLiteStatus status = kTfLiteOk; if (state_ == kStateUninvokable) { ReportError(""Invoke called on model that is not ready.""); return kTfLiteError; } else if (memory_planner_ && !memory_planner_->HasNonPersistentMemory()) { ReportError(""Non-persistent memory is not available.""); return kTfLiteError; } TFLITE_SCOPED_TAGGED_DEFAULT_PROFILE(profiler_.get(), ""Invoke""); for (int execution_plan_index = 0; execution_plan_index < execution_plan_.size(); execution_plan_index++) { if (execution_plan_index == next_execution_plan_index_to_prepare_) { TF_LITE_ENSURE_STATUS(PrepareOpsAndTensors()); TF_LITE_ENSURE(&context_, next_execution_plan_index_to_prepare_ >= execution_plan_index); } int node_index = execution_plan_[execution_plan_index]; TfLiteNode& node = nodes_and_registration_[node_index].first; const TfLiteRegistration& registration = nodes_and_registration_[node_index].second; const char* op_name = nullptr; if (profiler_) op_name = GetTFLiteOpName(registration); TFLITE_SCOPED_TAGGED_OPERATOR_PROFILE(profiler_.get(), op_name, node_index); for (int i = 0; i < node.inputs->size; ++i) { int tensor_index = node.inputs->data[i]; if (tensor_index == kTfLiteOptionalTensor) { continue; } TfLiteTensor* tensor = &tensors_[tensor_index]; if (tensor->delegate && tensor->delegate != node.delegate && tensor->data_is_stale) { TF_LITE_ENSURE_STATUS(EnsureTensorDataIsReadable(tensor_index)); } if (tensor->data.raw == nullptr && tensor->bytes > 0) { if (registration.builtin_code == kTfLiteBuiltinReshape && i == 1 && tensor->dims->size != 1) { continue; } else { ReportError(""Input tensor %d lacks data"", tensor_index); return kTfLiteError; } } } if (check_cancelled_func_ != nullptr && check_cancelled_func_(cancellation_data_)) { ReportError(""Client requested cancel during Invoke()""); return kTfLiteError; } EnsureTensorsVectorCapacity(); tensor_resized_since_op_invoke_ = false; if (OpInvoke(registration, &node) != kTfLiteOk) { return ReportOpError(&context_, node, registration, node_index, ""failed to invoke""); } if (tensor_resized_since_op_invoke_ && HasDynamicTensor(context_, node.outputs)) { next_execution_plan_index_to_prepare_ = execution_plan_index + 1; if (next_execution_plan_index_to_plan_allocation_ > next_execution_plan_index_to_prepare_) { next_execution_plan_index_to_plan_allocation_ = next_execution_plan_index_to_prepare_; if (memory_planner_) { TF_LITE_ENSURE_STATUS(memory_planner_->ResetAllocationsAfter( next_execution_plan_index_to_plan_allocation_ - 1)); } } } } return status; }"
"header_cache_t *imap_hcache_open(struct ImapData *idata, const char *path) { struct ImapMbox mx; struct Url url; char cachepath[PATH_MAX]; char mbox[PATH_MAX]; if (path) imap_cachepath(idata, path, mbox, sizeof(mbox)); else { if (!idata->ctx || imap_parse_path(idata->ctx->path, &mx) < 0) return NULL; imap_cachepath(idata, mx.mbox, mbox, sizeof(mbox)); FREE(&mx.mbox); } mutt_account_tourl(&idata->conn->account, &url); url.path = mbox; url_tostring(&url, cachepath, sizeof(cachepath), U_PATH); return mutt_hcache_open(HeaderCache, cachepath, imap_hcache_namer); }"
"static GF_AVCConfig *AVC_DuplicateConfig(GF_AVCConfig *cfg) { u32 i, count; GF_AVCConfigSlot *p1, *p2; GF_AVCConfig *cfg_new = gf_odf_avc_cfg_new(); cfg_new->AVCLevelIndication = cfg->AVCLevelIndication; cfg_new->AVCProfileIndication = cfg->AVCProfileIndication; cfg_new->configurationVersion = cfg->configurationVersion; cfg_new->nal_unit_size = cfg->nal_unit_size; cfg_new->profile_compatibility = cfg->profile_compatibility; cfg_new->complete_representation = cfg->complete_representation; cfg_new->chroma_bit_depth = cfg->chroma_bit_depth; cfg_new->luma_bit_depth = cfg->luma_bit_depth; cfg_new->chroma_format = cfg->chroma_format; count = gf_list_count(cfg->sequenceParameterSets); for (i=0; i<count; i++) { p1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSets, i); p2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot)); p2->size = p1->size; p2->id = p1->id; p2->data = (char *)gf_malloc(sizeof(char)*p1->size); memcpy(p2->data, p1->data, sizeof(char)*p1->size); gf_list_add(cfg_new->sequenceParameterSets, p2); } count = gf_list_count(cfg->pictureParameterSets); for (i=0; i<count; i++) { p1 = (GF_AVCConfigSlot*)gf_list_get(cfg->pictureParameterSets, i); p2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot)); p2->size = p1->size; p2->id = p1->id; p2->data = (char*)gf_malloc(sizeof(char)*p1->size); memcpy(p2->data, p1->data, sizeof(char)*p1->size); gf_list_add(cfg_new->pictureParameterSets, p2); } if (cfg->sequenceParameterSetExtensions) { cfg_new->sequenceParameterSetExtensions = gf_list_new(); count = gf_list_count(cfg->sequenceParameterSetExtensions); for (i=0; i<count; i++) { p1 = (GF_AVCConfigSlot*)gf_list_get(cfg->sequenceParameterSetExtensions, i); p2 = (GF_AVCConfigSlot*)gf_malloc(sizeof(GF_AVCConfigSlot)); p2->size = p1->size; p2->id = p1->id; p2->data = (char*)gf_malloc(sizeof(char)*p1->size); memcpy(p2->data, p1->data, sizeof(char)*p1->size); gf_list_add(cfg_new->sequenceParameterSetExtensions, p2); } } return cfg_new; }"
"static int gtco_probe(struct usb_interface *usbinterface, const struct usb_device_id *id) { struct gtco             *gtco; struct input_dev        *input_dev; struct hid_descriptor   *hid_desc; char                    *report; int                     result = 0, retry; interror; struct usb_endpoint_descriptor *endpoint; gtco = kzalloc(sizeof(struct gtco), GFP_KERNEL); input_dev = input_allocate_device(); if (!gtco || !input_dev) { dev_err(&usbinterface->dev, ""No more memory\n""); error = -ENOMEM; goto err_free_devs; } gtco->inputdevice = input_dev; gtco->usbdev = interface_to_usbdev(usbinterface); gtco->intf = usbinterface; gtco->buffer = usb_alloc_coherent(gtco->usbdev, REPORT_MAX_SIZE, GFP_KERNEL, &gtco->buf_dma); if (!gtco->buffer) { dev_err(&usbinterface->dev, ""No more memory for us buffers\n""); error = -ENOMEM; goto err_free_devs; } gtco->urbinfo = usb_alloc_urb(0, GFP_KERNEL); if (!gtco->urbinfo) { dev_err(&usbinterface->dev, ""Failed to allocate URB\n""); error = -ENOMEM; goto err_free_buf; } endpoint = &usbinterface->altsetting[0].endpoint[0].desc; dev_dbg(&usbinterface->dev, ""gtco # interfaces: %d\n"", usbinterface->num_altsetting); dev_dbg(&usbinterface->dev, ""num endpoints:     %d\n"", usbinterface->cur_altsetting->desc.bNumEndpoints); dev_dbg(&usbinterface->dev, ""interface class:   %d\n"", usbinterface->cur_altsetting->desc.bInterfaceClass); dev_dbg(&usbinterface->dev, ""endpoint: attribute:0x%x type:0x%x\n"", endpoint->bmAttributes, endpoint->bDescriptorType); if (usb_endpoint_xfer_int(endpoint)) dev_dbg(&usbinterface->dev, ""endpoint: we have interrupt endpoint\n""); dev_dbg(&usbinterface->dev, ""endpoint extra len:%d\n"", usbinterface->altsetting[0].extralen); if (usb_get_extra_descriptor(usbinterface->cur_altsetting, HID_DEVICE_TYPE, &hid_desc) != 0){ dev_err(&usbinterface->dev, ""Can't retrieve exta USB descriptor to get hid report descriptor length\n""); error = -EIO; goto err_free_urb; } dev_dbg(&usbinterface->dev, ""Extra descriptor success: type:%d  len:%d\n"", hid_desc->bDescriptorType,  hid_desc->wDescriptorLength); report = kzalloc(le16_to_cpu(hid_desc->wDescriptorLength), GFP_KERNEL); if (!report) { dev_err(&usbinterface->dev, ""No more memory for report\n""); error = -ENOMEM; goto err_free_urb; } for (retry = 0; retry < 3; retry++) { result = usb_control_msg(gtco->usbdev, usb_rcvctrlpipe(gtco->usbdev, 0), USB_REQ_GET_DESCRIPTOR, USB_RECIP_INTERFACE | USB_DIR_IN, REPORT_DEVICE_TYPE << 8, 0,  report, le16_to_cpu(hid_desc->wDescriptorLength), 5000);  dev_dbg(&usbinterface->dev, ""usb_control_msg result: %d\n"", result); if (result == le16_to_cpu(hid_desc->wDescriptorLength)) { parse_hid_report_descriptor(gtco, report, result); break; } } kfree(report); if (result != le16_to_cpu(hid_desc->wDescriptorLength)) { dev_err(&usbinterface->dev, ""Failed to get HID Report Descriptor of size: %d\n"", hid_desc->wDescriptorLength); error = -EIO; goto err_free_urb; } usb_make_path(gtco->usbdev, gtco->usbpath, sizeof(gtco->usbpath)); strlcat(gtco->usbpath, ""/input0"", sizeof(gtco->usbpath)); input_dev->open = gtco_input_open; input_dev->close = gtco_input_close; input_dev->name = ""GTCO_CalComp""; input_dev->phys = gtco->usbpath; input_set_drvdata(input_dev, gtco); gtco_setup_caps(input_dev); usb_to_input_id(gtco->usbdev, &input_dev->id); input_dev->dev.parent = &usbinterface->dev; endpoint = &usbinterface->altsetting[0].endpoint[0].desc; usb_fill_int_urb(gtco->urbinfo, gtco->usbdev, usb_rcvintpipe(gtco->usbdev, endpoint->bEndpointAddress), gtco->buffer, REPORT_MAX_SIZE, gtco_urb_callback, gtco, endpoint->bInterval); gtco->urbinfo->transfer_dma = gtco->buf_dma; gtco->urbinfo->transfer_flags |= URB_NO_TRANSFER_DMA_MAP; usb_set_intfdata(usbinterface, gtco); error = input_register_device(input_dev); if (error) goto err_free_urb; return 0; err_free_urb: usb_free_urb(gtco->urbinfo); err_free_buf: usb_free_coherent(gtco->usbdev, REPORT_MAX_SIZE, gtco->buffer, gtco->buf_dma); err_free_devs: input_free_device(input_dev); kfree(gtco); return error; }"
"bool CSecurityTLS::processMsg(CConnection* cc) { rdr::InStream* is = cc->getInStream(); rdr::OutStream* os = cc->getOutStream(); client = cc; initGlobal(); if (!session) { if (!is->checkNoWait(1)) return false; if (is->readU8() == 0) { rdr::U32 result = is->readU32(); CharArray reason; if (result == secResultFailed || result == secResultTooMany) reason.buf = is->readString(); else reason.buf = strDup(""Authentication failure (protocol error)""); throw AuthFailureException(reason.buf); } if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS) throw AuthFailureException(""gnutls_init failed""); if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS) throw AuthFailureException(""gnutls_set_default_priority failed""); setParam(); } rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session); rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session); int err; err = gnutls_handshake(session); if (err != GNUTLS_E_SUCCESS) { delete tlsis; delete tlsos; if (!gnutls_error_is_fatal(err)) return false; vlog.error(""TLS Handshake failed: %s\n"", gnutls_strerror (err)); shutdown(false); throw AuthFailureException(""TLS Handshake failed""); } checkSession(); cc->setStreams(fis = tlsis, fos = tlsos); return true; }"
"ecma_value_t ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p,  ecma_value_t pattern_value,  ecma_value_t flags_value)  { ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value); uint16_t flags = 0; if (JERRY_UNLIKELY (pattern_str_p == NULL)) { return ECMA_VALUE_ERROR; } if (!ecma_is_value_undefined (flags_value)) { ecma_string_t *flags_str_p = ecma_op_to_string (flags_value); if (JERRY_UNLIKELY (flags_str_p == NULL)) { ecma_deref_ecma_string (pattern_str_p); return ECMA_VALUE_ERROR; } ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags); ecma_deref_ecma_string (flags_str_p); if (ECMA_IS_VALUE_ERROR (parse_flags_value)) { ecma_deref_ecma_string (pattern_str_p); return parse_flags_value; } JERRY_ASSERT (ecma_is_value_empty (parse_flags_value)); } const re_compiled_code_t *bc_p = NULL; ecma_value_t ret_value = re_compile_bytecode (&bc_p, pattern_str_p, flags); ecma_deref_ecma_string (pattern_str_p); if (ECMA_IS_VALUE_ERROR (ret_value)) { return ret_value; } JERRY_ASSERT (ecma_is_value_empty (ret_value)); ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags); return ecma_make_object_value (regexp_obj_p); }"
"int hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func) { irda_queue_t* queue; unsigned long flags = 0; int i; IRDA_ASSERT(hashbin != NULL, return -1;); IRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;); if ( hashbin->hb_type & HB_LOCK ) { spin_lock_irqsave_nested(&hashbin->hb_spinlock, flags, hashbin_lock_depth++); } for (i = 0; i < HASHBIN_SIZE; i ++ ) { queue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]); while (queue ) { if (free_func) (*free_func)(queue); queue = dequeue_first( (irda_queue_t**) &hashbin->hb_queue[i]); } } hashbin->hb_current = NULL; hashbin->magic = ~HB_MAGIC; if ( hashbin->hb_type & HB_LOCK) { spin_unlock_irqrestore(&hashbin->hb_spinlock, flags); #ifdef CONFIG_LOCKDEP hashbin_lock_depth--; #endif } kfree(hashbin); return 0; }"
"static int mod_l1_entry(l1_pgentry_t *pl1e, l1_pgentry_t nl1e, unsigned long gl1mfn, int preserve_ad, struct vcpu *pt_vcpu, struct domain *pg_dom) { l1_pgentry_t ol1e; struct domain *pt_dom = pt_vcpu->domain; int rc = 0; if ( unlikely(__copy_from_user(&ol1e, pl1e, sizeof(ol1e)) != 0) ) return -EFAULT; if ( unlikely(paging_mode_refcounts(pt_dom)) ) { if ( UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad) ) return 0; return -EBUSY; } if ( l1e_get_flags(nl1e) & _PAGE_PRESENT ) { struct page_info *page = NULL; if ( unlikely(l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom)) ) { MEM_LOG(""Bad L1 flags %x"", l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom)); return -EINVAL; } if ( paging_mode_translate(pg_dom) ) { page = get_page_from_gfn(pg_dom, l1e_get_pfn(nl1e), NULL, P2M_ALLOC); if ( !page ) return -EINVAL; nl1e = l1e_from_pfn(page_to_mfn(page), l1e_get_flags(nl1e)); } if ( !l1e_has_changed(ol1e, nl1e, PAGE_CACHE_ATTRS | _PAGE_RW | _PAGE_PRESENT) ) { adjust_guest_l1e(nl1e, pt_dom); rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad); if ( page ) put_page(page); return rc ? 0 : -EBUSY; } switch ( rc = get_page_from_l1e(nl1e, pt_dom, pg_dom) ) { default: if ( page ) put_page(page); return rc; case 0: break; case _PAGE_RW ... _PAGE_RW | PAGE_CACHE_ATTRS: ASSERT(!(rc & ~(_PAGE_RW | PAGE_CACHE_ATTRS))); l1e_flip_flags(nl1e, rc); rc = 0; break; } if ( page ) put_page(page); adjust_guest_l1e(nl1e, pt_dom); if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad)) ) { ol1e = nl1e; rc = -EBUSY; } } else if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad)) ) { return -EBUSY; } put_page_from_l1e(ol1e, pt_dom); return rc; }"
"static GF_Err xmt_report(GF_XMTParser *parser, GF_Err e, char *format, ...) { #ifndef GPAC_DISABLE_LOG if (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) { char szMsg[2048]; va_list args; va_start(args, format); vsprintf(szMsg, format, args); va_end(args); GF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[XMT Parsing] %s (line %d)\n"", szMsg, gf_xml_sax_get_line(parser->sax_parser)) ); } #endif if (e) parser->last_error = e; return e; }"
"static int ssl_parse_server_key_exchange( mbedtls_ssl_context *ssl ) { int ret; const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info; unsigned char *p = NULL, *end = NULL; MBEDTLS_SSL_DEBUG_MSG( 2, ( ""=> parse server key exchange"" ) ); #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA ) { MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= skip parse server key exchange"" ) ); ssl->state++; return( 0 ); } ((void) p); ((void) end); #endif #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \ defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA ) { if( ( ret = ssl_get_ecdh_params_from_cert( ssl ) ) != 0 ) { MBEDTLS_SSL_DEBUG_RET( 1, ""ssl_get_ecdh_params_from_cert"", ret ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ); return( ret ); } MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= skip parse server key exchange"" ) ); ssl->state++; return( 0 ); } ((void) p); ((void) end); #endif  if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 ) { MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_ssl_read_record"", ret ); return( ret ); } if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE ); return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE ); } if( ssl->in_msg[0] != MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE ) { if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ) { ssl->keep_current_message = 1; goto exit; } MBEDTLS_SSL_DEBUG_MSG( 1, ( ""server key exchange message must "" ""not be skipped"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE ); return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE ); } p   = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ); end = ssl->in_msg + ssl->in_hslen; MBEDTLS_SSL_DEBUG_BUF( 3,   ""server key exchange"", p, end - p ); #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ) { if( ssl_parse_server_psk_hint( ssl, &p, end ) != 0 ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } }  #endif  #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED) ||                       \ defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ) ;  else #endif  #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \ defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ) { if( ssl_parse_server_dh_params( ssl, &p, end ) != 0 ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } } else #endif  #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \ defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED) ||                     \ defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK || ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ) { if( ssl_parse_server_ecdh_params( ssl, &p, end ) != 0 ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } } else #endif  #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED) if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ) { ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx, p, end - p ); if( ret != 0 ) { MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_ecjpake_read_round_two"", ret ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } } else #endif  { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) ); return( MBEDTLS_ERR_SSL_INTERNAL_ERROR ); } #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED) if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) ) { size_t sig_len, hashlen; unsigned char hash[64]; mbedtls_md_type_t md_alg = MBEDTLS_MD_NONE; mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE; unsigned char *params = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ); size_t params_len = p - params; #if defined(MBEDTLS_SSL_PROTO_TLS1_2) if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 ) { if( ssl_parse_signature_algorithm( ssl, &p, end, &md_alg, &pk_alg ) != 0 ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } if( pk_alg != mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ) ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } } else #endif  #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ defined(MBEDTLS_SSL_PROTO_TLS1_1) if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 ) { pk_alg = mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info ); if( pk_alg == MBEDTLS_PK_ECDSA && md_alg == MBEDTLS_MD_NONE ) md_alg = MBEDTLS_MD_SHA1; } else #endif { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) ); return( MBEDTLS_ERR_SSL_INTERNAL_ERROR ); } if( p > end - 2 ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } sig_len = ( p[0] << 8 ) | p[1]; p += 2; if( end != p + sig_len ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR ); return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE ); } MBEDTLS_SSL_DEBUG_BUF( 3, ""signature"", p, sig_len ); #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \ defined(MBEDTLS_SSL_PROTO_TLS1_1) if( md_alg == MBEDTLS_MD_NONE ) { hashlen = 36; ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash, params, params_len ); if( ret != 0 ) return( ret ); } else #endif  #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \ defined(MBEDTLS_SSL_PROTO_TLS1_2) if( md_alg != MBEDTLS_MD_NONE ) { hashlen = 0; ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash, params, params_len, md_alg ); if( ret != 0 ) return( ret ); } else #endif  { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""should never happen"" ) ); return( MBEDTLS_ERR_SSL_INTERNAL_ERROR ); } MBEDTLS_SSL_DEBUG_BUF( 3, ""parameters hash"", hash, hashlen != 0 ? hashlen : (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) ); if( ssl->session_negotiate->peer_cert == NULL ) { MBEDTLS_SSL_DEBUG_MSG( 2, ( ""certificate required"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ); return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE ); } if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) ) { MBEDTLS_SSL_DEBUG_MSG( 1, ( ""bad server key exchange message"" ) ); mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ); return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH ); } if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk, md_alg, hash, hashlen, p, sig_len ) ) != 0 ) { mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, MBEDTLS_SSL_ALERT_MSG_DECRYPT_ERROR ); MBEDTLS_SSL_DEBUG_RET( 1, ""mbedtls_pk_verify"", ret ); return( ret ); } } #endif  exit: ssl->state++; MBEDTLS_SSL_DEBUG_MSG( 2, ( ""<= parse server key exchange"" ) ); return( 0 ); }"
"jp2_box_t *jp2_box_get(jas_stream_t *in) { jp2_box_t *box; jp2_boxinfo_t *boxinfo; jas_stream_t *tmpstream; uint_fast32_t len; uint_fast64_t extlen; bool dataflag; box = 0; tmpstream = 0; if (!(box = jas_malloc(sizeof(jp2_box_t)))) { goto error; } box->ops = &jp2_boxinfo_unk.ops; if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) { goto error; } boxinfo = jp2_boxinfolookup(box->type); box->info = boxinfo; box->ops = &boxinfo->ops; box->len = len; if (box->len == 1) { if (jp2_getuint64(in, &extlen)) { goto error; } if (extlen > 0xffffffffUL) { jas_eprintf(""warning: cannot handle large 64-bit box length\n""); extlen = 0xffffffffUL; } box->len = extlen; box->datalen = extlen - JP2_BOX_HDRLEN(true); } else { box->datalen = box->len - JP2_BOX_HDRLEN(false); } if (box->len != 0 && box->len < 8) { goto error; } dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA)); if (dataflag) { if (!(tmpstream = jas_stream_memopen(0, 0))) { goto error; } if (jas_stream_copy(tmpstream, in, box->datalen)) { jas_eprintf(""cannot copy box data\n""); goto error; } jas_stream_rewind(tmpstream); if (box->ops->getdata) { if ((*box->ops->getdata)(box, tmpstream)) { jas_eprintf(""cannot parse box data\n""); goto error; } } jas_stream_close(tmpstream); } if (jas_getdbglevel() >= 1) { jp2_box_dump(box, stderr); } return box; error: if (box) { jp2_box_destroy(box); } if (tmpstream) { jas_stream_close(tmpstream); } return 0; }"
"static void prepare_singleton_class(mrb_state *mrb, struct RBasic *o) { struct RClass *sc, *c; if (o->c->tt == MRB_TT_SCLASS) return; sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class); sc->flags |= MRB_FL_CLASS_IS_INHERITED; sc->mt = mt_new(mrb); sc->iv = 0; if (o->tt == MRB_TT_CLASS) { c = (struct RClass*)o; if (!c->super) { sc->super = mrb->class_class; } else { sc->super = c->super->c; } } else if (o->tt == MRB_TT_SCLASS) { c = (struct RClass*)o; while (c->super->tt == MRB_TT_ICLASS) c = c->super; make_metaclass(mrb, c->super); sc->super = c->super->c; } else { sc->super = o->c; prepare_singleton_class(mrb, (struct RBasic*)sc); } o->c = sc; mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc); mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o); mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o)); sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN; }"
"PTA * ptaReadStream(FILE  *fp) { char       typestr[128]; l_int32    i, n, ix, iy, type, version; l_float32  x, y; PTA       *pta; PROCNAME(""ptaReadStream""); if (!fp) return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL); if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1) return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL); if (version != PTA_VERSION_NUMBER) return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL); if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2) return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL); if (!strcmp(typestr, ""float"")) type = 0; else   type = 1; if ((pta = ptaCreate(n)) == NULL) return (PTA *)ERROR_PTR(""pta not made"", procName, NULL); for (i = 0; i < n; i++) { if (type == 0) {   if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) { ptaDestroy(&pta); return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL); } ptaAddPt(pta, x, y); } else {    if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) { ptaDestroy(&pta); return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL); } ptaAddPt(pta, ix, iy); } } return pta; }"
"int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx, const uint8_t *der_cert, size_t der_size, char **_filter, char ***_domains) { int ret; struct match_map_rule *r; struct priority_list *p; struct sss_cert_content *cert_content = NULL; char *filter = NULL; char **domains = NULL; size_t c; if (_filter == NULL || _domains == NULL) { return EINVAL; } ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content); if (ret != 0) { CM_DEBUG(ctx, ""Failed to get certificate content [%d]."", ret); return ret; } if (ctx->prio_list == NULL) { if (ctx->default_mapping_rule == NULL) { CM_DEBUG(ctx, ""No matching or mapping rules available.""); return EINVAL; } ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter); goto done; } for (p = ctx->prio_list; p != NULL; p = p->next) { for (r = p->rule_list; r != NULL; r = r->next) { ret = do_match(ctx, r->parsed_match_rule, cert_content); if (ret == 0) { ret = get_filter(ctx, r->parsed_mapping_rule, cert_content, &filter); if (ret != 0) { CM_DEBUG(ctx, ""Failed to get filter""); goto done; } if (r->domains != NULL) { for (c = 0; r->domains[c] != NULL; c++); domains = talloc_zero_array(ctx, char *, c + 1); if (domains == NULL) { ret = ENOMEM; goto done; } for (c = 0; r->domains[c] != NULL; c++) { domains[c] = talloc_strdup(domains, r->domains[c]); if (domains[c] == NULL) { ret = ENOMEM; goto done; } } } ret = 0; goto done; } } } ret = ENOENT; done: talloc_free(cert_content); if (ret == 0) { *_filter = filter; *_domains = domains; } else { talloc_free(filter); talloc_free(domains); } return ret; }"
"void monitor_apply_keystate(struct monitor *pmonitor) { struct ssh *ssh = active_state; struct kex *kex; int r; debug3(""%s: packet_set_state"", __func__); if ((r = ssh_packet_set_state(ssh, child_state)) != 0) fatal(""%s: packet_set_state: %s"", __func__, ssh_err(r)); sshbuf_free(child_state); child_state = NULL; if ((kex = ssh->kex) != NULL) { #ifdef WITH_OPENSSL kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server; kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server; kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server; kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server; kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server; kex->kex[KEX_DH_GEX_SHA1] = kexgex_server; kex->kex[KEX_DH_GEX_SHA256] = kexgex_server; kex->kex[KEX_ECDH_SHA2] = kexecdh_server; #endif kex->kex[KEX_C25519_SHA256] = kexc25519_server; kex->load_host_public_key=&get_hostkey_public_by_type; kex->load_host_private_key=&get_hostkey_private_by_type; kex->host_key_index=&get_hostkey_index; kex->sign = sshd_hostkey_sign; } if (options.compression) { ssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib, (ssh_packet_comp_alloc_func *)mm_zalloc, (ssh_packet_comp_free_func *)mm_zfree); } }"
"OM_uint32 KRB5_CALLCONV gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count) { OM_uint32 status; gss_union_ctx_id_t ctx; gss_mechanism mech; status = val_unwrap_iov_args(minor_status, context_handle, NULL, qop_state, iov, iov_count); if (status != GSS_S_COMPLETE) return status; ctx = (gss_union_ctx_id_t)context_handle; mech = gssint_get_mechanism(ctx->mech_type); if (mech == NULL) return GSS_S_BAD_MECH; if (mech->gss_verify_mic_iov == NULL) return GSS_S_UNAVAILABLE; status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id, qop_state, iov, iov_count); if (status != GSS_S_COMPLETE) map_error(minor_status, mech); return status; }"
"static inline int make_table_template(gx_device     * pdev, gx_path       * path, const gs_fixed_rect * ibox, int             intersection_size, fixed           adjust, int           * scanlinesp, int          ** indexp, int          ** tablep) { int             scanlines; const subpath * restrict psub; int           * restrict index; int           * restrict table; int             i; int             offset, delta; fixed           base_y = ibox->p.y; *scanlinesp = 0; *indexp     = NULL; *tablep     = NULL; scanlines = ibox->q.y-base_y; index = (int *)gs_alloc_bytes(pdev->memory, (scanlines+1) * sizeof(*index), ""scanc index buffer""); if (index == NULL) return_error(gs_error_VMerror); memset(index, 0, (scanlines+1)*sizeof(int)); for (psub = path->first_subpath; psub != 0;) { const segment * restrict pseg = (const segment *)psub; fixed          ey = pseg->pt.y + adjust; fixed          iy = ey; int            iey = fixed2int(iy) - base_y; assert(pseg->type == s_start); if (iey >= 0 && iey < scanlines) { index[iey] += 2; if (iey+1 < scanlines) index[iey+1] -= 2; } while ((pseg = pseg->next) != 0 && pseg->type != s_start ) { fixed sy = ey; ey = pseg->pt.y + adjust; #ifdef DEBUG_SCAN_CONVERTER if (debugging_scan_converter) dlprintf1(""%d "", pseg->type); #endif switch (pseg->type) { default: case s_start:  case s_dash:   assert(""This should never happen"" == NULL); break; case s_curve: { const curve_segment *const restrict pcur = (const curve_segment *)pseg; fixed c1y = pcur->p1.y + adjust; fixed c2y = pcur->p2.y + adjust; fixed maxy = sy, miny = sy; int imaxy, iminy; if (miny > c1y) miny = c1y; if (miny > c2y) miny = c2y; if (miny > ey) miny = ey; if (maxy < c1y) maxy = c1y; if (maxy < c2y) maxy = c2y; if (maxy < ey) maxy = ey; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]+=3; if (imaxy < scanlines) index[imaxy+1]-=3; } } break; } case s_gap: case s_line: case s_line_close: { fixed miny, maxy; int imaxy, iminy; if (sy == ey) break; if (sy < ey) miny = sy, maxy = ey; else miny = ey, maxy = sy; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]++; if (imaxy < scanlines) { index[imaxy+1]--; } } } break; } } if (ey != iy) { fixed miny, maxy; int imaxy, iminy; if (iy < ey) miny = iy, maxy = ey; else miny = ey, maxy = iy; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]++; if (imaxy < scanlines) { index[imaxy+1]--; } } } } } #ifdef DEBUG_SCAN_CONVERTER if (debugging_scan_converter) dlprintf(""\n""); #endif psub = (const subpath *)pseg; } offset = 0; delta  = 0; for (i=0; i < scanlines; i++) { delta    += intersection_size*index[i];   index[i]  = offset;                       offset   += delta+1;                      } table = (int *)gs_alloc_bytes(pdev->memory, offset * sizeof(*table), ""scanc intersects buffer""); if (table == NULL) { gs_free_object(pdev->memory, table, ""scanc index buffer""); return_error(gs_error_VMerror); } for (i=0; i < scanlines; i++) { table[index[i]] = 0; } *scanlinesp = scanlines; *tablep     = table; *indexp     = index; return 0; }"
"static int string_scan_range(RList *list, RBinFile *bf, int min, const ut64 from, const ut64 to, int type) { ut8 tmp[R_STRING_SCAN_BUFFER_SIZE]; ut64 str_start, needle = from; int count = 0, i, rc, runes; int str_type = R_STRING_TYPE_DETECT; if (type == -1) { type = R_STRING_TYPE_DETECT; } if (from >= to) { eprintf (""Invalid range to find strings 0x%llx .. 0x%llx\n"", from, to); return -1; } ut8 *buf = calloc (to - from, 1); if (!buf || !min) { return -1; } r_buf_read_at (bf->buf, from, buf, to - from); while (needle < to) { rc = r_utf8_decode (buf + needle - from, to - needle, NULL); if (!rc) { needle++; continue; } if (type == R_STRING_TYPE_DETECT) { char *w = (char *)buf + needle + rc - from; if ((to - needle) > 5) { bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4]; if (is_wide32) { str_type = R_STRING_TYPE_WIDE32; } else { bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2]; str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII; } } else { str_type = R_STRING_TYPE_ASCII; } } else { str_type = type; } runes = 0; str_start = needle; for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) { RRune r = {0}; if (str_type == R_STRING_TYPE_WIDE32) { rc = r_utf32le_decode (buf + needle - from, to - needle, &r); if (rc) { rc = 4; } } else if (str_type == R_STRING_TYPE_WIDE) { rc = r_utf16le_decode (buf + needle - from, to - needle, &r); if (rc == 1) { rc = 2; } } else { rc = r_utf8_decode (buf + needle - from, to - needle, &r); if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } } if (!rc) { needle++; break; } needle += rc; if (r_isprint (r) && r != '\\') { if (str_type == R_STRING_TYPE_WIDE32) { if (r == 0xff) { r = 0; } } rc = r_utf8_encode (&tmp[i], r); runes++; } else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) { if ((i + 32) < sizeof (tmp) && r < 93) { tmp[i + 0] = '\\'; tmp[i + 1] = ""       abtnvfr             e  "" ""                              "" ""                              "" ""  \\""[r]; } else { break; } rc = 2; runes++; } else { break; } } tmp[i++] = '\0'; if (runes >= min) { if (str_type == R_STRING_TYPE_ASCII) { int j; for (j = 0; j < i; j++) { char ch = tmp[j]; if (ch != '\n' && ch != '\r' && ch != '\t') { if (!IS_PRINTABLE (tmp[j])) { continue; } } } } RBinString *bs = R_NEW0 (RBinString); if (!bs) { break; } bs->type = str_type; bs->length = runes; bs->size = needle - str_start; bs->ordinal = count++; switch (str_type) { case R_STRING_TYPE_WIDE: if (str_start -from> 1) { const ut8 *p = buf + str_start - 2 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 2; } } break; case R_STRING_TYPE_WIDE32: if (str_start -from> 3) { const ut8 *p = buf + str_start - 4 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 4; } } break; } bs->paddr = bs->vaddr = str_start; bs->string = r_str_ndup ((const char *)tmp, i); if (list) { r_list_append (list, bs); } else { print_string (bs, bf); r_bin_string_free (bs); } } } free (buf); return count; }"
"void skb_complete_tx_timestamp(struct sk_buff *skb, struct skb_shared_hwtstamps *hwtstamps) { struct sock *sk = skb->sk; if (!skb_may_tx_timestamp(sk, false)) return; if (likely(atomic_inc_not_zero(&sk->sk_refcnt))) { *skb_hwtstamps(skb) = *hwtstamps; __skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND); sock_put(sk); } }"
"static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)  { if (prev_options != NULL) { *prev_options = MBREX(regex_default_options); } if (prev_syntax != NULL) { *prev_syntax = MBREX(regex_default_syntax); } MBREX(regex_default_options) = options; MBREX(regex_default_syntax) = syntax; }"
"bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const EventTarget* target, ExceptionState& exceptionState) { ASSERT(target); const DOMWindow* window = target->toDOMWindow(); if (!window) { return true; } const Frame* frame = window->frame(); if (!frame || !frame->securityContext()) return false; return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState); }"
"CURLcode Curl_close(struct Curl_easy *data) { struct Curl_multi *m; if(!data) return CURLE_OK; Curl_expire_clear(data);  m = data->multi; if(m) curl_multi_remove_handle(data->multi, data); if(data->multi_easy) curl_multi_cleanup(data->multi_easy); Curl_llist_destroy(&data->state.timeoutlist, NULL); data->magic = 0;  if(data->state.rangestringalloc) free(data->state.range); Curl_free_request_state(data); Curl_ssl_close_all(data); Curl_safefree(data->state.first_host); Curl_safefree(data->state.scratch); Curl_ssl_free_certinfo(data); free(data->req.newurl); data->req.newurl = NULL; if(data->change.referer_alloc) { Curl_safefree(data->change.referer); data->change.referer_alloc = FALSE; } data->change.referer = NULL; Curl_up_free(data); Curl_safefree(data->state.buffer); Curl_safefree(data->state.headerbuff); Curl_safefree(data->state.ulbuf); Curl_flush_cookies(data, 1); Curl_digest_cleanup(data); Curl_safefree(data->info.contenttype); Curl_safefree(data->info.wouldredirect); Curl_resolver_cleanup(data->state.resolver); Curl_http2_cleanup_dependencies(data); Curl_convert_close(data); if(data->share) { Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE); data->share->dirty--; Curl_share_unlock(data, CURL_LOCK_DATA_SHARE); } Curl_wildcard_dtor(&data->wildcard); Curl_freeset(data); free(data); return CURLE_OK; }"
"static int wolfSSH_SFTP_DoStatus(WOLFSSH* ssh, word32 reqId, WS_SFTP_BUFFER* buffer) { word32 sz; word32 status = WOLFSSH_FTP_FAILURE; word32 localIdx = wolfSSH_SFTP_buffer_idx(buffer); word32 maxIdx = wolfSSH_SFTP_buffer_size(buffer); byte* buf = wolfSSH_SFTP_buffer_data(buffer); (void)reqId; if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &status); localIdx += UINT32_SZ; if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &sz); localIdx += UINT32_SZ; if (sz > 0) { byte* s; if (localIdx + sz > maxIdx) { return WS_FATAL_ERROR; } s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (s == NULL) { return WS_MEMORY_E; } WMEMCPY(s, buf + localIdx, sz); s[sz] = '\0'; WLOG(WS_LOG_SFTP, ""Status Recv : %s"", s); WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER); localIdx += sz; } if (localIdx + UINT32_SZ > maxIdx) { return WS_FATAL_ERROR; } ato32(buf + localIdx, &sz); localIdx += UINT32_SZ; if (sz > 0) { byte* s; if (localIdx + sz > maxIdx) { return WS_FATAL_ERROR; } s = (byte*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (s == NULL) { return WS_MEMORY_E; } WMEMCPY(s, buf + localIdx, sz); s[sz] = '\0'; WLOG(WS_LOG_SFTP, ""Status Language : %s"", s); WFREE(s, ssh->ctx->heap, DYNTYPE_BUFFER); localIdx += sz; } wolfSSH_SFTP_buffer_seek(buffer, 0, localIdx); return status; }"
"static void mbim_dissect_device_services_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset) { proto_tree *subtree; gint base_offset; guint32 i, device_services_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_device_services_info_device_services_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &device_services_count); offset += 4; proto_tree_add_item(tree, hf_mbim_device_services_info_max_dss_sessions, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset += 4; if (device_services_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), device_services_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*device_services_count, ett_mbim_pair_list, NULL, ""Device Services Ref List""); for (i = 0; i < device_services_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_device_services_info_device_services_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_device_services_info_device_services_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < device_services_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""Device Service Element #%u"", i+1); mbim_dissect_device_service_element(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } } } }"
"void FullFramePixelBuffer::setBuffer(int width, int height, rdr::U8* data_, int stride_) { ModifiablePixelBuffer::setSize(width, height); stride = stride_; data = data_; }"
"int main (int    argc, char **argv) { mode_t old_umask; cleanup_free char *base_path = NULL; int clone_flags; char *old_cwd = NULL; pid_t pid; int event_fd = -1; int child_wait_fd = -1; int setup_finished_pipe[] = {-1, -1}; const char *new_cwd; uid_t ns_uid; gid_t ns_gid; struct stat sbuf; uint64_t val; int res UNUSED; cleanup_free char *seccomp_data = NULL; size_t seccomp_len; struct sock_fprog seccomp_prog; cleanup_free char *args_data = NULL; if (argc == 2 && (strcmp (argv[1], ""--version"") == 0)) print_version_and_exit (); real_uid = getuid (); real_gid = getgid (); acquire_privs (); if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) die_with_error (""prctl(PR_SET_NO_NEW_CAPS) failed""); read_overflowids (); argv0 = argv[0]; if (isatty (1)) host_tty_dev = ttyname (1); argv++; argc--; if (argc == 0) usage (EXIT_FAILURE, stderr); parse_args (&argc, (const char ***) &argv); args_data = opt_args_data; opt_args_data = NULL; if ((requested_caps[0] || requested_caps[1]) && is_privileged) die (""--cap-add in setuid mode can be used only by root""); if (opt_userns_block_fd != -1 && !opt_unshare_user) die (""--userns-block-fd requires --unshare-user""); if (opt_userns_block_fd != -1 && opt_info_fd == -1) die (""--userns-block-fd requires --info-fd""); if (!is_privileged && getuid () != 0) opt_unshare_user = TRUE; #ifdef ENABLE_REQUIRE_USERNS if (is_privileged && getuid () != 0) opt_unshare_user = TRUE; #endif if (opt_unshare_user_try && stat (""/proc/self/ns/user"", &sbuf) == 0) { bool disabled = FALSE; if (stat (""/sys/module/user_namespace/parameters/enable"", &sbuf) == 0) { cleanup_free char *enable = NULL; enable = load_file_at (AT_FDCWD, ""/sys/module/user_namespace/parameters/enable""); if (enable != NULL && enable[0] == 'N') disabled = TRUE; } if (stat (""/proc/sys/user/max_user_namespaces"", &sbuf) == 0) { cleanup_free char *max_user_ns = NULL; max_user_ns = load_file_at (AT_FDCWD, ""/proc/sys/user/max_user_namespaces""); if (max_user_ns != NULL && strcmp(max_user_ns, ""0\n"") == 0) disabled = TRUE; } if (!disabled) opt_unshare_user = TRUE; } if (argc == 0) usage (EXIT_FAILURE, stderr); __debug__ ((""Creating root mount point\n"")); if (opt_sandbox_uid == -1) opt_sandbox_uid = real_uid; if (opt_sandbox_gid == -1) opt_sandbox_gid = real_gid; if (!opt_unshare_user && opt_sandbox_uid != real_uid) die (""Specifying --uid requires --unshare-user""); if (!opt_unshare_user && opt_sandbox_gid != real_gid) die (""Specifying --gid requires --unshare-user""); if (!opt_unshare_uts && opt_sandbox_hostname != NULL) die (""Specifying --hostname requires --unshare-uts""); if (opt_as_pid_1 && !opt_unshare_pid) die (""Specifying --as-pid-1 requires --unshare-pid""); if (opt_as_pid_1 && lock_files != NULL) die (""Specifying --as-pid-1 and --lock-file is not permitted""); proc_fd = open (""/proc"", O_PATH); if (proc_fd == -1) die_with_error (""Can't open /proc""); base_path = xasprintf (""/run/user/%d/.bubblewrap"", real_uid); if (ensure_dir (base_path, 0755)) { free (base_path); base_path = xasprintf (""/tmp/.bubblewrap-%d"", real_uid); if (ensure_dir (base_path, 0755)) die_with_error (""Creating root mountpoint failed""); } __debug__ ((""creating new namespace\n"")); if (opt_unshare_pid && !opt_as_pid_1) { event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK); if (event_fd == -1) die_with_error (""eventfd()""); } block_sigchild (); clone_flags = SIGCHLD | CLONE_NEWNS; if (opt_unshare_user) clone_flags |= CLONE_NEWUSER; if (opt_unshare_pid) clone_flags |= CLONE_NEWPID; if (opt_unshare_net) clone_flags |= CLONE_NEWNET; if (opt_unshare_ipc) clone_flags |= CLONE_NEWIPC; if (opt_unshare_uts) clone_flags |= CLONE_NEWUTS; if (opt_unshare_cgroup) { if (stat (""/proc/self/ns/cgroup"", &sbuf)) { if (errno == ENOENT) die (""Cannot create new cgroup namespace because the kernel does not support it""); else die_with_error (""stat on /proc/self/ns/cgroup failed""); } clone_flags |= CLONE_NEWCGROUP; } if (opt_unshare_cgroup_try) if (!stat (""/proc/self/ns/cgroup"", &sbuf)) clone_flags |= CLONE_NEWCGROUP; child_wait_fd = eventfd (0, EFD_CLOEXEC); if (child_wait_fd == -1) die_with_error (""eventfd()""); if (opt_json_status_fd != -1) { int ret; ret = pipe2 (setup_finished_pipe, O_CLOEXEC); if (ret == -1) die_with_error (""pipe2()""); } pid = raw_clone (clone_flags, NULL); if (pid == -1) { if (opt_unshare_user) { if (errno == EINVAL) die (""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.""); else if (errno == EPERM && !is_privileged) die (""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.""); } die_with_error (""Creating new namespace failed""); } ns_uid = opt_sandbox_uid; ns_gid = opt_sandbox_gid; if (pid != 0) { if (is_privileged && opt_unshare_user && opt_userns_block_fd == -1) { write_uid_gid_map (ns_uid, real_uid, ns_gid, real_gid, pid, TRUE, opt_needs_devpts); } drop_privs (FALSE); handle_die_with_parent (); if (opt_info_fd != -1) { cleanup_free char *output = xasprintf (""{\n    \""child-pid\"": %i\n}\n"", pid); dump_info (opt_info_fd, output, TRUE); close (opt_info_fd); } if (opt_json_status_fd != -1) { cleanup_free char *output = xasprintf (""{ \""child-pid\"": %i }\n"", pid); dump_info (opt_json_status_fd, output, TRUE); } if (opt_userns_block_fd != -1) { char b[1]; (void) TEMP_FAILURE_RETRY (read (opt_userns_block_fd, b, 1)); close (opt_userns_block_fd); } val = 1; res = write (child_wait_fd, &val, 8); close (child_wait_fd); return monitor_child (event_fd, pid, setup_finished_pipe[0]); } if (opt_info_fd != -1) close (opt_info_fd); if (opt_json_status_fd != -1) close (opt_json_status_fd); res = read (child_wait_fd, &val, 8); close (child_wait_fd); switch_to_user_with_privs (); if (opt_unshare_net) loopback_setup ();  ns_uid = opt_sandbox_uid; ns_gid = opt_sandbox_gid; if (!is_privileged && opt_unshare_user && opt_userns_block_fd == -1) { if (opt_needs_devpts) { ns_uid = 0; ns_gid = 0; } write_uid_gid_map (ns_uid, real_uid, ns_gid, real_gid, -1, TRUE, FALSE); } old_umask = umask (0); resolve_symlinks_in_ops (); if (mount (NULL, ""/"", NULL, MS_SLAVE | MS_REC, NULL) < 0) die_with_error (""Failed to make / slave""); if (mount (""tmpfs"", base_path, ""tmpfs"", MS_NODEV | MS_NOSUID, NULL) != 0) die_with_error (""Failed to mount tmpfs""); old_cwd = get_current_dir_name (); if (chdir (base_path) != 0) die_with_error (""chdir base_path""); if (mkdir (""newroot"", 0755)) die_with_error (""Creating newroot failed""); if (mount (""newroot"", ""newroot"", NULL, MS_MGC_VAL | MS_BIND | MS_REC, NULL) < 0) die_with_error (""setting up newroot bind""); if (mkdir (""oldroot"", 0755)) die_with_error (""Creating oldroot failed""); if (pivot_root (base_path, ""oldroot"")) die_with_error (""pivot_root""); if (chdir (""/"") != 0) die_with_error (""chdir / (base path)""); if (is_privileged) { pid_t child; int privsep_sockets[2]; if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0) die_with_error (""Can't create privsep socket""); child = fork (); if (child == -1) die_with_error (""Can't fork unprivileged helper""); if (child == 0) { drop_privs (FALSE); close (privsep_sockets[0]); setup_newroot (opt_unshare_pid, privsep_sockets[1]); exit (0); } else { int status; uint32_t buffer[2048];   uint32_t op, flags; const char *arg1, *arg2; cleanup_fd int unpriv_socket = -1; unpriv_socket = privsep_sockets[0]; close (privsep_sockets[1]); do { op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer), &flags, &arg1, &arg2); privileged_op (-1, op, flags, arg1, arg2); if (write (unpriv_socket, buffer, 1) != 1) die (""Can't write to op_socket""); } while (op != PRIV_SEP_OP_DONE); waitpid (child, &status, 0); } } else { setup_newroot (opt_unshare_pid, -1); } close_ops_fd (); if (mount (""oldroot"", ""oldroot"", NULL, MS_REC | MS_PRIVATE, NULL) != 0) die_with_error (""Failed to make old root rprivate""); if (umount2 (""oldroot"", MNT_DETACH)) die_with_error (""unmount old root""); { cleanup_fd int oldrootfd = open (""/"", O_DIRECTORY | O_RDONLY); if (oldrootfd < 0) die_with_error (""can't open /""); if (chdir (""/newroot"") != 0) die_with_error (""chdir /newroot""); if (pivot_root (""."", ""."") != 0) die_with_error (""pivot_root(/newroot)""); if (fchdir (oldrootfd) < 0) die_with_error (""fchdir to oldroot""); if (umount2 (""."", MNT_DETACH) < 0) die_with_error (""umount old root""); if (chdir (""/"") != 0) die_with_error (""chdir /""); } if (opt_unshare_user && (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid) && opt_userns_block_fd == -1) { if (unshare (CLONE_NEWUSER)) die_with_error (""unshare user ns""); write_uid_gid_map (opt_sandbox_uid, ns_uid, opt_sandbox_gid, ns_gid, -1, FALSE, FALSE); } drop_privs (!is_privileged); if (opt_block_fd != -1) { char b[1]; (void) TEMP_FAILURE_RETRY (read (opt_block_fd, b, 1)); close (opt_block_fd); } if (opt_seccomp_fd != -1) { seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len); if (seccomp_data == NULL) die_with_error (""Can't read seccomp data""); if (seccomp_len % 8 != 0) die (""Invalid seccomp data, must be multiple of 8""); seccomp_prog.len = seccomp_len / 8; seccomp_prog.filter = (struct sock_filter *) seccomp_data; close (opt_seccomp_fd); } umask (old_umask); new_cwd = ""/""; if (opt_chdir_path) { if (chdir (opt_chdir_path)) die_with_error (""Can't chdir to %s"", opt_chdir_path); new_cwd = opt_chdir_path; } else if (chdir (old_cwd) == 0) { new_cwd = old_cwd; } else { const char *home = getenv (""HOME""); if (home != NULL && chdir (home) == 0) new_cwd = home; } xsetenv (""PWD"", new_cwd, 1); free (old_cwd); if (opt_new_session && setsid () == (pid_t) -1) die_with_error (""setsid""); if (label_exec (opt_exec_label) == -1) die_with_error (""label_exec %s"", argv[0]); __debug__ ((""forking for child\n"")); if (!opt_as_pid_1 && (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1)) { pid = fork (); if (pid == -1) die_with_error (""Can't fork for pid 1""); if (pid != 0) { drop_all_caps (FALSE); { int dont_close[3]; int j = 0; if (event_fd != -1) dont_close[j++] = event_fd; if (opt_sync_fd != -1) dont_close[j++] = opt_sync_fd; dont_close[j++] = -1; fdwalk (proc_fd, close_extra_fds, dont_close); } return do_init (event_fd, pid, seccomp_data != NULL ? &seccomp_prog : NULL); } } __debug__ ((""launch executable %s\n"", argv[0])); if (proc_fd != -1) close (proc_fd); if (!opt_as_pid_1) { if (opt_sync_fd != -1) close (opt_sync_fd); } unblock_sigchild (); handle_die_with_parent (); if (!is_privileged) set_ambient_capabilities (); if (seccomp_data != NULL && prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &seccomp_prog) != 0) die_with_error (""prctl(PR_SET_SECCOMP)""); if (setup_finished_pipe[1] != -1) { char data = 0; res = write_to_fd (setup_finished_pipe[1], &data, 1); } if (execvp (argv[0], argv) == -1) { if (setup_finished_pipe[1] != -1) { int saved_errno = errno; char data = 0; res = write_to_fd (setup_finished_pipe[1], &data, 1); errno = saved_errno; } die_with_error (""execvp %s"", argv[0]); } return 0; }"
"static int match_func(struct libmnt_fs *fs, void *data __attribute__ ((__unused__))) { int rc = flags & FL_INVERT ? 1 : 0; const char *m; void *md; m = get_match(COL_FSTYPE); if (m && !mnt_fs_match_fstype(fs, m)) return rc; m = get_match(COL_OPTIONS); if (m && !mnt_fs_match_options(fs, m)) return rc; md = get_match_data(COL_MAJMIN); if (md && mnt_fs_get_devno(fs) != *((dev_t *) md)) return rc; m = get_match(COL_TARGET); if (m && !mnt_fs_match_target(fs, m, cache)) return rc; m = get_match(COL_SOURCE); if (m && !mnt_fs_match_source(fs, m, cache)) return rc; if ((flags & FL_DF) && !(flags & FL_ALL)) { const char *type = mnt_fs_get_fstype(fs); if (type && strstr(type, ""tmpfs"")) return !rc; if (mnt_fs_is_pseudofs(fs)) return rc; } if ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs)) return rc; if ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs)) return rc; if ((flags & FL_SHADOWED)) { struct libmnt_table *tb = NULL; mnt_fs_get_table(fs, &tb); if (tb && mnt_table_over_fs(tb, fs, NULL) != 0) return rc; } if ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs)) return rc; return !rc; }"
"static const char *fuse_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *callback) { struct fuse_conn *fc = get_fuse_conn(inode); struct page *page; int err; err = -EIO; if (is_bad_inode(inode)) goto out_err; if (fc->cache_symlinks) return page_get_link(dentry, inode, callback); err = -ECHILD; if (!dentry) goto out_err; page = alloc_page(GFP_KERNEL); err = -ENOMEM; if (!page) goto out_err; err = fuse_readlink_page(inode, page); if (err) { __free_page(page); goto out_err; } set_delayed_call(callback, page_put_link, page); return page_address(page); out_err: return ERR_PTR(err); }"
"bool  ExrEncoder::write( const Mat& img, const std::vector<int>& ) { int width = img.cols, height = img.rows; int depth = img.depth(), channels = img.channels(); bool result = false; bool issigned = depth == CV_8S || depth == CV_16S || depth == CV_32S; bool isfloat = depth == CV_32F || depth == CV_64F; depth = CV_ELEM_SIZE1(depth)*8; const int step = img.step; Header header( width, height ); Imf::PixelType type; if(depth == 8) type = HALF; else if(isfloat) type = FLOAT; else type = UINT; if( channels == 3 ) { header.channels().insert( ""R"", Channel( type )); header.channels().insert( ""G"", Channel( type )); header.channels().insert( ""B"", Channel( type )); } else { header.channels().insert( ""Y"", Channel( type )); } OutputFile file( m_filename.c_str(), header ); FrameBuffer frame; char *buffer; int bufferstep; int size; if( type == FLOAT && depth == 32 ) { buffer = (char *)const_cast<uchar *>(img.ptr()); bufferstep = step; size = 4; } else if( depth > 16 || type == UINT ) { buffer = (char *)new unsigned[width * channels]; bufferstep = 0; size = 4; } else { buffer = (char *)new half[width * channels]; bufferstep = 0; size = 2; } if( channels == 3 ) { frame.insert( ""B"", Slice( type, buffer, size * 3, bufferstep )); frame.insert( ""G"", Slice( type, buffer + size, size * 3, bufferstep )); frame.insert( ""R"", Slice( type, buffer + size * 2, size * 3, bufferstep )); } else frame.insert( ""Y"", Slice( type, buffer, size, bufferstep )); file.setFrameBuffer( frame ); int offset = issigned ? 1 << (depth - 1) : 0; result = true; if( type == FLOAT && depth == 32 ) { try { file.writePixels( height ); } catch(...) { result = false; } } else { for(int line = 0; line < height; line++) { if(type == UINT) { unsigned *buf = (unsigned*)buffer;  if( depth <= 8 ) { const uchar* sd = img.ptr(line); for(int i = 0; i < width * channels; i++) buf[i] = sd[i] + offset; } else if( depth <= 16 ) { const unsigned short *sd = img.ptr<unsigned short>(line); for(int i = 0; i < width * channels; i++) buf[i] = sd[i] + offset; } else { const int *sd = img.ptr<int>(line);                     for(int i = 0; i < width * channels; i++) buf[i] = (unsigned) sd[i] + offset; } } else { half *buf = (half *)buffer; if( depth <= 8 ) { const uchar* sd = img.ptr(line); for(int i = 0; i < width * channels; i++) buf[i] = sd[i]; } else if( depth <= 16 ) { const unsigned short *sd = img.ptr<unsigned short>(line); for(int i = 0; i < width * channels; i++) buf[i] = sd[i]; } } try { file.writePixels( 1 ); } catch(...) { result = false; break; } } delete[] buffer; } return result; }"
"static int pkey_gost2018_encrypt(EVP_PKEY_CTX *pctx, unsigned char *out, size_t *out_len, const unsigned char *key, size_t key_len) { PSKeyTransport_gost *pst = NULL; EVP_PKEY *pubk = EVP_PKEY_CTX_get0_pkey(pctx); struct gost_pmeth_data *data = EVP_PKEY_CTX_get_data(pctx); int pkey_nid = EVP_PKEY_base_id(pubk); unsigned char expkeys[64]; EVP_PKEY *sec_key = NULL; int ret = 0; int mac_nid = NID_undef; size_t mac_len = 0; int exp_len = 0, iv_len = 0; unsigned char *exp_buf = NULL; int key_is_ephemeral = 0; switch (data->cipher_nid) { case NID_magma_ctr: mac_nid = NID_magma_mac; mac_len = 8; iv_len = 4; break; case NID_grasshopper_ctr: mac_nid = NID_grasshopper_mac; mac_len = 16; iv_len = 8; break; default: GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_CIPHER); return -1; break; } exp_len = key_len + mac_len; exp_buf = OPENSSL_malloc(exp_len); if (!exp_buf) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); return -1; } sec_key = EVP_PKEY_CTX_get0_peerkey(pctx); if (!sec_key) { sec_key = EVP_PKEY_new(); if (sec_key == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE ); goto err; } if (!EVP_PKEY_assign(sec_key, EVP_PKEY_base_id(pubk), EC_KEY_new()) || !EVP_PKEY_copy_parameters(sec_key, pubk) || !gost_ec_keygen(EVP_PKEY_get0(sec_key))) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_SHARED_KEY); goto err; } key_is_ephemeral = 1; } if (data->shared_ukm_size == 0) { if (RAND_bytes(data->shared_ukm, 32) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_INTERNAL_ERROR); goto err; } data->shared_ukm_size = 32; } if (gost_keg(data->shared_ukm, pkey_nid, EC_KEY_get0_public_key(EVP_PKEY_get0(pubk)), EVP_PKEY_get0(sec_key), expkeys) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_ERROR_COMPUTING_EXPORT_KEYS); goto err; } if (gost_kexp15(key, key_len, data->cipher_nid, expkeys + 32, mac_nid, expkeys + 0, data->shared_ukm + 24, iv_len, exp_buf, &exp_len) <= 0) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } pst = PSKeyTransport_gost_new(); if (!pst) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } pst->ukm = ASN1_OCTET_STRING_new(); if (pst->ukm == NULL) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->ukm, data->shared_ukm, data->shared_ukm_size)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!ASN1_OCTET_STRING_set(pst->psexp, exp_buf, exp_len)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, ERR_R_MALLOC_FAILURE); goto err; } if (!X509_PUBKEY_set(&pst->ephem_key, out ? sec_key : pubk)) { GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_CANNOT_PACK_EPHEMERAL_KEY); goto err; } if ((*out_len = i2d_PSKeyTransport_gost(pst, out ? &out : NULL)) > 0) ret = 1; err: OPENSSL_cleanse(expkeys, sizeof(expkeys)); if (key_is_ephemeral) EVP_PKEY_free(sec_key); PSKeyTransport_gost_free(pst); OPENSSL_free(exp_buf); return ret; }"
"int blkcg_init_queue(struct request_queue *q) { struct blkcg_gq *new_blkg, *blkg; bool preloaded; int ret; new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL); if (!new_blkg) return -ENOMEM; preloaded = !radix_tree_preload(GFP_KERNEL); rcu_read_lock(); spin_lock_irq(q->queue_lock); blkg = blkg_create(&blkcg_root, q, new_blkg); spin_unlock_irq(q->queue_lock); rcu_read_unlock(); if (preloaded) radix_tree_preload_end(); if (IS_ERR(blkg)) { blkg_free(new_blkg); return PTR_ERR(blkg); } q->root_blkg = blkg; q->root_rl.blkg = blkg; ret = blk_throtl_init(q); if (ret) { spin_lock_irq(q->queue_lock); blkg_destroy_all(q); spin_unlock_irq(q->queue_lock); } return ret; }"
"static int __videobuf_mmap_mapper(struct videobuf_queue *q, struct vm_area_struct *vma) { struct videbuf_vmalloc_memory *mem; struct videobuf_mapping *map; unsigned int first; int retval; unsigned long offset = vma->vm_pgoff << PAGE_SHIFT; if (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED)) return -EINVAL; for (first = 0; first < VIDEO_MAX_FRAME; first++) { if (NULL == q->bufs[first]) continue; if (V4L2_MEMORY_MMAP != q->bufs[first]->memory) continue; if (q->bufs[first]->boff == offset) break; } if (VIDEO_MAX_FRAME == first) { dprintk(1,""mmap app bug: offset invalid [offset=0x%lx]\n"", (vma->vm_pgoff << PAGE_SHIFT)); return -EINVAL; } map = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL); if (NULL == map) return -ENOMEM; map->start = vma->vm_start; map->end   = vma->vm_end; map->q     = q; q->bufs[first]->baddr = vma->vm_start; vma->vm_ops          = &videobuf_vm_ops; vma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED; vma->vm_private_data = map; mem=q->bufs[first]->priv; BUG_ON (!mem); MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM); retval=remap_vmalloc_range(vma, mem->vmalloc,0); if (retval<0) { dprintk(1,""mmap: postponing remap_vmalloc_range\n""); mem->vma=kmalloc(sizeof(*vma),GFP_KERNEL); if (!mem->vma) { kfree(map); q->bufs[first]->map=NULL; return -ENOMEM; } memcpy(mem->vma,vma,sizeof(*vma)); } dprintk(1,""mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\n"", map,q,vma->vm_start,vma->vm_end, (long int) q->bufs[first]->bsize, vma->vm_pgoff,first); videobuf_vm_open(vma); return (0); }"
"static bool create_section_from_phdr(ELFOBJ *bin, RzVector *result, const char *name, ut64 addr, ut64 sz) { RzBinElfSection *section = rz_vector_push(result, NULL); if (!section) { RZ_LOG_WARN(""Failed to allocate memory for the section."") return false; } section->offset = Elf_(rz_bin_elf_v2p_new)(bin, addr); if (section->offset == UT64_MAX) { RZ_LOG_WARN(""invalid section offset."") return false; } section->rva = addr; section->size = sz; section->name = strdup(name); if (!section->name) { RZ_LOG_WARN(""Failed to allocate memory for the section name."") return false; } return true; }"
"static int userauth_pubkey(struct ssh *ssh) { Authctxt *authctxt = ssh->authctxt; struct passwd *pw = authctxt->pw; struct sshbuf *b; struct sshkey *key = NULL; char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL; u_char *pkblob, *sig, have_sig; size_t blen, slen; int r, pktype; int authenticated = 0; struct sshauthopt *authopts = NULL; if (!authctxt->valid) { debug2(""%s: disabled because of invalid user"", __func__); return 0; } if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 || (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 || (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0) fatal(""%s: parse request failed: %s"", __func__, ssh_err(r)); pktype = sshkey_type_from_name(pkalg); if (pktype == KEY_UNSPEC) { verbose(""%s: unsupported public key algorithm: %s"", __func__, pkalg); goto done; } if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) { error(""%s: could not parse key: %s"", __func__, ssh_err(r)); goto done; } if (key == NULL) { error(""%s: cannot decode key: %s"", __func__, pkalg); goto done; } if (key->type != pktype) { error(""%s: type mismatch for decoded key "" ""(received %d, expected %d)"", __func__, key->type, pktype); goto done; } if (sshkey_type_plain(key->type) == KEY_RSA && (ssh->compat & SSH_BUG_RSASIGMD5) != 0) { logit(""Refusing RSA key because client uses unsafe "" ""signature scheme""); goto done; } if (auth2_key_already_used(authctxt, key)) { logit(""refusing previously-used %s key"", sshkey_type(key)); goto done; } if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) { logit(""%s: key type %s not in PubkeyAcceptedKeyTypes"", __func__, sshkey_ssh_name(key)); goto done; } key_s = format_key(key); if (sshkey_is_cert(key)) ca_s = format_key(key->cert->signature_key); if (have_sig) { debug3(""%s: have %s signature for %s%s%s"", __func__, pkalg, key_s, ca_s == NULL ? """" : "" CA "", ca_s == NULL ? """" : ca_s); if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 || (r = sshpkt_get_end(ssh)) != 0) fatal(""%s: %s"", __func__, ssh_err(r)); if ((b = sshbuf_new()) == NULL) fatal(""%s: sshbuf_new failed"", __func__); if (ssh->compat & SSH_OLD_SESSIONID) { if ((r = sshbuf_put(b, session_id2, session_id2_len)) != 0) fatal(""%s: sshbuf_put session id: %s"", __func__, ssh_err(r)); } else { if ((r = sshbuf_put_string(b, session_id2, session_id2_len)) != 0) fatal(""%s: sshbuf_put_string session id: %s"", __func__, ssh_err(r)); } xasprintf(&userstyle, ""%s%s%s"", authctxt->user, authctxt->style ? "":"" : """", authctxt->style ? authctxt->style : """"); if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 || (r = sshbuf_put_cstring(b, userstyle)) != 0 || (r = sshbuf_put_cstring(b, authctxt->service)) != 0 || (r = sshbuf_put_cstring(b, ""publickey"")) != 0 || (r = sshbuf_put_u8(b, have_sig)) != 0 || (r = sshbuf_put_cstring(b, pkalg) != 0) || (r = sshbuf_put_string(b, pkblob, blen)) != 0) fatal(""%s: build packet failed: %s"", __func__, ssh_err(r)); #ifdef DEBUG_PK sshbuf_dump(b, stderr); #endif authenticated = 0; if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) && PRIVSEP(sshkey_verify(key, sig, slen, sshbuf_ptr(b), sshbuf_len(b), (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL, ssh->compat)) == 0) { authenticated = 1; } sshbuf_free(b); free(sig); auth2_record_key(authctxt, authenticated, key); } else { debug(""%s: test pkalg %s pkblob %s%s%s"", __func__, pkalg, key_s, ca_s == NULL ? """" : "" CA "", ca_s == NULL ? """" : ca_s); if ((r = sshpkt_get_end(ssh)) != 0) fatal(""%s: %s"", __func__, ssh_err(r)); if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) { if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK)) != 0 || (r = sshpkt_put_cstring(ssh, pkalg)) != 0 || (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 || (r = sshpkt_send(ssh)) != 0 || (r = ssh_packet_write_wait(ssh)) != 0) fatal(""%s: %s"", __func__, ssh_err(r)); authctxt->postponed = 1; } } done: if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) { debug(""%s: key options inconsistent with existing"", __func__); authenticated = 0; } debug2(""%s: authenticated %d pkalg %s"", __func__, authenticated, pkalg); sshauthopt_free(authopts); sshkey_free(key); free(userstyle); free(pkalg); free(pkblob); free(key_s); free(ca_s); return authenticated; }"
"static int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; int entries, i, j; if (c->fc->nb_streams < 1) return 0; st = c->fc->streams[c->fc->nb_streams-1]; sc = st->priv_data; avio_rb32(pb);     entries = avio_rb32(pb); if (entries >= UINT_MAX / sizeof(*sc->drefs)) return AVERROR_INVALIDDATA; av_free(sc->drefs); sc->drefs = av_mallocz(entries * sizeof(*sc->drefs)); if (!sc->drefs) return AVERROR(ENOMEM); sc->drefs_count = entries; for (i = 0; i < sc->drefs_count; i++) { MOVDref *dref = &sc->drefs[i]; uint32_t size = avio_rb32(pb); int64_t next = avio_tell(pb) + size - 4; if (size < 12) return AVERROR_INVALIDDATA; dref->type = avio_rl32(pb); avio_rb32(pb);         av_dlog(c->fc, ""type %.4s size %d\n"", (char*)&dref->type, size); if (dref->type == MKTAG('a','l','i','s') && size > 150) { uint16_t volume_len, len; int16_t type; avio_skip(pb, 10); volume_len = avio_r8(pb); volume_len = FFMIN(volume_len, 27); avio_read(pb, dref->volume, 27); dref->volume[volume_len] = 0; av_log(c->fc, AV_LOG_DEBUG, ""volume %s, len %d\n"", dref->volume, volume_len); avio_skip(pb, 12); len = avio_r8(pb); len = FFMIN(len, 63); avio_read(pb, dref->filename, 63); dref->filename[len] = 0; av_log(c->fc, AV_LOG_DEBUG, ""filename %s, len %d\n"", dref->filename, len); avio_skip(pb, 16); dref->nlvl_from = avio_rb16(pb); dref->nlvl_to   = avio_rb16(pb); av_log(c->fc, AV_LOG_DEBUG, ""nlvl from %d, nlvl to %d\n"", dref->nlvl_from, dref->nlvl_to); avio_skip(pb, 16); for (type = 0; type != -1 && avio_tell(pb) < next; ) { if(url_feof(pb)) return AVERROR_EOF; type = avio_rb16(pb); len = avio_rb16(pb); av_log(c->fc, AV_LOG_DEBUG, ""type %d, len %d\n"", type, len); if (len&1) len += 1; if (type == 2) {                     av_free(dref->path); dref->path = av_mallocz(len+1); if (!dref->path) return AVERROR(ENOMEM); avio_read(pb, dref->path, len); if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) { len -= volume_len; memmove(dref->path, dref->path+volume_len, len); dref->path[len] = 0; } for (j = 0; j < len; j++) if (dref->path[j] == ':') dref->path[j] = '/'; av_log(c->fc, AV_LOG_DEBUG, ""path %s\n"", dref->path); } else if (type == 0) {                     av_free(dref->dir); dref->dir = av_malloc(len+1); if (!dref->dir) return AVERROR(ENOMEM); avio_read(pb, dref->dir, len); dref->dir[len] = 0; for (j = 0; j < len; j++) if (dref->dir[j] == ':') dref->dir[j] = '/'; av_log(c->fc, AV_LOG_DEBUG, ""dir %s\n"", dref->dir); } else avio_skip(pb, len); } } avio_seek(pb, next, SEEK_SET); } return 0; }"
"static void append_options(DBusMessageIter *iter, void *user_data) { struct pending_op *op = user_data; const char *path = device_get_path(op->device); struct bt_gatt_server *server; const char *link; uint16_t mtu; switch (op->link_type) { case BT_ATT_BREDR: link = ""BR/EDR""; break; case BT_ATT_LE: link = ""LE""; break; default: link = NULL; break; } dict_append_entry(iter, ""device"", DBUS_TYPE_OBJECT_PATH, &path); if (op->offset) dict_append_entry(iter, ""offset"", DBUS_TYPE_UINT16, &op->offset); if (link) dict_append_entry(iter, ""link"", DBUS_TYPE_STRING, &link); if (op->prep_authorize) dict_append_entry(iter, ""prepare-authorize"", DBUS_TYPE_BOOLEAN, &op->prep_authorize); server = btd_device_get_gatt_server(op->device); mtu = bt_gatt_server_get_mtu(server); dict_append_entry(iter, ""mtu"", DBUS_TYPE_UINT16, &mtu); }"
"static size_t transcodeQ15ToFloat(uint8_t* buffer, size_t length, BtifAvrcpAudioTrack* trackHolder) { size_t sampleSize = sampleSizeFor(trackHolder); size_t i = 0; for (; i <= length / sampleSize; i++) { trackHolder->buffer[i] = ((int16_t*)buffer)[i] * kScaleQ15ToFloat; } return i * sampleSize; }"
void recovery_delete_character(void) { if(strlen(mnemonic) > 0) { mnemonic[strlen(mnemonic) - 1] = '\0'; } next_character(); }
"uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr) { VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev); uint32_t val; k->get_config(vdev, vdev->config); if (addr > (vdev->config_len - sizeof(val))) return (uint32_t)-1; val = ldl_p(vdev->config + addr); return val; }"
"bool PathGroup::hasPath(const std::string& name, Http::Method method) const { auto group = paths(name); auto it    = std::find_if(std::begin(group), std::end(group), [&](const Path& p) { return p.method == method; }); return it != std::end(group); }"
"const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst, socklen_t size) { if (!src || !dst) { errno = EFAULT; return nullptr; } size_t src_size = 0; if (af == AF_INET) { src_size = sizeof(struct in_addr); } else if (af == AF_INET6) { src_size = sizeof(struct in6_addr); } else { errno = EAFNOSUPPORT; return nullptr; } MessageWriter input; input.Push<int>(TokLinuxAfFamily(af)); input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size}); input.Push(size); MessageReader output; const auto status = NonSystemCallDispatcher( ::asylo::host_call::kInetNtopHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_ntop"", 2); auto result = output.next(); int klinux_errno = output.next<int>(); if (result.empty()) { errno = FromkLinuxErrorNumber(klinux_errno); return nullptr; } memcpy(dst, result.data(), std::min(static_cast<size_t>(size), static_cast<size_t>(INET6_ADDRSTRLEN))); return dst; }"
"static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data) { size_t realsize = 0; connection_t *conn = NULL; char *ptr = NULL; conn = data; ogs_assert(conn); realsize = size * nmemb; ptr = ogs_realloc(conn->memory, conn->size + realsize + 1); if(!ptr) { ogs_fatal(""not enough memory (realloc returned NULL)""); ogs_assert_if_reached(); return 0; } conn->memory = ptr; memcpy(&(conn->memory[conn->size]), contents, realsize); conn->size += realsize; conn->memory[conn->size] = 0; return realsize; }"
"static void handle_method_call(GDBusConnection *connection, const gchar *caller, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant    *parameters, GDBusMethodInvocation *invocation, gpointer    user_data) { reset_timeout(); uid_t caller_uid; GVariant *response; caller_uid = get_caller_uid(connection, invocation, caller); log_notice(""caller_uid:%ld method:'%s'"", (long)caller_uid, method_name); if (caller_uid == (uid_t) -1) return; if (g_strcmp0(method_name, ""NewProblem"") == 0) { char *error = NULL; char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error); if (!problem_id) { g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); free(error); return; } response = g_variant_new(""(s)"", problem_id); g_dbus_method_invocation_return_value(invocation, response); free(problem_id); return; } if (g_strcmp0(method_name, ""GetProblems"") == 0) { GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""GetAllProblems"") == 0) { if (caller_uid != 0) { if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes) caller_uid = 0; } GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""GetForeignProblems"") == 0) { GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""ChownProblemDir"") == 0) { const gchar *problem_dir; g_variant_get(parameters, ""(&s)"", &problem_dir); log_notice(""problem_dir:'%s'"", problem_dir); if (!allowed_problem_dir(problem_dir)) { return_InvalidProblemDir_error(invocation, problem_dir); return; } int ddstat = dump_dir_stat_for_uid(problem_dir, caller_uid); if (ddstat < 0) { if (errno == ENOTDIR) { log_notice(""requested directory does not exist '%s'"", problem_dir); } else { perror_msg(""can't get stat of '%s'"", problem_dir); } return_InvalidProblemDir_error(invocation, problem_dir); return; } if (ddstat & DD_STAT_OWNED_BY_UID) {               log_notice(""caller has access to the requested directory %s"", problem_dir); g_dbus_method_invocation_return_value(invocation, NULL); return; } if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) { log_notice(""not authorized""); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.AuthFailure"", _(""Not Authorized"")); return; } struct dump_dir *dd = dd_opendir(problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES); if (!dd) { return_InvalidProblemDir_error(invocation, problem_dir); return; } int chown_res = dd_chown(dd, caller_uid); if (chown_res != 0) g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.ChownError"", _(""Chowning directory failed. Check system logs for more details."")); else g_dbus_method_invocation_return_value(invocation, NULL); dd_close(dd); return; } if (g_strcmp0(method_name, ""GetInfo"") == 0) { const gchar *problem_dir; g_variant_get_child(parameters, 0, ""&s"", &problem_dir); log_notice(""problem_dir:'%s'"", problem_dir); if (!allowed_problem_dir(problem_dir)) { return_InvalidProblemDir_error(invocation, problem_dir); return; } if (!dump_dir_accessible_by_uid(problem_dir, caller_uid)) { if (errno == ENOTDIR) { log_notice(""Requested directory does not exist '%s'"", problem_dir); return_InvalidProblemDir_error(invocation, problem_dir); return; } if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) { log_notice(""not authorized""); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.AuthFailure"", _(""Not Authorized"")); return; } } struct dump_dir *dd = dd_opendir(problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES); if (!dd) { return_InvalidProblemDir_error(invocation, problem_dir); return; } GVariant *array = g_variant_get_child_value(parameters, 1); GList *elements = string_list_from_variant(array); g_variant_unref(array); GVariantBuilder *builder = NULL; for (GList *l = elements; l; l = l->next) { const char *element_name = (const char*)l->data; char *value = dd_load_text_ext(dd, element_name, 0 | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT | DD_FAIL_QUIETLY_EACCES); log_notice(""element '%s' %s"", element_name, value ? ""fetched"" : ""not found""); if (value) { if (!builder) builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); g_variant_builder_add(builder, ""{ss}"", element_name, value); free(value); } } list_free_with_free(elements); dd_close(dd); GVariant *response = g_variant_new(""(a{ss})"", builder); if (builder) g_variant_builder_unref(builder); log_info(""GetInfo: returning value for '%s'"", problem_dir); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""SetElement"") == 0) { const char *problem_id; const char *element; const char *value; g_variant_get(parameters, ""(&s&s&s)"", &problem_id, &element, &value); if (element == NULL || element[0] == '\0' || strlen(element) > 64) { log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id); char *error = xasprintf(_(""'%s' is not a valid element name""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.InvalidElement"", error); free(error); return; } struct dump_dir *dd = open_directory_for_modification_of_element( invocation, caller_uid, problem_id, element); if (!dd) return; const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024); const long item_size = dd_get_item_size(dd, element); if (item_size < 0) { log_notice(""Can't get size of '%s/%s'"", problem_id, element); char *error = xasprintf(_(""Can't get size of '%s'""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); return; } const double requested_size = (double)strlen(value) - item_size; if (requested_size > 0 && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location))) { log_notice(""No problem space left in '%s' (requested Bytes %f)"", problem_id, requested_size); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", _(""No problem space left"")); } else { dd_save_text(dd, element, value); g_dbus_method_invocation_return_value(invocation, NULL); } dd_close(dd); return; } if (g_strcmp0(method_name, ""DeleteElement"") == 0) { const char *problem_id; const char *element; g_variant_get(parameters, ""(&s&s)"", &problem_id, &element); struct dump_dir *dd = open_directory_for_modification_of_element( invocation, caller_uid, problem_id, element); if (!dd) return; const int res = dd_delete_item(dd, element); dd_close(dd); if (res != 0) { log_notice(""Can't delete the element '%s' from the problem directory '%s'"", element, problem_id); char *error = xasprintf(_(""Can't delete the element '%s' from the problem directory '%s'""), element, problem_id); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); free(error); return; } g_dbus_method_invocation_return_value(invocation, NULL); return; } if (g_strcmp0(method_name, ""DeleteProblem"") == 0) { GVariant *array = g_variant_get_child_value(parameters, 0); GList *problem_dirs = string_list_from_variant(array); g_variant_unref(array); for (GList *l = problem_dirs; l; l = l->next) { const char *dir_name = (const char*)l->data; log_notice(""dir_name:'%s'"", dir_name); if (!allowed_problem_dir(dir_name)) { return_InvalidProblemDir_error(invocation, dir_name); goto ret; } } for (GList *l = problem_dirs; l; l = l->next) { const char *dir_name = (const char*)l->data; if (!dump_dir_accessible_by_uid(dir_name, caller_uid)) { if (errno == ENOTDIR) { log_notice(""Requested directory does not exist '%s'"", dir_name); continue; } if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) {                     continue; } } delete_dump_dir(dir_name); } g_dbus_method_invocation_return_value(invocation, NULL); ret: list_free_with_free(problem_dirs); return; } if (g_strcmp0(method_name, ""FindProblemByElementInTimeRange"") == 0) { const gchar *element; const gchar *value; glong timestamp_from; glong timestamp_to; gboolean all; g_variant_get_child(parameters, 0, ""&s"", &element); g_variant_get_child(parameters, 1, ""&s"", &value); g_variant_get_child(parameters, 2, ""x"", &timestamp_from); g_variant_get_child(parameters, 3, ""x"", &timestamp_to); g_variant_get_child(parameters, 4, ""b"", &all); if (all && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes) caller_uid = 0; GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from, timestamp_to); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""Quit"") == 0) { g_dbus_method_invocation_return_value(invocation, NULL); g_main_loop_quit(loop); return; } }"
"LiteralString(const std::string &s, bool ignore_case) : lit_(s), ignore_case_(ignore_case), is_word_(false) {}"
"static int try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level) { int                start_offset; gint8              ber_class; gboolean           pc, ind; gint32             tag; guint32            len; int                hdr_len; proto_item        *item      = NULL; proto_tree        *next_tree = NULL; guint8             c; guint32            i; gboolean           is_printable; volatile gboolean  is_decoded_as; proto_item        *pi, *cause; asn1_ctx_t         asn1_ctx; if (nest_level > BER_MAX_NESTING) { THROW(ReportedBoundsError); } start_offset = offset; asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo); offset = get_ber_identifier(tvb, offset, &ber_class, &pc, &tag); offset = get_ber_length(tvb, offset, &len, &ind); if (len > (guint32)tvb_reported_length_remaining(tvb, offset)) { if (show_internal_ber_fields) { offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag); offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL); } cause = proto_tree_add_string_format_value( tree, hf_ber_error, tvb, offset, len, ""illegal_length"", ""length:%u longer than tvb_reported_length_remaining:%d"", len, tvb_reported_length_remaining(tvb, offset)); expert_add_info(pinfo, cause, &ei_ber_error_length); return tvb_reported_length(tvb); } switch (pc) { case FALSE:  switch (ber_class) {  case BER_CLASS_UNI:  switch (tag) { case BER_UNI_TAG_EOC: break; case BER_UNI_TAG_INTEGER: offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_INTEGER, NULL); break; case BER_UNI_TAG_REAL: offset = dissect_ber_real(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_REAL, NULL); break; case BER_UNI_TAG_BITSTRING: offset = dissect_ber_bitstring(FALSE, &asn1_ctx, tree, tvb, start_offset, NULL, hf_ber_unknown_BITSTRING, -1, NULL); break; case BER_UNI_TAG_ENUMERATED: offset = dissect_ber_integer(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_ENUMERATED, NULL); break; case BER_UNI_TAG_GraphicString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GraphicString, NULL); break; case BER_UNI_TAG_OCTETSTRING: is_decoded_as = FALSE; if (decode_octetstring_as_ber && (len >= 2)) { volatile int ber_offset = 0; guint32 ber_len = 0; TRY { ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL); ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL); } CATCH_ALL { } ENDTRY; if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) { is_decoded_as = TRUE; if (show_internal_ber_fields) { offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, NULL, NULL, NULL); offset = dissect_ber_length(pinfo, tree, tvb, offset, NULL, NULL); } item = ber_proto_tree_add_item(pinfo, tree, hf_ber_unknown_BER_OCTETSTRING, tvb, offset, len, ENC_NA); next_tree = proto_item_add_subtree(item, ett_ber_octet_string); offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1); } } if (!is_decoded_as) { offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OCTETSTRING, NULL); } break; case BER_UNI_TAG_OID: offset = dissect_ber_object_identifier_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_OID, NULL); break; case BER_UNI_TAG_RELATIVE_OID: offset = dissect_ber_relative_oid_str(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_relative_OID, NULL); break; case BER_UNI_TAG_NumericString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_NumericString, NULL); break; case BER_UNI_TAG_PrintableString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_PrintableString, NULL); break; case BER_UNI_TAG_TeletexString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_TeletexString, NULL); break; case BER_UNI_TAG_VisibleString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_VisibleString, NULL); break; case BER_UNI_TAG_GeneralString: offset = dissect_ber_GeneralString(&asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralString, NULL, 0); break; case BER_UNI_TAG_BMPString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BMPString, NULL); break; case BER_UNI_TAG_UniversalString: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UniversalString, NULL); break; case BER_UNI_TAG_IA5String: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_IA5String, NULL); break; case BER_UNI_TAG_UTCTime: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTCTime, NULL); break; case BER_UNI_TAG_NULL: proto_tree_add_item(tree, hf_ber_null_tag, tvb, offset, len, ENC_NA); break; case BER_UNI_TAG_UTF8String: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_UTF8String, NULL); break; case BER_UNI_TAG_GeneralizedTime: offset = dissect_ber_octet_string(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_GeneralizedTime, NULL); break; case BER_UNI_TAG_BOOLEAN: offset = dissect_ber_boolean(FALSE, &asn1_ctx, tree, tvb, start_offset, hf_ber_unknown_BOOLEAN, NULL); break; default: offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag); offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL); cause = proto_tree_add_string_format_value( tree, hf_ber_error, tvb, offset, len, ""unknown_universal_tag"", ""can not handle universal tag:%d"", tag); expert_add_info(pinfo, cause, &ei_ber_universal_tag_unknown); offset += len; } break; case BER_CLASS_APP: case BER_CLASS_CON: case BER_CLASS_PRI: default: if (show_internal_ber_fields) { offset = dissect_ber_identifier(pinfo, tree, tvb, start_offset, &ber_class, &pc, &tag); offset = dissect_ber_length(pinfo, tree, tvb, offset, &len, NULL); } pi = proto_tree_add_none_format(tree, hf_ber_unknown_BER_primitive, tvb, offset, len, ""[%s %d] "", val_to_str_const(ber_class, ber_class_codes, ""Unknown""), tag); is_decoded_as = FALSE; if (decode_primitive_as_ber && (len >= 2)) { volatile int ber_offset = 0; guint32 ber_len = 0; TRY { ber_offset = get_ber_identifier(tvb, offset, NULL, &pc, NULL); ber_offset = get_ber_length(tvb, ber_offset, &ber_len, NULL); } CATCH_ALL { } ENDTRY; if (pc && (ber_len > 0) && (ber_len + (ber_offset - offset) == len)) { is_decoded_as = TRUE; proto_item_append_text (pi, ""[BER encoded]""); next_tree = proto_item_add_subtree(pi, ett_ber_primitive); offset = try_dissect_unknown_ber(pinfo, tvb, offset, next_tree, nest_level+1); } } if (!is_decoded_as && len) { is_printable = TRUE; for (i=0; i<len; i++) { c = tvb_get_guint8(tvb, offset+i); if (is_printable && !g_ascii_isprint(c)) is_printable = FALSE; proto_item_append_text(pi, ""%02x"", c); } if (is_printable) {  proto_item_append_text(pi, "" (""); for (i=0; i<len; i++) { proto_item_append_text(pi, ""%c"", tvb_get_guint8(tvb, offset+i)); } proto_item_append_text(pi, "")""); } offset += len; } break; }"
"static int set_geometry(unsigned int cmd, struct floppy_struct *g, int drive, int type, struct block_device *bdev) { int cnt; if (g->sect <= 0 || g->head <= 0 || g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) || (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0) return -EINVAL; if (type) { if (!capable(CAP_SYS_ADMIN)) return -EPERM; mutex_lock(&open_lock); if (lock_fdc(drive)) { mutex_unlock(&open_lock); return -EINTR; } floppy_type[type] = *g; floppy_type[type].name = ""user format""; for (cnt = type << 2; cnt < (type << 2) + 4; cnt++) floppy_sizes[cnt] = floppy_sizes[cnt + 0x80] = floppy_type[type].size + 1; process_fd_request(); for (cnt = 0; cnt < N_DRIVE; cnt++) { struct block_device *bdev = opened_bdev[cnt]; if (!bdev || ITYPE(drive_state[cnt].fd_device) != type) continue; __invalidate_device(bdev, true); } mutex_unlock(&open_lock); } else { int oldStretch; if (lock_fdc(drive)) return -EINTR; if (cmd != FDDEFPRM) { if (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR) return -EINTR; } oldStretch = g->stretch; user_params[drive] = *g; if (buffer_drive == drive) SUPBOUND(buffer_max, user_params[drive].sect); current_type[drive] = &user_params[drive]; floppy_sizes[drive] = user_params[drive].size; if (cmd == FDDEFPRM) DRS->keep_data = -1; else DRS->keep_data = 1; if (DRS->maxblock > user_params[drive].sect || DRS->maxtrack || ((user_params[drive].sect ^ oldStretch) & (FD_SWAPSIDES | FD_SECTBASEMASK))) invalidate_drive(bdev); else process_fd_request(); } return 0; }"
"static int keyring_search_iterator(const void *object, void *iterator_data) { struct keyring_search_context *ctx = iterator_data; const struct key *key = keyring_ptr_to_key(object); unsigned long kflags = key->flags; kenter(""{%d}"", key->serial); if (key->type != ctx->index_key.type) { kleave("" = 0 [!type]""); return 0; } if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) { if (kflags & ((1 << KEY_FLAG_INVALIDATED) | (1 << KEY_FLAG_REVOKED))) { ctx->result = ERR_PTR(-EKEYREVOKED); kleave("" = %d [invrev]"", ctx->skipped_ret); goto skipped; } if (key->expiry && ctx->now.tv_sec >= key->expiry) { if (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED)) ctx->result = ERR_PTR(-EKEYEXPIRED); kleave("" = %d [expire]"", ctx->skipped_ret); goto skipped; } } if (!ctx->match_data.cmp(key, &ctx->match_data)) { kleave("" = 0 [!match]""); return 0; } if (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) && key_task_permission(make_key_ref(key, ctx->possessed), ctx->cred, KEY_NEED_SEARCH) < 0) { ctx->result = ERR_PTR(-EACCES); kleave("" = %d [!perm]"", ctx->skipped_ret); goto skipped; } if (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) { if (kflags & (1 << KEY_FLAG_NEGATIVE)) { smp_rmb(); ctx->result = ERR_PTR(key->reject_error); kleave("" = %d [neg]"", ctx->skipped_ret); goto skipped; } } ctx->result = make_key_ref(key, ctx->possessed); kleave("" = 1 [found]""); return 1; skipped: return ctx->skipped_ret; }"
"static GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current) { u32 count; count = gf_list_count(parser->entities); while (count) { char *entityEnd; XML_Entity *ent; char *entityStart = strstr(current, ""&""); Bool needs_text; u32 line_num; if (parser->in_entity) { u32 len; char *name; entityEnd = strstr(current, "";""); if (!entityEnd) return xml_sax_append_string(parser, current); entityStart = strrchr(parser->buffer, '&'); entityEnd[0] = 0; len = (u32) strlen(entityStart) + (u32) strlen(current) + 1; name = (char*)gf_malloc(sizeof(char)*len); sprintf(name, ""%s%s;"", entityStart+1, current); ent = gf_xml_locate_entity(parser, name, &needs_text); gf_free(name); if (!ent && !needs_text) { xml_sax_append_string(parser, current); xml_sax_parse(parser, GF_TRUE); entityEnd[0] = ';'; current = entityEnd; continue; } assert(ent); parser->line_size -= (u32) strlen(entityStart); entityStart[0] = 0; parser->in_entity = GF_FALSE; entityEnd[0] = ';'; current = entityEnd+1; } else { if (!entityStart) break; ent = gf_xml_locate_entity(parser, entityStart+1, &needs_text); entityStart[0] = 0; xml_sax_append_string(parser, current); xml_sax_parse(parser, GF_TRUE); entityStart[0] = '&'; if (!ent && !needs_text) { xml_sax_append_string(parser, ""&""); current = entityStart+1; continue; } if (!ent) { parser->in_entity = GF_TRUE; return xml_sax_append_string(parser, entityStart); } current = entityStart + ent->namelen + 2; } line_num = parser->line; xml_sax_append_string(parser, ent->value); GF_Err e = xml_sax_parse(parser, GF_TRUE); parser->line = line_num; if (e) return e; } xml_sax_append_string(parser, current); return xml_sax_parse(parser, GF_FALSE); }"
"Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context, NodeCosts* node_costs) const { bool found_unknown_shapes = false; const auto& op_info = op_context.op_info; ConvolutionDimensions dims = OpDimensionsFromInputs( op_info.inputs(0).shape(), op_info, &found_unknown_shapes); int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1; int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops; node_costs->num_compute_ops = ops; int64_t input_size = 0; if (dims.ky >= dims.sy) { input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes); } else {                  const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype())); input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz; } node_costs->num_input_bytes_accessed = {input_size}; const int64_t output_size = CalculateOutputSize(op_info, &found_unknown_shapes); node_costs->num_output_bytes_accessed = {output_size}; node_costs->max_memory = output_size; if (found_unknown_shapes) { node_costs->inaccurate = true; node_costs->num_nodes_with_unknown_shapes = 1; } return Status::OK(); }"
"static void *kmalloc_reserve(unsigned int *size, gfp_t flags, int node, bool *pfmemalloc) { bool ret_pfmemalloc = false; unsigned int obj_size; void *obj; obj_size = SKB_HEAD_ALIGN(*size); if (obj_size <= SKB_SMALL_HEAD_CACHE_SIZE && !(flags & KMALLOC_NOT_NORMAL_BITS)) { obj = kmem_cache_alloc_node(skb_small_head_cache, flags | __GFP_NOMEMALLOC | __GFP_NOWARN, node); *size = SKB_SMALL_HEAD_CACHE_SIZE; if (obj || !(gfp_pfmemalloc_allowed(flags))) goto out; ret_pfmemalloc = true; obj = kmem_cache_alloc_node(skb_small_head_cache, flags, node); goto out; } *size = obj_size = kmalloc_size_roundup(obj_size); obj = kmalloc_node_track_caller(obj_size, flags | __GFP_NOMEMALLOC | __GFP_NOWARN, node); if (obj || !(gfp_pfmemalloc_allowed(flags))) goto out; ret_pfmemalloc = true; obj = kmalloc_node_track_caller(obj_size, flags, node); out: if (pfmemalloc) *pfmemalloc = ret_pfmemalloc; return obj; }"
"static gboolean xcf_load_image_props (XcfInfo   *info, GimpImage *image) { PropType prop_type; guint32  prop_size; while (TRUE) { if (! xcf_load_prop (info, &prop_type, &prop_size)) return FALSE; switch (prop_type) { case PROP_END: return TRUE; case PROP_COLORMAP: { guint32 n_colors; guchar  cmap[GIMP_IMAGE_COLORMAP_SIZE]; xcf_read_int32 (info, &n_colors, 1); if (n_colors > (GIMP_IMAGE_COLORMAP_SIZE / 3)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_ERROR, ""Maximum colormap size (%d) exceeded"", GIMP_IMAGE_COLORMAP_SIZE); return FALSE; } if (info->file_version == 0) { gint i; gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, _(""XCF warning: version 0 of XCF file format\n"" ""did not save indexed colormaps correctly.\n"" ""Substituting grayscale map."")); if (! xcf_seek_pos (info, info->cp + n_colors, NULL)) return FALSE; for (i = 0; i < n_colors; i++) { cmap[i * 3 + 0] = i; cmap[i * 3 + 1] = i; cmap[i * 3 + 2] = i; } } else { xcf_read_int8 (info, cmap, n_colors * 3); } if (gimp_image_get_base_type (image) == GIMP_INDEXED) gimp_image_set_colormap (image, cmap, n_colors, FALSE); GIMP_LOG (XCF, ""prop colormap n_colors=%d"", n_colors); } break; case PROP_COMPRESSION: { guint8 compression; xcf_read_int8 (info, (guint8 *) &compression, 1); if ((compression != COMPRESS_NONE) && (compression != COMPRESS_RLE) && (compression != COMPRESS_ZLIB) && (compression != COMPRESS_FRACTAL)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_ERROR, ""Unknown compression type: %d"", (gint) compression); return FALSE; } info->compression = compression; gimp_image_set_xcf_compression (image, compression >= COMPRESS_ZLIB); GIMP_LOG (XCF, ""prop compression=%d"", compression); } break; case PROP_GUIDES: { GimpImagePrivate *private = GIMP_IMAGE_GET_PRIVATE (image); gint32            position; gint8             orientation; gint              i, nguides; nguides = prop_size / (4 + 1); for (i = 0; i < nguides; i++) { xcf_read_int32 (info, (guint32 *) &position,    1); xcf_read_int8  (info, (guint8 *)  &orientation, 1); if (info->file_version < 15 && position < 0) continue; GIMP_LOG (XCF, ""prop guide orientation=%d position=%d"", orientation, position); switch (orientation) { case XCF_ORIENTATION_HORIZONTAL: if (info->file_version < 15 && position > gimp_image_get_height (image)) gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Ignoring off-canvas horizontal guide (position %d) in XCF %d file"", position, info->file_version); else gimp_image_add_hguide (image, position, FALSE); break; case XCF_ORIENTATION_VERTICAL: if (info->file_version < 15 && position > gimp_image_get_width (image)) gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Ignoring off-canvas vertical guide (position %d) in XCF %d file"", position, info->file_version); else gimp_image_add_vguide (image, position, FALSE); break; default: gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Guide orientation out of range in XCF file""); continue; } } private->guides = g_list_reverse (private->guides); } break; case PROP_SAMPLE_POINTS: { gint n_sample_points, i; n_sample_points = prop_size / (5 * 4); for (i = 0; i < n_sample_points; i++) { GimpSamplePoint   *sample_point; gint32             x, y; GimpColorPickMode  pick_mode; guint32            padding[2] = { 0, }; xcf_read_int32 (info, (guint32 *) &x,         1); xcf_read_int32 (info, (guint32 *) &y,         1); xcf_read_int32 (info, (guint32 *) &pick_mode, 1); xcf_read_int32 (info, (guint32 *) padding,    2); GIMP_LOG (XCF, ""prop sample point x=%d y=%d mode=%d"", x, y, pick_mode); if (pick_mode > GIMP_COLOR_PICK_MODE_LAST) pick_mode = GIMP_COLOR_PICK_MODE_PIXEL; sample_point = gimp_image_add_sample_point_at_pos (image, x, y, FALSE); gimp_image_set_sample_point_pick_mode (image, sample_point, pick_mode, FALSE); } } break; case PROP_OLD_SAMPLE_POINTS: { gint32 x, y; gint   i, n_sample_points; if (gimp_image_get_sample_points (image)) { if (! xcf_skip_unknown_prop (info, prop_size)) return FALSE; break; } n_sample_points = prop_size / (4 + 4); for (i = 0; i < n_sample_points; i++) { xcf_read_int32 (info, (guint32 *) &x, 1); xcf_read_int32 (info, (guint32 *) &y, 1); GIMP_LOG (XCF, ""prop old sample point x=%d y=%d"", x, y); gimp_image_add_sample_point_at_pos (image, x, y, FALSE); } } break; case PROP_RESOLUTION: { gfloat xres, yres; xcf_read_float (info, &xres, 1); xcf_read_float (info, &yres, 1); GIMP_LOG (XCF, ""prop resolution x=%f y=%f"", xres, yres); if (xres < GIMP_MIN_RESOLUTION || xres > GIMP_MAX_RESOLUTION || yres < GIMP_MIN_RESOLUTION || yres > GIMP_MAX_RESOLUTION) { GimpTemplate *template = image->gimp->config->default_image; gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, resolution out of range in XCF file""); xres = gimp_template_get_resolution_x (template); yres = gimp_template_get_resolution_y (template); } gimp_image_set_resolution (image, xres, yres); } break; case PROP_TATTOO: { xcf_read_int32 (info, &info->tattoo_state, 1); GIMP_LOG (XCF, ""prop tattoo state=%d"", info->tattoo_state); } break; case PROP_PARASITES: { goffset base = info->cp; while (info->cp - base < prop_size) { GimpParasite *p     = xcf_load_parasite (info); GError       *error = NULL; if (! p) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Invalid image parasite found. "" ""Possibly corrupt XCF file.""); xcf_seek_pos (info, base + prop_size, NULL); continue; } if (! gimp_image_parasite_validate (image, p, &error)) { gimp_message (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, invalid image parasite in XCF file: %s"", error->message); g_clear_error (&error); } else { gimp_image_parasite_attach (image, p, FALSE); } gimp_parasite_free (p); } if (info->cp - base != prop_size) gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Error while loading an image's parasites""); } break; case PROP_UNIT: { guint32 unit; xcf_read_int32 (info, &unit, 1); GIMP_LOG (XCF, ""prop unit=%d"", unit); if ((unit <= GIMP_UNIT_PIXEL) || (unit >= gimp_unit_get_number_of_built_in_units ())) { gimp_message_literal (info->gimp, G_OBJECT (info->progress), GIMP_MESSAGE_WARNING, ""Warning, unit out of range in XCF file, "" ""falling back to inches""); unit = GIMP_UNIT_INCH; } gimp_image_set_unit (image, unit); } break; case PROP_PATHS: xcf_load_old_paths (info, image); break; case PROP_USER_UNIT: { gchar    *unit_strings[5]; float     factor; guint32   digits; GimpUnit  unit; gint      num_units; gint      i; xcf_read_float  (info, &factor,      1); xcf_read_int32  (info, &digits,      1); xcf_read_string (info, unit_strings, 5); for (i = 0; i < 5; i++) if (unit_strings[i] == NULL) unit_strings[i] = g_strdup (""""); num_units = gimp_unit_get_number_of_units (); for (unit = gimp_unit_get_number_of_built_in_units (); unit < num_units; unit++) { if ((ABS (gimp_unit_get_factor (unit) - factor) < 1e-5) && (strcmp (unit_strings[0], gimp_unit_get_identifier (unit)) == 0)) { break; } } if (unit == num_units) unit = gimp_unit_new (unit_strings[0], factor, digits, unit_strings[1], unit_strings[2], unit_strings[3], unit_strings[4]); gimp_image_set_unit (image, unit); for (i = 0; i < 5; i++) g_free (unit_strings[i]); } break; case PROP_VECTORS: { goffset base = info->cp; if (xcf_load_vectors (info, image)) { if (base + prop_size != info->cp) { g_printerr (""Mismatch in PROP_VECTORS size: "" ""skipping %"" G_GOFFSET_FORMAT "" bytes.\n"", base + prop_size - info->cp); xcf_seek_pos (info, base + prop_size, NULL); } } else { xcf_seek_pos (info, base + prop_size, NULL); } } break; case PROP_ITEM_SET: { GimpItemList *set       = NULL; gchar        *label; GType         item_type = 0; guint32       itype; guint32       method; xcf_read_int32  (info, &itype, 1); xcf_read_int32  (info, &method, 1); xcf_read_string (info, &label, 1); if (itype == 0) item_type = GIMP_TYPE_LAYER; else item_type = GIMP_TYPE_CHANNEL; if (itype > 1) { g_printerr (""xcf: unsupported item set '%s' type: %d (skipping)\n"", label ? label : ""unnamed"", itype); break; } else if (label == NULL) { g_printerr (""xcf: item set without a name or pattern (skipping)\n""); } else if (method != G_MAXUINT32 && method > GIMP_SELECT_GLOB_PATTERN) { g_printerr (""xcf: unsupported item set '%s' selection method attribute: 0x%x (skipping)\n"", label, method); } else { if (method == G_MAXUINT32) { set = g_object_new (GIMP_TYPE_ITEM_LIST, ""image"",      image, ""name"",       label, ""is-pattern"", FALSE, ""item-type"",  item_type, ""items"",      NULL, NULL); } else { set = gimp_item_list_pattern_new (image, item_type, method, label); } } if (item_type == GIMP_TYPE_LAYER) info->layer_sets = g_list_prepend (info->layer_sets, set); else info->channel_sets = g_list_prepend (info->channel_sets, set); } break; default: #ifdef GIMP_UNSTABLE g_printerr (""unexpected/unknown image property: %d (skipping)\n"", prop_type); #endif if (! xcf_skip_unknown_prop (info, prop_size)) return FALSE; break; } } return FALSE; }"
"struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices, u64 devid, u8 *uuid, u8 *fsid) { struct btrfs_device *device; while (fs_devices) { if (!fsid || !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) { device = find_device(fs_devices, devid, uuid); if (device) return device; } fs_devices = fs_devices->seed; } return NULL; }"
"int hvm_set_cr4(unsigned long value, bool_t may_defer) { struct vcpu *v = current; unsigned long old_cr; if ( value & ~hvm_cr4_guest_valid_bits(v, 0) ) { HVM_DBG_LOG(DBG_LEVEL_1, ""Guest attempts to set reserved bit in CR4: %lx"", value); return X86EMUL_EXCEPTION; } if ( !(value & X86_CR4_PAE) ) { if ( hvm_long_mode_active(v) ) { HVM_DBG_LOG(DBG_LEVEL_1, ""Guest cleared CR4.PAE while "" ""EFER.LMA is set""); return X86EMUL_EXCEPTION; } } old_cr = v->arch.hvm_vcpu.guest_cr[4]; if ( (value & X86_CR4_PCIDE) && !(old_cr & X86_CR4_PCIDE) && (!hvm_long_mode_active(v) || (v->arch.hvm_vcpu.guest_cr[3] & 0xfff)) ) { HVM_DBG_LOG(DBG_LEVEL_1, ""Guest attempts to change CR4.PCIDE from "" ""0 to 1 while either EFER.LMA=0 or CR3[11:0]!=000H""); return X86EMUL_EXCEPTION; } if ( may_defer && unlikely(v->domain->arch.monitor.write_ctrlreg_enabled & monitor_ctrlreg_bitmask(VM_EVENT_X86_CR4)) ) { ASSERT(v->arch.vm_event); if ( hvm_monitor_crX(CR4, value, old_cr) ) { v->arch.vm_event->write_data.do_write.cr4 = 1; v->arch.vm_event->write_data.cr4 = value; return X86EMUL_OKAY; } } hvm_update_cr(v, 4, value); if ( ((old_cr ^ value) & (X86_CR4_PSE | X86_CR4_PGE | X86_CR4_PAE | X86_CR4_SMEP)) || (!(value & X86_CR4_PCIDE) && (old_cr & X86_CR4_PCIDE)) ) { if ( !nestedhvm_vmswitch_in_progress(v) && nestedhvm_vcpu_in_guestmode(v) ) paging_update_nestedmode(v); else paging_update_paging_modes(v); } return X86EMUL_OKAY; }"
"static gboolean handle_spawn (PortalFlatpak         *object, GDBusMethodInvocation *invocation, GUnixFDList           *fd_list, const gchar           *arg_cwd_path, const gchar *const    *arg_argv, GVariant              *arg_fds, GVariant              *arg_envs, guint                  arg_flags, GVariant              *arg_options) { g_autoptr(GError) error = NULL; ChildSetupData child_setup_data = { NULL }; GPid pid; PidData *pid_data; InstanceIdReadData *instance_id_read_data = NULL; gsize i, j, n_fds, n_envs; const gint *fds = NULL; gint fds_len = 0; g_autofree FdMapEntry *fd_map = NULL; gchar **env; gint32 max_fd; GKeyFile *app_info; g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free); g_autofree char *app_id = NULL; g_autofree char *branch = NULL; g_autofree char *arch = NULL; g_autofree char *app_commit = NULL; g_autofree char *runtime_ref = NULL; g_auto(GStrv) runtime_parts = NULL; g_autofree char *runtime_commit = NULL; g_autofree char *instance_path = NULL; g_auto(GStrv) extra_args = NULL; g_auto(GStrv) shares = NULL; g_auto(GStrv) sockets = NULL; g_auto(GStrv) devices = NULL; g_auto(GStrv) sandbox_expose = NULL; g_auto(GStrv) sandbox_expose_ro = NULL; g_autoptr(GVariant) sandbox_expose_fd = NULL; g_autoptr(GVariant) sandbox_expose_fd_ro = NULL; g_autoptr(GOutputStream) instance_id_out_stream = NULL; guint sandbox_flags = 0; gboolean sandboxed; gboolean expose_pids; gboolean share_pids; gboolean notify_start; gboolean devel; g_autoptr(GString) env_string = g_string_new (""""); child_setup_data.instance_id_fd = -1; child_setup_data.env_fd = -1; if (fd_list != NULL) fds = g_unix_fd_list_peek_fds (fd_list, &fds_len); app_info = g_object_get_data (G_OBJECT (invocation), ""app-info""); g_assert (app_info != NULL); app_id = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_APPLICATION, FLATPAK_METADATA_KEY_NAME, NULL); g_assert (app_id != NULL); g_debug (""spawn() called from app: '%s'"", app_id); if (*app_id == 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""org.freedesktop.portal.Flatpak.Spawn only works in a flatpak""); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (*arg_cwd_path == 0) arg_cwd_path = NULL; if (arg_argv == NULL || *arg_argv == NULL) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No command given""); return G_DBUS_METHOD_INVOCATION_HANDLED; } if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Unsupported flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL); return G_DBUS_METHOD_INVOCATION_HANDLED; } runtime_ref = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_APPLICATION, FLATPAK_METADATA_KEY_RUNTIME, NULL); if (runtime_ref == NULL) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No runtime found""); return G_DBUS_METHOD_INVOCATION_HANDLED; } runtime_parts = g_strsplit (runtime_ref, ""/"", -1); branch = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_BRANCH, NULL); instance_path = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL); arch = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_ARCH, NULL); extra_args = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL); app_commit = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_APP_COMMIT, NULL); runtime_commit = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL); shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL, NULL); sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL); devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL, NULL); devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_DEVEL, NULL); g_variant_lookup (arg_options, ""sandbox-expose"", ""^as"", &sandbox_expose); g_variant_lookup (arg_options, ""sandbox-expose-ro"", ""^as"", &sandbox_expose_ro); g_variant_lookup (arg_options, ""sandbox-flags"", ""u"", &sandbox_flags); sandbox_expose_fd = g_variant_lookup_value (arg_options, ""sandbox-expose-fd"", G_VARIANT_TYPE (""ah"")); sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, ""sandbox-expose-fd-ro"", G_VARIANT_TYPE (""ah"")); if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Unsupported sandbox flags enabled: 0x%x"", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (instance_path == NULL && ((sandbox_expose != NULL && sandbox_expose[0] != NULL) || (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL))) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Invalid sandbox expose, caller has no instance path""); return G_DBUS_METHOD_INVOCATION_HANDLED; } for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++) { const char *expose = sandbox_expose[i]; g_debug (""exposing %s"", expose); if (!is_valid_expose (expose, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } } for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) { const char *expose = sandbox_expose_ro[i]; g_debug (""exposing %s"", expose); if (!is_valid_expose (expose, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } } g_debug (""Running spawn command %s"", arg_argv[0]); n_fds = 0; if (fds != NULL) n_fds = g_variant_n_children (arg_fds); fd_map = g_new0 (FdMapEntry, n_fds); child_setup_data.fd_map = fd_map; child_setup_data.fd_map_len = n_fds; max_fd = -1; for (i = 0; i < n_fds; i++) { gint32 handle, dest_fd; int handle_fd; g_variant_get_child (arg_fds, i, ""{uh}"", &dest_fd, &handle); if (handle >= fds_len || handle < 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } handle_fd = fds[handle]; fd_map[i].to = dest_fd; fd_map[i].from = handle_fd; fd_map[i].final = fd_map[i].to; if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) && !child_setup_data.set_tty && isatty (handle_fd)) { child_setup_data.set_tty = TRUE; child_setup_data.tty = handle_fd; } max_fd = MAX (max_fd, fd_map[i].to); max_fd = MAX (max_fd, fd_map[i].from); } for (i = 0; i < n_fds; i++) { int to_fd = fd_map[i].to; gboolean conflict = FALSE; for (j = i + 1; j < n_fds; j++) { int from_fd = fd_map[j].from; if (from_fd == to_fd) { conflict = TRUE; break; } } if (conflict) fd_map[i].to = ++max_fd; } if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV) { char *empty[] = { NULL }; env = g_strdupv (empty); } else env = g_get_environ (); n_envs = g_variant_n_children (arg_envs); for (i = 0; i < n_envs; i++) { const char *var = NULL; const char *val = NULL; g_variant_get_child (arg_envs, i, ""{&s&s}"", &var, &val); env = g_environ_setenv (env, var, val, TRUE); } g_ptr_array_add (flatpak_argv, g_strdup (""flatpak"")); g_ptr_array_add (flatpak_argv, g_strdup (""run"")); sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0; if (sandboxed) { g_ptr_array_add (flatpak_argv, g_strdup (""--sandbox"")); if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY) { if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""wayland"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=wayland"")); if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""fallback-x11"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=fallback-x11"")); if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""x11"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=x11"")); if (shares != NULL && g_strv_contains ((const char * const *) shares, ""ipc"") && sockets != NULL && (g_strv_contains ((const char * const *) sockets, ""fallback-x11"") || g_strv_contains ((const char * const *) sockets, ""x11""))) g_ptr_array_add (flatpak_argv, g_strdup (""--share=ipc"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND) { if (sockets != NULL && g_strv_contains ((const char * const *) sockets, ""pulseaudio"")) g_ptr_array_add (flatpak_argv, g_strdup (""--socket=pulseaudio"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU) { if (devices != NULL && (g_strv_contains ((const char * const *) devices, ""dri"") || g_strv_contains ((const char * const *) devices, ""all""))) g_ptr_array_add (flatpak_argv, g_strdup (""--device=dri"")); } if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS) g_ptr_array_add (flatpak_argv, g_strdup (""--session-bus"")); if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y) g_ptr_array_add (flatpak_argv, g_strdup (""--a11y-bus"")); } else { for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++) { if (g_str_has_prefix (extra_args[i], ""--env="")) { const char *var_val = extra_args[i] + strlen (""--env=""); if (var_val[0] == '\0' || var_val[0] == '=') { g_warning (""Environment variable in extra-args has empty name""); continue; } if (strchr (var_val, '=') == NULL) { g_warning (""Environment variable in extra-args has no value""); continue; } g_string_append (env_string, var_val); g_string_append_c (env_string, '\0'); } else { g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i])); } } } if (env_string->len > 0) { g_auto(GLnxTmpfile) env_tmpf  = { 0, }; if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, ""environ"", env_string->str, env_string->len, &error)) { g_dbus_method_invocation_return_gerror (invocation, error); return G_DBUS_METHOD_INVOCATION_HANDLED; } child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--env-fd=%d"", child_setup_data.env_fd)); } expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0; share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0; if (expose_pids || share_pids) { g_autofree char *instance_id = NULL; int sender_pid1 = 0; if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS)) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_NOT_SUPPORTED, ""Expose pids not supported with setuid bwrap""); return G_DBUS_METHOD_INVOCATION_HANDLED; } instance_id = g_key_file_get_string (app_info, FLATPAK_METADATA_GROUP_INSTANCE, FLATPAK_METADATA_KEY_INSTANCE_ID, NULL); if (instance_id) { g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id); sender_pid1 = flatpak_instance_get_child_pid (instance); } if (sender_pid1 == 0) { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""Could not find requesting pid""); return G_DBUS_METHOD_INVOCATION_HANDLED; } g_ptr_array_add (flatpak_argv, g_strdup_printf (""--parent-pid=%d"", sender_pid1)); if (share_pids) g_ptr_array_add (flatpak_argv, g_strdup (""--parent-share-pids"")); else g_ptr_array_add (flatpak_argv, g_strdup (""--parent-expose-pids"")); } notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0; if (notify_start) { int pipe_fds[2]; if (pipe (pipe_fds) == -1) { int errsv = errno; g_dbus_method_invocation_return_error (invocation, G_IO_ERROR, g_io_error_from_errno (errsv), ""Failed to create instance ID pipe: %s"", g_strerror (errsv)); return G_DBUS_METHOD_INVOCATION_HANDLED; } GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE)); instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE)); instance_id_read_data = g_new0 (InstanceIdReadData, 1); g_input_stream_read_async (in_stream, instance_id_read_data->buffer, INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL, instance_id_read_finish, instance_id_read_data); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--instance-id-fd=%d"", pipe_fds[1])); child_setup_data.instance_id_fd = pipe_fds[1]; } if (devel) g_ptr_array_add (flatpak_argv, g_strdup (""--devel"")); if (shares != NULL && g_strv_contains ((const char * const *) shares, ""network"") && !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK)) g_ptr_array_add (flatpak_argv, g_strdup (""--share=network"")); else g_ptr_array_add (flatpak_argv, g_strdup (""--unshare=network"")); if (instance_path) { for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++) g_ptr_array_add (flatpak_argv, filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE)); for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) g_ptr_array_add (flatpak_argv, filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE)); } for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++) { const char *expose = sandbox_expose_ro[i]; g_debug (""exposing %s"", expose); } if (sandbox_expose_fd != NULL) { gsize len = g_variant_n_children (sandbox_expose_fd); for (i = 0; i < len; i++) { gint32 handle; g_variant_get_child (sandbox_expose_fd, i, ""h"", &handle); if (handle >= 0 && handle < fds_len) { int handle_fd = fds[handle]; g_autofree char *path = NULL; gboolean writable = FALSE; path = get_path_for_fd (handle_fd, &writable, &error); if (path) { g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable)); } else { g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"", handle_fd, error->message); g_clear_error (&error); } } else { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } } } if (sandbox_expose_fd_ro != NULL) { gsize len = g_variant_n_children (sandbox_expose_fd_ro); for (i = 0; i < len; i++) { gint32 handle; g_variant_get_child (sandbox_expose_fd_ro, i, ""h"", &handle); if (handle >= 0 && handle < fds_len) { int handle_fd = fds[handle]; g_autofree char *path = NULL; gboolean writable = FALSE; path = get_path_for_fd (handle_fd, &writable, &error); if (path) { g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE)); } else { g_debug (""unable to get path for sandbox-exposed fd %d, ignoring: %s"", handle_fd, error->message); g_clear_error (&error); } } else { g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, ""No file descriptor for handle %d"", handle); return G_DBUS_METHOD_INVOCATION_HANDLED; } } } g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime=%s"", runtime_parts[1])); g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-version=%s"", runtime_parts[3])); if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0) { if (app_commit) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--commit=%s"", app_commit)); if (runtime_commit) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--runtime-commit=%s"", runtime_commit)); } if (arg_cwd_path != NULL) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--cwd=%s"", arg_cwd_path)); if (arg_argv[0][0] != 0) g_ptr_array_add (flatpak_argv, g_strdup_printf (""--command=%s"", arg_argv[0])); g_ptr_array_add (flatpak_argv, g_strdup_printf (""%s/%s/%s"", app_id, arch ? arch : """", branch ? branch : """")); for (i = 1; arg_argv[i] != NULL; i++) g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i])); g_ptr_array_add (flatpak_argv, NULL); if (opt_verbose) { g_autoptr(GString) cmd = g_string_new (""""); for (i = 0; flatpak_argv->pdata[i] != NULL; i++) { if (i > 0) g_string_append (cmd, "" ""); g_string_append (cmd, flatpak_argv->pdata[i]); } g_debug (""Starting: %s\n"", cmd->str); } if (!g_spawn_async_with_pipes (NULL, (char **) flatpak_argv->pdata, env, G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN, child_setup_func, &child_setup_data, &pid, NULL, NULL, NULL, &error)) { gint code = G_DBUS_ERROR_FAILED; if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES)) code = G_DBUS_ERROR_ACCESS_DENIED; else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT)) code = G_DBUS_ERROR_FILE_NOT_FOUND; g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code, ""Failed to start command: %s"", error->message); return G_DBUS_METHOD_INVOCATION_HANDLED; } if (instance_id_read_data) instance_id_read_data->pid = pid; pid_data = g_new0 (PidData, 1); pid_data->pid = pid; pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation)); pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0; pid_data->expose_or_share_pids = (expose_pids || share_pids); pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, child_watch_died, pid_data, NULL); g_debug (""Client Pid is %d"", pid_data->pid); g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid), pid_data); portal_flatpak_complete_spawn (object, invocation, NULL, pid); return G_DBUS_METHOD_INVOCATION_HANDLED; }"
"static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul) { double mul2 = mul * mul, mul3 = mul2 * mul; double kernel[] = { (5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096, (2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096, ( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096, (  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096, }; double mat_freq[13]; memcpy(mat_freq, kernel, sizeof(kernel)); memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel)); int n = 6; coeff_filter(mat_freq, n, kernel); for (int k = 0; k < 2 * prefilter; ++k) coeff_blur121(mat_freq, ++n); double vec_freq[13]; n = index[3] + prefilter + 3; calc_gauss(vec_freq, n, r2); memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0])); n -= 3; coeff_filter(vec_freq, n, kernel); for (int k = 0; k < prefilter; ++k) coeff_blur121(vec_freq, --n); double mat[4][4]; calc_matrix(mat, mat_freq, index); double vec[4]; for (int i = 0; i < 4; ++i) vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]]; for (int i = 0; i < 4; ++i) { double res = 0; for (int j = 0; j < 4; ++j) res += mat[i][j] * vec[j]; mu[i] = FFMAX(0, res); } }"
"static int spl2sw_nvmem_get_mac_address(struct device *dev, struct device_node *np, void *addrbuf) { struct nvmem_cell *cell; ssize_t len; u8 *mac; cell = of_nvmem_cell_get(np, ""mac-address""); if (IS_ERR(cell)) return PTR_ERR(cell); mac = nvmem_cell_read(cell, &len); nvmem_cell_put(cell); if (IS_ERR(mac)) return PTR_ERR(mac); if (len != ETH_ALEN) { kfree(mac); dev_info(dev, ""Invalid length of mac address in nvmem!\n""); return -EINVAL; } spl2sw_check_mac_vendor_id_and_convert(mac); if (!is_valid_ether_addr(mac)) { kfree(mac); dev_info(dev, ""Invalid mac address in nvmem (%pM)!\n"", mac); return -EINVAL; } ether_addr_copy(addrbuf, mac); kfree(mac); return 0; }"
static inline size_t parse_uiv(const unsigned char *p) { unsigned char cursor; size_t result = 0; if (*p == '+') { p++; } while (1) { cursor = *p; if (cursor >= '0' && cursor <= '9') { result = result * 10 + (size_t)(cursor - (unsigned char)'0'); } else { break; } p++; } return result; }
static void nodeDestruct(struct SaveNode* node) { if (node->v == &node->sorted) { tr_free(node->sorted.val.l.vals); } }
"bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) { uint32_t width = outputBufferWidth(); uint32_t height = outputBufferHeight(); uint64_t nFilledLen = width; nFilledLen *= height; if (nFilledLen > UINT32_MAX / 3) { ALOGE(""b/29421675, nFilledLen overflow %llu w %u h %u"", nFilledLen, width, height); android_errorWriteLog(0x534e4554, ""29421675""); return false; } else if (outHeader->nAllocLen < outHeader->nFilledLen) { ALOGE(""b/27597103, buffer too small""); android_errorWriteLog(0x534e4554, ""27597103""); return false; } return true; }"
"void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override { const Tensor* indices; OP_REQUIRES_OK(ctx, ctx->input(""indices"", &indices)); const Tensor* values; OP_REQUIRES_OK(ctx, ctx->input(""values"", &values)); const Tensor* dense_shape; OP_REQUIRES_OK(ctx, ctx->input(""dense_shape"", &dense_shape)); OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()), errors::InvalidArgument( ""Input indices should be a matrix but received shape "", indices->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()), errors::InvalidArgument( ""Input values should be a vector but received shape "", indices->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()), errors::InvalidArgument( ""Input shape should be a vector but received shape "", dense_shape->shape().DebugString())); int64_t previous_batch_index = -1; for (int64_t i = 0; i < indices->dim_size(0); ++i) { int64_t next_batch_index = indices->matrix<int64>()(i, 0); OP_REQUIRES( ctx, next_batch_index >= previous_batch_index, errors::Unimplemented(""The SparseTensor must be ordered in the batch "" ""dimension; handling arbitrarily ordered input "" ""is not currently supported."")); previous_batch_index = next_batch_index; } gtl::InlinedVector<int64, 8> std_order(dense_shape->NumElements(), 0); sparse::SparseTensor tensor; OP_REQUIRES_OK( ctx, sparse::SparseTensor::Create( *indices, *values, TensorShape(dense_shape->vec<int64>()), std_order, &tensor)); *output = new Dataset<T>(ctx, std::move(tensor)); }"
"static int rm_read_multi(AVFormatContext *s, AVIOContext *pb, AVStream *st, char *mime) { int number_of_streams = avio_rb16(pb); int number_of_mdpr; int i, ret; unsigned size2; for (i = 0; i<number_of_streams; i++) avio_rb16(pb); number_of_mdpr = avio_rb16(pb); if (number_of_mdpr != 1) { avpriv_request_sample(s, ""MLTI with multiple (%d) MDPR"", number_of_mdpr); } for (i = 0; i < number_of_mdpr; i++) { AVStream *st2; if (i > 0) { st2 = avformat_new_stream(s, NULL); if (!st2) { ret = AVERROR(ENOMEM); return ret; } st2->id = st->id + (i<<16); st2->codecpar->bit_rate = st->codecpar->bit_rate; st2->start_time = st->start_time; st2->duration   = st->duration; st2->codecpar->codec_type = AVMEDIA_TYPE_DATA; st2->priv_data = ff_rm_alloc_rmstream(); if (!st2->priv_data) return AVERROR(ENOMEM); } else st2 = st; size2 = avio_rb32(pb); ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data, size2, mime); if (ret < 0) return ret; } return 0; }"
"Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) { DCHECK_EQ(t.args_size(), 3); const auto& cont = t.args(0); const auto& tmpl = t.args(1); const auto& t_var = t.args(2); StringPiece var_name = t_var.s(); if (!attrs.contains(var_name)) { return Status( error::INVALID_ARGUMENT, absl::StrCat(""could not find an attribute for key '"", var_name, ""'"")); } const AttrValue* attr = attrs.at(var_name); FullTypeDef result; result.set_type_id(cont.type_id()); const auto attr_type = attr->value_case(); if (attr_type == AttrValue::kType) { FullTypeDef* target = result.add_args(); *target = tmpl; TF_RETURN_WITH_CONTEXT_IF_ERROR( SubstituteFromAttrs(attrs, *target), ""while substituting '"", var_name, ""' from\n"", attr->DebugString(), ""\ninto "", target->DebugString()); } else if (attr_type == AttrValue::kList) { const auto& attr_list = attr->list(); int tsize = attr_list.type_size(); if (tsize == 0) { return Status(error::UNIMPLEMENTED, absl::StrCat(""unsupported list attribute type\n"", attr_list.DebugString(), ""\nkey="", var_name)); } AttrValue replacement; attrs[var_name] = &replacement; for (int i = 0; i < tsize; i++) { replacement.set_type(attr_list.type(i)); FullTypeDef* target = result.add_args(); *target = tmpl; TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target), ""while substituting '"", var_name, ""' from\n"", attr->DebugString(), ""\n["", i, ""] into\n"", target->DebugString()); } attrs[var_name] = attr; } else { return Status(error::UNIMPLEMENTED, absl::StrCat(""unsupported attribute type\n"", attr->DebugString(), ""\nfor name "", var_name)); } t = result; return OkStatus(); }"
"static void mcba_usb_disconnect(struct usb_interface *intf) { struct mcba_priv *priv = usb_get_intfdata(intf); usb_set_intfdata(intf, NULL); netdev_info(priv->netdev, ""device disconnected\n""); unregister_candev(priv->netdev); free_candev(priv->netdev); mcba_urb_unlink(priv); }"
"int db_update(char* name, char* value) { char* sql; int r = 0; if (crypt_key) { value = note_encrypt(value,crypt_key); r = asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'"", value, name); free(value); if (r < 0) return 1; }else{ if (asprintf(&sql, ""UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'"", value, name) < 0) return 1; } r = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg); free(sql); return r; }"
"static libspdm_return_t libspdm_handle_response_not_ready(libspdm_context_t *spdm_context, const uint32_t *session_id, size_t *response_size, void **response, uint8_t original_request_code, uint8_t expected_response_code) { spdm_error_response_t *spdm_response; spdm_error_data_response_not_ready_t *extend_error_data; if(*response_size < sizeof(spdm_error_response_t) + sizeof(spdm_error_data_response_not_ready_t)) { return LIBSPDM_STATUS_INVALID_MSG_SIZE; } spdm_response = *response; extend_error_data = (spdm_error_data_response_not_ready_t *)(spdm_response + 1); LIBSPDM_ASSERT(spdm_response->header.request_response_code == SPDM_ERROR); LIBSPDM_ASSERT(spdm_response->header.param1 == SPDM_ERROR_CODE_RESPONSE_NOT_READY); if (extend_error_data->request_code != original_request_code) { return LIBSPDM_STATUS_INVALID_MSG_FIELD; } if (extend_error_data->rd_tm <= 1) { return LIBSPDM_STATUS_INVALID_MSG_FIELD; } spdm_context->error_data.rd_exponent = extend_error_data->rd_exponent; spdm_context->error_data.request_code = extend_error_data->request_code; spdm_context->error_data.token = extend_error_data->token; spdm_context->error_data.rd_tm = extend_error_data->rd_tm; libspdm_sleep((2 << extend_error_data->rd_exponent)); return libspdm_requester_respond_if_ready(spdm_context, session_id, response_size, response, expected_response_code); }"
static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id) { unsigned long h; const unsigned char *p; h = id->iface; h = MULTIPLIER * h + id->device; h = MULTIPLIER * h + id->subdevice; for (p = id->name; *p; p++) h = MULTIPLIER * h + *p; h = MULTIPLIER * h + id->index; h &= LONG_MAX; return h; }
"static void g_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class) { GObjectClass *object_class = G_OBJECT_CLASS (class); object_class->finalize = g_keyfile_settings_backend_finalize; object_class->constructed = g_keyfile_settings_backend_constructed; object_class->get_property = g_keyfile_settings_backend_get_property; object_class->set_property = g_keyfile_settings_backend_set_property; class->read = g_keyfile_settings_backend_read; class->write = g_keyfile_settings_backend_write; class->write_tree = g_keyfile_settings_backend_write_tree; class->reset = g_keyfile_settings_backend_reset; class->get_writable = g_keyfile_settings_backend_get_writable; class->get_permission = g_keyfile_settings_backend_get_permission; g_object_class_install_property (object_class, PROP_FILENAME, g_param_spec_string (""filename"", P_(""Filename""), P_(""The filename""), NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS)); g_object_class_install_property (object_class, PROP_ROOT_PATH, g_param_spec_string (""root-path"", P_(""Root path""), P_(""The root path""), NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS)); g_object_class_install_property (object_class, PROP_ROOT_GROUP, g_param_spec_string (""root-group"", P_(""Root group""), P_(""The root group""), NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS)); }"
"static krb5_error_code enctype_name(krb5_enctype ktype, char *buf, size_t buflen) { char *name; size_t len; if (buflen == 0) return EINVAL; *buf = '\0';  if (krb5int_c_deprecated_enctype(ktype)) { len = strlcpy(buf, ""DEPRECATED:"", buflen); if (len >= buflen) return ENOMEM; buflen -= len; buf += len; } if (ktype == ENCTYPE_DSA_SHA1_CMS) name = ""id-dsa-with-sha1-CmsOID""; else if (ktype == ENCTYPE_MD5_RSA_CMS) name = ""md5WithRSAEncryption-CmsOID""; else if (ktype == ENCTYPE_SHA1_RSA_CMS) name = ""sha-1WithRSAEncryption-CmsOID""; else if (ktype == ENCTYPE_RC2_CBC_ENV) name = ""rc2-cbc-EnvOID""; else if (ktype == ENCTYPE_RSA_ENV) name = ""rsaEncryption-EnvOID""; else if (ktype == ENCTYPE_RSA_ES_OAEP_ENV) name = ""id-RSAES-OAEP-EnvOID""; else if (ktype == ENCTYPE_DES3_CBC_ENV) name = ""des-ede3-cbc-EnvOID""; else return krb5_enctype_to_name(ktype, FALSE, buf, buflen); if (strlcpy(name, buf, buflen) >= buflen) return ENOMEM; return 0; }"
"void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) { COMPS_HSList *tmplist, *tmp_subnodes; COMPS_HSListItem *it; struct Pair { COMPS_HSList * subnodes; char * key; char added; } *pair, *parent_pair; pair = malloc(sizeof(struct Pair)); pair->subnodes = rt2->subnodes; pair->key = NULL; tmplist = comps_hslist_create(); comps_hslist_init(tmplist, NULL, NULL, &free); comps_hslist_append(tmplist, pair, 0); while (tmplist->first != NULL) { it = tmplist->first; comps_hslist_remove(tmplist, tmplist->first); tmp_subnodes = ((struct Pair*)it->data)->subnodes; parent_pair = (struct Pair*) it->data; free(it); for (it = tmp_subnodes->first; it != NULL; it=it->next) { pair = malloc(sizeof(struct Pair)); pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes; if (parent_pair->key != NULL) { pair->key = malloc(sizeof(char) * (strlen(((COMPS_ObjRTreeData*)it->data)->key) + strlen(parent_pair->key) + 1)); memcpy(pair->key, parent_pair->key, sizeof(char) * strlen(parent_pair->key)); memcpy(pair->key + strlen(parent_pair->key), ((COMPS_ObjRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1)); } else { pair->key = malloc(sizeof(char)* (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1)); memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1)); } if (((COMPS_ObjRTreeData*)it->data)->data != NULL) { comps_objrtree_set(rt1, pair->key, (((COMPS_ObjRTreeData*)it->data)->data)); } if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) { comps_hslist_append(tmplist, pair, 0); } else { free(pair->key); free(pair); } } free(parent_pair->key); free(parent_pair); } comps_hslist_destroy(&tmplist); }"
"int TNEFFillMapi(TNEFStruct *TNEF, BYTE *data, DWORD size, MAPIProps *p) { int i, j; DWORD num; BYTE *d; MAPIProperty *mp; DWORD type; DWORD length; variableLength *vl; WORD temp_word; DWORD temp_dword; DDWORD temp_ddword; int count = -1; int offset; d = data; p->count = SwapDWord((BYTE*)data, 4); d += 4; p->properties = calloc(p->count, sizeof(MAPIProperty)); ALLOCCHECK(p->properties); mp = p->properties; for (i = 0; i < p->count; i++) { if (count == -1) { mp->id = SwapDWord((BYTE*)d, 4); d += 4; mp->custom = 0; mp->count = 1; mp->namedproperty = 0; length = -1; if (PROP_ID(mp->id) >= 0x8000) { SIZECHECK(16); memcpy(&(mp->guid[0]), d, 16); d += 16; SIZECHECK(4); length = SwapDWord((BYTE*)d, 4); d += sizeof(DWORD); if (length > 0) { mp->namedproperty = length; mp->propnames = calloc(length, sizeof(variableLength)); ALLOCCHECK(mp->propnames); while (length > 0) { SIZECHECK(4); type = SwapDWord((BYTE*)d, 4); mp->propnames[length - 1].data = calloc(type, sizeof(BYTE)); ALLOCCHECK(mp->propnames[length - 1].data); mp->propnames[length - 1].size = type; d += 4; SIZECHECK(type); for (j = 0; j < (type >> 1); j++) { mp->propnames[length - 1].data[j] = d[j * 2]; } d += type + ((type % 4) ? (4 - type % 4) : 0); length--; } } else { SIZECHECK(sizeof(DWORD)); type = SwapDWord((BYTE*)d, sizeof(DWORD)); d += sizeof(DWORD); mp->id = PROP_TAG(PROP_TYPE(mp->id), type); } mp->custom = 1; } DEBUG2(TNEF->Debug, 3, ""Type id = %04x, Prop id = %04x"", PROP_TYPE(mp->id), PROP_ID(mp->id)); if (PROP_TYPE(mp->id) & MV_FLAG) { mp->id = PROP_TAG(PROP_TYPE(mp->id) - MV_FLAG, PROP_ID(mp->id)); SIZECHECK(4); mp->count = SwapDWord((BYTE*)d, 4); d += 4; count = 0; } mp->data = calloc(mp->count, sizeof(variableLength)); ALLOCCHECK(mp->data); vl = mp->data; } else { i--; count++; vl = &(mp->data[count]); } switch (PROP_TYPE(mp->id)) { case PT_BINARY: case PT_OBJECT: case PT_STRING8: case PT_UNICODE: if (count == -1) { SIZECHECK(4); vl->size = SwapDWord((BYTE*)d, 4); d += 4; } SIZECHECK(4); vl->size = SwapDWord((BYTE*)d, 4); d += 4; if (vl->size != 0) {     SIZECHECK(vl->size); if (PROP_TYPE(mp->id) == PT_UNICODE) { vl->data =(BYTE*) to_utf8(vl->size, (char*)d); } else { vl->data = calloc(vl->size, sizeof(BYTE)); ALLOCCHECK(vl->data); memcpy(vl->data, d, vl->size); } } else { vl->data = NULL; } num = vl->size; offset = ((num % 4) ? (4 - num % 4) : 0); d += num + ((num % 4) ? (4 - num % 4) : 0); break; case PT_I2: vl->size = 2; vl->data = calloc(vl->size, sizeof(WORD)); ALLOCCHECK(vl->data); SIZECHECK(sizeof(WORD)) temp_word = SwapWord((BYTE*)d, sizeof(WORD)); memcpy(vl->data, &temp_word, vl->size); d += 4; break; case PT_BOOLEAN: case PT_LONG: case PT_R4: case PT_CURRENCY: case PT_APPTIME: case PT_ERROR: vl->size = 4; vl->data = calloc(vl->size, sizeof(BYTE)); ALLOCCHECK(vl->data); SIZECHECK(4); temp_dword = SwapDWord((BYTE*)d, 4); memcpy(vl->data, &temp_dword, vl->size); d += 4; break; case PT_DOUBLE: case PT_I8: case PT_SYSTIME: vl->size = 8; vl->data = calloc(vl->size, sizeof(BYTE)); ALLOCCHECK(vl->data); SIZECHECK(8); temp_ddword = SwapDDWord(d, 8); memcpy(vl->data, &temp_ddword, vl->size); d += 8; break; case PT_CLSID: vl->size = 16; vl->data = calloc(vl->size, sizeof(BYTE)); ALLOCCHECK(vl->data); SIZECHECK(vl->size); memcpy(vl->data, d, vl->size); d+=16; break; default: printf(""Bad file\n""); exit(-1); } switch (PROP_ID(mp->id)) { case PR_SUBJECT: case PR_SUBJECT_IPM: case PR_ORIGINAL_SUBJECT: case PR_NORMALIZED_SUBJECT: case PR_CONVERSATION_TOPIC: DEBUG(TNEF->Debug, 3, ""Got a Subject""); if (TNEF->subject.size == 0) { int i; DEBUG(TNEF->Debug, 3, ""Assigning a Subject""); TNEF->subject.data = calloc(size, sizeof(BYTE)); ALLOCCHECK(TNEF->subject.data); TNEF->subject.size = vl->size; memcpy(TNEF->subject.data, vl->data, vl->size); for (i = 0; i != TNEF->subject.size; i++) { switch (TNEF->subject.data[i]) { case '\\': case '/': case '\0': TNEF->subject.data[i] = '_'; break; } } } break; } if (count == (mp->count - 1)) { count = -1; } if (count == -1) { mp++; } } if ((d - data) < size) { if (TNEF->Debug >= 1)  { printf(""ERROR DURING MAPI READ\n""); printf(""Read %td bytes, Expected %u bytes\n"", (d - data), size); printf(""%td bytes missing\n"", size - (d - data)); } } else if ((d - data) > size) { if (TNEF->Debug >= 1)  { printf(""ERROR DURING MAPI READ\n""); printf(""Read %td bytes, Expected %u bytes\n"", (d - data), size); printf(""%li bytes extra\n"", (d - data) - size); } } return 0; }"
"static int mj_raster_cmd(int c_id, int in_size, byte* in, byte* buf2, gx_device_printer* pdev, gp_file* prn_stream) { int band_size = 1; byte *out = buf2; int width = in_size; int count; byte* in_end = in + in_size; static char colour_number[] = ""\004\001\002\000"";  byte *inp = in; byte *outp = out; register byte *p, *q; gp_fputs(""\033r"",prn_stream);  gp_fputc(colour_number[c_id], prn_stream); for( p = inp, q = inp + 1 ; q < in_end ; ) { if( *p != *q ) { p += 2; q += 2; } else { if( p > inp && *p == *(p-1) ) p--; for( q++ ; *q == *p && q < in_end ; q++ ) { if( (q-p) >= 128 ) { if( p > inp ) { count = p - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1);  memcpy(outp, inp, count); outp += count; } *outp++ = '\201'; *outp++ = *p; p += 128; inp = p; } } if( (q - p) > 2 ) { if( p > inp ) { count = p - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1); memcpy(outp, inp, count); outp += count; } count = q - p; *outp++ = (char) (256 - count + 1); *outp++ = *p; p += count; inp = p; } else p = q; if( q < in_end ) q++; } } if( inp < in_end ) { count = in_end - inp; while( count > 128 ) { *outp++ = '\177'; memcpy(outp, inp, 128); inp += 128; outp += 128; count -= 128; } *outp++ = (char) (count - 1); memcpy(outp, inp, count); outp += count; } gp_fwrite(""\033.\001"", 1, 3, prn_stream); if(pdev->y_pixels_per_inch == 720) gp_fputc('\005', prn_stream); else if(pdev->y_pixels_per_inch == 180) gp_fputc('\024', prn_stream); else  gp_fputc('\012', prn_stream); if(pdev->x_pixels_per_inch == 720) gp_fputc('\005', prn_stream); else if(pdev->x_pixels_per_inch == 180) gp_fputc('\024', prn_stream); else  gp_fputc('\012', prn_stream); gp_fputc(band_size, prn_stream); gp_fputc((width << 3) & 0xff, prn_stream); gp_fputc( width >> 5,   prn_stream); gp_fwrite(out, 1, (outp - out), prn_stream); gp_fputc('\r', prn_stream); return 0; }"
"static void fill_kobj_path(const struct kobject *kobj, char *path, int length) { const struct kobject *parent; --length; for (parent = kobj; parent; parent = parent->parent) { int cur = strlen(kobject_name(parent)); length -= cur; memcpy(path + length, kobject_name(parent), cur); *(path + --length) = '/'; } pr_debug(""kobject: '%s' (%p): %s: path = '%s'\n"", kobject_name(kobj), kobj, __func__, path); }"
"static void dex_parse_debug_item(RBinFile *binfile, RBinDexObj *bin, RBinDexClass *c, int MI, int MA, int paddr, int ins_size, int insns_size, char *class_name, int regsz, int debug_info_off) { struct r_bin_t *rbin = binfile->rbin; const ut8 *p4 = r_buf_get_at (binfile->buf, debug_info_off, NULL); const ut8 *p4_end = p4 + binfile->buf->length - debug_info_off; ut64 line_start; ut64 parameters_size; ut64 param_type_idx; ut16 argReg = regsz - ins_size; ut64 source_file_idx = c->source_file; RList *params, *debug_positions, *emitted_debug_locals = NULL;  bool keep = true; if (argReg >= regsz) { } p4 = r_uleb128 (p4, p4_end - p4, &line_start); p4 = r_uleb128 (p4, p4_end - p4, &parameters_size); ut32 address = 0; ut32 line = line_start; if (!(debug_positions = r_list_newf ((RListFree)free))) { return; } if (!(emitted_debug_locals = r_list_newf ((RListFree)free))) { r_list_free (debug_positions); return; } struct dex_debug_local_t debug_locals[regsz]; memset (debug_locals, 0, sizeof (struct dex_debug_local_t) * regsz); if (!(MA & 0x0008)) { debug_locals[argReg].name = ""this""; debug_locals[argReg].descriptor = r_str_newf(""%s;"", class_name); debug_locals[argReg].startAddress = 0; debug_locals[argReg].signature = NULL; debug_locals[argReg].live = true; argReg++; } if (!(params = dex_method_signature2 (bin, MI))) { r_list_free (debug_positions); r_list_free (emitted_debug_locals); return; } RListIter *iter = r_list_iterator (params); char *name; char *type; int reg; r_list_foreach (params, iter, type) { if ((argReg >= regsz) || !type || parameters_size <= 0) { r_list_free (debug_positions); r_list_free (params); r_list_free (emitted_debug_locals); return; } p4 = r_uleb128 (p4, p4_end - p4, &param_type_idx); param_type_idx -= 1; name = getstr (bin, param_type_idx); reg = argReg; switch (type[0]) { case 'D': case 'J': argReg += 2; break; default: argReg += 1; break; } if (name) { debug_locals[reg].name = name; debug_locals[reg].descriptor = type; debug_locals[reg].signature = NULL; debug_locals[reg].startAddress = address; debug_locals[reg].live = true; } --parameters_size; } ut8 opcode = *(p4++) & 0xff; while (keep) { switch (opcode) { case 0x0: keep = false; break; case 0x1: { ut64 addr_diff; p4 = r_uleb128 (p4, p4_end - p4, &addr_diff); address += addr_diff; } break; case 0x2: { st64 line_diff = r_sleb128 (&p4, p4_end); line += line_diff; } break; case 0x3: { ut64 register_num; ut64 name_idx; ut64 type_idx; p4 = r_uleb128 (p4, p4_end - p4, &register_num); p4 = r_uleb128 (p4, p4_end - p4, &name_idx);  name_idx -= 1; p4 = r_uleb128 (p4, p4_end - p4, &type_idx);  type_idx -= 1; if (register_num >= regsz) { r_list_free (debug_positions); r_list_free (params); return; } if (debug_locals[register_num].live) { struct dex_debug_local_t *local = malloc ( sizeof (struct dex_debug_local_t)); if (!local) { keep = false; break; } local->name = debug_locals[register_num].name; local->descriptor = debug_locals[register_num].descriptor; local->startAddress = debug_locals[register_num].startAddress; local->signature = debug_locals[register_num].signature; local->live = true; local->reg = register_num; local->endAddress = address; r_list_append (emitted_debug_locals, local); } debug_locals[register_num].name = getstr (bin, name_idx); debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx); debug_locals[register_num].startAddress = address; debug_locals[register_num].signature = NULL; debug_locals[register_num].live = true; } break; case 0x4: { ut64 register_num; ut64 name_idx; ut64 type_idx; ut64 sig_idx; p4 = r_uleb128 (p4, p4_end - p4, &register_num); p4 = r_uleb128 (p4, p4_end - p4, &name_idx); name_idx -= 1; p4 = r_uleb128 (p4, p4_end - p4, &type_idx); type_idx -= 1; p4 = r_uleb128 (p4, p4_end - p4, &sig_idx); sig_idx -= 1; if (register_num >= regsz) { r_list_free (debug_positions); r_list_free (params); return; } if (debug_locals[register_num].live) { struct dex_debug_local_t *local = malloc ( sizeof (struct dex_debug_local_t)); if (!local) { keep = false; break; } local->name = debug_locals[register_num].name; local->descriptor = debug_locals[register_num].descriptor; local->startAddress = debug_locals[register_num].startAddress; local->signature = debug_locals[register_num].signature; local->live = true; local->reg = register_num; local->endAddress = address; r_list_append (emitted_debug_locals, local); } debug_locals[register_num].name = getstr (bin, name_idx); debug_locals[register_num].descriptor = dex_type_descriptor (bin, type_idx); debug_locals[register_num].startAddress = address; debug_locals[register_num].signature = getstr (bin, sig_idx); debug_locals[register_num].live = true; } break; case 0x5: { ut64 register_num; p4 = r_uleb128 (p4, p4_end - p4, &register_num); if (debug_locals[register_num].live) { struct dex_debug_local_t *local = malloc ( sizeof (struct dex_debug_local_t)); if (!local) { keep = false; break; } local->name = debug_locals[register_num].name; local->descriptor = debug_locals[register_num].descriptor; local->startAddress = debug_locals[register_num].startAddress; local->signature = debug_locals[register_num].signature; local->live = true; local->reg = register_num; local->endAddress = address; r_list_append (emitted_debug_locals, local); } debug_locals[register_num].live = false; } break; case 0x6: { ut64 register_num; p4 = r_uleb128 (p4, p4_end - p4, &register_num); if (!debug_locals[register_num].live) { debug_locals[register_num].startAddress = address; debug_locals[register_num].live = true; } } break; case 0x7: break; case 0x8: break; case 0x9: { p4 = r_uleb128 (p4, p4_end - p4, &source_file_idx); source_file_idx--; } break; default: { int adjusted_opcode = opcode - 0x0a; address += (adjusted_opcode / 15); line += -4 + (adjusted_opcode % 15); struct dex_debug_position_t *position = malloc (sizeof (struct dex_debug_position_t)); if (!position) { keep = false; break; } position->source_file_idx = source_file_idx; position->address = address; position->line = line; r_list_append (debug_positions, position); } break; } opcode = *(p4++) & 0xff; } if (!binfile->sdb_addrinfo) { binfile->sdb_addrinfo = sdb_new0 (); } char *fileline; char offset[64]; char *offset_ptr; RListIter *iter1; struct dex_debug_position_t *pos; r_list_foreach (debug_positions, iter1, pos) { fileline = r_str_newf (""%s|%""PFMT64d, getstr (bin, pos->source_file_idx), pos->line); offset_ptr = sdb_itoa (pos->address + paddr, offset, 16); sdb_set (binfile->sdb_addrinfo, offset_ptr, fileline, 0); sdb_set (binfile->sdb_addrinfo, fileline, offset_ptr, 0); } if (!dexdump) { r_list_free (debug_positions); r_list_free (emitted_debug_locals); r_list_free (params); return; } RListIter *iter2; struct dex_debug_position_t *position; rbin->cb_printf (""      positions     :\n""); r_list_foreach (debug_positions, iter2, position) { rbin->cb_printf (""        0x%04llx line=%llu\n"", position->address, position->line); } rbin->cb_printf (""      locals        :\n""); RListIter *iter3; struct dex_debug_local_t *local; r_list_foreach (emitted_debug_locals, iter3, local) { if (local->signature) { rbin->cb_printf ( ""        0x%04x - 0x%04x reg=%d %s %s %s\n"", local->startAddress, local->endAddress, local->reg, local->name, local->descriptor, local->signature); } else { rbin->cb_printf ( ""        0x%04x - 0x%04x reg=%d %s %s\n"", local->startAddress, local->endAddress, local->reg, local->name, local->descriptor); } } for (reg = 0; reg < regsz; reg++) { if (debug_locals[reg].live) { if (debug_locals[reg].signature) { rbin->cb_printf ( ""        0x%04x - 0x%04x reg=%d %s %s "" ""%s\n"", debug_locals[reg].startAddress, insns_size, reg, debug_locals[reg].name, debug_locals[reg].descriptor, debug_locals[reg].signature); } else { rbin->cb_printf ( ""        0x%04x - 0x%04x reg=%d %s %s"" ""\n"", debug_locals[reg].startAddress, insns_size, reg, debug_locals[reg].name, debug_locals[reg].descriptor); } } } r_list_free (debug_positions); r_list_free (emitted_debug_locals); r_list_free (params); }"
"static js_Ast *bitor(js_State *J, int notin) { js_Ast *a = bitxor(J, notin); while (jsP_accept(J, '|')) a = EXP2(BITOR, a, bitxor(J, notin)); return a; }"
"static void stellaris_enet_unrealize(DeviceState *dev, Error **errp) { stellaris_enet_state *s = STELLARIS_ENET(dev); unregister_savevm(DEVICE(s), ""stellaris_enet"", s); memory_region_destroy(&s->mmio); }"
static void init_peercred(struct sock *sk) { put_pid(sk->sk_peer_pid); if (sk->sk_peer_cred) put_cred(sk->sk_peer_cred); sk->sk_peer_pid  = get_pid(task_tgid(current)); sk->sk_peer_cred = get_current_cred(); }
"static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len) { const pj_uint8_t *p = start; int name_len, name_part_len; pj_status_t status; status = get_name_len(0, pkt, start, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4); rr->name.slen = 0; status = get_name(0, pkt, start, max, &rr->name); if (status != PJ_SUCCESS) return status; p = (start + name_part_len); if (p+10 > max) return PJLIB_UTIL_EDNSINSIZE; pj_memcpy(&rr->type, p, 2); rr->type = pj_ntohs(rr->type); p += 2; pj_memcpy(&rr->dnsclass, p, 2); rr->dnsclass = pj_ntohs(rr->dnsclass); p += 2; if (rr->dnsclass != 1) { if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  || rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    || rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV) { return PJLIB_UTIL_EDNSINCLASS; } } pj_memcpy(&rr->ttl, p, 4); rr->ttl = pj_ntohl(rr->ttl); p += 4; pj_memcpy(&rr->rdlength, p, 2); rr->rdlength = pj_ntohs(rr->rdlength); p += 2; if (p + rr->rdlength > max) return PJLIB_UTIL_EDNSINSIZE; if (rr->type == PJ_DNS_TYPE_A) { pj_memcpy(&rr->rdata.a.ip_addr, p, 4); p += 4; } else if (rr->type == PJ_DNS_TYPE_AAAA) { pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16); p += 16; } else if (rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS || rr->type == PJ_DNS_TYPE_PTR)  { status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.cname.name.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.cname.name); if (status != PJ_SUCCESS) return status; p += name_part_len; } else if (rr->type == PJ_DNS_TYPE_SRV) { pj_memcpy(&rr->rdata.srv.prio, p, 2); rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio); p += 2; pj_memcpy(&rr->rdata.srv.weight, p, 2); rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight); p += 2; pj_memcpy(&rr->rdata.srv.port, p, 2); rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port); p += 2; status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.srv.target.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.srv.target); if (status != PJ_SUCCESS) return status; p += name_part_len; } else { rr->data = pj_pool_alloc(pool, rr->rdlength); pj_memcpy(rr->data, p, rr->rdlength); p += rr->rdlength; } *parsed_len = (int)(p - start); return PJ_SUCCESS; }"
"void Compute(OpKernelContext* ctx) override { const auto splits = ctx->input(0).flat<int64_t>(); const auto values = ctx->input(1).flat<Tidx>(); const Tensor& size_t = ctx->input(2); const auto weights = ctx->input(3).flat<T>(); const int64_t weights_size = weights.size(); OP_REQUIRES(ctx, size_t.dims() == 0, errors::InvalidArgument(""Shape must be rank 0 but is rank "", size_t.dims())); Tidx size = size_t.scalar<Tidx>()(); OP_REQUIRES( ctx, size >= 0, errors::InvalidArgument(""size ("", size, "") must be non-negative"")); int num_rows = splits.size() - 1; int num_values = values.size(); int batch_idx = 0; OP_REQUIRES(ctx, splits(0) == 0, errors::InvalidArgument(""Splits must start with 0, not with "", splits(0))); OP_REQUIRES(ctx, splits(num_rows) == num_values, errors::InvalidArgument( ""Splits must end with the number of values, got "", splits(num_rows), "" instead of "", num_values)); Tensor* out_t; OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t)); functor::SetZeroFunctor<Device, T> fill; fill(ctx->eigen_device<Device>(), out_t->flat<T>()); const auto out = out_t->matrix<T>(); for (int idx = 0; idx < num_values; ++idx) { while (idx >= splits(batch_idx)) { batch_idx++; } Tidx bin = values(idx); OP_REQUIRES(ctx, bin >= 0, errors::InvalidArgument(""Input must be non-negative"")); if (bin < size) { if (binary_output_) { out(batch_idx - 1, bin) = T(1); } else { T value = (weights_size > 0) ? weights(idx) : T(1); out(batch_idx - 1, bin) += value; } } } }"
"const char * util_acl_to_str(const sc_acl_entry_t *e) { static char line[80], buf[20]; unsigned int acl; if (e == NULL) return ""N/A""; line[0] = 0; while (e != NULL) { acl = e->method; switch (acl) { case SC_AC_UNKNOWN: return ""N/A""; case SC_AC_NEVER: return ""NEVR""; case SC_AC_NONE: return ""NONE""; case SC_AC_CHV: strcpy(buf, ""CHV""); if (e->key_ref != SC_AC_KEY_REF_NONE) sprintf(buf + 3, ""%d"", e->key_ref); break; case SC_AC_TERM: strcpy(buf, ""TERM""); break; case SC_AC_PRO: strcpy(buf, ""PROT""); break; case SC_AC_AUT: strcpy(buf, ""AUTH""); if (e->key_ref != SC_AC_KEY_REF_NONE) sprintf(buf + 4, ""%d"", e->key_ref); break; case SC_AC_SEN: strcpy(buf, ""Sec.Env. ""); if (e->key_ref != SC_AC_KEY_REF_NONE) sprintf(buf + 3, ""#%d"", e->key_ref); break; case SC_AC_SCB: strcpy(buf, ""Sec.ControlByte ""); if (e->key_ref != SC_AC_KEY_REF_NONE) sprintf(buf + 3, ""Ox%X"", e->key_ref); break; case SC_AC_IDA: strcpy(buf, ""PKCS#15 AuthID ""); if (e->key_ref != SC_AC_KEY_REF_NONE) sprintf(buf + 3, ""#%d"", e->key_ref); break; default: strcpy(buf, ""????""); break; } strcat(line, buf); strcat(line, "" ""); e = e->next; } line[strlen(line)-1] = 0;  return line; }"
static int install_thread_keyring(void) { struct cred *new; int ret; new = prepare_creds(); if (!new) return -ENOMEM; BUG_ON(new->thread_keyring); ret = install_thread_keyring_to_cred(new); if (ret < 0) { abort_creds(new); return ret; } return commit_creds(new); }
"void shadow_teardown(struct domain *d, bool *preempted) { struct vcpu *v; mfn_t mfn; struct page_info *unpaged_pagetable = NULL; ASSERT(d->is_dying); ASSERT(d != current->domain); paging_lock(d); if ( shadow_mode_enabled(d) ) { for_each_vcpu(d, v) { if ( v->arch.paging.mode ) { v->arch.paging.mode->shadow.detach_old_tables(v); if ( shadow_mode_external(d) ) { mfn = pagetable_get_mfn(v->arch.monitor_table); if ( mfn_valid(mfn) && (mfn_x(mfn) != 0) ) v->arch.paging.mode->shadow.destroy_monitor_table(v, mfn); v->arch.monitor_table = pagetable_null(); } } } } #if (SHADOW_OPTIMIZATIONS & (SHOPT_VIRTUAL_TLB|SHOPT_OUT_OF_SYNC)) for_each_vcpu(d, v) { #if (SHADOW_OPTIMIZATIONS & SHOPT_VIRTUAL_TLB) if ( v->arch.paging.vtlb ) { xfree(v->arch.paging.vtlb); v->arch.paging.vtlb = NULL; } #endif  #if (SHADOW_OPTIMIZATIONS & SHOPT_OUT_OF_SYNC) { int i; mfn_t *oos_snapshot = v->arch.paging.shadow.oos_snapshot; for ( i = 0; i < SHADOW_OOS_PAGES; i++ ) if ( mfn_valid(oos_snapshot[i]) ) { shadow_free(d, oos_snapshot[i]); oos_snapshot[i] = INVALID_MFN; } } #endif  } #endif  if ( d->arch.paging.shadow.total_pages != 0 ) { shadow_set_allocation(d, 0, preempted); if ( preempted && *preempted ) goto out; if (d->arch.paging.shadow.hash_table) shadow_hash_teardown(d); ASSERT(d->arch.paging.shadow.total_pages == 0); } if ( !pagetable_is_null(d->arch.paging.shadow.unpaged_pagetable) ) { ASSERT(is_hvm_domain(d)); for_each_vcpu(d, v) if ( !hvm_paging_enabled(v) ) v->arch.guest_table = pagetable_null(); unpaged_pagetable = pagetable_get_page(d->arch.paging.shadow.unpaged_pagetable); d->arch.paging.shadow.unpaged_pagetable = pagetable_null(); } d->arch.paging.mode &= ~PG_log_dirty; if (d->arch.hvm_domain.dirty_vram) { xfree(d->arch.hvm_domain.dirty_vram->sl1ma); xfree(d->arch.hvm_domain.dirty_vram->dirty_bitmap); xfree(d->arch.hvm_domain.dirty_vram); d->arch.hvm_domain.dirty_vram = NULL; } out: paging_unlock(d); if ( unpaged_pagetable ) shadow_free_p2m_page(d, unpaged_pagetable); }"
"int snd_usbmidi_create(struct snd_card *card, struct usb_interface *iface, struct list_head *midi_list, const struct snd_usb_audio_quirk *quirk) { struct snd_usb_midi *umidi; struct snd_usb_midi_endpoint_info endpoints[MIDI_MAX_ENDPOINTS]; int out_ports, in_ports; int i, err; umidi = kzalloc(sizeof(*umidi), GFP_KERNEL); if (!umidi) return -ENOMEM; umidi->dev = interface_to_usbdev(iface); umidi->card = card; umidi->iface = iface; umidi->quirk = quirk; umidi->usb_protocol_ops = &snd_usbmidi_standard_ops; spin_lock_init(&umidi->disc_lock); init_rwsem(&umidi->disc_rwsem); mutex_init(&umidi->mutex); umidi->usb_id = USB_ID(le16_to_cpu(umidi->dev->descriptor.idVendor), le16_to_cpu(umidi->dev->descriptor.idProduct)); setup_timer(&umidi->error_timer, snd_usbmidi_error_timer, (unsigned long)umidi); memset(endpoints, 0, sizeof(endpoints)); switch (quirk ? quirk->type : QUIRK_MIDI_STANDARD_INTERFACE) { case QUIRK_MIDI_STANDARD_INTERFACE: err = snd_usbmidi_get_ms_info(umidi, endpoints); if (umidi->usb_id == USB_ID(0x0763, 0x0150))  umidi->usb_protocol_ops = &snd_usbmidi_maudio_broken_running_status_ops; break; case QUIRK_MIDI_US122L: umidi->usb_protocol_ops = &snd_usbmidi_122l_ops; case QUIRK_MIDI_FIXED_ENDPOINT: memcpy(&endpoints[0], quirk->data, sizeof(struct snd_usb_midi_endpoint_info)); err = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1); break; case QUIRK_MIDI_YAMAHA: err = snd_usbmidi_detect_yamaha(umidi, &endpoints[0]); break; case QUIRK_MIDI_ROLAND: err = snd_usbmidi_detect_roland(umidi, &endpoints[0]); break; case QUIRK_MIDI_MIDIMAN: umidi->usb_protocol_ops = &snd_usbmidi_midiman_ops; memcpy(&endpoints[0], quirk->data, sizeof(struct snd_usb_midi_endpoint_info)); err = 0; break; case QUIRK_MIDI_NOVATION: umidi->usb_protocol_ops = &snd_usbmidi_novation_ops; err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); break; case QUIRK_MIDI_RAW_BYTES: umidi->usb_protocol_ops = &snd_usbmidi_raw_ops; if (umidi->usb_id == USB_ID(0x07fd, 0x0001))  usb_set_interface(umidi->dev, 0, 0); err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); break; case QUIRK_MIDI_EMAGIC: umidi->usb_protocol_ops = &snd_usbmidi_emagic_ops; memcpy(&endpoints[0], quirk->data, sizeof(struct snd_usb_midi_endpoint_info)); err = snd_usbmidi_detect_endpoints(umidi, &endpoints[0], 1); break; case QUIRK_MIDI_CME: umidi->usb_protocol_ops = &snd_usbmidi_cme_ops; err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); break; case QUIRK_MIDI_AKAI: umidi->usb_protocol_ops = &snd_usbmidi_akai_ops; err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); endpoints[1].out_cables = 0; break; case QUIRK_MIDI_FTDI: umidi->usb_protocol_ops = &snd_usbmidi_ftdi_ops; err = usb_control_msg(umidi->dev, usb_sndctrlpipe(umidi->dev, 0), 3, 0x40, 0x60, 0, NULL, 0, 1000); if (err < 0) break; err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); break; case QUIRK_MIDI_CH345: umidi->usb_protocol_ops = &snd_usbmidi_ch345_broken_sysex_ops; err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints); break; default: dev_err(&umidi->dev->dev, ""invalid quirk type %d\n"", quirk->type); err = -ENXIO; break; } if (err < 0) { kfree(umidi); return err; } out_ports = 0; in_ports = 0; for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i) { out_ports += hweight16(endpoints[i].out_cables); in_ports += hweight16(endpoints[i].in_cables); } err = snd_usbmidi_create_rawmidi(umidi, out_ports, in_ports); if (err < 0) { kfree(umidi); return err; } if (quirk && quirk->type == QUIRK_MIDI_MIDIMAN) err = snd_usbmidi_create_endpoints_midiman(umidi, &endpoints[0]); else err = snd_usbmidi_create_endpoints(umidi, endpoints); if (err < 0) { snd_usbmidi_free(umidi); return err; } usb_autopm_get_interface_no_resume(umidi->iface); list_add_tail(&umidi->list, midi_list); return 0; }"
"void pt_intr_post(struct vcpu *v, struct hvm_intack intack) { struct periodic_time *pt; time_cb *cb; void *cb_priv; if ( intack.source == hvm_intsrc_vector ) return; spin_lock(&v->arch.hvm.tm_lock); pt = is_pt_irq(v, intack); if ( pt == NULL ) { spin_unlock(&v->arch.hvm.tm_lock); return; } pt_irq_fired(v, pt); cb = pt->cb; cb_priv = pt->priv; spin_unlock(&v->arch.hvm.tm_lock); if ( cb != NULL ) cb(v, cb_priv); }"
"static void dissect_llrp_message(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint16 type, guint offset) { gboolean    ends_with_parameters; guint8      requested_data; guint16     antenna_id, gpi_port, gpo_port; guint32     spec_id, vendor; proto_item *request_item, *antenna_item, *gpi_item, *gpo_item; guint (*dissect_custom_message)(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset) = NULL; ends_with_parameters = FALSE; switch (type) { case LLRP_TYPE_CLOSE_CONNECTION_RESPONSE: case LLRP_TYPE_GET_READER_CAPABILITIES_RESPONSE: case LLRP_TYPE_ADD_ROSPEC: case LLRP_TYPE_ADD_ROSPEC_RESPONSE: case LLRP_TYPE_DELETE_ROSPEC_RESPONSE: case LLRP_TYPE_START_ROSPEC_RESPONSE: case LLRP_TYPE_STOP_ROSPEC_RESPONSE: case LLRP_TYPE_ENABLE_ROSPEC_RESPONSE: case LLRP_TYPE_DISABLE_ROSPEC_RESPONSE: case LLRP_TYPE_GET_ROSPECS_RESPONSE: case LLRP_TYPE_ADD_ACCESSSPEC: case LLRP_TYPE_ADD_ACCESSSPEC_RESPONSE: case LLRP_TYPE_DELETE_ACCESSSPEC_RESPONSE: case LLRP_TYPE_ENABLE_ACCESSSPEC_RESPONSE: case LLRP_TYPE_DISABLE_ACCESSSPEC_RESPONSE: case LLRP_TYPE_GET_ACCESSSPECS: case LLRP_TYPE_CLIENT_REQUEST_OP: case LLRP_TYPE_CLIENT_RESQUEST_OP_RESPONSE: case LLRP_TYPE_RO_ACCESS_REPORT: case LLRP_TYPE_READER_EVENT_NOTIFICATION: case LLRP_TYPE_ERROR_MESSAGE: case LLRP_TYPE_GET_READER_CONFIG_RESPONSE: case LLRP_TYPE_SET_READER_CONFIG_RESPONSE: case LLRP_TYPE_SET_PROTOCOL_VERSION_RESPONSE: case LLRP_TYPE_GET_ACCESSSPECS_RESPONSE: case LLRP_TYPE_GET_REPORT: case LLRP_TYPE_ENABLE_EVENTS_AND_REPORTS: ends_with_parameters = TRUE; break; case LLRP_TYPE_START_ROSPEC: case LLRP_TYPE_STOP_ROSPEC: case LLRP_TYPE_ENABLE_ROSPEC: case LLRP_TYPE_DISABLE_ROSPEC: case LLRP_TYPE_DELETE_ROSPEC: spec_id = tvb_get_ntohl(tvb, offset); if (spec_id == LLRP_ROSPEC_ALL) proto_tree_add_uint_format(tree, hf_llrp_rospec, tvb, offset, 4, spec_id, ""All ROSpecs (%u)"", spec_id); else proto_tree_add_item(tree, hf_llrp_rospec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case LLRP_TYPE_ENABLE_ACCESSSPEC: case LLRP_TYPE_DELETE_ACCESSSPEC: case LLRP_TYPE_DISABLE_ACCESSSPEC: spec_id = tvb_get_ntohl(tvb, offset); if (spec_id == LLRP_ACCESSSPEC_ALL) proto_tree_add_uint_format(tree, hf_llrp_accessspec, tvb, offset, 4, spec_id, ""All Access Specs (%u)"", spec_id); else proto_tree_add_item(tree, hf_llrp_accessspec, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case LLRP_TYPE_GET_READER_CAPABILITIES: proto_tree_add_item(tree, hf_llrp_req_cap, tvb, offset, 1, ENC_BIG_ENDIAN); offset++; ends_with_parameters = TRUE; break; case LLRP_TYPE_GET_READER_CONFIG: antenna_id = tvb_get_ntohs(tvb, offset); if (antenna_id == LLRP_ANTENNA_ALL) antenna_item = proto_tree_add_uint_format(tree, hf_llrp_antenna_id, tvb, offset, 2, antenna_id, ""All Antennas (%u)"", antenna_id); else antenna_item = proto_tree_add_item(tree, hf_llrp_antenna_id, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; requested_data = tvb_get_guint8(tvb, offset); request_item = proto_tree_add_item(tree, hf_llrp_req_conf, tvb, offset, 1, ENC_BIG_ENDIAN); offset++; gpi_port = tvb_get_ntohs(tvb, offset); if (gpi_port == LLRP_GPI_PORT_ALL) gpi_item = proto_tree_add_uint_format(tree, hf_llrp_gpi_port, tvb, offset, 2, gpi_port, ""All GPI Ports (%u)"", gpi_port); else gpi_item = proto_tree_add_item(tree, hf_llrp_gpi_port, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; gpo_port = tvb_get_ntohs(tvb, offset); if (gpo_port == LLRP_GPO_PORT_ALL) gpo_item = proto_tree_add_uint_format(tree, hf_llrp_gpo_port, tvb, offset, 2, gpo_port, ""All GPO Ports (%u)"", gpo_port); else gpo_item = proto_tree_add_item(tree, hf_llrp_gpo_port, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; switch (requested_data) { case LLRP_CONF_ALL: break; case LLRP_CONF_ANTENNA_PROPERTIES: case LLRP_CONF_ANTENNA_CONFIGURATION: proto_item_append_text(gpi_item, "" (Ignored)""); proto_item_append_text(gpo_item, "" (Ignored)""); break; case LLRP_CONF_IDENTIFICATION: case LLRP_CONF_RO_REPORT_SPEC: case LLRP_CONF_READER_EVENT_NOTIFICATION_SPEC: case LLRP_CONF_ACCESS_REPORT_SPEC: case LLRP_CONF_LLRP_CONFIGURATION_STATE: case LLRP_CONF_KEEPALIVE_SPEC: case LLRP_CONF_EVENTS_AND_REPORTS: proto_item_append_text(antenna_item, "" (Ignored)""); proto_item_append_text(gpi_item, "" (Ignored)""); proto_item_append_text(gpo_item, "" (Ignored)""); break; case LLRP_CONF_GPI_PORT_CURRENT_STATE: proto_item_append_text(antenna_item, "" (Ignored)""); proto_item_append_text(gpo_item, "" (Ignored)""); break; case LLRP_CONF_GPO_WRITE_DATA: proto_item_append_text(antenna_item, "" (Ignored)""); proto_item_append_text(gpi_item, "" (Ignored)""); break; default: proto_item_append_text(antenna_item, "" (Ignored)""); expert_add_info_format(pinfo, request_item, &ei_llrp_req_conf, ""Unrecognized configuration request: %u"", requested_data); proto_item_append_text(gpi_item, "" (Ignored)""); proto_item_append_text(gpo_item, "" (Ignored)""); break; }; ends_with_parameters = TRUE; break; case LLRP_TYPE_SET_READER_CONFIG: proto_tree_add_item(tree, hf_llrp_rest_fact, tvb, offset, 1, ENC_NA); offset++; ends_with_parameters = TRUE; break; case LLRP_TYPE_SET_PROTOCOL_VERSION: proto_tree_add_item(tree, hf_llrp_version, tvb, offset, 1, ENC_BIG_ENDIAN); break; case LLRP_TYPE_GET_SUPPORTED_VERSION_RESPONSE: proto_tree_add_item(tree, hf_llrp_cur_ver, tvb, offset, 1, ENC_BIG_ENDIAN); offset++; proto_tree_add_item(tree, hf_llrp_sup_ver, tvb, offset, 1, ENC_BIG_ENDIAN); offset++; ends_with_parameters = TRUE; break; case LLRP_TYPE_CUSTOM_MESSAGE: vendor = tvb_get_ntohl(tvb, offset); proto_tree_add_item(tree, hf_llrp_vendor, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; switch(vendor) { case LLRP_VENDOR_IMPINJ: dissect_custom_message = dissect_llrp_impinj_message; ends_with_parameters = TRUE; break; } if (dissect_custom_message) offset = dissect_custom_message(tvb, pinfo, tree, offset); break; case LLRP_TYPE_KEEPALIVE: case LLRP_TYPE_KEEPALIVE_ACK: case LLRP_TYPE_CLOSE_CONNECTION: case LLRP_TYPE_GET_ROSPECS: case LLRP_TYPE_GET_SUPPORTED_VERSION: break; default: DISSECTOR_ASSERT_NOT_REACHED(); }; if(ends_with_parameters) { offset = dissect_llrp_parameters(tvb, pinfo, tree, offset, tvb_reported_length(tvb)); } if(tvb_reported_length_remaining(tvb, offset) != 0) { expert_add_info_format(pinfo, tree, &ei_llrp_invalid_length, ""Incorrect length of message: %u bytes decoded, but %u bytes available."", offset, tvb_reported_length(tvb)); } }"
"static int install_relocation_handler(int num_cpus, size_t save_state_size) { struct smm_loader_params smm_params = { .per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE, .num_concurrent_stacks = num_cpus, .per_cpu_save_state_size = save_state_size, .num_concurrent_save_states = 1, .handler = smm_do_relocation, }; if (mp_state.ops.adjust_smm_params != NULL) mp_state.ops.adjust_smm_params(&smm_params, 0); if (smm_setup_relocation_handler(&smm_params)) return -1; adjust_smm_apic_id_map(&smm_params); return 0; }"
"static void tiff_expand_colormap(fz_context *ctx, struct tiff *tiff) { int maxval = 1 << tiff->bitspersample; unsigned char *samples; unsigned char *src, *dst; unsigned int x, y; unsigned int stride; if (tiff->samplesperpixel != 1 && tiff->samplesperpixel != 2) fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of samples for RGBPal""); if (tiff->bitspersample != 1 && tiff->bitspersample != 2 && tiff->bitspersample != 4 && tiff->bitspersample != 8 && tiff->bitspersample != 16) fz_throw(ctx, FZ_ERROR_GENERIC, ""invalid number of bits for RGBPal""); if (tiff->colormaplen < (unsigned)maxval * 3) fz_throw(ctx, FZ_ERROR_GENERIC, ""insufficient colormap data""); if (tiff->imagelength > UINT_MAX / tiff->imagewidth / (tiff->samplesperpixel + 2)) fz_throw(ctx, FZ_ERROR_GENERIC, ""image too large""); stride = tiff->imagewidth * (tiff->samplesperpixel + 2); samples = fz_malloc(ctx, stride * tiff->imagelength); for (y = 0; y < tiff->imagelength; y++) { src = tiff->samples + (unsigned int)(tiff->stride * y); dst = samples + (unsigned int)(stride * y); for (x = 0; x < tiff->imagewidth; x++) { if (tiff->extrasamples) { int c = tiff_getcomp(src, x * 2, tiff->bitspersample); int a = tiff_getcomp(src, x * 2 + 1, tiff->bitspersample); *dst++ = tiff->colormap[c + 0] >> 8; *dst++ = tiff->colormap[c + maxval] >> 8; *dst++ = tiff->colormap[c + maxval * 2] >> 8; *dst++ = a << (8 - tiff->bitspersample); } else { int c = tiff_getcomp(src, x, tiff->bitspersample); *dst++ = tiff->colormap[c + 0] >> 8; *dst++ = tiff->colormap[c + maxval] >> 8; *dst++ = tiff->colormap[c + maxval * 2] >> 8; } } } tiff->samplesperpixel += 2; tiff->bitspersample = 8; tiff->stride = stride; fz_free(ctx, tiff->samples); tiff->samples = samples; }"
"int LiSendMouseMoveEvent(short deltaX, short deltaY) { PPACKET_HOLDER holder; int err; if (!initialized) { return -2; } holder = malloc(sizeof(*holder)); if (holder == NULL) { return -1; } holder->packetLength = sizeof(NV_MOUSE_MOVE_PACKET); holder->packet.mouseMove.header.packetType = htonl(PACKET_TYPE_MOUSE_MOVE); holder->packet.mouseMove.magic = MOUSE_MOVE_MAGIC; if (ServerMajorVersion >= 5) { holder->packet.mouseMove.magic++; } holder->packet.mouseMove.deltaX = htons(deltaX); holder->packet.mouseMove.deltaY = htons(deltaY); err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry); if (err != LBQ_SUCCESS) { free(holder); } return err; }"
"static bfd_boolean load_specific_debug_section (enum dwarf_section_display_enum debug, asection *sec, void *file) { struct dwarf_section *section = &debug_displays [debug].section; bfd *abfd = (bfd *) file; bfd_byte *contents; bfd_size_type amt; if (section->start != NULL) { if (streq (section->filename, bfd_get_filename (abfd))) return TRUE; free (section->start); } section->filename = bfd_get_filename (abfd); section->reloc_info = NULL; section->num_relocs = 0; section->address = bfd_get_section_vma (abfd, sec); section->size = bfd_get_section_size (sec); amt = section->size + 1; section->start = contents = malloc (amt); section->user_data = sec; if (amt == 0 || section->start == NULL || !bfd_get_full_section_contents (abfd, sec, &contents)) { free_debug_section (debug); printf (_(""\nCan't get contents for section '%s'.\n""), section->name); return FALSE; } section->start[section->size] = 0; if (is_relocatable && debug_displays [debug].relocate) { long         reloc_size; bfd_boolean  ret; bfd_cache_section_contents (sec, section->start); ret = bfd_simple_get_relocated_section_contents (abfd, sec, section->start, syms) != NULL; if (! ret) { free_debug_section (debug); printf (_(""\nCan't get contents for section '%s'.\n""), section->name); return FALSE; } reloc_size = bfd_get_reloc_upper_bound (abfd, sec); if (reloc_size > 0) { unsigned long reloc_count; arelent **relocs; relocs = (arelent **) xmalloc (reloc_size); reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, NULL); if (reloc_count == 0) free (relocs); else { section->reloc_info = relocs; section->num_relocs = reloc_count; } } } return TRUE; }"
"void LowerABIAttributesPass::runOnOperation() { spirv::ModuleOp module = getOperation(); MLIRContext *context = &getContext(); spirv::TargetEnv targetEnv(spirv::lookupTargetEnv(module)); SPIRVTypeConverter typeConverter(targetEnv); typeConverter.addSourceMaterialization([](OpBuilder &builder, spirv::PointerType type, ValueRange inputs, Location loc) { if (inputs.size() != 1 || !inputs[0].getType().isa<spirv::PointerType>()) return Value(); return builder.create<spirv::BitcastOp>(loc, type, inputs[0]).getResult(); }); RewritePatternSet patterns(context); patterns.add<ProcessInterfaceVarABI>(typeConverter, context); ConversionTarget target(*context); target.addDynamicallyLegalOp<spirv::FuncOp>([&](spirv::FuncOp op) { StringRef attrName = spirv::getInterfaceVarABIAttrName(); for (unsigned i = 0, e = op.getNumArguments(); i < e; ++i) if (op.getArgAttr(i, attrName)) return false; return true; }); target.markUnknownOpDynamicallyLegal([](Operation *op) { return op->getDialect()->getNamespace() == spirv::SPIRVDialect::getDialectNamespace(); }); if (failed(applyPartialConversion(module, target, std::move(patterns)))) return signalPassFailure(); OpBuilder builder(context); SmallVector<spirv::FuncOp, 1> entryPointFns; auto entryPointAttrName = spirv::getEntryPointABIAttrName(); module.walk([&](spirv::FuncOp funcOp) { if (funcOp->getAttrOfType<spirv::EntryPointABIAttr>(entryPointAttrName)) { entryPointFns.push_back(funcOp); } }); for (auto fn : entryPointFns) { if (failed(lowerEntryPointABIAttr(fn, builder))) { return signalPassFailure(); } } }"
"void Compute(OpKernelContext* ctx) override { const Tensor& in0 = ctx->input(0); const Tensor& in1 = ctx->input(1); ValidateInputTensors(ctx, in0, in1); MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes()); OP_REQUIRES( ctx, bcast.IsValid(), errors::InvalidArgument( ""In[0] and In[1] must have compatible batch dimensions: "", in0.shape().DebugString(), "" vs. "", in1.shape().DebugString())); TensorShape out_shape = bcast.output_batch_shape(); auto batch_size = bcast.output_batch_size(); auto d0 = in0.dim_size(in0.dims() - 2);      auto d1 = in0.dim_size(in0.dims() - 1); Tensor in0_reshaped; OP_REQUIRES( ctx, in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})), errors::Internal(""Failed to reshape In[0] from "", in0.shape().DebugString())); auto d2 = in1.dim_size(in1.dims() - 2); auto d3 = in1.dim_size(in1.dims() - 1); Tensor in1_reshaped; OP_REQUIRES( ctx, in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})), errors::Internal(""Failed to reshape In[1] from "", in1.shape().DebugString())); OP_REQUIRES(ctx, d1 == d2, errors::InvalidArgument( ""In[0] mismatch In[1] shape: "", d1, "" vs. "", d2, "": "", in0.shape().DebugString(), "" "", in1.shape().DebugString(), "" "", lower_, "" "", adjoint_)); out_shape.AddDim(d1); out_shape.AddDim(d3); Tensor* out = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out)); if (out->NumElements() == 0) { return; } Tensor out_reshaped; OP_REQUIRES(ctx, out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})), errors::Internal(""Failed to reshape output from "", out->shape().DebugString())); LaunchBatchBandedTriangularSolve<Scalar>::Launch( ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast, &out_reshaped); }"
"GF_Err gf_bifs_dec_field(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com) { GF_Err e; u8 flag; assert(node); if (gf_sg_vrml_is_sf_field(field->fieldType)) { e = gf_bifs_dec_sf_field(codec, bs, node, field, is_mem_com); if (e) return e; } else { if (field->eventType == GF_SG_EVENT_IN) { if (field->fieldType == GF_SG_VRML_MFNODE) { gf_node_unregister_children(node, * (GF_ChildNodeItem **)field->far_ptr); * (GF_ChildNodeItem **)field->far_ptr = NULL; } else { gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType); } } if (codec->info->config.UsePredictiveMFField) { flag = gf_bs_read_int(bs, 1); if (flag) { #ifdef GPAC_ENABLE_BIFS_PMF return gf_bifs_dec_pred_mf_field(codec, bs, node, field); #else GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[BIFS] Stream uses Predictive Field Coding, disabled in this build!\n"")); return GF_NOT_SUPPORTED; #endif } } flag = gf_bs_read_int(bs, 1); if (!flag) { if (field->fieldType != GF_SG_VRML_MFNODE) { e = gf_sg_vrml_mf_reset(field->far_ptr, field->fieldType); if (e) return e; } flag = gf_bs_read_int(bs, 1); if (flag) { e = BD_DecMFFieldList(codec, bs, node, field, is_mem_com); } else { e = BD_DecMFFieldVec(codec, bs, node, field, is_mem_com); } if (e) return e; } } return GF_OK; }"
"static int dhcpv6_print(netdissect_options *ndo, const u_char *cp, u_int length, int indent) { u_int i, t; const u_char *tlv, *value; uint16_t type, optlen; i = 0; while (i < length) { tlv = cp + i; type = EXTRACT_16BITS(tlv); optlen = EXTRACT_16BITS(tlv + 2); value = tlv + 4; ND_PRINT((ndo, ""\n"")); for (t = indent; t > 0; t--) ND_PRINT((ndo, ""\t"")); ND_PRINT((ndo, ""%s"", tok2str(dh6opt_str, ""Unknown"", type))); ND_PRINT((ndo,"" (%u)"", optlen + 4 )); switch (type) { case DH6OPT_DNS_SERVERS: case DH6OPT_SNTP_SERVERS: { if (optlen % 16 != 0) { ND_PRINT((ndo, "" %s"", istr)); return -1; } for (t = 0; t < optlen; t += 16) ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, value + t))); } break; case DH6OPT_DOMAIN_LIST: { const u_char *tp = value; while (tp < value + optlen) { ND_PRINT((ndo, "" "")); if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL) return -1; } } break; } i += 4 + optlen; } return 0; }"
"static int path_set_perms(Item *i, const char *path) { char fn[STRLEN(""/proc/self/fd/"") + DECIMAL_STR_MAX(int)]; _cleanup_close_ int fd = -1; struct stat st; assert(i); assert(path); if (!i->mode_set && !i->uid_set && !i->gid_set) goto shortcut; fd = open(path, O_NOFOLLOW|O_CLOEXEC|O_PATH); if (fd < 0) { int level = LOG_ERR, r = -errno; if (i->type == EMPTY_DIRECTORY && errno == ENOENT) { level = LOG_DEBUG; r = 0; } log_full_errno(level, errno, ""Adjusting owner and mode for %s failed: %m"", path); return r; } if (fstatat(fd, """", &st, AT_EMPTY_PATH) < 0) return log_error_errno(errno, ""Failed to fstat() file %s: %m"", path); xsprintf(fn, ""/proc/self/fd/%i"", fd); if (i->mode_set) { if (S_ISLNK(st.st_mode)) log_debug(""Skipping mode fix for symlink %s."", path); else { mode_t m = i->mode; if (i->mask_perms) { if (!(st.st_mode & 0111)) m &= ~0111; if (!(st.st_mode & 0222)) m &= ~0222; if (!(st.st_mode & 0444)) m &= ~0444; if (!S_ISDIR(st.st_mode)) m &= ~07000;  } if (m == (st.st_mode & 07777)) log_debug(""\""%s\"" has correct mode %o already."", path, st.st_mode); else { log_debug(""Changing \""%s\"" to mode %o."", path, m); if (chmod(fn, m) < 0) return log_error_errno(errno, ""chmod() of %s via %s failed: %m"", path, fn); } } } if ((i->uid_set && i->uid != st.st_uid) || (i->gid_set && i->gid != st.st_gid)) { log_debug(""Changing \""%s\"" to owner ""UID_FMT"":""GID_FMT, path, i->uid_set ? i->uid : UID_INVALID, i->gid_set ? i->gid : GID_INVALID); if (chown(fn, i->uid_set ? i->uid : UID_INVALID, i->gid_set ? i->gid : GID_INVALID) < 0) return log_error_errno(errno, ""chown() of %s via %s failed: %m"", path, fn); } fd = safe_close(fd); shortcut: return label_fix(path, false, false); }"
"static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) { opj_pi_comp_t *comp = NULL; opj_pi_resolution_t *res = NULL; OPJ_UINT32 index = 0; if (!pi->first) { comp = &pi->comps[pi->compno]; goto LABEL_SKIP; } else { pi->first = 0; } for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) { OPJ_UINT32 resno; comp = &pi->comps[pi->compno]; pi->dx = 0; pi->dy = 0; for (resno = 0; resno < comp->numresolutions; resno++) { OPJ_UINT32 dx, dy; res = &comp->resolutions[resno]; dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno)); dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno)); pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx); pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy); } if (!pi->tp_on) { pi->poc.ty0 = pi->ty0; pi->poc.tx0 = pi->tx0; pi->poc.ty1 = pi->ty1; pi->poc.tx1 = pi->tx1; } for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) { for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) { for (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) { OPJ_UINT32 levelno; OPJ_INT32 trx0, try0; OPJ_INT32 trx1, try1; OPJ_UINT32 rpx, rpy; OPJ_INT32 prci, prcj; res = &comp->resolutions[pi->resno]; levelno = comp->numresolutions - 1 - pi->resno; trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno)); try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno)); trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno)); try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno)); rpx = res->pdx + levelno; rpy = res->pdy + levelno; if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))) { continue; } if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))) { continue; } if ((res->pw == 0) || (res->ph == 0)) { continue; } if ((trx0 == trx1) || (try0 == try1)) { continue; } prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx) - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx); prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy) - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy); pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw); for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) { index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p; if (!pi->include[index]) { pi->include[index] = 1; return OPJ_TRUE; } LABEL_SKIP: ; } } } } } return OPJ_FALSE; }"
"void dmar_free_irte(const struct intr_source *intr_src, uint16_t index) { struct dmar_drhd_rt *dmar_unit; union dmar_ir_entry *ir_table, *ir_entry; union pci_bdf sid; if (intr_src->is_msi) { dmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun); } else { dmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid); } if (is_dmar_unit_valid(dmar_unit, sid)) { ir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr); ir_entry = ir_table + index; ir_entry->bits.remap.present = 0x0UL; iommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry)); dmar_invalid_iec(dmar_unit, index, 0U, false); if (!is_irte_reserved(dmar_unit, index)) { spinlock_obtain(&dmar_unit->lock); bitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]); spinlock_release(&dmar_unit->lock); } } }"
"static Image *ReadPCDImage(const ImageInfo *image_info,ExceptionInfo *exception) { Image *image; MagickBooleanType status; MagickOffsetType offset; MagickSizeType number_pixels; register ssize_t i, y; register PixelPacket *q; register unsigned char *c1, *c2, *yy; size_t height, number_images, rotate, scene, width; ssize_t count, x; unsigned char *chroma1, *chroma2, *header, *luma; unsigned int overview; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } header=(unsigned char *) AcquireQuantumMemory(0x800,3UL*sizeof(*header)); if (header == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,3*0x800,header); overview=LocaleNCompare((char *) header,""PCD_OPA"",7) == 0; if ((count != (3*0x800)) || ((LocaleNCompare((char *) header+0x800,""PCD"",3) != 0) && (overview == 0))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); rotate=header[0x0e02] & 0x03; number_images=(header[10] << 8) | header[11]; if (number_images > 65535) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); header=(unsigned char *) RelinquishMagickMemory(header); if ((image->columns == 0) || (image->rows == 0)) scene=3; else { width=192; height=128; for (scene=1; scene < 6; scene++) { if ((width >= image->columns) && (height >= image->rows)) break; width<<=1; height<<=1; } } if (image_info->number_scenes != 0) scene=(size_t) MagickMin(image_info->scene,6); if (overview != 0) scene=1; width=192; height=128; for (i=1; i < (ssize_t) MagickMin(scene,3); i++) { width<<=1; height<<=1; } image->columns=width; image->rows=height; image->depth=8; for ( ; i < (ssize_t) scene; i++) { image->columns<<=1; image->rows<<=1; } status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } number_pixels=(MagickSizeType) image->columns*image->rows; if (number_pixels != (size_t) number_pixels) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); chroma1=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows* sizeof(*chroma1)); chroma2=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows* sizeof(*chroma2)); luma=(unsigned char *) AcquireQuantumMemory(image->columns+1UL,image->rows* sizeof(*luma)); if ((chroma1 == (unsigned char *) NULL) || (chroma2 == (unsigned char *) NULL) || (luma == (unsigned char *) NULL)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); offset=93; if (overview != 0) offset=2; else if (scene == 2) offset=20; else if (scene <= 1) offset=1; for (i=0; i < (ssize_t) (offset*0x800); i++) (void) ReadBlobByte(image); if (overview != 0) { Image *overview_image; MagickProgressMonitor progress_monitor; register ssize_t j; for (j=1; j <= (ssize_t) number_images; j++) { progress_monitor=SetImageProgressMonitor(image, (MagickProgressMonitor) NULL,image->client_data); (void) FormatLocaleString(image->filename,MaxTextExtent, ""images/img%04ld.pcd"",(long) j); (void) FormatLocaleString(image->magick_filename,MaxTextExtent, ""images/img%04ld.pcd"",(long) j); image->scene=(size_t) j; image->columns=width; image->rows=height; image->depth=8; yy=luma; c1=chroma1; c2=chroma2; for (y=0; y < (ssize_t) height; y+=2) { count=ReadBlob(image,width,yy); yy+=image->columns; count=ReadBlob(image,width,yy); yy+=image->columns; count=ReadBlob(image,width >> 1,c1); c1+=image->columns; count=ReadBlob(image,width >> 1,c2); c2+=image->columns; } Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1); Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2); yy=luma; c1=chroma1; c2=chroma2; for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(q,ScaleCharToQuantum(*yy++)); SetPixelGreen(q,ScaleCharToQuantum(*c1++)); SetPixelBlue(q,ScaleCharToQuantum(*c2++)); q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } image->colorspace=YCCColorspace; if (LocaleCompare(image_info->magick,""PCDS"") == 0) SetImageColorspace(image,sRGBColorspace); if (j < (ssize_t) number_images) { AcquireNextImage(image_info,image); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); } (void) SetImageProgressMonitor(image,progress_monitor, image->client_data); if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,j-1,number_images); if (status == MagickFalse) break; } } chroma2=(unsigned char *) RelinquishMagickMemory(chroma2); chroma1=(unsigned char *) RelinquishMagickMemory(chroma1); luma=(unsigned char *) RelinquishMagickMemory(luma); image=GetFirstImageInList(image); overview_image=OverviewImage(image_info,image,exception); return(overview_image); } yy=luma; c1=chroma1; c2=chroma2; for (y=0; y < (ssize_t) height; y+=2) { count=ReadBlob(image,width,yy); yy+=image->columns; count=ReadBlob(image,width,yy); yy+=image->columns; count=ReadBlob(image,width >> 1,c1); c1+=image->columns; count=ReadBlob(image,width >> 1,c2); c2+=image->columns; } if (scene >= 4) { Upsample(768,512,image->columns,luma); Upsample(384,256,image->columns,chroma1); Upsample(384,256,image->columns,chroma2); image->rows=1024; for (i=0; i < (4*0x800); i++) (void) ReadBlobByte(image); status=DecodeImage(image,luma,chroma1,chroma2); if ((scene >= 5) && status) { Upsample(1536,1024,image->columns,luma); Upsample(768,512,image->columns,chroma1); Upsample(768,512,image->columns,chroma2); image->rows=2048; offset=TellBlob(image)/0x800+12; offset=SeekBlob(image,offset*0x800,SEEK_SET); status=DecodeImage(image,luma,chroma1,chroma2); if ((scene >= 6) && (status != MagickFalse)) { Upsample(3072,2048,image->columns,luma); Upsample(1536,1024,image->columns,chroma1); Upsample(1536,1024,image->columns,chroma2); image->rows=4096; } } } Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma1); Upsample(image->columns >> 1,image->rows >> 1,image->columns,chroma2); yy=luma; c1=chroma1; c2=chroma2; for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(q,ScaleCharToQuantum(*yy++)); SetPixelGreen(q,ScaleCharToQuantum(*c1++)); SetPixelBlue(q,ScaleCharToQuantum(*c2++)); q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } chroma2=(unsigned char *) RelinquishMagickMemory(chroma2); chroma1=(unsigned char *) RelinquishMagickMemory(chroma1); luma=(unsigned char *) RelinquishMagickMemory(luma); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); if (image_info->ping == MagickFalse) if ((rotate == 1) || (rotate == 3)) { double degrees; Image *rotate_image; degrees=rotate == 1 ? -90.0 : 90.0; rotate_image=RotateImage(image,degrees,exception); if (rotate_image != (Image *) NULL) { image=DestroyImage(image); image=rotate_image; } } image->chromaticity.red_primary.x=0.6400f; image->chromaticity.red_primary.y=0.3300f; image->chromaticity.green_primary.x=0.3000f; image->chromaticity.green_primary.y=0.6000f; image->chromaticity.blue_primary.x=0.1500f; image->chromaticity.blue_primary.y=0.0600f; image->chromaticity.white_point.x=0.3127f; image->chromaticity.white_point.y=0.3290f; image->gamma=1.000f/2.200f; image->colorspace=YCCColorspace; if (LocaleCompare(image_info->magick,""PCDS"") == 0) SetImageColorspace(image,sRGBColorspace); return(GetFirstImageInList(image)); }"
"static void polkit_unix_process_class_init (PolkitUnixProcessClass *klass) { GObjectClass *gobject_class = G_OBJECT_CLASS (klass); gobject_class->get_property = polkit_unix_process_get_property; gobject_class->set_property = polkit_unix_process_set_property; gobject_class->constructed =  polkit_unix_process_constructed; g_object_class_install_property (gobject_class, PROP_PID, g_param_spec_int (""pid"", ""Process ID"", ""The UNIX process ID"", 0, G_MAXINT, 0, G_PARAM_CONSTRUCT | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK)); g_object_class_install_property (gobject_class, PROP_UID, g_param_spec_int (""uid"", ""User ID"", ""The UNIX user ID"", -1, G_MAXINT, -1, G_PARAM_CONSTRUCT | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK)); g_object_class_install_property (gobject_class, PROP_START_TIME, g_param_spec_uint64 (""start-time"", ""Start Time"", ""The start time of the process, since the machine booted"", 0, G_MAXUINT64, 0, G_PARAM_CONSTRUCT | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK)); }"
"SampleTable::SampleTable(const sp<DataSource> &source) : mDataSource(source), mChunkOffsetOffset(-1), mChunkOffsetType(0), mNumChunkOffsets(0), mSampleToChunkOffset(-1), mNumSampleToChunkOffsets(0), mSampleSizeOffset(-1), mSampleSizeFieldSize(0), mDefaultSampleSize(0), mNumSampleSizes(0), mTimeToSampleCount(0), mTimeToSample(), mSampleTimeEntries(NULL), mCompositionTimeDeltaEntries(NULL), mNumCompositionTimeDeltaEntries(0), mCompositionDeltaLookup(new CompositionDeltaLookup), mSyncSampleOffset(-1), mNumSyncSamples(0), mSyncSamples(NULL), mLastSyncSampleIndex(0), mSampleToChunkEntries(NULL) { mSampleIterator = new SampleIterator(this); }"
"static int decode_hextile(VmncContext *c, uint8_t* dst, GetByteContext *gb, int w, int h, int stride) { int i, j, k; int bg = 0, fg = 0, rects, color, flags, xy, wh; const int bpp = c->bpp2; uint8_t *dst2; int bw = 16, bh = 16; for (j = 0; j < h; j += 16) { dst2 = dst; bw   = 16; if (j + 16 > h) bh = h - j; for (i = 0; i < w; i += 16, dst2 += 16 * bpp) { if (bytestream2_get_bytes_left(gb) <= 0) { av_log(c->avctx, AV_LOG_ERROR, ""Premature end of data!\n""); return AVERROR_INVALIDDATA; } if (i + 16 > w) bw = w - i; flags = bytestream2_get_byte(gb); if (flags & HT_RAW) { if (bytestream2_get_bytes_left(gb) < bw * bh * bpp) { av_log(c->avctx, AV_LOG_ERROR, ""Premature end of data!\n""); return AVERROR_INVALIDDATA; } paint_raw(dst2, bw, bh, gb, bpp, c->bigendian, stride); } else { if (flags & HT_BKG) bg = vmnc_get_pixel(gb, bpp, c->bigendian); if (flags & HT_FG) fg = vmnc_get_pixel(gb, bpp, c->bigendian); rects = 0; if (flags & HT_SUB) rects = bytestream2_get_byte(gb); color = !!(flags & HT_CLR); paint_rect(dst2, 0, 0, bw, bh, bg, bpp, stride); if (bytestream2_get_bytes_left(gb) < rects * (color * bpp + 2)) { av_log(c->avctx, AV_LOG_ERROR, ""Premature end of data!\n""); return AVERROR_INVALIDDATA; } for (k = 0; k < rects; k++) { if (color) fg = vmnc_get_pixel(gb, bpp, c->bigendian); xy = bytestream2_get_byte(gb); wh = bytestream2_get_byte(gb); paint_rect(dst2, xy >> 4, xy & 0xF, (wh>>4)+1, (wh & 0xF)+1, fg, bpp, stride); } } } dst += stride * 16; } return 0; }"
"static u_char * ngx_http_v2_state_headers(ngx_http_v2_connection_t *h2c, u_char *pos, u_char *end) { size_t                     size; ngx_uint_t                 padded, priority, depend, dependency, excl, weight; ngx_uint_t                 status; ngx_http_v2_node_t        *node; ngx_http_v2_stream_t      *stream; ngx_http_v2_srv_conf_t    *h2scf; ngx_http_core_srv_conf_t  *cscf; ngx_http_core_loc_conf_t  *clcf; padded = h2c->state.flags & NGX_HTTP_V2_PADDED_FLAG; priority = h2c->state.flags & NGX_HTTP_V2_PRIORITY_FLAG; size = 0; if (padded) { size++; } if (priority) { size += sizeof(uint32_t) + 1; } if (h2c->state.length < size) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with incorrect length %uz"", h2c->state.length); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR); } if (h2c->state.length == size) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with empty header block""); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_SIZE_ERROR); } if (h2c->goaway) { ngx_log_debug0(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0, ""skipping http2 HEADERS frame""); return ngx_http_v2_state_skip(h2c, pos, end); } if ((size_t) (end - pos) < size) { return ngx_http_v2_state_save(h2c, pos, end, ngx_http_v2_state_headers); } h2c->state.length -= size; if (padded) { h2c->state.padding = *pos++; if (h2c->state.padding > h2c->state.length) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent padded HEADERS frame "" ""with incorrect length: %uz, padding: %uz"", h2c->state.length, h2c->state.padding); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } h2c->state.length -= h2c->state.padding; } depend = 0; excl = 0; weight = NGX_HTTP_V2_DEFAULT_WEIGHT; if (priority) { dependency = ngx_http_v2_parse_uint32(pos); depend = dependency & 0x7fffffff; excl = dependency >> 31; weight = pos[4] + 1; pos += sizeof(uint32_t) + 1; } ngx_log_debug4(NGX_LOG_DEBUG_HTTP, h2c->connection->log, 0, ""http2 HEADERS frame sid:%ui "" ""depends on %ui excl:%ui weight:%ui"", h2c->state.sid, depend, excl, weight); if (h2c->state.sid % 2 == 0 || h2c->state.sid <= h2c->last_sid) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame with incorrect identifier "" ""%ui, the last was %ui"", h2c->state.sid, h2c->last_sid); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } if (depend == h2c->state.sid) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent HEADERS frame for stream %ui "" ""with incorrect dependency"", h2c->state.sid); return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); } h2c->last_sid = h2c->state.sid; h2c->state.pool = ngx_create_pool(1024, h2c->connection->log); if (h2c->state.pool == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } cscf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx, ngx_http_core_module); h2c->state.header_limit = cscf->large_client_header_buffers.size * cscf->large_client_header_buffers.num; h2scf = ngx_http_get_module_srv_conf(h2c->http_connection->conf_ctx, ngx_http_v2_module); if (h2c->processing >= h2scf->concurrent_streams) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""concurrent streams exceeded %ui"", h2c->processing); status = NGX_HTTP_V2_REFUSED_STREAM; goto rst_stream; } if (!h2c->settings_ack && !(h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG) && h2scf->preread_size < NGX_HTTP_V2_DEFAULT_WINDOW) { ngx_log_error(NGX_LOG_INFO, h2c->connection->log, 0, ""client sent stream with data "" ""before settings were acknowledged""); status = NGX_HTTP_V2_REFUSED_STREAM; goto rst_stream; } node = ngx_http_v2_get_node_by_id(h2c, h2c->state.sid, 1); if (node == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } if (node->parent) { ngx_queue_remove(&node->reuse); h2c->closed_nodes--; } stream = ngx_http_v2_create_stream(h2c, 0); if (stream == NULL) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } h2c->state.stream = stream; stream->pool = h2c->state.pool; h2c->state.keep_pool = 1; stream->request->request_length = h2c->state.length; stream->in_closed = h2c->state.flags & NGX_HTTP_V2_END_STREAM_FLAG; stream->node = node; node->stream = stream; if (priority || node->parent == NULL) { node->weight = weight; ngx_http_v2_set_dependency(h2c, node, depend, excl); } clcf = ngx_http_get_module_loc_conf(h2c->http_connection->conf_ctx, ngx_http_core_module); if (clcf->keepalive_timeout == 0 || h2c->connection->requests >= clcf->keepalive_requests || ngx_current_msec - h2c->connection->start_time > clcf->keepalive_time) { h2c->goaway = 1; if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } } return ngx_http_v2_state_header_block(h2c, pos, end); rst_stream: if (ngx_http_v2_send_rst_stream(h2c, h2c->state.sid, status) != NGX_OK) { return ngx_http_v2_connection_error(h2c, NGX_HTTP_V2_INTERNAL_ERROR); } return ngx_http_v2_state_header_block(h2c, pos, end); }"
"void PackTmt::pack(OutputFile *fo) { big_relocs = 0; Packer::handleStub(fi, fo, adam_offset); const unsigned usize = ih.imagesize; const unsigned rsize = ih.relocsize; ibuf.alloc(usize + rsize + 128); obuf.allocForCompression(usize + rsize + 128); MemBuffer mb_wrkmem; mb_wrkmem.alloc(rsize + EXTRA_INFO);     SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem); fi->seek(adam_offset + sizeof(ih), SEEK_SET); fi->readx(ibuf, usize); fi->readx(wrkmem + 4, rsize); const unsigned overlay = file_size - fi->tell(); if (find_le32(ibuf, 128, get_le32(""UPX "")) >= 0) throwAlreadyPacked(); if (rsize == 0) throwCantPack(""file is already compressed with another packer""); checkOverlay(overlay); unsigned relocsize = 0; { for (unsigned ic = 4; ic <= rsize; ic += 4) set_le32(wrkmem + ic, get_le32(wrkmem + ic) - 4); relocsize = optimizeReloc32(wrkmem + 4, rsize / 4, wrkmem, ibuf, file_size, true, &big_relocs); } wrkmem[relocsize++] = 0; set_le32(wrkmem + relocsize, ih.entry);     relocsize += 4; set_le32(wrkmem + relocsize, relocsize + 4); relocsize += 4; memcpy(ibuf + usize, wrkmem, relocsize); ph.u_len = usize + relocsize; Filter ft(ph.level); ft.buf_len = usize; upx_compress_config_t cconf; cconf.reset(); cconf.conf_lzma.max_num_probs = 1846 + (768 << 4);     compressWithFilters(&ft, 512, &cconf); const unsigned lsize = getLoaderSize(); const unsigned s_point = getLoaderSection(""TMTMAIN1""); int e_len = getLoaderSectionStart(""TMTCUTPO""); const unsigned d_len = lsize - e_len; assert(e_len > 0 && s_point > 0); linker->defineSymbol(""original_entry"", ih.entry); defineDecompressorSymbols(); defineFilterSymbols(&ft); linker->defineSymbol(""bytes_to_copy"", ph.c_len + d_len); linker->defineSymbol(""copy_dest"", 0u - (ph.u_len + ph.overlap_overhead + d_len - 1)); linker->defineSymbol(""copy_source"", ph.c_len + lsize - 1); linker->defineSymbol(""TMTCUTPO"", ph.u_len + ph.overlap_overhead); relocateLoader(); MemBuffer loader(lsize); memcpy(loader, getLoader(), lsize); patchPackHeader(loader, e_len); memcpy(&oh, &ih, sizeof(oh)); oh.imagesize = ph.c_len + lsize;     oh.entry = s_point;                  oh.relocsize = 4; fo->write(&oh, sizeof(oh)); fo->write(loader, e_len); fo->write(obuf, ph.c_len); fo->write(loader + lsize - d_len, d_len);     char rel_entry[4]; set_le32(rel_entry, 5 + s_point); fo->write(rel_entry, sizeof(rel_entry)); verifyOverlappingDecompression(); copyOverlay(fo, overlay, obuf); if (!checkFinalCompressionRatio(fo)) throwNotCompressible(); }"
"void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting) { const struct k_clock *kc = timr->kclock; ktime_t now, remaining, iv; struct timespec64 ts64; bool sig_none; sig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE; iv = timr->it_interval; if (iv) { cur_setting->it_interval = ktime_to_timespec64(iv); } else if (!timr->it_active) { if (!sig_none) return; } kc->clock_get(timr->it_clock, &ts64); now = timespec64_to_ktime(ts64); if (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none)) timr->it_overrun += kc->timer_forward(timr, now); remaining = kc->timer_remaining(timr, now); if (remaining <= 0) { if (!sig_none) cur_setting->it_value.tv_nsec = 1; } else { cur_setting->it_value = ktime_to_timespec64(remaining); } }"
"void readSampleCountForLineBlock(InputStreamMutex* streamData, DeepScanLineInputFile::Data* data, int lineBlockId) { streamData->is->seekg(data->lineOffsets[lineBlockId]); if (isMultiPart(data->version)) { int partNumber; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, partNumber); if (partNumber != data->partNumber) throw IEX_NAMESPACE::ArgExc(""Unexpected part number.""); } int minY; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, minY); if (minY != data->minY + lineBlockId * data->linesInBuffer) throw IEX_NAMESPACE::ArgExc(""Unexpected data block y coordinate.""); int maxY; maxY = min(minY + data->linesInBuffer - 1, data->maxY); uint64_t sampleCountTableDataSize; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, sampleCountTableDataSize); if(sampleCountTableDataSize>static_cast<uint64_t>(data->maxSampleCountTableSize)) { THROW (IEX_NAMESPACE::ArgExc, ""Bad sampleCountTableDataSize read from chunk ""<< lineBlockId << "": expected "" << data->maxSampleCountTableSize << "" or less, got ""<< sampleCountTableDataSize); } uint64_t packedDataSize; uint64_t unpackedDataSize; OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, packedDataSize); OPENEXR_IMF_INTERNAL_NAMESPACE::Xdr::read <OPENEXR_IMF_INTERNAL_NAMESPACE::StreamIO> (*streamData->is, unpackedDataSize); int compressorMaxDataSize = std::numeric_limits<int>::max(); if (sampleCountTableDataSize > uint64_t(compressorMaxDataSize)) { THROW (IEX_NAMESPACE::ArgExc, ""This version of the library does not "" << ""support the allocation of data with size  > "" << compressorMaxDataSize << "" file table size    :"" << sampleCountTableDataSize << "".\n""); } streamData->is->read(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize)); const char* readPtr; if (sampleCountTableDataSize < static_cast<uint64_t>(data->maxSampleCountTableSize)) { if(!data->sampleCountTableComp) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline data corrupt at chunk "" << lineBlockId << "" (sampleCountTableDataSize error)""); } data->sampleCountTableComp->uncompress(data->sampleCountTableBuffer, static_cast<int>(sampleCountTableDataSize), minY, readPtr); } else readPtr = data->sampleCountTableBuffer; char* base = data->sampleCountSliceBase; int xStride = data->sampleCountXStride; int yStride = data->sampleCountYStride; size_t cumulative_total_samples=0; for (int y = minY; y <= maxY; y++) { int yInDataWindow = y - data->minY; data->lineSampleCount[yInDataWindow] = 0; int lastAccumulatedCount = 0; for (int x = data->minX; x <= data->maxX; x++) { int accumulatedCount, count; Xdr::read <CharPtrIO> (readPtr, accumulatedCount); if (accumulatedCount < lastAccumulatedCount) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "" (negative sample count detected)""); } count = accumulatedCount - lastAccumulatedCount; lastAccumulatedCount = accumulatedCount; data->sampleCount[yInDataWindow][x - data->minX] = count; data->lineSampleCount[yInDataWindow] += count; sampleCount(base, xStride, yStride, x, y) = count; } cumulative_total_samples+=data->lineSampleCount[yInDataWindow]; if(cumulative_total_samples*data->combinedSampleSize > unpackedDataSize) { THROW(IEX_NAMESPACE::ArgExc,""Deep scanline sampleCount data corrupt at chunk "" << lineBlockId << "": pixel data only contains "" << unpackedDataSize  << "" bytes of data but table references at least "" << cumulative_total_samples*data->combinedSampleSize << "" bytes of sample data"" );             } data->gotSampleCount[y - data->minY] = true; } }"
"static MagickBooleanType WriteGROUP4Image(const ImageInfo *image_info, Image *image) { char filename[MaxTextExtent]; FILE *file; Image *huffman_image; ImageInfo *write_info; int unique_file; MagickBooleanType status; register ssize_t i; ssize_t count; TIFF *tiff; toff_t *byte_count, strip_size; unsigned char *buffer; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception); if (status == MagickFalse) return(status); huffman_image=CloneImage(image,0,0,MagickTrue,&image->exception); if (huffman_image == (Image *) NULL) { (void) CloseBlob(image); return(MagickFalse); } huffman_image->endian=MSBEndian; file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(filename); if (unique_file != -1) file=fdopen(unique_file,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) { ThrowFileException(&image->exception,FileOpenError, ""UnableToCreateTemporaryFile"",filename); return(MagickFalse); } (void) FormatLocaleString(huffman_image->filename,MaxTextExtent,""tiff:%s"", filename); (void) SetImageType(huffman_image,BilevelType); write_info=CloneImageInfo((ImageInfo *) NULL); SetImageInfoFile(write_info,file); (void) SetImageType(image,BilevelType); (void) SetImageDepth(image,1); write_info->compression=Group4Compression; write_info->type=BilevelType; (void) SetImageOption(write_info,""quantum:polarity"",""min-is-white""); status=WriteTIFFImage(write_info,huffman_image); (void) fflush(file); write_info=DestroyImageInfo(write_info); if (status == MagickFalse) { InheritException(&image->exception,&huffman_image->exception); huffman_image=DestroyImage(huffman_image); (void) fclose(file); (void) RelinquishUniqueFileResource(filename); return(MagickFalse); } tiff=TIFFOpen(filename,""rb""); if (tiff == (TIFF *) NULL) { huffman_image=DestroyImage(huffman_image); (void) fclose(file); (void) RelinquishUniqueFileResource(filename); ThrowFileException(&image->exception,FileOpenError,""UnableToOpenFile"", image_info->filename); return(MagickFalse); } if (TIFFGetField(tiff,TIFFTAG_STRIPBYTECOUNTS,&byte_count) != 1) { TIFFClose(tiff); huffman_image=DestroyImage(huffman_image); (void) fclose(file); (void) RelinquishUniqueFileResource(filename); return(MagickFalse); } strip_size=byte_count[0]; for (i=1; i < (ssize_t) TIFFNumberOfStrips(tiff); i++) if (byte_count[i] > strip_size) strip_size=byte_count[i]; buffer=(unsigned char *) AcquireQuantumMemory((size_t) strip_size, sizeof(*buffer)); if (buffer == (unsigned char *) NULL) { TIFFClose(tiff); huffman_image=DestroyImage(huffman_image); (void) fclose(file); (void) RelinquishUniqueFileResource(filename); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image_info->filename); } for (i=0; i < (ssize_t) TIFFNumberOfStrips(tiff); i++) { count=(ssize_t) TIFFReadRawStrip(tiff,(uint32) i,buffer,strip_size); if (WriteBlob(image,(size_t) count,buffer) != count) status=MagickFalse; } buffer=(unsigned char *) RelinquishMagickMemory(buffer); TIFFClose(tiff); huffman_image=DestroyImage(huffman_image); (void) fclose(file); (void) RelinquishUniqueFileResource(filename); (void) CloseBlob(image); return(status); }"
"void UrlRewrite::PerformACLFiltering(HttpTransact::State *s, url_mapping *map) { if (unlikely(!s || s->acl_filtering_performed || !s->client_connection_enabled)) { return; } s->acl_filtering_performed = true;  if (map->filter) { int method               = s->hdr_info.client_request.method_get_wksidx(); int method_wksidx        = (method != -1) ? (method - HTTP_WKSIDX_CONNECT) : -1; bool client_enabled_flag = true; ink_release_assert(ats_is_ip(&s->client_info.src_addr)); for (acl_filter_rule *rp = map->filter; rp && client_enabled_flag; rp = rp->next) { bool match = true; if (rp->method_restriction_enabled) { if (method_wksidx != -1) { match = rp->standard_method_lookup[method_wksidx]; } else if (!rp->nonstandard_methods.empty()) { match = false; } else { int method_str_len; const char *method_str = s->hdr_info.client_request.method_get(&method_str_len); match                  = rp->nonstandard_methods.count(std::string(method_str, method_str_len)); } } if (match && rp->src_ip_valid) { match = false; for (int j = 0; j < rp->src_ip_cnt && !match; j++) { bool in_range = rp->src_ip_array[j].contains(s->client_info.src_addr); if (rp->src_ip_array[j].invert) { if (!in_range) { match = true; } } else { if (in_range) { match = true; } } } } if (match && rp->in_ip_valid) { Debug(""url_rewrite"", ""match was true and we have specified a in_ip field""); match = false; for (int j = 0; j < rp->in_ip_cnt && !match; j++) { IpEndpoint incoming_addr; incoming_addr.assign(s->state_machine->ua_txn->get_netvc()->get_local_addr()); if (is_debug_tag_set(""url_rewrite"")) { char buf1[128], buf2[128], buf3[128]; ats_ip_ntop(incoming_addr, buf1, sizeof(buf1)); ats_ip_ntop(rp->in_ip_array[j].start, buf2, sizeof(buf2)); ats_ip_ntop(rp->in_ip_array[j].end, buf3, sizeof(buf3)); Debug(""url_rewrite"", ""Trying to match incoming address %s in range %s - %s."", buf1, buf2, buf3); } bool in_range = rp->in_ip_array[j].contains(incoming_addr); if (rp->in_ip_array[j].invert) { if (!in_range) { match = true; } } else { if (in_range) { match = true; } } } } if (rp->internal) { match = s->state_machine->ua_txn->get_netvc()->get_is_internal_request(); Debug(""url_rewrite"", ""%s an internal request"", match ? ""matched"" : ""didn't match""); } if (match && client_enabled_flag) {         Debug(""url_rewrite"", ""matched ACL filter rule, %s request"", rp->allow_flag ? ""allowing"" : ""denying""); client_enabled_flag = rp->allow_flag ? true : false; } else { if (!client_enabled_flag) { Debug(""url_rewrite"", ""Previous ACL filter rule denied request, continuing to deny it""); } else { Debug(""url_rewrite"", ""did NOT match ACL filter rule, %s request"", rp->allow_flag ? ""denying"" : ""allowing""); client_enabled_flag = rp->allow_flag ? false : true; } } }  s->client_connection_enabled = client_enabled_flag; } }"
"static int da9150_charger_remove(struct platform_device *pdev) { struct da9150_charger *charger = platform_get_drvdata(pdev); int irq; irq = platform_get_irq_byname(pdev, ""CHG_VBUS""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_VFAULT""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_TJUNC""); free_irq(irq, charger); irq = platform_get_irq_byname(pdev, ""CHG_STATUS""); free_irq(irq, charger); if (!IS_ERR_OR_NULL(charger->usb_phy)) usb_unregister_notifier(charger->usb_phy, &charger->otg_nb); power_supply_unregister(charger->battery); power_supply_unregister(charger->usb); iio_channel_release(charger->ibus_chan); iio_channel_release(charger->vbus_chan); iio_channel_release(charger->tjunc_chan); iio_channel_release(charger->vbat_chan); return 0; }"
"WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op) { ih264d_create_op_t *ps_create_op; WORD32 ret; ps_create_op = (ih264d_create_op_t *)pv_api_op; ps_create_op->s_ivd_create_op_t.u4_error_code = 0; ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op); if((IV_FAIL == ret) && (NULL != dec_hdl)) { ih264d_free_static_bufs(dec_hdl); ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED; ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR; return IV_FAIL; } return IV_SUCCESS; }"
"int wolfSSH_SFTP_RecvSetSTAT(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) { WS_SFTP_FILEATRB atr; char* name = NULL; int   ret = WS_SUCCESS; word32 sz; word32 idx = 0; byte*  out = NULL; word32 outSz = 0; char  suc[] = ""Set Attirbutes""; char  ser[] = ""Unable to set attributes error""; char  per[] = ""Unable to parse attributes error""; char* res   = suc; byte  type  = WOLFSSH_FTP_OK; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_SETSTAT""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz) { return WS_BUFFER_E; } name = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (name == NULL) { return WS_MEMORY_E; } WMEMCPY(name, data + idx, sz); idx += sz; name[sz] = '\0'; if (wolfSSH_CleanPath(ssh, name) < 0) { ret = WS_FATAL_ERROR; } if (ret == WS_SUCCESS && SFTP_ParseAtributes_buffer(ssh, &atr, data, &idx, maxSz) != 0) { type = WOLFSSH_FTP_FAILURE; res  = per; ret  = WS_BAD_FILE_E; } if (ret == WS_SUCCESS && (ret = SFTP_SetFileAttributes(ssh, name, &atr)) != WS_SUCCESS) { WLOG(WS_LOG_SFTP, ""Unable to get set attributes of file/directory""); type = WOLFSSH_FTP_FAILURE; res  = ser; ret  = WS_BAD_FILE_E; } WFREE(name, ssh->ctx->heap, DYNTYPE_BUFFER); if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", NULL, &outSz) != WS_SIZE_ONLY) { return WS_FATAL_ERROR; } out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }"
"void pointZZ_pAdd(PointZZ_p * rop, const PointZZ_p * op1, const PointZZ_p * op2, const CurveZZ_p * curve) { mpz_t xdiff, ydiff, lambda; mpz_inits(xdiff, ydiff, lambda, NULL); mpz_sub(ydiff, op2->y, op1->y); mpz_sub(xdiff, op2->x, op1->x); mpz_invert(xdiff, xdiff, curve->p);      mpz_mul(lambda, ydiff, xdiff); mpz_mod(lambda, lambda, curve->p); mpz_mul(rop->x, lambda, lambda); mpz_sub(rop->x, rop->x, op1->x); mpz_sub(rop->x, rop->x, op2->x); mpz_mod(rop->x, rop->x, curve->p); mpz_sub(rop->y, op1->x, rop->x); mpz_mul(rop->y, lambda, rop->y); mpz_sub(rop->y, rop->y, op1->y); mpz_mod(rop->y, rop->y, curve->p); mpz_clears(xdiff, ydiff, lambda, NULL); }"
"GF_Err afra_box_read(GF_Box *s, GF_BitStream *bs) { unsigned int i; GF_AdobeFragRandomAccessBox *ptr = (GF_AdobeFragRandomAccessBox *)s; ISOM_DECREASE_SIZE(ptr, 9) ptr->long_ids = gf_bs_read_int(bs, 1); ptr->long_offsets = gf_bs_read_int(bs, 1); ptr->global_entries = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 5); ptr->time_scale = gf_bs_read_u32(bs); ptr->entry_count = gf_bs_read_u32(bs); if (ptr->size / ( (ptr->long_offsets ? 16 : 12) ) < ptr->entry_count) return GF_ISOM_INVALID_FILE; for (i=0; i<ptr->entry_count; i++) { GF_AfraEntry *ae = gf_malloc(sizeof(GF_AfraEntry)); if (!ae) return GF_OUT_OF_MEM; gf_list_insert(ptr->local_access_entries, ae, i); ISOM_DECREASE_SIZE(ptr, 8) ae->time = gf_bs_read_u64(bs); if (ptr->long_offsets) { ISOM_DECREASE_SIZE(ptr, 8) ae->offset = gf_bs_read_u64(bs); } else { ISOM_DECREASE_SIZE(ptr, 4) ae->offset = gf_bs_read_u32(bs); } } if (ptr->global_entries) { ISOM_DECREASE_SIZE(ptr, 4) ptr->global_entry_count = gf_bs_read_u32(bs); for (i=0; i<ptr->global_entry_count; i++) { GF_GlobalAfraEntry *ae = gf_malloc(sizeof(GF_GlobalAfraEntry)); if (!ae) return GF_OUT_OF_MEM; gf_list_insert(ptr->global_access_entries, ae, i); ISOM_DECREASE_SIZE(ptr, 8) ae->time = gf_bs_read_u64(bs); if (ptr->long_ids) { ISOM_DECREASE_SIZE(ptr, 8) ae->segment = gf_bs_read_u32(bs); ae->fragment = gf_bs_read_u32(bs); } else { ISOM_DECREASE_SIZE(ptr, 4) ae->segment = gf_bs_read_u16(bs); ae->fragment = gf_bs_read_u16(bs); } if (ptr->long_offsets) { ISOM_DECREASE_SIZE(ptr, 16) ae->afra_offset = gf_bs_read_u64(bs); ae->offset_from_afra = gf_bs_read_u64(bs); } else { ISOM_DECREASE_SIZE(ptr, 8) ae->afra_offset = gf_bs_read_u32(bs); ae->offset_from_afra = gf_bs_read_u32(bs); } } } return GF_OK; }"
"StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs, const OpDef& op_def) { FullTypeDef ft; ft.set_type_id(TFT_PRODUCT); for (int i = 0; i < op_def.output_arg_size(); i++) { auto* t = ft.add_args(); *t = op_def.output_arg(i).experimental_full_type(); for (int j = 0; j < t->args_size(); j++) { auto* arg = t->mutable_args(i); if (arg->type_id() == TFT_VAR) { const auto* attr = attrs.Find(arg->s()); DCHECK(attr != nullptr); if (attr->value_case() == AttrValue::kList) { const auto& attr_list = attr->list(); arg->set_type_id(TFT_PRODUCT); for (int i = 0; i < attr_list.type_size(); i++) { map_dtype_to_tensor(attr_list.type(i), arg->add_args()); } } else if (attr->value_case() == AttrValue::kType) { map_dtype_to_tensor(attr->type(), arg); } else { return Status(error::UNIMPLEMENTED, absl::StrCat(""unknown attribute type"", attrs.DebugString(), "" key="", arg->s())); } arg->clear_s(); } } } return ft; }"
"void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) { size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom; DCHECK_LT(newCapacity, UINT32_MAX); DCHECK(!isSharedOne()); if (headroom() + tailroom() >= minHeadroom + minTailroom) { uint8_t* newData = writableBuffer() + minHeadroom; memmove(newData, data_, length_); data_ = newData; return; } size_t newAllocatedCapacity = 0; uint8_t* newBuffer = nullptr; std::size_t newHeadroom = 0; std::size_t oldHeadroom = headroom(); SharedInfo* info = sharedInfo(); bool useHeapFullStorage = info && info->useHeapFullStorage; if (info && (info->freeFn == nullptr) && length_ != 0 && oldHeadroom >= minHeadroom) { size_t headSlack = oldHeadroom - minHeadroom; newAllocatedCapacity = goodExtBufferSize(newCapacity + headSlack); if (usingJEMalloc()) { if (headSlack * 4 <= newCapacity) { size_t allocatedCapacity = capacity() + sizeof(SharedInfo); void* p = buf_; if (allocatedCapacity >= jemallocMinInPlaceExpandable) { if (xallocx(p, newAllocatedCapacity, 0, 0) == newAllocatedCapacity) { if (io_buf_free_cb) { io_buf_free_cb(p, reinterpret_cast<size_t>(info->userData)); } newBuffer = static_cast<uint8_t*>(p); newHeadroom = oldHeadroom; info->userData = reinterpret_cast<void*>(newAllocatedCapacity); if (io_buf_alloc_cb) { io_buf_alloc_cb(newBuffer, newAllocatedCapacity); } } } } } else {       size_t copySlack = capacity() - length_; if (copySlack * 2 <= length_) { void* p = realloc(buf_, newAllocatedCapacity); if (UNLIKELY(p == nullptr)) { throw_exception<std::bad_alloc>(); } newBuffer = static_cast<uint8_t*>(p); newHeadroom = oldHeadroom; } } } if (newBuffer == nullptr) { newAllocatedCapacity = goodExtBufferSize(newCapacity); newBuffer = static_cast<uint8_t*>(checkedMalloc(newAllocatedCapacity)); if (length_ > 0) { assert(data_ != nullptr); memcpy(newBuffer + minHeadroom, data_, length_); } if (sharedInfo()) { freeExtBuffer(); } newHeadroom = minHeadroom; } std::size_t cap; initExtBuffer(newBuffer, newAllocatedCapacity, &info, &cap); if (flags() & kFlagFreeSharedInfo) { delete sharedInfo(); } else { if (useHeapFullStorage) { SharedInfo::releaseStorage(sharedInfo()); } } setFlagsAndSharedInfo(0, info); capacity_ = cap; buf_ = newBuffer; data_ = newBuffer + newHeadroom; }"
"static void print_insn32 (bfd_vma pc, disassemble_info *info, uint32_t insn) { int op = OP6 (insn); const int rt = RT5 (insn); const int ra = RA5 (insn); const int rb = RB5 (insn); const int imm15s = IMMS (insn, 15); const int imm15u = IMMU (insn, 15); uint32_t shift; fprintf_ftype func = info->fprintf_func; void *stream = info->stream; switch (op) { case 0x0: case 0x1: case 0x2: case 0x3: case 0x8: case 0x9: case 0xa: case 0xb: case 0x10: case 0x11: case 0x12: shift = op & 0x3; func (stream, ""%s\t%s, [%s + #%d]"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift); return; case 0x4: case 0x5: case 0x6: case 0x7: case 0xc: case 0xd: case 0xe: case 0xf: case 0x14: case 0x15: case 0x16: shift = op & 0x3; func (stream, ""%s\t%s, [%s], #%d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s << shift); return; case 0x13: { const char *subtype = ""???""; char wd = 'w'; shift = 2; if (rt & 0x10) { wd = 'd'; shift = 3; } if ((rt & 0xf) < ARRAY_SIZE (keyword_dpref)) subtype = keyword_dpref[rt & 0xf]; func (stream, ""%s.%c\t%s, [%s + #%d]"", mnemonic_op6[op], wd, subtype, gpr_map[ra], imm15s << shift); } return; case 0x17: func (stream, ""%s\t%s, [+ %d]"", ((insn & __BIT (19)) ? ""lbsi.gp"" : ""lbi.gp""), gpr_map[rt], IMMS (insn, 19)); return; case 0x18: case 0x19: case 0x1a: case 0x1b: if (__GF (insn, 13, 2) == 0) { char ls = (op & 1) ? 's' : 'l'; char wd = (op & 2) ? 'd' : 's'; if (insn & __BIT (12)) { func (stream, ""f%c%ci.bi\t$f%c%d, [%s], %d"", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2); } else { func (stream, ""f%c%ci\t$f%c%d, [%s + %d]"", ls, wd, wd, rt, gpr_map[ra], IMMS (insn, 12) << 2); } } else { char ls = (op & 1) ? 's' : 'l'; char wd = (op & 2) ? 'd' : 'w'; int cp = __GF (insn, 13, 2); if (insn & __BIT (12)) { func (stream, ""cp%c%ci\tcp%d, $cpr%d, [%s], %d"", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2); } else { func (stream, ""cp%c%ci\tcp%d, $cpr%d, [%s + %d]"", ls, wd, cp, rt, gpr_map[ra], IMMS (insn, 12) << 2); } } return; case 0x1c: print_insn32_mem (pc, info, insn); return; case 0x1d: { int enb4 = __GF (insn, 6, 4); char ls = (insn & __BIT (5)) ? 's' : 'l'; char ab = (insn & __BIT (4)) ? 'a' : 'b'; char *di = (insn & __BIT (3)) ? ""d"" : ""i""; char *m = (insn & __BIT (2)) ? ""m"" : """"; static const char *s[] = {"""", ""a"", ""zb"", ""?""}; if ((insn & 0x3) == 2) di = """"; func (stream, ""%cmw%s.%c%s%s\t%s, [%s], %s, 0x%x"", ls, s[insn & 0x3], ab, di, m, gpr_map[rt], gpr_map[ra], gpr_map[rb], enb4); } return; case 0x1e: op = __GF (insn, 17, 3); switch (op) { case 0: case 1: case 2: case 3: case 4: case 5: func (stream, ""%s\t%s, [+ %d]"", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 18) << 1); return; case 6: case 7: func (stream, ""%s\t%s, [+ %d]"", mnemonic_hwgp[op], gpr_map[rt], IMMS (insn, 17) << 2); return; } return; case 0x1f: if (insn & __BIT (19)) func (stream, ""addi.gp\t%s, %d"", gpr_map[rt], IMMS (insn, 19)); else func (stream, ""sbi.gp\t%s, [+ %d]"", gpr_map[rt], IMMS (insn, 19)); return; case 0x20: print_insn32_alu1 (pc, info, insn); return; case 0x21: print_insn32_alu2 (pc, info, insn); return; case 0x22: func (stream, ""movi\t%s, %d"", gpr_map[rt], IMMS (insn, 20)); return; case 0x23: func (stream, ""sethi\t%s, 0x%x"", gpr_map[rt], IMMU (insn, 20)); return; case 0x24: if (info->flags & INSN_HAS_RELOC) pc = 0; func (stream, ""%s\t"", ((insn & __BIT (24)) ? ""jal"" : ""j"")); info->print_address_func ((IMMS (insn, 24) << 1) + pc, info); return; case 0x25: print_insn32_jreg (pc, info, insn); return; case 0x26: func (stream, ""%s\t%s, %s, "", ((insn & __BIT (14)) ? ""bne"" : ""beq""), gpr_map[rt], gpr_map[ra]); info->print_address_func ((IMMS (insn, 14) << 1) + pc, info); return; case 0x27: func (stream, ""%s\t%s, "", mnemonic_br2[__GF (insn, 16, 4)], gpr_map[rt]); info->print_address_func ((IMMS (insn, 16) << 1) + pc, info); return; case 0x28: case 0x2e: case 0x2f: case 0x29: func (stream, ""%s\t%s, %s, %d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15s); return; case 0x2a: case 0x2b: case 0x2c: case 0x33: func (stream, ""%s\t%s, %s, %d"", mnemonic_op6[op], gpr_map[rt], gpr_map[ra], imm15u); return; case 0x2d: func (stream, ""%s\t%s, %d, "", ((insn & __BIT (19)) ? ""bnec"" : ""beqc""), gpr_map[rt], __SEXT (__GF (insn, 8, 11), 11)); info->print_address_func ((IMMS (insn, 8) << 1) + pc, info); return; case 0x32: print_insn32_misc (pc, info, insn); return; case 0x35: print_insn32_fpu (pc, info, insn); return; } }"
"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp) { struct sctp_association *asoc = sctp_id2assoc(sk, id); struct sctp_sock *sp = sctp_sk(sk); struct socket *sock; int err = 0; if (!asoc) return -EINVAL; if (waitqueue_active(&asoc->wait)) return -EBUSY; if (!sctp_style(sk, UDP)) return -EINVAL; err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock); if (err < 0) return err; sctp_copy_sock(sock->sk, sk, asoc); sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk); sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH); *sockp = sock; return err; }"
void detachThreadLocals() { resetControlMessages_.cancelTimeout(); resetDirectErrors_.cancelTimeout(); timer_ = nullptr; numControlMsgsInCurrentInterval_ = 0; numDirectErrorHandlingInCurrentInterval_ = 0; }
"BOOL SQLWriteFileDSN(LPCSTRpszFileName, LPCSTRpszAppName, LPCSTRpszKeyName, LPCSTRpszString ) { HINIhIni; charszFileName[ODBC_FILENAME_MAX+1]; if ( pszFileName[0] == '/' ) { strncpy( szFileName, sizeof(szFileName) - 5, pszFileName ); } else { char szPath[ODBC_FILENAME_MAX+1]; *szPath = '\0'; _odbcinst_FileINI( szPath ); snprintf( szFileName, sizeof(szFileName) - 5, ""%s/%s"", szPath, pszFileName ); } if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, "".dsn"" )) { strcat( szFileName, "".dsn"" ); } #ifdef __OS2__ if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS ) #else if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE ) != INI_SUCCESS ) #endif { inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, """" ); return FALSE; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS ) { iniObjectDelete( hIni ); } } else if( pszString == NULL ) { if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS ) { iniPropertyDelete( hIni ); } } else { if ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS ) { iniObjectInsert( hIni, (char *)pszAppName ); } if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS ) { iniObjectSeek( hIni, (char *)pszAppName ); iniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString ); } else { iniObjectSeek( hIni, (char *)pszAppName ); iniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString ); } } if ( iniCommit( hIni ) != INI_SUCCESS ) { iniClose( hIni ); inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, """" ); return FALSE; } iniClose( hIni ); return TRUE; }"
"static int xenmem_add_to_physmap_batch(struct domain *d, struct xen_add_to_physmap_batch *xatpb, unsigned int extent) { if ( unlikely(xatpb->size < extent) ) return -EILSEQ; if ( unlikely(xatpb->size == extent) ) return extent ? -EILSEQ : 0; if ( !guest_handle_subrange_okay(xatpb->idxs, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->gpfns, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->errs, extent, xatpb->size - 1) ) return -EFAULT; while ( xatpb->size > extent ) { xen_ulong_t idx; xen_pfn_t gpfn; int rc; if ( unlikely(__copy_from_guest_offset(&idx, xatpb->idxs, extent, 1)) || unlikely(__copy_from_guest_offset(&gpfn, xatpb->gpfns, extent, 1)) ) return -EFAULT; rc = xenmem_add_to_physmap_one(d, xatpb->space, xatpb->u, idx, _gfn(gpfn)); if ( unlikely(__copy_to_guest_offset(xatpb->errs, extent, &rc, 1)) ) return -EFAULT; if ( xatpb->size > ++extent && hypercall_preempt_check() ) return extent; } return 0; }"
"mp_err mp_2expt(mp_int *a, int b) { mp_err    err; mp_zero(a); if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } a->used = (b / MP_DIGIT_BIT) + 1; a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT); return MP_OKAY; }"
void vcpu_destroy(struct vcpu *v) { xfree(v->arch.vm_event); v->arch.vm_event = NULL; vcpu_destroy_fpu(v); if ( !is_idle_domain(v->domain) ) vpmu_destroy(v); if ( is_hvm_vcpu(v) ) hvm_vcpu_destroy(v); else pv_vcpu_destroy(v); }
"static void ParseCommon(map_string_t *settings, const char *conf_filename) { const char *value; value = get_map_string_item_or_NULL(settings, ""WatchCrashdumpArchiveDir""); if (value) { g_settings_sWatchCrashdumpArchiveDir = xstrdup(value); remove_map_string_item(settings, ""WatchCrashdumpArchiveDir""); } value = get_map_string_item_or_NULL(settings, ""MaxCrashReportsSize""); if (value) { char *end; errno = 0; unsigned long ul = strtoul(value, &end, 10); if (errno || end == value || *end != '\0' || ul > INT_MAX) error_msg(""Error parsing %s setting: '%s'"", ""MaxCrashReportsSize"", value); else g_settings_nMaxCrashReportsSize = ul; remove_map_string_item(settings, ""MaxCrashReportsSize""); } value = get_map_string_item_or_NULL(settings, ""DumpLocation""); if (value) { g_settings_dump_location = xstrdup(value); remove_map_string_item(settings, ""DumpLocation""); } else g_settings_dump_location = xstrdup(DEFAULT_DUMP_LOCATION); value = get_map_string_item_or_NULL(settings, ""DeleteUploaded""); if (value) { g_settings_delete_uploaded = string_to_bool(value); remove_map_string_item(settings, ""DeleteUploaded""); } value = get_map_string_item_or_NULL(settings, ""AutoreportingEnabled""); if (value) { g_settings_autoreporting = string_to_bool(value); remove_map_string_item(settings, ""AutoreportingEnabled""); } value = get_map_string_item_or_NULL(settings, ""AutoreportingEvent""); if (value) { g_settings_autoreporting_event = xstrdup(value); remove_map_string_item(settings, ""AutoreportingEvent""); } else g_settings_autoreporting_event = xstrdup(""report_uReport""); value = get_map_string_item_or_NULL(settings, ""ShortenedReporting""); if (value) { g_settings_shortenedreporting = string_to_bool(value); remove_map_string_item(settings, ""ShortenedReporting""); } else g_settings_shortenedreporting = 0; GHashTableIter iter; const char *name; init_map_string_iter(&iter, settings); while (next_map_string_iter(&iter, &name, &value)) { error_msg(""Unrecognized variable '%s' in '%s'"", name, conf_filename); } }"
"njs_token_t njs_regexp_literal(njs_vm_t *vm, njs_parser_t *parser, njs_value_t *value) { u_char                *p; njs_str_t             text; njs_lexer_t           *lexer; njs_regexp_flags_t    flags; njs_regexp_pattern_t  *pattern; lexer = parser->lexer; for (p = lexer->start; p < lexer->end; p++) { switch (*p) { case '\n': case '\r': goto failed; case '[': while (++p < lexer->end && *p != ']') { switch (*p) { case '\n': case '\r': goto failed; case '\\': if (++p < lexer->end && (*p == '\n' || *p == '\r')) { goto failed; } break; } } break; case '\\': if (++p < lexer->end && (*p == '\n' || *p == '\r')) { goto failed; } break; case '/': text.start = lexer->start; text.length = p - text.start; p++; lexer->start = p; flags = njs_regexp_flags(&p, lexer->end, 0); if (njs_slow_path(flags < 0)) { njs_parser_syntax_error(vm, parser, ""Invalid RegExp flags \""%*s\"""", p - lexer->start, lexer->start); return NJS_TOKEN_ILLEGAL; } lexer->start = p; pattern = njs_regexp_pattern_create(vm, text.start, text.length, flags); if (njs_slow_path(pattern == NULL)) { return NJS_TOKEN_ILLEGAL; } value->data.u.data = pattern; return NJS_TOKEN_REGEXP; } } failed: njs_parser_syntax_error(vm, parser, ""Unterminated RegExp \""%*s\"""", p - (lexer->start - 1), lexer->start - 1); return NJS_TOKEN_ILLEGAL; }"
"static int LZWDecode(TIFF* tif, uint8_t* op0, tmsize_t occ0, uint16_t s) { static const char module[] = ""LZWDecode""; LZWCodecState *sp = DecoderState(tif); uint8_t *op = (uint8_t*) op0; tmsize_t occ = occ0; uint8_t *bp; long nbits, nextbits, nbitsmask; WordType nextdata; code_t *free_entp, *maxcodep, *oldcodep; (void) s; assert(sp != NULL); assert(sp->dec_codetab != NULL); if (sp->dec_restart) { tmsize_t residue; code_t* codep = sp->dec_codep; residue = codep->length - sp->dec_restart; if (residue > occ) { sp->dec_restart += occ; do { codep = codep->next; } while (--residue > occ && codep); if (codep) { uint8_t* tp = op + occ; do { *--tp = codep->value; codep = codep->next; } while (--occ && codep); } return (1); } op += residue; occ -= residue; uint8_t* tp = op; do { *--tp = codep->value; codep = codep->next; } while (--residue && codep); sp->dec_restart = 0; } bp = (uint8_t*)tif->tif_rawcp; sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3); uint64_t dec_bitsleft = sp->dec_bitsleft; nbits = sp->lzw_nbits; nextdata = sp->lzw_nextdata; nextbits = sp->lzw_nextbits; nbitsmask = sp->dec_nbitsmask; oldcodep = sp->dec_oldcodep; free_entp = sp->dec_free_entp; maxcodep = sp->dec_maxcodep; code_t* const dec_codetab = sp->dec_codetab; code_t* codep; if (occ == 0) { goto after_loop; } begin: { WordType code; GetNextCodeLZW(); codep = dec_codetab + code; if (code >= CODE_FIRST) goto code_above_or_equal_to_258; if (code < 256) goto code_below_256; if (code == CODE_EOI) goto after_loop; goto code_clear; code_below_256: { if (codep > free_entp) goto error_code; free_entp->next = oldcodep; free_entp->firstchar = oldcodep->firstchar; free_entp->length = oldcodep->length+1; free_entp->value = (uint8_t)code; free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == code)); if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = dec_codetab + nbitsmask-1; if( free_entp >= &dec_codetab[CSIZE] ) { free_entp = dec_codetab - 1; } } oldcodep = codep; *op++ = (uint8_t)code; occ--; if (occ == 0) goto after_loop; goto begin; } code_above_or_equal_to_258: { if (codep >= free_entp) { if (codep != free_entp) goto error_code; free_entp->value = oldcodep->firstchar; } else { free_entp->value = codep->firstchar; } free_entp->repeated = (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value)); free_entp->next = oldcodep; free_entp->firstchar = oldcodep->firstchar; free_entp->length = oldcodep->length+1; if (++free_entp > maxcodep) { if (++nbits > BITS_MAX) nbits = BITS_MAX; nbitsmask = MAXCODE(nbits); maxcodep = dec_codetab + nbitsmask-1; if (free_entp >= &dec_codetab[CSIZE]) { free_entp = dec_codetab - 1; } } oldcodep = codep; unsigned short len = codep->length; if (len < 3)  { if (occ <= 2) { if (occ == 2) { memcpy(op, &(codep->firstchar), 2); op += 2; occ -= 2; goto after_loop; } goto too_short_buffer; } memcpy(op, &(codep->firstchar), 2); op += 2; occ -= 2; goto begin;  } if (len == 3) { if (occ <= 3) { if (occ == 3) { op[0] = codep->firstchar; op[1] = codep->next->value; op[2] = codep->value; op += 3; occ -= 3; goto after_loop; } goto too_short_buffer; } op[0] = codep->firstchar; op[1] = codep->next->value; op[2] = codep->value; op += 3; occ -= 3; goto begin;  } if (len > occ) { goto too_short_buffer; } if (codep->repeated) { memset(op, codep->value, len); op += len; occ -= len; if (occ == 0) goto after_loop; goto begin; } uint8_t* tp = op + len; assert(len >= 4); *--tp = codep->value; codep = codep->next; *--tp = codep->value; codep = codep->next; *--tp = codep->value; codep = codep->next; *--tp = codep->value; if (tp > op) { do { codep = codep->next; *--tp = codep->value; } while (tp > op); } assert(occ >= len); op += len; occ -= len; if (occ == 0) goto after_loop; goto begin; } code_clear: { free_entp = dec_codetab + CODE_FIRST; nbits = BITS_MIN; nbitsmask = MAXCODE(BITS_MIN); maxcodep = dec_codetab + nbitsmask-1; do { GetNextCodeLZW(); } while (code == CODE_CLEAR); if (code == CODE_EOI) goto after_loop; if (code > CODE_EOI) { goto error_code; } *op++ = (uint8_t)code; occ--; oldcodep = dec_codetab + code; if (occ == 0) goto after_loop; goto begin; } } too_short_buffer: { sp->dec_codep = codep; do { codep = codep->next; } while (codep->length > occ); sp->dec_restart = occ; uint8_t* tp = op + occ; do  { *--tp = codep->value; codep = codep->next; }  while (--occ); } after_loop: tif->tif_rawcc -= (tmsize_t)((uint8_t*) bp - tif->tif_rawcp ); tif->tif_rawcp = (uint8_t*) bp; sp->old_tif_rawcc = tif->tif_rawcc; sp->dec_bitsleft = dec_bitsleft; sp->lzw_nbits = (unsigned short) nbits; sp->lzw_nextdata = nextdata; sp->lzw_nextbits = nextbits; sp->dec_nbitsmask = nbitsmask; sp->dec_oldcodep = oldcodep; sp->dec_free_entp = free_entp; sp->dec_maxcodep = maxcodep; if (occ > 0) { TIFFErrorExt(tif->tif_clientdata, module, ""Not enough data at scanline %""PRIu32"" (short %""PRIu64"" bytes)"", tif->tif_row, (uint64_t)occ); return (0); } return (1); no_eoi: TIFFErrorExt(tif->tif_clientdata, module, ""LZWDecode: Strip %""PRIu32"" not terminated with EOI code"", tif->tif_curstrip); return 0; error_code: TIFFErrorExt(tif->tif_clientdata, tif->tif_name, ""Using code not yet in table""); return 0; }"
"static MagickBooleanType WriteMPCImage(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { char buffer[MagickPathExtent], cache_filename[MagickPathExtent]; const char *property, *value; MagickBooleanType status; MagickOffsetType offset, scene; register ssize_t i; size_t depth, imageListLength; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); (void) CopyMagickString(cache_filename,image->filename,MagickPathExtent-6); AppendImageFormat(""cache"",cache_filename); scene=0; offset=0; imageListLength=GetImageListLength(image); do { depth=GetImageQuantumDepth(image,MagickTrue); if ((image->storage_class == PseudoClass) && (image->colors > (size_t) (GetQuantumRange(image->depth)+1))) (void) SetImageStorageClass(image,DirectClass,exception); (void) WriteBlobString(image,""id=MagickCache\n""); (void) FormatLocaleString(buffer,MagickPathExtent,""magick-signature=%u\n"", GetMagickSignature((const StringInfo *) NULL)); (void) WriteBlobString(image,buffer); (void) FormatLocaleString(buffer,MagickPathExtent, ""class=%s  colors=%.20g  alpha-trait=%s\n"",CommandOptionToMnemonic( MagickClassOptions,image->storage_class),(double) image->colors, CommandOptionToMnemonic(MagickPixelTraitOptions,(ssize_t) image->alpha_trait)); (void) WriteBlobString(image,buffer); (void) FormatLocaleString(buffer,MagickPathExtent, ""number-channels=%.20g  number-meta-channels=%.20g\n"", (double) image->number_channels,(double) image->number_meta_channels); (void) WriteBlobString(image,buffer); (void) FormatLocaleString(buffer,MagickPathExtent, ""columns=%.20g  rows=%.20g depth=%.20g\n"",(double) image->columns, (double) image->rows,(double) image->depth); (void) WriteBlobString(image,buffer); if (image->type != UndefinedType) { (void) FormatLocaleString(buffer,MagickPathExtent,""type=%s\n"", CommandOptionToMnemonic(MagickTypeOptions,image->type)); (void) WriteBlobString(image,buffer); } (void) FormatLocaleString(buffer,MagickPathExtent,""colorspace=%s\n"", CommandOptionToMnemonic(MagickColorspaceOptions,image->colorspace)); (void) WriteBlobString(image,buffer); if (image->intensity != UndefinedPixelIntensityMethod) { (void) FormatLocaleString(buffer,MagickPathExtent, ""pixel-intensity=%s\n"",CommandOptionToMnemonic( MagickPixelIntensityOptions,image->intensity)); (void) WriteBlobString(image,buffer); } if (image->endian != UndefinedEndian) { (void) FormatLocaleString(buffer,MagickPathExtent,""endian=%s\n"", CommandOptionToMnemonic(MagickEndianOptions,image->endian)); (void) WriteBlobString(image,buffer); } if (image->compression != UndefinedCompression) { (void) FormatLocaleString(buffer,MagickPathExtent, ""compression=%s  quality=%.20g\n"",CommandOptionToMnemonic( MagickCompressOptions,image->compression),(double) image->quality); (void) WriteBlobString(image,buffer); } if (image->units != UndefinedResolution) { (void) FormatLocaleString(buffer,MagickPathExtent,""units=%s\n"", CommandOptionToMnemonic(MagickResolutionOptions,image->units)); (void) WriteBlobString(image,buffer); } if ((image->resolution.x != 0) || (image->resolution.y != 0)) { (void) FormatLocaleString(buffer,MagickPathExtent, ""resolution=%gx%g\n"",image->resolution.x,image->resolution.y); (void) WriteBlobString(image,buffer); } if ((image->page.width != 0) || (image->page.height != 0)) { (void) FormatLocaleString(buffer,MagickPathExtent, ""page=%.20gx%.20g%+.20g%+.20g\n"",(double) image->page.width,(double) image->page.height,(double) image->page.x,(double) image->page.y); (void) WriteBlobString(image,buffer); } else if ((image->page.x != 0) || (image->page.y != 0)) { (void) FormatLocaleString(buffer,MagickPathExtent,""page=%+ld%+ld\n"", (long) image->page.x,(long) image->page.y); (void) WriteBlobString(image,buffer); } if ((image->tile_offset.x != 0) || (image->tile_offset.y != 0)) { (void) FormatLocaleString(buffer,MagickPathExtent, ""tile-offset=%+ld%+ld\n"",(long) image->tile_offset.x,(long) image->tile_offset.y); (void) WriteBlobString(image,buffer); } if ((GetNextImageInList(image) != (Image *) NULL) || (GetPreviousImageInList(image) != (Image *) NULL)) { if (image->scene == 0) (void) FormatLocaleString(buffer,MagickPathExtent, ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"",(double) image->iterations,(double) image->delay,(double) image->ticks_per_second); else (void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g  "" ""iterations=%.20g  delay=%.20g  ticks-per-second=%.20g\n"", (double) image->scene,(double) image->iterations,(double) image->delay,(double) image->ticks_per_second); (void) WriteBlobString(image,buffer); } else { if (image->scene != 0) { (void) FormatLocaleString(buffer,MagickPathExtent,""scene=%.20g\n"", (double) image->scene); (void) WriteBlobString(image,buffer); } if (image->iterations != 0) { (void) FormatLocaleString(buffer,MagickPathExtent, ""iterations=%.20g\n"",(double) image->iterations); (void) WriteBlobString(image,buffer); } if (image->delay != 0) { (void) FormatLocaleString(buffer,MagickPathExtent,""delay=%.20g\n"", (double) image->delay); (void) WriteBlobString(image,buffer); } if (image->ticks_per_second != UndefinedTicksPerSecond) { (void) FormatLocaleString(buffer,MagickPathExtent, ""ticks-per-second=%.20g\n"",(double) image->ticks_per_second); (void) WriteBlobString(image,buffer); } } if (image->gravity != UndefinedGravity) { (void) FormatLocaleString(buffer,MagickPathExtent,""gravity=%s\n"", CommandOptionToMnemonic(MagickGravityOptions,image->gravity)); (void) WriteBlobString(image,buffer); } if (image->dispose != UndefinedDispose) { (void) FormatLocaleString(buffer,MagickPathExtent,""dispose=%s\n"", CommandOptionToMnemonic(MagickDisposeOptions,image->dispose)); (void) WriteBlobString(image,buffer); } if (image->rendering_intent != UndefinedIntent) { (void) FormatLocaleString(buffer,MagickPathExtent, ""rendering-intent=%s\n"",CommandOptionToMnemonic(MagickIntentOptions, image->rendering_intent)); (void) WriteBlobString(image,buffer); } if (image->gamma != 0.0) { (void) FormatLocaleString(buffer,MagickPathExtent,""gamma=%g\n"", image->gamma); (void) WriteBlobString(image,buffer); } if (image->chromaticity.white_point.x != 0.0) { (void) FormatLocaleString(buffer,MagickPathExtent,""red-primary="" ""%g,%g  green-primary=%g,%g  blue-primary=%g,%g\n"", image->chromaticity.red_primary.x,image->chromaticity.red_primary.y, image->chromaticity.green_primary.x, image->chromaticity.green_primary.y, image->chromaticity.blue_primary.x, image->chromaticity.blue_primary.y); (void) WriteBlobString(image,buffer); (void) FormatLocaleString(buffer,MagickPathExtent, ""white-point=%g,%g\n"",image->chromaticity.white_point.x, image->chromaticity.white_point.y); (void) WriteBlobString(image,buffer); } if (image->orientation != UndefinedOrientation) { (void) FormatLocaleString(buffer,MagickPathExtent, ""orientation=%s\n"",CommandOptionToMnemonic(MagickOrientationOptions, image->orientation)); (void) WriteBlobString(image,buffer); } if (image->profiles != (void *) NULL) { const char *name; const StringInfo *profile; ResetImageProfileIterator(image); for (name=GetNextImageProfile(image); name != (const char *) NULL; ) { profile=GetImageProfile(image,name); if (profile != (StringInfo *) NULL) { (void) FormatLocaleString(buffer,MagickPathExtent,""profile=%s\n"", name); (void) WriteBlobString(image,buffer); } name=GetNextImageProfile(image); } } if (image->montage != (char *) NULL) { (void) FormatLocaleString(buffer,MagickPathExtent,""montage=%s\n"", image->montage); (void) WriteBlobString(image,buffer); } ResetImagePropertyIterator(image); property=GetNextImageProperty(image); while (property != (const char *) NULL) { (void) FormatLocaleString(buffer,MagickPathExtent,""%s="",property); (void) WriteBlobString(image,buffer); value=GetImageProperty(image,property,exception); if (value != (const char *) NULL) { size_t length; length=strlen(value); for (i=0; i < (ssize_t) length; i++) if (isspace((int) ((unsigned char) value[i])) != 0) break; if ((i == (ssize_t) length) && (i != 0)) (void) WriteBlob(image,length,(const unsigned char *) value); else { (void) WriteBlobByte(image,'{'); if (strchr(value,'}') == (char *) NULL) (void) WriteBlob(image,length,(const unsigned char *) value); else for (i=0; i < (ssize_t) length; i++) { if (value[i] == (int) '}') (void) WriteBlobByte(image,'\\'); (void) WriteBlobByte(image,(unsigned char) value[i]); } (void) WriteBlobByte(image,'}'); } } (void) WriteBlobByte(image,'\n'); property=GetNextImageProperty(image); } (void) WriteBlobString(image,""\f\n:\032""); if (image->montage != (char *) NULL) { if (image->directory != (char *) NULL) (void) WriteBlobString(image,image->directory); (void) WriteBlobByte(image,'\0'); } if (image->profiles != 0) { const char *name; const StringInfo *profile; ResetImageProfileIterator(image); name=GetNextImageProfile(image); while (name != (const char *) NULL) { profile=GetImageProfile(image,name); (void) WriteBlobMSBLong(image,(unsigned int) GetStringInfoLength(profile)); (void) WriteBlob(image,GetStringInfoLength(profile), GetStringInfoDatum(profile)); name=GetNextImageProfile(image); } } if (image->storage_class == PseudoClass) { size_t packet_size; unsigned char *colormap, *q; packet_size=(size_t) (3UL*depth/8UL); colormap=(unsigned char *) AcquireQuantumMemory(image->colors, packet_size*sizeof(*colormap)); if (colormap == (unsigned char *) NULL) return(MagickFalse); q=colormap; for (i=0; i < (ssize_t) image->colors; i++) { switch (depth) { default: ThrowWriterException(CorruptImageError,""ImageDepthNotSupported""); case 32: { unsigned int pixel; pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].red)); q=PopLongPixel(MSBEndian,pixel,q); pixel=ScaleQuantumToLong(ClampToQuantum( image->colormap[i].green)); q=PopLongPixel(MSBEndian,pixel,q); pixel=ScaleQuantumToLong(ClampToQuantum(image->colormap[i].blue)); q=PopLongPixel(MSBEndian,pixel,q); break; } case 16: { unsigned short pixel; pixel=ScaleQuantumToShort(ClampToQuantum(image->colormap[i].red)); q=PopShortPixel(MSBEndian,pixel,q); pixel=ScaleQuantumToShort(ClampToQuantum( image->colormap[i].green)); q=PopShortPixel(MSBEndian,pixel,q); pixel=ScaleQuantumToShort(ClampToQuantum( image->colormap[i].blue)); q=PopShortPixel(MSBEndian,pixel,q); break; } case 8: { unsigned char pixel; pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum( image->colormap[i].red)); q=PopCharPixel(pixel,q); pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum( image->colormap[i].green)); q=PopCharPixel(pixel,q); pixel=(unsigned char) ScaleQuantumToChar(ClampToQuantum( image->colormap[i].blue)); q=PopCharPixel(pixel,q); break; } } } (void) WriteBlob(image,packet_size*image->colors,colormap); colormap=(unsigned char *) RelinquishMagickMemory(colormap); } status=PersistPixelCache(image,cache_filename,MagickFalse,&offset, exception); if (status == MagickFalse) ThrowWriterException(CacheError,""UnableToPersistPixelCache""); if (GetNextImageInList(image) == (Image *) NULL) break; image=SyncNextImageInList(image); if (image->progress_monitor != (MagickProgressMonitor) NULL) { status=image->progress_monitor(SaveImagesTag,scene, imageListLength,image->client_data); if (status == MagickFalse) break; } scene++; } while (image_info->adjoin != MagickFalse); (void) CloseBlob(image); return(status); }"
"static bool nested_vmx_exit_handled(struct kvm_vcpu *vcpu) { u32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO); struct vcpu_vmx *vmx = to_vmx(vcpu); struct vmcs12 *vmcs12 = get_vmcs12(vcpu); u32 exit_reason = vmx->exit_reason; trace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason, vmcs_readl(EXIT_QUALIFICATION), vmx->idt_vectoring_info, intr_info, vmcs_read32(VM_EXIT_INTR_ERROR_CODE), KVM_ISA_VMX); if (vmx->nested.nested_run_pending) return 0; if (unlikely(vmx->fail)) { pr_info_ratelimited(""%s failed vm entry %x\n"", __func__, vmcs_read32(VM_INSTRUCTION_ERROR)); return 1; } switch (exit_reason) { case EXIT_REASON_EXCEPTION_NMI: if (!is_exception(intr_info)) return 0; else if (is_page_fault(intr_info)) return enable_ept; else if (is_no_device(intr_info) && !(vmcs12->guest_cr0 & X86_CR0_TS)) return 0; return vmcs12->exception_bitmap & (1u << (intr_info & INTR_INFO_VECTOR_MASK)); case EXIT_REASON_EXTERNAL_INTERRUPT: return 0; case EXIT_REASON_TRIPLE_FAULT: return 1; case EXIT_REASON_PENDING_INTERRUPT: return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_INTR_PENDING); case EXIT_REASON_NMI_WINDOW: return nested_cpu_has(vmcs12, CPU_BASED_VIRTUAL_NMI_PENDING); case EXIT_REASON_TASK_SWITCH: return 1; case EXIT_REASON_CPUID: if (kvm_register_read(vcpu, VCPU_REGS_RAX) == 0xa) return 0; return 1; case EXIT_REASON_HLT: return nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING); case EXIT_REASON_INVD: return 1; case EXIT_REASON_INVLPG: return nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING); case EXIT_REASON_RDPMC: return nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING); case EXIT_REASON_RDTSC: return nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING); case EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR: case EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD: case EXIT_REASON_VMPTRST: case EXIT_REASON_VMREAD: case EXIT_REASON_VMRESUME: case EXIT_REASON_VMWRITE: case EXIT_REASON_VMOFF: case EXIT_REASON_VMON: case EXIT_REASON_INVEPT: return 1; case EXIT_REASON_CR_ACCESS: return nested_vmx_exit_handled_cr(vcpu, vmcs12); case EXIT_REASON_DR_ACCESS: return nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING); case EXIT_REASON_IO_INSTRUCTION: return nested_vmx_exit_handled_io(vcpu, vmcs12); case EXIT_REASON_MSR_READ: case EXIT_REASON_MSR_WRITE: return nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason); case EXIT_REASON_INVALID_STATE: return 1; case EXIT_REASON_MWAIT_INSTRUCTION: return nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING); case EXIT_REASON_MONITOR_INSTRUCTION: return nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING); case EXIT_REASON_PAUSE_INSTRUCTION: return nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) || nested_cpu_has2(vmcs12, SECONDARY_EXEC_PAUSE_LOOP_EXITING); case EXIT_REASON_MCE_DURING_VMENTRY: return 0; case EXIT_REASON_TPR_BELOW_THRESHOLD: return nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW); case EXIT_REASON_APIC_ACCESS: return nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES); case EXIT_REASON_EPT_VIOLATION: return 0; case EXIT_REASON_EPT_MISCONFIG: return 0; case EXIT_REASON_WBINVD: return nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING); case EXIT_REASON_XSETBV: return 1; default: return 1; } }"
"static void php_array_merge_recursive(PointerSet &seen, bool check, Array &arr1, const Array& arr2) { if (check && !seen.insert((void*)arr1.get()).second) { raise_warning(""array_merge_recursive(): recursion detected""); return; } for (ArrayIter iter(arr2); iter; ++iter) { Variant key(iter.first()); const Variant& value(iter.secondRef()); if (key.isNumeric()) { arr1.appendWithRef(value); } else if (arr1.exists(key, true)) { Variant &v = arr1.lvalAt(key, AccessFlags::Key); auto subarr1 = v.toArray().copy(); php_array_merge_recursive(seen, couldRecur(v, subarr1), subarr1, value.toArray()); v.unset();       v = subarr1; } else { arr1.setWithRef(key, value, true); } } if (check) { seen.erase((void*)arr1.get()); } }"
"void input_l2cap_credit(uint8_t *data) { uint16_t len; uint16_t cid; uint16_t credits; l2cap_channel_t *channel = get_channel_for_addr(packetbuf_addr(PACKETBUF_ADDR_SENDER)); memcpy(&len, &data[1], 2); if(len != 4) { LOG_WARN(""process_l2cap_credit: invalid len: %d\n"", len); return; } memcpy(&cid, &data[3], 2); memcpy(&credits, &data[5], 2); channel->channel_peer.credits += credits; }"
"static bfd_boolean scan_unit_for_symbols (struct comp_unit *unit) { bfd *abfd = unit->abfd; bfd_byte *info_ptr = unit->first_child_die_ptr; bfd_byte *info_ptr_end = unit->stash->info_ptr_end; int nesting_level = 1; struct funcinfo **nested_funcs; int nested_funcs_size; nested_funcs_size = 32; nested_funcs = (struct funcinfo **) bfd_malloc (nested_funcs_size * sizeof (struct funcinfo *)); if (nested_funcs == NULL) return FALSE; nested_funcs[nesting_level] = 0; while (nesting_level) { unsigned int abbrev_number, bytes_read, i; struct abbrev_info *abbrev; struct attribute attr; struct funcinfo *func; struct varinfo *var; bfd_vma low_pc = 0; bfd_vma high_pc = 0; bfd_boolean high_pc_relative = FALSE; if (info_ptr >= info_ptr_end) goto fail; abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, info_ptr_end); info_ptr += bytes_read; if (! abbrev_number) { nesting_level--; continue; } abbrev = lookup_abbrev (abbrev_number, unit->abbrevs); if (! abbrev) { static unsigned int previous_failed_abbrev = -1U; if (abbrev_number != previous_failed_abbrev) { _bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""), abbrev_number); previous_failed_abbrev = abbrev_number; } bfd_set_error (bfd_error_bad_value); goto fail; } var = NULL; if (abbrev->tag == DW_TAG_subprogram || abbrev->tag == DW_TAG_entry_point || abbrev->tag == DW_TAG_inlined_subroutine) { bfd_size_type amt = sizeof (struct funcinfo); func = (struct funcinfo *) bfd_zalloc (abfd, amt); if (func == NULL) goto fail; func->tag = abbrev->tag; func->prev_func = unit->function_table; unit->function_table = func; unit->number_of_functions++; BFD_ASSERT (!unit->cached); if (func->tag == DW_TAG_inlined_subroutine) for (i = nesting_level - 1; i >= 1; i--) if (nested_funcs[i]) { func->caller_func = nested_funcs[i]; break; } nested_funcs[nesting_level] = func; } else { func = NULL; if (abbrev->tag == DW_TAG_variable) { bfd_size_type amt = sizeof (struct varinfo); var = (struct varinfo *) bfd_zalloc (abfd, amt); if (var == NULL) goto fail; var->tag = abbrev->tag; var->stack = 1; var->prev_var = unit->variable_table; unit->variable_table = var; } nested_funcs[nesting_level] = 0; } for (i = 0; i < abbrev->num_attrs; ++i) { info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end); if (info_ptr == NULL) goto fail; if (func) { switch (attr.name) { case DW_AT_call_file: func->caller_file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_call_line: func->caller_line = attr.u.val; break; case DW_AT_abstract_origin: case DW_AT_specification: func->name = find_abstract_instance_name (unit, &attr, &func->is_linkage); break; case DW_AT_name: if (func->name == NULL && is_str_attr (attr.form)) { func->name = attr.u.str; if (non_mangled (unit->lang)) func->is_linkage = TRUE; } break; case DW_AT_linkage_name: case DW_AT_MIPS_linkage_name: if (is_str_attr (attr.form)) { func->name = attr.u.str; func->is_linkage = TRUE; } break; case DW_AT_low_pc: low_pc = attr.u.val; break; case DW_AT_high_pc: high_pc = attr.u.val; high_pc_relative = attr.form != DW_FORM_addr; break; case DW_AT_ranges: if (!read_rangelist (unit, &func->arange, attr.u.val)) goto fail; break; case DW_AT_decl_file: func->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: func->line = attr.u.val; break; default: break; } } else if (var) { switch (attr.name) { case DW_AT_name: var->name = attr.u.str; break; case DW_AT_decl_file: var->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: var->line = attr.u.val; break; case DW_AT_external: if (attr.u.val != 0) var->stack = 0; break; case DW_AT_location: switch (attr.form) { case DW_FORM_block: case DW_FORM_block1: case DW_FORM_block2: case DW_FORM_block4: case DW_FORM_exprloc: if (*attr.u.blk->data == DW_OP_addr) { var->stack = 0; if (attr.u.blk->size == unit->addr_size + 1U) var->addr = bfd_get (unit->addr_size * 8, unit->abfd, attr.u.blk->data + 1); } break; default: break; } break; default: break; } } } if (high_pc_relative) high_pc += low_pc; if (func && high_pc != 0) { if (!arange_add (unit, &func->arange, low_pc, high_pc)) goto fail; } if (abbrev->has_children) { nesting_level++; if (nesting_level >= nested_funcs_size) { struct funcinfo **tmp; nested_funcs_size *= 2; tmp = (struct funcinfo **) bfd_realloc (nested_funcs, nested_funcs_size * sizeof (struct funcinfo *)); if (tmp == NULL) goto fail; nested_funcs = tmp; } nested_funcs[nesting_level] = 0; } } free (nested_funcs); return TRUE; fail: free (nested_funcs); return FALSE; }"
"void Gobby::EditCommands::on_paste() { g_assert(m_current_view != NULL); g_assert(m_current_view->get_active_user() != NULL); gtk_text_buffer_paste_clipboard( GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), NULL, TRUE); m_current_view->scroll_to_cursor_position(0.0); }"
"OMX_ERRORTYPE SoftMPEG4Encoder::initEncParams() { CHECK(mHandle != NULL); memset(mHandle, 0, sizeof(tagvideoEncControls)); CHECK(mEncParams != NULL); memset(mEncParams, 0, sizeof(tagvideoEncOptions)); if (!PVGetDefaultEncOption(mEncParams, 0)) { ALOGE(""Failed to get default encoding parameters""); return OMX_ErrorUndefined; } mEncParams->encMode = mEncodeMode; mEncParams->encWidth[0] = mWidth; mEncParams->encHeight[0] = mHeight; mEncParams->encFrameRate[0] = mFramerate >> 16;     mEncParams->rcType = VBR_1; mEncParams->vbvDelay = 5.0f; mEncParams->profile_level = CORE_PROFILE_LEVEL2; mEncParams->packetSize = 32; mEncParams->rvlcEnable = PV_OFF; mEncParams->numLayers = 1; mEncParams->timeIncRes = 1000; mEncParams->tickPerSrc = ((int64_t)mEncParams->timeIncRes << 16) / mFramerate; mEncParams->bitRate[0] = mBitrate; mEncParams->iQuant[0] = 15; mEncParams->pQuant[0] = 12; mEncParams->quantType[0] = 0; mEncParams->noFrameSkipped = PV_OFF; if (mColorFormat != OMX_COLOR_FormatYUV420Planar || mInputDataIsMeta) { free(mInputFrameData); mInputFrameData = (uint8_t *) malloc((mWidth * mHeight * 3 ) >> 1); CHECK(mInputFrameData != NULL); } if (mWidth % 16 != 0 || mHeight % 16 != 0) { ALOGE(""Video frame size %dx%d must be a multiple of 16"", mWidth, mHeight); return OMX_ErrorBadParameter; } if (mIDRFrameRefreshIntervalInSec < 0) { mEncParams->intraPeriod = -1; } else if (mIDRFrameRefreshIntervalInSec == 0) { mEncParams->intraPeriod = 1;      } else { mEncParams->intraPeriod = (mIDRFrameRefreshIntervalInSec * mFramerate) >> 16; } mEncParams->numIntraMB = 0; mEncParams->sceneDetect = PV_ON; mEncParams->searchRange = 16; mEncParams->mv8x8Enable = PV_OFF; mEncParams->gobHeaderInterval = 0; mEncParams->useACPred = PV_ON; mEncParams->intraDCVlcTh = 0; return OMX_ErrorNone; }"
"void v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode, struct super_block *sb) { umode_t mode; char ext[32]; char tag_name[14]; unsigned int i_nlink; struct v9fs_session_info *v9ses = sb->s_fs_info; struct v9fs_inode *v9inode = V9FS_I(inode); set_nlink(inode, 1); inode->i_atime.tv_sec = stat->atime; inode->i_mtime.tv_sec = stat->mtime; inode->i_ctime.tv_sec = stat->mtime; inode->i_uid = v9ses->dfltuid; inode->i_gid = v9ses->dfltgid; if (v9fs_proto_dotu(v9ses)) { inode->i_uid = stat->n_uid; inode->i_gid = stat->n_gid; } if ((S_ISREG(inode->i_mode)) || (S_ISDIR(inode->i_mode))) { if (v9fs_proto_dotu(v9ses) && (stat->extension[0] != '\0')) { strlcpy(ext, stat->extension, sizeof(ext)); sscanf(ext, ""%13s %u"", tag_name, &i_nlink); if (!strncmp(tag_name, ""HARDLINKCOUNT"", 13)) set_nlink(inode, i_nlink); } } mode = p9mode2perm(v9ses, stat); mode |= inode->i_mode & ~S_IALLUGO; inode->i_mode = mode; i_size_write(inode, stat->length); inode->i_blocks = (i_size_read(inode) + 512 - 1) >> 9; v9inode->cache_validity &= ~V9FS_INO_INVALID_ATTR; }"
"uint8_t * copyn_utf8_str(const uint8_t *src, uint32_t *pos, int *str_len, int limit) { *str_len      = 0; uint8_t *dest = NULL; if (limit < 2) return NULL; NNI_GET16(src + (*pos), *str_len); *pos = (*pos) + 2; if (*str_len > (limit-2)) { *str_len = -1; return NULL; } if (*str_len > 0) { if (utf8_check((const char *) (src + *pos), *str_len) == ERR_SUCCESS) { if ((dest = nng_alloc(*str_len + 1)) == NULL) { *str_len = 0; return NULL; } memcpy(dest, src + (*pos), *str_len); dest[*str_len] = '\0'; *pos           = (*pos) + (*str_len); } else { *str_len = -1; } } return dest; }"
"void isoclns_print(netdissect_options *ndo, const uint8_t *p, u_int length, u_int caplen) { if (caplen <= 1) {  ND_PRINT((ndo, ""|OSI"")); return; } if (ndo->ndo_eflag) ND_PRINT((ndo, ""OSI NLPID %s (0x%02x): "", tok2str(nlpid_values, ""Unknown"", *p), *p)); switch (*p) { case NLPID_CLNP: if (!clnp_print(ndo, p, length)) print_unknown_data(ndo, p, ""\n\t"", caplen); break; case NLPID_ESIS: esis_print(ndo, p, length); return; case NLPID_ISIS: if (!isis_print(ndo, p, length)) print_unknown_data(ndo, p, ""\n\t"", caplen); break; case NLPID_NULLNS: ND_PRINT((ndo, ""%slength: %u"", ndo->ndo_eflag ? """" : "", "", length)); break; case NLPID_Q933: q933_print(ndo, p + 1, length - 1); break; case NLPID_IP: ip_print(ndo, p + 1, length - 1); break; case NLPID_IP6: ip6_print(ndo, p + 1, length - 1); break; case NLPID_PPP: ppp_print(ndo, p + 1, length - 1); break; default: if (!ndo->ndo_eflag) ND_PRINT((ndo, ""OSI NLPID 0x%02x unknown"", *p)); ND_PRINT((ndo, ""%slength: %u"", ndo->ndo_eflag ? """" : "", "", length)); if (caplen > 1) print_unknown_data(ndo, p, ""\n\t"", caplen); break; } }"
"static struct inode *v9fs_qid_iget(struct super_block *sb, struct p9_qid *qid, struct p9_wstat *st, int new) { dev_t rdev; int retval; umode_t umode; unsigned long i_ino; struct inode *inode; struct v9fs_session_info *v9ses = sb->s_fs_info; int (*test)(struct inode *, void *); if (new) test = v9fs_test_new_inode; else test = v9fs_test_inode; i_ino = v9fs_qid2ino(qid); inode = iget5_locked(sb, i_ino, test, v9fs_set_inode, st); if (!inode) return ERR_PTR(-ENOMEM); if (!(inode->i_state & I_NEW)) return inode; inode->i_ino = i_ino; umode = p9mode2unixmode(v9ses, st, &rdev); retval = v9fs_init_inode(v9ses, inode, umode, rdev); if (retval) goto error; v9fs_stat2inode(st, inode, sb); v9fs_cache_inode_get_cookie(inode); unlock_new_inode(inode); return inode; error: iget_failed(inode); return ERR_PTR(retval); }"
"static void internal_set_int(grpc_error **err, grpc_error_ints which, intptr_t value) { uint8_t slot = (*err)->ints[which]; if (slot == UINT8_MAX) { slot = get_placement(err, sizeof(value)); if (slot == UINT8_MAX) { gpr_log(GPR_ERROR, ""Error %p is full, dropping int {\""%s\"":%"" PRIiPTR ""}"", *err, error_int_name(which), value); return; } } (*err)->ints[which] = slot; (*err)->arena[slot] = value; }"
"static int sendControllerEventInternal(short controllerNumber, short buttonFlags, unsigned char leftTrigger, unsigned char rightTrigger, short leftStickX, short leftStickY, short rightStickX, short rightStickY) { PPACKET_HOLDER holder; int err; if (!initialized) { return -2; } holder = malloc(sizeof(*holder)); if (holder == NULL) { return -1; } if (ServerMajorVersion == 3) { holder->packetLength = sizeof(NV_CONTROLLER_PACKET); holder->packet.controller.header.packetType = htonl(PACKET_TYPE_CONTROLLER); holder->packet.controller.headerA = C_HEADER_A; holder->packet.controller.headerB = C_HEADER_B; holder->packet.controller.buttonFlags = buttonFlags; holder->packet.controller.leftTrigger = leftTrigger; holder->packet.controller.rightTrigger = rightTrigger; holder->packet.controller.leftStickX = leftStickX; holder->packet.controller.leftStickY = leftStickY; holder->packet.controller.rightStickX = rightStickX; holder->packet.controller.rightStickY = rightStickY; holder->packet.controller.tailA = C_TAIL_A; holder->packet.controller.tailB = C_TAIL_B; } else { holder->packetLength = sizeof(NV_MULTI_CONTROLLER_PACKET); holder->packet.multiController.header.packetType = htonl(PACKET_TYPE_MULTI_CONTROLLER); holder->packet.multiController.headerA = MC_HEADER_A; if (ServerMajorVersion >= 5) { holder->packet.multiController.headerA--; } holder->packet.multiController.headerB = MC_HEADER_B; holder->packet.multiController.controllerNumber = controllerNumber; holder->packet.multiController.midA = MC_ACTIVE_CONTROLLER_FLAGS; holder->packet.multiController.midB = MC_MID_B; holder->packet.multiController.buttonFlags = buttonFlags; holder->packet.multiController.leftTrigger = leftTrigger; holder->packet.multiController.rightTrigger = rightTrigger; holder->packet.multiController.leftStickX = leftStickX; holder->packet.multiController.leftStickY = leftStickY; holder->packet.multiController.rightStickX = rightStickX; holder->packet.multiController.rightStickY = rightStickY; holder->packet.multiController.tailA = MC_TAIL_A; holder->packet.multiController.tailB = MC_TAIL_B; } err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry); if (err != LBQ_SUCCESS) { free(holder); } return err; }"
"static inline int check_compat_entry_size_and_hooks(struct compat_arpt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 || (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_arpt_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!arp_checkentry(&e->arp)) return -EINVAL; ret = xt_compat_check_entry_offsets(e, e->target_offset, e->next_offset); if (ret) return ret; off = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry); entry_offset = (void *)e - (void *)base; t = compat_arpt_get_target(e); target = xt_request_find_target(NFPROTO_ARP, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto out; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off); if (ret) goto release_target; for (h = 0; h < NF_ARP_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; release_target: module_put(t->u.kernel.target->me); out: return ret; }"
"static void fz_append_display_node( fz_context *ctx, fz_device *dev, fz_display_command cmd, int flags, const fz_rect *rect, const fz_path *path, const float *color, fz_colorspace *colorspace, const float *alpha, const fz_matrix *ctm, const fz_stroke_state *stroke, const void *private_data, int private_data_len) { fz_display_node node = { 0 }; fz_display_node *node_ptr; fz_list_device *writer = (fz_list_device *)dev; fz_display_list *list = writer->list; int size; int rect_off = 0; int path_off = 0; int color_off = 0; int colorspace_off = 0; int alpha_off = 0; int ctm_off = 0; int stroke_off = 0; int rect_for_updates = 0; int private_off = 0; fz_path *my_path = NULL; fz_stroke_state *my_stroke = NULL; fz_rect local_rect; int path_size = 0; switch (cmd) { case FZ_CMD_CLIP_PATH: case FZ_CMD_CLIP_STROKE_PATH: case FZ_CMD_CLIP_TEXT: case FZ_CMD_CLIP_STROKE_TEXT: case FZ_CMD_CLIP_IMAGE_MASK: if (writer->top < STACK_SIZE) { rect_for_updates = 1; writer->stack[writer->top].rect = fz_empty_rect; } writer->top++; break; case FZ_CMD_END_MASK: if (writer->top < STACK_SIZE) { writer->stack[writer->top].update = NULL; writer->stack[writer->top].rect = fz_empty_rect; } writer->top++; break; case FZ_CMD_BEGIN_TILE: writer->tiled++; if (writer->top > 0 && writer->top <= STACK_SIZE) { writer->stack[writer->top-1].rect = fz_infinite_rect; } break; case FZ_CMD_END_TILE: writer->tiled--; break; case FZ_CMD_END_GROUP: break; case FZ_CMD_POP_CLIP: if (writer->top > STACK_SIZE) { writer->top--; rect = &fz_infinite_rect; } else if (writer->top > 0) { fz_rect *update; writer->top--; update = writer->stack[writer->top].update; if (writer->tiled == 0) { if (update) { *update = fz_intersect_rect(*update, writer->stack[writer->top].rect); local_rect = *update; rect = &local_rect; } else rect = &writer->stack[writer->top].rect; } else rect = &fz_infinite_rect; } default: if (writer->top > 0 && writer->tiled == 0 && writer->top <= STACK_SIZE && rect) writer->stack[writer->top-1].rect = fz_union_rect(writer->stack[writer->top-1].rect, *rect); break; } size = 1;  node.cmd = cmd; if (rect_for_updates || (rect != NULL && (writer->rect.x0 != rect->x0 || writer->rect.y0 != rect->y0 || writer->rect.x1 != rect->x1 || writer->rect.y1 != rect->y1))) { node.rect = 1; rect_off = size; size += SIZE_IN_NODES(sizeof(fz_rect)); } if (color || colorspace) { if (colorspace != writer->colorspace) { assert(color); if (colorspace == fz_device_gray(ctx)) { if (color[0] == 0.0f) node.cs = CS_GRAY_0, color = NULL; else { node.cs = CS_GRAY_1; if (color[0] == 1.0f) color = NULL; } } else if (colorspace == fz_device_rgb(ctx)) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) node.cs = CS_RGB_0, color = NULL; else { node.cs = CS_RGB_1; if (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f) color = NULL; } } else if (colorspace == fz_device_cmyk(ctx)) { node.cs = CS_CMYK_0; if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { if (color[3] == 0.0f) color = NULL; else { node.cs = CS_CMYK_1; if (color[3] == 1.0f) color = NULL; } } } else { int i; int n = fz_colorspace_n(ctx, colorspace); colorspace_off = size; size += SIZE_IN_NODES(sizeof(fz_colorspace *)); node.cs = CS_OTHER_0; for (i = 0; i < n; i++) if (color[i] != 0.0f) break; if (i == n) color = NULL; memset(writer->color, 0, sizeof(float)*n); } } else { if (colorspace == fz_device_gray(ctx)) { if (writer->color[0] != color[0]) { if (color[0] == 0.0f) { node.cs = CS_GRAY_0; color = NULL; } else if (color[0] == 1.0f) { node.cs = CS_GRAY_1; color = NULL; } } } else if (colorspace == fz_device_rgb(ctx)) { if (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2]) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { node.cs = CS_RGB_0; color = NULL; } else if (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f) { node.cs = CS_RGB_1; color = NULL; } } } else if (colorspace == fz_device_cmyk(ctx)) { if (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2] || writer->color[3] != color[3]) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { if (color[3] == 0.0f) { node.cs = CS_CMYK_0; color = NULL; } else if (color[3] == 1.0f) { node.cs = CS_CMYK_1; color = NULL; } } } } else { int i; int n = fz_colorspace_n(ctx, colorspace); for (i=0; i < n; i++) if (color[i] != 0.0f) break; if (i == n) { node.cs = CS_OTHER_0; colorspace_off = size; size += SIZE_IN_NODES(sizeof(fz_colorspace *)); color = NULL; } } } } if (color) { int i, n; const float *wc = &writer->color[0]; assert(colorspace != NULL); n = fz_colorspace_n(ctx, colorspace); i = 0; if (colorspace == writer->colorspace) for (; i < n; i++) if (color[i] != wc[i]) break; if (i != n) { node.color = 1; color_off = size; size += n * SIZE_IN_NODES(sizeof(float)); } } if (alpha && (*alpha != writer->alpha)) { if (*alpha >= 1.0f) node.alpha = ALPHA_1; else if (*alpha <= 0.0f) node.alpha = ALPHA_0; else { alpha_off = size; size += SIZE_IN_NODES(sizeof(float)); node.alpha = ALPHA_PRESENT; } } if (ctm && (ctm->a != writer->ctm.a || ctm->b != writer->ctm.b || ctm->c != writer->ctm.c || ctm->d != writer->ctm.d || ctm->e != writer->ctm.e || ctm->f != writer->ctm.f)) { int ctm_flags; ctm_off = size; ctm_flags = CTM_UNCHANGED; if (ctm->a != writer->ctm.a || ctm->d != writer->ctm.d) ctm_flags = CTM_CHANGE_AD, size += SIZE_IN_NODES(2*sizeof(float)); if (ctm->b != writer->ctm.b || ctm->c != writer->ctm.c) ctm_flags |= CTM_CHANGE_BC, size += SIZE_IN_NODES(2*sizeof(float)); if (ctm->e != writer->ctm.e || ctm->f != writer->ctm.f) ctm_flags |= CTM_CHANGE_EF, size += SIZE_IN_NODES(2*sizeof(float)); node.ctm = ctm_flags; } if (stroke && (writer->stroke == NULL || stroke != writer->stroke)) { stroke_off = size; size += SIZE_IN_NODES(sizeof(fz_stroke_state *)); node.stroke = 1; } if (path && (writer->path == NULL || path != writer->path)) { int max = SIZE_IN_NODES(MAX_NODE_SIZE) - size - SIZE_IN_NODES(private_data_len); path_size = SIZE_IN_NODES(fz_pack_path(ctx, NULL, max, path)); node.path = 1; path_off = size; size += path_size; } if (private_data != NULL) { private_off = size; size += SIZE_IN_NODES(private_data_len); } while (list->len + size > list->max) { int newsize = list->max * 2; fz_display_node *old = list->list; ptrdiff_t diff; int i, n; if (newsize < 256) newsize = 256; list->list = fz_realloc_array(ctx, list->list, newsize, fz_display_node); list->max = newsize; diff = (char *)(list->list) - (char *)old; n = (writer->top < STACK_SIZE ? writer->top : STACK_SIZE); for (i = 0; i < n; i++) { if (writer->stack[i].update != NULL) writer->stack[i].update = (fz_rect *)(((char *)writer->stack[i].update) + diff); } if (writer->path) writer->path = (fz_path *)(((char *)writer->path) + diff); } node.size = size; node.flags = flags; assert(size < (1<<9)); node_ptr = &list->list[list->len]; *node_ptr = node; if (path_off) { my_path = (void *)(&node_ptr[path_off]); (void)fz_pack_path(ctx, (void *)my_path, path_size * sizeof(fz_display_node), path); } if (stroke_off) { fz_try(ctx) { my_stroke = fz_keep_stroke_state(ctx, stroke); } fz_catch(ctx) { fz_drop_path(ctx, my_path); fz_rethrow(ctx); } } if (rect_off) { fz_rect *out_rect = (fz_rect *)(void *)(&node_ptr[rect_off]); writer->rect = *rect; *out_rect = *rect; if (rect_for_updates) writer->stack[writer->top-1].update = out_rect; } if (path_off) { fz_drop_path(ctx, writer->path); writer->path = fz_keep_path(ctx, my_path);  } if (node.cs) { fz_drop_colorspace(ctx, writer->colorspace); switch(node.cs) { case CS_GRAY_0: writer->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx)); writer->color[0] = 0; break; case CS_GRAY_1: writer->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx)); writer->color[0] = 1; break; case CS_RGB_0: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx)); break; case CS_RGB_1: writer->color[0] = 1; writer->color[1] = 1; writer->color[2] = 1; writer->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx)); break; case CS_CMYK_0: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->color[3] = 0; writer->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx)); break; case CS_CMYK_1: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->color[3] = 1; writer->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx)); break; default: { fz_colorspace **out_colorspace = (fz_colorspace **)(void *)(&node_ptr[colorspace_off]); int i, n; n = fz_colorspace_n(ctx, colorspace); *out_colorspace = fz_keep_colorspace(ctx, colorspace); writer->colorspace = fz_keep_colorspace(ctx, colorspace); for (i = 0; i < n; i++) writer->color[i] = 0; break; } } } if (color_off) { int n = fz_colorspace_n(ctx, colorspace); float *out_color = (float *)(void *)(&node_ptr[color_off]); memcpy(writer->color, color, n * sizeof(float)); memcpy(out_color, color, n * sizeof(float)); } if (node.alpha) { writer->alpha = *alpha; if (alpha_off) { float *out_alpha = (float *)(void *)(&node_ptr[alpha_off]); *out_alpha = *alpha; } } if (ctm_off) { float *out_ctm = (float *)(void *)(&node_ptr[ctm_off]); if (node.ctm & CTM_CHANGE_AD) { writer->ctm.a = *out_ctm++ = ctm->a; writer->ctm.d = *out_ctm++ = ctm->d; } if (node.ctm & CTM_CHANGE_BC) { writer->ctm.b = *out_ctm++ = ctm->b; writer->ctm.c = *out_ctm++ = ctm->c; } if (node.ctm & CTM_CHANGE_EF) { writer->ctm.e = *out_ctm++ = ctm->e; writer->ctm.f = *out_ctm = ctm->f; } } if (stroke_off) { fz_stroke_state **out_stroke = (fz_stroke_state **)(void *)(&node_ptr[stroke_off]); *out_stroke = my_stroke; fz_drop_stroke_state(ctx, writer->stroke); writer->stroke = fz_keep_stroke_state(ctx, my_stroke); } if (private_off) { char *out_private = (char *)(void *)(&node_ptr[private_off]); memcpy(out_private, private_data, private_data_len); } list->len += size; }"
"static MagickBooleanType TraceBezier(MVGInfo *mvg_info, const size_t number_coordinates) { double alpha, *coefficients, weight; PointInfo end, point, *points; PrimitiveInfo *primitive_info; register PrimitiveInfo *p; register ssize_t i, j; size_t control_points, quantum; primitive_info=(*mvg_info->primitive_info)+mvg_info->offset; quantum=number_coordinates; for (i=0; i < (ssize_t) number_coordinates; i++) { for (j=i+1; j < (ssize_t) number_coordinates; j++) { alpha=fabs(primitive_info[j].point.x-primitive_info[i].point.x); if (alpha > (double) SSIZE_MAX) { (void) ThrowMagickException(mvg_info->exception,GetMagickModule(), ResourceLimitError,""MemoryAllocationFailed"",""`%s'"",""""); return(MagickFalse); } if (alpha > (double) quantum) quantum=(size_t) alpha; alpha=fabs(primitive_info[j].point.y-primitive_info[i].point.y); if (alpha > (double) SSIZE_MAX) { (void) ThrowMagickException(mvg_info->exception,GetMagickModule(), ResourceLimitError,""MemoryAllocationFailed"",""`%s'"",""""); return(MagickFalse); } if (alpha > (double) quantum) quantum=(size_t) alpha; } } quantum=MagickMin(quantum/number_coordinates,BezierQuantum); primitive_info=(*mvg_info->primitive_info)+mvg_info->offset; coefficients=(double *) AcquireQuantumMemory(number_coordinates, sizeof(*coefficients)); points=(PointInfo *) AcquireQuantumMemory(quantum,number_coordinates* sizeof(*points)); if ((coefficients == (double *) NULL) || (points == (PointInfo *) NULL)) { if (points != (PointInfo *) NULL) points=(PointInfo *) RelinquishMagickMemory(points); if (coefficients != (double *) NULL) coefficients=(double *) RelinquishMagickMemory(coefficients); (void) ThrowMagickException(mvg_info->exception,GetMagickModule(), ResourceLimitError,""MemoryAllocationFailed"",""`%s'"",""""); return(MagickFalse); } control_points=quantum*number_coordinates; if (CheckPrimitiveExtent(mvg_info,control_points+1) == MagickFalse) { points=(PointInfo *) RelinquishMagickMemory(points); coefficients=(double *) RelinquishMagickMemory(coefficients); return(MagickFalse); } end=primitive_info[number_coordinates-1].point; for (i=0; i < (ssize_t) number_coordinates; i++) coefficients[i]=Permutate((ssize_t) number_coordinates-1,i); weight=0.0; for (i=0; i < (ssize_t) control_points; i++) { p=primitive_info; point.x=0.0; point.y=0.0; alpha=pow((double) (1.0-weight),(double) number_coordinates-1.0); for (j=0; j < (ssize_t) number_coordinates; j++) { point.x+=alpha*coefficients[j]*p->point.x; point.y+=alpha*coefficients[j]*p->point.y; alpha*=weight/(1.0-weight); p++; } points[i]=point; weight+=1.0/control_points; } p=primitive_info; for (i=0; i < (ssize_t) control_points; i++) { if (TracePoint(p,points[i]) == MagickFalse) { points=(PointInfo *) RelinquishMagickMemory(points); coefficients=(double *) RelinquishMagickMemory(coefficients); return(MagickFalse); } p+=p->coordinates; } if (TracePoint(p,end) == MagickFalse) { points=(PointInfo *) RelinquishMagickMemory(points); coefficients=(double *) RelinquishMagickMemory(coefficients); return(MagickFalse); } p+=p->coordinates; primitive_info->coordinates=(size_t) (p-primitive_info); primitive_info->closed_subpath=MagickFalse; for (i=0; i < (ssize_t) primitive_info->coordinates; i++) { p->primitive=primitive_info->primitive; p--; } points=(PointInfo *) RelinquishMagickMemory(points); coefficients=(double *) RelinquishMagickMemory(coefficients); return(MagickTrue); }"
"struct clock_source *dcn10_clock_source_create( struct dc_context *ctx, struct dc_bios *bios, enum clock_source_id id, const struct dce110_clk_src_regs *regs, bool dp_clk_src) { struct dce110_clk_src *clk_src = kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); if (!clk_src) return NULL; if (dce112_clk_src_construct(clk_src, ctx, bios, id, regs, &cs_shift, &cs_mask)) { clk_src->base.dp_clk_src = dp_clk_src; return &clk_src->base; } BREAK_TO_DEBUGGER(); return NULL; }"
"static int sanitize_ptr_alu(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg, struct bpf_reg_state *dst_reg, struct bpf_insn_aux_data *tmp_aux, const bool commit_window) { struct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux; struct bpf_verifier_state *vstate = env->cur_state; bool off_is_neg = off_reg->smin_value < 0; bool ptr_is_dst_reg = ptr_reg == dst_reg; u8 opcode = BPF_OP(insn->code); u32 alu_state, alu_limit; struct bpf_reg_state tmp; bool ret; int err; if (can_skip_alu_sanitation(env, insn)) return 0; if (vstate->speculative) goto do_sim; err = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode); if (err < 0) return err; if (commit_window) { alu_state = tmp_aux->alu_state; alu_limit = abs(tmp_aux->alu_limit - alu_limit); } else { alu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0; alu_state |= ptr_is_dst_reg ? BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST; } err = update_alu_sanitation_state(aux, alu_state, alu_limit); if (err < 0) return err; do_sim: if (commit_window) return 0; if (!ptr_is_dst_reg) { tmp = *dst_reg; *dst_reg = *ptr_reg; } ret = push_stack(env, env->insn_idx + 1, env->insn_idx, true); if (!ptr_is_dst_reg && ret) *dst_reg = tmp; return !ret ? REASON_STACK : 0; }"
void LocalFrame::navigate(const FrameLoadRequest& request) { if (!isNavigationAllowed()) return; m_loader.load(request); }
"void jsP_dumpsyntax(js_State *J, js_Ast *prog, int dominify) { minify = dominify; if (prog->type == AST_LIST) pstmlist(-1, prog); else { pstm(0, prog); nl(); } if (minify > 1) putchar('\n'); }"
"Status XParseColor ( register Display *dpy, Colormap cmap, _Xconst char *spec, XColor *def) { register int n, i; int r, g, b; char c; XcmsCCC ccc; XcmsColor cmsColor; if (!spec) return(0); n = (int) strlen (spec); if (*spec == '#') { spec++; n--; if (n != 3 && n != 6 && n != 9 && n != 12) return (0); n /= 3; g = b = 0; do { r = g; g = b; b = 0; for (i = n; --i >= 0; ) { c = *spec++; b <<= 4; if (c >= '0' && c <= '9') b |= c - '0'; else if (c >= 'A' && c <= 'F') b |= c - ('A' - 10); else if (c >= 'a' && c <= 'f') b |= c - ('a' - 10); else return (0); } } while (*spec != '\0'); n <<= 2; n = 16 - n; def->red = r << n; def->green = g << n; def->blue = b << n; def->flags = DoRed | DoGreen | DoBlue; return (1); } #ifdef XCMS if ((ccc = XcmsCCCOfColormap(dpy, cmap)) != (XcmsCCC)NULL) { const char *tmpName = spec; switch (_XcmsResolveColorString(ccc, &tmpName, &cmsColor, XcmsRGBFormat)) { case XcmsSuccess: case XcmsSuccessWithCompression: cmsColor.pixel = def->pixel; _XcmsRGB_to_XColor(&cmsColor, def, 1); return(1); case XcmsFailure: case _XCMS_NEWNAME: break; } } #endif { xLookupColorReply reply; register xLookupColorReq *req; LockDisplay(dpy); GetReq (LookupColor, req); req->cmap = cmap; req->nbytes = (CARD16) (n = (int) strlen(spec)); req->length += (n + 3) >> 2; Data (dpy, spec, (long)n); if (!_XReply (dpy, (xReply *) &reply, 0, xTrue)) { UnlockDisplay(dpy); SyncHandle(); return (0); } def->red = reply.exactRed; def->green = reply.exactGreen; def->blue = reply.exactBlue; def->flags = DoRed | DoGreen | DoBlue; UnlockDisplay(dpy); SyncHandle(); return (1); } }"
"static ssize_t parse8BIM(Image *ifile, Image *ofile) { char brkused, quoted, *line, *token, *newstr, *name; int state, next; unsigned char dataset; unsigned int recnum; int inputlen = MagickPathExtent; MagickOffsetType savedpos, currentpos; ssize_t savedolen = 0L, outputlen = 0L; TokenInfo *token_info; dataset = 0; recnum = 0; line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line)); if (line == (char *) NULL) return(-1); newstr = name = token = (char *) NULL; savedpos = 0; token_info=AcquireTokenInfo(); while (super_fgets(&line,&inputlen,ifile)!=NULL) { state=0; next=0; token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token)); if (token == (char *) NULL) break; newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr)); if (newstr == (char *) NULL) break; while (Tokenizer(token_info,0,token,(size_t) inputlen,line,"""",""="",""\"""",0, &brkused,&next,&quoted)==0) { if (state == 0) { int state, next; char brkused, quoted; state=0; next=0; while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""#"", """", 0,&brkused,&next,&quoted)==0) { switch (state) { case 0: if (strcmp(newstr,""8BIM"")==0) dataset = 255; else dataset = (unsigned char) StringToLong(newstr); break; case 1: recnum = (unsigned int) StringToUnsignedLong(newstr); break; case 2: name=(char *) AcquireQuantumMemory(strlen(newstr)+MagickPathExtent, sizeof(*name)); if (name) (void) strcpy(name,newstr); break; } state++; } } else if (state == 1) { int next; ssize_t len; char brkused, quoted; next=0; len = (ssize_t) strlen(token); while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""&"", """",0,&brkused,&next,&quoted)==0) { if (brkused && next > 0) { size_t codes_length; char *s = &token[next-1]; codes_length=convertHTMLcodes(s, strlen(s)); if ((ssize_t) codes_length > len) len=0; else len-=codes_length; } } if (dataset == 255) { unsigned char nlen = 0; int i; if (savedolen > 0) { MagickOffsetType offset; ssize_t diff = outputlen - savedolen; currentpos = TellBlob(ofile); if (currentpos < 0) return(-1); offset=SeekBlob(ofile,savedpos,SEEK_SET); if (offset < 0) return(-1); (void) WriteBlobMSBLong(ofile,(unsigned int) diff); offset=SeekBlob(ofile,currentpos,SEEK_SET); if (offset < 0) return(-1); savedolen = 0L; } if (outputlen & 1) { (void) WriteBlobByte(ofile,0x00); outputlen++; } (void) WriteBlobString(ofile,""8BIM""); (void) WriteBlobMSBShort(ofile,(unsigned short) recnum); outputlen += 6; if (name) nlen = (unsigned char) strlen(name); (void) WriteBlobByte(ofile,nlen); outputlen++; for (i=0; i<nlen; i++) (void) WriteBlobByte(ofile,(unsigned char) name[i]); outputlen += nlen; if ((nlen & 0x01) == 0) { (void) WriteBlobByte(ofile,0x00); outputlen++; } if (recnum != IPTC_ID) { (void) WriteBlobMSBLong(ofile, (unsigned int) len); outputlen += 4; next=0; outputlen += len; while (len-- > 0) (void) WriteBlobByte(ofile,(unsigned char) token[next++]); if (outputlen & 1) { (void) WriteBlobByte(ofile,0x00); outputlen++; } } else { savedpos = TellBlob(ofile); if (savedpos < 0) return(-1); (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU); outputlen += 4; savedolen = outputlen; } } else { if (len <= 0x7FFF) { (void) WriteBlobByte(ofile,0x1c); (void) WriteBlobByte(ofile,(unsigned char) dataset); (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff)); (void) WriteBlobMSBShort(ofile,(unsigned short) len); outputlen += 5; next=0; outputlen += len; while (len-- > 0) (void) WriteBlobByte(ofile,(unsigned char) token[next++]); } } } state++; } if (token != (char *) NULL) token=DestroyString(token); if (newstr != (char *) NULL) newstr=DestroyString(newstr); if (name != (char *) NULL) name=DestroyString(name); } token_info=DestroyTokenInfo(token_info); if (token != (char *) NULL) token=DestroyString(token); if (newstr != (char *) NULL) newstr=DestroyString(newstr); if (name != (char *) NULL) name=DestroyString(name); line=DestroyString(line); if (savedolen > 0) { MagickOffsetType offset; ssize_t diff = outputlen - savedolen; currentpos = TellBlob(ofile); if (currentpos < 0) return(-1); offset=SeekBlob(ofile,savedpos,SEEK_SET); if (offset < 0) return(-1); (void) WriteBlobMSBLong(ofile,(unsigned int) diff); offset=SeekBlob(ofile,currentpos,SEEK_SET); if (offset < 0) return(-1); savedolen = 0L; } return outputlen; }"
"static MagickBooleanType DrawDashPolygon(const DrawInfo *draw_info, const PrimitiveInfo *primitive_info,Image *image,ExceptionInfo *exception) { DrawInfo *clone_info; double length, maximum_length, offset, scale, total_length; MagickStatusType status; PrimitiveInfo *dash_polygon; register ssize_t i; register double dx, dy; size_t number_vertices; ssize_t j, n; assert(draw_info != (const DrawInfo *) NULL); if (image->debug != MagickFalse) (void) LogMagickEvent(DrawEvent,GetMagickModule(),""    begin draw-dash""); for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ; number_vertices=(size_t) i; dash_polygon=(PrimitiveInfo *) AcquireQuantumMemory((size_t) (2UL*number_vertices+1UL),sizeof(*dash_polygon)); if (dash_polygon == (PrimitiveInfo *) NULL) return(MagickFalse); clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); clone_info->miterlimit=0; dash_polygon[0]=primitive_info[0]; scale=ExpandAffine(&draw_info->affine); length=scale*(draw_info->dash_pattern[0]-0.5); offset=draw_info->dash_offset != 0.0 ? scale*draw_info->dash_offset : 0.0; j=1; for (n=0; offset > 0.0; j=0) { if (draw_info->dash_pattern[n] <= 0.0) break; length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5)); if (offset > length) { offset-=length; n++; length=scale*(draw_info->dash_pattern[n]+0.5); continue; } if (offset < length) { length-=offset; offset=0.0; break; } offset=0.0; n++; } status=MagickTrue; maximum_length=0.0; total_length=0.0; for (i=1; (i < number_vertices) && (length >= 0.0); i++) { dx=primitive_info[i].point.x-primitive_info[i-1].point.x; dy=primitive_info[i].point.y-primitive_info[i-1].point.y; maximum_length=hypot((double) dx,dy); if (length == 0.0) { n++; if (draw_info->dash_pattern[n] == 0.0) n=0; length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5)); } for (total_length=0.0; (length >= 0.0) && (maximum_length >= (total_length+length)); ) { total_length+=length; if ((n & 0x01) != 0) { dash_polygon[0]=primitive_info[0]; dash_polygon[0].point.x=(double) (primitive_info[i-1].point.x+dx* total_length/maximum_length); dash_polygon[0].point.y=(double) (primitive_info[i-1].point.y+dy* total_length/maximum_length); j=1; } else { if ((j+1) > (ssize_t) (2*number_vertices)) break; dash_polygon[j]=primitive_info[i-1]; dash_polygon[j].point.x=(double) (primitive_info[i-1].point.x+dx* total_length/maximum_length); dash_polygon[j].point.y=(double) (primitive_info[i-1].point.y+dy* total_length/maximum_length); dash_polygon[j].coordinates=1; j++; dash_polygon[0].coordinates=(size_t) j; dash_polygon[j].primitive=UndefinedPrimitive; status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception); } n++; if (draw_info->dash_pattern[n] == 0.0) n=0; length=scale*(draw_info->dash_pattern[n]+(n == 0 ? -0.5 : 0.5)); } length-=(maximum_length-total_length); if ((n & 0x01) != 0) continue; dash_polygon[j]=primitive_info[i]; dash_polygon[j].coordinates=1; j++; } if ((total_length <= maximum_length) && ((n & 0x01) == 0) && (j > 1)) { dash_polygon[j]=primitive_info[i-1]; dash_polygon[j].point.x+=MagickEpsilon; dash_polygon[j].point.y+=MagickEpsilon; dash_polygon[j].coordinates=1; j++; dash_polygon[0].coordinates=(size_t) j; dash_polygon[j].primitive=UndefinedPrimitive; status&=DrawStrokePolygon(image,clone_info,dash_polygon,exception); } dash_polygon=(PrimitiveInfo *) RelinquishMagickMemory(dash_polygon); clone_info=DestroyDrawInfo(clone_info); if (image->debug != MagickFalse) (void) LogMagickEvent(DrawEvent,GetMagickModule(),""    end draw-dash""); return(status != 0 ? MagickTrue : MagickFalse); }"
"static BOOL handle_SSH2_newkeys(PTInstVar pvar) { logputs(LOG_LEVEL_VERBOSE, ""SSH2_MSG_NEWKEYS was received(DH key generation is completed).""); if (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) { save_memdump(LOGDUMP); } finish_memdump(); pvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED; ssh2_set_newkeys(pvar, MODE_IN); if (!CRYPT_start_encryption(pvar, 0, 1)) { } pvar->ssh2_keys[MODE_IN].mac.enabled = 1; pvar->ssh2_keys[MODE_IN].comp.enabled = 1; enable_recv_compression(pvar); SSH2_dispatch_add_message(SSH2_MSG_EXT_INFO); if (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) { if (pvar->kex_status & KEX_FLAG_REKEYING) { int i; Channel_t *c; do_SSH2_dispatch_setup_for_transfer(pvar); for (i = 0 ; i < CHANNEL_MAX ; i++) { c = &channels[i]; if (c->used) { ssh2_channel_retry_send_bufchain(pvar, c); } } } else { ssh2_finish_encryption_setup(pvar); ssh2_prep_userauth(pvar); } pvar->kex_status = KEX_FLAG_KEXDONE; } return TRUE; }"
"int pdf_is_pdf(FILE *fp) { int   is_pdf; char *header; header = get_header(fp); if (header && strstr(header, ""%PDF-"")) is_pdf = 1; else  is_pdf = 0; free(header); return is_pdf; }"
"bool GIFInput::read_subimage_data() { GifColorType* colormap = NULL; int colormap_count; if (m_gif_file->Image.ColorMap) {          colormap = m_gif_file->Image.ColorMap->Colors; colormap_count = m_gif_file->Image.ColorMap->ColorCount; } else if (m_gif_file->SColorMap) {          colormap = m_gif_file->SColorMap->Colors; colormap_count = m_gif_file->SColorMap->ColorCount; } else { errorf(""Neither local nor global colormap present.""); return false; } if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) { std::fill(m_canvas.begin(), m_canvas.end(), 0x00); } bool interlacing = m_spec.get_int_attribute(""gif:Interlacing"") != 0; int window_height = m_gif_file->Image.Height; int window_width  = m_gif_file->Image.Width; int window_top    = m_gif_file->Image.Top; int window_left   = m_gif_file->Image.Left; std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]); for (int wy = 0; wy < window_height; wy++) { if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) { report_last_error(); return false; } int y = window_top + (interlacing ? decode_line_number(wy, window_height) : wy); if (0 <= y && y < m_spec.height) { for (int wx = 0; wx < window_width; wx++) { if (fscanline[wx] >= colormap_count) { errorfmt(""Possible corruption: Encoded value {:d} @ ({},{}) exceeds palette size {}\n"", fscanline[wx], wx, y, colormap_count); return false; } int x   = window_left + wx; int idx = m_spec.nchannels * (y * m_spec.width + x); if (0 <= x && x < m_spec.width && fscanline[wx] != m_transparent_color) { m_canvas[idx]     = colormap[fscanline[wx]].Red; m_canvas[idx + 1] = colormap[fscanline[wx]].Green; m_canvas[idx + 2] = colormap[fscanline[wx]].Blue; m_canvas[idx + 3] = 0xff; } } } } return true; }"
"static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len, u32 off, u32 cnt) { struct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data; if (cnt == 1) return 0; new_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len); if (!new_data) return -ENOMEM; memcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off); memcpy(new_data + off + cnt - 1, old_data + off, sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1)); env->insn_aux_data = new_data; vfree(old_data); return 0; }"
"int nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_writeargs *args) { unsigned int len, hdr, dlen; struct kvec *head = rqstp->rq_arg.head; int v; p = decode_fh(p, &args->fh); if (!p) return 0; p++; args->offset = ntohl(*p++); p++; len = args->len = ntohl(*p++); if (len > NFSSVC_MAXBLKSIZE_V2) return 0; hdr = (void*)p - head->iov_base; dlen = head->iov_len + rqstp->rq_arg.page_len - hdr; if (dlen < XDR_QUADLEN(len)*4) return 0; rqstp->rq_vec[0].iov_base = (void*)p; rqstp->rq_vec[0].iov_len = head->iov_len - hdr; v = 0; while (len > rqstp->rq_vec[v].iov_len) { len -= rqstp->rq_vec[v].iov_len; v++; rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]); rqstp->rq_vec[v].iov_len = PAGE_SIZE; } rqstp->rq_vec[v].iov_len = len; args->vlen = v + 1; return 1; }"
"GF_Err audio_sample_entry_AddBox(GF_Box *s, GF_Box *a) { GF_MPEGAudioSampleEntryBox *ptr = (GF_MPEGAudioSampleEntryBox *)s; switch (a->type) { case GF_ISOM_BOX_TYPE_ESDS: if (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr) ptr->esd = (GF_ESDBox *)a; break; case GF_ISOM_BOX_TYPE_SINF: gf_list_add(ptr->protections, a); break; case GF_ISOM_BOX_TYPE_DAMR: case GF_ISOM_BOX_TYPE_DEVC: case GF_ISOM_BOX_TYPE_DQCP: case GF_ISOM_BOX_TYPE_DSMV: ptr->cfg_3gpp = (GF_3GPPConfigBox *) a; ptr->cfg_3gpp->cfg.type = ptr->type; break; case GF_ISOM_BOX_TYPE_DAC3: ptr->cfg_ac3 = (GF_AC3ConfigBox *) a; break; case GF_ISOM_BOX_TYPE_DEC3: ptr->cfg_ac3 = (GF_AC3ConfigBox *) a; break; case GF_ISOM_BOX_TYPE_MHA1: case GF_ISOM_BOX_TYPE_MHA2: case GF_ISOM_BOX_TYPE_MHM1: case GF_ISOM_BOX_TYPE_MHM2: ptr->cfg_mha = (GF_MHAConfigBox *) a; break; case GF_ISOM_BOX_TYPE_UNKNOWN: if (ptr->esd) ERROR_ON_DUPLICATED_BOX(a, ptr) { GF_UnknownBox *wave = (GF_UnknownBox *)a; if ((wave->original_4cc == GF_ISOM_BOX_TYPE_WAVE) && gf_list_count(wave->other_boxes)) { u32 i; for (i =0; i<gf_list_count(wave->other_boxes); i++) { GF_Box *inner_box = (GF_Box *)gf_list_get(wave->other_boxes, i); if (inner_box->type == GF_ISOM_BOX_TYPE_ESDS) { ptr->esd = (GF_ESDBox *)inner_box; } } return gf_isom_box_add_default(s, a); } else if (wave->data != NULL) { u32 offset = 0; while ((wave->data[offset + 4] != 'e') && (wave->data[offset + 5] != 's')) { offset++; if (offset == wave->dataSize) break; } if (offset < wave->dataSize) { GF_Box *a; GF_Err e; GF_BitStream *bs = gf_bs_new(wave->data + offset, wave->dataSize - offset, GF_BITSTREAM_READ); e = gf_isom_box_parse(&a, bs); gf_bs_del(bs); if (e) return e; ptr->esd = (GF_ESDBox *)a; gf_isom_box_add_for_dump_mode((GF_Box *)ptr, a); } GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Cannot process box %s!\n"", gf_4cc_to_str(wave->original_4cc))); return gf_isom_box_add_default(s, a); } gf_isom_box_del(a); return GF_ISOM_INVALID_MEDIA; } break; default: return gf_isom_box_add_default(s, a); } return GF_OK; }"
"void Context::onLog() { if (wasm_->onLog_) { wasm_->onLog_(this, id_); } }"
"static void ok_wav_decode_ms_ima_adpcm_data(ok_wav_decoder *decoder) { ok_wav *wav = decoder->wav; struct ok_wav_ima_state *channel_states = NULL; uint8_t *block = NULL; uint8_t num_channels = wav->num_channels; const uint64_t max_output_frames = wav->num_frames + 7;     const uint64_t output_data_length = max_output_frames * sizeof(int16_t) * num_channels; const size_t platform_data_length = (size_t)output_data_length; channel_states = calloc(num_channels, sizeof(struct ok_wav_ima_state)); if (!channel_states) { ok_wav_error(wav, ""Couldn't allocate channel_state buffer""); goto done; } block = malloc(decoder->block_size); if (!block) { ok_wav_error(wav, ""Couldn't allocate block""); goto done; } if (platform_data_length > 0 && platform_data_length == output_data_length) { wav->data = malloc(platform_data_length); } if (!wav->data) { ok_wav_error(wav, ""Couldn't allocate memory for audio""); goto done; } uint64_t remaining_frames = wav->num_frames; int16_t *output = wav->data; while (remaining_frames > 0) { const uint64_t block_frames = min(remaining_frames, decoder->frames_per_block); int64_t frames = (int64_t)block_frames; if (!ok_read(decoder, block, decoder->block_size)) { goto done; } uint8_t *input = block; for (int channel = 0; channel < num_channels; channel++) { int16_t sample = (int16_t)(wav->little_endian ? readLE16(input) : readBE16(input)); channel_states[channel].predictor = sample; channel_states[channel].step_index = (int8_t)input[2]; input += 4; *output++ = sample; } frames--; while (frames > 0) { for (int channel = 0; channel < num_channels; channel++) { struct ok_wav_ima_state *channel_state = channel_states + channel; int16_t *channel_output = output + channel;  for (int i = 0; i < 4; i++) { *channel_output = ok_wav_decode_ima_adpcm_nibble(channel_state, (*input) & 0x0f); channel_output += num_channels; *channel_output = ok_wav_decode_ima_adpcm_nibble(channel_state, (*input) >> 4); channel_output += num_channels; input++; } } frames -= 8; output += 8 * num_channels; } remaining_frames -= block_frames; } const int n = 1; const bool system_is_little_endian = *(const char *)&n == 1; wav->little_endian = system_is_little_endian; wav->bit_depth = 16; done: free(block); free(channel_states); }"
"static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt, void (*get)(struct x86_emulate_ctxt *ctxt, struct desc_ptr *ptr)) { struct desc_ptr desc_ptr; if (ctxt->mode == X86EMUL_MODE_PROT64) ctxt->op_bytes = 8; get(ctxt, &desc_ptr); if (ctxt->op_bytes == 2) { ctxt->op_bytes = 4; desc_ptr.address &= 0x00ffffff; } ctxt->dst.type = OP_NONE; return segmented_write(ctxt, ctxt->dst.addr.mem, &desc_ptr, 2 + ctxt->op_bytes); }"
"static int wb_prep(netdissect_options *ndo, const struct pkt_prep *prep, u_int len) { int n; const struct pgstate *ps; const u_char *ep = ndo->ndo_snapend; ND_PRINT((ndo, "" wb-prep:"")); if (len < sizeof(*prep)) { return (-1); } n = EXTRACT_32BITS(&prep->pp_n); ps = (const struct pgstate *)(prep + 1); while (--n >= 0 && ND_TTEST(*ps)) { const struct id_off *io, *ie; char c = '<'; ND_PRINT((ndo, "" %u/%s:%u"", EXTRACT_32BITS(&ps->slot), ipaddr_string(ndo, &ps->page.p_sid), EXTRACT_32BITS(&ps->page.p_uid))); io = (const struct id_off *)(ps + 1); for (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) { ND_PRINT((ndo, ""%c%s:%u"", c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off))); c = ','; } ND_PRINT((ndo, "">"")); ps = (const struct pgstate *)io; } return ((const u_char *)ps <= ep? 0 : -1); }"
"static jobject getMethodAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags) { jobject returnValue = NULL; J9VMThread *vmThread = (J9VMThread *) env; J9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions; SunReflectCPResult result = NULL_POINTER_EXCEPTION; jmethodID methodID = NULL; UDATA cpType = J9CPTYPE_UNUSED; if (NULL != constantPoolOop) { J9RAMConstantRef *ramConstantRef = NULL; jclass jlClass = NULL; vmFunctions->internalEnterVMFromJNI(vmThread); result = getRAMConstantRefAndType(vmThread, constantPoolOop, cpIndex, &cpType, &ramConstantRef); if (OK == result) { J9Method *method = NULL; J9Class *cpClass = J9CLASS_FROMCPINTERNALRAMCLASS(vmThread, constantPoolOop); J9ConstantPool *constantPool = J9_CP_FROM_CLASS(cpClass); switch (cpType) { case J9CPTYPE_HANDLE_METHOD:  case J9CPTYPE_INSTANCE_METHOD:  case J9CPTYPE_INTERFACE_INSTANCE_METHOD: method = ((J9RAMMethodRef *) ramConstantRef)->method; if ((NULL == method) || (NULL == method->constantPool)) { if (0 == vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method)) { clearException(vmThread); method = vmFunctions->resolveSpecialMethodRef(vmThread, constantPool, cpIndex, resolveFlags); } if (NULL == method) { clearException(vmThread); method = vmFunctions->resolveStaticMethodRefInto(vmThread, constantPool, cpIndex, resolveFlags, NULL); } } break; case J9CPTYPE_STATIC_METHOD:  case J9CPTYPE_INTERFACE_STATIC_METHOD: method = ((J9RAMStaticMethodRef *) ramConstantRef)->method; if ((NULL == method) || (NULL == method->constantPool)) { method = vmFunctions->resolveStaticMethodRef(vmThread, constantPool, cpIndex, resolveFlags); if (NULL == method) { clearException(vmThread); vmFunctions->resolveVirtualMethodRef(vmThread, constantPool, cpIndex, resolveFlags, &method); } } break; case J9CPTYPE_INTERFACE_METHOD: method = vmFunctions->resolveInterfaceMethodRef(vmThread, constantPool, cpIndex, resolveFlags); break; default: result = WRONG_CP_ENTRY_TYPE_EXCEPTION; break; } if (NULL != method) { methodID = (jmethodID) vmFunctions->getJNIMethodID(vmThread, method); jlClass = vmFunctions->j9jni_createLocalRef(env, cpClass->classObject); } } vmFunctions->internalExitVMToJNI(vmThread); if (NULL != methodID) { if (NULL != jlClass) { const jboolean isStatic = (J9CPTYPE_STATIC_METHOD == cpType) || (J9CPTYPE_INTERFACE_STATIC_METHOD == cpType); returnValue = (*env)->ToReflectedMethod(env, jlClass, methodID, isStatic); } else { vmFunctions->throwNativeOOMError(env, 0, 0); } } } checkResult(env, result); return returnValue; }"
"static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx, struct vrend_shader *vs, struct vrend_shader *fs, struct vrend_shader *gs) { struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program); char name[16]; int i; GLuint prog_id; GLint lret; int id; int last_shader; if (!sprog) return NULL; if ((gs && gs->compiled_fs_id != fs->id) || (!gs && vs->compiled_fs_id != fs->id)) { bool ret; if (gs) vrend_patch_vertex_shader_interpolants(gs->glsl_prog, &gs->sel->sinfo, &fs->sel->sinfo, true, fs->key.flatshade); else vrend_patch_vertex_shader_interpolants(vs->glsl_prog, &vs->sel->sinfo, &fs->sel->sinfo, false, fs->key.flatshade); ret = vrend_compile_shader(ctx, gs ? gs : vs); if (ret == false) { glDeleteShader(gs ? gs->id : vs->id); free(sprog); return NULL; } if (gs) gs->compiled_fs_id = fs->id; else vs->compiled_fs_id = fs->id; } prog_id = glCreateProgram(); glAttachShader(prog_id, vs->id); if (gs) { if (gs->id > 0) glAttachShader(prog_id, gs->id); set_stream_out_varyings(prog_id, &gs->sel->sinfo); } else set_stream_out_varyings(prog_id, &vs->sel->sinfo); glAttachShader(prog_id, fs->id); if (fs->sel->sinfo.num_outputs > 1) { if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) { glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0""); glBindFragDataLocationIndexed(prog_id, 0, 1, ""fsout_c1""); sprog->dual_src_linked = true; } else { glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0""); glBindFragDataLocationIndexed(prog_id, 1, 0, ""fsout_c1""); sprog->dual_src_linked = false; } } else sprog->dual_src_linked = false; if (vrend_state.have_vertex_attrib_binding) { uint32_t mask = vs->sel->sinfo.attrib_input_mask; while (mask) { i = u_bit_scan(&mask); snprintf(name, 10, ""in_%d"", i); glBindAttribLocation(prog_id, i, name); } } glLinkProgram(prog_id); glGetProgramiv(prog_id, GL_LINK_STATUS, &lret); if (lret == GL_FALSE) { char infolog[65536]; int len; glGetProgramInfoLog(prog_id, 65536, &len, infolog); fprintf(stderr,""got error linking\n%s\n"", infolog); report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0); fprintf(stderr,""vert shader: %d GLSL\n%s\n"", vs->id, vs->glsl_prog); if (gs) fprintf(stderr,""geom shader: %d GLSL\n%s\n"", gs->id, gs->glsl_prog); fprintf(stderr,""frag shader: %d GLSL\n%s\n"", fs->id, fs->glsl_prog); glDeleteProgram(prog_id); return NULL; } sprog->ss[PIPE_SHADER_VERTEX] = vs; sprog->ss[PIPE_SHADER_FRAGMENT] = fs; sprog->ss[PIPE_SHADER_GEOMETRY] = gs; list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs); list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs); if (gs) list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs); last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT; sprog->id = prog_id; list_addtail(&sprog->head, &ctx->sub->programs); if (fs->key.pstipple_tex) sprog->fs_stipple_loc = glGetUniformLocation(prog_id, ""pstipple_sampler""); else sprog->fs_stipple_loc = -1; sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, ""winsys_adjust""); for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.samplers_used_mask) { uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask; int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask); int index; sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask; if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) { sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t)); sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t)); } else { sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL; } sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t)); if (sprog->samp_locs[id]) { const char *prefix = pipe_shader_to_prefix(id); index = 0; while(mask) { i = u_bit_scan(&mask); snprintf(name, 10, ""%ssamp%d"", prefix, i); sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name); if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) { snprintf(name, 14, ""%sshadmask%d"", prefix, i); sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name); snprintf(name, 14, ""%sshadadd%d"", prefix, i); sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name); } index++; } } } else { sprog->samp_locs[id] = NULL; sprog->shadow_samp_mask_locs[id] = NULL; sprog->shadow_samp_add_locs[id] = NULL; sprog->shadow_samp_mask[id] = 0; } sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask; } for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.num_consts) { sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t)); if (sprog->const_locs[id]) { const char *prefix = pipe_shader_to_prefix(id); for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) { snprintf(name, 16, ""%sconst0[%d]"", prefix, i); sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name); } } } else sprog->const_locs[id] = NULL; } if (!vrend_state.have_vertex_attrib_binding) { if (vs->sel->sinfo.num_inputs) { sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t)); if (sprog->attrib_locs) { for (i = 0; i < vs->sel->sinfo.num_inputs; i++) { snprintf(name, 10, ""in_%d"", i); sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name); } } } else sprog->attrib_locs = NULL; } for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.num_ubos) { const char *prefix = pipe_shader_to_prefix(id); sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t)); for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) { snprintf(name, 16, ""%subo%d"", prefix, i + 1); sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name); } } else sprog->ubo_locs[id] = NULL; } if (vs->sel->sinfo.num_ucp) { for (i = 0; i < vs->sel->sinfo.num_ucp; i++) { snprintf(name, 10, ""clipp[%d]"", i); sprog->clip_locs[i] = glGetUniformLocation(prog_id, name); } } return sprog; }"
"int main(int argc, char** argv) { GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); cxxopts::Options options(""htm"", ""Headless terminal multiplexer""); options.allow_unrecognised_options(); options.add_options()             (""help"", ""Print help"")        (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")        ; auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } setvbuf(stdin, NULL, _IONBF, 0);     setvbuf(stdout, NULL, _IONBF, 0);   termios terminal_local; tcgetattr(0, &terminal_local); memcpy(&terminal_backup, &terminal_local, sizeof(struct termios)); cfmakeraw(&terminal_local); tcsetattr(0, TCSANOW, &terminal_local); struct sigaction action; memset(&action, 0, sizeof(struct sigaction)); action.sa_handler = term; sigaction(SIGTERM, &action, NULL); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); el::Loggers::setVerboseLevel(3); string maxlogsize = ""20971520""; LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + ""htm.log"", maxlogsize); LogHandler::stderrToFile(GetTempDirectory() + ""htm""); el::Loggers::reconfigureLogger(""default"", defaultConf); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); uid_t myuid = getuid(); if (result.count(""x"")) { LOG(INFO) << ""Killing previous htmd""; string command = string(""pkill -x -U "") + to_string(myuid) + string("" htmd""); system(command.c_str()); } string command = string(""pgrep -x -U "") + to_string(myuid) + string("" htmd""); string pgrepOutput = SystemToStr(command.c_str()); if (pgrepOutput.length() == 0) { int result = DaemonCreator::create(false, """"); if (result == DaemonCreator::CHILD) { exit(system(""htmd"")); } } std::this_thread::sleep_for(std::chrono::microseconds( 10 * 1000));    shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler()); SocketEndpoint pipeEndpoint; pipeEndpoint.set_name(HtmServer::getPipeName()); HtmClient htmClient(socketHandler, pipeEndpoint); htmClient.run(); char buf[] = { 0x1b, 0x5b, '$', '$', '$', 'q', }; RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf)); fflush(stdout); tcsetattr(0, TCSANOW, &terminal_backup); return 0; }"
"static int cfg80211_add_nontrans_list(struct cfg80211_bss *trans_bss, struct cfg80211_bss *nontrans_bss) { const struct element *ssid_elem; struct cfg80211_bss *bss = NULL; rcu_read_lock(); ssid_elem = ieee80211_bss_get_elem(nontrans_bss, WLAN_EID_SSID); if (!ssid_elem) { rcu_read_unlock(); return -EINVAL; } list_for_each_entry(bss, &trans_bss->nontrans_list, nontrans_list) { if (is_bss(bss, nontrans_bss->bssid, ssid_elem->data, ssid_elem->datalen)) { rcu_read_unlock(); return 0; } } rcu_read_unlock(); list_add_tail(&nontrans_bss->nontrans_list, &trans_bss->nontrans_list); return 0; }"
static void vmei_reset_teardown(void *param) { struct virtio_mei *vmei = param; vmei->reset_mevp = NULL; pthread_mutex_destroy(&vmei->mutex); free(vmei->config); free(vmei); }
"static int apparmor_setprocattr(struct task_struct *task, char *name, void *value, size_t size) { struct common_audit_data sa; struct apparmor_audit_data aad = {0,}; char *command, *args = value; size_t arg_size; int error; if (size == 0) return -EINVAL; if (args[size - 1] != '\0') { if (size == PAGE_SIZE) return -EINVAL; args[size] = '\0'; } if (current != task) return -EACCES; args = value; args = strim(args); command = strsep(&args, "" ""); if (!args) return -EINVAL; args = skip_spaces(args); if (!*args) return -EINVAL; arg_size = size - (args - (char *) value); if (strcmp(name, ""current"") == 0) { if (strcmp(command, ""changehat"") == 0) { error = aa_setprocattr_changehat(args, arg_size, !AA_DO_TEST); } else if (strcmp(command, ""permhat"") == 0) { error = aa_setprocattr_changehat(args, arg_size, AA_DO_TEST); } else if (strcmp(command, ""changeprofile"") == 0) { error = aa_setprocattr_changeprofile(args, !AA_ONEXEC, !AA_DO_TEST); } else if (strcmp(command, ""permprofile"") == 0) { error = aa_setprocattr_changeprofile(args, !AA_ONEXEC, AA_DO_TEST); } else goto fail; } else if (strcmp(name, ""exec"") == 0) { if (strcmp(command, ""exec"") == 0) error = aa_setprocattr_changeprofile(args, AA_ONEXEC, !AA_DO_TEST); else goto fail; } else return -EINVAL; if (!error) error = size; return error; fail: sa.type = LSM_AUDIT_DATA_NONE; sa.aad = &aad; aad.profile = aa_current_profile(); aad.op = OP_SETPROCATTR; aad.info = name; aad.error = -EINVAL; aa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL); return -EINVAL; }"
"static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh, struct mschmd_header *chm, int entire) { unsigned int section, name_len, x, errors, num_chunks; unsigned char buf[0x54], *chunk = NULL, *name, *p, *end; struct mschmd_file *fi, *link = NULL; off_t offset, length; int num_entries; chm->files         = NULL; chm->sysfiles      = NULL; chm->chunk_cache   = NULL; chm->sec0.base.chm = chm; chm->sec0.base.id  = 0; chm->sec1.base.chm = chm; chm->sec1.base.id  = 1; chm->sec1.content  = NULL; chm->sec1.control  = NULL; chm->sec1.spaninfo = NULL; chm->sec1.rtable   = NULL; if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) { return MSPACK_ERR_READ; } if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) { return MSPACK_ERR_SIGNATURE; } if (memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) { D((""incorrect GUIDs"")) return MSPACK_ERR_SIGNATURE; } chm->version   = EndGetI32(&buf[chmhead_Version]); chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]); chm->language  = EndGetI32(&buf[chmhead_LanguageID]); if (chm->version > 3) { sys->message(fh, ""WARNING; CHM version > 3""); } if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) || read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) || read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) { return MSPACK_ERR_READ; } chm->dir_offset = sys->tell(fh); chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]); chm->density    = EndGetI32(&buf[chmhs1_Density]); chm->depth      = EndGetI32(&buf[chmhs1_Depth]); chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]); chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]); chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]); chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]); if (chm->version < 3) { chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks); } if (chm->sec0.offset > chm->length) { D((""content section begins after file has ended"")) return MSPACK_ERR_DATAFORMAT; } if (chm->chunk_size < (pmgl_Entries + 2)) { D((""chunk size not large enough"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks == 0) { D((""no chunks"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks > 100000) { D((""more than 100,000 chunks"")) return MSPACK_ERR_DATAFORMAT; }    if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) { D((""chunks larger than entire file"")) return MSPACK_ERR_DATAFORMAT; } if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) { sys->message(fh, ""WARNING; chunk size is not a power of two""); } if (chm->first_pmgl != 0) { sys->message(fh, ""WARNING; first PMGL chunk is not zero""); } if (chm->first_pmgl > chm->last_pmgl) { D((""first pmgl chunk is after last pmgl chunk"")) return MSPACK_ERR_DATAFORMAT; } if (chm->index_root != 0xFFFFFFFF && chm->index_root >= chm->num_chunks) { D((""index_root outside valid range"")) return MSPACK_ERR_DATAFORMAT; } if (!entire) { return MSPACK_ERR_OK; } if ((x = chm->first_pmgl) != 0) { if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) { return MSPACK_ERR_SEEK; } } num_chunks = chm->last_pmgl - x + 1; if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) { return MSPACK_ERR_NOMEMORY; } errors = 0; while (num_chunks--) { if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) { sys->free(chunk); return MSPACK_ERR_READ; } if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue; if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) { sys->message(fh, ""WARNING; PMGL quickref area is too small""); } if (EndGetI32(&chunk[pmgl_QuickRefSize]) >  ((int)chm->chunk_size - pmgl_Entries)) { sys->message(fh, ""WARNING; PMGL quickref area is too large""); } p = &chunk[pmgl_Entries]; end = &chunk[chm->chunk_size - 2]; num_entries = EndGetI16(end); while (num_entries--) { READ_ENCINT(name_len); if (name_len > (unsigned int) (end - p)) goto chunk_end; name = p; p += name_len; READ_ENCINT(section); READ_ENCINT(offset); READ_ENCINT(length); if (name_len < 2 || !name[0] || !name[1]) continue; if ((offset == 0) && (length == 0)) { if ((name_len > 0) && (name[name_len-1] == '/')) continue; } if (section > 1) { sys->message(fh, ""invalid section number '%u'."", section); continue; } if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) { sys->free(chunk); return MSPACK_ERR_NOMEMORY; } fi->next     = NULL; fi->filename = (char *) &fi[1]; fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0) : (struct mschmd_section *) (&chm->sec1)); fi->offset   = offset; fi->length   = length; sys->copy(name, fi->filename, (size_t) name_len); fi->filename[name_len] = '\0'; if (name[0] == ':' && name[1] == ':') { if (memcmp(&name[2], &content_name[2], 31L) == 0) { if (memcmp(&name[33], &content_name[33], 8L) == 0) { chm->sec1.content = fi; } else if (memcmp(&name[33], &control_name[33], 11L) == 0) { chm->sec1.control = fi; } else if (memcmp(&name[33], &spaninfo_name[33], 8L) == 0) { chm->sec1.spaninfo = fi; } else if (memcmp(&name[33], &rtable_name[33], 72L) == 0) { chm->sec1.rtable = fi; } } fi->next = chm->sysfiles; chm->sysfiles = fi; } else { if (link) link->next = fi; else chm->files = fi; link = fi; } } chunk_end: if (num_entries >= 0) { D((""chunk ended before all entries could be read"")) errors++; } } sys->free(chunk); return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK; }"
"static void dissect_rsvp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean e2ei) { guint8 message_type; int    session_off, tempfilt_off; rsvp_conversation_info  *rsvph; conversation_t          *conversation; struct rsvp_request_key  request_key, *new_request_key; struct rsvp_request_val *request_val; col_clear(pinfo->cinfo, COL_INFO); message_type = tvb_get_guint8(tvb, 1); rsvph = wmem_new0(wmem_packet_scope(), rsvp_conversation_info); set_address(&rsvph->source, pinfo->src.type, pinfo->src.len, pinfo->src.data); set_address(&rsvph->destination, pinfo->dst.type, pinfo->dst.len, pinfo->dst.data); col_add_str(pinfo->cinfo, COL_INFO, val_to_str_ext(message_type, &message_type_vals_ext, ""Unknown (%u). "")); if (message_type == RSVP_MSG_BUNDLE) { col_set_str(pinfo->cinfo, COL_INFO, rsvp_bundle_dissect ? ""Component Messages Dissected"" : ""Component Messages Not Dissected""); } else { find_rsvp_session_tempfilt(tvb, 0, &session_off, &tempfilt_off); if (session_off) col_append_str(pinfo->cinfo, COL_INFO, summary_session(tvb, session_off)); if (tempfilt_off) col_append_str(pinfo->cinfo, COL_INFO, summary_template(tvb, tempfilt_off)); } dissect_rsvp_msg_tree(tvb, pinfo, tree, TREE(TT_RSVP), rsvph, e2ei); if ((message_type == RSVP_MSG_ACK)      || (message_type == RSVP_MSG_SREFRESH) || (message_type == RSVP_MSG_HELLO)) return; conversation = find_or_create_conversation(pinfo); memset(&request_key, 0, sizeof(request_key)); request_key.conversation = conversation->index; request_key.session_type = rsvph->session_type; switch (request_key.session_type) { case RSVP_SESSION_TYPE_IPV4: set_address(&request_key.u.session_ipv4.destination, rsvph->destination.type, rsvph->destination.len, rsvph->destination.data); request_key.u.session_ipv4.protocol = rsvph->protocol; request_key.u.session_ipv4.udp_dest_port = rsvph->udp_dest_port; break; case RSVP_SESSION_TYPE_IPV6: break; case RSVP_SESSION_TYPE_IPV4_LSP: set_address(&request_key.u.session_ipv4_lsp.destination, rsvph->destination.type, rsvph->destination.len, rsvph->destination.data); request_key.u.session_ipv4_lsp.udp_dest_port = rsvph->udp_dest_port; request_key.u.session_ipv4_lsp.ext_tunnel_id = rsvph->ext_tunnel_id; break; case RSVP_SESSION_TYPE_AGGREGATE_IPV4: set_address(&request_key.u.session_agg_ipv4.destination, rsvph->destination.type, rsvph->destination.len, rsvph->destination.data); request_key.u.session_agg_ipv4.dscp = rsvph->dscp; break; case RSVP_SESSION_TYPE_IPV4_UNI: set_address(&request_key.u.session_ipv4_uni.destination, rsvph->destination.type, rsvph->destination.len, rsvph->destination.data); request_key.u.session_ipv4_uni.udp_dest_port = rsvph->udp_dest_port; request_key.u.session_ipv4_uni.ext_tunnel_id = rsvph->ext_tunnel_id; break; case RSVP_SESSION_TYPE_IPV4_E_NNI: set_address(&request_key.u.session_ipv4_enni.destination, rsvph->destination.type, rsvph->destination.len, rsvph->destination.data); request_key.u.session_ipv4_enni.udp_dest_port = rsvph->udp_dest_port; request_key.u.session_ipv4_enni.ext_tunnel_id = rsvph->ext_tunnel_id; break; default: proto_tree_add_expert(tree, pinfo, &ei_rsvp_session_type, tvb, 0, 0); break; } copy_address_wmem(wmem_file_scope(), &request_key.source_info.source, &rsvph->source); request_key.source_info.udp_source_port = rsvph->udp_source_port; request_val = (struct rsvp_request_val *) g_hash_table_lookup(rsvp_request_hash, &request_key); if (!request_val) { new_request_key = (struct rsvp_request_key *)wmem_memdup( wmem_file_scope(), &request_key, sizeof(struct rsvp_request_key)); request_val = wmem_new(wmem_file_scope(), struct rsvp_request_val); request_val->value = conversation->index; g_hash_table_insert(rsvp_request_hash, new_request_key, request_val); } tap_queue_packet(rsvp_tap, pinfo, rsvph); }"
"static void lsi_do_msgout(LSIState *s) { uint8_t msg; int len; uint32_t current_tag; lsi_request *current_req, *p, *p_next; if (s->current) { current_tag = s->current->tag; current_req = s->current; } else { current_tag = s->select_tag; current_req = lsi_find_by_tag(s, current_tag); } trace_lsi_do_msgout(s->dbc); while (s->dbc) { msg = lsi_get_msgbyte(s); s->sfbr = msg; switch (msg) { case 0x04: trace_lsi_do_msgout_disconnect(); lsi_disconnect(s); break; case 0x08: trace_lsi_do_msgout_noop(); lsi_set_phase(s, PHASE_CMD); break; case 0x01: len = lsi_get_msgbyte(s); msg = lsi_get_msgbyte(s); (void)len;  trace_lsi_do_msgout_extended(msg, len); switch (msg) { case 1: trace_lsi_do_msgout_ignored(""SDTR""); lsi_skip_msgbytes(s, 2); break; case 3: trace_lsi_do_msgout_ignored(""WDTR""); lsi_skip_msgbytes(s, 1); break; case 4: trace_lsi_do_msgout_ignored(""PPR""); lsi_skip_msgbytes(s, 5); break; default: goto bad; } break; case 0x20:  s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; trace_lsi_do_msgout_simplequeue(s->select_tag & 0xff); break; case 0x21:  qemu_log_mask(LOG_UNIMP, ""lsi_scsi: HEAD queue not implemented\n""); s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; break; case 0x22:  qemu_log_mask(LOG_UNIMP, ""lsi_scsi: ORDERED queue not implemented\n""); s->select_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID; break; case 0x0d: trace_lsi_do_msgout_abort(current_tag); if (current_req) { scsi_req_cancel(current_req->req); } lsi_disconnect(s); break; case 0x06: case 0x0e: case 0x0c: if (msg == 0x06) { trace_lsi_do_msgout_abort(current_tag); } if (msg == 0x0e) { trace_lsi_do_msgout_clearqueue(current_tag); } if (msg == 0x0c) { trace_lsi_do_msgout_busdevicereset(current_tag); } if (s->current) { scsi_req_cancel(s->current->req); } QTAILQ_FOREACH_SAFE(p, &s->queue, next, p_next) { if ((p->tag & 0x0000ff00) == (current_tag & 0x0000ff00)) { scsi_req_cancel(p->req); } } lsi_disconnect(s); break; default: if ((msg & 0x80) == 0) { goto bad; } s->current_lun = msg & 7; trace_lsi_do_msgout_select(s->current_lun); lsi_set_phase(s, PHASE_CMD); break; } } return; bad: qemu_log_mask(LOG_UNIMP, ""Unimplemented message 0x%02x\n"", msg); lsi_set_phase(s, PHASE_MI); lsi_add_msg_byte(s, 7);  s->msg_action = LSI_MSG_ACTION_COMMAND; }"
"int gdAlphaBlend (int dst, int src) { int src_alpha = gdTrueColorGetAlpha(src); int dst_alpha, alpha, red, green, blue; int src_weight, dst_weight, tot_weight; if( src_alpha == gdAlphaOpaque ) return src; dst_alpha = gdTrueColorGetAlpha(dst); if( src_alpha == gdAlphaTransparent ) return dst; if( dst_alpha == gdAlphaTransparent ) return src; src_weight = gdAlphaTransparent - src_alpha; dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax; tot_weight = src_weight + dst_weight; alpha = src_alpha * dst_alpha / gdAlphaMax; red = (gdTrueColorGetRed(src) * src_weight + gdTrueColorGetRed(dst) * dst_weight) / tot_weight; green = (gdTrueColorGetGreen(src) * src_weight + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight; blue = (gdTrueColorGetBlue(src) * src_weight + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight; return ((alpha << 24) + (red << 16) + (green << 8) + blue); }"
"H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering) { u32 rv = 0; decContainer_t *pDecCont; DEC_API_TRC(""H264SwDecInit#""); if ( ((-1)>>1) != (-1) ) { DEC_API_TRC(""H264SwDecInit# ERROR: Right shift is not signed""); return(H264SWDEC_INITFAIL); } if (decInst == NULL) { DEC_API_TRC(""H264SwDecInit# ERROR: decInst == NULL""); return(H264SWDEC_PARAM_ERR); } pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t)); if (pDecCont == NULL) { DEC_API_TRC(""H264SwDecInit# ERROR: Memory allocation failed""); return(H264SWDEC_MEMFAIL); } #ifdef H264DEC_TRACE sprintf(pDecCont->str, ""H264SwDecInit# decInst %p noOutputReordering %d"", (void*)decInst, noOutputReordering); DEC_API_TRC(pDecCont->str); #endif rv = h264bsdInit(&pDecCont->storage, noOutputReordering); if (rv != HANTRO_OK) { H264SwDecRelease(pDecCont); return(H264SWDEC_MEMFAIL); } pDecCont->decStat  = INITIALIZED; pDecCont->picNumber = 0; #ifdef H264DEC_TRACE sprintf(pDecCont->str, ""H264SwDecInit# OK: return %p"", (void*)pDecCont); DEC_API_TRC(pDecCont->str); #endif *decInst = (decContainer_t *)pDecCont; return(H264SWDEC_OK); }"
"inline typename V::VariantType FBUnserializer<V>::unserializeThing() { size_t code = nextCode(); switch (code) { case FB_SERIALIZE_BYTE: case FB_SERIALIZE_I16: case FB_SERIALIZE_I32: case FB_SERIALIZE_I64: return V::fromInt64(unserializeInt64()); case FB_SERIALIZE_VARCHAR: case FB_SERIALIZE_STRING: return V::fromString(unserializeString()); case FB_SERIALIZE_STRUCT: return V::fromMap(unserializeMap()); case FB_SERIALIZE_NULL: ++p_; return V::createNull(); case FB_SERIALIZE_DOUBLE: return V::fromDouble(unserializeDouble()); case FB_SERIALIZE_BOOLEAN: return V::fromBool(unserializeBoolean()); case FB_SERIALIZE_VECTOR: return V::fromVector(unserializeVector()); case FB_SERIALIZE_LIST: return V::fromVector(unserializeList()); case FB_SERIALIZE_SET: return V::fromSet(unserializeSet()); default: throw UnserializeError(""Invalid code: "" + folly::to<std::string>(code) + "" at location "" + folly::to<std::string>(p_)); } }"
"String_Obj Parser::parse_ie_keyword_arg() { String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3); if (lex< variable >()) { kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed))); } else { lex< alternatives< identifier_schema, identifier > >(); kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed)); } lex< exactly<'='> >(); kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed)); if (peek< variable >()) kwd_arg->append(parse_list()); else if (lex< number >()) { std::string parsed(lexed); Util::normalize_decimals(parsed); kwd_arg->append(lexed_number(parsed)); } else if (peek < ie_keyword_arg_value >()) { kwd_arg->append(parse_list()); } return kwd_arg; }"
"static void mctp_unregister(struct net_device *dev) { struct mctp_dev *mdev; mdev = mctp_dev_get_rtnl(dev); if (mdev && !mctp_known(dev)) { netdev_warn(dev, ""%s: BUG mctp_ptr set for unknown type %d"", __func__, dev->type); return; } if (!mdev) return; RCU_INIT_POINTER(mdev->dev->mctp_ptr, NULL); mctp_route_remove_dev(mdev); mctp_neigh_remove_dev(mdev); kfree(mdev->addrs); mctp_dev_put(mdev); }"
"static void ax25_kill_by_device(struct net_device *dev) { ax25_dev *ax25_dev; ax25_cb *s; struct sock *sk; if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) return; spin_lock_bh(&ax25_list_lock); again: ax25_for_each(s, &ax25_list) { if (s->ax25_dev == ax25_dev) { sk = s->sk; sock_hold(sk); spin_unlock_bh(&ax25_list_lock); lock_sock(sk); s->ax25_dev = NULL; ax25_dev_put(ax25_dev); release_sock(sk); ax25_disconnect(s, ENETUNREACH); spin_lock_bh(&ax25_list_lock); sock_put(sk); goto again; } } spin_unlock_bh(&ax25_list_lock); }"
"static int read_2004_compressed_section (Bit_Chain *dat, Dwg_Data *restrict dwg, Bit_Chain *sec_dat, Dwg_Section_Type type) { uint32_t address, sec_mask, initial_address; uint32_t max_decomp_size; long bytes_left; Dwg_Section_Info *info = NULL; encrypted_section_header es; BITCODE_RC *decomp; BITCODE_BL i, j; int error = 0; for (i = 0; i < dwg->header.section_infohdr.num_desc && !info; ++i) { if (dwg->header.section_info[i].fixedtype == type) { info = &dwg->header.section_info[i]; break; } } sec_dat->chain = NULL;   if (!info) { if (type < SECTION_REVHISTORY && type != SECTION_TEMPLATE && type != SECTION_OBJFREESPACE) { LOG_WARN (""Failed to find section_info[%u] with type %d"", i, type) } else { LOG_TRACE (""Found no section_info[%u] with type %d\n"", i, type) } return DWG_ERR_SECTIONNOTFOUND; } else { LOG_TRACE (""\nFound section_info["" FORMAT_BL ""] %s type %d with %d sections (%scompressed):\n"", i, info->name, type, info->num_sections, info->compressed == 2 ? """" : ""un""); } max_decomp_size = info->num_sections * info->max_decomp_size; if (info->num_sections == 0) return 0; if (max_decomp_size == 0 || max_decomp_size > 0x2f000000)     { LOG_ERROR (""Invalid section %s count or max decompression size. "" ""Sections: %u, Max size: %u"", info->name, info->num_sections, info->max_decomp_size); return DWG_ERR_INVALIDDWG; } decomp = (BITCODE_RC *)calloc (max_decomp_size, sizeof (BITCODE_RC)); if (!decomp) { LOG_ERROR (""Out of memory with %u sections"", info->num_sections); return DWG_ERR_OUTOFMEM; } bytes_left = max_decomp_size; initial_address = info->sections[0] ? info->sections[0]->address : 0; sec_dat->bit = 0; sec_dat->byte = 0; sec_dat->version = dat->version; sec_dat->from_version = dat->from_version; sec_dat->chain = decomp; for (i = 0; i < info->num_sections; ++i) { if (!info->sections[i]) { LOG_WARN (""Skip empty section %u %s"", i, info->name); continue; } address = info->sections[i]->address; dat->byte = address; bit_read_fixed (dat, es.char_data, 32); sec_mask = 0x4164536b ^ address; for (j = 0; j < 8; ++j) es.long_data[j] ^= sec_mask; LOG_INFO (""=== Section %s (%u) @%u ===\n"", info->name, i, address) if (es.fields.tag != 0x4163043b) { LOG_WARN (""Section Tag:      0x%x  (should be 0x4163043b)"", (unsigned)es.fields.tag); } else { LOG_INFO (""Section Tag:      0x%x\n"", (unsigned)es.fields.tag); } LOG_INFO (""Section Type:     %u\n"", (unsigned)es.fields.section_type) LOG_INFO (""Data size:        0x%x/%u\n"", (unsigned)es.fields.data_size, (unsigned)es.fields.data_size) LOG_INFO (""Comp data size:   0x%x\n"", (unsigned)es.fields.section_size) LOG_TRACE (""StartOffset:      0x%x\n"", (unsigned)es.fields.address) LOG_HANDLE (""Unknown:          0x%x\n"", (unsigned)es.fields.unknown) LOG_HANDLE (""Checksum1:        0x%x\n"", (unsigned)es.fields.checksum_1) LOG_HANDLE (""Checksum2:        0x%x\n"", (unsigned)es.fields.checksum_2) LOG_TRACE (""Section start:    %lu\n\n"", dat->byte); LOG_INSANE (""info[%d]->max_decomp_size: %lu (0x%lx)\n"", i, (unsigned long)info->max_decomp_size, (unsigned long)info->max_decomp_size) LOG_INSANE (""max_decomp_size:          %lu (0x%lx)\n"", (unsigned long)max_decomp_size, (unsigned long)max_decomp_size) LOG_INSANE (""bytes_left:               %ld\n"", bytes_left); if (info->compressed == 2 && bytes_left > 0 && (i * info->max_decomp_size) <= max_decomp_size) { error = decompress_R2004_section ( dat, &decomp[i * info->max_decomp_size],               info->max_decomp_size, es.fields.data_size); if (error > DWG_ERR_CRITICAL) { sec_dat->chain = NULL;               free (decomp); return error; } bytes_left -= info->max_decomp_size; sec_dat->size = max_decomp_size; } else { if (info->compressed == 2 || info->size > max_decomp_size || bytes_left < 0 ) { LOG_ERROR (""Some section size out of bounds"") sec_dat->chain = NULL; free (decomp); return type < SECTION_REVHISTORY ? DWG_ERR_INVALIDDWG : DWG_ERR_VALUEOUTOFBOUNDS; } memcpy (&decomp[i * info->size], &dat->chain[address + es.fields.address + 32], MIN (bytes_left, info->size)); bytes_left -= info->size; sec_dat->size = max_decomp_size; } } return error; }"
"static int libxl__device_pci_assignable_remove(libxl__gc *gc, libxl_device_pci *pcidev, int rebind) { int rc; char *driver_path; if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) { return ERROR_FAIL; } else if ( rc ) { pciback_dev_unassign(gc, pcidev); } else { LOG(WARN, ""Not bound to pciback""); } driver_path = pci_assignable_driver_path_read(gc, pcidev); if ( driver_path ) { if ( rebind ) { LOG(INFO, ""Rebinding to driver at %s"", driver_path); if ( sysfs_write_bdf(gc, GCSPRINTF(""%s/bind"", driver_path), pcidev) < 0 ) { LOGE(ERROR, ""Couldn't bind device to %s"", driver_path); return -1; } pci_assignable_driver_path_remove(gc, pcidev); } } else { if ( rebind ) { LOG(WARN, ""Couldn't find path for original driver; not rebinding""); } } return 0; }"
"static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr) { struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx; struct tipc_aead_key *skey = NULL; u16 key_gen = msg_key_gen(hdr); u16 size = msg_data_sz(hdr); u8 *data = msg_data(hdr); spin_lock(&rx->lock); if (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) { pr_err(""%s: key existed <%p>, gen %d vs %d\n"", rx->name, rx->skey, key_gen, rx->key_gen); goto exit; } skey = kmalloc(size, GFP_ATOMIC); if (unlikely(!skey)) { pr_err(""%s: unable to allocate memory for skey\n"", rx->name); goto exit; } skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME))); memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME); memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32), skey->keylen); if (unlikely(size != tipc_aead_key_size(skey))) { kfree(skey); skey = NULL; goto exit; } rx->key_gen = key_gen; rx->skey_mode = msg_key_mode(hdr); rx->skey = skey; rx->nokey = 0; mb();  exit: spin_unlock(&rx->lock); if (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0))) return true; return false; }"
"long keyctl_set_reqkey_keyring(int reqkey_defl) { struct cred *new; int ret, old_setting; old_setting = current_cred_xxx(jit_keyring); if (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE) return old_setting; new = prepare_creds(); if (!new) return -ENOMEM; switch (reqkey_defl) { case KEY_REQKEY_DEFL_THREAD_KEYRING: ret = install_thread_keyring_to_cred(new); if (ret < 0) goto error; goto set; case KEY_REQKEY_DEFL_PROCESS_KEYRING: ret = install_process_keyring_to_cred(new); if (ret < 0) { if (ret != -EEXIST) goto error; ret = 0; } goto set; case KEY_REQKEY_DEFL_DEFAULT: case KEY_REQKEY_DEFL_SESSION_KEYRING: case KEY_REQKEY_DEFL_USER_KEYRING: case KEY_REQKEY_DEFL_USER_SESSION_KEYRING: case KEY_REQKEY_DEFL_REQUESTOR_KEYRING: goto set; case KEY_REQKEY_DEFL_NO_CHANGE: case KEY_REQKEY_DEFL_GROUP_KEYRING: default: ret = -EINVAL; goto error; } set: new->jit_keyring = reqkey_defl; commit_creds(new); return old_setting; error: abort_creds(new); return ret; }"
"bool JT_PushMessage::take(const QDomElement &e) { if(e.tagName() != ""message"") return false; QDomElement e1 = e; QDomElement forward; Message::CarbonDir cd = Message::NoCarbon; QDomNodeList list = e1.childNodes(); for (int i = 0; i < list.size(); ++i) { QDomElement el = list.at(i).toElement(); if (el.attribute(""xmlns"") == QLatin1String(""urn:xmpp:carbons:2"") && (el.tagName() == QLatin1String(""received"") || el.tagName() == QLatin1String(""sent""))) { QDomElement el1 = el.firstChildElement(); if (el1.tagName() == QLatin1String(""forwarded"") && el1.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) { QDomElement el2 = el1.firstChildElement(QLatin1String(""message"")); if (!el2.isNull()) { forward = el2; cd = el.tagName() == QLatin1String(""received"")? Message::Received : Message::Sent; break; } } } else if (el.tagName() == QLatin1String(""forwarded"") && el.attribute(QLatin1String(""xmlns"")) == QLatin1String(""urn:xmpp:forward:0"")) { forward = el.firstChildElement(QLatin1String(""message"")); if (!forward.isNull()) { break; } } } QString from = e1.attribute(QLatin1String(""from"")); Stanza s = client()->stream().createStanza(addCorrectNS(forward.isNull()? e1 : forward)); if(s.isNull()) { return false; } Message m; if(!m.fromStanza(s, client()->manualTimeZoneOffset(), client()->timeZoneOffset())) { return false; } if (!forward.isNull()) { m.setForwardedFrom(Jid(from)); m.setCarbonDirection(cd); } emit message(m); return true; }"
void FrameLoader::dispatchDocumentElementAvailable() { client()->documentElementAvailable(); }
"void Client::encryptConnection() { boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23}; const auto remote_hostname = *client_options_.remote_hostname_; bool verify_hostname = false; if (client_options_.always_verify_peer_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); verify_hostname = true; } else { ctx.set_verify_mode(boost::asio::ssl::verify_none); } if (client_options_.server_certificate_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); ctx.load_verify_file(*client_options_.server_certificate_); verify_hostname = true; } if (client_options_.verify_path_) { ctx.set_verify_mode(boost::asio::ssl::verify_peer); ctx.add_verify_path(*client_options_.verify_path_); verify_hostname = true; } if (client_options_.ciphers_) { ::SSL_CTX_set_cipher_list(ctx.native_handle(), client_options_.ciphers_->c_str()); } if (client_options_.ssl_options_) { ctx.set_options(client_options_.ssl_options_); } if (client_options_.client_certificate_file_) { ctx.use_certificate_file(*client_options_.client_certificate_file_, boost::asio::ssl::context::pem); } if (client_options_.client_private_key_file_) { ctx.use_private_key_file(*client_options_.client_private_key_file_, boost::asio::ssl::context::pem); } ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx); ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(), remote_hostname.c_str()); if (verify_hostname) { ssl_sock_->set_verify_callback( boost::asio::ssl::rfc2818_verification(remote_hostname)); } callNetworkOperation([&]() { ssl_sock_->async_handshake( boost::asio::ssl::stream_base::client, std::bind(&Client::handshakeHandler, this, std::placeholders::_1)); }); if (ec_) { throw std::system_error(ec_); } }"
"db_result_t storage_put_index(index_t *index) { char filename[INDEX_NAME_LENGTH]; int fd; int r; struct index_record record; db_result_t result; merge_strings(filename, index->rel->name, INDEX_NAME_SUFFIX); fd = cfs_open(filename, CFS_WRITE | CFS_APPEND); if(fd < 0) { return DB_STORAGE_ERROR; } strcpy(record.attribute_name, index->attr->name); memcpy(record.file_name, index->descriptor_file, sizeof(record.file_name)); record.type = index->type; result = DB_OK; r = cfs_write(fd, &record, sizeof(record)); if(r < sizeof(record)) { result = DB_STORAGE_ERROR; } else { PRINTF(""DB: Wrote an index record for %s.%s, type %d\n"", index->rel->name, index->attr->name, record.type); } cfs_close(fd); return result; }"
"void ih264d_init_decoder(void * ps_dec_params) { dec_struct_t * ps_dec = (dec_struct_t *)ps_dec_params; dec_slice_params_t *ps_cur_slice; pocstruct_t *ps_prev_poc, *ps_cur_poc; ih264d_free_dynamic_bufs(ps_dec); ps_cur_slice = ps_dec->ps_cur_slice; ps_dec->init_done = 0; ps_dec->u4_num_cores = 1; ps_dec->u2_pic_ht = ps_dec->u2_pic_wd = 0; ps_dec->u1_separate_parse = DEFAULT_SEPARATE_PARSE; ps_dec->u4_app_disable_deblk_frm = 0; ps_dec->i4_degrade_type = 0; ps_dec->i4_degrade_pics = 0; ps_dec->i4_app_skip_mode = IVD_SKIP_NONE; ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE; memset(ps_dec->ps_pps, 0, ((sizeof(dec_pic_params_t)) * MAX_NUM_PIC_PARAMS)); memset(ps_dec->ps_sps, 0, ((sizeof(dec_seq_params_t)) * MAX_NUM_SEQ_PARAMS)); ps_dec->p_DeblockPicture[0] = ih264d_deblock_picture_non_mbaff; ps_dec->p_DeblockPicture[1] = ih264d_deblock_picture_mbaff; ps_dec->s_cab_dec_env.pv_codec_handle = ps_dec; ps_dec->u4_num_fld_in_frm = 0; ps_dec->ps_dpb_mgr->pv_codec_handle = ps_dec; ps_dec->ps_sei->u1_is_valid = 0; ps_dec->ps_cur_pps = NULL; ps_dec->ps_cur_sps = NULL; ps_dec->u1_init_dec_flag = 0; ps_dec->u1_first_slice_in_stream = 1; ps_dec->u1_first_pb_nal_in_pic = 1; ps_dec->u1_last_pic_not_decoded = 0; ps_dec->u4_app_disp_width = 0; ps_dec->i4_header_decoded = 0; ps_dec->u4_total_frames_decoded = 0; ps_dec->i4_error_code = 0; ps_dec->i4_content_type = -1; ps_dec->ps_cur_slice->u1_mbaff_frame_flag = 0; ps_dec->ps_dec_err_status->u1_err_flag = ACCEPT_ALL_PICS;     ps_dec->ps_dec_err_status->u1_cur_pic_type = PIC_TYPE_UNKNOWN; ps_dec->ps_dec_err_status->u4_frm_sei_sync = SYNC_FRM_DEFAULT; ps_dec->ps_dec_err_status->u4_cur_frm = INIT_FRAME; ps_dec->ps_dec_err_status->u1_pic_aud_i = PIC_TYPE_UNKNOWN; ps_dec->u1_pr_sl_type = 0xFF; ps_dec->u2_mbx = 0xffff; ps_dec->u2_mby = 0; ps_dec->u2_total_mbs_coded = 0; ps_prev_poc = &ps_dec->s_prev_pic_poc; ps_cur_poc = &ps_dec->s_cur_pic_poc; ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb = 0; ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb = 0; ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom = 0; ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0] = 0; ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1] = 0; ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0; ps_prev_poc->i4_top_field_order_count = ps_cur_poc->i4_top_field_order_count = 0; ps_prev_poc->i4_bottom_field_order_count = ps_cur_poc->i4_bottom_field_order_count = 0; ps_prev_poc->u1_bot_field = ps_cur_poc->u1_bot_field = 0; ps_prev_poc->u1_mmco_equalto5 = ps_cur_poc->u1_mmco_equalto5 = 0; ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst = 0; ps_cur_slice->u1_mmco_equalto5 = 0; ps_cur_slice->u2_frame_num = 0; ps_dec->i4_max_poc = 0; ps_dec->i4_prev_max_display_seq = 0; ps_dec->u1_recon_mb_grp = 4; ps_dec->u1_second_field = 0; ps_dec->s_prev_seq_params.u1_eoseq_pending = 0; ps_dec->u2_crop_offset_y = 0; ps_dec->u2_crop_offset_uv = 0; ps_dec->i4_vui_frame_rate = -1; ps_dec->i4_pic_type = -1; ps_dec->i4_frametype = -1; ps_dec->i4_content_type = -1; ps_dec->u1_res_changed = 0; ps_dec->u1_frame_decoded_flag = 0; ps_dec->u4_skip_frm_mask = SKIP_NONE; ps_dec->pf_cavlc_4x4res_block[0] = ih264d_cavlc_4x4res_block_totalcoeff_1; ps_dec->pf_cavlc_4x4res_block[1] = ih264d_cavlc_4x4res_block_totalcoeff_2to10; ps_dec->pf_cavlc_4x4res_block[2] = ih264d_cavlc_4x4res_block_totalcoeff_11to16; ps_dec->pf_cavlc_parse4x4coeff[0] = ih264d_cavlc_parse4x4coeff_n0to7; ps_dec->pf_cavlc_parse4x4coeff[1] = ih264d_cavlc_parse4x4coeff_n8; ps_dec->pf_cavlc_parse_8x8block[0] = ih264d_cavlc_parse_8x8block_none_available; ps_dec->pf_cavlc_parse_8x8block[1] = ih264d_cavlc_parse_8x8block_left_available; ps_dec->pf_cavlc_parse_8x8block[2] = ih264d_cavlc_parse_8x8block_top_available; ps_dec->pf_cavlc_parse_8x8block[3] = ih264d_cavlc_parse_8x8block_both_available; ps_dec->pf_fill_bs1[0][0] = ih264d_fill_bs1_16x16mb_pslice; ps_dec->pf_fill_bs1[0][1] = ih264d_fill_bs1_non16x16mb_pslice; ps_dec->pf_fill_bs1[1][0] = ih264d_fill_bs1_16x16mb_bslice; ps_dec->pf_fill_bs1[1][1] = ih264d_fill_bs1_non16x16mb_bslice; ps_dec->pf_fill_bs_xtra_left_edge[0] = ih264d_fill_bs_xtra_left_edge_cur_frm; ps_dec->pf_fill_bs_xtra_left_edge[1] = ih264d_fill_bs_xtra_left_edge_cur_fld; ih264d_init_ref_bufs(ps_dec->ps_dpb_mgr); ps_dec->u2_prv_frame_num = 0; ps_dec->u1_top_bottom_decoded = 0; ps_dec->u1_dangling_field = 0; ps_dec->s_cab_dec_env.cabac_table = gau4_ih264d_cabac_table; ps_dec->pu1_left_mv_ctxt_inc = ps_dec->u1_left_mv_ctxt_inc_arr[0]; ps_dec->pi1_left_ref_idx_ctxt_inc = &ps_dec->i1_left_ref_idx_ctx_inc_arr[0][0]; ps_dec->pu1_left_yuv_dc_csbp = &ps_dec->u1_yuv_dc_csbp_topmb; ps_dec->u1_flushfrm = 0; { ps_dec->s_cab_dec_env.pv_codec_handle = (void*)ps_dec; ps_dec->ps_bitstrm->pv_codec_handle = (void*)ps_dec; ps_dec->ps_cur_slice->pv_codec_handle = (void*)ps_dec; ps_dec->ps_dpb_mgr->pv_codec_handle = (void*)ps_dec; } memset(ps_dec->disp_bufs, 0, (MAX_DISP_BUFS_NEW) * sizeof(disp_buf_t)); memset(ps_dec->u4_disp_buf_mapping, 0, (MAX_DISP_BUFS_NEW) * sizeof(UWORD32)); memset(ps_dec->u4_disp_buf_to_be_freed, 0, (MAX_DISP_BUFS_NEW) * sizeof(UWORD32)); ih264d_init_arch(ps_dec); ih264d_init_function_ptr(ps_dec); ps_dec->e_frm_out_mode = IVD_DISPLAY_FRAME_OUT; ps_dec->init_done = 1; }"
"static bool GetUpdateFile( update_t *p_update ) { stream_t *p_stream = NULL; char *psz_version_line = NULL; char *psz_update_data = NULL; p_stream = stream_UrlNew( p_update->p_libvlc, UPDATE_VLC_STATUS_URL ); if( !p_stream ) { msg_Err( p_update->p_libvlc, ""Failed to open %s for reading"", UPDATE_VLC_STATUS_URL ); goto error; } const int64_t i_read = stream_Size( p_stream ); psz_update_data = malloc( i_read + 1 );  if( !psz_update_data ) goto error; if( stream_Read( p_stream, psz_update_data, i_read ) != i_read ) { msg_Err( p_update->p_libvlc, ""Couldn't download update file %s"", UPDATE_VLC_STATUS_URL ); goto error; } psz_update_data[i_read] = '\0'; stream_Delete( p_stream ); p_stream = NULL; char *psz_update_data_parser = psz_update_data; size_t i_len = strcspn( psz_update_data, ""\r\n"" ); psz_update_data_parser += i_len; while( *psz_update_data_parser == '\r' || *psz_update_data_parser == '\n' ) psz_update_data_parser++; if( !(psz_version_line = malloc( i_len + 1)) ) goto error; strncpy( psz_version_line, psz_update_data, i_len ); psz_version_line[i_len] = '\0'; p_update->release.i_extra = 0; int ret = sscanf( psz_version_line, ""%i.%i.%i.%i"", &p_update->release.i_major, &p_update->release.i_minor, &p_update->release.i_revision, &p_update->release.i_extra); if( ret != 3 && ret != 4 ) { msg_Err( p_update->p_libvlc, ""Update version false formated"" ); goto error; } i_len = strcspn( psz_update_data_parser, ""\r\n"" ); if( i_len == 0 ) { msg_Err( p_update->p_libvlc, ""Update file %s is corrupted: URL missing"", UPDATE_VLC_STATUS_URL ); goto error; } if( !(p_update->release.psz_url = malloc( i_len + 1)) ) goto error; strncpy( p_update->release.psz_url, psz_update_data_parser, i_len ); p_update->release.psz_url[i_len] = '\0'; psz_update_data_parser += i_len; while( *psz_update_data_parser == '\r' || *psz_update_data_parser == '\n' ) psz_update_data_parser++; i_len = strlen( psz_update_data_parser ); if( i_len == 0 ) { msg_Err( p_update->p_libvlc, ""Update file %s is corrupted: description missing"", UPDATE_VLC_STATUS_URL ); goto error; } if( !(p_update->release.psz_desc = malloc( i_len + 1)) ) goto error; strncpy( p_update->release.psz_desc, psz_update_data_parser, i_len ); p_update->release.psz_desc[i_len] = '\0'; signature_packet_t sign; if( download_signature( VLC_OBJECT( p_update->p_libvlc ), &sign, UPDATE_VLC_STATUS_URL ) != VLC_SUCCESS ) { msg_Err( p_update->p_libvlc, ""Couldn't download signature of status file"" ); goto error; } if( sign.type != BINARY_SIGNATURE && sign.type != TEXT_SIGNATURE ) { msg_Err( p_update->p_libvlc, ""Invalid signature type"" ); goto error; } p_update->p_pkey = (public_key_t*)malloc( sizeof( public_key_t ) ); if( !p_update->p_pkey ) goto error; if( parse_public_key( videolan_public_key, sizeof( videolan_public_key ), p_update->p_pkey, NULL ) != VLC_SUCCESS ) { msg_Err( p_update->p_libvlc, ""Couldn't parse embedded public key, something went really wrong..."" ); FREENULL( p_update->p_pkey ); goto error; } memcpy( p_update->p_pkey->longid, videolan_public_key_longid, 8 ); if( memcmp( sign.issuer_longid, p_update->p_pkey->longid , 8 ) != 0 ) { msg_Dbg( p_update->p_libvlc, ""Need to download the GPG key"" ); public_key_t *p_new_pkey = download_key( VLC_OBJECT(p_update->p_libvlc), sign.issuer_longid, videolan_public_key_longid ); if( !p_new_pkey ) { msg_Err( p_update->p_libvlc, ""Couldn't download GPG key"" ); FREENULL( p_update->p_pkey ); goto error; } uint8_t *p_hash = hash_from_public_key( p_new_pkey ); if( !p_hash ) { msg_Err( p_update->p_libvlc, ""Failed to hash signature"" ); free( p_new_pkey ); FREENULL( p_update->p_pkey ); goto error; } if( verify_signature( &p_new_pkey->sig, &p_update->p_pkey->key, p_hash ) == VLC_SUCCESS ) { free( p_hash ); msg_Info( p_update->p_libvlc, ""Key authenticated"" ); free( p_update->p_pkey ); p_update->p_pkey = p_new_pkey; } else { free( p_hash ); msg_Err( p_update->p_libvlc, ""Key signature invalid !"" ); goto error; } } uint8_t *p_hash = hash_from_text( psz_update_data, &sign ); if( !p_hash ) { msg_Warn( p_update->p_libvlc, ""Can't compute hash for status file"" ); goto error; } else if( p_hash[0] != sign.hash_verification[0] || p_hash[1] != sign.hash_verification[1] ) { msg_Warn( p_update->p_libvlc, ""Bad hash for status file"" ); free( p_hash ); goto error; } else if( verify_signature( &sign, &p_update->p_pkey->key, p_hash ) != VLC_SUCCESS ) { msg_Err( p_update->p_libvlc, ""BAD SIGNATURE for status file"" ); free( p_hash ); goto error; } else { msg_Info( p_update->p_libvlc, ""Status file authenticated"" ); free( p_hash ); free( psz_version_line ); free( psz_update_data ); return true; } error: if( p_stream ) stream_Delete( p_stream ); free( psz_version_line ); free( psz_update_data ); return false; }"
"char *build_local_reparse(tm_cell_t *Trans,unsigned int branch, unsigned int *len, char *method, int method_len, str *to , struct cancel_reason *reason ) { char*invite_buf, *invite_buf_end; char*cancel_buf; char*s, *s1, *d; shortinvite_len; enum _hdr_types_thf_type; intfirst_via, to_len; int cancel_buf_len; int reason_len, code_len; struct hdr_field *reas1, *reas_last, *hdr; int hadded = 0; sr_cfgenv_t *cenv = NULL; invite_buf = Trans->uac[branch].request.buffer; invite_len = Trans->uac[branch].request.buffer_len; if (!invite_buf || invite_len<=0) { LM_ERR(""INVITE is missing\n""); goto error; } if ((*invite_buf != 'I') && (*invite_buf != 'i')) { LM_ERR(""trying to build with local reparse"" "" for a non-INVITE request?\n""); goto error; } reason_len = 0; reas1 = 0; reas_last = 0; if (reason && reason->cause != CANCEL_REAS_UNKNOWN){ if (likely(reason->cause > 0 && cfg_get(tm, tm_cfg, local_cancel_reason))){ reason_len = REASON_PREFIX_LEN + USHORT2SBUF_MAX_LEN + (reason->u.text.s? REASON_TEXT_LEN + 1 + reason->u.text.len + 1 : 0) + CRLF_LEN; } else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS && !(Trans->flags & T_NO_E2E_CANCEL_REASON))) { reason_len = reason->u.packed_hdrs.len; } else if (reason->cause == CANCEL_REAS_RCVD_CANCEL && reason->u.e2e_cancel && !(Trans->flags & T_NO_E2E_CANCEL_REASON)) { if(parse_headers(reason->u.e2e_cancel, HDR_EOH_F, 0)<0) { LM_WARN(""failed to parse headers\n""); } for(hdr=get_hdr(reason->u.e2e_cancel, HDR_REASON_T), reas1=hdr; hdr; hdr=next_sibling_hdr(hdr)) { reason_len += hdr->len; reas_last=hdr; } } else if (unlikely(reason->cause < CANCEL_REAS_MIN)) LM_BUG(""unhandled reason cause %d\n"", reason->cause); } invite_buf_end = invite_buf + invite_len; s = invite_buf; to_len = to ? to->len : 0; cancel_buf_len = invite_len + to_len + reason_len; cancel_buf = shm_malloc(sizeof(char)*cancel_buf_len); if (!cancel_buf) { SHM_MEM_ERROR; goto error; } d = cancel_buf; append_str(d, method, method_len); *d = ' '; d++; s += 7; s1 = s; s = eat_line(s, invite_buf_end - s); append_str(d, s1, s - s1); cenv = sr_cfgenv_get(); first_via = 1; while (s < invite_buf_end) { s1 = s; if ((*s == '\n') || (*s == '\r')) { hf_type = HDR_EOH_T; } else { s = lw_get_hf_name(s, invite_buf_end, &hf_type); } switch(hf_type) { case HDR_CSEQ_T: while ((s < invite_buf_end) && ((*s == ':') || (*s == ' ') || (*s == '\t') || ((*s >= '0') && (*s <= '9'))) ) s++; append_str(d, s1, s - s1); append_str(d, method, method_len); append_str(d, CRLF, CRLF_LEN); s = lw_next_line(s, invite_buf_end); break; case HDR_VIA_T: s = lw_next_line(s, invite_buf_end); if (first_via) { append_str(d, s1, s - s1); first_via = 0; }  break; case HDR_TO_T: if (to_len == 0) { s = lw_next_line(s, invite_buf_end); append_str(d, s1, s - s1); } else { append_str(d, to->s, to->len); s = lw_next_line(s, invite_buf_end); } break; case HDR_FROM_T: case HDR_CALLID_T: case HDR_ROUTE_T: case HDR_MAXFORWARDS_T: s = lw_next_line(s, invite_buf_end); append_str(d, s1, s - s1); break; case HDR_REQUIRE_T: case HDR_PROXYREQUIRE_T: s = lw_next_line(s, invite_buf_end); break; case HDR_CONTENTLENGTH_T: append_str(d, s1, s - s1); append_str(d, "": 0"" CRLF, 3 + CRLF_LEN); s = lw_next_line(s, invite_buf_end); break; case HDR_EOH_T: if (reason_len) { if (likely(reason->cause > 0)) { append_str(d, REASON_PREFIX, REASON_PREFIX_LEN); code_len=ushort2sbuf(reason->cause, d, cancel_buf_len-(int)(d-cancel_buf)); if (unlikely(code_len==0)) LM_BUG(""not enough space to write reason code""); d+=code_len; if (reason->u.text.s){ append_str(d, REASON_TEXT, REASON_TEXT_LEN); *d='""'; d++; append_str(d, reason->u.text.s, reason->u.text.len); *d='""'; d++; } append_str(d, CRLF, CRLF_LEN); } else if (likely(reason->cause == CANCEL_REAS_PACKED_HDRS)) { append_str(d, reason->u.packed_hdrs.s, reason->u.packed_hdrs.len); } else if (reason->cause == CANCEL_REAS_RCVD_CANCEL) { for(hdr=reas1; hdr; hdr=next_sibling_hdr(hdr)) { append_str(d, hdr->name.s, hdr->len); if (likely(hdr==reas_last)) break; } } } append_str(d, CRLF, CRLF_LEN); *len = d - cancel_buf; return cancel_buf; default: s = lw_next_line(s, invite_buf_end); hadded = 0; if(Trans->uas.request && (Trans->uas.request->msg_flags & FL_UAC_AUTH)) { if(s1 + cenv->uac_cseq_auth.len + 2 < invite_buf_end) { if(s1[cenv->uac_cseq_auth.len]==':' && strncmp(s1, cenv->uac_cseq_auth.s, cenv->uac_cseq_auth.len)==0) { hadded = 1; append_str(d, s1, s - s1); } else if(s1[cenv->uac_cseq_refresh.len]==':' && strncmp(s1, cenv->uac_cseq_refresh.s, cenv->uac_cseq_refresh.len)==0) { hadded = 1; append_str(d, s1, s - s1); } } } if(likely(hadded==0)) { if (cfg_get(tm, tm_cfg, ac_extra_hdrs).len && (s1 + cfg_get(tm, tm_cfg, ac_extra_hdrs).len < invite_buf_end) && (strncasecmp(s1, cfg_get(tm, tm_cfg, ac_extra_hdrs).s, cfg_get(tm, tm_cfg, ac_extra_hdrs).len) == 0)) { append_str(d, s1, s - s1); } } break; } } LM_ERR(""HDR_EOH_T was not found\n""); shm_free(cancel_buf); error: LM_ERR(""cannot build %.*s request\n"", method_len, method); return NULL; }"
"static int sfq_init(struct Qdisc *sch, struct nlattr *opt, struct netlink_ext_ack *extack) { struct sfq_sched_data *q = qdisc_priv(sch); int i; int err; q->sch = sch; timer_setup(&q->perturb_timer, sfq_perturbation, TIMER_DEFERRABLE); err = tcf_block_get(&q->block, &q->filter_list, sch, extack); if (err) return err; for (i = 0; i < SFQ_MAX_DEPTH + 1; i++) { q->dep[i].next = i + SFQ_MAX_FLOWS; q->dep[i].prev = i + SFQ_MAX_FLOWS; } q->limit = SFQ_MAX_DEPTH; q->maxdepth = SFQ_MAX_DEPTH; q->cur_depth = 0; q->tail = NULL; q->divisor = SFQ_DEFAULT_HASH_DIVISOR; q->maxflows = SFQ_DEFAULT_FLOWS; q->quantum = psched_mtu(qdisc_dev(sch)); q->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum); q->perturb_period = 0; q->perturbation = prandom_u32(); if (opt) { int err = sfq_change(sch, opt); if (err) return err; } q->ht = sfq_alloc(sizeof(q->ht[0]) * q->divisor); q->slots = sfq_alloc(sizeof(q->slots[0]) * q->maxflows); if (!q->ht || !q->slots) { return -ENOMEM; } for (i = 0; i < q->divisor; i++) q->ht[i] = SFQ_EMPTY_SLOT; for (i = 0; i < q->maxflows; i++) { slot_queue_init(&q->slots[i]); sfq_link(q, i); } if (q->limit >= 1) sch->flags |= TCQ_F_CAN_BYPASS; else sch->flags &= ~TCQ_F_CAN_BYPASS; return 0; }"
static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node) { return to_o2nm_cluster(node->nd_item.ci_parent->ci_parent); }
"void LayoutBlock::styleDidChange(StyleDifference diff, const ComputedStyle* oldStyle) { LayoutBox::styleDidChange(diff, oldStyle); if (isFloatingOrOutOfFlowPositioned() && oldStyle && !oldStyle->isFloating() && !oldStyle->hasOutOfFlowPosition() && parent() && parent()->isLayoutBlockFlow()) { toLayoutBlock(parent())->removeAnonymousWrappersIfRequired(); if (previousSibling() && previousSibling()->isAnonymousBlock()) toLayoutBlock(parent())->moveChildTo(toLayoutBlock(previousSibling()), this, nullptr, false); else if (nextSibling() && nextSibling()->isAnonymousBlock()) toLayoutBlock(parent())->moveChildTo(toLayoutBlock(nextSibling()), this, nextSibling()->slowFirstChild(), false); } const ComputedStyle& newStyle = styleRef(); if (oldStyle && parent()) { if (oldStyle->position() != newStyle.position() && newStyle.position() != StaticPosition) { if (LayoutBlock* cb = containingBlock()) cb->removePositionedObjects(this, NewContainingBlock); } } if (TextAutosizer* textAutosizer = document().textAutosizer()) textAutosizer->record(this); propagateStyleToAnonymousChildren(true); m_widthAvailableToChildrenChanged |= oldStyle && diff.needsFullLayout() && needsLayout() && borderOrPaddingLogicalWidthChanged(*oldStyle, newStyle); }"
"static void paste_option_changed(void) { static intold_p_paste = FALSE; static intsave_sm = 0; static intsave_sta = 0; #ifdef FEAT_CMDL_INFO static intsave_ru = 0; #endif #ifdef FEAT_RIGHTLEFT static intsave_ri = 0; static intsave_hkmap = 0; #endif buf_T*buf; if (p_paste) { if (!old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw_nopaste = buf->b_p_tw; buf->b_p_wm_nopaste = buf->b_p_wm; buf->b_p_sts_nopaste = buf->b_p_sts; buf->b_p_ai_nopaste = buf->b_p_ai; buf->b_p_et_nopaste = buf->b_p_et; #ifdef FEAT_VARTABS if (buf->b_p_vsts_nopaste) vim_free(buf->b_p_vsts_nopaste); buf->b_p_vsts_nopaste = buf->b_p_vsts && buf->b_p_vsts != empty_option ? vim_strsave(buf->b_p_vsts) : NULL; #endif } save_sm = p_sm; save_sta = p_sta; #ifdef FEAT_CMDL_INFO save_ru = p_ru; #endif #ifdef FEAT_RIGHTLEFT save_ri = p_ri; save_hkmap = p_hkmap; #endif p_ai_nopaste = p_ai; p_et_nopaste = p_et; p_sts_nopaste = p_sts; p_tw_nopaste = p_tw; p_wm_nopaste = p_wm; #ifdef FEAT_VARTABS if (p_vsts_nopaste) vim_free(p_vsts_nopaste); p_vsts_nopaste = p_vsts && p_vsts != empty_option ? vim_strsave(p_vsts) : NULL; #endif } FOR_ALL_BUFFERS(buf) { buf->b_p_tw = 0;        buf->b_p_wm = 0;        buf->b_p_sts = 0;        buf->b_p_ai = 0;        buf->b_p_et = 0;    #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = empty_option; if (buf->b_p_vsts_array) vim_free(buf->b_p_vsts_array); buf->b_p_vsts_array = 0; #endif } p_sm = 0;    p_sta = 0;    #ifdef FEAT_CMDL_INFO if (p_ru) status_redraw_all();    p_ru = 0;    #endif #ifdef FEAT_RIGHTLEFT p_ri = 0;    p_hkmap = 0;    #endif p_tw = 0; p_wm = 0; p_sts = 0; p_ai = 0; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = empty_option; #endif } else if (old_p_paste) { FOR_ALL_BUFFERS(buf) { buf->b_p_tw = buf->b_p_tw_nopaste; buf->b_p_wm = buf->b_p_wm_nopaste; buf->b_p_sts = buf->b_p_sts_nopaste; buf->b_p_ai = buf->b_p_ai_nopaste; buf->b_p_et = buf->b_p_et_nopaste; #ifdef FEAT_VARTABS if (buf->b_p_vsts) free_string_option(buf->b_p_vsts); buf->b_p_vsts = buf->b_p_vsts_nopaste ? vim_strsave(buf->b_p_vsts_nopaste) : empty_option; if (buf->b_p_vsts_array) vim_free(buf->b_p_vsts_array); if (buf->b_p_vsts && buf->b_p_vsts != empty_option) tabstop_set(buf->b_p_vsts, &buf->b_p_vsts_array); else buf->b_p_vsts_array = 0; #endif } p_sm = save_sm; p_sta = save_sta; #ifdef FEAT_CMDL_INFO if (p_ru != save_ru) status_redraw_all();    p_ru = save_ru; #endif #ifdef FEAT_RIGHTLEFT p_ri = save_ri; p_hkmap = save_hkmap; #endif p_ai = p_ai_nopaste; p_et = p_et_nopaste; p_sts = p_sts_nopaste; p_tw = p_tw_nopaste; p_wm = p_wm_nopaste; #ifdef FEAT_VARTABS if (p_vsts) free_string_option(p_vsts); p_vsts = p_vsts_nopaste ? vim_strsave(p_vsts_nopaste) : empty_option; #endif } old_p_paste = p_paste; }"
static void queue_delete(struct snd_seq_queue *q) { snd_seq_timer_stop(q->timer); snd_seq_timer_close(q); snd_use_lock_sync(&q->use_lock); snd_seq_prioq_delete(&q->tickq); snd_seq_prioq_delete(&q->timeq); snd_seq_timer_delete(&q->timer); kfree(q); }
"static const ut8 *r_bin_dwarf_parse_attr_value(const ut8 *obuf, int obuf_len, RBinDwarfAttrSpec *spec, RBinDwarfAttrValue *value, const RBinDwarfCompUnitHdr *hdr, const ut8 *debug_str, size_t debug_str_len) { const ut8 *buf = obuf; const ut8 *buf_end = obuf + obuf_len; size_t j; if (!spec || !value || !hdr || !obuf || obuf_len < 0) { return NULL; } value->form = spec->attr_form; value->name = spec->attr_name; value->encoding.block.data = NULL; value->encoding.str_struct.string = NULL; value->encoding.str_struct.offset = 0; switch (spec->attr_form) { case DW_FORM_addr: switch (hdr->pointer_size) { case 1: value->encoding.address = READ (buf, ut8); break; case 2: value->encoding.address = READ (buf, ut16); break; case 4: value->encoding.address = READ (buf, ut32); break; case 8: value->encoding.address = READ (buf, ut64); break; default: eprintf(""DWARF: Unexpected pointer size: %u\n"", (unsigned)hdr->pointer_size); return NULL; } break; case DW_FORM_block2: value->encoding.block.length = READ (buf, ut16); if (value->encoding.block.length > 0) { value->encoding.block.data = calloc (sizeof(ut8), value->encoding.block.length); for (j = 0; j < value->encoding.block.length; j++) { value->encoding.block.data[j] = READ (buf, ut8); } } break; case DW_FORM_block4: value->encoding.block.length = READ (buf, ut32); if (value->encoding.block.length > 0) { ut8 *data = calloc (sizeof (ut8), value->encoding.block.length); if (data) { for (j = 0; j < value->encoding.block.length; j++) { data[j] = READ (buf, ut8); } } value->encoding.block.data = data; } break; case DW_FORM_data2: value->encoding.data = READ (buf, ut16); break; case DW_FORM_data4: value->encoding.data = READ (buf, ut32); break; case DW_FORM_data8: value->encoding.data = READ (buf, ut64); break; case DW_FORM_string: value->encoding.str_struct.string = *buf? strdup ((const char*)buf) : NULL; buf += (strlen ((const char*)buf) + 1); break; case DW_FORM_block: buf = r_uleb128 (buf, buf_end - buf, &value->encoding.block.length); if (!buf) { return NULL; } value->encoding.block.data = calloc (sizeof(ut8), value->encoding.block.length); for (j = 0; j < value->encoding.block.length; j++) { value->encoding.block.data[j] = READ (buf, ut8); } break; case DW_FORM_block1: value->encoding.block.length = READ (buf, ut8); value->encoding.block.data = calloc (sizeof (ut8), value->encoding.block.length + 1); for (j = 0; j < value->encoding.block.length; j++) { value->encoding.block.data[j] = READ (buf, ut8); } break; case DW_FORM_flag: value->encoding.flag = READ (buf, ut8); break; case DW_FORM_sdata: buf = r_leb128 (buf, &value->encoding.sdata); break; case DW_FORM_strp: value->encoding.str_struct.offset = READ (buf, ut32); if (debug_str && value->encoding.str_struct.offset < debug_str_len) { value->encoding.str_struct.string = strdup ( (const char *)(debug_str + value->encoding.str_struct.offset)); } else { value->encoding.str_struct.string = NULL; } break; case DW_FORM_udata: { ut64 ndata = 0; const ut8 *data = (const ut8*)&ndata; buf = r_uleb128 (buf, R_MIN (sizeof (data), (size_t)(buf_end - buf)), &ndata); memcpy (&value->encoding.data, data, sizeof (value->encoding.data)); value->encoding.str_struct.string = NULL; } break; case DW_FORM_ref_addr: value->encoding.reference = READ (buf, ut64); break; case DW_FORM_ref1: value->encoding.reference = READ (buf, ut8); break; case DW_FORM_ref2: value->encoding.reference = READ (buf, ut16); break; case DW_FORM_ref4: value->encoding.reference = READ (buf, ut32); break; case DW_FORM_ref8: value->encoding.reference = READ (buf, ut64); break; case DW_FORM_data1: value->encoding.data = READ (buf, ut8); break; default: eprintf (""Unknown DW_FORM 0x%02""PFMT64x""\n"", spec->attr_form); value->encoding.data = 0; return NULL; } return buf; }"
"static ssize_t store_attach(struct device *dev, struct device_attribute *attr, const char *buf, size_t count) { struct socket *socket; int sockfd = 0; __u32 port = 0, pdev_nr = 0, rhport = 0, devid = 0, speed = 0; struct usb_hcd *hcd; struct vhci_hcd *vhci_hcd; struct vhci_device *vdev; struct vhci *vhci; int err; unsigned long flags; if (sscanf(buf, ""%u %u %u %u"", &port, &sockfd, &devid, &speed) != 4) return -EINVAL; pdev_nr = port_to_pdev_nr(port); rhport = port_to_rhport(port); usbip_dbg_vhci_sysfs(""port(%u) pdev(%d) rhport(%u)\n"", port, pdev_nr, rhport); usbip_dbg_vhci_sysfs(""sockfd(%u) devid(%u) speed(%u)\n"", sockfd, devid, speed); if (!valid_args(pdev_nr, rhport, speed)) return -EINVAL; hcd = platform_get_drvdata(vhcis[pdev_nr].pdev); if (hcd == NULL) { dev_err(dev, ""port %d is not ready\n"", port); return -EAGAIN; } vhci_hcd = hcd_to_vhci_hcd(hcd); vhci = vhci_hcd->vhci; if (speed == USB_SPEED_SUPER) vdev = &vhci->vhci_hcd_ss->vdev[rhport]; else vdev = &vhci->vhci_hcd_hs->vdev[rhport]; socket = sockfd_lookup(sockfd, &err); if (!socket) return -EINVAL; spin_lock_irqsave(&vhci->lock, flags); spin_lock(&vdev->ud.lock); if (vdev->ud.status != VDEV_ST_NULL) { spin_unlock(&vdev->ud.lock); spin_unlock_irqrestore(&vhci->lock, flags); sockfd_put(socket); dev_err(dev, ""port %d already used\n"", rhport); return -EBUSY; } dev_info(dev, ""pdev(%u) rhport(%u) sockfd(%d)\n"", pdev_nr, rhport, sockfd); dev_info(dev, ""devid(%u) speed(%u) speed_str(%s)\n"", devid, speed, usb_speed_string(speed)); vdev->devid         = devid; vdev->speed         = speed; vdev->ud.tcp_socket = socket; vdev->ud.status     = VDEV_ST_NOTASSIGNED; spin_unlock(&vdev->ud.lock); spin_unlock_irqrestore(&vhci->lock, flags); vdev->ud.tcp_rx = kthread_get_run(vhci_rx_loop, &vdev->ud, ""vhci_rx""); vdev->ud.tcp_tx = kthread_get_run(vhci_tx_loop, &vdev->ud, ""vhci_tx""); rh_port_connect(vdev, speed); return count; }"
"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl) { unsigned long len; GET_STATE(self); Check_Type(object_nl, T_STRING); len = RSTRING_LEN(object_nl); if (len == 0) { if (state->object_nl) { ruby_xfree(state->object_nl); state->object_nl = NULL; } } else { if (state->object_nl) ruby_xfree(state->object_nl); state->object_nl = strdup(RSTRING_PTR(object_nl)); state->object_nl_len = len; } return Qnil; }"
"double js_strtod(const char *string, char **endPtr) { int sign, expSign = FALSE; double fraction, dblExp, *d; register const char *p; register int c; int exp = 0; int fracExp = 0; int mantSize; int decPt; const char *pExp; p = string; while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') { p += 1; } if (*p == '-') { sign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } sign = FALSE; } decPt = -1; for (mantSize = 0; ; mantSize += 1) { c = *p; if (!(c>='0'&&c<='9')) { if ((c != '.') || (decPt >= 0)) { break; } decPt = mantSize; } p += 1; } pExp = p; p -= mantSize; if (decPt < 0) { decPt = mantSize; } else { mantSize -= 1; } if (mantSize > 18) { fracExp = decPt - 18; mantSize = 18; } else { fracExp = decPt - mantSize; } if (mantSize == 0) { fraction = 0.0; p = string; goto done; } else { int frac1, frac2; frac1 = 0; for ( ; mantSize > 9; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac1 = 10*frac1 + (c - '0'); } frac2 = 0; for (; mantSize > 0; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac2 = 10*frac2 + (c - '0'); } fraction = (1.0e9 * frac1) + frac2; } p = pExp; if ((*p == 'E') || (*p == 'e')) { p += 1; if (*p == '-') { expSign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } expSign = FALSE; } while ((*p >= '0') && (*p <= '9')) { exp = exp * 10 + (*p - '0'); p += 1; } } if (expSign) { exp = fracExp - exp; } else { exp = fracExp + exp; } if (exp < -maxExponent) { exp = maxExponent; expSign = TRUE; errno = ERANGE; } else if (exp > maxExponent) { exp = maxExponent; expSign = FALSE; errno = ERANGE; } else if (exp < 0) { expSign = TRUE; exp = -exp; } else { expSign = FALSE; } dblExp = 1.0; for (d = powersOf10; exp != 0; exp >>= 1, d += 1) { if (exp & 01) { dblExp *= *d; } } if (expSign) { fraction /= dblExp; } else { fraction *= dblExp; } done: if (endPtr != NULL) { *endPtr = (char *) p; } if (sign) { return -fraction; } return fraction; }"
"status_t MediaPlayer::setDataSource( const sp<IMediaHTTPService> &httpService, const char *url, const KeyedVector<String8, String8> *headers) { ALOGV(""setDataSource(%s)"", url); status_t err = BAD_VALUE; if (url != NULL) { const sp<IMediaPlayerService>& service(getMediaPlayerService()); if (service != 0) { sp<IMediaPlayer> player(service->create(this, mAudioSessionId)); if ((NO_ERROR != doSetRetransmitEndpoint(player)) || (NO_ERROR != player->setDataSource(httpService, url, headers))) { player.clear(); } err = attachNewPlayer(player); } } return err; }"
"static int dxtory_decode_v1_444(AVCodecContext *avctx, AVFrame *pic, const uint8_t *src, int src_size) { int h, w; uint8_t *Y, *U, *V; int ret; if (src_size < avctx->width * avctx->height * 3) { av_log(avctx, AV_LOG_ERROR, ""packet too small\n""); return AVERROR_INVALIDDATA; } avctx->pix_fmt = AV_PIX_FMT_YUV444P; if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) return ret; Y = pic->data[0]; U = pic->data[1]; V = pic->data[2]; for (h = 0; h < avctx->height; h++) { for (w = 0; w < avctx->width; w++) { Y[w] = *src++; U[w] = *src++ ^ 0x80; V[w] = *src++ ^ 0x80; } Y += pic->linesize[0]; U += pic->linesize[1]; V += pic->linesize[2]; } return 0; }"
"static GBytes * finish_headers (CockpitWebResponse *self, GString *string, gssize length, gint status, guint seen) { const gchar *content_type; if ((seen & HEADER_CONTENT_TYPE) == 0 && self->full_path != NULL && status >= 200 && status <= 299) { content_type = cockpit_web_response_content_type (self->full_path); if (content_type) g_string_append_printf (string, ""Content-Type: %s\r\n"", content_type); } if (status != 304) { if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters) { self->chunked = TRUE; g_string_append_printf (string, ""Transfer-Encoding: chunked\r\n""); } else { self->chunked = FALSE; g_string_append_printf (string, ""Content-Length: %"" G_GSSIZE_FORMAT ""\r\n"", length); self->out_queueable = length; } } if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299) { if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER) g_string_append (string, ""Cache-Control: max-age=31556926, public\r\n""); else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE) g_string_append (string, ""Cache-Control: no-cache, no-store\r\n""); else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE) g_string_append (string, ""Cache-Control: max-age=86400, private\r\n""); } if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 && self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE) { g_string_append (string, ""Vary: Cookie\r\n""); } if (!self->keep_alive) g_string_append (string, ""Connection: close\r\n""); if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0) g_string_append (string, ""X-DNS-Prefetch-Control: off\r\n""); if ((seen & HEADER_REFERRER_POLICY) == 0) g_string_append (string, ""Referrer-Policy: no-referrer\r\n""); if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0) g_string_append (string, ""X-Content-Type-Options: nosniff\r\n""); if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0) g_string_append (string, ""Cross-Origin-Resource-Policy: same-origin\r\n""); g_string_append (string, ""\r\n""); return g_string_free_to_bytes (string); }"
"static int printbuf_extend(struct printbuf *p, int min_size) { char *t; int new_size; if (p->size >= min_size) return 0; new_size = p->size * 2; if (new_size < min_size + 8) new_size =  min_size + 8; #ifdef PRINTBUF_DEBUG MC_DEBUG(""printbuf_memappend: realloc "" ""bpos=%d min_size=%d old_size=%d new_size=%d\n"", p->bpos, min_size, p->size, new_size); #endif  if(!(t = (char*)realloc(p->buf, new_size))) return -1; p->size = new_size; p->buf = t; return 0; }"
"static __be32 nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr, struct nfsd4_layoutget *lgp) { struct xdr_stream *xdr = &resp->xdr; const struct nfsd4_layout_ops *ops = nfsd4_layout_ops[lgp->lg_layout_type]; __be32 *p; dprintk(""%s: err %d\n"", __func__, nfserr); if (nfserr) goto out; nfserr = nfserr_resource; p = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t)); if (!p) goto out; *p++ = cpu_to_be32(1); *p++ = cpu_to_be32(lgp->lg_sid.si_generation); p = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque, sizeof(stateid_opaque_t)); *p++ = cpu_to_be32(1); p = xdr_encode_hyper(p, lgp->lg_seg.offset); p = xdr_encode_hyper(p, lgp->lg_seg.length); *p++ = cpu_to_be32(lgp->lg_seg.iomode); *p++ = cpu_to_be32(lgp->lg_layout_type); nfserr = ops->encode_layoutget(xdr, lgp); out: kfree(lgp->lg_content); return nfserr; }"
"static VALUE ossl_cipher_update(int argc, VALUE *argv, VALUE self) { EVP_CIPHER_CTX *ctx; unsigned char *in; long in_len, out_len; VALUE data, str; rb_scan_args(argc, argv, ""11"", &data, &str); StringValue(data); in = (unsigned char *)RSTRING_PTR(data); if ((in_len = RSTRING_LEN(data)) == 0) ossl_raise(rb_eArgError, ""data must not be empty""); GetCipher(self, ctx); out_len = in_len+EVP_CIPHER_CTX_block_size(ctx); if (out_len <= 0) { ossl_raise(rb_eRangeError, ""data too big to make output buffer: %ld bytes"", in_len); } if (NIL_P(str)) { str = rb_str_new(0, out_len); } else { StringValue(str); rb_str_resize(str, out_len); } if (!ossl_cipher_update_long(ctx, (unsigned char *)RSTRING_PTR(str), &out_len, in, in_len)) ossl_raise(eCipherError, NULL); assert(out_len < RSTRING_LEN(str)); rb_str_set_len(str, out_len); return str; }"
"static int dissect_rpkirtr_pdu(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) { proto_item *ti = NULL, *ti_flags, *ti_type; proto_tree *rpkirtr_tree = NULL, *flags_tree = NULL; int offset = 0; guint8 pdu_type, version; guint length; while (tvb_reported_length_remaining(tvb, offset) != 0) { ti = proto_tree_add_item(tree, proto_rpkirtr, tvb, 0, -1, ENC_NA); rpkirtr_tree = proto_item_add_subtree(ti, ett_rpkirtr); proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_version, tvb, offset, 1, ENC_BIG_ENDIAN); version = tvb_get_guint8(tvb, offset); offset += 1; ti_type = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_pdu_type, tvb, offset, 1, ENC_BIG_ENDIAN); pdu_type = tvb_get_guint8(tvb, offset); col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown (%d)"")); proto_item_append_text(ti, "" (%s)"", val_to_str(pdu_type, rtr_pdu_type_vals, ""Unknown %d"")); offset += 1; length = tvb_get_ntohl(tvb, offset); switch (pdu_type) { case RPKI_RTR_SERIAL_NOTIFY_PDU:  case RPKI_RTR_SERIAL_QUERY_PDU:   proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case RPKI_RTR_RESET_QUERY_PDU:   case RPKI_RTR_CACHE_RESET_PDU:   proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case RPKI_RTR_CACHE_RESPONSE_PDU:   proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case RPKI_RTR_IPV4_PREFIX_PDU:  proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN); flags_tree = proto_item_add_subtree(ti_flags, ett_flags); proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv4_prefix,      tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case RPKI_RTR_IPV6_PREFIX_PDU:  proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN); flags_tree = proto_item_add_subtree(ti_flags, ett_flags); proto_tree_add_item(flags_tree, hf_rpkirtr_flags_aw,           tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_prefix_length,    tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_max_length,       tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_ipv6_prefix,      tvb, offset, 16, ENC_NA); offset += 16; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number,        tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case RPKI_RTR_END_OF_DATA_PDU:  proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_session_id,       tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_serial_number,    tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; if (version >= 1){ proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_refresh_interval, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_retry_interval,   tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_expire_interval,  tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; } break; case RPKI_RTR_ROUTER_KEY:  if(version < 1){ expert_add_info(pinfo, ti_type, &ei_rpkirtr_wrong_version_router_key); } else { asn1_ctx_t asn1_ctx; ti_flags = proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_flags, tvb, offset, 1, ENC_BIG_ENDIAN); flags_tree = proto_item_add_subtree(ti_flags, ett_flags_nd); proto_tree_add_item(flags_tree, hf_rpkirtr_flags_rk,           tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_reserved,         tvb, offset, 2, ENC_NA); offset += 1; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_subject_key_identifier, tvb, offset, 20, ENC_NA); offset += 20; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_as_number, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo); offset = dissect_x509af_SubjectPublicKeyInfo(FALSE, tvb, offset, &asn1_ctx, rpkirtr_tree, hf_rpkirtr_subject_public_key_info); } break; case RPKI_RTR_ERROR_REPORT_PDU:  { guint32 len_pdu, len_text; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_code,       tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length,           tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_pdu,       tvb, offset, 4, ENC_BIG_ENDIAN); len_pdu =                                                      tvb_get_ntohl(tvb, offset); offset += 4; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_pdu,        tvb, offset, len_pdu, ENC_NA); offset +=  len_pdu; proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_length_text,      tvb, offset, 4, ENC_BIG_ENDIAN); len_text =                                                     tvb_get_ntohl(tvb, offset); offset += 4, proto_tree_add_item(rpkirtr_tree, hf_rpkirtr_error_text,   tvb, offset, len_text, ENC_ASCII|ENC_NA); offset += len_text; } break; default: offset += length; break; } } return tvb_reported_length(tvb); }"
"void MidiManagerMac::SendMidiData(MidiManagerClient* client, uint32 port_index, const std::vector<uint8>& data, double timestamp) { DCHECK(client_thread_.task_runner()->BelongsToCurrentThread()); if (static_cast<size_t>(port_index) >= destinations_.size()) return; MIDITimeStamp coremidi_timestamp = SecondsToMIDITimeStamp(timestamp); MIDIEndpointRef destination = destinations_[port_index]; size_t send_size; for (size_t sent_size = 0; sent_size < data.size(); sent_size += send_size) { MIDIPacketList* packet_list = reinterpret_cast<MIDIPacketList*>(midi_buffer_.data()); MIDIPacket* midi_packet = MIDIPacketListInit(packet_list); send_size = std::min(data.size() - sent_size, kEstimatedMaxPacketDataSize); midi_packet = MIDIPacketListAdd( packet_list, kCoreMIDIMaxPacketListSize, midi_packet, coremidi_timestamp, send_size, &data[sent_size]); DCHECK(midi_packet); MIDISend(coremidi_output_, destination, packet_list); } client->AccumulateMidiBytesSent(data.size()); }"
"int nvmx_handle_vmptrst(struct cpu_user_regs *regs) { struct vcpu *v = current; struct vmx_inst_decoded decode; struct nestedvcpu *nvcpu = &vcpu_nestedhvm(v); pagefault_info_t pfinfo; unsigned long gpa = 0; int rc; rc = decode_vmx_inst(regs, &decode, &gpa, 0); if ( rc != X86EMUL_OKAY ) return rc; gpa = nvcpu->nv_vvmcxaddr; rc = hvm_copy_to_guest_linear(decode.mem, &gpa, decode.len, 0, &pfinfo); if ( rc == HVMTRANS_bad_linear_to_gfn ) hvm_inject_page_fault(pfinfo.ec, pfinfo.linear); if ( rc != HVMTRANS_okay ) return X86EMUL_EXCEPTION; vmsucceed(regs); return X86EMUL_OKAY; }"
"void net_tx_pkt_init(struct NetTxPkt **pkt, PCIDevice *pci_dev, uint32_t max_frags, bool has_virt_hdr) { struct NetTxPkt *p = g_malloc0(sizeof *p); p->pci_dev = pci_dev; p->vec = g_malloc((sizeof *p->vec) * (max_frags + NET_TX_PKT_PL_START_FRAG)); p->raw = g_malloc((sizeof *p->raw) * max_frags); p->max_payload_frags = max_frags; p->max_raw_frags = max_frags; p->has_virt_hdr = has_virt_hdr; p->vec[NET_TX_PKT_VHDR_FRAG].iov_base = &p->virt_hdr; p->vec[NET_TX_PKT_VHDR_FRAG].iov_len = p->has_virt_hdr ? sizeof p->virt_hdr : 0; p->vec[NET_TX_PKT_L2HDR_FRAG].iov_base = &p->l2_hdr; p->vec[NET_TX_PKT_L3HDR_FRAG].iov_base = &p->l3_hdr; *pkt = p; }"
"static void _clean_slate_datagram(gnrc_sixlowpan_frag_fb_t *fbuf) { clist_node_t new_queue = { .next = NULL }; fbuf->sfr.arq_timeout_event.msg.content.ptr = NULL; evtimer_del((evtimer_t *)(&_arq_timer), &fbuf->sfr.arq_timeout_event.event); fbuf->sfr.arq_timeout_event.event.next = NULL; if (gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) { for (clist_node_t *node = clist_lpop(&_frame_queue); node != NULL; node = clist_lpop(&_frame_queue)) { _frame_queue_t *entry = (_frame_queue_t *)node; if (entry->datagram_tag == fbuf->tag) { gnrc_pktbuf_release(entry->frame); entry->frame = NULL; clist_rpush(&_frag_descs_free, node); } else { clist_rpush(&new_queue, node); } } _frame_queue = new_queue; } fbuf->offset = 0U; fbuf->sfr.cur_seq = 0U; fbuf->sfr.frags_sent = 0U; for (clist_node_t *node = clist_lpop(&fbuf->sfr.window); node != NULL; node = clist_lpop(&fbuf->sfr.window)) { clist_rpush(&_frag_descs_free, node); } }"
"static int snd_hrtimer_stop(struct snd_timer *t) { struct snd_hrtimer *stime = t->private_data; atomic_set(&stime->running, 0); return 0; }"
"static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf) { int ret; if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM) return -ENODEV; ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0); usbnet_link_change(dev, 0, 0); return ret; }"
"static GCObject **correctgraylist (GCObject **p) { GCObject *curr; while ((curr = *p) != NULL) { switch (curr->tt) { case LUA_VTABLE: case LUA_VUSERDATA: { GCObject **next = getgclist(curr); if (getage(curr) == G_TOUCHED1) {   lua_assert(isgray(curr)); gray2black(curr);   changeage(curr, G_TOUCHED1, G_TOUCHED2); p = next;   } else {   if (!iswhite(curr)) {   lua_assert(isold(curr)); if (getage(curr) == G_TOUCHED2)   changeage(curr, G_TOUCHED2, G_OLD);   gray2black(curr);   } *p = *next;   } break; } case LUA_VTHREAD: { lua_State *th = gco2th(curr); lua_assert(!isblack(th)); if (iswhite(th))   *p = th->gclist;   else   p = &th->gclist;   break; } default: lua_assert(0);   } } return p; }"
"void cb_metrics_prometheus(mk_request_t *request, void *data) { int i; int j; int m; int len; int time_len; int start_time_len; size_t index; size_t num_metrics = 0; long now; flb_sds_t sds; flb_sds_t sds_metric; flb_sds_t tmp_sds; struct flb_sds *metric_helptxt_head; flb_sds_t metric_helptxt; size_t off = 0; struct flb_hs_buf *buf; msgpack_unpacked result; msgpack_object map; char tmp[32]; char time_str[64]; char start_time_str[64]; char* *metrics_arr; struct timeval tp; struct flb_hs *hs = data; struct flb_config *config = hs->config; buf = metrics_get_latest(); if (!buf) { mk_http_status(request, 404); mk_http_done(request); return; } buf->users++; sds = flb_sds_create_size(1024); if (!sds) { mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt = flb_sds_create_size(128); if (!metric_helptxt) { flb_sds_destroy(sds); mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt); gettimeofday(&tp, NULL); now = tp.tv_sec * 1000 + tp.tv_usec / 1000; time_len = snprintf(time_str, sizeof(time_str) - 1, ""%lu"", now); start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, ""%lu"", config->init_time); index = 0; msgpack_unpacked_init(&result); msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off); map = result.data; for (i = 0; i < map.via.map.size; i++) { msgpack_object v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { num_metrics++; } } } metrics_arr = flb_malloc(num_metrics * sizeof(char*)); for (i = 0; i < map.via.map.size; i++) { msgpack_object k; msgpack_object v; k = map.via.map.ptr[i].key; v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sk; msgpack_object sv; sk = v.via.map.ptr[j].key; sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { msgpack_object mk; msgpack_object mv; mk = sv.via.map.ptr[m].key; mv = sv.via.map.ptr[m].val; len = snprintf(tmp, sizeof(tmp) - 1, ""%"" PRIu64 "" "", mv.via.u64); if (len < 0) { goto error; } sds_metric = flb_sds_create_size(k.via.str.size + mk.via.str.size + sk.via.str.size + len + time_len + 28); if (sds_metric == NULL) { goto error; } sds_metric = flb_sds_cat(sds_metric, ""fluentbit_"", 10); sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_"", 1); sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_total{name=\"""", 13); sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""\""} "", 3); sds_metric = flb_sds_cat(sds_metric, tmp, len); sds_metric = flb_sds_cat(sds_metric, time_str, time_len); sds_metric = flb_sds_cat(sds_metric, ""\n"", 1); metrics_arr[index] = sds_metric; index++; } } } qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp); tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); for (i = 0; i < num_metrics; i++) { tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i])); null_check(tmp_sds); if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) { tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); metric_helptxt_head->len = 0; if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); } } tmp_sds = flb_sds_cat(sds, ""# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n"", 89); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE process_start_time_seconds gauge\n"", 40); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""process_start_time_seconds "", 27); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\n"", 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# HELP fluentbit_build_info Build version information.\n"", 55); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE fluentbit_build_info gauge\n"", 34); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""fluentbit_build_info{version=\"""", 30); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\"",edition=\"""", 11); null_check(tmp_sds); #ifdef FLB_ENTERPRISE tmp_sds = flb_sds_cat(sds, ""Enterprise\""} 1\n"", 15); null_check(tmp_sds); #else tmp_sds = flb_sds_cat(sds, ""Community\""} 1\n"", 14); null_check(tmp_sds); #endif msgpack_unpacked_destroy(&result); buf->users--; mk_http_status(request, 200); mk_http_header(request, ""Content-Type"", 12, PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1); mk_http_send(request, sds, flb_sds_len(sds), NULL); for (i = 0; i < num_metrics; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); mk_http_done(request); return; error: mk_http_status(request, 500); mk_http_done(request); buf->users--; for (i = 0; i < index; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); msgpack_unpacked_destroy(&result); }"
"static struct desc_struct *get_desc(unsigned short sel) { struct desc_ptr gdt_desc = {0, 0}; unsigned long desc_base; #ifdef CONFIG_MODIFY_LDT_SYSCALL if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) { struct desc_struct *desc = NULL; struct ldt_struct *ldt; sel >>= 3; mutex_lock(&current->active_mm->context.lock); ldt = current->active_mm->context.ldt; if (ldt && sel < ldt->nr_entries) desc = &ldt->entries[sel]; mutex_unlock(&current->active_mm->context.lock); return desc; } #endif native_store_gdt(&gdt_desc); desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK); if (desc_base > gdt_desc.size) return NULL; return (struct desc_struct *)(gdt_desc.address + desc_base); }"
"static int build_open_gop_key_points(AVStream *st) { int k; int sample_id = 0; uint32_t cra_index; MOVStreamContext *sc = st->priv_data; if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count) return 0; sc->sample_offsets_count = 0; for (uint32_t i = 0; i < sc->ctts_count; i++) sc->sample_offsets_count += sc->ctts_data[i].count; av_freep(&sc->sample_offsets); sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets)); if (!sc->sample_offsets) return AVERROR(ENOMEM); k = 0; for (uint32_t i = 0; i < sc->ctts_count; i++) for (int j = 0; j < sc->ctts_data[i].count; j++) sc->sample_offsets[k++] = sc->ctts_data[i].duration; cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT);  if (!cra_index) return 0; sc->open_key_samples_count = 0; for (uint32_t i = 0; i < sc->sync_group_count; i++) if (sc->sync_group[i].index == cra_index) sc->open_key_samples_count += sc->sync_group[i].count; av_freep(&sc->open_key_samples); sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples)); if (!sc->open_key_samples) return AVERROR(ENOMEM); k = 0; for (uint32_t i = 0; i < sc->sync_group_count; i++) { const MOVSbgp *sg = &sc->sync_group[i]; if (sg->index == cra_index) for (uint32_t j = 0; j < sg->count; j++) sc->open_key_samples[k++] = sample_id; sample_id += sg->count; } sc->min_sample_duration = UINT_MAX; for (uint32_t i = 0; i < sc->stts_count; i++) sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration); return 0; }"
"void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v) { if (v->vt != JSI_VT_OBJECT) { Jsi_LogBug(""Jsi_ValueArrayShift, target is not object""); return; } Jsi_Obj *o = v->d.obj; if (o->isarrlist) { uint i; if (!o->arrCnt) return; if (o->arr[0]) Jsi_DecrRefCount(interp, o->arr[0]); for (i=1; i<o->arrCnt; i++) { o->arr[i-1] = o->arr[i]; } o->arr[o->arrCnt--] = NULL; return; } int len = Jsi_ObjGetLength(interp, v->d.obj); if (len <= 0) return; Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0); if (!v0) return; Jsi_ValueReset(interp, &v0); int i; Jsi_Value *last = v0; for (i = 1; i < len; ++i) { Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i); if (!t) return; Jsi_ValueCopy(interp, last, t); Jsi_ValueReset(interp, &t); last = t; } Jsi_ObjSetLength(interp, v->d.obj, len - 1); }"
"GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box) { u32 type, uuid_type, hdr_size, restore_type; u64 size, start, comp_start, end; char uuid[16]; GF_Err e; GF_BitStream *uncomp_bs = NULL; u8 *uncomp_data = NULL; u32 compressed_size=0; GF_Box *newBox; Bool skip_logs = (gf_bs_get_cookie(bs) & GF_ISOM_BS_COOKIE_NO_LOGS ) ? GF_TRUE : GF_FALSE; Bool is_special = GF_TRUE; if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM; *outBox = NULL; if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } comp_start = start = gf_bs_get_position(bs); uuid_type = 0; size = (u64) gf_bs_read_u32(bs); hdr_size = 4; if ((size >= 2) && (size <= 4)) { size = 4; type = GF_ISOM_BOX_TYPE_VOID; } else { type = gf_bs_read_u32(bs); hdr_size += 4; if (type == GF_ISOM_BOX_TYPE_TOTL) size = 12; if (!size) { if (is_root_box) { if (!skip_logs) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type)); } size = gf_bs_available(bs) + 8; } else { if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start)); } return GF_OK; } } if (is_root_box && (size>=8)) { Bool do_uncompress = GF_FALSE; u8 *compb = NULL; u32 osize = 0; u32 otype = type; if (type==GF_4CC('!', 'm', 'o', 'f')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_MOOF; } else if (type==GF_4CC('!', 'm', 'o', 'v')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_MOOV; } else if (type==GF_4CC('!', 's', 'i', 'x')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_SIDX; } else if (type==GF_4CC('!', 's', 's', 'x')) { do_uncompress = GF_TRUE; type = GF_ISOM_BOX_TYPE_SSIX; } if (do_uncompress) { compb = gf_malloc((u32) (size-8)); compressed_size = (u32) (size - 8); gf_bs_read_data(bs, compb, compressed_size); e = gf_gz_decompress_payload(compb, compressed_size, &uncomp_data, &osize); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Failed to uncompress payload for box type %s (0x%08X)\n"", gf_4cc_to_str(otype), otype)); return e; } size = osize + 8; uncomp_bs = gf_bs_new(uncomp_data, osize, GF_BITSTREAM_READ); bs = uncomp_bs; start = 0; gf_free(compb); } } } memset(uuid, 0, 16); if (type == GF_ISOM_BOX_TYPE_UUID ) { if (gf_bs_available(bs) < 16) { return GF_ISOM_INCOMPLETE_FILE; } gf_bs_read_data(bs, uuid, 16); hdr_size += 16; uuid_type = gf_isom_solve_uuid_box(uuid); } if (size == 1) { if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } size = gf_bs_read_u64(bs); hdr_size += 8; } if (!skip_logs) GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), size,  start)); if ( size < hdr_size ) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", size, hdr_size)); return GF_ISOM_INVALID_FILE; } restore_type = 0; if ((parent_type==GF_ISOM_BOX_TYPE_STSD) && (type==GF_QT_SUBTYPE_RAW) ) { u64 cookie = gf_bs_get_cookie(bs); restore_type = type; if (cookie & GF_ISOM_BS_COOKIE_VISUAL_TRACK) type = GF_QT_SUBTYPE_RAW_VID; else type = GF_QT_SUBTYPE_RAW_AUD; } if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI); if (!newBox) return GF_OUT_OF_MEM; ((GF_ItemReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackGroupTypeBox*)newBox)->group_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT); if (!newBox) return GF_OUT_OF_MEM; ((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type; } else { is_special = GF_FALSE; newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box); if (!newBox) return GF_OUT_OF_MEM; } if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) { memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16); ((GF_UUIDBox *)newBox)->internal_4cc = uuid_type; } if (!newBox->type) newBox->type = type; if (restore_type) newBox->type = restore_type; end = gf_bs_available(bs); if (size - hdr_size > end ) { newBox->size = size - hdr_size - end; *outBox = newBox; return GF_ISOM_INCOMPLETE_FILE; } newBox->size = size - hdr_size; e = gf_isom_full_box_read(newBox, bs); if (!e) e = gf_isom_box_read(newBox, bs); if (e) { if (gf_opts_get_bool(""core"", ""no-check"")) e = GF_OK; } newBox->size = size; end = gf_bs_get_position(bs); if (uncomp_bs) { gf_free(uncomp_data); gf_bs_del(uncomp_bs); if (e) { gf_isom_box_del(newBox); *outBox = NULL; return e; } size -= 8; if (type==GF_ISOM_BOX_TYPE_MOOF) { ((GF_MovieFragmentBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } else if (type==GF_ISOM_BOX_TYPE_MOOV) { ((GF_MovieBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; ((GF_MovieBox *)newBox)->file_offset = comp_start; } else if (type==GF_ISOM_BOX_TYPE_SIDX) { ((GF_SegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } else if (type==GF_ISOM_BOX_TYPE_SSIX) { ((GF_SubsegmentIndexBox *)newBox)->compressed_diff = (s32)size - (s32)compressed_size; } newBox->internal_flags = GF_ISOM_BOX_COMPRESSED; } if (e && (e != GF_ISOM_INCOMPLETE_FILE)) { gf_isom_box_del(newBox); *outBox = NULL; if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e))); } return e; } if (end-start > size) { if (!skip_logs) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), size, start, (end-start) )); } gf_bs_seek(bs, start+size); } else if (end-start < size) { u32 to_skip = (u32) (size-(end-start)); if (!skip_logs) { if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip)); unused_bytes += to_skip; } } gf_bs_skip_bytes(bs, to_skip); } *outBox = newBox; return e; }"
"int mutt_seqset_iterator_next (SEQSET_ITERATOR *iter, unsigned int *next) { char *range_sep; if (!iter || !next) return -1; if (iter->in_range) { if ((iter->down && iter->range_cur == (iter->range_end - 1)) || (!iter->down && iter->range_cur == (iter->range_end + 1))) iter->in_range = 0; } if (!iter->in_range) { iter->substr_cur = iter->substr_end; if (iter->substr_cur == iter->eostr) return 1; while (!*(iter->substr_cur)) iter->substr_cur++; iter->substr_end = strchr (iter->substr_cur, ','); if (!iter->substr_end) iter->substr_end = iter->eostr; else *(iter->substr_end) = '\0'; range_sep = strchr (iter->substr_cur, ':'); if (range_sep) *range_sep++ = '\0'; if (mutt_atoui (iter->substr_cur, &iter->range_cur)) return -1; if (range_sep) { if (mutt_atoui (range_sep, &iter->range_end)) return -1; } else iter->range_end = iter->range_cur; iter->down = (iter->range_end < iter->range_cur); iter->in_range = 1; } *next = iter->range_cur; if (iter->down) iter->range_cur--; else iter->range_cur++; return 0; }"
"static SQInteger thread_call(HSQUIRRELVM v) { SQObjectPtr o = stack_get(v,1); if(sq_type(o) == OT_THREAD) { SQInteger nparams = sq_gettop(v); _thread(o)->Push(_thread(o)->_roottable); for(SQInteger i = 2; i<(nparams+1); i++) sq_move(_thread(o),v,i); if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) { sq_move(v,_thread(o),-1); sq_pop(_thread(o),1); return 1; } v->_lasterror = _thread(o)->_lasterror; return SQ_ERROR; } return sq_throwerror(v,_SC(""wrong parameter"")); }"
"static int tower_probe (struct usb_interface *interface, const struct usb_device_id *id) { struct device *idev = &interface->dev; struct usb_device *udev = interface_to_usbdev(interface); struct lego_usb_tower *dev = NULL; struct usb_host_interface *iface_desc; struct usb_endpoint_descriptor* endpoint; struct tower_get_version_reply get_version_reply; int i; int retval = -ENOMEM; int result; dev = kmalloc (sizeof(struct lego_usb_tower), GFP_KERNEL); if (!dev) goto exit; mutex_init(&dev->lock); dev->udev = udev; dev->open_count = 0; dev->read_buffer = NULL; dev->read_buffer_length = 0; dev->read_packet_length = 0; spin_lock_init (&dev->read_buffer_lock); dev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout); dev->read_last_arrival = jiffies; init_waitqueue_head (&dev->read_wait); init_waitqueue_head (&dev->write_wait); dev->interrupt_in_buffer = NULL; dev->interrupt_in_endpoint = NULL; dev->interrupt_in_urb = NULL; dev->interrupt_in_running = 0; dev->interrupt_in_done = 0; dev->interrupt_out_buffer = NULL; dev->interrupt_out_endpoint = NULL; dev->interrupt_out_urb = NULL; dev->interrupt_out_busy = 0; iface_desc = interface->cur_altsetting; for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) { endpoint = &iface_desc->endpoint[i].desc; if (usb_endpoint_xfer_int(endpoint)) { if (usb_endpoint_dir_in(endpoint)) dev->interrupt_in_endpoint = endpoint; else dev->interrupt_out_endpoint = endpoint; } } if(dev->interrupt_in_endpoint == NULL) { dev_err(idev, ""interrupt in endpoint not found\n""); goto error; } if (dev->interrupt_out_endpoint == NULL) { dev_err(idev, ""interrupt out endpoint not found\n""); goto error; } dev->read_buffer = kmalloc (read_buffer_size, GFP_KERNEL); if (!dev->read_buffer) goto error; dev->interrupt_in_buffer = kmalloc (usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL); if (!dev->interrupt_in_buffer) goto error; dev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL); if (!dev->interrupt_in_urb) goto error; dev->interrupt_out_buffer = kmalloc (write_buffer_size, GFP_KERNEL); if (!dev->interrupt_out_buffer) goto error; dev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL); if (!dev->interrupt_out_urb) goto error; dev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval; dev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval; usb_set_intfdata (interface, dev); retval = usb_register_dev (interface, &tower_class); if (retval) { dev_err(idev, ""Not able to get a minor for this device.\n""); usb_set_intfdata (interface, NULL); goto error; } dev->minor = interface->minor; dev_info(&interface->dev, ""LEGO USB Tower #%d now attached to major "" ""%d minor %d\n"", (dev->minor - LEGO_USB_TOWER_MINOR_BASE), USB_MAJOR, dev->minor); result = usb_control_msg (udev, usb_rcvctrlpipe(udev, 0), LEGO_USB_TOWER_REQUEST_GET_VERSION, USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE, 0, 0, &get_version_reply, sizeof(get_version_reply), 1000); if (result < 0) { dev_err(idev, ""LEGO USB Tower get version control request failed\n""); retval = result; goto error; } dev_info(&interface->dev, ""LEGO USB Tower firmware version is %d.%d "" ""build %d\n"", get_version_reply.major, get_version_reply.minor, le16_to_cpu(get_version_reply.build_no)); exit: return retval; error: tower_delete(dev); return retval; }"
"static gboolean gvs_tuple_is_normal (GVariantSerialised value) { guint offset_size; gsize offset_ptr; gsize length; gsize offset; gsize i; if G_UNLIKELY (value.data == NULL && value.size != 0) return FALSE; offset_size = gvs_get_offset_size (value.size); length = g_variant_type_info_n_members (value.type_info); offset_ptr = value.size; offset = 0; for (i = 0; i < length; i++) { const GVariantMemberInfo *member_info; GVariantSerialised child = { 0, }; gsize fixed_size; guint alignment; gsize end; member_info = g_variant_type_info_member_info (value.type_info, i); child.type_info = member_info->type_info; child.depth = value.depth + 1; g_variant_type_info_query (child.type_info, &alignment, &fixed_size); while (offset & alignment) { if (offset > value.size || value.data[offset] != '\0') return FALSE; offset++; } child.data = value.data + offset; switch (member_info->ending_type) { case G_VARIANT_MEMBER_ENDING_FIXED: end = offset + fixed_size; break; case G_VARIANT_MEMBER_ENDING_LAST: end = offset_ptr; break; case G_VARIANT_MEMBER_ENDING_OFFSET: if (offset_ptr < offset_size) return FALSE; offset_ptr -= offset_size; if (offset_ptr < offset) return FALSE; end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size); break; default: g_assert_not_reached (); } if (end < offset || end > offset_ptr) return FALSE; child.size = end - offset; if (child.size == 0) child.data = NULL; if (!g_variant_serialised_is_normal (child)) return FALSE; offset = end; } value.ordered_offsets_up_to = G_MAXSIZE; value.checked_offsets_up_to = G_MAXSIZE; { gsize fixed_size; guint alignment; g_variant_type_info_query (value.type_info, &alignment, &fixed_size); if (fixed_size) { g_assert (fixed_size == value.size); g_assert (offset_ptr == value.size); if (i == 0) { if (value.data[offset++] != '\0') return FALSE; } else { while (offset & alignment) if (value.data[offset++] != '\0') return FALSE; } g_assert (offset == value.size); } } return offset_ptr == offset; }"
"static int dissect_ldss_transfer (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) { conversation_t *transfer_conv; ldss_transfer_info_t *transfer_info; struct tcpinfo *transfer_tcpinfo; proto_tree *ti, *line_tree = NULL, *ldss_tree = NULL; nstime_t broadcast_response_time; if (data == NULL) return 0; transfer_tcpinfo = (struct tcpinfo *)data; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""LDSS""); transfer_conv = find_conversation (pinfo->fd->num, &pinfo->src, &pinfo->dst, PT_TCP, pinfo->srcport, pinfo->destport, 0); transfer_info = (ldss_transfer_info_t *)conversation_get_proto_data(transfer_conv, proto_ldss); if (transfer_tcpinfo->seq == 1 && transfer_tcpinfo->lastackseq == 1 && transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND) { guint offset = 0; gboolean already_dissected = TRUE; col_set_str(pinfo->cinfo, COL_INFO, ""LDSS File Transfer (Requesting file - pull)""); if (highest_num_seen == 0 || highest_num_seen < pinfo->fd->num) { already_dissected = FALSE; transfer_info->req = wmem_new0(wmem_file_scope(), ldss_file_request_t); transfer_info->req->file = wmem_new0(wmem_file_scope(), ldss_file_t); highest_num_seen = pinfo->fd->num; } if (tree) { ti = proto_tree_add_item(tree, proto_ldss, tvb, 0, tvb_reported_length(tvb), ENC_NA); ldss_tree = proto_item_add_subtree(ti, ett_ldss_transfer); } transfer_info->file = transfer_info->req->file; while (tvb_offset_exists(tvb, offset)) { gint next_offset; const guint8 *line; int linelen; gboolean is_digest_line; guint digest_type_len; linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE); line = (guint8 *)tvb_memdup(NULL, tvb, offset, linelen+1);  line_tree = proto_tree_add_subtree(ldss_tree, tvb, offset, linelen, ett_ldss_transfer_req, NULL, tvb_format_text(tvb, offset, next_offset-offset)); is_digest_line = FALSE; if (strncmp(line,""md5:"",4)==0) { is_digest_line = TRUE; digest_type_len = 4; transfer_info->file->digest_type = DIGEST_TYPE_MD5; } else if (strncmp(line, ""sha1:"", 5)==0) { is_digest_line = TRUE; digest_type_len = 5; transfer_info->file->digest_type = DIGEST_TYPE_SHA1; } else if (strncmp(line, ""sha256:"", 7)==0) { is_digest_line = TRUE; digest_type_len = 7; transfer_info->file->digest_type = DIGEST_TYPE_SHA256; } else if (strncmp(line, ""unknown:"", 8)==0) { is_digest_line = TRUE; digest_type_len = 8; transfer_info->file->digest_type = DIGEST_TYPE_UNKNOWN; } else if (strncmp(line, ""Size: "", 6)==0) { transfer_info->req->size = g_ascii_strtoull(line+6, NULL, 10); if (tree) { ti = proto_tree_add_uint64(line_tree, hf_ldss_size, tvb, offset+6, linelen-6, transfer_info->req->size); PROTO_ITEM_SET_GENERATED(ti); } } else if (strncmp(line, ""Start: "", 7)==0) { transfer_info->req->offset = g_ascii_strtoull(line+7, NULL, 10); if (tree) { ti = proto_tree_add_uint64(line_tree, hf_ldss_offset, tvb, offset+7, linelen-7, transfer_info->req->offset); PROTO_ITEM_SET_GENERATED(ti); } } else if (strncmp(line, ""Compression: "", 13)==0) { transfer_info->req->compression = (gint8)strtol(line+13, NULL, 10);  if (tree) { ti = proto_tree_add_uint(line_tree, hf_ldss_compression, tvb, offset+13, linelen-13, transfer_info->req->compression); PROTO_ITEM_SET_GENERATED(ti); } } else { proto_tree_add_expert(line_tree, pinfo, &ei_ldss_unrecognized_line, tvb, offset, linelen); } if (is_digest_line) { if (!already_dissected) { GByteArray *digest_bytes; digest_bytes = g_byte_array_new(); hex_str_to_bytes( tvb_get_ptr(tvb, offset+digest_type_len, linelen-digest_type_len), digest_bytes, FALSE); if(digest_bytes->len >= DIGEST_LEN) digest_bytes->len = (DIGEST_LEN-1); transfer_info->file->digest = (guint8 *)wmem_alloc0(wmem_file_scope(), DIGEST_LEN); memcpy(transfer_info->file->digest, digest_bytes->data, digest_bytes->len); g_byte_array_free(digest_bytes, TRUE); } if (tree) { proto_item *tii = NULL; tii = proto_tree_add_uint(line_tree, hf_ldss_digest_type, tvb, offset, digest_type_len, transfer_info->file->digest_type); PROTO_ITEM_SET_GENERATED(tii); tii = proto_tree_add_bytes(line_tree, hf_ldss_digest, tvb, offset+digest_type_len, MIN(linelen-digest_type_len, DIGEST_LEN), transfer_info->file->digest); PROTO_ITEM_SET_GENERATED(tii); } } offset = next_offset; } if (tree && transfer_info->resp_num != 0) { ti = proto_tree_add_uint(ldss_tree, hf_ldss_response_in, tvb, 0, 0, transfer_info->resp_num); PROTO_ITEM_SET_GENERATED(ti); } transfer_info->req->num = pinfo->fd->num; transfer_info->req->ts = pinfo->fd->abs_ts; } else { guint64 size; guint64 offset; guint8 compression; if (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND && transfer_info->req != NULL) { transfer_info->file = transfer_info->req->file; size = transfer_info->req->size; offset = transfer_info->req->offset; compression = transfer_info->req->compression; } else { transfer_info->file = transfer_info->broadcast->file; size = transfer_info->broadcast->size; offset = transfer_info->broadcast->offset; compression = transfer_info->broadcast->compression; } if (pinfo->can_desegment) { if (size == 0 || tvb_captured_length(tvb) < size) { pinfo->desegment_offset = 0; pinfo->desegment_len = DESEGMENT_UNTIL_FIN; return 0; } } transfer_info->resp_num = pinfo->fd->num; transfer_info->resp_ts = pinfo->fd->abs_ts; col_add_fstr(pinfo->cinfo, COL_INFO, ""LDSS File Transfer (Sending file - %s)"", transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND ? ""pull"" : ""push""); if (tree) { ti = proto_tree_add_item(tree, proto_ldss, tvb, 0, tvb_reported_length(tvb), ENC_NA); ldss_tree = proto_item_add_subtree(ti, ett_ldss_transfer); proto_tree_add_bytes_format(ldss_tree, hf_ldss_file_data, tvb, 0, tvb_captured_length(tvb), NULL, compression == COMPRESSION_GZIP ? ""Gzip compressed data: %d bytes"" : ""File data: %d bytes"", tvb_captured_length(tvb)); #ifdef HAVE_LIBZ if (compression == COMPRESSION_GZIP) { tvbuff_t *uncomp_tvb; uncomp_tvb = tvb_child_uncompress(tvb, tvb, 0, tvb_captured_length(tvb)); if (uncomp_tvb != NULL) { add_new_data_source(pinfo, uncomp_tvb, ""Uncompressed Data""); proto_tree_add_bytes_format_value(ldss_tree, hf_ldss_file_data, uncomp_tvb, 0, tvb_captured_length(uncomp_tvb), NULL, ""Uncompressed data: %d bytes"", tvb_captured_length(uncomp_tvb)); } } #endif ti = proto_tree_add_uint(ldss_tree, hf_ldss_digest_type, tvb, 0, 0, transfer_info->file->digest_type); PROTO_ITEM_SET_GENERATED(ti); if (transfer_info->file->digest != NULL) { ti = proto_tree_add_bytes(ldss_tree, hf_ldss_digest, tvb, 0, DIGEST_LEN, transfer_info->file->digest); } PROTO_ITEM_SET_GENERATED(ti); ti = proto_tree_add_uint64(ldss_tree, hf_ldss_size, tvb, 0, 0, size); PROTO_ITEM_SET_GENERATED(ti); ti = proto_tree_add_uint64(ldss_tree, hf_ldss_offset, tvb, 0, 0, offset); PROTO_ITEM_SET_GENERATED(ti); ti = proto_tree_add_uint(ldss_tree, hf_ldss_compression, tvb, 0, 0, compression); PROTO_ITEM_SET_GENERATED(ti); if (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND && transfer_info->req != NULL && transfer_info->req->num != 0) { ti = proto_tree_add_uint(ldss_tree, hf_ldss_response_to, tvb, 0, 0, transfer_info->req->num); PROTO_ITEM_SET_GENERATED(ti); } } } if (transfer_info->broadcast->message_id == MESSAGE_ID_WILLSEND && transfer_info->req != NULL && transfer_info->resp_num != 0) { nstime_t pull_response_time; nstime_delta(&pull_response_time, &transfer_info->resp_ts, &transfer_info->req->ts); ti = proto_tree_add_time(ldss_tree, hf_ldss_transfer_response_time, tvb, 0, 0, &pull_response_time); PROTO_ITEM_SET_GENERATED(ti); } ti = proto_tree_add_uint(ldss_tree, hf_ldss_initiated_by, tvb, 0, 0, transfer_info->broadcast->num); PROTO_ITEM_SET_GENERATED(ti); if (transfer_info->resp_num != 0) { nstime_delta(&broadcast_response_time, &transfer_info->resp_ts, &transfer_info->broadcast->ts); ti = proto_tree_add_time(ldss_tree, hf_ldss_transfer_completed_in, tvb, 0, 0, &broadcast_response_time); PROTO_ITEM_SET_GENERATED(ti); } if (transfer_tcpinfo->seq == 1 && transfer_tcpinfo->lastackseq == 1) { prepare_ldss_transfer_conv(transfer_info->broadcast); } return tvb_captured_length(tvb); }"
"int read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id, uint32_t offset, uint32_t length, uint8_t *frubuf) { static uint32_t fru_data_rqst_size = 20; uint32_t off = offset, tmp, finish; struct ipmi_rs * rsp; struct ipmi_rq req; uint8_t msg_data[4]; if (offset > fru->size) { lprintf(LOG_ERR, ""Read FRU Area offset incorrect: %d > %d"", offset, fru->size); return -1; } finish = offset + length; if (finish > fru->size) { finish = fru->size; lprintf(LOG_NOTICE, ""Read FRU Area length %d too large, "" ""Adjusting to %d"", offset + length, finish - offset); } memset(&req, 0, sizeof(req)); req.msg.netfn = IPMI_NETFN_STORAGE; req.msg.cmd = GET_FRU_DATA; req.msg.data = msg_data; req.msg.data_len = 4; #ifdef LIMIT_ALL_REQUEST_SIZE if (fru_data_rqst_size > 16) #else if (fru->access && fru_data_rqst_size > 16) #endif fru_data_rqst_size = 16; do { tmp = fru->access ? off >> 1 : off; msg_data[0] = id; msg_data[1] = (uint8_t)(tmp & 0xff); msg_data[2] = (uint8_t)(tmp >> 8); tmp = finish - off; if (tmp > fru_data_rqst_size) msg_data[3] = (uint8_t)fru_data_rqst_size; else msg_data[3] = (uint8_t)tmp; rsp = intf->sendrecv(intf, &req); if (!rsp) { lprintf(LOG_NOTICE, ""FRU Read failed""); break; } if (rsp->ccode) { if (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) { lprintf(LOG_INFO, ""Retrying FRU read with request size %d"", fru_data_rqst_size); continue; } lprintf(LOG_NOTICE, ""FRU Read failed: %s"", val2str(rsp->ccode, completion_code_vals)); break; } tmp = fru->access ? rsp->data[0] << 1 : rsp->data[0]; memcpy((frubuf + off)-offset, rsp->data + 1, tmp); off += tmp; if (tmp == 0 && off < finish) return 0; } while (off < finish); if (off < finish) return -1; return 0; }"
"static int dissect_bencoded_list(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, const char *label  ) { proto_item *ti; proto_tree *sub_tree; guint       one_byte; const char *result; ti = proto_tree_add_none_format( tree, hf_bencoded_list, tvb, offset, 0, ""%s: list..."", label ); sub_tree = proto_item_add_subtree( ti, ett_bencoded_list); offset += 1; while( (one_byte=tvb_get_guint8(tvb,offset)) != 'e' ) { switch( one_byte ) { case 'i': offset = dissect_bencoded_int( tvb, pinfo, sub_tree, offset, &result, ""Integer"" ); break; case 'l': offset = dissect_bencoded_list( tvb, pinfo, sub_tree, offset, ""Sub-list"" ); break; case 'd': offset = dissect_bencoded_dict( tvb, pinfo, sub_tree, offset, ""Sub-dict"" ); break; default: offset = dissect_bencoded_string( tvb, pinfo, sub_tree, offset, &result, FALSE, ""String"" ); if (offset == 0) { proto_tree_add_expert(sub_tree, pinfo, &ei_int_string, tvb, offset, -1); return 0; } break; } } proto_tree_add_item(sub_tree, hf_bencoded_list_terminator, tvb, offset, 1, ENC_ASCII|ENC_NA); offset += 1; return offset; }"
"PgQueryPlpgsqlParseResult pg_query_parse_plpgsql(const char* input) { MemoryContext ctx = NULL; PgQueryPlpgsqlParseResult result = {0}; PgQueryInternalParsetreeAndError parse_result; createFunctionStmts statements; size_t i; ctx = pg_query_enter_memory_context(""pg_query_parse_plpgsql""); parse_result = pg_query_raw_parse(input); result.error = parse_result.error; if (result.error != NULL) { pg_query_exit_memory_context(ctx); return result; } statements.stmts_buf_size = 100; statements.stmts = (CreateFunctionStmt**) palloc(statements.stmts_buf_size * sizeof(CreateFunctionStmt*)); statements.stmts_count = 0; create_function_stmts_walker((Node*) parse_result.tree, &statements); if (statements.stmts_count == 0) { result.plpgsql_funcs = strdup(""[]""); pg_query_exit_memory_context(ctx); return result; } result.plpgsql_funcs = strdup(""[\n""); for (i = 0; i < statements.stmts_count; i++) { PgQueryInternalPlpgsqlFuncAndError func_and_error; func_and_error = pg_query_raw_parse_plpgsql(statements.stmts[i]); result.error = func_and_error.error; if (result.error != NULL) { pg_query_exit_memory_context(ctx); return result; } if (func_and_error.func != NULL) { char *func_json; char *new_out; int ignored; func_json = plpgsqlToJSON(func_and_error.func); plpgsql_free_function_memory(func_and_error.func); ignored = asprintf(&new_out, ""%s%s,\n"", result.plpgsql_funcs, func_json); free(result.plpgsql_funcs); result.plpgsql_funcs = new_out; pfree(func_json); } } result.plpgsql_funcs[strlen(result.plpgsql_funcs) - 2] = '\n'; result.plpgsql_funcs[strlen(result.plpgsql_funcs) - 1] = ']'; pg_query_exit_memory_context(ctx); return result; }"
"static CallResult<HermesValue> getCodeBlockFileName( Runtime &runtime, const CodeBlock *codeBlock, OptValue<hbc::DebugSourceLocation> location) { RuntimeModule *runtimeModule = codeBlock->getRuntimeModule(); if (location) { auto debugInfo = runtimeModule->getBytecode()->getDebugInfo(); return StringPrimitive::createEfficient( runtime, debugInfo->getFilenameByID(location->filenameId)); } else { llvh::StringRef sourceURL = runtimeModule->getSourceURL(); if (!sourceURL.empty()) { return StringPrimitive::createEfficient(runtime, sourceURL); } } return HermesValue::encodeUndefinedValue(); }"
"Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index, const bool validate_indices, sparse::SparseTensor* tensor) { TensorShape shape; TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape( ctx->input(base_index + 2).vec<int64_t>(), &shape)); CheckRankAtLeast2(ctx, shape); std::vector<int64_t> order(shape.dims()); std::iota(order.begin(), order.end(), 0); Status status = sparse::SparseTensor::Create( ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor); if (!validate_indices || !status.ok()) return status; return tensor->IndicesValid(); }"
"void RPZIXFRTracker(const ComboAddress& master, const DNSName& zone, const std::string& polName, const TSIGTriplet& tt, shared_ptr<SOARecordContent> oursr) { int refresh = oursr->d_st.refresh; for(;;) { DNSRecord dr; dr.d_content=oursr; sleep(refresh); L<<Logger::Info<<""Getting IXFR deltas for ""<<zone<<"" from ""<<master.toStringWithPort()<<"", our serial: ""<<getRR<SOARecordContent>(dr)->d_st.serial<<endl; vector<pair<vector<DNSRecord>, vector<DNSRecord> > > deltas; try { deltas = getIXFRDeltas(master, zone, dr, tt); } catch(std::runtime_error& e ){ L<<Logger::Warning<<e.what()<<endl; continue; } if(deltas.empty()) continue; L<<Logger::Info<<""Processing ""<<deltas.size()<<"" delta""<<addS(deltas)<<"" for RPZ ""<<zone<<endl; auto luaconfsCopy = g_luaconfs.getCopy(); int totremove=0, totadd=0; for(const auto& delta : deltas) { const auto& remove = delta.first; const auto& add = delta.second; if(remove.empty()) { L<<Logger::Warning<<""IXFR update is a whole new zone""<<endl; luaconfsCopy.dfe.clear(0); } for(const auto& rr : remove) { totremove++; if(rr.d_type == QType::SOA) { auto oldsr = getRR<SOARecordContent>(rr); if(oldsr && oldsr->d_st.serial == oursr->d_st.serial) { } else L<<Logger::Error<<""GOT WRONG SOA SERIAL REMOVAL, SHOULD TRIGGER WHOLE RELOAD""<<endl; } else { L<<Logger::Info<<""Had removal of ""<<rr.d_name<<endl; RPZRecordToPolicy(rr, luaconfsCopy.dfe, polName, false, boost::optional<DNSFilterEngine::Policy>(), 0); } } for(const auto& rr : add) { totadd++; if(rr.d_type == QType::SOA) { auto newsr = getRR<SOARecordContent>(rr); if (newsr) { oursr = newsr; } } else { L<<Logger::Info<<""Had addition of ""<<rr.d_name<<endl; RPZRecordToPolicy(rr, luaconfsCopy.dfe, polName, true, boost::optional<DNSFilterEngine::Policy>(), 0); } } } L<<Logger::Info<<""Had ""<<totremove<<"" RPZ removal""<<addS(totremove)<<"", ""<<totadd<<"" addition""<<addS(totadd)<<"" for ""<<zone<<"" New serial: ""<<oursr->d_st.serial<<endl; g_luaconfs.setState(luaconfsCopy); } }"
"static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len, void *data, size_t size, u16 *result) { struct l2cap_conf_req *req = data; void *ptr = req->data; void *endptr = data + size; int type, olen; unsigned long val; struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC }; struct l2cap_conf_efs efs; BT_DBG(""chan %p, rsp %p, len %d, req %p"", chan, rsp, len, data); while (len >= L2CAP_CONF_OPT_SIZE) { len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val); switch (type) { case L2CAP_CONF_MTU: if (olen != 2) break; if (val < L2CAP_DEFAULT_MIN_MTU) { *result = L2CAP_CONF_UNACCEPT; chan->imtu = L2CAP_DEFAULT_MIN_MTU; } else chan->imtu = val; l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->imtu, endptr - ptr); break; case L2CAP_CONF_FLUSH_TO: if (olen != 2) break; chan->flush_to = val; l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, chan->flush_to, endptr - ptr); break; case L2CAP_CONF_RFC: if (olen != sizeof(rfc)) break; memcpy(&rfc, (void *)val, olen); if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) && rfc.mode != chan->mode) return -ECONNREFUSED; chan->fcs = 0; l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); break; case L2CAP_CONF_EWS: if (olen != 2) break; chan->ack_win = min_t(u16, val, chan->ack_win); l2cap_add_conf_opt(&ptr, L2CAP_CONF_EWS, 2, chan->tx_win, endptr - ptr); break; case L2CAP_CONF_EFS: if (olen != sizeof(efs)) break; memcpy(&efs, (void *)val, olen); if (chan->local_stype != L2CAP_SERV_NOTRAFIC && efs.stype != L2CAP_SERV_NOTRAFIC && efs.stype != chan->local_stype) return -ECONNREFUSED; l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs, endptr - ptr); break; case L2CAP_CONF_FCS: if (olen != 1) break; if (*result == L2CAP_CONF_PENDING) if (val == L2CAP_FCS_NONE) set_bit(CONF_RECV_NO_FCS, &chan->conf_state); break; } } if (chan->mode == L2CAP_MODE_BASIC && chan->mode != rfc.mode) return -ECONNREFUSED; chan->mode = rfc.mode; if (*result == L2CAP_CONF_SUCCESS || *result == L2CAP_CONF_PENDING) { switch (rfc.mode) { case L2CAP_MODE_ERTM: chan->retrans_timeout = le16_to_cpu(rfc.retrans_timeout); chan->monitor_timeout = le16_to_cpu(rfc.monitor_timeout); chan->mps    = le16_to_cpu(rfc.max_pdu_size); if (!test_bit(FLAG_EXT_CTRL, &chan->flags)) chan->ack_win = min_t(u16, chan->ack_win, rfc.txwin_size); if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) { chan->local_msdu = le16_to_cpu(efs.msdu); chan->local_sdu_itime = le32_to_cpu(efs.sdu_itime); chan->local_acc_lat = le32_to_cpu(efs.acc_lat); chan->local_flush_to = le32_to_cpu(efs.flush_to); } break; case L2CAP_MODE_STREAMING: chan->mps    = le16_to_cpu(rfc.max_pdu_size); } } req->dcid   = cpu_to_le16(chan->dcid); req->flags  = cpu_to_le16(0); return ptr - data; }"
"static gboolean compare_by_guid(gconstpointer a, gconstpointer b) { const endpoint_guid * guid_a = (const endpoint_guid *) a; const endpoint_guid * guid_b = (const endpoint_guid *) b; return memcmp(guid_a, guid_b, sizeof(endpoint_guid)) == 0; }"
"static int dpu_crtc_atomic_check(struct drm_crtc *crtc, struct drm_atomic_state *state) { struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state, crtc); struct dpu_crtc *dpu_crtc = to_dpu_crtc(crtc); struct dpu_crtc_state *cstate = to_dpu_crtc_state(crtc_state); struct plane_state *pstates; const struct drm_plane_state *pstate; struct drm_plane *plane; struct drm_display_mode *mode; int cnt = 0, rc = 0, mixer_width = 0, i, z_pos; struct dpu_multirect_plane_states multirect_plane[DPU_STAGE_MAX * 2]; int multirect_count = 0; const struct drm_plane_state *pipe_staged[SSPP_MAX]; int left_zpos_cnt = 0, right_zpos_cnt = 0; struct drm_rect crtc_rect = { 0 }; bool needs_dirtyfb = dpu_crtc_needs_dirtyfb(crtc_state); pstates = kzalloc(sizeof(*pstates) * DPU_STAGE_MAX * 4, GFP_KERNEL); if (!crtc_state->enable || !crtc_state->active) { DRM_DEBUG_ATOMIC(""crtc%d -> enable %d, active %d, skip atomic_check\n"", crtc->base.id, crtc_state->enable, crtc_state->active); memset(&cstate->new_perf, 0, sizeof(cstate->new_perf)); goto end; } mode = &crtc_state->adjusted_mode; DRM_DEBUG_ATOMIC(""%s: check\n"", dpu_crtc->name); if (crtc_state->active_changed) crtc_state->mode_changed = true; memset(pipe_staged, 0, sizeof(pipe_staged)); if (cstate->num_mixers) { mixer_width = mode->hdisplay / cstate->num_mixers; _dpu_crtc_setup_lm_bounds(crtc, crtc_state); } crtc_rect.x2 = mode->hdisplay; crtc_rect.y2 = mode->vdisplay; drm_atomic_crtc_state_for_each_plane_state(plane, pstate, crtc_state) { struct dpu_plane_state *dpu_pstate = to_dpu_plane_state(pstate); struct drm_rect dst, clip = crtc_rect; if (IS_ERR_OR_NULL(pstate)) { rc = PTR_ERR(pstate); DPU_ERROR(""%s: failed to get plane%d state, %d\n"", dpu_crtc->name, plane->base.id, rc); goto end; } if (cnt >= DPU_STAGE_MAX * 4) continue; if (!pstate->visible) continue; pstates[cnt].dpu_pstate = dpu_pstate; pstates[cnt].drm_pstate = pstate; pstates[cnt].stage = pstate->normalized_zpos; pstates[cnt].pipe_id = dpu_plane_pipe(plane); dpu_pstate->needs_dirtyfb = needs_dirtyfb; if (pipe_staged[pstates[cnt].pipe_id]) { multirect_plane[multirect_count].r0 = pipe_staged[pstates[cnt].pipe_id]; multirect_plane[multirect_count].r1 = pstate; multirect_count++; pipe_staged[pstates[cnt].pipe_id] = NULL; } else { pipe_staged[pstates[cnt].pipe_id] = pstate; } cnt++; dst = drm_plane_state_dest(pstate); if (!drm_rect_intersect(&clip, &dst)) { DPU_ERROR(""invalid vertical/horizontal destination\n""); DPU_ERROR(""display: "" DRM_RECT_FMT "" plane: "" DRM_RECT_FMT ""\n"", DRM_RECT_ARG(&crtc_rect), DRM_RECT_ARG(&dst)); rc = -E2BIG; goto end; } } for (i = 1; i < SSPP_MAX; i++) { if (pipe_staged[i]) dpu_plane_clear_multirect(pipe_staged[i]); } z_pos = -1; for (i = 0; i < cnt; i++) { if (pstates[i].stage != z_pos) { left_zpos_cnt = 0; right_zpos_cnt = 0; z_pos = pstates[i].stage; } if (z_pos >= DPU_STAGE_MAX - DPU_STAGE_0) { DPU_ERROR(""> %d plane stages assigned\n"", DPU_STAGE_MAX - DPU_STAGE_0); rc = -EINVAL; goto end; } else if (pstates[i].drm_pstate->crtc_x < mixer_width) { if (left_zpos_cnt == 2) { DPU_ERROR(""> 2 planes @ stage %d on left\n"", z_pos); rc = -EINVAL; goto end; } left_zpos_cnt++; } else { if (right_zpos_cnt == 2) { DPU_ERROR(""> 2 planes @ stage %d on right\n"", z_pos); rc = -EINVAL; goto end; } right_zpos_cnt++; } pstates[i].dpu_pstate->stage = z_pos + DPU_STAGE_0; DRM_DEBUG_ATOMIC(""%s: zpos %d\n"", dpu_crtc->name, z_pos); } for (i = 0; i < multirect_count; i++) { if (dpu_plane_validate_multirect_v2(&multirect_plane[i])) { DPU_ERROR( ""multirect validation failed for planes (%d - %d)\n"", multirect_plane[i].r0->plane->base.id, multirect_plane[i].r1->plane->base.id); rc = -EINVAL; goto end; } } atomic_inc(&_dpu_crtc_get_kms(crtc)->bandwidth_ref); rc = dpu_core_perf_crtc_check(crtc, crtc_state); if (rc) { DPU_ERROR(""crtc%d failed performance check %d\n"", crtc->base.id, rc); goto end; } for (i = 1; i < cnt; i++) { struct plane_state *prv_pstate, *cur_pstate; struct drm_rect left_rect, right_rect; int32_t left_pid, right_pid; int32_t stage; prv_pstate = &pstates[i - 1]; cur_pstate = &pstates[i]; if (prv_pstate->stage != cur_pstate->stage) continue; stage = cur_pstate->stage; left_pid = prv_pstate->dpu_pstate->base.plane->base.id; left_rect = drm_plane_state_dest(prv_pstate->drm_pstate); right_pid = cur_pstate->dpu_pstate->base.plane->base.id; right_rect = drm_plane_state_dest(cur_pstate->drm_pstate); if (right_rect.x1 < left_rect.x1) { swap(left_pid, right_pid); swap(left_rect, right_rect); } if (right_pid < left_pid) { DPU_ERROR( ""invalid src split cfg. priority mismatch. stage: %d left: %d right: %d\n"", stage, left_pid, right_pid); rc = -EINVAL; goto end; } else if (right_rect.x1 != drm_rect_width(&left_rect)) { DPU_ERROR(""non-contiguous coordinates for src split. "" ""stage: %d left: "" DRM_RECT_FMT "" right: "" DRM_RECT_FMT ""\n"", stage, DRM_RECT_ARG(&left_rect), DRM_RECT_ARG(&right_rect)); rc = -EINVAL; goto end; } else if (left_rect.y1 != right_rect.y1 || drm_rect_height(&left_rect) != drm_rect_height(&right_rect)) { DPU_ERROR(""source split at stage: %d. invalid "" ""yoff/height: left: "" DRM_RECT_FMT "" right: "" DRM_RECT_FMT ""\n"", stage, DRM_RECT_ARG(&left_rect), DRM_RECT_ARG(&right_rect)); rc = -EINVAL; goto end; } } end: kfree(pstates); return rc; }"
"static int ept_next_level(struct p2m_domain *p2m, bool_t read_only, ept_entry_t **table, unsigned long *gfn_remainder, int next_level) { ept_entry_t *ept_entry, *next = NULL, e; u32 shift, index; shift = next_level * EPT_TABLE_ORDER; index = *gfn_remainder >> shift; ASSERT(index < EPT_PAGETABLE_ENTRIES); ept_entry = (*table) + index; e = atomic_read_ept_entry(ept_entry); if ( !is_epte_present(&e) ) { if ( e.sa_p2mt == p2m_populate_on_demand ) return GUEST_TABLE_POD_PAGE; if ( read_only ) return GUEST_TABLE_MAP_FAILED; next = ept_set_middle_entry(p2m, ept_entry); if ( !next ) return GUEST_TABLE_MAP_FAILED; } else if ( is_epte_superpage(&e) ) return GUEST_TABLE_SUPER_PAGE; unmap_domain_page(*table); *table = next ?: map_domain_page(_mfn(e.mfn)); *gfn_remainder &= (1UL << shift) - 1; return GUEST_TABLE_NORMAL_PAGE; }"
"void Converter::cnvXmpGPSVersion(const char* from, const char* to) { Exiv2::XmpData::iterator pos = xmpData_->findKey(XmpKey(from)); if (pos == xmpData_->end()) return; if (!prepareExifTarget(to)) return; std::string value = pos->toString(); if (!pos->value().ok()) { #ifndef SUPPRESS_WARNINGS EXV_WARNING << ""Failed to convert "" << from << "" to "" << to << ""\n""; #endif return; } for (unsigned i = 0; i < value.length(); ++i) { if (value[i] == '.') value[i] = ' '; } (*exifData_)[to] = value; if (erase_) xmpData_->erase(pos); }"
"static inline void ncp_invalidate_dircache_entries(struct dentry *parent) { struct ncp_server *server = NCP_SERVER(parent->d_inode); struct dentry *dentry; spin_lock(&parent->d_lock); list_for_each_entry(dentry, &parent->d_subdirs, d_u.d_child) { dentry->d_fsdata = NULL; ncp_age_dentry(server, dentry); } spin_unlock(&parent->d_lock); }"
"String DOMWindow::crossDomainAccessErrorMessage(const LocalDOMWindow* callingWindow) const { if (!callingWindow || !callingWindow->document() || !frame()) return String(); const KURL& callingWindowURL = callingWindow->document()->url(); if (callingWindowURL.isNull()) return String(); const SecurityOrigin* activeOrigin = callingWindow->document()->getSecurityOrigin(); const SecurityOrigin* targetOrigin = frame()->securityContext()->getSecurityOrigin(); ASSERT(!activeOrigin->canAccessCheckSuborigins(targetOrigin)); String message = ""Blocked a frame with origin \"""" + activeOrigin->toString() + ""\"" from accessing a frame with origin \"""" + targetOrigin->toString() + ""\"". ""; KURL activeURL = callingWindow->document()->url(); KURL targetURL = isLocalDOMWindow() ? document()->url() : KURL(KURL(), targetOrigin->toString()); if (frame()->securityContext()->isSandboxed(SandboxOrigin) || callingWindow->document()->isSandboxed(SandboxOrigin)) { message = ""Blocked a frame at \"""" + SecurityOrigin::create(activeURL)->toString() + ""\"" from accessing a frame at \"""" + SecurityOrigin::create(targetURL)->toString() + ""\"". ""; if (frame()->securityContext()->isSandboxed(SandboxOrigin) && callingWindow->document()->isSandboxed(SandboxOrigin)) return ""Sandbox access violation: "" + message + "" Both frames are sandboxed and lack the \""allow-same-origin\"" flag.""; if (frame()->securityContext()->isSandboxed(SandboxOrigin)) return ""Sandbox access violation: "" + message + "" The frame being accessed is sandboxed and lacks the \""allow-same-origin\"" flag.""; return ""Sandbox access violation: "" + message + "" The frame requesting access is sandboxed and lacks the \""allow-same-origin\"" flag.""; } if (targetOrigin->protocol() != activeOrigin->protocol()) return message + "" The frame requesting access has a protocol of \"""" + activeURL.protocol() + ""\"", the frame being accessed has a protocol of \"""" + targetURL.protocol() + ""\"". Protocols must match.\n""; if (targetOrigin->domainWasSetInDOM() && activeOrigin->domainWasSetInDOM()) return message + ""The frame requesting access set \""document.domain\"" to \"""" + activeOrigin->domain() + ""\"", the frame being accessed set it to \"""" + targetOrigin->domain() + ""\"". Both must set \""document.domain\"" to the same value to allow access.""; if (activeOrigin->domainWasSetInDOM()) return message + ""The frame requesting access set \""document.domain\"" to \"""" + activeOrigin->domain() + ""\"", but the frame being accessed did not. Both must set \""document.domain\"" to the same value to allow access.""; if (targetOrigin->domainWasSetInDOM()) return message + ""The frame being accessed set \""document.domain\"" to \"""" + targetOrigin->domain() + ""\"", but the frame requesting access did not. Both must set \""document.domain\"" to the same value to allow access.""; return message + ""Protocols, domains, and ports must match.""; }"
"static gboolean _handle_carbons(xmpp_stanza_t *const stanza) { xmpp_stanza_t *carbons = xmpp_stanza_get_child_by_ns(stanza, STANZA_NS_CARBONS); if (!carbons) { return FALSE; } const char *name = xmpp_stanza_get_name(carbons); if (!name) { log_error(""Unable to retrieve stanza name for Carbon""); return TRUE; } if (g_strcmp0(name, ""private"") == 0) { log_info(""Carbon received with private element.""); return FALSE; } if ((g_strcmp0(name, ""received"") != 0) && (g_strcmp0(name, ""sent"") != 0)) { log_warning(""Carbon received with unrecognised stanza name: %s"", name); return TRUE; } xmpp_stanza_t *forwarded = xmpp_stanza_get_child_by_ns(carbons, STANZA_NS_FORWARD); if (!forwarded) { log_warning(""Carbon received with no forwarded element""); return TRUE; } xmpp_stanza_t *message = xmpp_stanza_get_child_by_name(forwarded, STANZA_NAME_MESSAGE); if (!message) { log_warning(""Carbon received with no message element""); return TRUE; } char *message_txt = xmpp_message_get_body(message); if (!message_txt) { log_warning(""Carbon received with no message.""); return TRUE; } const gchar *to = xmpp_stanza_get_to(message); const gchar *from = xmpp_stanza_get_from(message); if (!to) to = from; Jid *jid_from = jid_create(from); Jid *jid_to = jid_create(to); Jid *my_jid = jid_create(connection_get_fulljid()); char *enc_message = NULL; xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED); if (x) { enc_message = xmpp_stanza_get_text(x); } if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) { sv_ev_incoming_carbon(jid_from->barejid, jid_from->resourcepart, message_txt, enc_message); } else { sv_ev_outgoing_carbon(jid_to->barejid, message_txt, enc_message); } xmpp_ctx_t *ctx = connection_get_ctx(); xmpp_free(ctx, message_txt); xmpp_free(ctx, enc_message); jid_destroy(jid_from); jid_destroy(jid_to); jid_destroy(my_jid); return TRUE; }"
"static unsigned int set_iommu_pde_present(struct amd_iommu_pte *pte, unsigned long next_mfn, unsigned int next_level, bool iw, bool ir) { unsigned int flush_flags = IOMMU_FLUSHF_added; if ( pte->pr && (pte->mfn != next_mfn || pte->iw != iw || pte->ir != ir || pte->next_level != next_level) ) flush_flags |= IOMMU_FLUSHF_modified; pte->fc = !next_level; pte->mfn = next_mfn; pte->iw = iw; pte->ir = ir; pte->next_level = next_level; pte->pr = 1; return flush_flags; }"
"inline typename V::VectorType FBUnserializer<V>::unserializeVector() { p_ += CODE_SIZE; typename V::VectorType ret = V::createVector(); size_t code = nextCode(); while (code != FB_SERIALIZE_STOP) { V::vectorAppend(ret, unserializeThing()); code = nextCode(); } p_ += CODE_SIZE; return ret; }"
"static void gre_print_0(netdissect_options *ndo, const u_char *bp, u_int length) { u_int len = length; uint16_t flags, prot; flags = EXTRACT_16BITS(bp); if (ndo->ndo_vflag) ND_PRINT((ndo, "", Flags [%s]"", bittok2str(gre_flag_values,""none"",flags))); len -= 2; bp += 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; prot = EXTRACT_16BITS(bp); len -= 2; bp += 2; if ((flags & GRE_CP) | (flags & GRE_RP)) { ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; if (ndo->ndo_vflag) ND_PRINT((ndo, "", sum 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; ND_TCHECK2(*bp, 2); if (len < 2) goto trunc; ND_PRINT((ndo, "", off 0x%x"", EXTRACT_16BITS(bp))); bp += 2; len -= 2; } if (flags & GRE_KP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", key=0x%x"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_SP) { ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; ND_PRINT((ndo, "", seq %u"", EXTRACT_32BITS(bp))); bp += 4; len -= 4; } if (flags & GRE_RP) { for (;;) { uint16_t af; uint8_t sreoff; uint8_t srelen; ND_TCHECK2(*bp, 4); if (len < 4) goto trunc; af = EXTRACT_16BITS(bp); sreoff = *(bp + 2); srelen = *(bp + 3); bp += 4; len -= 4; if (af == 0 && srelen == 0) break; if (!gre_sre_print(ndo, af, sreoff, srelen, bp, len)) goto trunc; if (len < srelen) goto trunc; bp += srelen; len -= srelen; } } if (ndo->ndo_eflag) ND_PRINT((ndo, "", proto %s (0x%04x)"", tok2str(ethertype_values,""unknown"",prot), prot)); ND_PRINT((ndo, "", length %u"",length)); if (ndo->ndo_vflag < 1) ND_PRINT((ndo, "": ""));  else ND_PRINT((ndo, ""\n\t""));  switch (prot) { case ETHERTYPE_IP: ip_print(ndo, bp, len); break; case ETHERTYPE_IPV6: ip6_print(ndo, bp, len); break; case ETHERTYPE_MPLS: mpls_print(ndo, bp, len); break; case ETHERTYPE_IPX: ipx_print(ndo, bp, len); break; case ETHERTYPE_ATALK: atalk_print(ndo, bp, len); break; case ETHERTYPE_GRE_ISO: isoclns_print(ndo, bp, len, ndo->ndo_snapend - bp); break; case ETHERTYPE_TEB: ether_print(ndo, bp, len, ndo->ndo_snapend - bp, NULL, NULL); break; default: ND_PRINT((ndo, ""gre-proto-0x%x"", prot)); } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
"MODRET copy_cpto(cmd_rec *cmd) { register unsigned int i; const char *from, *to = """"; unsigned char *authenticated = NULL; if (copy_engine == FALSE) { return PR_DECLINED(cmd); } if (cmd->argc < 3 || strncasecmp(cmd->argv[1], ""CPTO"", 5) != 0) { return PR_DECLINED(cmd); } authenticated = get_param_ptr(cmd->server->conf, ""authenticated"", FALSE); if (authenticated == NULL || *authenticated == FALSE) { pr_response_add_err(R_530, _(""Please login with USER and PASS"")); pr_cmd_set_errno(cmd, EPERM); errno = EPERM; return PR_ERROR(cmd); } CHECK_CMD_MIN_ARGS(cmd, 3); from = pr_table_get(session.notes, ""mod_copy.cpfr-path"", NULL); if (from == NULL) { pr_response_add_err(R_503, _(""Bad sequence of commands"")); pr_cmd_set_errno(cmd, EPERM); errno = EPERM; return PR_ERROR(cmd); } for (i = 2; i <= cmd->argc-1; i++) { char *decoded_path; decoded_path = pr_fs_decode_path2(cmd->tmp_pool, cmd->argv[i], FSIO_DECODE_FL_TELL_ERRORS); if (decoded_path == NULL) { int xerrno = errno; pr_log_debug(DEBUG8, ""'%s' failed to decode properly: %s"", (char *) cmd->argv[i], strerror(xerrno)); pr_response_add_err(R_550, _(""%s: Illegal character sequence in filename""), cmd->arg); pr_cmd_set_errno(cmd, xerrno); errno = xerrno; return PR_ERROR(cmd); } to = pstrcat(cmd->tmp_pool, to, *to ? "" "" : """", decoded_path, NULL); } to = dir_canonical_vpath(cmd->tmp_pool, to); if (copy_paths(cmd->tmp_pool, from, to) < 0) { int xerrno = errno; const char *err_code = R_550; pr_log_debug(DEBUG7, MOD_COPY_VERSION "": error copying '%s' to '%s': %s"", from, to, strerror(xerrno)); switch (xerrno) { #if defined(EDQUOT) case EDQUOT: #endif  #if defined(EFBIG) case EFBIG: #endif  #if defined(ENOSPC) case ENOSPC: #endif  err_code = R_552; break; default: err_code = R_550; break; } pr_response_add_err(err_code, ""%s: %s"", (char *) cmd->argv[1], strerror(xerrno)); pr_cmd_set_errno(cmd, xerrno); errno = xerrno; return PR_ERROR(cmd); } pr_response_add(R_250, ""%s"", _(""Copy successful"")); return PR_HANDLED(cmd); }"
"void SingleDuel::UpdateDeck(DuelPlayer* dp, void* pdata, unsigned int len) { if(dp->type > 1 || ready[dp->type]) return; char* deckbuf = (char*)pdata; int mainc = BufferIO::ReadInt32(deckbuf); int sidec = BufferIO::ReadInt32(deckbuf); if((unsigned)mainc + (unsigned)sidec > (len - 8) / 4) { STOC_ErrorMsg scem; scem.msg = ERRMSG_DECKERROR; scem.code = 0; NetServer::SendPacketToPlayer(dp, STOC_ERROR_MSG, scem); return; } if(duel_count == 0) { deck_error[dp->type] = deckManager.LoadDeck(pdeck[dp->type], (int*)deckbuf, mainc, sidec); } else { if(deckManager.LoadSide(pdeck[dp->type], (int*)deckbuf, mainc, sidec)) { ready[dp->type] = true; NetServer::SendPacketToPlayer(dp, STOC_DUEL_START); if(ready[0] && ready[1]) { NetServer::SendPacketToPlayer(players[tp_player], STOC_SELECT_TP); players[1 - tp_player]->state = 0xff; players[tp_player]->state = CTOS_TP_RESULT; duel_stage = DUEL_STAGE_FIRSTGO; } } else { STOC_ErrorMsg scem; scem.msg = ERRMSG_SIDEERROR; scem.code = 0; NetServer::SendPacketToPlayer(dp, STOC_ERROR_MSG, scem); } } }"
"set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) { lock_guard<std::recursive_mutex> guard(globalMutex); string pipePath = endpoint.name(); if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) { throw runtime_error(""Tried to listen twice on the same path""); } sockaddr_un local; int fd = socket(AF_UNIX, SOCK_STREAM, 0); FATAL_FAIL(fd); initServerSocket(fd); local.sun_family = AF_UNIX;  strcpy(local.sun_path, pipePath.c_str()); unlink(local.sun_path); FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un))); ::listen(fd, 5); #ifndef WIN32 FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR)); #endif pipeServerSockets[pipePath] = set<int>({fd}); return pipeServerSockets[pipePath]; }"
"void PackLinuxElf32::PackLinuxElf32help1(InputFile *f) { e_type  = get_te16(&ehdri.e_type); e_phnum = get_te16(&ehdri.e_phnum); e_shnum = get_te16(&ehdri.e_shnum); unsigned const e_phentsize = get_te16(&ehdri.e_phentsize); if (ehdri.e_ident[Elf32_Ehdr::EI_CLASS]!=Elf32_Ehdr::ELFCLASS32 || sizeof(Elf32_Phdr) != e_phentsize || (Elf32_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA] && &N_BELE_RTP::be_policy != bele) || (Elf32_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf32_Ehdr::EI_DATA] && &N_BELE_RTP::le_policy != bele)) { e_phoff = 0; e_shoff = 0; sz_phdrs = 0; return; } e_phoff = get_te32(&ehdri.e_phoff); e_shoff = get_te32(&ehdri.e_shoff); sz_phdrs = e_phnum * e_phentsize; if (f && Elf32_Ehdr::ET_DYN!=e_type) { unsigned const len = sz_phdrs + e_phoff; alloc_file_image(file_image, len); f->seek(0, SEEK_SET); f->readx(file_image, len); phdri= (Elf32_Phdr       *)(e_phoff + file_image);      } if (f && Elf32_Ehdr::ET_DYN==e_type) { alloc_file_image(file_image, file_size); f->seek(0, SEEK_SET); f->readx(file_image, file_size); phdri= (Elf32_Phdr       *)(e_phoff + file_image);          shdri= (Elf32_Shdr const *)(e_shoff + file_image);          sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM); if (sec_dynsym) sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri; Elf32_Phdr const *phdr= phdri; for (int j = e_phnum; --j>=0; ++phdr) if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf32_Dyn const *)(get_te32(&phdr->p_offset) + file_image); break; } dynstr =      (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB); dynsym = (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB); gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH); hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH); jni_onload_sym = elf_lookup(""JNI_OnLoad""); if (jni_onload_sym) { jni_onload_va = get_te32(&jni_onload_sym->st_value); jni_onload_va = 0; } } }"
"int conn_activate_ssl(int server_role) { gnutls_alert_description_t alrt; char *ssl_keyfile; char *ssl_certfile; int err; if (csync_conn_usessl) return 0; ASPRINTF(&ssl_keyfile, ""%s/csync2_ssl_key.pem"", systemdir); ASPRINTF(&ssl_certfile, ""%s/csync2_ssl_cert.pem"", systemdir); gnutls_global_init(); gnutls_global_set_log_function(ssl_log); gnutls_global_set_log_level(10); gnutls_certificate_allocate_credentials(&conn_x509_cred); err = gnutls_certificate_set_x509_key_file(conn_x509_cred, ssl_certfile, ssl_keyfile, GNUTLS_X509_FMT_PEM); if(err != GNUTLS_E_SUCCESS) { gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: failed to use key file %s and/or certificate file %s: %s (%s)\n"", ssl_keyfile, ssl_certfile, gnutls_strerror(err), gnutls_strerror_name(err) ); } if(server_role) { gnutls_certificate_free_cas(conn_x509_cred); if(gnutls_certificate_set_x509_trust_file(conn_x509_cred, ssl_certfile, GNUTLS_X509_FMT_PEM) < 1) { gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: failed to use certificate file %s as CA.\n"", ssl_certfile ); } } else gnutls_certificate_free_ca_names(conn_x509_cred); gnutls_init(&conn_tls_session, (server_role ? GNUTLS_SERVER : GNUTLS_CLIENT)); gnutls_priority_set_direct(conn_tls_session, ""PERFORMANCE"", NULL); gnutls_credentials_set(conn_tls_session, GNUTLS_CRD_CERTIFICATE, conn_x509_cred); if(server_role) { gnutls_certificate_send_x509_rdn_sequence(conn_tls_session, 0); gnutls_certificate_server_set_request(conn_tls_session, GNUTLS_CERT_REQUIRE); } gnutls_transport_set_ptr2( conn_tls_session, (gnutls_transport_ptr_t)(long)conn_fd_in, (gnutls_transport_ptr_t)(long)conn_fd_out ); err = gnutls_handshake(conn_tls_session); switch(err) { case GNUTLS_E_SUCCESS: break; case GNUTLS_E_WARNING_ALERT_RECEIVED: alrt = gnutls_alert_get(conn_tls_session); fprintf( csync_debug_out, ""SSL: warning alert received from peer: %d (%s).\n"", alrt, gnutls_alert_get_name(alrt) ); break; case GNUTLS_E_FATAL_ALERT_RECEIVED: alrt = gnutls_alert_get(conn_tls_session); fprintf( csync_debug_out, ""SSL: fatal alert received from peer: %d (%s).\n"", alrt, gnutls_alert_get_name(alrt) ); default: gnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR); gnutls_deinit(conn_tls_session); gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: handshake failed: %s (%s)\n"", gnutls_strerror(err), gnutls_strerror_name(err) ); } csync_conn_usessl = 1; return 0; }"
"static void ecma_op_internal_buffer_append (ecma_collection_t *container_p,  ecma_value_t key_arg,  ecma_value_t value_arg,  lit_magic_string_id_t lit_id)  { JERRY_ASSERT (container_p != NULL); ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg)); if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL) { ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg)); } ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1); }"
"bool JpegEncoder::Encode(const struct heif_image_handle* handle, const struct heif_image* image, const std::string& filename) { FILE* fp = fopen(filename.c_str(), ""wb""); if (!fp) { fprintf(stderr, ""Can't open %s: %s\n"", filename.c_str(), strerror(errno)); return false; } struct jpeg_compress_struct cinfo; struct ErrorHandler jerr; cinfo.err = jpeg_std_error(reinterpret_cast<struct jpeg_error_mgr*>(&jerr)); jerr.pub.error_exit = &JpegEncoder::OnJpegError; if (setjmp(jerr.setjmp_buffer)) { cinfo.err->output_message(reinterpret_cast<j_common_ptr>(&cinfo)); jpeg_destroy_compress(&cinfo); fclose(fp); return false; } jpeg_create_compress(&cinfo); jpeg_stdio_dest(&cinfo, fp); cinfo.image_width = heif_image_get_width(image, heif_channel_Y); cinfo.image_height = heif_image_get_height(image, heif_channel_Y); cinfo.input_components = 3; cinfo.in_color_space = JCS_YCbCr; jpeg_set_defaults(&cinfo); static const boolean kForceBaseline = TRUE; jpeg_set_quality(&cinfo, quality_, kForceBaseline); static const boolean kWriteAllTables = TRUE; jpeg_start_compress(&cinfo, kWriteAllTables); size_t exifsize = 0; uint8_t* exifdata = GetExifMetaData(handle, &exifsize); if (exifdata) { if (exifsize > 4) { static const uint8_t kExifMarker = JPEG_APP0 + 1; uint32_t skip = (exifdata[0]<<24) | (exifdata[1]<<16) | (exifdata[2]<<8) | exifdata[3]; skip += 4; uint8_t* ptr = exifdata + skip; size_t size = exifsize - skip; modify_exif_orientation_tag_if_it_exists(ptr, (int)size, 1); if (size>0x1000000) { size = 0x1000000; } std::vector<uint8_t> jpegExifMarkerData(6+size); memcpy(jpegExifMarkerData.data()+6, ptr, size); jpegExifMarkerData[0]='E'; jpegExifMarkerData[1]='x'; jpegExifMarkerData[2]='i'; jpegExifMarkerData[3]='f'; jpegExifMarkerData[4]=0; jpegExifMarkerData[5]=0; ptr = jpegExifMarkerData.data(); size = jpegExifMarkerData.size(); while (size > MAX_BYTES_IN_MARKER) { jpeg_write_marker(&cinfo, kExifMarker, ptr, static_cast<unsigned int>(MAX_BYTES_IN_MARKER)); ptr += MAX_BYTES_IN_MARKER; size -= MAX_BYTES_IN_MARKER; } jpeg_write_marker(&cinfo, kExifMarker, ptr, static_cast<unsigned int>(size)); } free(exifdata); } auto xmp = get_xmp_metadata(handle); if (xmp.size() > 65502) { fprintf(stderr, ""XMP data too large, ExtendedXMP is not supported yet.\n""); } else if (!xmp.empty()) { std::vector<uint8_t> xmpWithId; xmpWithId.resize(xmp.size() + strlen(JPEG_XMP_MARKER_ID)+1); strcpy((char*)xmpWithId.data(), JPEG_XMP_MARKER_ID); memcpy(xmpWithId.data() + strlen(JPEG_XMP_MARKER_ID) + 1, xmp.data(), xmp.size()); jpeg_write_marker(&cinfo, JPEG_XMP_MARKER, xmpWithId.data(), static_cast<unsigned int>(xmpWithId.size())); } size_t profile_size = heif_image_handle_get_raw_color_profile_size(handle); if (profile_size > 0) { uint8_t* profile_data = static_cast<uint8_t*>(malloc(profile_size)); heif_image_handle_get_raw_color_profile(handle, profile_data); jpeg_write_icc_profile(&cinfo, profile_data, (unsigned int) profile_size); free(profile_data); } if (heif_image_get_bits_per_pixel(image, heif_channel_Y) != 8) { fprintf(stderr, ""JPEG writer cannot handle image with >8 bpp.\n""); return false; } int stride_y; const uint8_t* row_y = heif_image_get_plane_readonly(image, heif_channel_Y, &stride_y); int stride_u; const uint8_t* row_u = heif_image_get_plane_readonly(image, heif_channel_Cb, &stride_u); int stride_v; const uint8_t* row_v = heif_image_get_plane_readonly(image, heif_channel_Cr, &stride_v); JSAMPARRAY buffer = cinfo.mem->alloc_sarray( reinterpret_cast<j_common_ptr>(&cinfo), JPOOL_IMAGE, cinfo.image_width * cinfo.input_components, 1); JSAMPROW row[1] = {buffer[0]}; while (cinfo.next_scanline < cinfo.image_height) { size_t offset_y = cinfo.next_scanline * stride_y; const uint8_t* start_y = &row_y[offset_y]; size_t offset_u = (cinfo.next_scanline / 2) * stride_u; const uint8_t* start_u = &row_u[offset_u]; size_t offset_v = (cinfo.next_scanline / 2) * stride_v; const uint8_t* start_v = &row_v[offset_v]; JOCTET* bufp = buffer[0]; for (JDIMENSION x = 0; x < cinfo.image_width; ++x) { *bufp++ = start_y[x]; *bufp++ = start_u[x / 2]; *bufp++ = start_v[x / 2]; } jpeg_write_scanlines(&cinfo, row, 1); } jpeg_finish_compress(&cinfo); fclose(fp); jpeg_destroy_compress(&cinfo); return true; }"
"long join_session_keyring(const char *name) { const struct cred *old; struct cred *new; struct key *keyring; long ret, serial; new = prepare_creds(); if (!new) return -ENOMEM; old = current_cred(); if (!name) { ret = install_session_keyring_to_cred(new, NULL); if (ret < 0) goto error; serial = new->session_keyring->serial; ret = commit_creds(new); if (ret == 0) ret = serial; goto okay; } mutex_lock(&key_session_mutex); keyring = find_keyring_by_name(name, false); if (PTR_ERR(keyring) == -ENOKEY) { keyring = keyring_alloc( name, old->uid, old->gid, old, KEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK, KEY_ALLOC_IN_QUOTA, NULL); if (IS_ERR(keyring)) { ret = PTR_ERR(keyring); goto error2; } } else if (IS_ERR(keyring)) { ret = PTR_ERR(keyring); goto error2; } else if (keyring == new->session_keyring) { ret = 0; goto error2; } ret = install_session_keyring_to_cred(new, keyring); if (ret < 0) goto error2; commit_creds(new); mutex_unlock(&key_session_mutex); ret = keyring->serial; key_put(keyring); okay: return ret; error2: mutex_unlock(&key_session_mutex); error: abort_creds(new); return ret; }"
"static rfbBool HandleUltraZipBPP (rfbClient* client, int rx, int ry, int rw, int rh) { rfbZlibHeader hdr; int i=0; int toRead=0; int inflateResult=0; unsigned char *ptr=NULL; lzo_uint uncompressedBytes = ry + (rw * 65535); unsigned int numCacheRects = rx; if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader)) return FALSE; toRead = rfbClientSwap32IfLE(hdr.nBytes); if (toRead==0) return TRUE; if (uncompressedBytes==0) { rfbClientLog(""ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\n"", ry, rw, rx);  return FALSE; } if ( client->raw_buffer_size < (int)(uncompressedBytes + 500)) { if ( client->raw_buffer != NULL ) { free( client->raw_buffer ); } client->raw_buffer_size = uncompressedBytes + 500; if ((client->raw_buffer_size % 4)!=0) client->raw_buffer_size += (4-(client->raw_buffer_size % 4)); client->raw_buffer = (char*) malloc( client->raw_buffer_size ); } if ( client->ultra_buffer_size < toRead ) { if ( client->ultra_buffer != NULL ) { free( client->ultra_buffer ); } client->ultra_buffer_size = toRead; client->ultra_buffer = (char*) malloc( client->ultra_buffer_size ); } if (!ReadFromRFBServer(client, client->ultra_buffer, toRead)) return FALSE; uncompressedBytes = client->raw_buffer_size; inflateResult = lzo1x_decompress( (lzo_byte *)client->ultra_buffer, toRead, (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL); if ( inflateResult != LZO_E_OK )  { rfbClientLog(""ultra decompress returned error: %d\n"", inflateResult); return FALSE; } ptr = (unsigned char *)client->raw_buffer; for (i=0; i<numCacheRects; i++) { unsigned short sx, sy, sw, sh; unsigned int se; memcpy((char *)&sx, ptr, 2); ptr += 2; memcpy((char *)&sy, ptr, 2); ptr += 2; memcpy((char *)&sw, ptr, 2); ptr += 2; memcpy((char *)&sh, ptr, 2); ptr += 2; memcpy((char *)&se, ptr, 4); ptr += 4; sx = rfbClientSwap16IfLE(sx); sy = rfbClientSwap16IfLE(sy); sw = rfbClientSwap16IfLE(sw); sh = rfbClientSwap16IfLE(sh); se = rfbClientSwap32IfLE(se); if (se == rfbEncodingRaw) { CopyRectangle(client, (unsigned char *)ptr, sx, sy, sw, sh); ptr += ((sw * sh) * (BPP / 8)); } }   return TRUE; }"
"static void fuse_free_conn(struct fuse_conn *fc) { kfree_rcu(fc, rcu); }"
"Jsi_RC Jsi_FunctionInvoke(Jsi_Interp *interp, Jsi_Value *func, Jsi_Value *args, Jsi_Value **ret, Jsi_Value *_this) { Jsi_Func *fstatic = func->d.obj->d.fobj->func; jsi_OpCode *oldops = interp->curIp; if (fstatic->opcodes) interp->curIp = fstatic->opcodes->codes; Jsi_RC rc = jsi_FunctionInvoke(interp, func, args, ret, _this); interp->curIp = oldops; if (Jsi_InterpGone(interp)) return JSI_ERROR; return rc; }"
"static void __vmx_load_host_state(struct vcpu_vmx *vmx) { unsigned long flags; if (!vmx->host_state.loaded) return; ++vmx->vcpu.stat.host_state_reload; vmx->host_state.loaded = 0; if (vmx->host_state.fs_reload_needed) kvm_load_fs(vmx->host_state.fs_sel); if (vmx->host_state.gs_ldt_reload_needed) { kvm_load_ldt(vmx->host_state.ldt_sel); local_irq_save(flags); kvm_load_gs(vmx->host_state.gs_sel); #ifdef CONFIG_X86_64 wrmsrl(MSR_GS_BASE, vmcs_readl(HOST_GS_BASE)); #endif local_irq_restore(flags); } reload_tss(); #ifdef CONFIG_X86_64 if (is_long_mode(&vmx->vcpu)) { rdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base); wrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base); } #endif if (current_thread_info()->status & TS_USEDFPU) clts(); }"
"void MultiPartOutputFile::Data::do_header_sanity_checks(bool overrideSharedAttributes) { size_t parts = _headers.size(); if (parts == 0)  throw IEX_NAMESPACE::ArgExc (""Empty header list.""); bool isMultiPart = (parts > 1);  _headers[0].sanityCheck (_headers[0].hasTileDescription(), isMultiPart); if (isMultiPart) { _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true)); for (size_t i = 1; i < parts; i++) { if (_headers[i].hasType() == false) throw IEX_NAMESPACE::ArgExc (""Every header in a multipart file should have a type""); _headers[i].setChunkCount(getChunkOffsetTableSize(_headers[i],true)); _headers[i].sanityCheck (_headers[i].hasTileDescription(), isMultiPart); if (overrideSharedAttributes) overrideSharedAttributesValues(_headers[0],_headers[i]); else { std::vector<std::string> conflictingAttributes; bool valid =checkSharedAttributesValues (_headers[0], _headers[i],  conflictingAttributes); if (valid) { string excMsg(""Conflicting attributes found for header :: ""); excMsg += _headers[i].name(); for (size_t i=0; i<conflictingAttributes.size(); i++) excMsg += "" '"" + conflictingAttributes[i] + ""' ""; THROW (IEX_NAMESPACE::ArgExc, excMsg); } } } headerNameUniquenessCheck(_headers); }else{ if (_headers[0].hasType() && isImage(_headers[0].type()) == false) { _headers[0].setChunkCount(getChunkOffsetTableSize(_headers[0],true)); } } }"
"CConnection::CConnection() : csecurity(0), is(0), os(0), reader_(0), writer_(0), shared(false), state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false), framebuffer(NULL), decoder(this) { security = new SecurityClient(); }"
"static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { const char *option, *property; int jp2_status; MagickBooleanType status; opj_codec_t *jp2_codec; OPJ_COLOR_SPACE jp2_colorspace; opj_cparameters_t parameters; opj_image_cmptparm_t jp2_info[5]; opj_image_t *jp2_image; opj_stream_t *jp2_stream; register ssize_t i; ssize_t y; unsigned int channels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); opj_set_default_encoder_parameters(&parameters); for (i=1; i < 6; i++) if (((size_t) (1UL << (i+2)) > image->columns) && ((size_t) (1UL << (i+2)) > image->rows)) break; parameters.numresolution=i; option=GetImageOption(image_info,""jp2:number-resolutions""); if (option != (const char *) NULL) parameters.numresolution=StringToInteger(option); parameters.tcp_numlayers=1; parameters.tcp_rates[0]=0;   parameters.cp_disto_alloc=1; if ((image_info->quality != 0) && (image_info->quality != 100)) { parameters.tcp_distoratio[0]=(double) image_info->quality; parameters.cp_fixed_quality=OPJ_TRUE; } if (image_info->extract != (char *) NULL) { RectangleInfo geometry; int flags; flags=ParseAbsoluteGeometry(image_info->extract,&geometry); parameters.cp_tdx=(int) geometry.width; parameters.cp_tdy=(int) geometry.width; if ((flags & HeightValue) != 0) parameters.cp_tdy=(int) geometry.height; if ((flags & XValue) != 0) parameters.cp_tx0=geometry.x; if ((flags & YValue) != 0) parameters.cp_ty0=geometry.y; parameters.tile_size_on=OPJ_TRUE; } option=GetImageOption(image_info,""jp2:quality""); if (option != (const char *) NULL) { register const char *p; p=option; for (i=0; sscanf(p,""%f"",&parameters.tcp_distoratio[i]) == 1; i++) { if (i > 100) break; while ((*p != '\0') && (*p != ',')) p++; if (*p == '\0') break; p++; } parameters.tcp_numlayers=i+1; parameters.cp_fixed_quality=OPJ_TRUE; } option=GetImageOption(image_info,""jp2:progression-order""); if (option != (const char *) NULL) { if (LocaleCompare(option,""LRCP"") == 0) parameters.prog_order=OPJ_LRCP; if (LocaleCompare(option,""RLCP"") == 0) parameters.prog_order=OPJ_RLCP; if (LocaleCompare(option,""RPCL"") == 0) parameters.prog_order=OPJ_RPCL; if (LocaleCompare(option,""PCRL"") == 0) parameters.prog_order=OPJ_PCRL; if (LocaleCompare(option,""CPRL"") == 0) parameters.prog_order=OPJ_CPRL; } option=GetImageOption(image_info,""jp2:rate""); if (option != (const char *) NULL) { register const char *p; p=option; for (i=0; sscanf(p,""%f"",&parameters.tcp_rates[i]) == 1; i++) { if (i >= 100) break; while ((*p != '\0') && (*p != ',')) p++; if (*p == '\0') break; p++; } parameters.tcp_numlayers=i+1; parameters.cp_disto_alloc=OPJ_TRUE; } if (image_info->sampling_factor != (const char *) NULL) (void) sscanf(image_info->sampling_factor,""%d,%d"", &parameters.subsampling_dx,&parameters.subsampling_dy); property=GetImageProperty(image,""comment"",exception); if (property != (const char *) NULL) parameters.cp_comment=ConstantString(property); channels=3; jp2_colorspace=OPJ_CLRSPC_SRGB; if (image->colorspace == YUVColorspace) { jp2_colorspace=OPJ_CLRSPC_SYCC; parameters.subsampling_dx=2; } else { if (IsGrayColorspace(image->colorspace) != MagickFalse) { channels=1; jp2_colorspace=OPJ_CLRSPC_GRAY; } else (void) TransformImageColorspace(image,sRGBColorspace,exception); if (image->alpha_trait != UndefinedPixelTrait) channels++; } parameters.tcp_mct=channels == 3 ? 1 : 0; ResetMagickMemory(jp2_info,0,sizeof(jp2_info)); for (i=0; i < (ssize_t) channels; i++) { jp2_info[i].prec=(OPJ_UINT32) image->depth; jp2_info[i].bpp=(OPJ_UINT32) image->depth; if ((image->depth == 1) && ((LocaleCompare(image_info->magick,""JPT"") == 0) || (LocaleCompare(image_info->magick,""JP2"") == 0))) { jp2_info[i].prec++;   jp2_info[i].bpp++; } jp2_info[i].sgnd=0; jp2_info[i].dx=parameters.subsampling_dx; jp2_info[i].dy=parameters.subsampling_dy; jp2_info[i].w=(OPJ_UINT32) image->columns; jp2_info[i].h=(OPJ_UINT32) image->rows; } jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace); if (jp2_image == (opj_image_t *) NULL) ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); jp2_image->x0=parameters.image_offset_x0; jp2_image->y0=parameters.image_offset_y0; jp2_image->x1=(unsigned int) (2*parameters.image_offset_x0+(image->columns-1)* parameters.subsampling_dx+1); jp2_image->y1=(unsigned int) (2*parameters.image_offset_y0+(image->rows-1)* parameters.subsampling_dx+1); if ((image->depth == 12) && ((image->columns == 2048) || (image->rows == 1080) || (image->columns == 4096) || (image->rows == 2160))) CinemaProfileCompliance(jp2_image,&parameters); if (channels == 4) jp2_image->comps[3].alpha=1; else if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY)) jp2_image->comps[1].alpha=1; for (y=0; y < (ssize_t) image->rows; y++) { register const Quantum *p; ssize_t x; p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { for (i=0; i < (ssize_t) channels; i++) { double scale; register int *q; scale=(double) ((1UL << jp2_image->comps[i].prec)-1)/QuantumRange; q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy* image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx); switch (i) { case 0: { if (jp2_colorspace == OPJ_CLRSPC_GRAY) { *q=(int) (scale*GetPixelLuma(image,p)); break; } *q=(int) (scale*GetPixelRed(image,p)); break; } case 1: { if (jp2_colorspace == OPJ_CLRSPC_GRAY) { *q=(int) (scale*GetPixelAlpha(image,p)); break; } *q=(int) (scale*GetPixelGreen(image,p)); break; } case 2: { *q=(int) (scale*GetPixelBlue(image,p)); break; } case 3: { *q=(int) (scale*GetPixelAlpha(image,p)); break; } } } p+=GetPixelChannels(image); } status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } if (LocaleCompare(image_info->magick,""JPT"") == 0) jp2_codec=opj_create_compress(OPJ_CODEC_JPT); else if (LocaleCompare(image_info->magick,""J2K"") == 0) jp2_codec=opj_create_compress(OPJ_CODEC_J2K); else jp2_codec=opj_create_compress(OPJ_CODEC_JP2); opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception); opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception); opj_setup_encoder(jp2_codec,&parameters,jp2_image); jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE); opj_stream_set_read_function(jp2_stream,JP2ReadHandler); opj_stream_set_write_function(jp2_stream,JP2WriteHandler); opj_stream_set_seek_function(jp2_stream,JP2SeekHandler); opj_stream_set_skip_function(jp2_stream,JP2SkipHandler); opj_stream_set_user_data(jp2_stream,image,NULL); if (jp2_stream == (opj_stream_t *) NULL) ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream); if (jp2_status == 0) ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); if ((opj_encode(jp2_codec,jp2_stream) == 0) || (opj_end_compress(jp2_codec,jp2_stream) == 0)) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); } opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); (void) CloseBlob(image); return(MagickTrue); }"
"GF_EXPORT GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; if (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) { u32 ref_track; GF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track); if (e == GF_OK) { trackNumber = ref_track; } } trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->hevc_config) return NULL; return HEVC_DuplicateConfig(entry->hevc_config->config); }"
"inline bool operator ==(const MaskedIP& l, const MaskedIP& r) { auto shift = std::max((l.v6 ? 128 : 32) - l.prefix, (r.v6 ? 128 : 32) - r.prefix); ceph_assert(shift > 0); return (l.addr >> shift) == (r.addr >> shift); }"
"static int vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev, struct vhu_msg_context *ctx) { uint32_t vring_idx; switch (ctx->msg.request.master) { case VHOST_USER_SET_VRING_KICK: case VHOST_USER_SET_VRING_CALL: case VHOST_USER_SET_VRING_ERR: vring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK; break; case VHOST_USER_SET_VRING_NUM: case VHOST_USER_SET_VRING_BASE: case VHOST_USER_GET_VRING_BASE: case VHOST_USER_SET_VRING_ENABLE: vring_idx = ctx->msg.payload.state.index; break; case VHOST_USER_SET_VRING_ADDR: vring_idx = ctx->msg.payload.addr.index; break; default: return 0; } if (vring_idx >= VHOST_MAX_VRING) { VHOST_LOG_CONFIG(ERR, ""(%s) invalid vring index: %u\n"", dev->ifname, vring_idx); return -1; } if (dev->virtqueue[vring_idx]) return 0; return alloc_vring_queue(dev, vring_idx); }"
"static boolean parse_instruction( struct translate_ctx *ctx, boolean has_label ) { uint i; uint saturate = 0; const struct tgsi_opcode_info *info; struct tgsi_full_instruction inst; const char *cur; uint advance; inst = tgsi_default_full_instruction(); eat_opt_white( &ctx->cur ); if (*ctx->cur == '(') { uint file; int index; uint swizzle[4]; boolean parsed_swizzle; inst.Instruction.Predicate = 1; ctx->cur++; if (*ctx->cur == '!') { ctx->cur++; inst.Predicate.Negate = 1; } if (!parse_register_1d( ctx, &file, &index )) return FALSE; if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) { if (parsed_swizzle) { inst.Predicate.SwizzleX = swizzle[0]; inst.Predicate.SwizzleY = swizzle[1]; inst.Predicate.SwizzleZ = swizzle[2]; inst.Predicate.SwizzleW = swizzle[3]; } } if (*ctx->cur != ')') { report_error( ctx, ""Expected `)'"" ); return FALSE; } ctx->cur++; } eat_opt_white( &ctx->cur ); for (i = 0; i < TGSI_OPCODE_LAST; i++) { cur = ctx->cur; info = tgsi_get_opcode_info( i ); if (match_inst(&cur, &saturate, info)) { if (info->num_dst + info->num_src + info->is_tex == 0) { ctx->cur = cur; break; } else if (*cur == '\0' || eat_white( &cur )) { ctx->cur = cur; break; } } } if (i == TGSI_OPCODE_LAST) { if (has_label) report_error( ctx, ""Unknown opcode"" ); else report_error( ctx, ""Expected `DCL', `IMM' or a label"" ); return FALSE; } inst.Instruction.Opcode = i; inst.Instruction.Saturate = saturate; inst.Instruction.NumDstRegs = info->num_dst; inst.Instruction.NumSrcRegs = info->num_src; if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) { inst.Instruction.Texture = 1; inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN; } for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) { if (i > 0) { eat_opt_white( &ctx->cur ); if (*ctx->cur != ',') { report_error( ctx, ""Expected `,'"" ); return FALSE; } ctx->cur++; eat_opt_white( &ctx->cur ); } if (i < info->num_dst) { if (!parse_dst_operand( ctx, &inst.Dst[i] )) return FALSE; } else if (i < info->num_dst + info->num_src) { if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] )) return FALSE; } else { uint j; for (j = 0; j < TGSI_TEXTURE_COUNT; j++) { if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) { inst.Instruction.Texture = 1; inst.Texture.Texture = j; break; } } if (j == TGSI_TEXTURE_COUNT) { report_error( ctx, ""Expected texture target"" ); return FALSE; } } } cur = ctx->cur; eat_opt_white( &cur ); for (i = 0; inst.Instruction.Texture && *cur == ','; i++) { cur++; eat_opt_white( &cur ); ctx->cur = cur; if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] )) return FALSE; cur = ctx->cur; eat_opt_white( &cur ); } inst.Texture.NumOffsets = i; cur = ctx->cur; eat_opt_white( &cur ); if (info->is_branch && *cur == ':') { uint target; cur++; eat_opt_white( &cur ); if (!parse_uint( &cur, &target )) { report_error( ctx, ""Expected a label"" ); return FALSE; } inst.Instruction.Label = 1; inst.Label.Label = target; ctx->cur = cur; } advance = tgsi_build_full_instruction( &inst, ctx->tokens_cur, ctx->header, (uint) (ctx->tokens_end - ctx->tokens_cur) ); if (advance == 0) return FALSE; ctx->tokens_cur += advance; return TRUE; }"
"static int dissect_kafka_string_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_string_offset, int *p_string_length) { gint64 val; guint len; proto_item *pi; len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG); if (len == 0) { pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_varint); len = 5; val = 0; } else if (val > 0) { proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_UTF_8); } else if (val == 0) { proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<EMPTY>""); } else if (val == -1) { proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<NULL>""); val = 0; } else { pi = proto_tree_add_string_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_string_length); val = 0; } if (p_string_offset != NULL) { *p_string_offset = offset+len; } if (p_string_length != NULL) { *p_string_length = (gint)val; } return offset+len+(gint)val; }"
"void bm_set_font(Bitmap *b, BmFont *font) { b->font = font; }"
"bfd_boolean _bfd_coff_get_external_symbols (bfd *abfd) { bfd_size_type symesz; bfd_size_type size; void * syms; if (obj_coff_external_syms (abfd) != NULL) return TRUE; symesz = bfd_coff_symesz (abfd); size = obj_raw_syment_count (abfd) * symesz; if (size == 0) return TRUE; syms = bfd_malloc (size); if (syms == NULL) { _bfd_error_handler (_(""%B: Not enough memory to allocate space for %Lu symbols""), abfd, size); return FALSE; } if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0 || bfd_bread (syms, size, abfd) != size) { if (syms != NULL) free (syms); return FALSE; } obj_coff_external_syms (abfd) = syms; return TRUE; }"
"static int arc_emac_tx(struct sk_buff *skb, struct net_device *ndev) { struct arc_emac_priv *priv = netdev_priv(ndev); unsigned int len, *txbd_curr = &priv->txbd_curr; struct net_device_stats *stats = &ndev->stats; __le32 *info = &priv->txbd[*txbd_curr].info; dma_addr_t addr; if (skb_padto(skb, ETH_ZLEN)) return NETDEV_TX_OK; len = max_t(unsigned int, ETH_ZLEN, skb->len); if (unlikely(!arc_emac_tx_avail(priv))) { netif_stop_queue(ndev); netdev_err(ndev, ""BUG! Tx Ring full when queue awake!\n""); return NETDEV_TX_BUSY; } addr = dma_map_single(&ndev->dev, (void *)skb->data, len, DMA_TO_DEVICE); if (unlikely(dma_mapping_error(&ndev->dev, addr))) { stats->tx_dropped++; stats->tx_errors++; dev_kfree_skb(skb); return NETDEV_TX_OK; } dma_unmap_addr_set(&priv->tx_buff[*txbd_curr], addr, addr); dma_unmap_len_set(&priv->tx_buff[*txbd_curr], len, len); priv->tx_buff[*txbd_curr].skb = skb; priv->txbd[*txbd_curr].data = cpu_to_le32(addr); wmb(); skb_tx_timestamp(skb); *info = cpu_to_le32(FOR_EMAC | FIRST_OR_LAST_MASK | len); *txbd_curr = (*txbd_curr + 1) % TX_BD_NUM; smp_mb(); if (!arc_emac_tx_avail(priv)) { netif_stop_queue(ndev); smp_mb(); if (arc_emac_tx_avail(priv)) netif_start_queue(ndev); } arc_reg_set(priv, R_STATUS, TXPL_MASK); return NETDEV_TX_OK; }"
"vector<DNSResourceRecord> doAxfr(const ComboAddress& raddr, const DNSName& domain, const TSIGTriplet& tt, const ComboAddress& laddr,  scoped_ptr<AuthLua>& pdl, ZoneStatus& zs) { vector<DNSResourceRecord> rrs; AXFRRetriever retriever(raddr, domain, tt, (laddr.sin4.sin_family == 0) ? NULL : &laddr); Resolver::res_t recs; bool first=true; bool firstNSEC3{true}; bool soa_received {false}; while(retriever.getChunk(recs)) { if(first) { L<<Logger::Error<<""AXFR started for '""<<domain<<""'""<<endl; first=false; } for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) { if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG)         continue; if(!i->qname.isPartOf(domain)) { L<<Logger::Error<<""Remote ""<<raddr.toStringWithPort()<<"" tried to sneak in out-of-zone data '""<<i->qname<<""'|""<<i->qtype.getName()<<"" during AXFR of zone '""<<domain<<""', ignoring""<<endl; continue; } vector<DNSResourceRecord> out; if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) { out.push_back(*i);       } for(DNSResourceRecord& rr :  out) { if(!processRecordForZS(domain, firstNSEC3, rr, zs)) continue; if(rr.qtype.getCode() == QType::SOA) { if(soa_received) continue;           SOAData sd; fillSOAData(rr.content,sd); zs.soa_serial = sd.serial; soa_received = true; } rrs.push_back(rr); } } } return rrs; }"
"void snd_msndmidi_input_read(void *mpuv) { unsigned long flags; struct snd_msndmidi *mpu = mpuv; void *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF; spin_lock_irqsave(&mpu->input_lock, flags); while (readw(mpu->dev->MIDQ + JQS_wTail) != readw(mpu->dev->MIDQ + JQS_wHead)) { u16 wTmp, val; val = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead)); if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) snd_rawmidi_receive(mpu->substream_input, (unsigned char *)&val, 1); wTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1; if (wTmp > readw(mpu->dev->MIDQ + JQS_wSize)) writew(0,  mpu->dev->MIDQ + JQS_wHead); else writew(wTmp,  mpu->dev->MIDQ + JQS_wHead); } spin_unlock_irqrestore(&mpu->input_lock, flags); }"
"int table_regex_match(const char *string, const char *pattern) { regex_t preg; intcflags = REG_EXTENDED|REG_NOSUB; if (strncmp(pattern, ""(?i)"", 4) == 0) { cflags |= REG_ICASE; pattern += 4; } if (regcomp(&preg, pattern, cflags) != 0) return (0); if (regexec(&preg, string, 0, NULL, 0) != 0) return (0); return (1); }"
"int dwarf_getaranges (Dwarf *dbg, Dwarf_Aranges **aranges, size_t *naranges) { if (dbg == NULL) return -1; if (dbg->aranges != NULL) { *aranges = dbg->aranges; if (naranges != NULL) *naranges = dbg->aranges->naranges; return 0; } if (dbg->sectiondata[IDX_debug_aranges] == NULL) { *aranges = NULL; if (naranges != NULL) *naranges = 0; return 0; } if (dbg->sectiondata[IDX_debug_aranges]->d_buf == NULL) return -1; struct arangelist *arangelist = NULL; unsigned int narangelist = 0; const unsigned char *readp = dbg->sectiondata[IDX_debug_aranges]->d_buf; const unsigned char *readendp = readp + dbg->sectiondata[IDX_debug_aranges]->d_size; while (readp < readendp) { const unsigned char *hdrstart = readp; if (unlikely (readp + 4 > readendp)) goto invalid; Dwarf_Word length = read_4ubyte_unaligned_inc (dbg, readp); unsigned int length_bytes = 4; if (length == DWARF3_LENGTH_64_BIT) { if (unlikely (readp + 8 > readendp)) goto invalid; length = read_8ubyte_unaligned_inc (dbg, readp); length_bytes = 8; } else if (unlikely (length >= DWARF3_LENGTH_MIN_ESCAPE_CODE && length <= DWARF3_LENGTH_MAX_ESCAPE_CODE)) goto invalid; if (unlikely (readp + 2 > readendp)) goto invalid; unsigned int version = read_2ubyte_unaligned_inc (dbg, readp); if (version != 2) { invalid: __libdw_seterrno (DWARF_E_INVALID_DWARF); fail: while (arangelist != NULL) { struct arangelist *next = arangelist->next; free (arangelist); arangelist = next; } return -1; } Dwarf_Word offset = 0; if (__libdw_read_offset_inc (dbg, IDX_debug_aranges, &readp, length_bytes, &offset, IDX_debug_info, 4)) goto fail; unsigned int address_size = *readp++; if (unlikely (address_size != 4 && address_size != 8)) goto invalid; unsigned int segment_size = *readp++; if (segment_size != 0) goto invalid; readp += ((2 * address_size - ((readp - hdrstart) % (2 * address_size))) % (2 * address_size)); while (1) { Dwarf_Word range_address; Dwarf_Word range_length; if (__libdw_read_address_inc (dbg, IDX_debug_aranges, &readp, address_size, &range_address)) goto fail; if (readp + address_size > readendp) goto invalid; if (address_size == 4) range_length = read_4ubyte_unaligned_inc (dbg, readp); else range_length = read_8ubyte_unaligned_inc (dbg, readp); if (range_address == 0 && range_length == 0) break; struct arangelist *new_arange = malloc (sizeof *new_arange); if (unlikely (new_arange == NULL)) { __libdw_seterrno (DWARF_E_NOMEM); goto fail; } new_arange->arange.addr = range_address; new_arange->arange.length = range_length; Dwarf_CU *cu = __libdw_findcu (dbg, offset, false); if (unlikely (cu == NULL)) { free (new_arange); goto fail; } new_arange->arange.offset = __libdw_first_die_off_from_cu (cu); new_arange->next = arangelist; arangelist = new_arange; ++narangelist; if (unlikely (new_arange->arange.offset >= dbg->sectiondata[IDX_debug_info]->d_size)) goto invalid; } } if (narangelist == 0) { assert (arangelist == NULL); if (naranges != NULL) *naranges = 0; *aranges = NULL; return 0; } void *buf = libdw_alloc (dbg, Dwarf_Aranges, sizeof (Dwarf_Aranges) + narangelist * sizeof (Dwarf_Arange), 1); assert (sizeof (Dwarf_Arange) >= sizeof (Dwarf_Arange *)); struct arangelist **sortaranges = (buf + sizeof (Dwarf_Aranges) + ((sizeof (Dwarf_Arange) - sizeof sortaranges[0]) * narangelist)); unsigned int i = narangelist; while (i-- > 0) { sortaranges[i] = arangelist; arangelist = arangelist->next; } assert (arangelist == NULL); qsort (sortaranges, narangelist, sizeof sortaranges[0], &compare_aranges); *aranges = buf; (*aranges)->dbg = dbg; (*aranges)->naranges = narangelist; dbg->aranges = *aranges; if (naranges != NULL) *naranges = narangelist; for (i = 0; i < narangelist; ++i) { struct arangelist *elt = sortaranges[i]; (*aranges)->info[i] = elt->arange; free (elt); } return 0; }"
"static int sudoers_lookup_check(struct sudo_nss *nss, struct sudoers_context *ctx, unsigned int *validated, struct cmnd_info *info, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, struct cmndspec **matching_cs, struct defaults_list **defs) { struct cmndspec *cs; struct privilege *priv; struct userspec *us; struct member *matching_user; debug_decl(sudoers_lookup_check, SUDOERS_DEBUG_PARSER); init_cmnd_info(ctx, info); TAILQ_FOREACH_REVERSE(us, &nss->parse_tree->userspecs, userspec_list, entries) { int user_match = userlist_matches(nss->parse_tree, ctx->user.pw, &us->users); if (user_match != ALLOW) { if (callback != NULL && user_match != UNSPEC) { callback(nss->parse_tree, us, user_match, NULL, UNSPEC, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data); } continue; } CLR(*validated, FLAG_NO_USER); TAILQ_FOREACH_REVERSE(priv, &us->privileges, privilege_list, entries) { int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw, &priv->hostlist); if (host_match == ALLOW) { CLR(*validated, FLAG_NO_HOST); } else { if (callback != NULL) { callback(nss->parse_tree, us, user_match, priv, host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data); } continue; } TAILQ_FOREACH_REVERSE(cs, &priv->cmndlist, cmndspec_list, entries) { int cmnd_match = UNSPEC; int date_match = UNSPEC; int runas_match = UNSPEC; if (cs->notbefore != UNSPEC) { date_match = now < cs->notbefore ? DENY : ALLOW; } if (cs->notafter != UNSPEC) { date_match = now > cs->notafter ? DENY : ALLOW; } if (date_match != DENY) { matching_user = NULL; runas_match = runaslist_matches(nss->parse_tree, cs->runasuserlist, cs->runasgrouplist, &matching_user, NULL); if (runas_match == ALLOW) { cmnd_match = cmnd_matches(nss->parse_tree, cs->cmnd, cs->runchroot, info); } } if (callback != NULL) { callback(nss->parse_tree, us, user_match, priv, host_match, cs, date_match, runas_match, cmnd_match, cb_data); } if (cmnd_match != UNSPEC) { if (matching_user && matching_user->type == MYSELF) { sudo_pw_delref(ctx->runas.pw); sudo_pw_addref(ctx->user.pw); ctx->runas.pw = ctx->user.pw; } *matching_cs = cs; *defs = &priv->defaults; sudo_debug_printf(SUDO_DEBUG_DEBUG|SUDO_DEBUG_LINENO, ""userspec matched @ %s:%d:%d: %s"", us->file ? us->file : ""???"", us->line, us->column, cmnd_match ? ""allowed"" : ""denied""); debug_return_int(cmnd_match); } free(info->cmnd_path); init_cmnd_info(ctx, info); } } } debug_return_int(UNSPEC); }"
"WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst) { OSSL_STATEM *st = &s->statem; switch (st->hand_state) { case TLS_ST_SW_HELLO_REQ: s->shutdown = 0; if (SSL_IS_DTLS(s)) dtls1_clear_record_buffer(s); break; case DTLS_ST_SW_HELLO_VERIFY_REQUEST: s->shutdown = 0; if (SSL_IS_DTLS(s)) { dtls1_clear_record_buffer(s); st->use_timer = 0; } break; case TLS_ST_SW_SRVR_HELLO: if (SSL_IS_DTLS(s)) { st->use_timer = 1; } break; case TLS_ST_SW_SRVR_DONE: #ifndef OPENSSL_NO_SCTP if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) return dtls_wait_for_dry(s); #endif return WORK_FINISHED_CONTINUE; case TLS_ST_SW_SESSION_TICKET: if (SSL_IS_DTLS(s)) { st->use_timer = 0; } break; case TLS_ST_SW_CHANGE: s->session->cipher = s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ossl_statem_set_error(s); return WORK_ERROR; } if (SSL_IS_DTLS(s)) { st->use_timer = 0; } return WORK_FINISHED_CONTINUE; case TLS_ST_OK: return tls_finish_handshake(s, wst); default: break; } return WORK_FINISHED_CONTINUE; }"
"int DCTStream::getChars(int nChars, unsigned char *buffer) { for (int i = 0; i < nChars;) { if (current == limit) { if (!readLine()) return i; } int left = limit - current; if (nChars < left) left = nChars; memcpy(buffer + i, current, left); current += left; i += left; } return nChars; }"
"static char * expand_dynamic_string_token (struct link_map *l, const char *s) { size_t cnt; size_t total; char *result; cnt = DL_DST_COUNT (s, 1); if (cnt == 0) return local_strdup (s); total = DL_DST_REQUIRED (l, s, strlen (s), cnt); result = (char *) malloc (total + 1); if (result == NULL) return NULL; return DL_DST_SUBSTITUTE (l, s, result, 1); }"
"static dict *dictCreate(dictType *type, void *privDataPtr) { dict *ht = malloc(sizeof(*ht)); _dictInit(ht,type,privDataPtr); return ht; }"
"static void io_msg_tw_complete(struct callback_head *head) { struct io_msg *msg = container_of(head, struct io_msg, tw); struct io_kiocb *req = cmd_to_io_kiocb(msg); struct io_ring_ctx *target_ctx = req->file->private_data; int ret = 0; if (current->flags & PF_EXITING) ret = -EOWNERDEAD; else if (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0)) ret = -EOVERFLOW; if (ret < 0) req_set_fail(req); io_req_queue_tw_complete(req, ret); }"
"static fp_info * fp_set_per_packet_inf_from_conv(umts_fp_conversation_info_t *p_conv_data, tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree _U_) { fp_info  *fpi; guint8    tfi, c_t; int       offset = 0, i=0, j=0, num_tbs, chan, tb_size, tb_bit_off; gboolean  is_control_frame; umts_mac_info *macinf; rlc_info *rlcinf; guint8 fake_lchid=0; gint *cur_val=NULL; fpi = wmem_new0(wmem_file_scope(), fp_info); p_add_proto_data(wmem_file_scope(), pinfo, proto_fp, 0, fpi); fpi->iface_type = p_conv_data->iface_type; fpi->division = p_conv_data->division; fpi->release = 7;                fpi->release_year = 2006; fpi->release_month = 12; fpi->channel = p_conv_data->channel; fpi->dch_crc_present = p_conv_data->dch_crc_present; fpi->link_type = FP_Link_Ethernet; #if 0 if (!pinfo->fd->flags.visited &&  p_conv_data->reset_frag ) { fpi->reset_frag = p_conv_data->reset_frag; p_conv_data->reset_frag = FALSE; } #endif fpi->srcport = pinfo->srcport; fpi->destport = pinfo->destport; fpi->com_context_id = p_conv_data->com_context_id; if (pinfo->link_dir == P2P_DIR_UL) { fpi->is_uplink = TRUE; } else { fpi->is_uplink = FALSE; } is_control_frame = tvb_get_guint8(tvb, offset) & 0x01; switch (fpi->channel) { case CHANNEL_HSDSCH:  fpi->hsdsch_entity = p_conv_data->hsdsch_entity; macinf = wmem_new0(wmem_file_scope(), umts_mac_info); fpi->hsdsch_macflowd_id = p_conv_data->hsdsch_macdflow_id; macinf->content[0] = hsdsch_macdflow_id_mac_content_map[p_conv_data->hsdsch_macdflow_id];  macinf->lchid[0] = p_conv_data->hsdsch_macdflow_id; p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); rlcinf = wmem_new0(wmem_file_scope(), rlc_info); rlcinf->mode[0] = hsdsch_macdflow_id_rlc_map[p_conv_data->hsdsch_macdflow_id]; if (fpi->hsdsch_entity == hs ) { for (i=0; i<MAX_NUM_HSDHSCH_MACDFLOW; i++) { if ((cur_val=(gint *)g_tree_lookup(hsdsch_muxed_flows, GINT_TO_POINTER((gint)p_conv_data->hrnti))) != NULL) { j = 1 << i; fpi->hsdhsch_macfdlow_is_mux[i] = j & *cur_val; } else { fpi->hsdhsch_macfdlow_is_mux[i] = FALSE; } } } rlcinf->urnti[0] = fpi->com_context_id; rlcinf->li_size[0] = RLC_LI_7BITS; rlcinf->ciphered[0] = FALSE; rlcinf->deciphered[0] = FALSE; p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); return fpi; case CHANNEL_EDCH: macinf = wmem_new0(wmem_file_scope(), umts_mac_info); rlcinf = wmem_new0(wmem_file_scope(), rlc_info); fpi->no_ddi_entries = p_conv_data->no_ddi_entries; for (i=0; i<fpi->no_ddi_entries; i++) { fpi->edch_ddi[i] = p_conv_data->edch_ddi[i];     fpi->edch_macd_pdu_size[i] = p_conv_data->edch_macd_pdu_size[i];     fpi->edch_lchId[i] = p_conv_data->edch_lchId[i];     } fpi->edch_type = p_conv_data->edch_type; p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); rlcinf->urnti[0] = fpi->com_context_id; rlcinf->li_size[0] = RLC_LI_7BITS; rlcinf->ciphered[0] = FALSE; rlcinf->deciphered[0] = FALSE; p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); return fpi; case CHANNEL_PCH: fpi->paging_indications = p_conv_data->paging_indications; fpi->num_chans = p_conv_data->num_dch_in_flow; if (is_control_frame) { return fpi; } offset = 3; break; case CHANNEL_DCH: fpi->num_chans = p_conv_data->num_dch_in_flow; if (is_control_frame) { return fpi; } rlcinf = wmem_new0(wmem_file_scope(), rlc_info); macinf = wmem_new0(wmem_file_scope(), umts_mac_info); offset = 2;     fakes  = 5;  for (chan=0; chan < fpi->num_chans; chan++) {     tfi = tvb_get_bits8(tvb, 3+offset*8, 5); num_tbs = (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[chan].ul_chan_num_tbs[tfi] : p_conv_data->fp_dch_channel_info[chan].dl_chan_num_tbs[tfi]; tb_size=  (fpi->is_uplink) ? p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi] :    p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi]; if ( p_conv_data->dchs_in_flow_list[chan] != 31 && (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) ) { fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]); } tb_bit_off = (2+p_conv_data->num_dch_in_flow)*8;     for (j=0; j < num_tbs && j+chan < MAX_MAC_FRAMES; j++) { macinf->trchid[j+chan] = p_conv_data->dchs_in_flow_list[chan]; if ( p_conv_data->dchs_in_flow_list[chan] == 31 || p_conv_data->dchs_in_flow_list[chan] == 24) { if (0) { macinf->ctmux[j+chan] = FALSE; macinf->lchid[j+chan] = 1; macinf->content[j+chan] = lchId_type_table[1];     rlcinf->mode[j+chan] = lchId_rlc_map[1];     } else if (p_conv_data->dchs_in_flow_list[chan] == 24 && tb_size != 340) { macinf->ctmux[j+chan] = FALSE; macinf->lchid[j+chan] = fake_lchid; macinf->fake_chid[j+chan] = TRUE; macinf->content[j+chan] = MAC_CONTENT_PS_DTCH;      rlcinf->mode[j+chan] = RLC_AM;     } else { macinf->ctmux[j+chan] = TRUE; c_t = tvb_get_bits8(tvb, tb_bit_off, 4);     macinf->lchid[j+chan] = c_t+1; macinf->content[j+chan] = lchId_type_table[c_t+1];     rlcinf->mode[j+chan] = lchId_rlc_map[c_t+1];     } } else { fake_lchid = make_fake_lchid(pinfo, p_conv_data->dchs_in_flow_list[chan]); macinf->ctmux[j+chan] = FALSE; macinf->content[j+chan] = lchId_type_table[fake_lchid]; rlcinf->mode[j+chan] = lchId_rlc_map[fake_lchid]; macinf->fake_chid[j+chan] = TRUE; macinf->lchid[j+chan] = fake_lchid;   } rlcinf->urnti[j+chan] = p_conv_data->com_context_id; rlcinf->li_size[j+chan] = RLC_LI_7BITS; #if 0 if ( rrc_ciph_inf && g_tree_lookup(rrc_ciph_inf, GINT_TO_POINTER((gint)p_conv_data->com_context_id)) != NULL ) { rlcinf->ciphered[j+chan] = TRUE; } else { rlcinf->ciphered[j+chan] = FALSE; } #endif rlcinf->ciphered[j+chan] = FALSE; rlcinf->deciphered[j+chan] = FALSE; rlcinf->rbid[j+chan] = macinf->lchid[j+chan]; tb_bit_off += tb_size+4; } offset++; } p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); offset = 2; break; case CHANNEL_FACH_FDD: fpi->num_chans = p_conv_data->num_dch_in_flow; if (is_control_frame) { return fpi; } offset = 2; macinf = wmem_new0(wmem_file_scope(), umts_mac_info); macinf->ctmux[0]   = 1; macinf->content[0] = MAC_CONTENT_DCCH; p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); rlcinf = wmem_new0(wmem_file_scope(), rlc_info); rlcinf->urnti[0] = fpi->channel; rlcinf->mode[0] = RLC_AM; rlcinf->li_size[0] = RLC_LI_7BITS; rlcinf->ciphered[0] = FALSE; rlcinf->deciphered[0] = FALSE; p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); break; case CHANNEL_RACH_FDD: fpi->num_chans = p_conv_data->num_dch_in_flow; if (is_control_frame) { return fpi; } offset = 2; macinf = wmem_new0(wmem_file_scope(), umts_mac_info); rlcinf = wmem_new0(wmem_file_scope(), rlc_info); for ( chan = 0; chan < fpi->num_chans; chan++ ) { macinf->ctmux[chan]   = 1; macinf->content[chan] = MAC_CONTENT_DCCH; rlcinf->urnti[chan] = fpi->com_context_id;     } p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); break; case CHANNEL_HSDSCH_COMMON: rlcinf = wmem_new0(wmem_file_scope(), rlc_info); macinf = wmem_new0(wmem_file_scope(), umts_mac_info); p_add_proto_data(wmem_file_scope(), pinfo, proto_umts_mac, 0, macinf); p_add_proto_data(wmem_file_scope(), pinfo, proto_rlc, 0, rlcinf); break; default: expert_add_info(pinfo, NULL, &ei_fp_transport_channel_type_unknown); return NULL; } for (i=0; i<fpi->num_chans; i++) { tfi = tvb_get_guint8(tvb, offset); if (pinfo->link_dir == P2P_DIR_UL) { fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_tf_size[tfi]; fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].ul_chan_num_tbs[tfi]; } else { fpi->chan_tf_size[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_tf_size[tfi]; fpi->chan_num_tbs[i] = p_conv_data->fp_dch_channel_info[i].dl_chan_num_tbs[tfi]; } offset++; } return fpi; }"
"char *M_fs_path_tmpdir(M_fs_system_t sys_type) { char         *d   = NULL; char         *out = NULL; M_fs_error_t  res; #ifdef _WIN32 size_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1; d = M_malloc_zero(len); if (GetTempPath((DWORD)len, d) >= len) { M_free(d); d = NULL; } #elif defined(__APPLE__) d = M_fs_path_mac_tmpdir(); #else const char *const_temp; #  ifdef HAVE_SECURE_GETENV const_temp = secure_getenv(""TMPDIR""); #  else const_temp = getenv(""TMPDIR""); #  endif if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) { d = M_strdup(const_temp); } if (d == NULL) { const_temp = ""/tmp""; if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) { d = M_strdup(const_temp); } } if (d == NULL) { const_temp = ""/var/tmp""; if (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) { d = M_strdup(const_temp); } } #endif if (d != NULL) { res = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type); if (res != M_FS_ERROR_SUCCESS) { out = NULL; } } M_free(d); return out; }"
"static struct lys_node * read_yin_notif(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options, struct unres_schema *unres) { struct ly_ctx *ctx = module->ctx; struct lyxml_elem *sub, *next, root; struct lys_node *node = NULL; struct lys_node *retval; struct lys_node_notif *notif; int r; int c_tpdf = 0, c_ftrs = 0, c_must = 0, c_ext = 0; void *reallocated; if (parent && (module->version < 2)) { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, parent, ""notification""); return NULL; } memset(&root, 0, sizeof root); notif = calloc(1, sizeof *notif); LY_CHECK_ERR_RETURN(!notif, LOGMEM(ctx), NULL); notif->nodetype = LYS_NOTIF; notif->prev = (struct lys_node *)notif; retval = (struct lys_node *)notif; if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin, OPT_IDENT | OPT_MODULE, unres)) { goto error; } LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name); if (lys_node_addchild(parent, lys_main_module(module), retval, options)) { goto error; } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""notification"", error); c_ext++; continue; } else if (!strcmp(sub->name, ""container"") || !strcmp(sub->name, ""leaf-list"") || !strcmp(sub->name, ""leaf"") || !strcmp(sub->name, ""list"") || !strcmp(sub->name, ""choice"") || !strcmp(sub->name, ""uses"") || !strcmp(sub->name, ""grouping"") || !strcmp(sub->name, ""anyxml"") || !strcmp(sub->name, ""anydata"")) { lyxml_unlink_elem(ctx, sub, 2); lyxml_add_child(ctx, &root, sub); } else if (!strcmp(sub->name, ""typedef"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, notif->tpdf_size, ""typedefs"", ""notification"", error); c_tpdf++; } else if (!strcmp(sub->name, ""if-feature"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""notification"", error); c_ftrs++; } else if ((module->version >= 2) && !strcmp(sub->name, ""must"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, notif->must_size, ""musts"", ""notification"", error); c_must++; } else { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name); goto error; } } if (c_tpdf) { notif->tpdf = calloc(c_tpdf, sizeof *notif->tpdf); LY_CHECK_ERR_GOTO(!notif->tpdf, LOGMEM(ctx), error); } if (c_ftrs) { notif->iffeature = calloc(c_ftrs, sizeof *notif->iffeature); LY_CHECK_ERR_GOTO(!notif->iffeature, LOGMEM(ctx), error); } if (c_must) { notif->must = calloc(c_must, sizeof *notif->must); LY_CHECK_ERR_GOTO(!notif->must, LOGMEM(ctx), error); } if (c_ext) { reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext); LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error); retval->ext = reallocated; memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext); } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres); if (r) { goto error; } } else if (!strcmp(sub->name, ""typedef"")) { r = fill_yin_typedef(module, retval, sub, &notif->tpdf[notif->tpdf_size], unres); notif->tpdf_size++; if (r) { goto error; } } else if (!strcmp(sub->name, ""if-feature"")) { r = fill_yin_iffeature(retval, 0, sub, &notif->iffeature[notif->iffeature_size], unres); notif->iffeature_size++; if (r) { goto error; } } else if (!strcmp(sub->name, ""must"")) { r = fill_yin_must(module, sub, &notif->must[notif->must_size], unres); notif->must_size++; if (r) { goto error; } } } lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size); options |= LYS_PARSE_OPT_CFG_IGNORE; LY_TREE_FOR_SAFE(root.child, next, sub) { if (!strcmp(sub->name, ""container"")) { node = read_yin_container(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf-list"")) { node = read_yin_leaflist(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""leaf"")) { node = read_yin_leaf(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""list"")) { node = read_yin_list(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""choice"")) { node = read_yin_choice(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""uses"")) { node = read_yin_uses(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""grouping"")) { node = read_yin_grouping(module, retval, sub, options, unres); } else if (!strcmp(sub->name, ""anyxml"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres); } else if (!strcmp(sub->name, ""anydata"")) { node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres); } if (!node) { goto error; } lyxml_free(ctx, sub); } if (!(ctx->models.flags & LY_CTX_TRUSTED) && notif->must) { if (options & LYS_PARSE_OPT_INGRP) { if (lyxp_node_check_syntax(retval)) { goto error; } } else { if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) { goto error; } } } return retval; error: lys_node_free(retval, NULL, 0); while (root.child) { lyxml_free(ctx, root.child); } return NULL; }"
"void* jfif_load(char *file) { JFIF *jfif   = NULL; FILE *fp     = NULL; int   header = 0; int   type   = 0; WORD  size   = 0; BYTE *buf    = NULL; int   ret    =-1; long  offset = 0; int   i; jfif = calloc(1, sizeof(JFIF)); buf  = calloc(1, 0x10000); if (!jfif || !buf) goto done; fp = fopen(file, ""rb""); if (!fp) goto done; while (1) { do { header = fgetc(fp); } while (header != EOF && header != 0xff);         do { type   = fgetc(fp); } while (type   != EOF && type   == 0xff);         if (header == EOF || type == EOF) { printf(""file eof !\n""); break; } if ((type == 0xd8) || (type == 0xd9) || (type == 0x01) || (type >= 0xd0 && type <= 0xd7)) { size = 0; } else { size  = fgetc(fp) << 8; size |= fgetc(fp) << 0; size -= 2; } fread(buf, size, 1, fp); switch (type) { case 0xc0:             jfif->width    = (buf[3] << 8) | (buf[4] << 0); jfif->height   = (buf[1] << 8) | (buf[2] << 0); jfif->comp_num = buf[5]; for (i=0; i<jfif->comp_num; i++) { jfif->comp_info[i].id = buf[6 + i * 3]; jfif->comp_info[i].samp_factor_v = (buf[7 + i * 3] >> 0) & 0x0f; jfif->comp_info[i].samp_factor_h = (buf[7 + i * 3] >> 4) & 0x0f; jfif->comp_info[i].qtab_idx      =  buf[8 + i * 3]; } break; case 0xda:             jfif->comp_num = buf[0]; for (i=0; i<jfif->comp_num; i++) { jfif->comp_info[i].id = buf[1 + i * 2]; jfif->comp_info[i].htab_idx_ac = (buf[2 + i * 2] >> 0) & 0x0f; jfif->comp_info[i].htab_idx_dc = (buf[2 + i * 2] >> 4) & 0x0f; } offset = ftell(fp); ret    = 0; goto read_data; break; case 0xdb: {                 BYTE *dqt = buf; while (size >= 65) { int idx = dqt[0] & 0x0f; int f16 = dqt[0] & 0xf0; if (!jfif->pqtab[idx]) jfif->pqtab[idx] = malloc(64 * sizeof(int)); if (!jfif->pqtab[idx]) break; if (f16) {                         for (i=0; i<64; i++) { jfif->pqtab[idx][ZIGZAG[i]] = (dqt[1 + i * 2] << 8) | (dqt[2 + i * 2] << 0); } } else {                         for (i=0; i<64; i++) { jfif->pqtab[idx][ZIGZAG[i]] = dqt[1 + i]; } } size -= 1 + 64 * (f16 ? 2 : 1); dqt  += 1 + 64 * (f16 ? 2 : 1); } } break; case 0xc4: {                 BYTE *dht = buf; while (size >= 17) { int idx  = dht[0] & 0x0f; int fac  = dht[0] & 0xf0; int len  = 0; for (i=1; i<1+16; i++) len += dht[i]; if (fac) { if (!jfif->phcac[idx]) jfif->phcac[idx] = calloc(1, sizeof(HUFCODEC)); if ( jfif->phcac[idx]) memcpy(jfif->phcac[idx]->huftab, &dht[1], 16 + len); } else { if (!jfif->phcdc[idx]) jfif->phcdc[idx] = calloc(1, sizeof(HUFCODEC)); if ( jfif->phcdc[idx]) memcpy(jfif->phcdc[idx]->huftab, &dht[1], 16 + len); } size -= 17 + len; dht  += 17 + len; } } break; } } read_data: fseek(fp, 0, SEEK_END); jfif->datalen = ftell(fp) - offset; jfif->databuf = malloc(jfif->datalen); if (jfif->databuf) { fseek(fp, offset, SEEK_SET); fread(jfif->databuf, jfif->datalen, 1, fp); } done: if (buf) free  (buf); if (fp ) fclose(fp ); if (ret == -1) { jfif_free(jfif); jfif = NULL; } return jfif; }"
"static int _parse_dns_reply(uint8_t *buf, size_t len, void* addr_out, int family) { sock_dns_hdr_t *hdr = (sock_dns_hdr_t*) buf; uint8_t *bufpos = buf + sizeof(*hdr); for (unsigned n = 0; n < ntohs(hdr->qdcount); n++) { bufpos += _skip_hostname(bufpos); bufpos += 4;     } for (unsigned n = 0; n < ntohs(hdr->ancount); n++) { bufpos += _skip_hostname(bufpos); uint16_t _type = ntohs(_get_short(bufpos)); bufpos += 2; uint16_t class = ntohs(_get_short(bufpos)); bufpos += 2; bufpos += 4;  unsigned addrlen = ntohs(_get_short(bufpos)); bufpos += 2; if ((bufpos + addrlen) > (buf + len)) { return -EBADMSG; } if ((class != DNS_CLASS_IN) || ((_type == DNS_TYPE_A) && (family == AF_INET6)) || ((_type == DNS_TYPE_AAAA) && (family == AF_INET)) || ! ((_type == DNS_TYPE_A) || ((_type == DNS_TYPE_AAAA)) )) { bufpos += addrlen; continue; } memcpy(addr_out, bufpos, addrlen); return addrlen; } return -1; }"
"static void hso_free_net_device(struct hso_device *hso_dev, bool bailout) { int i; struct hso_net *hso_net = dev2net(hso_dev); if (!hso_net) return; remove_net_device(hso_net->parent); if (hso_net->net) unregister_netdev(hso_net->net); for (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) { usb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]); kfree(hso_net->mux_bulk_rx_buf_pool[i]); hso_net->mux_bulk_rx_buf_pool[i] = NULL; } usb_free_urb(hso_net->mux_bulk_tx_urb); kfree(hso_net->mux_bulk_tx_buf); hso_net->mux_bulk_tx_buf = NULL; if (hso_net->net && !bailout) free_netdev(hso_net->net); kfree(hso_dev); }"
"void GrpcHealthCheckerImpl::GrpcActiveHealthCheckSession::onGoAway( Http::GoAwayErrorCode error_code) { ENVOY_CONN_LOG(debug, ""connection going away health_flags={}"", *client_, HostUtility::healthFlagsToString(*host_)); if (request_encoder_ && error_code == Http::GoAwayErrorCode::NoError) { received_no_error_goaway_ = true; return; } if (request_encoder_) { handleFailure(envoy::data::core::v3::NETWORK); expect_reset_ = true; request_encoder_->getStream().resetStream(Http::StreamResetReason::LocalReset); } client_->close(); }"
"bool RequestParser::OnHeadersEnd() { bool matched = view_matcher_(request_->method(), request_->url().path(), &stream_); if (!matched) { LOG_WARN(""No view matches the request: %s %s"", request_->method().c_str(), request_->url().path().c_str()); } return matched; }"
"CodingReturnValue VP8ComponentDecoder::decode_chunk(UncompressedComponents * const colldata) { mux_splicer.init(spin_workers_); if ( thread_state_[0] == nullptr || thread_state_[0]->context_[0].isNil() ) { BlockBasedImagePerChannel<false> framebuffer; framebuffer.memset(0); for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) { framebuffer[i] = &colldata->full_component_write((BlockType)i); } Sirikata::Array1d<BlockBasedImagePerChannel<false>, MAX_NUM_THREADS> all_framebuffers; for (size_t i = 0; i < all_framebuffers.size(); ++i) { all_framebuffers[i] = framebuffer; } size_t num_threads_needed = initialize_decoder_state(colldata, all_framebuffers).size(); for (size_t i = 0;i < num_threads_needed; ++i) { map_logical_thread_to_physical_thread(i, i); } for (size_t i = 0;i < num_threads_needed; ++i) { initialize_thread_id(i, i, framebuffer); if (!do_threading_) { break; } } if (num_threads_needed > NUM_THREADS || num_threads_needed == 0) { return CODING_ERROR; } } if (do_threading_) { for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) { unsigned int cur_spin_worker = thread_id; spin_workers_[cur_spin_worker].work = std::bind(worker_thread, thread_state_[thread_id], thread_id, colldata, mux_splicer.thread_target, getWorker(cur_spin_worker), &send_to_actual_thread_state); spin_workers_[cur_spin_worker].activate_work(); } flush(); for (unsigned int thread_id = 0; thread_id < NUM_THREADS; ++thread_id) { unsigned int cur_spin_worker = thread_id; TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_STARTED] = TimingHarness::get_time_us(); spin_workers_[cur_spin_worker].main_wait_for_done(); TimingHarness::timing[thread_id][TimingHarness::TS_THREAD_WAIT_FINISHED] = TimingHarness::get_time_us(); } } else { if (virtual_thread_id_ != -1) { TimingHarness::timing[0][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us(); CodingReturnValue ret = thread_state_[0]->vp8_decode_thread(0, colldata); if (ret == CODING_PARTIAL) { return ret; } TimingHarness::timing[0][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us(); } virtual_thread_id_ += 1;         for (unsigned int thread_id = virtual_thread_id_; thread_id < NUM_THREADS; ++thread_id, ++virtual_thread_id_) { BlockBasedImagePerChannel<false> framebuffer; framebuffer.memset(0); for (size_t i = 0; i < framebuffer.size() && int( i ) < colldata->get_num_components(); ++i) { framebuffer[i] = &colldata->full_component_write((BlockType)i); } initialize_thread_id(thread_id, 0, framebuffer); thread_state_[0]->bool_decoder_.init(new VirtualThreadPacketReader(thread_id, &mux_reader_, &mux_splicer)); TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_STARTED] = TimingHarness::get_time_us(); CodingReturnValue ret; if ((ret = thread_state_[0]->vp8_decode_thread(0, colldata)) == CODING_PARTIAL) { return ret; } TimingHarness::timing[thread_id][TimingHarness::TS_ARITH_FINISHED] = TimingHarness::get_time_us(); } } TimingHarness::timing[0][TimingHarness::TS_JPEG_RECODE_STARTED] = TimingHarness::get_time_us(); for (int component = 0; component < colldata->get_num_components(); ++component) { colldata->worker_mark_cmp_finished((BlockType)component); } colldata->worker_update_coefficient_position_progress( 64 ); colldata->worker_update_bit_progress( 16 ); write_byte_bill(Billing::DELIMITERS, true, mux_reader_.getOverhead()); return CODING_DONE; }"
"void ZlibDecompressorImpl::decompress(const Buffer::Instance& input_buffer, Buffer::Instance& output_buffer) { for (const Buffer::RawSlice& input_slice : input_buffer.getRawSlices()) { zstream_ptr_->avail_in = input_slice.len_; zstream_ptr_->next_in = static_cast<Bytef*>(input_slice.mem_); while (inflateNext()) { if (zstream_ptr_->avail_out == 0) { updateOutput(output_buffer); } } } updateOutput(output_buffer); }"
"static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e) { char *content = attribute_content; while (*content == ' ') content++; if (strstr(content, ""defer"")) { par->defer = 1; content += 4; } else { content = attribute_content; } while (*content == ' ') content++; if (strstr(content, ""none"")) { par->align = SVG_PRESERVEASPECTRATIO_NONE; content+=4; } else if (strstr(content, ""xMinYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMIN; content+=8; } else if (strstr(content, ""xMidYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN; content+=8; } else if (strstr(content, ""xMaxYMin"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN; content+=8; } else if (strstr(content, ""xMinYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMID; content+=8; } else if (strstr(content, ""xMidYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMID; content+=8; } else if (strstr(content, ""xMaxYMid"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMID; content+=8; } else if (strstr(content, ""xMinYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMINYMAX; content+=8; } else if (strstr(content, ""xMidYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX; content+=8; } else if (strstr(content, ""xMaxYMax"")) { par->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX; content+=8; } else { *out_e = GF_NON_COMPLIANT_BITSTREAM; } while (*content == ' ') content++; if (*content == 0) return; if (strstr(content, ""meet"")) { par->meetOrSlice = SVG_MEETORSLICE_MEET; } else if (strstr(content, ""slice"")) { par->meetOrSlice = SVG_MEETORSLICE_SLICE; } else { *out_e = GF_NON_COMPLIANT_BITSTREAM; } }"
"status_t SampleTable::setTimeToSampleParams( off64_t data_offset, size_t data_size) { if (!mTimeToSample.empty() || data_size < 8) { return ERROR_MALFORMED; } uint8_t header[8]; if (mDataSource->readAt( data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) { return ERROR_IO; } if (U32_AT(header) != 0) { return ERROR_MALFORMED; } mTimeToSampleCount = U32_AT(&header[4]); if ((uint64_t)mTimeToSampleCount > (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) { ALOGE(""  Error: Time-to-sample table size too large.""); return ERROR_OUT_OF_RANGE; } if (!mDataSource->getVector(data_offset + 8, &mTimeToSample, mTimeToSampleCount * 2)) { ALOGE(""  Error: Incomplete data read for time-to-sample table.""); return ERROR_IO; } for (size_t i = 0; i < mTimeToSample.size(); ++i) { mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]); } return OK; }"
"Macho_Binary_t** macho_parse(const char *file) { FatBinary* fat = Parser::parse(file).release(); auto** c_macho_binaries = static_cast<Macho_Binary_t**>( malloc((fat->size() + 1) * sizeof(Macho_Binary_t**))); for (size_t i = 0; i < fat->size(); ++i) { Binary* binary = fat->at(i); if (binary != nullptr) { c_macho_binaries[i] = static_cast<Macho_Binary_t*>(malloc(sizeof(Macho_Binary_t))); init_c_binary(c_macho_binaries[i], binary); } } c_macho_binaries[fat->size()] = nullptr; return c_macho_binaries; }"
"bool Decompress::handleZipEntry(std::istream& zipStream, const ZipLocalFileHeader& hdr) { if (hdr.isDirectory()) { if (!_flattenDirs) { std::string dirName = hdr.getFileName(); if (!ZipCommon::isValidPath(dirName)) throw ZipException(""Illegal entry name "" + dirName + "" containing parent directory reference""); Poco::Path dir(_outDir, dirName); dir.makeDirectory(); Poco::File aFile(dir); aFile.createDirectories(); } return true; } try { std::string fileName = hdr.getFileName(); if (_flattenDirs) { Poco::Path p(fileName); p.makeFile(); fileName = p.getFileName(); } if (!ZipCommon::isValidPath(fileName)) throw ZipException(""Illegal entry name "" + fileName + "" containing parent directory reference""); Poco::Path file(fileName); file.makeFile(); Poco::Path dest(_outDir, file); dest.makeFile(); if (dest.depth() > 0) { Poco::File aFile(dest.parent()); aFile.createDirectories(); } Poco::FileOutputStream out(dest.toString()); ZipInputStream inp(zipStream, hdr, false); Poco::StreamCopier::copyStream(inp, out); out.close(); Poco::File aFile(dest.toString()); if (!aFile.exists() || !aFile.isFile()) { std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Failed to create output stream "" + dest.toString()); EError.notify(this, tmp); return false; } if (!inp.crcValid()) { if (!_keepIncompleteFiles) aFile.remove(); std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""CRC mismatch. Corrupt file: "" + dest.toString()); EError.notify(this, tmp); return false; } if (aFile.getSize() != hdr.getUncompressedSize() && !hdr.searchCRCAndSizesAfterData()) { if (!_keepIncompleteFiles) aFile.remove(); std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, ""Filesizes do not match. Corrupt file: "" + dest.toString()); EError.notify(this, tmp); return false; } std::pair<const ZipLocalFileHeader, const Poco::Path> tmp = std::make_pair(hdr, file); EOk.notify(this, tmp); } catch (Poco::Exception& e) { std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Exception: "" + e.displayText())); EError.notify(this, tmp); return false; } catch (...) { std::pair<const ZipLocalFileHeader, const std::string> tmp = std::make_pair(hdr, std::string(""Unknown Exception"")); EError.notify(this, tmp); return false; } return true; }"
"apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location, char **javascript, char **javascript_method) { if (oidc_cfg_dir_preserve_post(r) == 0) return FALSE; oidc_debug(r, ""enter""); oidc_cfg *cfg = ap_get_module_config(r->server->module_config, &auth_openidc_module); const char *method = oidc_original_request_method(r, cfg, FALSE); if (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0) return FALSE; apr_table_t *params = apr_table_make(r->pool, 8); if (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) { oidc_error(r, ""something went wrong when reading the POST parameters""); return FALSE; } const apr_array_header_t *arr = apr_table_elts(params); const apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts; int i; char *json = """"; for (i = 0; i < arr->nelts; i++) { json = apr_psprintf(r->pool, ""%s'%s': '%s'%s"", json, oidc_util_escape_string(r, elts[i].key), oidc_util_escape_string(r, elts[i].val), i < arr->nelts - 1 ? "","" : """"); } json = apr_psprintf(r->pool, ""{ %s }"", json); const char *jmethod = ""preserveOnLoad""; const char *jscript = apr_psprintf(r->pool, ""    <script type=\""text/javascript\"">\n"" ""      function %s() {\n"" ""        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\n"" ""        %s"" ""      }\n"" ""    </script>\n"", jmethod, json, location ? apr_psprintf(r->pool, ""window.location='%s';\n"", location) : """"); if (location == NULL) { if (javascript_method) *javascript_method = apr_pstrdup(r->pool, jmethod); if (javascript) *javascript = apr_pstrdup(r->pool, jscript); } else { oidc_util_html_send(r, ""Preserving..."", jscript, jmethod, ""<p>Preserving...</p>"", OK); } return TRUE; }"
"const char *janus_get_codec_from_pt(const char *sdp, int pt) { if(!sdp || pt < 0) return NULL; if(pt == 0) return ""pcmu""; if(pt == 8) return ""pcma""; if(pt == 9) return ""g722""; char rtpmap[50]; g_snprintf(rtpmap, 50, ""a=rtpmap:%d "", pt); const char *line = strstr(sdp, ""m=""); while(line) { char *next = strchr(line, '\n'); if(next) { *next = '\0'; if(strstr(line, rtpmap)) { char name[100]; if(sscanf(line, ""a=rtpmap:%d %s"", &pt, name) == 2) { *next = '\n'; if(strstr(name, ""vp8"") || strstr(name, ""VP8"")) return ""vp8""; if(strstr(name, ""vp9"") || strstr(name, ""VP9"")) return ""vp9""; if(strstr(name, ""h264"") || strstr(name, ""H264"")) return ""h264""; if(strstr(name, ""av1"") || strstr(name, ""AV1"")) return ""av1""; if(strstr(name, ""h265"") || strstr(name, ""H265"")) return ""h265""; if(strstr(name, ""opus"") || strstr(name, ""OPUS"")) return ""opus""; if(strstr(name, ""pcmu"") || strstr(name, ""PCMU"")) return ""pcmu""; if(strstr(name, ""pcma"") || strstr(name, ""PCMA"")) return ""pcma""; if(strstr(name, ""g722"") || strstr(name, ""G722"")) return ""g722""; if(strstr(name, ""isac/16"") || strstr(name, ""ISAC/16"")) return ""isac16""; if(strstr(name, ""isac/32"") || strstr(name, ""ISAC/32"")) return ""isac32""; JANUS_LOG(LOG_ERR, ""Unsupported codec '%s'\n"", name); return NULL; } } *next = '\n'; } line = next ? (next+1) : NULL; } return NULL; }"
"static int fuse_unlink(struct inode *dir, struct dentry *entry) { int err; struct fuse_mount *fm = get_fuse_mount(dir); FUSE_ARGS(args); args.opcode = FUSE_UNLINK; args.nodeid = get_node_id(dir); args.in_numargs = 1; args.in_args[0].size = entry->d_name.len + 1; args.in_args[0].value = entry->d_name.name; err = fuse_simple_request(fm, &args); if (!err) { struct inode *inode = d_inode(entry); struct fuse_inode *fi = get_fuse_inode(inode); spin_lock(&fi->lock); fi->attr_version = atomic64_inc_return(&fm->fc->attr_version); if (inode->i_nlink > 0) drop_nlink(inode); spin_unlock(&fi->lock); fuse_invalidate_attr(inode); fuse_dir_changed(dir); fuse_invalidate_entry_cache(entry); fuse_update_ctime(inode); } else if (err == -EINTR) fuse_invalidate_entry(entry); return err; }"
"static void dns_resolve_cb(enum dns_resolve_status status, struct dns_addrinfo *info, void *user_data) { struct getaddrinfo_state *state = user_data; struct zsock_addrinfo *ai = ai_arr + state->idx; int socktype = SOCK_STREAM; int proto; NET_DBG(""dns status: %d"", status); if (info == NULL) { if (status == DNS_EAI_ALLDONE) { status = 0; } state->status = status; k_sem_give(&state->sem); return; } memcpy(&ai->_ai_addr, &info->ai_addr, info->ai_addrlen); ai->ai_addr = &ai->_ai_addr; ai->ai_addrlen = info->ai_addrlen; memcpy(&ai->_ai_canonname, &info->ai_canonname, sizeof(ai->_ai_canonname)); ai->ai_canonname = ai->_ai_canonname; ai->ai_family = info->ai_family; if (state->hints) { if (state->hints->ai_socktype) { socktype = state->hints->ai_socktype; } } proto = IPPROTO_TCP; if (socktype == SOCK_DGRAM) { proto = IPPROTO_UDP; } ai->ai_socktype = socktype; ai->ai_protocol = proto; state->idx++; }"
"static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kSegCountOffset = 6; const size_t kEndCountOffset = 14; const size_t kHeaderSize = 16; const size_t kSegmentSize = 8;      if (kEndCountOffset > size) { return false; } size_t segCount = readU16(data, kSegCountOffset) >> 1; if (kHeaderSize + segCount * kSegmentSize > size) { return false; } for (size_t i = 0; i < segCount; i++) { uint32_t end = readU16(data, kEndCountOffset + 2 * i); uint32_t start = readU16(data, kHeaderSize + 2 * (segCount + i)); if (end < start) { return false; } uint32_t rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i)); if (rangeOffset == 0) { uint32_t delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i)); if (((end + delta) & 0xffff) > end - start) { addRange(coverage, start, end + 1); } else { for (uint32_t j = start; j < end + 1; j++) { if (((j + delta) & 0xffff) != 0) { addRange(coverage, j, j + 1); } } } } else { for (uint32_t j = start; j < end + 1; j++) { uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset + (i + j - start) * 2; if (actualRangeOffset + 2 > size) { continue; } uint32_t glyphId = readU16(data, actualRangeOffset); if (glyphId != 0) { addRange(coverage, j, j + 1); } } } } return true; }"
"static void php_wddx_pop_element(void *user_data, const XML_Char *name) { st_entry *ent1, *ent2; wddx_stack *stack = (wddx_stack *)user_data; HashTable *target_hash; zend_class_entry **pce; zval*obj; zval*tmp; TSRMLS_FETCH(); if (stack->top == 0) { return; } if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) || !strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) || !strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) || !strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) || !strcmp(name, EL_DATETIME)) { wddx_stack_top(stack, (void**)&ent1); if (!strcmp(name, EL_BINARY)) { int new_len=0; unsigned char *new_str; new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len); STR_FREE(Z_STRVAL_P(ent1->data)); Z_STRVAL_P(ent1->data) = new_str; Z_STRLEN_P(ent1->data) = new_len; } if (Z_TYPE_P(ent1->data) == IS_OBJECT) { zval *fname, *retval = NULL; MAKE_STD_ZVAL(fname); ZVAL_STRING(fname, ""__wakeup"", 1); call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC); zval_dtor(fname); FREE_ZVAL(fname); if (retval) { zval_ptr_dtor(&retval); } } if (stack->top > 1) { stack->top--; wddx_stack_top(stack, (void**)&ent2); if (ent2->type == ST_FIELD && ent2->data == NULL) { zval_ptr_dtor(&ent1->data); efree(ent1); return; } if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) { target_hash = HASH_OF(ent2->data); if (ent1->varname) { if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) && Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) && ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) { zend_bool incomplete_class = 0; zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) { incomplete_class = 1; pce = &PHP_IC_ENTRY; } MAKE_STD_ZVAL(obj); object_init_ex(obj, *pce); zend_hash_merge(Z_OBJPROP_P(obj), Z_ARRVAL_P(ent2->data), (void (*)(void *)) zval_add_ref, (void *) &tmp, sizeof(zval *), 0); if (incomplete_class) { php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data)); } zval_ptr_dtor(&ent2->data); ent2->data = obj; zval_ptr_dtor(&ent1->data); } else if (Z_TYPE_P(ent2->data) == IS_OBJECT) { zend_class_entry *old_scope = EG(scope); EG(scope) = Z_OBJCE_P(ent2->data); Z_DELREF_P(ent1->data); add_property_zval(ent2->data, ent1->varname, ent1->data); EG(scope) = old_scope; } else { zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL); } efree(ent1->varname); } else{ zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL); } } efree(ent1); } else { stack->done = 1; } } else if (!strcmp(name, EL_VAR) && stack->varname) { efree(stack->varname); } else if (!strcmp(name, EL_FIELD)) { st_entry *ent; wddx_stack_top(stack, (void **)&ent); efree(ent); stack->top--; } }"
explicit ElementsAccessorBase(const char* name) : ElementsAccessor(name) { }
static void unref_ft_library() { gFTMutex.assertHeld(); SkASSERT(gFTCount > 0); --gFTCount; if (0 == gFTCount) { SkASSERT(nullptr != gFTLibrary); delete gFTLibrary; SkDEBUGCODE(gFTLibrary = nullptr;) } }
"static void child_setup_func (gpointer user_data) { ChildSetupData *data = (ChildSetupData *) user_data; FdMapEntry *fd_map = data->fd_map; sigset_t set; int i; flatpak_close_fds_workaround (3); if (data->instance_id_fd != -1) drop_cloexec (data->instance_id_fd); sigemptyset (&set); if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1) { g_warning (""Failed to unblock signals when starting child""); return; } for (i = 1; i < NSIG; i++) { if (i != SIGSTOP && i != SIGKILL) signal (i, SIG_DFL); } for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].from != fd_map[i].to) { dup2 (fd_map[i].from, fd_map[i].to); close (fd_map[i].from); } } for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].to != fd_map[i].final) { dup2 (fd_map[i].to, fd_map[i].final); close (fd_map[i].to); } drop_cloexec (fd_map[i].final); } setsid (); setpgid (0, 0); if (data->set_tty) { for (i = 0; i < data->fd_map_len; i++) { if (fd_map[i].from == data->tty) { if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1) g_debug (""ioctl(%d, TIOCSCTTY, 0) failed: %s"", fd_map[i].final, strerror (errno)); break; } } } }"
"static void gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) { int idx; int type = nint(tree->car); switch (type) { case NODE_GVAR: case NODE_ARG: case NODE_LVAR: case NODE_IVAR: case NODE_CVAR: case NODE_CONST: case NODE_NIL: case NODE_MASGN: if (rhs) { codegen(s, rhs, VAL); pop(); sp = cursp(); } break; case NODE_COLON2: case NODE_CALL: case NODE_SCALL: break; case NODE_NVAR: codegen_error(s, ""Can't assign to numbered parameter""); break; default: codegen_error(s, ""unknown lhs""); break; } tree = tree->cdr; switch (type) { case NODE_GVAR: gen_setxv(s, OP_SETGV, sp, nsym(tree), val); break; case NODE_ARG: case NODE_LVAR: idx = lv_idx(s, nsym(tree)); if (idx > 0) { if (idx != sp) { gen_move(s, idx, sp, val); } break; } else {                       gen_setupvar(s, sp, nsym(tree)); } break; case NODE_IVAR: gen_setxv(s, OP_SETIV, sp, nsym(tree), val); break; case NODE_CVAR: gen_setxv(s, OP_SETCV, sp, nsym(tree), val); break; case NODE_CONST: gen_setxv(s, OP_SETCONST, sp, nsym(tree), val); break; case NODE_COLON2: if (sp) { gen_move(s, cursp(), sp, 0); } sp = cursp(); push(); codegen(s, tree->car, VAL); if (rhs) { codegen(s, rhs, VAL); pop(); gen_move(s, sp, cursp(), 0); } pop_n(2); idx = new_sym(s, nsym(tree->cdr)); genop_2(s, OP_SETMCNST, sp, idx); break; case NODE_CALL: case NODE_SCALL: { int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0; mrb_sym mid = nsym(tree->cdr->car); top = cursp(); if (val || sp == cursp()) { push();                    } call = cursp(); if (!tree->car) { noself = 1; push(); } else { codegen(s, tree->car, VAL);  } if (safe) { int recv = cursp()-1; gen_move(s, cursp(), recv, 1); skip = genjmp2_0(s, OP_JMPNIL, cursp(), val); } tree = tree->cdr->cdr->car; if (tree) { if (tree->car) {             n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14); if (n < 0) {               n = 15; push(); } } if (tree->cdr->car) {        if (n == 14) { pop_n(n); genop_2(s, OP_ARRAY, cursp(), n); push(); n = 15; } gen_hash(s, tree->cdr->car->cdr, VAL, 0); if (n < 14) { n++; } else { pop_n(2); genop_2(s, OP_ARYPUSH, cursp(), 1); } push(); } } if (rhs) { codegen(s, rhs, VAL); pop(); } else { gen_move(s, cursp(), sp, 0); } if (val) { gen_move(s, top, cursp(), 1); } if (n < 15) { n++; if (n == 15) { pop_n(14); genop_2(s, OP_ARRAY, cursp(), 15); } } else { pop(); genop_2(s, OP_ARYPUSH, cursp(), 1); } s->sp = call; if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) { genop_1(s, OP_SETIDX, cursp()); } else { genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n); } if (safe) { dispatch(s, skip); } s->sp = top; } break; case NODE_MASGN: gen_massignment(s, tree->car, sp, val); break; case NODE_NIL: break; default: codegen_error(s, ""unknown lhs""); break; } if (val) push(); }"
"static int jpc_dec_tileinit(jpc_dec_t *dec, jpc_dec_tile_t *tile) { jpc_dec_tcomp_t *tcomp; int compno; int rlvlno; jpc_dec_rlvl_t *rlvl; jpc_dec_band_t *band; jpc_dec_prc_t *prc; int bndno; jpc_tsfb_band_t *bnd; int bandno; jpc_dec_ccp_t *ccp; int prccnt; jpc_dec_cblk_t *cblk; int cblkcnt; uint_fast32_t tlprcxstart; uint_fast32_t tlprcystart; uint_fast32_t brprcxend; uint_fast32_t brprcyend; uint_fast32_t tlcbgxstart; uint_fast32_t tlcbgystart; uint_fast32_t brcbgxend; uint_fast32_t brcbgyend; uint_fast32_t cbgxstart; uint_fast32_t cbgystart; uint_fast32_t cbgxend; uint_fast32_t cbgyend; uint_fast32_t tlcblkxstart; uint_fast32_t tlcblkystart; uint_fast32_t brcblkxend; uint_fast32_t brcblkyend; uint_fast32_t cblkxstart; uint_fast32_t cblkystart; uint_fast32_t cblkxend; uint_fast32_t cblkyend; uint_fast32_t tmpxstart; uint_fast32_t tmpystart; uint_fast32_t tmpxend; uint_fast32_t tmpyend; jpc_dec_cp_t *cp; jpc_tsfb_band_t bnds[64]; jpc_pchg_t *pchg; int pchgno; jpc_dec_cmpt_t *cmpt; cp = tile->cp; tile->realmode = 0; if (cp->mctid == JPC_MCT_ICT) { tile->realmode = 1; } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { ccp = &tile->cp->ccps[compno]; if (ccp->qmfbid == JPC_COX_INS) { tile->realmode = 1; } tcomp->numrlvls = ccp->numrlvls; if (!(tcomp->rlvls = jas_alloc2(tcomp->numrlvls, sizeof(jpc_dec_rlvl_t)))) { return -1; } if (!(tcomp->data = jas_seq2d_create(JPC_CEILDIV(tile->xstart, cmpt->hstep), JPC_CEILDIV(tile->ystart, cmpt->vstep), JPC_CEILDIV(tile->xend, cmpt->hstep), JPC_CEILDIV(tile->yend, cmpt->vstep)))) { return -1; } if (!(tcomp->tsfb = jpc_cod_gettsfb(ccp->qmfbid, tcomp->numrlvls - 1))) { return -1; } { jpc_tsfb_getbands(tcomp->tsfb, jas_seq2d_xstart(tcomp->data), jas_seq2d_ystart(tcomp->data), jas_seq2d_xend(tcomp->data), jas_seq2d_yend(tcomp->data), bnds); } for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls; ++rlvlno, ++rlvl) { rlvl->bands = 0; rlvl->xstart = JPC_CEILDIVPOW2(tcomp->xstart, tcomp->numrlvls - 1 - rlvlno); rlvl->ystart = JPC_CEILDIVPOW2(tcomp->ystart, tcomp->numrlvls - 1 - rlvlno); rlvl->xend = JPC_CEILDIVPOW2(tcomp->xend, tcomp->numrlvls - 1 - rlvlno); rlvl->yend = JPC_CEILDIVPOW2(tcomp->yend, tcomp->numrlvls - 1 - rlvlno); rlvl->prcwidthexpn = ccp->prcwidthexpns[rlvlno]; rlvl->prcheightexpn = ccp->prcheightexpns[rlvlno]; tlprcxstart = JPC_FLOORDIVPOW2(rlvl->xstart, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; tlprcystart = JPC_FLOORDIVPOW2(rlvl->ystart, rlvl->prcheightexpn) << rlvl->prcheightexpn; brprcxend = JPC_CEILDIVPOW2(rlvl->xend, rlvl->prcwidthexpn) << rlvl->prcwidthexpn; brprcyend = JPC_CEILDIVPOW2(rlvl->yend, rlvl->prcheightexpn) << rlvl->prcheightexpn; rlvl->numhprcs = (brprcxend - tlprcxstart) >> rlvl->prcwidthexpn; rlvl->numvprcs = (brprcyend - tlprcystart) >> rlvl->prcheightexpn; rlvl->numprcs = rlvl->numhprcs * rlvl->numvprcs; if (rlvl->xstart >= rlvl->xend || rlvl->ystart >= rlvl->yend) { rlvl->bands = 0; rlvl->numprcs = 0; rlvl->numhprcs = 0; rlvl->numvprcs = 0; continue; } if (!rlvlno) { tlcbgxstart = tlprcxstart; tlcbgystart = tlprcystart; brcbgxend = brprcxend; brcbgyend = brprcyend; rlvl->cbgwidthexpn = rlvl->prcwidthexpn; rlvl->cbgheightexpn = rlvl->prcheightexpn; } else { tlcbgxstart = JPC_CEILDIVPOW2(tlprcxstart, 1); tlcbgystart = JPC_CEILDIVPOW2(tlprcystart, 1); brcbgxend = JPC_CEILDIVPOW2(brprcxend, 1); brcbgyend = JPC_CEILDIVPOW2(brprcyend, 1); rlvl->cbgwidthexpn = rlvl->prcwidthexpn - 1; rlvl->cbgheightexpn = rlvl->prcheightexpn - 1; } rlvl->cblkwidthexpn = JAS_MIN(ccp->cblkwidthexpn, rlvl->cbgwidthexpn); rlvl->cblkheightexpn = JAS_MIN(ccp->cblkheightexpn, rlvl->cbgheightexpn); rlvl->numbands = (!rlvlno) ? 1 : 3; if (!(rlvl->bands = jas_alloc2(rlvl->numbands, sizeof(jpc_dec_band_t)))) { return -1; } for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) { bndno = (!rlvlno) ? 0 : (3 * (rlvlno - 1) + bandno + 1); bnd = &bnds[bndno]; band->orient = bnd->orient; band->stepsize = ccp->stepsizes[bndno]; band->analgain = JPC_NOMINALGAIN(ccp->qmfbid, tcomp->numrlvls - 1, rlvlno, band->orient); band->absstepsize = jpc_calcabsstepsize(band->stepsize, cmpt->prec + band->analgain); band->numbps = ccp->numguardbits + JPC_QCX_GETEXPN(band->stepsize) - 1; band->roishift = (ccp->roishift + band->numbps >= JPC_PREC) ? (JPC_PREC - 1 - band->numbps) : ccp->roishift; band->data = 0; band->prcs = 0; if (bnd->xstart == bnd->xend || bnd->ystart == bnd->yend) { continue; } if (!(band->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(band->data, tcomp->data, bnd->locxstart, bnd->locystart, bnd->locxend, bnd->locyend); jas_seq2d_setshift(band->data, bnd->xstart, bnd->ystart); assert(rlvl->numprcs); if (!(band->prcs = jas_alloc2(rlvl->numprcs, sizeof(jpc_dec_prc_t)))) { return -1; } cbgxstart = tlcbgxstart; cbgystart = tlcbgystart; for (prccnt = rlvl->numprcs, prc = band->prcs; prccnt > 0; --prccnt, ++prc) { cbgxend = cbgxstart + (1 << rlvl->cbgwidthexpn); cbgyend = cbgystart + (1 << rlvl->cbgheightexpn); prc->xstart = JAS_MAX(cbgxstart, JAS_CAST(uint_fast32_t, jas_seq2d_xstart(band->data))); prc->ystart = JAS_MAX(cbgystart, JAS_CAST(uint_fast32_t, jas_seq2d_ystart(band->data))); prc->xend = JAS_MIN(cbgxend, JAS_CAST(uint_fast32_t, jas_seq2d_xend(band->data))); prc->yend = JAS_MIN(cbgyend, JAS_CAST(uint_fast32_t, jas_seq2d_yend(band->data))); if (prc->xend > prc->xstart && prc->yend > prc->ystart) { tlcblkxstart = JPC_FLOORDIVPOW2(prc->xstart, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; tlcblkystart = JPC_FLOORDIVPOW2(prc->ystart, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; brcblkxend = JPC_CEILDIVPOW2(prc->xend, rlvl->cblkwidthexpn) << rlvl->cblkwidthexpn; brcblkyend = JPC_CEILDIVPOW2(prc->yend, rlvl->cblkheightexpn) << rlvl->cblkheightexpn; prc->numhcblks = (brcblkxend - tlcblkxstart) >> rlvl->cblkwidthexpn; prc->numvcblks = (brcblkyend - tlcblkystart) >> rlvl->cblkheightexpn; prc->numcblks = prc->numhcblks * prc->numvcblks; assert(prc->numcblks > 0); if (!(prc->incltagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->numimsbstagtree = jpc_tagtree_create( prc->numhcblks, prc->numvcblks))) { return -1; } if (!(prc->cblks = jas_alloc2(prc->numcblks, sizeof(jpc_dec_cblk_t)))) { return -1; } cblkxstart = cbgxstart; cblkystart = cbgystart; for (cblkcnt = prc->numcblks, cblk = prc->cblks; cblkcnt > 0;) { cblkxend = cblkxstart + (1 << rlvl->cblkwidthexpn); cblkyend = cblkystart + (1 << rlvl->cblkheightexpn); tmpxstart = JAS_MAX(cblkxstart, prc->xstart); tmpystart = JAS_MAX(cblkystart, prc->ystart); tmpxend = JAS_MIN(cblkxend, prc->xend); tmpyend = JAS_MIN(cblkyend, prc->yend); if (tmpxend > tmpxstart && tmpyend > tmpystart) { cblk->firstpassno = -1; cblk->mqdec = 0; cblk->nulldec = 0; cblk->flags = 0; cblk->numpasses = 0; cblk->segs.head = 0; cblk->segs.tail = 0; cblk->curseg = 0; cblk->numimsbs = 0; cblk->numlenbits = 3; cblk->flags = 0; if (!(cblk->data = jas_seq2d_create(0, 0, 0, 0))) { return -1; } jas_seq2d_bindsub(cblk->data, band->data, tmpxstart, tmpystart, tmpxend, tmpyend); ++cblk; --cblkcnt; } cblkxstart += 1 << rlvl->cblkwidthexpn; if (cblkxstart >= cbgxend) { cblkxstart = cbgxstart; cblkystart += 1 << rlvl->cblkheightexpn; } } } else { prc->cblks = 0; prc->incltagtree = 0; prc->numimsbstagtree = 0; } cbgxstart += 1 << rlvl->cbgwidthexpn; if (cbgxstart >= brcbgxend) { cbgxstart = tlcbgxstart; cbgystart += 1 << rlvl->cbgheightexpn; } } } } } if (!(tile->pi = jpc_dec_pi_create(dec, tile))) { return -1; } for (pchgno = 0; pchgno < jpc_pchglist_numpchgs(tile->cp->pchglist); ++pchgno) { pchg = jpc_pchg_copy(jpc_pchglist_get(tile->cp->pchglist, pchgno)); assert(pchg); jpc_pi_addpchg(tile->pi, pchg); } jpc_pi_init(tile->pi); return 0; }"
"future<fragmented_temporary_buffer> cql_server::connection::read_and_decompress_frame(size_t length, uint8_t flags) { using namespace compression_buffers; if (flags & cql_frame_flags::compression) { if (_compression == cql_compression::lz4) { if (length < 4) { throw std::runtime_error(fmt::format(""CQL frame truncated: expected to have at least 4 bytes, got {}"", length)); } return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) { auto linearization_buffer = bytes_ostream(); int32_t uncomp_len = request_reader(buf.get_istream(), linearization_buffer).read_int(); if (uncomp_len < 0) { throw std::runtime_error(""CQL frame uncompressed length is negative: "" + std::to_string(uncomp_len)); } buf.remove_prefix(4); auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf)); auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) { auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()), in.size(), out.size()); if (ret < 0) { throw std::runtime_error(""CQL frame LZ4 uncompression failure""); } return out.size(); }); on_compression_buffer_use(); return uncomp; }); } else if (_compression == cql_compression::snappy) { return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) { auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf)); size_t uncomp_len; if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) { throw std::runtime_error(""CQL frame Snappy uncompressed size is unknown""); } auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) { size_t output_len = out.size(); if (snappy_uncompress(reinterpret_cast<const char*>(in.data()), in.size(), reinterpret_cast<char*>(out.data()), &output_len) != SNAPPY_OK) { throw std::runtime_error(""CQL frame Snappy uncompression failure""); } return output_len; }); on_compression_buffer_use(); return uncomp; }); } else { throw exceptions::protocol_exception(format(""Unknown compression algorithm"")); } } return _buffer_reader.read_exactly(_read_buf, length); }"
"static Image *ReadTGAImage(const ImageInfo *image_info, ExceptionInfo *exception) { Image *image; MagickBooleanType status; PixelInfo pixel; Quantum index; register Quantum *q; register ssize_t i, x; size_t base, flag, offset, real, skip; ssize_t count, y; TGAInfo tga_info; unsigned char j, k, pixels[4], runlength; unsigned int alpha_bits; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,1,&tga_info.id_length); tga_info.colormap_type=(unsigned char) ReadBlobByte(image); tga_info.image_type=(TGAImageType) ReadBlobByte(image); if ((count != 1) || ((tga_info.image_type != TGAColormap) && (tga_info.image_type != TGARGB) && (tga_info.image_type != TGAMonochrome) && (tga_info.image_type != TGARLEColormap) && (tga_info.image_type != TGARLERGB) && (tga_info.image_type != TGARLEMonochrome)) || (((tga_info.image_type == TGAColormap) || (tga_info.image_type == TGARLEColormap)) && (tga_info.colormap_type == 0))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); tga_info.colormap_index=ReadBlobLSBShort(image); tga_info.colormap_length=ReadBlobLSBShort(image); tga_info.colormap_size=(unsigned char) ReadBlobByte(image); tga_info.x_origin=ReadBlobLSBShort(image); tga_info.y_origin=ReadBlobLSBShort(image); tga_info.width=(unsigned short) ReadBlobLSBShort(image); tga_info.height=(unsigned short) ReadBlobLSBShort(image); tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image); tga_info.attributes=(unsigned char) ReadBlobByte(image); if (EOFBlob(image) != MagickFalse) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) && (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); image->columns=tga_info.width; image->rows=tga_info.height; alpha_bits=(tga_info.attributes & 0x0FU); image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) || (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait; if ((tga_info.image_type != TGAColormap) && (tga_info.image_type != TGARLEColormap)) image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 : (tga_info.bits_per_pixel <= 16) ? 5 : (tga_info.bits_per_pixel == 24) ? 8 : (tga_info.bits_per_pixel == 32) ? 8 : 8); else image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 : (tga_info.colormap_size <= 16) ? 5 : (tga_info.colormap_size == 24) ? 8 : (tga_info.colormap_size == 32) ? 8 : 8); if ((tga_info.image_type == TGAColormap) || (tga_info.image_type == TGAMonochrome) || (tga_info.image_type == TGARLEColormap) || (tga_info.image_type == TGARLEMonochrome)) image->storage_class=PseudoClass; image->compression=NoCompression; if ((tga_info.image_type == TGARLEColormap) || (tga_info.image_type == TGARLEMonochrome) || (tga_info.image_type == TGARLERGB)) image->compression=RLECompression; if (image->storage_class == PseudoClass) { if (tga_info.colormap_type != 0) image->colors=tga_info.colormap_index+tga_info.colormap_length; else { size_t one; one=1; image->colors=one << tga_info.bits_per_pixel; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } } if (tga_info.id_length != 0) { char *comment; size_t length; length=(size_t) tga_info.id_length; comment=(char *) NULL; if (~length >= (MagickPathExtent-1)) comment=(char *) AcquireQuantumMemory(length+MagickPathExtent, sizeof(*comment)); if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment); comment[tga_info.id_length]='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); } if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(image); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); (void) ResetMagickMemory(&pixel,0,sizeof(pixel)); pixel.alpha=(MagickRealType) OpaqueAlpha; if (tga_info.colormap_type != 0) { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (i=0; i < (ssize_t) tga_info.colormap_index; i++) image->colormap[i]=pixel; for ( ; i < (ssize_t) image->colors; i++) { switch (tga_info.colormap_size) { case 8: default: { pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.green=pixel.red; pixel.blue=pixel.red; break; } case 15: case 16: { QuantumAny range; j=(unsigned char) ReadBlobByte(image); k=(unsigned char) ReadBlobByte(image); range=GetQuantumRange(5UL); pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2, range); pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range); pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range); break; } case 24: { pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); break; } case 32: { pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); break; } } image->colormap[i]=pixel; } } base=0; flag=0; skip=MagickFalse; real=0; index=0; runlength=0; offset=0; for (y=0; y < (ssize_t) image->rows; y++) { real=offset; if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0) real=image->rows-real-1; q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { if ((tga_info.image_type == TGARLEColormap) || (tga_info.image_type == TGARLERGB) || (tga_info.image_type == TGARLEMonochrome)) { if (runlength != 0) { runlength--; skip=flag != 0; } else { count=ReadBlob(image,1,&runlength); if (count != 1) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); flag=runlength & 0x80; if (flag != 0) runlength-=128; skip=MagickFalse; } } if (skip == MagickFalse) switch (tga_info.bits_per_pixel) { case 8: default: { index=(Quantum) ReadBlobByte(image); if (tga_info.colormap_type != 0) pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image, (ssize_t) index,exception)]; else { pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char) index); pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char) index); pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char) index); } break; } case 15: case 16: { QuantumAny range; if (ReadBlob(image,2,pixels) != 2) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); j=pixels[0]; k=pixels[1]; range=GetQuantumRange(5UL); pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2, range); pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL* (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range); pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range); if (image->alpha_trait != UndefinedPixelTrait) pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum) TransparentAlpha : (Quantum) OpaqueAlpha); if (image->storage_class == PseudoClass) index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+ j,exception); break; } case 24: { if (ReadBlob(image,3,pixels) != 3) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]); pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]); pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]); break; } case 32: { if (ReadBlob(image,4,pixels) != 4) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]); pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]); pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]); pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]); break; } } if (status == MagickFalse) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); if (image->storage_class == PseudoClass) SetPixelIndex(image,index,q); SetPixelRed(image,ClampToQuantum(pixel.red),q); SetPixelGreen(image,ClampToQuantum(pixel.green),q); SetPixelBlue(image,ClampToQuantum(pixel.blue),q); if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q); q+=GetPixelChannels(image); } if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2) offset+=2; else offset++; if (offset >= image->rows) { base++; offset=base; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) { ecc_25519_work_t s2, work; ecc_int256_t w, tmp; ecc_25519_scalarmult(&s2, &ctx->u2, pubkey); ecc_25519_add(&work, &ctx->s1, &s2); ecc_25519_store_xy_legacy(&w, NULL, &work); ecc_25519_gf_sub(&tmp, &ctx->r, &w); return ecc_25519_gf_is_zero(&tmp); }"
"static bool_t ept_split_super_page(struct p2m_domain *p2m, ept_entry_t *ept_entry, unsigned int level, unsigned int target) { ept_entry_t new_ept, *table; uint64_t trunk; unsigned int i; bool_t rv = 1; if ( level <= target ) return 1; ASSERT(is_epte_superpage(ept_entry)); if ( !ept_set_middle_entry(p2m, &new_ept) ) return 0; table = map_domain_page(_mfn(new_ept.mfn)); trunk = 1UL << ((level - 1) * EPT_TABLE_ORDER); for ( i = 0; i < EPT_PAGETABLE_ENTRIES; i++ ) { ept_entry_t *epte = table + i; *epte = *ept_entry; epte->sp = (level > 1); epte->mfn += i * trunk; epte->snp = is_iommu_enabled(p2m->domain) && iommu_snoop; epte->suppress_ve = 1; ept_p2m_type_to_flags(p2m, epte); if ( (level - 1) == target ) continue; ASSERT(is_epte_superpage(epte)); if ( !(rv = ept_split_super_page(p2m, epte, level - 1, target)) ) break; } unmap_domain_page(table); *ept_entry = new_ept; return rv; }"
"static int sg_common_write(Sg_fd * sfp, Sg_request * srp, unsigned char *cmnd, int timeout, int blocking) { int k, at_head; Sg_device *sdp = sfp->parentdp; sg_io_hdr_t *hp = &srp->header; srp->data.cmd_opcode = cmnd[0]; hp->status = 0; hp->masked_status = 0; hp->msg_status = 0; hp->info = 0; hp->host_status = 0; hp->driver_status = 0; hp->resid = 0; SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp, ""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"", (int) cmnd[0], (int) hp->cmd_len)); k = sg_start_req(srp, cmnd); if (k) { SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp, ""sg_common_write: start_req err=%d\n"", k)); sg_finish_rem_req(srp); return k; } if (atomic_read(&sdp->detaching)) { if (srp->bio) blk_end_request_all(srp->rq, -EIO); sg_finish_rem_req(srp); return -ENODEV; } hp->duration = jiffies_to_msecs(jiffies); if (hp->interface_id != '\0' && (SG_FLAG_Q_AT_TAIL & hp->flags)) at_head = 0; else at_head = 1; srp->rq->timeout = timeout; kref_get(&sfp->f_ref);  blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk, srp->rq, at_head, sg_rq_end_io); return 0; }"
"static struct mnt_namespace *create_mnt_ns(struct vfsmount *m) { struct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns); if (!IS_ERR(new_ns)) { struct mount *mnt = real_mount(m); mnt->mnt_ns = new_ns; new_ns->root = mnt; list_add(&mnt->mnt_list, &new_ns->list); } else { mntput(m); } return new_ns; }"
"static multipart_info_t * get_multipart_info(packet_info *pinfo, http_message_info_t *message_info) { char *start_boundary, *start_protocol = NULL; multipart_info_t *m_info = NULL; const char *type = pinfo->match_string; char *parameters; gint dummy; if (type == NULL) { return NULL; } if (message_info == NULL) { return NULL; } if (message_info->media_str == NULL) { return NULL; } parameters = unfold_and_compact_mime_header(message_info->media_str, &dummy); start_boundary = ws_find_media_type_parameter(wmem_packet_scope(), parameters, ""boundary""); if(!start_boundary) { return NULL; } if(strncmp(type, ""multipart/encrypted"", sizeof(""multipart/encrypted"")-1) == 0) { start_protocol = ws_find_media_type_parameter(wmem_packet_scope(), parameters, ""protocol""); if(!start_protocol) { g_free(start_boundary); return NULL; } } m_info = wmem_new(wmem_packet_scope(), multipart_info_t); m_info->type = type; m_info->boundary = start_boundary; m_info->boundary_length = (guint)strlen(start_boundary); if(start_protocol) { m_info->protocol = start_protocol; m_info->protocol_length = (guint)strlen(start_protocol); } else { m_info->protocol = NULL; m_info->protocol_length = -1; } m_info->orig_content_type = NULL; m_info->orig_parameters = NULL; return m_info; }"
"void SMsgWriter::writeFence(rdr::U32 flags, unsigned len, const char data[]) { if (!cp->supportsFence) throw Exception(""Client does not support fences""); if (len > 64) throw Exception(""Too large fence payload""); if ((flags & ~fenceFlagsSupported) != 0) throw Exception(""Unknown fence flags""); startMsg(msgTypeServerFence); os->pad(3); os->writeU32(flags); os->writeU8(len); os->writeBytes(data, len); endMsg(); }"
"struct inode *ext4_iget(struct super_block *sb, unsigned long ino) { struct ext4_iloc iloc; struct ext4_inode *raw_inode; struct ext4_inode_info *ei; struct inode *inode; journal_t *journal = EXT4_SB(sb)->s_journal; long ret; loff_t size; int block; uid_t i_uid; gid_t i_gid; projid_t i_projid; inode = iget_locked(sb, ino); if (!inode) return ERR_PTR(-ENOMEM); if (!(inode->i_state & I_NEW)) return inode; ei = EXT4_I(inode); iloc.bh = NULL; ret = __ext4_get_inode_loc(inode, &iloc, 0); if (ret < 0) goto bad_inode; raw_inode = ext4_raw_inode(&iloc); if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) { ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize); if (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > EXT4_INODE_SIZE(inode->i_sb) || (ei->i_extra_isize & 3)) { EXT4_ERROR_INODE(inode, ""bad extra_isize %u (inode size %u)"", ei->i_extra_isize, EXT4_INODE_SIZE(inode->i_sb)); ret = -EFSCORRUPTED; goto bad_inode; } } else ei->i_extra_isize = 0; if (ext4_has_metadata_csum(sb)) { struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb); __u32 csum; __le32 inum = cpu_to_le32(inode->i_ino); __le32 gen = raw_inode->i_generation; csum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum, sizeof(inum)); ei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen, sizeof(gen)); } if (!ext4_inode_csum_verify(inode, raw_inode, ei)) { EXT4_ERROR_INODE(inode, ""checksum invalid""); ret = -EFSBADCRC; goto bad_inode; } inode->i_mode = le16_to_cpu(raw_inode->i_mode); i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low); i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low); if (ext4_has_feature_project(sb) && EXT4_INODE_SIZE(sb) > EXT4_GOOD_OLD_INODE_SIZE && EXT4_FITS_IN_INODE(raw_inode, ei, i_projid)) i_projid = (projid_t)le32_to_cpu(raw_inode->i_projid); else i_projid = EXT4_DEF_PROJID; if (!(test_opt(inode->i_sb, NO_UID32))) { i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16; i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16; } i_uid_write(inode, i_uid); i_gid_write(inode, i_gid); ei->i_projid = make_kprojid(&init_user_ns, i_projid); set_nlink(inode, le16_to_cpu(raw_inode->i_links_count)); ext4_clear_state_flags(ei); ei->i_inline_off = 0; ei->i_dir_start_lookup = 0; ei->i_dtime = le32_to_cpu(raw_inode->i_dtime); if (inode->i_nlink == 0) { if ((inode->i_mode == 0 || !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) && ino != EXT4_BOOT_LOADER_INO) { ret = -ESTALE; goto bad_inode; } } ei->i_flags = le32_to_cpu(raw_inode->i_flags); inode->i_blocks = ext4_inode_blocks(raw_inode, ei); ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo); if (ext4_has_feature_64bit(sb)) ei->i_file_acl |= ((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32; inode->i_size = ext4_isize(sb, raw_inode); if ((size = i_size_read(inode)) < 0) { EXT4_ERROR_INODE(inode, ""bad i_size value: %lld"", size); ret = -EFSCORRUPTED; goto bad_inode; } ei->i_disksize = inode->i_size; #ifdef CONFIG_QUOTA ei->i_reserved_quota = 0; #endif inode->i_generation = le32_to_cpu(raw_inode->i_generation); ei->i_block_group = iloc.block_group; ei->i_last_alloc_group = ~0; for (block = 0; block < EXT4_N_BLOCKS; block++) ei->i_data[block] = raw_inode->i_block[block]; INIT_LIST_HEAD(&ei->i_orphan); if (journal) { transaction_t *transaction; tid_t tid; read_lock(&journal->j_state_lock); if (journal->j_running_transaction) transaction = journal->j_running_transaction; else transaction = journal->j_committing_transaction; if (transaction) tid = transaction->t_tid; else tid = journal->j_commit_sequence; read_unlock(&journal->j_state_lock); ei->i_sync_tid = tid; ei->i_datasync_tid = tid; } if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) { if (ei->i_extra_isize == 0) { BUILD_BUG_ON(sizeof(struct ext4_inode) & 3); ei->i_extra_isize = sizeof(struct ext4_inode) - EXT4_GOOD_OLD_INODE_SIZE; } else { ext4_iget_extra_inode(inode, raw_inode, ei); } } EXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode); EXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode); EXT4_INODE_GET_XTIME(i_atime, inode, raw_inode); EXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode); if (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) { u64 ivers = le32_to_cpu(raw_inode->i_disk_version); if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) { if (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi)) ivers |= (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32; } inode_set_iversion_queried(inode, ivers); } ret = 0; if (ei->i_file_acl && !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) { EXT4_ERROR_INODE(inode, ""bad extended attribute block %llu"", ei->i_file_acl); ret = -EFSCORRUPTED; goto bad_inode; } else if (!ext4_has_inline_data(inode)) { if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) { if ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || (S_ISLNK(inode->i_mode) && !ext4_inode_is_fast_symlink(inode)))) ret = ext4_ext_check_inode(inode); } else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || (S_ISLNK(inode->i_mode) && !ext4_inode_is_fast_symlink(inode))) { ret = ext4_ind_check_inode(inode); } } if (ret) goto bad_inode; if (S_ISREG(inode->i_mode)) { inode->i_op = &ext4_file_inode_operations; inode->i_fop = &ext4_file_operations; ext4_set_aops(inode); } else if (S_ISDIR(inode->i_mode)) { inode->i_op = &ext4_dir_inode_operations; inode->i_fop = &ext4_dir_operations; } else if (S_ISLNK(inode->i_mode)) { if (ext4_encrypted_inode(inode)) { inode->i_op = &ext4_encrypted_symlink_inode_operations; ext4_set_aops(inode); } else if (ext4_inode_is_fast_symlink(inode)) { inode->i_link = (char *)ei->i_data; inode->i_op = &ext4_fast_symlink_inode_operations; nd_terminate_link(ei->i_data, inode->i_size, sizeof(ei->i_data) - 1); } else { inode->i_op = &ext4_symlink_inode_operations; ext4_set_aops(inode); } inode_nohighmem(inode); } else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) || S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) { inode->i_op = &ext4_special_inode_operations; if (raw_inode->i_block[0]) init_special_inode(inode, inode->i_mode, old_decode_dev(le32_to_cpu(raw_inode->i_block[0]))); else init_special_inode(inode, inode->i_mode, new_decode_dev(le32_to_cpu(raw_inode->i_block[1]))); } else if (ino == EXT4_BOOT_LOADER_INO) { make_bad_inode(inode); } else { ret = -EFSCORRUPTED; EXT4_ERROR_INODE(inode, ""bogus i_mode (%o)"", inode->i_mode); goto bad_inode; } brelse(iloc.bh); ext4_set_inode_flags(inode); unlock_new_inode(inode); return inode; bad_inode: brelse(iloc.bh); iget_failed(inode); return ERR_PTR(ret); }"
"s32_rtw_init_xmit_priv(struct xmit_priv *pxmitpriv, struct adapter *padapter) { int i; struct xmit_buf *pxmitbuf; struct xmit_frame *pxframe; intres = _SUCCESS; u32 max_xmit_extbuf_size = MAX_XMIT_EXTBUF_SZ; u32 num_xmit_extbuf = NR_XMIT_EXTBUFF; spin_lock_init(&pxmitpriv->lock); sema_init(&pxmitpriv->terminate_xmitthread_sema, 0); pxmitpriv->adapter = padapter; rtw_init_queue(&pxmitpriv->be_pending); rtw_init_queue(&pxmitpriv->bk_pending); rtw_init_queue(&pxmitpriv->vi_pending); rtw_init_queue(&pxmitpriv->vo_pending); rtw_init_queue(&pxmitpriv->bm_pending); rtw_init_queue(&pxmitpriv->free_xmit_queue); pxmitpriv->pallocated_frame_buf = vzalloc(NR_XMITFRAME * sizeof(struct xmit_frame) + 4); if (!pxmitpriv->pallocated_frame_buf) { pxmitpriv->pxmit_frame_buf = NULL; res = _FAIL; goto exit; } pxmitpriv->pxmit_frame_buf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_frame_buf), 4); pxframe = (struct xmit_frame *)pxmitpriv->pxmit_frame_buf; for (i = 0; i < NR_XMITFRAME; i++) { INIT_LIST_HEAD(&pxframe->list); pxframe->padapter = padapter; pxframe->frame_tag = NULL_FRAMETAG; pxframe->pkt = NULL; pxframe->buf_addr = NULL; pxframe->pxmitbuf = NULL; list_add_tail(&pxframe->list, &pxmitpriv->free_xmit_queue.queue); pxframe++; } pxmitpriv->free_xmitframe_cnt = NR_XMITFRAME; pxmitpriv->frag_len = MAX_FRAG_THRESHOLD; rtw_init_queue(&pxmitpriv->free_xmitbuf_queue); rtw_init_queue(&pxmitpriv->pending_xmitbuf_queue); pxmitpriv->pallocated_xmitbuf = vzalloc(NR_XMITBUFF * sizeof(struct xmit_buf) + 4); if (!pxmitpriv->pallocated_xmitbuf) { res = _FAIL; goto exit; } pxmitpriv->pxmitbuf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_xmitbuf), 4); pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmitbuf; for (i = 0; i < NR_XMITBUFF; i++) { INIT_LIST_HEAD(&pxmitbuf->list); pxmitbuf->priv_data = NULL; pxmitbuf->padapter = padapter; pxmitbuf->ext_tag = false; res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ)); if (res == _FAIL) { msleep(10); res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, (MAX_XMITBUF_SZ + XMITBUF_ALIGN_SZ)); if (res == _FAIL) goto exit; } pxmitbuf->flags = XMIT_VO_QUEUE; list_add_tail(&pxmitbuf->list, &pxmitpriv->free_xmitbuf_queue.queue); pxmitbuf++; } pxmitpriv->free_xmitbuf_cnt = NR_XMITBUFF; rtw_init_queue(&pxmitpriv->free_xmit_extbuf_queue); pxmitpriv->pallocated_xmit_extbuf = vzalloc(num_xmit_extbuf * sizeof(struct xmit_buf) + 4); if (!pxmitpriv->pallocated_xmit_extbuf) { res = _FAIL; goto exit; } pxmitpriv->pxmit_extbuf = (u8 *)N_BYTE_ALIGMENT((size_t)(pxmitpriv->pallocated_xmit_extbuf), 4); pxmitbuf = (struct xmit_buf *)pxmitpriv->pxmit_extbuf; for (i = 0; i < num_xmit_extbuf; i++) { INIT_LIST_HEAD(&pxmitbuf->list); pxmitbuf->priv_data = NULL; pxmitbuf->padapter = padapter; pxmitbuf->ext_tag = true; res = rtw_os_xmit_resource_alloc(padapter, pxmitbuf, max_xmit_extbuf_size + XMITBUF_ALIGN_SZ); if (res == _FAIL) { res = _FAIL; goto exit; } list_add_tail(&pxmitbuf->list, &pxmitpriv->free_xmit_extbuf_queue.queue); pxmitbuf++; } pxmitpriv->free_xmit_extbuf_cnt = num_xmit_extbuf; rtw_alloc_hwxmits(padapter); rtw_init_hwxmits(pxmitpriv->hwxmits, pxmitpriv->hwxmit_entry); for (i = 0; i < 4; i++) pxmitpriv->wmm_para_seq[i] = i; pxmitpriv->txirp_cnt = 1; sema_init(&pxmitpriv->tx_retevt, 0); pxmitpriv->beq_cnt = 0; pxmitpriv->bkq_cnt = 0; pxmitpriv->viq_cnt = 0; pxmitpriv->voq_cnt = 0; pxmitpriv->ack_tx = false; mutex_init(&pxmitpriv->ack_tx_mutex); rtw_sctx_init(&pxmitpriv->ack_tx_ops, 0); rtl8188eu_init_xmit_priv(padapter); exit: return res; }"
"void printIFD(std::ostream& out, PrintStructureOption option, uint64_t dir_offset, int depth) { BasicIo& io = Image::io(); if (depth > 200) { out << Internal::indent(depth) << ""Maximum indentation depth exceeded."" << std::endl; return; } depth++; bool bFirst  = true; bool bPrint = true; do { io.seek(static_cast<int64>(dir_offset), BasicIo::beg); const uint64_t entries = readData(header_.format() == Header::StandardTiff? 2: 8); const bool tooBig = entries > 500; if ( bFirst && bPrint ) { out << Internal::indent(depth) << ""STRUCTURE OF BIGTIFF FILE "" << io.path() << std::endl; if (tooBig) out << Internal::indent(depth) << ""entries = "" << entries << std::endl; } if (tooBig) break; for ( uint64_t i = 0; i < entries; i ++ ) { if ( bFirst && bPrint ) out << Internal::indent(depth) << "" address |    tag                           |     "" << "" type |    count |    offset | value\n""; bFirst = false; const uint16_t tag   = (uint16_t) readData(2); const uint16_t type  = (uint16_t) readData(2); const uint64_t count = readData(dataSize_); const DataBuf  data  = io.read(dataSize_);         std::string sp = """" ;  const uint64_t kount  = isStringType(type)? (count > 32 ? 32 : count)                                                             : count > 5              ? 5 : count ; const uint32_t pad    = isStringType(type) ? 1 : 0; const uint32_t size   = isStringType(type) ? 1 : is2ByteType(type)  ? 2 : is4ByteType(type)  ? 4 : is8ByteType(type)  ? 8 : 1; if (count != 0) { if (size > std::numeric_limits<uint64_t>::max() / count) { throw Error(kerInvalidMalloc);                                             } } if (size * count > std::numeric_limits<uint64_t>::max() - pad) throw Error(kerInvalidMalloc);              const uint64_t allocate = size*count + pad; if ( allocate > io.size() ) { throw Error(kerInvalidMalloc); } DataBuf buf(static_cast<long>(allocate)); const uint64_t offset = header_.format() == Header::StandardTiff? byteSwap4(data, 0, doSwap_): byteSwap8(data, 0, doSwap_); const bool usePointer = (size_t) count*size > (size_t) dataSize_; if ( usePointer )                                                      { size_t   restore = io.tell();                                          io.seek(static_cast<int64>(offset), BasicIo::beg);                                         io.read(buf.pData_, (long) count * size);                                     io.seek(restore, BasicIo::beg);                                    } else                                  std::memcpy(buf.pData_, data.pData_, (size_t) count * size);      if ( bPrint ) { const uint64_t entrySize = header_.format() == Header::StandardTiff? 12: 20; const uint64_t address = dir_offset + 2 + i * entrySize; out << Internal::indent(depth) << Internal::stringFormat(""%8u | %#06x %-25s |%10s |%9u |"", static_cast<size_t>(address), tag, tagName(tag).c_str(), typeName(type), count) <<(usePointer ? Internal::stringFormat(""%10u | "",(size_t)offset) : Internal::stringFormat(""%10s | "","""")) ; if ( isShortType(type) ) { for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap2(buf, k*size, doSwap_); sp = "" ""; } } else if ( isLongType(type) ) { for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap4(buf, k*size, doSwap_); sp = "" ""; } } else if ( isLongLongType(type) ) { for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap8(buf, k*size, doSwap_); sp = "" ""; } } else if ( isRationalType(type) ) { for ( size_t k = 0 ; k < kount ; k++ ) { uint32_t a = byteSwap4(buf, k*size+0, doSwap_); uint32_t b = byteSwap4(buf, k*size+4, doSwap_); out << sp << a << ""/"" << b; sp = "" ""; } } else if ( isStringType(type) ) out << sp << Internal::binaryToString(makeSlice(buf, 0, static_cast<size_t>(kount))); sp = kount == count ? """" : "" ...""; out << sp << std::endl; if ( option == kpsRecursive && (tag == 0x8769  || tag == 0x014a || type == tiffIfd || type == tiffIfd8) ) { for ( size_t k = 0 ; k < count ; k++ ) { const size_t restore = io.tell(); const uint64_t ifdOffset = type == tiffIfd8? byteSwap8(buf, k*size, doSwap_): byteSwap4(buf, k*size, doSwap_); printIFD(out, option, ifdOffset, depth); io.seek(restore, BasicIo::beg); } } else if ( option == kpsRecursive && tag == 0x83bb  ) { if (Safe::add(count, offset) > io.size()) { throw Error(kerCorruptedMetadata); } const size_t restore = io.tell(); io.seek(static_cast<int64>(offset), BasicIo::beg);                                      std::vector<byte> bytes(static_cast<size_t>(count)) ;                                                                          const size_t read_bytes = io.read(&bytes[0], static_cast<long>(count)); io.seek(restore, BasicIo::beg); IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth); } else if ( option == kpsRecursive && tag == 0x927c  && count > 10) { size_t   restore = io.tell();   long jump= 10           ; byte     bytes[20]          ; const char* chars = (const char*) &bytes[0] ; io.seek(static_cast<int64>(dir_offset), BasicIo::beg);                                      io.read(bytes,jump    )     ;                                      bytes[jump]=0               ; if ( ::strcmp(""Nikon"",chars) == 0 ) { std::vector<byte> nikon_bytes(static_cast<size_t>(count - jump)); io.read(&nikon_bytes.at(0), (long)nikon_bytes.size()); MemIo memIo(&nikon_bytes.at(0), (long)count - jump);                                       std::cerr << ""Nikon makernote"" << std::endl; } else { io.seek(0, BasicIo::beg);                                          std::cerr << ""makernote"" << std::endl; printIFD(out,option,offset,depth); } io.seek(restore,BasicIo::beg);                                 } } } const uint64_t nextDirOffset = readData(dataSize_); dir_offset = tooBig ? 0 : nextDirOffset; out.flush(); } while (dir_offset != 0); if ( bPrint ) out << Internal::indent(depth) << ""END "" << io.path() << std::endl; }"
"static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { RBuffer *fbuf = r_buf_ref (buf); struct MACH0_(opts_t) opts; MACH0_(opts_set_default) (&opts, bf); struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts); if (!main_mach0) { return false; } RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0); RKernelCacheObj *obj = NULL; RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0); if (!prelink_range) { goto beach; } obj = R_NEW0 (RKernelCacheObj); if (!obj) { R_FREE (prelink_range); goto beach; } RCFValueDict *prelink_info = NULL; if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) { prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset, prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA); if (!prelink_info) { R_FREE (prelink_range); R_FREE (obj); goto beach; } } if (!pending_bin_files) { pending_bin_files = r_list_new (); if (!pending_bin_files) { R_FREE (prelink_range); R_FREE (obj); R_FREE (prelink_info); goto beach; } } obj->mach0 = main_mach0; obj->rebase_info = rebase_info; obj->prelink_info = prelink_info; obj->cache_buf = fbuf; obj->pa2va_exec = prelink_range->pa2va_exec; obj->pa2va_data = prelink_range->pa2va_data; R_FREE (prelink_range); *bin_obj = obj; r_list_push (pending_bin_files, bf); if (rebase_info || main_mach0->chained_starts) { RIO *io = bf->rbin->iob.io; swizzle_io_read (obj, io); } return true; beach: r_buf_free (fbuf); obj->cache_buf = NULL; MACH0_(mach0_free) (main_mach0); return false; }"
"static int fixup_bpf_calls(struct bpf_verifier_env *env) { struct bpf_prog *prog = env->prog; bool expect_blinding = bpf_jit_blinding_enabled(prog); struct bpf_insn *insn = prog->insnsi; const struct bpf_func_proto *fn; const int insn_cnt = prog->len; const struct bpf_map_ops *ops; struct bpf_insn_aux_data *aux; struct bpf_insn insn_buf[16]; struct bpf_prog *new_prog; struct bpf_map *map_ptr; int i, ret, cnt, delta = 0; for (i = 0; i < insn_cnt; i++, insn++) { if (insn->code == (BPF_ALU64 | BPF_MOD | BPF_X) || insn->code == (BPF_ALU64 | BPF_DIV | BPF_X) || insn->code == (BPF_ALU | BPF_MOD | BPF_X) || insn->code == (BPF_ALU | BPF_DIV | BPF_X)) { bool is64 = BPF_CLASS(insn->code) == BPF_ALU64; bool isdiv = BPF_OP(insn->code) == BPF_DIV; struct bpf_insn *patchlet; struct bpf_insn chk_and_div[] = { BPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) | BPF_JNE | BPF_K, insn->src_reg, 0, 2, 0), BPF_ALU32_REG(BPF_XOR, insn->dst_reg, insn->dst_reg), BPF_JMP_IMM(BPF_JA, 0, 0, 1), *insn, }; struct bpf_insn chk_and_mod[] = { BPF_RAW_INSN((is64 ? BPF_JMP : BPF_JMP32) | BPF_JEQ | BPF_K, insn->src_reg, 0, 1, 0), *insn, }; patchlet = isdiv ? chk_and_div : chk_and_mod; cnt = isdiv ? ARRAY_SIZE(chk_and_div) : ARRAY_SIZE(chk_and_mod); new_prog = bpf_patch_insn_data(env, i + delta, patchlet, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (BPF_CLASS(insn->code) == BPF_LD && (BPF_MODE(insn->code) == BPF_ABS || BPF_MODE(insn->code) == BPF_IND)) { cnt = env->ops->gen_ld_abs(insn, insn_buf); if (cnt == 0 || cnt >= ARRAY_SIZE(insn_buf)) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (insn->code == (BPF_ALU64 | BPF_ADD | BPF_X) || insn->code == (BPF_ALU64 | BPF_SUB | BPF_X)) { const u8 code_add = BPF_ALU64 | BPF_ADD | BPF_X; const u8 code_sub = BPF_ALU64 | BPF_SUB | BPF_X; struct bpf_insn insn_buf[16]; struct bpf_insn *patch = &insn_buf[0]; bool issrc, isneg; u32 off_reg; aux = &env->insn_aux_data[i + delta]; if (!aux->alu_state || aux->alu_state == BPF_ALU_NON_POINTER) continue; isneg = aux->alu_state & BPF_ALU_NEG_VALUE; issrc = (aux->alu_state & BPF_ALU_SANITIZE) == BPF_ALU_SANITIZE_SRC; off_reg = issrc ? insn->src_reg : insn->dst_reg; if (isneg) *patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1); *patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1); *patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg); *patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg); *patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0); *patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63); if (issrc) { *patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX, off_reg); insn->src_reg = BPF_REG_AX; } else { *patch++ = BPF_ALU64_REG(BPF_AND, off_reg, BPF_REG_AX); } if (isneg) insn->code = insn->code == code_add ? code_sub : code_add; *patch++ = *insn; if (issrc && isneg) *patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1); cnt = patch - insn_buf; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (insn->code != (BPF_JMP | BPF_CALL)) continue; if (insn->src_reg == BPF_PSEUDO_CALL) continue; if (insn->imm == BPF_FUNC_get_route_realm) prog->dst_needed = 1; if (insn->imm == BPF_FUNC_get_prandom_u32) bpf_user_rnd_init_once(); if (insn->imm == BPF_FUNC_override_return) prog->kprobe_override = 1; if (insn->imm == BPF_FUNC_tail_call) { prog->cb_access = 1; if (!allow_tail_call_in_subprogs(env)) prog->aux->stack_depth = MAX_BPF_STACK; prog->aux->max_pkt_offset = MAX_PACKET_OFF; insn->imm = 0; insn->code = BPF_JMP | BPF_TAIL_CALL; aux = &env->insn_aux_data[i + delta]; if (env->bpf_capable && !expect_blinding && prog->jit_requested && !bpf_map_key_poisoned(aux) && !bpf_map_ptr_poisoned(aux) && !bpf_map_ptr_unpriv(aux)) { struct bpf_jit_poke_descriptor desc = { .reason = BPF_POKE_REASON_TAIL_CALL, .tail_call.map = BPF_MAP_PTR(aux->map_ptr_state), .tail_call.key = bpf_map_key_immediate(aux), .insn_idx = i + delta, }; ret = bpf_jit_add_poke_descriptor(prog, &desc); if (ret < 0) { verbose(env, ""adding tail call poke descriptor failed\n""); return ret; } insn->imm = ret + 1; continue; } if (!bpf_map_ptr_unpriv(aux)) continue; if (bpf_map_ptr_poisoned(aux)) { verbose(env, ""tail_call abusing map_ptr\n""); return -EINVAL; } map_ptr = BPF_MAP_PTR(aux->map_ptr_state); insn_buf[0] = BPF_JMP_IMM(BPF_JGE, BPF_REG_3, map_ptr->max_entries, 2); insn_buf[1] = BPF_ALU32_IMM(BPF_AND, BPF_REG_3, container_of(map_ptr, struct bpf_array, map)->index_mask); insn_buf[2] = *insn; cnt = 3; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } if (prog->jit_requested && BITS_PER_LONG == 64 && (insn->imm == BPF_FUNC_map_lookup_elem || insn->imm == BPF_FUNC_map_update_elem || insn->imm == BPF_FUNC_map_delete_elem || insn->imm == BPF_FUNC_map_push_elem   || insn->imm == BPF_FUNC_map_pop_elem    || insn->imm == BPF_FUNC_map_peek_elem)) { aux = &env->insn_aux_data[i + delta]; if (bpf_map_ptr_poisoned(aux)) goto patch_call_imm; map_ptr = BPF_MAP_PTR(aux->map_ptr_state); ops = map_ptr->ops; if (insn->imm == BPF_FUNC_map_lookup_elem && ops->map_gen_lookup) { cnt = ops->map_gen_lookup(map_ptr, insn_buf); if (cnt == -EOPNOTSUPP) goto patch_map_ops_generic; if (cnt <= 0 || cnt >= ARRAY_SIZE(insn_buf)) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } BUILD_BUG_ON(!__same_type(ops->map_lookup_elem, (void *(*)(struct bpf_map *map, void *key))NULL)); BUILD_BUG_ON(!__same_type(ops->map_delete_elem, (int (*)(struct bpf_map *map, void *key))NULL)); BUILD_BUG_ON(!__same_type(ops->map_update_elem, (int (*)(struct bpf_map *map, void *key, void *value, u64 flags))NULL)); BUILD_BUG_ON(!__same_type(ops->map_push_elem, (int (*)(struct bpf_map *map, void *value, u64 flags))NULL)); BUILD_BUG_ON(!__same_type(ops->map_pop_elem, (int (*)(struct bpf_map *map, void *value))NULL)); BUILD_BUG_ON(!__same_type(ops->map_peek_elem, (int (*)(struct bpf_map *map, void *value))NULL)); patch_map_ops_generic: switch (insn->imm) { case BPF_FUNC_map_lookup_elem: insn->imm = BPF_CAST_CALL(ops->map_lookup_elem) - __bpf_call_base; continue; case BPF_FUNC_map_update_elem: insn->imm = BPF_CAST_CALL(ops->map_update_elem) - __bpf_call_base; continue; case BPF_FUNC_map_delete_elem: insn->imm = BPF_CAST_CALL(ops->map_delete_elem) - __bpf_call_base; continue; case BPF_FUNC_map_push_elem: insn->imm = BPF_CAST_CALL(ops->map_push_elem) - __bpf_call_base; continue; case BPF_FUNC_map_pop_elem: insn->imm = BPF_CAST_CALL(ops->map_pop_elem) - __bpf_call_base; continue; case BPF_FUNC_map_peek_elem: insn->imm = BPF_CAST_CALL(ops->map_peek_elem) - __bpf_call_base; continue; } goto patch_call_imm; } if (prog->jit_requested && BITS_PER_LONG == 64 && insn->imm == BPF_FUNC_jiffies64) { struct bpf_insn ld_jiffies_addr[2] = { BPF_LD_IMM64(BPF_REG_0, (unsigned long)&jiffies), }; insn_buf[0] = ld_jiffies_addr[0]; insn_buf[1] = ld_jiffies_addr[1]; insn_buf[2] = BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0); cnt = 3; new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt); if (!new_prog) return -ENOMEM; delta    += cnt - 1; env->prog = prog = new_prog; insn      = new_prog->insnsi + i + delta; continue; } patch_call_imm: fn = env->ops->get_func_proto(insn->imm, env->prog); if (!fn->func) { verbose(env, ""kernel subsystem misconfigured func %s#%d\n"", func_id_name(insn->imm), insn->imm); return -EFAULT; } insn->imm = fn->func - __bpf_call_base; } for (i = 0; i < prog->aux->size_poke_tab; i++) { map_ptr = prog->aux->poke_tab[i].tail_call.map; if (!map_ptr->ops->map_poke_track || !map_ptr->ops->map_poke_untrack || !map_ptr->ops->map_poke_run) { verbose(env, ""bpf verifier is misconfigured\n""); return -EINVAL; } ret = map_ptr->ops->map_poke_track(map_ptr, prog->aux); if (ret < 0) { verbose(env, ""tracking tail call prog failed\n""); return ret; } } return 0; }"
"Jsi_RC Jsi_ValueToNumber(Jsi_Interp *interp, Jsi_Value *v) { if (v->vt == JSI_VT_NUMBER) return JSI_OK; Jsi_Number a = Jsi_ValueToNumberInt(interp, v, 0); Jsi_ValueReset(interp, &v); Jsi_ValueMakeNumber(interp, &v, a); return JSI_OK; }"
"static void handle_PORT(ctrl_t *ctrl, char *str) { int a, b, c, d, e, f; char addr[INET_ADDRSTRLEN]; struct sockaddr_in sin; if (ctrl->data_sd > 0) { uev_io_stop(&ctrl->data_watcher); close(ctrl->data_sd); ctrl->data_sd = -1; } sscanf(str, ""%d,%d,%d,%d,%d,%d"", &a, &b, &c, &d, &e, &f); sprintf(addr, ""%d.%d.%d.%d"", a, b, c, d); if (!inet_aton(addr, &(sin.sin_addr))) { ERR(0, ""Invalid address '%s' given to PORT command"", addr); send_msg(ctrl->sd, ""500 Illegal PORT command.\r\n""); return; } strlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address)); ctrl->data_port = e * 256 + f; DBG(""Client PORT command accepted for %s:%d"", ctrl->data_address, ctrl->data_port); send_msg(ctrl->sd, ""200 PORT command successful.\r\n""); }"
"static int register_interfaces(extcap_parameters * extcap_conf, const char *adb_server_ip, unsigned short *adb_server_tcp_port) { static char            packet[PACKET_LENGTH]; static char            helpful_packet[PACKET_LENGTH]; char                  *response; char                  *device_list; gssize                 data_length; gssize                 device_length; socket_handle_t        sock; const char            *adb_transport_serial_templace = ""%04x""""host:transport:%s""; const char            *adb_check_port_templace       = ""%04x""""shell:cat /proc/%s/net/tcp""; const char            *adb_devices            = ""000E""""host:devices-l""; const char            *adb_api_level          = ""0022""""shell:getprop ro.build.version.sdk""; const char            *adb_hcidump_version    = ""0017""""shell:hcidump --version""; const char            *adb_ps_droid_bluetooth = ""0018""""shell:ps droid.bluetooth""; const char            *adb_ps_bluetooth_app   = ""001E""""shell:ps com.android.bluetooth""; const char            *adb_tcpdump_help       = ""0010""""shell:tcpdump -h""; char                   serial_number[SERIAL_NUMBER_LENGTH_MAX]; size_t                 serial_number_length; char                   model_name[MODEL_NAME_LENGTH_MAX]; int                    result; char                  *pos; char                  *i_pos; char                  *model_pos; char                  *device_pos; char                  *prev_pos; int                    api_level; int                    disable_interface; sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) return EXIT_CODE_INVALID_SOCKET_INTERFACES_LIST; device_list = adb_send_and_receive(sock, adb_devices, packet, sizeof(packet), &device_length); closesocket(sock); if (!device_list) { errmsg_print(""ERROR: Cannot get list of interfaces from devices""); return EXIT_CODE_CANNOT_GET_INTERFACES_LIST; } device_list[device_length] = '\0'; pos = (char *) device_list; while (pos < (char *) (device_list + device_length)) { prev_pos = pos; pos = strchr(pos, ' '); i_pos = pos; result = (int) (pos - prev_pos); pos = strchr(pos, '\n') + 1; if (result >= (int) sizeof(serial_number)) { verbose_print(""WARNING: Serial number too long, ignore device\n""); continue; } memcpy(serial_number, prev_pos, result); serial_number[result] = '\0'; serial_number_length = strlen(serial_number); model_name[0] = '\0'; model_pos = g_strstr_len(i_pos, pos - i_pos, ""model:""); if (model_pos) { device_pos = g_strstr_len(i_pos, pos - i_pos, ""device:""); if (device_pos && device_pos - model_pos - 6 - 1 < MODEL_NAME_LENGTH_MAX) { memcpy(model_name, model_pos + 6, device_pos - model_pos - 6 - 1); model_name[device_pos - model_pos - 6 - 1] = '\0'; } } if (model_name[0] == '\0') strcpy(model_name, ""unknown""); verbose_print(""VERBOSE: Processing device: \""%s\"" <%s>\n"" , serial_number, model_name); sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) continue; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet for transport""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_1; } result = adb_send(sock, helpful_packet); if (result) { verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet); closesocket(sock); } else { response = adb_send_and_read(sock, adb_tcpdump_help, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (response) { response[data_length] = '\0'; if (strstr(response,""tcpdump version"")) { new_interface(extcap_conf, INTERFACE_ANDROID_WIFI_TCPDUMP, model_name, serial_number, ""Android WiFi""); } } else { verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet); } } sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) continue; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_2; } result = adb_send(sock, helpful_packet); if (result) { verbose_print(""WARNING: Error while setting adb transport for <%s>\n"", helpful_packet); closesocket(sock); continue; } response = adb_send_and_read(sock, adb_api_level, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response) { verbose_print(""WARNING: Error on socket: <%s>\n"", helpful_packet); continue; } response[data_length] = '\0'; api_level = (int) g_ascii_strtoll(response, NULL, 10); verbose_print(""VERBOSE: Android API Level for %s is %i\n"", serial_number, api_level); if (api_level < 21) { new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_MAIN,   model_name, serial_number, ""Android Logcat Main""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_SYSTEM, model_name, serial_number, ""Android Logcat System""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_RADIO,  model_name, serial_number, ""Android Logcat Radio""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_EVENTS, model_name, serial_number, ""Android Logcat Events""); } else { new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_MAIN,   model_name, serial_number, ""Android Logcat Main""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_SYSTEM, model_name, serial_number, ""Android Logcat System""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_RADIO,  model_name, serial_number, ""Android Logcat Radio""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_EVENTS, model_name, serial_number, ""Android Logcat Events""); new_interface(extcap_conf, INTERFACE_ANDROID_LOGCAT_TEXT_CRASH,  model_name, serial_number, ""Android Logcat Crash""); } if (api_level >= 5 && api_level < 17) { disable_interface = 0; sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) continue; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_3; } result = adb_send(sock, helpful_packet); if (result) { errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet); closesocket(sock); return EXIT_CODE_GENERIC; } response = adb_send_and_read(sock, adb_hcidump_version, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response || data_length < 1) { verbose_print(""WARNING: Error while getting hcidump version by <%s> (%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length); verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number); disable_interface = 1; } else { response[data_length] = '\0'; if (g_ascii_strtoull(response, NULL, 10) == 0) { verbose_print(""VERBOSE: Android hcidump version for %s is unknown\n"", serial_number); disable_interface = 1; } else { verbose_print(""VERBOSE: Android hcidump version for %s is %s\n"", serial_number, response); } } if (!disable_interface) { new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_HCIDUMP, model_name, serial_number, ""Android Bluetooth Hcidump""); } } if (api_level >= 17 && api_level < 21) { disable_interface = 0; sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) continue; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_4; } result = adb_send(sock, helpful_packet); if (result) { errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet); closesocket(sock); return EXIT_CODE_GENERIC; } response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response || data_length < 1) { verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> "" ""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length); verbose_print( ""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number); disable_interface = 1; } else { char  *data_str; char   pid[16]; memset(pid, 0, sizeof(pid)); response[data_length] = '\0'; data_str = strchr(response, '\n'); if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) { verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid); sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) return EXIT_CODE_INVALID_SOCKET_1; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_5; } result = adb_send(sock, helpful_packet); if (result) { errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet); closesocket(sock); return EXIT_CODE_GENERIC; } result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_6; } response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response) { disable_interface = 1; } else { response[data_length] = '\0'; data_str = strchr(response, '\n'); if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""10EA"") == 0) { verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is %s\n"", serial_number, pid + 9); } else { disable_interface = 1; verbose_print(""VERBOSE: Bluedroid External Parser Port for %s is unknown\n"", serial_number); } } } else { disable_interface = 1; verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number); } } if (!disable_interface) { new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_EXTERNAL_PARSER, model_name, serial_number, ""Android Bluetooth External Parser""); } } if (api_level >= 21) { disable_interface = 0; sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) continue; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_7; } result = adb_send(sock, helpful_packet); if (result) { errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet); closesocket(sock); return EXIT_CODE_GENERIC; } if (api_level >= 23) { response = adb_send_and_read(sock, adb_ps_bluetooth_app, helpful_packet, sizeof(helpful_packet), &data_length); }  else response = adb_send_and_read(sock, adb_ps_droid_bluetooth, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response || data_length < 1) { verbose_print(""WARNING: Error while getting Bluetooth application process id by <%s> "" ""(%p len=%""G_GSSIZE_FORMAT"")\n"", adb_hcidump_version, (void*)response, data_length); verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number); disable_interface = 1; } else { char  *data_str; char   pid[16]; memset(pid, 0, sizeof(pid)); response[data_length] = '\0'; data_str = strchr(response, '\n'); if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1) { verbose_print(""VERBOSE: Android Bluetooth application PID for %s is %s\n"", serial_number, pid); sock = adb_connect(adb_server_ip, adb_server_tcp_port); if (sock == INVALID_SOCKET) return EXIT_CODE_INVALID_SOCKET_2; result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_transport_serial_templace, 15 + serial_number_length, serial_number); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_8; } result = adb_send(sock, helpful_packet); if (result) { errmsg_print(""ERROR: Error while setting adb transport for <%s>"", helpful_packet); closesocket(sock); return EXIT_CODE_GENERIC; } result = g_snprintf((char *) helpful_packet, PACKET_LENGTH, adb_check_port_templace, strlen(adb_check_port_templace) - 6 + strlen(pid), pid); if (result <= 0 || result > PACKET_LENGTH) { errmsg_print(""ERROR: Error while completing adb packet""); closesocket(sock); return EXIT_CODE_BAD_SIZE_OF_ASSEMBLED_ADB_PACKET_9; } response = adb_send_and_read(sock, helpful_packet, helpful_packet, sizeof(helpful_packet), &data_length); closesocket(sock); if (!response) { disable_interface = 1; } else { response[data_length] = '\0'; data_str = strchr(response, '\n'); if (data_str && sscanf(data_str, ""%*s %s"", pid) == 1 && strcmp(pid + 9, ""22A8"") == 0) { verbose_print(""VERBOSE: Btsnoop Net Port for %s is %s\n"", serial_number, pid + 9); } else { disable_interface = 1; verbose_print(""VERBOSE: Btsnoop Net Port for %s is unknown\n"", serial_number); } } } else { disable_interface = 1; verbose_print(""VERBOSE: Android Bluetooth application PID for %s is unknown\n"", serial_number); } } if (!disable_interface) { new_interface(extcap_conf, INTERFACE_ANDROID_BLUETOOTH_BTSNOOP_NET, model_name, serial_number, ""Android Bluetooth Btsnoop Net""); } } } return EXIT_CODE_SUCCESS; }"
"int PDFDoc::savePageAs(const GooString &name, int pageNo) { FILE *f; OutStream *outStr; XRef *yRef, *countRef; if (file && file->modificationTimeChangedSinceOpen()) { return errFileChangedSinceOpen; } int rootNum = getXRef()->getNumObjects() + 1; xref->scanSpecialFlags(); unsigned char *fileKey; CryptAlgorithm encAlgorithm; int keyLength; xref->getEncryptionParameters(&fileKey, &encAlgorithm, &keyLength); if (pageNo < 1 || pageNo > getNumPages() || !getCatalog()->getPage(pageNo)) { error(errInternal, -1, ""Illegal pageNo: {0:d}({1:d})"", pageNo, getNumPages()); return errOpenFile; } const PDFRectangle *cropBox = nullptr; if (getCatalog()->getPage(pageNo)->isCropped()) { cropBox = getCatalog()->getPage(pageNo)->getCropBox(); } replacePageDict(pageNo, getCatalog()->getPage(pageNo)->getRotate(), getCatalog()->getPage(pageNo)->getMediaBox(), cropBox); Ref *refPage = getCatalog()->getPageRef(pageNo); Object page = getXRef()->fetch(*refPage); if (!(f = openFile(name.c_str(), ""wb""))) { error(errIO, -1, ""Couldn't open file '{0:t}'"", &name); return errOpenFile; } outStr = new FileOutStream(f, 0); yRef = new XRef(getXRef()->getTrailerDict()); if (secHdlr != nullptr && !secHdlr->isUnencrypted()) { yRef->setEncryption(secHdlr->getPermissionFlags(), secHdlr->getOwnerPasswordOk(), fileKey, keyLength, secHdlr->getEncVersion(), secHdlr->getEncRevision(), encAlgorithm); } countRef = new XRef(); Object *trailerObj = getXRef()->getTrailerDict(); if (trailerObj->isDict()) { markPageObjects(trailerObj->getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } yRef->add(0, 65535, 0, false); writeHeader(outStr, getPDFMajorVersion(), getPDFMinorVersion()); Object infoObj = getXRef()->getDocInfo(); if (infoObj.isDict()) { Dict *infoDict = infoObj.getDict(); markPageObjects(infoDict, yRef, countRef, 0, refPage->num, rootNum + 2); if (trailerObj->isDict()) { Dict *trailerDict = trailerObj->getDict(); const Object &ref = trailerDict->lookupNF(""Info""); if (ref.isRef()) { yRef->add(ref.getRef(), 0, true); if (getXRef()->getEntry(ref.getRef().num)->type == xrefEntryCompressed) { yRef->getEntry(ref.getRef().num)->type = xrefEntryCompressed; } } } } Object catObj = getXRef()->getCatalog(); if (!catObj.isDict()) { fclose(f); delete yRef; delete countRef; delete outStr; error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary""); return errOpenFile; } Dict *catDict = catObj.getDict(); Object pagesObj = catDict->lookup(""Pages""); Object afObj = catDict->lookupNF(""AcroForm"").copy(); if (!afObj.isNull()) { markAcroForm(&afObj, yRef, countRef, 0, refPage->num, rootNum + 2); } Dict *pagesDict = pagesObj.getDict(); Object resourcesObj = pagesDict->lookup(""Resources""); if (resourcesObj.isDict()) { markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } markPageObjects(catDict, yRef, countRef, 0, refPage->num, rootNum + 2); Dict *pageDict = page.getDict(); if (resourcesObj.isNull() && !pageDict->hasKey(""Resources"")) { Object *resourceDictObject = getCatalog()->getPage(pageNo)->getResourceDictObject(); if (resourceDictObject->isDict()) { resourcesObj = resourceDictObject->copy(); markPageObjects(resourcesObj.getDict(), yRef, countRef, 0, refPage->num, rootNum + 2); } } markPageObjects(pageDict, yRef, countRef, 0, refPage->num, rootNum + 2); Object annotsObj = pageDict->lookupNF(""Annots"").copy(); if (!annotsObj.isNull()) { markAnnotations(&annotsObj, yRef, countRef, 0, refPage->num, rootNum + 2); } yRef->markUnencrypted(); writePageObjects(outStr, yRef, 0); yRef->add(rootNum, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum); outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1); for (int j = 0; j < catDict->getLength(); j++) { const char *key = catDict->getKey(j); if (strcmp(key, ""Type"") != 0 && strcmp(key, ""Catalog"") != 0 && strcmp(key, ""Pages"") != 0) { if (j > 0) { outStr->printf("" ""); } Object value = catDict->getValNF(j).copy(); outStr->printf(""/%s "", key); writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } } outStr->printf("">>\nendobj\n""); yRef->add(rootNum + 1, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + 1); outStr->printf(""<< /Type /Pages /Kids [ %d 0 R ] /Count 1 "", rootNum + 2); if (resourcesObj.isDict()) { outStr->printf(""/Resources ""); writeObject(&resourcesObj, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } outStr->printf("">>\n""); outStr->printf(""endobj\n""); yRef->add(rootNum + 2, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + 2); outStr->printf(""<< ""); for (int n = 0; n < pageDict->getLength(); n++) { if (n > 0) { outStr->printf("" ""); } const char *key = pageDict->getKey(n); Object value = pageDict->getValNF(n).copy(); if (strcmp(key, ""Parent"") == 0) { outStr->printf(""/Parent %d 0 R"", rootNum + 1); } else { outStr->printf(""/%s "", key); writeObject(&value, outStr, getXRef(), 0, nullptr, cryptRC4, 0, 0, 0); } } outStr->printf("" >>\nendobj\n""); Goffset uxrefOffset = outStr->getPos(); Ref ref; ref.num = rootNum; ref.gen = 0; Object trailerDict = createTrailerDict(rootNum + 3, false, 0, &ref, getXRef(), name.c_str(), uxrefOffset); writeXRefTableTrailer(std::move(trailerDict), yRef, false , uxrefOffset, outStr, getXRef()); outStr->close(); fclose(f); delete yRef; delete countRef; delete outStr; return errNone; }"
"static int mlx5_fpga_conn_create_cq(struct mlx5_fpga_conn *conn, int cq_size) { struct mlx5_fpga_device *fdev = conn->fdev; struct mlx5_core_dev *mdev = fdev->mdev; u32 temp_cqc[MLX5_ST_SZ_DW(cqc)] = {0}; u32 out[MLX5_ST_SZ_DW(create_cq_out)]; struct mlx5_wq_param wqp; struct mlx5_cqe64 *cqe; int inlen, err, eqn; unsigned int irqn; void *cqc, *in; __be64 *pas; u32 i; cq_size = roundup_pow_of_two(cq_size); MLX5_SET(cqc, temp_cqc, log_cq_size, ilog2(cq_size)); wqp.buf_numa_node = mdev->priv.numa_node; wqp.db_numa_node  = mdev->priv.numa_node; err = mlx5_cqwq_create(mdev, &wqp, temp_cqc, &conn->cq.wq, &conn->cq.wq_ctrl); if (err) return err; for (i = 0; i < mlx5_cqwq_get_size(&conn->cq.wq); i++) { cqe = mlx5_cqwq_get_wqe(&conn->cq.wq, i); cqe->op_own = MLX5_CQE_INVALID << 4 | MLX5_CQE_OWNER_MASK; } inlen = MLX5_ST_SZ_BYTES(create_cq_in) + sizeof(u64) * conn->cq.wq_ctrl.buf.npages; in = kvzalloc(inlen, GFP_KERNEL); if (!in) { err = -ENOMEM; goto err_cqwq; } err = mlx5_vector2eqn(mdev, smp_processor_id(), &eqn, &irqn); if (err) goto err_cqwq; cqc = MLX5_ADDR_OF(create_cq_in, in, cq_context); MLX5_SET(cqc, cqc, log_cq_size, ilog2(cq_size)); MLX5_SET(cqc, cqc, c_eqn, eqn); MLX5_SET(cqc, cqc, uar_page, fdev->conn_res.uar->index); MLX5_SET(cqc, cqc, log_page_size, conn->cq.wq_ctrl.buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT); MLX5_SET64(cqc, cqc, dbr_addr, conn->cq.wq_ctrl.db.dma); pas = (__be64 *)MLX5_ADDR_OF(create_cq_in, in, pas); mlx5_fill_page_frag_array(&conn->cq.wq_ctrl.buf, pas); err = mlx5_core_create_cq(mdev, &conn->cq.mcq, in, inlen, out, sizeof(out)); kvfree(in); if (err) goto err_cqwq; conn->cq.mcq.cqe_sz     = 64; conn->cq.mcq.set_ci_db  = conn->cq.wq_ctrl.db.db; conn->cq.mcq.arm_db     = conn->cq.wq_ctrl.db.db + 1; *conn->cq.mcq.set_ci_db = 0; *conn->cq.mcq.arm_db    = 0; conn->cq.mcq.vector     = 0; conn->cq.mcq.comp       = mlx5_fpga_conn_cq_complete; conn->cq.mcq.event      = mlx5_fpga_conn_cq_event; conn->cq.mcq.irqn       = irqn; conn->cq.mcq.uar        = fdev->conn_res.uar; tasklet_init(&conn->cq.tasklet, mlx5_fpga_conn_cq_tasklet, (unsigned long)conn); mlx5_fpga_dbg(fdev, ""Created CQ #0x%x\n"", conn->cq.mcq.cqn); goto out; err_cqwq: mlx5_wq_destroy(&conn->cq.wq_ctrl); out: return err; }"
"static int ax25_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; ax25_cb *ax25; if (protocol < 0 || protocol > SK_PROTOCOL_MAX) return -EINVAL; if (!net_eq(net, &init_net)) return -EAFNOSUPPORT; switch (sock->type) { case SOCK_DGRAM: if (protocol == 0 || protocol == PF_AX25) protocol = AX25_P_TEXT; break; case SOCK_SEQPACKET: switch (protocol) { case 0: case PF_AX25: protocol = AX25_P_TEXT; break; case AX25_P_SEGMENT: #ifdef CONFIG_INET case AX25_P_ARP: case AX25_P_IP: #endif #ifdef CONFIG_NETROM case AX25_P_NETROM: #endif #ifdef CONFIG_ROSE case AX25_P_ROSE: #endif return -ESOCKTNOSUPPORT; #ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM: if (ax25_protocol_is_registered(AX25_P_NETROM)) return -ESOCKTNOSUPPORT; break; #endif #ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE: if (ax25_protocol_is_registered(AX25_P_ROSE)) return -ESOCKTNOSUPPORT; #endif default: break; } break; case SOCK_RAW: break; default: return -ESOCKTNOSUPPORT; } sk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern); if (sk == NULL) return -ENOMEM; ax25 = ax25_sk(sk)->cb = ax25_create_cb(); if (!ax25) { sk_free(sk); return -ENOMEM; } sock_init_data(sock, sk); sk->sk_destruct = ax25_free_sock; sock->ops    = &ax25_proto_ops; sk->sk_protocol = protocol; ax25->sk    = sk; return 0; }"
"static int gtStripSeparate(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { TIFF* tif = img->tif; tileSeparateRoutine put = img->put.separate; unsigned char *buf = NULL; unsigned char *p0 = NULL, *p1 = NULL, *p2 = NULL, *pa = NULL; uint32 row, y, nrow, rowstoread; tmsize_t pos; tmsize_t scanline; uint32 rowsperstrip, offset_row; uint32 imagewidth = img->width; tmsize_t stripsize; tmsize_t bufsize; int32 fromskew, toskew; int alpha = img->alpha; int ret = 1, flip; uint16 colorchannels; stripsize = TIFFStripSize(tif);   bufsize = _TIFFMultiplySSize(tif,alpha?4:3,stripsize, ""gtStripSeparate""); if (bufsize == 0) { return (0); } flip = setorientation(img); if (flip & FLIP_VERTICALLY) { y = h - 1; toskew = -(int32)(w + w); } else { y = 0; toskew = -(int32)(w - w); } switch( img->photometric ) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: case PHOTOMETRIC_PALETTE: colorchannels = 1; break; default: colorchannels = 3; break; } TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif);   fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += nrow) { rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip; nrow = (row + rowstoread > h ? h - row : rowstoread); offset_row = row + img->row_offset; if( buf == NULL ) { if (_TIFFReadEncodedStripAndAllocBuffer( tif, TIFFComputeStrip(tif, offset_row, 0), (void**) &buf, bufsize, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1) && (buf == NULL || img->stoponerr)) { ret = 0; break; } p0 = buf; if( colorchannels == 1 ) { p2 = p1 = p0; pa = (alpha?(p0+3*stripsize):NULL); } else { p1 = p0 + stripsize; p2 = p1 + stripsize; pa = (alpha?(p2+stripsize):NULL); } } else if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 0), p0, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1) && img->stoponerr) { ret = 0; break; } if (colorchannels > 1  && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 1), p1, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1) && img->stoponerr) { ret = 0; break; } if (colorchannels > 1  && TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, 2), p2, ((row + img->row_offset)%rowsperstrip + nrow) * scanline) == (tmsize_t)(-1) && img->stoponerr) { ret = 0; break; } if (alpha) { if (TIFFReadEncodedStrip(tif, TIFFComputeStrip(tif, offset_row, colorchannels), pa, ((row + img->row_offset)%rowsperstrip + nrow) * scanline)==(tmsize_t)(-1) && img->stoponerr) { ret = 0; break; } } pos = ((row + img->row_offset) % rowsperstrip) * scanline + \ ((tmsize_t) img->col_offset * img->samplesperpixel); (*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, p0 + pos, p1 + pos, p2 + pos, (alpha?(pa+pos):NULL)); y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow); } if (flip & FLIP_HORIZONTALLY) { uint32 line; for (line = 0; line < h; line++) { uint32 *left = raster + (line * w); uint32 *right = left + w - 1; while ( left < right ) { uint32 temp = *left; *left = *right; *right = temp; left++; right--; } } } _TIFFfree(buf); return (ret); }"
"static int add_match_busid(char *busid) { int i; int ret = -1; spin_lock(&busid_table_lock); if (get_busid_idx(busid) >= 0) { ret = 0; goto out; } for (i = 0; i < MAX_BUSID; i++) if (!busid_table[i].name[0]) { strlcpy(busid_table[i].name, busid, BUSID_SIZE); if ((busid_table[i].status != STUB_BUSID_ALLOC) && (busid_table[i].status != STUB_BUSID_REMOV)) busid_table[i].status = STUB_BUSID_ADDED; ret = 0; break; } out: spin_unlock(&busid_table_lock); return ret; }"
"void sh_emulate_unmap_dest(struct vcpu *v, void *addr, unsigned int bytes, struct sh_emulate_ctxt *sh_ctxt) { u32 b1 = bytes, b2 = 0, shflags; shflags = mfn_to_page(sh_ctxt->mfn[0])->shadow_flags; #if (SHADOW_OPTIMIZATIONS & SHOPT_SKIP_VERIFY) if ( sh_ctxt->low_bit_was_clear && !(*(u8 *)addr & _PAGE_PRESENT) && ((!(shflags & SHF_32) && ((unsigned long)addr & 7) == 0 && bytes <= 8) || (!(shflags & (SHF_PAE|SHF_64)) && ((unsigned long)addr & 3) == 0 && bytes <= 4)) ) { ASSERT(!mfn_valid(sh_ctxt->mfn[1])); } else #endif  { if ( unlikely(mfn_valid(sh_ctxt->mfn[1])) ) { b1 = PAGE_SIZE - (((unsigned long)addr) & ~PAGE_MASK); b2 = bytes - b1; ASSERT(b2 < bytes); } if ( likely(b1 > 0) ) sh_validate_guest_pt_write(v, sh_ctxt->mfn[0], addr, b1); if ( unlikely(b2 > 0) ) sh_validate_guest_pt_write(v, sh_ctxt->mfn[1], addr + b1, b2); } paging_mark_dirty(v->domain, sh_ctxt->mfn[0]); if ( unlikely(mfn_valid(sh_ctxt->mfn[1])) ) { paging_mark_dirty(v->domain, sh_ctxt->mfn[1]); vunmap((void *)((unsigned long)addr & PAGE_MASK)); } else unmap_domain_page(addr); atomic_inc(&v->domain->arch.paging.shadow.gtable_dirty_version); }"
"static int dissect_modbus(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data) { proto_tree          *modbus_tree; proto_item          *mi; int                 offset = 0; int*                packet_type = (int*)data; gint                payload_start, payload_len, len; guint8              function_code, exception_code; modbus_pkt_info_t   *pkt_info; if (packet_type == NULL) return 0; len = tvb_captured_length(tvb); if (len == 0) return 0; mi = proto_tree_add_protocol_format(tree, proto_modbus, tvb, offset, len, ""Modbus""); modbus_tree = proto_item_add_subtree(mi, ett_modbus_hdr); function_code = tvb_get_guint8(tvb, offset) & 0x7F; proto_tree_add_item(modbus_tree, hf_modbus_functioncode, tvb, offset, 1, ENC_BIG_ENDIAN); if (!pinfo->fd->flags.visited) { conversation_t       *conversation = NULL; modbus_conversation  *modbus_conv_data = NULL; conversation = find_or_create_conversation(pinfo); modbus_conv_data = (modbus_conversation *)conversation_get_proto_data(conversation, proto_modbus); pkt_info = wmem_new0(wmem_file_scope(), modbus_pkt_info_t); if (modbus_conv_data == NULL){ modbus_conv_data = wmem_new(wmem_file_scope(), modbus_conversation); modbus_conv_data->modbus_request_frame_data = wmem_list_new(wmem_file_scope()); modbus_conv_data->register_format = global_mbus_register_format; conversation_add_proto_data(conversation, proto_modbus, (void *)modbus_conv_data); } pkt_info->register_format = modbus_conv_data->register_format; if (*packet_type == QUERY_PACKET) { modbus_request_info_t    *frame_ptr = wmem_new(wmem_file_scope(), modbus_request_info_t); frame_ptr->fnum = pinfo->num; frame_ptr->function_code = function_code; pkt_info->reg_base = frame_ptr->base_address = tvb_get_ntohs(tvb, 1); pkt_info->num_reg = frame_ptr->num_reg = tvb_get_ntohs(tvb, 3); wmem_list_prepend(modbus_conv_data->modbus_request_frame_data, frame_ptr); } else if (*packet_type == RESPONSE_PACKET) { guint8                req_function_code; guint32               req_frame_num; modbus_request_info_t *request_data; wmem_list_frame_t *frame = wmem_list_head(modbus_conv_data->modbus_request_frame_data); while (frame && !pkt_info->request_found) { request_data = (modbus_request_info_t *)wmem_list_frame_data(frame); req_frame_num = request_data->fnum; req_function_code = request_data->function_code; if ((pinfo->num > req_frame_num) && (req_function_code == function_code)) { pkt_info->reg_base = request_data->base_address; pkt_info->num_reg = request_data->num_reg; pkt_info->request_found = TRUE; pkt_info->req_frame_num = req_frame_num; } frame = wmem_list_frame_next(frame); } } p_add_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0, pkt_info); } else {  pkt_info = (modbus_pkt_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_modbus, 0); } if (tvb_get_guint8(tvb, offset) & 0x80 ) { exception_code = tvb_get_guint8(tvb, offset+1); } else { exception_code = 0; } payload_start = offset + 1; payload_len = len - 1; if (exception_code != 0) { proto_item_set_text(mi, ""Function %u:  %s.  Exception: %s"", function_code, val_to_str_const(function_code, function_code_vals, ""Unknown Function""), val_to_str(exception_code, exception_code_vals, ""Unknown Exception Code (%u)"")); proto_tree_add_uint(modbus_tree, hf_modbus_exceptioncode, tvb, payload_start, 1, exception_code); } else { if (*packet_type == QUERY_PACKET) { dissect_modbus_request(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info); } else if (*packet_type == RESPONSE_PACKET) { dissect_modbus_response(tvb, pinfo, modbus_tree, function_code, payload_start, payload_len, pkt_info); } } return tvb_captured_length(tvb); }"
"static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg) { struct fib* srbfib; int status; struct aac_srb *srbcmd = NULL; struct aac_hba_cmd_req *hbacmd = NULL; struct user_aac_srb *user_srbcmd = NULL; struct user_aac_srb __user *user_srb = arg; struct aac_srb_reply __user *user_reply; u32 chn; u32 fibsize = 0; u32 flags = 0; s32 rcode = 0; u32 data_dir; void __user *sg_user[HBA_MAX_SG_EMBEDDED]; void *sg_list[HBA_MAX_SG_EMBEDDED]; u32 sg_count[HBA_MAX_SG_EMBEDDED]; u32 sg_indx = 0; u32 byte_count = 0; u32 actual_fibsize64, actual_fibsize = 0; int i; int is_native_device; u64 address; if (dev->in_reset) { dprintk((KERN_DEBUG""aacraid: send raw srb -EBUSY\n"")); return -EBUSY; } if (!capable(CAP_SYS_ADMIN)){ dprintk((KERN_DEBUG""aacraid: No permission to send raw srb\n"")); return -EPERM; } if (!(srbfib = aac_fib_alloc(dev))) { return -ENOMEM; } memset(sg_list, 0, sizeof(sg_list));  if(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){ dprintk((KERN_DEBUG""aacraid: Could not copy data size from user\n"")); rcode = -EFAULT; goto cleanup; } if ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) || (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) { rcode = -EINVAL; goto cleanup; } user_srbcmd = kmalloc(fibsize, GFP_KERNEL); if (!user_srbcmd) { dprintk((KERN_DEBUG""aacraid: Could not make a copy of the srb\n"")); rcode = -ENOMEM; goto cleanup; } if(copy_from_user(user_srbcmd, user_srb,fibsize)){ dprintk((KERN_DEBUG""aacraid: Could not copy srb from user\n"")); rcode = -EFAULT; goto cleanup; } flags = user_srbcmd->flags;  switch (flags & (SRB_DataIn | SRB_DataOut)) { case SRB_DataOut: data_dir = DMA_TO_DEVICE; break; case (SRB_DataIn | SRB_DataOut): data_dir = DMA_BIDIRECTIONAL; break; case SRB_DataIn: data_dir = DMA_FROM_DEVICE; break; default: data_dir = DMA_NONE; } if (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) { dprintk((KERN_DEBUG""aacraid: too many sg entries %d\n"", user_srbcmd->sg.count)); rcode = -EINVAL; goto cleanup; } if ((data_dir == DMA_NONE) && user_srbcmd->sg.count) { dprintk((KERN_DEBUG""aacraid:SG with no direction specified\n"")); rcode = -EINVAL; goto cleanup; } actual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) + ((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry)); actual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) * (sizeof(struct sgentry64) - sizeof(struct sgentry)); if ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) { dprintk((KERN_DEBUG""aacraid: Bad Size specified in "" ""Raw SRB command calculated fibsize=%lu;%lu "" ""user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu "" ""issued fibsize=%d\n"", actual_fibsize, actual_fibsize64, user_srbcmd->sg.count, sizeof(struct aac_srb), sizeof(struct sgentry), sizeof(struct sgentry64), fibsize)); rcode = -EINVAL; goto cleanup; } chn = user_srbcmd->channel; if (chn < AAC_MAX_BUSES && user_srbcmd->id < AAC_MAX_TARGETS && dev->hba_map[chn][user_srbcmd->id].devtype == AAC_DEVTYPE_NATIVE_RAW) { is_native_device = 1; hbacmd = (struct aac_hba_cmd_req *)srbfib->hw_fib_va; memset(hbacmd, 0, 96); switch (data_dir) { case DMA_TO_DEVICE: hbacmd->byte1 = 2; break; case DMA_FROM_DEVICE: case DMA_BIDIRECTIONAL: hbacmd->byte1 = 1; break; case DMA_NONE: default: break; } hbacmd->lun[1] = cpu_to_le32(user_srbcmd->lun); hbacmd->it_nexus = dev->hba_map[chn][user_srbcmd->id].rmw_nexus; memcpy(hbacmd->cdb, user_srbcmd->cdb, sizeof(hbacmd->cdb)); address = (u64)srbfib->hw_error_pa; hbacmd->error_ptr_hi = cpu_to_le32((u32)(address >> 32)); hbacmd->error_ptr_lo = cpu_to_le32((u32)(address & 0xffffffff)); hbacmd->error_length = cpu_to_le32(FW_ERROR_BUFFER_SIZE); hbacmd->emb_data_desc_count = cpu_to_le32(user_srbcmd->sg.count); srbfib->hbacmd_size = 64 + user_srbcmd->sg.count * sizeof(struct aac_hba_sgl); } else { is_native_device = 0; aac_fib_init(srbfib); srbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable); srbcmd = (struct aac_srb *) fib_data(srbfib); srbcmd->function = cpu_to_le32(SRBF_ExecuteScsi); srbcmd->channel = cpu_to_le32(user_srbcmd->channel); srbcmd->id = cpu_to_le32(user_srbcmd->id); srbcmd->lun = cpu_to_le32(user_srbcmd->lun); srbcmd->timeout = cpu_to_le32(user_srbcmd->timeout); srbcmd->flags = cpu_to_le32(flags); srbcmd->retry_limit = 0; srbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size); memcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb)); } byte_count = 0; if (is_native_device) { struct user_sgmap *usg32 = &user_srbcmd->sg; struct user_sgmap64 *usg64 = (struct user_sgmap64 *)&user_srbcmd->sg; for (i = 0; i < usg32->count; i++) { void *p; u64 addr; sg_count[i] = (actual_fibsize64 == fibsize) ? usg64->sg[i].count : usg32->sg[i].count; if (sg_count[i] > (dev->scsi_host_ptr->max_sectors << 9)) { pr_err(""aacraid: upsg->sg[%d].count=%u>%u\n"", i, sg_count[i], dev->scsi_host_ptr->max_sectors << 9); rcode = -EINVAL; goto cleanup; } p = kmalloc(sg_count[i], GFP_KERNEL); if (!p) { rcode = -ENOMEM; goto cleanup; } if (actual_fibsize64 == fibsize) { addr = (u64)usg64->sg[i].addr[0]; addr += ((u64)usg64->sg[i].addr[1]) << 32; } else { addr = (u64)usg32->sg[i].addr; } sg_user[i] = (void __user *)(uintptr_t)addr; sg_list[i] = p; sg_indx = i; if (flags & SRB_DataOut) { if (copy_from_user(p, sg_user[i], sg_count[i])) { rcode = -EFAULT; goto cleanup; } } addr = pci_map_single(dev->pdev, p, sg_count[i], data_dir); hbacmd->sge[i].addr_hi = cpu_to_le32((u32)(addr>>32)); hbacmd->sge[i].addr_lo = cpu_to_le32( (u32)(addr & 0xffffffff)); hbacmd->sge[i].len = cpu_to_le32(sg_count[i]); hbacmd->sge[i].flags = 0; byte_count += sg_count[i]; } if (usg32->count > 0) hbacmd->sge[usg32->count-1].flags = cpu_to_le32(0x40000000); hbacmd->data_length = cpu_to_le32(byte_count); status = aac_hba_send(HBA_IU_TYPE_SCSI_CMD_REQ, srbfib, NULL, NULL); } else if (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64) { struct user_sgmap64* upsg = (struct user_sgmap64*)&user_srbcmd->sg; struct sgmap64* psg = (struct sgmap64*)&srbcmd->sg; if (actual_fibsize64 == fibsize) { actual_fibsize = actual_fibsize64; for (i = 0; i < upsg->count; i++) { u64 addr; void* p; sg_count[i] = upsg->sg[i].count; if (sg_count[i] > ((dev->adapter_info.options & AAC_OPT_NEW_COMM) ? (dev->scsi_host_ptr->max_sectors << 9) : 65536)) { rcode = -EINVAL; goto cleanup; } p = kmalloc(sg_count[i], GFP_KERNEL); if(!p) { dprintk((KERN_DEBUG""aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n"", sg_count[i], i, upsg->count)); rcode = -ENOMEM; goto cleanup; } addr = (u64)upsg->sg[i].addr[0]; addr += ((u64)upsg->sg[i].addr[1]) << 32; sg_user[i] = (void __user *)(uintptr_t)addr; sg_list[i] = p; sg_indx = i; if (flags & SRB_DataOut) { if (copy_from_user(p, sg_user[i], sg_count[i])){ dprintk((KERN_DEBUG""aacraid: Could not copy sg data from user\n"")); rcode = -EFAULT; goto cleanup; } } addr = pci_map_single(dev->pdev, p, sg_count[i], data_dir); psg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff); psg->sg[i].addr[1] = cpu_to_le32(addr>>32); byte_count += sg_count[i]; psg->sg[i].count = cpu_to_le32(sg_count[i]); } } else { struct user_sgmap* usg; usg = kmemdup(upsg, actual_fibsize - sizeof(struct aac_srb) + sizeof(struct sgmap), GFP_KERNEL); if (!usg) { dprintk((KERN_DEBUG""aacraid: Allocation error in Raw SRB command\n"")); rcode = -ENOMEM; goto cleanup; } actual_fibsize = actual_fibsize64; for (i = 0; i < usg->count; i++) { u64 addr; void* p; sg_count[i] = usg->sg[i].count; if (sg_count[i] > ((dev->adapter_info.options & AAC_OPT_NEW_COMM) ? (dev->scsi_host_ptr->max_sectors << 9) : 65536)) { kfree(usg); rcode = -EINVAL; goto cleanup; } p = kmalloc(sg_count[i], GFP_KERNEL); if(!p) { dprintk((KERN_DEBUG ""aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n"", sg_count[i], i, usg->count)); kfree(usg); rcode = -ENOMEM; goto cleanup; } sg_user[i] = (void __user *)(uintptr_t)usg->sg[i].addr; sg_list[i] = p; sg_indx = i; if (flags & SRB_DataOut) { if (copy_from_user(p, sg_user[i], sg_count[i])) { kfree (usg); dprintk((KERN_DEBUG""aacraid: Could not copy sg data from user\n"")); rcode = -EFAULT; goto cleanup; } } addr = pci_map_single(dev->pdev, p, sg_count[i], data_dir); psg->sg[i].addr[0] = cpu_to_le32(addr & 0xffffffff); psg->sg[i].addr[1] = cpu_to_le32(addr>>32); byte_count += sg_count[i]; psg->sg[i].count = cpu_to_le32(sg_count[i]); } kfree (usg); } srbcmd->count = cpu_to_le32(byte_count); if (user_srbcmd->sg.count) psg->count = cpu_to_le32(sg_indx+1); else psg->count = 0; status = aac_fib_send(ScsiPortCommand64, srbfib, actual_fibsize, FsaNormal, 1, 1,NULL,NULL); } else { struct user_sgmap* upsg = &user_srbcmd->sg; struct sgmap* psg = &srbcmd->sg; if (actual_fibsize64 == fibsize) { struct user_sgmap64* usg = (struct user_sgmap64 *)upsg; for (i = 0; i < upsg->count; i++) { uintptr_t addr; void* p; sg_count[i] = usg->sg[i].count; if (sg_count[i] > ((dev->adapter_info.options & AAC_OPT_NEW_COMM) ? (dev->scsi_host_ptr->max_sectors << 9) : 65536)) { rcode = -EINVAL; goto cleanup; } p = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32); if (!p) { dprintk((KERN_DEBUG""aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n"", sg_count[i], i, usg->count)); rcode = -ENOMEM; goto cleanup; } addr = (u64)usg->sg[i].addr[0]; addr += ((u64)usg->sg[i].addr[1]) << 32; sg_user[i] = (void __user *)addr; sg_list[i] = p; sg_indx = i; if (flags & SRB_DataOut) { if (copy_from_user(p, sg_user[i], sg_count[i])){ dprintk((KERN_DEBUG""aacraid: Could not copy sg data from user\n"")); rcode = -EFAULT; goto cleanup; } } addr = pci_map_single(dev->pdev, p, usg->sg[i].count, data_dir); psg->sg[i].addr = cpu_to_le32(addr & 0xffffffff); byte_count += usg->sg[i].count; psg->sg[i].count = cpu_to_le32(sg_count[i]); } } else { for (i = 0; i < upsg->count; i++) { dma_addr_t addr; void* p; sg_count[i] = upsg->sg[i].count; if (sg_count[i] > ((dev->adapter_info.options & AAC_OPT_NEW_COMM) ? (dev->scsi_host_ptr->max_sectors << 9) : 65536)) { rcode = -EINVAL; goto cleanup; } p = kmalloc(sg_count[i], GFP_KERNEL|GFP_DMA32); if (!p) { dprintk((KERN_DEBUG""aacraid: Could not allocate SG buffer - size = %d buffer number %d of %d\n"", sg_count[i], i, upsg->count)); rcode = -ENOMEM; goto cleanup; } sg_user[i] = (void __user *)(uintptr_t)upsg->sg[i].addr; sg_list[i] = p; sg_indx = i; if (flags & SRB_DataOut) { if (copy_from_user(p, sg_user[i], sg_count[i])) { dprintk((KERN_DEBUG""aacraid: Could not copy sg data from user\n"")); rcode = -EFAULT; goto cleanup; } } addr = pci_map_single(dev->pdev, p, sg_count[i], data_dir); psg->sg[i].addr = cpu_to_le32(addr); byte_count += sg_count[i]; psg->sg[i].count = cpu_to_le32(sg_count[i]); } } srbcmd->count = cpu_to_le32(byte_count); if (user_srbcmd->sg.count) psg->count = cpu_to_le32(sg_indx+1); else psg->count = 0; status = aac_fib_send(ScsiPortCommand, srbfib, actual_fibsize, FsaNormal, 1, 1, NULL, NULL); } if (status == -ERESTARTSYS) { rcode = -ERESTARTSYS; goto cleanup; } if (status != 0) { dprintk((KERN_DEBUG""aacraid: Could not send raw srb fib to hba\n"")); rcode = -ENXIO; goto cleanup; } if (flags & SRB_DataIn) { for(i = 0 ; i <= sg_indx; i++){ if (copy_to_user(sg_user[i], sg_list[i], sg_count[i])) { dprintk((KERN_DEBUG""aacraid: Could not copy sg data to user\n"")); rcode = -EFAULT; goto cleanup; } } } user_reply = arg + fibsize; if (is_native_device) { struct aac_hba_resp *err = &((struct aac_native_hba *)srbfib->hw_fib_va)->resp.err; struct aac_srb_reply reply; reply.status = ST_OK; if (srbfib->flags & FIB_CONTEXT_FLAG_FASTRESP) { reply.srb_status = SRB_STATUS_SUCCESS; reply.scsi_status = 0; reply.data_xfer_length = byte_count; reply.sense_data_size = 0; memset(reply.sense_data, 0, AAC_SENSE_BUFFERSIZE); } else { reply.srb_status = err->service_response; reply.scsi_status = err->status; reply.data_xfer_length = byte_count - le32_to_cpu(err->residual_count); reply.sense_data_size = err->sense_response_data_len; memcpy(reply.sense_data, err->sense_response_buf, AAC_SENSE_BUFFERSIZE); } if (copy_to_user(user_reply, &reply, sizeof(struct aac_srb_reply))) { dprintk((KERN_DEBUG""aacraid: Copy to user failed\n"")); rcode = -EFAULT; goto cleanup; } } else { struct aac_srb_reply *reply; reply = (struct aac_srb_reply *) fib_data(srbfib); if (copy_to_user(user_reply, reply, sizeof(struct aac_srb_reply))) { dprintk((KERN_DEBUG""aacraid: Copy to user failed\n"")); rcode = -EFAULT; goto cleanup; } } cleanup: kfree(user_srbcmd); if (rcode != -ERESTARTSYS) { for (i = 0; i <= sg_indx; i++) kfree(sg_list[i]); aac_fib_complete(srbfib); aac_fib_free(srbfib); } return rcode; }"
"static int lock_fdc(int drive, bool interruptible) { if (WARN(atomic_read(&usage_count) == 0, ""Trying to lock fdc while usage count=0\n"")) return -1; if (wait_event_interruptible(fdc_wait, !test_and_set_bit(0, &fdc_busy))) return -EINTR; command_status = FD_COMMAND_NONE; reschedule_timeout(drive, ""lock fdc""); set_fdc(drive); return 0; }"
"bool WebCursor::Deserialize(base::PickleIterator* iter) { int type, hotspot_x, hotspot_y, size_x, size_y, data_len; float scale; const char* data; if (!iter->ReadInt(&type) || !iter->ReadInt(&hotspot_x) || !iter->ReadInt(&hotspot_y) || !iter->ReadLength(&size_x) || !iter->ReadLength(&size_y) || !iter->ReadFloat(&scale) || !iter->ReadData(&data, &data_len)) return false; if (size_x > kMaxCursorDimension || size_y > kMaxCursorDimension) return false; if (scale < 0.01 || scale > 100 || size_x / scale > kMaxCursorDimension || size_y / scale > kMaxCursorDimension) return false; type_ = type; if (type == WebCursorInfo::TypeCustom) { if (size_x > 0 && size_y > 0) { if (size_x * size_y * 4 > data_len) return false; hotspot_.set_x(hotspot_x); hotspot_.set_y(hotspot_y); custom_size_.set_width(size_x); custom_size_.set_height(size_y); custom_scale_ = scale; ClampHotspot(); custom_data_.clear(); if (data_len > 0) { custom_data_.resize(data_len); memcpy(&custom_data_[0], data, data_len); } } } return DeserializePlatformData(iter); }"
"void cb_str_postprocess(packet_info *pinfo, proto_tree *tree _U_, proto_item *item, dcerpc_info *di _U_, tvbuff_t *tvb, int start_offset, int end_offset, void *callback_args) { gint options = GPOINTER_TO_INT(callback_args); gint levels = CB_STR_ITEM_LEVELS(options); guint8 *s; if (start_offset % 4) start_offset += 4 - (start_offset % 4); if ((end_offset - start_offset) <= 12) return; s = tvb_get_string_enc(wmem_packet_scope(), tvb, start_offset + 12, (end_offset - start_offset - 12), ENC_ASCII); if (options & CB_STR_COL_INFO) { col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", s); } if (levels > 0 && item && s && s[0]) { proto_item_append_text(item, "": %s"", s); item = GET_ITEM_PARENT(item); levels--; if (levels > 0) { proto_item_append_text(item, "": %s"", s); item = GET_ITEM_PARENT(item); levels--; while (levels > 0) { proto_item_append_text(item, "" %s"", s); item = GET_ITEM_PARENT(item); levels--; } } } if (options & CB_STR_SAVE) { dcerpc_call_value *dcv = (dcerpc_call_value *)di->call_data; dcv->private_data = s; } }"
"static int xmlCtxtUseOptionsInternal(xmlParserCtxtPtr ctxt, int options, const char *encoding) { if (ctxt == NULL) return(-1); if (encoding != NULL) { if (ctxt->encoding != NULL) xmlFree((xmlChar *) ctxt->encoding); ctxt->encoding = xmlStrdup((const xmlChar *) encoding); } if (options & XML_PARSE_RECOVER) { ctxt->recovery = 1; options -= XML_PARSE_RECOVER; ctxt->options |= XML_PARSE_RECOVER; } else ctxt->recovery = 0; if (options & XML_PARSE_DTDLOAD) { ctxt->loadsubset = XML_DETECT_IDS; options -= XML_PARSE_DTDLOAD; ctxt->options |= XML_PARSE_DTDLOAD; } else ctxt->loadsubset = 0; if (options & XML_PARSE_DTDATTR) { ctxt->loadsubset |= XML_COMPLETE_ATTRS; options -= XML_PARSE_DTDATTR; ctxt->options |= XML_PARSE_DTDATTR; } if (options & XML_PARSE_NOENT) { ctxt->replaceEntities = 1; options -= XML_PARSE_NOENT; ctxt->options |= XML_PARSE_NOENT; } else ctxt->replaceEntities = 0; if (options & XML_PARSE_PEDANTIC) { ctxt->pedantic = 1; options -= XML_PARSE_PEDANTIC; ctxt->options |= XML_PARSE_PEDANTIC; } else ctxt->pedantic = 0; if (options & XML_PARSE_NOBLANKS) { ctxt->keepBlanks = 0; ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace; options -= XML_PARSE_NOBLANKS; ctxt->options |= XML_PARSE_NOBLANKS; } else ctxt->keepBlanks = 1; if (options & XML_PARSE_DTDVALID) { ctxt->validate = 1; if (options & XML_PARSE_NOWARNING) ctxt->vctxt.warning = NULL; if (options & XML_PARSE_NOERROR) ctxt->vctxt.error = NULL; options -= XML_PARSE_DTDVALID; ctxt->options |= XML_PARSE_DTDVALID; } else ctxt->validate = 0; if (options & XML_PARSE_NOWARNING) { ctxt->sax->warning = NULL; options -= XML_PARSE_NOWARNING; } if (options & XML_PARSE_NOERROR) { ctxt->sax->error = NULL; ctxt->sax->fatalError = NULL; options -= XML_PARSE_NOERROR; } #ifdef LIBXML_SAX1_ENABLED if (options & XML_PARSE_SAX1) { ctxt->sax->startElement = xmlSAX2StartElement; ctxt->sax->endElement = xmlSAX2EndElement; ctxt->sax->startElementNs = NULL; ctxt->sax->endElementNs = NULL; ctxt->sax->initialized = 1; options -= XML_PARSE_SAX1; ctxt->options |= XML_PARSE_SAX1; } #endif  if (options & XML_PARSE_NODICT) { ctxt->dictNames = 0; options -= XML_PARSE_NODICT; ctxt->options |= XML_PARSE_NODICT; } else { ctxt->dictNames = 1; } if (options & XML_PARSE_NOCDATA) { ctxt->sax->cdataBlock = NULL; options -= XML_PARSE_NOCDATA; ctxt->options |= XML_PARSE_NOCDATA; } if (options & XML_PARSE_NSCLEAN) { ctxt->options |= XML_PARSE_NSCLEAN; options -= XML_PARSE_NSCLEAN; } if (options & XML_PARSE_NONET) { ctxt->options |= XML_PARSE_NONET; options -= XML_PARSE_NONET; } if (options & XML_PARSE_COMPACT) { ctxt->options |= XML_PARSE_COMPACT; options -= XML_PARSE_COMPACT; } if (options & XML_PARSE_OLD10) { ctxt->options |= XML_PARSE_OLD10; options -= XML_PARSE_OLD10; } if (options & XML_PARSE_NOBASEFIX) { ctxt->options |= XML_PARSE_NOBASEFIX; options -= XML_PARSE_NOBASEFIX; } if (options & XML_PARSE_HUGE) { ctxt->options |= XML_PARSE_HUGE; options -= XML_PARSE_HUGE; if (ctxt->dict != NULL) xmlDictSetLimit(ctxt->dict, 0); } if (options & XML_PARSE_OLDSAX) { ctxt->options |= XML_PARSE_OLDSAX; options -= XML_PARSE_OLDSAX; } if (options & XML_PARSE_IGNORE_ENC) { ctxt->options |= XML_PARSE_IGNORE_ENC; options -= XML_PARSE_IGNORE_ENC; } if (options & XML_PARSE_BIG_LINES) { ctxt->options |= XML_PARSE_BIG_LINES; options -= XML_PARSE_BIG_LINES; } ctxt->linenumbers = 1; return (options); }"
"static ALGobject * ALGnew(PyObject *self, PyObject *args, PyObject *kwdict) { unsigned char *key, *IV; ALGobject * new=NULL; int keylen, IVlen=0, mode=MODE_ECB, segment_size=0; PyObject *counter = NULL; int counter_shortcut = 0; #ifdef PCT_ARC2_MODULE int effective_keylen = 1024;     #endif if (!PyArg_ParseTupleAndKeywords(args, kwdict, ""s#|is#Oi"" #ifdef PCT_ARC2_MODULE ""i"" #endif , kwlist, &key, &keylen, &mode, &IV, &IVlen, &counter, &segment_size #ifdef PCT_ARC2_MODULE , &effective_keylen #endif ))  { return NULL; } if (mode<MODE_ECB || mode>MODE_CTR)  { PyErr_Format(PyExc_ValueError,  ""Unknown cipher feedback mode %i"", mode); return NULL; } if (mode == MODE_PGP) { PyErr_Format(PyExc_ValueError,  ""MODE_PGP is not supported anymore""); return NULL; } if (KEY_SIZE!=0 && keylen!=KEY_SIZE) { PyErr_Format(PyExc_ValueError, ""Key must be %i bytes long, not %i"", KEY_SIZE, keylen); return NULL; } if (KEY_SIZE==0 && keylen==0) { PyErr_SetString(PyExc_ValueError, ""Key cannot be the null string""); return NULL; } if (IVlen != BLOCK_SIZE && mode != MODE_ECB && mode != MODE_CTR) { PyErr_Format(PyExc_ValueError, ""IV must be %i bytes long"", BLOCK_SIZE); return NULL; } if (mode == MODE_CFB) { if (segment_size == 0) segment_size = 8; if (segment_size < 1 || segment_size > BLOCK_SIZE*8 || ((segment_size & 7) != 0)) { PyErr_Format(PyExc_ValueError,  ""segment_size must be multiple of 8 (bits) "" ""between 1 and %i"", BLOCK_SIZE*8); return NULL; } } if (mode == MODE_CTR) { if (counter == NULL) { PyErr_SetString(PyExc_TypeError, ""'counter' keyword parameter is required with CTR mode""); return NULL; } else if (Py_TYPE(counter) == PCT_CounterBEType || Py_TYPE(counter) == PCT_CounterLEType) { counter_shortcut = 1; } else if (!PyCallable_Check(counter)) { PyErr_SetString(PyExc_ValueError,  ""'counter' parameter must be a callable object""); return NULL; } } else { if (counter != NULL) { PyErr_SetString(PyExc_ValueError,  ""'counter' parameter only useful with CTR mode""); return NULL; } } #ifdef PCT_ARC2_MODULE if (effective_keylen<0 || effective_keylen>1024) { PyErr_Format(PyExc_ValueError, ""RC2: effective_keylen must be between 0 and 1024, not %i"", effective_keylen); return NULL; } #endif new = newALGobject(); new->segment_size = segment_size; new->counter = counter; Py_XINCREF(counter); new->counter_shortcut = counter_shortcut; #ifdef PCT_ARC2_MODULE new->st.effective_keylen = effective_keylen; #endif block_init(&(new->st), key, keylen); if (PyErr_Occurred()) { Py_DECREF(new); return NULL; } memset(new->IV, 0, BLOCK_SIZE); memset(new->oldCipher, 0, BLOCK_SIZE); memcpy(new->IV, IV, IVlen); new->mode = mode; new->count=BLOCK_SIZE;    return new; }"
"void pt_migrate(struct vcpu *v) { struct list_head *head = &v->arch.hvm.tm_list; struct periodic_time *pt; spin_lock(&v->arch.hvm.tm_lock); list_for_each_entry ( pt, head, list ) migrate_timer(&pt->timer, v->processor); spin_unlock(&v->arch.hvm.tm_lock); }"
"static void php_wddx_serialize_object(wddx_packet *packet, zval *obj) { zval **ent, *fname, **varname; zval *retval = NULL; const char *key; ulong idx; char tmp_buf[WDDX_BUF_LEN]; HashTable *objhash, *sleephash; TSRMLS_FETCH(); MAKE_STD_ZVAL(fname); ZVAL_STRING(fname, ""__sleep"", 1); if (call_user_function_ex(CG(function_table), &obj, fname, &retval, 0, 0, 1, NULL TSRMLS_CC) == SUCCESS) { if (retval && (sleephash = HASH_OF(retval))) { PHP_CLASS_ATTRIBUTES; PHP_SET_CLASS_ATTRIBUTES(obj); php_wddx_add_chunk_static(packet, WDDX_STRUCT_S); snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR); php_wddx_add_chunk(packet, tmp_buf); php_wddx_add_chunk_static(packet, WDDX_STRING_S); php_wddx_add_chunk_ex(packet, class_name, name_len); php_wddx_add_chunk_static(packet, WDDX_STRING_E); php_wddx_add_chunk_static(packet, WDDX_VAR_E); PHP_CLEANUP_CLASS_ATTRIBUTES(); objhash = HASH_OF(obj); for (zend_hash_internal_pointer_reset(sleephash); zend_hash_get_current_data(sleephash, (void **)&varname) == SUCCESS; zend_hash_move_forward(sleephash)) { if (Z_TYPE_PP(varname) != IS_STRING) { php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""__sleep should return an array only containing the names of instance-variables to serialize.""); continue; } if (zend_hash_find(objhash, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname)+1, (void **)&ent) == SUCCESS) { php_wddx_serialize_var(packet, *ent, Z_STRVAL_PP(varname), Z_STRLEN_PP(varname) TSRMLS_CC); } } php_wddx_add_chunk_static(packet, WDDX_STRUCT_E); } } else { uint key_len; PHP_CLASS_ATTRIBUTES; PHP_SET_CLASS_ATTRIBUTES(obj); php_wddx_add_chunk_static(packet, WDDX_STRUCT_S); snprintf(tmp_buf, WDDX_BUF_LEN, WDDX_VAR_S, PHP_CLASS_NAME_VAR); php_wddx_add_chunk(packet, tmp_buf); php_wddx_add_chunk_static(packet, WDDX_STRING_S); php_wddx_add_chunk_ex(packet, class_name, name_len); php_wddx_add_chunk_static(packet, WDDX_STRING_E); php_wddx_add_chunk_static(packet, WDDX_VAR_E); PHP_CLEANUP_CLASS_ATTRIBUTES(); objhash = HASH_OF(obj); for (zend_hash_internal_pointer_reset(objhash); zend_hash_get_current_data(objhash, (void**)&ent) == SUCCESS; zend_hash_move_forward(objhash)) { if (*ent == obj) { continue; } if (zend_hash_get_current_key_ex(objhash, &key, &key_len, &idx, 0, NULL) == HASH_KEY_IS_STRING) { const char *class_name, *prop_name; zend_unmangle_property_name(key, key_len-1, &class_name, &prop_name); php_wddx_serialize_var(packet, *ent, prop_name, strlen(prop_name)+1 TSRMLS_CC); } else { key_len = slprintf(tmp_buf, sizeof(tmp_buf), ""%ld"", idx); php_wddx_serialize_var(packet, *ent, tmp_buf, key_len TSRMLS_CC); } } php_wddx_add_chunk_static(packet, WDDX_STRUCT_E); } zval_dtor(fname); FREE_ZVAL(fname); if (retval) { zval_ptr_dtor(&retval); } }"
"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si) { s32 pps_id; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if ((pps_id<0) || (pps_id > 255)) return -1; si->pps = &avc->pps[pps_id]; si->pps->id = pps_id; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT]; if (!si->sps->log2_max_frame_num) return -2; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; if (si->sps->frame_mbs_only_flag) { } else { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE || si->svc_nalhdr.idr_pic_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""delta_poc_bottom""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } return 0; }"
"gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int src_width, const unsigned int src_height, const unsigned int new_width, const unsigned int new_height) { gdImagePtr tmp_im; gdImagePtr dst; if (!src->trueColor) { gdImagePaletteToTrueColor(src); } tmp_im = gdImageCreateTrueColor(new_width, src_height); if (tmp_im == NULL) { return NULL; } gdImageSetInterpolationMethod(tmp_im, src->interpolation_id); _gdScaleHoriz(src, src_width, src_height, tmp_im, new_width, src_height); dst = gdImageCreateTrueColor(new_width, new_height); if (dst == NULL) { gdFree(tmp_im); return NULL; } gdImageSetInterpolationMethod(dst, src->interpolation_id); _gdScaleVert(tmp_im, new_width, src_height, dst, new_width, new_height); gdFree(tmp_im); return dst; }"
"static LY_ERR lysp_stmt_validate_value(struct lysp_ctx *ctx, enum yang_arg val_type, const char *val) { uint8_t prefix = 0; ly_bool first = 1; uint32_t c; size_t utf8_char_len; while (*val) { LY_CHECK_ERR_RET(ly_getutf8(&val, &c, &utf8_char_len), LOGVAL_PARSER(ctx, LY_VCODE_INCHAR, (val)[-utf8_char_len]), LY_EVALID); switch (val_type) { case Y_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, NULL)); break; case Y_PREF_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, &prefix)); break; case Y_STR_ARG: case Y_MAYBE_STR_ARG: LY_CHECK_RET(lysp_check_stringchar(ctx, c)); break; } first = 0; } return LY_SUCCESS; }"
"static void m2tsdmx_declare_pid(GF_M2TSDmxCtx *ctx, GF_M2TS_PES *stream, GF_ESD *esd) { u32 i, count, codecid=0, stype=0, orig_stype=0; GF_FilterPid *opid; Bool m4sys_stream = GF_FALSE; Bool m4sys_iod_stream = GF_FALSE; Bool has_scal_layer = GF_FALSE; Bool unframed = GF_FALSE; Bool unframed_latm = GF_FALSE; char szName[20]; const char *stname; if (stream->user) return; if (stream->flags & GF_M2TS_GPAC_CODEC_ID) { codecid = stream->stream_type; stype = gf_codecid_type(codecid); if (stream->gpac_meta_dsi) stype = stream->gpac_meta_dsi[4]; if (!stype) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] Unrecognized gpac codec %s - ignoring pid\n"", gf_4cc_to_str(codecid) )); return; } } else { switch (stream->stream_type) { case GF_M2TS_VIDEO_MPEG1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG1; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_MPEG2: case GF_M2TS_VIDEO_DCII: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG2_MAIN; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_MPEG4: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_MPEG4_PART2; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_H264: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AVC; unframed = GF_TRUE; if (stream->program->is_scalable) has_scal_layer = GF_TRUE; break; case GF_M2TS_HLS_AVC_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AVC; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_SVC: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_SVC; has_scal_layer = GF_TRUE; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_HEVC: case GF_M2TS_VIDEO_HEVC_TEMPORAL: case GF_M2TS_VIDEO_HEVC_MCTS: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_HEVC; unframed = GF_TRUE; if (stream->program->is_scalable) has_scal_layer = GF_TRUE; break; case GF_M2TS_VIDEO_SHVC: case GF_M2TS_VIDEO_SHVC_TEMPORAL: case GF_M2TS_VIDEO_MHVC: case GF_M2TS_VIDEO_MHVC_TEMPORAL: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_LHVC; has_scal_layer = GF_TRUE; break; case GF_M2TS_VIDEO_VVC: case GF_M2TS_VIDEO_VVC_TEMPORAL: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_VVC; unframed = GF_TRUE; break; case GF_M2TS_VIDEO_VC1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_SMPTE_VC1; stream->flags |= GF_M2TS_CHECK_VC1; break; case GF_M2TS_VIDEO_AV1: stype = GF_STREAM_VISUAL; codecid = GF_CODECID_AV1; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_MPEG1: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MPEG_AUDIO; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_MPEG2: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MPEG2_PART3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_AAC: case GF_CODECID_AAC_MPEG2_MP: case GF_CODECID_AAC_MPEG2_LCP: case GF_CODECID_AAC_MPEG2_SSRP: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_LATM_AAC: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; unframed_latm = GF_TRUE; break; case GF_M2TS_MHAS_MAIN: case GF_M2TS_MHAS_AUX: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_MHAS; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_AC3: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AC3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_EC3: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_TRUEHD: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_TRUEHD; unframed = GF_TRUE; break; case GF_M2TS_AUDIO_DTS: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_DTS_X; break; case GF_M2TS_AUDIO_OPUS: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_OPUS; break; case GF_M2TS_SYSTEMS_MPEG4_SECTIONS: ((GF_M2TS_ES*)stream)->flags |= GF_M2TS_ES_SEND_REPEATED_SECTIONS; case GF_M2TS_SYSTEMS_MPEG4_PES: if (!esd) { m4sys_iod_stream = GF_TRUE; count = gf_list_count(stream->program->pmt_iod->ESDescriptors); for (i=0; i<count; i++) { esd = gf_list_get(stream->program->pmt_iod->ESDescriptors, i); if (esd->ESID == stream->mpeg4_es_id) break; esd = NULL; } } m4sys_stream = GF_TRUE; if (!esd) return; break; case GF_M2TS_METADATA_PES: case GF_M2TS_METADATA_ID3_HLS: stype = GF_STREAM_METADATA; codecid = GF_CODECID_SIMPLE_TEXT; break; case 0xA1: stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; break; case GF_M2TS_HLS_AAC_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AAC_MPEG4; unframed = GF_TRUE; break; case GF_M2TS_HLS_AC3_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_AC3; unframed = GF_TRUE; break; case GF_M2TS_HLS_EC3_CRYPT: stype = GF_STREAM_ENCRYPTED; orig_stype = GF_STREAM_AUDIO; codecid = GF_CODECID_EAC3; break; case GF_M2TS_DVB_SUBTITLE: stype = GF_STREAM_TEXT; codecid = GF_CODECID_DVB_SUBS; stream->flags |= GF_M2TS_ES_FULL_AU; break; case GF_M2TS_DVB_TELETEXT: if (!ctx->dvbtxt) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] DVB teletext pid skipped, use --dvbtxt to enable\n"", stream->stream_type)); return; } stype = GF_STREAM_TEXT; codecid = GF_CODECID_DVB_TELETEXT; stream->flags |= GF_M2TS_ES_FULL_AU; break; default: GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[M2TSDmx] Stream type 0x%02X not supported - ignoring pid\n"", stream->stream_type)); return; } } opid = NULL; for (i=0; i<gf_filter_get_opid_count(ctx->filter); i++) { opid = gf_filter_get_opid(ctx->filter, i); const GF_PropertyValue *p = gf_filter_pid_get_property(opid, GF_PROP_PID_ID); if (p && (p->value.uint == stream->pid)) break; opid = NULL; } if (!opid) opid = gf_filter_pid_new(ctx->filter); stream->user = opid; stream->flags |= GF_M2TS_ES_ALREADY_DECLARED; u32 d_type = orig_stype ? orig_stype : stype; switch (d_type) { case GF_STREAM_AUDIO: case GF_STREAM_VISUAL: stream->flags |= GF_M2TS_CHECK_DISC; break; default: stream->flags &= ~GF_M2TS_CHECK_DISC; break; } stname = gf_stream_type_name(stype); sprintf(szName, ""P%d%c%d"", stream->program->number, stname[0], 1+gf_list_find(stream->program->streams, stream)); gf_filter_pid_set_name(opid, szName); gf_filter_pid_set_property(opid, GF_PROP_PID_ID, &PROP_UINT(stream->pid) ); gf_filter_pid_set_property(opid, GF_PROP_PID_ESID, stream->mpeg4_es_id ? &PROP_UINT(stream->mpeg4_es_id) : NULL); if (m4sys_stream) { if (stream->slcfg) gf_free(stream->slcfg); stream->slcfg = esd->slConfig; esd->slConfig = NULL; gf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(esd->decoderConfig ? esd->decoderConfig->streamType : GF_STREAM_SCENE) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(esd->decoderConfig ? esd->decoderConfig->objectTypeIndication : GF_CODECID_BIFS) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(esd->OCRESID ? esd->OCRESID : esd->ESID) ); gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID) ); if (esd->decoderConfig && esd->decoderConfig->decoderSpecificInfo  && esd->decoderConfig->decoderSpecificInfo->dataLength) gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength) ); gf_filter_pid_set_property(opid, GF_PROP_PID_IN_IOD, &PROP_BOOL(m4sys_iod_stream) ); gf_filter_pid_set_property(opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(((GF_M2TS_ES*)stream)->slcfg->timestampResolution) ); if (esd->decoderConfig && (esd->decoderConfig->streamType==GF_STREAM_OD)) stream->flags |= GF_M2TS_ES_IS_MPEG4_OD; } else { gf_filter_pid_set_property(opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(stype) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(codecid) ); gf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED, unframed ? &PROP_BOOL(GF_TRUE) : NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_UNFRAMED_LATM, unframed_latm ? &PROP_BOOL(GF_TRUE) : NULL ); if (orig_stype) { gf_filter_pid_set_property(opid, GF_PROP_PID_ORIG_STREAM_TYPE, &PROP_UINT(orig_stype) ); gf_filter_pid_set_property(opid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, &PROP_UINT(GF_HLS_SAMPLE_AES_SCHEME) ); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_ORIG_STREAM_TYPE, NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_PROTECTION_SCHEME_TYPE, NULL); } gf_filter_pid_set_property(opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(90000) ); gf_filter_pid_set_property(opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(stream->program->pcr_pid) ); if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->gpac_meta_dsi) { char *cname; GF_BitStream *bs = gf_bs_new(stream->gpac_meta_dsi, stream->gpac_meta_dsi_size, GF_BITSTREAM_READ); u32 val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_CODECID, &PROP_UINT(val) ); gf_bs_read_u8(bs); gf_bs_read_u8(bs); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_CODEC_ID, &PROP_UINT(val) ); cname = gf_bs_read_utf8(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_CODEC_NAME, cname ? &PROP_STRING_NO_COPY(cname) : NULL ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_META_DEMUX_OPAQUE, &PROP_UINT(val) ); u32 dsi_len = gf_bs_read_u32(bs); if (dsi_len) { u32 pos = gf_bs_get_position(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(stream->gpac_meta_dsi+pos, dsi_len) ); gf_bs_skip_bytes(bs, dsi_len); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, NULL); } if (stype==GF_STREAM_VISUAL) { val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_WIDTH, &PROP_UINT(val) ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_HEIGHT, &PROP_UINT(val) ); } else if (stype==GF_STREAM_AUDIO) { val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT(val) ); val = gf_bs_read_u32(bs); gf_filter_pid_set_property(opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT(val) ); } gf_bs_del(bs); } } gf_filter_pid_set_property(opid, GF_PROP_PID_SCALABLE, has_scal_layer ? &PROP_BOOL(GF_TRUE) : NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_SERVICE_ID, &PROP_UINT(stream->program->number) ); if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->lang) { char szLang[4]; szLang[0] = (stream->lang>>16) & 0xFF; szLang[1] = (stream->lang>>8) & 0xFF; szLang[2] = stream->lang & 0xFF; szLang[3] = 0; if (szLang[2]==' ') szLang[2] = 0; gf_filter_pid_set_property(opid, GF_PROP_PID_LANGUAGE, &PROP_STRING(szLang) ); } if (codecid == GF_CODECID_DVB_SUBS) { char szLang[4]; memcpy(szLang, stream->sub.language, 3); szLang[3]=0; gf_filter_pid_set_property(opid, GF_PROP_PID_LANGUAGE, &PROP_STRING(szLang) ); u8 dsi[5]; dsi[0] = stream->sub.composition_page_id>>8; dsi[1] = stream->sub.composition_page_id & 0xFF; dsi[2] = stream->sub.ancillary_page_id>>8; dsi[3] = stream->sub.ancillary_page_id & 0xFF; dsi[4] = stream->sub.type; gf_filter_pid_set_property(opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(dsi, 5)); } if (ctx->duration.num>1) { gf_filter_pid_set_property(opid, GF_PROP_PID_DURATION, &PROP_FRAC64(ctx->duration) ); gf_filter_pid_set_property(opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) ); } if (!m4sys_stream) { if ((stream->flags&GF_M2TS_ES_IS_PES) && stream->depends_on_pid) { gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(stream->depends_on_pid) ); if ((stream->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) || (stream->stream_type == GF_M2TS_VIDEO_HEVC_MCTS)) { gf_filter_pid_set_property(opid, GF_PROP_PID_SUBLAYER, &PROP_BOOL(GF_TRUE) ); } } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DEPENDENCY_ID, NULL); gf_filter_pid_set_property(opid, GF_PROP_PID_SUBLAYER, NULL); } } if ((stream->flags & GF_M2TS_ES_IS_PES) && (stream->dv_info[0])) { gf_filter_pid_set_property(opid, GF_PROP_PID_DOLBY_VISION, &PROP_DATA(stream->dv_info, 24) ); u32 dvtype=0; if (stream->dv_info[24]) { if (stream->stream_type == GF_M2TS_VIDEO_H264) dvtype = GF_4CC('d','a','v','1'); else dvtype = GF_4CC('d','v','h','1'); } gf_filter_pid_set_property(opid, GF_PROP_PID_ISOM_SUBTYPE, dvtype ? &PROP_4CC(dvtype) : NULL); } else { gf_filter_pid_set_property(opid, GF_PROP_PID_DOLBY_VISION, NULL); } m2tsdmx_update_sdt(ctx->ts, opid); gf_m2ts_set_pes_framing((GF_M2TS_PES *)stream, GF_M2TS_PES_FRAMING_DEFAULT); }"
"size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) { switch (dt) { case DT_FLOAT: return 4; case DT_DOUBLE: return 8; case DT_INT32: return 10; case DT_UINT8: return 2; case DT_INT16: return 10; case DT_INT8: return 10; case DT_COMPLEX64: return 8; case DT_INT64: return 10; case DT_BOOL: return 1; case DT_QINT8: return 10; case DT_QUINT8: return 2; case DT_QINT32: return 10; case DT_QINT16: return 10; case DT_QUINT16: return 3; case DT_UINT16: return 3; case DT_COMPLEX128: return 16; case DT_HALF: return 3; case DT_INVALID: case DT_STRING: case DT_BFLOAT16: default: LOG(FATAL) << ""MaxBytesPerElement not implemented for dtype: "" << dt; } return 0; }"
"int ext4_orphan_add(handle_t *handle, struct inode *inode) { struct super_block *sb = inode->i_sb; struct ext4_iloc iloc; int err = 0, rc; if (!ext4_handle_valid(handle)) return 0; mutex_lock(&EXT4_SB(sb)->s_orphan_lock); if (!list_empty(&EXT4_I(inode)->i_orphan)) goto out_unlock; J_ASSERT((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) || inode->i_nlink == 0); BUFFER_TRACE(EXT4_SB(sb)->s_sbh, ""get_write_access""); err = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh); if (err) goto out_unlock; err = ext4_reserve_inode_write(handle, inode, &iloc); if (err) goto out_unlock; if (NEXT_ORPHAN(inode) && NEXT_ORPHAN(inode) <= (le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))) goto mem_insert; NEXT_ORPHAN(inode) = le32_to_cpu(EXT4_SB(sb)->s_es->s_last_orphan); EXT4_SB(sb)->s_es->s_last_orphan = cpu_to_le32(inode->i_ino); err = ext4_handle_dirty_super(handle, sb); rc = ext4_mark_iloc_dirty(handle, inode, &iloc); if (!err) err = rc; mem_insert: if (!err) list_add(&EXT4_I(inode)->i_orphan, &EXT4_SB(sb)->s_orphan); jbd_debug(4, ""superblock will point to %lu\n"", inode->i_ino); jbd_debug(4, ""orphan inode %lu will point to %d\n"", inode->i_ino, NEXT_ORPHAN(inode)); out_unlock: mutex_unlock(&EXT4_SB(sb)->s_orphan_lock); ext4_std_error(inode->i_sb, err); return err; }"
"int sas_discover_end_dev(struct domain_device *dev) { int res; res = sas_notify_lldd_dev_found(dev); if (res) return res; sas_discover_event(dev->port, DISCE_PROBE); return 0; }"
"GVariant * g_variant_new_from_bytes (const GVariantType *type, GBytes             *bytes, gboolean            trusted) { GVariant *value; guint alignment; gsize size; GBytes *owned_bytes = NULL; GVariantSerialised serialised; value = g_variant_alloc (type, TRUE, trusted); g_variant_type_info_query (value->type_info, &alignment, &size); serialised.type_info = value->type_info; serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size); serialised.depth = 0; if (!g_variant_serialised_check (serialised)) { #ifdef HAVE_POSIX_MEMALIGN gpointer aligned_data = NULL; gsize aligned_size = g_bytes_get_size (bytes); if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1), aligned_size) != 0) g_error (""posix_memalign failed""); if (aligned_size != 0) memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size); bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data, aligned_size, free, aligned_data); aligned_data = NULL; #else bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL), g_bytes_get_size (bytes)); #endif } value->contents.serialised.bytes = g_bytes_ref (bytes); if (size && g_bytes_get_size (bytes) != size) { value->contents.serialised.data = NULL; value->size = size; } else { value->contents.serialised.data = g_bytes_get_data (bytes, &value->size); } g_clear_pointer (&owned_bytes, g_bytes_unref); return value; }"
"static int expandrow2(UINT8* dest, const UINT8* src, int n, int z, int xsize) { UINT8 pixel, count; for (;n > 0; n--) { pixel = src[1]; src+=2; if (n == 1 && pixel != 0) return n; count = pixel & RLE_MAX_RUN; if (!count) return count; if (count > xsize) { return -1; } if (pixel & RLE_COPY_FLAG) { while(count--) { memcpy(dest, src, 2); src += 2; dest += z * 2; } } else { while (count--) { memcpy(dest, src, 2); dest += z * 2; } src+=2; } } return 0; }"
"GF_Err Media_GetESD(GF_MediaBox *mdia, u32 sampleDescIndex, GF_ESD **out_esd, Bool true_desc_only) { u32 type; GF_ESD *esd; GF_MPEGSampleEntryBox *entry = NULL; GF_ESDBox *ESDa; GF_ProtectionSchemeInfoBox *sinf; GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription; *out_esd = NULL; if (!stsd || !stsd->child_boxes || !sampleDescIndex || (sampleDescIndex > gf_list_count(stsd->child_boxes)) ) return GF_BAD_PARAM; esd = NULL; entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1); if (! entry) return GF_ISOM_INVALID_MEDIA; *out_esd = NULL; ESDa = NULL; type = entry->type; switch (type) { case GF_ISOM_BOX_TYPE_ENCV: case GF_ISOM_BOX_TYPE_ENCA: case GF_ISOM_BOX_TYPE_ENCS: case GF_ISOM_BOX_TYPE_ENCF: case GF_ISOM_BOX_TYPE_ENCM: case GF_ISOM_BOX_TYPE_ENCT: sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) { type = sinf->original_format->data_format; } break; case GF_ISOM_BOX_TYPE_RESV: sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF); if (sinf && sinf->original_format) { type = sinf->original_format->data_format; } break; } switch (type) { case GF_ISOM_BOX_TYPE_MP4V: ESDa = ((GF_MPEGVisualSampleEntryBox*)entry)->esd; if (ESDa) esd = (GF_ESD *) ESDa->desc; else esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_AVC1: case GF_ISOM_BOX_TYPE_AVC2: case GF_ISOM_BOX_TYPE_AVC3: case GF_ISOM_BOX_TYPE_AVC4: case GF_ISOM_BOX_TYPE_HVC1: case GF_ISOM_BOX_TYPE_HEV1: case GF_ISOM_BOX_TYPE_HVC2: case GF_ISOM_BOX_TYPE_HEV2: case GF_ISOM_BOX_TYPE_HVT1: case GF_ISOM_BOX_TYPE_264B: case GF_ISOM_BOX_TYPE_265B: case GF_ISOM_BOX_TYPE_DVHE: case GF_ISOM_BOX_TYPE_VVC1: case GF_ISOM_BOX_TYPE_VVI1: esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_SVC1: case GF_ISOM_BOX_TYPE_MVC1: if ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT) AVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia); else AVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL); esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_LHE1: case GF_ISOM_BOX_TYPE_LHV1: if ((mdia->mediaTrack->extractor_mode & 0x0000FFFF) != GF_ISOM_NALU_EXTRACT_INSPECT) HEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, mdia); else HEVC_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*) entry, NULL); esd = ((GF_MPEGVisualSampleEntryBox*) entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_AV01: AV1_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia); esd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_VP08: case GF_ISOM_BOX_TYPE_VP09: VP9_RewriteESDescriptorEx((GF_MPEGVisualSampleEntryBox*)entry, mdia); esd = ((GF_MPEGVisualSampleEntryBox*)entry)->emul_esd; break; case GF_ISOM_BOX_TYPE_MP4A: { GF_MPEGAudioSampleEntryBox *ase = (GF_MPEGAudioSampleEntryBox*)entry; ESDa = ase->esd; if (ESDa) { esd = (GF_ESD *) ESDa->desc; } else if (!true_desc_only) { Bool make_mp4a = GF_FALSE; sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) { if (sinf->original_format->data_format==GF_ISOM_BOX_TYPE_MP4A) { make_mp4a = GF_TRUE; } } else { make_mp4a = GF_TRUE; } if (make_mp4a) { GF_M4ADecSpecInfo aacinfo; memset(&aacinfo, 0, sizeof(GF_M4ADecSpecInfo)); aacinfo.nb_chan = ase->channel_count; aacinfo.base_object_type = GF_M4A_AAC_LC; aacinfo.base_sr = ase->samplerate_hi; *out_esd = gf_odf_desc_esd_new(0); (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO; (*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_AAC_MPEG4; gf_m4a_write_config(&aacinfo, &(*out_esd)->decoderConfig->decoderSpecificInfo->data, &(*out_esd)->decoderConfig->decoderSpecificInfo->dataLength); } } } break; case GF_ISOM_BOX_TYPE_MP4S: if (entry->internal_type==GF_ISOM_SAMPLE_ENTRY_MP4S) { ESDa = entry->esd; if (ESDa) esd = (GF_ESD *) ESDa->desc; } break; #ifndef GPAC_DISABLE_TTXT case GF_ISOM_BOX_TYPE_TX3G: case GF_ISOM_BOX_TYPE_TEXT: if (!true_desc_only && mdia->mediaTrack->moov->mov->convert_streaming_text) { GF_Err e = gf_isom_get_ttxt_esd(mdia, out_esd); if (e) return e; break; } else return GF_ISOM_INVALID_MEDIA; #endif #ifndef GPAC_DISABLE_VTT case GF_ISOM_BOX_TYPE_WVTT: { GF_WebVTTSampleEntryBox*vtte = (GF_WebVTTSampleEntryBox*)entry; esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_TEXT; esd->decoderConfig->objectTypeIndication = GF_CODECID_WEBVTT; if (vtte->config) { esd->decoderConfig->decoderSpecificInfo->dataLength = (u32) strlen(vtte->config->string); esd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*esd->decoderConfig->decoderSpecificInfo->dataLength); memcpy(esd->decoderConfig->decoderSpecificInfo->data, vtte->config->string, esd->decoderConfig->decoderSpecificInfo->dataLength); } } break; case GF_ISOM_BOX_TYPE_STPP: case GF_ISOM_BOX_TYPE_SBTT: case GF_ISOM_BOX_TYPE_STXT: break; #endif case GF_ISOM_SUBTYPE_3GP_AMR: case GF_ISOM_SUBTYPE_3GP_AMR_WB: case GF_ISOM_SUBTYPE_3GP_EVRC: case GF_ISOM_SUBTYPE_3GP_QCELP: case GF_ISOM_SUBTYPE_3GP_SMV: if (!true_desc_only) { GF_Err e = gf_isom_get_3gpp_audio_esd(mdia->information->sampleTable, type, (GF_GenericAudioSampleEntryBox*)entry, out_esd); if (e) return e; break; } else return GF_ISOM_INVALID_MEDIA; case GF_ISOM_SUBTYPE_OPUS: { GF_OpusSpecificBox *e = ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_opus; GF_BitStream *bs_out; if (!e) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""ESD not found for Opus\n)"")); break; } *out_esd = gf_odf_desc_esd_new(2); (*out_esd)->decoderConfig->streamType = GF_STREAM_AUDIO; (*out_esd)->decoderConfig->objectTypeIndication = GF_CODECID_OPUS; bs_out = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_isom_box_size((GF_Box *) e); gf_isom_box_write((GF_Box *) e, bs_out); gf_bs_get_content(bs_out, & (*out_esd)->decoderConfig->decoderSpecificInfo->data, & (*out_esd)->decoderConfig->decoderSpecificInfo->dataLength); gf_bs_del(bs_out); break; } case GF_ISOM_SUBTYPE_3GP_H263: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_VISUAL; esd->decoderConfig->objectTypeIndication = GF_CODECID_H263; break; } case GF_ISOM_SUBTYPE_MP3: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_AUDIO; esd->decoderConfig->objectTypeIndication = GF_CODECID_MPEG_AUDIO; break; } case GF_ISOM_SUBTYPE_LSR1: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { GF_LASeRSampleEntryBox*ptr = (GF_LASeRSampleEntryBox*)entry; esd =  gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_SCENE; esd->decoderConfig->objectTypeIndication = GF_CODECID_LASER; esd->decoderConfig->decoderSpecificInfo->dataLength = ptr->lsr_config->hdr_size; esd->decoderConfig->decoderSpecificInfo->data = gf_malloc(sizeof(char)*ptr->lsr_config->hdr_size); if (!esd->decoderConfig->decoderSpecificInfo->data) return GF_OUT_OF_MEM; memcpy(esd->decoderConfig->decoderSpecificInfo->data, ptr->lsr_config->hdr, sizeof(char)*ptr->lsr_config->hdr_size); break; } case GF_ISOM_SUBTYPE_MH3D_MHA1: case GF_ISOM_SUBTYPE_MH3D_MHA2: case GF_ISOM_SUBTYPE_MH3D_MHM1: case GF_ISOM_SUBTYPE_MH3D_MHM2: if (true_desc_only) { return GF_ISOM_INVALID_MEDIA; } else { GF_MPEGAudioSampleEntryBox*ptr = (GF_MPEGAudioSampleEntryBox*)entry; esd = gf_odf_desc_esd_new(2); *out_esd = esd; esd->decoderConfig->streamType = GF_STREAM_AUDIO; if ((type==GF_ISOM_SUBTYPE_MH3D_MHA1) || (type==GF_ISOM_SUBTYPE_MH3D_MHA2)) esd->decoderConfig->objectTypeIndication = GF_CODECID_MPHA; else esd->decoderConfig->objectTypeIndication = GF_CODECID_MHAS; if (ptr->cfg_mha) { GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_bs_write_u8(bs, ptr->cfg_mha->configuration_version); gf_bs_write_u8(bs, ptr->cfg_mha->mha_pl_indication); gf_bs_write_u8(bs, ptr->cfg_mha->reference_channel_layout); gf_bs_write_u16(bs, ptr->cfg_mha->mha_config ? ptr->cfg_mha->mha_config_size : 0); if (ptr->cfg_mha->mha_config && ptr->cfg_mha->mha_config_size) gf_bs_write_data(bs, ptr->cfg_mha->mha_config, ptr->cfg_mha->mha_config_size); gf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength); gf_bs_del(bs); } } break; default: return GF_ISOM_INVALID_MEDIA; } if (true_desc_only) { if (!esd) return GF_ISOM_INVALID_MEDIA; *out_esd = esd; return GF_OK; } else { if (!esd && !*out_esd) return GF_ISOM_INVALID_MEDIA; if (*out_esd == NULL) return gf_odf_desc_copy((GF_Descriptor *)esd, (GF_Descriptor **)out_esd); } return GF_OK; }"
"void PngImage::readMetadata() { #ifdef DEBUG std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << io_->path() << std::endl; #endif if (io_->open() != 0) { throw Error(kerDataSourceOpenFailed, io_->path(), strError()); } IoCloser closer(*io_); if (!isPngType(*io_, true)) { throw Error(kerNotAnImage, ""PNG""); } clearMetadata(); const long imgSize = (long)io_->size(); DataBuf cheaderBuf(8);   while (!io_->eof()) { std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_); readChunk(cheaderBuf, *io_);   uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian); long pos = io_->tell(); if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) { throw Exiv2::Error(kerFailedToReadImageData); } std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4); #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << chunkType << "" length: "" << chunkLength << std::endl; #endif if (chunkType == ""IEND"" || chunkType == ""IHDR"" || chunkType == ""tEXt"" || chunkType == ""zTXt"" || chunkType == ""iTXt"" || chunkType == ""iCCP"") { DataBuf chunkData(chunkLength); readChunk(chunkData, *io_);   if (chunkType == ""IEND"") { return;                  } else if (chunkType == ""IHDR"" && chunkData.size_ >= 8) { Internal::PngImageHeader header; PngChunk::decodeIHDRChunk(chunkData, header); pixelWidth_ = header.width; pixelHeight_ = header.height; } else if (chunkType == ""tEXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk); } else if (chunkType == ""zTXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk); } else if (chunkType == ""iTXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk); } else if (chunkType == ""iCCP"") { uint32_t iccOffset = 0; while (iccOffset < 80 && iccOffset < chunkLength) { if (chunkData.pData_[iccOffset++] == 0x00) { break; } } profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1); ++iccOffset;                      enforce(iccOffset <= chunkLength, Exiv2::kerCorruptedMetadata); zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_); #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << profileName_ << std::endl; std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : "" << iccProfile_.size_ << std::endl; #endif } chunkLength = 0; } #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl; #endif io_->seek(chunkLength + 4, BasicIo::cur); if (io_->error() || io_->eof()) { throw Error(kerFailedToReadImageData); } } }"
"static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus, struct sk_buff *skb, bool first) { int size = lstatus & BD_LENGTH_MASK; struct page *page = rxb->page; if (likely(first)) { skb_put(skb, size); } else { if (lstatus & BD_LFLAG(RXBD_LAST)) size -= skb->len; skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, rxb->page_offset + RXBUF_ALIGNMENT, size, GFAR_RXB_TRUESIZE); } if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page))) return false; rxb->page_offset ^= GFAR_RXB_TRUESIZE; page_ref_inc(page); return true; }"
static int redisIvykisAttach(redisAsyncContext *ac) { redisContext *c = &(ac->c); redisIvykisEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisIvykisEvents*)hiredis_safe_malloc(sizeof(*e)); e->context = ac; ac->ev.addRead = redisIvykisAddRead; ac->ev.delRead = redisIvykisDelRead; ac->ev.addWrite = redisIvykisAddWrite; ac->ev.delWrite = redisIvykisDelWrite; ac->ev.cleanup = redisIvykisCleanup; ac->ev.data = e; IV_FD_INIT(&e->fd); e->fd.fd = c->fd; e->fd.handler_in = redisIvykisReadEvent; e->fd.handler_out = redisIvykisWriteEvent; e->fd.handler_err = NULL; e->fd.cookie = e->context; iv_fd_register(&e->fd); return REDIS_OK; }
"static int cit_get_packet_size(struct gspca_dev *gspca_dev) { struct usb_host_interface *alt; struct usb_interface *intf; intf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface); alt = usb_altnum_to_altsetting(intf, gspca_dev->alt); if (!alt) { pr_err(""Couldn't get altsetting\n""); return -EIO; } return le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize); }"
"TfLiteStatus PopulatePrecomputedZPTimesWeightsWithBias(TfLiteContext* context, OpData* op_data, TfLiteNode* node) { const TfLiteTensor* input; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputTensor, &input)); const TfLiteTensor* output_state = GetVariableInput(context, node, lstm::full::kOutputStateTensor); TF_LITE_ENSURE(context, output_state != nullptr); const int32_t input_zero_point = -input->params.zero_point; const int32_t output_state_zero_point = -output_state->params.zero_point; const TfLiteTensor* input_to_input_weights = GetOptionalInputTensor( context, node, lstm::full::kInputToInputWeightsTensor); const TfLiteTensor* input_to_forget_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputToForgetWeightsTensor, &input_to_forget_weights)); const TfLiteTensor* input_to_cell_weights; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, lstm::full::kInputToCellWeightsTensor, &input_to_cell_weights)); const TfLiteTensor* input_to_output_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kInputToOutputWeightsTensor, &input_to_output_weights)); const TfLiteTensor* recurrent_to_input_weights = GetOptionalInputTensor( context, node, lstm::full::kRecurrentToInputWeightsTensor); const TfLiteTensor* recurrent_to_forget_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToForgetWeightsTensor, &recurrent_to_forget_weights)); const TfLiteTensor* recurrent_to_cell_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToCellWeightsTensor, &recurrent_to_cell_weights)); const TfLiteTensor* recurrent_to_output_weights; TF_LITE_ENSURE_OK( context, GetInputSafe(context, node, lstm::full::kRecurrentToOutputWeightsTensor, &recurrent_to_output_weights)); const TfLiteTensor* projection_weights = GetOptionalInputTensor( context, node, lstm::full::kProjectionWeightsTensor); const TfLiteTensor* projection_bias = GetOptionalInputTensor(context, node, lstm::full::kProjectionBiasTensor); lstm_eval::IntegerLstmParameter* integer_lstm_params = &op_data->integer_lstm_param; const TfLiteTensor* intermediate = &context->tensors[node->intermediates->data[4]]; const auto* params = static_cast<TfLiteAffineQuantization*>(intermediate->quantization.params); const int32_t hidden_zp = params->zero_point->data[0]; const bool is_layer_norm = op_data->use_layer_norm; const TfLiteTensor* forget_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kForgetGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_forget_weights, forget_gate_bias, &(integer_lstm_params->input_to_forget_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_forget_weights, nullptr, &(integer_lstm_params->recurrent_to_forget_effective_bias))); const TfLiteTensor* cell_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kCellGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_cell_weights, cell_gate_bias, &(integer_lstm_params->input_to_cell_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_cell_weights, nullptr, &(integer_lstm_params->recurrent_to_cell_effective_bias))); const TfLiteTensor* output_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kOutputGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_output_weights, output_gate_bias, &(integer_lstm_params->input_to_output_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_output_weights, nullptr, &(integer_lstm_params->recurrent_to_output_effective_bias))); const TfLiteTensor* input_gate_bias = is_layer_norm ? nullptr : GetInput(context, node, lstm::full::kInputGateBiasTensor); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, input_zero_point, input_to_input_weights, input_gate_bias, &(integer_lstm_params->input_to_input_effective_bias))); TF_LITE_ENSURE_OK( context, PrecomputeZeroPointTimesWeightWithBias( context, output_state_zero_point, recurrent_to_input_weights, nullptr, &(integer_lstm_params->recurrent_to_input_effective_bias))); TF_LITE_ENSURE_OK(context, PrecomputeZeroPointTimesWeightWithBias( context, hidden_zp, projection_weights, projection_bias, &(integer_lstm_params->projection_effective_bias))); return kTfLiteOk; }"
"inline void Response::set_header(const char *key, const char *val) { headers.emplace(key, val); }"
"static int check_assertion(struct config_module * config, json_t * j_params, const char * username, json_t * j_scheme_data, json_t * j_assertion) { int ret, res; unsigned char * client_data = NULL, * challenge_b64 = NULL, * auth_data = NULL, rpid_hash[32] = {0}, * flags, cdata_hash[32] = {0}, data_signed[128] = {0}, sig[128] = {0}, * counter; char * challenge_hash = NULL; const char * rpid = NULL; size_t client_data_len, challenge_b64_len, auth_data_len, rpid_hash_len = 32, cdata_hash_len = 32, sig_len = 128, counter_value = 0, rpid_len = 0; json_t * j_client_data = NULL, * j_credential = NULL, * j_query; gnutls_pubkey_t pubkey = NULL; gnutls_datum_t pubkey_dat, data, signature; if (j_scheme_data != NULL && j_assertion != NULL) { do { ret = G_OK; if (!json_is_string(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId"")) || !json_string_length(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - rawId missing""); ret = G_ERROR_PARAM; break; } j_credential = get_credential(config, j_params, username, json_string_value(json_object_get(json_object_get(j_scheme_data, ""credential""), ""rawId""))); if (check_result_value(j_credential, G_ERROR_NOT_FOUND)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - credential ID not found""); ret = G_ERROR_UNAUTHORIZED; break; } if (!json_is_string(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")) || !json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON mandatory""); ret = G_ERROR_PARAM; break; } if ((client_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON""))+1)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error allocating resources for client_data""); ret = G_ERROR_MEMORY; break; } if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""clientDataJSON"")), client_data, &client_data_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64_decode client_data""); ret = G_ERROR_PARAM; break; } client_data[client_data_len] = '\0'; j_client_data = json_loads((const char *)client_data, JSON_DECODE_ANY, NULL); if (j_client_data == NULL) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error parsing JSON client data %s"", client_data); ret = G_ERROR_PARAM; break; } if (0 != o_strcmp(""webauthn.get"", json_string_value(json_object_get(j_client_data, ""type"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.type invalid""); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(j_client_data, ""challenge""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge mandatory""); ret = G_ERROR_PARAM; break; } if ((challenge_b64 = o_malloc(json_string_length(json_object_get(j_client_data, ""challenge""))+3)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""register_new_attestation - Error allocating resources for challenge_b64""); ret = G_ERROR_MEMORY; break; } if (!o_base64url_2_base64((unsigned char *)json_string_value(json_object_get(j_client_data, ""challenge"")), json_string_length(json_object_get(j_client_data, ""challenge"")), challenge_b64, &challenge_b64_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge invalid base64""); ret = G_ERROR_PARAM; break; } challenge_b64[challenge_b64_len] = '\0'; if ((challenge_hash = generate_hash(config->hash_algorithm, (const char *)challenge_b64)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""register_new_attestation - Error generate_hash for challenge_b64""); ret = G_ERROR; break; } if (0 != o_strcmp(challenge_hash, json_string_value(json_object_get(j_assertion, ""challenge_hash"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.challenge invalid""); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(j_client_data, ""origin""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.origin mandatory""); ret = G_ERROR_PARAM; break; } if (0 != o_strcmp(json_string_value(json_object_get(j_params, ""rp-origin"")), json_string_value(json_object_get(j_client_data, ""origin"")))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - clientDataJSON.origin invalid - Client send %s, required %s"", json_string_value(json_object_get(j_client_data, ""origin"")), json_string_value(json_object_get(j_params, ""rp-origin""))); ret = G_ERROR_PARAM; break; } if (!json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authenticatorData mandatory""); ret = G_ERROR_PARAM; break; } if ((auth_data = o_malloc(json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData""))+1)) == NULL) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error allocating resources for auth_data""); ret = G_ERROR_PARAM; break; } if (!o_base64_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""authenticatorData"")), auth_data, &auth_data_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64_decode auth_data""); ret = G_ERROR_PARAM; break; } if (auth_data_len < 37) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error authenticatorData invalid""); ret = G_ERROR_PARAM; break; } if (o_strstr(json_string_value(json_object_get(j_params, ""rp-origin"")), "":        rpid = o_strstr(json_string_value(json_object_get(j_params, ""rp-origin"")), "":      } else { rpid = json_string_value(json_object_get(j_params, ""rp-origin"")); } if (o_strchr(rpid, ':') != NULL) { rpid_len = o_strchr(rpid, ':') - rpid; } else { rpid_len = o_strlen(rpid); } if (!generate_digest_raw(digest_SHA256, (unsigned char *)rpid, rpid_len, rpid_hash, &rpid_hash_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error generate_digest_raw for rpid_hash""); ret = G_ERROR_PARAM; break; } if (0 != memcmp(auth_data, rpid_hash, rpid_hash_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authData.rpIdHash invalid""); ret = G_ERROR_PARAM; break; } flags = auth_data + FLAGS_OFFSET; if (!(*flags & FLAG_USER_PRESENT)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - authData.userPresent not set""); ret = G_ERROR_PARAM; break; } if (!generate_digest_raw(digest_SHA256, client_data, client_data_len, cdata_hash, &cdata_hash_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error generate_digest_raw for cdata_hash""); ret = G_ERROR_PARAM; break; } counter = auth_data + COUNTER_OFFSET; counter_value = counter[3] | (counter[2] << 8) | (counter[1] << 16) | (counter[0] << 24); if (gnutls_pubkey_init(&pubkey) < 0) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error gnutls_pubkey_init""); ret = G_ERROR; break; } pubkey_dat.data = (unsigned char *)json_string_value(json_object_get(json_object_get(j_credential, ""credential""), ""public_key"")); pubkey_dat.size = json_string_length(json_object_get(json_object_get(j_credential, ""credential""), ""public_key"")); if ((ret = gnutls_pubkey_import(pubkey, &pubkey_dat, GNUTLS_X509_FMT_PEM)) < 0) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error gnutls_pubkey_import: %d"", ret); ret = G_ERROR; break; } if (!o_base64url_decode((const unsigned char *)json_string_value(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""signature"")), json_string_length(json_object_get(json_object_get(json_object_get(j_scheme_data, ""credential""), ""response""), ""signature"")), sig, &sig_len)) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Error o_base64url_decode signature""); ret = G_ERROR_PARAM; break; } memcpy(data_signed, auth_data, auth_data_len); memcpy(data_signed+auth_data_len, cdata_hash, cdata_hash_len); data.data = data_signed; data.size = (auth_data_len+cdata_hash_len); signature.data = sig; signature.size = sig_len; if ((res = gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) < 0) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - Invalid signature: %d"", res); ret = G_ERROR_UNAUTHORIZED; break; } if ((json_integer_value(json_object_get(json_object_get(j_credential, ""credential""), ""counter"")) || counter_value) && counter_value <= (size_t)json_integer_value(json_object_get(json_object_get(j_credential, ""credential""), ""counter""))) { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_assertion - counter invalid""); ret = G_ERROR_UNAUTHORIZED; break; } } while (0);  if (ret == G_OK) { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 1, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (1)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } else { if (counter) { j_query = json_pack(""{sss{si}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_CREDENTIAL, ""set"", ""gswc_counter"", counter_value, ""where"", ""gswc_id"", json_object_get(json_object_get(j_credential, ""credential""), ""gswc_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (2)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } } } else if (ret == G_ERROR_PARAM) { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 2, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (3)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } else { j_query = json_pack(""{sss{sisi}s{sO}}"", ""table"", G_TABLE_WEBAUTHN_ASSERTION, ""set"", ""gswa_counter"", counter_value, ""gswa_status"", 3, ""where"", ""gswa_id"", json_object_get(j_assertion, ""gswa_id"")); res = h_update(config->conn, j_query, NULL); json_decref(j_query); if (res != H_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""check_assertion - Error executing j_query (4)""); config->glewlwyd_module_callback_metrics_increment_counter(config, GLWD_METRICS_DATABSE_ERROR, 1, NULL); ret = G_ERROR_DB; } } o_free(client_data); o_free(challenge_b64); o_free(challenge_hash); o_free(auth_data); json_decref(j_client_data); json_decref(j_credential); gnutls_pubkey_deinit(pubkey); } else { ret = G_ERROR_PARAM; } return ret; }"
"static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop) { struct se_device *remote_dev; if (xop->op_origin == XCOL_SOURCE_RECV_OP) remote_dev = xop->dst_dev; else remote_dev = xop->src_dev; pr_debug(""Calling configfs_undepend_item for"" "" remote_dev: %p remote_dev->dev_group: %p\n"", remote_dev, &remote_dev->dev_group.cg_item); target_undepend_item(&remote_dev->dev_group.cg_item); }"
"static int printbuf_extend(struct printbuf *p, int min_size) { char *t; int new_size; if (p->size >= min_size) return 0; new_size = p->size * 2; if (new_size < min_size + 8) new_size = min_size + 8; #ifdef PRINTBUF_DEBUG MC_DEBUG(""printbuf_memappend: realloc "" ""bpos=%d min_size=%d old_size=%d new_size=%d\n"", p->bpos, min_size, p->size, new_size); #endif  if (!(t = (char *)realloc(p->buf, new_size))) return -1; p->size = new_size; p->buf = t; return 0; }"
void* H264SwDecMalloc(u32 size) { return malloc(size); }
"static PixelChannels **AcquirePixelThreadSet(const Image *images) { const Image *next; PixelChannels **pixels; register ssize_t i; size_t columns, number_threads; number_threads=(size_t) GetMagickResourceLimit(ThreadResource); pixels=(PixelChannels **) AcquireQuantumMemory(number_threads, sizeof(*pixels)); if (pixels == (PixelChannels **) NULL) return((PixelChannels **) NULL); (void) memset(pixels,0,number_threads*sizeof(*pixels)); columns=images->columns; for (next=images; next != (Image *) NULL; next=next->next) columns=MagickMax(next->columns,columns); for (i=0; i < (ssize_t) number_threads; i++) { register ssize_t j; pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels)); if (pixels[i] == (PixelChannels *) NULL) return(DestroyPixelThreadSet(pixels)); for (j=0; j < (ssize_t) columns; j++) { register ssize_t k; for (k=0; k < MaxPixelChannels; k++) pixels[i][j].channel[k]=0.0; } } return(pixels); }"
"int _sasl_add_string(char **out, size_t *alloclen, size_t *outlen, const char *add) { size_t addlen; if (add==NULL) add = ""(null)""; addlen=strlen(add);  if (_buf_alloc(out, alloclen, (*outlen)+addlen)!=SASL_OK) return SASL_NOMEM; strncpy(*out + *outlen, add, addlen); *outlen += addlen; return SASL_OK; }"
"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, int bytes) { TIFFSTATE *clientstate = (TIFFSTATE *)state->context; char *filename = ""tempfile.tif""; char *mode = ""r""; TIFF *tiff; int size; TRACE((""in decoder: bytes %d\n"", bytes)); TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state, state->x, state->y, state->ystep)); TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize, state->xoff, state->yoff)); TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes)); TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3])); TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3])); TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"", im->mode, im->type, im->bands, im->xsize, im->ysize)); TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"", im->image8, im->image32, im->image, im->block)); TRACE((""Image: pixelsize: %d, linesize %d \n"", im->pixelsize, im->linesize)); dump_state(clientstate); clientstate->size = bytes; clientstate->eof = clientstate->size; clientstate->loc = 0; clientstate->data = (tdata_t)buffer; clientstate->flrealloc = 0; dump_state(clientstate); TIFFSetWarningHandler(NULL); TIFFSetWarningHandlerExt(NULL); if (clientstate->fp) { TRACE((""Opening using fd: %d\n"",clientstate->fp)); lseek(clientstate->fp,0,SEEK_SET); tiff = TIFFFdOpen(clientstate->fp, filename, mode); } else { TRACE((""Opening from string\n"")); tiff = TIFFClientOpen(filename, mode, (thandle_t) clientstate, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); } if (!tiff){ TRACE((""Error, didn't get the tiff\n"")); state->errcode = IMAGING_CODEC_BROKEN; return -1; } if (clientstate->ifd){ int rv; unsigned int ifdoffset = clientstate->ifd; TRACE((""reading tiff ifd %d\n"", ifdoffset)); rv = TIFFSetSubDirectory(tiff, ifdoffset); if (!rv){ TRACE((""error in TIFFSetSubDirectory"")); return -1; } } size = TIFFScanlineSize(tiff); TRACE((""ScanlineSize: %d \n"", size)); if (size > state->bytes) { TRACE((""Error, scanline size > buffer size\n"")); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } while(state->y < state->ysize){ if (TIFFReadScanline(tiff, (tdata_t)state->buffer, (uint32)state->y, 0) == -1) { TRACE((""Decode Error, row %d\n"", state->y)); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } state->shuffle((UINT8*) im->image[state->y + state->yoff] + state->xoff * im->pixelsize, state->buffer, state->xsize); state->y++; } TIFFClose(tiff); TRACE((""Done Decoding, Returning \n"")); return -1; }"
"static struct mobj *alloc_ta_mem(size_t size) { #ifdef CFG_PAGED_USER_TA return mobj_paged_alloc(size); #else struct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr); if (mobj) memset(mobj_get_va(mobj, 0), 0, size); return mobj; #endif }"
"void PasswordGenerationAgent::ShowGenerationPopup() { Send(new AutofillHostMsg_ShowPasswordGenerationPopup( routing_id(), render_frame()->GetRenderView()->ElementBoundsInWindow( generation_element_), generation_element_.maxLength(), generation_element_.nameForAutofill(), is_manually_triggered_, *generation_form_data_->form)); generation_popup_shown_ = true; }"
"ACPI_STATUS AcpiDsCreateOperands ( ACPI_WALK_STATE         *WalkState, ACPI_PARSE_OBJECT       *FirstArg) { ACPI_STATUS             Status = AE_OK; ACPI_PARSE_OBJECT       *Arg; ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS]; UINT32                  ArgCount = 0; UINT32                  Index = WalkState->NumOperands; UINT32                  i; ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg); Arg = FirstArg; while (Arg) { if (Index >= ACPI_OBJ_NUM_OPERANDS) { return_ACPI_STATUS (AE_BAD_DATA); } Arguments[Index] = Arg; WalkState->Operands [Index] = NULL; Arg = Arg->Common.Next; ArgCount++; Index++; } ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, ""NumOperands %d, ArgCount %d, Index %d\n"", WalkState->NumOperands, ArgCount, Index)); Index--; for (i = 0; i < ArgCount; i++) { Arg = Arguments[Index]; WalkState->OperandIndex = (UINT8) Index; Status = AcpiDsCreateOperand (WalkState, Arg, Index); if (ACPI_FAILURE (Status)) { goto Cleanup; } ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, ""Created Arg #%u (%p) %u args total\n"", Index, Arg, ArgCount)); Index--; } return_ACPI_STATUS (Status); Cleanup: AcpiDsObjStackPopAndDelete (ArgCount, WalkState); ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index)); return_ACPI_STATUS (Status); }"
"int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info, struct btrfs_ioctl_get_dev_stats *stats) { struct btrfs_device *dev; struct btrfs_fs_devices *fs_devices = fs_info->fs_devices; int i; mutex_lock(&fs_devices->device_list_mutex); dev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL); mutex_unlock(&fs_devices->device_list_mutex); if (!dev) { btrfs_warn(fs_info, ""get dev_stats failed, device not found""); return -ENODEV; } else if (!dev->dev_stats_valid) { btrfs_warn(fs_info, ""get dev_stats failed, not yet valid""); return -ENODEV; } else if (stats->flags & BTRFS_DEV_STATS_RESET) { for (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) { if (stats->nr_items > i) stats->values[i] = btrfs_dev_stat_read_and_reset(dev, i); else btrfs_dev_stat_reset(dev, i); } } else { for (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) if (stats->nr_items > i) stats->values[i] = btrfs_dev_stat_read(dev, i); } if (stats->nr_items > BTRFS_DEV_STAT_VALUES_MAX) stats->nr_items = BTRFS_DEV_STAT_VALUES_MAX; return 0; }"
"int wasm_dis(WasmOp *op, const unsigned char *buf, int buf_len) { op->len = 1; op->op = buf[0]; if (op->op > 0xbf) { return 1; } WasmOpDef *opdef = &opcodes[op->op]; switch (op->op) { case WASM_OP_TRAP: case WASM_OP_NOP: case WASM_OP_ELSE: case WASM_OP_RETURN: case WASM_OP_DROP: case WASM_OP_SELECT: case WASM_OP_I32EQZ: case WASM_OP_I32EQ: case WASM_OP_I32NE: case WASM_OP_I32LTS: case WASM_OP_I32LTU: case WASM_OP_I32GTS: case WASM_OP_I32GTU: case WASM_OP_I32LES: case WASM_OP_I32LEU: case WASM_OP_I32GES: case WASM_OP_I32GEU: case WASM_OP_I64EQZ: case WASM_OP_I64EQ: case WASM_OP_I64NE: case WASM_OP_I64LTS: case WASM_OP_I64LTU: case WASM_OP_I64GTS: case WASM_OP_I64GTU: case WASM_OP_I64LES: case WASM_OP_I64LEU: case WASM_OP_I64GES: case WASM_OP_I64GEU: case WASM_OP_F32EQ: case WASM_OP_F32NE: case WASM_OP_F32LT: case WASM_OP_F32GT: case WASM_OP_F32LE: case WASM_OP_F32GE: case WASM_OP_F64EQ: case WASM_OP_F64NE: case WASM_OP_F64LT: case WASM_OP_F64GT: case WASM_OP_F64LE: case WASM_OP_F64GE: case WASM_OP_I32CLZ: case WASM_OP_I32CTZ: case WASM_OP_I32POPCNT: case WASM_OP_I32ADD: case WASM_OP_I32SUB: case WASM_OP_I32MUL: case WASM_OP_I32DIVS: case WASM_OP_I32DIVU: case WASM_OP_I32REMS: case WASM_OP_I32REMU: case WASM_OP_I32AND: case WASM_OP_I32OR: case WASM_OP_I32XOR: case WASM_OP_I32SHL: case WASM_OP_I32SHRS: case WASM_OP_I32SHRU: case WASM_OP_I32ROTL: case WASM_OP_I32ROTR: case WASM_OP_I64CLZ: case WASM_OP_I64CTZ: case WASM_OP_I64POPCNT: case WASM_OP_I64ADD: case WASM_OP_I64SUB: case WASM_OP_I64MUL: case WASM_OP_I64DIVS: case WASM_OP_I64DIVU: case WASM_OP_I64REMS: case WASM_OP_I64REMU: case WASM_OP_I64AND: case WASM_OP_I64OR: case WASM_OP_I64XOR: case WASM_OP_I64SHL: case WASM_OP_I64SHRS: case WASM_OP_I64SHRU: case WASM_OP_I64ROTL: case WASM_OP_I64ROTR: case WASM_OP_F32ABS: case WASM_OP_F32NEG: case WASM_OP_F32CEIL: case WASM_OP_F32FLOOR: case WASM_OP_F32TRUNC: case WASM_OP_F32NEAREST: case WASM_OP_F32SQRT: case WASM_OP_F32ADD: case WASM_OP_F32SUB: case WASM_OP_F32MUL: case WASM_OP_F32DIV: case WASM_OP_F32MIN: case WASM_OP_F32MAX: case WASM_OP_F32COPYSIGN: case WASM_OP_F64ABS: case WASM_OP_F64NEG: case WASM_OP_F64CEIL: case WASM_OP_F64FLOOR: case WASM_OP_F64TRUNC: case WASM_OP_F64NEAREST: case WASM_OP_F64SQRT: case WASM_OP_F64ADD: case WASM_OP_F64SUB: case WASM_OP_F64MUL: case WASM_OP_F64DIV: case WASM_OP_F64MIN: case WASM_OP_F64MAX: case WASM_OP_F64COPYSIGN: case WASM_OP_I32WRAPI64: case WASM_OP_I32TRUNCSF32: case WASM_OP_I32TRUNCUF32: case WASM_OP_I32TRUNCSF64: case WASM_OP_I32TRUNCUF64: case WASM_OP_I64EXTENDSI32: case WASM_OP_I64EXTENDUI32: case WASM_OP_I64TRUNCSF32: case WASM_OP_I64TRUNCUF32: case WASM_OP_I64TRUNCSF64: case WASM_OP_I64TRUNCUF64: case WASM_OP_F32CONVERTSI32: case WASM_OP_F32CONVERTUI32: case WASM_OP_F32CONVERTSI64: case WASM_OP_F32CONVERTUI64: case WASM_OP_F32DEMOTEF64: case WASM_OP_F64CONVERTSI32: case WASM_OP_F64CONVERTUI32: case WASM_OP_F64CONVERTSI64: case WASM_OP_F64CONVERTUI64: case WASM_OP_F64PROMOTEF32: case WASM_OP_I32REINTERPRETF32: case WASM_OP_I64REINTERPRETF64: case WASM_OP_F32REINTERPRETI32: case WASM_OP_F64REINTERPRETI64: case WASM_OP_END: { snprintf (op->txt, R_ASM_BUFSIZE, ""%s"", opdef->txt); } break; case WASM_OP_BLOCK: case WASM_OP_LOOP: case WASM_OP_IF: { st32 val = 0; size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; switch (0x80 - val) { case R_BIN_WASM_VALUETYPE_EMPTY: snprintf (op->txt, R_ASM_BUFSIZE, ""%s"", opdef->txt); break; case R_BIN_WASM_VALUETYPE_i32: snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result i32)"", opdef->txt); break; case R_BIN_WASM_VALUETYPE_i64: snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result i64)"", opdef->txt); break; case R_BIN_WASM_VALUETYPE_f32: snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result f32)"", opdef->txt); break; case R_BIN_WASM_VALUETYPE_f64: snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result f64)"", opdef->txt); break; default: snprintf (op->txt, R_ASM_BUFSIZE, ""%s (result ?)"", opdef->txt); break; } op->len += n; } break; case WASM_OP_BR: case WASM_OP_BRIF: case WASM_OP_CALL: { ut32 val = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, val); op->len += n; } break; case WASM_OP_BRTABLE: { ut32 count = 0, *table = NULL, def = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &count); if (!(n > 0 && n < buf_len)) { goto err; } if (!(table = calloc (count, sizeof (ut32)))) { goto err; } int i = 0; op->len += n; for (i = 0; i < count; i++) { n = read_u32_leb128 (buf + op->len, buf + buf_len, &table[i]); if (!(op->len + n <= buf_len)) { goto beach; } op->len += n; } n = read_u32_leb128 (buf + op->len, buf + buf_len, &def); if (!(n > 0 && n + op->len < buf_len)) { goto beach; } op->len += n; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d "", opdef->txt, count); for (i = 0; i < count && strlen (op->txt) + 10 < R_ASM_BUFSIZE; i++) { int optxtlen = strlen (op->txt); snprintf (op->txt + optxtlen, R_ASM_BUFSIZE - optxtlen, ""%d "", table[i]); } snprintf (op->txt + strlen (op->txt), R_ASM_BUFSIZE, ""%d"", def); free (table); break; beach: free (table); goto err; } break; case WASM_OP_CALLINDIRECT: { ut32 val = 0, reserved = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; op->len += n; n = read_u32_leb128 (buf + op->len, buf + buf_len, &reserved); if (!(n == 1 && op->len + n <= buf_len)) goto err; reserved &= 0x1; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d %d"", opdef->txt, val, reserved); op->len += n; } break; case WASM_OP_GETLOCAL: case WASM_OP_SETLOCAL: case WASM_OP_TEELOCAL: case WASM_OP_GETGLOBAL: case WASM_OP_SETGLOBAL: { ut32 val = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, val); op->len += n; } break; case WASM_OP_I32LOAD: case WASM_OP_I64LOAD: case WASM_OP_F32LOAD: case WASM_OP_F64LOAD: case WASM_OP_I32LOAD8S: case WASM_OP_I32LOAD8U: case WASM_OP_I32LOAD16S: case WASM_OP_I32LOAD16U: case WASM_OP_I64LOAD8S: case WASM_OP_I64LOAD8U: case WASM_OP_I64LOAD16S: case WASM_OP_I64LOAD16U: case WASM_OP_I64LOAD32S: case WASM_OP_I64LOAD32U: case WASM_OP_I32STORE: case WASM_OP_I64STORE: case WASM_OP_F32STORE: case WASM_OP_F64STORE: case WASM_OP_I32STORE8: case WASM_OP_I32STORE16: case WASM_OP_I64STORE8: case WASM_OP_I64STORE16: case WASM_OP_I64STORE32: { ut32 flag = 0, offset = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &flag); if (!(n > 0 && n < buf_len)) goto err; op->len += n; n = read_u32_leb128 (buf + op->len, buf + buf_len, &offset); if (!(n > 0 && op->len + n <= buf_len)) goto err; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d %d"", opdef->txt, flag, offset); op->len += n; } break; case WASM_OP_CURRENTMEMORY: case WASM_OP_GROWMEMORY: { ut32 reserved = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &reserved); if (!(n == 1 && n < buf_len)) goto err; reserved &= 0x1; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %d"", opdef->txt, reserved); op->len += n; } break; case WASM_OP_I32CONST: { st32 val = 0; size_t n = read_i32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" PFMT32d, opdef->txt, val); op->len += n; } break; case WASM_OP_I64CONST: { st64 val = 0; size_t n = read_i64_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" PFMT64d, opdef->txt, val); op->len += n; } break; case WASM_OP_F32CONST: { ut32 val = 0; size_t n = read_u32_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; long double d =  (long double)val; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" LDBLFMT, opdef->txt, d); op->len += n; } break; case WASM_OP_F64CONST: { ut64 val = 0; size_t n = read_u64_leb128 (buf + 1, buf + buf_len, &val); if (!(n > 0 && n < buf_len)) goto err; long double d =  (long double)val; snprintf (op->txt, R_ASM_BUFSIZE, ""%s %"" LDBLFMT, opdef->txt, d); op->len += n; } break; default: goto err; } return op->len; err: op->len = 1; snprintf (op->txt, R_ASM_BUFSIZE, ""invalid""); return op->len; }"
"void ScavengeVisitor::ScavengePointer(Object** p) { Object* object = *p; if (!heap_->InNewSpace(object)) return; if (heap_->PurgeLeftTrimmedObject(p)) return; Scavenger::ScavengeObject(reinterpret_cast<HeapObject**>(p), reinterpret_cast<HeapObject*>(object)); }"
"static void get_info_from_frame (mpeg2ps_stream_t *sptr, u8 *buffer, u32 buflen) { if (sptr->is_video) { if (MPEG12_ParseSeqHdr(buffer, buflen, &sptr->have_mpeg2, &sptr->h, &sptr->w, &sptr->frame_rate, &sptr->bit_rate, &sptr->par) < 0) { sptr->m_stream_id = 0; sptr->m_fd = FDNULL; } sptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate); return; } if (sptr->m_stream_id >= 0xc0) { u32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]); sptr->channels = gf_mp3_num_channels(hdr); sptr->freq = gf_mp3_sampling_rate(hdr); sptr->samples_per_frame = gf_mp3_window_size(hdr); sptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; sptr->layer = gf_mp3_layer(hdr); } else if (sptr->m_stream_id == 0xbd) { if (sptr->m_substream_id >= 0xa0) { } else if (sptr->m_substream_id >= 0x80) { u32 pos; GF_AC3Config hdr; memset(&hdr, 0, sizeof(GF_AC3Config)); gf_ac3_parser(buffer, buflen, &pos, &hdr, 0); sptr->bitrate = gf_ac3_get_bitrate(hdr.brcode); sptr->freq = hdr.sample_rate; sptr->channels = hdr.streams[0].channels; sptr->samples_per_frame = 256 * 6; } else { return; } } else { return; } }"
"static void g_variant_serialise (GVariant *value, gpointer  data) { GVariantSerialised serialised = { 0, }; gpointer *children; gsize n_children; g_assert (~value->state & STATE_SERIALISED); g_assert (value->state & STATE_LOCKED); serialised.type_info = value->type_info; serialised.size = value->size; serialised.data = data; serialised.depth = value->depth; children = (gpointer *) value->contents.tree.children; n_children = value->contents.tree.n_children; g_variant_serialiser_serialise (serialised, g_variant_fill_gvs, children, n_children); }"
"static void check_POLYLINE_handles (Dwg_Object *obj) { Dwg_Entity_POLYLINE_2D *_obj = obj->tio.entity->tio.POLYLINE_2D; Dwg_Data *dwg = obj->parent; if (dwg->header.version >= R_2004) { BITCODE_BL i = 0; Dwg_Object_Ref *layer = obj->tio.entity->layer; Dwg_Object_Ref *seqend = _obj->seqend; if (layer && !layer->obj) layer->obj = dwg_ref_object_relative (dwg, layer, obj); if (!layer || !layer->obj) {           LOG_WARN (""Wrong POLYLINE.layer %lX"", layer ? layer->handleref.value : 0L); if (_obj->num_owned > 0 && _obj->vertex) { Dwg_Object_Ref *vertex = _obj->vertex[0]; if (vertex && !vertex->obj) vertex->obj = dwg_ref_object_relative (dwg, vertex, obj); if (vertex && vertex->obj  && vertex->obj->fixedtype == DWG_TYPE_LAYER) { Dwg_Object *seq; obj->tio.entity->layer = layer = vertex; LOG_WARN ( ""POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"", layer->handleref.value); for (i = 0; i < _obj->num_owned - 1; i++) { _obj->vertex[i] = _obj->vertex[i + 1]; } _obj->vertex[_obj->num_owned - 1] = seqend; _obj->seqend = NULL; seq = dwg_next_object (obj); if (seq && seq->type == DWG_TYPE_SEQEND) { LOG_WARN (""POLYLINE.seqend = POLYLINE+1 %lX"", seq->handle.value); seqend = _obj->seqend = dwg_find_objectref (dwg, seq); } else { seq = dwg_next_object (seqend->obj); if (seq && seq->type == DWG_TYPE_SEQEND) { LOG_WARN (""POLYLINE.seqend = VERTEX+1 %lX"", seq->handle.value); seqend = _obj->seqend = dwg_find_objectref (dwg, seq); } } } } } else if (layer->obj->fixedtype != DWG_TYPE_LAYER && layer->obj->fixedtype != DWG_TYPE_DICTIONARY) {           LOG_WARN (""Wrong POLYLINE.layer %s"", layer->obj->dxfname) } if (!seqend || !seqend->handleref.value) { LOG_WARN (""Empty POLYLINE.seqend"") } else if (seqend->obj && seqend->obj->fixedtype != DWG_TYPE_SEQEND) {           LOG_WARN (""Wrong POLYLINE.seqend %s"", seqend->obj->dxfname) } if (!_obj->vertex) return; for (; i < _obj->num_owned; i++) { Dwg_Object_Ref *v = _obj->vertex[i]; if (!v || !v->handleref.value) { LOG_WARN (""Empty POLYLINE.vertex[%d]"", i); } else if (v->obj && v->obj->fixedtype != DWG_TYPE_VERTEX_2D && v->obj->fixedtype != DWG_TYPE_VERTEX_3D && v->obj->fixedtype != DWG_TYPE_VERTEX_MESH && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE && v->obj->fixedtype != DWG_TYPE_VERTEX_PFACE_FACE) { LOG_WARN (""Wrong POLYLINE.vertex[%d] %lX %s"", i, v->handleref.value, v->obj->dxfname) } } } }"
"void ElementAnimations::NotifyPlayersAnimationFinished( base::TimeTicks monotonic_time, TargetProperty::Type target_property, int group) { for (PlayersListNode* node = players_list_->head(); node != players_list_->end(); node = node->next()) { AnimationPlayer* player = node->value(); player->NotifyAnimationFinished(monotonic_time, target_property, group); } }"
"static void *load_bytes(RBinFile *arch, const ut8 *buf, ut64 sz, ut64 loaddr, Sdb *sdb) { if (!buf || !sz || sz == UT64_MAX) { return NULL; } RBuffer *tbuf = r_buf_new (); r_buf_set_bytes (tbuf, buf, sz); struct r_bin_bflt_obj *res = r_bin_bflt_new_buf (tbuf); r_buf_free (tbuf); return res ? res : NULL; }"
"int sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw, bool force) { sudo_auth *auth; debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH); for (auth = auth_switch; auth->name; auth++) { if (auth->cleanup && !IS_DISABLED(auth)) { int status = (auth->cleanup)(ctx, pw, auth, force); if (status == AUTH_ERROR) { debug_return_int(-1); } } } debug_return_int(0); }"
"int32_t *enc_untrusted_create_wait_queue() { MessageWriter input; MessageReader output; input.Push<uint64_t>(sizeof(int32_t)); const auto status = NonSystemCallDispatcher( ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_create_wait_queue"", 2); int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>()); int klinux_errno = output.next<int>(); if (queue == nullptr) { errno = FromkLinuxErrorNumber(klinux_errno); } enc_untrusted_disable_waiting(queue); return queue; }"
static void __reg_combine_64_into_32(struct bpf_reg_state *reg) { __mark_reg32_unbounded(reg); if (__reg64_bound_s32(reg->smin_value) && __reg64_bound_s32(reg->smax_value)) { reg->s32_min_value = (s32)reg->smin_value; reg->s32_max_value = (s32)reg->smax_value; } if (__reg64_bound_u32(reg->umin_value)) reg->u32_min_value = (u32)reg->umin_value; if (__reg64_bound_u32(reg->umax_value)) reg->u32_max_value = (u32)reg->umax_value; __reg_deduce_bounds(reg); __reg_bound_offset(reg); __update_reg_bounds(reg); }
"static int map_delete_elem(union bpf_attr *attr) { void __user *ukey = u64_to_user_ptr(attr->key); int ufd = attr->map_fd; struct bpf_map *map; struct fd f; void *key; int err; if (CHECK_ATTR(BPF_MAP_DELETE_ELEM)) return -EINVAL; f = fdget(ufd); map = __bpf_map_get(f); if (IS_ERR(map)) return PTR_ERR(map); if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) { err = -EPERM; goto err_put; } key = __bpf_copy_key(ukey, map->key_size); if (IS_ERR(key)) { err = PTR_ERR(key); goto err_put; } if (bpf_map_is_dev_bound(map)) { err = bpf_map_offload_delete_elem(map, key); goto out; } else if (IS_FD_PROG_ARRAY(map) || map->map_type == BPF_MAP_TYPE_STRUCT_OPS) { err = map->ops->map_delete_elem(map, key); goto out; } bpf_disable_instrumentation(); rcu_read_lock(); err = map->ops->map_delete_elem(map, key); rcu_read_unlock(); bpf_enable_instrumentation(); maybe_wait_bpf_programs(map); out: kvfree(key); err_put: fdput(f); return err; }"
"grub_err_t grub_disk_read (grub_disk_t disk, grub_disk_addr_t sector, grub_off_t offset, grub_size_t size, void *buf) { char *tmp_buf; unsigned real_offset; if (grub_disk_adjust_range (disk, &sector, &offset, size) != GRUB_ERR_NONE) { grub_error_push (); grub_dprintf (""disk"", ""Read out of range: sector 0x%llx (%s).\n"", (unsigned long long) sector, grub_errmsg); grub_error_pop (); return grub_errno; } real_offset = offset; tmp_buf = grub_malloc (GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS); if (! tmp_buf) return grub_errno; while (size) { char *data; grub_disk_addr_t start_sector; grub_size_t len; grub_size_t pos; start_sector = sector & ~(GRUB_DISK_CACHE_SIZE - 1); pos = (sector - start_sector) << GRUB_DISK_SECTOR_BITS; len = ((GRUB_DISK_SECTOR_SIZE << GRUB_DISK_CACHE_BITS) - pos - real_offset); if (len > size) len = size; data = grub_disk_cache_fetch (disk->dev->id, disk->id, start_sector); if (data) { if (buf) grub_memcpy (buf, data + pos + real_offset, len); grub_disk_cache_unlock (disk->dev->id, disk->id, start_sector); } else { if (start_sector + GRUB_DISK_CACHE_SIZE > disk->total_sectors || (disk->dev->read) (disk, start_sector, GRUB_DISK_CACHE_SIZE, tmp_buf) != GRUB_ERR_NONE) { unsigned num; char *p; grub_errno = GRUB_ERR_NONE; num = ((size + real_offset + GRUB_DISK_SECTOR_SIZE - 1) >> GRUB_DISK_SECTOR_BITS); p = grub_realloc (tmp_buf, num << GRUB_DISK_SECTOR_BITS); if (!p) goto finish; tmp_buf = p; if ((disk->dev->read) (disk, sector, num, tmp_buf)) { grub_error_push (); grub_dprintf (""disk"", ""%s read failed\n"", disk->name); grub_error_pop (); goto finish; } if (buf) grub_memcpy (buf, tmp_buf + real_offset, size); if (disk->read_hook) while (size) { grub_size_t to_read; to_read = size; if (real_offset + to_read > GRUB_DISK_SECTOR_SIZE) to_read = GRUB_DISK_SECTOR_SIZE - real_offset; (disk->read_hook) (sector, real_offset, to_read, disk->closure); if (grub_errno != GRUB_ERR_NONE) goto finish; sector++; size -= to_read; real_offset = 0; } goto finish; } if (buf) grub_memcpy (buf, tmp_buf + pos + real_offset, len); grub_disk_cache_store (disk->dev->id, disk->id, start_sector, tmp_buf); } if (disk->read_hook) { grub_disk_addr_t s = sector; grub_size_t l = len; while (l) { (disk->read_hook) (s, real_offset, ((l > GRUB_DISK_SECTOR_SIZE) ? GRUB_DISK_SECTOR_SIZE : l), disk->closure); if (l < GRUB_DISK_SECTOR_SIZE - real_offset) break; s++; l -= GRUB_DISK_SECTOR_SIZE - real_offset; real_offset = 0; } } sector = start_sector + GRUB_DISK_CACHE_SIZE; if (buf) buf = (char *) buf + len; size -= len; real_offset = 0; } finish: grub_free (tmp_buf); return grub_errno; }"
void Animation::createCompositorPlayer() { if (Platform::current()->isThreadedAnimationEnabled() && !m_compositorPlayer) { ASSERT(Platform::current()->compositorSupport()); m_compositorPlayer = CompositorAnimationPlayer::create(); ASSERT(m_compositorPlayer); m_compositorPlayer->setAnimationDelegate(this); attachCompositorTimeline(); } attachCompositedLayers(); }
"bool CradLoader::load(const std::string &filename, const CFileProvider &fp) { binistream *f = fp.open(filename); if(!f) return false; char id[16]; unsigned char buf,ch,c,b,inp; char bufstr[2] = ""\0""; unsigned int i,j; unsigned short patofs[32]; const unsigned char convfx[16] = {255,1,2,3,255,5,255,255,255,255,20,255,17,0xd,255,19}; f->readString(id, 16); version = f->readInt(1); if(strncmp(id,""RAD by REALiTY!!"",16) || version != 0x10) { fp.close(f); return false; } radflags = f->readInt(1); if(radflags & 128) {    memset(desc,0,80*22); while((buf = f->readInt(1))) if(buf == 1) strcat(desc,""\n""); else if(buf >= 2 && buf <= 0x1f) for(i=0;i<buf;i++) strcat(desc,"" ""); else { *bufstr = buf; strcat(desc,bufstr); } } while((buf = f->readInt(1))) {    buf--; inst[buf].data[2] = f->readInt(1); inst[buf].data[1] = f->readInt(1); inst[buf].data[10] = f->readInt(1); inst[buf].data[9] = f->readInt(1); inst[buf].data[4] = f->readInt(1); inst[buf].data[3] = f->readInt(1); inst[buf].data[6] = f->readInt(1); inst[buf].data[5] = f->readInt(1); inst[buf].data[0] = f->readInt(1); inst[buf].data[8] = f->readInt(1); inst[buf].data[7] = f->readInt(1); } length = f->readInt(1); for(i = 0; i < length; i++) order[i] = f->readInt(1);  for(i = 0; i < 32; i++) patofs[i] = f->readInt(2);  init_trackord();  for(i=0;i<32;i++) if(patofs[i]) { f->seek(patofs[i]); do { buf = f->readInt(1); b = buf & 127; do { ch = f->readInt(1); c = ch & 127; inp = f->readInt(1); tracks[i*9+c][b].note = inp & 127; tracks[i*9+c][b].inst = (inp & 128) >> 3; inp = f->readInt(1); tracks[i*9+c][b].inst += inp >> 4; tracks[i*9+c][b].command = inp & 15; if(inp & 15) { inp = f->readInt(1); tracks[i*9+c][b].param1 = inp / 10; tracks[i*9+c][b].param2 = inp % 10; } } while(!(ch & 128)); } while(!(buf & 128)); } else memset(trackord[i],0,9*2); fp.close(f); for(i=0;i<32*9;i++)    for(j=0;j<64;j++) { if(tracks[i][j].note == 15) tracks[i][j].note = 127; if(tracks[i][j].note > 16 && tracks[i][j].note < 127) tracks[i][j].note -= 4 * (tracks[i][j].note >> 4); if(tracks[i][j].note && tracks[i][j].note < 126) tracks[i][j].note++; tracks[i][j].command = convfx[tracks[i][j].command]; } restartpos = 0; initspeed = radflags & 31; bpm = radflags & 64 ? 0 : 50; flags = Decimal; rewind(0); return true; }"
"Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env) { session_ = 0; request_ = request; env_ = env; clear();  sessionInitialize(); if (!sessionActive() && !isAuthNeeded()) sessionStart(); if (isBanned()) { status(403, ""Forbidden""); print(QObject::tr(""Your IP address has been banned after too many failed authentication attempts.""), Http::CONTENT_TYPE_TXT); } else { processRequest(); } return response(); }"
"static int save_dev(blkid_dev dev, FILE *file) { struct list_head *p; if (!dev || dev->bid_name[0] != '/') return 0; DBG(SAVE, ul_debug(""device %s, type %s"", dev->bid_name, dev->bid_type ? dev->bid_type : ""(null)"")); fprintf(file, ""<device DEVNO=\""0x%04lx\"" TIME=\""%ld.%ld\"""", (unsigned long) dev->bid_devno, (long) dev->bid_time, (long) dev->bid_utime); if (dev->bid_pri) fprintf(file, "" PRI=\""%d\"""", dev->bid_pri); list_for_each(p, &dev->bid_tags) { blkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags); fprintf(file, "" %s=\""%s\"""", tag->bit_name,tag->bit_val); } fprintf(file, "">%s</device>\n"", dev->bid_name); return 0; }"
"static void print_include_directory_details(Dwarf_Debug dbg, unsigned int line_version, Dwarf_Line_Context line_context) { Dwarf_Unsigned u = 0; dwarfstring    m4; Dwarf_Unsigned indexbase = 0; Dwarf_Unsigned indexlimit = 0; dwarfstring_constructor_static(&m4,locallinebuf, sizeof(locallinebuf)); if (line_version == DW_LINE_VERSION5) { unsigned i = 0; unsigned dfcount = line_context->lc_directory_entry_format_count; dwarfstring_constructor(&m4); dwarfstring_append_printf_u(&m4, ""  directory entry format count %u\n"",dfcount); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); for ( ; i < dfcount;++i) { struct Dwarf_Unsigned_Pair_s *valpair = 0; const char *tname = 0; const char *fname = 0; int res; valpair = line_context->lc_directory_format_values +i; dwarfstring_append_printf_u(&m4, ""  format [%2u] "",i); res = dwarf_get_LNCT_name(valpair->up_first, &tname); if ( res != DW_DLV_OK) { tname = ""<unknown type>""; } dwarfstring_append_printf_u (&m4, "" type 0x%"" DW_PR_XZEROS DW_PR_DUx ,valpair->up_first); dwarfstring_append_printf_s (&m4, "" %-20s\n"",(char *)tname); res = dwarf_get_FORM_name(valpair->up_second,&fname); if ( res != DW_DLV_OK) { fname = ""<unknown form>""; } dwarfstring_append_printf_u(&m4, ""               code 0x%"" DW_PR_XZEROS DW_PR_DUx , valpair->up_second); dwarfstring_append_printf_s(&m4, "" %-20s\n"", (char *)fname); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); } } if (line_version == DW_LINE_VERSION5) { dwarfstring_append_printf_i(&m4, ""  include directories count %d\n"", (int) line_context->lc_include_directories_count); } else { if(!line_context->lc_include_directories_count) { dwarfstring_append_printf_i(&m4, ""  include directories count %d\n"", (int) line_context->lc_include_directories_count); } else { dwarfstring_append_printf_i(&m4, ""  include directories count %d"" "" (index starts at 1)\n"", (int) line_context->lc_include_directories_count); } } _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); if (line_version == DW_LINE_VERSION5) { indexbase = 0; indexlimit =  line_context->lc_include_directories_count; } else { indexbase = 1; indexlimit = 1 + line_context->lc_include_directories_count; } for (u = indexbase; u < indexlimit; ++u) { dwarfstring_append_printf_u(&m4, ""  include dir[%u] "",u); dwarfstring_append_printf_s(&m4, ""%s\n"",(char *) line_context->lc_include_directories[u-indexbase]); _dwarf_printf(dbg,dwarfstring_string(&m4)); dwarfstring_reset(&m4); } dwarfstring_destructor(&m4); }"
"void VpnDbus::connect(const QString &preferredServer, const QList<QString> &servers, const QString &username, const QString &passwd, const QString &extraArgs) { inner->connect(preferredServer, username, passwd, extraArgs); }"
CachedDocumentParameters::CachedDocumentParameters(Document* document) { ASSERT(isMainThread()); ASSERT(document); doHtmlPreloadScanning = !document->settings() || document->settings()->doHtmlPreloadScanning(); doDocumentWritePreloadScanning = doHtmlPreloadScanning && document->frame() && document->frame()->isMainFrame(); defaultViewportMinWidth = document->viewportDefaultMinWidth(); viewportMetaZeroValuesQuirk = document->settings() && document->settings()->viewportMetaZeroValuesQuirk(); viewportMetaEnabled = document->settings() && document->settings()->viewportMetaEnabled(); referrerPolicy = ReferrerPolicyDefault; }
"static void xmt_new_od_link(GF_XMTParser *parser, GF_ObjectDescriptor *od, char *name, u32 ID) { u32 i, j, count; XMT_ODLink *odl; if (!ID) { if (!strnicmp(name, ""od"", 2)) ID = atoi(name + 2); else if (!strnicmp(name, ""iod"", 3)) ID = atoi(name+ 3); else if (sscanf(name, ""%u"", &ID) == 1) { char szURL[20]; sprintf(szURL, ""%u"", ID); if (strcmp(szURL, name)) { ID = 0; } else { name = NULL; } } } count = gf_list_count(parser->od_links); for (i=0; i<count; i++) { odl = (XMT_ODLink*)gf_list_get(parser->od_links, i); if ( (ID && (odl->ID == ID)) || (odl->od == od) || (odl->desc_name && name && !strcmp(odl->desc_name, name)) ) { if (!odl->od) odl->od = od; if (!odl->desc_name && name) odl->desc_name = gf_strdup(name); if (!od->objectDescriptorID) { od->objectDescriptorID = ID; } else if (ID && (od->objectDescriptorID != ID)) { xmt_report(parser, GF_BAD_PARAM, ""Conflicting OD IDs %d vs %d\n"", ID, od->objectDescriptorID); } for (j=i+1; j<count; j++) { XMT_ODLink *l2 = (XMT_ODLink*)gf_list_get(parser->od_links, j); if (l2->od == od) { odl->ID = od->objectDescriptorID = odl->od->objectDescriptorID; gf_list_rem(parser->od_links, j); if (l2->desc_name) gf_free(l2->desc_name); gf_list_del(l2->mf_urls); gf_free(l2); break; } } return; } } GF_SAFEALLOC(odl, XMT_ODLink); if (!odl) return; odl->mf_urls = gf_list_new(); odl->od = od; if (ID) od->objectDescriptorID = ID; if (name) odl->desc_name = gf_strdup(name); gf_list_add(parser->od_links, odl); }"
"static int dissect_vlan(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) { proto_item *ti; guint16 tci, vlan_id; guint16 encap_proto; gboolean is_802_2; proto_tree *vlan_tree; proto_item *item; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""VLAN""); col_clear(pinfo->cinfo, COL_INFO); tci = tvb_get_ntohs( tvb, 0 ); vlan_id = tci & 0xFFF; if (pinfo->vlan_id == 0) { pinfo->vlan_id = vlan_id; } columns_set_vlan(pinfo->cinfo, tci); vlan_tree = NULL; if (tree) { ti = proto_tree_add_item(tree, hfi_vlan, tvb, 0, 4, ENC_NA); if (vlan_summary_in_tree) { proto_item_append_text(ti, "", PRI: %u, CFI: %u, ID: %u"", (tci >> 13), ((tci >> 12) & 1), vlan_id); } vlan_tree = proto_item_add_subtree(ti, ett_vlan); proto_tree_add_item(vlan_tree, &hfi_vlan_priority, tvb, 0, 2, ENC_BIG_ENDIAN); proto_tree_add_item(vlan_tree, &hfi_vlan_cfi, tvb, 0, 2, ENC_BIG_ENDIAN); proto_tree_add_item(vlan_tree, &hfi_vlan_id, tvb, 0, 2, ENC_BIG_ENDIAN); if (gbl_resolv_flags.vlan_name) { item = proto_tree_add_string(vlan_tree, &hfi_vlan_id_name, tvb, 0, 2, get_vlan_name(wmem_packet_scope(), vlan_id)); PROTO_ITEM_SET_GENERATED(item); } } encap_proto = tvb_get_ntohs(tvb, 2); if (encap_proto <= IEEE_802_3_MAX_LEN) { is_802_2 = TRUE; if (tvb_captured_length_remaining(tvb, 4) >= 2) { if (tvb_get_ntohs(tvb, 4) == 0xffff) { is_802_2 = FALSE; } } dissect_802_3(encap_proto, is_802_2, tvb, 4, pinfo, tree, vlan_tree, hfi_vlan_len.id, hfi_vlan_trailer.id, &ei_vlan_len, 0); } else { ethertype_data_t ethertype_data; ethertype_data.etype = encap_proto; ethertype_data.offset_after_ethertype = 4; ethertype_data.fh_tree = vlan_tree; ethertype_data.etype_id = hfi_vlan_etype.id; ethertype_data.trailer_id = hfi_vlan_trailer.id; ethertype_data.fcs_len = 0; call_dissector_with_data(ethertype_handle, tvb, pinfo, tree, &ethertype_data); } return tvb_captured_length(tvb); }"
"int detach_capi_ctr(struct capi_ctr *ctr) { int err = 0; mutex_lock(&capi_controller_lock); ctr_down(ctr, CAPI_CTR_DETACHED); if (capi_controller[ctr->cnr - 1] != ctr) { err = -EINVAL; goto unlock_out; } capi_controller[ctr->cnr - 1] = NULL; ncontrollers--; if (ctr->procent) remove_proc_entry(ctr->procfn, NULL); printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"", ctr->cnr, ctr->name); unlock_out: mutex_unlock(&capi_controller_lock); return err; }"
"static void _toggle_guest_pt(struct vcpu *v) { const struct domain *d = v->domain; v->arch.flags ^= TF_kernel_mode; update_cr3(v); if ( d->arch.pv.xpti ) { struct cpu_info *cpu_info = get_cpu_info(); cpu_info->root_pgt_changed = true; cpu_info->pv_cr3 = __pa(this_cpu(root_pgt)) | (d->arch.pv.pcid ? get_pcid_bits(v, true) : 0); } write_cr3(v->arch.cr3); if ( !(v->arch.flags & TF_kernel_mode) ) return; if ( v->arch.pv.need_update_runstate_area && update_runstate_area(v) ) v->arch.pv.need_update_runstate_area = 0; if ( v->arch.pv.pending_system_time.version && update_secondary_system_time(v, &v->arch.pv.pending_system_time) ) v->arch.pv.pending_system_time.version = 0; }"
"void FixExtensionMap(extension_map_t *map) { int i, extension_size, max_elements; if (( map->size & 0x3 ) != 0 ) { printf(""PANIC! - Verify map id %i: WARNING: map size %i not aligned!\n"", map->map_id, map->size); exit(255); } if ( ((int)map->size - (int)sizeof(extension_map_t)) <= 0 ) { printf(""PANIC! - Verify map id %i: ERROR: map size %i too small!\n"", map->map_id, map->size); exit(255); } max_elements = (map->size - sizeof(extension_map_t)) / sizeof(uint16_t); extension_size = 0; i=0; while (map->ex_id[i] && i <= max_elements) { int id = map->ex_id[i]; if ( id > Max_num_extensions ) { printf(""PANIC! - Verify map id %i: ERROR: element id %i out of range [%i]!\n"", map->map_id, id, Max_num_extensions); } extension_size += extension_descriptor[id].size; i++; } if ( (extension_size != map->extension_size ) ) { #ifdef DEVEL printf(""FixExtension map extension size from %i to %i\n"", map->extension_size, extension_size); #endif map->extension_size = extension_size; } if ( (i != max_elements ) && ((max_elements-i) != 1) ) { printf(""Verify map id %i: ERROR: Expected %i elements in map, but found %i!\n"", map->map_id, max_elements, i); } }"
"static int iccompareproc(i_ctx_t *i_ctx_p, ref *space, ref *testspace) { int code1, code2; ref ICCdict1, ICCdict2, *tempref1, *tempref2; int buff_size; code1 = array_get(imemory, space, 1, &ICCdict1); if (code1 < 0) return 0; code2 = array_get(imemory, testspace, 1, &ICCdict2); if (code2 < 0) return 0; if (ICCdict1.value.bytes == ICCdict2.value.bytes)  return 1; code1 = dict_find_string(&ICCdict1, ""N"", &tempref1); code2 = dict_find_string(&ICCdict2, ""N"", &tempref2); if (code1 != code2) return 0; if (tempref1->value.intval != tempref2->value.intval) return 0; if (!comparedictkey(i_ctx_p, &ICCdict1, &ICCdict2, (char *)""Range"")) return 0; code1 = dict_find_string(&ICCdict1, ""DataSource"", &tempref1); if (code1 <= 0) return 0; code2 = dict_find_string(&ICCdict2, ""DataSource"", &tempref2); if (code2 <= 0) return 0; if (r_size(tempref1) != r_size(tempref2))  return 0; buff_size = r_size(tempref1); if (memcmp(tempref1->value.const_bytes, tempref2->value.const_bytes, buff_size) == 0) return 1; else return 0; }"
"static QSvgNode *createPathNode(QSvgNode *parent, const QXmlStreamAttributes &attributes, QSvgHandler *) { QStringRef data      = attributes.value(QLatin1String(""d"")); QPainterPath qpath; qpath.setFillRule(Qt::WindingFill); parsePathDataFast(data, qpath); QSvgNode *path = new QSvgPath(parent, qpath); return path; }"
"static cmd_rec *make_ftp_cmd(pool *p, char *buf, size_t buflen, int flags) { register unsigned int i, j; char *arg, *ptr, *wrd; size_t arg_len; cmd_rec *cmd; pool *subpool; array_header *tarr; int have_crnul = FALSE, str_flags = PR_STR_FL_PRESERVE_COMMENTS|flags; if (PR_ISSPACE(buf[0])) { pr_trace_msg(""ctrl"", 5, ""command '%s' has illegal leading whitespace, rejecting"", buf); errno = EINVAL; return NULL; } ptr = buf; wrd = pr_str_get_word(&ptr, str_flags); if (wrd == NULL) { pr_trace_msg(""ctrl"", 5, ""command '%s' is empty, ignoring"", buf); errno = ENOENT; return NULL; } subpool = make_sub_pool(p); pr_pool_tag(subpool, ""make_ftp_cmd pool""); cmd = pcalloc(subpool, sizeof(cmd_rec)); cmd->pool = subpool; cmd->tmp_pool = NULL; cmd->stash_index = -1; cmd->stash_hash = 0; tarr = make_array(cmd->pool, 2, sizeof(char *)); *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd); cmd->argc++; arg_len = buflen - strlen(wrd); arg = pcalloc(cmd->pool, arg_len + 1); for (i = 0, j = 0; i < arg_len; i++) { pr_signals_handle(); if (i > 1 && ptr[i] == '\0' && ptr[i-1] == '\r') { have_crnul = TRUE; } else { arg[j++] = ptr[i]; } } cmd->arg = arg; if (have_crnul) { char *dup_arg; dup_arg = pstrdup(cmd->pool, arg); ptr = dup_arg; } while ((wrd = pr_str_get_word(&ptr, str_flags)) != NULL) { pr_signals_handle(); *((char **) push_array(tarr)) = pstrdup(cmd->pool, wrd); cmd->argc++; } *((char **) push_array(tarr)) = NULL; cmd->argv = tarr->elts; pr_pool_tag(cmd->pool, cmd->argv[0]); cmd->notes = pr_table_nalloc(cmd->pool, 0, 8); return cmd; }"
"struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) { size_t i, len = strlen(name); for (i = 0; hm->header_names[i].len > 0; i++) { struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i]; if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len)) return v; } return NULL; }"
void my_output_message( j_common_ptr ) {}
"static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc, unsigned int *rsize) { unsigned long quirks = (unsigned long)hid_get_drvdata(hdev); unsigned int i; if (!(quirks & CP_RDESC_SWAPPED_MIN_MAX)) return rdesc; for (i = 0; i < *rsize - 4; i++) if (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) { __u8 tmp; rdesc[i] = 0x19; rdesc[i + 2] = 0x29; tmp = rdesc[i + 3]; rdesc[i + 3] = rdesc[i + 1]; rdesc[i + 1] = tmp; } return rdesc; }"
"static inline int r_asm_pseudo_incbin(RAsmOp *op, char *input) { int bytes_read = 0; r_str_replace_char (input, ',', ' '); r_str_word_set0 (input); int skip = (int)r_num_math (NULL, r_str_word_get0 (input, 1)); int count = (int)r_num_math (NULL,r_str_word_get0 (input, 2)); char *content = r_file_slurp (input, &bytes_read); if (skip > 0) { skip = skip > bytes_read ? bytes_read : skip; } if (count > 0) { count = count > bytes_read ? 0 : count; } else { count = bytes_read; } r_buf_free (op->buf_inc); op->buf_inc = r_buf_new_with_string (content + skip); free (content); return count; }"
"int  dlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx) { tcpeditdlt_plugin_t *plugin; assert(ctx); if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) { tcpedit_seterr(ctx->tcpedit, ""Unable to cleanup unregistered plugin %s"", dlt_name); return TCPEDIT_ERROR; } safe_free(plugin->name); plugin->name = NULL; if (plugin->config != NULL) { jnpr_ether_config_t *config; config = (jnpr_ether_config_t *)ctx->encoder->config; tcpedit_dlt_cleanup(config->subctx); safe_free(config->subctx); safe_free(plugin->config); plugin->config = NULL; plugin->config_size = 0; } return TCPEDIT_OK;  }"
"Animation::Animation(ExecutionContext* executionContext, AnimationTimeline& timeline, AnimationEffect* content) : ActiveScriptWrappable(this) , ActiveDOMObject(executionContext) , m_playState(Idle) , m_playbackRate(1) , m_startTime(nullValue()) , m_holdTime(0) , m_sequenceNumber(nextSequenceNumber()) , m_content(content) , m_timeline(&timeline) , m_paused(false) , m_held(false) , m_isPausedForTesting(false) , m_isCompositedAnimationDisabledForTesting(false) , m_outdated(false) , m_finished(true) , m_compositorState(nullptr) , m_compositorPending(false) , m_compositorGroup(0) , m_currentTimePending(false) , m_stateIsBeingUpdated(false) , m_effectSuppressed(false) { if (m_content) { if (m_content->animation()) { m_content->animation()->cancel(); m_content->animation()->setEffect(0); } m_content->attach(this); } InspectorInstrumentation::didCreateAnimation(m_timeline->document(), m_sequenceNumber); }"
"void qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line, const char *fmt, ...) { va_list va; struct va_format vaf; char nfunc[32]; memset(nfunc, 0, sizeof(nfunc)); memcpy(nfunc, func, sizeof(nfunc) - 1); va_start(va, fmt); vaf.fmt = fmt; vaf.va = &va; if (!(qedi_dbg_log & QEDI_LOG_NOTICE)) goto ret; if (likely(qedi) && likely(qedi->pdev)) pr_notice(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev), nfunc, line, qedi->host_no, &vaf); else pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf); ret: va_end(va); }"
"HANDLE create_token (cygsid &usersid, user_groups &new_groups) { NTSTATUS status; LSA_HANDLE lsa = NULL; cygsidlist tmp_gsids (cygsidlist_auto, 12); SECURITY_QUALITY_OF_SERVICE sqos = { sizeof sqos, SecurityImpersonation, SECURITY_STATIC_TRACKING, FALSE }; OBJECT_ATTRIBUTES oa = { sizeof oa, 0, 0, 0, 0, &sqos }; LUID auth_luid = SYSTEM_LUID; LARGE_INTEGER exp = { QuadPart:INT64_MAX }; TOKEN_USER user; PTOKEN_GROUPS new_tok_gsids = NULL; PTOKEN_PRIVILEGES privs = NULL; TOKEN_OWNER owner; TOKEN_PRIMARY_GROUP pgrp; TOKEN_DEFAULT_DACL dacl = {}; TOKEN_SOURCE source; TOKEN_STATISTICS stats; memcpy (source.SourceName, ""Cygwin.1"", 8); source.SourceIdentifier.HighPart = 0; source.SourceIdentifier.LowPart = 0x0101; HANDLE token = INVALID_HANDLE_VALUE; HANDLE primary_token = INVALID_HANDLE_VALUE; PTOKEN_GROUPS my_tok_gsids = NULL; cygpsid mandatory_integrity_sid; ULONG size; size_t psize = 0; push_self_privilege (SE_CREATE_TOKEN_PRIVILEGE, true); if (!(lsa = lsa_open_policy (NULL, POLICY_EXECUTE))) goto out; user.User.Sid = usersid; user.User.Attributes = 0; owner.Owner = usersid; if (hProcToken) { if (usersid == well_known_system_sid) ; else { status = NtQueryInformationToken (hProcToken, TokenStatistics, &stats, sizeof stats, &size); if (!NT_SUCCESS (status)) debug_printf (""NtQueryInformationToken(hProcToken, "" ""TokenStatistics), %y"", status); else auth_luid = stats.AuthenticationId; } status = NtQueryInformationToken (hProcToken, TokenGroups, NULL, 0, &size); if (!NT_SUCCESS (status) && status != STATUS_BUFFER_TOO_SMALL) debug_printf (""NtQueryInformationToken(hProcToken, TokenGroups), %y"", status); else if (!(my_tok_gsids = (PTOKEN_GROUPS) malloc (size))) debug_printf (""malloc (my_tok_gsids) failed.""); else { status = NtQueryInformationToken (hProcToken, TokenGroups, my_tok_gsids, size, &size); if (!NT_SUCCESS (status)) { debug_printf (""NtQueryInformationToken(hProcToken, TokenGroups), "" ""%y"", status); free (my_tok_gsids); my_tok_gsids = NULL; } } } int auth_pos; if (new_groups.issetgroups ()) get_setgroups_sidlist (tmp_gsids, usersid, my_tok_gsids, new_groups, auth_luid, auth_pos); else if (!get_initgroups_sidlist (tmp_gsids, usersid, new_groups.pgsid, my_tok_gsids, auth_luid, auth_pos)) goto out; pgrp.PrimaryGroup = new_groups.pgsid; new_tok_gsids = (PTOKEN_GROUPS) alloca (sizeof (DWORD) + (tmp_gsids.count () + 1) * sizeof (SID_AND_ATTRIBUTES)); new_tok_gsids->GroupCount = tmp_gsids.count (); for (DWORD i = 0; i < new_tok_gsids->GroupCount; ++i) { new_tok_gsids->Groups[i].Sid = tmp_gsids.sids[i]; new_tok_gsids->Groups[i].Attributes = SE_GROUP_MANDATORY | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED; } if (auth_pos >= 0) new_tok_gsids->Groups[auth_pos].Attributes |= SE_GROUP_LOGON_ID; if (!(privs = get_priv_list (lsa, usersid, tmp_gsids, psize, &mandatory_integrity_sid))) goto out; if (wincap.has_mandatory_integrity_control ()) { new_tok_gsids->Groups[new_tok_gsids->GroupCount].Attributes = SE_GROUP_INTEGRITY | SE_GROUP_INTEGRITY_ENABLED; new_tok_gsids->Groups[new_tok_gsids->GroupCount++].Sid = mandatory_integrity_sid; } status = NtCreateToken (&token, TOKEN_ALL_ACCESS, &oa, TokenImpersonation, &auth_luid, &exp, &user, new_tok_gsids, privs, &owner, &pgrp, &dacl, &source); if (status) __seterrno_from_nt_status (status); else { if (!DuplicateTokenEx (token, MAXIMUM_ALLOWED, &sec_none, SecurityImpersonation, TokenPrimary, &primary_token)) { __seterrno (); debug_printf (""DuplicateTokenEx %E""); } } out: pop_self_privilege (); if (token != INVALID_HANDLE_VALUE) CloseHandle (token); if (privs) free (privs); if (my_tok_gsids) free (my_tok_gsids); lsa_close_policy (lsa); debug_printf (""%p = create_token ()"", primary_token); return primary_token; }"
"bool elf_access_ok(struct elf_binary * elf, uint64_t ptrval, size_t size) { if ( elf_ptrval_in_range(ptrval, size, elf->image_base, elf->size) ) return 1; if ( elf_ptrval_in_range(ptrval, size, elf->dest_base, elf->dest_size) ) return 1; if ( elf_ptrval_in_range(ptrval, size, elf->caller_xdest_base, elf->caller_xdest_size) ) return 1; elf_mark_broken(elf, ""out of range access""); return 0; }"
"WOURLError WOParseApplicationName(WOURLComponents *wc, const char *url) { int len; const char *s; const char *webobjects, *extension, *version, *start, *end; int i; len = strlen(url); webobjects = NULL; s = (url != NULL) ? url : """"; while ( (s <= url + (len - WebObjects_LEN)) && (webobjects == NULL) && (*s != '?') ) { while ((*s != '/') && (s <= url + (len - WebObjects_LEN))) s++; if ((strncmp(s, WebObjects_STR, WebObjects_LEN) == 0) || (strncmp(s, WEBOBJECTS_STR, WebObjects_LEN) == 0) ) webobjects = s; else s++; } if (webobjects == NULL) return WOURLInvalidPrefix; s = webobjects + WebObjects_LEN; for (end = s; (end < url + len) && (*end != '?') && (*end != '/'); end++) ; version = (*s == '-') ? s : NULL; extension = NULL; for (i=0; (extension == NULL) && (cgi_extensions[i] != NULL); i++) { int n = strlen(cgi_extensions[i]); if ((end - n >= version) && (strncmp(end-n, cgi_extensions[i], n) == 0)) extension = end - n; } if (extension != NULL) { if (version && ((extension - (version+1) < 1) || ( !isdigit((int)*(extension-1)) ))) return WOURLInvalidWebObjectsVersion; } else if (version != NULL) { if ((end - (version+1) < 1) || ( !isdigit((int)*(end-1)) )) return WOURLInvalidWebObjectsVersion; } else if ((end - s) > 1 ) return WOURLInvalidPrefix; wc->prefix.start = url; wc->prefix.length = end - url; if (version != NULL) { wc->webObjectsVersion.start = version + 1; wc->webObjectsVersion.length = ((extension) ? extension : end)-version; } start = ((end < url + len) && (*end != '?')) ? end + 1 : end; end = url + len; extension = end; for (i=0; (extension == end) && (app_extensions[i] != NULL); i++) { int n = strlen(app_extensions[i]); for (s=start; (s+n <= url+len) && (*s != '?') && (extension == end); ++s) { if ( (strncmp(s, app_extensions[i], n) == 0) && ((s + n == url + len) || (*(s+n) == '?') || (*(s+n) == '/')) ) { extension = s; end = s + n; } } if (*s == '?') end = s; } wc->applicationName.length = (end < extension) ? end - start : extension - start; if (wc->applicationName.length != 0) { wc->applicationName.start = start; while(wc->applicationName.length && wc->applicationName.start[wc->applicationName.length-1] == '/') wc->applicationName.length--; return WOURLOK; } else return WOURLInvalidApplicationName; }"
"bool XRef::readXRefTable(Parser *parser, Goffset *pos, std::vector<Goffset> *followedXRefStm, std::vector<int> *xrefStreamObjsNum) { XRefEntry entry; bool more; Object obj, obj2; Goffset pos2; int first, n; while (true) { obj = parser->getObj(true); if (obj.isCmd(""trailer"")) { break; } if (!obj.isInt()) { goto err0; } first = obj.getInt(); obj = parser->getObj(true); if (!obj.isInt()) { goto err0; } n = obj.getInt(); if (first < 0 || n < 0 || first > INT_MAX - n) { goto err0; } if (first + n > size) { if (resize(first + n) != first + n) { error(errSyntaxError, -1, ""Invalid 'obj' parameters'""); goto err0; } } for (int i = first; i < first + n; ++i) { obj = parser->getObj(true); if (obj.isInt()) { entry.offset = obj.getInt(); } else if (obj.isInt64()) { entry.offset = obj.getInt64(); } else { goto err0; } obj = parser->getObj(true); if (!obj.isInt()) { goto err0; } entry.gen = obj.getInt(); entry.flags = 0; obj = parser->getObj(true); if (obj.isCmd(""n"")) { entry.type = xrefEntryUncompressed; } else if (obj.isCmd(""f"")) { entry.type = xrefEntryFree; } else { goto err0; } if (entries[i].offset == -1) { entries[i].offset = entry.offset; entries[i].gen = entry.gen; entries[i].type = entry.type; entries[i].flags = entry.flags; entries[i].obj.setToNull(); if (i == 1 && first == 1 && entries[1].offset == 0 && entries[1].gen == 65535 && entries[1].type == xrefEntryFree) { i = first = 0; entries[0].offset = 0; entries[0].gen = 65535; entries[0].type = xrefEntryFree; entries[0].flags = entries[1].flags; entries[0].obj = std::move(entries[1].obj); entries[1].offset = -1; entries[1].obj.setToNull(); } } } } obj = parser->getObj(); if (!obj.isDict()) { goto err0; } obj2 = obj.getDict()->lookupNF(""Prev"").copy(); if (obj2.isInt() || obj2.isInt64()) { if (obj2.isInt()) pos2 = obj2.getInt(); else pos2 = obj2.getInt64(); if (pos2 != *pos) { *pos = pos2; more = true; } else { error(errSyntaxWarning, -1, ""Infinite loop in xref table""); more = false; } } else if (obj2.isRef()) { pos2 = (unsigned int)obj2.getRefNum(); if (pos2 != *pos) { *pos = pos2; more = true; } else { error(errSyntaxWarning, -1, ""Infinite loop in xref table""); more = false; } } else { more = false; } if (trailerDict.isNone()) { trailerDict = obj.copy(); } obj2 = obj.getDict()->lookup(""XRefStm""); if (obj2.isInt() || obj2.isInt64()) { if (obj2.isInt()) pos2 = obj2.getInt(); else pos2 = obj2.getInt64(); for (size_t i = 0; ok == true && i < followedXRefStm->size(); ++i) { if (followedXRefStm->at(i) == pos2) { ok = false; } } if (ok) { followedXRefStm->push_back(pos2); readXRef(&pos2, followedXRefStm, xrefStreamObjsNum); } if (!ok) { goto err0; } } return more; err0: ok = false; return false; }"
"xmlIDPtr xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value, xmlAttrPtr attr) { xmlIDPtr ret; xmlIDTablePtr table; if (doc == NULL) { return(NULL); } if (value == NULL) { return(NULL); } if (attr == NULL) { return(NULL); } table = (xmlIDTablePtr) doc->ids; if (table == NULL)  { doc->ids = table = xmlHashCreateDict(0, doc->dict); } if (table == NULL) { xmlVErrMemory(ctxt, ""xmlAddID: Table creation failed!\n""); return(NULL); } ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID)); if (ret == NULL) { xmlVErrMemory(ctxt, ""malloc failed""); return(NULL); } ret->value = xmlStrdup(value); ret->doc = doc; if ((ctxt != NULL) && (ctxt->vstateNr != 0)) { if (doc->dict != NULL) ret->name = xmlDictLookup(doc->dict, attr->name, -1); else ret->name = xmlStrdup(attr->name); ret->attr = NULL; } else { ret->attr = attr; ret->name = NULL; } ret->lineno = xmlGetLineNo(attr->parent); if (xmlHashAddEntry(table, value, ret) < 0) { #ifdef LIBXML_VALID_ENABLED if (ctxt != NULL) { xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED, ""ID %s already defined\n"", value, NULL, NULL); } #endif  xmlFreeID(ret); return(NULL); } if (attr != NULL) attr->atype = XML_ATTRIBUTE_ID; return(ret); }"
"static int container_setup_modules(struct hyper_container *container) { struct stat st; struct utsname uts; char src[512], dst[512]; if (uname(&uts) < 0) { perror(""fail to call uname""); return -1; } sprintf(src, ""/lib/modules/%s"", uts.release); sprintf(dst, ""./%s"", src); if (stat(dst, &st) == 0) { struct dirent **list; int num; if (!S_ISDIR(st.st_mode)) { return -1; } num = scandir(dst, &list, NULL, NULL); if (num > 2) { fprintf(stdout, ""%s is not null, %d"", dst, num); return 0; } } else if (errno == ENOENT) { if (hyper_mkdir(dst, 0755) < 0) return -1; } else { return -1; } if (mount(src, dst, NULL, MS_BIND, NULL) < 0) { perror(""mount bind modules failed""); return -1; } return 0; }"
"int nfc_llcp_send_cc(struct nfc_llcp_sock *sock) { struct nfc_llcp_local *local; struct sk_buff *skb; u8 *miux_tlv = NULL, miux_tlv_length; u8 *rw_tlv = NULL, rw_tlv_length, rw; int err; u16 size = 0; __be16 miux; pr_debug(""Sending CC\n""); local = sock->local; if (local == NULL) return -ENODEV; miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ? local->miux : sock->miux; rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw; miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0, &miux_tlv_length); size += miux_tlv_length; rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length); size += rw_tlv_length; skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size); if (skb == NULL) { err = -ENOMEM; goto error_tlv; } llcp_add_tlv(skb, miux_tlv, miux_tlv_length); llcp_add_tlv(skb, rw_tlv, rw_tlv_length); skb_queue_tail(&local->tx_queue, skb); err = 0; error_tlv: if (err) pr_err(""error %d\n"", err); kfree(miux_tlv); kfree(rw_tlv); return err; }"
"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, s32 bytes_in_box, u32 entry_size, u32 *total_bytes) { Bool null_size_ok = GF_FALSE; GF_DefaultSampleGroupDescriptionEntry *def_ptr; switch (grouping_type) { case GF_ISOM_SAMPLE_GROUP_ROLL: case GF_ISOM_SAMPLE_GROUP_PROL: { GF_RollRecoveryEntry *ptr; GF_SAFEALLOC(ptr, GF_RollRecoveryEntry); if (!ptr) return NULL; ptr->roll_distance = gf_bs_read_int(bs, 16); *total_bytes = 2; return ptr; } case GF_ISOM_SAMPLE_GROUP_RAP: { GF_VisualRandomAccessEntry *ptr; GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry); if (!ptr) return NULL; ptr->num_leading_samples_known = gf_bs_read_int(bs, 1); ptr->num_leading_samples = gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SAP: { GF_SAPEntry *ptr; GF_SAFEALLOC(ptr, GF_SAPEntry); if (!ptr) return NULL; ptr->dependent_flag = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 3); ptr->SAP_type = gf_bs_read_int(bs, 4); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SYNC: { GF_SYNCEntry *ptr; GF_SAFEALLOC(ptr, GF_SYNCEntry); if (!ptr) return NULL; gf_bs_read_int(bs, 2); ptr->NALU_type = gf_bs_read_int(bs, 6); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_TELE: { GF_TemporalLevelEntry *ptr; GF_SAFEALLOC(ptr, GF_TemporalLevelEntry); if (!ptr) return NULL; ptr->level_independently_decodable = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SEIG: { GF_CENCSampleEncryptionGroupEntry *ptr; if (bytes_in_box<3) return NULL; GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry); if (!ptr) return NULL; Bool use_mkey = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); ptr->crypt_byte_block = gf_bs_read_int(bs, 4); ptr->skip_byte_block = gf_bs_read_int(bs, 4); ptr->IsProtected = gf_bs_read_u8(bs); bytes_in_box -= 3; if (use_mkey) { u64 pos = gf_bs_get_position(bs); u32 i, count = gf_bs_read_u16(bs); bytes_in_box -= 2; if (bytes_in_box<0) { gf_free(ptr); return NULL; } for (i=0; i<count; i++) { u8 ivsize = gf_bs_read_u8(bs); gf_bs_skip_bytes(bs, 16); bytes_in_box -= 17; if (!ivsize) { ivsize = gf_bs_read_u8(bs); gf_bs_skip_bytes(bs, ivsize); bytes_in_box -= 1 + ivsize; } if (bytes_in_box<0) { gf_free(ptr); return NULL; } } ptr->key_info_size = 1 + (u32) (gf_bs_get_position(bs) - pos); ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size); if (!ptr->key_info) { gf_free(ptr); return NULL; } gf_bs_seek(bs, pos); ptr->key_info[0] = 1; gf_bs_read_data(bs, ptr->key_info + 1, ptr->key_info_size - 1); *total_bytes = 3 + ptr->key_info_size - 1; if (!gf_cenc_validate_key_info(ptr->key_info, ptr->key_info_size)) { gf_free(ptr->key_info); gf_free(ptr); return NULL; } } else { bin128 kid; u8 const_iv_size = 0; u8 iv_size = gf_bs_read_u8(bs); gf_bs_read_data(bs, kid, 16); bytes_in_box -= 17; if (bytes_in_box<0) { gf_free(ptr); return NULL; } *total_bytes = 20; if ((ptr->IsProtected == 1) && !iv_size) { const_iv_size = gf_bs_read_u8(bs); if ((const_iv_size != 8) && (const_iv_size != 16)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group have invalid constant_IV size\n"")); gf_free(ptr); return NULL; } } ptr->key_info_size = 20; if (!iv_size && ptr->IsProtected) { ptr->key_info_size += 1 + const_iv_size; } ptr->key_info = gf_malloc(sizeof(u8) * ptr->key_info_size); if (!ptr->key_info) { gf_free(ptr); return NULL; } ptr->key_info[0] = 0; ptr->key_info[1] = 0; ptr->key_info[2] = 0; ptr->key_info[3] = iv_size; memcpy(ptr->key_info+4, kid, 16); if (!iv_size && ptr->IsProtected) { ptr->key_info[20] = const_iv_size; gf_bs_read_data(bs, (char *)ptr->key_info+21, const_iv_size); *total_bytes += 1 + const_iv_size; } } if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_OINF: { GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_oinf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_LINF: { GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_linf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_TRIF: if (! entry_size) { u32 flags = gf_bs_peek_bits(bs, 24, 0); if (flags & 0x10000) entry_size=3; else { if (flags & 0x80000) entry_size=7; else entry_size=11; if (flags & 0x200000) { u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size); entry_size += 2 + 2*nb_entries; } } GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_NALM: if (! entry_size) { u64 start = gf_bs_get_position(bs); Bool rle, large_size; u32 entry_count; gf_bs_read_int(bs, 6); large_size = gf_bs_read_int(bs, 1); rle = gf_bs_read_int(bs, 1); entry_count = gf_bs_read_int(bs, large_size ? 16 : 8); gf_bs_seek(bs, start); entry_size = 1 + (large_size ? 2 : 1); entry_size += entry_count * 2; if (rle) entry_size += entry_count * (large_size ? 2 : 1); GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_TSAS: case GF_ISOM_SAMPLE_GROUP_STSA: null_size_ok = GF_TRUE; break; case GF_ISOM_SAMPLE_GROUP_TSCL: entry_size = 20; break; case GF_ISOM_SAMPLE_GROUP_LBLI: entry_size = 2; break; case GF_ISOM_SAMPLE_GROUP_SPOR: { u32 i; GF_SubpictureOrderEntry *ptr; GF_SAFEALLOC(ptr, GF_SubpictureOrderEntry); if (!ptr) return NULL; ptr->subpic_id_info_flag = gf_bs_read_int(bs, 1); ptr->num_subpic_ref_idx = gf_bs_read_int(bs, 15); *total_bytes = 2; ptr->subp_track_ref_idx = gf_malloc(sizeof(u16) * ptr->num_subpic_ref_idx); if (!ptr->subp_track_ref_idx) { gf_free(ptr); return NULL; } for (i=0; i<ptr->num_subpic_ref_idx; i++) { ptr->subp_track_ref_idx[i] = gf_bs_read_u16(bs); *total_bytes += 2; } if (ptr->subpic_id_info_flag) { ptr->spinfo.subpic_id_len_minus1 = gf_bs_read_int(bs, 4); ptr->spinfo.subpic_id_bit_pos = gf_bs_read_int(bs, 12); ptr->spinfo.start_code_emul_flag = gf_bs_read_int(bs, 1); ptr->spinfo.pps_sps_subpic_id_flag = gf_bs_read_int(bs, 1); if (ptr->spinfo.pps_sps_subpic_id_flag) { ptr->spinfo.xps_id = gf_bs_read_int(bs, 6); } else { ptr->spinfo.xps_id = gf_bs_read_int(bs, 4); gf_bs_read_int(bs, 2); } *total_bytes += 3; } return ptr; } case GF_ISOM_SAMPLE_GROUP_SULM: { u32 i; GF_SubpictureLayoutMapEntry *ptr; GF_SAFEALLOC(ptr, GF_SubpictureLayoutMapEntry); if (!ptr) return NULL; ptr->groupID_info_4cc = gf_bs_read_u32(bs); ptr->nb_entries = 1 + gf_bs_read_u16(bs); *total_bytes = 6; ptr->groupIDs = gf_malloc(sizeof(u16) * ptr->nb_entries); if (!ptr->groupIDs) { gf_free(ptr); return NULL; } for (i=0; i<ptr->nb_entries; i++) { ptr->groupIDs[i] = gf_bs_read_u16(bs); *total_bytes += 2; } return ptr; } default: break; } if (!entry_size && !null_size_ok) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) )); return NULL; } GF_SAFEALLOC(def_ptr, GF_DefaultSampleGroupDescriptionEntry); if (!def_ptr) return NULL; if (entry_size) { def_ptr->length = entry_size; def_ptr->data = (u8 *) gf_malloc(sizeof(u8)*def_ptr->length); if (!def_ptr->data) { gf_free(def_ptr); return NULL; } gf_bs_read_data(bs, (char *) def_ptr->data, def_ptr->length); *total_bytes = entry_size; } return def_ptr; }"
"static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm) { int L1, L2, L3; L1 = emitjump(J, F, OP_TRY); { L2 = emitjump(J, F, OP_TRY); { cstm(J, F, finallystm);  emit(J, F, OP_THROW);  } label(J, F, L2); if (F->strict) { checkfutureword(J, F, catchvar); if (!strcmp(catchvar->string, ""arguments"")) jsC_error(J, catchvar, ""redefining 'arguments' is not allowed in strict mode""); if (!strcmp(catchvar->string, ""eval"")) jsC_error(J, catchvar, ""redefining 'eval' is not allowed in strict mode""); } emitline(J, F, catchvar); emitstring(J, F, OP_CATCH, catchvar->string); cstm(J, F, catchstm); emit(J, F, OP_ENDCATCH); L3 = emitjump(J, F, OP_JUMP);  } label(J, F, L1); cstm(J, F, trystm); emit(J, F, OP_ENDTRY); label(J, F, L3); cstm(J, F, finallystm); }"
"void FrameworkListener::init(const char *socketName UNUSED, bool withSeq) { mCommands = new FrameworkCommandCollection(); errorRate = 0; mCommandCount = 0; mWithSeq = withSeq; }"
"void rng_backend_request_entropy(RngBackend *s, size_t size, EntropyReceiveFunc *receive_entropy, void *opaque) { RngBackendClass *k = RNG_BACKEND_GET_CLASS(s); if (k->request_entropy) { k->request_entropy(s, size, receive_entropy, opaque); } }"
"static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu) { struct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache; struct kvm_steal_time __user *st; struct kvm_memslots *slots; static const u8 preempted = KVM_VCPU_PREEMPTED; if (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED)) return; if (vcpu->arch.st.preempted) return; if (unlikely(current->mm != vcpu->kvm->mm)) return; slots = kvm_memslots(vcpu->kvm); if (unlikely(slots->generation != ghc->generation || kvm_is_error_hva(ghc->hva) || !ghc->memslot)) return; st = (struct kvm_steal_time __user *)ghc->hva; BUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted)); if (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted))) vcpu->arch.st.preempted = KVM_VCPU_PREEMPTED; mark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa)); }"
"void PackLinuxElf32::invert_pt_dynamic(Elf32_Dyn const *dynp) { if (dt_table[Elf32_Dyn::DT_NULL]) { return;      } Elf32_Dyn const *const dynp0 = dynp; unsigned ndx = 1+ 0; if (dynp) for (; ; ++ndx, ++dynp) { unsigned const d_tag = get_te32(&dynp->d_tag); if (d_tag < DT_NUM) { if (Elf32_Dyn::DT_NEEDED != d_tag &&  dt_table[d_tag] &&    get_te32(&dynp->d_val) != get_te32(&dynp0[-1+ dt_table[d_tag]].d_val)) { char msg[50]; snprintf(msg, sizeof(msg), ""duplicate DT_%#x: [%#x] [%#x]"", d_tag, -1+ dt_table[d_tag], -1+ ndx); throwCantPack(msg); } dt_table[d_tag] = ndx; } if (Elf32_Dyn::DT_NULL == d_tag) { break;          } } upx_dt_init = 0; if (dt_table[Elf32_Dyn::DT_INIT])          upx_dt_init = Elf32_Dyn::DT_INIT; else if (dt_table[Elf32_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf32_Dyn::DT_PREINIT_ARRAY; else if (dt_table[Elf32_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf32_Dyn::DT_INIT_ARRAY; unsigned const z_str = dt_table[Elf32_Dyn::DT_STRSZ]; if (z_str) { strtab_end = get_te32(&dynp0[-1+ z_str].d_val); if ((u32_t)file_size <= strtab_end) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_STRSZ %#x"", strtab_end); throwCantPack(msg); } } unsigned const x_sym = dt_table[Elf32_Dyn::DT_SYMTAB]; unsigned const x_str = dt_table[Elf32_Dyn::DT_STRTAB]; if (x_sym && x_str) { upx_uint32_t const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); upx_uint32_t const v_str = get_te32(&dynp0[-1+ x_str].d_val); unsigned const  z_sym = dt_table[Elf32_Dyn::DT_SYMENT]; unsigned const sz_sym = !z_sym ? sizeof(Elf32_Sym) : get_te32(&dynp0[-1+ z_sym].d_val); if (v_sym < v_str) { symnum_end = (v_str - v_sym) / sz_sym; } } unsigned const v_hsh = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH); if (v_hsh && file_image) { hashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_HASH); if (!hashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_HASH %#x"", v_hsh); throwCantPack(msg); } unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; (void)chains; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!nbucket || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)          || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2                  + sizeof(*buckets)*nbucket                  + sizeof(*chains) *nbucket             )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_HASH nbucket=%#x  len=%#x"", nbucket, (v_sym - v_hsh)); throwCantPack(msg); } } unsigned const v_gsh = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH); if (v_gsh && file_image) { gashtab = (unsigned const *)elf_find_dynamic(Elf32_Dyn::DT_GNU_HASH); if (!gashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH %#x"", v_gsh); throwCantPack(msg); } unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); unsigned const *const bitmask = (unsigned const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!n_bucket || !n_bitmask || (-1+ n_bitmask) & n_bitmask          || 8*sizeof(unsigned) <= gnu_shift          || (n_bucket>>30)          || (n_bitmask>>30) || (file_size / sizeof(unsigned)) <= (n_bitmask + 2*n_bucket)                  || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4                  + sizeof(*bitmask)*n_bitmask                  + sizeof(*buckets)*n_bucket                  + sizeof(*hasharr)*n_bucket              )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#x"", n_bucket, n_bitmask, v_sym - v_gsh); throwCantPack(msg); } } unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx); if (e_shnum <= e_shstrndx &&  !(0==e_shnum && 0==e_shstrndx) ) { char msg[40]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } }"
"static json_t *parse_json(lex_t *lex, size_t flags, json_error_t *error) { json_t *result; lex_scan(lex, error); if(!(flags & JSON_DECODE_ANY)) { if(lex->token != '[' && lex->token != '{') { error_set(error, lex, ""'[' or '{' expected""); return NULL; } } result = parse_value(lex, flags, error); if(!result) return NULL; if(!(flags & JSON_DISABLE_EOF_CHECK)) { lex_scan(lex, error); if(lex->token != TOKEN_EOF) { error_set(error, lex, ""end of file expected""); json_decref(result); return NULL; } } if(error) { error->position = (int)lex->stream.position; } return result; }"
"static void perf_event__header_size(struct perf_event *event) { __perf_event_read_size(event, event->group_leader->nr_siblings); __perf_event_header_size(event, event->attr.sample_type); }"
void ZlibInStream::deinit() { assert(zs != NULL); removeUnderlying(); inflateEnd(zs); delete zs; zs = NULL; }
"char_u * compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx) { char_u  *arg = eap->arg; lhs_T   *lhs = &cctx->ctx_redir_lhs; if (lhs->lhs_name != NULL) { if (STRNCMP(arg, ""END"", 3) == 0) { if (lhs->lhs_append) { if (compile_load_lhs_with_index(lhs, lhs->lhs_whole, cctx) == FAIL) return NULL; } generate_instr_type(cctx, ISN_REDIREND, &t_string); if (lhs->lhs_append) generate_CONCAT(cctx, 2); if (lhs->lhs_has_index) { if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE, &t_string, cctx) == FAIL) return NULL; } else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL) return NULL; VIM_CLEAR(lhs->lhs_name); VIM_CLEAR(lhs->lhs_whole); return arg + 3; } emsg(_(e_cannot_nest_redir)); return NULL; } if (arg[0] == '=' && arg[1] == '>') { int    append = FALSE; arg += 2; if (*arg == '>') { ++arg; append = TRUE; } arg = skipwhite(arg); if (compile_assign_lhs(arg, lhs, CMD_redir, FALSE, FALSE, FALSE, 1, cctx) == FAIL) return NULL; if (need_type(&t_string, lhs->lhs_member_type, -1, 0, cctx, FALSE, FALSE) == FAIL) return NULL; generate_instr(cctx, ISN_REDIRSTART); lhs->lhs_append = append; if (lhs->lhs_has_index) { lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total); if (lhs->lhs_whole == NULL) return NULL; } return arg + lhs->lhs_varlen_total; } return compile_exec(line, eap, cctx); }"
"void ConnectionManagerImpl::ActiveStream::recreateStream( StreamInfo::FilterStateSharedPtr filter_state) { ResponseEncoder* response_encoder = response_encoder_; response_encoder_ = nullptr; Buffer::InstancePtr request_data = std::make_unique<Buffer::OwnedImpl>(); const auto& buffered_request_data = filter_manager_.bufferedRequestData(); const bool proxy_body = buffered_request_data != nullptr && buffered_request_data->length() > 0; if (proxy_body) { request_data->move(*buffered_request_data); } response_encoder->getStream().removeCallbacks(*this); connection_manager_.doEndStream(*this); RequestDecoder& new_stream = connection_manager_.newStream(*response_encoder, true); if (filter_state->hasDataAtOrAboveLifeSpan(StreamInfo::FilterState::LifeSpan::Request)) { (*connection_manager_.streams_.begin())->filter_manager_.streamInfo().filter_state_ = std::make_shared<StreamInfo::FilterStateImpl>( filter_state->parent(), StreamInfo::FilterState::LifeSpan::FilterChain); } new_stream.decodeHeaders(std::move(request_headers_), !proxy_body); if (proxy_body) { new_stream.decodeData(*request_data, true); } }"
"static struct page *follow_pmd_mask(struct vm_area_struct *vma, unsigned long address, pud_t *pudp, unsigned int flags, struct follow_page_context *ctx) { pmd_t *pmd, pmdval; spinlock_t *ptl; struct page *page; struct mm_struct *mm = vma->vm_mm; pmd = pmd_offset(pudp, address); pmdval = READ_ONCE(*pmd); if (pmd_none(pmdval)) return no_page_table(vma, flags); if (pmd_huge(pmdval) && is_vm_hugetlb_page(vma)) { page = follow_huge_pmd(mm, address, pmd, flags); if (page) return page; return no_page_table(vma, flags); } if (is_hugepd(__hugepd(pmd_val(pmdval)))) { page = follow_huge_pd(vma, address, __hugepd(pmd_val(pmdval)), flags, PMD_SHIFT); if (page) return page; return no_page_table(vma, flags); } retry: if (!pmd_present(pmdval)) { VM_BUG_ON(!thp_migration_supported() || !is_pmd_migration_entry(pmdval)); if (likely(!(flags & FOLL_MIGRATION))) return no_page_table(vma, flags); pmd_migration_entry_wait(mm, pmd); pmdval = READ_ONCE(*pmd); if (pmd_none(pmdval)) return no_page_table(vma, flags); goto retry; } if (pmd_devmap(pmdval)) { ptl = pmd_lock(mm, pmd); page = follow_devmap_pmd(vma, address, pmd, flags, &ctx->pgmap); spin_unlock(ptl); if (page) return page; } if (likely(!pmd_trans_huge(pmdval))) return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); if ((flags & FOLL_NUMA) && pmd_protnone(pmdval)) return no_page_table(vma, flags); retry_locked: ptl = pmd_lock(mm, pmd); if (unlikely(pmd_none(*pmd))) { spin_unlock(ptl); return no_page_table(vma, flags); } if (unlikely(!pmd_present(*pmd))) { spin_unlock(ptl); if (likely(!(flags & FOLL_MIGRATION))) return no_page_table(vma, flags); pmd_migration_entry_wait(mm, pmd); goto retry_locked; } if (unlikely(!pmd_trans_huge(*pmd))) { spin_unlock(ptl); return follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); } if (flags & FOLL_SPLIT_PMD) { int ret; page = pmd_page(*pmd); if (is_huge_zero_page(page)) { spin_unlock(ptl); ret = 0; split_huge_pmd(vma, pmd, address); if (pmd_trans_unstable(pmd)) ret = -EBUSY; } else { spin_unlock(ptl); split_huge_pmd(vma, pmd, address); ret = pte_alloc(mm, pmd) ? -ENOMEM : 0; } return ret ? ERR_PTR(ret) : follow_page_pte(vma, address, pmd, flags, &ctx->pgmap); } page = follow_trans_huge_pmd(vma, address, pmd, flags); spin_unlock(ptl); ctx->page_mask = HPAGE_PMD_NR - 1; return page; }"
"void setrangeCommand(client *c) { robj *o; long offset; sds value = c->argv[3]->ptr; if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK) return; if (offset < 0) { addReplyError(c,""offset is out of range""); return; } o = lookupKeyWrite(c->db,c->argv[1]); if (o == NULL) { if (sdslen(value) == 0) { addReply(c,shared.czero); return; } if (checkStringLength(c,offset+sdslen(value)) != C_OK) return; o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value))); dbAdd(c->db,c->argv[1],o); } else { size_t olen; if (checkType(c,o,OBJ_STRING)) return; olen = stringObjectLen(o); if (sdslen(value) == 0) { addReplyLongLong(c,olen); return; } if (checkStringLength(c,offset+sdslen(value)) != C_OK) return; o = dbUnshareStringValue(c->db,c->argv[1],o); } if (sdslen(value) > 0) { o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value)); memcpy((char*)o->ptr+offset,value,sdslen(value)); signalModifiedKey(c,c->db,c->argv[1]); notifyKeyspaceEvent(NOTIFY_STRING, ""setrange"",c->argv[1],c->db->id); server.dirty++; } addReplyLongLong(c,sdslen(o->ptr)); }"
"static int write_node(FILE   *out, tree_t *t, int    col) { inti; uchar*ptr, *entity, *src, *realsrc, newsrc[1024]; if (out == NULL) return (0); switch (t->markup) { case MARKUP_NONE : if (t->data == NULL) break; if (t->preformatted) { for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); if (t->data[strlen((char *)t->data) - 1] == '\n') col = 0; else col += strlen((char *)t->data); } else { if ((col + (int)strlen((char *)t->data)) > 72 && col > 0) { putc('\n', out); col = 0; } for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); col += strlen((char *)t->data); if (col > 72) { putc('\n', out); col = 0; } } break; case MARKUP_COMMENT : case MARKUP_UNKNOWN : fputs(""\n<!--"", out); for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); fputs(""-->\n"", out); col = 0; break; case MARKUP_AREA : case MARKUP_BODY : case MARKUP_DOCTYPE : case MARKUP_ERROR : case MARKUP_FILE : case MARKUP_HEAD : case MARKUP_HTML : case MARKUP_MAP : case MARKUP_META : case MARKUP_TITLE : break; case MARKUP_BR : case MARKUP_CENTER : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_H7 : case MARKUP_H8 : case MARKUP_H9 : case MARKUP_H10 : case MARKUP_H11 : case MARKUP_H12 : case MARKUP_H13 : case MARKUP_H14 : case MARKUP_H15 : case MARKUP_HR : case MARKUP_LI : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TR : case MARKUP_UL : if (col > 0) { putc('\n', out); col = 0; } default : if (t->markup == MARKUP_IMG && OutputFiles && (src = htmlGetVariable(t, (uchar *)""SRC"")) != NULL && (realsrc = htmlGetVariable(t, (uchar *)""REALSRC"")) != NULL) { if (file_method((char *)src) == NULL && src[0] != '/' && src[0] != '\\' && (!isalpha(src[0]) || src[1] != ':')) { image_copy((char *)src, (char *)realsrc, OutputPath); strlcpy((char *)newsrc, file_basename((char *)src), sizeof(newsrc)); htmlSetVariable(t, (uchar *)""SRC"", newsrc); } } if (t->markup != MARKUP_EMBED) { col += fprintf(out, ""<%s"", _htmlMarkups[t->markup]); for (i = 0; i < t->nvars; i ++) { if (strcasecmp((char *)t->vars[i].name, ""BREAK"") == 0 && t->markup == MARKUP_HR) continue; if (strcasecmp((char *)t->vars[i].name, ""REALSRC"") == 0 && t->markup == MARKUP_IMG) continue; if (strncasecmp((char *)t->vars[i].name, ""_HD_"", 4) == 0) continue; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } if (col > 0) { putc(' ', out); col ++; } if (t->vars[i].value == NULL) col += fprintf(out, ""%s"", t->vars[i].name); else { col += fprintf(out, ""%s=\"""", t->vars[i].name); for (ptr = t->vars[i].value; *ptr; ptr ++) { entity = iso8859(*ptr); fputs((char *)entity, out); col += strlen((char *)entity); } putc('\""', out); col ++; } } putc('>', out); col ++; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } } break; } return (col); }"
"static int kvm_ioctl_create_device(struct kvm *kvm, struct kvm_create_device *cd) { struct kvm_device_ops *ops = NULL; struct kvm_device *dev; bool test = cd->flags & KVM_CREATE_DEVICE_TEST; int ret; if (cd->type >= ARRAY_SIZE(kvm_device_ops_table)) return -ENODEV; ops = kvm_device_ops_table[cd->type]; if (ops == NULL) return -ENODEV; if (test) return 0; dev = kzalloc(sizeof(*dev), GFP_KERNEL); if (!dev) return -ENOMEM; dev->ops = ops; dev->kvm = kvm; mutex_lock(&kvm->lock); ret = ops->create(dev, cd->type); if (ret < 0) { mutex_unlock(&kvm->lock); kfree(dev); return ret; } list_add(&dev->vm_node, &kvm->devices); mutex_unlock(&kvm->lock); if (ops->init) ops->init(dev); ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC); if (ret < 0) { ops->destroy(dev); mutex_lock(&kvm->lock); list_del(&dev->vm_node); mutex_unlock(&kvm->lock); return ret; } kvm_get_kvm(kvm); cd->fd = ret; return 0; }"
"ssize_t _import_text(caca_canvas_t *cv, void const *data, size_t size) { char const *text = (char const *)data; unsigned int width = 0, height = 0, x = 0, y = 0, i; caca_set_canvas_size(cv, width, height); for(i = 0; i < size; i++) { unsigned char ch = *text++; if(ch == '\r') continue; if(ch == '\n') { x = 0; y++; continue; } if(x >= width || y >= height) { if(x >= width) width = x + 1; if(y >= height) height = y + 1; caca_set_canvas_size(cv, width, height); } caca_put_char(cv, x, y, ch); x++; } if(y > height) caca_set_canvas_size(cv, width, height = y); return (ssize_t)size; }"
"static int internal_get_user_pages_fast(unsigned long start, int nr_pages, unsigned int gup_flags, struct page **pages) { unsigned long addr, len, end; int nr_pinned = 0, ret = 0; if (WARN_ON_ONCE(gup_flags & ~(FOLL_WRITE | FOLL_LONGTERM | FOLL_FORCE | FOLL_PIN | FOLL_GET))) return -EINVAL; start = untagged_addr(start) & PAGE_MASK; addr = start; len = (unsigned long) nr_pages << PAGE_SHIFT; end = start + len; if (end <= start) return 0; if (unlikely(!access_ok((void __user *)start, len))) return -EFAULT; if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) && gup_fast_permitted(start, end)) { local_irq_disable(); gup_pgd_range(addr, end, gup_flags, pages, &nr_pinned); local_irq_enable(); ret = nr_pinned; } if (nr_pinned < nr_pages) { start += nr_pinned << PAGE_SHIFT; pages += nr_pinned; ret = __gup_longterm_unlocked(start, nr_pages - nr_pinned, gup_flags, pages); if (nr_pinned > 0) { if (ret < 0) ret = nr_pinned; else ret += nr_pinned; } } return ret; }"
"static int ext4_xattr_set_entry(struct ext4_xattr_info *i, struct ext4_xattr_search *s, handle_t *handle, struct inode *inode, bool is_block) { struct ext4_xattr_entry *last; struct ext4_xattr_entry *here = s->here; size_t min_offs = s->end - s->base, name_len = strlen(i->name); int in_inode = i->in_inode; struct inode *old_ea_inode = NULL; struct inode *new_ea_inode = NULL; size_t old_size, new_size; int ret; old_size = (!s->not_found && !here->e_value_inum) ? EXT4_XATTR_SIZE(le32_to_cpu(here->e_value_size)) : 0; new_size = (i->value && !in_inode) ? EXT4_XATTR_SIZE(i->value_len) : 0; if (new_size && new_size == old_size) { size_t offs = le16_to_cpu(here->e_value_offs); void *val = s->base + offs; here->e_value_size = cpu_to_le32(i->value_len); if (i->value == EXT4_ZERO_XATTR_VALUE) { memset(val, 0, new_size); } else { memcpy(val, i->value, i->value_len); memset(val + i->value_len, 0, new_size - i->value_len); } goto update_hash; } last = s->first; for (; !IS_LAST_ENTRY(last); last = EXT4_XATTR_NEXT(last)) { if (!last->e_value_inum && last->e_value_size) { size_t offs = le16_to_cpu(last->e_value_offs); if (offs < min_offs) min_offs = offs; } } if (i->value) { size_t free; free = min_offs - ((void *)last - s->base) - sizeof(__u32); if (!s->not_found) free += EXT4_XATTR_LEN(name_len) + old_size; if (free < EXT4_XATTR_LEN(name_len) + new_size) { ret = -ENOSPC; goto out; } if (ext4_has_feature_ea_inode(inode->i_sb) && new_size && is_block && (min_offs + old_size - new_size) < EXT4_XATTR_BLOCK_RESERVE(inode)) { ret = -ENOSPC; goto out; } } if (!s->not_found && here->e_value_inum) { ret = ext4_xattr_inode_iget(inode, le32_to_cpu(here->e_value_inum), le32_to_cpu(here->e_hash), &old_ea_inode); if (ret) { old_ea_inode = NULL; goto out; } } if (i->value && in_inode) { WARN_ON_ONCE(!i->value_len); ret = ext4_xattr_inode_alloc_quota(inode, i->value_len); if (ret) goto out; ret = ext4_xattr_inode_lookup_create(handle, inode, i->value, i->value_len, &new_ea_inode); if (ret) { new_ea_inode = NULL; ext4_xattr_inode_free_quota(inode, NULL, i->value_len); goto out; } } if (old_ea_inode) { ret = ext4_xattr_inode_dec_ref(handle, old_ea_inode); if (ret) { if (new_ea_inode) { int err; err = ext4_xattr_inode_dec_ref(handle, new_ea_inode); if (err) ext4_warning_inode(new_ea_inode, ""dec ref new_ea_inode err=%d"", err); ext4_xattr_inode_free_quota(inode, new_ea_inode, i->value_len); } goto out; } ext4_xattr_inode_free_quota(inode, old_ea_inode, le32_to_cpu(here->e_value_size)); } if (!s->not_found && here->e_value_size && here->e_value_offs) { void *first_val = s->base + min_offs; size_t offs = le16_to_cpu(here->e_value_offs); void *val = s->base + offs; memmove(first_val + old_size, first_val, val - first_val); memset(first_val, 0, old_size); min_offs += old_size; last = s->first; while (!IS_LAST_ENTRY(last)) { size_t o = le16_to_cpu(last->e_value_offs); if (!last->e_value_inum && last->e_value_size && o < offs) last->e_value_offs = cpu_to_le16(o + old_size); last = EXT4_XATTR_NEXT(last); } } if (!i->value) { size_t size = EXT4_XATTR_LEN(name_len); last = ENTRY((void *)last - size); memmove(here, (void *)here + size, (void *)last - (void *)here + sizeof(__u32)); memset(last, 0, size); } else if (s->not_found) { size_t size = EXT4_XATTR_LEN(name_len); size_t rest = (void *)last - (void *)here + sizeof(__u32); memmove((void *)here + size, here, rest); memset(here, 0, size); here->e_name_index = i->name_index; here->e_name_len = name_len; memcpy(here->e_name, i->name, name_len); } else { here->e_value_inum = 0; here->e_value_offs = 0; here->e_value_size = 0; } if (i->value) { if (in_inode) { here->e_value_inum = cpu_to_le32(new_ea_inode->i_ino); } else if (i->value_len) { void *val = s->base + min_offs - new_size; here->e_value_offs = cpu_to_le16(min_offs - new_size); if (i->value == EXT4_ZERO_XATTR_VALUE) { memset(val, 0, new_size); } else { memcpy(val, i->value, i->value_len); memset(val + i->value_len, 0, new_size - i->value_len); } } here->e_value_size = cpu_to_le32(i->value_len); } update_hash: if (i->value) { __le32 hash = 0; if (in_inode) { __le32 crc32c_hash; crc32c_hash = cpu_to_le32( ext4_xattr_inode_get_hash(new_ea_inode)); hash = ext4_xattr_hash_entry(here->e_name, here->e_name_len, &crc32c_hash, 1); } else if (is_block) { __le32 *value = s->base + le16_to_cpu( here->e_value_offs); hash = ext4_xattr_hash_entry(here->e_name, here->e_name_len, value, new_size >> 2); } here->e_hash = hash; } if (is_block) ext4_xattr_rehash((struct ext4_xattr_header *)s->base); ret = 0; out: iput(old_ea_inode); iput(new_ea_inode); return ret; }"
"static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid) { linenr_Tlnum; qfline_T*qfp; intold_KeyTyped = KeyTyped; list_T*qftf_list = NULL; listitem_T*qftf_li = NULL; if (old_last == NULL) { if (buf != curbuf) { internal_error(""qf_fill_buffer()""); return; } while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0) (void)ml_delete((linenr_T)1); } if (qfl != NULL) { char_udirname[MAXPATHL]; intinvalid_val = FALSE; intprev_bufnr = -1; *dirname = NUL; if (old_last == NULL) { qfp = qfl->qf_start; lnum = 0; } else { if (old_last->qf_next != NULL) qfp = old_last->qf_next; else qfp = old_last; lnum = buf->b_ml.ml_line_count; } qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1), (long)qfl->qf_count); if (qftf_list != NULL) qftf_li = qftf_list->lv_first; while (lnum < qfl->qf_count) { char_u*qftf_str = NULL; if (qftf_li != NULL && !invalid_val) { qftf_str = tv_get_string_chk(&qftf_li->li_tv); if (qftf_str == NULL) invalid_val = TRUE; } if (qf_buf_add_line(buf, lnum, qfp, dirname, prev_bufnr != qfp->qf_fnum, qftf_str) == FAIL) break; prev_bufnr = qfp->qf_fnum; ++lnum; qfp = qfp->qf_next; if (qfp == NULL) break; if (qftf_li != NULL) qftf_li = qftf_li->li_next; } if (old_last == NULL) (void)ml_delete(lnum + 1); } check_lnums(TRUE); if (old_last == NULL) { ++curbuf_lock; set_option_value_give_err((char_u *)""ft"", 0L, (char_u *)""qf"", OPT_LOCAL); curbuf->b_p_ma = FALSE; keep_filetype = TRUE;apply_autocmds(EVENT_BUFREADPOST, (char_u *)""quickfix"", NULL, FALSE, curbuf); apply_autocmds(EVENT_BUFWINENTER, (char_u *)""quickfix"", NULL, FALSE, curbuf); keep_filetype = FALSE; --curbuf_lock; redraw_curbuf_later(UPD_NOT_VALID); } KeyTyped = old_KeyTyped; }"
"unsigned paravirt_patch_jmp(void *insnbuf, const void *target, unsigned long addr, unsigned len) { struct branch *b = insnbuf; unsigned long delta = (unsigned long)target - (addr+5); if (len < 5) return len; b->opcode = 0xe9; b->delta = delta; return 5; }"
"static inline struct file *io_file_get(struct io_ring_ctx *ctx, struct io_kiocb *req, int fd, bool fixed) { if (fixed) return io_file_get_fixed(ctx, req, fd); else return io_file_get_normal(ctx, req, fd); }"
"int main(int argc, char **argv, char **envp) { int opt; while ((opt = getopt(argc, argv, ""b:h:k:p:q:w:z:xv"")) != -1) { switch (opt) { case 'b': tmate_settings->bind_addr = xstrdup(optarg); break; case 'h': tmate_settings->tmate_host = xstrdup(optarg); break; case 'k': tmate_settings->keys_dir = xstrdup(optarg); break; case 'p': tmate_settings->ssh_port = atoi(optarg); break; case 'q': tmate_settings->ssh_port_advertized = atoi(optarg); break; case 'w': tmate_settings->websocket_hostname = xstrdup(optarg); break; case 'z': tmate_settings->websocket_port = atoi(optarg); break; case 'x': tmate_settings->use_proxy_protocol = true; break; case 'v': tmate_settings->log_level++; break; default: usage(); return 1; } } init_logging(tmate_settings->log_level); setup_locale(); if (!tmate_settings->tmate_host) tmate_settings->tmate_host = get_full_hostname(); cmdline = *argv; cmdline_end = *envp; tmate_preload_trace_lib(); tmate_catch_sigsegv(); tmate_init_rand(); if ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) || (mkdir(TMATE_WORKDIR ""/sessions"", 0703) < 0 && errno != EEXIST) || (mkdir(TMATE_WORKDIR ""/jail"", 0700)     < 0 && errno != EEXIST)) tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR); if ((chmod(TMATE_WORKDIR, 0701)             < 0) || (chmod(TMATE_WORKDIR ""/sessions"", 0703) < 0) || (chmod(TMATE_WORKDIR ""/jail"", 0700)     < 0)) tmate_fatal(""Cannot prepare session in "" TMATE_WORKDIR); tmate_ssh_server_main(tmate_session, tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port); return 0; }"
"static int segmented_read_std(struct x86_emulate_ctxt *ctxt, struct segmented_address addr, void *data, unsigned size) { int rc; ulong linear; rc = linearize(ctxt, addr, size, false, &linear); if (rc != X86EMUL_CONTINUE) return rc; return ctxt->ops->read_std(ctxt, linear, data, size, &ctxt->exception); }"
"DataBuf packIfdId(const ExifData& exifData, IfdId     ifdId, ByteOrder byteOrder) { const uint16_t size = 1024; DataBuf buf(size); std::memset(buf.pData_, 0x0, buf.size_); uint16_t len = 0; const ExifData::const_iterator b = exifData.begin(); const ExifData::const_iterator e = exifData.end(); for (ExifData::const_iterator i = b; i != e; ++i) { if (i->ifdId() != ifdId) continue; const uint16_t s = i->tag()*2 + static_cast<uint16_t>(i->size()); assert(s <= size); if (len < s) len = s; i->copy(buf.pData_ + i->tag()*2, byteOrder); } buf.size_ = len + len%2; return buf; }"
"static OPJ_BOOL opj_j2k_write_all_tile_parts(opj_j2k_t *p_j2k, OPJ_BYTE * p_data, OPJ_UINT32 * p_data_written, OPJ_UINT32 p_total_data_size, opj_stream_private_t *p_stream, struct opj_event_mgr * p_manager ) { OPJ_UINT32 tilepartno = 0; OPJ_UINT32 l_nb_bytes_written = 0; OPJ_UINT32 l_current_nb_bytes_written; OPJ_UINT32 l_part_tile_size; OPJ_UINT32 tot_num_tp; OPJ_UINT32 pino; OPJ_BYTE * l_begin_data; opj_tcp_t *l_tcp = 00; opj_tcd_t * l_tcd = 00; opj_cp_t * l_cp = 00; l_tcd = p_j2k->m_tcd; l_cp = &(p_j2k->m_cp); l_tcp = l_cp->tcps + p_j2k->m_current_tile_number; tot_num_tp = opj_j2k_get_num_tp(l_cp, 0, p_j2k->m_current_tile_number); ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number; for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) { p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno; l_current_nb_bytes_written = 0; l_part_tile_size = 0; l_begin_data = p_data; if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream, p_manager)) { return OPJ_FALSE; } l_nb_bytes_written += l_current_nb_bytes_written; p_data += l_current_nb_bytes_written; p_total_data_size -= l_current_nb_bytes_written; l_part_tile_size += l_current_nb_bytes_written; l_current_nb_bytes_written = 0; if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written, p_total_data_size, p_stream, p_manager)) { return OPJ_FALSE; } p_data += l_current_nb_bytes_written; l_nb_bytes_written += l_current_nb_bytes_written; p_total_data_size -= l_current_nb_bytes_written; l_part_tile_size += l_current_nb_bytes_written; opj_write_bytes(l_begin_data + 6, l_part_tile_size, 4);                                    if (OPJ_IS_CINEMA(l_cp->rsiz)) { opj_j2k_update_tlm(p_j2k, l_part_tile_size); } ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number; } for (pino = 1; pino <= l_tcp->numpocs; ++pino) { l_tcd->cur_pino = pino; tot_num_tp = opj_j2k_get_num_tp(l_cp, pino, p_j2k->m_current_tile_number); for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) { p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno; l_current_nb_bytes_written = 0; l_part_tile_size = 0; l_begin_data = p_data; if (! opj_j2k_write_sot(p_j2k, p_data, &l_current_nb_bytes_written, p_stream, p_manager)) { return OPJ_FALSE; } l_nb_bytes_written += l_current_nb_bytes_written; p_data += l_current_nb_bytes_written; p_total_data_size -= l_current_nb_bytes_written; l_part_tile_size += l_current_nb_bytes_written; l_current_nb_bytes_written = 0; if (! opj_j2k_write_sod(p_j2k, l_tcd, p_data, &l_current_nb_bytes_written, p_total_data_size, p_stream, p_manager)) { return OPJ_FALSE; } l_nb_bytes_written += l_current_nb_bytes_written; p_data += l_current_nb_bytes_written; p_total_data_size -= l_current_nb_bytes_written; l_part_tile_size += l_current_nb_bytes_written; opj_write_bytes(l_begin_data + 6, l_part_tile_size, 4);                                    if (OPJ_IS_CINEMA(l_cp->rsiz)) { opj_j2k_update_tlm(p_j2k, l_part_tile_size); } ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number; } } *p_data_written = l_nb_bytes_written; return OPJ_TRUE; }"
"static const u_char * ikev2_auth_print(netdissect_options *ndo, u_char tpay, const struct isakmp_gen *ext, u_int item_len _U_, const u_char *ep, uint32_t phase _U_, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { struct ikev2_auth a; const char *v2_auth[]={ ""invalid"", ""rsasig"", ""shared-secret"", ""dsssig"" }; const u_char *authdata = (const u_char*)ext + sizeof(a); unsigned int len; ND_TCHECK(*ext); UNALIGNED_MEMCPY(&a, ext, sizeof(a)); ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical); len = ntohs(a.h.len); ND_PRINT((ndo,"" len=%d method=%s"", len-4, STR_OR_ID(a.auth_method, v2_auth))); if (1 < ndo->ndo_vflag && 4 < len) { ND_PRINT((ndo,"" authdata=("")); if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a))) goto trunc; ND_PRINT((ndo,"") "")); } else if(ndo->ndo_vflag && 4 < len) { if(!ike_show_somedata(ndo, authdata, ep)) goto trunc; } return (const u_char *)ext + len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay))); return NULL; }"
"void pt_restore_timer(struct vcpu *v) { struct list_head *head = &v->arch.hvm.tm_list; struct periodic_time *pt; spin_lock(&v->arch.hvm.tm_lock); list_for_each_entry ( pt, head, list ) { if ( pt->pending_intr_nr == 0 ) { pt_process_missed_ticks(pt); set_timer(&pt->timer, pt->scheduled); } } pt_thaw_time(v); spin_unlock(&v->arch.hvm.tm_lock); }"
"static void on_handler_appeared(GDBusConnection *connection, const gchar     *name, const gchar     *name_owner, gpointer         user_data) { struct tcmur_handler *handler = user_data; struct dbus_info *info = handler->opaque; if (info->register_invocation) { info->connection = connection; tcmur_register_handler(handler); dbus_export_handler(handler, G_CALLBACK(on_dbus_check_config)); g_dbus_method_invocation_return_value(info->register_invocation, g_variant_new(""(bs)"", TRUE, ""succeeded"")); info->register_invocation = NULL; } }"
"u_int juniper_pppoe_atm_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; uint16_t extracted_ethertype; l2info.pictype = DLT_JUNIPER_PPPOE_ATM; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; extracted_ethertype = EXTRACT_16BITS(p); if (ethertype_print(ndo, extracted_ethertype, p+ETHERTYPE_LEN, l2info.length-ETHERTYPE_LEN, l2info.caplen-ETHERTYPE_LEN, NULL, NULL) == 0) ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype)); return l2info.header_len; }"
"int _TIFFCheckFieldIsValidForCodec(TIFF *tif, ttag_t tag) { switch (tag) { case TIFFTAG_PREDICTOR: case TIFFTAG_JPEGTABLES: case TIFFTAG_JPEGIFOFFSET: case TIFFTAG_JPEGIFBYTECOUNT: case TIFFTAG_JPEGQTABLES: case TIFFTAG_JPEGDCTABLES: case TIFFTAG_JPEGACTABLES: case TIFFTAG_JPEGPROC: case TIFFTAG_JPEGRESTARTINTERVAL: case TIFFTAG_BADFAXLINES: case TIFFTAG_CLEANFAXDATA: case TIFFTAG_CONSECUTIVEBADFAXLINES: case TIFFTAG_GROUP3OPTIONS: case TIFFTAG_GROUP4OPTIONS: case TIFFTAG_LERC_PARAMETERS: break; default: return 1; } switch (tif->tif_dir.td_compression) { case COMPRESSION_LZW: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_PACKBITS: break; case COMPRESSION_THUNDERSCAN: break; case COMPRESSION_NEXT: break; case COMPRESSION_JPEG: if (tag == TIFFTAG_JPEGTABLES) return 1; break; case COMPRESSION_OJPEG: switch (tag) { case TIFFTAG_JPEGIFOFFSET: case TIFFTAG_JPEGIFBYTECOUNT: case TIFFTAG_JPEGQTABLES: case TIFFTAG_JPEGDCTABLES: case TIFFTAG_JPEGACTABLES: case TIFFTAG_JPEGPROC: case TIFFTAG_JPEGRESTARTINTERVAL: return 1; } break; case COMPRESSION_CCITTRLE: case COMPRESSION_CCITTRLEW: case COMPRESSION_CCITTFAX3: case COMPRESSION_CCITTFAX4: switch (tag) { case TIFFTAG_BADFAXLINES: case TIFFTAG_CLEANFAXDATA: case TIFFTAG_CONSECUTIVEBADFAXLINES: return 1; case TIFFTAG_GROUP3OPTIONS: if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX3) return 1; break; case TIFFTAG_GROUP4OPTIONS: if (tif->tif_dir.td_compression == COMPRESSION_CCITTFAX4) return 1; break; } break; case COMPRESSION_JBIG: break; case COMPRESSION_DEFLATE: case COMPRESSION_ADOBE_DEFLATE: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_PIXARLOG: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_SGILOG: case COMPRESSION_SGILOG24: break; case COMPRESSION_LZMA: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_ZSTD: if (tag == TIFFTAG_PREDICTOR) return 1; break; case COMPRESSION_LERC: if (tag == TIFFTAG_LERC_PARAMETERS) return 1; break; case COMPRESSION_WEBP: if (tag == TIFFTAG_PREDICTOR) return 1; break; } return 0; }"
"static void async_polkit_query_free(AsyncPolkitQuery *q) { if (!q) return; sd_bus_slot_unref(q->slot); if (q->registry && q->request) hashmap_remove(q->registry, q->request); sd_bus_message_unref(q->request); sd_bus_message_unref(q->reply); free(q->action); strv_free(q->details); free(q); }"
"static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind) { struct evtchn *lchn, *rchn; struct domain *ld = current->domain, *rd; int            lport, rport = bind->remote_port; domid_t        rdom = bind->remote_dom; long           rc; if ( rdom == DOMID_SELF ) rdom = current->domain->domain_id; if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL ) return -ESRCH; if ( ld < rd ) { spin_lock(&ld->event_lock); spin_lock(&rd->event_lock); } else { if ( ld != rd ) spin_lock(&rd->event_lock); spin_lock(&ld->event_lock); } if ( (lport = get_free_port(ld)) < 0 ) ERROR_EXIT(lport); lchn = evtchn_from_port(ld, lport); if ( !port_is_valid(rd, rport) ) ERROR_EXIT_DOM(-EINVAL, rd); rchn = evtchn_from_port(rd, rport); if ( (rchn->state != ECS_UNBOUND) || (rchn->u.unbound.remote_domid != ld->domain_id) ) ERROR_EXIT_DOM(-EINVAL, rd); rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn); if ( rc ) goto out; double_evtchn_lock(lchn, rchn); lchn->u.interdomain.remote_dom  = rd; lchn->u.interdomain.remote_port = rport; lchn->state                     = ECS_INTERDOMAIN; evtchn_port_init(ld, lchn); rchn->u.interdomain.remote_dom  = ld; rchn->u.interdomain.remote_port = lport; rchn->state                     = ECS_INTERDOMAIN; evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn); double_evtchn_unlock(lchn, rchn); bind->local_port = lport; out: check_free_port(ld, lport); spin_unlock(&ld->event_lock); if ( ld != rd ) spin_unlock(&rd->event_lock); rcu_unlock_domain(rd); return rc; }"
"void freeClient(redisClient *c) { listNode *ln; sdsfree(c->querybuf); c->querybuf = NULL; if (c->flags & REDIS_BLOCKED) unblockClientWaitingData(c); unwatchAllKeys(c); listRelease(c->watched_keys); pubsubUnsubscribeAllChannels(c,0); pubsubUnsubscribeAllPatterns(c,0); dictRelease(c->pubsub_channels); listRelease(c->pubsub_patterns); aeDeleteFileEvent(server.el,c->fd,AE_READABLE); aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE); listRelease(c->reply); freeClientArgv(c); close(c->fd); ln = listSearchKey(server.clients,c); redisAssert(ln != NULL); listDelNode(server.clients,ln); if (c->flags & REDIS_IO_WAIT) { redisAssert(server.vm_enabled); if (listLength(c->io_keys) == 0) { ln = listSearchKey(server.io_ready_clients,c); redisAssert(ln != NULL); listDelNode(server.io_ready_clients,ln); } else { while (listLength(c->io_keys)) { ln = listFirst(c->io_keys); dontWaitForSwappedKey(c,ln->value); } } server.vm_blocked_clients--; } listRelease(c->io_keys); if (c->flags & REDIS_SLAVE) { if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1) close(c->repldbfd); list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves; ln = listSearchKey(l,c); redisAssert(ln != NULL); listDelNode(l,ln); } if (c->flags & REDIS_MASTER) { server.master = NULL; server.replstate = REDIS_REPL_CONNECT; while (listLength(server.slaves)) { ln = listFirst(server.slaves); freeClient((redisClient*)ln->value); } } zfree(c->argv); freeClientMultiState(c); zfree(c); }"
"lyd_node * lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name, void *value, LYD_ANYDATA_VALUETYPE value_type) { const struct lys_node *siblings, *snode; if ((!parent && !module) || !name) { LOGARG; return NULL; } siblings = lyd_new_find_schema(parent, module, 0); if (!siblings) { LOGARG; return NULL; } if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) { LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."", name, lys_node_module(siblings)->name, siblings->name); return NULL; } return lyd_create_anydata(parent, snode, value, value_type); }"
"int sas_discover_sata(struct domain_device *dev) { int res; if (dev->dev_type == SAS_SATA_PM) return -ENODEV; dev->sata_dev.class = sas_get_ata_command_set(dev); sas_fill_in_rphy(dev, dev->rphy); res = sas_notify_lldd_dev_found(dev); if (res) return res; sas_discover_event(dev->port, DISCE_PROBE); return 0; }"
"static struct aead_request *macsec_alloc_req(struct crypto_aead *tfm, unsigned char **iv, struct scatterlist **sg) { size_t size, iv_offset, sg_offset; struct aead_request *req; void *tmp; size = sizeof(struct aead_request) + crypto_aead_reqsize(tfm); iv_offset = size; size += GCM_AES_IV_LEN; size = ALIGN(size, __alignof__(struct scatterlist)); sg_offset = size; size += sizeof(struct scatterlist) * (MAX_SKB_FRAGS + 1); tmp = kmalloc(size, GFP_ATOMIC); if (!tmp) return NULL; *iv = (unsigned char *)(tmp + iv_offset); *sg = (struct scatterlist *)(tmp + sg_offset); req = tmp; aead_request_set_tfm(req, tfm); return req; }"
"static struct env * createenv(const struct rule *rule) { struct env *env; u_int i; env = malloc(sizeof(*env)); if (!env) err(1, NULL); RB_INIT(&env->root); env->count = 0; if (rule->options & KEEPENV) { extern char **environ; for (i = 0; environ[i] != NULL; i++) { struct envnode *node; const char *e, *eq; size_t len; char keybuf[1024]; e = environ[i]; if ((eq = strchr(e, '=')) == NULL || eq == e) continue; len = eq - e; if (len > sizeof(keybuf) - 1) continue; memcpy(keybuf, e, len); keybuf[len] = '\0'; node = createnode(keybuf, eq + 1); if (RB_INSERT(envtree, &env->root, node)) { freenode(node); } else { env->count++; } } } return env; }"
"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_cipher rcipher; strlcpy(rcipher.type, ""cipher"", sizeof(rcipher.type)); rcipher.blocksize = alg->cra_blocksize; rcipher.min_keysize = alg->cra_cipher.cia_min_keysize; rcipher.max_keysize = alg->cra_cipher.cia_max_keysize; if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER, sizeof(struct crypto_report_cipher), &rcipher)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }"
"GF_Err MergeTrack(GF_TrackBox *trak, GF_TrackFragmentBox *traf, GF_MovieFragmentBox *moof_box, u64 moof_offset, s32 compressed_diff, u64 *cumulated_offset, Bool is_first_merge) { u32 i, j, chunk_size, track_num; u64 base_offset, data_offset, traf_duration; u32 def_duration, DescIndex, def_size, def_flags; u32 duration, size, flags, prev_trun_data_offset, sample_index; u8 pad, sync; u16 degr; Bool first_samp_in_traf=GF_TRUE; Bool store_traf_map=GF_FALSE; u8 *moof_template=NULL; u32 moof_template_size=0; Bool is_seg_start = GF_FALSE; u64 seg_start=0, sidx_start=0, sidx_end=0, frag_start=0, last_dts=0; GF_TrackFragmentRunBox *trun; GF_TrunEntry *ent; #ifdef GF_ENABLE_CTRN GF_TrackFragmentBox *traf_ref = NULL; #endif GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack); GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack); GF_Err stbl_AppendChunk(GF_SampleTableBox *stbl, u64 offset); GF_Err stbl_AppendSampleToChunk(GF_SampleTableBox *stbl, u32 DescIndex, u32 samplesInChunk); GF_Err stbl_AppendCTSOffset(GF_SampleTableBox *stbl, s32 CTSOffset); GF_Err stbl_AppendRAP(GF_SampleTableBox *stbl, u8 isRap); GF_Err stbl_AppendPadding(GF_SampleTableBox *stbl, u8 padding); GF_Err stbl_AppendDegradation(GF_SampleTableBox *stbl, u16 DegradationPriority); if (trak->Header->trackID != traf->tfhd->trackID) return GF_OK; if (!trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize || !trak->Media->information->sampleTable->TimeToSample || !trak->Media->information->sampleTable->SampleToChunk || !trak->Media->information->sampleTable->ChunkOffset ) { return GF_ISOM_INVALID_FILE; } if (!traf->trex->track) traf->trex->track = trak; DescIndex = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DESC) ? traf->tfhd->sample_desc_index : traf->trex->def_sample_desc_index; if (!DescIndex) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to 0, likely broken ! Fixing to 1\n"" )); DescIndex = 1; } else if (DescIndex > gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] default sample description set to %d but only %d sample description(s), likely broken ! Fixing to 1\n"", DescIndex, gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes))); DescIndex = 1; } #ifdef GF_ENABLE_CTRN if (traf->trex->inherit_from_traf_id) { u32 traf_count = gf_list_count(moof_box->TrackList); for (i=0; i<traf_count; i++) { GF_TrackFragmentBox *atraf = gf_list_get(moof_box->TrackList, i); if (atraf->tfhd && atraf->tfhd->trackID==traf->trex->inherit_from_traf_id) { traf_ref = atraf; break; } } } #endif def_duration = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) ? traf->tfhd->def_sample_duration : traf->trex->def_sample_duration; def_size = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_SIZE) ? traf->tfhd->def_sample_size : traf->trex->def_sample_size; def_flags = (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_FLAGS) ? traf->tfhd->def_sample_flags : traf->trex->def_sample_flags; base_offset = moof_offset; if (traf->tfhd->flags & GF_ISOM_TRAF_BASE_OFFSET) base_offset = traf->tfhd->base_data_offset; else if (!(traf->tfhd->flags & GF_ISOM_MOOF_BASE_OFFSET)) base_offset = *cumulated_offset; chunk_size = 0; prev_trun_data_offset = 0; data_offset = 0; traf_duration = 0; if (traf->tfdt && is_first_merge) { #ifndef GPAC_DISABLE_LOG if (trak->moov->mov->NextMoofNumber && trak->present_in_scalable_segment && trak->sample_count_at_seg_start && (trak->dts_at_seg_start != traf->tfdt->baseMediaDecodeTime)) { s32 drift = (s32) ((s64) traf->tfdt->baseMediaDecodeTime - (s64)trak->dts_at_seg_start); if (drift<0)  { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Warning: TFDT timing ""LLD"" less than cumulated timing ""LLD"" - using tfdt\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start )); } else { GF_LOG(GF_LOG_INFO, GF_LOG_CONTAINER, (""[iso file] TFDT timing ""LLD"" higher than cumulated timing ""LLD"" (last sample got extended in duration)\n"", traf->tfdt->baseMediaDecodeTime, trak->dts_at_seg_start )); } } #endif trak->dts_at_seg_start = traf->tfdt->baseMediaDecodeTime; } else if (traf->tfxd) { trak->dts_at_seg_start = traf->tfxd->absolute_time_in_track_timescale; } if (traf->tfxd) { trak->last_tfxd_value = traf->tfxd->absolute_time_in_track_timescale; trak->last_tfxd_value += traf->tfxd->fragment_duration_in_track_timescale; } if (traf->tfrf) { if (trak->tfrf) gf_isom_box_del_parent(&trak->child_boxes, (GF_Box *)trak->tfrf); trak->tfrf = traf->tfrf; gf_list_del_item(traf->child_boxes, traf->tfrf); gf_list_add(trak->child_boxes, trak->tfrf); } if (trak->moov->mov->signal_frag_bounds) { store_traf_map = GF_TRUE; if (is_first_merge) { GF_MovieFragmentBox *moof_clone = NULL; gf_isom_box_freeze_order((GF_Box *)moof_box); gf_isom_clone_box((GF_Box *)moof_box, (GF_Box **)&moof_clone); if (moof_clone) { GF_BitStream *bs; for (i=0; i<gf_list_count(moof_clone->TrackList); i++) { GF_TrackFragmentBox *traf_clone = gf_list_get(moof_clone->TrackList, i); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->TrackRuns); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroups); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sampleGroupsDescription); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sub_samples); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_offsets); gf_isom_box_array_reset_parent(&traf_clone->child_boxes, traf_clone->sai_sizes); if (traf_clone->sample_encryption) { gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sample_encryption); traf_clone->sample_encryption = NULL; } if (traf_clone->sdtp) { gf_isom_box_del_parent(&traf_clone->child_boxes, (GF_Box *) traf_clone->sdtp); traf_clone->sdtp = NULL; } } gf_isom_box_size((GF_Box *)moof_clone); bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); if (trak->moov->mov->seg_styp) { gf_isom_box_size(trak->moov->mov->seg_styp); gf_isom_box_write(trak->moov->mov->seg_styp, bs); } if (trak->moov->mov->root_sidx) { gf_isom_box_size((GF_Box *)trak->moov->mov->root_sidx); gf_isom_box_write((GF_Box *)trak->moov->mov->root_sidx, bs); } if (trak->moov->mov->seg_ssix) { gf_isom_box_size(trak->moov->mov->seg_ssix); gf_isom_box_write(trak->moov->mov->seg_ssix, bs); } gf_isom_box_write((GF_Box *)moof_clone, bs); gf_isom_box_del((GF_Box*)moof_clone); gf_bs_get_content(bs, &moof_template, &moof_template_size); gf_bs_del(bs); } } if (trak->moov->mov->seg_styp) { is_seg_start = GF_TRUE; seg_start = trak->moov->mov->styp_start_offset; } if (trak->moov->mov->root_sidx) { is_seg_start = GF_TRUE; sidx_start = trak->moov->mov->sidx_start_offset; sidx_end = trak->moov->mov->sidx_end_offset; if (! seg_start || (sidx_start<seg_start)) seg_start = sidx_start; } frag_start = trak->moov->mov->current_top_box_start; } else if (trak->moov->mov->store_traf_map) { store_traf_map = GF_TRUE; } sample_index = 0; i=0; while ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) { for (j=0; j<trun->sample_count; j++) { GF_Err e; s32 cts_offset=0; if (j<trun->nb_samples) { ent = &trun->samples[j]; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d doesn't have enough trun entries (%d) compared to sample count (%d) in run\n"", traf->trex->trackID, trun->nb_samples, trun->sample_count )); break; } size = def_size; duration = def_duration; flags = def_flags; cts_offset = ent->CTS_Offset; #ifdef GF_ENABLE_CTRN if (trun->use_ctrn) { if (!j && (trun->ctrn_flags & GF_ISOM_CTRN_FIRST_SAMPLE) ) { if (trun->ctrn_first_dur) duration = ent->Duration; if (trun->ctrn_first_size) size = ent->size; if (trun->ctrn_first_ctts) flags = ent->flags; } else { if (trun->ctrn_dur) duration = ent->Duration; if (trun->ctrn_size) size = ent->size; if (trun->ctrn_sample_flags) flags = ent->flags; } if (trun->ctrn_flags & 0xF0) { GF_TrunEntry *ref_entry; if (!traf_ref) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance to track ID %d but reference traf not found\n"", traf->trex->trackID, traf->trex->inherit_from_traf_id )); break; } ref_entry = traf_get_sample_entry(traf_ref, sample_index); if (!ref_entry) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Track %d use traf inheritance but sample %d not found in reference traf\n"", traf->trex->trackID, sample_index+1 )); break; } if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_DUR) duration = ref_entry->Duration; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_SIZE) size = ref_entry->size; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_FLAGS) flags = ref_entry->flags; if (trun->ctrn_flags & GF_ISOM_CTRN_INHERIT_CTSO) cts_offset = ref_entry->CTS_Offset; } } else #endif { if (trun->flags & GF_ISOM_TRUN_DURATION) duration = ent->Duration; if (trun->flags & GF_ISOM_TRUN_SIZE) size = ent->size; if (trun->flags & GF_ISOM_TRUN_FLAGS) { flags = ent->flags; } else if (!j && (trun->flags & GF_ISOM_TRUN_FIRST_FLAG)) { flags = trun->first_sample_flags; } } sample_index++; ent->size = size; ent->Duration = duration; ent->flags = flags; ent->CTS_Offset = cts_offset; last_dts += duration; if (!trak->Media->information->sampleTable->SampleSize) { trak->Media->information->sampleTable->SampleSize = (GF_SampleSizeBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSZ); if (!trak->Media->information->sampleTable->SampleSize) return GF_OUT_OF_MEM; } e = stbl_AppendSize(trak->Media->information->sampleTable, size, ent->nb_pack); if (e) return e; if (!trak->Media->information->sampleTable->TimeToSample) { trak->Media->information->sampleTable->TimeToSample = (GF_TimeToSampleBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STTS); if (!trak->Media->information->sampleTable->TimeToSample) return GF_OUT_OF_MEM; } e = stbl_AppendTime(trak->Media->information->sampleTable, duration, ent->nb_pack); if (e) return e; if (!j) { u64 final_offset; data_offset = base_offset; if (trun->flags & GF_ISOM_TRUN_DATA_OFFSET) { data_offset += trun->data_offset; chunk_size = 0; prev_trun_data_offset = trun->data_offset; if (trun->data_offset>=0) { data_offset -= compressed_diff; prev_trun_data_offset -= compressed_diff; } } else if (prev_trun_data_offset) { data_offset += prev_trun_data_offset + chunk_size; } else { data_offset += chunk_size; if ((i==1) && (trun->data_offset>=0)) { data_offset -= compressed_diff; } } final_offset = data_offset; if (trak->moov->compressed_diff) { final_offset += trak->moov->compressed_diff; } if (!trak->Media->information->sampleTable->ChunkOffset) { trak->Media->information->sampleTable->ChunkOffset = gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STCO); if (!trak->Media->information->sampleTable->ChunkOffset) return GF_OUT_OF_MEM; } e = stbl_AppendChunk(trak->Media->information->sampleTable, final_offset); if (e) return e; if (!trak->Media->information->sampleTable->SampleToChunk) { trak->Media->information->sampleTable->SampleToChunk = (GF_SampleToChunkBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_STSC); if (!trak->Media->information->sampleTable->SampleToChunk) return GF_OUT_OF_MEM; } e = stbl_AppendSampleToChunk(trak->Media->information->sampleTable, DescIndex, trun->sample_count); if (e) return e; } chunk_size += size; if (store_traf_map && first_samp_in_traf) { first_samp_in_traf = GF_FALSE; e = stbl_AppendTrafMap(trak->Media->information->sampleTable, is_seg_start, seg_start, frag_start, moof_template, moof_template_size, sidx_start, sidx_end); if (e) return e; moof_template = NULL; moof_template_size = 0; } if (ent->nb_pack>1) { j+= ent->nb_pack-1; traf_duration += ent->nb_pack*duration; continue; } traf_duration += duration; e = stbl_AppendCTSOffset(trak->Media->information->sampleTable, cts_offset); if (e) return e; sync = GF_ISOM_GET_FRAG_SYNC(flags); if (trak->Media->information->sampleTable->no_sync_found && sync) { trak->Media->information->sampleTable->no_sync_found = 0; } e = stbl_AppendRAP(trak->Media->information->sampleTable, sync); if (e) return e; pad = GF_ISOM_GET_FRAG_PAD(flags); if (pad) { e = stbl_AppendPadding(trak->Media->information->sampleTable, pad); if (e) return e; } degr = GF_ISOM_GET_FRAG_DEG(flags); if (degr) { e = stbl_AppendDegradation(trak->Media->information->sampleTable, degr); if (e) return e; } e = stbl_AppendDependencyType(trak->Media->information->sampleTable, GF_ISOM_GET_FRAG_LEAD(flags), GF_ISOM_GET_FRAG_DEPENDS(flags), GF_ISOM_GET_FRAG_DEPENDED(flags), GF_ISOM_GET_FRAG_REDUNDANT(flags)); if (e) return e; } } if (trak->moov->mov->is_smooth && !traf->tfdt && !traf->tfxd) { if (is_first_merge) trak->dts_at_seg_start = trak->dts_at_next_seg_start; trak->dts_at_next_seg_start += last_dts; } if (traf_duration && trak->editBox && trak->editBox->editList) { for (i=0; i<gf_list_count(trak->editBox->editList->entryList); i++) { GF_EdtsEntry *edts_e = gf_list_get(trak->editBox->editList->entryList, i); if (edts_e->was_empty_dur) { u64 extend_dur = traf_duration; extend_dur *= trak->moov->mvhd->timeScale; extend_dur /= trak->Media->mediaHeader->timeScale; edts_e->segmentDuration += extend_dur; } else if (!edts_e->segmentDuration) { edts_e->was_empty_dur = GF_TRUE; if ((s64) traf_duration > edts_e->mediaTime) traf_duration -= edts_e->mediaTime; else traf_duration = 0; edts_e->segmentDuration = traf_duration; edts_e->segmentDuration *= trak->moov->mvhd->timeScale; edts_e->segmentDuration /= trak->Media->mediaHeader->timeScale; } } } *cumulated_offset = data_offset + chunk_size; if (traf->sampleGroups) { GF_List *groups; GF_List *groupDescs; Bool is_identical_sgpd = GF_TRUE; u32 *new_idx = NULL, new_idx_count=0; if (!trak->Media->information->sampleTable->sampleGroups) trak->Media->information->sampleTable->sampleGroups = gf_list_new(); if (!trak->Media->information->sampleTable->sampleGroupsDescription) trak->Media->information->sampleTable->sampleGroupsDescription = gf_list_new(); groupDescs = trak->Media->information->sampleTable->sampleGroupsDescription; for (i=0; i<gf_list_count(traf->sampleGroupsDescription); i++) { GF_SampleGroupDescriptionBox *new_sgdesc = NULL; GF_SampleGroupDescriptionBox *sgdesc = gf_list_get(traf->sampleGroupsDescription, i); for (j=0; j<gf_list_count(groupDescs); j++) { new_sgdesc = gf_list_get(groupDescs, j); if (new_sgdesc->grouping_type==sgdesc->grouping_type) break; new_sgdesc = NULL; } if (!new_sgdesc) { gf_list_add(groupDescs, sgdesc); gf_list_add(trak->Media->information->sampleTable->child_boxes, sgdesc); gf_list_rem(traf->sampleGroupsDescription, i); gf_list_del_item(traf->child_boxes, sgdesc); i--; } else { u32 count; is_identical_sgpd = gf_isom_is_identical_sgpd(new_sgdesc, sgdesc, 0); if (is_identical_sgpd) continue; new_idx_count = gf_list_count(sgdesc->group_descriptions); new_idx = (u32 *)gf_malloc(new_idx_count * sizeof(u32)); if (!new_idx) return GF_OUT_OF_MEM; count = 0; while (gf_list_count(sgdesc->group_descriptions)) { void *sgpd_entry = gf_list_get(sgdesc->group_descriptions, 0); Bool new_entry = GF_TRUE; for (j = 0; j < gf_list_count(new_sgdesc->group_descriptions); j++) { void *ptr = gf_list_get(new_sgdesc->group_descriptions, j); if (gf_isom_is_identical_sgpd(sgpd_entry, ptr, new_sgdesc->grouping_type)) { new_idx[count] = j + 1; count ++; new_entry = GF_FALSE; gf_free(sgpd_entry); break; } } if (new_entry) { gf_list_add(new_sgdesc->group_descriptions, sgpd_entry); new_idx[count] = gf_list_count(new_sgdesc->group_descriptions); count ++; } gf_list_rem(sgdesc->group_descriptions, 0); } } } groups = trak->Media->information->sampleTable->sampleGroups; for (i=0; i<gf_list_count(traf->sampleGroups); i++) { GF_SampleGroupBox *stbl_group = NULL; GF_SampleGroupBox *frag_group = gf_list_get(traf->sampleGroups, i); for (j=0; j<gf_list_count(groups); j++) { stbl_group = gf_list_get(groups, j); if ((frag_group->grouping_type==stbl_group->grouping_type) && (frag_group->grouping_type_parameter==stbl_group->grouping_type_parameter)) break; stbl_group = NULL; } if (!stbl_group) { stbl_group = (GF_SampleGroupBox *) gf_isom_box_new_parent(&trak->Media->information->sampleTable->child_boxes, GF_ISOM_BOX_TYPE_SBGP); if (!stbl_group) return GF_OUT_OF_MEM; stbl_group->grouping_type = frag_group->grouping_type; stbl_group->grouping_type_parameter = frag_group->grouping_type_parameter; stbl_group->version = frag_group->version; gf_list_add(groups, stbl_group); } if (is_identical_sgpd) { for (j = 0; j < frag_group->entry_count; j++) frag_group->sample_entries[j].group_description_index &= 0x0FFFF; if (frag_group->entry_count && stbl_group->entry_count && (frag_group->sample_entries[0].group_description_index==stbl_group->sample_entries[stbl_group->entry_count-1].group_description_index) ) { stbl_group->sample_entries[stbl_group->entry_count - 1].sample_count += frag_group->sample_entries[0].sample_count; if (frag_group->entry_count>1) { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count - 1)); memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[1], sizeof(GF_SampleGroupEntry) * (frag_group->entry_count - 1)); stbl_group->entry_count += frag_group->entry_count - 1; } } else { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count)); memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count); stbl_group->entry_count += frag_group->entry_count; } } else { stbl_group->sample_entries = gf_realloc(stbl_group->sample_entries, sizeof(GF_SampleGroupEntry) * (stbl_group->entry_count + frag_group->entry_count)); for (j = 0; j < frag_group->entry_count; j++) { u32 sgidx = frag_group->sample_entries[j].group_description_index; if (sgidx > 0x10000) { sgidx -= 0x10001; if (sgidx>=new_idx_count) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[isobmf] corrupted sample group index in fragment %d but only %d group descriptions in fragment\n"", sgidx, new_idx_count)); } else { frag_group->sample_entries[j].group_description_index = new_idx[sgidx]; } } } memcpy(&stbl_group->sample_entries[stbl_group->entry_count], &frag_group->sample_entries[0], sizeof(GF_SampleGroupEntry) * frag_group->entry_count); stbl_group->entry_count += frag_group->entry_count; } } if (new_idx) gf_free(new_idx); } track_num = gf_isom_get_tracknum_from_id(trak->moov, trak->Header->trackID); if (gf_isom_is_cenc_media(trak->moov->mov, track_num, DescIndex) || traf->sample_encryption) { GF_SampleEncryptionBox *senc = NULL; u32 scheme_type; gf_isom_get_cenc_info(trak->moov->mov, track_num, DescIndex, NULL, &scheme_type, NULL); if (traf->sample_encryption) { for (i = 0; i < gf_list_count(trak->Media->information->sampleTable->child_boxes); i++) { GF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->child_boxes, i); if (a->type != traf->sample_encryption->type) continue; if ((a->type ==GF_ISOM_BOX_TYPE_UUID) && (((GF_UUIDBox *)a)->internal_4cc == GF_ISOM_BOX_UUID_PSEC)) { senc = (GF_SampleEncryptionBox *)a; break; } else if (a->type ==GF_ISOM_BOX_TYPE_SENC) { senc = (GF_SampleEncryptionBox *)a; break; } } if (!senc && trak->sample_encryption) senc = trak->sample_encryption; if (!senc) { if (traf->sample_encryption->piff_type==1) { senc = (GF_SampleEncryptionBox *)gf_isom_create_piff_psec_box(1, 0x2, 0, 0, NULL); } else { senc = gf_isom_create_samp_enc_box(1, 0x2); } if (!trak->Media->information->sampleTable->child_boxes) trak->Media->information->sampleTable->child_boxes = gf_list_new(); trak->sample_encryption = senc; if (!trak->child_boxes) trak->child_boxes = gf_list_new(); gf_list_add(trak->child_boxes, senc); } } if (gf_isom_cenc_has_saiz_saio_traf(traf, scheme_type)) { u32 nb_saio; u32 aux_info_type; u64 offset; GF_Err e; Bool is_encrypted; GF_SampleAuxiliaryInfoOffsetBox *saio = NULL; GF_SampleAuxiliaryInfoSizeBox *saiz = NULL; offset = nb_saio = 0; for (i = 0; i < gf_list_count(traf->sai_offsets); i++) { saio = (GF_SampleAuxiliaryInfoOffsetBox *)gf_list_get(traf->sai_offsets, i); aux_info_type = saio->aux_info_type; if (!aux_info_type) aux_info_type = scheme_type; if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) || (aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) || (gf_list_count(traf->sai_offsets) == 1)) { offset = saio->offsets[0] + moof_offset; nb_saio = saio->entry_count; break; } } for (i = 0; i < gf_list_count(traf->sai_sizes); i++) { saiz = (GF_SampleAuxiliaryInfoSizeBox *)gf_list_get(traf->sai_sizes, i); aux_info_type = saiz->aux_info_type; if (!aux_info_type) aux_info_type = scheme_type; if ((aux_info_type == GF_ISOM_CENC_SCHEME) || (aux_info_type == GF_ISOM_CBC_SCHEME) || (aux_info_type == GF_ISOM_CENS_SCHEME) || (aux_info_type == GF_ISOM_CBCS_SCHEME) || (gf_list_count(traf->sai_sizes) == 1)) { break; } } if (saiz && saio) { for (i = 0; i < saiz->sample_count; i++) { GF_CENCSampleAuxInfo *sai; const u8 *key_info=NULL; u32 key_info_size; u64 cur_position; if (nb_saio != 1) offset = saio->offsets[i] + moof_offset; size = saiz->default_sample_info_size ? saiz->default_sample_info_size : saiz->sample_info_size[i]; cur_position = gf_bs_get_position(trak->moov->mov->movieFileMap->bs); gf_bs_seek(trak->moov->mov->movieFileMap->bs, offset); GF_SAFEALLOC(sai, GF_CENCSampleAuxInfo); if (!sai) return GF_OUT_OF_MEM; e = gf_isom_get_sample_cenc_info_internal(trak, traf, senc, i+1, &is_encrypted, NULL, NULL, &key_info, &key_info_size); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isobmf] could not get cenc info for sample %d: %s\n"", i+1, gf_error_to_string(e) )); return e; } if (is_encrypted) { sai->cenc_data_size = size; sai->cenc_data = gf_malloc(sizeof(u8)*size); if (!sai->cenc_data) return GF_OUT_OF_MEM; gf_bs_read_data(trak->moov->mov->movieFileMap->bs, sai->cenc_data, sai->cenc_data_size); } else { sai->isNotProtected=1; } if (key_info) { if (!key_info[0]) { if (size > key_info[3]) senc->flags = 0x00000002; } else { senc->flags = 0x00000002; } } gf_bs_seek(trak->moov->mov->movieFileMap->bs, cur_position); gf_list_add(senc->samp_aux_info, sai); e = gf_isom_cenc_merge_saiz_saio(senc, trak->Media->information->sampleTable, offset, size); if (e) return e; if (nb_saio == 1) offset += size; } } } else if (traf->sample_encryption) { senc_Parse(trak->moov->mov->movieFileMap->bs, trak, traf, traf->sample_encryption); trak->sample_encryption->AlgorithmID = traf->sample_encryption->AlgorithmID; if (!trak->sample_encryption->IV_size) trak->sample_encryption->IV_size = traf->sample_encryption->IV_size; if (!trak->sample_encryption->samp_aux_info) trak->sample_encryption->samp_aux_info = gf_list_new(); gf_list_transfer(trak->sample_encryption->samp_aux_info, traf->sample_encryption->samp_aux_info); if (traf->sample_encryption->flags & 0x00000002) trak->sample_encryption->flags |= 0x00000002; } } return GF_OK; }"
"static int SetupSavePath(const DetectEngineCtx *de_ctx, char *save, size_t save_size) { SCLogDebug(""save %s"", save); if (PathIsAbsolute(save)) { return 0; } const char *dir = ConfigGetDataDirectory(); BUG_ON(dir == NULL);     char path[PATH_MAX]; if (snprintf(path, sizeof(path), ""%s/%s"", dir, save) >= (int)sizeof(path))         return -1; strlcpy(save, path, save_size); return 0; }"
"static int alloc_l4_table(struct page_info *page) { struct domain *d = page_get_owner(page); unsigned long  pfn = mfn_x(page_to_mfn(page)); l4_pgentry_t  *pl4e = map_domain_page(_mfn(pfn)); unsigned int   i; int            rc = 0, partial = page->partial_pte; for ( i = page->nr_validated_ptes; i < L4_PAGETABLE_ENTRIES; i++, partial = 0 ) { if ( !is_guest_l4_slot(d, i) || (rc = get_page_from_l4e(pl4e[i], pfn, d, partial)) > 0 ) continue; if ( rc == -ERESTART ) { page->nr_validated_ptes = i; page->partial_pte = partial ?: 1; } else if ( rc < 0 ) { if ( rc != -EINTR ) gdprintk(XENLOG_WARNING, ""Failure in alloc_l4_table: slot %#x\n"", i); if ( i ) { page->nr_validated_ptes = i; page->partial_pte = 0; if ( rc == -EINTR ) rc = -ERESTART; else { if ( current->arch.old_guest_table ) page->nr_validated_ptes++; current->arch.old_guest_table = page; } } } if ( rc < 0 ) { unmap_domain_page(pl4e); return rc; } pl4e[i] = adjust_guest_l4e(pl4e[i], d); } if ( rc >= 0 ) { init_guest_l4_table(pl4e, d, !VM_ASSIST(d, m2p_strict)); atomic_inc(&d->arch.pv_domain.nr_l4_pages); rc = 0; } unmap_domain_page(pl4e); return rc; }"
"BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags) { int i; BYTE iBitmapFormat; BOOL compressed = FALSE; if (!Stream_EnsureRemainingCapacity(s, update_approximate_cache_brush_order(cache_brush, flags))) return FALSE; iBitmapFormat = BPP_BMF[cache_brush->bpp]; Stream_Write_UINT8(s, cache_brush->index);   Stream_Write_UINT8(s, iBitmapFormat);        Stream_Write_UINT8(s, cache_brush->cx);      Stream_Write_UINT8(s, cache_brush->cy);      Stream_Write_UINT8(s, cache_brush->style);   Stream_Write_UINT8(s, cache_brush->length);  if ((cache_brush->cx == 8) && (cache_brush->cy == 8)) { if (cache_brush->bpp == 1) { if (cache_brush->length != 8) { WLog_ERR(TAG, ""incompatible 1bpp brush of length:%"" PRIu32 """", cache_brush->length); return FALSE; } for (i = 7; i >= 0; i--) { Stream_Write_UINT8(s, cache_brush->data[i]); } } else { if ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20)) compressed = TRUE; else if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24)) compressed = TRUE; else if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32)) compressed = TRUE; if (compressed != FALSE) { if (!update_compress_brush(s, cache_brush->data, cache_brush->bpp)) return FALSE; } else { int scanline = (cache_brush->bpp / 8) * 8; for (i = 7; i >= 0; i--) { Stream_Write(s, &cache_brush->data[i * scanline], scanline); } } } } return TRUE; }"
"static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs) { GF_Err e; u32 NodeID, ind, field_ind, NumBits; GF_Node *node; GF_ChildNodeItem *prev_child; GF_FieldInfo field; NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); node = gf_sg_find_node(codec->current_graph, NodeID); if (!node) return GF_NON_COMPLIANT_BITSTREAM; NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1); ind = gf_bs_read_int(bs, NumBits); e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind); if (e) return e; e = gf_node_get_field(node, field_ind, &field); if (e) return e; prev_child = NULL; if (field.fieldType == GF_SG_VRML_MFNODE) { prev_child = * ((GF_ChildNodeItem **) field.far_ptr); * ((GF_ChildNodeItem **) field.far_ptr) = NULL; } else if (!gf_sg_vrml_is_sf_field(field.fieldType)) { gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType); } codec->is_com_dec = GF_TRUE; e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE); codec->is_com_dec = GF_FALSE; if (field.fieldType == GF_SG_VRML_MFNODE) { gf_node_unregister_children(node, prev_child); } if (!e) gf_bifs_check_field_change(node, &field); return e; }"
"static void polkit_unix_user_class_init (PolkitUnixUserClass *klass) { GObjectClass *gobject_class = G_OBJECT_CLASS (klass); gobject_class->finalize = polkit_unix_user_finalize; gobject_class->get_property = polkit_unix_user_get_property; gobject_class->set_property = polkit_unix_user_set_property; g_object_class_install_property (gobject_class, PROP_UID, g_param_spec_int (""uid"", ""User ID"", ""The UNIX user ID"", 0, G_MAXINT, 0, G_PARAM_CONSTRUCT | G_PARAM_READWRITE | G_PARAM_STATIC_NAME | G_PARAM_STATIC_BLURB | G_PARAM_STATIC_NICK)); }"
"static void decode_residue(vorb *f, float *residue_buffers[], int ch, int n, int rn, uint8 *do_not_decode) { int i,j,pass; Residue *r = f->residue_config + rn; int rtype = f->residue_types[rn]; int c = r->classbook; int classwords = f->codebooks[c].dimensions; int n_read = r->end - r->begin; int part_read = n_read / r->part_size; int temp_alloc_point = temp_alloc_save(f); #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE uint8 ***part_classdata = (uint8 ***) temp_block_array(f,f->channels, part_read * sizeof(**part_classdata)); #else int **classifications = (int **) temp_block_array(f,f->channels, part_read * sizeof(**classifications)); #endif CHECK(f); for (i=0; i < ch; ++i) if (!do_not_decode[i]) memset(residue_buffers[i], 0, sizeof(float) * n); if (rtype == 2 && ch != 1) { for (j=0; j < ch; ++j) if (!do_not_decode[j]) break; if (j == ch) goto done; for (pass=0; pass < 8; ++pass) { int pcount = 0, class_set = 0; if (ch == 2) { while (pcount < part_read) { int z = r->begin + pcount*r->part_size; int c_inter = (z & 1), p_inter = z>>1; if (pass == 0) { Codebook *c = f->codebooks+r->classbook; int q; DECODE(q,f,c); if (q == EOP) goto done; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata[0][class_set] = r->classdata[q]; #else for (i=classwords-1; i >= 0; --i) { classifications[0][i+pcount] = q % r->classifications; q /= r->classifications; } #endif } for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) { int z = r->begin + pcount*r->part_size; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata[0][class_set][i]; #else int c = classifications[0][pcount]; #endif int b = r->residue_books[c][pass]; if (b >= 0) { Codebook *book = f->codebooks + b; #ifdef STB_VORBIS_DIVIDES_IN_CODEBOOK if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size)) goto done; #else if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size)) goto done; #endif } else { z += r->part_size; c_inter = z & 1; p_inter = z >> 1; } } #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++class_set; #endif } } else if (ch == 1) { while (pcount < part_read) { int z = r->begin + pcount*r->part_size; int c_inter = 0, p_inter = z; if (pass == 0) { Codebook *c = f->codebooks+r->classbook; int q; DECODE(q,f,c); if (q == EOP) goto done; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata[0][class_set] = r->classdata[q]; #else for (i=classwords-1; i >= 0; --i) { classifications[0][i+pcount] = q % r->classifications; q /= r->classifications; } #endif } for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) { int z = r->begin + pcount*r->part_size; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata[0][class_set][i]; #else int c = classifications[0][pcount]; #endif int b = r->residue_books[c][pass]; if (b >= 0) { Codebook *book = f->codebooks + b; if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size)) goto done; } else { z += r->part_size; c_inter = 0; p_inter = z; } } #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++class_set; #endif } } else { while (pcount < part_read) { int z = r->begin + pcount*r->part_size; int c_inter = z % ch, p_inter = z/ch; if (pass == 0) { Codebook *c = f->codebooks+r->classbook; int q; DECODE(q,f,c); if (q == EOP) goto done; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata[0][class_set] = r->classdata[q]; #else for (i=classwords-1; i >= 0; --i) { classifications[0][i+pcount] = q % r->classifications; q /= r->classifications; } #endif } for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) { int z = r->begin + pcount*r->part_size; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata[0][class_set][i]; #else int c = classifications[0][pcount]; #endif int b = r->residue_books[c][pass]; if (b >= 0) { Codebook *book = f->codebooks + b; if (!codebook_decode_deinterleave_repeat(f, book, residue_buffers, ch, &c_inter, &p_inter, n, r->part_size)) goto done; } else { z += r->part_size; c_inter = z % ch; p_inter = z / ch; } } #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++class_set; #endif } } } goto done; } CHECK(f); for (pass=0; pass < 8; ++pass) { int pcount = 0, class_set=0; while (pcount < part_read) { if (pass == 0) { for (j=0; j < ch; ++j) { if (!do_not_decode[j]) { Codebook *c = f->codebooks+r->classbook; int temp; DECODE(temp,f,c); if (temp == EOP) goto done; #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata[j][class_set] = r->classdata[temp]; #else for (i=classwords-1; i >= 0; --i) { classifications[j][i+pcount] = temp % r->classifications; temp /= r->classifications; } #endif } } } for (i=0; i < classwords && pcount < part_read; ++i, ++pcount) { for (j=0; j < ch; ++j) { if (!do_not_decode[j]) { #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE int c = part_classdata[j][class_set][i]; #else int c = classifications[j][pcount]; #endif int b = r->residue_books[c][pass]; if (b >= 0) { float *target = residue_buffers[j]; int offset = r->begin + pcount * r->part_size; int n = r->part_size; Codebook *book = f->codebooks + b; if (!residue_decode(f, book, target, offset, n, rtype)) goto done; } } } } #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE ++class_set; #endif } } done: CHECK(f); #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE temp_free(f,part_classdata); #else temp_free(f,classifications); #endif temp_alloc_restore(f,temp_alloc_point); }"
"static void chrc_write_cb(struct gatt_db_attribute *attrib, unsigned int id, uint16_t offset, const uint8_t *value, size_t len, uint8_t opcode, struct bt_att *att, void *user_data) { struct external_chrc *chrc = user_data; struct btd_device *device; struct queue *queue; DBusMessageIter iter; if (chrc->attrib != attrib) { error(""Write callback called with incorrect attribute""); goto fail; } device = att_get_device(att); if (!device) { error(""Unable to find device object""); goto fail; } if (!(chrc->props & BT_GATT_CHRC_PROP_WRITE_WITHOUT_RESP)) queue = chrc->pending_writes; else queue = NULL; if (opcode == BT_ATT_OP_PREP_WRITE_REQ) { if (!device_is_trusted(device) && !chrc->prep_authorized && chrc->req_prep_authorization) send_write(device, attrib, chrc->proxy, queue, id, value, len, offset, bt_att_get_link_type(att), true, true); else gatt_db_attribute_write_result(attrib, id, 0); return; } if (opcode == BT_ATT_OP_EXEC_WRITE_REQ) chrc->prep_authorized = false; if (chrc->write_io) { if (sock_io_send(chrc->write_io, value, len) < 0) { error(""Unable to write: %s"", strerror(errno)); goto fail; } gatt_db_attribute_write_result(attrib, id, 0); return; } if (g_dbus_proxy_get_property(chrc->proxy, ""WriteAcquired"", &iter)) { if (acquire_write(chrc, device, attrib, id, value, len, bt_att_get_link_type(att))) return; } if (send_write(device, attrib, chrc->proxy, queue, id, value, len, offset, bt_att_get_link_type(att), false, false)) return; fail: gatt_db_attribute_write_result(attrib, id, BT_ATT_ERROR_UNLIKELY); }"
"void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input, typename TTypes<T, 3>::ConstTensor filter, typename TTypes<T, 4>::ConstTensor out_backprop, int stride_rows, int stride_cols, int rate_rows, int rate_cols, int pad_top, int pad_left, typename TTypes<T, 3>::Tensor filter_backprop) { const int batch = input.dimension(0); const int input_rows = input.dimension(1); const int input_cols = input.dimension(2); const int depth = input.dimension(3); const int filter_rows = filter.dimension(0); const int filter_cols = filter.dimension(1); const int output_rows = out_backprop.dimension(1); const int output_cols = out_backprop.dimension(2); filter_backprop.setZero(); for (int b = 0; b < batch; ++b) { for (int h_out = 0; h_out < output_rows; ++h_out) { int h_beg = h_out * stride_rows - pad_top; for (int w_out = 0; w_out < output_cols; ++w_out) { int w_beg = w_out * stride_cols - pad_left; for (int d = 0; d < depth; ++d) { T cur_val = Eigen::NumTraits<T>::lowest(); int h_max = 0; int w_max = 0; for (int h = 0; h < filter_rows; ++h) { const int h_in = h_beg + h * rate_rows; if (h_in >= 0 && h_in < input_rows) { for (int w = 0; w < filter_cols; ++w) { const int w_in = w_beg + w * rate_cols; if (w_in >= 0 && w_in < input_cols) { const T val = input(b, h_in, w_in, d) + filter(h, w, d); if (val > cur_val) { cur_val = val; h_max = h; w_max = w; } } } } } filter_backprop(h_max, w_max, d) += out_backprop(b, h_out, w_out, d); } } } } }"
"int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols) { int rc; pr_debug(""dev_name %s initiator protocols 0x%x target protocols 0x%x\n"", dev_name(&dev->dev), im_protocols, tm_protocols); if (!im_protocols && !tm_protocols) return -EINVAL; device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (!dev->dev_up) { rc = -ENODEV; goto error; } if (dev->polling) { rc = -EBUSY; goto error; } rc = dev->ops->start_poll(dev, im_protocols, tm_protocols); if (!rc) { dev->polling = true; dev->rf_mode = NFC_RF_NONE; } error: device_unlock(&dev->dev); return rc; }"
"void gdImageRectangle (gdImagePtr im, int x1, int y1, int x2, int y2, int color) { int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2; int thick = im->thick; int t; if (x1 == x2 && y1 == y2 && thick == 1) { gdImageSetPixel(im, x1, y1, color); return; } if (y2 < y1) { t=y1; y1 = y2; y2 = t; t = x1; x1 = x2; x2 = t; } x1h = x1; x1v = x1; y1h = y1; y1v = y1; x2h = x2; x2v = x2; y2h = y2; y2v = y2; if (thick > 1) { int cx, cy, x1ul, y1ul, x2lr, y2lr; int half = thick >> 1; x1ul = x1 - half; y1ul = y1 - half; x2lr = x2 + half; y2lr = y2 + half; cy = y1ul + thick; while (cy-- > y1ul) { cx = x1ul - 1; while (cx++ < x2lr) { gdImageSetPixel(im, cx, cy, color); } } cy = y2lr - thick; while (cy++ < y2lr) { cx = x1ul - 1; while (cx++ < x2lr) { gdImageSetPixel(im, cx, cy, color); } } cy = y1ul + thick - 1; while (cy++ < y2lr -thick) { cx = x1ul - 1; while (cx++ < x1ul + thick) { gdImageSetPixel(im, cx, cy, color); } } cy = y1ul + thick - 1; while (cy++ < y2lr -thick) { cx = x2lr - thick - 1; while (cx++ < x2lr) { gdImageSetPixel(im, cx, cy, color); } } return; } else { y1v = y1h + 1; y2v = y2h - 1; gdImageLine(im, x1h, y1h, x2h, y1h, color); gdImageLine(im, x1h, y2h, x2h, y2h, color); gdImageLine(im, x1v, y1v, x1v, y2v, color); gdImageLine(im, x2v, y1v, x2v, y2v, color); } }"
"std::string encodeBase64(const std::string& input) { using namespace boost::archive::iterators; using b64it = base64_from_binary<transform_width<const char*, 6, 8>>; auto data = input.data(); std::string encoded(b64it(data), b64it(data + (input.length()))); encoded.append((3 - (input.length() % 3)) % 3, '='); return encoded; }"
"static void esis_print(netdissect_options *ndo, const uint8_t *pptr, u_int length) { const uint8_t *optr; u_int li,esis_pdu_type,source_address_length, source_address_number; const struct esis_header_t *esis_header; if (!ndo->ndo_eflag) ND_PRINT((ndo, ""ES-IS"")); if (length <= 2) { ND_PRINT((ndo, ndo->ndo_qflag ? ""bad pkt!"" : ""no header at all!"")); return; } esis_header = (const struct esis_header_t *) pptr; ND_TCHECK(*esis_header); li = esis_header->length_indicator; optr = pptr; if (esis_header->nlpid != NLPID_ESIS) { ND_PRINT((ndo, "" nlpid 0x%02x packet not supported"", esis_header->nlpid)); return; } if (esis_header->version != ESIS_VERSION) { ND_PRINT((ndo, "" version %d packet not supported"", esis_header->version)); return; } if (li > length) { ND_PRINT((ndo, "" length indicator(%u) > PDU size (%u)!"", li, length)); return; } if (li < sizeof(struct esis_header_t) + 2) { ND_PRINT((ndo, "" length indicator %u < min PDU size:"", li)); while (pptr < ndo->ndo_snapend) ND_PRINT((ndo, ""%02X"", *pptr++)); return; } esis_pdu_type = esis_header->type & ESIS_PDU_TYPE_MASK; if (ndo->ndo_vflag < 1) { ND_PRINT((ndo, ""%s%s, length %u"", ndo->ndo_eflag ? """" : "", "", tok2str(esis_pdu_values,""unknown type (%u)"",esis_pdu_type), length)); return; } else ND_PRINT((ndo, ""%slength %u\n\t%s (%u)"", ndo->ndo_eflag ? """" : "", "", length, tok2str(esis_pdu_values,""unknown type: %u"", esis_pdu_type), esis_pdu_type)); ND_PRINT((ndo, "", v: %u%s"", esis_header->version, esis_header->version == ESIS_VERSION ? """" : ""unsupported"" )); ND_PRINT((ndo, "", checksum: 0x%04x"", EXTRACT_16BITS(esis_header->cksum))); osi_print_cksum(ndo, pptr, EXTRACT_16BITS(esis_header->cksum), 7, li); ND_PRINT((ndo, "", holding time: %us, length indicator: %u"", EXTRACT_16BITS(esis_header->holdtime), li)); if (ndo->ndo_vflag > 1) print_unknown_data(ndo, optr, ""\n\t"", sizeof(struct esis_header_t)); pptr += sizeof(struct esis_header_t); li -= sizeof(struct esis_header_t); switch (esis_pdu_type) { case ESIS_PDU_REDIRECT: { const uint8_t *dst, *snpa, *neta; u_int dstl, snpal, netal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dstl = *pptr; pptr++; li--; ND_TCHECK2(*pptr, dstl); if (li < dstl) { ND_PRINT((ndo, "", bad redirect/li"")); return; } dst = pptr; pptr += dstl; li -= dstl; ND_PRINT((ndo, ""\n\t  %s"", isonsap_string(ndo, dst, dstl))); ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpal = *pptr; pptr++; li--; ND_TCHECK2(*pptr, snpal); if (li < snpal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } snpa = pptr; pptr += snpal; li -= snpal; ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad redirect/li"")); return; } netal = *pptr; pptr++; ND_TCHECK2(*pptr, netal); if (li < netal) { ND_PRINT((ndo, "", bad redirect/li"")); return; } neta = pptr; pptr += netal; li -= netal; if (snpal == 6) ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"", snpal, etheraddr_string(ndo, snpa))); else ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"", snpal, linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal))); if (netal != 0) ND_PRINT((ndo, ""\n\t  NET (length: %u) %s"", netal, isonsap_string(ndo, neta, netal))); break; } case ESIS_PDU_ESH: ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_number = *pptr; pptr++; li--; ND_PRINT((ndo, ""\n\t  Number of Source Addresses: %u"", source_address_number)); while (source_address_number > 0) { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad esh/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad esh/li"")); return; } ND_PRINT((ndo, ""\n\t  NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; source_address_number--; } break; case ESIS_PDU_ISH: { ND_TCHECK(*pptr); if (li < 1) { ND_PRINT((ndo, "", bad ish/li"")); return; } source_address_length = *pptr; pptr++; li--; ND_TCHECK2(*pptr, source_address_length); if (li < source_address_length) { ND_PRINT((ndo, "", bad ish/li"")); return; } ND_PRINT((ndo, ""\n\t  NET (length: %u): %s"", source_address_length, isonsap_string(ndo, pptr, source_address_length))); pptr += source_address_length; li -= source_address_length; break; } default: if (ndo->ndo_vflag <= 1) { if (pptr < ndo->ndo_snapend) print_unknown_data(ndo, pptr, ""\n\t  "", ndo->ndo_snapend - pptr); } return; } while (li != 0) { u_int op, opli; const uint8_t *tptr; if (li < 2) { ND_PRINT((ndo, "", bad opts/li"")); return; } ND_TCHECK2(*pptr, 2); op = *pptr++; opli = *pptr++; li -= 2; if (opli > li) { ND_PRINT((ndo, "", opt (%d) too long"", op)); return; } li -= opli; tptr = pptr; ND_PRINT((ndo, ""\n\t  %s Option #%u, length %u, value: "", tok2str(esis_option_values,""Unknown"",op), op, opli)); switch (op) { case ESIS_OPTION_ES_CONF_TIME: if (opli == 2) { ND_TCHECK2(*pptr, 2); ND_PRINT((ndo, ""%us"", EXTRACT_16BITS(tptr))); } else ND_PRINT((ndo, ""(bad length)"")); break; case ESIS_OPTION_PROTOCOLS: while (opli>0) { ND_TCHECK(*pptr); ND_PRINT((ndo, ""%s (0x%02x)"", tok2str(nlpid_values, ""unknown"", *tptr), *tptr)); if (opli>1)  ND_PRINT((ndo, "", "")); tptr++; opli--; } break; case ESIS_OPTION_QOS_MAINTENANCE: case ESIS_OPTION_SECURITY: case ESIS_OPTION_PRIORITY: case ESIS_OPTION_ADDRESS_MASK: case ESIS_OPTION_SNPA_MASK: default: print_unknown_data(ndo, tptr, ""\n\t  "", opli); break; } if (ndo->ndo_vflag > 1) print_unknown_data(ndo, pptr, ""\n\t  "", opli); pptr += opli; } trunc: return; }"
"static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement) { size_t i; int de, section_index = SECTION_MAKERNOTE; int NumDirEntries, old_motorola_intel; #ifdef KALLE_0 int offset_diff; #endif const maker_note_type *maker_note; char *dir_start; int data_len; for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) { if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) { #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""No maker note data found. Detected maker: %s (length = %d)"", ImageInfo->make, strlen(ImageInfo->make)); #endif return TRUE; } maker_note = maker_note_array+i; if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make))) continue; if (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len)) continue; break; } if (value_len < 2 || maker_note->offset >= value_len - 1) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X offset 0x%04X"", value_len, maker_note->offset); return FALSE; } dir_start = value_ptr + maker_note->offset; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement)); #endif ImageInfo->sections_found |= FOUND_MAKERNOTE; old_motorola_intel = ImageInfo->motorola_intel; switch (maker_note->byte_order) { case MN_ORDER_INTEL: ImageInfo->motorola_intel = 0; break; case MN_ORDER_MOTOROLA: ImageInfo->motorola_intel = 1; break; default: case MN_ORDER_NORMAL: break; } NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel); switch (maker_note->offset_mode) { case MN_OFFSET_MAKER: offset_base = value_ptr; data_len = value_len; break; #ifdef KALLE_0 case MN_OFFSET_GUESS: if (maker_note->offset + 10 + 4 >= value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X"", value_len); return FALSE; } offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel); #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff); #endif if (offset_diff < 0 || offset_diff >= value_len ) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data bad offset: 0x%04X length 0x%04X"", offset_diff, value_len); return FALSE; } offset_base = value_ptr + offset_diff; data_len = value_len - offset_diff; break; #endif default: case MN_OFFSET_NORMAL: data_len = value_len; break; } if ((2+NumDirEntries*12) > value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len); return FALSE; } for (de=0;de<NumDirEntries;de++) { if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de, offset_base, data_len, displacement, section_index, 0, maker_note->tag_table)) { return FALSE; } } ImageInfo->motorola_intel = old_motorola_intel; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE)); #endif return TRUE; }"
void ElementAnimations::AddPlayer(AnimationPlayer* player) { players_list_->Append(player); }
"u_int juniper_mfr_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; memset(&l2info, 0, sizeof(l2info)); l2info.pictype = DLT_JUNIPER_MFR; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; if (l2info.cookie_len == 0) { mfr_print(ndo, p, l2info.length); return l2info.header_len; } if (l2info.cookie_len == AS_PIC_COOKIE_LEN) { switch(l2info.proto) { case JUNIPER_LSQ_L3_PROTO_IPV4: ip_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_IPV6: ip6_print(ndo, p,l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_MPLS: mpls_print(ndo, p, l2info.length); return l2info.header_len; case JUNIPER_LSQ_L3_PROTO_ISO: isoclns_print(ndo, p, l2info.length, l2info.caplen); return l2info.header_len; default: break; } return l2info.header_len; } if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1) ND_PRINT((ndo, ""Bundle-ID %u, "", l2info.bundle)); switch (l2info.proto) { case (LLCSAP_ISONS<<8 | LLCSAP_ISONS): isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1); break; case (LLC_UI<<8 | NLPID_Q933): case (LLC_UI<<8 | NLPID_IP): case (LLC_UI<<8 | NLPID_IP6): isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1); break; default: ND_PRINT((ndo, ""unknown protocol 0x%04x, length %u"", l2info.proto, l2info.length)); } return l2info.header_len; }"
"static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg) { struct crypto_report_acomp racomp; strlcpy(racomp.type, ""acomp"", sizeof(racomp.type)); if (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP, sizeof(struct crypto_report_acomp), &racomp)) goto nla_put_failure; return 0; nla_put_failure: return -EMSGSIZE; }"
"static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus, uint8_t devfn) { const struct domain_iommu *hd = dom_iommu(d); struct pci_dev *pdev; int ret = 0; if ( !is_iommu_enabled(d) ) return -EINVAL; ASSERT(pcidevs_locked()); pdev = pci_get_pdev_by_domain(d, seg, bus, devfn); if ( !pdev ) return -ENODEV; while ( pdev->phantom_stride ) { devfn += pdev->phantom_stride; if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) ) break; ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn, pci_to_dev(pdev)); if ( !ret ) continue; printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret); return ret; } devfn = pdev->devfn; ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn, pci_to_dev(pdev)); if ( ret ) { dprintk(XENLOG_G_ERR, ""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn)); return ret; } pdev->fault.count = 0; return ret; }"
"static long mem_seek(jas_stream_obj_t *obj, long offset, int origin) { jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; long newpos; JAS_DBGLOG(100, (""mem_seek(%p, %ld, %d)\n"", obj, offset, origin)); switch (origin) { case SEEK_SET: newpos = offset; break; case SEEK_END: newpos = m->len_ - offset; break; case SEEK_CUR: newpos = m->pos_ + offset; break; default: abort(); break; } if (newpos < 0) { return -1; } m->pos_ = newpos; return m->pos_; }"
"status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory, sound_model_handle_t *handle) { ALOGV(""loadSoundModel() handle""); if (!captureHotwordAllowed()) { return PERMISSION_DENIED; } if (modelMemory == 0 || modelMemory->pointer() == NULL) { ALOGE(""loadSoundModel() modelMemory is 0 or has NULL pointer()""); return BAD_VALUE; } struct sound_trigger_sound_model *sound_model = (struct sound_trigger_sound_model *)modelMemory->pointer(); AutoMutex lock(mLock); if (mModels.size() >= mDescriptor.properties.max_sound_models) { ALOGW(""loadSoundModel(): Not loading, max number of models (%d) would be exceeded"", mDescriptor.properties.max_sound_models); return INVALID_OPERATION; } status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model, SoundTriggerHwService::soundModelCallback, this, handle); if (status != NO_ERROR) { return status; } audio_session_t session; audio_io_handle_t ioHandle; audio_devices_t device; status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device); if (status != NO_ERROR) { return status; } sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type); mModels.replaceValueFor(*handle, model); return status; }"
"inline void Conv3DTranspose( const Conv3DTransposeParams& params, const RuntimeShape& input_shape, const float* input_data, const RuntimeShape& filter_shape, const float* filter_data, const RuntimeShape& bias_shape, const float* bias_data, const RuntimeShape& output_shape, float* output_data) { const int stride_width = params.stride_width; const int stride_height = params.stride_height; const int stride_depth = params.stride_depth; const int pad_width = params.padding_values.width; const int pad_height = params.padding_values.height; const int pad_depth = params.padding_values.depth; TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 5); TFLITE_DCHECK_EQ(filter_shape.DimensionsCount(), 5); TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 5); const int batches = MatchingDim(input_shape, 0, output_shape, 0); const int input_num_channels = MatchingDim(input_shape, 4, filter_shape, 4); const int output_num_channels = output_shape.Dims(4); const int input_depth = input_shape.Dims(1); const int input_height = input_shape.Dims(2); const int input_width = input_shape.Dims(3); const int filter_depth = filter_shape.Dims(0); const int filter_height = filter_shape.Dims(1); const int filter_width = filter_shape.Dims(2); const int output_depth = output_shape.Dims(1); const int output_height = output_shape.Dims(2); const int output_width = output_shape.Dims(3); if (bias_data) { TFLITE_DCHECK_EQ(bias_shape.FlatSize(), output_num_channels); } const int num_elements = output_shape.FlatSize(); for (int i = 0; i < num_elements; i++) { output_data[i] = 0.0f; } for (int batch = 0; batch < batches; ++batch) { for (int in_d = 0; in_d < input_depth; ++in_d) { for (int in_y = 0; in_y < input_height; ++in_y) { for (int in_x = 0; in_x < input_width; ++in_x) { for (int in_channel = 0; in_channel < input_num_channels; ++in_channel) { const int out_x_origin = (in_x * stride_width) - pad_width; const int out_y_origin = (in_y * stride_height) - pad_height; const int out_d_origin = (in_d * stride_depth) - pad_depth; for (int filter_d = 0; filter_d < filter_depth; ++filter_d) { for (int filter_y = 0; filter_y < filter_height; ++filter_y) { for (int filter_x = 0; filter_x < filter_width; ++filter_x) { for (int out_channel = 0; out_channel < output_num_channels; ++out_channel) { const int out_x = out_x_origin + params.dilation_width * filter_x; const int out_y = out_y_origin + params.dilation_height * filter_y; const int out_d = out_d_origin + params.dilation_depth * filter_d; if ((out_x >= 0) && (out_x < output_width) && (out_y >= 0) && (out_y < output_height) && (out_d >= 0) && (out_d < output_depth)) { float input_value = input_data[Offset( input_shape, batch, in_d, in_y, in_x, in_channel)]; float filter_value = filter_data[Offset( filter_shape, filter_d, filter_y, filter_x, out_channel, in_channel)]; output_data[Offset(output_shape, batch, out_d, out_y, out_x, out_channel)] += input_value * filter_value; } } } } } } } } } } const float float_activation_min = params.float_activation_min; const float float_activation_max = params.float_activation_max; float* data_ptr = output_data; if (bias_data) { const int outer_size = batches * output_depth * output_height * output_width; const int num_channels = input_shape.Dims(4); for (int n = 0; n < outer_size; ++n) { for (int c = 0; c < output_num_channels; ++c) { data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c], float_activation_min, float_activation_max); } data_ptr += num_channels; } } else { const int flat_size = output_shape.FlatSize(); for (int i = 0; i < flat_size; ++i) { data_ptr[i] = ActivationFunctionWithMinMax( data_ptr[i], float_activation_min, float_activation_max); } } }"
"TEE_Result crypto_mac_alloc_ctx(void **ctx_ret, uint32_t algo) { TEE_Result res; size_t ctx_size; void *ctx; res = mac_get_ctx_size(algo, &ctx_size); if (res) return res; ctx = calloc(1, ctx_size); if (!ctx) return TEE_ERROR_OUT_OF_MEMORY; *ctx_ret = ctx; return TEE_SUCCESS; }"
"static String HHVM_FUNCTION(bcsub, const String& left, const String& right, int64_t scale ) { if (scale < 0) scale = BCG(bc_precision); bc_num first, second, result; bc_init_num(&first); bc_init_num(&second); bc_init_num(&result); php_str2num(&first, (char*)left.data()); php_str2num(&second, (char*)right.data()); bc_sub(first, second, &result, scale); if (result->n_scale > scale) { result->n_scale = scale; } String ret(bc_num2str(result), AttachString); bc_free_num(&first); bc_free_num(&second); bc_free_num(&result); return ret; }"
"int yr_re_fast_exec( uint8_t* code, uint8_t* input_data, size_t input_size, int flags, RE_MATCH_CALLBACK_FUNC callback, void* callback_args) { RE_REPEAT_ANY_ARGS* repeat_any_args; uint8_t* code_stack[MAX_FAST_RE_STACK]; uint8_t* input_stack[MAX_FAST_RE_STACK]; int matches_stack[MAX_FAST_RE_STACK]; uint8_t* ip = code; uint8_t* input = input_data; uint8_t* next_input; uint8_t* next_opcode; uint8_t mask; uint8_t value; int i; int stop; int input_incr; int sp = 0; int bytes_matched; int max_bytes_matched = input_size; input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1; if (flags & RE_FLAGS_BACKWARDS) input--; code_stack[sp] = code; input_stack[sp] = input; matches_stack[sp] = 0; sp++; while (sp > 0) { sp--; ip = code_stack[sp]; input = input_stack[sp]; bytes_matched = matches_stack[sp]; stop = FALSE; while(!stop) { if (*ip == RE_OPCODE_MATCH) { if (flags & RE_FLAGS_EXHAUSTIVE) { int cb_result = callback( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data, bytes_matched, flags, callback_args); switch(cb_result) { case ERROR_INSUFFICIENT_MEMORY: return -2; case ERROR_TOO_MANY_MATCHES: return -3; default: if (cb_result != ERROR_SUCCESS) return -4; } break; } else { return bytes_matched; } } if (bytes_matched >= max_bytes_matched) break; switch(*ip) { case RE_OPCODE_LITERAL: if (*input == *(ip + 1)) { bytes_matched++; input += input_incr; ip += 2; } else { stop = TRUE; } break; case RE_OPCODE_MASKED_LITERAL: value = *(int16_t*)(ip + 1) & 0xFF; mask = *(int16_t*)(ip + 1) >> 8; if ((*input & mask) == value) { bytes_matched++; input += input_incr; ip += 3; } else { stop = TRUE; } break; case RE_OPCODE_ANY: bytes_matched++; input += input_incr; ip += 1; break; case RE_OPCODE_REPEAT_ANY_UNGREEDY: repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1); next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS); for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++) { next_input = input + i * input_incr; if (bytes_matched + i >= max_bytes_matched) break; if ( *(next_opcode) != RE_OPCODE_LITERAL || (*(next_opcode) == RE_OPCODE_LITERAL && *(next_opcode + 1) == *next_input)) { if (sp >= MAX_FAST_RE_STACK) return -4; code_stack[sp] = next_opcode; input_stack[sp] = next_input; matches_stack[sp] = bytes_matched + i; sp++; } } input += input_incr * repeat_any_args->min; bytes_matched += repeat_any_args->min; ip = next_opcode; break; default: assert(FALSE); } } } return -1; }"
"static int wav_fmt(wav_reader_t *reader, uint32_t size) { uint16_t wFormatTag, nChannels, nBlockAlign, wBitsPerSample, cbSize; uint32_t nSamplesPerSec, nAvgBytesPerSec, dwChannelMask = 0; uint16_t wValidBitsPerSample; uint8_t guid[16]; int is_float = 0; ENSURE(size >= 16); TRY_IO(pcm_scanl(&reader->io, ""SSLLSS"", &wFormatTag, &nChannels, &nSamplesPerSec, &nAvgBytesPerSec, &nBlockAlign, &wBitsPerSample) != 6); wValidBitsPerSample = wBitsPerSample; ENSURE(wFormatTag == 1 || wFormatTag == 3 || wFormatTag == 0xfffe); ENSURE(nChannels && nSamplesPerSec && nAvgBytesPerSec && nBlockAlign && wBitsPerSample && !(wBitsPerSample & 7) && nBlockAlign == nChannels * wBitsPerSample / 8); if (wFormatTag == 3) is_float = 1; if (wFormatTag != 0xfffe) TRY_IO(pcm_skip(&reader->io, (size - 15) & ~1)); else { ENSURE(size >= 40); TRY_IO(pcm_scanl(&reader->io, ""SSL"", &cbSize, &wValidBitsPerSample, &dwChannelMask) != 3); TRY_IO(pcm_read(&reader->io, guid, 16) != 16); if (memcmp(guid, WAV_GUID_FLOAT, 16) == 0) is_float = 1; else if (memcmp(guid, WAV_GUID_PCM, 16) != 0) goto FAIL; ENSURE(wValidBitsPerSample && wValidBitsPerSample <= wBitsPerSample); TRY_IO(pcm_skip(&reader->io, (size - 39) & ~1)); } reader->sample_format.sample_rate = nSamplesPerSec; reader->sample_format.bits_per_channel = wValidBitsPerSample; reader->sample_format.bytes_per_frame = nBlockAlign; reader->sample_format.channels_per_frame = nChannels; reader->sample_format.channel_mask = dwChannelMask; if (is_float) reader->sample_format.sample_type = PCM_TYPE_FLOAT; else if (wBitsPerSample == 8) reader->sample_format.sample_type = PCM_TYPE_UINT; else reader->sample_format.sample_type = PCM_TYPE_SINT; return 0; FAIL: return -1; }"
"int get_devices_from_authfile(const char *authfile, const char *username, unsigned max_devs, int verbose, FILE *debug_file, device_t *devices, unsigned *n_devs) { char *buf = NULL; char *s_user, *s_token; int retval = 0; int fd = -1; struct stat st; struct passwd *pw = NULL, pw_s; char buffer[BUFSIZE]; int gpu_ret; FILE *opwfile = NULL; unsigned i, j; *n_devs = 0; fd = open(authfile, O_RDONLY, 0); if (fd < 0) { if (verbose) D(debug_file, ""Cannot open file: %s (%s)"", authfile, strerror(errno)); goto err; } if (fstat(fd, &st) < 0) { if (verbose) D(debug_file, ""Cannot stat file: %s (%s)"", authfile, strerror(errno)); goto err; } if (!S_ISREG(st.st_mode)) { if (verbose) D(debug_file, ""%s is not a regular file"", authfile); goto err; } if (st.st_size == 0) { if (verbose) D(debug_file, ""File %s is empty"", authfile); goto err; } gpu_ret = getpwuid_r(st.st_uid, &pw_s, buffer, sizeof(buffer), &pw); if (gpu_ret != 0 || pw == NULL) { D(debug_file, ""Unable to retrieve credentials for uid %u, (%s)"", st.st_uid, strerror(errno)); goto err; } if (strcmp(pw->pw_name, username) != 0 && strcmp(pw->pw_name, ""root"") != 0) { if (strcmp(username, ""root"") != 0) { D(debug_file, ""The owner of the authentication file is neither %s nor root"", username); } else { D(debug_file, ""The owner of the authentication file is not root""); } goto err; } opwfile = fdopen(fd, ""r""); if (opwfile == NULL) { if (verbose) D(debug_file, ""fdopen: %s"", strerror(errno)); goto err; } buf = malloc(sizeof(char) * (DEVSIZE * max_devs)); if (!buf) { if (verbose) D(debug_file, ""Unable to allocate memory""); goto err; } retval = -2; while (fgets(buf, (int)(DEVSIZE * (max_devs - 1)), opwfile)) { char *saveptr = NULL; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = '\0'; if (verbose) D(debug_file, ""Authorization line: %s"", buf); s_user = strtok_r(buf, "":"", &saveptr); if (s_user && strcmp(username, s_user) == 0) { if (verbose) D(debug_file, ""Matched user: %s"", s_user); retval = -1;  for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; i = 0; while ((s_token = strtok_r(NULL, "","", &saveptr))) { devices[i].keyHandle = NULL; devices[i].publicKey = NULL; if ((*n_devs)++ > MAX_DEVS - 1) { *n_devs = MAX_DEVS; if (verbose) D(debug_file, ""Found more than %d devices, ignoring the remaining ones"", MAX_DEVS); break; } if (verbose) D(debug_file, ""KeyHandle for device number %d: %s"", i + 1, s_token); devices[i].keyHandle = strdup(s_token); if (!devices[i].keyHandle) { if (verbose) D(debug_file, ""Unable to allocate memory for keyHandle number %d"", i); goto err; } s_token = strtok_r(NULL, "":"", &saveptr); if (!s_token) { if (verbose) D(debug_file, ""Unable to retrieve publicKey number %d"", i + 1); goto err; } if (verbose) D(debug_file, ""publicKey for device number %d: %s"", i + 1, s_token); if (strlen(s_token) % 2 != 0) { if (verbose) D(debug_file, ""Length of key number %d not even"", i + 1); goto err; } devices[i].key_len = strlen(s_token) / 2; if (verbose) D(debug_file, ""Length of key number %d is %zu"", i + 1, devices[i].key_len); devices[i].publicKey = malloc((sizeof(unsigned char) * devices[i].key_len)); if (!devices[i].publicKey) { if (verbose) D(debug_file, ""Unable to allocate memory for publicKey number %d"", i); goto err; } for (j = 0; j < devices[i].key_len; j++) { unsigned int x; if (sscanf(&s_token[2 * j], ""%2x"", &x) != 1) { if (verbose) D(debug_file, ""Invalid hex number in key""); goto err; } devices[i].publicKey[j] = (unsigned char)x; } i++; } } } if (verbose) D(debug_file, ""Found %d device(s) for user %s"", *n_devs, username); retval = 1; goto out; err: for (i = 0; i < *n_devs; i++) { free(devices[i].keyHandle); free(devices[i].publicKey); devices[i].keyHandle = NULL; devices[i].publicKey = NULL; } *n_devs = 0; out: if (buf) { free(buf); buf = NULL; } if (opwfile) fclose(opwfile); else if (fd >= 0) close(fd); return retval; }"
"static void p54u_load_firmware_cb(const struct firmware *firmware, void *context) { struct p54u_priv *priv = context; struct usb_device *udev = priv->udev; int err; complete(&priv->fw_wait_load); if (firmware) { priv->fw = firmware; err = p54u_start_ops(priv); } else { err = -ENOENT; dev_err(&udev->dev, ""Firmware not found.\n""); } if (err) { struct device *parent = priv->udev->dev.parent; dev_err(&udev->dev, ""failed to initialize device (%d)\n"", err); if (parent) device_lock(parent); device_release_driver(&udev->dev); priv = NULL; if (parent) device_unlock(parent); } usb_put_dev(udev); }"
"static inline void ConvertCommonV0(void *record, common_record_t *flow_record) { common_record_v0_t *flow_record_v0 = (common_record_v0_t *)record; memcpy((void *)flow_record, record, COMMON_RECORDV0_DATA_SIZE); memcpy((void *)flow_record->data, (void *)flow_record_v0->data, flow_record_v0->size - COMMON_RECORDV0_DATA_SIZE); flow_record->type= CommonRecordType; flow_record->size+= (COMMON_RECORD_DATA_SIZE - COMMON_RECORDV0_DATA_SIZE); flow_record->flags= flow_record_v0->flags; flow_record->exporter_sysid = flow_record_v0->exporter_sysid; flow_record->reserved = 0; }"
"static int execstack2_continue(i_ctx_t *i_ctx_p) { os_ptr op = osp; return do_execstack(i_ctx_p, op->value.boolval, op - 1); }"
"static void copyMultiCh8(short *dst, const int *const *src, unsigned nSamples, unsigned nChannels) { for (unsigned i = 0; i < nSamples; ++i) { for (unsigned c = 0; c < nChannels; ++c) { *dst++ = src[c][i] << 8; } } }"
"static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr) { AVC_SPS *sps; s32 mb_width, mb_height, sps_id = -1; u32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd; u8 separate_colour_plane_flag = 0; if (!vui_flag_pos) { gf_bs_enable_emulation_byte_removal(bs, GF_TRUE); } if (!bs) { return -1; } if (!nal_hdr) { gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit""); gf_bs_read_int_log(bs, 2, ""nal_ref_idc""); gf_bs_read_int_log(bs, 5, ""nal_unit_type""); } profile_idc = gf_bs_read_int_log(bs, 8, ""profile_idc""); pcomp = gf_bs_read_int_log(bs, 8, ""profile_compatibility""); if (pcomp & 0x3) return -1; level_idc = gf_bs_read_int_log(bs, 8, ""level_idc""); sps_id = gf_bs_read_ue_log(bs, ""sps_id"") + GF_SVC_SSPS_ID_SHIFT * subseq_sps; if (sps_id >= 32) { return -1; } if (sps_id < 0) { return -1; } luma_bd = chroma_bd = 0; sps = &avc->sps[sps_id]; chroma_format_idc = sps->ChromaArrayType = 1; sps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED; switch (profile_idc) { case 100: case 110: case 122: case 244: case 44: if (pcomp & 0xE0) return -1; case 83: case 86: case 118: case 128: chroma_format_idc = gf_bs_read_ue_log(bs, ""chroma_format_idc""); sps->ChromaArrayType = chroma_format_idc; if (chroma_format_idc == 3) { separate_colour_plane_flag = gf_bs_read_int_log(bs, 1, ""separate_colour_plane_flag""); if (separate_colour_plane_flag) sps->ChromaArrayType = 0; } luma_bd = gf_bs_read_ue_log(bs, ""luma_bit_depth""); chroma_bd = gf_bs_read_ue_log(bs, ""chroma_bit_depth""); gf_bs_read_int_log(bs, 1, ""qpprime_y_zero_transform_bypass_flag""); if (gf_bs_read_int_log(bs, 1, ""seq_scaling_matrix_present_flag"")) { u32 k; for (k = 0; k < 8; k++) { if (gf_bs_read_int_log_idx(bs, 1, ""seq_scaling_list_present_flag"", k)) { u32 z, last = 8, next = 8; u32 sl = k < 6 ? 16 : 64; for (z = 0; z < sl; z++) { if (next) { s32 delta = gf_bs_read_se(bs); next = (last + delta + 256) % 256; } last = next ? next : last; } } } } break; } sps->profile_idc = profile_idc; sps->level_idc = level_idc; sps->prof_compat = pcomp; sps->log2_max_frame_num = gf_bs_read_ue_log(bs, ""log2_max_frame_num"") + 4; sps->poc_type = gf_bs_read_ue_log(bs, ""poc_type""); sps->chroma_format = chroma_format_idc; sps->luma_bit_depth_m8 = luma_bd; sps->chroma_bit_depth_m8 = chroma_bd; if (sps->poc_type == 0) { sps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, ""log2_max_poc_lsb"") + 4; } else if (sps->poc_type == 1) { sps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, ""delta_pic_order_always_zero_flag""); sps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, ""offset_for_non_ref_pic""); sps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, ""offset_for_top_to_bottom_field""); sps->poc_cycle_length = gf_bs_read_ue_log(bs, ""poc_cycle_length""); if (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\n"")); return -1; } for (i = 0; i < sps->poc_cycle_length; i++) sps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, ""offset_for_ref_frame"", i); } if (sps->poc_type > 2) { return -1; } sps->max_num_ref_frames = gf_bs_read_ue_log(bs, ""max_num_ref_frames""); sps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, ""gaps_in_frame_num_value_allowed_flag""); mb_width = gf_bs_read_ue_log(bs, ""pic_width_in_mbs_minus1"") + 1; mb_height = gf_bs_read_ue_log(bs, ""pic_height_in_map_units_minus1"") + 1; sps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, ""frame_mbs_only_flag""); sps->width = mb_width * 16; sps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16; if (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, ""mb_adaptive_frame_field_flag""); gf_bs_read_int_log(bs, 1, ""direct_8x8_inference_flag""); if (gf_bs_read_int_log(bs, 1, ""frame_cropping_flag"")) { int CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1; if (chroma_format_idc == 1) { SubWidthC = 2; SubHeightC = 2; } else if (chroma_format_idc == 2) { SubWidthC = 2; SubHeightC = 1; } else if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) { SubWidthC = 1; SubHeightC = 1; } if (sps->ChromaArrayType == 0) { assert(SubWidthC == -1); CropUnitX = 1; CropUnitY = 2 - sps->frame_mbs_only_flag; } else { CropUnitX = SubWidthC; CropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag); } cl = gf_bs_read_ue_log(bs, ""frame_crop_left_offset""); cr = gf_bs_read_ue_log(bs, ""frame_crop_right_offset""); ct = gf_bs_read_ue_log(bs, ""frame_crop_top_offset""); cb = gf_bs_read_ue_log(bs, ""frame_crop_bottom_offset""); sps->width -= CropUnitX * (cl + cr); sps->height -= CropUnitY * (ct + cb); cl *= CropUnitX; cr *= CropUnitX; ct *= CropUnitY; cb *= CropUnitY; } sps->crop.left = cl; sps->crop.right = cr; sps->crop.top = ct; sps->crop.bottom = cb; if (vui_flag_pos) { *vui_flag_pos = (u32)gf_bs_get_bit_offset(bs); } sps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_parameters_present_flag""); if (sps->vui_parameters_present_flag) { sps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, ""aspect_ratio_info_present_flag""); if (sps->vui.aspect_ratio_info_present_flag) { s32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, ""aspect_ratio_idc""); if (aspect_ratio_idc == 255) { sps->vui.par_num = gf_bs_read_int_log(bs, 16, ""aspect_ratio_num""); sps->vui.par_den = gf_bs_read_int_log(bs, 16, ""aspect_ratio_den""); } else if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) { sps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w; sps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\n"")); } } sps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, ""overscan_info_present_flag""); if (sps->vui.overscan_info_present_flag) gf_bs_read_int_log(bs, 1, ""overscan_appropriate_flag""); sps->vui.video_format = 5; sps->vui.colour_primaries = 2; sps->vui.transfer_characteristics = 2; sps->vui.matrix_coefficients = 2; sps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, ""video_signal_type_present_flag""); if (sps->vui.video_signal_type_present_flag) { sps->vui.video_format = gf_bs_read_int_log(bs, 3, ""video_format""); sps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, ""video_full_range_flag""); sps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, ""colour_description_present_flag""); if (sps->vui.colour_description_present_flag) { sps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, ""colour_primaries""); sps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, ""transfer_characteristics""); sps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, ""matrix_coefficients""); } } if (gf_bs_read_int_log(bs, 1, ""chroma_location_info_present_flag"")) { gf_bs_read_ue_log(bs, ""chroma_sample_location_type_top_field""); gf_bs_read_ue_log(bs, ""chroma_sample_location_type_bottom_field""); } sps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""timing_info_present_flag""); if (sps->vui.timing_info_present_flag) { sps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, ""num_units_in_tick""); sps->vui.time_scale = gf_bs_read_int_log(bs, 32, ""time_scale""); sps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, ""fixed_frame_rate_flag""); } sps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""nal_hrd_parameters_present_flag""); if (sps->vui.nal_hrd_parameters_present_flag) avc_parse_hrd_parameters(bs, &sps->vui.hrd); sps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vcl_hrd_parameters_present_flag""); if (sps->vui.vcl_hrd_parameters_present_flag) avc_parse_hrd_parameters(bs, &sps->vui.hrd); if (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag) sps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, ""low_delay_hrd_flag""); sps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, ""pic_struct_present_flag""); } if (subseq_sps) { if ((profile_idc == 83) || (profile_idc == 86)) { u8 extended_spatial_scalability_idc; gf_bs_read_int_log(bs, 1, ""inter_layer_deblocking_filter_control_present_flag""); extended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, ""extended_spatial_scalability_idc""); if (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) { gf_bs_read_int_log(bs, 1, ""chroma_phase_x_plus1_flag""); } if (sps->ChromaArrayType == 1) { gf_bs_read_int_log(bs, 2, ""chroma_phase_y_plus1""); } if (extended_spatial_scalability_idc == 1) { if (sps->ChromaArrayType > 0) { gf_bs_read_int_log(bs, 1, ""seq_ref_layer_chroma_phase_x_plus1_flag""); gf_bs_read_int_log(bs, 2, ""seq_ref_layer_chroma_phase_y_plus1""); } gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_left_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_top_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_right_offset""); gf_bs_read_se_log(bs, ""seq_scaled_ref_layer_bottom_offset""); } if (gf_bs_read_int_log(bs, 1, ""seq_tcoeff_level_prediction_flag"")) { gf_bs_read_int_log(bs, 1, ""adaptive_tcoeff_level_prediction_flag""); } gf_bs_read_int_log(bs, 1, ""slice_header_restriction_flag""); if (gf_bs_read_int_log(bs, 1, ""svc_vui_parameters_present"")) { u32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, ""vui_ext_num_entries_minus1""); for (i = 0; i <= vui_ext_num_entries_minus1; i++) { u8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag; gf_bs_read_int_log(bs, 3, ""vui_ext_dependency_id""); gf_bs_read_int_log(bs, 4, ""vui_ext_quality_id""); gf_bs_read_int_log(bs, 3, ""vui_ext_temporal_id""); vui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_timing_info_present_flag""); if (vui_ext_timing_info_present_flag) { gf_bs_read_int_log(bs, 32, ""vui_ext_num_units_in_tick""); gf_bs_read_int_log(bs, 32, ""vui_ext_time_scale""); gf_bs_read_int_log(bs, 1, ""vui_ext_fixed_frame_rate_flag""); } vui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_nal_hrd_parameters_present_flag""); if (vui_ext_nal_hrd_parameters_present_flag) { } vui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, ""vui_ext_vcl_hrd_parameters_present_flag""); if (vui_ext_vcl_hrd_parameters_present_flag) { } if (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) { gf_bs_read_int_log(bs, 1, ""vui_ext_low_delay_hrd_flag""); } gf_bs_read_int_log(bs, 1, ""vui_ext_pic_struct_present_flag""); } } } else if ((profile_idc == 118) || (profile_idc == 128)) { GF_LOG(GF_LOG_INFO, GF_LOG_CODING, (""[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\n"")); return sps_id; } if (gf_bs_read_int_log(bs, 1, ""additional_extension2"")) { GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\n"")); return sps_id; } } return sps_id; }"
"static int qdisc_graft(struct net_device *dev, struct Qdisc *parent, struct sk_buff *skb, struct nlmsghdr *n, u32 classid, struct Qdisc *new, struct Qdisc *old, struct netlink_ext_ack *extack) { struct Qdisc *q = old; struct net *net = dev_net(dev); if (parent == NULL) { unsigned int i, num_q, ingress; ingress = 0; num_q = dev->num_tx_queues; if ((q && q->flags & TCQ_F_INGRESS) || (new && new->flags & TCQ_F_INGRESS)) { num_q = 1; ingress = 1; if (!dev_ingress_queue(dev)) { NL_SET_ERR_MSG(extack, ""Device does not have an ingress queue""); return -ENOENT; } } if (dev->flags & IFF_UP) dev_deactivate(dev); qdisc_offload_graft_root(dev, new, old, extack); if (new && new->ops->attach && !ingress) goto skip; for (i = 0; i < num_q; i++) { struct netdev_queue *dev_queue = dev_ingress_queue(dev); if (!ingress) dev_queue = netdev_get_tx_queue(dev, i); old = dev_graft_qdisc(dev_queue, new); if (new && i > 0) qdisc_refcount_inc(new); if (!ingress) qdisc_put(old); } skip: if (!ingress) { old = rtnl_dereference(dev->qdisc); if (new && !new->ops->attach) qdisc_refcount_inc(new); rcu_assign_pointer(dev->qdisc, new ? : &noop_qdisc); notify_and_destroy(net, skb, n, classid, old, new); if (new && new->ops->attach) new->ops->attach(new); } else { notify_and_destroy(net, skb, n, classid, old, new); } if (dev->flags & IFF_UP) dev_activate(dev); } else { const struct Qdisc_class_ops *cops = parent->ops->cl_ops; unsigned long cl; int err; if (new && (new->flags & TCQ_F_NOLOCK) && !(parent->flags & TCQ_F_NOLOCK)) qdisc_clear_nolock(new); if (!cops || !cops->graft) return -EOPNOTSUPP; cl = cops->find(parent, classid); if (!cl) { NL_SET_ERR_MSG(extack, ""Specified class not found""); return -ENOENT; } err = cops->graft(parent, cl, new, &old, extack); if (err) return err; notify_and_destroy(net, skb, n, classid, old, new); } return 0; }"
"gint wimax_decode_dlmapc(tvbuff_t *tvb, packet_info *pinfo, proto_tree *base_tree) { guint offset = 0; proto_item *ti = NULL; proto_item *ti_phy = NULL; proto_item *ti_dlmap_ies = NULL; proto_tree *tree = NULL; proto_tree *ie_tree = NULL; proto_tree *phy_tree = NULL; gint ulmap_appended; guint length, lennib, pad; guint mac_len, dl_ie_count; guint tvb_len = tvb_reported_length(tvb); guint nib = 0; guint32 mac_crc, calculated_crc; col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, ""Compressed DL-MAP""); INC_CID = 0; length = tvb_get_ntohs(tvb, offset) & 0x07FF;  mac_len = length; lennib = BYTE_TO_NIB(length); ulmap_appended = (tvb_get_guint8(tvb, offset) >> 4) & 1;  ti = proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, offset, length, ""Compressed DL-MAP (%u bytes)"", length); tree = proto_item_add_subtree(ti, ett_305); proto_tree_add_item(tree, hf_dlmapc_compr, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_ulmap, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_rsv, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_len, tvb, offset, 2, ENC_BIG_ENDIAN); { phy_tree = proto_tree_add_subtree(tree, tvb, offset+2, 4, ett_275_phy, &ti_phy, ""Phy Synchronization Field""); proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_ms, tvb, offset+2, 1, ENC_BIG_ENDIAN); proto_tree_add_item(phy_tree, hf_dlmap_phy_fdur_per_sec, tvb, offset+2, 1, ENC_BIG_ENDIAN); proto_tree_add_item(phy_tree, hf_dlmap_phy_fnum, tvb, offset+3, 3, ENC_BIG_ENDIAN); } proto_tree_add_item(tree, hf_dlmap_dcd,   tvb, offset+6, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_opid, tvb, offset+7, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmapc_secid,tvb, offset+8, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_dlmap_ofdma_sym, tvb, offset+9, 1, ENC_BIG_ENDIAN);  proto_tree_add_item(tree, hf_dlmapc_count,tvb, offset+10,1, ENC_BIG_ENDIAN); dl_ie_count = tvb_get_guint8(tvb, offset + 10); offset += 11; nib = BYTE_TO_NIB(offset); length -= 15;  if (dl_ie_count) { ie_tree = proto_tree_add_subtree_format(tree, tvb, offset, length, ett_dlmap_ie, &ti_dlmap_ies, ""DL-MAP IEs (%d bytes)"", length); while (dl_ie_count--) { nib += dissect_dlmap_ie(ie_tree, pinfo, nib, tvb_len * 2, tvb); } pad = NIB_PADDING(nib); if (pad) { proto_tree_add_bytes_format(tree, hf_padding, tvb, NIBHI(nib,1), NULL, ""Padding nibble""); nib++; } } if (ulmap_appended) { proto_item_set_text(ti, ""Compressed DL-MAP (%u bytes)"", NIB_ADDR(nib)); proto_item_set_text(ti_dlmap_ies, ""DL-MAP IEs (%u bytes)"",NIB_ADDR(nib)- offset); proto_item_set_end(ti_dlmap_ies, tvb, NIB_ADDR(nib)); proto_item_set_end(ti, tvb, NIB_ADDR(nib)); col_append_sep_str(pinfo->cinfo, COL_INFO, NULL, ""Compressed UL-MAP""); wimax_decode_ulmapc(base_tree, pinfo, nib, lennib - 8, tvb); } if (mac_len <= sizeof(mac_crc)) { expert_add_info_format(pinfo, ti, &ei_mac_header_invalid_length, ""Invalid length: %d."", mac_len); } else if (MIN(tvb_len, tvb_reported_length(tvb)) >= mac_len) { calculated_crc = wimax_mac_calc_crc32(tvb_get_ptr(tvb, 0, mac_len - (int)sizeof(mac_crc)), mac_len - (int)sizeof(mac_crc)); proto_tree_add_checksum(base_tree, tvb, mac_len - (int)sizeof(mac_crc), hf_mac_header_compress_dlmap_crc, hf_mac_header_compress_dlmap_crc_status, &ei_mac_header_compress_dlmap_crc, pinfo, calculated_crc, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY); } else {    proto_tree_add_protocol_format(base_tree, proto_mac_mgmt_msg_dlmap_decoder, tvb, 0, tvb_len, ""CRC missing - the frame is too short (%u bytes)"", tvb_len); } return mac_len; }"
"static int dnxhd_find_frame_end(DNXHDParserContext *dctx, const uint8_t *buf, int buf_size) { ParseContext *pc = &dctx->pc; uint64_t state = pc->state64; int pic_found = pc->frame_start_found; int i = 0; if (!pic_found) { for (i = 0; i < buf_size; i++) { state = (state << 8) | buf[i]; if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) { i++; pic_found = 1; dctx->cur_byte = 0; dctx->remaining = 0; break; } } } if (pic_found && !dctx->remaining) { if (!buf_size)  return 0; for (; i < buf_size; i++) { dctx->cur_byte++; state = (state << 8) | buf[i]; if (dctx->cur_byte == 24) { dctx->h = (state >> 32) & 0xFFFF; } else if (dctx->cur_byte == 26) { dctx->w = (state >> 32) & 0xFFFF; } else if (dctx->cur_byte == 42) { int cid = (state >> 32) & 0xFFFFFFFF; if (cid <= 0) continue; dctx->remaining = avpriv_dnxhd_get_frame_size(cid); if (dctx->remaining <= 0) { dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h); if (dctx->remaining <= 0) return dctx->remaining; } if (buf_size - i + 47 >= dctx->remaining) { int remaining = dctx->remaining; pc->frame_start_found = 0; pc->state64 = -1; dctx->cur_byte = 0; dctx->remaining = 0; return remaining; } else { dctx->remaining -= buf_size; } } } } else if (pic_found) { if (dctx->remaining > buf_size) { dctx->remaining -= buf_size; } else { int remaining = dctx->remaining; pc->frame_start_found = 0; pc->state64 = -1; dctx->cur_byte = 0; dctx->remaining = 0; return remaining; } } pc->frame_start_found = pic_found; pc->state64 = state; return END_NOT_FOUND; }"
"static void ngx_http_v2_read_handler(ngx_event_t *rev) { u_char                    *p, *end; size_t                     available; ssize_t                    n; ngx_connection_t          *c; ngx_http_v2_main_conf_t   *h2mcf; ngx_http_v2_connection_t  *h2c; c = rev->data; h2c = c->data; if (rev->timedout) { ngx_log_error(NGX_LOG_INFO, c->log, NGX_ETIMEDOUT, ""client timed out""); ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_PROTOCOL_ERROR); return; } ngx_log_debug0(NGX_LOG_DEBUG_HTTP, c->log, 0, ""http2 read handler""); h2c->blocked = 1; if (c->close) { c->close = 0; if (c->error) { ngx_http_v2_finalize_connection(h2c, 0); return; } if (!h2c->processing && !h2c->pushing) { ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR); return; } if (!h2c->goaway) { h2c->goaway = 1; if (ngx_http_v2_send_goaway(h2c, NGX_HTTP_V2_NO_ERROR) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } if (ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } } h2c->blocked = 0; return; } h2mcf = ngx_http_get_module_main_conf(h2c->http_connection->conf_ctx, ngx_http_v2_module); available = h2mcf->recv_buffer_size - 2 * NGX_HTTP_V2_STATE_BUFFER_SIZE; do { p = h2mcf->recv_buffer; ngx_memcpy(p, h2c->state.buffer, NGX_HTTP_V2_STATE_BUFFER_SIZE); end = p + h2c->state.buffer_used; n = c->recv(c, end, available); if (n == NGX_AGAIN) { break; } if (n == 0 && (h2c->state.incomplete || h2c->processing || h2c->pushing)) { ngx_log_error(NGX_LOG_INFO, c->log, 0, ""client prematurely closed connection""); } if (n == 0 || n == NGX_ERROR) { c->error = 1; ngx_http_v2_finalize_connection(h2c, 0); return; } end += n; h2c->state.buffer_used = 0; h2c->state.incomplete = 0; do { p = h2c->state.handler(h2c, p, end); if (p == NULL) { return; } } while (p != end); h2c->total_bytes += n; if (h2c->total_bytes / 8 > h2c->payload_bytes + 1048576) { ngx_log_error(NGX_LOG_INFO, c->log, 0, ""http2 flood detected""); ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_NO_ERROR); return; } } while (rev->ready); if (ngx_handle_read_event(rev, 0) != NGX_OK) { ngx_http_v2_finalize_connection(h2c, NGX_HTTP_V2_INTERNAL_ERROR); return; } if (h2c->last_out && ngx_http_v2_send_output_queue(h2c) == NGX_ERROR) { ngx_http_v2_finalize_connection(h2c, 0); return; } h2c->blocked = 0; ngx_http_v2_handle_connection(h2c); }"
static void __dentry_kill(struct dentry *dentry) { struct dentry *parent = NULL; bool can_free = true; if (!IS_ROOT(dentry)) parent = dentry->d_parent; lockref_mark_dead(&dentry->d_lockref); if (dentry->d_flags & DCACHE_OP_PRUNE) dentry->d_op->d_prune(dentry); if (dentry->d_flags & DCACHE_LRU_LIST) { if (!(dentry->d_flags & DCACHE_SHRINK_LIST)) d_lru_del(dentry); } __d_drop(dentry); list_del(&dentry->d_child); dentry->d_flags |= DCACHE_DENTRY_KILLED; if (parent) spin_unlock(&parent->d_lock); dentry_iput(dentry); BUG_ON((int)dentry->d_lockref.count > 0); this_cpu_dec(nr_dentry); if (dentry->d_op && dentry->d_op->d_release) dentry->d_op->d_release(dentry); spin_lock(&dentry->d_lock); if (dentry->d_flags & DCACHE_SHRINK_LIST) { dentry->d_flags |= DCACHE_MAY_FREE; can_free = false; } spin_unlock(&dentry->d_lock); if (likely(can_free)) dentry_free(dentry); }
"int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2) { charcvbuf[32], _text[512]; time_titm = time(NULL); struct tmltm; localtime_r(&itm, &ltm); _text[0] = 0; if ( ltm.tm_mday < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_mday, cvbuf); strcat(_text, cvbuf); strcat(_text, ""-""); if ( ltm.tm_mon+1 < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_mon+1, cvbuf); strcat(_text, cvbuf); strcat(_text, ""-""); ultostr(ltm.tm_year+1900, cvbuf); strcat(_text, cvbuf); strcat(_text, "" ""); if ( ltm.tm_hour < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_hour, cvbuf); strcat(_text, cvbuf); strcat(_text, "":""); if ( ltm.tm_min < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_min, cvbuf); strcat(_text, cvbuf); strcat(_text, "":""); if ( ltm.tm_sec < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_sec, cvbuf); strcat(_text, cvbuf); if (context) { strcat(_text, "" S-id=""); ultostr(context->SessionID, cvbuf); strcat(_text, cvbuf); } strcat(_text, "": ""); if (logtext1) strcat(_text, logtext1); if (logtext2) strcat(_text, logtext2); strcat(_text, CRLF); return writeconsolestr(_text); }"
"static guint32 parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset, guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr, const wbxml_decoding *map) { guint32     tvb_len  = tvb_reported_length (tvb); guint32     off      = offset; guint32     len; guint       str_len; guint32     ent; guint32     idx; guint8      peek; guint32     tag_len;                      guint8      tag_save_known      = 0;      guint8      tag_new_known       = 0;      const char *tag_save_literal    = NULL;   const char *tag_new_literal;              gchar      *str; guint8      parsing_tag_content = FALSE;  if (*level == 255) { proto_tree_add_expert(tree, pinfo, &ei_wbxml_too_much_recursion, tvb, offset, tvb_captured_length_remaining(tvb, offset)); return tvb_len; } DebugLog((""parse_wbxml_tag_defined (level = %u, offset = %u)\n"", *level, offset)); while (off < tvb_len) { peek = tvb_get_guint8 (tvb, off); DebugLog((""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\n"", *level, peek, off, tvb_len)); if ((peek & 0x3F) < 4) switch (peek) {  case 0x00:  *codepage_stag = tvb_get_guint8 (tvb, off+1); proto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag, ""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |"", *codepage_stag); off += 2; break; case 0x01:  if (tag_save_known) {  proto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal, ""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>"", *level, *codepage_stag, tag_save_known, Indent (*level), tag_save_literal);  } else {  proto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : """", ""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>"", *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : """"); } (*level)--; off++; DebugLog((""STAG: level = %u, Return: len = %u\n"", *level, off - offset)); return (off - offset); case 0x02:  ent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); proto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent, ""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'"", *level, *codepage_stag, Indent (*level), ent); off += 1+len; break; case 0x03:  len = tvb_strsize (tvb, off+1); str = tvb_format_text (tvb, off+1, len-1); proto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\'%s\'"", *level, *codepage_stag, Indent(*level), str); off += 1+len; break; case 0x40:  case 0x41:  case 0x42:  len = tvb_strsize (tvb, off+1); str = tvb_format_text (tvb, off+1, len-1); proto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \'%s\')"", *level, *codepage_stag, peek & 0x0f, Indent (*level), ((map != NULL) ? map_token (map->global, 0, peek) : ""Inline string extension""), str); off += 1+len; break; case 0x43:  proto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1, ""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml"", *level, *codepage_stag, Indent (*level)); len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1, ""  %3d | Tag   | T %3d    | END (PI)                        | %s?>"", *level, *codepage_stag, Indent (*level)); break; case 0x80:  case 0x81:  case 0x82:  idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); { char *s; if (map) { if (map->ext_t[peek & 0x03]) s = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl); else s = wmem_strdup_printf(wmem_packet_scope(), ""EXT_T_%1x (%s)"", peek & 0x03, map_token (map->global, 0, peek)); } else { s = wmem_strdup_printf(wmem_packet_scope(), ""(Extension Token, integer value: %u)"", idx); } proto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s, ""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s"", *level, *codepage_stag, peek & 0x0f, Indent (*level), s); } off += 1+len; break; case 0x83:  idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); str_len = tvb_strsize (tvb, str_tbl+idx); str = tvb_format_text (tvb, str_tbl+idx, str_len-1); proto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\'%s\'"", *level, *codepage_stag, Indent (*level), str); off += 1+len; break; case 0xC0:  case 0xC1:  case 0xC2:  str = (char*)((map != NULL) ? map_token (map->global, 0, peek) : ""Single-byte extension""); proto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str, ""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)"", *level, *codepage_stag, peek & 0x0f, Indent (*level), str); off++; break; case 0xC3:  if (tvb_get_guint8 (tvb, 0)) {  if (map != NULL) { char *tmp_str; if (tag_save_known) {  if (map->opaque_binary_tag) { tmp_str = map->opaque_binary_tag(tvb, off + 1, tag_save_known, *codepage_stag, &len, pinfo); } else { tmp_str = default_opaque_binary_tag(tvb, off + 1, tag_save_known, *codepage_stag, &len, pinfo); } } else {  if (map->opaque_literal_tag) { tmp_str = map->opaque_literal_tag(tvb, off + 1, tag_save_literal, *codepage_stag, &len, pinfo); } else { tmp_str = default_opaque_literal_tag(tvb, off + 1, tag_save_literal, *codepage_stag, &len, pinfo); } } proto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL, ""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s"", *level, *codepage_stag, Indent (*level), tmp_str); off += 1 + len; } else { idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); proto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL, ""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)"", *level, *codepage_stag, Indent (*level), idx); off += 1+len+idx; } } else {  proto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1, ""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here."", *level, *codepage_stag); off = tvb_len; DebugLog((""STAG: level = %u, Return: len = %u\n"", *level, off - offset)); return (off - offset); } break; } else {  tag_len = 0; if ((peek & 0x3F) == 4) {  DebugLog((""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\n"", peek, off)); idx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar); str_len = tvb_strsize (tvb, str_tbl+idx); tag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len); tag_new_known = 0;  } else {  tag_new_known = peek & 0x3F; if (map != NULL) { tag_new_literal = map_token (map->tags, *codepage_stag, tag_new_known); } else { tag_new_literal = wmem_strdup_printf(wmem_packet_scope(), ""Tag_0x%02X"", tag_new_known); } } if (peek & 0x40) {  if (parsing_tag_content) {  DebugLog((""STAG: Tag in Tag - RECURSE! (off = %u)\n"", off)); (*level)++; len = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl, level, codepage_stag, codepage_attr, map); off += len; } else {  if ((peek & 0x3F) == 4) {  tag_save_literal = tag_new_literal; tag_save_known = 0; } else {  tag_save_known = tag_new_known; tag_save_literal = tag_new_literal; } if (peek & 0x80) {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1, ""  %3d | Tag   | T %3d    | END (attribute list)            | %s>"", *level, *codepage_stag, Indent (*level)); } else {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } } parsing_tag_content = TRUE; DebugLog((""Tag in Tag - No recursion this time! (off = %u)\n"", off)); } } else {  DebugLog((""<Tag/> in Tag - No recursion! (off = %u)\n"", off)); (*level)++; if (peek & 0x80) {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off > tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag, ""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>"", *level, *codepage_stag, Indent (*level)); } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, """", ""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>"", *level, *codepage_stag, Indent (*level)); } } else {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } } (*level)--; } }  }  DebugLog((""STAG: level = %u, Return: len = %u (end of function body)\n"", *level, off - offset)); return (off - offset); }"
"void writeStats(Array& ) override { fprintf(stderr, ""writeStats start\n""); fprintf(stderr, ""Count Function MinSerLen MaxSerLen RetSame HasThis "" ""AllSame MemberCount\n""); for (auto& me : m_memos) { if (me.second.m_ignore) continue; if (me.second.m_count == 1) continue; int min_ser_len = 999999999; int max_ser_len = 0; int count = 0; int member_count = 0; bool all_same = true; if (me.second.m_has_this) { bool any_multiple = false; auto& fr = me.second.m_member_memos.begin()->second.m_return_value; member_count = me.second.m_member_memos.size(); for (auto& mme : me.second.m_member_memos) { if (mme.second.m_return_value != fr) all_same = false; count += mme.second.m_count; auto ser_len = mme.second.m_return_value.length(); min_ser_len = std::min(min_ser_len, ser_len); max_ser_len = std::max(max_ser_len, ser_len); if (mme.second.m_count > 1) any_multiple = true; } if (!any_multiple && !all_same) continue; } else { min_ser_len = max_ser_len = me.second.m_return_value.length(); count = me.second.m_count; all_same = me.second.m_ret_tv_same; } fprintf(stderr, ""%d %s %d %d %s %s %s %d\n"", count, me.first.data(), min_ser_len, max_ser_len, me.second.m_ret_tv_same ? "" true"" : ""false"", me.second.m_has_this ? "" true"" : ""false"", all_same ? "" true"" : ""false"", member_count ); } fprintf(stderr, ""writeStats end\n""); }"
void init_env(CephContext *cct) override { env.init(cct); }
"bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path) { barrier::FingerprintData fingerprint_sha1, fingerprint_sha256; try { auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl); fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert, barrier::FingerprintType::SHA1); fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert, barrier::FingerprintType::SHA256); } catch (const std::exception& e) { LOG((CLOG_ERR ""%s"", e.what())); return false; } LOG((CLOG_NOTE ""server fingerprint (SHA1): %s (SHA256): %s"", barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(), barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str())); LOG((CLOG_NOTE ""fingerprint_db_path: %s"", fingerprint_db_path.u8string().c_str())); barrier::FingerprintDatabase db; db.read(fingerprint_db_path); if (!db.fingerprints().empty()) { LOG((CLOG_NOTE ""Read %d fingerprints from: %s"", db.fingerprints().size(), fingerprint_db_path.u8string().c_str())); } else { LOG((CLOG_NOTE ""Could not read fingerprints from: %s"", fingerprint_db_path.u8string().c_str())); } if (db.is_trusted(fingerprint_sha256)) { LOG((CLOG_NOTE ""Fingerprint matches trusted fingerprint"")); return true; } else { LOG((CLOG_NOTE ""Fingerprint does not match trusted fingerprint"")); return false; } }"
"void sqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type) { ST *tree = *ptree; int is_id; int cr_forced_static = 0; sc->sc_no_remote = 1; if (IS_UNION_ST (tree)) { tree = sqlp_view_def (NULL, tree, 1); tree = sqlc_union_dt_wrap (tree); *ptree = tree; } sqlc_top_select_wrap_dt (sc, tree); sql_stmt_comp (sc, ptree); tree = *ptree; if (sc->sc_so) is_id = sqlo_cr_is_identifiable (sc->sc_so, tree); else is_id = sqlc_cr_is_identifiable (sc, tree); if (!is_id) cr_forced_static = 1; { NEW_VARZ (query_cursor_t, qc); if (sc->sc_cc->cc_query->qr_cursor) { qc_free (sc->sc_cc->cc_query->qr_cursor); fprintf (stderr, ""Freeing qc in sqlc_cursor\n""); } sc->sc_cc->cc_query->qr_cursor = qc; sc->sc_cc->cc_query->qr_cursor_type = cr_type; if (sc->sc_so) { if (!cr_forced_static && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree)) cr_forced_static = 1; } else { if (!cr_forced_static && -1 == qc_make_cols (sc, qc, tree)) cr_forced_static = 1; } if (!cr_forced_static) { qc->qc_cursor_type = cr_type; if (sc->sc_so) sqlo_qc_make_stmts (sc->sc_so, qc); else qc_make_stmts (sc, qc); } else { qc_make_static (sc, qc, ptree); tree = *ptree; } } }"
"static VALUE rb_xml_reader_attribute_hash(VALUE rb_reader) { VALUE rb_attributes = rb_hash_new(); xmlTextReaderPtr c_reader; xmlNodePtr c_node; xmlAttrPtr c_property; Data_Get_Struct(rb_reader, xmlTextReader, c_reader); if (!has_attributes(c_reader)) { return rb_attributes; } c_node = xmlTextReaderExpand(c_reader); c_property = c_node->properties; while (c_property != NULL) { VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name); VALUE rb_value = Qnil; xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property); if (c_value) { rb_value = NOKOGIRI_STR_NEW2(c_value); xmlFree(c_value); } rb_hash_aset(rb_attributes, rb_name, rb_value); c_property = c_property->next; } return rb_attributes; }"
"ST * sqlc_table_from_select_view (query_t * view_qr, ST * view_def) { int inx; state_slot_t **sel_out = view_qr->qr_select_node->sel_out_slots; int n_out = BOX_ELEMENTS (sqlp_union_tree_select (view_def->_.view_def.exp)->_.select_stmt.selection); dk_set_t cols = NULL; dk_set_t key_parts = NULL; DO_BOX (state_slot_t *, ssl, inx, sel_out) { dtp_t sl_dtp; uint32 sl_prec; char sl_scale; int col_is_indexable; if (inx >= n_out) break; if (SSL_REF == ssl->ssl_type) ssl = ((state_slot_ref_t*)ssl)->sslr_ssl; sl_dtp = ssl->ssl_dtp; sl_prec = ssl->ssl_prec; sl_scale = ssl->ssl_scale; if (!sl_dtp || !dtp_is_column_compatible (sl_dtp)) { sl_dtp = DV_LONG_STRING; sl_prec = 0; sl_scale = 0; } col_is_indexable = !( (DV_BLOB == sl_dtp) || (DV_BLOB_WIDE == sl_dtp) || (DV_BLOB_BIN == sl_dtp) || (DV_BLOB_XPER == sl_dtp) ); t_dk_set_append_1 (&cols, (void *) t_box_string (ssl->ssl_name)); t_dk_set_append_1 (&cols, t_list (2, t_list (3, t_box_num (sl_dtp), t_box_num (sl_prec), t_box_num (sl_scale)), NULL)); if (col_is_indexable) t_dk_set_append_1 (&key_parts, (void *) t_box_string (ssl->ssl_name)); } END_DO_BOX; t_dk_set_append_1 (&cols, NULL); t_dk_set_append_1 (&cols, t_list (5, INDEX_DEF, NULL, NULL, t_list_to_array (key_parts), NULL)); return ((ST *) t_list (3, TABLE_DEF, t_box_string (view_def->_.view_def.name), t_list_to_array (cols))); }"
"static long evtchn_bind_pirq(evtchn_bind_pirq_t *bind) { struct evtchn *chn; struct domain *d = current->domain; struct vcpu   *v = d->vcpu[0]; struct pirq   *info; int            port = 0, pirq = bind->pirq; long           rc; if ( (pirq < 0) || (pirq >= d->nr_pirqs) ) return -EINVAL; if ( !is_hvm_domain(d) && !pirq_access_permitted(d, pirq) ) return -EPERM; spin_lock(&d->event_lock); if ( pirq_to_evtchn(d, pirq) != 0 ) ERROR_EXIT(-EEXIST); if ( (port = get_free_port(d)) < 0 ) ERROR_EXIT(port); chn = evtchn_from_port(d, port); info = pirq_get_info(d, pirq); if ( !info ) ERROR_EXIT(-ENOMEM); info->evtchn = port; rc = (!is_hvm_domain(d) ? pirq_guest_bind(v, info, !!(bind->flags & BIND_PIRQ__WILL_SHARE)) : 0); if ( rc != 0 ) { info->evtchn = 0; pirq_cleanup_check(info, d); goto out; } spin_lock(&chn->lock); chn->state  = ECS_PIRQ; chn->u.pirq.irq = pirq; link_pirq_port(port, chn, v); evtchn_port_init(d, chn); spin_unlock(&chn->lock); bind->port = port; arch_evtchn_bind_pirq(d, pirq); out: check_free_port(d, port); spin_unlock(&d->event_lock); return rc; }"
"void FolderMan::editFileLocally(const QString &accountDisplayName, const QString &relPath) { const auto showError = [this](const OCC::AccountStatePtr accountState, const QString &errorMessage, const QString &subject) { if (accountState && accountState->account()) { const auto foundFolder = std::find_if(std::cbegin(map()), std::cend(map()), [accountState](const auto &folder) { return accountState->account()->davUrl() == folder->remoteUrl(); }); if (foundFolder != std::cend(map())) { (*foundFolder)->syncEngine().addErrorToGui(SyncFileItem::SoftError, errorMessage, subject); } } const auto messageBox = new QMessageBox; messageBox->setAttribute(Qt::WA_DeleteOnClose); messageBox->setText(errorMessage); messageBox->setInformativeText(subject); messageBox->setIcon(QMessageBox::Warning); messageBox->addButton(QMessageBox::StandardButton::Ok); messageBox->show(); messageBox->activateWindow(); messageBox->raise(); }; const auto accountFound = AccountManager::instance()->account(accountDisplayName); if (!accountFound) { qCWarning(lcFolderMan) << ""Could not find an account "" << accountDisplayName << "" to edit file "" << relPath << "" locally.""; showError(accountFound, tr(""Could not find an account for local editing""), accountDisplayName); return; } const auto foundFiles = findFileInLocalFolders(relPath, accountFound->account()); if (foundFiles.isEmpty()) { for (const auto &folder : map()) { bool result = false; const auto excludedThroughSelectiveSync = folder->journalDb()->getSelectiveSyncList(SyncJournalDb::SelectiveSyncBlackList, &result); for (const auto &excludedPath : excludedThroughSelectiveSync) { if (relPath.startsWith(excludedPath)) { showError(accountFound, tr(""Could not find a file for local editing. Make sure it is not excluded via selective sync.""), relPath); return; } } } showError(accountFound, tr(""Could not find a file for local editing. Make sure its path is valid and it is synced locally.""), relPath); return; } const auto localFilePath = foundFiles.first(); const auto folderForFile = folderForPath(localFilePath); if (!folderForFile) { showError(accountFound, tr(""Could not find a folder to sync.""), relPath); return; } const auto relPathSplit = relPath.split(QLatin1Char('/')); if (relPathSplit.size() > 0) { Systray::instance()->createEditFileLocallyLoadingDialog(relPathSplit.last()); } else { showError(accountFound, tr(""Could not find a file for local editing. Make sure its path is valid and it is synced locally.""), relPath); return; } folderForFile->startSync(); _localFileEditingSyncFinishedConnections.insert(localFilePath, QObject::connect(folderForFile, &Folder::syncFinished, this, [this, localFilePath](const OCC::SyncResult &result) { Q_UNUSED(result); const auto foundConnectionIt = _localFileEditingSyncFinishedConnections.find(localFilePath); if (foundConnectionIt != std::end(_localFileEditingSyncFinishedConnections) && foundConnectionIt.value()) { QObject::disconnect(foundConnectionIt.value()); _localFileEditingSyncFinishedConnections.erase(foundConnectionIt); } QtConcurrent::run([localFilePath]() { QDesktopServices::openUrl(QUrl::fromLocalFile(localFilePath)); Systray::instance()->destroyEditFileLocallyLoadingDialog(); }); })); }"
"static void __inet_del_ifa(struct in_device *in_dev, struct in_ifaddr **ifap, int destroy, struct nlmsghdr *nlh, u32 portid) { struct in_ifaddr *promote = NULL; struct in_ifaddr *ifa, *ifa1 = *ifap; struct in_ifaddr *last_prim = in_dev->ifa_list; struct in_ifaddr *prev_prom = NULL; int do_promote = IN_DEV_PROMOTE_SECONDARIES(in_dev); ASSERT_RTNL(); if (!(ifa1->ifa_flags & IFA_F_SECONDARY)) { struct in_ifaddr **ifap1 = &ifa1->ifa_next; while ((ifa = *ifap1) != NULL) { if (!(ifa->ifa_flags & IFA_F_SECONDARY) && ifa1->ifa_scope <= ifa->ifa_scope) last_prim = ifa; if (!(ifa->ifa_flags & IFA_F_SECONDARY) || ifa1->ifa_mask != ifa->ifa_mask || !inet_ifa_match(ifa1->ifa_address, ifa)) { ifap1 = &ifa->ifa_next; prev_prom = ifa; continue; } if (!do_promote) { inet_hash_remove(ifa); *ifap1 = ifa->ifa_next; rtmsg_ifa(RTM_DELADDR, ifa, nlh, portid); blocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa); inet_free_ifa(ifa); } else { promote = ifa; break; } } } for (ifa = promote; ifa; ifa = ifa->ifa_next) { if (ifa1->ifa_mask == ifa->ifa_mask && inet_ifa_match(ifa1->ifa_address, ifa)) fib_del_ifaddr(ifa, ifa1); } *ifap = ifa1->ifa_next; inet_hash_remove(ifa1); rtmsg_ifa(RTM_DELADDR, ifa1, nlh, portid); blocking_notifier_call_chain(&inetaddr_chain, NETDEV_DOWN, ifa1); if (promote) { struct in_ifaddr *next_sec = promote->ifa_next; if (prev_prom) { prev_prom->ifa_next = promote->ifa_next; promote->ifa_next = last_prim->ifa_next; last_prim->ifa_next = promote; } promote->ifa_flags &= ~IFA_F_SECONDARY; rtmsg_ifa(RTM_NEWADDR, promote, nlh, portid); blocking_notifier_call_chain(&inetaddr_chain, NETDEV_UP, promote); for (ifa = next_sec; ifa; ifa = ifa->ifa_next) { if (ifa1->ifa_mask != ifa->ifa_mask || !inet_ifa_match(ifa1->ifa_address, ifa)) continue; fib_add_ifaddr(ifa); } } if (destroy) inet_free_ifa(ifa1); }"
"OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) { if (buffer == 0) { return NULL; } Mutex::Autolock autoLock(mBufferIDLock); ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer); if (index < 0) { CLOGW(""findBufferHeader: buffer %u not found"", buffer); return NULL; } return mBufferIDToBufferHeader.valueAt(index); }"
"static int dissect_kafka_message_old(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset, int end_offset _U_) { proto_item  *message_ti; proto_tree  *subtree; tvbuff_t    *decompressed_tvb; int         decompressed_offset; int         start_offset = offset; int         bytes_offset; gint8       magic_byte; guint8      codec; guint32     message_size; guint32     length; message_size = tvb_get_guint32(tvb, start_offset + 8, ENC_BIG_ENDIAN); subtree = proto_tree_add_subtree(tree, tvb, start_offset, message_size + 12, ett_kafka_message, &message_ti, ""Message""); offset = dissect_kafka_int64(subtree, hf_kafka_offset, tvb, pinfo, offset, NULL); offset = dissect_kafka_int32(subtree, hf_kafka_message_size, tvb, pinfo, offset, NULL); offset = dissect_kafka_int32(subtree, hf_kafka_message_crc, tvb, pinfo, offset, NULL); offset = dissect_kafka_int8(subtree, hf_kafka_message_magic, tvb, pinfo, offset, &magic_byte); offset = dissect_kafka_int8(subtree, hf_kafka_message_codec, tvb, pinfo, offset, &codec); codec &= KAFKA_MESSAGE_CODEC_MASK; offset = dissect_kafka_int8(subtree, hf_kafka_message_timestamp_type, tvb, pinfo, offset, NULL); if (magic_byte == 1) { proto_tree_add_item(subtree, hf_kafka_message_timestamp, tvb, offset, 8, ENC_TIME_MSECS|ENC_BIG_ENDIAN); offset += 8; } bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_key, tvb, pinfo, offset, NULL, NULL); if (bytes_offset > offset) { offset = bytes_offset; } else { expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length); return offset; } if (codec == 0) { bytes_offset = dissect_kafka_regular_bytes(subtree, hf_kafka_message_value, tvb, pinfo, offset, NULL, &length); if (bytes_offset > offset) { offset = bytes_offset; } else { expert_add_info(pinfo, message_ti, &ei_kafka_bad_bytes_length); return offset; } } else { length = tvb_get_ntohl(tvb, offset); offset += 4; if (decompress(tvb, pinfo, offset, length, codec, &decompressed_tvb, &decompressed_offset)==1) { add_new_data_source(pinfo, decompressed_tvb, ""Decompressed content""); show_compression_reduction(tvb, subtree, length, tvb_captured_length(decompressed_tvb)); dissect_kafka_message_set(decompressed_tvb, pinfo, subtree, decompressed_offset, tvb_reported_length_remaining(decompressed_tvb, decompressed_offset), codec); } else { proto_item_append_text(subtree, "" [Cannot decompress records]""); } offset += length; } proto_item_set_end(message_ti, tvb, offset); return offset; }"
"int ff_mms_asf_header_parser(MMSContext *mms) { uint8_t *p = mms->asf_header; uint8_t *end; int flags, stream_id; mms->stream_num = 0; if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 || memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (invalid ASF header, size=%d)\n"", mms->asf_header_size); return AVERROR_INVALIDDATA; } end = mms->asf_header + mms->asf_header_size; p += sizeof(ff_asf_guid) + 14; while(end - p >= sizeof(ff_asf_guid) + 8) { uint64_t chunksize; if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) { chunksize = 50;         } else { chunksize = AV_RL64(p + sizeof(ff_asf_guid)); } if (!chunksize || chunksize > end - p) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"", chunksize); return AVERROR_INVALIDDATA; } if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) { if (end - p > sizeof(ff_asf_guid) * 2 + 68) { mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64); if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (too large pkt_len %d)\n"", mms->asf_packet_len); return AVERROR_INVALIDDATA; } } } else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) { flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24); stream_id = flags & 0x7F; if (mms->stream_num < MMS_MAX_STREAMS && 46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) { mms->streams = av_fast_realloc(mms->streams, &mms->nb_streams_allocated, (mms->stream_num + 1) * sizeof(MMSStream)); if (!mms->streams) return AVERROR(ENOMEM); mms->streams[mms->stream_num].id = stream_id; mms->stream_num++; } else { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (too many A/V streams)\n""); return AVERROR_INVALIDDATA; } } else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) { if (end - p >= 88) { int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86); uint64_t skip_bytes = 88; while (stream_count--) { if (end - p < skip_bytes + 4) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (next stream name length is not in the buffer)\n""); return AVERROR_INVALIDDATA; } skip_bytes += 4 + AV_RL16(p + skip_bytes + 2); } while (ext_len_count--) { if (end - p < skip_bytes + 22) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (next extension system info length is not in the buffer)\n""); return AVERROR_INVALIDDATA; } skip_bytes += 22 + AV_RL32(p + skip_bytes + 18); } if (end - p < skip_bytes) { av_log(NULL, AV_LOG_ERROR, ""Corrupt stream (the last extension system info length is invalid)\n""); return AVERROR_INVALIDDATA; } if (chunksize - skip_bytes > 24) chunksize = skip_bytes; } } else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) { chunksize = 46;         } p += chunksize; } return 0; }"
"int gs_main_finit(gs_main_instance * minst, int exit_status, int code) { i_ctx_t *i_ctx_p = minst->i_ctx_p; gs_dual_memory_t dmem = {0}; int exit_code; ref error_object; char *tempnames; tempnames = gs_main_tempnames(minst); gs_finit_push_systemdict(i_ctx_p); if (minst->init_done >= 2) { gs_main_run_string(minst, ""/BGPrint /GetDeviceParam .special_op \ {{ <</BeginPage {pop} /EndPage {pop pop               /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \ serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \ .systemvar exec"", 0 , &exit_code, &error_object); } if (minst->init_done >= 2) { int code = 0; if (idmemory->reclaim != 0) { code = interp_reclaim(&minst->i_ctx_p, avm_global); if (code < 0) { ref error_name; if (tempnames) free(tempnames); if (gs_errorname(i_ctx_p, code, &error_name) >= 0) { char err_str[32] = {0}; name_string_ref(imemory, &error_name, &error_name); memcpy(err_str, error_name.value.const_bytes, r_size(&error_name)); emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code); } else { emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code); } #ifdef MEMENTO_SQUEEZE_BUILD if (code != gs_error_VMerror ) return gs_error_Fatal; #else return gs_error_Fatal; #endif } i_ctx_p = minst->i_ctx_p;  } if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) { gx_device *pdev = i_ctx_p->pgs->device; const char * dname = pdev->dname; rc_adjust(pdev, 1, ""gs_main_finit""); gs_main_run_string(minst, "".uninstallpagedevice serverdict \ /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec"", 0 , &exit_code, &error_object); code = gs_closedevice(pdev); if (code < 0) { ref error_name; if (gs_errorname(i_ctx_p, code, &error_name) >= 0) { char err_str[32] = {0}; name_string_ref(imemory, &error_name, &error_name); memcpy(err_str, error_name.value.const_bytes, r_size(&error_name)); emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname); } else { emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname); } } rc_decrement(pdev, ""gs_main_finit"");                 if (exit_status == 0 || exit_status == gs_error_Quit) exit_status = code; } gs_main_run_string(minst, ""(%stdout) (w) file closefile (%stderr) (w) file closefile \ serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \ systemdict /savedinitialgstate .forceundef"", 0 , &exit_code, &error_object); } gp_readline_finit(minst->readline_data); i_ctx_p = minst->i_ctx_p; if (gs_debug_c(':')) { print_resource_usage(minst, &gs_imemory, ""Final""); dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst); } if (minst->init_done >= 1) { gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory; i_plugin_holder *h = i_ctx_p->plugin_list; dmem = *idmemory; code = alloc_restore_all(i_ctx_p); if (code < 0) emprintf1(mem_raw, ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"", code); i_iodev_finit(&dmem); i_plugin_finit(mem_raw, h); } if (minst->heap->gs_lib_ctx->fstdout2 && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout) && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) { fclose(minst->heap->gs_lib_ctx->fstdout2); minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL; } minst->heap->gs_lib_ctx->stdout_is_redirected = 0; minst->heap->gs_lib_ctx->stdout_to_stderr = 0; if (tempnames) { char *p = tempnames; while (*p) { unlink(p); p += strlen(p) + 1; } free(tempnames); } gs_lib_finit(exit_status, code, minst->heap); gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array""); ialloc_finit(&dmem); return exit_status; }"
"static BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize) { UINT32 left = originalSize; while (left > 4) { const BYTE value = *in++; UINT32 len = 0; if (left == 5) { if (outSize < 1) return FALSE; outSize--; *out++ = value; left--; } else if (value == *in) { in++; if (*in < 0xFF) { len = (UINT32)*in++; len += 2; } else { in++; len = ((UINT32)(*in++)); len |= ((UINT32)(*in++)) << 8U; len |= ((UINT32)(*in++)) << 16U; len |= ((UINT32)(*in++)) << 24U; } if (outSize < len) return FALSE; outSize -= len; FillMemory(out, len, value); out += len; left -= len; } else { if (outSize < 1) return FALSE; outSize--; *out++ = value; left--; } } if ((outSize < 4) || (left < 4)) return FALSE; memcpy(out, in, 4); return TRUE; }"
"RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { if (!bin->entry_table) { return NULL; } RList *entries = r_list_newf (free); if (!entries) { return NULL; } RList *segments = r_bin_ne_get_segments (bin); if (!segments) { r_list_free (entries); return NULL; } if (bin->ne_header->csEntryPoint) { RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } entry->bits = 16; ut32 entry_cs = bin->ne_header->csEntryPoint; RBinSection *s = r_list_get_n (segments, entry_cs - 1); entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0); r_list_append (entries, entry); } int off = 0; size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; while (off < bin->ne_header->EntryTableLength) { if (tableat + off >= r_buf_size (bin->buf)) { break; } ut8 bundle_length = *(ut8 *)(bin->entry_table + off); if (!bundle_length) { break; } off++; ut8 bundle_type = *(ut8 *)(bin->entry_table + off); off++; int i; for (i = 0; i < bundle_length; i++) { if (tableat + off + 4 >= r_buf_size (bin->buf)) { break; } RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } off++; if (!bundle_type) { off--; free (entry); break; } else if (bundle_type == 0xff) { off += 2; ut8 segnum = *(bin->entry_table + off); off++; ut16 segoff = *(ut16 *)(bin->entry_table + off); if (segnum > 0) { entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; } } else { if (bundle_type < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off); } } off += 2; r_list_append (entries, entry); } } r_list_free (segments); bin->entries = entries; return entries; }"
"static int Hmac_UpdateFinal_CT(Hmac* hmac, byte* digest, const byte* in, word32 sz, byte* header) { byte lenBytes[8]; int  i, j, k; int  blockBits, blockMask; int  realLen, lastBlockLen, macLen, extraLen, eocIndex; int  blocks, safeBlocks, lenBlock, eocBlock; int  maxLen; int  blockSz, padSz; int  ret; byte extraBlock; switch (hmac->macType) { #ifndef NO_SHA case WC_SHA: blockSz = WC_SHA_BLOCK_SIZE; blockBits = 6; macLen = WC_SHA_DIGEST_SIZE; padSz = WC_SHA_BLOCK_SIZE - WC_SHA_PAD_SIZE + 1; break; #endif  #ifndef NO_SHA256 case WC_SHA256: blockSz = WC_SHA256_BLOCK_SIZE; blockBits = 6; macLen = WC_SHA256_DIGEST_SIZE; padSz = WC_SHA256_BLOCK_SIZE - WC_SHA256_PAD_SIZE + 1; break; #endif  #ifdef WOLFSSL_SHA384 case WC_SHA384: blockSz = WC_SHA384_BLOCK_SIZE; blockBits = 7; macLen = WC_SHA384_DIGEST_SIZE; padSz = WC_SHA384_BLOCK_SIZE - WC_SHA384_PAD_SIZE + 1; break; #endif  #ifdef WOLFSSL_SHA512 case WC_SHA512: blockSz = WC_SHA512_BLOCK_SIZE; blockBits = 7; macLen = WC_SHA512_DIGEST_SIZE; padSz = WC_SHA512_BLOCK_SIZE - WC_SHA512_PAD_SIZE + 1; break; #endif  default: return BAD_FUNC_ARG; } blockMask = blockSz - 1; maxLen = WOLFSSL_TLS_HMAC_INNER_SZ + sz - 1 - macLen; extraBlock = ctSetLTE((maxLen + padSz) & blockMask, padSz); blocks = ((maxLen + blockSz - 1) >> blockBits) + extraBlock; safeBlocks = blocks - 6; realLen = maxLen - in[sz - 1]; lastBlockLen = realLen & blockMask; extraLen = ((blockSz * 2 - padSz - lastBlockLen) & blockMask) + 1; lenBlock = (realLen + extraLen) >> blockBits; eocBlock = realLen >> blockBits; eocIndex = realLen & blockMask; realLen += blockSz; c32toa(realLen >> ((sizeof(word32) * 8) - 3), lenBytes); c32toa(realLen << 3, lenBytes + sizeof(word32)); ret = Hmac_HashUpdate(hmac, (unsigned char*)hmac->ipad, blockSz); if (ret != 0) return ret; XMEMSET(hmac->innerHash, 0, macLen); if (safeBlocks > 0) { ret = Hmac_HashUpdate(hmac, header, WOLFSSL_TLS_HMAC_INNER_SZ); if (ret != 0) return ret; ret = Hmac_HashUpdate(hmac, in, safeBlocks * blockSz - WOLFSSL_TLS_HMAC_INNER_SZ); if (ret != 0) return ret; } else safeBlocks = 0; XMEMSET(digest, 0, macLen); k = safeBlocks * blockSz; for (i = safeBlocks; i < blocks; i++) { unsigned char hashBlock[WC_MAX_BLOCK_SIZE]; unsigned char isEocBlock = ctMaskEq(i, eocBlock); unsigned char isOutBlock = ctMaskEq(i, lenBlock); for (j = 0; j < blockSz; j++, k++) { unsigned char atEoc = ctMaskEq(j, eocIndex) & isEocBlock; unsigned char pastEoc = ctMaskGT(j, eocIndex) & isEocBlock; unsigned char b = 0; if (k < WOLFSSL_TLS_HMAC_INNER_SZ) b = header[k]; else if (k < maxLen) b = in[k - WOLFSSL_TLS_HMAC_INNER_SZ]; b = ctMaskSel(atEoc, b, 0x80); b &= (unsigned char)~(word32)pastEoc; b &= ((unsigned char)~(word32)isOutBlock) | isEocBlock; if (j >= blockSz - 8) { b = ctMaskSel(isOutBlock, b, lenBytes[j - (blockSz - 8)]); } hashBlock[j] = b; } ret = Hmac_HashUpdate(hmac, hashBlock, blockSz); if (ret != 0) return ret; ret = Hmac_HashFinalRaw(hmac, hashBlock); if (ret != 0) return ret; for (j = 0; j < macLen; j++) ((unsigned char*)hmac->innerHash)[j] |= hashBlock[j] & isOutBlock; } ret = Hmac_OuterHash(hmac, digest); return ret; }"
"static void usb_ohci_init(OHCIState *ohci, DeviceState *dev, int num_ports, dma_addr_t localmem_base, char *masterbus, uint32_t firstport, AddressSpace *as, Error **errp) { Error *err = NULL; int i; ohci->as = as; if (usb_frame_time == 0) { #ifdef OHCI_TIME_WARP usb_frame_time = get_ticks_per_sec(); usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ/1000); #else usb_frame_time = muldiv64(1, get_ticks_per_sec(), 1000); if (get_ticks_per_sec() >= USB_HZ) { usb_bit_time = muldiv64(1, get_ticks_per_sec(), USB_HZ); } else { usb_bit_time = 1; } #endif trace_usb_ohci_init_time(usb_frame_time, usb_bit_time); } ohci->num_ports = num_ports; if (masterbus) { USBPort *ports[OHCI_MAX_PORTS]; for(i = 0; i < num_ports; i++) { ports[i] = &ohci->rhport[i].port; } usb_register_companion(masterbus, ports, num_ports, firstport, ohci, &ohci_port_ops, USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL, &err); if (err) { error_propagate(errp, err); return; } } else { usb_bus_new(&ohci->bus, sizeof(ohci->bus), &ohci_bus_ops, dev); for (i = 0; i < num_ports; i++) { usb_register_port(&ohci->bus, &ohci->rhport[i].port, ohci, i, &ohci_port_ops, USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL); } } memory_region_init_io(&ohci->mem, OBJECT(dev), &ohci_mem_ops, ohci, ""ohci"", 256); ohci->localmem_base = localmem_base; ohci->name = object_get_typename(OBJECT(dev)); usb_packet_init(&ohci->usb_packet); ohci->async_td = 0; }"
"static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception) { Image *image; MagickBooleanType status; MagickSizeType number_pixels; MemoryInfo *pixel_info; register Quantum *q; register ssize_t i, x; register unsigned char *p; SGIInfo iris_info; size_t bytes_per_pixel, quantum; ssize_t count, y, z; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } iris_info.magic=ReadBlobMSBShort(image); do { if (iris_info.magic != 0x01DA) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.storage=(unsigned char) ReadBlobByte(image); switch (iris_info.storage) { case 0x00: image->compression=NoCompression; break; case 0x01: image->compression=RLECompression; break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image); if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.dimension=ReadBlobMSBShort(image); iris_info.columns=ReadBlobMSBShort(image); iris_info.rows=ReadBlobMSBShort(image); iris_info.depth=ReadBlobMSBShort(image); if ((iris_info.depth == 0) || (iris_info.depth > 4)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.minimum_value=ReadBlobMSBLong(image); iris_info.maximum_value=ReadBlobMSBLong(image); iris_info.sans=ReadBlobMSBLong(image); (void) ReadBlob(image,sizeof(iris_info.name),(unsigned char *) iris_info.name); iris_info.name[sizeof(iris_info.name)-1]='\0'; if (*iris_info.name != '\0') (void) SetImageProperty(image,""label"",iris_info.name,exception); iris_info.pixel_format=ReadBlobMSBLong(image); if (iris_info.pixel_format != 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler); (void) count; image->columns=iris_info.columns; image->rows=iris_info.rows; image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH); if (iris_info.pixel_format == 0) image->depth=(size_t) MagickMin((size_t) 8* iris_info.bytes_per_pixel,MAGICKCORE_QUANTUM_DEPTH); if (iris_info.depth < 3) { image->storage_class=PseudoClass; image->colors=iris_info.bytes_per_pixel > 1 ? 65535 : 256; } if ((image_info->ping != MagickFalse)  && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); bytes_per_pixel=(size_t) iris_info.bytes_per_pixel; number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows; if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t) (4*bytes_per_pixel*number_pixels))) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4* bytes_per_pixel*sizeof(*pixels)); if (pixel_info == (MemoryInfo *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info); if ((int) iris_info.storage != 0x01) { unsigned char *scanline; scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns, bytes_per_pixel*sizeof(*scanline)); if (scanline == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (z=0; z < (ssize_t) iris_info.depth; z++) { p=pixels+bytes_per_pixel*z; for (y=0; y < (ssize_t) iris_info.rows; y++) { count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline); if (EOFBlob(image) != MagickFalse) break; if (bytes_per_pixel == 2) for (x=0; x < (ssize_t) iris_info.columns; x++) { *p=scanline[2*x]; *(p+1)=scanline[2*x+1]; p+=8; } else for (x=0; x < (ssize_t) iris_info.columns; x++) { *p=scanline[x]; p+=4; } } } scanline=(unsigned char *) RelinquishMagickMemory(scanline); } else { MemoryInfo *packet_info; size_t *runlength; ssize_t offset, *offsets; unsigned char *packets; unsigned int data_order; offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows, iris_info.depth*sizeof(*offsets)); runlength=(size_t *) AcquireQuantumMemory(iris_info.rows, iris_info.depth*sizeof(*runlength)); packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL* sizeof(*packets)); if ((offsets == (ssize_t *) NULL) || (runlength == (size_t *) NULL) || (packet_info == (MemoryInfo *) NULL)) { if (offsets == (ssize_t *) NULL) offsets=(ssize_t *) RelinquishMagickMemory(offsets); if (runlength == (size_t *) NULL) runlength=(size_t *) RelinquishMagickMemory(runlength); if (packet_info == (MemoryInfo *) NULL) packet_info=RelinquishVirtualMemory(packet_info); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } packets=(unsigned char *) GetVirtualMemoryBlob(packet_info); for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++) offsets[i]=ReadBlobMSBSignedLong(image); for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++) { runlength[i]=ReadBlobMSBLong(image); if (runlength[i] > (4*(size_t) iris_info.columns+10)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } offset=0; data_order=0; for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++) for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++) { if (offsets[y+z*iris_info.rows] < offset) data_order=1; offset=offsets[y+z*iris_info.rows]; } offset=(ssize_t) TellBlob(image); if (data_order == 1) { for (z=0; z < (ssize_t) iris_info.depth; z++) { p=pixels; for (y=0; y < (ssize_t) iris_info.rows; y++) { if (offset != offsets[y+z*iris_info.rows]) { offset=offsets[y+z*iris_info.rows]; offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET); } count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows], packets); if (EOFBlob(image) != MagickFalse) break; offset+=(ssize_t) runlength[y+z*iris_info.rows]; status=SGIDecode(bytes_per_pixel,(ssize_t) (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets, 1L*iris_info.columns,p+bytes_per_pixel*z); if (status == MagickFalse) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); p+=(iris_info.columns*4*bytes_per_pixel); } } } else { MagickOffsetType position; position=TellBlob(image); p=pixels; for (y=0; y < (ssize_t) iris_info.rows; y++) { for (z=0; z < (ssize_t) iris_info.depth; z++) { if (offset != offsets[y+z*iris_info.rows]) { offset=offsets[y+z*iris_info.rows]; offset=(ssize_t) SeekBlob(image,(ssize_t) offset,SEEK_SET); } count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows], packets); if (EOFBlob(image) != MagickFalse) break; offset+=(ssize_t) runlength[y+z*iris_info.rows]; status=SGIDecode(bytes_per_pixel,(ssize_t) (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets, 1L*iris_info.columns,p+bytes_per_pixel*z); if (status == MagickFalse) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } p+=(iris_info.columns*4*bytes_per_pixel); } offset=(ssize_t) SeekBlob(image,position,SEEK_SET); } packet_info=RelinquishVirtualMemory(packet_info); runlength=(size_t *) RelinquishMagickMemory(runlength); offsets=(ssize_t *) RelinquishMagickMemory(offsets); } image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait :  UndefinedPixelTrait; image->columns=iris_info.columns; image->rows=iris_info.rows; if (image->storage_class == DirectClass) { if (bytes_per_pixel == 2) { for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*8*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleShortToQuantum((unsigned short) ((*(p+0) << 8) | (*(p+1)))),q); SetPixelGreen(image,ScaleShortToQuantum((unsigned short) ((*(p+2) << 8) | (*(p+3)))),q); SetPixelBlue(image,ScaleShortToQuantum((unsigned short) ((*(p+4) << 8) | (*(p+5)))),q); SetPixelAlpha(image,OpaqueAlpha,q); if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) ((*(p+6) << 8) | (*(p+7)))),q); p+=8; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows); if (status == MagickFalse) break; } } } else for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*4*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleCharToQuantum(*p),q); SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q); SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q); SetPixelAlpha(image,OpaqueAlpha,q); if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q); p+=4; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } else { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); if (bytes_per_pixel == 2) { for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*8*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { quantum=(*p << 8); quantum|=(*(p+1)); SetPixelIndex(image,(Quantum) quantum,q); p+=8; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows); if (status == MagickFalse) break; } } } else for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*4*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelIndex(image,*p,q); p+=4; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } (void) SyncImage(image,exception); } pixel_info=RelinquishVirtualMemory(pixel_info); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; iris_info.magic=ReadBlobMSBShort(image); if (iris_info.magic == 0x01DA) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (iris_info.magic == 0x01DA); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"void Compute(OpKernelContext* context) override { const Tensor& images = context->input(0); const Tensor& boxes = context->input(1); const int64 depth = images.dim_size(3); OP_REQUIRES(context, images.dims() == 4, errors::InvalidArgument(""The rank of the images should be 4"")); OP_REQUIRES( context, boxes.dims() == 3, errors::InvalidArgument(""The rank of the boxes tensor should be 3"")); OP_REQUIRES(context, images.dim_size(0) == boxes.dim_size(0), errors::InvalidArgument(""The batch sizes should be the same"")); OP_REQUIRES( context, depth == 4 || depth == 1 || depth == 3, errors::InvalidArgument(""Channel depth should be either 1 (GRY), "" ""3 (RGB), or 4 (RGBA)"")); const int64 batch_size = images.dim_size(0); const int64 height = images.dim_size(1); const int64 width = images.dim_size(2); std::vector<std::vector<float>> color_table; if (context->num_inputs() == 3) { const Tensor& colors_tensor = context->input(2); OP_REQUIRES(context, colors_tensor.shape().dims() == 2, errors::InvalidArgument(""colors must be a 2-D matrix"", colors_tensor.shape().DebugString())); OP_REQUIRES(context, colors_tensor.shape().dim_size(1) >= depth, errors::InvalidArgument(""colors must have equal or more "", ""channels than the image provided: "", colors_tensor.shape().DebugString())); if (colors_tensor.NumElements() != 0) { color_table.clear(); auto colors = colors_tensor.matrix<float>(); for (int64 i = 0; i < colors.dimension(0); i++) { std::vector<float> color_value(4); for (int64 j = 0; j < 4; j++) { color_value[j] = colors(i, j); } color_table.emplace_back(color_value); } } } if (color_table.empty()) { color_table = DefaultColorTable(depth); } Tensor* output; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({batch_size, height, width, depth}), &output)); output->tensor<T, 4>() = images.tensor<T, 4>(); auto canvas = output->tensor<T, 4>(); for (int64 b = 0; b < batch_size; ++b) { const int64 num_boxes = boxes.dim_size(1); const auto tboxes = boxes.tensor<T, 3>(); for (int64 bb = 0; bb < num_boxes; ++bb) { int64 color_index = bb % color_table.size(); const int64 min_box_row = static_cast<float>(tboxes(b, bb, 0)) * (height - 1); const int64 min_box_row_clamp = std::max<int64>(min_box_row, int64{0}); const int64 max_box_row = static_cast<float>(tboxes(b, bb, 2)) * (height - 1); const int64 max_box_row_clamp = std::min<int64>(max_box_row, height - 1); const int64 min_box_col = static_cast<float>(tboxes(b, bb, 1)) * (width - 1); const int64 min_box_col_clamp = std::max<int64>(min_box_col, int64{0}); const int64 max_box_col = static_cast<float>(tboxes(b, bb, 3)) * (width - 1); const int64 max_box_col_clamp = std::min<int64>(max_box_col, width - 1); if (min_box_row > max_box_row || min_box_col > max_box_col) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is inverted and will not be drawn.""; continue; } if (min_box_row >= height || max_box_row < 0 || min_box_col >= width || max_box_col < 0) { LOG(WARNING) << ""Bounding box ("" << min_box_row << "","" << min_box_col << "","" << max_box_row << "","" << max_box_col << "") is completely outside the image"" << "" and will not be drawn.""; continue; } CHECK_GE(min_box_row_clamp, 0); CHECK_GE(max_box_row_clamp, 0); CHECK_LT(min_box_row_clamp, height); CHECK_LT(max_box_row_clamp, height); CHECK_GE(min_box_col_clamp, 0); CHECK_GE(max_box_col_clamp, 0); CHECK_LT(min_box_col_clamp, width); CHECK_LT(max_box_col_clamp, width); CHECK_LT(min_box_row, height); CHECK_GE(max_box_row, 0); CHECK_LT(min_box_col, width); CHECK_GE(max_box_col, 0); if (min_box_row >= 0) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, min_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_row < height) { for (int64 j = min_box_col_clamp; j <= max_box_col_clamp; ++j) for (int64 c = 0; c < depth; c++) { canvas(b, max_box_row, j, c) = static_cast<T>(color_table[color_index][c]); } } if (min_box_col >= 0) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, min_box_col, c) = static_cast<T>(color_table[color_index][c]); } } if (max_box_col < width) { for (int64 i = min_box_row_clamp; i <= max_box_row_clamp; ++i) for (int64 c = 0; c < depth; c++) { canvas(b, i, max_box_col, c) = static_cast<T>(color_table[color_index][c]); } } } } }"
"static int io_req_defer_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe) { ssize_t ret = 0; switch (req->opcode) { case IORING_OP_NOP: break; case IORING_OP_READV: case IORING_OP_READ_FIXED: ret = io_read_prep(req, sqe, true); break; case IORING_OP_WRITEV: case IORING_OP_WRITE_FIXED: ret = io_write_prep(req, sqe, true); break; case IORING_OP_POLL_ADD: ret = io_poll_add_prep(req, sqe); break; case IORING_OP_POLL_REMOVE: ret = io_poll_remove_prep(req, sqe); break; case IORING_OP_FSYNC: ret = io_prep_fsync(req, sqe); break; case IORING_OP_SYNC_FILE_RANGE: ret = io_prep_sfr(req, sqe); break; case IORING_OP_SENDMSG: ret = io_sendmsg_prep(req, sqe); break; case IORING_OP_RECVMSG: ret = io_recvmsg_prep(req, sqe); break; case IORING_OP_CONNECT: ret = io_connect_prep(req, sqe); break; case IORING_OP_TIMEOUT: ret = io_timeout_prep(req, sqe, false); break; case IORING_OP_TIMEOUT_REMOVE: ret = io_timeout_remove_prep(req, sqe); break; case IORING_OP_ASYNC_CANCEL: ret = io_async_cancel_prep(req, sqe); break; case IORING_OP_LINK_TIMEOUT: ret = io_timeout_prep(req, sqe, true); break; case IORING_OP_ACCEPT: ret = io_accept_prep(req, sqe); break; case IORING_OP_FALLOCATE: ret = io_fallocate_prep(req, sqe); break; case IORING_OP_OPENAT: ret = io_openat_prep(req, sqe); break; default: printk_once(KERN_WARNING ""io_uring: unhandled opcode %d\n"", req->opcode); ret = -EINVAL; break; } return ret; }"
"static VALUE from_document(VALUE klass, VALUE document) { xmlDocPtr doc; xmlRelaxNGParserCtxtPtr ctx; xmlRelaxNGPtr schema; VALUE errors; VALUE rb_schema; Data_Get_Struct(document, xmlDoc, doc); doc = doc->doc; ctx = xmlRelaxNGNewDocParserCtxt(doc); errors = rb_ary_new(); xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher); #ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS xmlRelaxNGSetParserStructuredErrors( ctx, Nokogiri_error_array_pusher, (void *)errors ); #endif schema = xmlRelaxNGParse(ctx); xmlSetStructuredErrorFunc(NULL, NULL); xmlRelaxNGFreeParserCtxt(ctx); if(NULL == schema) { xmlErrorPtr error = xmlGetLastError(); if(error) Nokogiri_error_raise(NULL, error); else rb_raise(rb_eRuntimeError, ""Could not parse document""); return Qnil; } rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema); rb_iv_set(rb_schema, ""@errors"", errors); return rb_schema; }"
"static struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb, struct tcp_sacktag_state *state, u32 start_seq, u32 end_seq, bool dup_sack) { struct tcp_sock *tp = tcp_sk(sk); struct sk_buff *prev; int mss; int pcount = 0; int len; int in_sack; if (!dup_sack && (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS) goto fallback; if (!skb_can_shift(skb)) goto fallback; if (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una)) goto fallback; prev = skb_rb_prev(skb); if (!prev) goto fallback; if ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) goto fallback; if (!tcp_skb_can_collapse_to(prev)) goto fallback; in_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) && !before(end_seq, TCP_SKB_CB(skb)->end_seq); if (in_sack) { len = skb->len; pcount = tcp_skb_pcount(skb); mss = tcp_skb_seglen(skb); if (mss != tcp_skb_seglen(prev)) goto fallback; } else { if (!after(TCP_SKB_CB(skb)->end_seq, start_seq)) goto noop; if (tcp_skb_pcount(skb) <= 1) goto noop; in_sack = !after(start_seq, TCP_SKB_CB(skb)->seq); if (!in_sack) { goto fallback; } len = end_seq - TCP_SKB_CB(skb)->seq; BUG_ON(len < 0); BUG_ON(len > skb->len); mss = tcp_skb_mss(skb); if (mss != tcp_skb_seglen(prev)) goto fallback; if (len == mss) { pcount = 1; } else if (len < mss) { goto noop; } else { pcount = len / mss; len = pcount * mss; } } if (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una)) goto fallback; if (!skb_shift(prev, skb, len)) goto fallback; if (!tcp_shifted_skb(sk, prev, skb, state, pcount, len, mss, dup_sack)) goto out; skb = skb_rb_next(prev); if (!skb) goto out; if (!skb_can_shift(skb) || ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) || (mss != tcp_skb_seglen(skb))) goto out; len = skb->len; if (skb_shift(prev, skb, len)) { pcount += tcp_skb_pcount(skb); tcp_shifted_skb(sk, prev, skb, state, tcp_skb_pcount(skb), len, mss, 0); } out: return prev; noop: return skb; fallback: NET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK); return NULL; }"
"static void domain_dump_evtchn_info(struct domain *d) { unsigned int port; int irq; bitmap_scnlistprintf(keyhandler_scratch, sizeof(keyhandler_scratch), d->poll_mask, d->max_vcpus); printk(""Event channel information for domain %d:\n"" ""Polling vCPUs: {%s}\n"" ""    port [p/m/s]\n"", d->domain_id, keyhandler_scratch); spin_lock(&d->event_lock); for ( port = 1; port < d->max_evtchns; ++port ) { const struct evtchn *chn; char *ssid; if ( !port_is_valid(d, port) ) continue; chn = evtchn_from_port(d, port); if ( chn->state == ECS_FREE ) continue; printk(""    %4u [%d/%d/"", port, !!evtchn_port_is_pending(d, chn), !!evtchn_port_is_masked(d, chn)); evtchn_port_print_state(d, chn); printk(""]: s=%d n=%d x=%d"", chn->state, chn->notify_vcpu_id, chn->xen_consumer); switch ( chn->state ) { case ECS_UNBOUND: printk("" d=%d"", chn->u.unbound.remote_domid); break; case ECS_INTERDOMAIN: printk("" d=%d p=%d"", chn->u.interdomain.remote_dom->domain_id, chn->u.interdomain.remote_port); break; case ECS_PIRQ: irq = domain_pirq_to_irq(d, chn->u.pirq.irq); printk("" p=%d i=%d"", chn->u.pirq.irq, irq); break; case ECS_VIRQ: printk("" v=%d"", chn->u.virq); break; } ssid = xsm_show_security_evtchn(d, chn); if (ssid) { printk("" Z=%s\n"", ssid); xfree(ssid); } else { printk(""\n""); } } spin_unlock(&d->event_lock); }"
"static const u_char * ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_, const struct isakmp_gen *ext, u_int item_len, const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_, uint32_t proto0 _U_, int depth _U_) { const struct ikev1_pl_cert *p; struct ikev1_pl_cert cert; static const char *certstr[] = { ""none"",""pkcs7"", ""pgp"", ""dns"", ""x509sign"", ""x509ke"", ""kerberos"", ""crl"", ""arl"", ""spki"", ""x509attr"", }; ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_CERT))); p = (const struct ikev1_pl_cert *)ext; ND_TCHECK(*p); UNALIGNED_MEMCPY(&cert, ext, sizeof(cert)); ND_PRINT((ndo,"" len=%d"", item_len - 4)); ND_PRINT((ndo,"" type=%s"", STR_OR_ID((cert.encode), certstr))); if (2 < ndo->ndo_vflag && 4 < item_len) { ND_PRINT((ndo,"" "")); if (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4)) goto trunc; } return (const u_char *)ext + item_len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_CERT))); return NULL; }"
"static int GetNumSameData(const byte * curPtr, const int maxnum) { int count = 1; if (1 == maxnum) { return (1); } while (*curPtr == *(curPtr + count) && maxnum > count) { count++; } return (count); }"
"static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kSegCountOffset = 6; const size_t kEndCountOffset = 14; const size_t kHeaderSize = 16; const size_t kSegmentSize = 8;      if (kEndCountOffset > size) { return false; } size_t segCount = readU16(data, kSegCountOffset) >> 1; if (kHeaderSize + segCount * kSegmentSize > size) { return false; } for (size_t i = 0; i < segCount; i++) { int end = readU16(data, kEndCountOffset + 2 * i); int start = readU16(data, kHeaderSize + 2 * (segCount + i)); int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i)); if (rangeOffset == 0) { int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i)); if (((end + delta) & 0xffff) > end - start) { addRange(coverage, start, end + 1); } else { for (int j = start; j < end + 1; j++) { if (((j + delta) & 0xffff) != 0) { addRange(coverage, j, j + 1); } } } } else { for (int j = start; j < end + 1; j++) { uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset + (i + j - start) * 2; if (actualRangeOffset + 2 > size) { return false; } int glyphId = readU16(data, actualRangeOffset); if (glyphId != 0) { addRange(coverage, j, j + 1); } } } } return true; }"
"static void io_req_free_batch_finish(struct io_ring_ctx *ctx, struct req_batch *rb) { if (rb->to_free) __io_req_free_batch_flush(ctx, rb); if (rb->task) { put_task_struct_many(rb->task, rb->task_refs); rb->task = NULL; } }"
"GF_Err abst_Read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize=(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->movie_identifier = gf_strdup(tmp_str); ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->drm_data = gf_strdup(tmp_str); i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->meta_data = gf_strdup(tmp_str); ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_insert(ptr->segment_run_table_entries, asrt, i); } ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_insert(ptr->fragment_run_table_entries, afrt, i); } gf_free(tmp_str); return GF_OK; }"
"static size_t optsize (lua_State *L, char opt, const char **fmt) { switch (opt) { case 'B': case 'b': return sizeof(char); case 'H': case 'h': return sizeof(short); case 'L': case 'l': return sizeof(long); case 'T': return sizeof(size_t); case 'f':  return sizeof(float); case 'd':  return sizeof(double); case 'x': return 1; case 'c': return getnum(fmt, 1); case 'i': case 'I': { int sz = getnum(fmt, sizeof(int)); if (sz > MAXINTSIZE) luaL_error(L, ""integral size %d is larger than limit of %d"", sz, MAXINTSIZE); return sz; } default: return 0;   } }"
static void release_card(struct l1oip *hc) { intch; if (timer_pending(&hc->keep_tl)) del_timer(&hc->keep_tl); if (timer_pending(&hc->timeout_tl)) del_timer(&hc->timeout_tl); cancel_work_sync(&hc->workq); if (hc->socket_thread) l1oip_socket_close(hc); if (hc->registered && hc->chan[hc->d_idx].dch) mISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev); for (ch = 0; ch < 128; ch++) { if (hc->chan[ch].dch) { mISDN_freedchannel(hc->chan[ch].dch); kfree(hc->chan[ch].dch); } if (hc->chan[ch].bch) { mISDN_freebchannel(hc->chan[ch].bch); kfree(hc->chan[ch].bch); #ifdef REORDER_DEBUG dev_kfree_skb(hc->chan[ch].disorder_skb); #endif } } spin_lock(&l1oip_lock); list_del(&hc->list); spin_unlock(&l1oip_lock); kfree(hc); }
"static mrb_value mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class) { mrb_value blk; mrb_value proc; struct RProc *p; mrb_get_args(mrb, ""&!"", &blk); p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class)); mrb_proc_copy(p, mrb_proc_ptr(blk)); proc = mrb_obj_value(p); mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc); if (!MRB_PROC_STRICT_P(p) && mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) { p->flags |= MRB_PROC_ORPHAN; } return proc; }"
"static int mp_dss_print(netdissect_options *ndo, const u_char *opt, u_int opt_len, u_char flags) { const struct mp_dss *mdss = (const struct mp_dss *) opt; if ((opt_len != mp_dss_len(mdss, 1) && opt_len != mp_dss_len(mdss, 0)) || flags & TH_SYN) return 0; if (mdss->flags & MP_DSS_F) ND_PRINT((ndo, "" fin"")); opt += 4; if (mdss->flags & MP_DSS_A) { ND_PRINT((ndo, "" ack "")); if (mdss->flags & MP_DSS_a) { ND_PRINT((ndo, ""%"" PRIu64, EXTRACT_64BITS(opt))); opt += 8; } else { ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(opt))); opt += 4; } } if (mdss->flags & MP_DSS_M) { ND_PRINT((ndo, "" seq "")); if (mdss->flags & MP_DSS_m) { ND_PRINT((ndo, ""%"" PRIu64, EXTRACT_64BITS(opt))); opt += 8; } else { ND_PRINT((ndo, ""%u"", EXTRACT_32BITS(opt))); opt += 4; } ND_PRINT((ndo, "" subseq %u"", EXTRACT_32BITS(opt))); opt += 4; ND_PRINT((ndo, "" len %u"", EXTRACT_16BITS(opt))); opt += 2; if (opt_len == mp_dss_len(mdss, 1)) ND_PRINT((ndo, "" csum 0x%x"", EXTRACT_16BITS(opt))); } return 1; }"
"static void xudc_set_clear_feature(struct xusb_udc *udc) { struct xusb_ep *ep0= &udc->ep[0]; struct xusb_req *req= udc->req; struct xusb_ep *target_ep; u8 endpoint; u8 outinbit; u32 epcfgreg; int flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0); int ret; switch (udc->setup.bRequestType) { case USB_RECIP_DEVICE: switch (udc->setup.wValue) { case USB_DEVICE_TEST_MODE: break; case USB_DEVICE_REMOTE_WAKEUP: if (flag) udc->remote_wkp = 1; else udc->remote_wkp = 0; break; default: xudc_ep0_stall(udc); break; } break; case USB_RECIP_ENDPOINT: if (!udc->setup.wValue) { endpoint = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK; target_ep = &udc->ep[endpoint]; outinbit = udc->setup.wIndex & USB_ENDPOINT_DIR_MASK; outinbit = outinbit >> 7; if (outinbit != target_ep->is_in) { xudc_ep0_stall(udc); return; } epcfgreg = udc->read_fn(udc->addr + target_ep->offset); if (!endpoint) { epcfgreg &= ~XUSB_EP_CFG_STALL_MASK; udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } else { if (flag) { epcfgreg |= XUSB_EP_CFG_STALL_MASK; udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } else { epcfgreg &= ~(XUSB_EP_CFG_STALL_MASK | XUSB_EP_CFG_DATA_TOGGLE_MASK); udc->write_fn(udc->addr, target_ep->offset, epcfgreg); } } } break; default: xudc_ep0_stall(udc); return; } req->usb_req.length = 0; ret = __xudc_ep0_queue(ep0, req); if (ret == 0) return; dev_err(udc->dev, ""Can't respond to SET/CLEAR FEATURE\n""); xudc_ep0_stall(udc); }"
"void gf_isom_meta_restore_items_ref(GF_ISOFile *movie, GF_MetaBox *meta) { u32 i, nb_items, nb_tracks; if (!meta->item_locations || !meta->item_infos) return; nb_tracks = movie->moov ? gf_list_count(movie->moov->trackList) : 0; nb_items = gf_list_count(meta->item_locations->location_entries); for (i=0; i<nb_items; i++) { u32 j; u64 item_offset; GF_ItemExtentEntry *entry; GF_ItemLocationEntry *iloc = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, i); GF_ItemInfoEntryBox *iinf = NULL; j=0; while ((iinf = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &j))) { if (iinf->item_ID==iloc->item_ID) break; iinf = NULL; } if (!iinf) continue; if (iinf->ref_it_id) continue; if (gf_list_count(iloc->extent_entries) != 1) continue; entry = (GF_ItemExtentEntry *)gf_list_get(iloc->extent_entries, 0); if (!entry) continue; item_offset = iloc->base_offset + entry->extent_offset; for (j=0;j<nb_tracks; j++) { GF_TrackBox *trak; GF_SampleSizeBox *stsz; u32 k; trak = gf_list_get(movie->moov->trackList, j); if (! gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) continue; stsz = trak->Media->information->sampleTable->SampleSize; if (!stsz->sampleCount) continue; for (k=0; k<stsz->sampleCount; k++) { GF_Err e; u32 chunk, di, samp_size; u64 samp_offset; samp_size = stsz->sampleSize ? stsz->sampleSize : stsz->sizes[k]; if (samp_size != entry->extent_length) continue; e = stbl_GetSampleInfos(trak->Media->information->sampleTable, k+1, &samp_offset, &chunk, &di, NULL); if (e) continue; if (samp_offset == item_offset) { iinf->tk_id = trak->Header->trackID; iinf->sample_num = k+1; iinf->data_len = (u32) entry->extent_length; meta->use_item_sample_sharing = 1; break; } } if (iinf->tk_id) break; } for (j=i+1;j<nb_items; j++) { u32 k; u64 item_offset2; GF_ItemExtentEntry *entry2; GF_ItemLocationEntry *iloc2 = (GF_ItemLocationEntry *)gf_list_get(meta->item_locations->location_entries, j); GF_ItemInfoEntryBox *iinf2 = NULL; k=0; while ((iinf2 = (GF_ItemInfoEntryBox *)gf_list_enum(meta->item_infos->item_infos, &k))) { if (iinf2->item_ID==iloc2->item_ID) break; iinf2 = NULL; } if (!iinf2) continue; if (gf_list_count(iloc2->extent_entries) != 1) continue; entry2 = (GF_ItemExtentEntry *)gf_list_get(iloc2->extent_entries, 0); if (!entry2) continue; item_offset2 = iloc2->base_offset + entry2->extent_offset; if (item_offset == item_offset2) { iinf2->ref_it_id = iinf->item_ID; meta->use_item_item_sharing = 1; } } } }"
"int amqp_handle_input(amqp_connection_state_t state, amqp_bytes_t received_data, amqp_frame_t *decoded_frame) { size_t bytes_consumed; void *raw_frame; decoded_frame->frame_type = 0; if (received_data.len == 0) { return AMQP_STATUS_OK; } if (state->state == CONNECTION_STATE_IDLE) { state->state = CONNECTION_STATE_HEADER; } bytes_consumed = consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } raw_frame = state->inbound_buffer.bytes; switch (state->state) { case CONNECTION_STATE_INITIAL: if (memcmp(raw_frame, ""AMQP"", 4) == 0) { decoded_frame->frame_type = AMQP_PSEUDOFRAME_PROTOCOL_HEADER; decoded_frame->channel = 0; decoded_frame->payload.protocol_header.transport_high = amqp_d8(amqp_offset(raw_frame, 4)); decoded_frame->payload.protocol_header.transport_low = amqp_d8(amqp_offset(raw_frame, 5)); decoded_frame->payload.protocol_header.protocol_version_major = amqp_d8(amqp_offset(raw_frame, 6)); decoded_frame->payload.protocol_header.protocol_version_minor = amqp_d8(amqp_offset(raw_frame, 7)); return_to_idle(state); return (int)bytes_consumed; } case CONNECTION_STATE_HEADER: { amqp_channel_t channel; amqp_pool_t *channel_pool; channel = amqp_d16(amqp_offset(raw_frame, 1)); state->target_size = amqp_d32(amqp_offset(raw_frame, 3)) + HEADER_SIZE + FOOTER_SIZE; if ((size_t)state->frame_max < state->target_size) { return AMQP_STATUS_BAD_AMQP_DATA; } channel_pool = amqp_get_or_create_channel_pool(state, channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } amqp_pool_alloc_bytes(channel_pool, state->target_size, &state->inbound_buffer); if (NULL == state->inbound_buffer.bytes) { return AMQP_STATUS_NO_MEMORY; } memcpy(state->inbound_buffer.bytes, state->header_buffer, HEADER_SIZE); raw_frame = state->inbound_buffer.bytes; state->state = CONNECTION_STATE_BODY; bytes_consumed += consume_data(state, &received_data); if (state->inbound_offset < state->target_size) { return (int)bytes_consumed; } } case CONNECTION_STATE_BODY: { amqp_bytes_t encoded; int res; amqp_pool_t *channel_pool; if (amqp_d8(amqp_offset(raw_frame, state->target_size - 1)) != AMQP_FRAME_END) { return AMQP_STATUS_BAD_AMQP_DATA; } decoded_frame->frame_type = amqp_d8(amqp_offset(raw_frame, 0)); decoded_frame->channel = amqp_d16(amqp_offset(raw_frame, 1)); channel_pool = amqp_get_or_create_channel_pool(state, decoded_frame->channel); if (NULL == channel_pool) { return AMQP_STATUS_NO_MEMORY; } switch (decoded_frame->frame_type) { case AMQP_FRAME_METHOD: decoded_frame->payload.method.id = amqp_d32(amqp_offset(raw_frame, HEADER_SIZE)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 4); encoded.len = state->target_size - HEADER_SIZE - 4 - FOOTER_SIZE; res = amqp_decode_method(decoded_frame->payload.method.id, channel_pool, encoded, &decoded_frame->payload.method.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_HEADER: decoded_frame->payload.properties.class_id = amqp_d16(amqp_offset(raw_frame, HEADER_SIZE)); decoded_frame->payload.properties.body_size = amqp_d64(amqp_offset(raw_frame, HEADER_SIZE + 4)); encoded.bytes = amqp_offset(raw_frame, HEADER_SIZE + 12); encoded.len = state->target_size - HEADER_SIZE - 12 - FOOTER_SIZE; decoded_frame->payload.properties.raw = encoded; res = amqp_decode_properties( decoded_frame->payload.properties.class_id, channel_pool, encoded, &decoded_frame->payload.properties.decoded); if (res < 0) { return res; } break; case AMQP_FRAME_BODY: decoded_frame->payload.body_fragment.len = state->target_size - HEADER_SIZE - FOOTER_SIZE; decoded_frame->payload.body_fragment.bytes = amqp_offset(raw_frame, HEADER_SIZE); break; case AMQP_FRAME_HEARTBEAT: break; default: decoded_frame->frame_type = 0; break; } return_to_idle(state); return (int)bytes_consumed; } default: amqp_abort(""Internal error: invalid amqp_connection_state_t->state %d"", state->state); } }"
"static ssize_t nports_show(struct device *dev, struct device_attribute *attr, char *out) { char *s = out; out += sprintf(out, ""%d\n"", VHCI_PORTS * vhci_num_controllers); return out - s; }"
"v8::Local<v8::Object> CreateNativeEvent( v8::Isolate* isolate, v8::Local<v8::Object> sender, content::RenderFrameHost* frame, electron::mojom::ElectronBrowser::MessageSyncCallback callback) { v8::Local<v8::Object> event; if (frame && callback) { gin::Handle<Event> native_event = Event::Create(isolate); native_event->SetCallback(std::move(callback)); event = v8::Local<v8::Object>::Cast(native_event.ToV8()); } else { event = CreateEvent(isolate); } Dictionary dict(isolate, event); dict.Set(""sender"", sender); if (frame) dict.Set(""frameId"", frame->GetRoutingID()); return event; }"
"char* parseKey( char* ptr, FileNode& collection, FileNode& value_placeholder ) { if( *ptr != '""' ) CV_PARSE_ERROR_CPP( ""Key must start with \'\""\'"" ); char * beg = ptr + 1; do { ++ptr; CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP(); } while( cv_isprint(*ptr) && *ptr != '""' ); if( *ptr != '""' ) CV_PARSE_ERROR_CPP( ""Key must end with \'\""\'"" ); const char * end = ptr; ptr++; ptr = skipSpaces( ptr ); if( !ptr || !*ptr ) return 0; if( *ptr != ':' ) CV_PARSE_ERROR_CPP( ""Missing \':\' between key and value"" ); if( end <= beg ) CV_PARSE_ERROR_CPP( ""Key is empty"" ); value_placeholder = fs->addNode(collection, std::string(beg, (size_t)(end - beg)), FileNode::NONE); return ++ptr; }"
"void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext) { std::string real_rule; if(startsWith(rule, ""[]"") && add_direct) { filtered_nodelist.emplace_back(rule.substr(2)); } #ifndef NO_JS_RUNTIME else if(startsWith(rule, ""script:"")) { script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){ std::string script = fileGet(rule.substr(7), true); try { ctx.eval(script); auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(""filter""); std::string result_list = filter(nodelist); filtered_nodelist = split(regTrim(result_list), ""\n""); } catch (qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } #endif     else { for(Proxy &x : nodelist) { if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end()) filtered_nodelist.emplace_back(x.Remark); } } }"
"int put_page_type_preemptible(struct page_info *page) { return __put_page_type(page, 1); }"
"PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool, const char *filename, unsigned ptime, unsigned options, pj_ssize_t buff_size, pjmedia_port **p_port ) { pjmedia_wave_hdr wave_hdr; pj_ssize_t size_to_read, size_read; struct file_reader_port *fport; pjmedia_audio_format_detail *ad; pj_off_t pos; pj_str_t name; unsigned samples_per_frame; pj_status_t status = PJ_SUCCESS; PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL); if (!pj_file_exists(filename)) { return PJ_ENOTFOUND; } if (ptime == 0) ptime = 20; if (buff_size < 1) buff_size = PJMEDIA_FILE_PORT_BUFSIZE; fport = create_file_port(pool); if (!fport) { return PJ_ENOMEM; } fport->fsize = pj_file_size(filename); if (fport->fsize <= sizeof(pjmedia_wave_hdr)) { return PJMEDIA_ENOTVALIDWAVE; } status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd); if (status != PJ_SUCCESS) return status; size_read = size_to_read = sizeof(wave_hdr) - 8; status = pj_file_read( fport->fd, &wave_hdr, &size_read); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } if (size_read != size_to_read) { pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE; } pjmedia_wave_hdr_file_to_host(&wave_hdr); if (wave_hdr.riff_hdr.riff != PJMEDIA_RIFF_TAG || wave_hdr.riff_hdr.wave != PJMEDIA_WAVE_TAG || wave_hdr.fmt_hdr.fmt != PJMEDIA_FMT_TAG) { pj_file_close(fport->fd); TRACE_((THIS_FILE,  ""actual value|expected riff=%x|%x, wave=%x|%x fmt=%x|%x"", wave_hdr.riff_hdr.riff, PJMEDIA_RIFF_TAG, wave_hdr.riff_hdr.wave, PJMEDIA_WAVE_TAG, wave_hdr.fmt_hdr.fmt, PJMEDIA_FMT_TAG)); return PJMEDIA_ENOTVALIDWAVE; } switch (wave_hdr.fmt_hdr.fmt_tag) { case PJMEDIA_WAVE_FMT_TAG_PCM: if (wave_hdr.fmt_hdr.bits_per_sample != 16 ||  wave_hdr.fmt_hdr.block_align != 2 * wave_hdr.fmt_hdr.nchan) status = PJMEDIA_EWAVEUNSUPP; break; case PJMEDIA_WAVE_FMT_TAG_ALAW: case PJMEDIA_WAVE_FMT_TAG_ULAW: if (wave_hdr.fmt_hdr.bits_per_sample != 8 || wave_hdr.fmt_hdr.block_align != wave_hdr.fmt_hdr.nchan) status = PJMEDIA_ENOTVALIDWAVE; break; default: status = PJMEDIA_EWAVEUNSUPP; break; } if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag; fport->bytes_per_sample = (pj_uint16_t)  (wave_hdr.fmt_hdr.bits_per_sample / 8); if (wave_hdr.fmt_hdr.len > 16) { size_to_read = wave_hdr.fmt_hdr.len - 16; status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } } for (;;) { pjmedia_wave_subchunk subchunk; size_read = 8; status = pj_file_read(fport->fd, &subchunk, &size_read); if (status != PJ_SUCCESS || size_read != 8) { pj_file_close(fport->fd); return PJMEDIA_EWAVETOOSHORT; } PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk); if (subchunk.id == PJMEDIA_DATA_TAG) { wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG; wave_hdr.data_hdr.len = subchunk.len; break; } size_to_read = subchunk.len; status = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } } status = pj_file_getpos(fport->fd, &pos); fport->start_data = (unsigned)pos; fport->data_len = wave_hdr.data_hdr.len; fport->data_left = wave_hdr.data_hdr.len; if (wave_hdr.data_hdr.len > fport->fsize - fport->start_data) { wave_hdr.data_hdr.len = (pj_uint32_t)fport->fsize - fport->start_data; } if (wave_hdr.data_hdr.len < ptime * wave_hdr.fmt_hdr.sample_rate * wave_hdr.fmt_hdr.nchan / 1000) { pj_file_close(fport->fd); return PJMEDIA_EWAVETOOSHORT; } fport->options = options; ad = pjmedia_format_get_audio_format_detail(&fport->base.info.fmt, 1); pj_strdup2(pool, &name, filename); samples_per_frame = ptime * wave_hdr.fmt_hdr.sample_rate * wave_hdr.fmt_hdr.nchan / 1000; pjmedia_port_info_init(&fport->base.info, &name, SIGNATURE, wave_hdr.fmt_hdr.sample_rate, wave_hdr.fmt_hdr.nchan, BITS_PER_SAMPLE, samples_per_frame); if (wave_hdr.data_hdr.len < (unsigned)buff_size) buff_size = wave_hdr.data_hdr.len; fport->bufsize = (pj_uint32_t)buff_size; if (samples_per_frame * fport->bytes_per_sample >= fport->bufsize) { pj_file_close(fport->fd); return PJ_EINVAL; } fport->buf = (char*) pj_pool_alloc(pool, fport->bufsize); if (!fport->buf) { pj_file_close(fport->fd); return PJ_ENOMEM; } fport->readpos = fport->buf; fport->fpos = fport->start_data; status = fill_buffer(fport); if (status != PJ_SUCCESS) { pj_file_close(fport->fd); return status; } *p_port = &fport->base; PJ_LOG(4,(THIS_FILE,  ""File player '%.*s' created: samp.rate=%d, ch=%d, bufsize=%uKB, "" ""filesize=%luKB"", (int)fport->base.info.name.slen, fport->base.info.name.ptr, ad->clock_rate, ad->channel_count, fport->bufsize / 1000, (unsigned long)(fport->fsize / 1000))); return PJ_SUCCESS; }"
"void sas_deform_port(struct asd_sas_phy *phy, int gone) { struct sas_ha_struct *sas_ha = phy->ha; struct asd_sas_port *port = phy->port; struct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt); struct domain_device *dev; unsigned long flags; if (!port) return;   dev = port->port_dev; if (dev) dev->pathways--; if (port->num_phys == 1) { sas_unregister_domain_devices(port, gone); sas_port_delete(port->port); port->port = NULL; } else { sas_port_delete_phy(port->port, phy->phy); sas_device_set_phy(dev, port->port); } if (si->dft->lldd_port_deformed) si->dft->lldd_port_deformed(phy); spin_lock_irqsave(&sas_ha->phy_port_lock, flags); spin_lock(&port->phy_list_lock); list_del_init(&phy->port_phy_el); sas_phy_set_target(phy, NULL); phy->port = NULL; port->num_phys--; port->phy_mask &= ~(1U << phy->id); if (port->num_phys == 0) { INIT_LIST_HEAD(&port->phy_list); memset(port->sas_addr, 0, SAS_ADDR_SIZE); memset(port->attached_sas_addr, 0, SAS_ADDR_SIZE); port->class = 0; port->iproto = 0; port->tproto = 0; port->oob_mode = 0; port->phy_mask = 0; } spin_unlock(&port->phy_list_lock); spin_unlock_irqrestore(&sas_ha->phy_port_lock, flags); return; }"
"static int ovl_fill_super(struct super_block *sb, void *data, int silent) { struct path upperpath = { NULL, NULL }; struct path workpath = { NULL, NULL }; struct dentry *root_dentry; struct ovl_entry *oe; struct ovl_fs *ufs; struct path *stack = NULL; char *lowertmp; char *lower; unsigned int numlower; unsigned int stacklen = 0; unsigned int i; bool remote = false; int err; err = -ENOMEM; ufs = kzalloc(sizeof(struct ovl_fs), GFP_KERNEL); if (!ufs) goto out; err = ovl_parse_opt((char *) data, &ufs->config); if (err) goto out_free_config; err = -EINVAL; if (!ufs->config.lowerdir) { pr_err(""overlayfs: missing 'lowerdir'\n""); goto out_free_config; } sb->s_stack_depth = 0; if (ufs->config.upperdir) { if (!ufs->config.workdir) { pr_err(""overlayfs: missing 'workdir'\n""); goto out_free_config; } err = ovl_mount_dir(ufs->config.upperdir, &upperpath); if (err) goto out_free_config; if (upperpath.mnt->mnt_sb->s_flags & MS_RDONLY) { pr_err(""overlayfs: upper fs is r/o, try multi-lower layers mount\n""); err = -EINVAL; goto out_put_upperpath; } err = ovl_mount_dir(ufs->config.workdir, &workpath); if (err) goto out_put_upperpath; err = -EINVAL; if (upperpath.mnt != workpath.mnt) { pr_err(""overlayfs: workdir and upperdir must reside under the same mount\n""); goto out_put_workpath; } if (!ovl_workdir_ok(workpath.dentry, upperpath.dentry)) { pr_err(""overlayfs: workdir and upperdir must be separate subtrees\n""); goto out_put_workpath; } sb->s_stack_depth = upperpath.mnt->mnt_sb->s_stack_depth; } err = -ENOMEM; lowertmp = kstrdup(ufs->config.lowerdir, GFP_KERNEL); if (!lowertmp) goto out_put_workpath; err = -EINVAL; stacklen = ovl_split_lowerdirs(lowertmp); if (stacklen > OVL_MAX_STACK) { pr_err(""overlayfs: too many lower directries, limit is %d\n"", OVL_MAX_STACK); goto out_free_lowertmp; } else if (!ufs->config.upperdir && stacklen == 1) { pr_err(""overlayfs: at least 2 lowerdir are needed while upperdir nonexistent\n""); goto out_free_lowertmp; } stack = kcalloc(stacklen, sizeof(struct path), GFP_KERNEL); if (!stack) goto out_free_lowertmp; lower = lowertmp; for (numlower = 0; numlower < stacklen; numlower++) { err = ovl_lower_dir(lower, &stack[numlower], &ufs->lower_namelen, &sb->s_stack_depth, &remote); if (err) goto out_put_lowerpath; lower = strchr(lower, '\0') + 1; } err = -EINVAL; sb->s_stack_depth++; if (sb->s_stack_depth > FILESYSTEM_MAX_STACK_DEPTH) { pr_err(""overlayfs: maximum fs stacking depth exceeded\n""); goto out_put_lowerpath; } if (ufs->config.upperdir) { ufs->upper_mnt = clone_private_mount(&upperpath); err = PTR_ERR(ufs->upper_mnt); if (IS_ERR(ufs->upper_mnt)) { pr_err(""overlayfs: failed to clone upperpath\n""); goto out_put_lowerpath; } ufs->workdir = ovl_workdir_create(ufs->upper_mnt, workpath.dentry); err = PTR_ERR(ufs->workdir); if (IS_ERR(ufs->workdir)) { pr_warn(""overlayfs: failed to create directory %s/%s (errno: %i); mounting read-only\n"", ufs->config.workdir, OVL_WORKDIR_NAME, -err); sb->s_flags |= MS_RDONLY; ufs->workdir = NULL; } } err = -ENOMEM; ufs->lower_mnt = kcalloc(numlower, sizeof(struct vfsmount *), GFP_KERNEL); if (ufs->lower_mnt == NULL) goto out_put_workdir; for (i = 0; i < numlower; i++) { struct vfsmount *mnt = clone_private_mount(&stack[i]); err = PTR_ERR(mnt); if (IS_ERR(mnt)) { pr_err(""overlayfs: failed to clone lowerpath\n""); goto out_put_lower_mnt; } mnt->mnt_flags |= MNT_READONLY; ufs->lower_mnt[ufs->numlower] = mnt; ufs->numlower++; } if (!ufs->upper_mnt) sb->s_flags |= MS_RDONLY; if (remote) sb->s_d_op = &ovl_reval_dentry_operations; else sb->s_d_op = &ovl_dentry_operations; err = -ENOMEM; oe = ovl_alloc_entry(numlower); if (!oe) goto out_put_lower_mnt; root_dentry = d_make_root(ovl_new_inode(sb, S_IFDIR, oe)); if (!root_dentry) goto out_free_oe; mntput(upperpath.mnt); for (i = 0; i < numlower; i++) mntput(stack[i].mnt); path_put(&workpath); kfree(lowertmp); oe->__upperdentry = upperpath.dentry; for (i = 0; i < numlower; i++) { oe->lowerstack[i].dentry = stack[i].dentry; oe->lowerstack[i].mnt = ufs->lower_mnt[i]; } kfree(stack); root_dentry->d_fsdata = oe; sb->s_magic = OVERLAYFS_SUPER_MAGIC; sb->s_op = &ovl_super_operations; sb->s_root = root_dentry; sb->s_fs_info = ufs; return 0; out_free_oe: kfree(oe); out_put_lower_mnt: for (i = 0; i < ufs->numlower; i++) mntput(ufs->lower_mnt[i]); kfree(ufs->lower_mnt); out_put_workdir: dput(ufs->workdir); mntput(ufs->upper_mnt); out_put_lowerpath: for (i = 0; i < numlower; i++) path_put(&stack[i]); kfree(stack); out_free_lowertmp: kfree(lowertmp); out_put_workpath: path_put(&workpath); out_put_upperpath: path_put(&upperpath); out_free_config: kfree(ufs->config.lowerdir); kfree(ufs->config.upperdir); kfree(ufs->config.workdir); kfree(ufs); out: return err; }"
"static int vrend_renderer_resource_allocate_texture(struct vrend_resource *gr, void *image_oes) { uint level; GLenum internalformat, glformat, gltype; enum virgl_formats format = gr->base.format; struct vrend_texture *gt = (struct vrend_texture *)gr; struct pipe_resource *pr = &gr->base; if (pr->width0 == 0) return EINVAL; bool format_can_texture_storage = has_feature(feat_texture_storage) && (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE); if (vrend_state.use_gles && pr->nr_samples > 0 && !format_can_texture_storage) { VREND_DEBUG(dbg_tex, NULL, ""Apply VIRGL_BIND_PREFER_EMULATED_BGRA because GLES+MS+noTS\n""); gr->base.bind |= VIRGL_BIND_PREFER_EMULATED_BGRA; } if (image_oes && !has_feature(feat_egl_image_storage)) gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA; #ifdef ENABLE_GBM_ALLOCATION if (virgl_gbm_external_allocation_preferred(gr->base.bind) && !has_feature(feat_egl_image_storage)) gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA; #endif format = vrend_format_replace_emulated(gr->base.bind, gr->base.format); format_can_texture_storage = has_feature(feat_texture_storage) && (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE); if (format_can_texture_storage) gr->storage_bits |= VREND_STORAGE_GL_IMMUTABLE; if (!image_oes) { vrend_resource_gbm_init(gr, format); if (gr->gbm_bo && !has_bit(gr->storage_bits, VREND_STORAGE_EGL_IMAGE)) return 0; image_oes = gr->egl_image; } gr->target = tgsitargettogltarget(pr->target, pr->nr_samples); gr->storage_bits |= VREND_STORAGE_GL_TEXTURE; if (vrend_state.use_gles && gr->target == GL_TEXTURE_RECTANGLE_NV) { if (pr->width0 != 1 || pr->height0 != 1) { report_gles_warn(NULL, GLES_WARN_TEXTURE_RECT); } gr->target = GL_TEXTURE_2D; } if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D) { gr->target = GL_TEXTURE_2D; } if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D_ARRAY) { gr->target = GL_TEXTURE_2D_ARRAY; } glGenTextures(1, &gr->id); glBindTexture(gr->target, gr->id); debug_texture(__func__, gr); if (image_oes) { if (has_bit(gr->storage_bits, VREND_STORAGE_GL_IMMUTABLE) && has_feature(feat_egl_image_storage)) { glEGLImageTargetTexStorageEXT(gr->target, (GLeglImageOES) image_oes, NULL); } else if (has_feature(feat_egl_image_external)) { gr->storage_bits &= ~VREND_STORAGE_GL_IMMUTABLE; glEGLImageTargetTexture2DOES(gr->target, (GLeglImageOES) image_oes); } else { vrend_printf( ""missing GL_OES_EGL_image_external extensions\n""); glBindTexture(gr->target, 0); FREE(gr); return EINVAL; } } else { internalformat = tex_conv_table[format].internalformat; glformat = tex_conv_table[format].glformat; gltype = tex_conv_table[format].gltype; if (internalformat == 0) { vrend_printf(""unknown format is %d\n"", pr->format); glBindTexture(gr->target, 0); FREE(gt); return EINVAL; } if (pr->nr_samples > 0) { if (format_can_texture_storage) { if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) { glTexStorage2DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, GL_TRUE); } else { glTexStorage3DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, pr->array_size, GL_TRUE); } } else { if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) { glTexImage2DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, GL_TRUE); } else { glTexImage3DMultisample(gr->target, pr->nr_samples, internalformat, pr->width0, pr->height0, pr->array_size, GL_TRUE); } } } else if (gr->target == GL_TEXTURE_CUBE_MAP) { int i; if (format_can_texture_storage) glTexStorage2D(GL_TEXTURE_CUBE_MAP, pr->last_level + 1, internalformat, pr->width0, pr->height0); else { for (i = 0; i < 6; i++) { GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i; for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage2D(ctarget, level, internalformat, mwidth, mheight, 0, glformat, gltype, NULL); } } } } else if (gr->target == GL_TEXTURE_3D || gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) { if (format_can_texture_storage) { unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ? pr->array_size : pr->depth0; glTexStorage3D(gr->target, pr->last_level + 1, internalformat, pr->width0, pr->height0, depth_param); } else { for (level = 0; level <= pr->last_level; level++) { unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ? pr->array_size : u_minify(pr->depth0, level); unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage3D(gr->target, level, internalformat, mwidth, mheight, depth_param, 0, glformat, gltype, NULL); } } } else if (gr->target == GL_TEXTURE_1D && vrend_state.use_gles) { report_gles_missing_func(NULL, ""glTexImage1D""); } else if (gr->target == GL_TEXTURE_1D) { if (format_can_texture_storage) { glTexStorage1D(gr->target, pr->last_level + 1, internalformat, pr->width0); } else { for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); glTexImage1D(gr->target, level, internalformat, mwidth, 0, glformat, gltype, NULL); } } } else { if (format_can_texture_storage) glTexStorage2D(gr->target, pr->last_level + 1, internalformat, pr->width0, gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : pr->height0); else { for (level = 0; level <= pr->last_level; level++) { unsigned mwidth = u_minify(pr->width0, level); unsigned mheight = u_minify(pr->height0, level); glTexImage2D(gr->target, level, internalformat, mwidth, gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : mheight, 0, glformat, gltype, NULL); } } } } if (!format_can_texture_storage) { glTexParameteri(gr->target, GL_TEXTURE_BASE_LEVEL, 0); glTexParameteri(gr->target, GL_TEXTURE_MAX_LEVEL, pr->last_level); } glBindTexture(gr->target, 0); if (image_oes && gr->gbm_bo) { #ifdef ENABLE_GBM_ALLOCATION for (int i = 0; i < gbm_bo_get_plane_count(gr->gbm_bo) - 1; i++) { gr->aux_plane_egl_image[i] = virgl_egl_aux_plane_image_from_dmabuf(egl, gr->gbm_bo, i + 1); } #endif } gt->state.max_lod = -1; gt->cur_swizzle_r = gt->cur_swizzle_g = gt->cur_swizzle_b = gt->cur_swizzle_a = -1; gt->cur_base = -1; gt->cur_max = 10000; return 0; }"
"static int __dcache_readdir(struct file *file,  struct dir_context *ctx, u32 shared_gen) { struct ceph_file_info *fi = file->private_data; struct dentry *parent = file->f_dentry; struct inode *dir = parent->d_inode; struct list_head *p; struct dentry *dentry, *last; struct ceph_dentry_info *di; int err = 0; last = fi->dentry; fi->dentry = NULL; dout(""__dcache_readdir %p v%u at %llu (last %p)\n"", dir, shared_gen, ctx->pos, last); spin_lock(&parent->d_lock); if (ctx->pos == 2 || last == NULL || fpos_cmp(ctx->pos, ceph_dentry(last)->offset) < 0) { if (list_empty(&parent->d_subdirs)) goto out_unlock; p = parent->d_subdirs.prev; dout("" initial p %p/%p\n"", p->prev, p->next); } else { p = last->d_u.d_child.prev; } more: dentry = list_entry(p, struct dentry, d_u.d_child); di = ceph_dentry(dentry); while (1) { dout("" p %p/%p %s d_subdirs %p/%p\n"", p->prev, p->next, d_unhashed(dentry) ? ""!hashed"" : ""hashed"", parent->d_subdirs.prev, parent->d_subdirs.next); if (p == &parent->d_subdirs) { fi->flags |= CEPH_F_ATEND; goto out_unlock; } spin_lock_nested(&dentry->d_lock, DENTRY_D_LOCK_NESTED); if (di->lease_shared_gen == shared_gen && !d_unhashed(dentry) && dentry->d_inode && ceph_snap(dentry->d_inode) != CEPH_SNAPDIR && ceph_ino(dentry->d_inode) != CEPH_INO_CEPH && fpos_cmp(ctx->pos, di->offset) <= 0) break; dout("" skipping %p %.*s at %llu (%llu)%s%s\n"", dentry, dentry->d_name.len, dentry->d_name.name, di->offset, ctx->pos, d_unhashed(dentry) ? "" unhashed"" : """", !dentry->d_inode ? "" null"" : """"); spin_unlock(&dentry->d_lock); p = p->prev; dentry = list_entry(p, struct dentry, d_u.d_child); di = ceph_dentry(dentry); } dget_dlock(dentry); spin_unlock(&dentry->d_lock); spin_unlock(&parent->d_lock); if (!ceph_dir_is_complete(dir)) { dout("" lost dir complete on %p; falling back to mds\n"", dir); dput(dentry); err = -EAGAIN; goto out; } dout("" %llu (%llu) dentry %p %.*s %p\n"", di->offset, ctx->pos, dentry, dentry->d_name.len, dentry->d_name.name, dentry->d_inode); if (!dir_emit(ctx, dentry->d_name.name, dentry->d_name.len, ceph_translate_ino(dentry->d_sb, dentry->d_inode->i_ino), dentry->d_inode->i_mode >> 12)) { if (last) { fi->dentry = last; fi->next_offset = fpos_off(di->offset); } dput(dentry); return 0; } ctx->pos = di->offset + 1; if (last) dput(last); last = dentry; spin_lock(&parent->d_lock); p = p->prev; goto more; out_unlock: spin_unlock(&parent->d_lock); out: if (last) dput(last); return err; }"
"void DecodePngV2(OpKernelContext* context, StringPiece input) { int channel_bits = (data_type_ == DataType::DT_UINT8) ? 8 : 16; png::DecodeContext decode; OP_REQUIRES( context, png::CommonInitDecode(input, channels_, channel_bits, &decode), errors::InvalidArgument(""Invalid PNG. Failed to initialize decoder."")); const int width = static_cast<int>(decode.width); const int height = static_cast<int>(decode.height); const int64_t total_size = static_cast<int64_t>(width) * static_cast<int64_t>(height); if (width != static_cast<int64_t>(decode.width) || width <= 0 || width >= (1LL << 27) || height != static_cast<int64_t>(decode.height) || height <= 0 || height >= (1LL << 27) || total_size >= (1LL << 29)) { OP_REQUIRES(context, false, errors::InvalidArgument(""PNG size too large for int: "", decode.width, "" by "", decode.height)); } Tensor* output = nullptr; if (op_type_ == ""DecodeGif"") { OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({1, height, width, decode.channels}), &output)); } else { OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({height, width, decode.channels}), &output)); } if (op_type_ == ""DecodeBmp"") { OP_REQUIRES(context, false, errors::InvalidArgument( ""Trying to decode PNG format using DecodeBmp op. Use "" ""`decode_png` or `decode_image` instead."")); } else if (op_type_ == ""DecodeAndCropJpeg"") { OP_REQUIRES(context, false, errors::InvalidArgument( ""DecodeAndCropJpeg operation can run on JPEG only, but "" ""detected PNG."")); } if (data_type_ == DataType::DT_UINT8) { OP_REQUIRES( context, png::CommonFinishDecode( reinterpret_cast<png_bytep>(output->flat<uint8>().data()), decode.channels * width * sizeof(uint8), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); } else if (data_type_ == DataType::DT_UINT16) { OP_REQUIRES( context, png::CommonFinishDecode( reinterpret_cast<png_bytep>(output->flat<uint16>().data()), decode.channels * width * sizeof(uint16), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); } else if (data_type_ == DataType::DT_FLOAT) { std::unique_ptr<uint16[]> buffer( new uint16[height * width * decode.channels]); OP_REQUIRES( context, png::CommonFinishDecode(reinterpret_cast<png_bytep>(buffer.get()), decode.channels * width * sizeof(uint16), &decode), errors::InvalidArgument(""Invalid PNG data, size "", input.size())); const auto& device = context->eigen_device<Eigen::ThreadPoolDevice>(); TTypes<uint16, 3>::UnalignedConstTensor buf(buffer.get(), height, width, decode.channels); float scale = 1. / std::numeric_limits<uint16>::max(); output->tensor<float, 3>().device(device) = buf.cast<float>() * scale; } }"
"static void *__bpf_ringbuf_reserve(struct bpf_ringbuf *rb, u64 size) { unsigned long cons_pos, prod_pos, new_prod_pos, flags; u32 len, pg_off; struct bpf_ringbuf_hdr *hdr; if (unlikely(size > RINGBUF_MAX_RECORD_SZ)) return NULL; len = round_up(size + BPF_RINGBUF_HDR_SZ, 8); cons_pos = smp_load_acquire(&rb->consumer_pos); if (in_nmi()) { if (!spin_trylock_irqsave(&rb->spinlock, flags)) return NULL; } else { spin_lock_irqsave(&rb->spinlock, flags); } prod_pos = rb->producer_pos; new_prod_pos = prod_pos + len; if (new_prod_pos - cons_pos > rb->mask) { spin_unlock_irqrestore(&rb->spinlock, flags); return NULL; } hdr = (void *)rb->data + (prod_pos & rb->mask); pg_off = bpf_ringbuf_rec_pg_off(rb, hdr); hdr->len = size | BPF_RINGBUF_BUSY_BIT; hdr->pg_off = pg_off; smp_store_release(&rb->producer_pos, new_prod_pos); spin_unlock_irqrestore(&rb->spinlock, flags); return (void *)hdr + BPF_RINGBUF_HDR_SZ; }"
"char * XkbVModIndexText(XkbDescPtr xkb, unsigned ndx, unsigned format) { register int len; register Atom *vmodNames; char *rtrn; const char *tmp; char numBuf[20]; if (xkb && xkb->names) vmodNames = xkb->names->vmods; else vmodNames = NULL; tmp = NULL; if (ndx >= XkbNumVirtualMods) tmp = ""illegal""; else if (vmodNames && (vmodNames[ndx] != None)) tmp = NameForAtom(vmodNames[ndx]); if (tmp == NULL) { snprintf(numBuf, sizeof(numBuf), ""%d"", ndx); tmp = numBuf; } len = strlen(tmp) + 1; if (format == XkbCFile) len += 4; if (len >= BUFFER_SIZE) len = BUFFER_SIZE - 1; rtrn = tbGetBuffer(len); if (format == XkbCFile) { strcpy(rtrn, ""vmod_""); strncpy(&rtrn[5], tmp, len - 4); } else strncpy(rtrn, tmp, len); return rtrn; }"
"static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception) { char colorspace[MagickPathExtent], text[MagickPathExtent]; Image *image; long x_offset, y_offset; PixelInfo pixel; MagickBooleanType status; QuantumAny range; register ssize_t i, x; register Quantum *q; ssize_t count, type, y; unsigned long depth, height, max_value, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } (void) ResetMagickMemory(text,0,sizeof(text)); (void) ReadBlobString(image,text); if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); do { width=0; height=0; max_value=0; *colorspace='\0'; count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value, colorspace); if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); image->columns=width; image->rows=height; for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ; image->depth=depth; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); LocaleLower(colorspace); i=(ssize_t) strlen(colorspace)-1; image->alpha_trait=UndefinedPixelTrait; if ((i > 0) && (colorspace[i] == 'a')) { colorspace[i]='\0'; image->alpha_trait=BlendPixelTrait; } type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace); if (type < 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); (void) SetImageBackgroundColor(image,exception); (void) SetImageColorspace(image,(ColorspaceType) type,exception); GetPixelInfo(image,&pixel); range=GetQuantumRange(image->depth); for (y=0; y < (ssize_t) image->rows; y++) { double alpha, black, blue, green, red; red=0.0; green=0.0; blue=0.0; black=0.0; alpha=0.0; for (x=0; x < (ssize_t) image->columns; x++) { if (ReadBlobString(image,text) == (char *) NULL) break; switch (image->colorspace) { case GRAYColorspace: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&alpha); green=red; blue=red; break; } count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset, &y_offset,&red); green=red; blue=red; break;        } case CMYKColorspace: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&green,&blue,&black,&alpha); break; } count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset, &y_offset,&red,&green,&blue,&black); break; } default: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&green,&blue,&alpha); break; } count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset, &y_offset,&red,&green,&blue); break;        } } if (strchr(text,'%') != (char *) NULL) { red*=0.01*range; green*=0.01*range; blue*=0.01*range; black*=0.01*range; alpha*=0.01*range; } if (image->colorspace == LabColorspace) { green+=(range+1)/2.0; blue+=(range+1)/2.0; } pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5), range); pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5), range); pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5), range); pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5), range); pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5), range); q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1, exception); if (q == (Quantum *) NULL) continue; SetPixelViaPixelInfo(image,&pixel,q); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } } if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } (void) ReadBlobString(image,text); if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"static void rds_tcp_kill_sock(struct net *net) { struct rds_tcp_connection *tc, *_tc; struct sock *sk; LIST_HEAD(tmp_list); struct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid); rds_tcp_listen_stop(rtn->rds_tcp_listen_sock); rtn->rds_tcp_listen_sock = NULL; flush_work(&rtn->rds_tcp_accept_w); spin_lock_irq(&rds_tcp_conn_lock); list_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) { struct net *c_net = read_pnet(&tc->conn->c_net); if (net != c_net) continue; list_move_tail(&tc->t_tcp_node, &tmp_list); } spin_unlock_irq(&rds_tcp_conn_lock); list_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node) { sk = tc->t_sock->sk; sk->sk_prot->disconnect(sk, 0); tcp_done(sk); if (tc->conn->c_passive) rds_conn_destroy(tc->conn->c_passive); rds_conn_destroy(tc->conn); } }"
"void FilterManager::maybeEndDecode(bool end_stream) { ASSERT(!state_.remote_complete_); state_.remote_complete_ = end_stream; if (end_stream) { stream_info_.downstreamTiming().onLastDownstreamRxByteReceived(dispatcher().timeSource()); ENVOY_STREAM_LOG(debug, ""request end stream"", *this); } }"
"void Huff_Compress(msg_t *mbuf, int offset) { inti, ch, size; byteseq[65536]; byte*buffer; huff_thuff; size = mbuf->cursize - offset; buffer = mbuf->data+ + offset; if (size<=0) { return; } Com_Memset(&huff, 0, sizeof(huff_t)); huff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]); huff.tree->symbol = NYT; huff.tree->weight = 0; huff.lhead->next = huff.lhead->prev = NULL; huff.tree->parent = huff.tree->left = huff.tree->right = NULL; seq[0] = (size>>8); seq[1] = size&0xff; bloc = 16; for (i=0; i<size; i++ ) { ch = buffer[i]; Huff_transmit(&huff, ch, seq); Huff_addRef(&huff, (byte)ch); } bloc += 8; mbuf->cursize = (bloc>>3) + offset; Com_Memcpy(mbuf->data+offset, seq, (bloc>>3)); }"
"static void repl(void) { sds historyfile = NULL; int history = 0; char *line; int argc; sds *argv; config.interactive = 1; linenoiseSetMultiLine(1); linenoiseSetCompletionCallback(completionCallback); linenoiseSetHintsCallback(hintsCallback); linenoiseSetFreeHintsCallback(freeHintsCallback); if (isatty(fileno(stdin))) { historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT); if (historyfile != NULL) { history = 1; linenoiseHistoryLoad(historyfile); } cliLoadPreferences(); } cliRefreshPrompt(); while((line = linenoise(context ? config.prompt : ""not connected> "")) != NULL) { if (line[0] != '\0') { argv = cliSplitArgs(line,&argc); if (history) linenoiseHistoryAdd(line); if (historyfile) linenoiseHistorySave(historyfile); if (argv == NULL) { printf(""Invalid argument(s)\n""); linenoiseFree(line); continue; } else if (argc > 0) { if (strcasecmp(argv[0],""quit"") == 0 || strcasecmp(argv[0],""exit"") == 0) { exit(0); } else if (argv[0][0] == ':') { cliSetPreferences(argv,argc,1); continue; } else if (strcasecmp(argv[0],""restart"") == 0) { if (config.eval) { config.eval_ldb = 1; config.output = OUTPUT_RAW; return;  } else { printf(""Use 'restart' only in Lua debugging mode.""); } } else if (argc == 3 && !strcasecmp(argv[0],""connect"")) { sdsfree(config.hostip); config.hostip = sdsnew(argv[1]); config.hostport = atoi(argv[2]); cliRefreshPrompt(); cliConnect(1); } else if (argc == 1 && !strcasecmp(argv[0],""clear"")) { linenoiseClearScreen(); } else { long long start_time = mstime(), elapsed; int repeat, skipargs = 0; repeat = atoi(argv[0]); if (argc > 1 && repeat) { skipargs = 1; } else { repeat = 1; } issueCommandRepeat(argc-skipargs, argv+skipargs, repeat); if (config.eval_ldb_end) { config.eval_ldb_end = 0; cliReadReply(0); printf(""\n(Lua debugging session ended%s)\n\n"", config.eval_ldb_sync ? """" : "" -- dataset changes rolled back""); } elapsed = mstime()-start_time; if (elapsed >= 500) { printf(""(%.2fs)\n"",(double)elapsed/1000); } } } sdsfreesplitres(argv,argc); } linenoiseFree(line); } exit(0); }"
"static void *createArrayObject(const redisReadTask *task, size_t elements) { redisReply *r, *parent; r = createReplyObject(task->type); if (r == NULL) return NULL; if (elements > 0) { r->element = hi_calloc(elements,sizeof(redisReply*)); if (r->element == NULL) { freeReplyObject(r); return NULL; } } r->elements = elements; if (task->parent) { parent = task->parent->obj; assert(parent->type == REDIS_REPLY_ARRAY || parent->type == REDIS_REPLY_MAP || parent->type == REDIS_REPLY_SET || parent->type == REDIS_REPLY_PUSH); parent->element[task->idx] = r; } return r; }"
"static void pci_vtblk_proc(struct pci_vtblk_softc *sc, struct vqueue_info *vq) { struct virtio_blk_hdr *vbh; struct virtio_blk_discard_write_zeroes *vbdiscard; struct pci_vtblk_ioreq *io; int i, n; int err; ssize_t iolen; int expectro, type; struct iovec iov[BLOCKIF_IOV_MAX + 2]; uint16_t idx, flags[BLOCKIF_IOV_MAX + 2]; n = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags); assert(n >= 2 && n <= BLOCKIF_IOV_MAX + 2); io = &sc->vbsc_ios[idx]; assert((flags[0] & VRING_DESC_F_WRITE) == 0); assert(iov[0].iov_len == sizeof(struct virtio_blk_hdr)); vbh = iov[0].iov_base; memcpy(&io->io_req.br_iov, &iov[1], sizeof(struct iovec) * ((size_t)n - 2)); io->io_req.br_iovcnt = n - 2; io->io_req.br_offset = (off_t)(vbh->vbh_sector * DEV_BSIZE); io->io_status = iov[--n].iov_base; assert(iov[n].iov_len == 1); assert(flags[n] & VRING_DESC_F_WRITE); type = vbh->vbh_type & ~VBH_FLAG_BARRIER; expectro = (type == VBH_OP_WRITE) || (type == VBH_OP_DISCARD); iolen = 0; for (i = 1; i < n; i++) { assert(((flags[i] & VRING_DESC_F_WRITE) == 0) == expectro); iolen += iov[i].iov_len; } io->io_req.br_resid = iolen; DPRINTF((""virtio-block: %s op, %zd bytes, %d segs\n\r"", print_vbh_op(type), iolen, i - 1)); switch (type) { case VBH_OP_READ: err = blockif_read(sc->bc, &io->io_req); break; case VBH_OP_WRITE: err = blockif_write(sc->bc, &io->io_req); break; case VBH_OP_DISCARD: assert(iov[1].iov_len = sizeof(struct virtio_blk_discard_write_zeroes)); assert(n == 2); vbdiscard = iov[1].iov_base; io->io_req.br_offset = (off_t) vbdiscard->sector * DEV_BSIZE; io->io_req.br_resid = vbdiscard->num_sectors * DEV_BSIZE; err = blockif_delete(sc->bc, &io->io_req); break; case VBH_OP_FLUSH: case VBH_OP_FLUSH_OUT: err = blockif_flush(sc->bc, &io->io_req); break; case VBH_OP_IDENT: memset(iov[1].iov_base, 0, iov[1].iov_len); strncpy(iov[1].iov_base, sc->vbsc_ident, MIN(iov[1].iov_len, sizeof(sc->vbsc_ident))); pci_vtblk_done_locked(&io->io_req, 0); return; default: pci_vtblk_done_locked(&io->io_req, EOPNOTSUPP); return; } assert(err == 0); }"
"static int prealloc_elems_and_freelist(struct bpf_stack_map *smap) { u32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size; int err; smap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries, smap->map.numa_node); if (!smap->elems) return -ENOMEM; err = pcpu_freelist_init(&smap->freelist); if (err) goto free_elems; pcpu_freelist_populate(&smap->freelist, smap->elems, elem_size, smap->map.max_entries); return 0; free_elems: bpf_map_area_free(smap->elems); return err; }"
"int expand_dns_name(tvbuff_t *tvb, int offset, int max_len, int dns_data_offset, const guchar **name) { int     start_offset    = offset; guchar *np; int     len             = -1; int     chars_processed = 0; int     data_size       = tvb_reported_length_remaining(tvb, dns_data_offset); int     component_len; int     indir_offset; int     maxname; const int min_len = 1;         maxname=MAXDNAME; np=(guchar *)wmem_alloc(wmem_packet_scope(), maxname); *name=np; maxname--;    for (;;) { if (max_len && offset - start_offset > max_len - 1) { break; } component_len = tvb_get_guint8(tvb, offset); offset++; if (component_len == 0) { break; } chars_processed++; switch (component_len & 0xc0) { case 0x00: if (np != *name) { if (maxname > 0) { *np++ = '.'; maxname--; } } while (component_len > 0) { if (max_len && offset - start_offset > max_len - 1) { THROW(ReportedBoundsError); } if (maxname > 0) { *np++ = tvb_get_guint8(tvb, offset); maxname--; } component_len--; offset++; chars_processed++; } break; case 0x40: switch (component_len & 0x3f) { case 0x01: { int bit_count; int label_len; int print_len; bit_count = tvb_get_guint8(tvb, offset); offset++; label_len = (bit_count - 1) / 8 + 1; if (maxname > 0) { print_len = g_snprintf(np, maxname + 1, ""\\[x""); if (print_len <= maxname) { np      += print_len; maxname -= print_len; } else { maxname = 0; } } while (label_len--) { if (maxname > 0) { print_len = g_snprintf(np, maxname + 1, ""%02x"", tvb_get_guint8(tvb, offset)); if (print_len <= maxname) { np      += print_len; maxname -= print_len; } else { maxname = 0; } } offset++; } if (maxname > 0) { print_len = g_snprintf(np, maxname + 1, ""/%d]"", bit_count); if (print_len <= maxname) { np      += print_len; maxname -= print_len; } else { maxname = 0; } } } break; default: *name=""<Unknown extended label>""; len = offset - start_offset; if (len < min_len) { THROW(ReportedBoundsError); } return len; } break; case 0x80: THROW(ReportedBoundsError); break; case 0xc0: indir_offset = dns_data_offset + (((component_len & ~0xc0) << 8) | tvb_get_guint8(tvb, offset)); offset++; chars_processed++; if (len < 0) { len = offset - start_offset; } if (chars_processed >= data_size) { *name=""<Name contains a pointer that loops>""; if (len < min_len) { THROW(ReportedBoundsError); } return len; } offset = indir_offset; break;    } } *np = '\0'; if (len < 0) { len = offset - start_offset; } if (len < min_len) { THROW(ReportedBoundsError); } return len; }"
"static void g_socket_client_connected_callback (GObject      *source, GAsyncResult *result, gpointer      user_data) { ConnectionAttempt *attempt = user_data; GSocketClientAsyncConnectData *data = attempt->data; GSList *l; GError *error = NULL; GProxy *proxy; const gchar *protocol; if (data && g_task_return_error_if_cancelled (data->task)) { g_object_unref (data->task); connection_attempt_unref (attempt); return; } if (attempt->timeout_source) { g_source_destroy (attempt->timeout_source); g_clear_pointer (&attempt->timeout_source, g_source_unref); } if (!g_socket_connection_connect_finish (G_SOCKET_CONNECTION (source), result, &error)) { if (!g_cancellable_is_cancelled (attempt->cancellable)) { clarify_connect_error (error, data->connectable, attempt->address); set_last_error (data, error); } else g_clear_error (&error); if (data) { connection_attempt_remove (attempt); enumerator_next_async (data); } else connection_attempt_unref (attempt); return; } data->socket = g_steal_pointer (&attempt->socket); data->connection = g_steal_pointer (&attempt->connection); for (l = data->connection_attempts; l; l = g_slist_next (l)) { ConnectionAttempt *attempt_entry = l->data; g_cancellable_cancel (attempt_entry->cancellable); attempt_entry->data = NULL; connection_attempt_unref (attempt_entry); } g_slist_free (data->connection_attempts); data->connection_attempts = NULL; connection_attempt_unref (attempt); g_socket_connection_set_cached_remote_address ((GSocketConnection*)data->connection, NULL); g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_CONNECTED, data->connectable, data->connection); g_socket_set_blocking (data->socket, TRUE); if (!data->proxy_addr) { g_socket_client_tls_handshake (data); return; } protocol = g_proxy_address_get_protocol (data->proxy_addr); if (!G_IS_TCP_CONNECTION (data->connection)) { g_critical (""Trying to proxy over non-TCP connection, this is "" ""most likely a bug in GLib IO library.""); g_set_error_literal (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED, _(""Proxying over a non-TCP connection is not supported."")); enumerator_next_async (data); } else if (g_hash_table_contains (data->client->priv->app_proxies, protocol)) { g_socket_client_async_connect_complete (data); } else if ((proxy = g_proxy_get_default_for_protocol (protocol))) { g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_PROXY_NEGOTIATING, data->connectable, data->connection); g_proxy_connect_async (proxy, data->connection, data->proxy_addr, g_task_get_cancellable (data->task), g_socket_client_proxy_connect_callback, data); g_object_unref (proxy); } else { g_clear_error (&data->last_error); g_set_error (&data->last_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED, _(""Proxy protocol %s is not supported.""), protocol); enumerator_next_async (data); } }"
"void HelperApp::setUp() { QStringList args = QCoreApplication::arguments(); QString server; int pos; if ((pos = args.indexOf(""--socket"")) >= 0) { if (pos >= args.length() - 1) { qCritical() << ""This application is not supposed to be executed manually""; exit(Auth::HELPER_OTHER_ERROR); return; } server = args[pos + 1]; } if ((pos = args.indexOf(""--id"")) >= 0) { if (pos >= args.length() - 1) { qCritical() << ""This application is not supposed to be executed manually""; exit(Auth::HELPER_OTHER_ERROR); return; } m_id = QString(args[pos + 1]).toLongLong(); } if ((pos = args.indexOf(""--start"")) >= 0) { if (pos >= args.length() - 1) { qCritical() << ""This application is not supposed to be executed manually""; exit(Auth::HELPER_OTHER_ERROR); return; } m_session->setPath(args[pos + 1]); } if ((pos = args.indexOf(""--user"")) >= 0) { if (pos >= args.length() - 1) { qCritical() << ""This application is not supposed to be executed manually""; exit(Auth::HELPER_OTHER_ERROR); return; } m_user = args[pos + 1]; } if ((pos = args.indexOf(""--autologin"")) >= 0) { m_backend->setAutologin(true); } if (server.isEmpty() || m_id <= 0) { qCritical() << ""This application is not supposed to be executed manually""; exit(Auth::HELPER_OTHER_ERROR); return; } connect(m_socket, SIGNAL(connected()), this, SLOT(doAuth())); connect(m_session, SIGNAL(finished(int)), this, SLOT(sessionFinished(int))); m_socket->connectToServer(server, QIODevice::ReadWrite | QIODevice::Unbuffered); }"
"static void nv_replace(cmdarg_T *cap) { char_u*ptr; inthad_ctrl_v; longn; if (checkclearop(cap->oap)) return; #ifdef FEAT_JOB_CHANNEL if (bt_prompt(curbuf) && !prompt_curpos_editable()) { clearopbeep(cap->oap); return; } #endif if (cap->nchar == Ctrl_V) { had_ctrl_v = Ctrl_V; cap->nchar = get_literal(FALSE); if (cap->nchar > DEL) had_ctrl_v = NUL; } else had_ctrl_v = NUL; if (IS_SPECIAL(cap->nchar)) { clearopbeep(cap->oap); return; } if (VIsual_active) { if (got_int) reset_VIsual(); if (had_ctrl_v) { if (cap->nchar == CAR) cap->nchar = REPLACE_CR_NCHAR; else if (cap->nchar == NL) cap->nchar = REPLACE_NL_NCHAR; } nv_operator(cap); return; } if (virtual_active()) { if (u_save_cursor() == FAIL) return; if (gchar_cursor() == NUL) { coladvance_force((colnr_T)(getviscol() + cap->count1)); curwin->w_cursor.col -= cap->count1; } else if (gchar_cursor() == TAB) coladvance_force(getviscol()); } ptr = ml_get_cursor(); if (STRLEN(ptr) < (unsigned)cap->count1 || (has_mbyte && mb_charlen(ptr) < cap->count1)) { clearopbeep(cap->oap); return; } if (had_ctrl_v != Ctrl_V && cap->nchar == '\t' && (curbuf->b_p_et || p_sta)) { stuffnumReadbuff(cap->count1); stuffcharReadbuff('R'); stuffcharReadbuff('\t'); stuffcharReadbuff(ESC); return; } if (u_save_cursor() == FAIL) return; if (had_ctrl_v != Ctrl_V && (cap->nchar == '\r' || cap->nchar == '\n')) { (void)del_chars(cap->count1, FALSE);stuffcharReadbuff('\r'); stuffcharReadbuff(ESC); invoke_edit(cap, TRUE, 'r', FALSE); } else { prep_redo(cap->oap->regname, cap->count1, NUL, 'r', NUL, had_ctrl_v, cap->nchar); curbuf->b_op_start = curwin->w_cursor; if (has_mbyte) { intold_State = State; if (cap->ncharC1 != 0) AppendCharToRedobuff(cap->ncharC1); if (cap->ncharC2 != 0) AppendCharToRedobuff(cap->ncharC2); for (n = cap->count1; n > 0; --n) { State = REPLACE; if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ins_char(c); else ++curwin->w_cursor.col; } else ins_char(cap->nchar); State = old_State; if (cap->ncharC1 != 0) ins_char(cap->ncharC1); if (cap->ncharC2 != 0) ins_char(cap->ncharC2); } } else { for (n = cap->count1; n > 0; --n) { ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE); if (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y) { int c = ins_copychar(curwin->w_cursor.lnum + (cap->nchar == Ctrl_Y ? -1 : 1)); if (c != NUL) ptr[curwin->w_cursor.col] = c; } else ptr[curwin->w_cursor.col] = cap->nchar; if (p_sm && msg_silent == 0) showmatch(cap->nchar); ++curwin->w_cursor.col; } #ifdef FEAT_NETBEANS_INTG if (netbeans_active()) { colnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1); netbeans_removed(curbuf, curwin->w_cursor.lnum, start, (long)cap->count1); netbeans_inserted(curbuf, curwin->w_cursor.lnum, start, &ptr[start], (int)cap->count1); } #endif changed_bytes(curwin->w_cursor.lnum, (colnr_T)(curwin->w_cursor.col - cap->count1)); } --curwin->w_cursor.col;    if (has_mbyte) mb_adjust_cursor(); curbuf->b_op_end = curwin->w_cursor; curwin->w_set_curswant = TRUE; set_last_insert(cap->nchar); } }"
"void arch_do_multicall_call(struct mc_state *state) { if ( !is_pv_32bit_vcpu(current) ) { struct multicall_entry *call = &state->call; if ( (call->op < ARRAY_SIZE(pv_hypercall_table)) && pv_hypercall_table[call->op].native ) call->result = pv_hypercall_table[call->op].native( call->args[0], call->args[1], call->args[2], call->args[3], call->args[4], call->args[5]); else call->result = -ENOSYS; } #ifdef CONFIG_COMPAT else { struct compat_multicall_entry *call = &state->compat_call; if ( (call->op < ARRAY_SIZE(pv_hypercall_table)) && pv_hypercall_table[call->op].compat ) call->result = pv_hypercall_table[call->op].compat( call->args[0], call->args[1], call->args[2], call->args[3], call->args[4], call->args[5]); else call->result = -ENOSYS; } #endif }"
"GF_Err gnrv_box_dump(GF_Box *a, FILE * trace) { GF_GenericVisualSampleEntryBox *p = (GF_GenericVisualSampleEntryBox *)a; if (p->EntryType) { a->type = p->EntryType; if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) a->type = GF_4CC('u','k','n','w'); } gf_isom_box_dump_start(a, ""VisualSampleDescriptionBox"", trace); gf_fprintf(trace, ""DataReferenceIndex=\""%d\"" Version=\""%d\"" Revision=\""%d\"" Vendor=\""%d\"" TemporalQuality=\""%d\"" SpacialQuality=\""%d\"" Width=\""%d\"" Height=\""%d\"" HorizontalResolution=\""%d\"" VerticalResolution=\""%d\"" CompressorName=\""%s\"" BitDepth=\""%d\"""", p->dataReferenceIndex, p->version, p->revision, p->vendor, p->temporal_quality, p->spatial_quality, p->Width, p->Height, p->horiz_res, p->vert_res, isalnum(p->compressor_name[0]) ? p->compressor_name : p->compressor_name+1, p->bit_depth); a->type = GF_ISOM_BOX_TYPE_GNRV; gnr_dump_exts(p->data, p->data_size, trace); gf_isom_box_dump_done(""VisualSampleDescriptionBox"", a, trace); return GF_OK; }"
"static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in) { jpc_siz_t *siz = &ms->parms.siz; unsigned int i; uint_fast8_t tmp; cstate = 0; if (jpc_getuint16(in, &siz->caps) || jpc_getuint32(in, &siz->width) || jpc_getuint32(in, &siz->height) || jpc_getuint32(in, &siz->xoff) || jpc_getuint32(in, &siz->yoff) || jpc_getuint32(in, &siz->tilewidth) || jpc_getuint32(in, &siz->tileheight) || jpc_getuint32(in, &siz->tilexoff) || jpc_getuint32(in, &siz->tileyoff) || jpc_getuint16(in, &siz->numcomps)) { return -1; } if (!siz->width || !siz->height || !siz->tilewidth || !siz->tileheight || !siz->numcomps || siz->numcomps > 16384) { return -1; } if (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) { return -1; } for (i = 0; i < siz->numcomps; ++i) { if (jpc_getuint8(in, &tmp) || jpc_getuint8(in, &siz->comps[i].hsamp) || jpc_getuint8(in, &siz->comps[i].vsamp)) { jas_free(siz->comps); return -1; } if (siz->comps[i].hsamp == 0 || siz->comps[i].hsamp > 255) { jas_eprintf(""invalid XRsiz value %d\n"", siz->comps[i].hsamp); jas_free(siz->comps); return -1; } if (siz->comps[i].vsamp == 0 || siz->comps[i].vsamp > 255) { jas_eprintf(""invalid YRsiz value %d\n"", siz->comps[i].vsamp); jas_free(siz->comps); return -1; } siz->comps[i].sgnd = (tmp >> 7) & 1; siz->comps[i].prec = (tmp & 0x7f) + 1; } if (jas_stream_eof(in)) { jas_free(siz->comps); return -1; } return 0; }"
"void __ip_select_ident(struct net *net, struct iphdr *iph, int segs) { static u32 ip_idents_hashrnd __read_mostly; u32 hash, id; net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd)); hash = jhash_3words((__force u32)iph->daddr, (__force u32)iph->saddr, iph->protocol ^ net_hash_mix(net), ip_idents_hashrnd); id = ip_idents_reserve(hash, segs); iph->id = htons(id); }"
"static void tsl_copy_or_move_chunk_proc(FunctionCallInfo fcinfo, bool delete_on_src_node) { Oid chunk_id = PG_ARGISNULL(0) ? InvalidOid : PG_GETARG_OID(0); const char *src_node_name = PG_ARGISNULL(1) ? NULL : NameStr(*PG_GETARG_NAME(1)); const char *dst_node_name = PG_ARGISNULL(2) ? NULL : NameStr(*PG_GETARG_NAME(2)); const char *op_id = PG_ARGISNULL(3) ? NULL : NameStr(*PG_GETARG_NAME(3)); int rc; bool nonatomic = fcinfo->context && IsA(fcinfo->context, CallContext) && !castNode(CallContext, fcinfo->context)->atomic; TS_PREVENT_FUNC_IF_READ_ONLY(); PreventInTransactionBlock(true, get_func_name(FC_FN_OID(fcinfo))); if (src_node_name == NULL || dst_node_name == NULL) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid source or destination node""))); if (!OidIsValid(chunk_id)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(""invalid chunk""))); if ((rc = SPI_connect_ext(nonatomic ? SPI_OPT_NONATOMIC : 0)) != SPI_OK_CONNECT) elog(ERROR, ""SPI_connect failed: %s"", SPI_result_code_string(rc)); chunk_copy(chunk_id, src_node_name, dst_node_name, op_id, delete_on_src_node); if ((rc = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(rc)); }"
"void igraph_i_graphml_attribute_data_finish(struct igraph_i_graphml_parser_state *state) { const char *key=fromXmlChar(state->data_key); igraph_attribute_elemtype_t type=state->data_type; igraph_trie_t *trie=0; igraph_vector_ptr_t *ptrvector=0; igraph_i_graphml_attribute_record_t *graphmlrec; igraph_attribute_record_t *rec; long int recid, id=0; int ret; switch (type) { case IGRAPH_ATTRIBUTE_GRAPH: trie=&state->g_names; ptrvector=&state->g_attrs; id=0; break; case IGRAPH_ATTRIBUTE_VERTEX: trie=&state->v_names; ptrvector=&state->v_attrs; id=state->act_node; break; case IGRAPH_ATTRIBUTE_EDGE: trie=&state->e_names; ptrvector=&state->e_attrs; id=igraph_vector_size(&state->edgelist)/2-1;  break; default: break; } igraph_trie_check(trie, key, &recid); if (recid < 0) { igraph_warningf( ""unknown attribute key '%s' in a <data> tag, ignoring attribute"", __FILE__, __LINE__, 0, key ); igraph_Free(state->data_char); return; } graphmlrec=VECTOR(*ptrvector)[recid]; rec=&graphmlrec->record; switch (rec->type) { igraph_vector_bool_t *boolvec; igraph_vector_t *vec; igraph_strvector_t *strvec; long int s, i; const char* strvalue; case IGRAPH_ATTRIBUTE_BOOLEAN: boolvec=(igraph_vector_bool_t *)rec->value; s=igraph_vector_bool_size(boolvec); if (id >= s) { ret=igraph_vector_bool_resize(boolvec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } for (i=s; i<id; i++) { VECTOR(*boolvec)[i] = graphmlrec->default_value.as_boolean; } } VECTOR(*boolvec)[id] = igraph_i_graphml_parse_boolean(state->data_char, graphmlrec->default_value.as_boolean); break; case IGRAPH_ATTRIBUTE_NUMERIC: vec=(igraph_vector_t *)rec->value; s=igraph_vector_size(vec); if (id >= s) { ret=igraph_vector_resize(vec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } for (i=s; i<id; i++) { VECTOR(*vec)[i] = graphmlrec->default_value.as_numeric; } } VECTOR(*vec)[id] = igraph_i_graphml_parse_numeric(state->data_char, graphmlrec->default_value.as_numeric); break; case IGRAPH_ATTRIBUTE_STRING: strvec=(igraph_strvector_t *)rec->value; s=igraph_strvector_size(strvec); if (id >= s) { ret=igraph_strvector_resize(strvec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } strvalue = graphmlrec->default_value.as_string; for (i=s;i<id;i++) { igraph_strvector_set(strvec, i, strvalue); } } if (state->data_char) { strvalue = state->data_char; } else { strvalue = graphmlrec->default_value.as_string; } ret=igraph_strvector_set(strvec, id, strvalue); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } break; default: break; } if (state->data_char) { igraph_Free(state->data_char); } }"
"static bool __io_worker_unuse(struct io_wqe *wqe, struct io_worker *worker) { bool dropped_lock = false; if (current->files != worker->restore_files) { __acquire(&wqe->lock); spin_unlock_irq(&wqe->lock); dropped_lock = true; task_lock(current); current->files = worker->restore_files; task_unlock(current); } if (worker->mm) { if (!dropped_lock) { __acquire(&wqe->lock); spin_unlock_irq(&wqe->lock); dropped_lock = true; } __set_current_state(TASK_RUNNING); set_fs(KERNEL_DS); unuse_mm(worker->mm); mmput(worker->mm); worker->mm = NULL; } return dropped_lock; }"
"static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize) { BYTE c; BYTE flags; int extra; int opIndex; int haveBits; int inPrefix; UINT32 count; UINT32 distance; BYTE* pbSegment; size_t cbSegment = segmentSize - 1; if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1)) return FALSE; Stream_Read_UINT8(stream, flags);  zgfx->OutputCount = 0; pbSegment = Stream_Pointer(stream); Stream_Seek(stream, cbSegment); if (!(flags & PACKET_COMPRESSED)) { zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment); CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment); zgfx->OutputCount = cbSegment; return TRUE; } zgfx->pbInputCurrent = pbSegment; zgfx->pbInputEnd = &pbSegment[cbSegment - 1]; zgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd; zgfx->cBitsCurrent = 0; zgfx->BitsCurrent = 0; while (zgfx->cBitsRemaining) { haveBits = 0; inPrefix = 0; for (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++) { while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength) { zgfx_GetBits(zgfx, 1); inPrefix = (inPrefix << 1) + zgfx->bits; haveBits++; } if (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode) { if (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0) { zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits); c = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits); zgfx->HistoryBuffer[zgfx->HistoryIndex] = c; if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize) zgfx->HistoryIndex = 0; zgfx->OutputBuffer[zgfx->OutputCount++] = c; } else { zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits); distance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits; if (distance != 0) { zgfx_GetBits(zgfx, 1); if (zgfx->bits == 0) { count = 3; } else { count = 4; extra = 2; zgfx_GetBits(zgfx, 1); while (zgfx->bits == 1) { count *= 2; extra++; zgfx_GetBits(zgfx, 1); } zgfx_GetBits(zgfx, extra); count += zgfx->bits; } zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count); zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count); zgfx->OutputCount += count; } else { zgfx_GetBits(zgfx, 15); count = zgfx->bits; zgfx->cBitsRemaining -= zgfx->cBitsCurrent; zgfx->cBitsCurrent = 0; zgfx->BitsCurrent = 0; CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count); zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count); zgfx->pbInputCurrent += count; zgfx->cBitsRemaining -= (8 * count); zgfx->OutputCount += count; } } break; } } } return TRUE; }"
"int yr_object_array_set_item( YR_OBJECT* object, YR_OBJECT* item, int index) { YR_OBJECT_ARRAY* array; int i; int count; assert(index >= 0); assert(object->type == OBJECT_TYPE_ARRAY); array = object_as_array(object); if (array->items == NULL) { count = yr_max(64, (index + 1) * 2); array->items = (YR_ARRAY_ITEMS*) yr_malloc( sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*)); if (array->items == NULL) return ERROR_INSUFFICIENT_MEMORY; memset(array->items->objects, 0, count * sizeof(YR_OBJECT*)); array->items->count = count; } else if (index >= array->items->count) { count = array->items->count * 2; array->items = (YR_ARRAY_ITEMS*) yr_realloc( array->items, sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*)); if (array->items == NULL) return ERROR_INSUFFICIENT_MEMORY; for (i = array->items->count; i < count; i++) array->items->objects[i] = NULL; array->items->count = count; } item->parent = object; array->items->objects[index] = item; return ERROR_SUCCESS; }"
"int __get_user_pages_fast(unsigned long start, int nr_pages, int write, struct page **pages) { unsigned long len, end; unsigned long flags; int nr_pinned = 0; unsigned int gup_flags = FOLL_GET; if (write) gup_flags |= FOLL_WRITE; start = untagged_addr(start) & PAGE_MASK; len = (unsigned long) nr_pages << PAGE_SHIFT; end = start + len; if (end <= start) return 0; if (unlikely(!access_ok((void __user *)start, len))) return 0; if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) && gup_fast_permitted(start, end)) { local_irq_save(flags); gup_pgd_range(start, end, gup_flags, pages, &nr_pinned); local_irq_restore(flags); } return nr_pinned; }"
"static bool ATHEME_FATTR_WUR sasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len) { struct sasl_output_buf outbuf = { .buf    = NULL, .len    = 0, .flags  = ASASL_OUTFLAG_NONE, }; enum sasl_mechanism_result rc; bool have_responded = false; if (! p->mechptr && ! len) { if (! (p->mechptr = sasl_mechanism_find(buf))) { (void) sasl_sts(p->uid, 'M', sasl_mechlist_string); return false; } (void) sasl_sourceinfo_recreate(p); if (p->mechptr->mech_start) rc = p->mechptr->mech_start(p, &outbuf); else rc = ASASL_MRESULT_CONTINUE; } else if (! p->mechptr) { (void) slog(LG_DEBUG, ""%s: session has no mechanism?"", MOWGLI_FUNC_NAME); return false; } else { rc = sasl_process_input(p, buf, len, &outbuf); } if (outbuf.buf && outbuf.len) { if (! sasl_process_output(p, &outbuf)) return false; have_responded = true; } p->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION; switch (rc) { case ASASL_MRESULT_CONTINUE: { if (! have_responded) (void) sasl_sts(p->uid, 'C', ""+""); return true; } case ASASL_MRESULT_SUCCESS: { struct user *const u = user_find(p->uid); struct myuser *const mu = sasl_user_can_login(p); if (! mu) { if (u) (void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR); return false; } if (u && ! sasl_handle_login(p, u, mu)) return false; return sasl_session_success(p, mu, (u != NULL)); } case ASASL_MRESULT_FAILURE: { if (*p->authceid) { struct myuser *const mu = myuser_find_uid(p->authceid); if (! mu) return false; (void) sasl_sourceinfo_recreate(p); (void) logcommand(p->si, CMDLOG_LOGIN, ""failed LOGIN (%s) to \2%s\2 (bad password)"", p->mechptr->name, entity(mu)->name); (void) bad_password(p->si, mu); } return false; } case ASASL_MRESULT_ERROR: return false; } return false; }"
"int new_guest_cr3(mfn_t mfn) { struct vcpu *curr = current; struct domain *d = curr->domain; int rc; mfn_t old_base_mfn; if ( is_pv_32bit_domain(d) ) { mfn_t gt_mfn = pagetable_get_mfn(curr->arch.guest_table); l4_pgentry_t *pl4e = map_domain_page(gt_mfn); rc = mod_l4_entry(pl4e, l4e_from_mfn(mfn, (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)), mfn_x(gt_mfn), 0, curr); unmap_domain_page(pl4e); switch ( rc ) { case 0: break; case -EINTR: case -ERESTART: return -ERESTART; default: gdprintk(XENLOG_WARNING, ""Error while installing new compat baseptr %"" PRI_mfn ""\n"", mfn_x(mfn)); return rc; } invalidate_shadow_ldt(curr, 0); write_ptbase(curr); return 0; } rc = put_old_guest_table(curr); if ( unlikely(rc) ) return rc; old_base_mfn = pagetable_get_mfn(curr->arch.guest_table); if ( mfn_eq(old_base_mfn, mfn) ) { write_ptbase(curr); return 0; } rc = paging_mode_refcounts(d) ? (get_page_from_mfn(mfn, d) ? 0 : -EINVAL) : get_page_and_type_from_mfn(mfn, PGT_root_page_table, d, 0, 1); switch ( rc ) { case 0: break; case -EINTR: case -ERESTART: return -ERESTART; default: gdprintk(XENLOG_WARNING, ""Error while installing new baseptr %"" PRI_mfn ""\n"", mfn_x(mfn)); return rc; } invalidate_shadow_ldt(curr, 0); if ( !VM_ASSIST(d, m2p_strict) && !paging_mode_refcounts(d) ) fill_ro_mpt(mfn); curr->arch.guest_table = pagetable_from_mfn(mfn); update_cr3(curr); write_ptbase(curr); if ( likely(mfn_x(old_base_mfn) != 0) ) { struct page_info *page = mfn_to_page(old_base_mfn); if ( paging_mode_refcounts(d) ) put_page(page); else switch ( rc = put_page_and_type_preemptible(page) ) { case -EINTR: rc = -ERESTART; case -ERESTART: curr->arch.old_guest_table = page; break; default: BUG_ON(rc); break; } } return rc; }"
"static inline int init_new_context(struct task_struct *tsk, struct mm_struct *mm) { cpumask_clear(&mm->context.cpu_attach_mask); atomic_set(&mm->context.attach_count, 0); mm->context.flush_mm = 0; mm->context.asce_bits = _ASCE_TABLE_LENGTH | _ASCE_USER_BITS; mm->context.asce_bits |= _ASCE_TYPE_REGION3; #ifdef CONFIG_PGSTE mm->context.alloc_pgste = page_table_allocate_pgste; mm->context.has_pgste = 0; mm->context.use_skey = 0; #endif mm->context.asce_limit = STACK_TOP_MAX; crst_table_init((unsigned long *) mm->pgd, pgd_entry_type(mm)); return 0; }"
"int snd_timer_open(struct snd_timer_instance **ti, char *owner, struct snd_timer_id *tid, unsigned int slave_id) { struct snd_timer *timer; struct snd_timer_instance *timeri = NULL; struct device *card_dev_to_put = NULL; int err; mutex_lock(&register_mutex); if (tid->dev_class == SNDRV_TIMER_CLASS_SLAVE) { if (tid->dev_sclass <= SNDRV_TIMER_SCLASS_NONE || tid->dev_sclass > SNDRV_TIMER_SCLASS_OSS_SEQUENCER) { pr_debug(""ALSA: timer: invalid slave class %i\n"", tid->dev_sclass); err = -EINVAL; goto unlock; } timeri = snd_timer_instance_new(owner, NULL); if (!timeri) { err = -ENOMEM; goto unlock; } timeri->slave_class = tid->dev_sclass; timeri->slave_id = tid->device; timeri->flags |= SNDRV_TIMER_IFLG_SLAVE; list_add_tail(&timeri->open_list, &snd_timer_slave_list); err = snd_timer_check_slave(timeri); if (err < 0) { snd_timer_close_locked(timeri, &card_dev_to_put); timeri = NULL; } goto unlock; } timer = snd_timer_find(tid); #ifdef CONFIG_MODULES if (!timer) { mutex_unlock(&register_mutex); snd_timer_request(tid); mutex_lock(&register_mutex); timer = snd_timer_find(tid); } #endif if (!timer) { err = -ENODEV; goto unlock; } if (!list_empty(&timer->open_list_head)) { timeri = list_entry(timer->open_list_head.next, struct snd_timer_instance, open_list); if (timeri->flags & SNDRV_TIMER_IFLG_EXCLUSIVE) { err = -EBUSY; timeri = NULL; goto unlock; } } if (timer->num_instances >= timer->max_instances) { err = -EBUSY; goto unlock; } timeri = snd_timer_instance_new(owner, timer); if (!timeri) { err = -ENOMEM; goto unlock; } if (timer->card) get_device(&timer->card->card_dev); timeri->slave_class = tid->dev_sclass; timeri->slave_id = slave_id; if (list_empty(&timer->open_list_head) && timer->hw.open) { err = timer->hw.open(timer); if (err) { kfree(timeri->owner); kfree(timeri); timeri = NULL; if (timer->card) card_dev_to_put = &timer->card->card_dev; module_put(timer->module); goto unlock; } } list_add_tail(&timeri->open_list, &timer->open_list_head); timer->num_instances++; err = snd_timer_check_master(timeri); if (err < 0) { snd_timer_close_locked(timeri, &card_dev_to_put); timeri = NULL; } unlock: mutex_unlock(&register_mutex); if (card_dev_to_put) put_device(card_dev_to_put); *ti = timeri; return err; }"
"static Image *ReadJP2Image(const ImageInfo *image_info,ExceptionInfo *exception) { const char *option; Image *image; int jp2_status; MagickBooleanType status; opj_codec_t *jp2_codec; opj_codestream_index_t *codestream_index = (opj_codestream_index_t *) NULL; opj_dparameters_t parameters; opj_image_t *jp2_image; opj_stream_t *jp2_stream; register ssize_t i; ssize_t y; unsigned char sans[4]; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (ReadBlob(image,4,sans) != 4) { image=DestroyImageList(image); return((Image *) NULL); } (void) SeekBlob(image,SEEK_SET,0); if (LocaleCompare(image_info->magick,""JPT"") == 0) jp2_codec=opj_create_decompress(OPJ_CODEC_JPT); else if (IsJ2K(sans,4) != MagickFalse) jp2_codec=opj_create_decompress(OPJ_CODEC_J2K); else jp2_codec=opj_create_decompress(OPJ_CODEC_JP2); opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception); opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception); opj_set_default_decoder_parameters(&parameters); option=GetImageOption(image_info,""jp2:reduce-factor""); if (option != (const char *) NULL) parameters.cp_reduce=StringToInteger(option); option=GetImageOption(image_info,""jp2:quality-layers""); if (option == (const char *) NULL) option=GetImageOption(image_info,""jp2:layer-number""); if (option != (const char *) NULL) parameters.cp_layer=StringToInteger(option); if (opj_setup_decoder(jp2_codec,&parameters) == 0) { opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToManageJP2Stream""); } jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_TRUE); opj_stream_set_read_function(jp2_stream,JP2ReadHandler); opj_stream_set_write_function(jp2_stream,JP2WriteHandler); opj_stream_set_seek_function(jp2_stream,JP2SeekHandler); opj_stream_set_skip_function(jp2_stream,JP2SkipHandler); opj_stream_set_user_data(jp2_stream,image,NULL); opj_stream_set_user_data_length(jp2_stream,GetBlobSize(image)); if (opj_read_header(jp2_stream,jp2_codec,&jp2_image) == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } jp2_status=1; if ((image->columns != 0) && (image->rows != 0)) { jp2_status=opj_set_decode_area(jp2_codec,jp2_image, (OPJ_INT32) image->extract_info.x,(OPJ_INT32) image->extract_info.y, (OPJ_INT32) image->extract_info.x+(ssize_t) image->columns, (OPJ_INT32) image->extract_info.y+(ssize_t) image->rows); if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } } if ((image_info->number_scenes != 0) && (image_info->scene != 0)) jp2_status=opj_get_decoded_tile(jp2_codec,jp2_stream,jp2_image, (unsigned int) image_info->scene-1); else if (image->ping == MagickFalse) { jp2_status=opj_decode(jp2_codec,jp2_stream,jp2_image); if (jp2_status != 0) jp2_status=opj_end_decompress(jp2_codec,jp2_stream); } if (jp2_status == 0) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(DelegateError,""UnableToDecodeImageFile""); } opj_stream_destroy(jp2_stream); for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { if ((jp2_image->comps[i].dx == 0) || (jp2_image->comps[i].dy == 0)) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); ThrowReaderException(CoderError,""IrregularChannelGeometryNotSupported"") } } image->columns=(size_t) jp2_image->comps[0].w; image->rows=(size_t) jp2_image->comps[0].h; image->depth=jp2_image->comps[0].prec; status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } image->compression=JPEG2000Compression; if (jp2_image->color_space == 2) { SetImageColorspace(image,GRAYColorspace); if (jp2_image->numcomps > 1) image->matte=MagickTrue; } else if (jp2_image->color_space == 3) SetImageColorspace(image,Rec601YCbCrColorspace); if (jp2_image->numcomps > 3) image->matte=MagickTrue; if (jp2_image->icc_profile_buf != (unsigned char *) NULL) { StringInfo *profile; profile=BlobToStringInfo(jp2_image->icc_profile_buf, jp2_image->icc_profile_len); if (profile != (StringInfo *) NULL) SetImageProfile(image,""icc"",profile); } if (image->ping != MagickFalse) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); return(GetFirstImageInList(image)); } for (y=0; y < (ssize_t) image->rows; y++) { register PixelPacket *magick_restrict q; register ssize_t x; q=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { register ssize_t i; for (i=0; i < (ssize_t) jp2_image->numcomps; i++) { double pixel, scale; scale=QuantumRange/(double) ((1UL << jp2_image->comps[i].prec)-1); pixel=scale*(jp2_image->comps[i].data[y/jp2_image->comps[i].dy* image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx]+ (jp2_image->comps[i].sgnd ? 1UL << (jp2_image->comps[i].prec-1) : 0)); switch (i) { case 0: { q->red=ClampToQuantum(pixel); q->green=q->red; q->blue=q->red; q->opacity=OpaqueOpacity; break; } case 1: { if (jp2_image->numcomps == 2) { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } q->green=ClampToQuantum(pixel); break; } case 2: { q->blue=ClampToQuantum(pixel); break; } case 3: { q->opacity=ClampToQuantum(QuantumRange-pixel); break; } } } q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); opj_destroy_cstr_index(&codestream_index); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"struct key *key_alloc(struct key_type *type, const char *desc, kuid_t uid, kgid_t gid, const struct cred *cred, key_perm_t perm, unsigned long flags, struct key_restriction *restrict_link) { struct key_user *user = NULL; struct key *key; size_t desclen, quotalen; int ret; key = ERR_PTR(-EINVAL); if (!desc || !*desc) goto error; if (type->vet_description) { ret = type->vet_description(desc); if (ret < 0) { key = ERR_PTR(ret); goto error; } } desclen = strlen(desc); quotalen = desclen + 1 + type->def_datalen; user = key_user_lookup(uid); if (!user) goto no_memory_1; if (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) { unsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxkeys : key_quota_maxkeys; unsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ? key_quota_root_maxbytes : key_quota_maxbytes; spin_lock(&user->lock); if (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) { if (user->qnkeys + 1 >= maxkeys || user->qnbytes + quotalen >= maxbytes || user->qnbytes + quotalen < user->qnbytes) goto no_quota; } user->qnkeys++; user->qnbytes += quotalen; spin_unlock(&user->lock); } key = kmem_cache_zalloc(key_jar, GFP_KERNEL); if (!key) goto no_memory_2; key->index_key.desc_len = desclen; key->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL); if (!key->index_key.description) goto no_memory_3; refcount_set(&key->usage, 1); init_rwsem(&key->sem); lockdep_set_class(&key->sem, &type->lock_class); key->index_key.type = type; key->user = user; key->quotalen = quotalen; key->datalen = type->def_datalen; key->uid = uid; key->gid = gid; key->perm = perm; key->restrict_link = restrict_link; if (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) key->flags |= 1 << KEY_FLAG_IN_QUOTA; if (flags & KEY_ALLOC_BUILT_IN) key->flags |= 1 << KEY_FLAG_BUILTIN; #ifdef KEY_DEBUGGING key->magic = KEY_DEBUG_MAGIC; #endif ret = security_key_alloc(key, cred, flags); if (ret < 0) goto security_error; atomic_inc(&user->nkeys); key_alloc_serial(key); error: return key; security_error: kfree(key->description); kmem_cache_free(key_jar, key); if (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) { spin_lock(&user->lock); user->qnkeys--; user->qnbytes -= quotalen; spin_unlock(&user->lock); } key_user_put(user); key = ERR_PTR(ret); goto error; no_memory_3: kmem_cache_free(key_jar, key); no_memory_2: if (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) { spin_lock(&user->lock); user->qnkeys--; user->qnbytes -= quotalen; spin_unlock(&user->lock); } key_user_put(user); no_memory_1: key = ERR_PTR(-ENOMEM); goto error; no_quota: spin_unlock(&user->lock); key_user_put(user); key = ERR_PTR(-EDQUOT); goto error; }"
"static njs_int_t njs_promise_perform_all_handler(njs_vm_t *vm, njs_iterator_args_t *args, njs_value_t *value, int64_t index) { njs_int_t                    ret; njs_array_t                  *array; njs_value_t                  arguments[2], next; njs_function_t               *on_fulfilled; njs_promise_capability_t     *capability; njs_promise_all_context_t    *context; njs_promise_iterator_args_t  *pargs; pargs = (njs_promise_iterator_args_t *) args; capability = pargs->capability; array = args->data; njs_set_undefined(&array->start[index]); ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1, &next); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } on_fulfilled = njs_promise_create_function(vm, sizeof(njs_promise_all_context_t)); if (njs_slow_path(on_fulfilled == NULL)) { return NJS_ERROR; } on_fulfilled->u.native = njs_promise_all_resolve_element_functions; on_fulfilled->args_count = 1; context = on_fulfilled->context; context->already_called = 0; context->index = (uint32_t) index; context->values = pargs->args.data; context->capability = capability; context->remaining_elements = pargs->remaining; (*pargs->remaining)++; njs_set_function(&arguments[0], on_fulfilled); arguments[1] = capability->reject; ret = njs_promise_invoke_then(vm, &next, arguments, 2); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } return NJS_OK; }"
"bool BmpInput::read_rle_image() { int rletype = m_dib_header.compression == RLE4_COMPRESSION ? 4 : 8; m_spec.attribute(""compression"", rletype == 4 ? ""rle4"" : ""rle8""); m_uncompressed.clear(); m_uncompressed.resize(m_spec.height * m_spec.width); bool ok = true; int y = 0, x = 0; while (ok) { unsigned char rle_pair[2]; if (!ioread(rle_pair, 2)) { ok = false; break; } if (y >= m_spec.height) {              errorfmt( ""BMP might be corrupted, it is referencing an out-of-bounds pixel coordinte ({},{})"", x, y); ok = false; break; } int npixels = rle_pair[0]; int value   = rle_pair[1]; if (npixels == 0 && value == 0) { x = 0; ++y; } else if (npixels == 0 && value == 1) { break; } else if (npixels == 0 && value == 2) { unsigned char offset[2]; ok &= ioread(offset, 2); x += offset[0]; y += offset[1]; } else if (npixels == 0) { npixels    = value; int nbytes = (rletype == 4) ? round_to_multiple((npixels + 1) / 2, 2) : round_to_multiple(npixels, 2); unsigned char absolute[256]; ok &= ioread(absolute, nbytes); for (int i = 0; i < npixels; ++i, ++x) { if (rletype == 4) value = (i & 1) ? (absolute[i / 2] & 0x0f) : (absolute[i / 2] >> 4); else value = absolute[i]; if (x < m_spec.width) m_uncompressed[y * m_spec.width + x] = value; } } else { for (int i = 0; i < npixels; ++i, ++x) { int v; if (rletype == 4) v = (i & 1) ? (value & 0x0f) : (value >> 4); else v = value; if (x < m_spec.width) m_uncompressed[y * m_spec.width + x] = v; } } } return ok; }"
"Variant HHVM_FUNCTION(mcrypt_generic_init, const Resource& td, const String& key, const String& iv) { auto pm = get_valid_mcrypt_resource(td); if (!pm) { return false; } int max_key_size = mcrypt_enc_get_key_size(pm->m_td); int iv_size = mcrypt_enc_get_iv_size(pm->m_td); if (key.empty()) { raise_warning(""Key size is 0""); } unsigned char *key_s = (unsigned char *)malloc(key.size()); memset(key_s, 0, key.size()); unsigned char *iv_s = (unsigned char *)malloc(iv_size + 1); memset(iv_s, 0, iv_size + 1); int key_size; if (key.size() > max_key_size) { raise_warning(""Key size too large; supplied length: %d, max: %d"", key.size(), max_key_size); key_size = max_key_size; } else { key_size = key.size(); } memcpy(key_s, key.data(), key.size()); if (iv.size() != iv_size) { raise_warning(""Iv size incorrect; supplied length: %d, needed: %d"", iv.size(), iv_size); } memcpy(iv_s, iv.data(), std::min(iv_size, iv.size())); mcrypt_generic_deinit(pm->m_td); int result = mcrypt_generic_init(pm->m_td, key_s, key_size, iv_s); if (result < 0) { pm->close(); switch (result) { case -3: raise_warning(""Key length incorrect""); break; case -4: raise_warning(""Memory allocation error""); break; case -1: default: raise_warning(""Unknown error""); break; } } else { pm->m_init = true; } free(iv_s); free(key_s); return result; }"
static void cil_reset_classperms_set(struct cil_classperms_set *cp_set) { cil_reset_classpermission(cp_set->set); }
"void snd_pcm_period_elapsed(struct snd_pcm_substream *substream) { struct snd_pcm_runtime *runtime; unsigned long flags; if (PCM_RUNTIME_CHECK(substream)) return; runtime = substream->runtime; snd_pcm_stream_lock_irqsave(substream, flags); if (!snd_pcm_running(substream) || snd_pcm_update_hw_ptr0(substream, 1) < 0) goto _end; #ifdef CONFIG_SND_PCM_TIMER if (substream->timer_running) snd_timer_interrupt(substream->timer, 1); #endif _end: snd_pcm_stream_unlock_irqrestore(substream, flags); kill_fasync(&runtime->fasync, SIGIO, POLL_IN); }"
static int crypto_rng_init_tfm(struct crypto_tfm *tfm) { struct crypto_rng *rng = __crypto_rng_cast(tfm); struct rng_alg *alg = crypto_rng_alg(rng); struct old_rng_alg *oalg = crypto_old_rng_alg(rng); if (oalg->rng_make_random) { rng->generate = generate; rng->seed = rngapi_reset; rng->seedsize = oalg->seedsize; return 0; } rng->generate = alg->generate; rng->seed = alg->seed; rng->seedsize = alg->seedsize; return 0; }
"static void process_packet_data(struct wtap_pkthdr *phdr, Buffer *target, guint8 *buffer, gint len, k12_t *k12) { guint32 type; guint   buffer_offset; guint64 ts; guint32 length; guint32 extra_len; guint32 src_id; k12_src_desc_t* src_desc; phdr->rec_type = REC_TYPE_PACKET; phdr->presence_flags = WTAP_HAS_TS; ts = pntoh64(buffer + K12_PACKET_TIMESTAMP); phdr->ts.secs = (guint32) ((ts / 2000000) + 631152000); phdr->ts.nsecs = (guint32) ( (ts % 2000000) * 500 ); length = pntoh32(buffer + K12_RECORD_FRAME_LEN) & 0x00001FFF; phdr->len = phdr->caplen = length; type = pntoh32(buffer + K12_RECORD_TYPE); buffer_offset = (type == K12_REC_D0020) ? K12_PACKET_FRAME_D0020 : K12_PACKET_FRAME; ws_buffer_assure_space(target, length); memcpy(ws_buffer_start_ptr(target), buffer + buffer_offset, length); extra_len = len - buffer_offset - length; ws_buffer_assure_space(&(k12->extra_info), extra_len); memcpy(ws_buffer_start_ptr(&(k12->extra_info)), buffer + buffer_offset + length, extra_len); phdr->pseudo_header.k12.extra_info = (guint8*)ws_buffer_start_ptr(&(k12->extra_info)); phdr->pseudo_header.k12.extra_length = extra_len; src_id = pntoh32(buffer + K12_RECORD_SRC_ID); K12_DBG(5,(""process_packet_data: src_id=%.8x"",src_id)); phdr->pseudo_header.k12.input = src_id; if ( ! (src_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id))) ) { src_desc = (k12_src_desc_t*)g_hash_table_lookup(k12->src_by_id,GUINT_TO_POINTER(src_id&K12_RECORD_SRC_ID_MASK)); } if (src_desc) { K12_DBG(5,(""process_packet_data: input_name='%s' stack_file='%s' type=%x"",src_desc->input_name,src_desc->stack_file,src_desc->input_type)); phdr->pseudo_header.k12.input_name = src_desc->input_name; phdr->pseudo_header.k12.stack_file = src_desc->stack_file; phdr->pseudo_header.k12.input_type = src_desc->input_type; switch(src_desc->input_type) { case K12_PORT_ATMPVC: if ((long)(buffer_offset + length + K12_PACKET_OFFSET_CID) < len) { phdr->pseudo_header.k12.input_info.atm.vp =  pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VP); phdr->pseudo_header.k12.input_info.atm.vc =  pntoh16(buffer + buffer_offset + length + K12_PACKET_OFFSET_VC); phdr->pseudo_header.k12.input_info.atm.cid =  *((unsigned char*)(buffer + buffer_offset + length + K12_PACKET_OFFSET_CID)); break; } default: memcpy(&(phdr->pseudo_header.k12.input_info),&(src_desc->input_info),sizeof(src_desc->input_info)); break; } } else { K12_DBG(5,(""process_packet_data: NO SRC_RECORD FOUND"")); memset(&(phdr->pseudo_header.k12),0,sizeof(phdr->pseudo_header.k12)); phdr->pseudo_header.k12.input_name = ""unknown port""; phdr->pseudo_header.k12.stack_file = ""unknown stack file""; } phdr->pseudo_header.k12.input = src_id; phdr->pseudo_header.k12.stuff = k12; }"
"static void  Ins_MDRP( INS_ARG ) { Int         point; TT_F26Dot6  distance, org_dist; point = (Int)args[0]; if ( BOUNDS( args[0], CUR.zp1.n_points ) ) { return; } org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] - CUR.zp0.org_x[CUR.GS.rp0], CUR.zp1.org_y[point] - CUR.zp0.org_y[CUR.GS.rp0] ); if ( ABS(org_dist) < CUR.GS.single_width_cutin ) { if ( org_dist >= 0 ) org_dist = CUR.GS.single_width_value; else org_dist = -CUR.GS.single_width_value; } if ( (CUR.opcode & 4) != 0 ) distance = CUR_Func_round( org_dist, CUR.metrics.compensations[CUR.opcode & 3] ); else distance = Round_None( EXEC_ARGS org_dist, CUR.metrics.compensations[CUR.opcode & 3]  ); if ( (CUR.opcode & 8) != 0 ) { if ( org_dist >= 0 ) { if ( distance < CUR.GS.minimum_distance ) distance = CUR.GS.minimum_distance; } else { if ( distance > -CUR.GS.minimum_distance ) distance = -CUR.GS.minimum_distance; } } org_dist = CUR_Func_project( CUR.zp1.cur_x[point] - CUR.zp0.cur_x[CUR.GS.rp0], CUR.zp1.cur_y[point] - CUR.zp0.cur_y[CUR.GS.rp0] ); CUR_Func_move( &CUR.zp1, point, distance - org_dist ); CUR.GS.rp1 = CUR.GS.rp0; CUR.GS.rp2 = point; if ( (CUR.opcode & 16) != 0 ) CUR.GS.rp0 = point; }"
"static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info) { struct cfg80211_registered_device *rdev = info->user_ptr[0]; struct net_device *dev = info->user_ptr[1]; struct wireless_dev *wdev = dev->ieee80211_ptr; struct nlattr *tb[NUM_NL80211_REKEY_DATA]; struct cfg80211_gtk_rekey_data rekey_data; int err; if (!info->attrs[NL80211_ATTR_REKEY_DATA]) return -EINVAL; err = nla_parse_nested(tb, MAX_NL80211_REKEY_DATA, info->attrs[NL80211_ATTR_REKEY_DATA], nl80211_rekey_policy, info->extack); if (err) return err; if (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN) return -ERANGE; if (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN) return -ERANGE; if (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN) return -ERANGE; rekey_data.kek = nla_data(tb[NL80211_REKEY_DATA_KEK]); rekey_data.kck = nla_data(tb[NL80211_REKEY_DATA_KCK]); rekey_data.replay_ctr = nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]); wdev_lock(wdev); if (!wdev->current_bss) { err = -ENOTCONN; goto out; } if (!rdev->ops->set_rekey_data) { err = -EOPNOTSUPP; goto out; } err = rdev_set_rekey_data(rdev, dev, &rekey_data); out: wdev_unlock(wdev); return err; }"
"static int parse_acl_file(const char *filename, ACLList *acl_list) { FILE *f; char line[4096]; ACLRule *acl_rule; f = fopen(filename, ""r""); if (f == NULL) { return -1; } while (fgets(line, sizeof(line), f) != NULL) { char *ptr = line; char *cmd, *arg, *argend; while (isspace(*ptr)) { ptr++; } if (*ptr == '#' || *ptr == 0) { continue; } cmd = ptr; arg = strchr(cmd, ' '); if (arg == NULL) { arg = strchr(cmd, '\t'); } if (arg == NULL) { fprintf(stderr, ""Invalid config line:\n  %s\n"", line); fclose(f); errno = EINVAL; return -1; } *arg = 0; arg++; while (isspace(*arg)) { arg++; } argend = arg + strlen(arg); while (arg != argend && isspace(*(argend - 1))) { argend--; } *argend = 0; if (strcmp(cmd, ""deny"") == 0) { acl_rule = g_malloc(sizeof(*acl_rule)); if (strcmp(arg, ""all"") == 0) { acl_rule->type = ACL_DENY_ALL; } else { acl_rule->type = ACL_DENY; snprintf(acl_rule->iface, IFNAMSIZ, ""%s"", arg); } QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry); } else if (strcmp(cmd, ""allow"") == 0) { acl_rule = g_malloc(sizeof(*acl_rule)); if (strcmp(arg, ""all"") == 0) { acl_rule->type = ACL_ALLOW_ALL; } else { acl_rule->type = ACL_ALLOW; snprintf(acl_rule->iface, IFNAMSIZ, ""%s"", arg); } QSIMPLEQ_INSERT_TAIL(acl_list, acl_rule, entry); } else if (strcmp(cmd, ""include"") == 0) { parse_acl_file(arg, acl_list); } else { fprintf(stderr, ""Unknown command `%s'\n"", cmd); fclose(f); errno = EINVAL; return -1; } } fclose(f); return 0; }"
"lyd_node * lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str) { const struct lys_node *snode = NULL, *siblings; if ((!parent && !module) || !name) { LOGARG; return NULL; } siblings = lyd_new_find_schema(parent, module, 1); if (!siblings) { LOGARG; return NULL; } if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) { LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."", name, lys_node_module(siblings)->name, siblings->name); return NULL; } return _lyd_new_leaf(parent, snode, val_str, 0, 0); }"
"EbmlElement * EbmlElement::FindNextElement(IOCallback & DataStream, const EbmlSemanticContext & Context, int & UpperLevel, uint64 MaxDataSize, bool AllowDummyElt, unsigned int MaxLowerLevel) { int PossibleID_Length = 0; binary PossibleIdNSize[16]; int PossibleSizeLength; uint64 SizeUnknown; int ReadIndex = 0;   uint32 ReadSize = 0; uint64 SizeFound; int SizeIdx; bool bFound; int UpperLevel_original = UpperLevel; do { do { assert(ReadIndex < 16); bFound = false; binary IdBitMask = 1 << 7; for (SizeIdx = 0; SizeIdx < ReadIndex && SizeIdx < 4; SizeIdx++) { if (PossibleIdNSize[0] & (IdBitMask >> SizeIdx)) { PossibleID_Length = SizeIdx + 1; IdBitMask >>= SizeIdx; bFound = true; break; } } if (bFound) { break; } if (ReadIndex >= 4) { memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex); } if (MaxDataSize <= ReadSize) break; if (DataStream.read(&PossibleIdNSize[ReadIndex++], 1) == 0) { return NULL;       } ReadSize++; } while (!bFound); if (!bFound) return NULL; SizeIdx = ReadIndex; ReadIndex -= PossibleID_Length; uint32 _SizeLength; PossibleSizeLength = ReadIndex; while (1) { _SizeLength = PossibleSizeLength; SizeFound = ReadCodedSizeValue(&PossibleIdNSize[PossibleID_Length], _SizeLength, SizeUnknown); if (_SizeLength != 0) { bFound = true; break; } if (PossibleSizeLength >= 8) { bFound = false; break; } if (MaxDataSize <= ReadSize) { bFound = false; break; } if( DataStream.read( &PossibleIdNSize[SizeIdx++], 1 ) == 0 ) { return NULL;       } ReadSize++; PossibleSizeLength++; } if (bFound) { EbmlId PossibleID(PossibleIdNSize, PossibleID_Length); EbmlElement * Result = CreateElementUsingContext(PossibleID, Context, UpperLevel, false, AllowDummyElt, MaxLowerLevel); if (Result != NULL) { if (AllowDummyElt || !Result->IsDummy()) { Result->SetSizeLength(_SizeLength); Result->Size = SizeFound; if (Result->ValidateSize() && (SizeFound == SizeUnknown || UpperLevel > 0 || MaxDataSize == 0 || MaxDataSize >= (PossibleID_Length + PossibleSizeLength + SizeFound))) { if (SizeFound != SizeUnknown || Result->SetSizeInfinite()) { Result->SizePosition = DataStream.getFilePointer() - SizeIdx + EBML_ID_LENGTH(PossibleID); Result->ElementPosition = Result->SizePosition - EBML_ID_LENGTH(PossibleID); DataStream.setFilePointer(Result->SizePosition + _SizeLength); return Result; } } } delete Result; } } ReadIndex = SizeIdx - 1; memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex); UpperLevel = UpperLevel_original; } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length ); return NULL; }"
"static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception) { unsigned char attributes, tag[3]; Image *image; IndexPacket index; MagickBooleanType status; PDBImage pdb_image; PDBInfo pdb_info; register IndexPacket *indexes; register ssize_t x; register PixelPacket *q; register unsigned char *p; size_t bits_per_pixel, num_pad_bytes, one, packets; ssize_t count, img_offset, comment_offset = 0, y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name); if (count != sizeof(pdb_info.name)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); pdb_info.attributes=(short) ReadBlobMSBShort(image); pdb_info.version=(short) ReadBlobMSBShort(image); pdb_info.create_time=ReadBlobMSBLong(image); pdb_info.modify_time=ReadBlobMSBLong(image); pdb_info.archive_time=ReadBlobMSBLong(image); pdb_info.modify_number=ReadBlobMSBLong(image); pdb_info.application_info=ReadBlobMSBLong(image); pdb_info.sort_info=ReadBlobMSBLong(image); (void) ReadBlob(image,4,(unsigned char *) pdb_info.type); (void) ReadBlob(image,4,(unsigned char *) pdb_info.id); pdb_info.seed=ReadBlobMSBLong(image); pdb_info.next_record=ReadBlobMSBLong(image); pdb_info.number_records=(short) ReadBlobMSBShort(image); if ((memcmp(pdb_info.type,""vIMG"",4) != 0) || (memcmp(pdb_info.id,""View"",4) != 0)) if (pdb_info.next_record != 0) ThrowReaderException(CoderError,""MultipleRecordListNotSupported""); img_offset=(ssize_t) ReadBlobMSBSignedLong(image); attributes=(unsigned char) (ReadBlobByte(image)); (void) attributes; count=ReadBlob(image,3,(unsigned char *) tag); if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0) ThrowReaderException(CorruptImageError,""CorruptImage""); if (pdb_info.number_records > 1) { comment_offset=(ssize_t) ReadBlobMSBSignedLong(image); attributes=(unsigned char) (ReadBlobByte(image)); count=ReadBlob(image,3,(unsigned char *) tag); if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0) ThrowReaderException(CorruptImageError,""CorruptImage""); } num_pad_bytes = (size_t) (img_offset - TellBlob( image )); while (num_pad_bytes-- != 0) { int c; c=ReadBlobByte(image); if (c == EOF) break; } count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name); if (count != sizeof(pdb_image.name)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); pdb_image.version=ReadBlobByte(image); pdb_image.type=(unsigned char) ReadBlobByte(image); pdb_image.reserved_1=ReadBlobMSBLong(image); pdb_image.note=ReadBlobMSBLong(image); pdb_image.x_last=(short) ReadBlobMSBShort(image); pdb_image.y_last=(short) ReadBlobMSBShort(image); pdb_image.reserved_2=ReadBlobMSBLong(image); pdb_image.x_anchor=ReadBlobMSBShort(image); pdb_image.y_anchor=ReadBlobMSBShort(image); pdb_image.width=(short) ReadBlobMSBShort(image); pdb_image.height=(short) ReadBlobMSBShort(image); image->columns=(size_t) pdb_image.width; image->rows=(size_t) pdb_image.height; image->depth=8; image->storage_class=PseudoClass; bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL; one=1; if (AcquireImageColormap(image,one << bits_per_pixel) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } packets=(bits_per_pixel*image->columns+7)/8; pixels=(unsigned char *) AcquireQuantumMemory(packets+257UL,image->rows* sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); switch (pdb_image.version & 0x07) { case 0: { image->compression=NoCompression; count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels); break; } case 1: { image->compression=RLECompression; if (!DecodeImage(image, pixels, packets * image -> rows)) ThrowReaderException( CorruptImageError, ""RLEDecoderError"" ); break; } default: ThrowReaderException(CorruptImageError, ""UnrecognizedImageCompressionType"" ); } p=pixels; switch (bits_per_pixel) { case 1: { int bit; for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=0; bit < 8; bit++) { index=(IndexPacket) (*p & (0x80 >> bit) ? 0x00 : 0x01); SetPixelIndex(indexes+x+bit,index); } p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image); break; } case 2: { for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); for (x=0; x < (ssize_t) image->columns-3; x+=4) { index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03)); SetPixelIndex(indexes+x,index); index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03)); SetPixelIndex(indexes+x+1,index); index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03)); SetPixelIndex(indexes+x+2,index); index=ConstrainColormapIndex(image,3UL-((*p) & 0x03)); SetPixelIndex(indexes+x+3,index); p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image); break; } case 4: { for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; indexes=GetAuthenticIndexQueue(image); for (x=0; x < (ssize_t) image->columns-1; x+=2) { index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f)); SetPixelIndex(indexes+x,index); index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f)); SetPixelIndex(indexes+x+1,index); p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image); break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); if (pdb_info.number_records > 1) { char *comment; int c; register char *p; size_t length; num_pad_bytes = (size_t) (comment_offset - TellBlob( image )); while (num_pad_bytes--) ReadBlobByte( image ); c=ReadBlobByte(image); length=MaxTextExtent; comment=AcquireString((char *) NULL); for (p=comment; c != EOF; p++) { if ((size_t) (p-comment+MaxTextExtent) >= length) { *p='\0'; length<<=1; length+=MaxTextExtent; comment=(char *) ResizeQuantumMemory(comment,length+MaxTextExtent, sizeof(*comment)); if (comment == (char *) NULL) break; p=comment+strlen(comment); } *p=c; c=ReadBlobByte(image); } *p='\0'; if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) SetImageProperty(image,""comment"",comment); comment=DestroyString(comment); } (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"static int __acquire_grant_for_copy( struct domain *rd, unsigned long gref, domid_t ldom, int readonly, unsigned long *frame, struct page_info **page,  uint16_t *page_off, uint16_t *length, unsigned allow_transitive) { struct grant_table *rgt = rd->grant_table; grant_entry_v2_t *sha2; grant_entry_header_t *shah; struct active_grant_entry *act; grant_status_t *status; uint32_t old_pin; domid_t trans_domid; grant_ref_t trans_gref; struct domain *td; unsigned long grant_frame; uint16_t trans_page_off; uint16_t trans_length; int is_sub_page; s16 rc = GNTST_okay; *page = NULL; grant_read_lock(rgt); if ( unlikely(gref >= nr_grant_entries(rgt)) ) PIN_FAIL(gt_unlock_out, GNTST_bad_gntref, ""Bad grant reference %ld\n"", gref); act = active_entry_acquire(rgt, gref); shah = shared_entry_header(rgt, gref); if ( rgt->gt_version == 1 ) { sha2 = NULL; status = &shah->flags; } else { sha2 = &shared_entry_v2(rgt, gref); status = &status_entry(rgt, gref); } if ( act->pin && ((act->domid != ldom) || (act->pin & 0x80808080U) != 0) ) PIN_FAIL(unlock_out, GNTST_general_error, ""Bad domain (%d != %d), or risk of counter overflow %08x\n"", act->domid, ldom, act->pin); old_pin = act->pin; if ( !act->pin || (!readonly && !(act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask))) ) { if ( (rc = _set_status(rgt->gt_version, ldom, readonly, 0, shah, act, status) ) != GNTST_okay ) goto unlock_out; td = rd; trans_gref = gref; if ( !sha2 ) { unsigned long gfn = shared_entry_v1(rgt, gref).frame; rc = __get_paged_frame(gfn, &grant_frame, page, readonly, rd); if ( rc != GNTST_okay ) goto unlock_out_clear; act->gfn = gfn; is_sub_page = 0; trans_page_off = 0; trans_length = PAGE_SIZE; } else if ( (shah->flags & GTF_type_mask) == GTF_transitive ) { if ( !allow_transitive ) PIN_FAIL(unlock_out_clear, GNTST_general_error, ""transitive grant when transitivity not allowed\n""); trans_domid = sha2->transitive.trans_domid; trans_gref = sha2->transitive.gref; barrier();  if ( trans_domid == rd->domain_id ) PIN_FAIL(unlock_out_clear, GNTST_general_error, ""transitive grants cannot be self-referential\n""); td = rcu_lock_domain_by_id(trans_domid); if ( td == NULL ) PIN_FAIL(unlock_out_clear, GNTST_general_error, ""transitive grant referenced bad domain %d\n"", trans_domid); active_entry_release(act); grant_read_unlock(rgt); rc = __acquire_grant_for_copy(td, trans_gref, rd->domain_id, readonly, &grant_frame, page, &trans_page_off, &trans_length, 0); grant_read_lock(rgt); act = active_entry_acquire(rgt, gref); if ( rc != GNTST_okay ) { __fixup_status_for_copy_pin(act, status); rcu_unlock_domain(td); active_entry_release(act); grant_read_unlock(rgt); return rc; } if ( act->pin != old_pin ) { __fixup_status_for_copy_pin(act, status); rcu_unlock_domain(td); active_entry_release(act); grant_read_unlock(rgt); put_page(*page); return __acquire_grant_for_copy(rd, gref, ldom, readonly, frame, page, page_off, length, allow_transitive); } is_sub_page = 1; act->gfn = -1ul; } else if ( !(sha2->hdr.flags & GTF_sub_page) ) { rc = __get_paged_frame(sha2->full_page.frame, &grant_frame, page, readonly, rd); if ( rc != GNTST_okay ) goto unlock_out_clear; act->gfn = sha2->full_page.frame; is_sub_page = 0; trans_page_off = 0; trans_length = PAGE_SIZE; } else { rc = __get_paged_frame(sha2->sub_page.frame, &grant_frame, page, readonly, rd); if ( rc != GNTST_okay ) goto unlock_out_clear; act->gfn = sha2->sub_page.frame; is_sub_page = 1; trans_page_off = sha2->sub_page.page_off; trans_length = sha2->sub_page.length; } if ( !act->pin ) { act->domid = ldom; act->is_sub_page = is_sub_page; act->start = trans_page_off; act->length = trans_length; act->trans_domain = td; act->trans_gref = trans_gref; act->frame = grant_frame; } } else { ASSERT(mfn_valid(_mfn(act->frame))); *page = mfn_to_page(act->frame); td = page_get_owner_and_reference(*page); ASSERT(td); } act->pin += readonly ? GNTPIN_hstr_inc : GNTPIN_hstw_inc; *page_off = act->start; *length = act->length; *frame = act->frame; active_entry_release(act); grant_read_unlock(rgt); return rc; unlock_out_clear: if ( !(readonly) && !(act->pin & GNTPIN_hstw_mask) ) gnttab_clear_flag(_GTF_writing, status); if ( !act->pin ) gnttab_clear_flag(_GTF_reading, status); unlock_out: active_entry_release(act); gt_unlock_out: grant_read_unlock(rgt); return rc; }"
"int for_each_problem_in_dir(const char *path, uid_t caller_uid, int (*callback)(struct dump_dir *dd, void *arg), void *arg) { DIR *dp = opendir(path); if (!dp) { return 0; } int brk = 0; struct dirent *dent; while ((dent = readdir(dp)) != NULL) { if (dot_or_dotdot(dent->d_name)) continue;  char *full_name = concat_path_file(path, dent->d_name); if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid)) { int sv_logmode = logmode; logmode = 0; struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK); logmode = sv_logmode; if (dd) { brk = callback ? callback(dd, arg) : 0; dd_close(dd); } } free(full_name); if (brk) break; } closedir(dp); return brk; }"
static void io_req_track_inflight(struct io_kiocb *req) { if (!(req->flags & REQ_F_INFLIGHT)) { req->flags |= REQ_F_INFLIGHT; atomic_inc(&current->io_uring->inflight_tracked); } }
"static int dex_loadcode(RBinFile *arch, RBinDexObj *bin) { struct r_bin_t *rbin = arch->rbin; int i; int *methods = NULL; int sym_count = 0; if (!bin || bin->methods_list) { return false; } bin->code_from = UT64_MAX; bin->code_to = 0; bin->methods_list = r_list_newf ((RListFree)free); if (!bin->methods_list) { return false; } bin->imports_list = r_list_newf ((RListFree)free); if (!bin->imports_list) { r_list_free (bin->methods_list); return false; } bin->classes_list = r_list_newf ((RListFree)__r_bin_class_free); if (!bin->classes_list) { r_list_free (bin->methods_list); r_list_free (bin->imports_list); return false; } if (bin->header.method_size>bin->size) { bin->header.method_size = 0; return false; } bin->header.method_size = R_MIN (bin->header.method_size, bin->size); bin->header.class_size = R_MIN (bin->header.class_size, bin->size); bin->header.strings_size = R_MIN (bin->header.strings_size, bin->size); if (bin->header.strings_size > bin->size) { eprintf (""Invalid strings size\n""); return false; } if (bin->classes) { ut64 amount = sizeof (int) * bin->header.method_size; if (amount > UT32_MAX || amount < bin->header.method_size) { return false; } methods = calloc (1, amount + 1); for (i = 0; i < bin->header.class_size; i++) { char *super_name, *class_name; struct dex_class_t *c = &bin->classes[i]; class_name = dex_class_name (bin, c); super_name = dex_class_super_name (bin, c); if (dexdump) {  rbin->cb_printf (""Class #%d            -\n"", i); } parse_class (arch, bin, c, i, methods, &sym_count); free (class_name); free (super_name); } } if (methods) { int import_count = 0; int sym_count = bin->methods_list->length; for (i = 0; i < bin->header.method_size; i++) { int len = 0; if (methods[i]) { continue; } if (bin->methods[i].class_id > bin->header.types_size - 1) { continue; } if (is_class_idx_in_code_classes(bin, bin->methods[i].class_id)) { continue; } char *class_name = getstr ( bin, bin->types[bin->methods[i].class_id] .descriptor_id); if (!class_name) { free (class_name); continue; } len = strlen (class_name); if (len < 1) { continue; } class_name[len - 1] = 0; char *method_name = dex_method_name (bin, i); char *signature = dex_method_signature (bin, i); if (method_name && *method_name) { RBinImport *imp = R_NEW0 (RBinImport); imp->name  = r_str_newf (""%s.method.%s%s"", class_name, method_name, signature); imp->type = r_str_const (""FUNC""); imp->bind = r_str_const (""NONE""); imp->ordinal = import_count++; r_list_append (bin->imports_list, imp); RBinSymbol *sym = R_NEW0 (RBinSymbol); sym->name = r_str_newf (""imp.%s"", imp->name); sym->type = r_str_const (""FUNC""); sym->bind = r_str_const (""NONE""); sym->paddr = sym->vaddr = bin->b->base + bin->header.method_offset + (sizeof (struct dex_method_t) * i) ; sym->ordinal = sym_count++; r_list_append (bin->methods_list, sym); sdb_num_set (mdb, sdb_fmt (0, ""method.%d"", i), sym->paddr, 0); } free (method_name); free (signature); free (class_name); } free (methods); } return true; }"
"GF_Err latm_dmx_process(GF_Filter *filter) { GF_LATMDmxCtx *ctx = gf_filter_get_udta(filter); GF_FilterPacket *pck, *dst_pck; u32 pos; u8 *data=NULL, *output; u32 pck_size=0, prev_pck_size; u64 cts = GF_FILTER_NO_TS; if (ctx->in_error) return ctx->in_error; if (!ctx->duration.num) latm_dmx_check_dur(filter, ctx); if (ctx->opid && !ctx->is_playing) return GF_OK; pck = gf_filter_pid_get_packet(ctx->ipid); if (!pck) { if (gf_filter_pid_is_eos(ctx->ipid)) { if (!ctx->latm_buffer_size) { if (ctx->opid) gf_filter_pid_set_eos(ctx->opid); if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = NULL; return GF_EOS; } } else { return GF_OK; } } else { data = (char *) gf_filter_pck_get_data(pck, &pck_size); } if (ctx->timescale && pck) { cts = gf_filter_pck_get_cts(pck); if (!ctx->cts && (cts != GF_FILTER_NO_TS)) ctx->cts = cts; } prev_pck_size = ctx->latm_buffer_size; if (pck && !ctx->resume_from) { if (ctx->latm_buffer_size + pck_size > ctx->latm_buffer_alloc) { ctx->latm_buffer_alloc = ctx->latm_buffer_size + pck_size; ctx->latm_buffer = gf_realloc(ctx->latm_buffer, ctx->latm_buffer_alloc); } memcpy(ctx->latm_buffer + ctx->latm_buffer_size, data, pck_size); ctx->latm_buffer_size += pck_size; } if (!ctx->bs) ctx->bs = gf_bs_new(ctx->latm_buffer, ctx->latm_buffer_size, GF_BITSTREAM_READ); else gf_bs_reassign_buffer(ctx->bs, ctx->latm_buffer, ctx->latm_buffer_size); if (ctx->resume_from) { gf_bs_seek(ctx->bs, ctx->resume_from-1); ctx->resume_from = 0; } if (cts == GF_FILTER_NO_TS) prev_pck_size = 0; while (1) { pos = (u32) gf_bs_get_position(ctx->bs); u8 latm_buffer[4096]; u32 latm_frame_size = 4096; if (!latm_dmx_sync_frame_bs(ctx->bs,&ctx->acfg, &latm_frame_size, latm_buffer, NULL)) break; if (ctx->in_seek) { u64 nb_samples_at_seek = (u64) (ctx->start_range * GF_M4ASampleRates[ctx->sr_idx]); if (ctx->cts + ctx->dts_inc >= nb_samples_at_seek) { ctx->in_seek = GF_FALSE; } } latm_dmx_check_pid(filter, ctx); if (!ctx->is_playing) { ctx->resume_from = pos+1; return GF_OK; } if (!ctx->in_seek) { GF_FilterSAPType sap = GF_FILTER_SAP_1; dst_pck = gf_filter_pck_new_alloc(ctx->opid, latm_frame_size, &output); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(output, latm_buffer, latm_frame_size); gf_filter_pck_set_cts(dst_pck, ctx->cts); gf_filter_pck_set_duration(dst_pck, ctx->dts_inc); gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE); if (ctx->acfg.base_object_type==GF_CODECID_USAC) { if (latm_frame_size && (output[0] & 0x80) && !ctx->prev_sap) { sap = GF_FILTER_SAP_1; ctx->prev_sap = GF_TRUE; } else { sap = GF_FILTER_SAP_NONE; ctx->prev_sap = GF_FALSE; } } gf_filter_pck_set_sap(dst_pck, sap); gf_filter_pck_send(dst_pck); } latm_dmx_update_cts(ctx); if (prev_pck_size) { pos = (u32) gf_bs_get_position(ctx->bs); if (prev_pck_size<=pos) { prev_pck_size=0; if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = pck; if (pck) gf_filter_pck_ref_props(&ctx->src_pck); } } } if (pck) { pos = (u32) gf_bs_get_position(ctx->bs); assert(ctx->latm_buffer_size >= pos); memmove(ctx->latm_buffer, ctx->latm_buffer+pos, ctx->latm_buffer_size - pos); ctx->latm_buffer_size -= pos; gf_filter_pid_drop_packet(ctx->ipid); assert(!ctx->resume_from); } else { ctx->latm_buffer_size = 0; return latm_dmx_process(filter); } return GF_OK; }"
"static int PatternMatch(char *pat, int patdashes, char *string, int stringdashes) { char        c, t; if (stringdashes < patdashes) return 0; for (;;) { switch (c = *pat++) { case '*': if (!(c = *pat++)) return 1; if (c == XK_minus) { patdashes--; for (;;) { while ((t = *string++) != XK_minus) if (!t) return 0; stringdashes--; if (PatternMatch(pat, patdashes, string, stringdashes)) return 1; if (stringdashes == patdashes) return 0; } } else { for (;;) { while ((t = *string++) != c) { if (!t) return 0; if (t == XK_minus) { if (stringdashes-- < patdashes) return 0; } } if (PatternMatch(pat, patdashes, string, stringdashes)) return 1; } } case '?': if (*string++ == XK_minus) stringdashes--; break; case '\0': return (*string == '\0'); case XK_minus: if (*string++ == XK_minus) { patdashes--; stringdashes--; break; } return 0; default: if (c == *string++) break; return 0; } } }"
struct bus_id_priv *get_busid_priv(const char *busid) { int idx; struct bus_id_priv *bid = NULL; spin_lock(&busid_table_lock); idx = get_busid_idx(busid); if (idx >= 0) bid = &(busid_table[idx]); spin_unlock(&busid_table_lock); return bid; }
"static int add_page_to_event_array(struct domain *d, unsigned long gfn) { void *virt; unsigned int slot; unsigned int port = d->evtchn_fifo->num_evtchns; int rc; slot = d->evtchn_fifo->num_evtchns / EVTCHN_FIFO_EVENT_WORDS_PER_PAGE; if ( slot >= EVTCHN_FIFO_MAX_EVENT_ARRAY_PAGES ) return -ENOSPC; rc = map_guest_page(d, gfn, &virt); if ( rc < 0 ) return rc; d->evtchn_fifo->event_array[slot] = virt; d->evtchn_fifo->num_evtchns += EVTCHN_FIFO_EVENT_WORDS_PER_PAGE; for ( ; port < d->evtchn_fifo->num_evtchns; port++ ) { struct evtchn *evtchn; if ( !port_is_valid(d, port) ) break; evtchn = evtchn_from_port(d, port); if ( evtchn->pending ) evtchn_fifo_set_pending(d->vcpu[evtchn->notify_vcpu_id], evtchn); } return 0; }"
"static int mptcp_disconnect(struct sock *sk, int flags) { struct mptcp_subflow_context *subflow; struct mptcp_sock *msk = mptcp_sk(sk); inet_sk_state_store(sk, TCP_CLOSE); mptcp_for_each_subflow(msk, subflow) { struct sock *ssk = mptcp_subflow_tcp_sock(subflow); __mptcp_close_ssk(sk, ssk, subflow, MPTCP_CF_FASTCLOSE); } mptcp_stop_timer(sk); sk_stop_timer(sk, &sk->sk_timer); if (mptcp_sk(sk)->token) mptcp_event(MPTCP_EVENT_CLOSED, mptcp_sk(sk), NULL, GFP_KERNEL); mptcp_destroy_common(msk); msk->last_snd = NULL; WRITE_ONCE(msk->flags, 0); msk->cb_flags = 0; msk->push_pending = 0; msk->recovery = false; msk->can_ack = false; msk->fully_established = false; msk->rcv_data_fin = false; msk->snd_data_fin_enable = false; msk->rcv_fastclose = false; msk->use_64bit_ack = false; WRITE_ONCE(msk->csum_enabled, mptcp_is_checksum_enabled(sock_net(sk))); mptcp_pm_data_reset(msk); mptcp_ca_reset(sk); sk->sk_shutdown = 0; sk_error_report(sk); return 0; }"
"static GF_Err BD_DecIndexValueReplace(GF_BifsDecoder * codec, GF_BitStream *bs) { GF_Node *new_node; u32 NodeID, ind, field_ind, NumBits, pos; u8 type; GF_Node *node; GF_Err e; GF_FieldInfo field, sffield; NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); node = gf_sg_find_node(codec->current_graph, NodeID); if (!node) return GF_NON_COMPLIANT_BITSTREAM; NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1); ind = gf_bs_read_int(bs, NumBits); e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind); if (e) return e; e = gf_node_get_field(node, field_ind, &field); if (e) return e; if (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM; type = gf_bs_read_int(bs, 2); switch (type) { case 0: pos = gf_bs_read_int(bs, 16); break; case 2: pos = 0; break; case 3: pos = ((GenMFField *) field.far_ptr)->count - 1; break; default: return GF_NON_COMPLIANT_BITSTREAM; } if (field.fieldType == GF_SG_VRML_MFNODE) { new_node = gf_bifs_dec_node(codec, bs, field.NDTtype); if (codec->LastError) { e = codec->LastError; goto exit; } if (new_node) { e = gf_node_register(new_node, node); if (e) return e; } e = gf_node_replace_child(node, (GF_ChildNodeItem**) field.far_ptr, pos, new_node); if (!e) gf_bifs_check_field_change(node, &field); } else { memcpy(&sffield, &field, sizeof(GF_FieldInfo)); sffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType); if (pos && pos >= ((GenMFField *)field.far_ptr)->count) { pos = ((GenMFField *)field.far_ptr)->count - 1; } e = gf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, & sffield.far_ptr, pos); if (e) return e; e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE); if (!e) gf_bifs_check_field_change(node, &field); } exit: return e; }"
"static bool inferBinaryBitwise(BinaryOperatorInst *BOI) { Type LeftTy = BOI->getLeftHandSide()->getType(); Type RightTy = BOI->getRightHandSide()->getType(); Type mayBeBigInt = LeftTy.canBeBigInt() && RightTy.canBeBigInt() ? Type::createBigInt() : Type::createNoType(); BOI->setType(Type::unionTy(Type::createInt32(), mayBeBigInt)); return true; }"
"int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len) { if (rr_nested == NULL || data == NULL || data_len <= 0) { return -1; } if (_dns_left_len(&rr_nested->context) < data_len) { return -1; } memcpy(rr_nested->context.ptr, data, data_len); rr_nested->context.ptr += data_len; return 0; }"
"void * adminchild(struct clientparam* param) { int i, res; char * buf; char username[256]; char *sb; char *req = NULL; struct printparam pp; int contentlen = 0; int isform = 0; pp.inbuf = 0; pp.cp = param; buf = myalloc(LINESIZE); if(!buf) {RETURN(555);} i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S]); if(i<5 || ((buf[0]!='G' || buf[1]!='E' || buf[2]!='T' || buf[3]!=' ' || buf[4]!='/') &&  (buf[0]!='P' || buf[1]!='O' || buf[2]!='S' || buf[3]!='T' || buf[4]!=' ' || buf[5]!='/'))) { RETURN(701); } buf[i] = 0; sb = strchr(buf+5, ' '); if(!sb){ RETURN(702); } *sb = 0; req = mystrdup(buf + ((*buf == 'P')? 6 : 5)); while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '\n', conf.timeouts[STRING_S])) > 2){ buf[i] = 0; if(i > 19 && (!strncasecmp(buf, ""authorization"", 13))){ sb = strchr(buf, ':'); if(!sb)continue; ++sb; while(isspace(*sb))sb++; if(!*sb || strncasecmp(sb, ""basic"", 5)){ continue; } sb+=5; while(isspace(*sb))sb++; i = de64((unsigned char *)sb, (unsigned char *)username, 255); if(i<=0)continue; username[i] = 0; sb = strchr((char *)username, ':'); if(sb){ *sb = 0; if(param->password)myfree(param->password); param->password = (unsigned char *)mystrdup(sb+1); } if(param->username) myfree(param->username); param->username = (unsigned char *)mystrdup(username); continue; } else if(i > 15 && (!strncasecmp(buf, ""content-length:"", 15))){ sb = buf + 15; while(isspace(*sb))sb++; contentlen = atoi(sb); } else if(i > 13 && (!strncasecmp(buf, ""content-type:"", 13))){ sb = buf + 13; while(isspace(*sb))sb++; if(!strncasecmp(sb, ""x-www-form-urlencoded"", 21)) isform = 1; } } param->operation = ADMIN; if(isform && contentlen) { printstr(&pp, ""HTTP/1.0 100 Continue\r\n\r\n""); stdpr(&pp, NULL, 0); } res = (*param->srv->authfunc)(param); if(res && res != 10) { printstr(&pp, authreq); RETURN(res); } if(param->srv->singlepacket || param->redirected){ if(*req == 'C') req[1] = 0; else *req = 0; } sprintf(buf, ok, conf.stringtable?(char *)conf.stringtable[2]:""3proxy"", conf.stringtable?(char *)conf.stringtable[2]:""3[APA3A] tiny proxy"", conf.stringtable?(char *)conf.stringtable[3]:""""); if(*req != 'S') printstr(&pp, buf); switch(*req){ case 'C': printstr(&pp, counters); { struct trafcount *cp;  int num = 0; for(cp = conf.trafcounter; cp; cp = cp->next, num++){ int inbuf = 0; if(cp->ace && (param->srv->singlepacket || param->redirected)){ if(!ACLmatches(cp->ace, param))continue; } if(req[1] == 'S' && atoi(req+2) == num) cp->disabled=0; if(req[1] == 'D' && atoi(req+2) == num) cp->disabled=1; inbuf += sprintf(buf,""<tr>"" ""<td>%s</td><td><A HREF=\'/C%c%d\'>%s</A></td><td>"", (cp->comment)?cp->comment:""&nbsp;"", (cp->disabled)?'S':'D', num, (cp->disabled)?""NO"":""YES"" ); if(!cp->ace || !cp->ace->users){ inbuf += sprintf(buf+inbuf, ""<center>ANY</center>""); } else { inbuf += printuserlist(buf+inbuf, LINESIZE-800, cp->ace->users, "",<br />\r\n""); } inbuf += sprintf(buf+inbuf, ""</td><td>""); if(!cp->ace || !cp->ace->src){ inbuf += sprintf(buf+inbuf, ""<center>ANY</center>""); } else { inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->src, "",<br />\r\n""); } inbuf += sprintf(buf+inbuf, ""</td><td>""); if(!cp->ace || !cp->ace->dst){ inbuf += sprintf(buf+inbuf, ""<center>ANY</center>""); } else { inbuf += printiplist(buf+inbuf, LINESIZE-512, cp->ace->dst, "",<br />\r\n""); } inbuf += sprintf(buf+inbuf, ""</td><td>""); if(!cp->ace || !cp->ace->ports){ inbuf += sprintf(buf+inbuf, ""<center>ANY</center>""); } else { inbuf += printportlist(buf+inbuf, LINESIZE-128, cp->ace->ports, "",<br />\r\n""); } if(cp->type == NONE) { inbuf += sprintf(buf+inbuf, ""</td><td colspan=\'6\' align=\'center\'>exclude from limitation</td></tr>\r\n"" ); } else { inbuf += sprintf(buf+inbuf, ""</td><td>%""PRINTF_INT64_MODIFIER""u</td>"" ""<td>MB%s</td>"" ""<td>%""PRINTF_INT64_MODIFIER""u</td>"" ""<td>%s</td>"", cp->traflim64 / (1024 * 1024), rotations[cp->type], cp->traf64, cp->cleared?ctime(&cp->cleared):""never"" ); inbuf += sprintf(buf + inbuf, ""<td>%s</td>"" ""<td>%i</td>"" ""</tr>\r\n"", cp->updated?ctime(&cp->updated):""never"", cp->number ); } printstr(&pp, buf); } } printstr(&pp, counterstail); break; case 'R': conf.needreload = 1; printstr(&pp, ""<h3>Reload scheduled</h3>""); break; case 'S': { if(req[1] == 'X'){ printstr(&pp, style); break; } printstr(&pp, xml); printval(conf.services, TYPE_SERVER, 0, &pp); printstr(&pp, postxml); } break; case 'F': { FILE *fp; char buf[256]; fp = confopen(); if(!fp){ printstr(&pp, ""<h3><font color=\""red\"">Failed to open config file</font></h3>""); break; } printstr(&pp, ""<h3>Please be careful editing config file remotely</h3>""); printstr(&pp, ""<form method=\""POST\"" action=\""/U\""><textarea cols=\""80\"" rows=\""30\"" name=\""conffile\"">""); while(fgets(buf, 256, fp)){ printstr(&pp, buf); } if(!writable) fclose(fp); printstr(&pp, ""</textarea><br><input type=\""Submit\""></form>""); break; } case 'U': { int l=0; int error = 0; if(!writable || fseek(writable, 0, 0)){ error = 1; } while((i = sockgetlinebuf(param, CLIENT, (unsigned char *)buf, LINESIZE - 1, '+', conf.timeouts[STRING_S])) > 0){ if(i > (contentlen - l)) i = (contentlen - l); buf[i] = 0; if(!l){ if(strncasecmp(buf, ""conffile="", 9)) error = 1; } if(!error){ decodeurl((unsigned char *)buf, 1); fprintf(writable, ""%s"", l? buf : buf + 9); } l += i; if(l >= contentlen) break; } if(writable && !error){ fflush(writable); #ifndef _WINCE ftruncate(fileno(writable), ftell(writable)); #endif } printstr(&pp, error?    ""<h3><font color=\""red\"">Config file is not writable</font></h3>Make sure you have \""writable\"" command in configuration file"": ""<h3>Configuration updated</h3>""); } break; default: printstr(&pp, (char *)conf.stringtable[WEBBANNERS]); break; } if(*req != 'S') printstr(&pp, tail); CLEANRET: printstr(&pp, NULL); if(buf) myfree(buf); (*param->srv->logfunc)(param, (unsigned char *)req); if(req)myfree(req); freeparam(param); return (NULL); }"
"static void outbound_phy_packet_callback(struct fw_packet *packet, struct fw_card *card, int status) { struct outbound_phy_packet_event *e = container_of(packet, struct outbound_phy_packet_event, p); switch (status) { case ACK_COMPLETE:e->phy_packet.rcode = RCODE_COMPLETE;break; case ACK_PENDING:e->phy_packet.rcode = RCODE_COMPLETE;break; case ACK_BUSY_X: case ACK_BUSY_A: case ACK_BUSY_B:e->phy_packet.rcode = RCODE_BUSY;break; case ACK_DATA_ERROR:e->phy_packet.rcode = RCODE_DATA_ERROR;break; case ACK_TYPE_ERROR:e->phy_packet.rcode = RCODE_TYPE_ERROR;break; default:e->phy_packet.rcode = status;break; } e->phy_packet.data[0] = packet->timestamp; queue_event(e->client, &e->event, &e->phy_packet, sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0); client_put(e->client); }"
"static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst, uint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu, gatt_connect_cb_t connect_cb, io_connect_arg_t* io_connect_arg) { bdaddr_t sba, dba; GError *err = NULL; if (g_gattlib_thread.ref == 0) { int error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread); if (error != 0) { fprintf(stderr, ""Cannot create connection thread: %s"", strerror(error)); return NULL; } while (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) { usleep(1000); } } else { g_gattlib_thread.ref++; } if (dst == NULL) { fprintf(stderr, ""Remote Bluetooth address required\n""); return NULL; } str2ba(dst, &dba); if (src != NULL) { if (!strncmp(src, ""hci"", 3)) hci_devba(atoi(src + 3), &sba); else str2ba(src, &sba); } else bacpy(&sba, BDADDR_ANY); if ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) { return NULL; } if ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) { return NULL; } gattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1); if (conn_context == NULL) { return NULL; } gatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1); if (conn == NULL) { return NULL; } conn->context = conn_context; io_connect_arg->conn       = conn; io_connect_arg->connect_cb = connect_cb; io_connect_arg->connected  = FALSE; io_connect_arg->timeout    = FALSE; io_connect_arg->error      = NULL; if (psm == 0) { conn_context->io = bt_io_connect( #if BLUEZ_VERSION_MAJOR == 4 BT_IO_L2CAP, #endif io_connect_cb, io_connect_arg, NULL, &err, BT_IO_OPT_SOURCE_BDADDR, &sba, #if BLUEZ_VERSION_MAJOR == 5 BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC, #endif BT_IO_OPT_DEST_BDADDR, &dba, BT_IO_OPT_DEST_TYPE, dest_type, BT_IO_OPT_CID, ATT_CID, BT_IO_OPT_SEC_LEVEL, sec_level, BT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT, BT_IO_OPT_INVALID); } else { conn_context->io = bt_io_connect( #if BLUEZ_VERSION_MAJOR == 4 BT_IO_L2CAP, #endif io_connect_cb, io_connect_arg, NULL, &err, BT_IO_OPT_SOURCE_BDADDR, &sba, #if BLUEZ_VERSION_MAJOR == 5 BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC, #endif BT_IO_OPT_DEST_BDADDR, &dba, BT_IO_OPT_PSM, psm, BT_IO_OPT_IMTU, mtu, BT_IO_OPT_SEC_LEVEL, sec_level, BT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT, BT_IO_OPT_INVALID); } if (err) { fprintf(stderr, ""%s\n"", err->message); g_error_free(err); free(conn_context); free(conn); return NULL; } else { return conn; } }"
"void proto_register_cbor(void) { static hf_register_info hf[] = { { &hf_cbor_item_major_type, { ""Major Type"", ""cbor.item.major_type"", FT_UINT8, BASE_DEC, VALS(major_type_vals), 0xe0, NULL, HFILL } }, { &hf_cbor_item_integer_size, { ""Size"", ""cbor.item.size"", FT_UINT8, BASE_DEC, VALS(integer_size_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_length_size, { ""Size"", ""cbor.item.size"", FT_UINT8, BASE_DEC, VALS(length_size_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_length5, { ""Length"", ""cbor.item.length5"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_length, { ""Length"", ""cbor.item.length"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_items5, { ""Items"", ""cbor.item.items5"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_items, { ""Items"", ""cbor.item.items"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_pairs5, { ""Pairs"", ""cbor.item.pairs"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_item_pairs, { ""Pairs"", ""cbor.item.pairs"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_float_simple_type, { ""Type"", ""cbor.item.float_simple_type"", FT_UINT8, BASE_DEC, VALS(float_simple_type_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_item_unsigned_integer, { ""Unsigned Integer"", ""cbor.item.unsigned_integer"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_negative_integer, { ""Negative Integer"", ""cbor.item.negative_integer"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_text_string, { ""Text String"", ""cbor.item.textstring"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_byte_string, { ""Byte String"", ""cbor.item.bytestring"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_array, { ""Array"", ""cbor.item.array"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_map, { ""Map"", ""cbor.item.map"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_tag, { ""Tag"", ""cbor.item.tag"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_item_float_simple, { ""Floating-point or Simple"", ""cbor.item.float_or_simple"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_uint5, { ""Unsigned Integer"", ""cbor.type.uint"", FT_UINT8, BASE_DEC, NULL, 0x1f, NULL, HFILL } }, { &hf_cbor_type_uint, { ""Unsigned Integer"", ""cbor.type.uint"", FT_UINT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_nint, { ""Negative Integer"", ""cbor.type.nint"", FT_INT64, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_byte_string, { ""Byte String"", ""cbor.type.bytestring"", FT_BYTES, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_byte_string_indef, { ""Byte String (indefinite length)"", ""cbor.type.bytestring.indef"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_cbor_type_text_string, { ""Text String"", ""cbor.type.textstring"", FT_STRING, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_text_string_indef, { ""Text String (indefinite length)"", ""cbor.type.textstring.indef"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_cbor_type_tag5, { ""Tag"", ""cbor.type.tag"", FT_UINT8, BASE_DEC, VALS(tag32_vals), 0x1f, NULL, HFILL } }, { &hf_cbor_type_tag, { ""Tag"", ""cbor.type.tag"", FT_UINT64, BASE_DEC|BASE_VAL64_STRING, VALS64(tag64_vals), 0x00, NULL, HFILL } }, { &hf_cbor_type_simple_data5, { ""Simple data"", ""cbor.type.simple_data"", FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x1f, NULL, HFILL } }, { &hf_cbor_type_simple_data8, { ""Simple data"", ""cbor.type.simple_data"", FT_UINT8, BASE_DEC, VALS(vals_simple_data), 0x00, NULL, HFILL } }, { &hf_cbor_type_float16, { ""Float 16 Bit"", ""cbor.type.float16"", FT_FLOAT, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_float32, { ""Float 32 Bit"", ""cbor.type.float32"", FT_FLOAT, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_cbor_type_float64, { ""Float 64 Bit"", ""cbor.type.float64"", FT_DOUBLE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, }; static gint *ett[] = { &ett_cbor, &ett_cbor_type, &ett_cbor_unsigned_integer, &ett_cbor_negative_integer, &ett_cbor_byte_string, &ett_cbor_byte_string_indef, &ett_cbor_text_string, &ett_cbor_text_string_indef, &ett_cbor_array, &ett_cbor_map, &ett_cbor_tag, &ett_cbor_float_simple }; static ei_register_info ei[] = { { &ei_cbor_invalid_minor_type, { ""cbor.invalid_minor_type"", PI_MALFORMED, PI_WARN, ""Invalid minor type"", EXPFILL }}, { &ei_cbor_invalid_element, { ""cbor.invalid_element"", PI_MALFORMED, PI_WARN, ""Invalid element"", EXPFILL }}, { &ei_cbor_too_long_length, { ""cbor.too_long_length"", PI_MALFORMED, PI_WARN, ""Too long length"", EXPFILL }}, }; expert_module_t *expert_cbor; proto_cbor = proto_register_protocol(""Concise Binary Object Representation"", ""CBOR"", ""cbor""); proto_register_field_array(proto_cbor, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_cbor = expert_register_protocol(proto_cbor); expert_register_field_array(expert_cbor, ei, array_length(ei)); cbor_handle = register_dissector(""cbor"", dissect_cbor, proto_cbor); cborseq_handle = register_dissector(""cborseq"", dissect_cborseq, proto_cbor); }"
"int ImagingLibTiffDecode(Imaging im, ImagingCodecState state, UINT8* buffer, Py_ssize_t bytes) { TIFFSTATE *clientstate = (TIFFSTATE *)state->context; char *filename = ""tempfile.tif""; char *mode = ""r""; TIFF *tiff; TRACE((""in decoder: bytes %d\n"", bytes)); TRACE((""State: count %d, state %d, x %d, y %d, ystep %d\n"", state->count, state->state, state->x, state->y, state->ystep)); TRACE((""State: xsize %d, ysize %d, xoff %d, yoff %d \n"", state->xsize, state->ysize, state->xoff, state->yoff)); TRACE((""State: bits %d, bytes %d \n"", state->bits, state->bytes)); TRACE((""Buffer: %p: %c%c%c%c\n"", buffer, (char)buffer[0], (char)buffer[1],(char)buffer[2], (char)buffer[3])); TRACE((""State->Buffer: %c%c%c%c\n"", (char)state->buffer[0], (char)state->buffer[1],(char)state->buffer[2], (char)state->buffer[3])); TRACE((""Image: mode %s, type %d, bands: %d, xsize %d, ysize %d \n"", im->mode, im->type, im->bands, im->xsize, im->ysize)); TRACE((""Image: image8 %p, image32 %p, image %p, block %p \n"", im->image8, im->image32, im->image, im->block)); TRACE((""Image: pixelsize: %d, linesize %d \n"", im->pixelsize, im->linesize)); dump_state(clientstate); clientstate->size = bytes; clientstate->eof = clientstate->size; clientstate->loc = 0; clientstate->data = (tdata_t)buffer; clientstate->flrealloc = 0; dump_state(clientstate); TIFFSetWarningHandler(NULL); TIFFSetWarningHandlerExt(NULL); if (clientstate->fp) { TRACE((""Opening using fd: %d\n"",clientstate->fp)); lseek(clientstate->fp,0,SEEK_SET);         tiff = TIFFFdOpen(clientstate->fp, filename, mode); } else { TRACE((""Opening from string\n"")); tiff = TIFFClientOpen(filename, mode, (thandle_t) clientstate, _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc, _tiffSizeProc, _tiffMapProc, _tiffUnmapProc); } if (!tiff){ TRACE((""Error, didn't get the tiff\n"")); state->errcode = IMAGING_CODEC_BROKEN; return -1; } if (clientstate->ifd){ int rv; uint32 ifdoffset = clientstate->ifd; TRACE((""reading tiff ifd %u\n"", ifdoffset)); rv = TIFFSetSubDirectory(tiff, ifdoffset); if (!rv){ TRACE((""error in TIFFSetSubDirectory"")); return -1; } } if (TIFFIsTiled(tiff)) { UINT32 x, y, tile_y, row_byte_size; UINT32 tile_width, tile_length, current_tile_width; UINT8 *new_data; TIFFGetField(tiff, TIFFTAG_TILEWIDTH, &tile_width); TIFFGetField(tiff, TIFFTAG_TILELENGTH, &tile_length); row_byte_size = (tile_width * state->bits + 7) / 8; state->bytes = row_byte_size * tile_length; if (state->bytes > INT_MAX - 1) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } new_data = realloc (state->buffer, state->bytes); if (!new_data) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } state->buffer = new_data; TRACE((""TIFFTileSize: %d\n"", state->bytes)); for (y = state->yoff; y < state->ysize; y += tile_length) { for (x = state->xoff; x < state->xsize; x += tile_width) { if (ReadTile(tiff, x, y, (UINT32*) state->buffer) == -1) { TRACE((""Decode Error, Tile at %dx%d\n"", x, y)); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } TRACE((""Read tile at %dx%d; \n\n"", x, y)); current_tile_width = min(tile_width, state->xsize - x); for (tile_y = 0; tile_y < min(tile_length, state->ysize - y); tile_y++) { TRACE((""Writing tile data at %dx%d using tile_width: %d; \n"", tile_y + y, x, current_tile_width)); state->shuffle((UINT8*) im->image[tile_y + y] + x * im->pixelsize, state->buffer + tile_y * row_byte_size, current_tile_width ); } } } } else { UINT32 strip_row, row_byte_size; UINT8 *new_data; UINT32 rows_per_strip; int ret; ret = TIFFGetField(tiff, TIFFTAG_ROWSPERSTRIP, &rows_per_strip); if (ret != 1) { rows_per_strip = state->ysize; } TRACE((""RowsPerStrip: %u \n"", rows_per_strip)); row_byte_size = (state->xsize * state->bits + 7) / 8; state->bytes = rows_per_strip * row_byte_size; TRACE((""StripSize: %d \n"", state->bytes)); new_data = realloc (state->buffer, state->bytes); if (!new_data) { state->errcode = IMAGING_CODEC_MEMORY; TIFFClose(tiff); return -1; } state->buffer = new_data; for (; state->y < state->ysize; state->y += rows_per_strip) { if (ReadStrip(tiff, state->y, (UINT32 *)state->buffer) == -1) { TRACE((""Decode Error, strip %d\n"", TIFFComputeStrip(tiff, state->y, 0))); state->errcode = IMAGING_CODEC_BROKEN; TIFFClose(tiff); return -1; } TRACE((""Decoded strip for row %d \n"", state->y)); for (strip_row = 0; strip_row < min(rows_per_strip, state->ysize - state->y); strip_row++) { TRACE((""Writing data into line %d ; \n"", state->y + strip_row)); state->shuffle((UINT8*) im->image[state->y + state->yoff + strip_row] + state->xoff * im->pixelsize, state->buffer + strip_row * row_byte_size, state->xsize); } } } TIFFClose(tiff); TRACE((""Done Decoding, Returning \n"")); return -1; }"
"static int dccp_print_option(netdissect_options *ndo, const u_char *option, u_int hlen) { uint8_t optlen, i; ND_TCHECK(*option); if (*option >= 32) { ND_TCHECK(*(option+1)); optlen = *(option +1); if (optlen < 2) { if (*option >= 128) ND_PRINT((ndo, ""CCID option %u optlen too short"", *option)); else ND_PRINT((ndo, ""%s optlen too short"", tok2str(dccp_option_values, ""Option %u"", *option))); return 0; } } else optlen = 1; if (hlen < optlen) { if (*option >= 128) ND_PRINT((ndo, ""CCID option %u optlen goes past header length"", *option)); else ND_PRINT((ndo, ""%s optlen goes past header length"", tok2str(dccp_option_values, ""Option %u"", *option))); return 0; } ND_TCHECK2(*option, optlen); if (*option >= 128) { ND_PRINT((ndo, ""CCID option %d"", *option)); switch (optlen) { case 4: ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2))); break; case 6: ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2))); break; default: break; } } else { ND_PRINT((ndo, ""%s"", tok2str(dccp_option_values, ""Option %u"", *option))); switch (*option) { case 32: case 33: case 34: case 35: if (optlen < 3) { ND_PRINT((ndo, "" optlen too short"")); return optlen; } if (*(option + 2) < 10){ ND_PRINT((ndo, "" %s"", dccp_feature_nums[*(option + 2)])); for (i = 0; i < optlen - 3; i++) ND_PRINT((ndo, "" %d"", *(option + 3 + i))); } break; case 36: if (optlen > 2) { ND_PRINT((ndo, "" 0x"")); for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, ""%02x"", *(option + 2 + i))); } break; case 37: for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, "" %d"", *(option + 2 + i))); break; case 38: if (optlen > 2) { ND_PRINT((ndo, "" 0x"")); for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, ""%02x"", *(option + 2 + i))); } break; case 39: if (optlen > 2) { ND_PRINT((ndo, "" 0x"")); for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, ""%02x"", *(option + 2 + i))); } break; case 40: if (optlen > 2) { ND_PRINT((ndo, "" 0x"")); for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, ""%02x"", *(option + 2 + i))); } break; case 41: if (optlen == 4) ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2))); else ND_PRINT((ndo, "" optlen != 4"")); break; case 42: if (optlen == 4) ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2))); else ND_PRINT((ndo, "" optlen != 4"")); break; case 43: if (optlen == 6) ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2))); else if (optlen == 4) ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2))); else ND_PRINT((ndo, "" optlen != 4 or 6"")); break; case 44: if (optlen > 2) { ND_PRINT((ndo, "" "")); for (i = 0; i < optlen - 2; i++) ND_PRINT((ndo, ""%02x"", *(option + 2 + i))); } break; } } return optlen; trunc: ND_PRINT((ndo, ""%s"", tstr)); return 0; }"
"static void win_exchange(long Prenum) { frame_T*frp; frame_T*frp2; win_T*wp; win_T*wp2; inttemp; if (ERROR_IF_ANY_POPUP_WINDOW) return; if (ONE_WINDOW)        { beep_flush(); return; } #ifdef FEAT_GUI need_mouse_correct = TRUE; #endif if (Prenum) { frp = curwin->w_frame->fr_parent->fr_child; while (frp != NULL && --Prenum > 0) frp = frp->fr_next; } else if (curwin->w_frame->fr_next != NULL)frp = curwin->w_frame->fr_next; else    frp = curwin->w_frame->fr_prev; if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin) return; wp = frp->fr_win; wp2 = curwin->w_prev; frp2 = curwin->w_frame->fr_prev; if (wp->w_prev != curwin) { win_remove(curwin, NULL); frame_remove(curwin->w_frame); win_append(wp->w_prev, curwin); frame_insert(frp, curwin->w_frame); } if (wp != wp2) { win_remove(wp, NULL); frame_remove(wp->w_frame); win_append(wp2, wp); if (frp2 == NULL) frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame); else frame_append(frp2, wp->w_frame); } temp = curwin->w_status_height; curwin->w_status_height = wp->w_status_height; wp->w_status_height = temp; temp = curwin->w_vsep_width; curwin->w_vsep_width = wp->w_vsep_width; wp->w_vsep_width = temp; frame_fix_height(curwin); frame_fix_height(wp); frame_fix_width(curwin); frame_fix_width(wp); (void)win_comp_pos(); if (wp->w_buffer != curbuf) reset_VIsual_and_resel(); else if (VIsual_active) wp->w_cursor = curwin->w_cursor; win_enter(wp, TRUE); redraw_all_later(UPD_NOT_VALID); }"
"void xfrm_state_fini(struct net *net) { unsigned int sz; flush_work(&net->xfrm.state_hash_work); flush_work(&xfrm_state_gc_work); xfrm_state_flush(net, IPSEC_PROTO_ANY, false, true); WARN_ON(!list_empty(&net->xfrm.state_all)); sz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head); WARN_ON(!hlist_empty(net->xfrm.state_byspi)); xfrm_hash_free(net->xfrm.state_byspi, sz); WARN_ON(!hlist_empty(net->xfrm.state_bysrc)); xfrm_hash_free(net->xfrm.state_bysrc, sz); WARN_ON(!hlist_empty(net->xfrm.state_bydst)); xfrm_hash_free(net->xfrm.state_bydst, sz); }"
"struct form_item_list * formList_addInput(struct form_list *fl, struct parsed_tag *tag) { struct form_item_list *item; char *p; int i; if (fl == NULL) return NULL; item = New(struct form_item_list); item->type = FORM_UNKNOWN; item->size = -1; item->rows = 0; item->checked = item->init_checked = 0; item->accept = 0; item->name = NULL; item->value = item->init_value = NULL; item->readonly = 0; if (parsedtag_get_value(tag, ATTR_TYPE, &p)) { item->type = formtype(p); if (item->size < 0 && (item->type == FORM_INPUT_TEXT || item->type == FORM_INPUT_FILE || item->type == FORM_INPUT_PASSWORD)) item->size = FORM_I_TEXT_DEFAULT_SIZE; } if (parsedtag_get_value(tag, ATTR_NAME, &p)) item->name = Strnew_charp(p); if (parsedtag_get_value(tag, ATTR_VALUE, &p)) item->value = item->init_value = Strnew_charp(p); item->checked = item->init_checked = parsedtag_exists(tag, ATTR_CHECKED); item->accept = parsedtag_exists(tag, ATTR_ACCEPT); parsedtag_get_value(tag, ATTR_SIZE, &item->size); parsedtag_get_value(tag, ATTR_MAXLENGTH, &item->maxlength); item->readonly = parsedtag_exists(tag, ATTR_READONLY); if (parsedtag_get_value(tag, ATTR_TEXTAREANUMBER, &i)) item->value = item->init_value = textarea_str[i]; #ifdef MENU_SELECT if (parsedtag_get_value(tag, ATTR_SELECTNUMBER, &i)) item->select_option = select_option[i].first; #endif if (parsedtag_get_value(tag, ATTR_ROWS, &p)) item->rows = atoi(p); if (item->type == FORM_UNKNOWN) { return NULL; } #ifdef MENU_SELECT if (item->type == FORM_SELECT) { chooseSelectOption(item, item->select_option); item->init_selected = item->selected; item->init_value = item->value; item->init_label = item->label; } #endif if (item->type == FORM_INPUT_FILE && item->value && item->value->length) { return NULL; } item->parent = fl; item->next = NULL; if (fl->item == NULL) { fl->item = fl->lastitem = item; } else { fl->lastitem->next = item; fl->lastitem = item; } if (item->type == FORM_INPUT_HIDDEN) return NULL; fl->nitems++; return item; }"
"static void pdf_process_extgstate(fz_context *ctx, pdf_processor *proc, pdf_csi *csi, pdf_obj *dict) { pdf_obj *obj; obj = pdf_dict_get(ctx, dict, PDF_NAME_LW); if (pdf_is_number(ctx, obj) && proc->op_w) proc->op_w(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LC); if (pdf_is_int(ctx, obj) && proc->op_J) proc->op_J(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_LJ); if (pdf_is_int(ctx, obj) && proc->op_j) proc->op_j(ctx, proc, fz_clampi(pdf_to_int(ctx, obj), 0, 2)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ML); if (pdf_is_number(ctx, obj) && proc->op_M) proc->op_M(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_D); if (pdf_is_array(ctx, obj) && proc->op_d) { pdf_obj *dash_array = pdf_array_get(ctx, obj, 0); pdf_obj *dash_phase = pdf_array_get(ctx, obj, 1); proc->op_d(ctx, proc, dash_array, pdf_to_real(ctx, dash_phase)); } obj = pdf_dict_get(ctx, dict, PDF_NAME_RI); if (pdf_is_name(ctx, obj) && proc->op_ri) proc->op_ri(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_FL); if (pdf_is_number(ctx, obj) && proc->op_i) proc->op_i(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_Font); if (pdf_is_array(ctx, obj) && proc->op_Tf) { pdf_obj *font_ref = pdf_array_get(ctx, obj, 0); pdf_obj *font_size = pdf_array_get(ctx, obj, 1); pdf_font_desc *font = load_font_or_hail_mary(ctx, csi->doc, csi->rdb, font_ref, 0, csi->cookie); fz_try(ctx) proc->op_Tf(ctx, proc, ""ExtGState"", font, pdf_to_real(ctx, font_size)); fz_always(ctx) pdf_drop_font(ctx, font); fz_catch(ctx) fz_rethrow(ctx); } obj = pdf_dict_get(ctx, dict, PDF_NAME_OP); if (pdf_is_bool(ctx, obj) && proc->op_gs_OP) proc->op_gs_OP(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_op); if (pdf_is_bool(ctx, obj) && proc->op_gs_op) proc->op_gs_op(ctx, proc, pdf_to_bool(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_OPM); if (pdf_is_int(ctx, obj) && proc->op_gs_OPM) proc->op_gs_OPM(ctx, proc, pdf_to_int(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_UseBlackPtComp); if (pdf_is_name(ctx, obj) && proc->op_gs_UseBlackPtComp) proc->op_gs_UseBlackPtComp(ctx, proc, obj); obj = pdf_dict_get(ctx, dict, PDF_NAME_TR2); if (pdf_is_name(ctx, obj)) if (!pdf_name_eq(ctx, obj, PDF_NAME_Identity) && !pdf_name_eq(ctx, obj, PDF_NAME_Default)) fz_warn(ctx, ""ignoring transfer function""); if (!obj)  { pdf_obj *tr = pdf_dict_get(ctx, dict, PDF_NAME_TR); if (pdf_is_name(ctx, tr)) if (!pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); } obj = pdf_dict_get(ctx, dict, PDF_NAME_CA); if (pdf_is_number(ctx, obj) && proc->op_gs_CA) proc->op_gs_CA(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_ca); if (pdf_is_number(ctx, obj) && proc->op_gs_ca) proc->op_gs_ca(ctx, proc, pdf_to_real(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_BM); if (pdf_is_array(ctx, obj)) obj = pdf_array_get(ctx, obj, 0); if (pdf_is_name(ctx, obj) && proc->op_gs_BM) proc->op_gs_BM(ctx, proc, pdf_to_name(ctx, obj)); obj = pdf_dict_get(ctx, dict, PDF_NAME_SMask); if (proc->op_gs_SMask) { if (pdf_is_dict(ctx, obj)) { pdf_xobject *xobj; pdf_obj *group, *s, *bc, *tr; float softmask_bc[FZ_MAX_COLORS]; fz_colorspace *colorspace; int colorspace_n = 1; int k, luminosity; fz_var(xobj); group = pdf_dict_get(ctx, obj, PDF_NAME_G); if (!group) fz_throw(ctx, FZ_ERROR_SYNTAX, ""cannot load softmask xobject (%d 0 R)"", pdf_to_num(ctx, obj)); xobj = pdf_load_xobject(ctx, csi->doc, group); fz_try(ctx) { colorspace = pdf_xobject_colorspace(ctx, xobj); if (colorspace) colorspace_n = fz_colorspace_n(ctx, colorspace); for (k = 0; k < colorspace_n; k++) softmask_bc[k] = 0; if (fz_colorspace_is_cmyk(ctx, colorspace)) softmask_bc[3] = 1.0f; fz_drop_colorspace(ctx, colorspace); bc = pdf_dict_get(ctx, obj, PDF_NAME_BC); if (pdf_is_array(ctx, bc)) { for (k = 0; k < colorspace_n; k++) softmask_bc[k] = pdf_to_real(ctx, pdf_array_get(ctx, bc, k)); } s = pdf_dict_get(ctx, obj, PDF_NAME_S); if (pdf_name_eq(ctx, s, PDF_NAME_Luminosity)) luminosity = 1; else luminosity = 0; tr = pdf_dict_get(ctx, obj, PDF_NAME_TR); if (tr && !pdf_name_eq(ctx, tr, PDF_NAME_Identity)) fz_warn(ctx, ""ignoring transfer function""); proc->op_gs_SMask(ctx, proc, xobj, csi->rdb, softmask_bc, luminosity); } fz_always(ctx) { pdf_drop_xobject(ctx, xobj); } fz_catch(ctx) { fz_rethrow(ctx); } } else if (pdf_is_name(ctx, obj) && pdf_name_eq(ctx, obj, PDF_NAME_None)) { proc->op_gs_SMask(ctx, proc, NULL, NULL, NULL, 0); } } }"
"void* checked_xmalloc (size_t size) { alloc_limit_assert (""checked_xmalloc"", size); return xmalloc (size); }"
"RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server, GeneralRequest* request, GeneralResponse* response) : RestVocbaseBaseHandler(server, request, response), _validFor(60 * 60 * 24 * 30) {}"
void ConnectDialog::on_qaUrl_triggered() { ServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem()); if (! si || si->qsUrl.isEmpty()) return; QDesktopServices::openUrl(QUrl(si->qsUrl)); }
"int verifyAttribute(struct MYSOFA_ATTRIBUTE *attr, char *name, char *value) { while (attr) { if (!strcmp(name, attr->name) && !strcmp(value, attr->value)) return 1; attr = attr->next; } return 0; }"
void rose_start_t3timer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); del_timer(&rose->timer); rose->timer.function = rose_timer_expiry; rose->timer.expires  = jiffies + rose->t3; add_timer(&rose->timer); }
"static void inline shadow_put_page_from_l1e(shadow_l1e_t sl1e, struct domain *d) { mfn_t mfn = shadow_l1e_get_mfn(sl1e); if ( !shadow_mode_refcounts(d) ) return; if ( mfn_valid(mfn) && page_refcounting_suppressed(mfn_to_page(mfn)) ) return; put_page_from_l1e(sl1e, d); }"
"static void print_trans(netdissect_options *ndo, const u_char *words, const u_char *data1, const u_char *buf, const u_char *maxbuf) { u_int bcc; const char *f1, *f2, *f3, *f4; const u_char *data, *param; const u_char *w = words + 1; int datalen, paramlen; if (request) { ND_TCHECK2(w[12 * 2], 2); paramlen = EXTRACT_LE_16BITS(w + 9 * 2); param = buf + EXTRACT_LE_16BITS(w + 10 * 2); datalen = EXTRACT_LE_16BITS(w + 11 * 2); data = buf + EXTRACT_LE_16BITS(w + 12 * 2); f1 = ""TotParamCnt=[d] \nTotDataCnt=[d] \nMaxParmCnt=[d] \nMaxDataCnt=[d]\nMaxSCnt=[d] \nTransFlags=[w] \nRes1=[w] \nRes2=[w] \nRes3=[w]\nParamCnt=[d] \nParamOff=[d] \nDataCnt=[d] \nDataOff=[d] \nSUCnt=[d]\n""; f2 = ""|Name=[S]\n""; f3 = ""|Param ""; f4 = ""|Data ""; } else { ND_TCHECK2(w[7 * 2], 2); paramlen = EXTRACT_LE_16BITS(w + 3 * 2); param = buf + EXTRACT_LE_16BITS(w + 4 * 2); datalen = EXTRACT_LE_16BITS(w + 6 * 2); data = buf + EXTRACT_LE_16BITS(w + 7 * 2); f1 = ""TotParamCnt=[d] \nTotDataCnt=[d] \nRes1=[d]\nParamCnt=[d] \nParamOff=[d] \nRes2=[d] \nDataCnt=[d] \nDataOff=[d] \nRes3=[d]\nLsetup=[d]\n""; f2 = ""|Unknown ""; f3 = ""|Param ""; f4 = ""|Data ""; } smb_fdata(ndo, words + 1, f1, min(words + 1 + 2 * words[0], maxbuf), unicodestr); ND_TCHECK2(*data1, 2); bcc = EXTRACT_LE_16BITS(data1); ND_PRINT((ndo, ""smb_bcc=%u\n"", bcc)); if (bcc > 0) { smb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr); if (strcmp((const char *)(data1 + 2), ""\\MAILSLOT\\BROWSE"") == 0) { print_browse(ndo, param, paramlen, data, datalen); return; } if (strcmp((const char *)(data1 + 2), ""\\PIPE\\LANMAN"") == 0) { print_ipc(ndo, param, paramlen, data, datalen); return; } if (paramlen) smb_fdata(ndo, param, f3, min(param + paramlen, maxbuf), unicodestr); if (datalen) smb_fdata(ndo, data, f4, min(data + datalen, maxbuf), unicodestr); } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
"static void stub_recv_cmd_submit(struct stub_device *sdev, struct usbip_header *pdu) { int ret; struct stub_priv *priv; struct usbip_device *ud = &sdev->ud; struct usb_device *udev = sdev->udev; int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction); priv = stub_priv_alloc(sdev, pdu); if (!priv) return; if (usb_pipeisoc(pipe)) priv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets, GFP_KERNEL); else priv->urb = usb_alloc_urb(0, GFP_KERNEL); if (!priv->urb) { usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } if (pdu->u.cmd_submit.transfer_buffer_length > 0) { priv->urb->transfer_buffer = kzalloc(pdu->u.cmd_submit.transfer_buffer_length, GFP_KERNEL); if (!priv->urb->transfer_buffer) { usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } } priv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8, GFP_KERNEL); if (!priv->urb->setup_packet) { dev_err(&udev->dev, ""allocate setup_packet\n""); usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } priv->urb->context                = (void *) priv; priv->urb->dev                    = udev; priv->urb->pipe                   = pipe; priv->urb->complete               = stub_complete; usbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0); if (usbip_recv_xbuff(ud, priv->urb) < 0) return; if (usbip_recv_iso(ud, priv->urb) < 0) return; tweak_special_requests(priv->urb); masking_bogus_flags(priv->urb); ret = usb_submit_urb(priv->urb, GFP_KERNEL); if (ret == 0) usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"", pdu->base.seqnum); else { dev_err(&udev->dev, ""submit_urb error, %d\n"", ret); usbip_dump_header(pdu); usbip_dump_urb(priv->urb); usbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT); } usbip_dbg_stub_rx(""Leave\n""); }"
"static void parse_publish_vhdr(struct mqtt_connection *conn, uint32_t *pos, const uint8_t *input_data_ptr, int input_data_len) { uint16_t copy_bytes; if(conn->in_packet.topic_len_received == 0) { conn->in_packet.topic_pos = 0; conn->in_packet.topic_len = (input_data_ptr[(*pos)++] << 8); conn->in_packet.byte_counter++; if(*pos >= input_data_len) { return; } conn->in_packet.topic_len |= input_data_ptr[(*pos)++]; conn->in_packet.byte_counter++; conn->in_packet.topic_len_received = 1; DBG(""MQTT - Read PUBLISH topic len %i\n"", conn->in_packet.topic_len); } if(conn->in_packet.topic_len_received == 1 && conn->in_packet.topic_received == 0) { copy_bytes = MIN(conn->in_packet.topic_len - conn->in_packet.topic_pos, input_data_len - *pos); DBG(""MQTT - topic_pos: %i copy_bytes: %i"", conn->in_packet.topic_pos, copy_bytes); memcpy(&conn->in_publish_msg.topic[conn->in_packet.topic_pos], &input_data_ptr[*pos], copy_bytes); (*pos) += copy_bytes; conn->in_packet.byte_counter += copy_bytes; conn->in_packet.topic_pos += copy_bytes; if(conn->in_packet.topic_len - conn->in_packet.topic_pos == 0) { DBG(""MQTT - Got topic '%s'"", conn->in_publish_msg.topic); conn->in_packet.topic_received = 1; conn->in_publish_msg.topic[conn->in_packet.topic_pos] = '\0'; conn->in_publish_msg.payload_length = conn->in_packet.remaining_length - conn->in_packet.topic_len - 2; conn->in_publish_msg.payload_left = conn->in_publish_msg.payload_length; } conn->in_publish_msg.first_chunk = 1; } }"
void rsi_mac80211_detach(struct rsi_hw *adapter) { struct ieee80211_hw *hw = adapter->hw; enum nl80211_band band; if (hw) { ieee80211_stop_queues(hw); ieee80211_unregister_hw(hw); ieee80211_free_hw(hw); } for (band = 0; band < NUM_NL80211_BANDS; band++) { struct ieee80211_supported_band *sband = &adapter->sbands[band]; kfree(sband->channels); } #ifdef CONFIG_RSI_DEBUGFS rsi_remove_dbgfs(adapter); kfree(adapter->dfsentry); #endif }
"bool HTTPAuthorized(map<string, string>& mapHeaders) { string strAuth = mapHeaders[""authorization""]; if (strAuth.substr(0,6) != ""Basic "") return false; string strUserPass64 = strAuth.substr(6); boost::trim(strUserPass64); string strUserPass = DecodeBase64(strUserPass64); return strUserPass == strRPCUserColonPass; }"
"size_t Xml::Leanify(size_t size_leanified ) { RemovePCDataSingle(doc_); if (doc_.child(""FictionBook"")) { VerbosePrint(""FB2 detected.""); if (depth < max_depth) { depth++; pugi::xml_node root = doc_.child(""FictionBook""); for (pugi::xml_node binary = root.child(""binary""), next; binary; binary = next) { next = binary.next_sibling(""binary""); pugi::xml_attribute id = binary.attribute(""id""); if (id == nullptr || id.value() == nullptr || id.value()[0] == 0) { root.remove_child(binary); continue; } PrintFileName(id.value()); const char* base64_data = binary.child_value(); if (base64_data == nullptr || base64_data[0] == 0) { VerbosePrint(""No data found.""); continue; } size_t base64_len = strlen(base64_data); std::vector<char> new_base64_data(base64_data, base64_data + base64_len + 1); size_t new_base64_len = Base64(new_base64_data.data(), base64_len).Leanify(); if (new_base64_len < base64_len) { new_base64_data[new_base64_len] = 0; binary.text() = new_base64_data.data(); } } depth--; } } else if (doc_.child(""svg"")) { VerbosePrint(""SVG detected.""); for (pugi::xml_node child = doc_.first_child(), next; child; child = next) { next = child.next_sibling(); if (child.type() == pugi::node_declaration || child.type() == pugi::node_doctype) doc_.remove_child(child); } TraverseElements(doc_.child(""svg""), [](pugi::xml_node node) { auto single_default_attrs_iter = kSingleDefaultAttributes.find(node.name()); const map<string, string>* single_default_attrs = nullptr; if (single_default_attrs_iter != kSingleDefaultAttributes.end()) single_default_attrs = &single_default_attrs_iter->second; for (pugi::xml_attribute attr = node.first_attribute(), next; attr; attr = next) { next = attr.next_attribute(); string value = ShrinkSpace(attr.value()); if (value.empty()) { node.remove_attribute(attr); continue; } if (value.size() > 5 && strcmp(attr.name(), ""preserveAspectRatio"") == 0 && value.substr(value.size() - 5) == "" meet"") value.resize(value.size() - 5); if (IsDefaultAttribute(single_default_attrs, attr.name(), value)) { if (!IsOverride(node, attr.name(), value)) { node.remove_attribute(attr); continue; } } const string kDataURIMagic = ""data:""; if ((strcmp(attr.name(), ""href"") == 0 || strcmp(attr.name(), ""xlink:href"") == 0) && value.size() > kDataURIMagic.size() && memcmp(value.data(), kDataURIMagic.data(), kDataURIMagic.size()) == 0) { DataURI data_uri(&value[0], value.size()); data_uri.SetSingleMode(true); size_t new_size = data_uri.Leanify(); value.resize(new_size); } attr = value.c_str(); } const char* name = node.name(); if (node.first_child() == nullptr) { if (strcmp(name, ""text"") == 0 || strcmp(name, ""tspan"") == 0 || strcmp(name, ""a"") == 0 || strcmp(name, ""defs"") == 0 || strcmp(name, ""g"") == 0 || strcmp(name, ""marker"") == 0 || strcmp(name, ""mask"") == 0 || strcmp(name, ""missing-glyph"") == 0 || strcmp(name, ""pattern"") == 0 || strcmp(name, ""switch"") == 0 || strcmp(name, ""symbol"") == 0) { node.parent().remove_child(node); return; } } if (strcmp(name, ""tref"") == 0 && node.attribute(""xlink:href"").empty()) { node.parent().remove_child(node); return; } if (strcmp(name, ""metadata"") == 0) { node.parent().remove_child(node); return; } }); } xml_memory_writer writer; fp_ -= size_leanified; writer.p_write = fp_; doc_.save(writer, nullptr, pugi::format_raw | pugi::format_no_declaration, encoding_); size_ = writer.p_write - fp_; return size_; }"
"void ReceiveMsg() { int left, len; static struct msg m; char *p; int ns = ServerSocket; struct win *wi; int recvfd = -1; struct acluser *user; bool is_socket; struct sockaddr_un a; struct msghdr msg; struct iovec iov; char control[1024]; is_socket = IsSocket(SockPath); if (!is_socket) { debug(""Ha, there was someone knocking on my fifo??\n""); if (fcntl(ServerSocket, F_SETFL, 0) == -1) Panic(errno, ""BLOCK fcntl""); p = (char *)&m; left = sizeof(m); } else { len = sizeof(a); debug(""Ha, there was someone knocking on my socket??\n""); if ((ns = accept(ns, (struct sockaddr *)&a, (void *)&len)) < 0) { Msg(errno, ""accept""); return; } p = (char *)&m; left = sizeof(m); bzero(&msg, sizeof(msg)); iov.iov_base = &m; iov.iov_len = left; msg.msg_iov = &iov; msg.msg_iovlen = 1; msg.msg_controllen = sizeof(control); msg.msg_control = &control; while (left > 0) { len = recvmsg(ns, &msg, 0); if (len < 0 && errno == EINTR) continue; if (len < 0) { close(ns); Msg(errno, ""read""); return; } if (msg.msg_controllen) { struct cmsghdr *cmsg; for (cmsg = CMSG_FIRSTHDR(&msg); cmsg; cmsg = CMSG_NXTHDR(&msg, cmsg)) { int cl; char *cp; if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS) continue; cp = (char *)CMSG_DATA(cmsg); cl = cmsg->cmsg_len; while (cl >= CMSG_LEN(sizeof(int))) { int passedfd; bcopy(cp, &passedfd, sizeof(int)); if (recvfd >= 0 && passedfd != recvfd) close(recvfd); recvfd = passedfd; cl -= CMSG_LEN(sizeof(int)); } } } p += len; left -= len; break; } } while (left > 0) { len = read(ns, p, left); if (len < 0 && errno == EINTR) continue; if (len <= 0) break; p += len; left -= len; } if (!is_socket) { #ifndef BROKEN_PIPE close(ServerSocket); if ((ServerSocket = secopen(SockPath, O_RDONLY | O_NONBLOCK, 0)) < 0) Panic(errno, ""reopen fifo %s"", SockPath); evdeq(&serv_read); serv_read.fd = ServerSocket; evenq(&serv_read); #endif } else { close(ns); } if (len < 0) { Msg(errno, ""read""); if (recvfd != -1) close(recvfd); return; } if (left > 0) { if (left != sizeof(m)) Msg(0, ""Message %d of %d bytes too small"", left, (int)sizeof(m)); else debug(""No data on socket.\n""); return; } if (m.protocol_revision != MSG_REVISION) { if (recvfd != -1) close(recvfd); Msg(0, ""Invalid message (magic 0x%08x)."", m.protocol_revision); return; } debug2(""*** RecMsg: type %d tty %s\n"", m.type, m.m_tty); if (m.type != MSG_ATTACH && recvfd != -1) { close(recvfd); recvfd = -1; } for (display = displays; display; display = display->d_next) if (TTYCMP(D_usertty, m.m_tty) == 0) break; debug2(""display: %s display %sfound\n"", m.m_tty, display ? """" : ""not ""); wi = 0; if (!display) { for (wi = windows; wi; wi = wi->w_next) if (!TTYCMP(m.m_tty, wi->w_tty)) { display = wi->w_layer.l_cvlist ? wi->w_layer.l_cvlist->c_display : 0; debug2(""but window %s %sfound.\n"", m.m_tty, display ? """" : ""(backfacing)""); break; } } if (display && D_status) RemoveStatus(); if (display && !D_tcinited && m.type != MSG_HANGUP) { if (recvfd != -1) close(recvfd); return;  } switch (m.type) { case MSG_WINCH: if (display) CheckScreenSize(1);  break; case MSG_CREATE: ExecCreate(&m); break; case MSG_CONT: if (display && D_userpid != 0 && kill(D_userpid, 0) == 0) break;  debug2(""RecMsg: apid=%d,was %d\n"", m.m.attach.apid, display ? D_userpid : 0); case MSG_ATTACH: if (CreateTempDisplay(&m, recvfd, wi)) break; #ifdef PASSWORD if (D_user->u_password && *D_user->u_password) AskPassword(&m); else #endif FinishAttach(&m); break; case MSG_ERROR: { int blocked=D_blocked; if(D_blocked == 4)  D_blocked=0;  Msg(0, ""%s"", m.m.message); D_blocked=blocked; } break; case MSG_HANGUP: if (!wi)  Hangup(); break; #ifdef REMOTE_DETACH case MSG_DETACH: #ifdef POW_DETACH case MSG_POW_DETACH: #endif  #ifdef PASSWORD user = *FindUserPtr(m.m.detach.duser); if (user && user->u_password && *user->u_password) { if (CreateTempDisplay(&m, recvfd, 0)) break; AskPassword(&m); } else #endif  FinishDetach(&m); break; #endif case MSG_QUERY: { char *oldSockPath = SaveStr(SockPath); strcpy(SockPath, m.m.command.writeback); bool is_socket = IsSocket(SockPath); int s = MakeClientSocket(0, is_socket); strcpy(SockPath, oldSockPath); Free(oldSockPath); if (s >= 0) { queryflag = s; DoCommandMsg(&m); close(s); } else queryflag = -1; Kill(m.m.command.apid, (queryflag >= 0) ? SIGCONT : SIG_BYE);  queryflag = -1; } break; case MSG_COMMAND: DoCommandMsg(&m); break; default: Msg(0, ""Invalid message (type %d)."", m.type); } }"
"int StreamTcpPacket (ThreadVars *tv, Packet *p, StreamTcpThread *stt, PacketQueue *pq) { SCEnter(); DEBUG_ASSERT_FLOW_LOCKED(p->flow); SCLogDebug(""p->pcap_cnt %""PRIu64, p->pcap_cnt); HandleThreadId(tv, p, stt); TcpSession *ssn = (TcpSession *)p->flow->protoctx; if (ssn != NULL) { ssn->tcp_packet_flags |= p->tcph->th_flags; if (PKT_IS_TOSERVER(p)) ssn->client.tcp_flags |= p->tcph->th_flags; else if (PKT_IS_TOCLIENT(p)) ssn->server.tcp_flags |= p->tcph->th_flags; if (ssn->flags & STREAMTCP_FLAG_ASYNC && ssn->client.tcp_flags != 0 && ssn->server.tcp_flags != 0) { SCLogDebug(""ssn %p: removing ASYNC flag as we have packets on both sides"", ssn); ssn->flags &= ~STREAMTCP_FLAG_ASYNC; } } if ((p->tcph->th_flags & (TH_SYN|TH_ACK)) == (TH_SYN|TH_ACK)) { StatsIncr(tv, stt->counter_tcp_synack); } else if (p->tcph->th_flags & (TH_SYN)) { StatsIncr(tv, stt->counter_tcp_syn); } if (p->tcph->th_flags & (TH_RST)) { StatsIncr(tv, stt->counter_tcp_rst); } if (StreamTcpCheckFlowDrops(p) == 1) { SCLogDebug(""This flow/stream triggered a drop rule""); FlowSetNoPacketInspectionFlag(p->flow); DecodeSetNoPacketInspectionFlag(p); StreamTcpDisableAppLayer(p->flow); PACKET_DROP(p); StreamTcpSessionPktFree(p); SCReturnInt(0); } if (ssn == NULL || ssn->state == TCP_NONE) { if (StreamTcpPacketStateNone(tv, p, stt, ssn, &stt->pseudo_queue) == -1) { goto error; } if (ssn != NULL) SCLogDebug(""ssn->alproto %""PRIu16"""", p->flow->alproto); } else { if (p->flags & PKT_PSEUDO_STREAM_END) { if (PKT_IS_TOCLIENT(p)) { ssn->client.last_ack = TCP_GET_ACK(p); StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, p, pq); } else { ssn->server.last_ack = TCP_GET_ACK(p); StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, p, pq); } goto skip; } if (p->flow->flags & FLOW_WRONG_THREAD || ssn->client.flags & STREAMTCP_STREAM_FLAG_GAP || ssn->server.flags & STREAMTCP_STREAM_FLAG_GAP) { p->flags |= PKT_STREAM_NO_EVENTS; } if (StreamTcpPacketIsKeepAlive(ssn, p) == 1) { goto skip; } if (StreamTcpPacketIsKeepAliveACK(ssn, p) == 1) { StreamTcpClearKeepAliveFlag(ssn, p); goto skip; } StreamTcpClearKeepAliveFlag(ssn, p); if (StreamTcpPacketIsFinShutdownAck(ssn, p) == 0) if (StreamTcpPacketIsWindowUpdate(ssn, p) == 0) if (StreamTcpPacketIsBadWindowUpdate(ssn,p)) goto skip; if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->state) < 0) goto error; skip: StreamTcpPacketCheckPostRst(ssn, p); if (ssn->state >= TCP_ESTABLISHED) { p->flags |= PKT_STREAM_EST; } } if (ssn != NULL) { while (stt->pseudo_queue.len > 0) { SCLogDebug(""processing pseudo packet / stream end""); Packet *np = PacketDequeue(&stt->pseudo_queue); if (np != NULL) { if (PKT_IS_TOSERVER(np)) { SCLogDebug(""pseudo packet is to server""); StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->client, np, NULL); } else { SCLogDebug(""pseudo packet is to client""); StreamTcpReassembleHandleSegment(tv, stt->ra_ctx, ssn, &ssn->server, np, NULL); } PacketEnqueue(pq, np); } SCLogDebug(""processing pseudo packet / stream end done""); } if (p->flags & PKT_STREAM_MODIFIED) { ReCalculateChecksum(p); } if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) || (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED)) { if (StreamTcpBypassEnabled()) { PacketBypassCallback(p); } } if ((ssn->client.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED) || (ssn->server.flags & STREAMTCP_STREAM_FLAG_DEPTH_REACHED)) { p->flags |= PKT_STREAM_NOPCAPLOG; } if ((PKT_IS_TOSERVER(p) && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY)) || (PKT_IS_TOCLIENT(p) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY))) { p->flags |= PKT_STREAM_NOPCAPLOG; } if (ssn->flags & STREAMTCP_FLAG_BYPASS) { if (StreamTcpBypassEnabled()) { PacketBypassCallback(p); } } else if (g_detect_disabled && (ssn->client.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) && (ssn->server.flags & STREAMTCP_STREAM_FLAG_NOREASSEMBLY) && StreamTcpBypassEnabled()) { SCLogDebug(""bypass as stream is dead and we have no rules""); PacketBypassCallback(p); } } SCReturnInt(0); error: while (stt->pseudo_queue.len > 0) { Packet *np = PacketDequeue(&stt->pseudo_queue); if (np != NULL) { PacketEnqueue(pq, np); } } if (p->flags & PKT_STREAM_MODIFIED) { ReCalculateChecksum(p); } if (StreamTcpInlineDropInvalid()) { DecodeSetNoPayloadInspectionFlag(p); PACKET_DROP(p); } SCReturnInt(-1); }"
"bool GetExtensionName(content::WebContents* web_contents, const GURL& origin_url, std::string* name_out) override { const Extension* extension = GetExtensionForWebContents(web_contents); if (extension && web_contents->GetLastCommittedURL().GetOrigin() == origin_url) { *name_out = extension->name(); return true; } return false; }"
"void OnPdfResourceIntercepted( const GURL& original_url, const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter) { content::WebContents* web_contents = web_contents_getter.Run(); if (!web_contents) return; if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) { auto browser_context = web_contents->GetBrowserContext(); auto download_manager = content::BrowserContext::GetDownloadManager(browser_context); download_manager->DownloadUrl( content::DownloadUrlParameters::CreateForWebContentsMainFrame( web_contents, original_url)); return; } content::NavigationController::LoadURLParams params( GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin, kPdfPluginSrc, original_url.spec().c_str()))); web_contents->GetController().LoadURLWithParams(params); }"
"void ShowExtensionInstallDialogImpl( ExtensionInstallPromptShowParams* show_params, ExtensionInstallPrompt::Delegate* delegate, scoped_refptr<ExtensionInstallPrompt::Prompt> prompt) { DCHECK_CURRENTLY_ON(content::BrowserThread::UI); ExtensionInstallDialogView* dialog = new ExtensionInstallDialogView(show_params->profile(), show_params->GetParentWebContents(), delegate, prompt); constrained_window::CreateBrowserModalDialogViews( dialog, show_params->GetParentWindow())->Show(); }"
"int sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen) { struct sock *sk = sock->sk; int val; int valbool; struct linger ling; int ret = 0; if (optname == SO_BINDTODEVICE) return sock_setbindtodevice(sk, optval, optlen); if (optlen < sizeof(int)) return -EINVAL; if (get_user(val, (int __user *)optval)) return -EFAULT; valbool = val ? 1 : 0; lock_sock(sk); switch (optname) { case SO_DEBUG: if (val && !capable(CAP_NET_ADMIN)) ret = -EACCES; else sock_valbool_flag(sk, SOCK_DBG, valbool); break; case SO_REUSEADDR: sk->sk_reuse = (valbool ? SK_CAN_REUSE : SK_NO_REUSE); break; case SO_REUSEPORT: sk->sk_reuseport = valbool; break; case SO_TYPE: case SO_PROTOCOL: case SO_DOMAIN: case SO_ERROR: ret = -ENOPROTOOPT; break; case SO_DONTROUTE: sock_valbool_flag(sk, SOCK_LOCALROUTE, valbool); break; case SO_BROADCAST: sock_valbool_flag(sk, SOCK_BROADCAST, valbool); break; case SO_SNDBUF: val = min_t(u32, val, sysctl_wmem_max); set_sndbuf: sk->sk_userlocks |= SOCK_SNDBUF_LOCK; sk->sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF); sk->sk_write_space(sk); break; case SO_SNDBUFFORCE: if (!capable(CAP_NET_ADMIN)) { ret = -EPERM; break; } goto set_sndbuf; case SO_RCVBUF: val = min_t(u32, val, sysctl_rmem_max); set_rcvbuf: sk->sk_userlocks |= SOCK_RCVBUF_LOCK; sk->sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF); break; case SO_RCVBUFFORCE: if (!capable(CAP_NET_ADMIN)) { ret = -EPERM; break; } goto set_rcvbuf; case SO_KEEPALIVE: #ifdef CONFIG_INET if (sk->sk_protocol == IPPROTO_TCP && sk->sk_type == SOCK_STREAM) tcp_set_keepalive(sk, valbool); #endif sock_valbool_flag(sk, SOCK_KEEPOPEN, valbool); break; case SO_OOBINLINE: sock_valbool_flag(sk, SOCK_URGINLINE, valbool); break; case SO_NO_CHECK: sk->sk_no_check_tx = valbool; break; case SO_PRIORITY: if ((val >= 0 && val <= 6) || ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) sk->sk_priority = val; else ret = -EPERM; break; case SO_LINGER: if (optlen < sizeof(ling)) { ret = -EINVAL; break; } if (copy_from_user(&ling, optval, sizeof(ling))) { ret = -EFAULT; break; } if (!ling.l_onoff) sock_reset_flag(sk, SOCK_LINGER); else { #if (BITS_PER_LONG == 32) if ((unsigned int)ling.l_linger >= MAX_SCHEDULE_TIMEOUT/HZ) sk->sk_lingertime = MAX_SCHEDULE_TIMEOUT; else #endif sk->sk_lingertime = (unsigned int)ling.l_linger * HZ; sock_set_flag(sk, SOCK_LINGER); } break; case SO_BSDCOMPAT: sock_warn_obsolete_bsdism(""setsockopt""); break; case SO_PASSCRED: if (valbool) set_bit(SOCK_PASSCRED, &sock->flags); else clear_bit(SOCK_PASSCRED, &sock->flags); break; case SO_TIMESTAMP: case SO_TIMESTAMPNS: if (valbool)  { if (optname == SO_TIMESTAMP) sock_reset_flag(sk, SOCK_RCVTSTAMPNS); else sock_set_flag(sk, SOCK_RCVTSTAMPNS); sock_set_flag(sk, SOCK_RCVTSTAMP); sock_enable_timestamp(sk, SOCK_TIMESTAMP); } else { sock_reset_flag(sk, SOCK_RCVTSTAMP); sock_reset_flag(sk, SOCK_RCVTSTAMPNS); } break; case SO_TIMESTAMPING: if (val & ~SOF_TIMESTAMPING_MASK) { ret = -EINVAL; break; } if (val & SOF_TIMESTAMPING_OPT_ID && !(sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID)) { if (sk->sk_protocol == IPPROTO_TCP && sk->sk_type == SOCK_STREAM) { if ((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN)) { ret = -EINVAL; break; } sk->sk_tskey = tcp_sk(sk)->snd_una; } else { sk->sk_tskey = 0; } } sk->sk_tsflags = val; if (val & SOF_TIMESTAMPING_RX_SOFTWARE) sock_enable_timestamp(sk, SOCK_TIMESTAMPING_RX_SOFTWARE); else sock_disable_timestamp(sk, (1UL << SOCK_TIMESTAMPING_RX_SOFTWARE)); break; case SO_RCVLOWAT: if (val < 0) val = INT_MAX; sk->sk_rcvlowat = val ? : 1; break; case SO_RCVTIMEO: ret = sock_set_timeout(&sk->sk_rcvtimeo, optval, optlen); break; case SO_SNDTIMEO: ret = sock_set_timeout(&sk->sk_sndtimeo, optval, optlen); break; case SO_ATTACH_FILTER: ret = -EINVAL; if (optlen == sizeof(struct sock_fprog)) { struct sock_fprog fprog; ret = -EFAULT; if (copy_from_user(&fprog, optval, sizeof(fprog))) break; ret = sk_attach_filter(&fprog, sk); } break; case SO_ATTACH_BPF: ret = -EINVAL; if (optlen == sizeof(u32)) { u32 ufd; ret = -EFAULT; if (copy_from_user(&ufd, optval, sizeof(ufd))) break; ret = sk_attach_bpf(ufd, sk); } break; case SO_ATTACH_REUSEPORT_CBPF: ret = -EINVAL; if (optlen == sizeof(struct sock_fprog)) { struct sock_fprog fprog; ret = -EFAULT; if (copy_from_user(&fprog, optval, sizeof(fprog))) break; ret = sk_reuseport_attach_filter(&fprog, sk); } break; case SO_ATTACH_REUSEPORT_EBPF: ret = -EINVAL; if (optlen == sizeof(u32)) { u32 ufd; ret = -EFAULT; if (copy_from_user(&ufd, optval, sizeof(ufd))) break; ret = sk_reuseport_attach_bpf(ufd, sk); } break; case SO_DETACH_FILTER: ret = sk_detach_filter(sk); break; case SO_LOCK_FILTER: if (sock_flag(sk, SOCK_FILTER_LOCKED) && !valbool) ret = -EPERM; else sock_valbool_flag(sk, SOCK_FILTER_LOCKED, valbool); break; case SO_PASSSEC: if (valbool) set_bit(SOCK_PASSSEC, &sock->flags); else clear_bit(SOCK_PASSSEC, &sock->flags); break; case SO_MARK: if (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN)) ret = -EPERM; else sk->sk_mark = val; break; case SO_RXQ_OVFL: sock_valbool_flag(sk, SOCK_RXQ_OVFL, valbool); break; case SO_WIFI_STATUS: sock_valbool_flag(sk, SOCK_WIFI_STATUS, valbool); break; case SO_PEEK_OFF: if (sock->ops->set_peek_off) ret = sock->ops->set_peek_off(sk, val); else ret = -EOPNOTSUPP; break; case SO_NOFCS: sock_valbool_flag(sk, SOCK_NOFCS, valbool); break; case SO_SELECT_ERR_QUEUE: sock_valbool_flag(sk, SOCK_SELECT_ERR_QUEUE, valbool); break; #ifdef CONFIG_NET_RX_BUSY_POLL case SO_BUSY_POLL: if ((val > sk->sk_ll_usec) && !capable(CAP_NET_ADMIN)) ret = -EPERM; else { if (val < 0) ret = -EINVAL; else sk->sk_ll_usec = val; } break; #endif case SO_MAX_PACING_RATE: sk->sk_max_pacing_rate = val; sk->sk_pacing_rate = min(sk->sk_pacing_rate, sk->sk_max_pacing_rate); break; case SO_INCOMING_CPU: sk->sk_incoming_cpu = val; break; case SO_CNX_ADVICE: if (val == 1) dst_negative_advice(sk); break; default: ret = -ENOPROTOOPT; break; } release_sock(sk); return ret; }"
"static const char * build_pathname(struct archive_string *as, struct file_info *file) { if (file->parent != NULL && archive_strlen(&file->parent->name) > 0) { build_pathname(as, file->parent); archive_strcat(as, ""/""); } if (archive_strlen(&file->name) == 0) archive_strcat(as, "".""); else archive_string_concat(as, &file->name); return (as->s); }"
static inline ut16 r_read_le16(const void *src) { const ut8 *s = (const ut8*)src; return (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0); }
"static gint dissect_wccp2_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, int idx, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table) { proto_item *tl, *te; proto_tree *element_tree, *value_tree; guint num_of_val_elements; guint i; gint new_length; element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0, ett_mv_set_element, &tl, ""Mask/Value Set Element(%d)"", idx); new_length = dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree); NOTE_EATEN_LENGTH(new_length); if (length < 4) return length-4; num_of_val_elements = tvb_get_ntohl(tvb, offset); te = proto_tree_add_uint(element_tree, hf_mask_value_set_element_value_element_num, tvb, offset, 4, num_of_val_elements); value_tree = proto_item_add_subtree(te, ett_mv_set_value_list); EAT(4); for (i = 0; i < num_of_val_elements; i++) { new_length=dissect_wccp2_value_element(tvb, offset, length, i, pinfo,  value_tree, addr_table); NOTE_EATEN_LENGTH(new_length); } proto_item_set_len(tl, 16+num_of_val_elements*16); return length; }"
"void rfbClientCleanup(rfbClient* client) { #ifdef LIBVNCSERVER_HAVE_LIBZ int i; for ( i = 0; i < 4; i++ ) { if (client->zlibStreamActive[i] == TRUE ) { if (inflateEnd (&client->zlibStream[i]) != Z_OK && client->zlibStream[i].msg != NULL) rfbClientLog(""inflateEnd: %s\n"", client->zlibStream[i].msg); } } if ( client->decompStreamInited == TRUE ) { if (inflateEnd (&client->decompStream) != Z_OK && client->decompStream.msg != NULL) rfbClientLog(""inflateEnd: %s\n"", client->decompStream.msg ); } #endif if (client->ultra_buffer) free(client->ultra_buffer); if (client->raw_buffer) free(client->raw_buffer); FreeTLS(client); while (client->clientData) { rfbClientData* next = client->clientData->next; free(client->clientData); client->clientData = next; } if (client->sock != RFB_INVALID_SOCKET) rfbCloseSocket(client->sock); if (client->listenSock != RFB_INVALID_SOCKET) rfbCloseSocket(client->listenSock); free(client->desktopName); free(client->serverHost); if (client->destHost) free(client->destHost); if (client->clientAuthSchemes) free(client->clientAuthSchemes); #ifdef LIBVNCSERVER_HAVE_SASL if (client->saslSecret) free(client->saslSecret); #endif  #ifdef WIN32 if(WSACleanup() != 0) { errno=WSAGetLastError(); rfbClientErr(""Could not terminate Windows Sockets: %s\n"", strerror(errno)); } #endif free(client); }"
"u_int fr_print(netdissect_options *ndo, register const u_char *p, u_int length) { int ret; uint16_t extracted_ethertype; u_int dlci; u_int addr_len; uint16_t nlpid; u_int hdr_len; uint8_t flags[4]; ret = parse_q922_addr(ndo, p, &dlci, &addr_len, flags, length); if (ret == -1) goto trunc; if (ret == 0) { ND_PRINT((ndo, ""Q.922, invalid address"")); return 0; } ND_TCHECK(p[addr_len]); if (length < addr_len + 1) goto trunc; if (p[addr_len] != LLC_UI && dlci != 0) { if (!ND_TTEST2(p[addr_len], 2) || length < addr_len + 2) { ND_PRINT((ndo, ""UI %02x! "", p[addr_len])); } else { extracted_ethertype = EXTRACT_16BITS(p+addr_len); if (ndo->ndo_eflag) fr_hdr_print(ndo, length, addr_len, dlci, flags, extracted_ethertype); if (ethertype_print(ndo, extracted_ethertype, p+addr_len+ETHERTYPE_LEN, length-addr_len-ETHERTYPE_LEN, ndo->ndo_snapend-p-addr_len-ETHERTYPE_LEN, NULL, NULL) == 0) ND_PRINT((ndo, ""UI %02x! "", p[addr_len])); else return addr_len + 2; } } ND_TCHECK(p[addr_len+1]); if (length < addr_len + 2) goto trunc; if (p[addr_len + 1] == 0) { if (addr_len != 3) ND_PRINT((ndo, ""Pad! "")); hdr_len = addr_len + 1  + 1  + 1 ; } else { if (addr_len == 3) ND_PRINT((ndo, ""No pad! "")); hdr_len = addr_len + 1  + 1 ; } ND_TCHECK(p[hdr_len - 1]); if (length < hdr_len) goto trunc; nlpid = p[hdr_len - 1]; if (ndo->ndo_eflag) fr_hdr_print(ndo, length, addr_len, dlci, flags, nlpid); p += hdr_len; length -= hdr_len; switch (nlpid) { case NLPID_IP: ip_print(ndo, p, length); break; case NLPID_IP6: ip6_print(ndo, p, length); break; case NLPID_CLNP: case NLPID_ESIS: case NLPID_ISIS: isoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1);  break; case NLPID_SNAP: if (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) { if (!ndo->ndo_eflag) fr_hdr_print(ndo, length + hdr_len, hdr_len, dlci, flags, nlpid); if (!ndo->ndo_suppress_default_print) ND_DEFAULTPRINT(p - hdr_len, length + hdr_len); } break; case NLPID_Q933: q933_print(ndo, p, length); break; case NLPID_MFR: frf15_print(ndo, p, length); break; case NLPID_PPP: ppp_print(ndo, p, length); break; default: if (!ndo->ndo_eflag) fr_hdr_print(ndo, length + hdr_len, addr_len, dlci, flags, nlpid); if (!ndo->ndo_xflag) ND_DEFAULTPRINT(p, length); } return hdr_len; trunc: ND_PRINT((ndo, ""[|fr]"")); return 0; }"
"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth) { if (cid != ctx->cid) { const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid); if (!cid_table) { av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %""PRIu32""\n"", cid); return AVERROR(ENOSYS); } if (cid_table->bit_depth != bitdepth && cid_table->bit_depth != DNXHD_VARIABLE) { av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", cid_table->bit_depth, bitdepth); return AVERROR_INVALIDDATA; } ctx->cid_table = cid_table; av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %""PRIu32"".\n"", cid); ff_free_vlc(&ctx->ac_vlc); ff_free_vlc(&ctx->dc_vlc); ff_free_vlc(&ctx->run_vlc); init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257, ctx->cid_table->ac_bits, 1, 1, ctx->cid_table->ac_codes, 2, 2, 0); init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12, ctx->cid_table->dc_bits, 1, 1, ctx->cid_table->dc_codes, 1, 1, 0); init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62, ctx->cid_table->run_bits, 1, 1, ctx->cid_table->run_codes, 2, 2, 0); ctx->cid = cid; } return 0; }"
"DltReturnValue dlt_file_message(DltFile *file, int index, int verbose) { PRINT_FUNCTION_VERBOSE(verbose); if (file == NULL) return DLT_RETURN_WRONG_PARAMETER; if (index >= file->counter) { dlt_vlog(LOG_WARNING, ""Message %d out of range!\r\n"", index); return DLT_RETURN_WRONG_PARAMETER; } if (fseek(file->handle, file->index[index], SEEK_SET) != 0) { dlt_vlog(LOG_WARNING, ""Seek to message %d to position %ld failed!\r\n"", index, file->index[index]); return DLT_RETURN_ERROR; } if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK) return DLT_RETURN_ERROR; file->position = index; return DLT_RETURN_OK; }"
"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc, uint32_t flags, uaddr_t uaddr, size_t len) { uaddr_t a; size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE, CORE_MMU_USER_PARAM_SIZE); if (ADD_OVERFLOW(uaddr, len, &a)) return TEE_ERROR_ACCESS_DENIED; if ((flags & TEE_MEMORY_ACCESS_NONSECURE) && (flags & TEE_MEMORY_ACCESS_SECURE)) return TEE_ERROR_ACCESS_DENIED; if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) && !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len)) return TEE_ERROR_ACCESS_DENIED; for (a = uaddr; a < (uaddr + len); a += addr_incr) { uint32_t attr; TEE_Result res; res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr); if (res != TEE_SUCCESS) return res; if ((flags & TEE_MEMORY_ACCESS_NONSECURE) && (attr & TEE_MATTR_SECURE)) return TEE_ERROR_ACCESS_DENIED; if ((flags & TEE_MEMORY_ACCESS_SECURE) && !(attr & TEE_MATTR_SECURE)) return TEE_ERROR_ACCESS_DENIED; if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW)) return TEE_ERROR_ACCESS_DENIED; if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR)) return TEE_ERROR_ACCESS_DENIED; } return TEE_SUCCESS; }"
"int secure_decrypt(void *data, unsigned int data_length, int is_signed) { at91_aes_key_size_t key_size; unsigned int cmac_key[8], cipher_key[8]; unsigned int iv[AT91_AES_IV_SIZE_WORD]; unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD]; unsigned int fixed_length; const unsigned int *cmac; int rc = -1; init_keys(&key_size, cipher_key, cmac_key, iv); at91_aes_init(); if (is_signed) { if (at91_aes_cmac(data_length, data, computed_cmac, key_size, cmac_key)) goto exit; fixed_length = at91_aes_roundup(data_length); cmac = (const unsigned int *)((char *)data + fixed_length); if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE)) goto exit; } if (at91_aes_cbc(data_length, data, data, 0, key_size, cipher_key, iv)) goto exit; rc = 0; exit: at91_aes_cleanup(); memset(cmac_key, 0, sizeof(cmac_key)); memset(cipher_key, 0, sizeof(cipher_key)); memset(iv, 0, sizeof(iv)); return rc; }"
"static int fuse_dev_fasync(int fd, struct file *file, int on) { struct fuse_conn *fc = fuse_get_conn(file); if (!fc) return -EPERM; return fasync_helper(fd, file, on, &fc->iq.fasync); }"
"static int __ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc, int in_mem) { struct ext4_group_desc*gdp; struct buffer_head*bh; struct super_block*sb = inode->i_sb; ext4_fsblk_tblock; intinodes_per_block, inode_offset; iloc->bh = NULL; if (!ext4_valid_inum(sb, inode->i_ino)) return -EFSCORRUPTED; iloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb); gdp = ext4_get_group_desc(sb, iloc->block_group, NULL); if (!gdp) return -EIO; inodes_per_block = EXT4_SB(sb)->s_inodes_per_block; inode_offset = ((inode->i_ino - 1) % EXT4_INODES_PER_GROUP(sb)); block = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block); iloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb); bh = sb_getblk(sb, block); if (unlikely(!bh)) return -ENOMEM; if (!buffer_uptodate(bh)) { lock_buffer(bh); if (buffer_write_io_error(bh) && !buffer_uptodate(bh)) set_buffer_uptodate(bh); if (buffer_uptodate(bh)) { unlock_buffer(bh); goto has_buffer; } if (in_mem) { struct buffer_head *bitmap_bh; int i, start; start = inode_offset & ~(inodes_per_block - 1); bitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp)); if (unlikely(!bitmap_bh)) goto make_io; if (!buffer_uptodate(bitmap_bh)) { brelse(bitmap_bh); goto make_io; } for (i = start; i < start + inodes_per_block; i++) { if (i == inode_offset) continue; if (ext4_test_bit(i, bitmap_bh->b_data)) break; } brelse(bitmap_bh); if (i == start + inodes_per_block) { memset(bh->b_data, 0, bh->b_size); set_buffer_uptodate(bh); unlock_buffer(bh); goto has_buffer; } } make_io: if (EXT4_SB(sb)->s_inode_readahead_blks) { ext4_fsblk_t b, end, table; unsigned num; __u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks; table = ext4_inode_table(sb, gdp); b = block & ~((ext4_fsblk_t) ra_blks - 1); if (table > b) b = table; end = b + ra_blks; num = EXT4_INODES_PER_GROUP(sb); if (ext4_has_group_desc_csum(sb)) num -= ext4_itable_unused_count(sb, gdp); table += num / inodes_per_block; if (end > table) end = table; while (b <= end) sb_breadahead(sb, b++); } trace_ext4_load_inode(inode); get_bh(bh); bh->b_end_io = end_buffer_read_sync; submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh); wait_on_buffer(bh); if (!buffer_uptodate(bh)) { EXT4_ERROR_INODE_BLOCK(inode, block, ""unable to read itable block""); brelse(bh); return -EIO; } } has_buffer: iloc->bh = bh; return 0; }"
"static inline void get_conn_text(const conn *c, const int af, char* addr, struct sockaddr *sock_addr) { char addr_text[MAXPATHLEN]; addr_text[0] = '\0'; const char *protoname = ""?""; unsigned short port = 0; switch (af) { case AF_INET: (void) inet_ntop(af, &((struct sockaddr_in *)sock_addr)->sin_addr, addr_text, sizeof(addr_text) - 1); port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port); protoname = IS_UDP(c->transport) ? ""udp"" : ""tcp""; break; case AF_INET6: addr_text[0] = '['; addr_text[1] = '\0'; if (inet_ntop(af, &((struct sockaddr_in6 *)sock_addr)->sin6_addr, addr_text + 1, sizeof(addr_text) - 2)) { strcat(addr_text, ""]""); } port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port); protoname = IS_UDP(c->transport) ? ""udp6"" : ""tcp6""; break; case AF_UNIX: strncpy(addr_text, ((struct sockaddr_un *)sock_addr)->sun_path, sizeof(addr_text) - 1); addr_text[sizeof(addr_text)-1] = '\0'; protoname = ""unix""; break; } if (strlen(addr_text) < 2) { sprintf(addr_text, ""<AF %d>"", af); } if (port) { sprintf(addr, ""%s:%s:%u"", protoname, addr_text, port); } else { sprintf(addr, ""%s:%s"", protoname, addr_text); } }"
"GF_EXPORT GF_DOVIDecoderConfigurationRecord *gf_isom_dovi_config_get(GF_ISOFile* the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox* trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1); if (!entry || !entry->dovi_config) return NULL; return DOVI_DuplicateConfig(&entry->dovi_config->DOVIConfig); }"
"Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g, ControlFlowInfo* cf_info) { const int num_nodes = g->num_node_ids(); cf_info->frame_names.resize(num_nodes); std::vector<Node*> parent_nodes; parent_nodes.resize(num_nodes); std::vector<bool> visited; visited.resize(num_nodes); string frame_name; std::deque<Node*> ready; for (Node* n : g->nodes()) { if (n->in_edges().empty()) { visited[n->id()] = true; cf_info->unique_frame_names.insert(frame_name); ready.push_back(n); } } while (!ready.empty()) { Node* curr_node = ready.front(); int curr_id = curr_node->id(); ready.pop_front(); Node* parent = nullptr; if (IsEnter(curr_node)) { TF_RETURN_IF_ERROR( GetNodeAttr(curr_node->attrs(), ""frame_name"", &frame_name)); parent = curr_node; } else if (IsExit(curr_node)) { parent = parent_nodes[curr_id]; frame_name = cf_info->frame_names[parent->id()]; parent = parent_nodes[parent->id()]; } else { parent = parent_nodes[curr_id]; frame_name = cf_info->frame_names[curr_id]; } for (const Edge* out_edge : curr_node->out_edges()) { Node* out = out_edge->dst(); if (IsSink(out)) continue; const int out_id = out->id(); bool is_visited = visited[out_id]; if (!is_visited) { ready.push_back(out); visited[out_id] = true; cf_info->frame_names[out_id] = frame_name; parent_nodes[out_id] = parent; cf_info->unique_frame_names.insert(frame_name); } } } return Status::OK(); }"
size_t jsuGetFreeStack() { #ifdef ARM void *frame = __builtin_frame_address(0); size_t stackPos = (size_t)((char*)frame); size_t stackEnd = (size_t)((char*)&LINKER_END_VAR); if (stackPos < stackEnd) return 0;   return  stackPos - stackEnd; #elif defined(LINUX) char ptr;   extern void *STACK_BASE; uint32_t count =  (uint32_t)((size_t)STACK_BASE - (size_t)&ptr); return 1000000 - count; #else return 1000000; #endif }
"static void intern_rec(value *dest) { unsigned int code; tag_t tag; mlsize_t size, len, ofs_ind; value v; asize_t ofs; header_t header; unsigned char digest[16]; struct custom_operations * ops; char * codeptr; struct intern_item * sp; sp = intern_stack; ReadItems(dest, 1); while(sp != intern_stack) { dest = sp->dest; switch (sp->op) { case OFreshOID: if (Int_val(Field((value)dest, 1)) >= 0) caml_set_oo_id((value)dest); sp--; break; case OShift: *dest += sp->arg; sp--; break; case OReadItems: sp->dest++; if (--(sp->arg) == 0) sp--; code = read8u(); if (code >= PREFIX_SMALL_INT) { if (code >= PREFIX_SMALL_BLOCK) { tag = code & 0xF; size = (code >> 4) & 0x7; read_block: if (size == 0) { v = Atom(tag); } else { v = Val_hp(intern_dest); if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v; *intern_dest = Make_header(size, tag, intern_color); intern_dest += 1 + size; if (tag == Object_tag) { Assert(size >= 2); ReadItems(&Field(v, 2), size - 2); PushItem(); sp->op = OFreshOID; sp->dest = (value*) v; sp->arg = 1; ReadItems(&Field(v, 0), 2); } else ReadItems(&Field(v, 0), size); } } else { v = Val_int(code & 0x3F); } } else { if (code >= PREFIX_SMALL_STRING) { len = (code & 0x1F); read_string: size = (len + sizeof(value)) / sizeof(value); v = Val_hp(intern_dest); if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v; *intern_dest = Make_header(size, String_tag, intern_color); intern_dest += 1 + size; Field(v, size - 1) = 0; ofs_ind = Bsize_wsize(size) - 1; Byte(v, ofs_ind) = ofs_ind - len; readblock(String_val(v), len); } else { switch(code) { case CODE_INT8: v = Val_long(read8s()); break; case CODE_INT16: v = Val_long(read16s()); break; case CODE_INT32: v = Val_long(read32s()); break; case CODE_INT64: #ifdef ARCH_SIXTYFOUR v = Val_long(read64s()); break; #else intern_cleanup(); caml_failwith(""input_value: integer too large""); break; #endif case CODE_SHARED8: ofs = read8u(); read_shared: Assert (ofs > 0); Assert (ofs <= obj_counter); Assert (intern_obj_table != NULL); v = intern_obj_table[obj_counter - ofs]; break; case CODE_SHARED16: ofs = read16u(); goto read_shared; case CODE_SHARED32: ofs = read32u(); goto read_shared; case CODE_BLOCK32: header = (header_t) read32u(); tag = Tag_hd(header); size = Wosize_hd(header); goto read_block; case CODE_BLOCK64: #ifdef ARCH_SIXTYFOUR header = (header_t) read64s(); tag = Tag_hd(header); size = Wosize_hd(header); goto read_block; #else intern_cleanup(); caml_failwith(""input_value: data block too large""); break; #endif case CODE_STRING8: len = read8u(); goto read_string; case CODE_STRING32: len = read32u(); goto read_string; case CODE_DOUBLE_LITTLE: case CODE_DOUBLE_BIG: v = Val_hp(intern_dest); if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v; *intern_dest = Make_header(Double_wosize, Double_tag, intern_color); intern_dest += 1 + Double_wosize; readfloat((double *) v, code); break; case CODE_DOUBLE_ARRAY8_LITTLE: case CODE_DOUBLE_ARRAY8_BIG: len = read8u(); read_double_array: size = len * Double_wosize; v = Val_hp(intern_dest); if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v; *intern_dest = Make_header(size, Double_array_tag, intern_color); intern_dest += 1 + size; readfloats((double *) v, len, code); break; case CODE_DOUBLE_ARRAY32_LITTLE: case CODE_DOUBLE_ARRAY32_BIG: len = read32u(); goto read_double_array; case CODE_CODEPOINTER: ofs = read32u(); readblock(digest, 16); codeptr = intern_resolve_code_pointer(digest, ofs); if (codeptr != NULL) { v = (value) codeptr; } else { value * function_placeholder = caml_named_value (""Debugger.function_placeholder""); if (function_placeholder != NULL) { v = *function_placeholder; } else { intern_cleanup(); intern_bad_code_pointer(digest); } } break; case CODE_INFIXPOINTER: ofs = read32u(); PushItem(); sp->dest = dest; sp->op = OShift; sp->arg = ofs; ReadItems(dest, 1); continue;   case CODE_CUSTOM: ops = caml_find_custom_operations((char *) intern_src); if (ops == NULL) { intern_cleanup(); caml_failwith(""input_value: unknown custom block identifier""); } while (*intern_src++ != 0) ;   size = ops->deserialize((void *) (intern_dest + 2)); size = 1 + (size + sizeof(value) - 1) / sizeof(value); v = Val_hp(intern_dest); if (intern_obj_table != NULL) intern_obj_table[obj_counter++] = v; *intern_dest = Make_header(size, Custom_tag, intern_color); Custom_ops_val(v) = ops; if (ops->finalize != NULL && Is_young(v)) { if (caml_finalize_table.ptr >= caml_finalize_table.limit){ CAMLassert (caml_finalize_table.ptr == caml_finalize_table.limit); caml_realloc_ref_table (&caml_finalize_table); } *caml_finalize_table.ptr++ = (value *)v; } intern_dest += 1 + size; break; default: intern_cleanup(); caml_failwith(""input_value: ill-formed message""); } } } *dest = v; break; default: Assert(0); } } intern_free_stack(); }"
"static void jv_dump_term(struct dtoa_context* C, jv x, int flags, int indent, FILE* F, jv* S) { char buf[JVP_DTOA_FMT_MAX_LEN]; const char* color = 0; double refcnt = (flags & JV_PRINT_REFCOUNT) ? jv_get_refcnt(x) - 1 : -1; if (flags & JV_PRINT_COLOR) { for (unsigned i=0; i<sizeof(color_kinds)/sizeof(color_kinds[0]); i++) { if (jv_get_kind(x) == color_kinds[i]) { color = colors[i]; put_str(color, F, S, flags & JV_PRINT_ISATTY); break; } } } switch (jv_get_kind(x)) { default: case JV_KIND_INVALID: if (flags & JV_PRINT_INVALID) { jv msg = jv_invalid_get_msg(jv_copy(x)); if (jv_get_kind(msg) == JV_KIND_STRING) { put_str(""<invalid:"", F, S, flags & JV_PRINT_ISATTY); jvp_dump_string(msg, flags | JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); put_str("">"", F, S, flags & JV_PRINT_ISATTY); } else { put_str(""<invalid>"", F, S, flags & JV_PRINT_ISATTY); } } else { assert(0 && ""Invalid value""); } break; case JV_KIND_NULL: put_str(""null"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_FALSE: put_str(""false"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_TRUE: put_str(""true"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_NUMBER: { double d = jv_number_value(x); if (d != d) { put_str(""null"", F, S, flags & JV_PRINT_ISATTY); } else { if (d > DBL_MAX) d = DBL_MAX; if (d < -DBL_MAX) d = -DBL_MAX; put_str(jvp_dtoa_fmt(C, buf, d), F, S, flags & JV_PRINT_ISATTY); } break; } case JV_KIND_STRING: jvp_dump_string(x, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_ARRAY: { if (jv_array_length(jv_copy(x)) == 0) { put_str(""[]"", F, S, flags & JV_PRINT_ISATTY); break; } put_str(""["", F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } jv_array_foreach(x, i, elem) { if (i!=0) { if (flags & JV_PRINT_PRETTY) { put_str("",\n"", F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } else { put_str("","", F, S, flags & JV_PRINT_ISATTY); } } jv_dump_term(C, elem, flags, indent + 1, F, S); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); } if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY); } if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_char(']', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); break; } case JV_KIND_OBJECT: { if (jv_object_length(jv_copy(x)) == 0) { put_str(""{}"", F, S, flags & JV_PRINT_ISATTY); break; } put_char('{', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } int first = 1; int i = 0; jv keyset = jv_null(); while (1) { jv key, value; if (flags & JV_PRINT_SORTED) { if (first) { keyset = jv_keys(jv_copy(x)); i = 0; } else { i++; } if (i >= jv_array_length(jv_copy(keyset))) { jv_free(keyset); break; } key = jv_array_get(jv_copy(keyset), i); value = jv_object_get(jv_copy(x), jv_copy(key)); } else { if (first) { i = jv_object_iter(x); } else { i = jv_object_iter_next(x, i); } if (!jv_object_iter_valid(x, i)) break; key = jv_object_iter_key(x, i); value = jv_object_iter_value(x, i); } if (!first) { if (flags & JV_PRINT_PRETTY){ put_str("",\n"", F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } else { put_str("","", F, S, flags & JV_PRINT_ISATTY); } } if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); first = 0; if (color) put_str(FIELD_COLOR, F, S, flags & JV_PRINT_ISATTY); jvp_dump_string(key, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); jv_free(key); if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_str((flags & JV_PRINT_PRETTY) ? "": "" : "":"", F, S, flags & JV_PRINT_ISATTY); if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); jv_dump_term(C, value, flags, indent + 1, F, S); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); } if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY); } if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_char('}', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); } } jv_free(x); if (color) { put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); } }"
static void drop_futex_key_refs(union futex_key *key) { if (!key->both.ptr) { WARN_ON_ONCE(1); return; } if (!IS_ENABLED(CONFIG_MMU)) return; switch (key->both.offset & (FUT_OFF_INODE|FUT_OFF_MMSHARED)) { case FUT_OFF_INODE: iput(key->shared.inode); break; case FUT_OFF_MMSHARED: mmdrop(key->private.mm); break; } }
"static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info) { int byte; gint64 date_off = -1, cur_off, packet_off; size_t string_level[ASCEND_MAGIC_STRINGS]; guint string_i = 0, type = 0; guint excessive_read_count = 262144; memset(&string_level, 0, sizeof(string_level)); while (((byte = file_getc(wth->fh)) != EOF)) { excessive_read_count--; if (!excessive_read_count) { *err = 0; return -1; } for (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) { const gchar *strptr = ascend_magic[string_i].strptr; size_t len          = strlen(strptr); if (byte == *(strptr + string_level[string_i])) { string_level[string_i]++; if (string_level[string_i] >= len) { cur_off = file_tell(wth->fh); if (cur_off == -1) { *err = file_error(wth->fh, err_info); return -1; } if (strcmp(strptr, ASCEND_DATE) == 0) { date_off = cur_off - len; } else { if (date_off == -1) { packet_off = cur_off - len; } else { packet_off = date_off; } type = ascend_magic[string_i].type; goto found; } } } else { string_level[string_i] = 0; } } } *err = file_error(wth->fh, err_info); return -1; found: if (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1) return -1; wth->phdr.pseudo_header.ascend.type = type; return packet_off; }"
"static void __evtchn_fifo_handle_events(unsigned cpu, bool drop) { struct evtchn_fifo_control_block *control_block; unsigned long ready; unsigned q; control_block = per_cpu(cpu_control_block, cpu); ready = xchg(&control_block->ready, 0); while (ready) { q = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES); consume_one_event(cpu, control_block, q, &ready, drop); ready |= xchg(&control_block->ready, 0); } }"
"static int r_jwe_aesgcm_key_unwrap(jwe_t * jwe, jwa_alg alg, jwk_t * jwk, int x5u_flags) { int ret, res; unsigned char iv[96] = {0}, * key = NULL, cipherkey[64] = {0}, tag[128] = {0}, tag_b64url[256] = {0}; size_t iv_len = 0, key_len = 0, cipherkey_len = 0, tag_b64url_len = 0, tag_len = gnutls_cipher_get_tag_size(r_jwe_get_alg_from_alg(alg)); unsigned int bits = 0; gnutls_datum_t key_g, iv_g; gnutls_cipher_hd_t handle = NULL; if (r_jwk_key_type(jwk, &bits, x5u_flags) & R_KEY_TYPE_SYMMETRIC && o_strlen(r_jwe_get_header_str_value(jwe, ""iv"")) && o_strlen(r_jwe_get_header_str_value(jwe, ""tag""))) { ret = RHN_OK; key_len = bits; do { if ((key = o_malloc(key_len+4)) == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error allocating resources for key""); ret = RHN_ERROR_MEMORY; break; } if (r_jwk_export_to_symmetric_key(jwk, key, &key_len) != RHN_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error r_jwk_export_to_symmetric_key""); ret = RHN_ERROR; break; } if (!o_base64url_decode((const unsigned char *)r_jwe_get_header_str_value(jwe, ""iv""), o_strlen(r_jwe_get_header_str_value(jwe, ""iv"")), iv, &iv_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_decode iv""); ret = RHN_ERROR_INVALID; break; } if (!o_base64url_decode((const unsigned char *)jwe->encrypted_key_b64url, o_strlen((const char *)jwe->encrypted_key_b64url), cipherkey, &cipherkey_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_decode cipherkey""); ret = RHN_ERROR_INVALID; break; } key_g.data = key; key_g.size = key_len; iv_g.data = iv; iv_g.size = iv_len; if ((res = gnutls_cipher_init(&handle, r_jwe_get_alg_from_alg(alg), &key_g, &iv_g))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_init: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR_INVALID; break; } if ((res = gnutls_cipher_decrypt(handle, cipherkey, cipherkey_len))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_decrypt: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR; break; } if ((res = gnutls_cipher_tag(handle, tag, tag_len))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error gnutls_cipher_tag: '%s'"", gnutls_strerror(res)); ret = RHN_ERROR; break; } if (!o_base64url_encode(tag, tag_len, tag_b64url, &tag_b64url_len)) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error o_base64url_encode tag""); ret = RHN_ERROR; break; } tag_b64url[tag_b64url_len] = '\0'; if (0 != o_strcmp((const char *)tag_b64url, r_jwe_get_header_str_value(jwe, ""tag""))) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Invalid tag %s %s"", tag_b64url, r_jwe_get_header_str_value(jwe, ""tag"")); ret = RHN_ERROR_INVALID; break; } if (r_jwe_set_cypher_key(jwe, cipherkey, cipherkey_len) != RHN_OK) { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error r_jwe_set_cypher_key""); ret = RHN_ERROR; } } while (0); o_free(key); if (handle != NULL) { gnutls_cipher_deinit(handle); } } else { y_log_message(Y_LOG_LEVEL_ERROR, ""r_jwe_aesgcm_key_unwrap - Error invalid key""); ret = RHN_ERROR_INVALID; } return ret; }"
"int win_alloc_lines(win_T *wp) { wp->w_lines_valid = 0; wp->w_lines = ALLOC_CLEAR_MULT(wline_T, Rows ); if (wp->w_lines == NULL) return FAIL; return OK; }"
"GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex) { GF_DataEntryURLBox *entry; GF_DataMap *map; GF_Err e; if (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM; entry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1); if (!entry) return GF_ISOM_INVALID_FILE; if (entry->flags == 1) return GF_OK; if (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED; if (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) { e = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map); } else { e = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map); } if (e) return e; gf_isom_datamap_del(map); return GF_OK; }"
"void ldbRedis(lua_State *lua, sds *argv, int argc) { int j, saved_rc = server.lua_replicate_commands; lua_getglobal(lua,""redis""); lua_pushstring(lua,""call""); lua_gettable(lua,-2);        for (j = 1; j < argc; j++) lua_pushlstring(lua,argv[j],sdslen(argv[j])); ldb.step = 1;                server.lua_replicate_commands = 1; lua_pcall(lua,argc-1,1,0);   ldb.step = 0;                server.lua_replicate_commands = saved_rc; lua_pop(lua,2);              }"
"static zval *phar_rename_archive(phar_archive_data *phar, char *ext, zend_bool compress TSRMLS_DC)  { const char *oldname = NULL; char *oldpath = NULL; char *basename = NULL, *basepath = NULL; char *newname = NULL, *newpath = NULL; zval *ret, arg1; zend_class_entry *ce; char *error; const char *pcr_error; int ext_len = ext ? strlen(ext) : 0; int oldname_len; phar_archive_data **pphar = NULL; php_stream_statbuf ssb; if (!ext) { if (phar->is_zip) { if (phar->is_data) { ext = ""zip""; } else { ext = ""phar.zip""; } } else if (phar->is_tar) { switch (phar->flags) { case PHAR_FILE_COMPRESSED_GZ: if (phar->is_data) { ext = ""tar.gz""; } else { ext = ""phar.tar.gz""; } break; case PHAR_FILE_COMPRESSED_BZ2: if (phar->is_data) { ext = ""tar.bz2""; } else { ext = ""phar.tar.bz2""; } break; default: if (phar->is_data) { ext = ""tar""; } else { ext = ""phar.tar""; } } } else { switch (phar->flags) { case PHAR_FILE_COMPRESSED_GZ: ext = ""phar.gz""; break; case PHAR_FILE_COMPRESSED_BZ2: ext = ""phar.bz2""; break; default: ext = ""phar""; } } } else if (phar_path_check(&ext, &ext_len, &pcr_error) > pcr_is_ok) { if (phar->is_data) { zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext); } else { zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar converted from \""%s\"" has invalid extension %s"", phar->fname, ext); } return NULL; } if (ext[0] == '.') { ++ext; } oldpath = estrndup(phar->fname, phar->fname_len); oldname = zend_memrchr(phar->fname, '/', phar->fname_len); ++oldname; oldname_len = strlen(oldname); basename = estrndup(oldname, oldname_len); spprintf(&newname, 0, ""%s.%s"", strtok(basename, "".""), ext); efree(basename); basepath = estrndup(oldpath, (strlen(oldpath) - oldname_len)); phar->fname_len = spprintf(&newpath, 0, ""%s%s"", basepath, newname); phar->fname = newpath; phar->ext = newpath + phar->fname_len - strlen(ext) - 1; efree(basepath); efree(newname); if (PHAR_G(manifest_cached) && SUCCESS == zend_hash_find(&cached_phars, newpath, phar->fname_len, (void **) &pphar)) { efree(oldpath); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, new phar name is in phar.cache_list"", phar->fname); return NULL; } if (SUCCESS == zend_hash_find(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void **) &pphar)) { if ((*pphar)->fname_len == phar->fname_len && !memcmp((*pphar)->fname, phar->fname, phar->fname_len)) { if (!zend_hash_num_elements(&phar->manifest)) { (*pphar)->is_tar = phar->is_tar; (*pphar)->is_zip = phar->is_zip; (*pphar)->is_data = phar->is_data; (*pphar)->flags = phar->flags; (*pphar)->fp = phar->fp; phar->fp = NULL; phar_destroy_phar_data(phar TSRMLS_CC); phar = *pphar; phar->refcount++; newpath = oldpath; goto its_ok; } } efree(oldpath); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars, a phar with that name already exists"", phar->fname); return NULL; } its_ok: if (SUCCESS == php_stream_stat_path(newpath, &ssb)) { zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" exists and must be unlinked prior to conversion"", newpath); efree(oldpath); return NULL; } if (!phar->is_data) { if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 1, 1, 1 TSRMLS_CC)) { efree(oldpath); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""phar \""%s\"" has invalid extension %s"", phar->fname, ext); return NULL; } if (phar->alias) { if (phar->is_temporary_alias) { phar->alias = NULL; phar->alias_len = 0; } else { phar->alias = estrndup(newpath, strlen(newpath)); phar->alias_len = strlen(newpath); phar->is_temporary_alias = 1; zend_hash_update(&(PHAR_GLOBALS->phar_alias_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL); } } } else { if (SUCCESS != phar_detect_phar_fname_ext(newpath, phar->fname_len, (const char **) &(phar->ext), &(phar->ext_len), 0, 1, 1 TSRMLS_CC)) { efree(oldpath); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""data phar \""%s\"" has invalid extension %s"", phar->fname, ext); return NULL; } phar->alias = NULL; phar->alias_len = 0; } if ((!pphar || phar == *pphar) && SUCCESS != zend_hash_update(&(PHAR_GLOBALS->phar_fname_map), newpath, phar->fname_len, (void*)&phar, sizeof(phar_archive_data*), NULL)) { efree(oldpath); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to add newly converted phar \""%s\"" to the list of phars"", phar->fname); return NULL; } phar_flush(phar, 0, 0, 1, &error TSRMLS_CC); if (error) { zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""%s"", error); efree(error); efree(oldpath); return NULL; } efree(oldpath); if (phar->is_data) { ce = phar_ce_data; } else { ce = phar_ce_archive; } MAKE_STD_ZVAL(ret); if (SUCCESS != object_init_ex(ret, ce)) { zval_dtor(ret); zend_throw_exception_ex(spl_ce_BadMethodCallException, 0 TSRMLS_CC, ""Unable to instantiate phar object when converting archive \""%s\"""", phar->fname); return NULL; } INIT_PZVAL(&arg1); ZVAL_STRINGL(&arg1, phar->fname, phar->fname_len, 0); zend_call_method_with_1_params(&ret, ce, &ce->constructor, ""__construct"", NULL, &arg1); return ret; }"
"boost::optional<SaplingNotePlaintext> SaplingNotePlaintext::decrypt( const SaplingEncCiphertext &ciphertext, const uint256 &ivk, const uint256 &epk, const uint256 &cmu ) { auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk); if (!pt) { return boost::none; } CDataStream ss(SER_NETWORK, PROTOCOL_VERSION); ss << pt.get(); SaplingNotePlaintext ret; ss >> ret; assert(ss.size() == 0); uint256 pk_d; if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) { return boost::none; } uint256 cmu_expected; if (!librustzcash_sapling_compute_cm( ret.d.data(), pk_d.begin(), ret.value(), ret.rcm.begin(), cmu_expected.begin() )) { return boost::none; } if (cmu_expected != cmu) { return boost::none; } return ret; }"
"static ssize_t parse8BIM(Image *ifile, Image *ofile) { char brkused, quoted, *line, *token, *newstr, *name; int state, next; unsigned char dataset; unsigned int recnum; int inputlen = MaxTextExtent; MagickOffsetType savedpos, currentpos; ssize_t savedolen = 0L, outputlen = 0L; TokenInfo *token_info; dataset = 0; recnum = 0; line = (char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*line)); if (line == (char *) NULL) return(-1); newstr = name = token = (char *) NULL; savedpos = 0; token_info=AcquireTokenInfo(); while (super_fgets(&line,&inputlen,ifile)!=NULL) { state=0; next=0; token=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*token)); if (token == (char *) NULL) break; newstr=(char *) AcquireQuantumMemory((size_t) inputlen,sizeof(*newstr)); if (newstr == (char *) NULL) break; while (Tokenizer(token_info,0,token,(size_t) inputlen,line,"""",""="",""\"""",0, &brkused,&next,&quoted)==0) { if (state == 0) { int state, next; char brkused, quoted; state=0; next=0; while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""#"", """", 0,&brkused,&next,&quoted)==0) { switch (state) { case 0: if (strcmp(newstr,""8BIM"")==0) dataset = 255; else dataset = (unsigned char) StringToLong(newstr); break; case 1: recnum = (unsigned int) StringToUnsignedLong(newstr); break; case 2: name=(char *) AcquireQuantumMemory(strlen(newstr)+MaxTextExtent, sizeof(*name)); if (name) (void) strcpy(name,newstr); break; } state++; } } else if (state == 1) { int next; ssize_t len; char brkused, quoted; next=0; len = (ssize_t) strlen(token); while (Tokenizer(token_info,0,newstr,(size_t) inputlen,token,"""",""&"", """",0,&brkused,&next,&quoted)==0) { if (brkused && next > 0) { char *s = &token[next-1]; len -= (ssize_t) convertHTMLcodes(s,(int) strlen(s)); } } if (dataset == 255) { unsigned char nlen = 0; int i; if (savedolen > 0) { MagickOffsetType offset; ssize_t diff = outputlen - savedolen; currentpos = TellBlob(ofile); if (currentpos < 0) return(-1); offset=SeekBlob(ofile,savedpos,SEEK_SET); if (offset < 0) return(-1); (void) WriteBlobMSBLong(ofile,(unsigned int) diff); offset=SeekBlob(ofile,currentpos,SEEK_SET); if (offset < 0) return(-1); savedolen = 0L; } if (outputlen & 1) { (void) WriteBlobByte(ofile,0x00); outputlen++; } (void) WriteBlobString(ofile,""8BIM""); (void) WriteBlobMSBShort(ofile,(unsigned short) recnum); outputlen += 6; if (name) nlen = (unsigned char) strlen(name); (void) WriteBlobByte(ofile,nlen); outputlen++; for (i=0; i<nlen; i++) (void) WriteBlobByte(ofile,(unsigned char) name[i]); outputlen += nlen; if ((nlen & 0x01) == 0) { (void) WriteBlobByte(ofile,0x00); outputlen++; } if (recnum != IPTC_ID) { (void) WriteBlobMSBLong(ofile, (unsigned int) len); outputlen += 4; next=0; outputlen += len; while (len--) (void) WriteBlobByte(ofile,(unsigned char) token[next++]); if (outputlen & 1) { (void) WriteBlobByte(ofile,0x00); outputlen++; } } else { savedpos = TellBlob(ofile); if (savedpos < 0) return(-1); (void) WriteBlobMSBLong(ofile,0xFFFFFFFFU); outputlen += 4; savedolen = outputlen; } } else { if (len <= 0x7FFF) { (void) WriteBlobByte(ofile,0x1c); (void) WriteBlobByte(ofile,(unsigned char) dataset); (void) WriteBlobByte(ofile,(unsigned char) (recnum & 0xff)); (void) WriteBlobMSBShort(ofile,(unsigned short) len); outputlen += 5; next=0; outputlen += len; while (len--) (void) WriteBlobByte(ofile,(unsigned char) token[next++]); } } } state++; } if (token != (char *) NULL) token=DestroyString(token); if (newstr != (char *) NULL) newstr=DestroyString(newstr); if (name != (char *) NULL) name=DestroyString(name); } token_info=DestroyTokenInfo(token_info); if (token != (char *) NULL) token=DestroyString(token); if (newstr != (char *) NULL) newstr=DestroyString(newstr); if (name != (char *) NULL) name=DestroyString(name); line=DestroyString(line); if (savedolen > 0) { MagickOffsetType offset; ssize_t diff = outputlen - savedolen; currentpos = TellBlob(ofile); if (currentpos < 0) return(-1); offset=SeekBlob(ofile,savedpos,SEEK_SET); if (offset < 0) return(-1); (void) WriteBlobMSBLong(ofile,(unsigned int) diff); offset=SeekBlob(ofile,currentpos,SEEK_SET); if (offset < 0) return(-1); savedolen = 0L; } return(outputlen); }"
"static void spl_array_set_array(zval *object, spl_array_object *intern, zval **array, long ar_flags, int just_array TSRMLS_DC) { if (Z_TYPE_PP(array) == IS_ARRAY) { SEPARATE_ZVAL_IF_NOT_REF(array); } if (Z_TYPE_PP(array) == IS_OBJECT && (Z_OBJ_HT_PP(array) == &spl_handler_ArrayObject || Z_OBJ_HT_PP(array) == &spl_handler_ArrayIterator)) { zval_ptr_dtor(&intern->array); if (just_array){ spl_array_object *other = (spl_array_object*)zend_object_store_get_object(*array TSRMLS_CC); ar_flags = other->ar_flags & ~SPL_ARRAY_INT_MASK; } ar_flags |= SPL_ARRAY_USE_OTHER; intern->array = *array; } else { if (Z_TYPE_PP(array) != IS_OBJECT && Z_TYPE_PP(array) != IS_ARRAY) { zend_throw_exception(spl_ce_InvalidArgumentException, ""Passed variable is not an array or object, using empty array instead"", 0 TSRMLS_CC); return; } zval_ptr_dtor(&intern->array); intern->array = *array; } if (object == *array) { intern->ar_flags |= SPL_ARRAY_IS_SELF; intern->ar_flags &= ~SPL_ARRAY_USE_OTHER; } else { intern->ar_flags &= ~SPL_ARRAY_IS_SELF; } intern->ar_flags |= ar_flags; Z_ADDREF_P(intern->array); if (Z_TYPE_PP(array) == IS_OBJECT) { zend_object_get_properties_t handler = Z_OBJ_HANDLER_PP(array, get_properties); if ((handler != std_object_handlers.get_properties && handler != spl_array_get_properties) || !spl_array_get_hash_table(intern, 0 TSRMLS_CC)) { zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0 TSRMLS_CC, ""Overloaded object of type %s is not compatible with %s"", Z_OBJCE_PP(array)->name, intern->std.ce->name); } } spl_array_rewind(intern TSRMLS_CC); }"
"bool TransactionSync::importDownloadedTxs( NodeIDPtr _fromNode, TransactionsPtr _txs, Block::Ptr _verifiedProposal) { if (_txs->size() == 0) { return true; } auto txsSize = _txs->size(); bool enforceImport = false; BlockHeader::Ptr proposalHeader = nullptr; if (_verifiedProposal && _verifiedProposal->blockHeader()) { proposalHeader = _verifiedProposal->blockHeader(); enforceImport = true; } auto recordT = utcTime(); auto startT = utcTime(); std::atomic_bool verifySuccess = {true}; tbb::parallel_for( tbb::blocked_range<size_t>(0, txsSize), [&](const tbb::blocked_range<size_t>& _r) { for (size_t i = _r.begin(); i < _r.end(); i++) { auto tx = (*_txs)[i]; if (!tx) { continue; } tx->appendKnownNode(_fromNode); if (_verifiedProposal && proposalHeader) { tx->setBatchId(proposalHeader->number()); tx->setBatchHash(proposalHeader->hash()); } if (m_config->txpoolStorage()->exist(tx->hash())) { continue; } try { tx->verify(); } catch (std::exception const& e) { tx->setInvalid(true); SYNC_LOG(WARNING) << LOG_DESC(""verify sender for tx failed"") << LOG_KV(""reason"", boost::diagnostic_information(e)) << LOG_KV(""hash"", tx->hash().abridged()); verifySuccess = false; } } }); if (enforceImport && !verifySuccess) { return false; } auto verifyT = utcTime() - startT; startT = utcTime(); auto txpool = m_config->txpoolStorage(); size_t successImportTxs = 0; for (size_t i = 0; i < txsSize; i++) { auto tx = (*_txs)[i]; if (tx->invalid()) { continue; } auto result = txpool->submitTransaction( std::const_pointer_cast<Transaction>(tx), nullptr, enforceImport); if (result != TransactionStatus::None) { if (enforceImport) { SYNC_LOG(DEBUG) << LOG_BADGE(""importDownloadedTxs: verify proposal failed"") << LOG_KV(""tx"", tx->hash().abridged()) << LOG_KV(""result"", result) << LOG_KV(""propIndex"", proposalHeader->number()) << LOG_KV(""propHash"", proposalHeader->hash().abridged()); return false; } SYNC_LOG(TRACE) << LOG_BADGE(""importDownloadedTxs"") << LOG_DESC(""Import transaction into txpool failed"") << LOG_KV(""errorCode"", result) << LOG_KV(""tx"", tx->hash().abridged()); continue; } successImportTxs++; } SYNC_LOG(DEBUG) << LOG_DESC(""importDownloadedTxs success"") << LOG_KV(""nodeId"", m_config->nodeID()->shortHex()) << LOG_KV(""successImportTxs"", successImportTxs) << LOG_KV(""totalTxs"", txsSize) << LOG_KV(""verifyT"", verifyT) << LOG_KV(""submitT"", (utcTime() - startT)) << LOG_KV(""timecost"", (utcTime() - recordT)); return true; }"
"static int handle_exception(struct kvm_vcpu *vcpu) { struct vcpu_vmx *vmx = to_vmx(vcpu); struct kvm_run *kvm_run = vcpu->run; u32 intr_info, ex_no, error_code; unsigned long cr2, rip, dr6; u32 vect_info; enum emulation_result er; vect_info = vmx->idt_vectoring_info; intr_info = vmx->exit_intr_info; if (is_machine_check(intr_info)) return handle_machine_check(vcpu); if ((intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR) return 1;   if (is_no_device(intr_info)) { vmx_fpu_activate(vcpu); return 1; } if (is_invalid_opcode(intr_info)) { if (is_guest_mode(vcpu)) { kvm_queue_exception(vcpu, UD_VECTOR); return 1; } er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD); if (er != EMULATE_DONE) kvm_queue_exception(vcpu, UD_VECTOR); return 1; } error_code = 0; if (intr_info & INTR_INFO_DELIVER_CODE_MASK) error_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE); if ((vect_info & VECTORING_INFO_VALID_MASK) && !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) { vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR; vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX; vcpu->run->internal.ndata = 3; vcpu->run->internal.data[0] = vect_info; vcpu->run->internal.data[1] = intr_info; vcpu->run->internal.data[2] = error_code; return 0; } if (is_page_fault(intr_info)) { BUG_ON(enable_ept); cr2 = vmcs_readl(EXIT_QUALIFICATION); trace_kvm_page_fault(cr2, error_code); if (kvm_event_needs_reinjection(vcpu)) kvm_mmu_unprotect_page_virt(vcpu, cr2); return kvm_mmu_page_fault(vcpu, cr2, error_code, NULL, 0); } ex_no = intr_info & INTR_INFO_VECTOR_MASK; if (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no)) return handle_rmode_exception(vcpu, ex_no, error_code); switch (ex_no) { case AC_VECTOR: kvm_queue_exception_e(vcpu, AC_VECTOR, error_code); return 1; case DB_VECTOR: dr6 = vmcs_readl(EXIT_QUALIFICATION); if (!(vcpu->guest_debug & (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) { vcpu->arch.dr6 &= ~15; vcpu->arch.dr6 |= dr6 | DR6_RTM; if (!(dr6 & ~DR6_RESERVED))  skip_emulated_instruction(vcpu); kvm_queue_exception(vcpu, DB_VECTOR); return 1; } kvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1; kvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7); case BP_VECTOR: vmx->vcpu.arch.event_exit_inst_len = vmcs_read32(VM_EXIT_INSTRUCTION_LEN); kvm_run->exit_reason = KVM_EXIT_DEBUG; rip = kvm_rip_read(vcpu); kvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip; kvm_run->debug.arch.exception = ex_no; break; default: kvm_run->exit_reason = KVM_EXIT_EXCEPTION; kvm_run->ex.exception = ex_no; kvm_run->ex.error_code = error_code; break; } return 0; }"
"R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut32 i = 0; RBinJavaBootStrapMethod *bsm = NULL; ut64 offset = 0; RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); offset += 6; if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR; attr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free); for (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) { if (offset >= sz) { break; } bsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset); if (bsm) { offset += bsm->size; r_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm); } else { } } attr->size = offset; } return attr; }"
"static void prepare_cmd(struct argv_array *out, const struct child_process *cmd) { if (!cmd->argv[0]) die(""BUG: command is empty""); argv_array_push(out, SHELL_PATH); if (cmd->git_cmd) { argv_array_push(out, ""git""); argv_array_pushv(out, cmd->argv); } else if (cmd->use_shell) { prepare_shell_cmd(out, cmd->argv); } else { argv_array_pushv(out, cmd->argv); } if (!strchr(out->argv[1], '/')) { char *program = locate_in_PATH(out->argv[1]); if (program) { free((char *)out->argv[1]); out->argv[1] = program; } } }"
"int genl_register_family(struct genl_family *family) { int err, i; int start = GENL_START_ALLOC, end = GENL_MAX_ID; err = genl_validate_ops(family); if (err) return err; genl_lock_all(); if (genl_family_find_byname(family->name)) { err = -EEXIST; goto errout_locked; } if (family == &genl_ctrl) { start = end = GENL_ID_CTRL; } else if (strcmp(family->name, ""pmcraid"") == 0) { start = end = GENL_ID_PMCRAID; } else if (strcmp(family->name, ""VFS_DQUOT"") == 0) { start = end = GENL_ID_VFS_DQUOT; } if (family->maxattr && !family->parallel_ops) { family->attrbuf = kmalloc_array(family->maxattr + 1, sizeof(struct nlattr *), GFP_KERNEL); if (family->attrbuf == NULL) { err = -ENOMEM; goto errout_locked; } } else family->attrbuf = NULL; family->id = idr_alloc(&genl_fam_idr, family, start, end + 1, GFP_KERNEL); if (family->id < 0) { err = family->id; goto errout_locked; } err = genl_validate_assign_mc_groups(family); if (err) goto errout_remove; genl_unlock_all(); genl_ctrl_event(CTRL_CMD_NEWFAMILY, family, NULL, 0); for (i = 0; i < family->n_mcgrps; i++) genl_ctrl_event(CTRL_CMD_NEWMCAST_GRP, family, &family->mcgrps[i], family->mcgrp_offset + i); return 0; errout_remove: idr_remove(&genl_fam_idr, family->id); kfree(family->attrbuf); errout_locked: genl_unlock_all(); return err; }"
"static size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address) { PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s); return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01, ""*l*lwwb*b*b*blww"", pcic->vendor_id, pcic->device_id, pcic->revision, pcic->subsystem_vendor_id, pcic->subsystem_id); }"
"static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image) { const char *comment; int bits; MagickBooleanType status; PDBImage pdb_image; PDBInfo pdb_info; QuantumInfo *quantum_info; register const PixelPacket *p; register ssize_t x; register unsigned char *q; size_t bits_per_pixel, literal, packets, packet_size, repeat; ssize_t y; unsigned char *buffer, *runlength, *scanline; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception); if (status == MagickFalse) return(status); (void) TransformImageColorspace(image,sRGBColorspace); if ((image -> colors <= 2 ) || (GetImageType(image,&image->exception ) == BilevelType)) { bits_per_pixel=1; } else if (image->colors <= 4) { bits_per_pixel=2; } else if (image->colors <= 8) { bits_per_pixel=3; } else { bits_per_pixel=4; } (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info)); (void) CopyMagickString(pdb_info.name,image_info->filename, sizeof(pdb_info.name)); pdb_info.attributes=0; pdb_info.version=0; pdb_info.create_time=time(NULL); pdb_info.modify_time=pdb_info.create_time; pdb_info.archive_time=0; pdb_info.modify_number=0; pdb_info.application_info=0; pdb_info.sort_info=0; (void) CopyMagickMemory(pdb_info.type,""vIMG"",4); (void) CopyMagickMemory(pdb_info.id,""View"",4); pdb_info.seed=0; pdb_info.next_record=0; comment=GetImageProperty(image,""comment""); pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2); (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info); (void) WriteBlob(image,4,(unsigned char *) pdb_info.type); (void) WriteBlob(image,4,(unsigned char *) pdb_info.id); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records); (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name)); pdb_image.version=1;   switch (bits_per_pixel) { case 1: pdb_image.type=(unsigned char) 0xff; break;   case 2: pdb_image.type=(unsigned char) 0x00; break;   default: pdb_image.type=(unsigned char) 0x02;   } pdb_image.reserved_1=0; pdb_image.note=0; pdb_image.x_last=0; pdb_image.y_last=0; pdb_image.reserved_2=0; pdb_image.x_anchor=(unsigned short) 0xffff; pdb_image.y_anchor=(unsigned short) 0xffff; pdb_image.width=(short) image->columns; if (image->columns % 16) pdb_image.width=(short) (16*(image->columns/16+1)); pdb_image.height=(short) image->rows; packets=((bits_per_pixel*image->columns+7)/8); runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets, image->rows*sizeof(*runlength)); if (runlength == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer)); if (buffer == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); packet_size=(size_t) (image->depth > 8 ? 2: 1); scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size* sizeof(*scanline)); if (scanline == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) (void) TransformImageColorspace(image,sRGBColorspace); quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); bits=8/(int) bits_per_pixel-1;   literal=0; repeat=0; q=runlength; buffer[0]=0x00; for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info, GrayQuantum,scanline,&image->exception); for (x=0; x < (ssize_t) pdb_image.width; x++) { if (x < (ssize_t) image->columns) buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >> (8-bits_per_pixel) << bits*bits_per_pixel; bits--; if (bits < 0) { if (((literal+repeat) > 0) && (buffer[literal+repeat] == buffer[literal+repeat-1])) { if (repeat == 0) { literal--; repeat++; } repeat++; if (0x7f < repeat) { q=EncodeRLE(q,buffer,literal,repeat); literal=0; repeat=0; } } else { if (repeat >= 2) literal+=repeat; else { q=EncodeRLE(q,buffer,literal,repeat); buffer[0]=buffer[literal+repeat]; literal=0; } literal++; repeat=0; if (0x7f < literal) { q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0); (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80); literal-=0x80; } } bits=8/(int) bits_per_pixel-1; buffer[literal+repeat]=0x00; } } status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } q=EncodeRLE(q,buffer,literal,repeat); scanline=(unsigned char *) RelinquishMagickMemory(scanline); buffer=(unsigned char *) RelinquishMagickMemory(buffer); quantum_info=DestroyQuantumInfo(quantum_info); (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8* pdb_info.number_records)); (void) WriteBlobByte(image,0x40); (void) WriteBlobByte(image,0x6f); (void) WriteBlobByte(image,0x80); (void) WriteBlobByte(image,0); if (pdb_info.number_records > 1) { (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q- runlength)); (void) WriteBlobByte(image,0x40); (void) WriteBlobByte(image,0x6f); (void) WriteBlobByte(image,0x80); (void) WriteBlobByte(image,1); } (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name); (void) WriteBlobByte(image,(unsigned char) pdb_image.version); (void) WriteBlobByte(image,pdb_image.type); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2); (void) WriteBlobMSBShort(image,pdb_image.x_anchor); (void) WriteBlobMSBShort(image,pdb_image.y_anchor); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height); (void) WriteBlob(image,(size_t) (q-runlength),runlength); runlength=(unsigned char *) RelinquishMagickMemory(runlength); if (pdb_info.number_records > 1) (void) WriteBlobString(image,comment); (void) CloseBlob(image); return(MagickTrue); }"
"static int formatIPTC(Image *ifile, Image *ofile) { char temp[MagickPathExtent]; unsigned int foundiptc, tagsfound; unsigned char recnum, dataset; unsigned char *readable, *str; ssize_t tagindx, taglen; int i, tagcount = (int) (sizeof(tags) / sizeof(tag_spec)); int c; foundiptc = 0;  tagsfound = 0;  c = ReadBlobByte(ifile); while (c != EOF) { if (c == 0x1c) foundiptc = 1; else { if (foundiptc) return(-1); else { c=0; continue; } } c = ReadBlobByte(ifile); if (c == EOF) return -1; dataset = (unsigned char) c; c = ReadBlobByte(ifile); if (c == EOF) return -1; recnum = (unsigned char) c; for (i=0; i< tagcount; i++) { if (tags[i].id == (short) recnum) break; } if (i < tagcount) readable = (unsigned char *) tags[i].name; else readable = (unsigned char *) """"; c=ReadBlobByte(ifile); if (c == EOF) return -1; if (c & (unsigned char) 0x80) return 0; else { int c0; c0=ReadBlobByte(ifile); if (c0 == EOF) return -1; taglen = (c << 8) | c0; } if (taglen < 0) return -1; str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent), sizeof(*str)); if (str == (unsigned char *) NULL) { printf(""MemoryAllocationFailed""); return 0; } for (tagindx=0; tagindx<taglen; tagindx++) { c=ReadBlobByte(ifile); if (c == EOF) return -1; str[tagindx] = (unsigned char) c; } str[taglen] = 0; if (strlen((char *)readable) > 0) (void) FormatLocaleString(temp,MagickPathExtent,""%d#%d#%s="", (unsigned int) dataset, (unsigned int) recnum, readable); else (void) FormatLocaleString(temp,MagickPathExtent,""%d#%d="", (unsigned int) dataset,(unsigned int) recnum); (void) WriteBlobString(ofile,temp); formatString( ofile, (char *)str, taglen ); str=(unsigned char *) RelinquishMagickMemory(str); tagsfound++; c=ReadBlobByte(ifile); } return((int) tagsfound); }"
"static char_u * skip_string(char_u *p) { int    i; for ( ; ; ++p) { if (p[0] == '\'')    { if (p[1] == NUL)    break; i = 2; if (p[1] == '\\' && p[2] != NUL)        { ++i; while (vim_isdigit(p[i - 1]))       ++i; } if (p[i] == '\'')        { p += i; continue; } } else if (p[0] == '""')    { for (++p; p[0]; ++p) { if (p[0] == '\\' && p[1] != NUL) ++p; else if (p[0] == '""')        break; } if (p[0] == '""') continue; } else if (p[0] == 'R' && p[1] == '""') { char_u *delim = p + 2; char_u *paren = vim_strchr(delim, '('); if (paren != NULL) { size_t delim_len = paren - delim; for (p += 3; *p; ++p) if (p[0] == ')' && STRNCMP(p + 1, delim, delim_len) == 0 && p[delim_len + 1] == '""') { p += delim_len + 1; break; } if (p[0] == '""') continue;     } } break;        } if (!*p) --p;        return p; }"
"static void sas_discover_domain(struct work_struct *work) { struct domain_device *dev; int error = 0; struct sas_discovery_event *ev = to_sas_discovery_event(work); struct asd_sas_port *port = ev->port; clear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending); if (port->port_dev) return; error = sas_get_port_device(port); if (error) return; dev = port->port_dev; SAS_DPRINTK(""DOING DISCOVERY on port %d, pid:%d\n"", port->id, task_pid_nr(current)); switch (dev->dev_type) { case SAS_END_DEVICE: error = sas_discover_end_dev(dev); break; case SAS_EDGE_EXPANDER_DEVICE: case SAS_FANOUT_EXPANDER_DEVICE: error = sas_discover_root_expander(dev); break; case SAS_SATA_DEV: case SAS_SATA_PM: #ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata(dev); break; #else SAS_DPRINTK(""ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\n""); #endif default: error = -ENXIO; SAS_DPRINTK(""unhandled device %d\n"", dev->dev_type); break; } if (error) { sas_rphy_free(dev->rphy); list_del_init(&dev->disco_list_node); spin_lock_irq(&port->dev_list_lock); list_del_init(&dev->dev_list_node); spin_unlock_irq(&port->dev_list_lock); sas_put_device(dev); port->port_dev = NULL; } SAS_DPRINTK(""DONE DISCOVERY on port %d, pid:%d, result:%d\n"", port->id, task_pid_nr(current), error); }"
"void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile) { struct rdma_umap_priv *priv, *next_priv; lockdep_assert_held(&ufile->hw_destroy_rwsem); while (1) { struct mm_struct *mm = NULL; mutex_lock(&ufile->umap_lock); while (!list_empty(&ufile->umaps)) { int ret; priv = list_first_entry(&ufile->umaps, struct rdma_umap_priv, list); mm = priv->vma->vm_mm; ret = mmget_not_zero(mm); if (!ret) { list_del_init(&priv->list); mm = NULL; continue; } break; } mutex_unlock(&ufile->umap_lock); if (!mm) return; down_write(&mm->mmap_sem); mutex_lock(&ufile->umap_lock); list_for_each_entry_safe (priv, next_priv, &ufile->umaps, list) { struct vm_area_struct *vma = priv->vma; if (vma->vm_mm != mm) continue; list_del_init(&priv->list); zap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start); vma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE); } mutex_unlock(&ufile->umap_lock); up_write(&mm->mmap_sem); mmput(mm); } }"
"static Jsi_RC MySqlQueryCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_RC rc = JSI_OK; MySqlObj *jdb; if (!(jdb = _mysql_getDbHandle(interp, _this, funcPtr))) return JSI_ERROR; Jsi_Value *vSql = Jsi_ValueArrayIndex(interp, args, 0); Jsi_DString eStr = {}; JSI_DSTRING_VAR(dStr, JSI_DB_DSTRING_SIZE); const char *zSql = Jsi_ValueGetDString(interp, vSql, &eStr, 0); Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 1); int cnt = 0; char **apColName = NULL; Jsi_OptionId *apColType = NULL; int isopts = 0; MyDbEvalContext sEval = {}; QueryOpts opts, *oEopt = NULL; opts = jdb->queryOpts; opts.callback = NULL; opts.width = NULL; Jsi_Value *callback = NULL, *width = NULL; if (arg) { if (Jsi_ValueIsFunction(interp,arg)) callback = opts.callback = arg; else if (Jsi_ValueIsString(interp, arg)) opts.objName = Jsi_ValueString(interp, arg, NULL); else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_ARRAY)) opts.values = arg; else if (Jsi_ValueIsObjType(interp, arg, JSI_OT_OBJECT)) isopts = 1; else  { rc = Jsi_LogError(""argument must be null, a function, string, array or options""); goto bail; } } if (isopts) { if (Jsi_OptionsProcess(interp, QueryFmtOptions, &opts, arg, 0) < 0) { rc = JSI_ERROR; goto bail; } callback = (opts.callback ? opts.callback : jdb->queryOpts.callback); width = (opts.width ? opts.width : jdb->queryOpts.width); } if (opts.objName) { if (Jsi_SqlObjBinds(interp, &eStr, opts.objName,  !(opts.objOpts&OBJMODE_NOTYPES),  !(opts.objOpts&OBJMODE_NODEFAULTS), (opts.objOpts&OBJMODE_NULLDEFAULTS)!=0) != JSI_OK) goto bail; zSql = Jsi_DSValue(&eStr); } if (!opts.separator) { switch (opts.mode) { case _mdb_EF_LIST: opts.separator = ""|""; break; case _mdb_EF_COLUMN: opts.separator = "" ""; break; case _mdb_EF_TABS: opts.separator = ""\t""; break; default: opts.separator = "",""; } } Jsi_DString sStr; Jsi_DSInit(&sStr); sEval.nocache = opts.nocache; if (mdbEvalInit(interp, &sEval, jdb, zSql, &sStr, 0, 0) != JSI_OK) { rc = JSI_ERROR; goto bail; } sEval.namedParams = (opts.noNamedParams==0 && !opts.values); sEval.ret = *ret; oEopt = jdb->optPtr; jdb->optPtr = &opts; if (sEval.namedParams) { rc = mdbEvalPrep(&sEval); if (rc == JSI_ERROR) goto bail; if (rc == JSI_BREAK) { rc = JSI_OK; goto bail; } } if (opts.mode == _mdb_EF_NONE) goto bail; if (callback) { sEval.tocall = callback; if (opts.mode != _mdb_EF_ROWS) rc = Jsi_LogError(""'mode' must be 'rows' with 'callback'""); else  rc = mdbEvalCallCmd(&sEval, interp, JSI_OK); goto bail; } switch (opts.mode) { case _mdb_EF_NONE: while(JSI_OK==(rc = mdbEvalStep(&sEval)) ) { cnt++; if (opts.limit && cnt>=opts.limit) break; } goto bail; break; case _mdb_EF_JSON: if (opts.headers) { Jsi_DSAppend(dStr, ""[ "", NULL); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0) { Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); } Jsi_DSAppend(dStr, ""]"", NULL); cnt++; } if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, ""]"", NULL); cnt++; if (opts.limit && cnt>opts.limit) break; } Jsi_DSAppend(dStr, "" ]"", NULL); } else { Jsi_DSAppend(dStr, ""[ "", NULL); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""{"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); Jsi_DSAppend(dStr, "":"", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, ""}"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSAppend(dStr, "" ]"", NULL); } break; case _mdb_EF_JSON2: { while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && 1) { Jsi_DSAppend(dStr, ""{ \""names\"": [ "", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); Jsi_JSONQuote(interp, apColName[i], -1, dStr); } Jsi_DSAppend(dStr, "" ], \""values\"": [ "", NULL); } if (cnt) Jsi_DSAppend(dStr, "", "", NULL); Jsi_DSAppend(dStr, ""["", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, "", "", NULL); mdbEvalSetColumnJSON(&sEval, i, dStr); } Jsi_DSAppend(dStr, "" ]"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } if (cnt) Jsi_DSAppend(dStr, "" ] } "", NULL); } break; case _mdb_EF_LIST: while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(dStr, apColName[i], NULL); } } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); mdbEvalSetColumn(&sEval, i, dStr); } cnt++; if (opts.limit && cnt>=opts.limit) break; } break; case _mdb_EF_COLUMN: { int *wids = NULL; Jsi_DString vStr = {}; while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i, w; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && nCol>0) { Jsi_DString sStr; wids = (int*)Jsi_Calloc(nCol, sizeof(int)); Jsi_DSInit(&sStr); for(i=0; i<nCol; i++) { int j = Jsi_Strlen(apColName[i]); wids[i] = (j<10?10:j); if (width) { Jsi_Value *wv = Jsi_ValueArrayIndex(interp, width, i); if (wv) { Jsi_Number dv; Jsi_ValueGetNumber(interp, wv, &dv); if (dv>0) wids[i] = (int)dv; } } w = (j<wids[i] ? j : wids[i]); Jsi_DSAppendLen(dStr, apColName[i], w); w = (j<wids[i] ? wids[i]-j+1 : 0); while (w-- > 0) Jsi_DSAppend(dStr, "" "", NULL); } for(i=0; i<nCol && opts.headers; i++) { w = wids[i]; w -= Jsi_Strlen(apColName[i]); if (i) { Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(&sStr, opts.separator, NULL); } w = wids[i]; while (w-- > 0) Jsi_DSAppend(&sStr, ""-"", NULL); } if (opts.headers) Jsi_DSAppend(dStr, ""\n"", Jsi_DSValue(&sStr), ""\n"", NULL); Jsi_DSFree(&sStr); } if (cnt) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); int nl = Jsi_DSLength(&vStr); if (nl > wids[i]) { Jsi_DSSetLength(&vStr, wids[i]); w = 0; } else { w = wids[i]-nl; } Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL); while (w-- > 0) Jsi_DSAppend(dStr, "" "", NULL); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); if (wids) Jsi_Free(wids); break; } case _mdb_EF_INSERT: { Jsi_DString vStr = {};     while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; const char *tbl = (opts.table ? opts.table : ""table""); if (cnt) Jsi_DSAppend(dStr, ""\n"", NULL); Jsi_DSAppend(dStr, ""INSERT INTO "", tbl, "" VALUES("", NULL); mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); for(i=0; i<nCol; i++) { Jsi_Number dv; const char *azArg; Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); MysqlPrep *prep = sEval.prep; Jsi_OptionId ptype = prep->fieldResult[i].jsiTypeMap; azArg = Jsi_DSValue(&vStr); const char *zSep = i>0 ? "","": """"; if (azArg[i]==0 && ptype != JSI_OPTION_STRING) { Jsi_DSAppend(dStr, zSep, ""NULL"", NULL); } else if( ptype ==JSI_OPTION_STRING) { if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL); mdbOutputQuotedString(dStr, azArg); } else if (ptype==JSI_OPTION_BOOL || ptype ==JSI_OPTION_DOUBLE) { Jsi_DSAppend(dStr, zSep, azArg, NULL); } else if( Jsi_GetDouble(interp, azArg, &dv) == JSI_OK ) { Jsi_DSAppend(dStr, zSep, azArg, NULL); } else { if( zSep[0] ) Jsi_DSAppend(dStr,zSep, NULL); mdbOutputQuotedString(dStr, azArg); } } Jsi_DSAppend(dStr, "");"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); } case _mdb_EF_TABS: case _mdb_EF_CSV: { Jsi_DString vStr = {};   while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSAppend(dStr, apColName[i], NULL); } } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); for(i=0; i<nCol; i++) { if (i) Jsi_DSAppend(dStr, opts.separator, NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); if (opts.mode == _mdb_EF_CSV) mdbOutputCsv(&opts, Jsi_DSValue(&vStr), dStr, 0); else Jsi_DSAppend(dStr, Jsi_DSValue(&vStr), NULL); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_LINE: { int i, w = 5, ww; int nCol; Jsi_DString vStr = {};    while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0) { for(i=0; i<nCol; i++) { ww = Jsi_Strlen(apColName[i]); if (ww>w) w = ww; } } for(i=0; i<nCol; i++) { Jsi_DString eStr; Jsi_DSInit(&eStr); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); Jsi_DSPrintf(&eStr, ""%*s = %s"", w, apColName[i], Jsi_DSValue(&vStr)); Jsi_DSAppend(dStr, (cnt?""\n"":""""), Jsi_DSValue(&eStr), NULL); Jsi_DSFree(&eStr); } cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_HTML: { Jsi_DString vStr = {};    while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { Jsi_DSAppend(dStr, ""<TR>"", NULL); for(i=0; i<nCol; i++) { Jsi_DSAppend(dStr, ""<TH>"", NULL); mdbOutputHtmlString(&opts, apColName[i], dStr); Jsi_DSAppend(dStr, ""</TH>"", NULL); } Jsi_DSAppend(dStr, ""</TR>"", NULL); } if (cnt || opts.headers) Jsi_DSAppend(dStr, ""\n"", NULL); Jsi_DSAppend(dStr, ""<TR>"", NULL); for(i=0; i<nCol; i++) { Jsi_DSAppend(dStr, ""<TD>"", NULL); Jsi_DSSetLength(&vStr, 0); mdbEvalSetColumn(&sEval, i, &vStr); mdbOutputHtmlString(&opts, Jsi_DSValue(&vStr), dStr); Jsi_DSAppend(dStr, ""</TD>"", NULL); } Jsi_DSAppend(dStr, ""</TR>"", NULL); cnt++; if (opts.limit && cnt>=opts.limit) break; } Jsi_DSFree(&vStr); break; } case _mdb_EF_ROWS: { Jsi_Value *vcur, *vrow; int cnt = 0; Jsi_Obj *oall, *ocur; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); ocur = Jsi_ObjNewType(interp, JSI_OT_OBJECT); vrow = Jsi_ValueMakeObject(interp, NULL, ocur); for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjInsert(interp, ocur, apColName[i], vcur, 0); } Jsi_ObjArrayAdd(interp, oall, vrow); cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } case _mdb_EF_ARRAYS: { Jsi_Value *vcur, *vrow; int cnt = 0; Jsi_Obj *oall, *ocur; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); for(i=0; i<nCol; i++) { vcur = Jsi_ValueNewStringDup(interp, apColName[i]); Jsi_ObjArrayAdd(interp, ocur, vcur); } Jsi_ObjArrayAdd(interp, oall, vrow); } vrow = Jsi_ValueMakeArrayObject(interp, NULL, ocur = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjArrayAdd(interp, ocur, vcur); } Jsi_ObjArrayAdd(interp, oall, vrow); cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } case _mdb_EF_ARRAY1D: { Jsi_Value *vcur; int cnt = 0; Jsi_Obj *oall; Jsi_ValueMakeArrayObject(interp, ret, oall = Jsi_ObjNewType(interp, JSI_OT_ARRAY)); while( JSI_OK==(rc = mdbEvalStep(&sEval)) ) { int i; int nCol; mdbEvalRowInfo(&sEval, &nCol, &apColName, &apColType); if (cnt == 0 && opts.headers) { for(i=0; i<nCol; i++) { vcur = Jsi_ValueNewStringDup(interp, apColName[i]); Jsi_ObjArrayAdd(interp, oall, vcur); } } for(i=0; i<nCol; i++) { vcur = mdbEvalSetColumnValue(&sEval, i, NULL); Jsi_ObjArrayAdd(interp, oall, vcur); } cnt++; if (opts.limit && cnt>=opts.limit) break; } mdbEvalFinalize(&sEval); if (rc != JSI_ERROR) rc = JSI_OK; goto bail; break; } } if( rc==JSI_BREAK ) { rc = JSI_OK; } Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(dStr)); bail: mdbEvalFinalize(&sEval); if (isopts) { Jsi_OptionsFree(interp, QueryFmtOptions, &opts, 0); } Jsi_DSFree(dStr); Jsi_DSFree(&eStr); jdb->optPtr = oEopt; return rc; }"
"void sqlc_union_order (sql_comp_t * sc, ST ** ptree) { ST * out = sqlc_union_dt_wrap (*ptree); if (out != *ptree) { *ptree = out; sql_stmt_comp (sc, ptree); } else sqlc_union_stmt (sc, ptree); }"
"static int bigben_probe(struct hid_device *hid, const struct hid_device_id *id) { struct bigben_device *bigben; struct hid_input *hidinput; struct list_head *report_list; struct led_classdev *led; char *name; size_t name_sz; int n, error; bigben = devm_kzalloc(&hid->dev, sizeof(*bigben), GFP_KERNEL); if (!bigben) return -ENOMEM; hid_set_drvdata(hid, bigben); bigben->hid = hid; bigben->removed = false; error = hid_parse(hid); if (error) { hid_err(hid, ""parse failed\n""); return error; } error = hid_hw_start(hid, HID_CONNECT_DEFAULT & ~HID_CONNECT_FF); if (error) { hid_err(hid, ""hw start failed\n""); return error; } report_list = &hid->report_enum[HID_OUTPUT_REPORT].report_list; bigben->report = list_entry(report_list->next, struct hid_report, list); hidinput = list_first_entry(&hid->inputs, struct hid_input, list); set_bit(FF_RUMBLE, hidinput->input->ffbit); INIT_WORK(&bigben->worker, bigben_worker); error = input_ff_create_memless(hidinput->input, NULL, hid_bigben_play_effect); if (error) goto error_hw_stop; name_sz = strlen(dev_name(&hid->dev)) + strlen("":red:bigben#"") + 1; for (n = 0; n < NUM_LEDS; n++) { led = devm_kzalloc( &hid->dev, sizeof(struct led_classdev) + name_sz, GFP_KERNEL ); if (!led) { error = -ENOMEM; goto error_hw_stop; } name = (void *)(&led[1]); snprintf(name, name_sz, ""%s:red:bigben%d"", dev_name(&hid->dev), n + 1 ); led->name = name; led->brightness = (n == 0) ? LED_ON : LED_OFF; led->max_brightness = 1; led->brightness_get = bigben_get_led; led->brightness_set = bigben_set_led; bigben->leds[n] = led; error = devm_led_classdev_register(&hid->dev, led); if (error) goto error_hw_stop; } bigben->led_state = BIT(0); bigben->right_motor_on = 0; bigben->left_motor_force = 0; bigben->work_led = true; bigben->work_ff = true; schedule_work(&bigben->worker); hid_info(hid, ""LED and force feedback support for BigBen gamepad\n""); return 0; error_hw_stop: hid_hw_stop(hid); return error; }"
"txScript* fxLoadScript(txMachine* the, txString path, txUnsigned flags) { txParser _parser; txParser* parser = &_parser; txParserJump jump; FILE* file = NULL; txString name = NULL; char map[C_PATH_MAX]; txScript* script = NULL; fxInitializeParser(parser, the, the->parserBufferSize, the->parserTableModulo); parser->firstJump = &jump; file = fopen(path, ""r""); if (c_setjmp(jump.jmp_buf) == 0) { mxParserThrowElse(file); parser->path = fxNewParserSymbol(parser, path); fxParserTree(parser, file, (txGetter)fgetc, flags, &name); fclose(file); file = NULL; if (name) { txString slash = c_strrchr(path, mxSeparator); if (slash) *slash = 0; c_strcat(path, name); mxParserThrowElse(c_realpath(path, map)); parser->path = fxNewParserSymbol(parser, map); file = fopen(map, ""r""); mxParserThrowElse(file); fxParserSourceMap(parser, file, (txGetter)fgetc, flags, &name); fclose(file); file = NULL; if (parser->errorCount == 0) { if (slash) *slash = 0; c_strcat(path, name); mxParserThrowElse(c_realpath(path, map)); parser->path = fxNewParserSymbol(parser, map); } } fxParserHoist(parser); fxParserBind(parser); script = fxParserCode(parser); } if (file) fclose(file); #ifdef mxInstrument if (the->peakParserSize < parser->total) the->peakParserSize = parser->total; #endif fxTerminateParser(parser); return script; }"
"static int asf_read_marker(AVFormatContext *s, int64_t size) { AVIOContext *pb = s->pb; ASFContext *asf = s->priv_data; int i, count, name_len, ret; char name[1024]; avio_rl64(pb);                avio_rl64(pb);                count = avio_rl32(pb);        avio_rl16(pb);                name_len = avio_rl16(pb);     for (i = 0; i < name_len; i++) avio_r8(pb);  for (i = 0; i < count; i++) { int64_t pres_time; int name_len; avio_rl64(pb);                     pres_time = avio_rl64(pb);         pres_time -= asf->hdr.preroll * 10000; avio_rl16(pb);                     avio_rl32(pb);                     avio_rl32(pb);                     name_len = avio_rl32(pb);          if ((ret = avio_get_str16le(pb, name_len * 2, name, sizeof(name))) < name_len) avio_skip(pb, name_len - ret); avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time, AV_NOPTS_VALUE, name); } return 0; }"
"void Compute(OpKernelContext* context) override { const Tensor& input = context->input(0); float input_min = context->input(1).flat<float>()(0); float input_max = context->input(2).flat<float>()(0); float input_scale = (input_max - input_min) / 255.0f; OP_REQUIRES(context, input_min < input_max, errors::InvalidArgument( ""input_min must be less than input_max : "", input_min, "" >= "", input_max)); auto input_tensor = input.tensor<quint8, 4>(); auto N = input_tensor.dimension(0); auto H = input_tensor.dimension(1); auto W = input_tensor.dimension(2); auto C = input_tensor.dimension(3); Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output(0, input.shape(), &output)); Tensor* output_min = nullptr; OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min)); Tensor* output_max = nullptr; OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max)); typedef TTypes<float>::Tensor::Index Index; const Eigen::IndexList<Eigen::type2index<1>, Eigen::type2index<2>> reduction_indices; Eigen::IndexList<Eigen::type2index<1>, Index, Index, Eigen::type2index<1>> broadcast_spec; broadcast_spec.set(1, H); broadcast_spec.set(2, W); Eigen::IndexList<Index, Eigen::type2index<1>, Eigen::type2index<1>, Index> expand_spec; expand_spec.set(0, N); expand_spec.set(3, C); Eigen::Tensor<float, 2, Eigen::RowMajor> float_mean(N, C); Eigen::Tensor<float, 2, Eigen::RowMajor> float_variance(N, C); #ifdef USE_NEON if (N == 1 && (C % 16 == 0)) { VLOG(2) << ""Calling optimized""; ColMeanAndVariance(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data()); float minimum = given_y_min_, maximum = given_y_max_; if (!output_range_given_) { MinAndMax(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data(), variance_epsilon_, &minimum, &maximum); } if (maximum - minimum < min_separation_) { maximum = minimum + min_separation_; } InstanceNorm(reinterpret_cast<const uint8_t*>(input_tensor.data()), H * W, C, float_mean.data(), float_variance.data(), variance_epsilon_, minimum, maximum, reinterpret_cast<uint8_t*>(output->flat<quint8>().data())); output_min->scalar<float>()() = minimum; output_max->scalar<float>()() = maximum; } else  #endif { VLOG(2) << ""Calling unoptimized""; float_mean = input_tensor.cast<float>().reduce( reduction_indices, Eigen::internal::MeanReducer<float>()); float_variance = (input_scale * ((input_tensor.cast<float>() - float_mean.reshape(expand_spec).broadcast(broadcast_spec)))) .square() .reduce(reduction_indices, Eigen::internal::MeanReducer<float>()); Eigen::Tensor<float, 4, Eigen::RowMajor> instance_normed = input_scale * (input_tensor.cast<float>() - float_mean.reshape(expand_spec).broadcast(broadcast_spec)) * (float_variance + variance_epsilon_) .rsqrt() .reshape(expand_spec) .broadcast(broadcast_spec); Eigen::Tensor<float, 0, Eigen::RowMajor> normed_min; Eigen::Tensor<float, 0, Eigen::RowMajor> normed_max; if (!output_range_given_) { normed_min = instance_normed.minimum(); normed_max = instance_normed.maximum(); } else { normed_min() = given_y_min_; normed_max() = given_y_max_; } if (normed_max() - normed_min() < min_separation_) { normed_max() = normed_min() + min_separation_; } FloatToQuantizedStruct<quint8> output_f2q(normed_min(), normed_max()); auto instance_normed_quantized = QUANTIZE_WITH_EIGEN(instance_normed, output_f2q, quint8); output->tensor<quint8, 4>().device( context->template eigen_device<CPUDevice>()) = instance_normed_quantized; output_min->flat<float>()(0) = normed_min(); output_max->flat<float>()(0) = normed_max(); } }"
"void xmlParsePEReference(xmlParserCtxtPtr ctxt) { const xmlChar *name; xmlEntityPtr entity = NULL; xmlParserInputPtr input; if (RAW != '%') return; NEXT; name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, ""PEReference: no name\n""); return; } if (xmlParserDebugEntities) xmlGenericError(xmlGenericErrorContext, ""PEReference: %s\n"", name); if (RAW != ';') { xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL); return; } NEXT; ctxt->nbentities++; if ((ctxt->sax != NULL) && (ctxt->sax->getParameterEntity != NULL)) entity = ctxt->sax->getParameterEntity(ctxt->userData, name); if (ctxt->instate == XML_PARSER_EOF) return; if (entity == NULL) { if ((ctxt->standalone == 1) || ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) { xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY, ""PEReference: %%%s; not found\n"", name); } else { if ((ctxt->validate) && (ctxt->vctxt.error != NULL)) { xmlValidityError(ctxt, XML_WAR_UNDECLARED_ENTITY, ""PEReference: %%%s; not found\n"", name, NULL); } else xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY, ""PEReference: %%%s; not found\n"", name, NULL); ctxt->valid = 0; } xmlParserEntityCheck(ctxt, 0, NULL, 0); } else { if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) && (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) { xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY, ""Internal: %%%s; is not a parameter entity\n"", name, NULL); } else { xmlChar start[4]; xmlCharEncoding enc; if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) && ((ctxt->options & XML_PARSE_NOENT) == 0) && ((ctxt->options & XML_PARSE_DTDVALID) == 0) && ((ctxt->options & XML_PARSE_DTDLOAD) == 0) && ((ctxt->options & XML_PARSE_DTDATTR) == 0) && (ctxt->replaceEntities == 0) && (ctxt->validate == 0)) return; input = xmlNewEntityInputStream(ctxt, entity); if (xmlPushInput(ctxt, input) < 0) return; if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) { GROW if (ctxt->instate == XML_PARSER_EOF) return; if ((ctxt->input->end - ctxt->input->cur)>=4) { start[0] = RAW; start[1] = NXT(1); start[2] = NXT(2); start[3] = NXT(3); enc = xmlDetectCharEncoding(start, 4); if (enc != XML_CHAR_ENCODING_NONE) { xmlSwitchEncoding(ctxt, enc); } } if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) { xmlParseTextDecl(ctxt); } } } } ctxt->hasPErefs = 1; }"
"void StartAdvertisingSet(int reg_id, IdTxPowerStatusCallback register_cb, AdvertiseParameters params, std::vector<uint8_t> advertise_data, std::vector<uint8_t> scan_response_data, PeriodicAdvertisingParameters periodic_params, std::vector<uint8_t> periodic_data, uint16_t duration, uint8_t maxExtAdvEvents, IdStatusCallback timeout_cb) { LOG(INFO) << __func__ << "" in shim layer""; bluetooth::hci::ExtendedAdvertisingConfig config{}; parse_parameter(config, params); bluetooth::hci::PeriodicAdvertisingParameters periodic_parameters; periodic_parameters.max_interval = periodic_params.max_interval; periodic_parameters.min_interval = periodic_params.min_interval; periodic_parameters.properties = periodic_params.periodic_advertising_properties; config.periodic_advertising_parameters = periodic_parameters; size_t offset = 0; while (offset < advertise_data.size()) { GapData gap_data; uint8_t len = advertise_data[offset]; auto begin = advertise_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.advertisement.push_back(gap_data); offset += len + 1;      } offset = 0; while (offset < scan_response_data.size()) { GapData gap_data; uint8_t len = scan_response_data[offset]; auto begin = scan_response_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.scan_response.push_back(gap_data); offset += len + 1;      } offset = 0; while (offset < periodic_data.size()) { GapData gap_data; uint8_t len = periodic_data[offset]; auto begin = periodic_data.begin() + offset; auto end = begin + len + 1;        auto data_copy = std::make_shared<std::vector<uint8_t>>(begin, end); bluetooth::packet::PacketView<bluetooth::packet::kLittleEndian> packet( data_copy); GapData::Parse(&gap_data, packet.begin()); config.periodic_data.push_back(gap_data); offset += len + 1;      } bluetooth::hci::AdvertiserId id = bluetooth::shim::GetAdvertising()->ExtendedCreateAdvertiser( reg_id, config, scan_callback, set_terminated_callback, duration, maxExtAdvEvents, bluetooth::shim::GetGdShimHandler()); LOG(INFO) << ""create advertising set, reg_id:"" << reg_id << "", id:"" << (uint16_t)id; BTM_LogHistory(kBtmLogTag, RawAddress::kEmpty, ""Le advert started"", base::StringPrintf(""advert_id:%d"", reg_id)); }"
"void TileManager::crop( RawTile *ttt ){ int tw = image->getTileWidth(); int th = image->getTileHeight(); if( loglevel >= 5 ){ *logfile << ""TileManager :: Edge tile: Base size: "" << tw << ""x"" << th << "": This tile: "" << ttt->width << ""x"" << ttt->height << endl; } int len = tw * th * ttt->channels * (ttt->bpc/8); unsigned char* buffer = (unsigned char*) malloc( len ); unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len ); unsigned char* dst_ptr = (unsigned char*) ttt->data; len =  ttt->width * ttt->channels * (ttt->bpc/8); for( unsigned int i=0; i<ttt->height; i++ ){ memcpy( dst_ptr, src_ptr, len ); dst_ptr += len; src_ptr += tw * ttt->channels * (ttt->bpc/8); } free( buffer ); len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8); ttt->dataLength = len; ttt->padded = false; }"
"static ssize_t o2nm_node_ipv4_address_store(struct config_item *item, const char *page, size_t count) { struct o2nm_node *node = to_o2nm_node(item); struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node); int ret, i; struct rb_node **p, *parent; unsigned int octets[4]; __be32 ipv4_addr = 0; ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2], &octets[1], &octets[0]); if (ret != 4) return -EINVAL; for (i = 0; i < ARRAY_SIZE(octets); i++) { if (octets[i] > 255) return -ERANGE; be32_add_cpu(&ipv4_addr, octets[i] << (i * 8)); } ret = 0; write_lock(&cluster->cl_nodes_lock); if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent)) ret = -EEXIST; else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes)) ret = -EBUSY; else { rb_link_node(&node->nd_ip_node, parent, p); rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree); } write_unlock(&cluster->cl_nodes_lock); if (ret) return ret; memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr)); return count; }"
"static int decode_studio_vop_header(Mpeg4DecContext *ctx, GetBitContext *gb) { MpegEncContext *s = &ctx->m; if (get_bits_left(gb) <= 32) return 0; s->partitioned_frame = 0; s->decode_mb = mpeg4_decode_studio_mb; decode_smpte_tc(ctx, gb); skip_bits(gb, 10);  skip_bits(gb, 2);  s->pict_type = get_bits(gb, 2) + AV_PICTURE_TYPE_I;  if (get_bits1(gb)) {  skip_bits1(gb);  skip_bits1(gb);  s->progressive_frame = get_bits1(gb) ^ 1;  } if (s->pict_type == AV_PICTURE_TYPE_I) { if (get_bits1(gb)) reset_studio_dc_predictors(s); } if (ctx->shape != BIN_ONLY_SHAPE) { s->alternate_scan = get_bits1(gb); s->frame_pred_frame_dct = get_bits1(gb); s->dct_precision = get_bits(gb, 2); s->intra_dc_precision = get_bits(gb, 2); s->q_scale_type = get_bits1(gb); } if (s->alternate_scan) { ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_alternate_vertical_scan); ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_alternate_vertical_scan); ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_vertical_scan); ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan); } else { ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable,   ff_zigzag_direct); ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable,   ff_zigzag_direct); ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan); ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan); } mpeg4_load_default_matrices(s); next_start_code_studio(gb); extension_and_user_data(s, gb, 4); return 0; }"
"static void inputSendThreadProc(void* context) { SOCK_RET err; PPACKET_HOLDER holder; char encryptedBuffer[MAX_INPUT_PACKET_SIZE]; int encryptedSize; while (!PltIsThreadInterrupted(&inputSendThread)) { int encryptedLengthPrefix; err = LbqWaitForQueueElement(&packetQueue, (void**)&holder); if (err != LBQ_SUCCESS) { return; } if (holder->packet.multiController.header.packetType == htonl(PACKET_TYPE_MULTI_CONTROLLER)) { PPACKET_HOLDER controllerBatchHolder; PNV_MULTI_CONTROLLER_PACKET origPkt; int dirs[6]; memset(dirs, 0, sizeof(dirs)); origPkt = &holder->packet.multiController; for (;;) { PNV_MULTI_CONTROLLER_PACKET newPkt; if (LbqPeekQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) { break; } if (controllerBatchHolder->packet.multiController.header.packetType != htonl(PACKET_TYPE_MULTI_CONTROLLER)) { break; } newPkt = &controllerBatchHolder->packet.multiController; if (newPkt->buttonFlags != origPkt->buttonFlags || newPkt->controllerNumber != origPkt->controllerNumber || !checkDirs(origPkt->leftTrigger, newPkt->leftTrigger, &dirs[0]) || !checkDirs(origPkt->rightTrigger, newPkt->rightTrigger, &dirs[1]) || !checkDirs(origPkt->leftStickX, newPkt->leftStickX, &dirs[2]) || !checkDirs(origPkt->leftStickY, newPkt->leftStickY, &dirs[3]) || !checkDirs(origPkt->rightStickX, newPkt->rightStickX, &dirs[4]) || !checkDirs(origPkt->rightStickY, newPkt->rightStickY, &dirs[5])) { break; } if (LbqPollQueueElement(&packetQueue, (void**)&controllerBatchHolder) != LBQ_SUCCESS) { break; } origPkt->leftTrigger = newPkt->leftTrigger; origPkt->rightTrigger = newPkt->rightTrigger; origPkt->leftStickX = newPkt->leftStickX; origPkt->leftStickY = newPkt->leftStickY; origPkt->rightStickX = newPkt->rightStickX; origPkt->rightStickY = newPkt->rightStickY; free(controllerBatchHolder); } } else if (holder->packet.mouseMove.header.packetType == htonl(PACKET_TYPE_MOUSE_MOVE)) { PPACKET_HOLDER mouseBatchHolder; int totalDeltaX = (short)htons(holder->packet.mouseMove.deltaX); int totalDeltaY = (short)htons(holder->packet.mouseMove.deltaY); for (;;) { int partialDeltaX; int partialDeltaY; if (LbqPeekQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) { break; } if (mouseBatchHolder->packet.mouseMove.header.packetType != htonl(PACKET_TYPE_MOUSE_MOVE)) { break; } partialDeltaX = (short)htons(mouseBatchHolder->packet.mouseMove.deltaX); partialDeltaY = (short)htons(mouseBatchHolder->packet.mouseMove.deltaY); if (partialDeltaX + totalDeltaX > INT16_MAX || partialDeltaX + totalDeltaX < INT16_MIN || partialDeltaY + totalDeltaY > INT16_MAX || partialDeltaY + totalDeltaY < INT16_MIN) { break; } if (LbqPollQueueElement(&packetQueue, (void**)&mouseBatchHolder) != LBQ_SUCCESS) { break; } totalDeltaX += partialDeltaX; totalDeltaY += partialDeltaY; free(mouseBatchHolder); } holder->packet.mouseMove.deltaX = htons((short)totalDeltaX); holder->packet.mouseMove.deltaY = htons((short)totalDeltaY); } encryptedSize = sizeof(encryptedBuffer) - 4; err = encryptData((const unsigned char*)&holder->packet, holder->packetLength, (unsigned char*)&encryptedBuffer[4], &encryptedSize); free(holder); if (err != 0) { Limelog(""Input: Encryption failed: %d\n"", (int)err); ListenerCallbacks.connectionTerminated(err); return; } encryptedLengthPrefix = htonl((unsigned long)encryptedSize); memcpy(&encryptedBuffer[0], &encryptedLengthPrefix, 4); if (ServerMajorVersion < 5) { err = send(inputSock, (const char*) encryptedBuffer, (int) (encryptedSize + sizeof(encryptedLengthPrefix)), 0); if (err <= 0) { Limelog(""Input: send() failed: %d\n"", (int) LastSocketError()); ListenerCallbacks.connectionTerminated(LastSocketError()); return; } } else { if (ServerMajorVersion >= 7 && encryptedSize >= 16 + sizeof(currentAesIv)) { memcpy(currentAesIv, &encryptedBuffer[4 + encryptedSize - sizeof(currentAesIv)], sizeof(currentAesIv)); } err = (SOCK_RET)sendInputPacketOnControlStream((unsigned char*) encryptedBuffer, (int) (encryptedSize + sizeof(encryptedLengthPrefix))); if (err < 0) { Limelog(""Input: sendInputPacketOnControlStream() failed: %d\n"", (int) err); ListenerCallbacks.connectionTerminated(LastSocketError()); return; } } } }"
"static int MqttClient_WaitType(MqttClient *client, void *packet_obj, byte wait_type, word16 wait_packet_id, int timeout_ms) { int rc; word16 packet_id; MqttPacketType packet_type; #ifdef WOLFMQTT_MULTITHREAD MqttPendResp *pendResp; int readLocked; #endif MqttMsgStat* mms_stat; int waitMatchFound; if (client == NULL || packet_obj == NULL) { return MQTT_CODE_ERROR_BAD_ARG; } mms_stat = (MqttMsgStat*)packet_obj; wait_again: packet_id = 0; packet_type = MQTT_PACKET_TYPE_RESERVED; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; readLocked = 0; #endif waitMatchFound = 0; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Type %s (%d), ID %d"", MqttPacket_TypeDesc((MqttPacketType)wait_type), wait_type, wait_packet_id); #endif switch ((int)*mms_stat) { case MQTT_MSG_BEGIN: { #ifdef WOLFMQTT_MULTITHREAD rc = wm_SemLock(&client->lockRecv); if (rc != 0) { PRINTF(""MqttClient_WaitType: recv lock error!""); return rc; } readLocked = 1; #endif client->packet.stat = MQTT_PK_BEGIN; } FALL_THROUGH; #ifdef WOLFMQTT_V5 case MQTT_MSG_AUTH: #endif case MQTT_MSG_WAIT: { #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,  wait_packet_id, &pendResp)) { if (pendResp->packetDone) { rc = pendResp->packet_ret; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp already Done %p: Rc %d"", pendResp, rc); #endif MqttClient_RespList_Remove(client, pendResp); wm_SemUnlock(&client->lockClient); wm_SemUnlock(&client->lockRecv); return rc; } } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  *mms_stat = MQTT_MSG_WAIT; rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len, timeout_ms); if (rc <= 0) { break; } client->packet.buf_len = rc; rc = MqttClient_DecodePacket(client, client->rx_buf, client->packet.buf_len, NULL, &packet_type, NULL, &packet_id); if (rc < 0) { break; } #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""Read Packet: Len %d, Type %d, ID %d"", client->packet.buf_len, packet_type, packet_id); #endif *mms_stat = MQTT_MSG_READ; } FALL_THROUGH; case MQTT_MSG_READ: case MQTT_MSG_READ_PAYLOAD: { MqttPacketType use_packet_type; void* use_packet_obj; #ifdef WOLFMQTT_MULTITHREAD readLocked = 1;  #endif if (*mms_stat == MQTT_MSG_READ_PAYLOAD) { packet_type = MQTT_PACKET_TYPE_PUBLISH; } if ((wait_type == MQTT_PACKET_TYPE_ANY || wait_type == packet_type || MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) && (wait_packet_id == 0 || wait_packet_id == packet_id)) { use_packet_obj = packet_obj; waitMatchFound = 1; } else { use_packet_obj = &client->msg; } use_packet_type = packet_type; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, packet_type, packet_id, &pendResp)) { pendResp->packetProcessing = 1; use_packet_obj = pendResp->packet_obj; use_packet_type = pendResp->packet_type; waitMatchFound = 0; } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  rc = MqttClient_HandlePacket(client, use_packet_type, use_packet_obj, timeout_ms); #ifdef WOLFMQTT_NONBLOCK if (rc == MQTT_CODE_CONTINUE) { return rc; } #endif if (rc >= 0) { rc = MQTT_CODE_SUCCESS; } #ifdef WOLFMQTT_MULTITHREAD if (pendResp) { if (wm_SemLock(&client->lockClient) == 0) { pendResp->packetDone = 1; pendResp->packet_ret = rc; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp Done %p"", pendResp); #endif pendResp = NULL; wm_SemUnlock(&client->lockClient); } } #endif  break; } case MQTT_MSG_WRITE: case MQTT_MSG_WRITE_PAYLOAD: default: { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Invalid state %d!"", *mms_stat); #endif rc = MQTT_CODE_ERROR_STAT; break; } }  #ifdef WOLFMQTT_NONBLOCK if (rc != MQTT_CODE_CONTINUE) #endif { *mms_stat = MQTT_MSG_BEGIN; } #ifdef WOLFMQTT_MULTITHREAD if (readLocked) { wm_SemUnlock(&client->lockRecv); } #endif if (rc < 0) { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Failure: %s (%d)"", MqttClient_ReturnCodeToString(rc), rc); #endif return rc; } if (!waitMatchFound) { goto wait_again; } return rc; }"
"static ssize_t bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) { struct bsg_device *bd = file->private_data; ssize_t bytes_written; int ret; dprintk(""%s: write %Zd bytes\n"", bd->name, count); bsg_set_block(bd, file); bytes_written = 0; ret = __bsg_write(bd, buf, count, &bytes_written, file->f_mode & FMODE_WRITE); *ppos = bytes_written; if (!bytes_written || err_block_err(ret)) bytes_written = ret; dprintk(""%s: returning %Zd\n"", bd->name, bytes_written); return bytes_written; }"
"zend_object_iterator *spl_array_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)  { spl_array_it       *iterator; spl_array_object   *array_object = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC); if (by_ref && (array_object->ar_flags & SPL_ARRAY_OVERLOADED_CURRENT)) { zend_error(E_ERROR, ""An iterator cannot be used with foreach by reference""); } iterator     = emalloc(sizeof(spl_array_it)); Z_ADDREF_P(object); iterator->intern.it.data = (void*)object; iterator->intern.it.funcs = &spl_array_it_funcs; iterator->intern.ce = ce; iterator->intern.value = NULL; iterator->object = array_object; return (zend_object_iterator*)iterator; }"
static void decompileCONSTANTPOOL (SWF_ACTION *act) { OUT_BEGIN(SWF_ACTIONCONSTANTPOOL); pool=sact->ConstantPool; }
"SWFReader *gf_swf_reader_new(const char *localPath, const char *inputName) { SWFReader *read; FILE *input; input = gf_fopen(inputName, ""rb""); if (!input) return NULL; GF_SAFEALLOC(read, SWFReader); if (!read) return NULL; read->inputName = gf_strdup(inputName); read->input = input; read->bs = gf_bs_from_file(input, GF_BITSTREAM_READ); gf_bs_set_eos_callback(read->bs, swf_io_error, &read); read->display_list = gf_list_new(); read->fonts = gf_list_new(); read->apps = gf_list_new(); read->sounds = gf_list_new(); if (localPath) { read->localPath = gf_strdup(localPath); } else { char *c; read->localPath = gf_strdup(inputName); c = strrchr(read->localPath, GF_PATH_SEPARATOR); if (c) c[1] = 0; else { gf_free(read->localPath); read->localPath = NULL; } } return read; }"
"static bool read_lead(zckCtx *zck) { VALIDATE_READ_BOOL(zck); int lead = 5 + 2*MAX_COMP_SIZE; char *header = zmalloc(lead); if (!header) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); return false; } size_t length = 0; if(read_data(zck, header, lead) < lead) { free(header); set_error(zck, ""Short read""); return false; } if(memcmp(header, ""\0ZHR1"", 5) == 0) { zck->header_only = true; } else if(memcmp(header, ""\0ZCK1"", 5) != 0) { free(header); set_error(zck, ""Invalid lead, perhaps this is not a zck file?""); return false; } length += 5; int hash_type = 0; if(!compint_to_int(zck, &hash_type, header+length, &length, lead)) { free(header); return false; } if(zck->prep_hash_type > -1 && zck->prep_hash_type != hash_type) { free(header); set_error(zck, ""Hash type (%i) doesn't match requested hash type "" ""(%i)"", hash_type, zck->prep_hash_type); return false; } if(!hash_setup(zck, &(zck->hash_type), hash_type)) { free(header); return false; } zck_log(ZCK_LOG_DEBUG, ""Setting header and full digest hash type to %s"", zck_hash_name_from_type(hash_type)); size_t header_length = 0; if(!compint_to_size(zck, &header_length, header+length, &length, lead)) { free(header); hash_reset(&(zck->hash_type)); return false; } if(header_length > SIZE_MAX) { free(header); set_error(zck, ""Header length of %li invalid"", header_length); hash_reset(&(zck->hash_type)); return false; } zck->header_length = header_length; zck->hdr_digest_loc = length; zck_log(ZCK_LOG_DEBUG, ""Reading header digest""); header = zrealloc(header, length + zck->hash_type.digest_size); if (!header) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); return false; } size_t to_read = 0; if(lead < length + zck->hash_type.digest_size) to_read = length + zck->hash_type.digest_size - lead; if(read_data(zck, header + lead, to_read) < to_read) { free(header); zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); return false; } lead += to_read; if(zck->prep_digest && memcmp(zck->prep_digest, header + length, zck->hash_type.digest_size) != 0) { zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); set_error(zck, ""Header digest doesn't match requested header digest"" ""Expected: %sActual: %s"", get_digest_string(zck->prep_digest, zck->hash_type.digest_size), get_digest_string(header + length, zck->hash_type.digest_size)); free(header); return false; } zck->header_digest = zmalloc(zck->hash_type.digest_size); if (!zck->header_digest) { zck_log(ZCK_LOG_ERROR, ""OOM in %s"", __func__); free(header); return false; } memcpy(zck->header_digest, header + length, zck->hash_type.digest_size); length += zck->hash_type.digest_size; if(zck->prep_hdr_size > -1 && (size_t)zck->prep_hdr_size != zck->header_length + length) { free(header); zck->header_length = 0; zck->hdr_digest_loc = 0; hash_reset(&(zck->hash_type)); free(zck->header_digest); zck->header_digest = NULL; set_error( zck, ""Header length (%llu) doesn't match requested header length (%llu)"", (long long unsigned) zck->header_length + length, (long long unsigned) zck->prep_hdr_size ); return false; } zck->header = header; zck->header_size = lead; zck->lead_string = header; zck->lead_size = length; zck_log( ZCK_LOG_DEBUG, ""Parsed lead: %llu bytes"", (long long unsigned) length ); return true; }"
"void xps_load_sfnt_name(xps_font_t *font, char *namep) { byte *namedata; int offset, length; int count, stringoffset; int found; int i, k; found = 0; strcpy(namep, ""Unknown""); offset = xps_find_sfnt_table(font, ""name"", &length); if (offset < 0 || length < 6) { gs_warn(""cannot find name table""); return; } namedata = font->data + offset; count = u16(namedata + 2); stringoffset = u16(namedata + 4); if (length < 6 + (count * 12)) { gs_warn(""name table too short""); return; } for (i = 0; i < count; i++) { byte *record = namedata + 6 + i * 12; int pid = u16(record + 0); int eid = u16(record + 2); int langid = u16(record + 4); int nameid = u16(record + 6); length = u16(record + 8); offset = u16(record + 10); if (nameid == 4 || nameid == 6) { if (pid == 1 && eid == 0 && langid == 0)  { if (found < 3) { memcpy(namep, namedata + stringoffset + offset, length); namep[length] = 0; found = 3; } } if (pid == 3 && eid == 1 && langid == 0x409)  { if (found < 2) { unsigned char *s = namedata + stringoffset + offset; int n = length / 2; for (k = 0; k < n; k ++) { int c = u16(s + k * 2); namep[k] = isprint(c) ? c : '?'; } namep[k] = 0; found = 2; } } if (pid == 3 && eid == 10 && langid == 0x409)  { if (found < 1) { unsigned char *s = namedata + stringoffset + offset; int n = length / 4; for (k = 0; k < n; k ++) { int c = u32(s + k * 4); namep[k] = isprint(c) ? c : '?'; } namep[k] = 0; found = 1; } } } } }"
"struct ieee802_11_elems * ieee802_11_parse_elems_full(struct ieee80211_elems_parse_params *params) { struct ieee802_11_elems *elems; const struct element *non_inherit = NULL; u8 *nontransmitted_profile; int nontransmitted_profile_len = 0; elems = kzalloc(sizeof(*elems), GFP_ATOMIC); if (!elems) return NULL; elems->ie_start = params->start; elems->total_len = params->len; nontransmitted_profile = kmalloc(params->len, GFP_ATOMIC); if (nontransmitted_profile) { nontransmitted_profile_len = ieee802_11_find_bssid_profile(params->start, params->len, elems, params->bss, nontransmitted_profile); non_inherit = cfg80211_find_ext_elem(WLAN_EID_EXT_NON_INHERITANCE, nontransmitted_profile, nontransmitted_profile_len); } elems->crc = _ieee802_11_parse_elems_full(params, elems, non_inherit); if (nontransmitted_profile_len) { struct ieee80211_elems_parse_params sub = { .start = nontransmitted_profile, .len = nontransmitted_profile_len, .action = params->action, .link_id = params->link_id, }; _ieee802_11_parse_elems_full(&sub, elems, NULL); } if (elems->tim && !elems->parse_error) { const struct ieee80211_tim_ie *tim_ie = elems->tim; elems->dtim_period = tim_ie->dtim_period; elems->dtim_count = tim_ie->dtim_count; } if (elems->bssid_index && elems->bssid_index_len >= offsetofend(struct ieee80211_bssid_index, dtim_period)) elems->dtim_period = elems->bssid_index->dtim_period; if (elems->bssid_index && elems->bssid_index_len >= offsetofend(struct ieee80211_bssid_index, dtim_count)) elems->dtim_count = elems->bssid_index->dtim_count; kfree(nontransmitted_profile); return elems; }"
"int ldbRepl(lua_State *lua) { sds *argv; int argc; while(1) { while((argv = ldbReplParseCommand(&argc)) == NULL) { char buf[1024]; int nread = connRead(ldb.conn,buf,sizeof(buf)); if (nread <= 0) { ldb.step = 0; ldb.bpcount = 0; return C_ERR; } ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread); } sdsfree(ldb.cbuf); ldb.cbuf = sdsempty(); if (!strcasecmp(argv[0],""h"") || !strcasecmp(argv[0],""help"")) { ldbLog(sdsnew(""Redis Lua debugger help:"")); ldbLog(sdsnew(""[h]elp               Show this help."")); ldbLog(sdsnew(""[s]tep               Run current line and stop again."")); ldbLog(sdsnew(""[n]ext               Alias for step."")); ldbLog(sdsnew(""[c]continue          Run till next breakpoint."")); ldbLog(sdsnew(""[l]list              List source code around current line."")); ldbLog(sdsnew(""[l]list [line]       List source code around [line]."")); ldbLog(sdsnew(""                     line = 0 means: current position."")); ldbLog(sdsnew(""[l]list [line] [ctx] In this form [ctx] specifies how many lines"")); ldbLog(sdsnew(""                     to show before/after [line]."")); ldbLog(sdsnew(""[w]hole              List all source code. Alias for 'list 1 1000000'."")); ldbLog(sdsnew(""[p]rint              Show all the local variables."")); ldbLog(sdsnew(""[p]rint <var>        Show the value of the specified variable."")); ldbLog(sdsnew(""                     Can also show global vars KEYS and ARGV."")); ldbLog(sdsnew(""[b]reak              Show all breakpoints."")); ldbLog(sdsnew(""[b]reak <line>       Add a breakpoint to the specified line."")); ldbLog(sdsnew(""[b]reak -<line>      Remove breakpoint from the specified line."")); ldbLog(sdsnew(""[b]reak 0            Remove all breakpoints."")); ldbLog(sdsnew(""[t]race              Show a backtrace."")); ldbLog(sdsnew(""[e]eval <code>       Execute some Lua code (in a different callframe)."")); ldbLog(sdsnew(""[r]edis <cmd>        Execute a Redis command."")); ldbLog(sdsnew(""[m]axlen [len]       Trim logged Redis replies and Lua var dumps to len."")); ldbLog(sdsnew(""                     Specifying zero as <len> means unlimited."")); ldbLog(sdsnew(""[a]bort              Stop the execution of the script. In sync"")); ldbLog(sdsnew(""                     mode dataset changes will be retained."")); ldbLog(sdsnew("""")); ldbLog(sdsnew(""Debugger functions you can call from Lua scripts:"")); ldbLog(sdsnew(""redis.debug()        Produce logs in the debugger console."")); ldbLog(sdsnew(""redis.breakpoint()   Stop execution like if there was a breakpoint in the"")); ldbLog(sdsnew(""                     next line of code."")); ldbSendLogs(); } else if (!strcasecmp(argv[0],""s"") || !strcasecmp(argv[0],""step"") || !strcasecmp(argv[0],""n"") || !strcasecmp(argv[0],""next"")) { ldb.step = 1; break; } else if (!strcasecmp(argv[0],""c"") || !strcasecmp(argv[0],""continue"")){ break; } else if (!strcasecmp(argv[0],""t"") || !strcasecmp(argv[0],""trace"")) { ldbTrace(lua); ldbSendLogs(); } else if (!strcasecmp(argv[0],""m"") || !strcasecmp(argv[0],""maxlen"")) { ldbMaxlen(argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""b"") || !strcasecmp(argv[0],""break"")) { ldbBreak(argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""e"") || !strcasecmp(argv[0],""eval"")) { ldbEval(lua,argv,argc); ldbSendLogs(); } else if (!strcasecmp(argv[0],""a"") || !strcasecmp(argv[0],""abort"")) { lua_pushstring(lua, ""script aborted for user request""); lua_error(lua); } else if (argc > 1 && (!strcasecmp(argv[0],""r"") || !strcasecmp(argv[0],""redis""))) { ldbRedis(lua,argv,argc); ldbSendLogs(); } else if ((!strcasecmp(argv[0],""p"") || !strcasecmp(argv[0],""print""))) { if (argc == 2) ldbPrint(lua,argv[1]); else ldbPrintAll(lua); ldbSendLogs(); } else if (!strcasecmp(argv[0],""l"") || !strcasecmp(argv[0],""list"")){ int around = ldb.currentline, ctx = 5; if (argc > 1) { int num = atoi(argv[1]); if (num > 0) around = num; } if (argc > 2) ctx = atoi(argv[2]); ldbList(around,ctx); ldbSendLogs(); } else if (!strcasecmp(argv[0],""w"") || !strcasecmp(argv[0],""whole"")){ ldbList(1,1000000); ldbSendLogs(); } else { ldbLog(sdsnew(""<error> Unknown Redis Lua debugger command or "" ""wrong number of arguments."")); ldbSendLogs(); } sdsfreesplitres(argv,argc); } sdsfreesplitres(argv,argc); return C_OK; }"
"GURL DevToolsWindow::GetDevToolsURL(Profile* profile, const GURL& base_url, bool shared_worker_frontend, const std::string& remote_frontend, bool can_dock, const std::string& settings) { if (base_url.SchemeIs(""data"")) return base_url; std::string frontend_url( !remote_frontend.empty() ? remote_frontend : base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec()); std::string url_string( frontend_url + ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"")); if (shared_worker_frontend) url_string += ""&isSharedWorker=true""; if (remote_frontend.size()) { url_string += ""&remoteFrontend=true""; } else { url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec(); } if (can_dock) url_string += ""&can_dock=true""; if (settings.size()) url_string += ""&settings="" + settings; return GURL(url_string); }"
"static int handle_input_expect_data_payload(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end, const char **err_desc) { size_t bytes_avail = src_end - *src; if (bytes_avail > stream->recvbuf.bytes_left_in_data_frame) bytes_avail = stream->recvbuf.bytes_left_in_data_frame; if (stream->req_body == NULL) h2o_buffer_init(&stream->req_body, &h2o_socket_buffer_prototype); if (!h2o_buffer_try_append(&stream->req_body, *src, bytes_avail)) return H2O_HTTP3_ERROR_INTERNAL; stream->req.entity = h2o_iovec_init(stream->req_body->bytes, stream->req_body->size); stream->req.req_body_bytes_received += bytes_avail; stream->recvbuf.bytes_left_in_data_frame -= bytes_avail; *src += bytes_avail; if (stream->recvbuf.bytes_left_in_data_frame == 0) stream->recvbuf.handle_input = handle_input_expect_data; return 0; }"
"static Image *ReadHDRImage(const ImageInfo *image_info,ExceptionInfo *exception) { char format[MaxTextExtent], keyword[MaxTextExtent], tag[MaxTextExtent], value[MaxTextExtent]; double gamma; Image *image; int c; MagickBooleanType status, value_expected; register Quantum *q; register ssize_t i, x; register unsigned char *p; ssize_t count, y; unsigned char *end, pixel[4], *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } image->columns=0; image->rows=0; *format='\0'; c=ReadBlobByte(image); if (c == EOF) { image=DestroyImage(image); return((Image *) NULL); } while (isgraph(c) && (image->columns == 0) && (image->rows == 0)) { if (c == (int) '#') { char *comment; register char *p; size_t length; length=MaxTextExtent; comment=AcquireString((char *) NULL); for (p=comment; comment != (char *) NULL; p++) { c=ReadBlobByte(image); if ((c == EOF) || (c == (int) '\n')) break; if ((size_t) (p-comment+1) >= length) { *p='\0'; length<<=1; comment=(char *) ResizeQuantumMemory(comment,length+ MaxTextExtent,sizeof(*comment)); if (comment == (char *) NULL) break; p=comment+strlen(comment); } *p=(char) c; } if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); *p='\0'; (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); c=ReadBlobByte(image); } else if (isalnum(c) == MagickFalse) c=ReadBlobByte(image); else { register char *p; p=keyword; do { if ((size_t) (p-keyword) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); } while (isalnum(c) || (c == '_')); *p='\0'; value_expected=MagickFalse; while ((isspace((int) ((unsigned char) c)) != 0) || (c == '=')) { if (c == '=') value_expected=MagickTrue; c=ReadBlobByte(image); } if (LocaleCompare(keyword,""Y"") == 0) value_expected=MagickTrue; if (value_expected == MagickFalse) continue; p=value; while ((c != '\n') && (c != '\0')) { if ((size_t) (p-value) < (MaxTextExtent-1)) *p++=c; c=ReadBlobByte(image); } *p='\0'; switch (*keyword) { case 'F': case 'f': { if (LocaleCompare(keyword,""format"") == 0) { (void) CopyMagickString(format,value,MaxTextExtent); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'G': case 'g': { if (LocaleCompare(keyword,""gamma"") == 0) { image->gamma=StringToDouble(value,(char **) NULL); break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'P': case 'p': { if (LocaleCompare(keyword,""primaries"") == 0) { float chromaticity[6], white_point[2]; (void) sscanf(value,""%g %g %g %g %g %g %g %g"", &chromaticity[0],&chromaticity[1],&chromaticity[2], &chromaticity[3],&chromaticity[4],&chromaticity[5], &white_point[0],&white_point[1]); image->chromaticity.red_primary.x=chromaticity[0]; image->chromaticity.red_primary.y=chromaticity[1]; image->chromaticity.green_primary.x=chromaticity[2]; image->chromaticity.green_primary.y=chromaticity[3]; image->chromaticity.blue_primary.x=chromaticity[4]; image->chromaticity.blue_primary.y=chromaticity[5]; image->chromaticity.white_point.x=white_point[0], image->chromaticity.white_point.y=white_point[1]; break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } case 'Y': case 'y': { char target[] = ""Y""; if (strcmp(keyword,target) == 0) { int height, width; (void) sscanf(value,""%d +X %d"",&height,&width); image->columns=(size_t) width; image->rows=(size_t) height; break; } (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } default: { (void) FormatLocaleString(tag,MaxTextExtent,""hdr:%s"",keyword); (void) SetImageProperty(image,tag,value,exception); break; } } } if ((image->columns == 0) && (image->rows == 0)) while (isspace((int) ((unsigned char) c)) != 0) c=ReadBlobByte(image); } if ((LocaleCompare(format,""32-bit_rle_rgbe"") != 0) && (LocaleCompare(format,""32-bit_rle_xyze"") != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((image->columns == 0) || (image->rows == 0)) ThrowReaderException(CorruptImageError,""NegativeOrZeroImageSize""); (void) SetImageColorspace(image,RGBColorspace,exception); if (LocaleCompare(format,""32-bit_rle_xyze"") == 0) (void) SetImageColorspace(image,XYZColorspace,exception); image->compression=(image->columns < 8) || (image->columns > 0x7ffff) ? NoCompression : RLECompression; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); pixels=(unsigned char *) AcquireQuantumMemory(image->columns,4* sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (y=0; y < (ssize_t) image->rows; y++) { if (image->compression != RLECompression) { count=ReadBlob(image,4*image->columns*sizeof(*pixels),pixels); if (count != (ssize_t) (4*image->columns*sizeof(*pixels))) break; } else { count=ReadBlob(image,4*sizeof(*pixel),pixel); if (count != 4) break; if ((size_t) ((((size_t) pixel[2]) << 8) | pixel[3]) != image->columns) { (void) memcpy(pixels,pixel,4*sizeof(*pixel)); count=ReadBlob(image,4*(image->columns-1)*sizeof(*pixels),pixels+4); image->compression=NoCompression; } else { p=pixels; for (i=0; i < 4; i++) { end=&pixels[(i+1)*image->columns]; while (p < end) { count=ReadBlob(image,2*sizeof(*pixel),pixel); if (count < 1) break; if (pixel[0] > 128) { count=(ssize_t) pixel[0]-128; if ((count == 0) || (count > (ssize_t) (end-p))) break; while (count-- > 0) *p++=pixel[1]; } else { count=(ssize_t) pixel[0]; if ((count == 0) || (count > (ssize_t) (end-p))) break; *p++=pixel[1]; if (--count > 0) { count=ReadBlob(image,(size_t) count*sizeof(*p),p); if (count < 1) break; p+=count; } } } } } } q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; i=0; for (x=0; x < (ssize_t) image->columns; x++) { if (image->compression == RLECompression) { pixel[0]=pixels[x]; pixel[1]=pixels[x+image->columns]; pixel[2]=pixels[x+2*image->columns]; pixel[3]=pixels[x+3*image->columns]; } else { pixel[0]=pixels[i++]; pixel[1]=pixels[i++]; pixel[2]=pixels[i++]; pixel[3]=pixels[i++]; } SetPixelRed(image,0,q); SetPixelGreen(image,0,q); SetPixelBlue(image,0,q); if (pixel[3] != 0) { gamma=pow(2.0,pixel[3]-(128.0+8.0)); SetPixelRed(image,ClampToQuantum(QuantumRange*gamma*pixel[0]),q); SetPixelGreen(image,ClampToQuantum(QuantumRange*gamma*pixel[1]),q); SetPixelBlue(image,ClampToQuantum(QuantumRange*gamma*pixel[2]),q); } q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"int read_fru_area(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id, uint32_t offset, uint32_t length, uint8_t *frubuf) { uint32_t off = offset, tmp, finish; struct ipmi_rs * rsp; struct ipmi_rq req; uint8_t msg_data[4]; if (offset > fru->size) { lprintf(LOG_ERR, ""Read FRU Area offset incorrect: %d > %d"", offset, fru->size); return -1; } finish = offset + length; if (finish > fru->size) { finish = fru->size; lprintf(LOG_NOTICE, ""Read FRU Area length %d too large, "" ""Adjusting to %d"", offset + length, finish - offset); } memset(&req, 0, sizeof(req)); req.msg.netfn = IPMI_NETFN_STORAGE; req.msg.cmd = GET_FRU_DATA; req.msg.data = msg_data; req.msg.data_len = 4; if (fru->max_read_size == 0) { uint16_t max_rs_size = ipmi_intf_get_max_response_data_size(intf) - 1; if (max_rs_size <= 1) { lprintf(LOG_ERROR, ""Maximum response size is too small to send "" ""a read request""); return -1; } if (max_rs_size - 1 > 255) { fru->max_read_size = 255; } else { fru->max_read_size = max_rs_size - 1; } if (fru->access) { fru->max_read_size &= ~1; } } do { tmp = fru->access ? off >> 1 : off; msg_data[0] = id; msg_data[1] = (uint8_t)(tmp & 0xff); msg_data[2] = (uint8_t)(tmp >> 8); tmp = finish - off; if (tmp > fru->max_read_size) msg_data[3] = (uint8_t)fru->max_read_size; else msg_data[3] = (uint8_t)tmp; rsp = intf->sendrecv(intf, &req); if (!rsp) { lprintf(LOG_NOTICE, ""FRU Read failed""); break; } if (rsp->ccode) { if (fru_cc_rq2big(rsp->ccode) && fru->max_read_size > FRU_BLOCK_SZ) { if (fru->max_read_size > FRU_AREA_MAXIMUM_BLOCK_SZ) { fru->max_read_size -= FRU_BLOCK_SZ; } else { fru->max_read_size--; } lprintf(LOG_INFO, ""Retrying FRU read with request size %d"", fru->max_read_size); continue; } lprintf(LOG_NOTICE, ""FRU Read failed: %s"", val2str(rsp->ccode, completion_code_vals)); break; } tmp = fru->access ? rsp->data[0] << 1 : rsp->data[0]; memcpy(frubuf, rsp->data + 1, tmp); off += tmp; frubuf += tmp; if (tmp == 0 && off < finish) { return 0; } } while (off < finish); if (off < finish) { return -1; } return 0; }"
"void proto_register_ber(void) { static hf_register_info hf[] = { { &hf_ber_id_class, { ""Class"", ""ber.id.class"", FT_UINT8, BASE_DEC, VALS(ber_class_codes), 0xc0, ""Class of BER TLV Identifier"", HFILL }}, { &hf_ber_bitstring_padding, { ""Padding"", ""ber.bitstring.padding"", FT_UINT8, BASE_DEC, NULL, 0x0, ""Number of unused bits in the last octet of the bitstring"", HFILL }}, { &hf_ber_bitstring_empty, { ""Empty"", ""ber.bitstring.empty"", FT_UINT8, BASE_DEC, NULL, 0x0, ""This is an empty bitstring"", HFILL }}, { &hf_ber_id_pc, { ""P/C"", ""ber.id.pc"", FT_BOOLEAN, 8, TFS(&ber_pc_codes), 0x20, ""Primitive or Constructed BER encoding"", HFILL }}, { &hf_ber_id_uni_tag, { ""Tag"", ""ber.id.uni_tag"", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &ber_uni_tag_codes_ext, 0x1f, ""Universal tag type"", HFILL }}, { &hf_ber_id_uni_tag_ext, { ""Tag"", ""ber.id.uni_tag"", FT_UINT32, BASE_DEC, NULL, 0, ""Universal tag type"", HFILL }}, { &hf_ber_id_tag, { ""Tag"", ""ber.id.tag"", FT_UINT8, BASE_DEC, NULL, 0x1f, ""Tag value for non-Universal classes"", HFILL }}, { &hf_ber_id_tag_ext, { ""Tag"", ""ber.id.tag"", FT_UINT32, BASE_DEC, NULL, 0, ""Tag value for non-Universal classes"", HFILL }}, { &hf_ber_length, { ""Length"", ""ber.length"", FT_UINT32, BASE_DEC, NULL, 0, ""Length of contents"", HFILL }}, { &hf_ber_unknown_OCTETSTRING, { ""OCTETSTRING"", ""ber.unknown.OCTETSTRING"", FT_BYTES, BASE_NONE, NULL, 0, ""This is an unknown OCTETSTRING"", HFILL }}, { &hf_ber_unknown_BER_OCTETSTRING, { ""OCTETSTRING [BER encoded]"", ""ber.unknown.OCTETSTRING"", FT_NONE, BASE_NONE, NULL, 0, ""This is an BER encoded OCTETSTRING"", HFILL }}, { &hf_ber_unknown_BER_primitive, { ""Primitive [BER encoded]"", ""ber.unknown.primitive"", FT_NONE, BASE_NONE, NULL, 0, ""This is a BER encoded Primitive"", HFILL }}, { &hf_ber_unknown_OID, { ""OID"", ""ber.unknown.OID"", FT_OID, BASE_NONE, NULL, 0, ""This is an unknown Object Identifier"", HFILL }}, { &hf_ber_unknown_relative_OID, { ""OID"", ""ber.unknown.relative_OID"", FT_REL_OID, BASE_NONE, NULL, 0, ""This is an unknown relative Object Identifier"", HFILL }}, { &hf_ber_unknown_GraphicString, { ""GRAPHICSTRING"", ""ber.unknown.GRAPHICSTRING"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown GRAPHICSTRING"", HFILL }}, { &hf_ber_unknown_NumericString, { ""NumericString"", ""ber.unknown.NumericString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown NumericString"", HFILL }}, { &hf_ber_unknown_PrintableString, { ""PrintableString"", ""ber.unknown.PrintableString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown PrintableString"", HFILL }}, { &hf_ber_unknown_TeletexString, { ""TeletexString"", ""ber.unknown.TeletexString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown TeletexString"", HFILL }}, { &hf_ber_unknown_VisibleString, { ""VisibleString"", ""ber.unknown.VisibleString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown VisibleString"", HFILL }}, { &hf_ber_unknown_GeneralString, { ""GeneralString"", ""ber.unknown.GeneralString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown GeneralString"", HFILL }}, { &hf_ber_unknown_UniversalString, { ""UniversalString"", ""ber.unknown.UniversalString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown UniversalString"", HFILL }}, { &hf_ber_unknown_BMPString, { ""BMPString"", ""ber.unknown.BMPString"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown BMPString"", HFILL }}, { &hf_ber_unknown_IA5String, { ""IA5String"", ""ber.unknown.IA5String"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown IA5String"", HFILL }}, { &hf_ber_unknown_UTCTime, { ""UTCTime"", ""ber.unknown.UTCTime"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown UTCTime"", HFILL }}, { &hf_ber_unknown_UTF8String, { ""UTF8String"", ""ber.unknown.UTF8String"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown UTF8String"", HFILL }}, { &hf_ber_unknown_GeneralizedTime, { ""GeneralizedTime"", ""ber.unknown.GeneralizedTime"", FT_STRING, BASE_NONE, NULL, 0, ""This is an unknown GeneralizedTime"", HFILL }}, { &hf_ber_unknown_INTEGER, { ""INTEGER"", ""ber.unknown.INTEGER"", FT_INT64, BASE_DEC, NULL, 0, ""This is an unknown INTEGER"", HFILL }}, { &hf_ber_unknown_REAL, { ""REAL"", ""ber.unknown.REAL"", FT_DOUBLE, BASE_NONE, NULL, 0, ""This is an unknown REAL"", HFILL }}, { &hf_ber_unknown_BITSTRING, { ""BITSTRING"", ""ber.unknown.BITSTRING"", FT_BYTES, BASE_NONE, NULL, 0, ""This is an unknown BITSTRING"", HFILL }}, { &hf_ber_unknown_BOOLEAN, { ""BOOLEAN"", ""ber.unknown.BOOLEAN"", FT_UINT8, BASE_HEX, NULL, 0, ""This is an unknown BOOLEAN"", HFILL }}, { &hf_ber_unknown_ENUMERATED, { ""ENUMERATED"", ""ber.unknown.ENUMERATED"", FT_UINT32, BASE_DEC, NULL, 0, ""This is an unknown ENUMERATED"", HFILL }}, { &hf_ber_error, { ""BER Error"", ""ber.error"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL }}, { &hf_ber_direct_reference, { ""direct-reference"", ""ber.direct_reference"", FT_OID, BASE_NONE, NULL, 0, ""ber.OBJECT_IDENTIFIER"", HFILL }}, { &hf_ber_indirect_reference, { ""indirect-reference"", ""ber.indirect_reference"", FT_INT32, BASE_DEC, NULL, 0, ""ber.INTEGER"", HFILL }}, { &hf_ber_data_value_descriptor, { ""data-value-descriptor"", ""ber.data_value_descriptor"", FT_STRING, BASE_NONE, NULL, 0, ""ber.ObjectDescriptor"", HFILL }}, { &hf_ber_encoding, { ""encoding"", ""ber.encoding"", FT_UINT32, BASE_DEC, VALS(ber_T_encoding_vals), 0, ""ber.T_encoding"", HFILL }}, { &hf_ber_octet_aligned, { ""octet-aligned"", ""ber.octet_aligned"", FT_BYTES, BASE_NONE, NULL, 0, ""ber.T_octet_aligned"", HFILL }}, { &hf_ber_arbitrary, { ""arbitrary"", ""ber.arbitrary"", FT_BYTES, BASE_NONE, NULL, 0, ""ber.T_arbitrary"", HFILL }}, { &hf_ber_single_ASN1_type, { ""single-ASN1-type"", ""ber.single_ASN1_type"", FT_NONE, BASE_NONE, NULL, 0, ""ber.T_single_ASN1_type"", HFILL }}, { &hf_ber_fragments, { ""OCTET STRING fragments"", ""ber.octet_string.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_ber_fragment, { ""OCTET STRING fragment"", ""ber.octet_string.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_ber_fragment_overlap, { ""OCTET STRING fragment overlap"", ""ber.octet_string.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_ber_fragment_overlap_conflicts, { ""OCTET STRING fragment overlapping with conflicting data"", ""ber.octet_string.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_ber_fragment_multiple_tails, { ""OCTET STRING has multiple tail fragments"", ""ber.octet_string.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_ber_fragment_too_long_fragment, { ""OCTET STRING fragment too long"", ""ber.octet_string.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_ber_fragment_error, { ""OCTET STRING defragmentation error"", ""ber.octet_string.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_ber_fragment_count, { ""OCTET STRING fragment count"", ""ber.octet_string.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_ber_reassembled_in, { ""Reassembled in"", ""ber.octet_string.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_ber_reassembled_length, { ""Reassembled OCTET STRING length"", ""ber.octet_string.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_ber_null_tag, { ""NULL tag"", ""ber.null_tag"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_unknown_data, { ""Unknown Data"", ""ber.unknown_data"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_unknown_octetstring, { ""Unknown OctetString"", ""ber.unknown_octetstring"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_seq_field_eoc, { ""SEQ FIELD EOC"", ""ber.seq_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_seq_eoc, { ""SEQ EOC"", ""ber.seq_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_set_field_eoc, { ""SET FIELD EOC"", ""ber.set_field_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_set_eoc, { ""SET EOC"", ""ber.set_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_choice_eoc, { ""CHOICE EOC"", ""ber.choice_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_seq_of_eoc, { ""SEQ OF EOC"", ""ber.seq_of_eoc"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, { &hf_ber_64bit_uint_as_bytes, { ""64bits unsigned integer"", ""ber.64bit_uint_as_bytes"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, }; static gint *ett[] = { &ett_ber_octet_string, &ett_ber_reassembled_octet_string, &ett_ber_primitive, &ett_ber_unknown, &ett_ber_SEQUENCE, &ett_ber_EXTERNAL, &ett_ber_T_encoding, &ett_ber_fragment, &ett_ber_fragments }; static ei_register_info ei[] = { { &ei_ber_size_constraint_string, { ""ber.size_constraint.string"", PI_PROTOCOL, PI_WARN, ""Size constraint: string"", EXPFILL }}, { &ei_ber_size_constraint_value, { ""ber.size_constraint.value"", PI_PROTOCOL, PI_WARN, ""Size constraint: values"", EXPFILL }}, { &ei_ber_size_constraint_items, { ""ber.size_constraint.items"", PI_PROTOCOL, PI_WARN, ""Size constraint: items"", EXPFILL }}, { &ei_ber_sequence_field_wrong, { ""ber.error.sequence.field_wrong"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong field in SEQUENCE"", EXPFILL }}, { &ei_ber_expected_octet_string, { ""ber.error.expected.octet_string"", PI_MALFORMED, PI_WARN, ""BER Error: OctetString expected"", EXPFILL }}, { &ei_ber_expected_null, { ""ber.error.expected.null"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expected"", EXPFILL }}, { &ei_ber_expected_null_zero_length, { ""ber.error.expected.null_zero_length"", PI_MALFORMED, PI_WARN, ""BER Error: NULL expect zero length"", EXPFILL }}, { &ei_ber_expected_sequence, { ""ber.error.expected.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Sequence expected"", EXPFILL }}, { &ei_ber_expected_set, { ""ber.error.expected.set"", PI_MALFORMED, PI_WARN, ""BER Error: SET expected"", EXPFILL }}, { &ei_ber_expected_string, { ""ber.error.expected.string"", PI_MALFORMED, PI_WARN, ""BER Error: String expected"", EXPFILL }}, { &ei_ber_expected_object_identifier, { ""ber.error.expected.object_identifier"", PI_MALFORMED, PI_WARN, ""BER Error: Object Identifier expected"", EXPFILL }}, { &ei_ber_expected_generalized_time, { ""ber.error.expected.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime expected"", EXPFILL }}, { &ei_ber_expected_utc_time, { ""ber.error.expected.utc_time"", PI_MALFORMED, PI_WARN, ""BER Error: UTCTime expected"", EXPFILL }}, { &ei_ber_expected_bitstring, { ""ber.error.expected.bitstring"", PI_MALFORMED, PI_WARN, ""BER Error: BitString expected"", EXPFILL }}, { &ei_ber_error_length, { ""ber.error.length"", PI_MALFORMED, PI_WARN, ""BER Error length"", EXPFILL }}, { &ei_ber_wrong_tag_in_tagged_type, { ""ber.error.wrong_tag_in_tagged_type"", PI_MALFORMED, PI_WARN, ""BER Error: Wrong tag in tagged type"", EXPFILL }}, { &ei_ber_universal_tag_unknown, { ""ber.error.universal_tag_unknown"", PI_MALFORMED, PI_WARN, ""BER Error: can not handle universal"", EXPFILL }}, { &ei_ber_no_oid, { ""ber.error.no_oid"", PI_MALFORMED, PI_WARN, ""BER Error: No OID supplied to call_ber_oid_callback"", EXPFILL }}, { &ei_ber_oid_not_implemented, { ""ber.error.oid_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Dissector for OID not implemented. Contact Wireshark developers if you want this supported"", EXPFILL }}, { &ei_ber_syntax_not_implemented, { ""ber.error.syntax_not_implemented"", PI_UNDECODED, PI_WARN, ""BER: Syntax not implemented"", EXPFILL }}, { &ei_ber_value_too_many_bytes, { ""ber.error.value_too_many_bytes"", PI_MALFORMED, PI_WARN, ""Value is encoded with too many bytes"", EXPFILL }}, { &ei_ber_unknown_field_sequence, { ""ber.error.unknown_field.sequence"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in Sequence"", EXPFILL }}, { &ei_ber_unknown_field_set, { ""ber.error.unknown_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Unknown field in SET"", EXPFILL }}, { &ei_ber_missing_field_set, { ""ber.error.missing_field.set"", PI_MALFORMED, PI_WARN, ""BER Error: Missing field in SET"", EXPFILL }}, { &ei_ber_empty_choice, { ""ber.error.empty_choice"", PI_MALFORMED, PI_WARN, ""BER Error: Empty choice was found"", EXPFILL }}, { &ei_ber_choice_not_found, { ""ber.error.choice_not_found"", PI_MALFORMED, PI_WARN, ""BER Error: This choice field was not found"", EXPFILL }}, { &ei_ber_bits_unknown, { ""ber.error.bits_unknown"", PI_UNDECODED, PI_WARN, ""BER Error: Bits unknown"", EXPFILL }}, { &ei_ber_bits_set_padded, { ""ber.error.bits_set_padded"", PI_UNDECODED, PI_WARN, ""BER Error: Bits set in padded area"", EXPFILL }}, { &ei_ber_illegal_padding, { ""ber.error.illegal_padding"", PI_UNDECODED, PI_WARN, ""Illegal padding"", EXPFILL }}, { &ei_ber_invalid_format_generalized_time, { ""ber.error.invalid_format.generalized_time"", PI_MALFORMED, PI_WARN, ""BER Error: GeneralizedTime invalid format"", EXPFILL }}, { &ei_ber_invalid_format_utctime, { ""ber.error.invalid_format.utctime"", PI_MALFORMED, PI_WARN, ""BER Error: malformed UTCTime encoding"", EXPFILL }}, { &ei_hf_field_not_integer_type, { ""ber.error.hf_field_not_integer_type"", PI_PROTOCOL, PI_ERROR, ""Was passed a HF field that was not integer type"", EXPFILL }}, }; static build_valid_func ber_da_build_value[1] = {ber_value}; static decode_as_value_t ber_da_values = {ber_prompt, 1, ber_da_build_value}; static decode_as_t ber_da = {""ber"", ""ASN.1"", ""ber.syntax"", 1, 0, &ber_da_values, NULL, NULL, ber_populate_list, ber_decode_as_reset, ber_decode_as_change, NULL}; module_t *ber_module; expert_module_t* expert_ber; uat_t* users_uat = uat_new(""OID Tables"", sizeof(oid_user_t), ""oid"", FALSE, &oid_users, &num_oid_users, UAT_AFFECTS_DISSECTION,  ""ChObjectIdentifiers"", oid_copy_cb, NULL, oid_free_cb, ber_update_oids, users_flds); proto_ber = proto_register_protocol(""Basic Encoding Rules (ASN.1 X.690)"", ""BER"", ""ber""); ber_handle = register_dissector(""ber"", dissect_ber, proto_ber); proto_register_field_array(proto_ber, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_ber = expert_register_protocol(proto_ber); expert_register_field_array(expert_ber, ei, array_length(ei)); proto_set_cant_toggle(proto_ber); ber_module = prefs_register_protocol(proto_ber, NULL); prefs_register_bool_preference(ber_module, ""show_internals"", ""Show internal BER encapsulation tokens"", ""Whether the dissector should also display internal"" "" ASN.1 BER details such as Identifier and Length fields"", &show_internal_ber_fields); prefs_register_bool_preference(ber_module, ""decode_unexpected"", ""Decode unexpected tags as BER encoded data"", ""Whether the dissector should decode unexpected tags as"" "" ASN.1 BER encoded data"", &decode_unexpected); prefs_register_bool_preference(ber_module, ""decode_octetstring"", ""Decode OCTET STRING as BER encoded data"", ""Whether the dissector should try decoding OCTET STRINGs as"" "" constructed ASN.1 BER encoded data"", &decode_octetstring_as_ber); prefs_register_bool_preference(ber_module, ""decode_primitive"", ""Decode Primitive as BER encoded data"", ""Whether the dissector should try decoding unknown primitive as"" "" constructed ASN.1 BER encoded data"", &decode_primitive_as_ber); prefs_register_bool_preference(ber_module, ""warn_too_many_bytes"", ""Warn if too many leading zero bits in encoded data"", ""Whether the dissector should warn if excessive leading zero (0) bits"", &decode_warning_leading_zero_bits); prefs_register_uat_preference(ber_module, ""oid_table"", ""Object Identifiers"", ""A table that provides names for object identifiers"" "" and the syntax of any associated values"", users_uat); ber_oid_dissector_table = register_dissector_table(""ber.oid"", ""BER OID Dissectors"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE); ber_syntax_dissector_table = register_dissector_table(""ber.syntax"", ""BER syntax"", FT_STRING, BASE_NONE, DISSECTOR_TABLE_ALLOW_DUPLICATE); syntax_table = g_hash_table_new(g_str_hash, g_str_equal);  register_ber_syntax_dissector(""ASN.1"", proto_ber, dissect_ber_syntax); register_init_routine(ber_defragment_init); register_cleanup_routine(ber_defragment_cleanup); register_decode_as(&ber_da); }"
"static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { int istart = 0, n, i = 0, dir=1, idx=-1; Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1); Jsi_Obj *obj = _this->d.obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); if (!seq) { goto bail; } n = jsi_SizeOfArray(interp, obj);     if (n == 0) { goto bail; } Jsi_Number nstart; if (op == 2) { istart = n-1; } if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (op == 2) { istart = n-1; dir = -1; } Jsi_ObjListifyArray(interp, obj); for (i = istart; ; i+=dir) { if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt) break; if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) { idx = i; break; } } bail: if (op == 3) Jsi_ValueMakeBool(interp, ret, (idx!=-1)); else Jsi_ValueMakeNumber(interp, ret, idx); return JSI_OK; }"
"void rdp_read_flow_control_pdu(wStream* s, UINT16* type) { UINT8 pduType; Stream_Read_UINT8(s, pduType);  *type = pduType; Stream_Seek_UINT8(s);   Stream_Seek_UINT8(s);   Stream_Seek_UINT8(s);   Stream_Seek_UINT16(s);  }"
"int get_lisp_indent(void) { pos_T*pos, realpos, paren; intamount; char_u*that; colnr_Tcol; colnr_Tfirsttry; intparencount, quotecount; intvi_lisp; vi_lisp = (vim_strchr(p_cpo, CPO_LISP) != NULL); realpos = curwin->w_cursor; curwin->w_cursor.col = 0; if ((pos = findmatch(NULL, '(')) == NULL) pos = findmatch(NULL, '['); else { paren = *pos; pos = findmatch(NULL, '['); if (pos == NULL || LT_POSP(pos, &paren)) pos = &paren; } if (pos != NULL) { amount = -1; parencount = 0; while (--curwin->w_cursor.lnum >= pos->lnum) { if (linewhite(curwin->w_cursor.lnum)) continue; for (that = ml_get_curline(); *that != NUL; ++that) { if (*that == ';') { while (*(that + 1) != NUL) ++that; continue; } if (*that == '\\') { if (*(that + 1) != NUL) ++that; continue; } if (*that == '""' && *(that + 1) != NUL) { while (*++that && *that != '""') { if (*that == '\\') { if (*++that == NUL) break; if (that[1] == NUL) { ++that; break; } } } } if (*that == '(' || *that == '[') ++parencount; else if (*that == ')' || *that == ']') --parencount; } if (parencount == 0) { amount = get_indent(); break; } } if (amount == -1) { curwin->w_cursor.lnum = pos->lnum; curwin->w_cursor.col = pos->col; col = pos->col; that = ml_get_curline(); if (vi_lisp && get_indent() == 0) amount = 2; else { char_u *line = that; amount = 0; while (*that && col) { amount += lbr_chartabsize_adv(line, &that, (colnr_T)amount); col--; } if (!vi_lisp && (*that == '(' || *that == '[') && lisp_match(that + 1)) amount += 2; else { that++; amount++; firsttry = amount; while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize(line, that, (colnr_T)amount); ++that; } if (*that && *that != ';')     { if (!vi_lisp && *that != '(' && *that != '[') firsttry++; parencount = 0; quotecount = 0; if (vi_lisp || (*that != '""' && *that != '\'' && *that != '#' && (*that < '0' || *that > '9'))) { while (*that && (!VIM_ISWHITE(*that) || quotecount || parencount) && (!((*that == '(' || *that == '[') && !quotecount && !parencount && vi_lisp))) { if (*that == '""') quotecount = !quotecount; if ((*that == '(' || *that == '[') && !quotecount) ++parencount; if ((*that == ')' || *that == ']') && !quotecount) --parencount; if (*that == '\\' && *(that+1) != NUL) amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); amount += lbr_chartabsize_adv( line, &that, (colnr_T)amount); } } while (VIM_ISWHITE(*that)) { amount += lbr_chartabsize( line, that, (colnr_T)amount); that++; } if (!*that || *that == ';') amount = firsttry; } } } } } else amount = 0; curwin->w_cursor = realpos; return amount; }"
"void ImageWriteJPEG( Image const& image, String const& filename, dip::uint jpegLevel ) { DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED ); DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED ); jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 ); JpegOutput jpeg( filename ); int nchan = static_cast< int >( image.TensorElements() ); jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 )); jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 )); jpeg.cinfo().input_components = nchan; jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE; jpeg_set_defaults( jpeg.cinfoptr() ); jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE ); jpeg.cinfo().density_unit = 2;    jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude );    jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude ); Image image_u8 = image.QuickCopy(); image_u8.Convert( DT_UINT8 ); jpeg_start_compress( jpeg.cinfoptr(), TRUE ); std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan )); dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() ); auto stride = image_u8.Strides(); auto tStride = image_u8.TensorStride(); for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) { JSAMPLE* outdata = buffer.data(); dip::uint8* indata = imagedata; for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) { for( int kk = 0; kk < nchan; ++kk ) { *outdata = *( indata + kk * tStride ); ++outdata; } indata += stride[ 0 ]; } outdata = buffer.data(); jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 ); imagedata += stride[ 1 ]; } jpeg_finish_compress( jpeg.cinfoptr()); }"
"char* parse_content_length( char* buffer, char* end, int* length) { int number; char *p; int  size; p = buffer; while ( p<end && (*p==' ' || *p=='\t' || (*p=='\r' && *(p+1)=='\n') || (*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) )) p++; if (p==end) goto error; size = 0; number = 0; while (p<end && *p>='0' && *p<='9') { number = number*10 + (*p)-'0'; if (number<0) { LM_ERR(""number overflow at pos %d in len number [%.*s]\n"", (int)(p-buffer),(int)(end-buffer), buffer); return 0; } size ++; p++; } if (p==end || size==0) goto error; while ( p<end && (*p==' ' || *p=='\t' || (*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) )) p++; if (p==end) goto error; if ( (*(p++)!='\n') && (*(p-1)!='\r' || *(p++)!='\n' ) ) goto error; *length = number; return p; error: LM_ERR(""parse error near char [%d][%c]\n"",*p,*p); return 0; }"
ompl::geometric::LazyPRM::~LazyPRM() = default;
"static int print_bacp_config_options(netdissect_options *ndo, const u_char *p, int length) { int len, opt; if (length < 2) return 0; ND_TCHECK2(*p, 2); len = p[1]; opt = p[0]; if (length < len) return 0; if (len < 2) { ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)"", tok2str(bacconfopts_values, ""Unknown"", opt), opt, len)); return 0; } ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"", tok2str(bacconfopts_values, ""Unknown"", opt), opt, len)); switch (opt) { case BACPOPT_FPEER: if (len != 6) { ND_PRINT((ndo, "" (length bogus, should be = 6)"")); return len; } ND_TCHECK2(*(p + 2), 4); ND_PRINT((ndo, "": Magic-Num 0x%08x"", EXTRACT_32BITS(p + 2))); break; default: if (ndo->ndo_vflag < 2) print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2); break; } if (ndo->ndo_vflag > 1) print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);  return len; trunc: ND_PRINT((ndo, ""[|bacp]"")); return 0; }"
"void jslGetTokenString(char *str, size_t len) { if (lex->tk == LEX_ID) { strncpy(str, ""ID:"", len); strncat(str, jslGetTokenValueAsString(), len); } else if (lex->tk == LEX_STR) { strncpy(str, ""String:'"", len); strncat(str, jslGetTokenValueAsString(), len); strncat(str, ""'"", len); } else jslTokenAsString(lex->tk, str, len); }"
"static int eval_lambda( char_u**arg, typval_T*rettv, evalarg_T*evalarg, intverbose){ intevaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); typval_Tbase = *rettv; intret; rettv->v_type = VAR_UNKNOWN; if (**arg == '{') { ret = get_lambda_tv(arg, rettv, FALSE, evalarg); } else { ++*arg; ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); if (**arg != ')') { emsg(_(e_missing_closing_paren)); ret = FAIL; } ++*arg; } if (ret != OK) return FAIL; else if (**arg != '(') { if (verbose) { if (*skipwhite(*arg) == '(') emsg(_(e_nowhitespace)); else semsg(_(e_missing_parenthesis_str), ""lambda""); } clear_tv(rettv); ret = FAIL; } else ret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base); if (evaluate) clear_tv(&base); return ret; }"
PDFObject::~PDFObject(void) { StringToVoidP::iterator it = mMetadata.begin(); for (; it != mMetadata.end(); ++it) { delete it->second; } mMetadata.clear(); }
"TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input, int axis, TfLiteTensor* output) { const TfLiteIntArray& input_dims = *input.dims; if (axis < 0) { axis = input_dims.size + 1 + axis; } TF_LITE_ENSURE(context, axis <= input_dims.size); TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1); for (int i = 0; i < output_dims->size; ++i) { if (i < axis) { output_dims->data[i] = input_dims.data[i]; } else if (i == axis) { output_dims->data[i] = 1; } else { output_dims->data[i] = input_dims.data[i - 1]; } } return context->ResizeTensor(context, output, output_dims); }"
"void PDFDoc::markPageObjects(Dict *pageDict, XRef *xRef, XRef *countRef, unsigned int numOffset, int oldRefNum, int newRefNum, std::set<Dict *> *alreadyMarkedDicts) { pageDict->remove(""OpenAction""); pageDict->remove(""Outlines""); pageDict->remove(""StructTreeRoot""); for (int n = 0; n < pageDict->getLength(); n++) { const char *key = pageDict->getKey(n); Object value = pageDict->getValNF(n).copy(); if (strcmp(key, ""Parent"") != 0 && strcmp(key, ""Pages"") != 0 && strcmp(key, ""AcroForm"") != 0 && strcmp(key, ""Annots"") != 0 && strcmp(key, ""P"") != 0 && strcmp(key, ""Root"") != 0) { markObject(&value, xRef, countRef, numOffset, oldRefNum, newRefNum, alreadyMarkedDicts); } } }"
"struct key *request_key_and_link(struct key_type *type, const char *description, const void *callout_info, size_t callout_len, void *aux, struct key *dest_keyring, unsigned long flags) { struct keyring_search_context ctx = { .index_key.type= type, .index_key.description= description, .cred= current_cred(), .match_data.cmp= type->match, .match_data.raw_data= description, .match_data.lookup_type= KEYRING_SEARCH_LOOKUP_DIRECT, }; struct key *key; key_ref_t key_ref; int ret; kenter(""%s,%s,%p,%zu,%p,%p,%lx"", ctx.index_key.type->name, ctx.index_key.description, callout_info, callout_len, aux, dest_keyring, flags); if (type->match_preparse) { ret = type->match_preparse(&ctx.match_data); if (ret < 0) { key = ERR_PTR(ret); goto error; } } key_ref = search_process_keyrings(&ctx); if (!IS_ERR(key_ref)) { key = key_ref_to_ptr(key_ref); if (dest_keyring) { construct_get_dest_keyring(&dest_keyring); ret = key_link(dest_keyring, key); key_put(dest_keyring); if (ret < 0) { key_put(key); key = ERR_PTR(ret); goto error_free; } } } else if (PTR_ERR(key_ref) != -EAGAIN) { key = ERR_CAST(key_ref); } else  { key = ERR_PTR(-ENOKEY); if (!callout_info) goto error_free; key = construct_key_and_link(&ctx, callout_info, callout_len, aux, dest_keyring, flags); } error_free: if (type->match_free) type->match_free(&ctx.match_data); error: kleave("" = %p"", key); return key; }"
"flb_sds_t flb_msgpack_to_gelf(flb_sds_t *s, msgpack_object *o, struct flb_time *tm, struct flb_gelf_fields *fields) { int i; int loop; flb_sds_t tmp; int host_key_found = FLB_FALSE; int timestamp_key_found = FLB_FALSE; int level_key_found = FLB_FALSE; int short_message_key_found = FLB_FALSE; int full_message_key_found = FLB_FALSE; char *host_key = NULL; char *timestamp_key = NULL; char *level_key = NULL; char *short_message_key = NULL; char *full_message_key = NULL; int host_key_len = 0; int timestamp_key_len = false; int level_key_len = 0; int short_message_key_len = 0; int full_message_key_len = 0; if (s == NULL || o == NULL) { return NULL; } if (o->type != MSGPACK_OBJECT_MAP) { return NULL; } if (fields != NULL && fields->host_key != NULL) { host_key = fields->host_key; host_key_len = flb_sds_len(fields->host_key); } else { host_key = ""host""; host_key_len = 4; } if (fields != NULL && fields->timestamp_key != NULL) { timestamp_key = fields->timestamp_key; timestamp_key_len = flb_sds_len(fields->timestamp_key); } else { timestamp_key = ""timestamp""; timestamp_key_len = 9; } if (fields != NULL && fields->level_key != NULL) { level_key = fields->level_key; level_key_len = flb_sds_len(fields->level_key); } else { level_key = ""level""; level_key_len = 5; } if (fields != NULL && fields->short_message_key != NULL) { short_message_key = fields->short_message_key; short_message_key_len = flb_sds_len(fields->short_message_key); } else { short_message_key = ""short_message""; short_message_key_len = 13; } if (fields != NULL && fields->full_message_key != NULL) { full_message_key = fields->full_message_key; full_message_key_len = flb_sds_len(fields->full_message_key); } else { full_message_key = ""full_message""; full_message_key_len = 12; } tmp = flb_sds_cat(*s, ""{\""version\"":\""1.1\"""", 16); if (tmp == NULL) { return NULL; } *s = tmp; loop = o->via.map.size; if (loop != 0) { msgpack_object_kv *p = o->via.map.ptr; for (i = 0; i < loop; i++) { const char *key = NULL; int key_len; const char *val = NULL; int val_len = 0; int quote = FLB_FALSE; int custom_key = FLB_FALSE; msgpack_object *k = &p[i].key; msgpack_object *v = &p[i].val; msgpack_object vtmp;  if (k->type != MSGPACK_OBJECT_BIN && k->type != MSGPACK_OBJECT_STR) { continue; } if (k->type == MSGPACK_OBJECT_STR) { key = k->via.str.ptr; key_len = k->via.str.size; } else { key = k->via.bin.ptr; key_len = k->via.bin.size; } if ((key_len == host_key_len) && !strncmp(key, host_key, host_key_len)) { if (host_key_found == FLB_TRUE) { continue; } host_key_found = FLB_TRUE; key = ""host""; key_len = 4; } else if ((key_len == short_message_key_len) && !strncmp(key, short_message_key, short_message_key_len)) { if (short_message_key_found == FLB_TRUE) { continue; } short_message_key_found = FLB_TRUE; key = ""short_message""; key_len = 13; } else if ((key_len == timestamp_key_len) && !strncmp(key, timestamp_key, timestamp_key_len)) { if (timestamp_key_found == FLB_TRUE) { continue; } timestamp_key_found = FLB_TRUE; key = ""timestamp""; key_len = 9; } else if ((key_len == level_key_len) && !strncmp(key, level_key, level_key_len )) { if (level_key_found == FLB_TRUE) { continue; } level_key_found = FLB_TRUE; key = ""level""; key_len = 5; if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) { if ( v->via.u64 > 7 ) { flb_warn(""[flb_msgpack_to_gelf] level is %"" PRIu64 "", "" ""but should be in 0..7 or a syslog keyword"", v->via.u64); } } else if (v->type == MSGPACK_OBJECT_STR) { val     = v->via.str.ptr; val_len = v->via.str.size; if (val_len == 1 && val[0] >= '0' && val[0] <= '7') { v = &vtmp; v->type = MSGPACK_OBJECT_POSITIVE_INTEGER; v->via.u64 = (uint64_t)(val[0] - '0'); } else { int n; char* allowed_levels[] = { ""emerg"", ""alert"", ""crit"", ""err"", ""warning"", ""notice"", ""info"", ""debug"", NULL }; for (n = 0; allowed_levels[n] != NULL; ++n) { if (val_len == strlen(allowed_levels[n]) && !strncasecmp(val, allowed_levels[n], val_len)) { v = &vtmp; v->type = MSGPACK_OBJECT_POSITIVE_INTEGER; v->via.u64 = (uint64_t)n; break; } } if (allowed_levels[n] == NULL) { flb_warn(""[flb_msgpack_to_gelf] level is '%.*s', "" ""but should be in 0..7 or a syslog keyword"", val_len, val); } } } else { flb_error(""[flb_msgpack_to_gelf] level must be a non-negative integer or a string""); return NULL; } } else if ((key_len == full_message_key_len) && !strncmp(key, full_message_key, full_message_key_len)) { if (full_message_key_found == FLB_TRUE) { continue; } full_message_key_found = FLB_TRUE; key = ""full_message""; key_len = 12; } else if ((key_len == 2)  && !strncmp(key, ""id"", 2)) { continue; } else { custom_key = FLB_TRUE; } if (v->type == MSGPACK_OBJECT_MAP) { char *prefix = NULL; int prefix_len = 0; prefix_len = key_len + 1; prefix = flb_calloc(1, prefix_len + 1); if (prefix == NULL) { return NULL; } prefix[0] = '_'; strncpy(prefix + 1, key, key_len); prefix[prefix_len] = '\0'; tmp = flb_msgpack_gelf_flatten(s, v, prefix, prefix_len, FLB_FALSE); if (tmp == NULL) { flb_free(prefix); return NULL; } *s = tmp; flb_free(prefix); } else if (v->type == MSGPACK_OBJECT_ARRAY) { if (custom_key == FLB_TRUE) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE, key, key_len); } else { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, key, key_len); } if (tmp == NULL) { return NULL; } *s = tmp; tmp = flb_msgpack_gelf_flatten(s, v, NULL, 0, FLB_FALSE); if (tmp == NULL) { return NULL; } *s = tmp; } else { char temp[48] = {0}; if (v->type == MSGPACK_OBJECT_NIL) { val = ""null""; val_len = 4; continue; } else if (v->type == MSGPACK_OBJECT_BOOLEAN) { quote   = FLB_TRUE; val = v->via.boolean ? ""true"" : ""false""; val_len = v->via.boolean ? 4 : 5; } else if (v->type == MSGPACK_OBJECT_POSITIVE_INTEGER) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%"" PRIu64, v->via.u64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_NEGATIVE_INTEGER) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%"" PRId64, v->via.i64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_FLOAT) { val = temp; val_len = snprintf(temp, sizeof(temp) - 1, ""%f"", v->via.f64); if (val_len > sizeof(temp)) { return NULL; } } else if (v->type == MSGPACK_OBJECT_STR) { quote   = FLB_TRUE; val     = v->via.str.ptr; val_len = v->via.str.size; } else if (v->type == MSGPACK_OBJECT_BIN) { quote   = FLB_TRUE; val     = v->via.bin.ptr; val_len = v->via.bin.size; } else if (v->type == MSGPACK_OBJECT_EXT) { quote   = FLB_TRUE; val     = o->via.ext.ptr; val_len = o->via.ext.size; } if (!val || !key) { continue; } if (custom_key == FLB_TRUE) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, ""_"", 1, FLB_FALSE, key, key_len); } else { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, key, key_len); } if (tmp == NULL) { return NULL; } *s = tmp; if (v->type == MSGPACK_OBJECT_EXT) { tmp = flb_msgpack_gelf_value_ext(s, quote, val, val_len); } else { tmp = flb_msgpack_gelf_value(s, quote, val, val_len); } if (tmp == NULL) { return NULL; } *s = tmp; } } } if (timestamp_key_found == FLB_FALSE && tm != NULL) { tmp = flb_msgpack_gelf_key(s, FLB_FALSE, NULL, 0, FLB_FALSE, ""timestamp"", 9); if (tmp == NULL) { return NULL; } *s = tmp; tmp = flb_sds_printf(s, ""%"" PRIu32"".%lu"", tm->tm.tv_sec, tm->tm.tv_nsec / 1000000); if (tmp == NULL) { return NULL; } *s = tmp; } if (short_message_key_found == FLB_FALSE) { flb_error(""[flb_msgpack_to_gelf] missing short_message key""); return NULL; } tmp = flb_sds_cat(*s, ""}"", 1); if (tmp == NULL) { return NULL; } *s = tmp; return *s; }"
"int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in) { char buf[2048]; unsigned short *cmd = (unsigned short *)buf; int plen; struct in_addr *addr = &s_in->sin_addr; unsigned short *pid = (unsigned short*) data; if (len == S_HELLO_LEN && memcmp(data, ""sorbo"", 5) == 0) { unsigned short *id = (unsigned short*) (data+5); int x = 2+4+2; *cmd = htons(S_CMD_INET_CHECK); memcpy(cmd+1, addr, 4); memcpy(cmd+1+2, id, 2); printf(""Inet check by %s %d\n"", inet_ntoa(*addr), ntohs(*id)); if (send(s, buf, x, 0) != x) return 1; return 0; } *cmd++ = htons(S_CMD_PACKET); *cmd++ = *pid; plen = len - 2; last_id = ntohs(*pid); if (last_id > 20000) wrap = 1; if (wrap && last_id < 100) { wrap = 0; memset(ids, 0, sizeof(ids)); } printf(""Got packet %d %d"", last_id, plen); if (is_dup(last_id)) { printf("" (DUP)\n""); return 0; } printf(""\n""); *cmd++ = htons(plen); memcpy(cmd, data+2, plen); plen += 2 + 2 + 2; assert(plen <= (int) sizeof(buf)); if (send(s, buf, plen, 0) != plen) return 1; return 0; }"
"bool  BmpDecoder::readData( Mat& img ) { uchar* data = img.ptr(); int step = (int)img.step; bool color = img.channels() > 1; uchar  gray_palette[256] = {0}; bool   result = false; int  src_pitch = ((m_width*(m_bpp != 15 ? m_bpp : 16) + 7)/8 + 3) & -4; int  nch = color ? 3 : 1; int  y, width3 = m_width*nch; if( m_offset < 0 || !m_strm.isOpened()) return false; if( m_origin == IPL_ORIGIN_BL ) { data += (m_height - 1)*step; step = -step; } AutoBuffer<uchar> _src, _bgr; _src.allocate(src_pitch + 32); if( !color ) { if( m_bpp <= 8 ) { CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp ); } _bgr.allocate(m_width*3 + 32); } uchar *src = _src, *bgr = _bgr; try { m_strm.setPos( m_offset ); switch( m_bpp ) { case 1: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); FillColorRow1( color ? data : bgr, src, m_width, m_palette ); if( !color ) icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1) ); } result = true; break; case 4: if( m_rle_code == BMP_RGB ) { for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( color ) FillColorRow4( data, src, m_width, m_palette ); else FillGrayRow4( data, src, m_width, gray_palette ); } result = true; } else if( m_rle_code == BMP_RLE4 )             { uchar* line_end = data + width3; y = 0; for(;;) { int code = m_strm.getWord(); int len = code & 255; code >>= 8; if( len != 0 )                     { PaletteEntry clr[2]; uchar gray_clr[2]; int t = 0; clr[0] = m_palette[code >> 4]; clr[1] = m_palette[code & 15]; gray_clr[0] = gray_palette[code >> 4]; gray_clr[1] = gray_palette[code & 15]; uchar* end = data + len*nch; if( end > line_end ) goto decode_rle4_bad; do { if( color ) WRITE_PIX( data, clr[t] ); else *data = gray_clr[t]; t ^= 1; } while( (data += nch) < end ); } else if( code > 2 )                     { if( data + code*nch > line_end ) goto decode_rle4_bad; int sz = (((code + 1)>>1) + 1) & (~1); CV_Assert((size_t)sz < _src.size()); m_strm.getBytes(src, sz); if( color ) data = FillColorRow4( data, src, code, m_palette ); else data = FillGrayRow4( data, src, code, gray_palette ); } else { int x_shift3 = (int)(line_end - data); int y_shift = m_height - y; if( code == 2 ) { x_shift3 = m_strm.getByte()*nch; y_shift = m_strm.getByte(); } len = x_shift3 + ((y_shift * width3) & ((code == 0) - 1)); if( color ) data = FillUniColor( data, line_end, step, width3, y, m_height, x_shift3, m_palette[0] ); else data = FillUniGray( data, line_end, step, width3, y, m_height, x_shift3, gray_palette[0] ); if( y >= m_height ) break; } } result = true; decode_rle4_bad: ; } break; case 8: if( m_rle_code == BMP_RGB ) { for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( color ) FillColorRow8( data, src, m_width, m_palette ); else FillGrayRow8( data, src, m_width, gray_palette ); } result = true; } else if( m_rle_code == BMP_RLE8 )             { uchar* line_end = data + width3; int line_end_flag = 0; y = 0; for(;;) { int code = m_strm.getWord(); int len = code & 255; code >>= 8; if( len != 0 )                     { int prev_y = y; len *= nch; if( data + len > line_end ) goto decode_rle8_bad; if( color ) data = FillUniColor( data, line_end, step, width3, y, m_height, len, m_palette[code] ); else data = FillUniGray( data, line_end, step, width3, y, m_height, len, gray_palette[code] ); line_end_flag = y - prev_y; } else if( code > 2 )                     { int prev_y = y; int code3 = code*nch; if( data + code3 > line_end ) goto decode_rle8_bad; int sz = (code + 1) & (~1); CV_Assert((size_t)sz < _src.size()); m_strm.getBytes(src, sz); if( color ) data = FillColorRow8( data, src, code, m_palette ); else data = FillGrayRow8( data, src, code, gray_palette ); line_end_flag = y - prev_y; } else { int x_shift3 = (int)(line_end - data); int y_shift = m_height - y; if( code || !line_end_flag || x_shift3 < width3 ) { if( code == 2 ) { x_shift3 = m_strm.getByte()*nch; y_shift = m_strm.getByte(); } x_shift3 += (y_shift * width3) & ((code == 0) - 1); if( y >= m_height ) break; if( color ) data = FillUniColor( data, line_end, step, width3, y, m_height, x_shift3, m_palette[0] ); else data = FillUniGray( data, line_end, step, width3, y, m_height, x_shift3, gray_palette[0] ); if( y >= m_height ) break; } line_end_flag = 0; if( y >= m_height ) break; } } result = true; decode_rle8_bad: ; } break; case 15: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( !color ) icvCvt_BGR5552Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) ); else icvCvt_BGR5552BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) ); } result = true; break; case 16: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( !color ) icvCvt_BGR5652Gray_8u_C2C1R( src, 0, data, 0, cvSize(m_width,1) ); else icvCvt_BGR5652BGR_8u_C2C3R( src, 0, data, 0, cvSize(m_width,1) ); } result = true; break; case 24: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if(!color) icvCvt_BGR2Gray_8u_C3C1R( src, 0, data, 0, cvSize(m_width,1) ); else memcpy( data, src, m_width*3 ); } result = true; break; case 32: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( !color ) icvCvt_BGRA2Gray_8u_C4C1R( src, 0, data, 0, cvSize(m_width,1) ); else icvCvt_BGRA2BGR_8u_C4C3R( src, 0, data, 0, cvSize(m_width,1) ); } result = true; break; default: assert(0); } } catch(...) { } return result; }"
"uint8_t* DTSStreamReader::findFrame(uint8_t* buff, uint8_t* end) { while (end - buff >= 16) { int64_t* ptr = (int64_t*)buff; int64_t hdrType = my_ntohll(ptr[0]); int64_t hdrSize = my_ntohll(ptr[1]) + 16; if (hdrType == AUPRINFO || hdrType == BITSHVTB || hdrType == BLACKOUT || hdrType == BRANCHPT || hdrType == BUILDVER || hdrType == CORESSMD || hdrType == EXTSS_MD || hdrType == FILEINFO || hdrType == NAVI_TBL || hdrType == TIMECODE || hdrType == DTSHDHDR) { if (buff + hdrSize > end) return 0;              buff += hdrSize; } else if (hdrType == AUPR_HDR) { if (buff + hdrSize > end) return 0;                          m_skippingSamples = (buff[35] << 8) + buff[36]; buff += hdrSize; } else if (hdrType == STRMDATA) { m_dataSegmentLen = hdrSize; buff += 16; break; } else { break;          } } if (m_firstCall) { m_firstCall = false; checkIfOnlyHDDataExists(buff, end); } if (!m_isCoreExists) { for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++) { if (p_buf[0] == 0x64 && p_buf[1] == 0x58 && p_buf[2] == 0x20 && p_buf[3] == 0x25) { return p_buf; } } return 0; } for (uint8_t* p_buf = buff; p_buf < end - 4; p_buf++) { if (p_buf < end - 6) { if (p_buf[0] == 0xff && p_buf[1] == 0x1f && p_buf[2] == 0x00 && p_buf[3] == 0xe8 && (p_buf[4] & 0xf0) == 0xf0 && p_buf[5] == 0x07) { return p_buf; } else if (p_buf[0] == 0x1f && p_buf[1] == 0xff && p_buf[2] == 0xe8 && p_buf[3] == 0x00 && p_buf[4] == 0x07 && (p_buf[5] & 0xf0) == 0xf0) { return p_buf; } } if (p_buf[0] == 0x7f && p_buf[1] == 0xfe && p_buf[2] == 0x80 && p_buf[3] == 0x01) { return p_buf; } else if (p_buf[0] == 0xfe && p_buf[1] == 0x7f && p_buf[2] == 0x01 && p_buf[3] == 0x80) { return p_buf; } } return 0; }"
"explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""display_name"", &display_name_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""num_threads"", &num_threads_)); OP_REQUIRES_OK(ctx, ctx->GetAttr(""max_intra_op_parallelism"", &max_intra_op_parallelism_)); OP_REQUIRES( ctx, num_threads_ > 0, errors::InvalidArgument(""`num_threads` must be greater than zero."")); }"
"int spider_db_mbase::exec_query( const char *query, uint length, int quick_mode ) { int error_num = 0; uint log_result_errors = spider_param_log_result_errors(); DBUG_ENTER(""spider_db_mbase::exec_query""); DBUG_PRINT(""info"",(""spider this=%p"", this)); if (spider_param_general_log()) { const char *tgt_str = conn->tgt_host; uint32 tgt_len = conn->tgt_host_length; spider_string tmp_query_str; tmp_query_str.init_calc_mem(230); if (tmp_query_str.reserve( length + conn->tgt_wrapper_length + tgt_len + (SPIDER_SQL_SPACE_LEN * 2))) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(conn->tgt_wrapper, conn->tgt_wrapper_length); tmp_query_str.q_append(SPIDER_SQL_SPACE_STR, SPIDER_SQL_SPACE_LEN); tmp_query_str.q_append(tgt_str, tgt_len); tmp_query_str.q_append(SPIDER_SQL_SPACE_STR, SPIDER_SQL_SPACE_LEN); tmp_query_str.q_append(query, length); general_log_write(current_thd, COM_QUERY, tmp_query_str.ptr(), tmp_query_str.length()); } if (!spider_param_dry_access()) { error_num = mysql_real_query(db_conn, query, length); } if ( (error_num && log_result_errors >= 1) || (log_result_errors >= 2 && db_conn->warning_count > 0) || (log_result_errors >= 4) ) { THD *thd = current_thd; uint log_result_error_with_sql = spider_param_log_result_error_with_sql(); if (log_result_error_with_sql) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); spider_string tmp_query_str; tmp_query_str.init_calc_mem(243); uint query_length = thd->query_length(); if ((log_result_error_with_sql & 2) && query_length) { Security_context *security_ctx = thd->security_ctx; tmp_query_str.length(0); if (tmp_query_str.reserve(query_length + 1)) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(thd->query(), query_length); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [RECV SPIDER SQL] "" ""from [%s][%s] to %ld:  "" ""sql: %s\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, security_ctx->user ? security_ctx->user : ""system user"", security_ctx->host_or_ip, (ulong) thd->thread_id, tmp_query_str.c_ptr_safe()); } if (log_result_error_with_sql & 1) { tmp_query_str.length(0); if (tmp_query_str.reserve(length + 1)) DBUG_RETURN(HA_ERR_OUT_OF_MEM); tmp_query_str.q_append(query, length); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [SEND SPIDER SQL] "" ""from %ld to [%s] %ld:  "" ""sql: %s\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, (ulong) thd->thread_id, conn->tgt_host, (ulong) db_conn->thread_id, tmp_query_str.c_ptr_safe()); } } if (log_result_errors >= 2 && db_conn->warning_count > 0) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [WARN SPIDER RESULT] "" ""from [%s] %ld to %ld:  "" ""affected_rows: %llu  id: %llu  status: %u  warning_count: %u\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, conn->tgt_host, (ulong) db_conn->thread_id, (ulong) thd->thread_id, db_conn->affected_rows, db_conn->insert_id, db_conn->server_status, db_conn->warning_count); if (spider_param_log_result_errors() >= 3) print_warnings(l_time); } else if (log_result_errors >= 4) { time_t cur_time = (time_t) time((time_t*) 0); struct tm lt; struct tm *l_time = localtime_r(&cur_time, &lt); fprintf(stderr, ""%04d%02d%02d %02d:%02d:%02d [INFO SPIDER RESULT] "" ""from [%s] %ld to %ld:  "" ""affected_rows: %llu  id: %llu  status: %u  warning_count: %u\n"", l_time->tm_year + 1900, l_time->tm_mon + 1, l_time->tm_mday, l_time->tm_hour, l_time->tm_min, l_time->tm_sec, conn->tgt_host, (ulong) db_conn->thread_id, (ulong) thd->thread_id, db_conn->affected_rows, db_conn->insert_id, db_conn->server_status, db_conn->warning_count); } } DBUG_RETURN(error_num); }"
"TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices, const TfLiteTensor* updates, const TfLiteTensor* shape, TfLiteTensor* output) { if (IsDynamicTensor(output)) { TF_LITE_ENSURE_OK( context, CheckShapes<IndicesT>( context, GetTensorShape(indices), GetTensorShape(updates), GetTensorShape(shape), GetTensorData<IndicesT>(shape))); TF_LITE_ENSURE_OK(context, ResizeOutputTensor<IndicesT>(context, shape, output)); } switch (updates->type) { case kTfLiteFloat32: return ScatterNd<IndicesT, float>(indices, updates, output); case kTfLiteUInt8: return ScatterNd<IndicesT, uint8_t>(indices, updates, output); case kTfLiteBool: return ScatterNd<IndicesT, bool>(indices, updates, output); case kTfLiteInt8: return ScatterNd<IndicesT, int8_t>(indices, updates, output); case kTfLiteInt32: return ScatterNd<IndicesT, int32_t>(indices, updates, output); case kTfLiteInt64: return ScatterNd<IndicesT, int64_t>(indices, updates, output); default: TF_LITE_KERNEL_LOG( context, ""Updates of type '%s' are not supported by scatter_nd."", TfLiteTypeGetName(updates->type)); return kTfLiteError; } }"
"void nsexec(void) { int pipenum; jmp_buf env; int sync_child_pipe[2], sync_grandchild_pipe[2]; struct nlconfig_t config = { 0 }; setup_logpipe(); pipenum = getenv_int(""_LIBCONTAINER_INITPIPE""); if (pipenum < 0) { return; } if (ensure_cloned_binary() < 0) bail(""could not ensure we are a cloned binary""); if (write(pipenum, """", 1) != 1) bail(""could not inform the parent we are past initial setup""); write_log(DEBUG, ""=> nsexec container setup""); nl_parse(pipenum, &config); update_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len); if (config.namespaces) { write_log(DEBUG, ""set process as non-dumpable""); if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0) bail(""failed to set process as non-dumpable""); } if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0) bail(""failed to setup sync pipe between parent and child""); if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0) bail(""failed to setup sync pipe between parent and grandchild""); current_stage = setjmp(env); switch (current_stage) { case STAGE_PARENT:{ int len; pid_t stage1_pid = -1, stage2_pid = -1; bool stage1_complete, stage2_complete; prctl(PR_SET_NAME, (unsigned long)""runc:[0:PARENT]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-0""); write_log(DEBUG, ""spawn stage-1""); stage1_pid = clone_parent(&env, STAGE_CHILD); if (stage1_pid < 0) bail(""unable to spawn stage-1""); syncfd = sync_child_pipe[1]; if (close(sync_child_pipe[0]) < 0) bail(""failed to close sync_child_pipe[0] fd""); write_log(DEBUG, ""-> stage-1 synchronisation loop""); stage1_complete = false; while (!stage1_complete) { enum sync_t s; if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with stage-1: next state""); switch (s) { case SYNC_USERMAP_PLS: write_log(DEBUG, ""stage-1 requested userns mappings""); if (config.is_rootless_euid && !config.is_setgroup) update_setgroups(stage1_pid, SETGROUPS_DENY); update_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len); update_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len); s = SYNC_USERMAP_ACK; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: write(SYNC_USERMAP_ACK)""); } break; case SYNC_RECVPID_PLS: write_log(DEBUG, ""stage-1 requested pid to be forwarded""); if (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: read(stage2_pid)""); } s = SYNC_RECVPID_ACK; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with stage-1: write(SYNC_RECVPID_ACK)""); } write_log(DEBUG, ""forward stage-1 (%d) and stage-2 (%d) pids to runc"", stage1_pid, stage2_pid); len = dprintf(pipenum, ""{\""stage1_pid\"":%d,\""stage2_pid\"":%d}\n"", stage1_pid, stage2_pid); if (len < 0) { sane_kill(stage1_pid, SIGKILL); sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with runc: write(pid-JSON)""); } break; case SYNC_CHILD_FINISH: write_log(DEBUG, ""stage-1 complete""); stage1_complete = true; break; default: bail(""unexpected sync value: %u"", s); } } write_log(DEBUG, ""<- stage-1 synchronisation loop""); syncfd = sync_grandchild_pipe[1]; if (close(sync_grandchild_pipe[0]) < 0) bail(""failed to close sync_grandchild_pipe[0] fd""); write_log(DEBUG, ""-> stage-2 synchronisation loop""); stage2_complete = false; while (!stage2_complete) { enum sync_t s; write_log(DEBUG, ""signalling stage-2 to run""); s = SYNC_GRANDCHILD; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with child: write(SYNC_GRANDCHILD)""); } if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with child: next state""); switch (s) { case SYNC_CHILD_FINISH: write_log(DEBUG, ""stage-2 complete""); stage2_complete = true; break; default: bail(""unexpected sync value: %u"", s); } } write_log(DEBUG, ""<- stage-2 synchronisation loop""); write_log(DEBUG, ""<~ nsexec stage-0""); exit(0); } break; case STAGE_CHILD:{ pid_t stage2_pid = -1; enum sync_t s; syncfd = sync_child_pipe[0]; if (close(sync_child_pipe[1]) < 0) bail(""failed to close sync_child_pipe[1] fd""); prctl(PR_SET_NAME, (unsigned long)""runc:[1:CHILD]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-1""); if (config.namespaces) join_namespaces(config.namespaces); if (config.cloneflags & CLONE_NEWUSER) { write_log(DEBUG, ""unshare user namespace""); if (unshare(CLONE_NEWUSER) < 0) bail(""failed to unshare user namespace""); config.cloneflags &= ~CLONE_NEWUSER; if (config.namespaces) { write_log(DEBUG, ""temporarily set process as dumpable""); if (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0) bail(""failed to temporarily set process as dumpable""); } write_log(DEBUG, ""request stage-0 to map user namespace""); s = SYNC_USERMAP_PLS; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: write(SYNC_USERMAP_PLS)""); write_log(DEBUG, ""request stage-0 to map user namespace""); if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: read(SYNC_USERMAP_ACK)""); if (s != SYNC_USERMAP_ACK) bail(""failed to sync with parent: SYNC_USERMAP_ACK: got %u"", s); if (config.namespaces) { write_log(DEBUG, ""re-set process as non-dumpable""); if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0) bail(""failed to re-set process as non-dumpable""); } if (setresuid(0, 0, 0) < 0) bail(""failed to become root in user namespace""); } write_log(DEBUG, ""unshare remaining namespace (except cgroupns)""); if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0) bail(""failed to unshare remaining namespaces (except cgroupns)""); write_log(DEBUG, ""spawn stage-2""); stage2_pid = clone_parent(&env, STAGE_INIT); if (stage2_pid < 0) bail(""unable to spawn stage-2""); write_log(DEBUG, ""request stage-0 to forward stage-2 pid (%d)"", stage2_pid); s = SYNC_RECVPID_PLS; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(SYNC_RECVPID_PLS)""); } if (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(stage2_pid)""); } if (read(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: read(SYNC_RECVPID_ACK)""); } if (s != SYNC_RECVPID_ACK) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: SYNC_RECVPID_ACK: got %u"", s); } write_log(DEBUG, ""signal completion to stage-0""); s = SYNC_CHILD_FINISH; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) { sane_kill(stage2_pid, SIGKILL); bail(""failed to sync with parent: write(SYNC_CHILD_FINISH)""); } write_log(DEBUG, ""<~ nsexec stage-1""); exit(0); } break; case STAGE_INIT:{ enum sync_t s; syncfd = sync_grandchild_pipe[0]; if (close(sync_grandchild_pipe[1]) < 0) bail(""failed to close sync_grandchild_pipe[1] fd""); if (close(sync_child_pipe[0]) < 0) bail(""failed to close sync_child_pipe[0] fd""); prctl(PR_SET_NAME, (unsigned long)""runc:[2:INIT]"", 0, 0, 0); write_log(DEBUG, ""~> nsexec stage-2""); if (read(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: read(SYNC_GRANDCHILD)""); if (s != SYNC_GRANDCHILD) bail(""failed to sync with parent: SYNC_GRANDCHILD: got %u"", s); if (setsid() < 0) bail(""setsid failed""); if (setuid(0) < 0) bail(""setuid failed""); if (setgid(0) < 0) bail(""setgid failed""); if (!config.is_rootless_euid && config.is_setgroup) { if (setgroups(0, NULL) < 0) bail(""setgroups failed""); } if (config.cloneflags & CLONE_NEWCGROUP) { if (unshare(CLONE_NEWCGROUP) < 0) bail(""failed to unshare cgroup namespace""); } write_log(DEBUG, ""signal completion to stage-0""); s = SYNC_CHILD_FINISH; if (write(syncfd, &s, sizeof(s)) != sizeof(s)) bail(""failed to sync with parent: write(SYNC_CHILD_FINISH)""); if (close(sync_grandchild_pipe[0]) < 0) bail(""failed to close sync_grandchild_pipe[0] fd""); nl_free(&config); write_log(DEBUG, ""<= nsexec container setup""); write_log(DEBUG, ""booting up go runtime ...""); return; } break; default: bail(""unknown stage '%d' for jump value"", current_stage); } bail(""should never be reached""); }"
"static inline int addrs_in_same_network_family(const tor_addr_t *a1, const tor_addr_t *a2) { return 0 == tor_addr_compare_masked(a1, a2, 16, CMP_SEMANTIC); }"
"int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params) { int Result = RESULT_SUCCESS; try { std::unique_ptr<TStrings> Arguments(new TStringList()); if (!DebugAlwaysTrue(Params->FindSwitch(L""batchsettings"", Arguments.get()))) { Abort(); } else { if (Arguments->Count < 1) { throw Exception(LoadStr(BATCH_SET_NO_MASK)); } else if (Arguments->Count < 2) { throw Exception(LoadStr(BATCH_SET_NO_SETTINGS)); } else { TFileMasks Mask(Arguments->Strings[0]); Arguments->Delete(0); std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false)); int Matches = 0; int Changes = 0; for (int Index = 0; Index < StoredSessions->Count; Index++) { TSessionData * Data = StoredSessions->Sessions[Index]; if (!Data->IsWorkspace && Mask.Matches(Data->Name, false, false)) { Matches++; std::unique_ptr<TSessionData> OriginalData(new TSessionData(L"""")); OriginalData->CopyDataNoRecrypt(Data); Data->ApplyRawSettings(OptionsStorage.get()); bool Changed = !OriginalData->IsSame(Data, false); if (Changed) { Changes++; } UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED); Console->PrintLine(FORMAT(L""%s - %s"", (Data->Name, StateStr))); } } StoredSessions->Save(false, true);         Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes))); } } } catch (Exception & E) { Result = HandleException(Console, E); } Console->WaitBeforeExit(); return Result; }"
"char *GetCommandbyName(const char *name, int *timeout) { int i = 0; if (name[0] == '!') { static char command[OS_FLSIZE]; if (snprintf(command, sizeof(command), ""%s/%s"", AR_BINDIR, name + 1) >= (int)sizeof(command)) { mwarn(""Cannot execute command '%32s...': path too long."", name + 1); return NULL; } *timeout = 0; return command; } for (; i < exec_size; i++) { if (strcmp(name, exec_names[i]) == 0) { *timeout = exec_timeout[i]; return (exec_cmd[i]); } } return (NULL); }"
"void atalk_register_sysctl(void) { atalk_table_header = register_net_sysctl(&init_net, ""net/appletalk"", atalk_table); }"
"LogicalResult IfOpConversion::matchAndRewrite(scf::IfOp ifOp, OpAdaptor adaptor, ConversionPatternRewriter &rewriter) const { auto loc = ifOp.getLoc(); auto selectionOp = rewriter.create<spirv::SelectionOp>(loc, spirv::SelectionControl::None); auto *mergeBlock = rewriter.createBlock(&selectionOp.getBody(), selectionOp.getBody().end()); rewriter.create<spirv::MergeOp>(loc); OpBuilder::InsertionGuard guard(rewriter); auto *selectionHeaderBlock = rewriter.createBlock(&selectionOp.getBody().front()); auto &thenRegion = ifOp.getThenRegion(); auto *thenBlock = &thenRegion.front(); rewriter.setInsertionPointToEnd(&thenRegion.back()); rewriter.create<spirv::BranchOp>(loc, mergeBlock); rewriter.inlineRegionBefore(thenRegion, mergeBlock); auto *elseBlock = mergeBlock; if (!ifOp.getElseRegion().empty()) { auto &elseRegion = ifOp.getElseRegion(); elseBlock = &elseRegion.front(); rewriter.setInsertionPointToEnd(&elseRegion.back()); rewriter.create<spirv::BranchOp>(loc, mergeBlock); rewriter.inlineRegionBefore(elseRegion, mergeBlock); } rewriter.setInsertionPointToEnd(selectionHeaderBlock); rewriter.create<spirv::BranchConditionalOp>(loc, adaptor.getCondition(), thenBlock, ArrayRef<Value>(), elseBlock, ArrayRef<Value>()); SmallVector<Type, 8> returnTypes; for (auto result : ifOp.getResults()) { auto convertedType = typeConverter.convertType(result.getType()); returnTypes.push_back(convertedType); } replaceSCFOutputValue(ifOp, selectionOp, rewriter, scfToSPIRVContext, returnTypes); return success(); }"
"static int action_getconfig(struct mansession *s, const struct message *m) { struct ast_config *cfg; const char *fn = astman_get_header(m, ""Filename""); const char *category = astman_get_header(m, ""Category""); const char *filter = astman_get_header(m, ""Filter""); const char *category_name; int catcount = 0; int lineno = 0; struct ast_category *cur_category = NULL; struct ast_variable *v; struct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE }; if (ast_strlen_zero(fn)) { astman_send_error(s, m, ""Filename not specified""); return 0; } if (restrictedFile(fn)) { astman_send_error(s, m, ""File requires escalated priveledges""); return 0; } cfg = ast_config_load2(fn, ""manager"", config_flags); if (cfg == CONFIG_STATUS_FILEMISSING) { astman_send_error(s, m, ""Config file not found""); return 0; } else if (cfg == CONFIG_STATUS_FILEINVALID) { astman_send_error(s, m, ""Config file has invalid format""); return 0; } astman_start_ack(s, m); while ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) { struct ast_str *templates; category_name = ast_category_get_name(cur_category); lineno = 0; astman_append(s, ""Category-%06d: %s\r\n"", catcount, category_name); if (ast_category_is_template(cur_category)) { astman_append(s, ""IsTemplate-%06d: %d\r\n"", catcount, 1); } if ((templates = ast_category_get_templates(cur_category)) && ast_str_strlen(templates) > 0) { astman_append(s, ""Templates-%06d: %s\r\n"", catcount, ast_str_buffer(templates)); ast_free(templates); } for (v = ast_category_first(cur_category); v; v = v->next) { astman_append(s, ""Line-%06d-%06d: %s=%s\r\n"", catcount, lineno++, v->name, v->value); } catcount++; } if (!ast_strlen_zero(category) && catcount == 0) {  astman_append(s, ""No categories found\r\n""); } ast_config_destroy(cfg); astman_append(s, ""\r\n""); return 0; }"
"static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req, const struct io_uring_sqe *sqe) __must_hold(&ctx->uring_lock) { struct io_submit_state *state; unsigned int sqe_flags; int personality, ret = 0; req->opcode = READ_ONCE(sqe->opcode); req->flags = sqe_flags = READ_ONCE(sqe->flags); req->user_data = READ_ONCE(sqe->user_data); req->file = NULL; req->fixed_rsrc_refs = NULL; req->task = current; if (unlikely(sqe_flags & ~SQE_VALID_FLAGS)) return -EINVAL; if (unlikely(req->opcode >= IORING_OP_LAST)) return -EINVAL; if (!io_check_restriction(ctx, req, sqe_flags)) return -EACCES; if ((sqe_flags & IOSQE_BUFFER_SELECT) && !io_op_defs[req->opcode].buffer_select) return -EOPNOTSUPP; if (unlikely(sqe_flags & IOSQE_IO_DRAIN)) ctx->drain_active = true; personality = READ_ONCE(sqe->personality); if (personality) { req->creds = xa_load(&ctx->personalities, personality); if (!req->creds) return -EINVAL; get_cred(req->creds); req->flags |= REQ_F_CREDS; } state = &ctx->submit_state; if (!state->plug_started && state->ios_left > 1 && io_op_defs[req->opcode].plug) { blk_start_plug(&state->plug); state->plug_started = true; } if (io_op_defs[req->opcode].needs_file) { req->file = io_file_get(ctx, req, READ_ONCE(sqe->fd), (sqe_flags & IOSQE_FIXED_FILE)); if (unlikely(!req->file)) ret = -EBADF; } state->ios_left--; return ret; }"
"static int writeback_single_inode(struct inode *inode, struct writeback_control *wbc) { struct bdi_writeback *wb; int ret = 0; spin_lock(&inode->i_lock); if (!atomic_read(&inode->i_count)) WARN_ON(!(inode->i_state & (I_WILL_FREE|I_FREEING))); else WARN_ON(inode->i_state & I_WILL_FREE); if (inode->i_state & I_SYNC) { if (wbc->sync_mode != WB_SYNC_ALL) goto out; __inode_wait_for_writeback(inode); } WARN_ON(inode->i_state & I_SYNC); if (!(inode->i_state & I_DIRTY_ALL) && (wbc->sync_mode != WB_SYNC_ALL || !mapping_tagged(inode->i_mapping, PAGECACHE_TAG_WRITEBACK))) goto out; inode->i_state |= I_SYNC; wbc_attach_and_unlock_inode(wbc, inode); ret = __writeback_single_inode(inode, wbc); wbc_detach_inode(wbc); wb = inode_to_wb_and_lock_list(inode); spin_lock(&inode->i_lock); if (!(inode->i_state & I_DIRTY_ALL)) inode_cgwb_move_to_attached(inode, wb); else if (!(inode->i_state & I_SYNC_QUEUED)) { if ((inode->i_state & I_DIRTY)) redirty_tail_locked(inode, wb); else if (inode->i_state & I_DIRTY_TIME) { inode->dirtied_when = jiffies; inode_io_list_move_locked(inode, wb, &wb->b_dirty_time); } } spin_unlock(&wb->list_lock); inode_sync_complete(inode); out: spin_unlock(&inode->i_lock); return ret; }"
"int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info, const char * name, int rep_quick) { int got_error; uint i,key, total_key_length, istep; ulong rec_length; ha_rows start_records; my_off_t new_header_length,del; File new_file; MI_SORT_PARAM *sort_param=0; MYISAM_SHARE *share=info->s; ulong   *rec_per_key_part; HA_KEYSEG *keyseg; char llbuff[22]; IO_CACHE new_data_cache;  IO_CACHE_SHARE io_share; SORT_INFO sort_info; ulonglong UNINIT_VAR(key_map); pthread_attr_t thr_attr; ulong max_pack_reclength; int error; DBUG_ENTER(""mi_repair_parallel""); start_records=info->state->records; got_error=1; new_file= -1; new_header_length=(param->testflag & T_UNPACK) ? 0 : share->pack.header_length; if (!(param->testflag & T_SILENT)) { printf(""- parallel recovering (with sort) MyISAM-table '%s'\n"",name); printf(""Data records: %s\n"", llstr(start_records,llbuff)); } param->testflag|=T_REP;  if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD)) param->testflag|=T_CALC_CHECKSUM; DBUG_PRINT(""info"", (""is quick repair: %d"", rep_quick)); bzero((char*)&sort_info,sizeof(sort_info)); mysql_mutex_init(mi_key_mutex_MI_SORT_INFO_mutex, &sort_info.mutex, MY_MUTEX_INIT_FAST); mysql_cond_init(mi_key_cond_MI_SORT_INFO_cond, &sort_info.cond, 0); mysql_mutex_init(mi_key_mutex_MI_CHECK_print_msg, &param->print_msg_mutex, MY_MUTEX_INIT_FAST); param->need_print_msg_lock= 1; if (!(sort_info.key_block= alloc_key_blocks(param, (uint) param->sort_key_blocks, share->base.max_key_block_length)) || init_io_cache(&param->read_cache, info->dfile, (uint) param->read_buffer_length, READ_CACHE, share->pack.header_length, 1, MYF(MY_WME)) || (!rep_quick && (init_io_cache(&info->rec_cache, info->dfile, (uint) param->write_buffer_length, WRITE_CACHE, new_header_length, 1, MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw) || init_io_cache(&new_data_cache, -1, (uint) param->write_buffer_length, READ_CACHE, new_header_length, 1, MYF(MY_WME | MY_DONT_CHECK_FILESIZE))))) goto err; sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks; info->opt_flag|=WRITE_CACHE_USED; info->rec_cache.file=info->dfile;          if (!rep_quick) { if ((new_file= mysql_file_create(mi_key_file_datatmp, fn_format(param->temp_filename, share->data_file_name, """", DATA_TMP_EXT, 2+4), 0, param->tmpfile_createflag, MYF(0))) < 0) { mi_check_print_error(param,""Can't create new tempfile: '%s'"", param->temp_filename); goto err; } if (new_header_length && filecopy(param, new_file,info->dfile,0L,new_header_length, ""datafile-header"")) goto err; if (param->testflag & T_UNPACK) { share->options&= ~HA_OPTION_COMPRESS_RECORD; mi_int2store(share->state.header.options,share->options); } share->state.dellink= HA_OFFSET_ERROR; info->rec_cache.file=new_file; } info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED); mi_drop_all_indexes(param, info, FALSE); key_map= share->state.key_map; if (param->testflag & T_CREATE_MISSING_KEYS) { key_map= ~key_map; } sort_info.info=info; sort_info.param = param; set_data_file_type(&sort_info, share); sort_info.dupp=0; sort_info.buff=0; param->read_cache.end_of_file=sort_info.filelength= mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0)); if (share->data_file_type == DYNAMIC_RECORD) rec_length=max(share->base.min_pack_length+1,share->base.min_block_length); else if (share->data_file_type == COMPRESSED_RECORD) rec_length=share->base.min_block_length; else rec_length=share->base.pack_reclength; sort_info.max_records= ((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records + 1: (ha_rows) (sort_info.filelength/rec_length+1)); del=info->state->del; param->glob_crc=0; max_pack_reclength= share->base.pack_reclength; if (share->options & HA_OPTION_COMPRESS_RECORD) set_if_bigger(max_pack_reclength, share->max_pack_length); if (!(sort_param=(MI_SORT_PARAM *) my_malloc((uint) share->base.keys * (sizeof(MI_SORT_PARAM) + max_pack_reclength), MYF(MY_ZEROFILL)))) { mi_check_print_error(param,""Not enough memory for key!""); goto err; } total_key_length=0; rec_per_key_part= param->rec_per_key_part; info->state->records=info->state->del=share->state.split=0; info->state->empty=0; for (i=key=0, istep=1 ; key < share->base.keys ; rec_per_key_part+=sort_param[i].keyinfo->keysegs, i+=istep, key++) { sort_param[i].key=key; sort_param[i].keyinfo=share->keyinfo+key; sort_param[i].seg=sort_param[i].keyinfo->seg; if (! mi_is_key_active(key_map, key)) { memcpy((char*) rec_per_key_part, (char*) (share->state.rec_per_key_part+ (uint) (rec_per_key_part - param->rec_per_key_part)), sort_param[i].keyinfo->keysegs*sizeof(*rec_per_key_part)); istep=0; continue; } istep=1; if ((!(param->testflag & T_SILENT))) printf (""- Fixing index %d\n"",key+1); if (sort_param[i].keyinfo->flag & HA_FULLTEXT) { sort_param[i].key_read=sort_ft_key_read; sort_param[i].key_write=sort_ft_key_write; } else { sort_param[i].key_read=sort_key_read; sort_param[i].key_write=sort_key_write; } sort_param[i].key_cmp=sort_key_cmp; sort_param[i].lock_in_memory=lock_memory; sort_param[i].tmpdir=param->tmpdir; sort_param[i].sort_info=&sort_info; sort_param[i].master=0; sort_param[i].fix_datafile=0; sort_param[i].calc_checksum= 0; sort_param[i].filepos=new_header_length; sort_param[i].max_pos=sort_param[i].pos=share->pack.header_length; sort_param[i].record= (((uchar *)(sort_param+share->base.keys))+ (max_pack_reclength * i)); if (!mi_alloc_rec_buff(info, -1, &sort_param[i].rec_buff)) { mi_check_print_error(param,""Not enough memory!""); goto err; } sort_param[i].key_length=share->rec_reflength; for (keyseg=sort_param[i].seg; keyseg->type != HA_KEYTYPE_END; keyseg++) { sort_param[i].key_length+=keyseg->length; if (keyseg->flag & HA_SPACE_PACK) sort_param[i].key_length+=get_pack_length(keyseg->length); if (keyseg->flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART)) sort_param[i].key_length+=2 + test(keyseg->length >= 127); if (keyseg->flag & HA_NULL_PART) sort_param[i].key_length++; } total_key_length+=sort_param[i].key_length; if (sort_param[i].keyinfo->flag & HA_FULLTEXT) { uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT* sort_param[i].keyinfo->seg->charset->mbmaxlen; sort_param[i].key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN; init_alloc_root(&sort_param[i].wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0); } } sort_info.total_keys=i; sort_param[0].master= 1; sort_param[0].fix_datafile= (my_bool)(! rep_quick); sort_param[0].calc_checksum= test(param->testflag & T_CALC_CHECKSUM); if (!ftparser_alloc_param(info)) goto err; sort_info.got_error=0; mysql_mutex_lock(&sort_info.mutex); if (i > 1) { if (rep_quick) init_io_cache_share(&param->read_cache, &io_share, NULL, i); else init_io_cache_share(&new_data_cache, &io_share, &info->rec_cache, i); } else io_share.total_threads= 0;  (void) pthread_attr_init(&thr_attr); (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED); for (i=0 ; i < sort_info.total_keys ; i++) { sort_param[i].read_cache= ((rep_quick || !i) ? param->read_cache : new_data_cache); DBUG_PRINT(""io_cache_share"", (""thread: %u  read_cache: 0x%lx"", i, (long) &sort_param[i].read_cache)); sort_param[i].sortbuff_size= #ifndef USING_SECOND_APPROACH param->sort_buffer_length/sort_info.total_keys; #else param->sort_buffer_length*sort_param[i].key_length/total_key_length; #endif if ((error= mysql_thread_create(mi_key_thread_find_all_keys, &sort_param[i].thr, &thr_attr, thr_find_all_keys, (void *) (sort_param+i)))) { mi_check_print_error(param,""Cannot start a repair thread (errno= %d)"", error); if (io_share.total_threads) remove_io_thread(&sort_param[i].read_cache); DBUG_PRINT(""error"", (""Cannot start a repair thread"")); sort_info.got_error=1; } else sort_info.threads_running++; } (void) pthread_attr_destroy(&thr_attr); while (sort_info.threads_running) mysql_cond_wait(&sort_info.cond, &sort_info.mutex); mysql_mutex_unlock(&sort_info.mutex); if ((got_error= thr_write_keys(sort_param))) { param->retry_repair=1; goto err; } got_error=1; if (sort_param[0].fix_datafile) { if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache)) goto err; if (param->testflag & T_SAFE_REPAIR) { if (info->state->records+1 < start_records) { info->state->records=start_records; goto err; } } share->state.state.data_file_length= info->state->data_file_length= sort_param->filepos; share->state.version=(ulong) time((time_t*) 0); mysql_file_close(info->dfile, MYF(0)); info->dfile=new_file; share->data_file_type=sort_info.new_data_file_type; share->pack.header_length=(ulong) new_header_length; } else info->state->data_file_length=sort_param->max_pos; if (rep_quick && del+sort_info.dupp != info->state->del) { mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records""); mi_check_print_error(param,""Run recovery again without -q""); param->retry_repair=1; param->testflag|=T_RETRY_WITHOUT_QUICK; goto err; } if (rep_quick & T_FORCE_UNIQUENESS) { my_off_t skr=info->state->data_file_length+ (share->options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0); #ifdef USE_RELOC if (share->data_file_type == STATIC_RECORD && skr < share->base.reloc*share->base.min_pack_length) skr=share->base.reloc*share->base.min_pack_length; #endif if (skr != sort_info.filelength) if (mysql_file_chsize(info->dfile, skr, 0, MYF(0))) mi_check_print_warning(param, ""Can't change size of datafile,  error: %d"", my_errno); } if (param->testflag & T_CALC_CHECKSUM) info->state->checksum=param->glob_crc; if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0))) mi_check_print_warning(param, ""Can't change size of indexfile, error: %d"", my_errno); if (!(param->testflag & T_SILENT)) { if (start_records != info->state->records) printf(""Data records: %s\n"", llstr(info->state->records,llbuff)); if (sort_info.dupp) mi_check_print_warning(param, ""%s records have been removed"", llstr(sort_info.dupp,llbuff)); } got_error=0; if (&share->state.state != info->state) memcpy(&share->state.state, info->state, sizeof(*info->state)); err: got_error|= flush_blocks(param, share->key_cache, share->kfile); (void) end_io_cache(&info->rec_cache); if (!rep_quick) (void) end_io_cache(&new_data_cache); if (!got_error) { if (new_file >= 0) { mysql_file_close(new_file, MYF(0)); info->dfile=new_file= -1; if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT, (param->testflag & T_BACKUP_DATA ? MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) || mi_open_datafile(info,share,name,-1)) got_error=1; } } if (got_error) { if (! param->error_printed) mi_check_print_error(param,""%d when fixing table"",my_errno); if (new_file >= 0) { (void) mysql_file_close(new_file, MYF(0)); (void) mysql_file_delete(mi_key_file_datatmp, param->temp_filename, MYF(MY_WME)); if (info->dfile == new_file)  if (unlikely(mi_open_datafile(info, share, name, -1))) param->retry_repair= 0;  } mi_mark_crashed_on_repair(info); } else if (key_map == share->state.key_map) share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS; share->state.changed|=STATE_NOT_SORTED_PAGES; mysql_cond_destroy(&sort_info.cond); mysql_mutex_destroy(&sort_info.mutex); mysql_mutex_destroy(&param->print_msg_mutex); param->need_print_msg_lock= 0; my_free(sort_info.ft_buf); my_free(sort_info.key_block); my_free(sort_param); my_free(sort_info.buff); (void) end_io_cache(&param->read_cache); info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED); if (!got_error && (param->testflag & T_UNPACK)) { share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD; share->pack.header_length=0; } DBUG_RETURN(got_error); }"
"static Jsi_RC StringReplaceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { const char *source_str; int source_len, bLen; const char *replace_str = NULL; int replace_len; int regexec_flags = 0; Jsi_Value *seq, *strVal; Jsi_DString dStr = {}; regex_t *regex; Jsi_Regex *re; const char *p; int maxArgs = 1; int offset = 0, n, j, isglob = 0, num_matches = 0; ChkString(_this, funcPtr, source_str, &source_len, &bLen); source_len = bLen; if (!skip) strVal = _this; else strVal = Jsi_ValueArrayIndex(interp, args, 0); seq = Jsi_ValueArrayIndex(interp, args, skip); Jsi_Value *repVal = Jsi_ValueArrayIndex(interp, args, 1+skip); if (!Jsi_ValueIsFunction(interp, repVal)) replace_str = Jsi_ValueToString(interp, repVal, &replace_len); else maxArgs = repVal->d.obj->d.fobj->func->argnames->argCnt; Jsi_DSInit(&dStr); if (Jsi_ValueIsString(interp, seq)) { const char *ce, *cp = Jsi_ValueString(interp, seq, NULL); if (!(ce = Jsi_Strstr(source_str, cp))) Jsi_ValueMakeStringDup(interp, ret, source_str); else { int slen; slen = (ce-source_str); if (slen) Jsi_DSAppendLen(&dStr, source_str, slen); if (replace_str) Jsi_DSAppendLen(&dStr, replace_str, replace_len); else { Jsi_Value *inStr = Jsi_ValueNewStringDup(interp, source_str); Jsi_IncrRefCount(interp, inStr); Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr); if (Jsi_InterpGone(interp)) return JSI_ERROR; if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } Jsi_DecrRefCount(interp, inStr); } Jsi_DSAppend(&dStr, ce+Jsi_Strlen(cp), NULL); Jsi_ValueFromDS(interp, &dStr, ret); } return JSI_OK; } if (seq == NULL || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) { Jsi_ValueMakeNull(interp, ret); return JSI_OK; } re = seq->d.obj->d.robj; regex = &re->reg; isglob = (re->eflags & JSI_REG_GLOB); regmatch_t pmatch[MAX_SUBREGEX] = {}; int eoffset=0; if (offset) { if (offset < 0) { offset += source_len + 1; } if (offset > source_len) { offset = source_len; } else if (offset < 0) { offset = 0; } } Jsi_DSAppendLen(&dStr, source_str, offset); n = source_len - offset; p = source_str + offset; Jsi_RC rc = JSI_OK; do { if (num_matches > 10000000) { Jsi_LogBug(""regexp infinite loop""); rc = JSI_ERROR; break; } int match = regexec(regex, p, MAX_SUBREGEX, pmatch, regexec_flags); if (match >= REG_BADPAT) { char buf[JSI_MAX_NUMBER_STRING]; regerror(match, regex, buf, sizeof(buf)); Jsi_LogError(""error while matching pattern: %s"", buf); Jsi_DSFree(&dStr); return JSI_ERROR; } if (match == REG_NOMATCH) { break; } num_matches++; Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so); if (replace_str &&  !Jsi_Strchr(replace_str, '$')) Jsi_DSAppend(&dStr, replace_str, NULL); else if (replace_str) { for (j = 0; j < replace_len; j++) { int idx; int c = replace_str[j]; if (c == '$' && j < replace_len) { c = replace_str[++j]; if ((c >= '0') && (c <= '9')) { idx = c - '0'; } else if (c == '&') { idx = 0; } else if (c == '$') { Jsi_DSAppendLen(&dStr, replace_str + j, 1); continue; } else if (c == '\'') { Jsi_DSAppendLen(&dStr, p + pmatch[0].rm_eo, pmatch[0].rm_eo-Jsi_Strlen(p)); continue; } else if (c == '`') { Jsi_DSAppendLen(&dStr, p, pmatch[0].rm_so); continue; } else { Jsi_DSAppendLen(&dStr, replace_str + j - 1, 2); continue; } } else { Jsi_DSAppendLen(&dStr, replace_str + j, 1); continue; } if ((idx < MAX_SUBREGEX) && pmatch[idx].rm_so != -1 && pmatch[idx].rm_eo != -1) { Jsi_DSAppendLen(&dStr, p + pmatch[idx].rm_so, pmatch[idx].rm_eo - pmatch[idx].rm_so); } } } else { Jsi_DString sStr; Jsi_DSInit(&sStr);  if (pmatch[0].rm_so <= 0 && pmatch[0].rm_eo <= 0) break; int olen = -1; char *ostr = jsi_SubstrDup(p, -1, pmatch[0].rm_so, pmatch[0].rm_eo - pmatch[0].rm_so, &olen); Jsi_Value *inStr = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen); Jsi_DSFree(&sStr); Jsi_IncrRefCount(interp, inStr); if (maxArgs==1) { Jsi_RC rc = Jsi_FunctionInvokeString(interp, repVal, inStr, &dStr); if (Jsi_InterpGone(interp)) return JSI_ERROR; if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } } else { Jsi_Value *vpargs, *items[MAX_SUBREGEX] = {}, *ret; int i; items[0] = inStr; for (i=1; i<=(int)re->reg.re_nsub && i<(MAX_SUBREGEX-3); i++) { if (pmatch[i].rm_so<0) items[i] = interp->NullValue; else { ostr = jsi_SubstrDup(p, -1, pmatch[i].rm_so, pmatch[i].rm_eo - pmatch[i].rm_so, &olen); items[i] = Jsi_ValueMakeBlob(interp, NULL, (uchar*)ostr, olen); } } items[i++] = Jsi_ValueMakeNumber(interp, NULL, eoffset+pmatch[0].rm_so); items[i++] = strVal; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, i, 0)); Jsi_IncrRefCount(interp, vpargs); ret = Jsi_ValueNew1(interp); rc = Jsi_FunctionInvoke(interp, repVal, vpargs, &ret, NULL); if (Jsi_InterpGone(interp)) return JSI_ERROR; Jsi_DecrRefCount(interp, vpargs); if (rc == JSI_OK) Jsi_DSAppend(&dStr, Jsi_ValueToString(interp, ret, NULL), NULL); Jsi_DecrRefCount(interp, ret); if (rc != JSI_OK) { Jsi_DSFree(&dStr); Jsi_DecrRefCount(interp, inStr); return JSI_ERROR; } } Jsi_DecrRefCount(interp, inStr); } eoffset += pmatch[0].rm_eo; p += pmatch[0].rm_eo; n -= pmatch[0].rm_eo; if (!isglob || n == 0 || pmatch[0].rm_eo == 0) { break; } if ((re->eflags & JSI_REG_NEWLINE) == 0 && re->pattern[0] == '^') { break; } if (re->pattern[0] == '\0' && n) { Jsi_DSAppendLen(&dStr, p, 1); p++; n--; } regexec_flags |= REG_NOTBOL; } while (n); Jsi_DSAppend(&dStr, p, NULL); Jsi_ValueFromDS(interp, &dStr, ret); return rc; }"
"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent) { FD_t wfd = NULL; int rc = 0; { mode_t old_umask = umask(0577); wfd = Fopen(dest, ""w.ufdio""); umask(old_umask); } if (Ferror(wfd)) { rc = RPMERR_OPEN_FAILED; goto exit; } if (!nocontent) rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm); exit: if (wfd) { int myerrno = errno; Fclose(wfd); errno = myerrno; } return rc; }"
"static void get_setgroups_sidlist (cygsidlist &tmp_list, PSID usersid, PTOKEN_GROUPS my_grps, user_groups &groups, LUID auth_luid, int &auth_pos) { tmp_list *= well_known_world_sid; tmp_list *= well_known_authenticated_users_sid; get_token_group_sidlist (tmp_list, my_grps, auth_luid, auth_pos); get_server_groups (tmp_list, usersid); for (int gidx = 0; gidx < groups.sgsids.count (); gidx++) tmp_list += groups.sgsids.sids[gidx]; tmp_list += groups.pgsid; }"
"void Pl_ASCII85Decoder::flush() { if (this->pos == 0) { QTC::TC(""libtests"", ""Pl_ASCII85Decoder no-op flush""); return; } unsigned long lval = 0; for (int i = 0; i < 5; ++i) { lval *= 85; lval += (this->inbuf[i] - 33U); } unsigned char outbuf[4]; memset(outbuf, 0, 4); for (int i = 3; i >= 0; --i) { outbuf[i] = lval & 0xff; lval >>= 8; } QTC::TC(""libtests"", ""Pl_ASCII85Decoder partial flush"", (this->pos == 5) ? 0 : 1); getNext()->write(outbuf, this->pos - 1); this->pos = 0; memset(this->inbuf, 117, 5); }"
"static int m_authenticate(struct Client *client_p, struct Client *source_p, int parc, const char *parv[]) { struct Client *agent_p = NULL; struct Client *saslserv_p = NULL; if(!IsCapable(source_p, CLICAP_SASL)) return 0; if (strlen(client_p->id) == 3) { exit_client(client_p, client_p, client_p, ""Mixing client and server protocol""); return 0; } saslserv_p = find_named_client(ConfigFileEntry.sasl_service); if (saslserv_p == NULL || !IsService(saslserv_p)) { sendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name); return 0; } if(source_p->localClient->sasl_complete) { *source_p->localClient->sasl_agent = '\0'; source_p->localClient->sasl_complete = 0; } if(strlen(parv[1]) > 400) { sendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? ""*"" : source_p->name); return 0; } if(!*source_p->id) { strcpy(source_p->id, generate_uid()); add_to_id_hash(source_p->id, source_p); } if(*source_p->localClient->sasl_agent) agent_p = find_id(source_p->localClient->sasl_agent); if(agent_p == NULL) { sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s H %s %s"", me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id, source_p->host, source_p->sockhost); if (!strcmp(parv[1], ""EXTERNAL"") && source_p->certfp != NULL) sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s %s"", me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id, parv[1], source_p->certfp); else sendto_one(saslserv_p, "":%s ENCAP %s SASL %s %s S %s"", me.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id, parv[1]); rb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN); } else sendto_one(agent_p, "":%s ENCAP %s SASL %s %s C %s"", me.id, agent_p->servptr->name, source_p->id, agent_p->id, parv[1]); source_p->localClient->sasl_out++; return 0; }"
"static void gf_media_update_bitrate_ex(GF_ISOFile *file, u32 track, Bool use_esd) { #ifndef GPAC_DISABLE_ISOM_WRITE u32 i, count, timescale, db_size, cdur, csize; u64 time_wnd, max_rate, avg_rate, bitrate; Double br; GF_ISOSample sample; db_size = 0; max_rate = avg_rate = time_wnd = bitrate = 0; csize = 0; cdur = 0; if (gf_isom_get_media_type(file, track)==GF_ISOM_MEDIA_AUDIO) { csize = gf_isom_get_constant_sample_size(file, track); cdur = gf_isom_get_constant_sample_duration(file, track); if (cdur > 1) cdur = 0; } memset(&sample, 0, sizeof(GF_ISOSample)); timescale = gf_isom_get_media_timescale(file, track); count = gf_isom_get_sample_count(file, track); if (csize && cdur) { db_size = 0; avg_rate = 8 * csize * timescale / cdur; bitrate = avg_rate; } else { u32 rate = 0; for (i=0; i<count; i++) { u32 di; GF_ISOSample *samp = gf_isom_get_sample_info_ex(file, track, i+1, &di, NULL, &sample); if (!samp) break; if (samp->dataLength > db_size) db_size = samp->dataLength; avg_rate += samp->dataLength; rate += samp->dataLength; if (samp->DTS > time_wnd + timescale) { if (rate > max_rate) max_rate = rate; time_wnd = samp->DTS; rate = 0; } } } br = (Double) (s64) gf_isom_get_media_duration(file, track); br /= timescale; if (br) { GF_ESD *esd = NULL; if (!csize || !cdur) { bitrate = (u32) ((Double) (s64)avg_rate / br); bitrate *= 8; max_rate *= 8; } if (!max_rate) max_rate = bitrate; if (use_esd) esd = gf_isom_get_esd(file, track, 1); if (esd && esd->decoderConfig) { esd->decoderConfig->avgBitrate = (u32) bitrate; esd->decoderConfig->maxBitrate = (u32) max_rate; esd->decoderConfig->bufferSizeDB = db_size; gf_isom_change_mpeg4_description(file, track, 1, esd); } else { gf_isom_update_bitrate(file, track, 1, (u32) bitrate, (u32) max_rate, db_size); } if (esd) gf_odf_desc_del((GF_Descriptor *)esd); } #endif }"
"static void handle_mailto (EMsgComposer *composer, const gchar *mailto) { EAttachmentView *view; EAttachmentStore *store; EComposerHeaderTable *table; GList *to = NULL, *cc = NULL, *bcc = NULL; EDestination **tov, **ccv, **bccv; gchar *subject = NULL, *body = NULL; gchar *header, *content, *buf; gsize nread, nwritten; const gchar *p; gint len, clen; table = e_msg_composer_get_header_table (composer); view = e_msg_composer_get_attachment_view (composer); store = e_attachment_view_get_store (view); buf = g_strdup (mailto); p = buf + 7; while (*p == '/' && p - buf < 10) p++; len = strcspn (p, ""?""); if (len) { content = g_strndup (p, len); camel_url_decode (content); to = add_recipients (to, content); g_free (content); } p += len; if (*p == '?') { p++; while (*p) { len = strcspn (p, ""=&""); if (p[len] != '=') break; header = (gchar *) p; header[len] = '\0'; p += len + 1; clen = strcspn (p, ""&""); content = g_strndup (p, clen); if (!g_ascii_strcasecmp (header, ""to"")) { camel_url_decode (content); to = add_recipients (to, content); } else if (!g_ascii_strcasecmp (header, ""cc"")) { camel_url_decode (content); cc = add_recipients (cc, content); } else if (!g_ascii_strcasecmp (header, ""bcc"")) { camel_url_decode (content); bcc = add_recipients (bcc, content); } else if (!g_ascii_strcasecmp (header, ""subject"")) { g_free (subject); camel_url_decode (content); if (g_utf8_validate (content, -1, NULL)) { subject = content; content = NULL; } else { subject = g_locale_to_utf8 ( content, clen, &nread, &nwritten, NULL); if (subject) { subject = g_realloc (subject, nwritten + 1); subject[nwritten] = '\0'; } } } else if (!g_ascii_strcasecmp (header, ""body"")) { g_free (body); camel_url_decode (content); if (g_utf8_validate (content, -1, NULL)) { body = content; content = NULL; } else { body = g_locale_to_utf8 ( content, clen, &nread, &nwritten, NULL); if (body) { body = g_realloc (body, nwritten + 1); body[nwritten] = '\0'; } } } else if (!g_ascii_strcasecmp (header, ""attach"") || !g_ascii_strcasecmp (header, ""attachment"")) { EAttachment *attachment; camel_url_decode (content); if (file_is_blacklisted (content)) e_alert_submit ( E_ALERT_SINK (e_msg_composer_get_editor (composer)), ""mail:blacklisted-file"", content, NULL); if (g_ascii_strncasecmp (content, ""file:"", 5) == 0) attachment = e_attachment_new_for_uri (content); else attachment = e_attachment_new_for_path (content); e_attachment_store_add_attachment (store, attachment); e_attachment_load_async ( attachment, (GAsyncReadyCallback) e_attachment_load_handle_error, composer); g_object_unref (attachment); } else if (!g_ascii_strcasecmp (header, ""from"")) { } else if (!g_ascii_strcasecmp (header, ""reply-to"")) { } else { camel_url_decode (content); e_msg_composer_add_header (composer, header, content); } g_free (content); p += clen; if (*p == '&') { p++; if (!g_ascii_strncasecmp (p, ""amp;"", 4)) p += 4; } } } g_free (buf); merge_always_cc_and_bcc (table, to, &cc, &bcc); tov = destination_list_to_vector (to); ccv = destination_list_to_vector (cc); bccv = destination_list_to_vector (bcc); g_list_free (to); g_list_free (cc); g_list_free (bcc); e_composer_header_table_set_destinations_to (table, tov); e_composer_header_table_set_destinations_cc (table, ccv); e_composer_header_table_set_destinations_bcc (table, bccv); e_destination_freev (tov); e_destination_freev (ccv); e_destination_freev (bccv); e_composer_header_table_set_subject (table, subject); g_free (subject); if (body) { GSettings *settings; gchar *html_body; guint32 flags = 0; settings = e_util_ref_settings (""org.gnome.evolution.mail""); if (g_settings_get_boolean (settings, ""composer-magic-links"")) { flags |= CAMEL_MIME_FILTER_TOHTML_CONVERT_URLS | CAMEL_MIME_FILTER_TOHTML_CONVERT_ADDRESSES; } if (g_settings_get_boolean (settings, ""composer-mailto-body-in-pre"")) flags |= CAMEL_MIME_FILTER_TOHTML_PRE; else flags |= CAMEL_MIME_FILTER_TOHTML_CONVERT_NL | CAMEL_MIME_FILTER_TOHTML_CONVERT_SPACES; g_clear_object (&settings); html_body = camel_text_to_html (body, flags, 0); set_editor_text (composer, html_body, TRUE, TRUE); g_free (html_body); g_free (body); } }"
"static void parse_content_range(URLContext *h, const char *p) { HTTPContext *s = h->priv_data; const char *slash; if (!strncmp(p, ""bytes "", 6)) { p     += 6; s->off = strtoll(p, NULL, 10); if ((slash = strchr(p, '/')) && strlen(slash) > 0) s->filesize = strtoll(slash + 1, NULL, 10); } if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647)) h->is_streamed = 0;  }"
"char * get_archive_member_name (struct archive_info *arch, struct archive_info *nested_arch) { unsigned long j, k; if (arch->arhdr.ar_name[0] == '/') { char *endp; char *member_file_name; char *member_name; if (arch->longnames == NULL || arch->longnames_size == 0) { error (_(""Archive member uses long names, but no longname table found\n"")); return NULL; } arch->nested_member_origin = 0; k = j = strtoul (arch->arhdr.ar_name + 1, &endp, 10); if (arch->is_thin_archive && endp != NULL && * endp == ':') arch->nested_member_origin = strtoul (endp + 1, NULL, 10); if (j > arch->longnames_size) { error (_(""Found long name index (%ld) beyond end of long name table\n""),j); return NULL; } while ((j < arch->longnames_size) && (arch->longnames[j] != '\n') && (arch->longnames[j] != '\0')) j++; if (j > 0 && arch->longnames[j-1] == '/') j--; if (j > arch->longnames_size) j = arch->longnames_size; arch->longnames[j] = '\0'; if (!arch->is_thin_archive || arch->nested_member_origin == 0) return arch->longnames + k; if (k >= j) { error (_(""Invalid Thin archive member name\n"")); return NULL; } member_file_name = adjust_relative_path (arch->file_name, arch->longnames + k, j - k); if (member_file_name != NULL && setup_nested_archive (nested_arch, member_file_name) == 0) { member_name = get_archive_member_name_at (nested_arch, arch->nested_member_origin, NULL); if (member_name != NULL) { free (member_file_name); return member_name; } } free (member_file_name); return arch->longnames + k; } for (j = 0; j < sizeof (arch->arhdr.ar_name); j++) if (arch->arhdr.ar_name[j] == '/') { arch->arhdr.ar_name[j] = '\0'; return arch->arhdr.ar_name; } { char *name = xmalloc (sizeof (arch->arhdr.ar_name) + 1); memcpy (name, arch->arhdr.ar_name, sizeof (arch->arhdr.ar_name)); name[sizeof (arch->arhdr.ar_name)] = '\0'; return name; } }"
"static UINT dvcman_receive_channel_data(drdynvcPlugin* drdynvc, IWTSVirtualChannelManager* pChannelMgr, UINT32 ChannelId, wStream* data) { UINT status = CHANNEL_RC_OK; DVCMAN_CHANNEL* channel; size_t dataSize = Stream_GetRemainingLength(data); channel = (DVCMAN_CHANNEL*) dvcman_find_channel_by_id(pChannelMgr, ChannelId); if (!channel) { WLog_Print(drdynvc->log, WLOG_ERROR, ""ChannelId %""PRIu32"" not found!"", ChannelId); return CHANNEL_RC_OK; } if (channel->dvc_data) { if (Stream_GetPosition(channel->dvc_data) + dataSize > (UINT32) Stream_Capacity( channel->dvc_data)) { WLog_Print(drdynvc->log, WLOG_ERROR, ""data exceeding declared length!""); Stream_Release(channel->dvc_data); channel->dvc_data = NULL; return ERROR_INVALID_DATA; } Stream_Write(channel->dvc_data, Stream_Pointer(data), dataSize); if (Stream_GetPosition(channel->dvc_data) >= channel->dvc_data_length) { Stream_SealLength(channel->dvc_data); Stream_SetPosition(channel->dvc_data, 0); status = channel->channel_callback->OnDataReceived(channel->channel_callback, channel->dvc_data); Stream_Release(channel->dvc_data); channel->dvc_data = NULL; } } else { status = channel->channel_callback->OnDataReceived(channel->channel_callback, data); } return status; }"
"int LoadEXRImageFromFile(EXRImage *exr_image, const EXRHeader *exr_header, const char *filename, const char **err) { if (exr_image == NULL) { if (err) { (*err) = ""Invalid argument.""; } return TINYEXR_ERROR_INVALID_ARGUMENT; } #ifdef _WIN32 FILE *fp = NULL; fopen_s(&fp, filename, ""rb""); #else FILE *fp = fopen(filename, ""rb""); #endif if (!fp) { if (err) { (*err) = ""Cannot read file.""; } return TINYEXR_ERROR_CANT_OPEN_FILE; } size_t filesize; fseek(fp, 0, SEEK_END); filesize = static_cast<size_t>(ftell(fp)); fseek(fp, 0, SEEK_SET); std::vector<unsigned char> buf(filesize);    { size_t ret; ret = fread(&buf[0], 1, filesize, fp); assert(ret == filesize); fclose(fp); (void)ret; } return LoadEXRImageFromMemory(exr_image, exr_header, &buf.at(0), filesize, err); }"
"void *zmalloc_no_tcache(size_t size) { void *ptr = mallocx(size+PREFIX_SIZE, MALLOCX_TCACHE_NONE); if (!ptr) zmalloc_oom_handler(size); update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; }"
static int redisIvykisAttach(redisAsyncContext *ac) { redisContext *c = &(ac->c); redisIvykisEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisIvykisEvents*)malloc(sizeof(*e)); e->context = ac; ac->ev.addRead = redisIvykisAddRead; ac->ev.delRead = redisIvykisDelRead; ac->ev.addWrite = redisIvykisAddWrite; ac->ev.delWrite = redisIvykisDelWrite; ac->ev.cleanup = redisIvykisCleanup; ac->ev.data = e; IV_FD_INIT(&e->fd); e->fd.fd = c->fd; e->fd.handler_in = redisIvykisReadEvent; e->fd.handler_out = redisIvykisWriteEvent; e->fd.handler_err = NULL; e->fd.cookie = e->context; iv_fd_register(&e->fd); return REDIS_OK; }
"static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k, opj_tcd_t * p_tile_coder, OPJ_BYTE * p_data, OPJ_UINT32 * p_data_written, OPJ_UINT32 p_total_data_size, const opj_stream_private_t *p_stream, opj_event_mgr_t * p_manager ) { opj_codestream_info_t *l_cstr_info = 00; OPJ_UINT32 l_remaining_data; assert(p_j2k != 00); assert(p_manager != 00); assert(p_stream != 00); OPJ_UNUSED(p_stream); opj_write_bytes(p_data, J2K_MS_SOD, 2);                                  p_data += 2; l_remaining_data =  p_total_data_size - 4; p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ; p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number; #ifdef USE_JPWL assert(0 && ""TODO""); #endif  if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) { p_tile_coder->tcd_image->tiles->packno = 0; if (l_cstr_info) { l_cstr_info->packno = 0; } } *p_data_written = 0; if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data, p_data_written, l_remaining_data, l_cstr_info, p_manager)) { opj_event_msg(p_manager, EVT_ERROR, ""Cannot encode tile\n""); return OPJ_FALSE; } *p_data_written += 2; return OPJ_TRUE; }"
"static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc) { struct evtchn *chn; struct domain *d; int            port; domid_t        dom = alloc->dom; long           rc; d = rcu_lock_domain_by_any_id(dom); if ( d == NULL ) return -ESRCH; spin_lock(&d->event_lock); if ( (port = get_free_port(d)) < 0 ) ERROR_EXIT_DOM(port, d); chn = evtchn_from_port(d, port); rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom); if ( rc ) goto out; spin_lock(&chn->lock); chn->state = ECS_UNBOUND; if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF ) chn->u.unbound.remote_domid = current->domain->domain_id; evtchn_port_init(d, chn); spin_unlock(&chn->lock); alloc->port = port; out: check_free_port(d, port); spin_unlock(&d->event_lock); rcu_unlock_domain(d); return rc; }"
"ssize_t netio_recv(netio_desc_t *nio,void *pkt,size_t max_len) { ssize_t len; int res; if (!nio) return(-1); if ((len = nio->recv(nio->dptr,pkt,max_len)) <= 0) return(-1); if (nio->debug) { printf(""NIO %s: receiving a packet of %ld bytes:\n"",nio->name,(long)len); mem_dump(stdout,pkt,len); } if (nio->rx_filter != NULL) { res = nio->rx_filter->pkt_handler(nio,pkt,len,nio->rx_filter_data); if (res == NETIO_FILTER_ACTION_DROP) return(-1); } if (nio->both_filter != NULL) { res = nio->both_filter->pkt_handler(nio,pkt,len,nio->both_filter_data); if (res == NETIO_FILTER_ACTION_DROP) return(-1); } nio->stats_pkts_in++; nio->stats_bytes_in += len; return(len); }"
"static void print_maps(struct pid_info_t* info) { FILE *maps; size_t offset; char device[10]; long int inode; char file[PATH_MAX]; strlcat(info->path, ""maps"", sizeof(info->path)); maps = fopen(info->path, ""r""); if (!maps) goto out; while (fscanf(maps, ""%*x-%*x %*s %zx %s %ld %s\n"", &offset, device, &inode, file) == 4) { if (inode == 0 || !strcmp(device, ""00:00"")) continue; printf(""%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\n"", info->cmdline, info->pid, info->user, ""mem"", ""???"", device, offset, inode, file); } fclose(maps); out: info->path[info->parent_length] = '\0'; }"
"bool ConstantFolding::SimplifyReshape(const GraphProperties& properties, bool use_shape_info, NodeDef* node) { if (!use_shape_info || node->attr().count(""T"") == 0 || !IsSimplifiableReshape(*node, properties)) { return false; } DataType output_type = node->attr().at(""T"").type(); node->set_op(""Identity""); EraseRegularNodeAttributes(node); (*node->mutable_attr())[""T""].set_type(output_type); *node->mutable_input(1) = AsControlDependency(node->input(1)); return true; }"
"static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) { RAnalRef *xref; RListIter *xrefIter; if (!curAddress || curAddress == UT64_MAX) { return false; } if (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) { return false; } RList *xrefs = r_anal_xrefs_get (context->anal, curAddress); if (r_list_empty (xrefs)) { r_list_free (xrefs); return false; } r_list_foreach (xrefs, xrefIter, xref) { if (vtable_addr_in_text_section (context, xref->addr)) { ut8 buf[VTABLE_BUFF_SIZE]; context->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf)); RAnalOp analop = {0}; r_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC); if (analop.type == R_ANAL_OP_TYPE_MOV || analop.type == R_ANAL_OP_TYPE_LEA) { r_list_free (xrefs); r_anal_op_fini (&analop); return true; } r_anal_op_fini (&analop); } } r_list_free (xrefs); return false; }"
"static int nut_read_header(AVFormatContext *s) { NUTContext *nut = s->priv_data; AVIOContext *bc = s->pb; int64_t pos; int initialized_stream_count; nut->avf = s; pos = 0; do { pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, ""No main startcode found.\n""); return AVERROR_INVALIDDATA; } } while (decode_main_header(nut) < 0); pos = 0; for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) { pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1; if (pos < 0 + 1) { av_log(s, AV_LOG_ERROR, ""Not all stream headers found.\n""); return AVERROR_INVALIDDATA; } if (decode_stream_header(nut) >= 0) initialized_stream_count++; } pos = 0; for (;;) { uint64_t startcode = find_any_startcode(bc, pos); pos = avio_tell(bc); if (startcode == 0) { av_log(s, AV_LOG_ERROR, ""EOF before video frames\n""); return AVERROR_INVALIDDATA; } else if (startcode == SYNCPOINT_STARTCODE) { nut->next_startcode = startcode; break; } else if (startcode != INFO_STARTCODE) { continue; } decode_info_header(nut); } ffformatcontext(s)->data_offset = pos - 8; if (bc->seekable & AVIO_SEEKABLE_NORMAL) { int64_t orig_pos = avio_tell(bc); find_and_decode_index(nut); avio_seek(bc, orig_pos, SEEK_SET); } av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE); ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv); return 0; }"
"static void svg_process_media_href(GF_SVG_Parser *parser, GF_Node *elt, XMLRI *iri) { u32 tag = gf_node_get_tag(elt); if ((tag==TAG_SVG_image) || (tag==TAG_SVG_video) || (tag==TAG_SVG_audio)) { SVG_SAFExternalStream *st = svg_saf_get_stream(parser, 0, iri->string+1); if (!st && !strnicmp(iri->string, ""stream:"", 7)) st = svg_saf_get_stream(parser, 0, iri->string+7); if (st) { gf_free(iri->string); iri->string = NULL; iri->lsr_stream_id = st->id; iri->type = XMLRI_STREAMID; return; } } if ((parser->load->flags & GF_SM_LOAD_EMBEDS_RES) && (iri->type==XMLRI_STRING) ) { u32 size; char *buffer; GF_Err e = gf_file_load_data(iri->string, (u8 **) &buffer, &size); if (e) return; if (tag==TAG_SVG_script) { GF_DOMText *dtext; GF_DOMAttribute *att, *prev; buffer[size]=0; dtext = gf_dom_add_text_node(elt, buffer); dtext->type = GF_DOM_TEXT_CDATA; gf_free(iri->string); iri->string=NULL; att = ((GF_DOMNode*)elt)->attributes; prev = NULL; while(att) { if (att->tag!=TAG_XLINK_ATT_href) { prev = att; att = att->next; continue; } gf_svg_delete_attribute_value(att->data_type, att->data, elt->sgprivate->scenegraph); if (prev) prev->next = att->next; else ((GF_DOMNode*)elt)->attributes = att->next; gf_free(att); break; } } else { char *mtype; char *buf64; u64 size64; char *ext; buf64 = (char *)gf_malloc((size_t)size*2); size64 = gf_base64_encode(buffer, (u32)size, buf64, (u32)size*2); buf64[size64] = 0; mtype = ""application/data""; ext = strchr(iri->string, '.'); if (ext) { if (!stricmp(ext, "".png"")) mtype = ""image/png""; if (!stricmp(ext, "".jpg"") || !stricmp(ext, "".jpeg"")) mtype = ""image/jpg""; } gf_free(iri->string); iri->string = (char *)gf_malloc(sizeof(char)*(40+(size_t)size64)); sprintf(iri->string, ""data:%s;base64,%s"", mtype, buf64); gf_free(buf64); gf_free(buffer); } } }"
"static void dissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) { gboolean        is_request; proto_tree      *imap_tree, *reqresp_tree; proto_item      *ti, *hidden_item; gint            offset = 0; gint            uid_offset = 0; gint            folder_offset = 0; const guchar    *line; const guchar    *uid_line; const guchar    *folder_line; gint            next_offset; int             linelen; int             tokenlen; int             uid_tokenlen; int             folder_tokenlen; const guchar    *next_token; const guchar    *uid_next_token; const guchar    *folder_next_token; guchar          *tokenbuf; guchar          *command_token; int             iter; int             commandlen; conversation_t *conversation; imap_state_t   *session_state; conversation = find_or_create_conversation(pinfo); session_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap); if (!session_state) { session_state = wmem_new0(wmem_file_scope(), imap_state_t); session_state->ssl_requested = FALSE; conversation_add_proto_data(conversation, proto_imap, session_state); } tokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER); command_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER); commandlen = 0; folder_offset = 0; folder_tokenlen = 0; folder_line = NULL; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""IMAP""); if (pinfo->match_uint == pinfo->destport) is_request = TRUE; else is_request = FALSE; linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE); line = tvb_get_ptr(tvb, offset, linelen); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s: %s"", is_request ? ""Request"" : ""Response"", format_text(line, linelen)); { ti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA); imap_tree = proto_item_add_subtree(ti, ett_imap); hidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request); PROTO_ITEM_SET_HIDDEN(hidden_item); while(tvb_offset_exists(tvb, offset)) { linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE); line = tvb_get_ptr(tvb, offset, linelen); ti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA); reqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp); if ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) { tokenlen = get_token_len(line, line + linelen, &next_token); if (tokenlen != 0) { proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA); offset += (gint) (next_token - line); linelen -= (int) (next_token - line); line = next_token; } tokenlen = get_token_len(line, line + linelen, &next_token); if (tokenlen != 0) { for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) { tokenbuf[iter] = g_ascii_tolower(line[iter]); } if (tree && is_request && strncmp(tokenbuf, ""uid"", tokenlen) == 0) { proto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA); uid_offset = offset; uid_offset += (gint) (next_token - line); uid_line = next_token; uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token); if (tokenlen != 0) { proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA); for (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) { command_token[iter] = g_ascii_tolower(uid_line[iter]); } commandlen = uid_tokenlen; folder_offset = uid_offset; folder_offset += (gint) (uid_next_token - uid_line); folder_line = uid_next_token; folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token); } } else { proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA); if (is_request) { for (iter = 0; iter < tokenlen && iter < 256; iter++) { command_token[iter] = g_ascii_tolower(line[iter]); } commandlen = tokenlen; folder_offset = offset; folder_offset += (gint) (next_token - line); folder_line = next_token; folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token); } } if (tree && commandlen > 0 && ( strncmp(command_token, ""select"", commandlen) == 0 || strncmp(command_token, ""examine"", commandlen) == 0 || strncmp(command_token, ""create"", commandlen) == 0 || strncmp(command_token, ""delete"", commandlen) == 0 || strncmp(command_token, ""rename"", commandlen) == 0 || strncmp(command_token, ""subscribe"", commandlen) == 0 || strncmp(command_token, ""unsubscribe"", commandlen) == 0 || strncmp(command_token, ""status"", commandlen) == 0 || strncmp(command_token, ""append"", commandlen) == 0 || strncmp(command_token, ""search"", commandlen) == 0)) { if (folder_tokenlen != 0) proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA); } if (tree && is_request && (NULL != folder_line) && strncmp(command_token, ""copy"", commandlen) == 0) { folder_offset += (gint) (folder_next_token - folder_line); folder_line = folder_next_token; folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token); if (folder_tokenlen != 0) proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA); } if (session_state->ssl_requested) { if (!is_request && session_state->ssl_requested && strncmp(tokenbuf, ""ok"", tokenlen) == 0) { ssl_starttls_ack(ssl_handle, pinfo, imap_handle); } session_state->ssl_requested = FALSE; } if (is_request && commandlen > 0 && strncmp(command_token, ""starttls"", commandlen) == 0) { session_state->ssl_requested = TRUE; } } if (linelen != 0) { proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA); } } offset = next_offset;  } } }"
"void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength) { int i; if(isCodingInverted){ for (i = 0; i < bufferLength; ++i) { xoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i]; } }else{ for (i = 0; i < bufferLength; ++i) { xoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])]; } } }"
"int RAND_DRBG_generate(RAND_DRBG *drbg, unsigned char *out, size_t outlen, int prediction_resistance, const unsigned char *adin, size_t adinlen) { int reseed_required = 0; if (drbg->state != DRBG_READY) { rand_drbg_restart(drbg, NULL, 0, 0); if (drbg->state == DRBG_ERROR) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_IN_ERROR_STATE); return 0; } if (drbg->state == DRBG_UNINITIALISED) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_NOT_INSTANTIATED); return 0; } } if (outlen > drbg->max_request) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_REQUEST_TOO_LARGE_FOR_DRBG); return 0; } if (adinlen > drbg->max_adinlen) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_ADDITIONAL_INPUT_TOO_LONG); return 0; } if (drbg->fork_count != rand_fork_count) { drbg->fork_count = rand_fork_count; reseed_required = 1; } if (drbg->reseed_interval > 0) { if (drbg->reseed_gen_counter >= drbg->reseed_interval) reseed_required = 1; } if (drbg->reseed_time_interval > 0) { time_t now = time(NULL); if (now < drbg->reseed_time || now - drbg->reseed_time >= drbg->reseed_time_interval) reseed_required = 1; } if (drbg->parent != NULL) { unsigned int reseed_counter = tsan_load(&drbg->reseed_prop_counter); if (reseed_counter > 0 && tsan_load(&drbg->parent->reseed_prop_counter) != reseed_counter) reseed_required = 1; } if (reseed_required || prediction_resistance) { if (!RAND_DRBG_reseed(drbg, adin, adinlen, prediction_resistance)) { RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_RESEED_ERROR); return 0; } adin = NULL; adinlen = 0; } if (!drbg->meth->generate(drbg, out, outlen, adin, adinlen)) { drbg->state = DRBG_ERROR; RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_GENERATE_ERROR); return 0; } drbg->reseed_gen_counter++; return 1; }"
"int packet_kexdh(const char *keydir, struct buf *b1, struct buf *b2) { unsigned char clientpk[sshcrypto_kem_PUBLICKEYMAX]; unsigned char serverpk[sshcrypto_kem_CIPHERTEXTMAX]; unsigned char sharedsecret[sshcrypto_kem_MAX]; unsigned char sm[sshcrypto_sign_MAX]; unsigned char key[sshcrypto_cipher_KEYMAX]; unsigned char hash[sshcrypto_hash_MAX]; long long pos = 0; crypto_uint8 ch; crypto_uint32 len; long long i; if (packet.kex_packet_follows && !packet.kex_guess) { buf_purge(b1); if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0; } buf_purge(b1); if (!packet_getall(b1, SSH_MSG_KEXDH_INIT)) return 0; pos = packetparser_uint8(b1->buf, b1->len, pos, &ch);            if (ch != SSH_MSG_KEXDH_INIT) bug_proto(); pos = packetparser_uint32(b1->buf, b1->len, pos, &len);          if (len != sshcrypto_kem_publickeybytes) bug_proto(); pos = packetparser_copy(b1->buf, b1->len, pos, clientpk, len); pos = packetparser_end(b1->buf, b1->len, pos); buf_purge(b1); do {  if (sshcrypto_enc(serverpk, sharedsecret, clientpk) != 0) bug_proto(); } while(sharedsecret[0] == 0 && sshcrypto_kem_publickeybytes == 32); buf_purge(&packet.hashbuf); buf_putstringlen(&packet.hashbuf, packet.helloreceive.buf, packet.helloreceive.len); buf_putstringlen(&packet.hashbuf, packet.hellosend.buf, packet.hellosend.len); buf_putstringlen(&packet.hashbuf, packet.kexrecv.buf, packet.kexrecv.len); buf_putstringlen(&packet.hashbuf, packet.kexsend.buf, packet.kexsend.len); sshcrypto_buf_putsignpk(&packet.hashbuf, sshcrypto_sign_publickey); buf_putstringlen(&packet.hashbuf, clientpk, sshcrypto_kem_publickeybytes); buf_putstringlen(&packet.hashbuf, serverpk, sshcrypto_kem_ciphertextbytes); sshcrypto_buf_putkemkey(&packet.hashbuf, sharedsecret); sshcrypto_hash(hash, packet.hashbuf.buf, packet.hashbuf.len); if (!packet.flagrekeying) byte_copy(packet.sessionid, sshcrypto_hash_bytes, hash); packet.flagrekeying = 1; if (subprocess_sign(sm, sshcrypto_sign_bytes, keydir, hash, sshcrypto_hash_bytes) != 0) return 0; buf_purge(b1); buf_purge(b2); buf_putnum8(b2, SSH_MSG_KEXDH_REPLY);                            sshcrypto_buf_putsignpk(b2, sshcrypto_sign_publickey);           buf_putstringlen(b2, serverpk, sshcrypto_kem_ciphertextbytes);   sshcrypto_buf_putsignature(b2, sm);                              packet_put(b2); buf_purge(b2); buf_putnum8(b2, SSH_MSG_NEWKEYS); packet_put(b2); if (!packet_sendall()) return 0; do { buf_purge(b2); if (!packet_getall(b2, 0)) return 0; } while (b2->buf[0] != SSH_MSG_NEWKEYS); for(i = 0; i < 6; ++i) { buf_purge(b1); sshcrypto_buf_putkemkey(b1, sharedsecret); buf_put(b1, hash, sshcrypto_hash_bytes); buf_putnum8(b1, 'A' + i); buf_put(b1, packet.sessionid, sshcrypto_hash_bytes); sshcrypto_hash(key, b1->buf, b1->len); buf_purge(b1); sshcrypto_buf_putkemkey(b1, sharedsecret); buf_put(b1, hash, sshcrypto_hash_bytes); buf_put(b1, key, sshcrypto_hash_bytes); sshcrypto_hash(key + sshcrypto_hash_bytes, b1->buf, b1->len); if (i == 0) byte_copy(packet.clientnonce, sshcrypto_cipher_KEYMAX, key); if (i == 1) byte_copy(packet.servernonce, sshcrypto_cipher_KEYMAX, key); if (i == 2) byte_copy(packet.clientkey, sshcrypto_cipher_KEYMAX, key); if (i == 3) byte_copy(packet.serverkey, sshcrypto_cipher_KEYMAX, key); if (i == 4) byte_copy(packet.clientmackey, sshcrypto_cipher_KEYMAX, key); if (i == 5) byte_copy(packet.servermackey, sshcrypto_cipher_KEYMAX, key); } purge(clientpk, sizeof clientpk); purge(serverpk, sizeof serverpk); purge(sharedsecret, sizeof sharedsecret); purge(sm, sizeof sm); purge(key, sizeof key); purge(hash, sizeof hash); return 1; }"
"static int smtp_open(struct Connection *conn, bool esmtp) { int rc; if (mutt_socket_open(conn)) return -1; rc = smtp_get_resp(conn); if (rc != 0) return rc; rc = smtp_helo(conn, esmtp); if (rc != 0) return rc; #ifdef USE_SSL enum QuadOption ans = MUTT_NO; if (conn->ssf) ans = MUTT_NO; else if (C_SslForceTls) ans = MUTT_YES; else if ((Capabilities & SMTP_CAP_STARTTLS) && ((ans = query_quadoption(C_SslStarttls, _(""Secure connection with TLS?""))) == MUTT_ABORT)) { return -1; } if (ans == MUTT_YES) { if (mutt_socket_send(conn, ""STARTTLS\r\n"") < 0) return SMTP_ERR_WRITE; rc = smtp_get_resp(conn); if (rc != 0) return rc; if (mutt_ssl_starttls(conn)) { mutt_error(_(""Could not negotiate TLS connection"")); return -1; } rc = smtp_helo(conn, esmtp); if (rc != 0) return rc; } #endif if (conn->account.flags & MUTT_ACCT_USER) { if (!(Capabilities & SMTP_CAP_AUTH)) { mutt_error(_(""SMTP server does not support authentication"")); return -1; } return smtp_auth(conn); } return 0; }"
"ServerSecurityFeature::ServerSecurityFeature( application_features::ApplicationServer& server) : ApplicationFeature(server, ""ServerSecurity""), _enableFoxxApi(true), _enableFoxxStore(true), _hardenedRestApi(false) { setOptional(false); startsAfter<application_features::GreetingsFeaturePhase>(); }"
"void cfile_open_failure_message(const char *progname, const char *filename, int err, gchar *err_info) { char *file_description; file_description = input_file_description(filename); if (err < 0) { switch (err) { case WTAP_ERR_NOT_REGULAR_FILE: cmdarg_err(""The %s is a \""special file\"" or socket or other non-regular file."", file_description); break; case WTAP_ERR_RANDOM_OPEN_PIPE: cmdarg_err(""The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode."", file_description, progname); break; case WTAP_ERR_FILE_UNKNOWN_FORMAT: cmdarg_err(""The %s isn't a capture file in a format %s understands."", file_description, progname); break; case WTAP_ERR_UNSUPPORTED: cmdarg_err(""The %s contains record data that %s doesn't support.\n"" ""(%s)"", file_description, progname, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED: cmdarg_err(""The %s is a capture for a network type that %s doesn't support."", file_description, progname); break; case WTAP_ERR_BAD_FILE: cmdarg_err(""The %s appears to be damaged or corrupt.\n"" ""(%s)"", file_description, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; case WTAP_ERR_CANT_OPEN: cmdarg_err(""The %s could not be opened for some unknown reason."", file_description); break; case WTAP_ERR_SHORT_READ: cmdarg_err(""The %s appears to have been cut short in the middle of a packet or other data."", file_description); break; case WTAP_ERR_DECOMPRESS: cmdarg_err(""The %s cannot be decompressed; it may be damaged or corrupt."" ""(%s)"", file_description, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; default: cmdarg_err(""The %s could not be opened: %s."", file_description, wtap_strerror(err)); break; } g_free(file_description); } else cmdarg_err(file_open_error_message(err, FALSE), filename); }"
"void PendingScript::notifyFinished(Resource* resource) { if (m_element) { ASSERT(resource->type() == Resource::Script); ScriptResource* scriptResource = toScriptResource(resource); String integrityAttr = m_element->fastGetAttribute(HTMLNames::integrityAttr); if (!integrityAttr.isEmpty() && !scriptResource->integrityMetadata().isEmpty()) { if (!scriptResource->integrityAlreadyChecked() && resource->resourceBuffer()) { scriptResource->setIntegrityAlreadyChecked(true); m_integrityFailure = !SubresourceIntegrity::CheckSubresourceIntegrity(scriptResource->integrityMetadata(), *m_element, resource->resourceBuffer()->data(), resource->resourceBuffer()->size(), resource->url(), *resource); } } } if (m_streamer) m_streamer->notifyFinished(resource); }"
"static MagickBooleanType WritePCXImage(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { MagickBooleanType status; MagickOffsetType offset, *page_table, scene; MemoryInfo *pixel_info; PCXInfo pcx_info; register const Quantum *p; register ssize_t i, x; register unsigned char *q; size_t length; ssize_t y; unsigned char *pcx_colormap, *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); (void) TransformImageColorspace(image,sRGBColorspace,exception); page_table=(MagickOffsetType *) NULL; if ((LocaleCompare(image_info->magick,""DCX"") == 0) || ((GetNextImageInList(image) != (Image *) NULL) && (image_info->adjoin != MagickFalse))) { (void) WriteBlobLSBLong(image,0x3ADE68B1L); page_table=(MagickOffsetType *) AcquireQuantumMemory(1024UL, sizeof(*page_table)); if (page_table == (MagickOffsetType *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); for (scene=0; scene < 1024; scene++) (void) WriteBlobLSBLong(image,0x00000000L); } scene=0; do { if (page_table != (MagickOffsetType *) NULL) page_table[scene]=TellBlob(image); pcx_info.identifier=0x0a; pcx_info.version=5; pcx_info.encoding=image_info->compression == NoCompression ? 0 : 1; pcx_info.bits_per_pixel=8; if ((image->storage_class == PseudoClass) && (SetImageMonochrome(image,exception) != MagickFalse)) pcx_info.bits_per_pixel=1; pcx_info.left=0; pcx_info.top=0; pcx_info.right=(unsigned short) (image->columns-1); pcx_info.bottom=(unsigned short) (image->rows-1); switch (image->units) { case UndefinedResolution: case PixelsPerInchResolution: default: { pcx_info.horizontal_resolution=(unsigned short) image->resolution.x; pcx_info.vertical_resolution=(unsigned short) image->resolution.y; break; } case PixelsPerCentimeterResolution: { pcx_info.horizontal_resolution=(unsigned short) (2.54*image->resolution.x+0.5); pcx_info.vertical_resolution=(unsigned short) (2.54*image->resolution.y+0.5); break; } } pcx_info.reserved=0; pcx_info.planes=1; if ((image->storage_class == DirectClass) || (image->colors > 256)) { pcx_info.planes=3; if (image->alpha_trait != UndefinedPixelTrait) pcx_info.planes++; } pcx_info.bytes_per_line=(unsigned short) (((size_t) image->columns* pcx_info.bits_per_pixel+7)/8); pcx_info.palette_info=1; pcx_info.colormap_signature=0x0c; (void) WriteBlobByte(image,pcx_info.identifier); (void) WriteBlobByte(image,pcx_info.version); (void) WriteBlobByte(image,pcx_info.encoding); (void) WriteBlobByte(image,pcx_info.bits_per_pixel); (void) WriteBlobLSBShort(image,pcx_info.left); (void) WriteBlobLSBShort(image,pcx_info.top); (void) WriteBlobLSBShort(image,pcx_info.right); (void) WriteBlobLSBShort(image,pcx_info.bottom); (void) WriteBlobLSBShort(image,pcx_info.horizontal_resolution); (void) WriteBlobLSBShort(image,pcx_info.vertical_resolution); pcx_colormap=(unsigned char *) AcquireQuantumMemory(256UL, 3*sizeof(*pcx_colormap)); if (pcx_colormap == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); (void) memset(pcx_colormap,0,3*256*sizeof(*pcx_colormap)); q=pcx_colormap; if ((image->storage_class == PseudoClass) && (image->colors <= 256)) for (i=0; i < (ssize_t) image->colors; i++) { *q++=ScaleQuantumToChar(image->colormap[i].red); *q++=ScaleQuantumToChar(image->colormap[i].green); *q++=ScaleQuantumToChar(image->colormap[i].blue); } (void) WriteBlob(image,3*16,(const unsigned char *) pcx_colormap); (void) WriteBlobByte(image,pcx_info.reserved); (void) WriteBlobByte(image,pcx_info.planes); (void) WriteBlobLSBShort(image,pcx_info.bytes_per_line); (void) WriteBlobLSBShort(image,pcx_info.palette_info); for (i=0; i < 58; i++) (void) WriteBlobByte(image,'\0'); length=(size_t) pcx_info.bytes_per_line; pixel_info=AcquireVirtualMemory(length,pcx_info.planes*sizeof(*pixels)); if (pixel_info == (MemoryInfo *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info); q=pixels; if ((image->storage_class == DirectClass) || (image->colors > 256)) { for (y=0; y < (ssize_t) image->rows; y++) { q=pixels; for (i=0; i < pcx_info.planes; i++) { p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; switch ((int) i) { case 0: { for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++) { *q++=ScaleQuantumToChar(GetPixelRed(image,p)); p+=GetPixelChannels(image); } break; } case 1: { for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++) { *q++=ScaleQuantumToChar(GetPixelGreen(image,p)); p+=GetPixelChannels(image); } break; } case 2: { for (x=0; x < (ssize_t) pcx_info.bytes_per_line; x++) { *q++=ScaleQuantumToChar(GetPixelBlue(image,p)); p+=GetPixelChannels(image); } break; } case 3: default: { for (x=(ssize_t) pcx_info.bytes_per_line; x != 0; x--) { *q++=ScaleQuantumToChar((Quantum) (GetPixelAlpha(image,p))); p+=GetPixelChannels(image); } break; } } } if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } else { if (pcx_info.bits_per_pixel > 1) for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; q=pixels; for (x=0; x < (ssize_t) image->columns; x++) { *q++=(unsigned char) GetPixelIndex(image,p); p+=GetPixelChannels(image); } if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } else { register unsigned char bit, byte; for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; bit=0; byte=0; q=pixels; for (x=0; x < (ssize_t) image->columns; x++) { byte<<=1; if (GetPixelLuma(image,p) >= (QuantumRange/2.0)) byte|=0x01; bit++; if (bit == 8) { *q++=byte; bit=0; byte=0; } p+=GetPixelChannels(image); } if (bit != 0) *q++=byte << (8-bit); if (PCXWritePixels(&pcx_info,pixels,image) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,image->rows); if (status == MagickFalse) break; } } } (void) WriteBlobByte(image,pcx_info.colormap_signature); (void) WriteBlob(image,3*256,pcx_colormap); } pixel_info=RelinquishVirtualMemory(pixel_info); pcx_colormap=(unsigned char *) RelinquishMagickMemory(pcx_colormap); if (page_table == (MagickOffsetType *) NULL) break; if (scene >= 1023) break; if (GetNextImageInList(image) == (Image *) NULL) break; image=SyncNextImageInList(image); status=SetImageProgress(image,SaveImagesTag,scene++, GetImageListLength(image)); if (status == MagickFalse) break; } while (image_info->adjoin != MagickFalse); if (page_table != (MagickOffsetType *) NULL) { page_table[scene+1]=0; offset=SeekBlob(image,0L,SEEK_SET); if (offset < 0) ThrowWriterException(CorruptImageError,""ImproperImageHeader""); (void) WriteBlobLSBLong(image,0x3ADE68B1L); for (i=0; i <= (ssize_t) scene; i++) (void) WriteBlobLSBLong(image,(unsigned int) page_table[i]); page_table=(MagickOffsetType *) RelinquishMagickMemory(page_table); } if (status == MagickFalse) { char *message; message=GetExceptionMessage(errno); (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError, ""UnableToWriteFile"",""`%s': %s"",image->filename,message); message=DestroyString(message); } (void) CloseBlob(image); return(MagickTrue); }"
"int cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr, struct usb_interface *intf, u8 *buffer, int buflen) { struct usb_cdc_union_desc *union_header = NULL; struct usb_cdc_header_desc *header = NULL; struct usb_cdc_ether_desc *ether = NULL; struct usb_cdc_mdlm_detail_desc *detail = NULL; struct usb_cdc_mdlm_desc *desc = NULL; unsigned int elength; int cnt = 0; memset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header)); hdr->phonet_magic_present = false; while (buflen > 0) { elength = buffer[0]; if (!elength) { dev_err(&intf->dev, ""skipping garbage byte\n""); elength = 1; goto next_desc; } if (buffer[1] != USB_DT_CS_INTERFACE) { dev_err(&intf->dev, ""skipping garbage\n""); goto next_desc; } switch (buffer[2]) { case USB_CDC_UNION_TYPE:  if (elength < sizeof(struct usb_cdc_union_desc)) goto next_desc; if (union_header) { dev_err(&intf->dev, ""More than one union descriptor, skipping ...\n""); goto next_desc; } union_header = (struct usb_cdc_union_desc *)buffer; break; case USB_CDC_COUNTRY_TYPE: if (elength < sizeof(struct usb_cdc_country_functional_desc)) goto next_desc; hdr->usb_cdc_country_functional_desc = (struct usb_cdc_country_functional_desc *)buffer; break; case USB_CDC_HEADER_TYPE: if (elength != sizeof(struct usb_cdc_header_desc)) goto next_desc; if (header) return -EINVAL; header = (struct usb_cdc_header_desc *)buffer; break; case USB_CDC_ACM_TYPE: if (elength < sizeof(struct usb_cdc_acm_descriptor)) goto next_desc; hdr->usb_cdc_acm_descriptor = (struct usb_cdc_acm_descriptor *)buffer; break; case USB_CDC_ETHERNET_TYPE: if (elength != sizeof(struct usb_cdc_ether_desc)) goto next_desc; if (ether) return -EINVAL; ether = (struct usb_cdc_ether_desc *)buffer; break; case USB_CDC_CALL_MANAGEMENT_TYPE: if (elength < sizeof(struct usb_cdc_call_mgmt_descriptor)) goto next_desc; hdr->usb_cdc_call_mgmt_descriptor = (struct usb_cdc_call_mgmt_descriptor *)buffer; break; case USB_CDC_DMM_TYPE: if (elength < sizeof(struct usb_cdc_dmm_desc)) goto next_desc; hdr->usb_cdc_dmm_desc = (struct usb_cdc_dmm_desc *)buffer; break; case USB_CDC_MDLM_TYPE: if (elength < sizeof(struct usb_cdc_mdlm_desc *)) goto next_desc; if (desc) return -EINVAL; desc = (struct usb_cdc_mdlm_desc *)buffer; break; case USB_CDC_MDLM_DETAIL_TYPE: if (elength < sizeof(struct usb_cdc_mdlm_detail_desc *)) goto next_desc; if (detail) return -EINVAL; detail = (struct usb_cdc_mdlm_detail_desc *)buffer; break; case USB_CDC_NCM_TYPE: if (elength < sizeof(struct usb_cdc_ncm_desc)) goto next_desc; hdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer; break; case USB_CDC_MBIM_TYPE: if (elength < sizeof(struct usb_cdc_mbim_desc)) goto next_desc; hdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer; break; case USB_CDC_MBIM_EXTENDED_TYPE: if (elength < sizeof(struct usb_cdc_mbim_extended_desc)) break; hdr->usb_cdc_mbim_extended_desc = (struct usb_cdc_mbim_extended_desc *)buffer; break; case CDC_PHONET_MAGIC_NUMBER: hdr->phonet_magic_present = true; break; default: dev_dbg(&intf->dev, ""Ignoring descriptor: type %02x, length %ud\n"", buffer[2], elength); goto next_desc; } cnt++; next_desc: buflen -= elength; buffer += elength; } hdr->usb_cdc_union_desc = union_header; hdr->usb_cdc_header_desc = header; hdr->usb_cdc_mdlm_detail_desc = detail; hdr->usb_cdc_mdlm_desc = desc; hdr->usb_cdc_ether_desc = ether; return cnt; }"
"void ImportEPUB::ExtractContainer() { int res = 0; if (!cp437) { cp437 = new QCodePage437Codec(); } #ifdef Q_OS_WIN32 zlib_filefunc64_def ffunc; fill_win32_filefunc64W(&ffunc); unzFile zfile = unzOpen2_64(Utility::QStringToStdWString(QDir::toNativeSeparators(m_FullFilePath)).c_str(), &ffunc); #else unzFile zfile = unzOpen64(QDir::toNativeSeparators(m_FullFilePath).toUtf8().constData()); #endif if (zfile == NULL) { throw (EPUBLoadParseError(QString(QObject::tr(""Cannot unzip EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString())); } res = unzGoToFirstFile(zfile); if (res == UNZ_OK) { do { char file_name[MAX_PATH] = {0}; unz_file_info64 file_info; unzGetCurrentFileInfo64(zfile, &file_info, file_name, MAX_PATH, NULL, 0, NULL, 0); QString qfile_name; QString cp437_file_name; qfile_name = QString::fromUtf8(file_name); if (!(file_info.flag & (1<<11))) { cp437_file_name = cp437->toUnicode(file_name); } if (!qfile_name.isEmpty()) { qfile_name = qfile_name.replace(""../"",""""); cp437_file_name = cp437_file_name.replace(""../"",""""); QDir dir(m_ExtractedFolderPath); QString file_path = m_ExtractedFolderPath + ""/"" + qfile_name; QFileInfo qfile_info(file_path); if (file_info.uncompressed_size == 0 && qfile_name.endsWith('/')) { dir.mkpath(qfile_name); continue; } else { dir.mkpath(qfile_info.path()); if (cp437_file_name.isEmpty()) { m_ZipFilePaths << qfile_name; } else { m_ZipFilePaths << cp437_file_name; } } if (unzOpenCurrentFile(zfile) != UNZ_OK) { unzClose(zfile); throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString())); } QFile entry(file_path); if (!entry.open(QIODevice::WriteOnly | QIODevice::Truncate)) { unzCloseCurrentFile(zfile); unzClose(zfile); throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString())); } char buff[BUFF_SIZE] = {0}; int read = 0; while ((read = unzReadCurrentFile(zfile, buff, BUFF_SIZE)) > 0) { entry.write(buff, read); } entry.close(); if (read < 0) { unzCloseCurrentFile(zfile); unzClose(zfile); throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString())); } if (unzCloseCurrentFile(zfile) == UNZ_CRCERROR) { unzClose(zfile); throw (EPUBLoadParseError(QString(QObject::tr(""Cannot extract file: %1"")).arg(qfile_name).toStdString())); } if (!cp437_file_name.isEmpty() && cp437_file_name != qfile_name) { QString cp437_file_path = m_ExtractedFolderPath + ""/"" + cp437_file_name; QFile::copy(file_path, cp437_file_path); } } } while ((res = unzGoToNextFile(zfile)) == UNZ_OK); } if (res != UNZ_END_OF_LIST_OF_FILE) { unzClose(zfile); throw (EPUBLoadParseError(QString(QObject::tr(""Cannot open EPUB: %1"")).arg(QDir::toNativeSeparators(m_FullFilePath)).toStdString())); } unzClose(zfile); }"
"static int smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args, const char *domain) { char   *p, *e; if (line == NULL) return (0); if (*line != '<') return (0); e = strchr(line, '>'); if (e == NULL) return (0); *e++ = '\0'; while (*e == ' ') e++; *args = e; if (!text_to_mailaddr(maddr, line + 1)) return (0); p = strchr(maddr->user, ':'); if (p != NULL) { p++; memmove(maddr->user, p, strlen(p) + 1); } if (!valid_localpart(maddr->user) || !valid_domainpart(maddr->domain)) { if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0') return (1); if (maddr->user[0] == '\0') return (0); if (maddr->domain[0] == '\0') { (void)strlcpy(maddr->domain, domain, sizeof(maddr->domain)); return (1); } return (0); } return (1); }"
"static int mwifiex_update_vs_ie(const u8 *ies, int ies_len, struct mwifiex_ie **ie_ptr, u16 mask, unsigned int oui, u8 oui_type) { struct ieee_types_header *vs_ie; struct mwifiex_ie *ie = *ie_ptr; const u8 *vendor_ie; vendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len); if (vendor_ie) { if (!*ie_ptr) { *ie_ptr = kzalloc(sizeof(struct mwifiex_ie), GFP_KERNEL); if (!*ie_ptr) return -ENOMEM; ie = *ie_ptr; } vs_ie = (struct ieee_types_header *)vendor_ie; memcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length), vs_ie, vs_ie->len + 2); le16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2); ie->mgmt_subtype_mask = cpu_to_le16(mask); ie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK); } *ie_ptr = ie; return 0; }"
"void gf_m2ts_flush_pes(GF_M2TS_Demuxer *ts, GF_M2TS_PES *pes, u32 force_flush_type) { GF_M2TS_PESHeader pesh; if (!ts) return; if ((pes->pck_data_len >= 4) && !pes->pck_data[0] && !pes->pck_data[1] && (pes->pck_data[2] == 0x1)) { u32 len; Bool has_pes_header = GF_TRUE; Bool has_data = GF_TRUE; u32 stream_id = pes->pck_data[3]; Bool same_pts = GF_FALSE; switch (stream_id) { case GF_M2_STREAMID_PADDING: has_data = GF_FALSE; case GF_M2_STREAMID_PROGRAM_STREAM_MAP: case GF_M2_STREAMID_PRIVATE_2: case GF_M2_STREAMID_ECM: case GF_M2_STREAMID_EMM: case GF_M2_STREAMID_PROGRAM_STREAM_DIRECTORY: case GF_M2_STREAMID_DSMCC: case GF_M2_STREAMID_H222_TYPE_E: has_pes_header = GF_FALSE; break; } if (has_pes_header) { gf_m2ts_pes_header(pes, pes->pck_data + 3, pes->pck_data_len - 3, &pesh); if (ts->notify_pes_timing) { GF_M2TS_PES_PCK pck; memset(&pck, 0, sizeof(GF_M2TS_PES_PCK)); pck.PTS = pesh.PTS; pck.DTS = pesh.DTS; pck.stream = pes; if (pes->rap) pck.flags |= GF_M2TS_PES_PCK_RAP; pes->pes_end_packet_number = ts->pck_number; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_PES_TIMING, &pck); } GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d Got PES header DTS %d PTS %d\n"", pes->pid, pesh.DTS, pesh.PTS)); if (pesh.PTS) { if (pesh.PTS == pes->PTS) { same_pts = GF_TRUE; if ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) { same_pts = GF_FALSE; } else if (!pes->is_resume) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - same PTS ""LLU"" for two consecutive PES packets \n"", pes->pid, pes->PTS)); } } #ifndef GPAC_DISABLE_LOG #endif pes->PTS = pesh.PTS; #ifndef GPAC_DISABLE_LOG { if (!pes->is_resume && pes->DTS && (pesh.DTS == pes->DTS)) { if ((pes->stream_type==GF_M2TS_AUDIO_TRUEHD) || (pes->stream_type==GF_M2TS_AUDIO_EC3)) { } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - same DTS ""LLU"" for two consecutive PES packets \n"", pes->pid, pes->DTS)); } } if (pesh.DTS < pes->DTS) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d - DTS ""LLU"" less than previous DTS ""LLU""\n"", pes->pid, pesh.DTS, pes->DTS)); } } #endif pes->DTS = pesh.DTS; } else if (!pesh.hdr_data_len) { same_pts = GF_TRUE; } pes->is_resume = GF_FALSE; len = 9 + pesh.hdr_data_len; } else { if (!has_data) goto exit; len = 4; memset(&pesh, 0, sizeof(pesh)); } if ((u8) pes->pck_data[3]==0xfa) { GF_M2TS_SL_PCK sl_pck; GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS] SL Packet in PES for %d - ES ID %d\n"", pes->pid, pes->mpeg4_es_id)); if (pes->pck_data_len > len) { sl_pck.data = (char *)pes->pck_data + len; sl_pck.data_len = pes->pck_data_len - len; sl_pck.stream = (GF_M2TS_ES *)pes; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_SL_PCK, &sl_pck); } else { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MPEG-2 TS] Bad SL Packet size: (%d indicated < %d header)\n"", pes->pid, pes->pck_data_len, len)); } goto exit; } if (pes->reframe) { u32 remain = 0; u32 offset = len; if (pesh.pck_len && (pesh.pck_len-3-pesh.hdr_data_len != pes->pck_data_len-len)) { if (!force_flush_type) { pes->is_resume = GF_TRUE; return; } if (force_flush_type==1) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d PES payload size %d but received %d bytes\n"", pes->pid, (u32) ( pesh.pck_len-3-pesh.hdr_data_len), pes->pck_data_len-len)); } } if (pes->prev_data_len) { if (pes->prev_data_len < len) { offset = len - pes->prev_data_len; memcpy(pes->pck_data + offset, pes->prev_data, pes->prev_data_len); } else { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PID %d PES reassembly buffer overflow (%d bytes not processed from previous PES) - discarding prev data\n"", pes->pid, pes->prev_data_len )); } } if (!pes->temi_pending && pes->temi_tc_desc_len) { gf_m2ts_store_temi(ts, pes); } if (pes->temi_pending) { pes->temi_pending = 0; pes->temi_tc.pes_pts = pes->PTS; pes->temi_tc.pid = pes->pid; if (ts->on_event) ts->on_event(ts, GF_M2TS_EVT_TEMI_TIMECODE, &pes->temi_tc); } if (! ts->seek_mode) remain = pes->reframe(ts, pes, same_pts, pes->pck_data+offset, pes->pck_data_len-offset, &pesh); if (pes->prev_data) gf_free(pes->prev_data); pes->prev_data = NULL; pes->prev_data_len = 0; if (remain) { pes->prev_data = gf_malloc(sizeof(char)*remain); assert(pes->pck_data_len >= remain); memcpy(pes->prev_data, pes->pck_data + pes->pck_data_len - remain, remain); pes->prev_data_len = remain; } } } else if (pes->pck_data_len) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MPEG-2 TS] PES %d: Bad PES Header, discarding packet (maybe stream is encrypted ?)\n"", pes->pid)); } exit: pes->pck_data_len = 0; pes->pes_len = 0; pes->rap = 0; }"
"static int numPartsWithin(int size, int part_size, int stride) { return (size - part_size + stride) / stride; }"
"PJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port( pjmedia_vid_conf *vid_conf, unsigned src_slot, unsigned sink_slot, void *opt) { vconf_port *src_port, *dst_port; unsigned i; PJ_ASSERT_RETURN(vid_conf && src_slot<vid_conf->opt.max_slot_cnt &&  sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL); PJ_UNUSED_ARG(opt); pj_mutex_lock(vid_conf->mutex); src_port = vid_conf->ports[src_slot]; dst_port = vid_conf->ports[sink_slot]; if (!src_port || !src_port->port->get_frame || !dst_port || !dst_port->port->put_frame) { PJ_LOG(4,(THIS_FILE,""Failed connecting video ports, make sure that "" ""source has get_frame() & sink has put_frame()"")); pj_mutex_unlock(vid_conf->mutex); return PJ_EINVAL; } for (i=0; i<src_port->listener_cnt; ++i) { if (src_port->listener_slots[i] == sink_slot) break; } if (i == src_port->listener_cnt) { src_port->listener_slots[src_port->listener_cnt] = sink_slot; dst_port->transmitter_slots[dst_port->transmitter_cnt] = src_slot; ++src_port->listener_cnt; ++dst_port->transmitter_cnt; if (src_port->listener_cnt == 1) { const pjmedia_video_format_info *vfi; pjmedia_video_apply_fmt_param vafp; vfi = pjmedia_get_video_format_info(NULL, src_port->port->info.fmt.id); pj_bzero(&vafp, sizeof(vafp)); vafp.size = src_port->port->info.fmt.det.vid.size; (*vfi->apply_fmt)(vfi, &vafp); if (vfi->color_model == PJMEDIA_COLOR_MODEL_RGB) { pj_memset(src_port->get_buf, 0, vafp.framebytes); } else if (src_port->port->info.fmt.id == PJMEDIA_FORMAT_I420 || src_port->port->info.fmt.id == PJMEDIA_FORMAT_YV12) {     pj_memset(src_port->get_buf, 16, vafp.plane_bytes[0]); pj_memset((pj_uint8_t*)src_port->get_buf + vafp.plane_bytes[0], 0x80, vafp.plane_bytes[1] * 2); } } update_render_state(vid_conf, dst_port); ++vid_conf->connect_cnt; if (vid_conf->connect_cnt == 1) { pj_status_t status; status = pjmedia_clock_start(vid_conf->clock); if (status != PJ_SUCCESS) { PJ_PERROR(4, (THIS_FILE, status, ""Failed to start clock"")); return status; } } PJ_LOG(4,(THIS_FILE,""Port %d (%.*s) transmitting to port %d (%.*s)"", src_slot, (int)src_port->name.slen, src_port->name.ptr, sink_slot, (int)dst_port->name.slen, dst_port->name.ptr)); } pj_mutex_unlock(vid_conf->mutex); return PJ_SUCCESS; }"
"void symmetric_difference (const hb_bit_set_invertible_t &other) { process (hb_bitwise_xor, other); inverted = inverted ^ other.inverted; }"
"void Compute(tensorflow::OpKernelContext* context) override { const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
"Object* Slow_ArrayConcat(Arguments* args, Handle<Object> species, Isolate* isolate) { int argument_count = args->length(); bool is_array_species = *species == isolate->context()->array_function(); ElementsKind kind = FAST_SMI_ELEMENTS; uint32_t estimate_result_length = 0; uint32_t estimate_nof_elements = 0; for (int i = 0; i < argument_count; i++) { HandleScope loop_scope(isolate); Handle<Object> obj((*args)[i], isolate); uint32_t length_estimate; uint32_t element_estimate; if (obj->IsJSArray()) { Handle<JSArray> array(Handle<JSArray>::cast(obj)); length_estimate = static_cast<uint32_t>(array->length()->Number()); if (length_estimate != 0) { ElementsKind array_kind = GetPackedElementsKind(array->map()->elements_kind()); kind = GetMoreGeneralElementsKind(kind, array_kind); } element_estimate = EstimateElementCount(array); } else { if (obj->IsHeapObject()) { if (obj->IsNumber()) { kind = GetMoreGeneralElementsKind(kind, FAST_DOUBLE_ELEMENTS); } else { kind = GetMoreGeneralElementsKind(kind, FAST_ELEMENTS); } } length_estimate = 1; element_estimate = 1; } if (JSObject::kMaxElementCount - estimate_result_length < length_estimate) { estimate_result_length = JSObject::kMaxElementCount; } else { estimate_result_length += length_estimate; } if (JSObject::kMaxElementCount - estimate_nof_elements < element_estimate) { estimate_nof_elements = JSObject::kMaxElementCount; } else { estimate_nof_elements += element_estimate; } } bool fast_case = is_array_species && (estimate_nof_elements * 2) >= estimate_result_length; if (fast_case && kind == FAST_DOUBLE_ELEMENTS) { Handle<FixedArrayBase> storage = isolate->factory()->NewFixedDoubleArray(estimate_result_length); int j = 0; bool failure = false; if (estimate_result_length > 0) { Handle<FixedDoubleArray> double_storage = Handle<FixedDoubleArray>::cast(storage); for (int i = 0; i < argument_count; i++) { Handle<Object> obj((*args)[i], isolate); if (obj->IsSmi()) { double_storage->set(j, Smi::cast(*obj)->value()); j++; } else if (obj->IsNumber()) { double_storage->set(j, obj->Number()); j++; } else { JSArray* array = JSArray::cast(*obj); uint32_t length = static_cast<uint32_t>(array->length()->Number()); switch (array->map()->elements_kind()) { case FAST_HOLEY_DOUBLE_ELEMENTS: case FAST_DOUBLE_ELEMENTS: { if (length == 0) break; FixedDoubleArray* elements = FixedDoubleArray::cast(array->elements()); for (uint32_t i = 0; i < length; i++) { if (elements->is_the_hole(i)) { failure = true; break; } double double_value = elements->get_scalar(i); double_storage->set(j, double_value); j++; } break; } case FAST_HOLEY_SMI_ELEMENTS: case FAST_SMI_ELEMENTS: { FixedArray* elements(FixedArray::cast(array->elements())); for (uint32_t i = 0; i < length; i++) { Object* element = elements->get(i); if (element->IsTheHole()) { failure = true; break; } int32_t int_value = Smi::cast(element)->value(); double_storage->set(j, int_value); j++; } break; } case FAST_HOLEY_ELEMENTS: case FAST_ELEMENTS: case DICTIONARY_ELEMENTS: case NO_ELEMENTS: DCHECK_EQ(0u, length); break; default: UNREACHABLE(); } } if (failure) break; } } if (!failure) { Handle<JSArray> array = isolate->factory()->NewJSArray(0); Smi* length = Smi::FromInt(j); Handle<Map> map; map = JSObject::GetElementsTransitionMap(array, kind); array->set_map(*map); array->set_length(length); array->set_elements(*storage); return *array; } } Handle<Object> storage; if (fast_case) { storage = isolate->factory()->NewFixedArrayWithHoles(estimate_result_length); } else if (is_array_species) { uint32_t at_least_space_for = estimate_nof_elements + (estimate_nof_elements >> 2); storage = SeededNumberDictionary::New(isolate, at_least_space_for); } else { DCHECK(species->IsConstructor()); Handle<Object> length(Smi::FromInt(0), isolate); Handle<Object> storage_object; ASSIGN_RETURN_FAILURE_ON_EXCEPTION( isolate, storage_object, Execution::New(isolate, species, species, 1, &length)); storage = storage_object; } ArrayConcatVisitor visitor(isolate, storage, fast_case); for (int i = 0; i < argument_count; i++) { Handle<Object> obj((*args)[i], isolate); Maybe<bool> spreadable = IsConcatSpreadable(isolate, obj); MAYBE_RETURN(spreadable, isolate->heap()->exception()); if (spreadable.FromJust()) { Handle<JSReceiver> object = Handle<JSReceiver>::cast(obj); if (!IterateElements(isolate, object, &visitor)) { return isolate->heap()->exception(); } } else { visitor.visit(0, obj); visitor.increase_index_offset(1); } } if (visitor.exceeds_array_limit()) { THROW_NEW_ERROR_RETURN_FAILURE( isolate, NewRangeError(MessageTemplate::kInvalidArrayLength)); } if (is_array_species) { return *visitor.ToArray(); } else { return *visitor.storage_jsreceiver(); } }"
"static uint8_t yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum, TSK_DADDR_T numblock, int32_t sec_skew) { TSK_FS_META *fs_meta; TSK_FS_FILE *fs_file; YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs; char ls[12]; YAFFSFS_PRINT_ADDR print; char timeBuf[32]; YaffsCacheObject * obj = NULL; YaffsCacheVersion * version = NULL; YaffsHeader * header = NULL; yaffscache_version_find_by_inode(yfs, inum, &version, &obj); if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) { return 1; } fs_meta = fs_file->meta; tsk_fprintf(hFile, ""inode: %"" PRIuINUM ""\n"", inum); tsk_fprintf(hFile, ""%sAllocated\n"", (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? """" : ""Not ""); if (fs_meta->link) tsk_fprintf(hFile, ""symbolic link to: %s\n"", fs_meta->link); tsk_fprintf(hFile, ""uid / gid: %"" PRIuUID "" / %"" PRIuGID ""\n"", fs_meta->uid, fs_meta->gid); tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls)); tsk_fprintf(hFile, ""mode: %s\n"", ls); tsk_fprintf(hFile, ""size: %"" PRIdOFF ""\n"", fs_meta->size); tsk_fprintf(hFile, ""num of links: %d\n"", fs_meta->nlink); if(version != NULL){ yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset); if(header != NULL){ tsk_fprintf(hFile, ""Name: %s\n"", header->name); } } if (sec_skew != 0) { tsk_fprintf(hFile, ""\nAdjusted Inode Times:\n""); fs_meta->mtime -= sec_skew; fs_meta->atime -= sec_skew; fs_meta->ctime -= sec_skew; tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); fs_meta->mtime += sec_skew; fs_meta->atime += sec_skew; fs_meta->ctime += sec_skew; tsk_fprintf(hFile, ""\nOriginal Inode Times:\n""); } else { tsk_fprintf(hFile, ""\nInode Times:\n""); } tsk_fprintf(hFile, ""Accessed:\t%s\n"", tsk_fs_time_to_str(fs_meta->atime, timeBuf)); tsk_fprintf(hFile, ""File Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->mtime, timeBuf)); tsk_fprintf(hFile, ""Inode Modified:\t%s\n"", tsk_fs_time_to_str(fs_meta->ctime, timeBuf)); if(version != NULL){ tsk_fprintf(hFile, ""\nHeader Chunk:\n""); tsk_fprintf(hFile, ""%"" PRIuDADDR ""\n"", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size))); } if (numblock > 0) { TSK_OFF_T lower_size = numblock * fs->block_size; fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size); } tsk_fprintf(hFile, ""\nData Chunks:\n""); if (flags & TSK_FS_ISTAT_RUNLIST){ const TSK_FS_ATTR *fs_attr_default = tsk_fs_file_attr_get_type(fs_file, TSK_FS_ATTR_TYPE_DEFAULT, 0, 0); if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) { if (tsk_fs_attr_print(fs_attr_default, hFile)) { tsk_fprintf(hFile, ""\nError creating run lists  ""); tsk_error_print(hFile); tsk_error_reset(); } } } else { print.idx = 0; print.hFile = hFile; if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY, (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) { tsk_fprintf(hFile, ""\nError reading file:  ""); tsk_error_print(hFile); tsk_error_reset(); } else if (print.idx != 0) { tsk_fprintf(hFile, ""\n""); } } tsk_fs_file_close(fs_file); return 0; }"
"int ksmbd_conn_handler_loop(void *p) { struct ksmbd_conn *conn = (struct ksmbd_conn *)p; struct ksmbd_transport *t = conn->transport; unsigned int pdu_size, max_allowed_pdu_size; char hdr_buf[4] = {0,}; int size; mutex_init(&conn->srv_mutex); __module_get(THIS_MODULE); if (t->ops->prepare && t->ops->prepare(t)) goto out; conn->last_active = jiffies; while (ksmbd_conn_alive(conn)) { if (try_to_freeze()) continue; kvfree(conn->request_buf); conn->request_buf = NULL; size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1); if (size != sizeof(hdr_buf)) break; pdu_size = get_rfc1002_len(hdr_buf); ksmbd_debug(CONN, ""RFC1002 header %u bytes\n"", pdu_size); if (ksmbd_conn_good(conn)) max_allowed_pdu_size = SMB3_MAX_MSGSIZE + conn->vals->max_write_size; else max_allowed_pdu_size = SMB3_MAX_MSGSIZE; if (pdu_size > max_allowed_pdu_size) { pr_err_ratelimited(""PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\n"", pdu_size, max_allowed_pdu_size, READ_ONCE(conn->status)); break; } if (pdu_size > MAX_STREAM_PROT_LEN) break; if (pdu_size < SMB1_MIN_SUPPORTED_HEADER_SIZE) break; size = pdu_size + 4 + 1; conn->request_buf = kvmalloc(size, GFP_KERNEL); if (!conn->request_buf) break; memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf)); if (!ksmbd_smb_request(conn)) break; size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2); if (size < 0) { pr_err(""sock_read failed: %d\n"", size); break; } if (size != pdu_size) { pr_err(""PDU error. Read: %d, Expected: %d\n"", size, pdu_size); continue; } if (((struct smb2_hdr *)smb2_get_msg(conn->request_buf))->ProtocolId == SMB2_PROTO_NUMBER) { if (pdu_size < SMB2_MIN_SUPPORTED_HEADER_SIZE) break; } if (!default_conn_ops.process_fn) { pr_err(""No connection request callback\n""); break; } if (default_conn_ops.process_fn(conn)) { pr_err(""Cannot handle request\n""); break; } } out: ksmbd_conn_set_releasing(conn); wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0); if (IS_ENABLED(CONFIG_UNICODE)) utf8_unload(conn->um); unload_nls(conn->local_nls); if (default_conn_ops.terminate_fn) default_conn_ops.terminate_fn(conn); t->ops->disconnect(t); module_put(THIS_MODULE); return 0; }"
"int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags) { int ret = get_buffer_internal(avctx, frame, flags); if (ret < 0) av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return ret; }"
"gboolean flatpak_dir_deploy_appstream (FlatpakDir          *self, const char          *remote, const char          *arch, gboolean            *out_changed, GCancellable        *cancellable, GError             **error) { g_autoptr(GFile) appstream_dir = NULL; g_autoptr(GFile) remote_dir = NULL; g_autoptr(GFile) arch_dir = NULL; g_autoptr(GFile) checkout_dir = NULL; g_autoptr(GFile) real_checkout_dir = NULL; g_autoptr(GFile) timestamp_file = NULL; g_autofree char *arch_path = NULL; gboolean checkout_exists; g_autofree char *remote_and_branch = NULL; const char *old_checksum = NULL; g_autofree char *new_checksum = NULL; g_autoptr(GFile) active_link = NULL; g_autofree char *branch = NULL; g_autoptr(GFile) old_checkout_dir = NULL; g_autoptr(GFile) active_tmp_link = NULL; g_autoptr(GError) tmp_error = NULL; g_autofree char *checkout_dir_path = NULL; OstreeRepoCheckoutAtOptions options = { 0, }; glnx_fd_close int dfd = -1; g_autoptr(GFileInfo) file_info = NULL; g_autofree char *tmpname = g_strdup ("".active-XXXXXX""); appstream_dir = g_file_get_child (flatpak_dir_get_path (self), ""appstream""); remote_dir = g_file_get_child (appstream_dir, remote); arch_dir = g_file_get_child (remote_dir, arch); active_link = g_file_get_child (arch_dir, ""active""); timestamp_file = g_file_get_child (arch_dir, "".timestamp""); arch_path = g_file_get_path (arch_dir); if (g_mkdir_with_parents (arch_path, 0755) != 0) { glnx_set_error_from_errno (error); return FALSE; } if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error)) return FALSE; old_checksum = NULL; file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, cancellable, NULL); if (file_info != NULL) old_checksum =  g_file_info_get_symlink_target (file_info); branch = g_strdup_printf (""appstream/%s"", arch); remote_and_branch = g_strdup_printf (""%s:%s"", remote, branch); if (!ostree_repo_resolve_rev (self->repo, remote_and_branch, TRUE, &new_checksum, error)) return FALSE; real_checkout_dir = g_file_get_child (arch_dir, new_checksum); checkout_exists = g_file_query_exists (real_checkout_dir, NULL); if (old_checksum != NULL && new_checksum != NULL && strcmp (old_checksum, new_checksum) == 0 && checkout_exists) { if (!g_file_replace_contents (timestamp_file, """", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error)) return FALSE; if (out_changed) *out_changed = FALSE; return TRUE;  } { g_autofree char *template = g_strdup_printf ("".%s-XXXXXX"", new_checksum); g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template); checkout_dir_path = g_file_get_path (tmp_dir_template); if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL) { g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED, _(""Can't create deploy directory"")); return FALSE; } } checkout_dir = g_file_new_for_path (checkout_dir_path); options.mode = OSTREE_REPO_CHECKOUT_MODE_USER; options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES; options.enable_fsync = FALSE;  if (!ostree_repo_checkout_at (self->repo, &options, AT_FDCWD, checkout_dir_path, new_checksum, cancellable, error)) return FALSE; glnx_gen_temp_name (tmpname); active_tmp_link = g_file_get_child (arch_dir, tmpname); if (!g_file_make_symbolic_link (active_tmp_link, new_checksum, cancellable, error)) return FALSE; if (syncfs (dfd) != 0) { glnx_set_error_from_errno (error); return FALSE; } if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE, cancellable, NULL, NULL, error)) return FALSE; if (syncfs (dfd) != 0) { glnx_set_error_from_errno (error); return FALSE; } if (!flatpak_file_rename (active_tmp_link, active_link, cancellable, error)) return FALSE; if (old_checksum != NULL && g_strcmp0 (old_checksum, new_checksum) != 0) { old_checkout_dir = g_file_get_child (arch_dir, old_checksum); if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error)) g_warning (""Unable to remove old appstream checkout: %s\n"", tmp_error->message); } if (!g_file_replace_contents (timestamp_file, """", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error)) return FALSE; if (!checkout_exists) { g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir); utime (appstream_dir_path, NULL); } if (out_changed) *out_changed = TRUE; return TRUE; }"
"static size_t exif_convert_any_to_int(void *value, int format, int motorola_intel TSRMLS_DC) { int s_den; unsigned u_den; switch(format) { case TAG_FMT_SBYTE:     return *(signed char *)value; case TAG_FMT_BYTE:      return *(uchar *)value; case TAG_FMT_USHORT:    return php_ifd_get16u(value, motorola_intel); case TAG_FMT_ULONG:     return php_ifd_get32u(value, motorola_intel); case TAG_FMT_URATIONAL: u_den = php_ifd_get32u(4+(char *)value, motorola_intel); if (u_den == 0) { return 0; } else { return php_ifd_get32u(value, motorola_intel) / u_den; } case TAG_FMT_SRATIONAL: s_den = php_ifd_get32s(4+(char *)value, motorola_intel); if (s_den == 0) { return 0; } else { return php_ifd_get32s(value, motorola_intel) / s_den; } case TAG_FMT_SSHORT:    return php_ifd_get16u(value, motorola_intel); case TAG_FMT_SLONG:     return php_ifd_get32s(value, motorola_intel); case TAG_FMT_SINGLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type single""); #endif return (size_t)*(float *)value; case TAG_FMT_DOUBLE: #ifdef EXIF_DEBUG php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Found value of type double""); #endif return (size_t)*(double *)value; } return 0; }"
"static bool parseOperands(char* str, ArmOp *op) { char *t = strdup (str); int operand = 0; char *token = t; char *x; int imm_count = 0; int mem_opt = 0; if (!token) { return false; } while (token) { char *next = strchr (token, ','); if (next) { *next++ = 0; } while (token[0] == ' ') { token++; } if (operand >= MAX_OPERANDS) { eprintf (""Too many operands\n""); return false; } op->operands[operand].type = ARM_NOTYPE; op->operands[operand].reg_type = ARM_UNDEFINED; op->operands[operand].shift = ARM_NO_SHIFT; while (token[0] == ' ' || token[0] == '[' || token[0] == ']') { token ++; } if (!strncmp (token, ""lsl"", 3)) { op->operands[operand].shift = ARM_LSL; } else if (!strncmp (token, ""lsr"", 3)) { op->operands[operand].shift = ARM_LSR; } else if (!strncmp (token, ""asr"", 3)) { op->operands[operand].shift = ARM_ASR; } if (op->operands[operand].shift != ARM_NO_SHIFT) { op->operands_count ++; op->operands[operand].shift_amount = r_num_math (NULL, token + 4); if (op->operands[operand].shift_amount > 63) { return false; } operand ++; token = next; continue; } switch (token[0]) { case 'x': x = strchr (token, ','); if (x) { x[0] = '\0'; } op->operands_count ++; op->operands[operand].type = ARM_GPR; op->operands[operand].reg_type = ARM_REG64; op->operands[operand].reg = r_num_math (NULL, token + 1); if (op->operands[operand].reg > 31) { return false; } break; case 'w': op->operands_count ++; op->operands[operand].type = ARM_GPR; op->operands[operand].reg_type = ARM_REG32; op->operands[operand].reg = r_num_math (NULL, token + 1); if (op->operands[operand].reg > 31) { return false; } break; case 'v': op->operands_count ++; op->operands[operand].type = ARM_FP; op->operands[operand].reg = r_num_math (NULL, token + 1); break; case 's': case 'S': if (token[1] == 'P' || token [1] == 'p') { int i; for (i = 0; msr_const[i].name; i++) { if (!r_str_ncasecmp (token, msr_const[i].name, strlen (msr_const[i].name))) { op->operands[operand].sp_val = msr_const[i].val; break; } } op->operands_count ++; op->operands[operand].type = ARM_GPR; op->operands[operand].reg_type = ARM_SP | ARM_REG64; op->operands[operand].reg = 31; break; } mem_opt = get_mem_option (token); if (mem_opt != -1) { op->operands_count ++; op->operands[operand].type = ARM_MEM_OPT; op->operands[operand].mem_option = mem_opt; } break; case 'L': case 'l': case 'I': case 'i': case 'N': case 'n': case 'O': case 'o': case 'p': case 'P': mem_opt = get_mem_option (token); if (mem_opt != -1) { op->operands_count ++; op->operands[operand].type = ARM_MEM_OPT; op->operands[operand].mem_option = mem_opt; } break; case '-': op->operands[operand].sign = -1; default: op->operands_count ++; op->operands[operand].type = ARM_CONSTANT; op->operands[operand].immediate = r_num_math (NULL, token); imm_count++; break; } token = next; operand ++; if (operand > MAX_OPERANDS) { free (t); return false; } } free (t); return true; }"
"static void xgmac_enet_send(XgmacState *s) { struct desc bd; int frame_size; int len; uint8_t frame[8192]; uint8_t *ptr; ptr = frame; frame_size = 0; while (1) { xgmac_read_desc(s, &bd, 0); if ((bd.ctl_stat & 0x80000000) == 0) { break; } len = (bd.buffer1_size & 0xfff) + (bd.buffer2_size & 0xfff); if ((bd.buffer1_size & 0xfff) > 2048) { DEBUGF_BRK(""qemu:%s:ERROR...ERROR...ERROR... -- "" ""xgmac buffer 1 len on send > 2048 (0x%x)\n"", __func__, bd.buffer1_size & 0xfff); } if ((bd.buffer2_size & 0xfff) != 0) { DEBUGF_BRK(""qemu:%s:ERROR...ERROR...ERROR... -- "" ""xgmac buffer 2 len on send != 0 (0x%x)\n"", __func__, bd.buffer2_size & 0xfff); } if (len >= sizeof(frame)) { DEBUGF_BRK(""qemu:%s: buffer overflow %d read into %zu "" ""buffer\n"" , __func__, len, sizeof(frame)); DEBUGF_BRK(""qemu:%s: buffer1.size=%d; buffer2.size=%d\n"", __func__, bd.buffer1_size, bd.buffer2_size); } cpu_physical_memory_read(bd.buffer1_addr, ptr, len); ptr += len; frame_size += len; if (bd.ctl_stat & 0x20000000) { qemu_send_packet(qemu_get_queue(s->nic), frame, len); ptr = frame; frame_size = 0; s->regs[DMA_STATUS] |= DMA_STATUS_TI | DMA_STATUS_NIS; } bd.ctl_stat &= ~0x80000000; xgmac_write_desc(s, &bd, 0); } }"
"void comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) { COMPS_HSList *tmplist, *tmp_subnodes; COMPS_HSListItem *it; COMPS_ObjListIt *it2; struct Pair { COMPS_HSList * subnodes; char * key; char added; } *pair, *parent_pair; pair = malloc(sizeof(struct Pair)); pair->subnodes = rt2->subnodes; pair->key = NULL; tmplist = comps_hslist_create(); comps_hslist_init(tmplist, NULL, NULL, &free); comps_hslist_append(tmplist, pair, 0); while (tmplist->first != NULL) { it = tmplist->first; comps_hslist_remove(tmplist, tmplist->first); tmp_subnodes = ((struct Pair*)it->data)->subnodes; parent_pair = (struct Pair*) it->data; free(it); pair->added = 0; for (it = tmp_subnodes->first; it != NULL; it=it->next) { pair = malloc(sizeof(struct Pair)); pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes; if (parent_pair->key != NULL) { pair->key = malloc(sizeof(char) * (strlen(((COMPS_ObjMRTreeData*)it->data)->key) + strlen(parent_pair->key) + 1)); memcpy(pair->key, parent_pair->key, sizeof(char) * strlen(parent_pair->key)); memcpy(pair->key+strlen(parent_pair->key), ((COMPS_ObjMRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1)); } else { pair->key = malloc(sizeof(char)* (strlen(((COMPS_ObjMRTreeData*)it->data)->key) + 1)); memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1)); } if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) { for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first; it2 != NULL; it2 = it2->next) { comps_objmrtree_set(rt1, pair->key, it2->comps_obj); } if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) { comps_hslist_append(tmplist, pair, 0); } else { free(pair->key); free(pair); } } else { if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) { comps_hslist_append(tmplist, pair, 0); } else { free(pair->key); free(pair); } } } free(parent_pair->key); free(parent_pair); } comps_hslist_destroy(&tmplist); }"
"static int fw_set_parms(struct net *net, struct tcf_proto *tp, struct fw_filter *f, struct nlattr **tb, struct nlattr **tca, unsigned long base, u32 flags, struct netlink_ext_ack *extack) { struct fw_head *head = rtnl_dereference(tp->root); u32 mask; int err; err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &f->exts, flags, extack); if (err < 0) return err; if (tb[TCA_FW_CLASSID]) { f->res.classid = nla_get_u32(tb[TCA_FW_CLASSID]); tcf_bind_filter(tp, &f->res, base); } if (tb[TCA_FW_INDEV]) { int ret; ret = tcf_change_indev(net, tb[TCA_FW_INDEV], extack); if (ret < 0) return ret; f->ifindex = ret; } err = -EINVAL; if (tb[TCA_FW_MASK]) { mask = nla_get_u32(tb[TCA_FW_MASK]); if (mask != head->mask) return err; } else if (head->mask != 0xFFFFFFFF) return err; return 0; }"
"x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access) { unsigned int first = 0; unsigned int last = ARR_SIZE(insn_regs_intel) - 1; unsigned int mid = ARR_SIZE(insn_regs_intel) / 2; if (!intel_regs_sorted) { memcpy(insn_regs_intel_sorted, insn_regs_intel, sizeof(insn_regs_intel_sorted)); qsort(insn_regs_intel_sorted, ARR_SIZE(insn_regs_intel_sorted), sizeof(struct insn_reg), regs_cmp); intel_regs_sorted = true; } while (first <= last) { if (insn_regs_intel_sorted[mid].insn < id) { first = mid + 1; } else if (insn_regs_intel_sorted[mid].insn == id) { if (access) { *access = insn_regs_intel_sorted[mid].access; } return insn_regs_intel_sorted[mid].reg; } else { if (mid == 0) break; last = mid - 1; } mid = (first + last) / 2; } return 0; }"
"static bool is_legal_file(const std::string &filename) { DBG_FS << ""Looking for '"" << filename << ""'.\n""; if (filename.empty()) { LOG_FS << ""  invalid filename\n""; return false; } if (filename.find("".."") != std::string::npos) { ERR_FS << ""Illegal path '"" << filename << ""' (\""..\"" not allowed).\n""; return false; } return true; }"
"int rtl_usb_probe(struct usb_interface *intf, const struct usb_device_id *id, struct rtl_hal_cfg *rtl_hal_cfg) { int err; struct ieee80211_hw *hw = NULL; struct rtl_priv *rtlpriv = NULL; struct usb_device*udev; struct rtl_usb_priv *usb_priv; hw = ieee80211_alloc_hw(sizeof(struct rtl_priv) + sizeof(struct rtl_usb_priv), &rtl_ops); if (!hw) { WARN_ONCE(true, ""rtl_usb: ieee80211 alloc failed\n""); return -ENOMEM; } rtlpriv = hw->priv; rtlpriv->hw = hw; rtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32), GFP_KERNEL); if (!rtlpriv->usb_data) return -ENOMEM; spin_lock_init(&rtlpriv->locks.usb_lock); INIT_WORK(&rtlpriv->works.fill_h2c_cmd, rtl_fill_h2c_cmd_work_callback); INIT_WORK(&rtlpriv->works.lps_change_work, rtl_lps_change_work_callback); rtlpriv->usb_data_index = 0; init_completion(&rtlpriv->firmware_loading_complete); SET_IEEE80211_DEV(hw, &intf->dev); udev = interface_to_usbdev(intf); usb_get_dev(udev); usb_priv = rtl_usbpriv(hw); memset(usb_priv, 0, sizeof(*usb_priv)); usb_priv->dev.intf = intf; usb_priv->dev.udev = udev; usb_set_intfdata(intf, hw); rtlpriv->rtlhal.interface = INTF_USB; rtlpriv->cfg = rtl_hal_cfg; rtlpriv->intf_ops = &rtl_usb_ops; _rtl_usb_io_handler_init(&udev->dev, hw); rtlpriv->cfg->ops->read_chip_version(hw); rtlpriv->cfg->ops->read_eeprom_info(hw); err = _rtl_usb_init(hw); if (err) goto error_out2; rtl_usb_init_sw(hw); err = rtl_init_core(hw); if (err) { pr_err(""Can't allocate sw for mac80211\n""); goto error_out2; } if (rtlpriv->cfg->ops->init_sw_vars(hw)) { pr_err(""Can't init_sw_vars\n""); goto error_out; } rtlpriv->cfg->ops->init_sw_leds(hw); err = ieee80211_register_hw(hw); if (err) { pr_err(""Can't register mac80211 hw.\n""); err = -ENODEV; goto error_out; } rtlpriv->mac80211.mac80211_registered = 1; set_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status); return 0; error_out: rtl_deinit_core(hw); error_out2: _rtl_usb_io_handler_release(hw); usb_put_dev(udev); complete(&rtlpriv->firmware_loading_complete); return -ENODEV; }"
"GF_Err gf_swf_read_header(SWFReader *read) { SWFRec rc; u8 sig[3]; sig[0] = gf_bs_read_u8(read->bs); sig[1] = gf_bs_read_u8(read->bs); sig[2] = gf_bs_read_u8(read->bs); if ( ((sig[0] != 'F') && (sig[0] != 'C')) || (sig[1] != 'W') || (sig[2] != 'S') ) { return GF_NON_COMPLIANT_BITSTREAM; } gf_bs_read_u8(read->bs); read->length = swf_get_32(read); if (sig[0] == 'C') { swf_init_decompress(read); if (!read->bs) return GF_NON_COMPLIANT_BITSTREAM; } swf_get_rec(read, &rc); read->width = rc.w; read->height = rc.h; swf_align(read); read->frame_rate = swf_get_16(read)>>8; read->frame_count = swf_get_16(read); GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (""SWF Import - Scene Size %gx%g - %d frames @ %d FPS\n"", read->width, read->height, read->frame_count, read->frame_rate)); return GF_OK; }"
"int zfp_prec_compress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) { BLOSC_UNUSED_PARAM(chunk); ZFP_ERROR_NULL(input); ZFP_ERROR_NULL(output); ZFP_ERROR_NULL(cparams); int8_t ndim; int64_t *shape = malloc(8 * sizeof(int64_t)); int32_t *chunkshape = malloc(8 * sizeof(int32_t)); int32_t *blockshape = malloc(8 * sizeof(int32_t)); uint8_t *smeta; int32_t smeta_len; if (blosc2_meta_get(cparams->schunk, ""b2nd"", &smeta, &smeta_len) < 0) { free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""b2nd layer not found!""); return BLOSC2_ERROR_FAILURE; } deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape); free(smeta); for(int i = 0; i < ndim; i++) { if (blockshape[i] < 4) { BLOSC_TRACE_ERROR(""ZFP does not support blocks smaller than cells (4x...x4""); return BLOSC2_ERROR_FAILURE; } } zfp_type type;      zfp_field *field;   zfp_stream *zfp;    zfp_stream *zfp_aux;    bitstream *stream;  bitstream *stream_aux;  size_t zfpsize;     uint prec; switch (ndim) { case 1: prec = meta + 5; break; case 2: prec = meta + 7; break; case 3: prec = meta + 9; break; case 4: prec = meta + 11; break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for ndims: %d"", ndim); return BLOSC2_ERROR_FAILURE; } if (prec > ZFP_MAX_PREC) { BLOSC_TRACE_ERROR(""Max precision for this codecs is %d"", ZFP_MAX_PREC); prec = ZFP_MAX_PREC; } int32_t typesize = cparams->typesize; switch (typesize) { case sizeof(float): type = zfp_type_float; break; case sizeof(double): type = zfp_type_double; break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for typesize: %d"", typesize); return BLOSC2_ERROR_FAILURE; } zfp = zfp_stream_open(NULL); zfp_stream_set_precision(zfp, prec); stream = stream_open(output, output_len); zfp_stream_set_bit_stream(zfp, stream); zfp_stream_rewind(zfp); switch (ndim) { case 1: field = zfp_field_1d((void *) input, type, blockshape[0]); break; case 2: field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]); break; case 3: field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]); break; case 4: field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]); break; default: free(shape); free(chunkshape); free(blockshape); BLOSC_TRACE_ERROR(""ZFP is not available for ndims: %d"", ndim); return BLOSC2_ERROR_FAILURE; } int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field); zfp_stream_close(zfp); stream_close(stream); uint8_t *aux_out = malloc(zfp_maxout); zfp_aux = zfp_stream_open(NULL); zfp_stream_set_precision(zfp_aux, prec); stream_aux = stream_open(aux_out, zfp_maxout); zfp_stream_set_bit_stream(zfp_aux, stream_aux); zfp_stream_rewind(zfp_aux); zfpsize = zfp_compress(zfp_aux, field); zfp_field_free(field); zfp_stream_close(zfp_aux); stream_close(stream_aux); free(shape); free(chunkshape); free(blockshape); if (zfpsize == 0) { BLOSC_TRACE_ERROR(""\n ZFP: Compression failed\n""); free(aux_out); return (int) zfpsize; } if ((int32_t) zfpsize >= input_len) { BLOSC_TRACE_ERROR(""\n ZFP: Compressed data is bigger than input! \n""); free(aux_out); return 0; } memcpy(output, aux_out, zfpsize); free(aux_out); return (int) zfpsize; }"
"static void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list) { FILE *logs = cbk ? cbk : stderr; if (rti_logs && (lm & GF_LOG_RTI)) { char szMsg[2048]; vsprintf(szMsg, fmt, list); UpdateRTInfo(szMsg + 6 ); } else { if (log_time_start) { u64 now = gf_sys_clock_high_res(); fprintf(logs, ""At ""LLD"" (diff %d) - "", now - log_time_start, (u32) (now - last_log_time) ); last_log_time = now; } if (log_utc_time) { u64 utc_clock = gf_net_get_utc() ; time_t secs = utc_clock/1000; struct tm t; t = *gmtime(&secs); fprintf(logs, ""UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS ""LLU"") - "", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock); } vfprintf(logs, fmt, list); fflush(logs); } }"
static unsigned int rpcrdma_max_call_header_size(unsigned int maxsegs) { unsigned int size; size = RPCRDMA_HDRLEN_MIN; size = maxsegs * rpcrdma_readchunk_maxsz * sizeof(__be32); size += sizeof(__be32); size += rpcrdma_segment_maxsz * sizeof(__be32); size += sizeof(__be32); return size; }
"int XmpTextValue::read(const std::string& buf) { std::string b = buf; std::string type; if (buf.length() > 5 && buf.substr(0, 5) == ""type="") { std::string::size_type pos = buf.find_first_of(' '); type = buf.substr(5, pos-5); if (type[0] == '""') type = type.substr(1); if (type[type.length()-1] == '""') type = type.substr(0, type.length()-1); b.clear(); if (pos != std::string::npos) b = buf.substr(pos+1); } if (!type.empty()) { if (type == ""Alt"") { setXmpArrayType(XmpValue::xaAlt); } else if (type == ""Bag"") { setXmpArrayType(XmpValue::xaBag); } else if (type == ""Seq"") { setXmpArrayType(XmpValue::xaSeq); } else if (type == ""Struct"") { setXmpStruct(); } else { throw Error(kerInvalidXmpText, type); } } value_ = b; return 0; }"
"int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max) { uint request = HID_REQ_GET_REPORT;     uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN;     uint value = 0x300; uint size = RAZER_USB_REPORT_LEN;     int len; int retval; int result = 0; char *buf; buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL); if (buf == NULL) return -ENOMEM; retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max); len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0), request,                                   request_type,                              value,                                     response_index,                            buf,                                       size, USB_CTRL_SET_TIMEOUT); memcpy(response_report, buf, sizeof(struct razer_report)); kfree(buf); if(len != 90) { printk(KERN_WARNING ""razer driver: Invalid USB response. USB Report length: %d\n"", len); result = 1; } return result; }"
"static int svm_migrate_vram_to_vram(struct svm_range *prange, uint32_t best_loc, struct mm_struct *mm, uint32_t trigger) { int r, retries = 3; pr_debug(""from gpu 0x%x to gpu 0x%x\n"", prange->actual_loc, best_loc); do { r = svm_migrate_vram_to_ram(prange, mm, trigger); if (r) return r; } while (prange->actual_loc && --retries); if (prange->actual_loc) return -EDEADLK; return svm_migrate_ram_to_vram(prange, best_loc, mm, trigger); }"
"static void main_get_appheader (xd3_stream *stream, main_file *ifile, main_file *output, main_file *sfile) { uint8_t *apphead; usize_t appheadsz; int ret; if (! option_use_appheader) { return; } ret = xd3_get_appheader (stream, & apphead, & appheadsz); if (ret != 0) { return; } if (appheadsz > 0) { char *start = (char*)apphead; char *slash; int   place = 0; char *parsed[4]; memset (parsed, 0, sizeof (parsed)); while ((slash = strchr (start, '/')) != NULL) { *slash = 0; parsed[place++] = start; start = slash + 1; } parsed[place++] = start; if (place == 2 || place == 4) { main_get_appheader_params (output, parsed, 1, ""output"", ifile); } if (place == 4) { main_get_appheader_params (sfile, parsed+2, 0, ""source"", ifile); } } option_use_appheader = 0; return; }"
void shutdown_mib(void) { unload_all_mibs(); if (tree_top) { if (tree_top->label) SNMP_FREE(tree_top->label); SNMP_FREE(tree_top); } tree_head = NULL; Mib = NULL; if (_mibindexes) { int i; for (i = 0; i < _mibindex; ++i) SNMP_FREE(_mibindexes[i]); free(_mibindexes); _mibindex = 0; _mibindex_max = 0; _mibindexes = NULL; } if (Prefix != NULL && Prefix != &Standard_Prefix[0]) SNMP_FREE(Prefix); if (Prefix) Prefix = NULL; SNMP_FREE(confmibs); SNMP_FREE(confmibdir); }
"static int ambiguity_error(Clp_Parser *clp, int ambiguous, int *ambiguous_values, const Clp_Option *opt, const Clp_InternOption *iopt, const char *prefix, const char *fmt, ...) { Clp_Internal *cli = clp->internal; Clp_BuildString bs; int i; va_list val; va_start(val, fmt); build_string_init(&bs, clp); Clp_vbsprintf(clp, &bs, fmt, val); append_build_string(&bs, ""\n"", 1); build_string_program_prefix(&bs, clp); append_build_string(&bs, ""(Possibilities are"", -1); for (i = 0; i < ambiguous && i < MAX_AMBIGUOUS_VALUES; i++) { int value = ambiguous_values[i]; const char *no_dash = """"; if (value < 0) value = -(value + 1), no_dash = ""no-""; if (i == 0) append_build_string(&bs, "" "", 1); else if (i == ambiguous - 1) append_build_string(&bs, (i == 1 ? "" and "" : "", and ""), -1); else append_build_string(&bs, "", "", 2); append_build_string(&bs, (cli->utf8 ? ""\342\200\230"" : ""'""), -1); append_build_string(&bs, prefix, -1); append_build_string(&bs, no_dash, -1); append_build_string(&bs, opt[value].long_name + iopt[value].ilongoff, -1); append_build_string(&bs, (cli->utf8 ? ""\342\200\231"" : ""'""), -1); } if (ambiguous > MAX_AMBIGUOUS_VALUES) append_build_string(&bs, "", and others"", -1); append_build_string(&bs, "".)\n"", -1); va_end(val); do_error(clp, &bs); build_string_cleanup(&bs); return 0; }"
"static gdImagePtr gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width, const unsigned int new_height) { const unsigned int src_width = src->sx; const unsigned int src_height = src->sy; gdImagePtr tmp_im = NULL; gdImagePtr dst = NULL; if (src_width == new_width && src_height == new_height) { return gdImageClone(src); } if (!src->trueColor) { gdImagePaletteToTrueColor(src); } if (src_width == new_width) { tmp_im = src; } else { tmp_im = gdImageCreateTrueColor(new_width, src_height); if (tmp_im == NULL) { return NULL; } gdImageSetInterpolationMethod(tmp_im, src->interpolation_id); _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL); } if (src_height == new_height) { assert(tmp_im != src); return tmp_im; } dst = gdImageCreateTrueColor(new_width, new_height); if (dst != NULL) { gdImageSetInterpolationMethod(dst, src->interpolation_id); _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL); } if (src != tmp_im) { gdFree(tmp_im); } return dst; }"
"static int sysMapBlockFile(FILE* mapf, MemMapping* pMap) { char block_dev[PATH_MAX+1]; size_t size; unsigned int blksize; unsigned int blocks; unsigned int range_count; unsigned int i; if (fgets(block_dev, sizeof(block_dev), mapf) == NULL) { LOGW(""failed to read block device from header\n""); return -1; } for (i = 0; i < sizeof(block_dev); ++i) { if (block_dev[i] == '\n') { block_dev[i] = 0; break; } } if (fscanf(mapf, ""%zu %u\n%u\n"", &size, &blksize, &range_count) != 3) { LOGW(""failed to parse block map header\n""); return -1; } blocks = ((size-1) / blksize) + 1; pMap->range_count = range_count; pMap->ranges = malloc(range_count * sizeof(MappedRange)); memset(pMap->ranges, 0, range_count * sizeof(MappedRange)); unsigned char* reserve; reserve = mmap64(NULL, blocks * blksize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0); if (reserve == MAP_FAILED) { LOGW(""failed to reserve address space: %s\n"", strerror(errno)); return -1; } pMap->ranges[range_count-1].addr = reserve; pMap->ranges[range_count-1].length = blocks * blksize; int fd = open(block_dev, O_RDONLY); if (fd < 0) { LOGW(""failed to open block device %s: %s\n"", block_dev, strerror(errno)); return -1; } unsigned char* next = reserve; for (i = 0; i < range_count; ++i) { int start, end; if (fscanf(mapf, ""%d %d\n"", &start, &end) != 2) { LOGW(""failed to parse range %d in block map\n"", i); return -1; } void* addr = mmap64(next, (end-start)*blksize, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, ((off64_t)start)*blksize); if (addr == MAP_FAILED) { LOGW(""failed to map block %d: %s\n"", i, strerror(errno)); return -1; } pMap->ranges[i].addr = addr; pMap->ranges[i].length = (end-start)*blksize; next += pMap->ranges[i].length; } pMap->addr = reserve; pMap->length = size; LOGI(""mmapped %d ranges\n"", range_count); return 0; }"
"void tr_rpcSetWhitelist(tr_rpc_server* server, char const* whitelistStr) { void* tmp; tmp = server->whitelistStr; server->whitelistStr = tr_strdup(whitelistStr); tr_free(tmp); while ((tmp = tr_list_pop_front(&server->whitelist)) != NULL) { tr_free(tmp); } for (char const* walk = whitelistStr; walk != NULL && *walk != '\0';) { char const* delimiters = "" ,;""; size_t const len = strcspn(walk, delimiters); char* token = tr_strndup(walk, len); tr_list_append(&server->whitelist, token); if (strcspn(token, ""+-"") < len) { tr_logAddNamedInfo(MY_NAME, ""Adding address to whitelist: %s (And it has a '+' or '-'!  Are you using an old ACL by mistake?)"", token); } else { tr_logAddNamedInfo(MY_NAME, ""Adding address to whitelist: %s"", token); } walk += len; if (*walk == '\0') { break; } ++walk; } }"
"ssize_t mgs_transport_read(gnutls_transport_ptr_t ptr, void *buffer, size_t len) { mgs_handle_t *ctxt = ptr; apr_size_t in = len; apr_read_type_e block = ctxt->input_block; ctxt->input_rc = APR_SUCCESS; if (!len || buffer == NULL) { return 0; } if (!ctxt->input_bb) { ctxt->input_rc = APR_EOF; gnutls_transport_set_errno(ctxt->session, ECONNABORTED); return -1; } if (APR_BRIGADE_EMPTY(ctxt->input_bb)) { apr_status_t rc = ap_get_brigade(ctxt->input_filter->next, ctxt->input_bb, AP_MODE_READBYTES, ctxt->input_block, in); if (APR_STATUS_IS_EAGAIN(rc) || APR_STATUS_IS_EINTR(rc) || (rc == APR_SUCCESS && APR_BRIGADE_EMPTY(ctxt->input_bb))) { ctxt->input_rc = (rc != APR_SUCCESS ? rc : APR_EINTR); gnutls_transport_set_errno(ctxt->session, EAI_APR_TO_RAW(ctxt->input_rc)); return -1; } if (ctxt->input_block == APR_BLOCK_READ && APR_STATUS_IS_TIMEUP(rc) && APR_BRIGADE_EMPTY(ctxt->input_bb)) { ctxt->input_rc = rc; gnutls_transport_set_errno(ctxt->session, EAGAIN); return -1; } if (rc != APR_SUCCESS) { ap_log_cerror(APLOG_MARK, APLOG_INFO, rc, ctxt->c, ""%s: Unexpected error!"", __func__); apr_brigade_cleanup(ctxt->input_bb); ctxt->input_bb = NULL; gnutls_transport_set_errno(ctxt->session, EIO); return -1; } } ctxt->input_rc = brigade_consume(ctxt->input_bb, block, buffer, &len); if (ctxt->input_rc == APR_SUCCESS) { return (ssize_t) len; } if (APR_STATUS_IS_EAGAIN(ctxt->input_rc) || APR_STATUS_IS_EINTR(ctxt->input_rc)) { if (len == 0) { gnutls_transport_set_errno(ctxt->session, EAI_APR_TO_RAW(ctxt->input_rc)); return -1; } return (ssize_t) len; } apr_brigade_cleanup(ctxt->input_bb); ctxt->input_bb = NULL; if (APR_STATUS_IS_EOF(ctxt->input_rc) && len) { return (ssize_t) len; } gnutls_transport_set_errno(ctxt->session, EIO); return -1; }"
"static int ng_pkt(git_pkt **out, const char *line, size_t len) { git_pkt_ng *pkt; const char *ptr; size_t alloclen; pkt = git__malloc(sizeof(*pkt)); GITERR_CHECK_ALLOC(pkt); pkt->ref = NULL; pkt->type = GIT_PKT_NG; line += 3;  if (!(ptr = strchr(line, ' '))) goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->ref = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->ref); memcpy(pkt->ref, line, len); pkt->ref[len] = '\0'; line = ptr + 1; if (!(ptr = strchr(line, '\n'))) goto out_err; len = ptr - line; GITERR_CHECK_ALLOC_ADD(&alloclen, len, 1); pkt->msg = git__malloc(alloclen); GITERR_CHECK_ALLOC(pkt->msg); memcpy(pkt->msg, line, len); pkt->msg[len] = '\0'; *out = (git_pkt *)pkt; return 0; out_err: giterr_set(GITERR_NET, ""invalid packet line""); git__free(pkt->ref); git__free(pkt); return -1; }"
"static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) { RList *ret = NULL; RBinWasmDataEntry *ptr = NULL; if (!(ret = r_list_newf ((RListFree)free))) { return NULL; } ut8* buf = bin->buf->buf + (ut32)sec->payload_data; ut32 len =  sec->payload_len; ut32 count = sec->count; ut32 i = 0, r = 0; size_t n = 0; while (i < len && r < count) { if (!(ptr = R_NEW0 (RBinWasmDataEntry))) { return ret; } if (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) { free (ptr); return ret; } if (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) { free (ptr); return ret; } ptr->offset.len = n; if (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) { free (ptr); return ret; } ptr->data = sec->payload_data + i; r_list_append (ret, ptr); r += 1; } return ret; }"
"static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) { if (disk != NULL) { const int blocksize = 512; int ret; RIOBind *iob = disk->data; if (bio) iob = bio; ret = iob->read_at (iob->io, delta+(blocksize*sector), (ut8*)buf, size*blocksize); if (ret == -1) return 1; } else eprintf (""oops. no disk\n""); return 0; }"
"static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len) { const pj_uint8_t *p = start; int name_len, name_part_len; pj_status_t status; status = get_name_len(0, pkt, start, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4); q->name.slen = 0; status = get_name(0, pkt, start, max, &q->name); if (status != PJ_SUCCESS) return status; p = (start + name_part_len); pj_memcpy(&q->type, p, 2); q->type = pj_ntohs(q->type); p += 2; pj_memcpy(&q->dnsclass, p, 2); q->dnsclass = pj_ntohs(q->dnsclass); p += 2; *parsed_len = (int)(p - start); return PJ_SUCCESS; }"
"bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz) { for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) { unsigned const symnum = get_te32(&rel->r_info) >> 8; char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr; if (0==strcmp(symnam, ""__libc_start_main"")          ||  0==strcmp(symnam, ""__libc_init"")          ||  0==strcmp(symnam, ""__uClibc_main"") ||  0==strcmp(symnam, ""__uClibc_start_main"")) return true; } return false; }"
"Expression* flexibleCopy(Expression* original, Module& wasm, CustomCopier custom) { struct Copier : public OverriddenVisitor<Copier, Expression*> { Module& wasm; CustomCopier custom; Builder builder; Copier(Module& wasm, CustomCopier custom) : wasm(wasm), custom(custom), builder(wasm) {} Expression* copy(Expression* curr) { if (!curr) { return nullptr; } auto* ret = custom(curr); if (ret) { return ret; } return OverriddenVisitor<Copier, Expression*>::visit(curr); } Expression* visitBlock(Block* curr) { ExpressionList list(wasm.allocator); for (Index i = 0; i < curr->list.size(); i++) { list.push_back(copy(curr->list[i])); } return builder.makeBlock(curr->name, list, curr->type); } Expression* visitIf(If* curr) { return builder.makeIf(copy(curr->condition), copy(curr->ifTrue), copy(curr->ifFalse), curr->type); } Expression* visitLoop(Loop* curr) { return builder.makeLoop(curr->name, copy(curr->body)); } Expression* visitBreak(Break* curr) { return builder.makeBreak( curr->name, copy(curr->value), copy(curr->condition)); } Expression* visitSwitch(Switch* curr) { return builder.makeSwitch(curr->targets, curr->default_, copy(curr->condition), copy(curr->value)); } Expression* visitCall(Call* curr) { auto* ret = builder.makeCall(curr->target, {}, curr->type, curr->isReturn); for (Index i = 0; i < curr->operands.size(); i++) { ret->operands.push_back(copy(curr->operands[i])); } return ret; } Expression* visitCallIndirect(CallIndirect* curr) { auto* ret = builder.makeCallIndirect( curr->fullType, copy(curr->target), {}, curr->type, curr->isReturn); for (Index i = 0; i < curr->operands.size(); i++) { ret->operands.push_back(copy(curr->operands[i])); } return ret; } Expression* visitLocalGet(LocalGet* curr) { return builder.makeLocalGet(curr->index, curr->type); } Expression* visitLocalSet(LocalSet* curr) { if (curr->isTee()) { return builder.makeLocalTee(curr->index, copy(curr->value)); } else { return builder.makeLocalSet(curr->index, copy(curr->value)); } } Expression* visitGlobalGet(GlobalGet* curr) { return builder.makeGlobalGet(curr->name, curr->type); } Expression* visitGlobalSet(GlobalSet* curr) { return builder.makeGlobalSet(curr->name, copy(curr->value)); } Expression* visitLoad(Load* curr) { if (curr->isAtomic) { return builder.makeAtomicLoad( curr->bytes, curr->offset, copy(curr->ptr), curr->type); } return builder.makeLoad(curr->bytes, LoadUtils::isSignRelevant(curr) ? curr->signed_ : false, curr->offset, curr->align, copy(curr->ptr), curr->type); } Expression* visitStore(Store* curr) { if (curr->isAtomic) { return builder.makeAtomicStore(curr->bytes, curr->offset, copy(curr->ptr), copy(curr->value), curr->valueType); } return builder.makeStore(curr->bytes, curr->offset, curr->align, copy(curr->ptr), copy(curr->value), curr->valueType); } Expression* visitAtomicRMW(AtomicRMW* curr) { return builder.makeAtomicRMW(curr->op, curr->bytes, curr->offset, copy(curr->ptr), copy(curr->value), curr->type); } Expression* visitAtomicCmpxchg(AtomicCmpxchg* curr) { return builder.makeAtomicCmpxchg(curr->bytes, curr->offset, copy(curr->ptr), copy(curr->expected), copy(curr->replacement), curr->type); } Expression* visitAtomicWait(AtomicWait* curr) { return builder.makeAtomicWait(copy(curr->ptr), copy(curr->expected), copy(curr->timeout), curr->expectedType, curr->offset); } Expression* visitAtomicNotify(AtomicNotify* curr) { return builder.makeAtomicNotify( copy(curr->ptr), copy(curr->notifyCount), curr->offset); } Expression* visitSIMDExtract(SIMDExtract* curr) { return builder.makeSIMDExtract(curr->op, copy(curr->vec), curr->index); } Expression* visitSIMDReplace(SIMDReplace* curr) { return builder.makeSIMDReplace( curr->op, copy(curr->vec), curr->index, copy(curr->value)); } Expression* visitSIMDShuffle(SIMDShuffle* curr) { return builder.makeSIMDShuffle( copy(curr->left), copy(curr->right), curr->mask); } Expression* visitSIMDBitselect(SIMDBitselect* curr) { return builder.makeSIMDBitselect( copy(curr->left), copy(curr->right), copy(curr->cond)); } Expression* visitSIMDShift(SIMDShift* curr) { return builder.makeSIMDShift( curr->op, copy(curr->vec), copy(curr->shift)); } Expression* visitConst(Const* curr) { return builder.makeConst(curr->value); } Expression* visitMemoryInit(MemoryInit* curr) { return builder.makeMemoryInit( curr->segment, copy(curr->dest), copy(curr->offset), copy(curr->size)); } Expression* visitDataDrop(DataDrop* curr) { return builder.makeDataDrop(curr->segment); } Expression* visitMemoryCopy(MemoryCopy* curr) { return builder.makeMemoryCopy( copy(curr->dest), copy(curr->source), copy(curr->size)); } Expression* visitMemoryFill(MemoryFill* curr) { return builder.makeMemoryFill( copy(curr->dest), copy(curr->value), copy(curr->size)); } Expression* visitUnary(Unary* curr) { return builder.makeUnary(curr->op, copy(curr->value)); } Expression* visitBinary(Binary* curr) { return builder.makeBinary(curr->op, copy(curr->left), copy(curr->right)); } Expression* visitSelect(Select* curr) { return builder.makeSelect( copy(curr->condition), copy(curr->ifTrue), copy(curr->ifFalse)); } Expression* visitDrop(Drop* curr) { return builder.makeDrop(copy(curr->value)); } Expression* visitReturn(Return* curr) { return builder.makeReturn(copy(curr->value)); } Expression* visitHost(Host* curr) { std::vector<Expression*> operands; for (Index i = 0; i < curr->operands.size(); i++) { operands.push_back(copy(curr->operands[i])); } auto* ret = builder.makeHost(curr->op, curr->nameOperand, std::move(operands)); return ret; } Expression* visitNop(Nop* curr) { return builder.makeNop(); } Expression* visitUnreachable(Unreachable* curr) { return builder.makeUnreachable(); } Expression* visitPush(Push* curr) { return builder.makePush(curr->value); } Expression* visitPop(Pop* curr) { return builder.makePop(curr->type); } }; Copier copier(wasm, custom); return copier.copy(original); }"
"static int replace(int argc, const char *argv[], char *newstr) { int i,j,k; struct { char *op; char *str; } ops[] = { { ""add"",     ""A += B""}, { ""adc"",     ""A += B + carry""}, { ""adiw"",    ""A+1:A += B""}, { ""sub"",     ""A -= B""}, { ""subi"",    ""A -= B""}, { ""sbc"",     ""A -= (B + carry)""}, { ""sbci"",    ""A -= (B + carry)""}, { ""sbiw"",    ""A+1:A -= B""}, { ""and"",     ""A &= B""}, { ""andi"",    ""A &= B""}, { ""or"",      ""A |= B""}, { ""ori"",     ""A |= B""}, { ""eor"",     ""A ^= B""}, { ""com"",     ""A = 0xff - A""}, { ""neg"",     ""A = -A""}, { ""sbr"",     ""A |= B""}, { ""cbr"",     ""A &= (0xff - B)""}, { ""inc"",     ""A++""}, { ""dec"",     ""A--""}, { ""tst"",     ""A &= A""}, { ""clr"",     ""A ^= A""}, { ""ser"",     ""A = 0xff""}, { ""mul"",     ""r1:r0 = A * B""}, { ""rjmp"",    ""goto A""}, { ""ijmp"",    ""goto z""}, { ""jmp"",     ""goto A""}, { ""rcall"",   ""goto A""}, { ""icall"",   ""goto z""}, { ""call"",    ""goto A""}, { ""ret"",     ""return""}, { ""iret"",    ""return_interrupt()""}, { ""cp"",      ""var = A - B""}, { ""cpc"",     ""var = A - B - carry""}, { ""cpi"",     ""var = A - B""}, { ""breq"",    ""if(!var) goto A""}, { ""brne"",    ""if(var) goto A""}, { ""brsh"",    ""if(var >= 0) goto A""}, { ""brlo"",    ""if(var < 0) goto A""}, { ""brmi"",    ""if(var < 0) goto A""}, { ""brpl"",    ""if(var > 0) goto A""}, { ""brge"",    ""if(var >= 0) goto A""}, { ""brlt"",    ""if(var < 0) goto A""}, { ""mov"",     ""A = B""}, { ""movw"",    ""A+1:A = B+1:B""}, { ""ldi"",     ""A = B""}, { ""lds"",     ""A = *(B)""}, { ""ld"",      ""A = *(B)""}, { ""ldd"",     ""A = *(B)""}, { ""lpm"",     ""r0 = z""}, { ""in"",      ""A = B""}, { ""out"",     ""A = B""}, { ""push"",    ""push(A)""}, { ""pop"",     ""A = pop()""}, { ""lsl"",     ""A <<= 1""}, { ""lsr"",     ""A >>= 1""}, { ""rol"",     ""A = (A << 1) | (A >> 7)""}, { ""ror"",     ""A = (A << 7) | (A >> 1)""}, { ""asr"",     ""A >>= 1""}, { ""swap"",    ""A = ((A & 0xf0) >> 4) | ((A & 0x0f) << 4)""}, { ""sec"",     ""c = 1""}, { ""clc"",     ""c = 0""}, { ""sen"",     ""n = 1""}, { ""cln"",     ""n = 0""}, { ""sez"",     ""z = 1""}, { ""clz"",     ""z = 0""}, { ""sei"",     ""i = 1""}, { ""cli"",     ""i = 0""}, { ""ses"",     ""s = 1""}, { ""cls"",     ""s = 0""}, { ""sev"",     ""v = 1""}, { ""clv"",     ""v = 0""}, { ""set"",     ""t = 1""}, { ""clt"",     ""t = 0""}, { ""seh"",     ""h = 1""}, { ""clh"",     ""h = 0""}, { ""nop"",     """"}, { ""halt"",    ""_halt()""}, { ""wdr"",     ""_watchdog_reset()""}, { ""std"",     ""*(A) = B""}, { ""st"",      ""*(A) = B""}, { ""sts"",     ""*(A) = B""}, { NULL } }; for (i = 0; ops[i].op != NULL; i++) { if (!strcmp (ops[i].op, argv[0])) { if (newstr != NULL) { for (j = k = 0; ops[i].str[j] != '\0'; j++, k++) { if (ops[i].str[j] >= 'A' && ops[i].str[j] <= 'J') { const char *w = argv[ops[i].str[j] - '@']; if (w != NULL) { strcpy (newstr + k, w); k += strlen(w) - 1; } } else { newstr[k] = ops[i].str[j]; } } newstr[k] = '\0'; } return true; } } if (newstr != NULL) { newstr[0] = '\0'; for (i = 0; i < argc; i++) { strcat (newstr, argv[i]); strcat (newstr, (i == 0 || i == argc - 1) ? "" "":"", ""); } } return false; }"
"void LoadIC::UpdateCaches(LookupIterator* lookup) { if (state() == UNINITIALIZED) { if (UseVector()) { ConfigureVectorState(PREMONOMORPHIC); } else { set_target(*pre_monomorphic_stub()); } TRACE_IC(""LoadIC"", lookup->name()); return; } Handle<Code> code; if (lookup->state() == LookupIterator::JSPROXY || lookup->state() == LookupIterator::ACCESS_CHECK) { code = slow_stub(); } else if (!lookup->IsFound()) { if (kind() == Code::LOAD_IC) { code = NamedLoadHandlerCompiler::ComputeLoadNonexistent(lookup->name(), receiver_map()); if (code.is_null()) code = slow_stub(); } else { code = slow_stub(); } } else { code = ComputeHandler(lookup); } PatchCache(lookup->name(), code); TRACE_IC(""LoadIC"", lookup->name()); }"
"static int p54u_probe(struct usb_interface *intf, const struct usb_device_id *id) { struct usb_device *udev = interface_to_usbdev(intf); struct ieee80211_hw *dev; struct p54u_priv *priv; int err; unsigned int i, recognized_pipes; dev = p54_init_common(sizeof(*priv)); if (!dev) { dev_err(&udev->dev, ""(p54usb) ieee80211 alloc failed\n""); return -ENOMEM; } priv = dev->priv; priv->hw_type = P54U_INVALID_HW; SET_IEEE80211_DEV(dev, &intf->dev); usb_set_intfdata(intf, dev); priv->udev = udev; priv->intf = intf; skb_queue_head_init(&priv->rx_queue); init_usb_anchor(&priv->submitted); usb_get_dev(udev); i = intf->altsetting->desc.bNumEndpoints; recognized_pipes = 0; while (i--) { switch (intf->altsetting->endpoint[i].desc.bEndpointAddress) { case P54U_PIPE_DATA: case P54U_PIPE_MGMT: case P54U_PIPE_BRG: case P54U_PIPE_DEV: case P54U_PIPE_DATA | USB_DIR_IN: case P54U_PIPE_MGMT | USB_DIR_IN: case P54U_PIPE_BRG | USB_DIR_IN: case P54U_PIPE_DEV | USB_DIR_IN: case P54U_PIPE_INT | USB_DIR_IN: recognized_pipes++; } } priv->common.open = p54u_open; priv->common.stop = p54u_stop; if (recognized_pipes < P54U_PIPE_NUMBER) { #ifdef CONFIG_PM udev->reset_resume = 1; #endif  err = p54u_device_reset(dev); priv->hw_type = P54U_3887; dev->extra_tx_headroom += sizeof(struct lm87_tx_hdr); priv->common.tx_hdr_len = sizeof(struct lm87_tx_hdr); priv->common.tx = p54u_tx_lm87; priv->upload_fw = p54u_upload_firmware_3887; } else { priv->hw_type = P54U_NET2280; dev->extra_tx_headroom += sizeof(struct net2280_tx_hdr); priv->common.tx_hdr_len = sizeof(struct net2280_tx_hdr); priv->common.tx = p54u_tx_net2280; priv->upload_fw = p54u_upload_firmware_net2280; } err = p54u_load_firmware(dev, intf); if (err) { usb_put_dev(udev); p54_free_common(dev); } return err; }"
"void CMapLayers::LoadEnvPoints(const CLayers *pLayers, array<CEnvPoint>& lEnvPoints) { lEnvPoints.clear(); CEnvPoint *pPoints = 0x0; { int Start, Num; pLayers->Map()->GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num); if(!Num) return; pPoints = (CEnvPoint *)pLayers->Map()->GetItem(Start, 0, 0); } int Start, Num; pLayers->Map()->GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num); if(!Num) return; for(int env = 0; env < Num; env++) { CMapItemEnvelope *pItem = (CMapItemEnvelope *)pLayers->Map()->GetItem(Start+env, 0, 0); if(pItem->m_Version >= 3) { for(int i = 0; i < pItem->m_NumPoints; i++) lEnvPoints.add(pPoints[i + pItem->m_StartPoint]); } else { for(int i = 0; i < pItem->m_NumPoints; i++) { CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pPoints)[i + pItem->m_StartPoint]; CEnvPoint p; p.m_Time = pEnvPoint_v1->m_Time; p.m_Curvetype = pEnvPoint_v1->m_Curvetype; for(int c = 0; c < pItem->m_Channels; c++) { p.m_aValues[c] = pEnvPoint_v1->m_aValues[c]; p.m_aInTangentdx[c] = 0; p.m_aInTangentdy[c] = 0; p.m_aOutTangentdx[c] = 0; p.m_aOutTangentdy[c] = 0; } lEnvPoints.add(p); } } } }"
"static gboolean dissect_fragmented_payload(tvbuff_t *payload_tvb, packet_info *pinfo, proto_tree *tree, proto_tree *chunk_tree, guint32 tsn, guint32 ppi, guint16 stream_id, guint32 stream_seq_num, guint8 b_bit, guint8 e_bit, guint8 u_bit, gboolean is_idata) { sctp_fragment *fragment; tvbuff_t *new_tvb = NULL; if (tvb_reported_length(payload_tvb) > tvb_captured_length(payload_tvb)) return TRUE; fragment = add_fragment(payload_tvb, pinfo, chunk_tree, tsn, stream_id, stream_seq_num, b_bit, e_bit, u_bit, ppi, is_idata); if (fragment) new_tvb = fragment_reassembly(payload_tvb, fragment, pinfo, chunk_tree, stream_id, stream_seq_num, u_bit); if (new_tvb){ wmem_list_frame_t *cur; guint proto_id; const gchar *proto_name; gboolean retval; void *tmp; cur = wmem_list_tail(pinfo->layers); retval = dissect_payload(new_tvb, pinfo, tree, ppi); cur = wmem_list_frame_next(cur); tmp = wmem_list_frame_data(cur); proto_id = GPOINTER_TO_UINT(tmp); proto_name = proto_get_protocol_filter_name(proto_id); if(strcmp(proto_name, ""data"") != 0){ if (have_tap_listener(exported_pdu_tap)){ export_sctp_data_chunk(pinfo,payload_tvb, proto_name); } } return retval; } return TRUE; }"
"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) { int new_mi_size; vp9_set_mb_mi(cm, width, height); new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows); if (cm->mi_alloc_size < new_mi_size) { cm->free_mi(cm); if (cm->alloc_mi(cm, new_mi_size)) goto fail; } if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) { free_seg_map(cm); if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail; } if (cm->above_context_alloc_cols < cm->mi_cols) { vpx_free(cm->above_context); cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc( 2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE, sizeof(*cm->above_context)); if (!cm->above_context) goto fail; vpx_free(cm->above_seg_context); cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc( mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context)); if (!cm->above_seg_context) goto fail; cm->above_context_alloc_cols = cm->mi_cols; } return 0; fail: vp9_free_context_buffers(cm); return 1; }"
"IdKeyPair UserTerminalRouter::acceptNewConnection() { LOG(INFO) << ""Listening to id/key FIFO""; int terminalFd = socketHandler->accept(serverFd); if (terminalFd < 0) { if (GetErrno() != EAGAIN && GetErrno() != EWOULDBLOCK) { FATAL_FAIL(-1);      } else { return IdKeyPair({"""", """"});      } } LOG(INFO) << ""Connected""; try { Packet packet; if (!socketHandler->readPacket(terminalFd, &packet)) { STFATAL << ""Missing user info packet""; } if (packet.getHeader() != TerminalPacketType::TERMINAL_USER_INFO) { STFATAL << ""Got an invalid packet header: "" << int(packet.getHeader()); } TerminalUserInfo tui = stringToProto<TerminalUserInfo>(packet.getPayload()); tui.set_fd(terminalFd); idInfoMap[tui.id()] = tui; return IdKeyPair({tui.id(), tui.passkey()}); } catch (const std::runtime_error &re) { STFATAL << ""Router can't talk to terminal: "" << re.what(); } STFATAL << ""Should never get here""; return IdKeyPair({"""", """"}); }"
"static char *pool_strdup(const char *s) { char *r = pool_alloc(strlen(s) + 1); strcpy(r, s); return r; }"
"static int do_mq_notify(mqd_t mqdes, const struct sigevent *notification) { int ret; struct fd f; struct sock *sock; struct inode *inode; struct mqueue_inode_info *info; struct sk_buff *nc; audit_mq_notify(mqdes, notification); nc = NULL; sock = NULL; if (notification != NULL) { if (unlikely(notification->sigev_notify != SIGEV_NONE && notification->sigev_notify != SIGEV_SIGNAL && notification->sigev_notify != SIGEV_THREAD)) return -EINVAL; if (notification->sigev_notify == SIGEV_SIGNAL && !valid_signal(notification->sigev_signo)) { return -EINVAL; } if (notification->sigev_notify == SIGEV_THREAD) { long timeo; nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL); if (!nc) { ret = -ENOMEM; goto out; } if (copy_from_user(nc->data, notification->sigev_value.sival_ptr, NOTIFY_COOKIE_LEN)) { ret = -EFAULT; goto out; } skb_put(nc, NOTIFY_COOKIE_LEN); retry: f = fdget(notification->sigev_signo); if (!f.file) { ret = -EBADF; goto out; } sock = netlink_getsockbyfilp(f.file); fdput(f); if (IS_ERR(sock)) { ret = PTR_ERR(sock); sock = NULL; goto out; } timeo = MAX_SCHEDULE_TIMEOUT; ret = netlink_attachskb(sock, nc, &timeo, NULL); if (ret == 1) goto retry; if (ret) { sock = NULL; nc = NULL; goto out; } } } f = fdget(mqdes); if (!f.file) { ret = -EBADF; goto out; } inode = file_inode(f.file); if (unlikely(f.file->f_op != &mqueue_file_operations)) { ret = -EBADF; goto out_fput; } info = MQUEUE_I(inode); ret = 0; spin_lock(&info->lock); if (notification == NULL) { if (info->notify_owner == task_tgid(current)) { remove_notification(info); inode->i_atime = inode->i_ctime = current_time(inode); } } else if (info->notify_owner != NULL) { ret = -EBUSY; } else { switch (notification->sigev_notify) { case SIGEV_NONE: info->notify.sigev_notify = SIGEV_NONE; break; case SIGEV_THREAD: info->notify_sock = sock; info->notify_cookie = nc; sock = NULL; nc = NULL; info->notify.sigev_notify = SIGEV_THREAD; break; case SIGEV_SIGNAL: info->notify.sigev_signo = notification->sigev_signo; info->notify.sigev_value = notification->sigev_value; info->notify.sigev_notify = SIGEV_SIGNAL; break; } info->notify_owner = get_pid(task_tgid(current)); info->notify_user_ns = get_user_ns(current_user_ns()); inode->i_atime = inode->i_ctime = current_time(inode); } spin_unlock(&info->lock); out_fput: fdput(f); out: if (sock) netlink_detachskb(sock, nc); else if (nc) dev_kfree_skb(nc); return ret; }"
"static pdf_xref_entry * pdf_load_obj_stm(fz_context *ctx, pdf_document *doc, int num, pdf_lexbuf *buf, int target) { fz_stream *stm = NULL; pdf_obj *objstm = NULL; int *numbuf = NULL; int64_t *ofsbuf = NULL; pdf_obj *obj; int64_t first; int count; int i; pdf_token tok; pdf_xref_entry *ret_entry = NULL; fz_var(numbuf); fz_var(ofsbuf); fz_var(objstm); fz_var(stm); fz_try(ctx) { objstm = pdf_load_object(ctx, doc, num); count = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_N)); first = pdf_to_int(ctx, pdf_dict_get(ctx, objstm, PDF_NAME_First)); if (count < 0) fz_throw(ctx, FZ_ERROR_GENERIC, ""negative number of objects in object stream""); if (first < 0) fz_throw(ctx, FZ_ERROR_GENERIC, ""first object in object stream resides outside stream""); numbuf = fz_calloc(ctx, count, sizeof(*numbuf)); ofsbuf = fz_calloc(ctx, count, sizeof(*ofsbuf)); stm = pdf_open_stream_number(ctx, doc, num); for (i = 0; i < count; i++) { tok = pdf_lex(ctx, stm, buf); if (tok != PDF_TOK_INT) fz_throw(ctx, FZ_ERROR_GENERIC, ""corrupt object stream (%d 0 R)"", num); numbuf[i] = buf->i; tok = pdf_lex(ctx, stm, buf); if (tok != PDF_TOK_INT) fz_throw(ctx, FZ_ERROR_GENERIC, ""corrupt object stream (%d 0 R)"", num); ofsbuf[i] = buf->i; } fz_seek(ctx, stm, first, SEEK_SET); for (i = 0; i < count; i++) { int xref_len = pdf_xref_len(ctx, doc); pdf_xref_entry *entry; fz_seek(ctx, stm, first + ofsbuf[i], SEEK_SET); obj = pdf_parse_stm_obj(ctx, doc, stm, buf); if (numbuf[i] <= 0 || numbuf[i] >= xref_len) { pdf_drop_obj(ctx, obj); fz_throw(ctx, FZ_ERROR_GENERIC, ""object id (%d 0 R) out of range (0..%d)"", numbuf[i], xref_len - 1); } entry = pdf_get_xref_entry(ctx, doc, numbuf[i]); pdf_set_obj_parent(ctx, obj, numbuf[i]); if (entry->type == 'o' && entry->ofs == num) { if (entry->obj) { if (pdf_objcmp(ctx, entry->obj, obj)) fz_warn(ctx, ""Encountered new definition for object %d - keeping the original one"", numbuf[i]); pdf_drop_obj(ctx, obj); } else { entry->obj = obj; fz_drop_buffer(ctx, entry->stm_buf); entry->stm_buf = NULL; } if (numbuf[i] == target) ret_entry = entry; } else { pdf_drop_obj(ctx, obj); } } } fz_always(ctx) { fz_drop_stream(ctx, stm); fz_free(ctx, ofsbuf); fz_free(ctx, numbuf); pdf_drop_obj(ctx, objstm); } fz_catch(ctx) { fz_rethrow(ctx); } return ret_entry; }"
"status_t HevcParameterSets::addNalUnit(const uint8_t* data, size_t size) { uint8_t nalUnitType = (data[0] >> 1) & 0x3f; status_t err = OK; switch (nalUnitType) { case 32:              err = parseVps(data + 2, size - 2); break; case 33:              err = parseSps(data + 2, size - 2); break; case 34:              err = parsePps(data + 2, size - 2); break; case 39:          case 40:                          break; default: ALOGE(""Unrecognized NAL unit type.""); return ERROR_MALFORMED; } if (err != OK) { return err; } sp<ABuffer> buffer = ABuffer::CreateAsCopy(data, size); buffer->setInt32Data(nalUnitType); mNalUnits.push(buffer); return OK; }"
"void f_fullcommand(typval_T *argvars, typval_T *rettv) { exarg_Tea; char_u*name; char_u*p; intvim9script = in_vim9script(); intsave_cmod_flags = cmdmod.cmod_flags; rettv->v_type = VAR_STRING; rettv->vval.v_string = NULL; if (in_vim9script() && (check_for_string_arg(argvars, 0) == FAIL || check_for_opt_bool_arg(argvars, 1) == FAIL)) return; name = argvars[0].vval.v_string; if (name == NULL) return; if (argvars[1].v_type != VAR_UNKNOWN) { vim9script = tv_get_bool(&argvars[1]); cmdmod.cmod_flags &= ~(CMOD_VIM9CMD | CMOD_LEGACY); cmdmod.cmod_flags |= vim9script ? CMOD_VIM9CMD : CMOD_LEGACY; } while (*name == ':') name++; name = skip_range(name, TRUE, NULL); ea.cmd = (*name == '2' || *name == '3') ? name + 1 : name; ea.cmdidx = (cmdidx_T)0; ea.addr_count = 0; ++emsg_silent;      p = find_ex_command(&ea, NULL, NULL, NULL); --emsg_silent; if (p == NULL || ea.cmdidx == CMD_SIZE) goto theend; if (vim9script) { int     res; ++emsg_silent; res = not_in_vim9(&ea); --emsg_silent; if (res == FAIL) goto theend; } rettv->vval.v_string = vim_strsave(IS_USER_CMDIDX(ea.cmdidx) ? get_user_command_name(ea.useridx, ea.cmdidx) : cmdnames[ea.cmdidx].cmd_name); theend: cmdmod.cmod_flags = save_cmod_flags; }"
"static int mem_resize(jas_stream_memobj_t *m, int bufsize) { unsigned char *buf; assert(bufsize >= 0); JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize)); if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) && bufsize) { JAS_DBGLOG(100, (""mem_resize realloc failed\n"")); return -1; } JAS_DBGLOG(100, (""mem_resize realloc succeeded\n"")); m->buf_ = buf; m->bufsize_ = bufsize; return 0; }"
"static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl) { uint32_t delta_poc_st, strp_entry_sign_flag = 0; rpl->ref_pic_num = get_ue_golomb_long(gb); if (rpl->ref_pic_num > 0) { delta_poc_st = get_ue_golomb_long(gb); rpl->ref_pics[0] = delta_poc_st; if (rpl->ref_pics[0] != 0) { strp_entry_sign_flag = get_bits(gb, 1); rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1); } } for (int i = 1; i < rpl->ref_pic_num; ++i) { delta_poc_st = get_ue_golomb_long(gb); if (delta_poc_st != 0) strp_entry_sign_flag = get_bits(gb, 1); rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1)); } return 0; }"
"void _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1) { SYMENT *ext = (SYMENT *) ext1; struct internal_syment *in = (struct internal_syment *) in1; if (ext->e.e_name[0] == 0) { in->_n._n_n._n_zeroes = 0; in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset); } else memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN); in->n_value = H_GET_32 (abfd, ext->e_value); in->n_scnum = (short) H_GET_16 (abfd, ext->e_scnum); if (sizeof (ext->e_type) == 2) in->n_type = H_GET_16 (abfd, ext->e_type); else in->n_type = H_GET_32 (abfd, ext->e_type); in->n_sclass = H_GET_8 (abfd, ext->e_sclass); in->n_numaux = H_GET_8 (abfd, ext->e_numaux); #ifndef STRICT_PE_FORMAT if (in->n_sclass == C_SECTION) { char namebuf[SYMNMLEN + 1]; const char *name = NULL; in->n_value = 0x0; if (in->n_scnum == 0) { asection *sec; name = _bfd_coff_internal_syment_name (abfd, in, namebuf); if (name == NULL) { _bfd_error_handler (_(""%pB: unable to find name for empty section""), abfd); bfd_set_error (bfd_error_invalid_target); return; } sec = bfd_get_section_by_name (abfd, name); if (sec != NULL) in->n_scnum = sec->target_index; } if (in->n_scnum == 0) { int unused_section_number = 0; asection *sec; flagword flags; for (sec = abfd->sections; sec; sec = sec->next) if (unused_section_number <= sec->target_index) unused_section_number = sec->target_index + 1; if (name == namebuf) { name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1); if (name == NULL) { _bfd_error_handler (_(""%pB: out of memory creating name for empty section""), abfd); return; } strcpy ((char *) name, namebuf); } flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD; sec = bfd_make_section_anyway_with_flags (abfd, name, flags); if (sec == NULL) { _bfd_error_handler (_(""%pB: unable to create fake empty section""), abfd); return; } sec->vma = 0; sec->lma = 0; sec->size = 0; sec->filepos = 0; sec->rel_filepos = 0; sec->reloc_count = 0; sec->line_filepos = 0; sec->lineno_count = 0; sec->userdata = NULL; sec->next = NULL; sec->alignment_power = 2; sec->target_index = unused_section_number; in->n_scnum = unused_section_number; } in->n_sclass = C_STAT; } #endif #ifdef coff_swap_sym_in_hook coff_swap_sym_in_hook (abfd, ext1, in1); #endif }"
"bool lcPiecesLibrary::LoadTexture(lcTexture* Texture) { char FileName[2*LC_MAXPATH]; if (mZipFiles[static_cast<int>(lcZipFileType::Official)]) { lcMemFile TextureFile; sprintf(FileName, ""parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Unofficial)] || !mZipFiles[static_cast<int>(lcZipFileType::Unofficial)]->ExtractFile(FileName, TextureFile)) { sprintf(FileName, ""ldraw/parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Official)]->ExtractFile(FileName, TextureFile)) return false; } return Texture->Load(TextureFile); } else return Texture->Load(Texture->mFileName); }"
"static int z2restore(i_ctx_t *i_ctx_p) { alloc_save_t *asave; bool saveLockSafety = gs_currentdevice_inline(igs)->LockSafetyParams; int code = restore_check_save(i_ctx_p, &asave); if (code < 0) return code; while (gs_gstate_saved(gs_gstate_saved(igs))) { if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restore1pagedevice""); gs_grestore(igs); } if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restorepagedevice""); code = dorestore(i_ctx_p, asave); if (code < 0) { gs_currentdevice_inline(igs)->LockSafetyParams = saveLockSafety; } return code; }"
"PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2( pjmedia_rtp_session *ses, const void *pkt, int pkt_len, const pjmedia_rtp_hdr **hdr, pjmedia_rtp_dec_hdr *dec_hdr, const void **payload, unsigned *payloadlen) { int offset; PJ_UNUSED_ARG(ses); *hdr = (pjmedia_rtp_hdr*)pkt; if ((*hdr)->v != RTP_VERSION) { return PJMEDIA_RTP_EINVER; } offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t)); if ((*hdr)->x) { dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset); dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1); dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length); offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t)); } else { dec_hdr->ext_hdr = NULL; dec_hdr->ext = NULL; dec_hdr->ext_len = 0; } if (offset > pkt_len) return PJMEDIA_RTP_EINLEN; *payload = ((pj_uint8_t*)pkt) + offset; *payloadlen = pkt_len - offset; if ((*hdr)->p && *payloadlen > 0) { pj_uint8_t pad_len; pad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1]; if (pad_len <= *payloadlen) *payloadlen -= pad_len; } return PJ_SUCCESS; }"
"int parse_mpls(const u_char *pktdata, uint32_t datalen, uint16_t *next_protocol, uint32_t *l2len, uint32_t *l2offset) { struct tcpr_mpls_label *mpls_label; const u_char *end_ptr = pktdata + datalen; u_char first_nibble; eth_hdr_t *eth_hdr; bool bos = false; uint32_t label; int len; assert(next_protocol); assert(l2len); assert(l2offset); len = (int)*l2len; while (!bos) { if (pktdata + len + sizeof(*mpls_label) > end_ptr) return -1; mpls_label = (struct tcpr_mpls_label *)(pktdata + len); len += sizeof(*mpls_label); bos = (ntohl(mpls_label->entry) & MPLS_LS_S_MASK) != 0; label = ntohl(mpls_label->entry) >> MPLS_LS_LABEL_SHIFT; if (label == MPLS_LABEL_GACH) { warn(""GACH MPLS label not supported at this time""); return -1; } } if ((u_char *)mpls_label + 1 > end_ptr) return -1; first_nibble = *((u_char *)(mpls_label + 1)) >> 4; switch (first_nibble) { case 4: *next_protocol = ETHERTYPE_IP; break; case 6: *next_protocol = ETHERTYPE_IP6; break; case 0: if (pktdata + len + 4 + sizeof(*eth_hdr) > end_ptr) return -1; len += 4; *l2offset = len; eth_hdr = (eth_hdr_t *)(pktdata + len); len += sizeof(*eth_hdr); *next_protocol = ntohs(eth_hdr->ether_type); break; default: return -1; } *l2len = (uint32_t)len; return 0; }"
"int input_set_keycode(struct input_dev *dev, const struct input_keymap_entry *ke) { unsigned long flags; unsigned int old_keycode; int retval; if (ke->keycode > KEY_MAX) return -EINVAL; spin_lock_irqsave(&dev->event_lock, flags); retval = dev->setkeycode(dev, ke, &old_keycode); if (retval) goto out; __clear_bit(KEY_RESERVED, dev->keybit); if (test_bit(EV_KEY, dev->evbit) && !is_event_supported(old_keycode, dev->keybit, KEY_MAX) && __test_and_clear_bit(old_keycode, dev->key)) { struct input_value vals[] =  { { EV_KEY, old_keycode, 0 }, input_value_sync }; input_pass_values(dev, vals, ARRAY_SIZE(vals)); } out: spin_unlock_irqrestore(&dev->event_lock, flags); return retval; }"
"GF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs) { u32 i; u32 sampleCount; GF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s; ISOM_DECREASE_SIZE(ptr, 4); ptr->nb_entries = gf_bs_read_u32(bs); if (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid number of entries %d in ctts\n"", ptr->nb_entries)); return GF_ISOM_INVALID_FILE; } ptr->alloc_size = ptr->nb_entries; ptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size); if (!ptr->entries) return GF_OUT_OF_MEM; sampleCount = 0; for (i=0; i<ptr->nb_entries; i++) { ISOM_DECREASE_SIZE(ptr, 8); ptr->entries[i].sampleCount = gf_bs_read_u32(bs); if (ptr->version) ptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32); else ptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs); if (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) { ptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset); } sampleCount += ptr->entries[i].sampleCount; } #ifndef GPAC_DISABLE_ISOM_WRITE ptr->w_LastSampleNumber = sampleCount; #endif return GF_OK; }"
"char **XGetFontPath( register Display *dpy, int *npaths) { xGetFontPathReply rep; unsigned long nbytes = 0; char **flist = NULL; char *ch = NULL; char *chend; int count = 0; register unsigned i; register int length; _X_UNUSED register xReq *req; LockDisplay(dpy); GetEmptyReq (GetFontPath, req); (void) _XReply (dpy, (xReply *) &rep, 0, xFalse); if (rep.nPaths) { flist = Xmalloc(rep.nPaths * sizeof (char *)); if (rep.length < (INT_MAX >> 2)) { nbytes = (unsigned long) rep.length << 2; ch = Xmalloc (nbytes + 1); } if ((! flist) || (! ch)) { Xfree(flist); Xfree(ch); _XEatDataWords(dpy, rep.length); UnlockDisplay(dpy); SyncHandle(); return (char **) NULL; } _XReadPad (dpy, ch, nbytes); chend = ch + nbytes; length = *ch; for (i = 0; i < rep.nPaths; i++) { if (ch + length < chend) { flist[i] = ch+1;   ch += length + 1;  length = *ch; *ch = '\0';  count++; } else flist[i] = NULL; } } *npaths = count; UnlockDisplay(dpy); SyncHandle(); return (flist); }"
"static void cifs_compound_callback(struct mid_q_entry *mid) { struct TCP_Server_Info *server = mid->server; struct cifs_credits credits; credits.value = server->ops->get_credits(mid); credits.instance = server->reconnect_instance; add_credits(server, &credits, mid->optype); }"
"static int get_max_inline_xattr_value_size(struct inode *inode, struct ext4_iloc *iloc) { struct ext4_xattr_ibody_header *header; struct ext4_xattr_entry *entry; struct ext4_inode *raw_inode; int free, min_offs; if (!EXT4_INODE_HAS_XATTR_SPACE(inode)) return 0; min_offs = EXT4_SB(inode->i_sb)->s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - EXT4_I(inode)->i_extra_isize - sizeof(struct ext4_xattr_ibody_header); if (!ext4_test_inode_state(inode, EXT4_STATE_XATTR)) return EXT4_XATTR_SIZE(min_offs - EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)) - EXT4_XATTR_ROUND - sizeof(__u32)); raw_inode = ext4_raw_inode(iloc); header = IHDR(inode, raw_inode); entry = IFIRST(header); for (; !IS_LAST_ENTRY(entry); entry = EXT4_XATTR_NEXT(entry)) { if (!entry->e_value_inum && entry->e_value_size) { size_t offs = le16_to_cpu(entry->e_value_offs); if (offs < min_offs) min_offs = offs; } } free = min_offs - ((void *)entry - (void *)IFIRST(header)) - sizeof(__u32); if (EXT4_I(inode)->i_inline_off) { entry = (struct ext4_xattr_entry *) ((void *)raw_inode + EXT4_I(inode)->i_inline_off); free += EXT4_XATTR_SIZE(le32_to_cpu(entry->e_value_size)); goto out; } free -= EXT4_XATTR_LEN(strlen(EXT4_XATTR_SYSTEM_DATA)); if (free > EXT4_XATTR_ROUND) free = EXT4_XATTR_SIZE(free - EXT4_XATTR_ROUND); else free = 0; out: return free; }"
"int main(int argc, char** argv) { WinsockContext context; string tmpDir = GetTempDirectory(); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); LogHandler::setupStdoutLogger(); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); cxxopts::Options options(""et"", ""Remote shell for the busy and impatient""); try { options.allow_unrecognised_options(); options.positional_help(""""); options.custom_help( ""[OPTION...] [user@]host[:port]\n\n"" ""  Note that 'host' can be a hostname or ipv4 address with or without "" ""a port\n  or an ipv6 address. If the ipv6 address is abbreviated with "" "":: then it must\n  be specfied without a port (use -p,--port).""); options.add_options()                     (""h,help"", ""Print help"")              (""version"", ""Print version"")          (""u,username"", ""Username"")            (""host"", ""Remote host name"", cxxopts::value<std::string>())          (""p,port"", ""Remote machine etserver port"", cxxopts::value<int>()->default_value(""2022""))          (""c,command"", ""Run command on connect"", cxxopts::value<std::string>())          (""terminal-path"", ""Path to etterminal on server side. "" ""Use if etterminal is not on the system path."", cxxopts::value<std::string>())          (""t,tunnel"", ""Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. "" ""10080:80,10443:443, 10090-10092:8000-8002)"", cxxopts::value<std::string>())          (""r,reversetunnel"", ""Reverse Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges"", cxxopts::value<std::string>())          (""jumphost"", ""jumphost between localhost and destination"", cxxopts::value<std::string>())          (""jport"", ""Jumphost machine port"", cxxopts::value<int>()->default_value(""2022""))          (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")          (""macserver"", ""Set when connecting to an macOS server.  Sets "" ""--terminal-path=/usr/local/bin/etterminal"")          (""v,verbose"", ""Enable verbose logging"", cxxopts::value<int>()->default_value(""0""))          (""k,keepalive"", ""Client keepalive duration in seconds"", cxxopts::value<int>())                                      (""logtostdout"", ""Write log to stdout"")                       (""silent"", ""Disable logging"")                                (""N,no-terminal"", ""Do not create a terminal"")                (""f,forward-ssh-agent"", ""Forward ssh-agent socket"")          (""ssh-socket"", ""The ssh-agent socket to forward"", cxxopts::value<std::string>())          (""telemetry"", ""Allow et to anonymously send errors to guide future improvements"", cxxopts::value<bool>()->default_value(""true""))          (""serverfifo"", ""If set, communicate to etserver on the matching fifo name"", cxxopts::value<std::string>()->default_value(""""))          (""ssh-option"", ""Options to pass down to `ssh -o`"", cxxopts::value<std::vector<std::string>>()); options.parse_positional({""host""}); auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } if (result.count(""version"")) { CLOG(INFO, ""stdout"") << ""et version "" << ET_VERSION << endl; exit(0); } el::Loggers::setVerboseLevel(result[""verbose""].as<int>()); if (result.count(""logtostdout"")) { defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""true""); } else { defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); LogHandler::stderrToFile((tmpDir + ""/etclient"")); } if (result.count(""silent"")) { defaultConf.setGlobally(el::ConfigurationType::Enabled, ""false""); } LogHandler::setupLogFile( &defaultConf, (tmpDir + ""/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log"")); el::Loggers::reconfigureLogger(""default"", defaultConf); el::Helpers::setThreadName(""client-main""); el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler); GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); TelemetryService::create(result[""telemetry""].as<bool>(), tmpDir + ""/.sentry-native-et"", ""Client""); string username = """"; if (result.count(""username"")) { username = result[""username""].as<string>(); } int destinationPort = result[""port""].as<int>(); string destinationHost; if (!result.count(""host"")) { CLOG(INFO, ""stdout"") << ""Missing host to connect to"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } string host_arg = result[""host""].as<std::string>(); if (host_arg.find('@') != string::npos) { int i = host_arg.find('@'); username = host_arg.substr(0, i); host_arg = host_arg.substr(i + 1); } if (host_arg.find(':') != string::npos) { int colon_count = std::count(host_arg.begin(), host_arg.end(), ':'); if (colon_count == 1) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { if (host_arg.find(""::"") != string::npos) { } else { if (colon_count == 7) { } else if (colon_count == 8) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { CLOG(INFO, ""stdout"") << ""Invalid host positional arg: "" << result[""host""].as<std::string>() << endl; exit(1); } } } } destinationHost = host_arg; string host_alias = destinationHost; string jumphost = result.count(""jumphost"") ? result[""jumphost""].as<string>() : """"; int keepaliveDuration = result.count(""keepalive"") ? result[""keepalive""].as<int>() : MAX_CLIENT_KEEP_ALIVE_DURATION; if (keepaliveDuration < 1 || keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) { CLOG(INFO, ""stdout"") << ""Keep-alive duration must between 1 and "" << MAX_CLIENT_KEEP_ALIVE_DURATION << "" seconds"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } Options sshConfigOptions = { NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          0,             0,             0,             0,             0,             NULL,          NULL,          0,             0,             NULL       }; char* home_dir = ssh_get_user_home_dir(); const char* host_from_command = destinationHost.c_str(); ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST, destinationHost.c_str()); parse_ssh_config_file(host_from_command, &sshConfigOptions, string(home_dir) + USER_SSH_CONFIG_PATH); parse_ssh_config_file(host_from_command, &sshConfigOptions, SYSTEM_SSH_CONFIG_PATH); LOG(INFO) << ""Parsed ssh config file, connecting to "" << sshConfigOptions.host; destinationHost = string(sshConfigOptions.host); if (username.empty()) { if (sshConfigOptions.username) { username = string(sshConfigOptions.username); } else { username = string(ssh_get_local_username()); } } if (sshConfigOptions.ProxyJump && jumphost.length() == 0) { string proxyjump = string(sshConfigOptions.ProxyJump); size_t colonIndex = proxyjump.find("":""); if (colonIndex != string::npos) { string userhostpair = proxyjump.substr(0, colonIndex); size_t atIndex = userhostpair.find(""@""); if (atIndex != string::npos) { jumphost = userhostpair.substr(atIndex + 1); } } else { jumphost = proxyjump; } LOG(INFO) << ""ProxyJump found for dst in ssh config: "" << proxyjump; } bool is_jumphost = false; SocketEndpoint socketEndpoint; if (!jumphost.empty()) { is_jumphost = true; LOG(INFO) << ""Setting port to jumphost port""; socketEndpoint.set_name(jumphost); socketEndpoint.set_port(result[""jport""].as<int>()); } else { socketEndpoint.set_name(destinationHost); socketEndpoint.set_port(destinationPort); } shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler()); shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler()); if (!ping(socketEndpoint, clientSocket)) { CLOG(INFO, ""stdout"") << ""Could not reach the ET server: "" << socketEndpoint.name() << "":"" << socketEndpoint.port() << endl; exit(1); } int jport = result[""jport""].as<int>(); string serverFifo = """"; if (result[""serverfifo""].as<string>() != """") { serverFifo = result[""serverfifo""].as<string>(); } std::vector<string> ssh_options; if (result.count(""ssh-option"")) { ssh_options = result[""ssh-option""].as<std::vector<string>>(); } string etterminal_path = """"; if (result.count(""macserver"") > 0) { etterminal_path = ""/usr/local/bin/etterminal""; } if (result.count(""etterminal_path"")) { etterminal_path = result[""terminal-path""].as<string>(); } string idpasskeypair = SshSetupHandler::SetupSsh( username, destinationHost, host_alias, destinationPort, jumphost, jport, result.count(""x"") > 0, result[""verbose""].as<int>(), etterminal_path, serverFifo, ssh_options); string id = """", passkey = """"; idpasskeypair.erase(idpasskeypair.find_last_not_of("" \n\r\t"") + 1); size_t slashIndex = idpasskeypair.find(""/""); if (slashIndex == string::npos) { STFATAL << ""Invalid idPasskey id/key pair: "" << idpasskeypair; } else { id = idpasskeypair.substr(0, slashIndex); passkey = idpasskeypair.substr(slashIndex + 1); } if (passkey.length() != 32) { STFATAL << ""Invalid/missing passkey: "" << passkey << "" "" << passkey.length(); } shared_ptr<Console> console; if (!result.count(""N"")) { console.reset(new PsuedoTerminalConsole()); } bool forwardAgent = result.count(""f"") > 0; string sshSocket = """"; #ifndef WIN32 if (sshConfigOptions.identity_agent) { sshSocket = string(sshConfigOptions.identity_agent); } forwardAgent |= sshConfigOptions.forward_agent; #endif if (result.count(""ssh-socket"")) { sshSocket = result[""ssh-socket""].as<string>(); } TelemetryService::get()->logToDatadog(""Session Started"", el::Level::Info, __FILE__, __LINE__); string tunnel_arg = result.count(""tunnel"") ? result[""tunnel""].as<string>() : """"; string r_tunnel_arg = result.count(""reversetunnel"") ? result[""reversetunnel""].as<string>() : """"; TerminalClient terminalClient(clientSocket, clientPipeSocket, socketEndpoint, id, passkey, console, is_jumphost, tunnel_arg, r_tunnel_arg, forwardAgent, sshSocket, keepaliveDuration); terminalClient.run(result.count(""command"") ? result[""command""].as<string>() : """"); } catch (TunnelParseException& tpe) { handleParseException(tpe, options); } catch (cxxopts::OptionException& oe) { handleParseException(oe, options); } #ifdef WIN32 WSACleanup(); #endif TelemetryService::get()->shutdown(); TelemetryService::destroy(); el::Helpers::uninstallPreRollOutCallback(); return 0; }"
"int FileIo::Impl::switchMode(OpMode opMode) { assert(fp_ != 0); if (opMode_ == opMode) return 0; OpMode oldOpMode = opMode_; opMode_ = opMode; bool reopen = true; switch(opMode) { case opRead: if (openMode_[0] == 'r' || openMode_[1] == '+') reopen = false; break; case opWrite: if (openMode_[0] != 'r' || openMode_[1] == '+') reopen = false; break; case opSeek: reopen = false; break; } if (!reopen) { if (oldOpMode == opSeek) return 0; std::fseek(fp_, 0, SEEK_CUR); return 0; } long offset = std::ftell(fp_); if (offset == -1) return -1; if (fp_ != 0) { std::fclose(fp_); fp_= 0; } openMode_ = ""r+b""; opMode_ = opSeek; #ifdef EXV_UNICODE_PATH if (wpMode_ == wpUnicode) { fp_ = ::_wfopen(wpath_.c_str(), s2ws(openMode_).c_str()); } else #endif { fp_ = std::fopen(path_.c_str(), openMode_.c_str()); } if (!fp_) return 1; return std::fseek(fp_, offset, SEEK_SET); }"
"static void gdm_display_store_class_init (GdmDisplayStoreClass *klass) { GObjectClass   *object_class = G_OBJECT_CLASS (klass); object_class->finalize = gdm_display_store_finalize; signals [DISPLAY_ADDED] = g_signal_new (""display-added"", G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GdmDisplayStoreClass, display_added), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING); signals [DISPLAY_REMOVED] = g_signal_new (""display-removed"", G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GdmDisplayStoreClass, display_removed), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING); g_type_class_add_private (klass, sizeof (GdmDisplayStorePrivate)); }"
"void Application::handleEditLocally(const QUrl &url) const { auto pathSplit = url.path().split('/', Qt::SkipEmptyParts); if (pathSplit.size() < 2) { qCWarning(lcApplication) << ""Invalid URL for file local editing: "" + pathSplit.join('/'); return; } const auto accountDisplayName = pathSplit.takeFirst(); const auto fileRemotePath = pathSplit.join('/'); FolderMan::instance()->editFileLocally(accountDisplayName, fileRemotePath); }"
"unsigned long X509_issuer_and_serial_hash(X509 *a) { unsigned long ret = 0; EVP_MD_CTX *ctx = EVP_MD_CTX_new(); unsigned char md[16]; char *f; if (ctx == NULL) goto err; f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0); if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL)) goto err; if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f))) goto err; OPENSSL_free(f); if (!EVP_DigestUpdate (ctx, (unsigned char *)a->cert_info.serialNumber.data, (unsigned long)a->cert_info.serialNumber.length)) goto err; if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL)) goto err; ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) | ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L) ) & 0xffffffffL; err: EVP_MD_CTX_free(ctx); return ret; }"
"static int zr364xx_vidioc_querycap(struct file *file, void *priv, struct v4l2_capability *cap) { struct zr364xx_camera *cam = video_drvdata(file); strscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver)); strscpy(cap->card, cam->udev->product, sizeof(cap->card)); strscpy(cap->bus_info, dev_name(&cam->udev->dev), sizeof(cap->bus_info)); cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE | V4L2_CAP_STREAMING; cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS; return 0; }"
"static pj_status_t  codec_open( pjmedia_codec *codec, pjmedia_codec_param *attr ) { struct opus_data *opus_data = (struct opus_data *)codec->codec_data; int idx, err; pj_bool_t auto_bit_rate = PJ_TRUE; PJ_ASSERT_RETURN(codec && attr && opus_data, PJ_EINVAL); pj_mutex_lock (opus_data->mutex); TRACE_((THIS_FILE, ""%s:%d: - TRACE"", __FUNCTION__, __LINE__)); opus_data->cfg.sample_rate = attr->info.clock_rate; opus_data->cfg.channel_cnt = attr->info.channel_cnt; opus_data->enc_ptime = opus_data->dec_ptime = attr->info.frm_ptime; if (!opus_data->enc) { opus_data->enc = pj_pool_zalloc(opus_data->pool, opus_encoder_get_size(2)); } if (!opus_data->dec) { opus_data->dec = pj_pool_zalloc(opus_data->pool, opus_decoder_get_size(2)); } if (!opus_data->enc_packer) { opus_data->enc_packer = pj_pool_zalloc(opus_data->pool, opus_repacketizer_get_size()); } if (!opus_data->dec_packer) { opus_data->dec_packer = pj_pool_zalloc(opus_data->pool, opus_repacketizer_get_size()); } if (!opus_data->enc || !opus_data->dec || !opus_data->enc_packer || !opus_data->dec_packer) { PJ_LOG(2, (THIS_FILE, ""Unable to allocate memory for the codec"")); pj_mutex_unlock (opus_data->mutex); return PJ_ENOMEM; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE); if (idx >= 0) { unsigned rate; auto_bit_rate = PJ_FALSE; rate = (unsigned)pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); if (rate < attr->info.avg_bps) attr->info.avg_bps = rate; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_INBAND_FEC, PJ_FALSE); if (idx >= 0) { unsigned plc; plc = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); attr->setting.plc = plc > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_DTX, PJ_FALSE); if (idx >= 0) { unsigned vad; vad = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); attr->setting.vad = vad > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.enc_fmtp, &STR_CBR, PJ_FALSE); if (idx >= 0) { unsigned cbr; cbr = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val); opus_data->cfg.cbr = cbr > 0? PJ_TRUE: PJ_FALSE; } idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE); if (idx >= 0) { unsigned rate; rate = (unsigned) pj_strtoul(&attr->setting.dec_fmtp.param[idx].val); if (rate < attr->info.avg_bps) attr->info.avg_bps = rate; } TRACE_((THIS_FILE, ""%s:%d: sample_rate: %u"", __FUNCTION__, __LINE__, opus_data->cfg.sample_rate)); err = opus_encoder_init(opus_data->enc, opus_data->cfg.sample_rate, attr->info.channel_cnt, OPUS_APPLICATION_VOIP); if (err != OPUS_OK) { PJ_LOG(2, (THIS_FILE, ""Unable to create encoder"")); return PJMEDIA_CODEC_EFAILED; } opus_encoder_ctl(opus_data->enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_VOICE)); opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(auto_bit_rate? OPUS_AUTO: attr->info.avg_bps)); opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0)); opus_encoder_ctl(opus_data->enc, OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0)); opus_encoder_ctl(opus_data->enc, OPUS_SET_MAX_BANDWIDTH(get_opus_bw_constant( opus_data->cfg.sample_rate))); opus_encoder_ctl(opus_data->enc, OPUS_SET_PACKET_LOSS_PERC(opus_data->cfg.packet_loss)); opus_encoder_ctl(opus_data->enc, OPUS_SET_COMPLEXITY(opus_data->cfg.complexity)); opus_encoder_ctl(opus_data->enc, OPUS_SET_VBR(opus_data->cfg.cbr ? 0 : 1)); PJ_LOG(5, (THIS_FILE, ""Initialize Opus encoder, sample rate: %d, "" ""avg bitrate: %d, vad: %d, plc: %d, pkt loss: %d, "" ""complexity: %d, constant bit rate: %d"", opus_data->cfg.sample_rate, attr->info.avg_bps, attr->setting.vad?1:0, attr->setting.plc?1:0, opus_data->cfg.packet_loss, opus_data->cfg.complexity, opus_data->cfg.cbr?1:0)); err = opus_decoder_init (opus_data->dec, opus_data->cfg.sample_rate, attr->info.channel_cnt); if (err != OPUS_OK) { PJ_LOG(2, (THIS_FILE, ""Unable to initialize decoder"")); return PJMEDIA_CODEC_EFAILED; } opus_data->dec_frame[0].type = PJMEDIA_FRAME_TYPE_NONE; opus_data->dec_frame[0].buf  = pj_pool_zalloc(opus_data->pool,                                    (opus_data->cfg.sample_rate / 1000) * 60 * attr->info.channel_cnt * 2 ); opus_data->dec_frame[1].type = PJMEDIA_FRAME_TYPE_NONE; opus_data->dec_frame[1].buf  = pj_pool_zalloc(opus_data->pool, (opus_data->cfg.sample_rate / 1000) * 60 * attr->info.channel_cnt * 2 ); opus_data->dec_frame_index = -1; opus_repacketizer_init(opus_data->enc_packer); opus_repacketizer_init(opus_data->dec_packer); pj_mutex_unlock (opus_data->mutex); return PJ_SUCCESS; }"
"Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const { std::string image_type = m_heif_file->get_item_type(id); if (image_type==""grid"" || image_type==""iden"" || image_type==""iovl"") { auto iref_box = m_heif_file->get_iref_box(); std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(""dimg"")); if (image_references.empty()) { return Error(heif_error_Invalid_input, heif_suberror_No_item_data, ""Derived image does not reference any other image items""); } else { return get_id_of_non_virtual_child_image(image_references[0], out); } } else { out = id; return Error::Ok; } }"
"static void activate_desktop_file (ActivateParameters *parameters, NautilusFile       *file) { ActivateParametersDesktop *parameters_desktop; char *primary, *secondary, *display_name; GtkWidget *dialog; GdkScreen *screen; char *uri; screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window)); if (!nautilus_file_is_trusted_link (file)) { parameters_desktop = g_new0 (ActivateParametersDesktop, 1); if (parameters->parent_window) { parameters_desktop->parent_window = parameters->parent_window; g_object_add_weak_pointer (G_OBJECT (parameters_desktop->parent_window), (gpointer *) &parameters_desktop->parent_window); } parameters_desktop->file = nautilus_file_ref (file); primary = _(""Untrusted application launcher""); display_name = nautilus_file_get_display_name (file); secondary = g_strdup_printf (_(""The application launcher %s has not been marked as trusted. "" ""If you do not know the source of this file, launching it may be unsafe."" ), display_name); dialog = gtk_message_dialog_new (parameters->parent_window, 0, GTK_MESSAGE_WARNING, GTK_BUTTONS_NONE, NULL); g_object_set (dialog, ""text"", primary, ""secondary-text"", secondary, NULL); gtk_dialog_add_button (GTK_DIALOG (dialog), _(""_Launch Anyway""), RESPONSE_RUN); if (nautilus_file_can_set_permissions (file)) { gtk_dialog_add_button (GTK_DIALOG (dialog), _(""Mark as _Trusted""), RESPONSE_MARK_TRUSTED); } gtk_dialog_add_button (GTK_DIALOG (dialog), _(""_Cancel""), GTK_RESPONSE_CANCEL); gtk_dialog_set_default_response (GTK_DIALOG (dialog), GTK_RESPONSE_CANCEL); g_signal_connect (dialog, ""response"", G_CALLBACK (untrusted_launcher_response_callback), parameters_desktop); gtk_widget_show (dialog); g_free (display_name); g_free (secondary); return; } uri = nautilus_file_get_uri (file); DEBUG (""Launching trusted launcher %s"", uri); nautilus_launch_desktop_file (screen, uri, NULL, parameters->parent_window); g_free (uri); }"
"struct xt_table_info *xt_alloc_table_info(unsigned int size) { struct xt_table_info *info = NULL; size_t sz = sizeof(*info) + size; if ((SMP_ALIGN(size) >> PAGE_SHIFT) + 2 > totalram_pages) return NULL; if (sz <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) info = kmalloc(sz, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY); if (!info) { info = vmalloc(sz); if (!info) return NULL; } memset(info, 0, sizeof(*info)); info->size = size; return info; }"
"static int peak_usb_create_dev(const struct peak_usb_adapter *peak_usb_adapter, struct usb_interface *intf, int ctrl_idx) { struct usb_device *usb_dev = interface_to_usbdev(intf); int sizeof_candev = peak_usb_adapter->sizeof_dev_private; struct peak_usb_device *dev; struct net_device *netdev; int i, err; u16 tmp16; if (sizeof_candev < sizeof(struct peak_usb_device)) sizeof_candev = sizeof(struct peak_usb_device); netdev = alloc_candev(sizeof_candev, PCAN_USB_MAX_TX_URBS); if (!netdev) { dev_err(&intf->dev, ""%s: couldn't alloc candev\n"", PCAN_USB_DRIVER_NAME); return -ENOMEM; } dev = netdev_priv(netdev); dev->cmd_buf = kmalloc(PCAN_USB_MAX_CMD_LEN, GFP_KERNEL); if (!dev->cmd_buf) { err = -ENOMEM; goto lbl_free_candev; } dev->udev = usb_dev; dev->netdev = netdev; dev->adapter = peak_usb_adapter; dev->ctrl_idx = ctrl_idx; dev->state = PCAN_USB_STATE_CONNECTED; dev->ep_msg_in = peak_usb_adapter->ep_msg_in; dev->ep_msg_out = peak_usb_adapter->ep_msg_out[ctrl_idx]; dev->can.clock = peak_usb_adapter->clock; dev->can.bittiming_const = peak_usb_adapter->bittiming_const; dev->can.do_set_bittiming = peak_usb_set_bittiming; dev->can.data_bittiming_const = peak_usb_adapter->data_bittiming_const; dev->can.do_set_data_bittiming = peak_usb_set_data_bittiming; dev->can.do_set_mode = peak_usb_set_mode; dev->can.do_get_berr_counter = peak_usb_adapter->do_get_berr_counter; dev->can.ctrlmode_supported = peak_usb_adapter->ctrlmode_supported; netdev->netdev_ops = &peak_usb_netdev_ops; netdev->flags |= IFF_ECHO;  init_usb_anchor(&dev->rx_submitted); init_usb_anchor(&dev->tx_submitted); atomic_set(&dev->active_tx_urbs, 0); for (i = 0; i < PCAN_USB_MAX_TX_URBS; i++) dev->tx_contexts[i].echo_index = PCAN_USB_MAX_TX_URBS; dev->prev_siblings = usb_get_intfdata(intf); usb_set_intfdata(intf, dev); SET_NETDEV_DEV(netdev, &intf->dev); netdev->dev_id = ctrl_idx; err = register_candev(netdev); if (err) { dev_err(&intf->dev, ""couldn't register CAN device: %d\n"", err); goto lbl_restore_intf_data; } if (dev->prev_siblings) (dev->prev_siblings)->next_siblings = dev; tmp16 = le16_to_cpu(usb_dev->descriptor.bcdDevice); dev->device_rev = tmp16 >> 8; if (dev->adapter->dev_init) { err = dev->adapter->dev_init(dev); if (err) goto lbl_unregister_candev; } if (dev->adapter->dev_set_bus) { err = dev->adapter->dev_set_bus(dev, 0); if (err) goto lbl_unregister_candev; } if (dev->adapter->dev_get_device_id) dev->adapter->dev_get_device_id(dev, &dev->device_number); netdev_info(netdev, ""attached to %s channel %u (device %u)\n"", peak_usb_adapter->name, ctrl_idx, dev->device_number); return 0; lbl_unregister_candev: unregister_candev(netdev); lbl_restore_intf_data: usb_set_intfdata(intf, dev->prev_siblings); kfree(dev->cmd_buf); lbl_free_candev: free_candev(netdev); return err; }"
"Status AutoParallel::Initialize(const GrapplerItem& item) { num_gpus_ = GetNumAvailableGPUs(); LOG(INFO) << ""Number of GPUs: "" << num_gpus_; item_ = &item; graph_ = item.graph; LOG(INFO) << ""Original graph size: "" << graph_.node_size(); if (item.fetch.empty()) { return Status(error::INVALID_ARGUMENT, ""No fetch nodes provided.""); } if (item.MainVariables().empty()) { return Status(error::INVALID_ARGUMENT, ""No variables provided.""); } for (const auto& init : item.init_ops) { VLOG(1) << ""Init node: "" << init; } for (const auto& fetch : item.fetch) { VLOG(1) << ""Fetch node: "" << fetch; } for (const auto& var : item.MainVariables()) { VLOG(2) << ""Variable: "" << var->name(); } const std::set<string> apply_gradients_ops = {""ApplyGradientDescent"", ""ApplyProximalGradientDescent"", ""ApplyAdadelta"", ""ApplyAdagrad"", ""ApplyProximalAdagrad"", ""ApplyAdagradDA"", ""ApplyFtrl"", ""ApplyMomentum"", ""ApplyAdam"", ""ApplyRMSProp"", ""ApplyCenteredRMSProp""}; for (int i = 0; i < graph_.node_size(); i++) { all_nodes_.insert( std::make_pair(graph_.node(i).name(), graph_.mutable_node(i))); if (apply_gradients_ops.find(graph_.node(i).op()) != apply_gradients_ops.end()) { apply_gradients_nodes_.insert(graph_.node(i).name()); VLOG(2) << ""Apply gradients node: "" << graph_.node(i).name(); } } auto div_const_node = AddNodeDivConst(); all_nodes_.insert(std::make_pair(div_const_node->name(), div_const_node)); std::map<string, int> gradient_pos = {{""ApplyGradientDescent"", 2}, {""ApplyProximalGradientDescent"", 4}, {""ApplyAdadelta"", 6}, {""ApplyAdagrad"", 3}, {""ApplyProximalAdagrad"", 5}, {""ApplyAdagradDA"", 3}, {""ApplyFtrl"", 3}, {""ApplyMomentum"", 3}, {""ApplyAdam"", 9}, {""ApplyRMSProp"", 7}, {""ApplyCenteredRMSProp"", 8}}; for (const auto& apply_gradient_node_name : apply_gradients_nodes_) { auto apply_gradients_op = all_nodes_[apply_gradient_node_name]->op(); auto apply_gradients_node = all_nodes_[apply_gradient_node_name]; auto div_node = AddNodeDiv( apply_gradient_node_name, apply_gradients_node->input(gradient_pos[apply_gradients_op]), div_const_node->name()); all_nodes_.insert(std::make_pair(div_node->name(), div_node)); *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) = div_node->name(); } LOG(INFO) << ""Graph size after adding div nodes: "" << all_nodes_.size(); std::vector<const NodeDef*> train_nodes; TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes)); LOG(INFO) << ""Number of training nodes: "" << train_nodes.size(); const NodeDef* dequeue_node; for (const auto& train_node : train_nodes) { if (IsDequeueOp(*train_node)) { dequeue_node = train_node; break; } } std::vector<const NodeDef*> input_nodes; if (dequeue_node) { LOG(INFO) << ""Dequeue node: "" << dequeue_node->name(); TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, {dequeue_node->name()}, {}, &input_nodes)); } LOG(INFO) << ""Number of input nodes: "" << input_nodes.size(); std::set<string> dont_replicate_nodes; for (const auto& variable : item.MainVariables()) { dont_replicate_nodes.insert(variable->name()); } for (const auto& init : item.init_ops) { dont_replicate_nodes.insert(NodeName(init)); } for (const auto& input_node : input_nodes) { if (input_node->name() != dequeue_node->name()) { dont_replicate_nodes.insert(input_node->name()); } } for (const auto& node : train_nodes) { if (dont_replicate_nodes.find(node->name()) == dont_replicate_nodes.end()) { replica_nodes_.insert(node->name()); } } LOG(INFO) << ""Number of replica nodes: "" << replica_nodes_.size(); for (const auto& node : all_nodes_) { if (replica_nodes_.find(node.first) == replica_nodes_.end()) { shared_nodes_.insert(node.first); } } LOG(INFO) << ""Number of shared nodes: "" << shared_nodes_.size(); return Status::OK(); }"
"void janus_voicemail_destroy_session(janus_plugin_session *handle, int *error) { if(g_atomic_int_get(&stopping) || !g_atomic_int_get(&initialized)) { *error = -1; return; } janus_mutex_lock(&sessions_mutex); janus_voicemail_session *session = janus_voicemail_lookup_session(handle); if(!session) { janus_mutex_unlock(&sessions_mutex); JANUS_LOG(LOG_ERR, ""No VoiceMail session associated with this handle...\n""); *error = -2; return; } JANUS_LOG(LOG_VERB, ""Removing VoiceMail session...\n""); janus_voicemail_hangup_media_internal(handle); handle->plugin_handle = NULL; g_hash_table_remove(sessions, handle); janus_mutex_unlock(&sessions_mutex); return; }"
static unsigned int rpcrdma_max_reply_header_size(unsigned int maxsegs) { unsigned int size; size = RPCRDMA_HDRLEN_MIN; size = sizeof(__be32); size += maxsegs * rpcrdma_segment_maxsz * sizeof(__be32); size += sizeof(__be32); return size; }
"NPT_Result  PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request,  const NPT_HttpRequestContext& context, NPT_HttpResponse&             response, NPT_String                    file_path)  { NPT_InputStreamReference stream; NPT_File                 file(file_path); NPT_FileInfo             file_info; if ((file_path.Find(""/.."") >= 0) || (file_path.Find(""\\.."") >= 0) || NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) { return NPT_ERROR_NO_SUCH_ITEM; } const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE); NPT_DateTime  date; NPT_TimeStamp timestamp; if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) && !range_spec) { date.ToTimeStamp(timestamp); NPT_LOG_INFO_5(""File %s timestamps: request=%d (%s) vs file=%d (%s)"",  (const char*)request.GetUrl().GetPath(), (NPT_UInt32)timestamp.ToSeconds(), (const char*)date.ToString(), (NPT_UInt32)file_info.m_ModificationTime, (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString()); if (timestamp >= file_info.m_ModificationTime) { NPT_LOG_FINE_1(""Returning 304 for %s"", request.GetUrl().GetPath().GetChars()); response.SetStatus(304, ""Not Modified"", NPT_HTTP_PROTOCOL_1_1); return NPT_SUCCESS; } } if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) ||  NPT_FAILED(file.GetInputStream(stream))        || stream.IsNull()) { return NPT_ERROR_NO_SUCH_ITEM; } if (file_info.m_ModificationTime) { NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime); response.GetHeaders().SetHeader(""Last-Modified"", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true); response.GetHeaders().SetHeader(""Cache-Control"", ""max-age=0,must-revalidate"", true); } PLT_HttpRequestContext tmp_context(request, context); return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context)); }"
"gboolean flatpak_context_load_metadata (FlatpakContext *context, GKeyFile       *metakey, GError        **error) { gboolean remove; g_auto(GStrv) groups = NULL; gsize i; if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL)) { g_auto(GStrv) shares = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SHARED, NULL, error); if (shares == NULL) return FALSE; for (i = 0; shares[i] != NULL; i++) { FlatpakContextShares share; share = flatpak_context_share_from_string (parse_negated (shares[i], &remove), NULL); if (share == 0) g_info (""Unknown share type %s"", shares[i]); else { if (remove) flatpak_context_remove_shares (context, share); else flatpak_context_add_shares (context, share); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL)) { g_auto(GStrv) sockets = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_SOCKETS, NULL, error); if (sockets == NULL) return FALSE; for (i = 0; sockets[i] != NULL; i++) { FlatpakContextSockets socket = flatpak_context_socket_from_string (parse_negated (sockets[i], &remove), NULL); if (socket == 0) g_info (""Unknown socket type %s"", sockets[i]); else { if (remove) flatpak_context_remove_sockets (context, socket); else flatpak_context_add_sockets (context, socket); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL)) { g_auto(GStrv) devices = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_DEVICES, NULL, error); if (devices == NULL) return FALSE; for (i = 0; devices[i] != NULL; i++) { FlatpakContextDevices device = flatpak_context_device_from_string (parse_negated (devices[i], &remove), NULL); if (device == 0) g_info (""Unknown device type %s"", devices[i]); else { if (remove) flatpak_context_remove_devices (context, device); else flatpak_context_add_devices (context, device); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL)) { g_auto(GStrv) features = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FEATURES, NULL, error); if (features == NULL) return FALSE; for (i = 0; features[i] != NULL; i++) { FlatpakContextFeatures feature = flatpak_context_feature_from_string (parse_negated (features[i], &remove), NULL); if (feature == 0) g_info (""Unknown feature type %s"", features[i]); else { if (remove) flatpak_context_remove_features (context, feature); else flatpak_context_add_features (context, feature); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL)) { g_auto(GStrv) filesystems = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_FILESYSTEMS, NULL, error); if (filesystems == NULL) return FALSE; for (i = 0; filesystems[i] != NULL; i++) { const char *fs = parse_negated (filesystems[i], &remove); g_autofree char *filesystem = NULL; FlatpakFilesystemMode mode; if (!flatpak_context_parse_filesystem (fs, remove, &filesystem, &mode, NULL)) g_info (""Unknown filesystem type %s"", filesystems[i]); else { g_assert (mode == FLATPAK_FILESYSTEM_MODE_NONE || !remove); flatpak_context_take_filesystem (context, g_steal_pointer (&filesystem), mode); } } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL)) { g_auto(GStrv) persistent = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_PERSISTENT, NULL, error); if (persistent == NULL) return FALSE; for (i = 0; persistent[i] != NULL; i++) flatpak_context_set_persistent (context, persistent[i]); } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SESSION_BUS_POLICY, key, NULL); FlatpakPolicy policy; if (!flatpak_verify_dbus_name (key, error)) return FALSE; policy = flatpak_policy_from_string (value, NULL); if ((int) policy != -1) flatpak_context_set_session_bus_policy (context, key, policy); } } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_SYSTEM_BUS_POLICY, key, NULL); FlatpakPolicy policy; if (!flatpak_verify_dbus_name (key, error)) return FALSE; policy = flatpak_policy_from_string (value, NULL); if ((int) policy != -1) flatpak_context_set_system_bus_policy (context, key, policy); } } if (g_key_file_has_group (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT)) { g_auto(GStrv) keys = NULL; gsize keys_count; keys = g_key_file_get_keys (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, &keys_count, NULL); for (i = 0; i < keys_count; i++) { const char *key = keys[i]; g_autofree char *value = g_key_file_get_string (metakey, FLATPAK_METADATA_GROUP_ENVIRONMENT, key, NULL); flatpak_context_set_env_var (context, key, value); } } if (g_key_file_has_key (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, NULL)) { g_auto(GStrv) vars = NULL; gsize vars_count; vars = g_key_file_get_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT, FLATPAK_METADATA_KEY_UNSET_ENVIRONMENT, &vars_count, error); if (vars == NULL) return FALSE; for (i = 0; i < vars_count; i++) { const char *var = vars[i]; flatpak_context_set_env_var (context, var, NULL); } } groups = g_key_file_get_groups (metakey, NULL); for (i = 0; groups[i] != NULL; i++) { const char *group = groups[i]; const char *subsystem; int j; if (g_str_has_prefix (group, FLATPAK_METADATA_GROUP_PREFIX_POLICY)) { g_auto(GStrv) keys = NULL; subsystem = group + strlen (FLATPAK_METADATA_GROUP_PREFIX_POLICY); keys = g_key_file_get_keys (metakey, group, NULL, NULL); for (j = 0; keys != NULL && keys[j] != NULL; j++) { const char *key = keys[j]; g_autofree char *policy_key = g_strdup_printf (""%s.%s"", subsystem, key); g_auto(GStrv) values = NULL; int k; values = g_key_file_get_string_list (metakey, group, key, NULL, NULL); for (k = 0; values != NULL && values[k] != NULL; k++) flatpak_context_apply_generic_policy (context, policy_key, values[k]); } } } return TRUE; }"
"static int ttusb_dec_send_command(struct ttusb_dec *dec, const u8 command, int param_length, const u8 params[], int *result_length, u8 cmd_result[]) { int result, actual_len; u8 *b; dprintk(""%s\n"", __func__); b = kmalloc(COMMAND_PACKET_SIZE + 4, GFP_KERNEL); if (!b) return -ENOMEM; if ((result = mutex_lock_interruptible(&dec->usb_mutex))) { kfree(b); printk(""%s: Failed to lock usb mutex.\n"", __func__); return result; } b[0] = 0xaa; b[1] = ++dec->trans_count; b[2] = command; b[3] = param_length; if (params) memcpy(&b[4], params, param_length); if (debug) { printk(KERN_DEBUG ""%s: command: %*ph\n"", __func__, param_length, b); } result = usb_bulk_msg(dec->udev, dec->command_pipe, b, COMMAND_PACKET_SIZE + 4, &actual_len, 1000); if (result) { printk(""%s: command bulk message failed: error %d\n"", __func__, result); mutex_unlock(&dec->usb_mutex); kfree(b); return result; } result = usb_bulk_msg(dec->udev, dec->result_pipe, b, COMMAND_PACKET_SIZE + 4, &actual_len, 1000); if (result) { printk(""%s: result bulk message failed: error %d\n"", __func__, result); mutex_unlock(&dec->usb_mutex); kfree(b); return result; } else { if (debug) { printk(KERN_DEBUG ""%s: result: %*ph\n"", __func__, actual_len, b); } if (result_length) *result_length = b[3]; if (cmd_result && b[3] > 0) memcpy(cmd_result, &b[4], b[3]); mutex_unlock(&dec->usb_mutex); kfree(b); return 0; } }"
"static int ExecuteSQL( SQLHDBC hDbc, char *szSQL, char cDelimiter, int bColumnNames, int bHTMLTable ) { SQLHSTMT        hStmt; SQLTCHAR        szSepLine[32001];    SQLTCHAR        szUcSQL[32001];  SQLSMALLINT     cols; SQLINTEGER      ret; SQLLEN          nRows                   = 0; szSepLine[ 0 ] = 0; ansi_to_unicode( szSQL, szUcSQL ); if ( SQLAllocStmt( hDbc, &hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, 0 ); fprintf( stderr, ""[ISQL]ERROR: Could not SQLAllocStmt\n"" ); return 0; } if ( buseED ) { ret = SQLExecDirect( hStmt, szUcSQL, SQL_NTS ); if ( ret == SQL_NO_DATA ) { fprintf( stderr, ""[ISQL]INFO: SQLExecDirect returned SQL_NO_DATA\n"" ); } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]INFO: SQLExecDirect returned SQL_SUCCESS_WITH_INFO\n"" ); } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]ERROR: Could not SQLExecDirect\n"" ); SQLFreeStmt( hStmt, SQL_DROP ); free(szSepLine); return 0; } } else { if ( SQLPrepare( hStmt, szUcSQL, SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]ERROR: Could not SQLPrepare\n"" ); SQLFreeStmt( hStmt, SQL_DROP ); return 0; } ret =  SQLExecute( hStmt ); if ( ret == SQL_NO_DATA ) { fprintf( stderr, ""[ISQL]INFO: SQLExecute returned SQL_NO_DATA\n"" ); } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]INFO: SQLExecute returned SQL_SUCCESS_WITH_INFO\n"" ); } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]ERROR: Could not SQLExecute\n"" ); SQLFreeStmt( hStmt, SQL_DROP ); return 0; } } do  { if ( SQLNumResultCols( hStmt, &cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog( hEnv, hDbc, hStmt ); fprintf( stderr, ""[ISQL]ERROR: Could not SQLNumResultCols\n"" ); SQLFreeStmt( hStmt, SQL_DROP ); return 0; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable( hStmt ); else if ( cDelimiter == 0 ) UWriteHeaderNormal( hStmt, szSepLine ); else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited( hStmt, cDelimiter ); if ( bHTMLTable ) WriteBodyHTMLTable( hStmt ); else if ( cDelimiter == 0 ) nRows = WriteBodyNormal( hStmt ); else WriteBodyDelimited( hStmt, cDelimiter ); } if ( bHTMLTable ) WriteFooterHTMLTable( hStmt ); else if ( cDelimiter == 0 ) UWriteFooterNormal( hStmt, szSepLine, nRows ); } while ( SQL_SUCCEEDED( SQLMoreResults( hStmt ))); SQLFreeStmt( hStmt, SQL_DROP ); return 1; }"
"int sonmp_decode(struct lldpd *cfg, char *frame, int s, struct lldpd_hardware *hardware, struct lldpd_chassis **newchassis, struct lldpd_port **newport) { const u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR; struct lldpd_chassis *chassis; struct lldpd_port *port; struct lldpd_mgmt *mgmt; int length, i; u_int8_t *pos; u_int8_t seg[3], rchassis; struct in_addr address; log_debug(""sonmp"", ""decode SONMP PDU from %s"", hardware->h_ifname); if ((chassis = calloc(1, sizeof(struct lldpd_chassis))) == NULL) { log_warn(""sonmp"", ""failed to allocate remote chassis""); return -1; } TAILQ_INIT(&chassis->c_mgmt); if ((port = calloc(1, sizeof(struct lldpd_port))) == NULL) { log_warn(""sonmp"", ""failed to allocate remote port""); free(chassis); return -1; } #ifdef ENABLE_DOT1 TAILQ_INIT(&port->p_vlans); #endif length = s; pos = (u_int8_t*)frame; if (length < SONMP_SIZE) { log_warnx(""sonmp"", ""too short SONMP frame received on %s"", hardware->h_ifname); goto malformed; } if (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0) goto malformed; PEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16; PEEK_DISCARD(6); if (PEEK_UINT16 != LLC_PID_SONMP_HELLO) { log_debug(""sonmp"", ""incorrect LLC protocol ID received for SONMP on %s"", hardware->h_ifname); goto malformed; } chassis->c_id_subtype = LLDP_CHASSISID_SUBTYPE_ADDR; if ((chassis->c_id = calloc(1, sizeof(struct in_addr) + 1)) == NULL) { log_warn(""sonmp"", ""unable to allocate memory for chassis id on %s"", hardware->h_ifname); goto malformed; } chassis->c_id_len = sizeof(struct in_addr) + 1; chassis->c_id[0] = 1; PEEK_BYTES(&address, sizeof(struct in_addr)); memcpy(chassis->c_id + 1, &address, sizeof(struct in_addr)); if (asprintf(&chassis->c_name, ""%s"", inet_ntoa(address)) == -1) { log_warnx(""sonmp"", ""unable to write chassis name for %s"", hardware->h_ifname); goto malformed; } PEEK_BYTES(seg, sizeof(seg)); rchassis = PEEK_UINT8; for (i=0; sonmp_chassis_types[i].type != 0; i++) { if (sonmp_chassis_types[i].type == rchassis) break; } if (asprintf(&chassis->c_descr, ""%s"", sonmp_chassis_types[i].description) == -1) { log_warnx(""sonmp"", ""unable to write chassis description for %s"", hardware->h_ifname); goto malformed; } mgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, &address, sizeof(struct in_addr), 0); if (mgmt == NULL) { if (errno == ENOMEM) log_warn(""sonmp"", ""unable to allocate memory for management address""); else log_warn(""sonmp"", ""too large management address received on %s"", hardware->h_ifname); goto malformed; } TAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries); port->p_ttl = cfg?(cfg->g_config.c_tx_interval * cfg->g_config.c_tx_hold): LLDPD_TTL; port->p_ttl = (port->p_ttl + 999) / 1000; port->p_id_subtype = LLDP_PORTID_SUBTYPE_LOCAL; if (asprintf(&port->p_id, ""%02x-%02x-%02x"", seg[0], seg[1], seg[2]) == -1) { log_warn(""sonmp"", ""unable to allocate memory for port id on %s"", hardware->h_ifname); goto malformed; } port->p_id_len = strlen(port->p_id); if ((seg[0] == 0) && (seg[1] == 0)) { if (asprintf(&port->p_descr, ""port %d"", seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } else if (seg[0] == 0) { if (asprintf(&port->p_descr, ""port %d/%d"", seg[1], seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } else { if (asprintf(&port->p_descr, ""port %x:%x:%x"", seg[0], seg[1], seg[2]) == -1) { log_warnx(""sonmp"", ""unable to write port description for %s"", hardware->h_ifname); goto malformed; } } *newchassis = chassis; *newport = port; return 1; malformed: lldpd_chassis_cleanup(chassis, 1); lldpd_port_cleanup(port, 1); free(port); return -1; }"
"void nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma) { struct nvkm_vma *next; nvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags); nvkm_memory_unref(&vma->memory); if (vma->part) { struct nvkm_vma *prev = node(vma, prev); if (!prev->memory) { prev->size += vma->size; rb_erase(&vma->tree, &vmm->root); list_del(&vma->head); kfree(vma); vma = prev; } } next = node(vma, next); if (next && next->part) { if (!next->memory) { vma->size += next->size; rb_erase(&next->tree, &vmm->root); list_del(&next->head); kfree(next); } } }"
"void scramble(FILE* keyFile){ for (int j = 0; j < 16; ++j) { char temp = 0; for (int i = 0; i < 256; ++i) { scrambleAsciiTables[j][i] = i; } if (keyFile != NULL){ int size; char extractedString[BUFFER_SIZE] = """"; while((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){ for (int i = 0; i < size; ++i) { temp = scrambleAsciiTables[j][i%256]; scrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])]; scrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp; } } rewind(keyFile); } else { unsigned char random256; for (int i = 0; i < 10 * 256; ++i) { random256 = generateNumber() ^ passPhrase[passIndex]; passIndex++; passIndex %= 16384; temp = scrambleAsciiTables[j][i%256]; scrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256]; scrambleAsciiTables[j][random256] = temp; } } } }"
"GF_Err hdlr_dump(GF_Box *a, FILE * trace) { GF_HandlerBox *p = (GF_HandlerBox *)a; gf_isom_box_dump_start(a, ""HandlerBox"", trace); if (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) { fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8+1); } else { fprintf(trace, ""hdlrType=\""%s\"" Name=\""%s\"" "", gf_4cc_to_str(p->handlerType), p->nameUTF8); } fprintf(trace, ""reserved1=\""%d\"" reserved2=\"""", p->reserved1); dump_data(trace, (char *) p->reserved2, 12); fprintf(trace, ""\""""); fprintf(trace, "">\n""); gf_isom_box_dump_done(""HandlerBox"", a, trace); return GF_OK; }"
"static byte * i_alloc_byte_array(gs_memory_t * mem, uint num_elements, uint elt_size, client_name_t cname) { gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem; obj_header_t *obj; #ifdef MEMENTO if (Memento_failThisEvent()) return NULL; #endif obj = alloc_obj(imem, (ulong) num_elements * elt_size, &st_bytes, ALLOC_DIRECT, cname); if_debug6m('A', mem, ""[a%d:+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"", alloc_trace_space(imem), client_name_string(cname), (ulong) num_elements * elt_size, num_elements, elt_size, (ulong) obj); return (byte *) obj; }"
"int run_cmd(int fd, ...) { pid_t pid; sigset_t sigm, sigm_old; sigemptyset(&sigm); sigaddset(&sigm, SIGTERM); sigprocmask(SIG_BLOCK, &sigm, &sigm_old); pid = fork(); if ( pid < 0 ) { sigprocmask(SIG_SETMASK, &sigm_old, NULL); fd_printf(STO, ""*** cannot fork: %s ***\r\n"", strerror(errno)); return -1; } else if ( pid ) { int status, r; sigprocmask(SIG_SETMASK, &sigm_old, NULL); do { r = waitpid(pid, &status, 0); } while ( r < 0 && errno == EINTR ); term_apply(STI); if ( WIFEXITED(status) ) {  fd_printf(STO, ""\r\n*** exit status: %d ***\r\n"",  WEXITSTATUS(status)); return WEXITSTATUS(status); } else if ( WIFSIGNALED(status) ) { fd_printf(STO, ""\r\n*** killed by signal: %d ***\r\n"",  WTERMSIG(status)); return -1; } else { fd_printf(STO, ""\r\n*** abnormal termination: 0x%x ***\r\n"", r); return -1; } } else { long fl; char cmd[512]; term_remove(STI); term_erase(fd); fl = fcntl(fd, F_GETFL);  fl &= ~O_NONBLOCK; fcntl(fd, F_SETFL, fl); close(STI); close(STO); dup2(fd, STI); dup2(fd, STO); { char *c, *ce; const char *s; int n; va_list vls; strcpy(cmd, EXEC); c = &cmd[sizeof(EXEC)- 1]; ce = cmd + sizeof(cmd) - 1; va_start(vls, fd); while ( (s = va_arg(vls, const char *)) ) { n = strlen(s); if ( c + n + 1 >= ce ) break; memcpy(c, s, n); c += n; *c++ = ' '; } va_end(vls); *c = '\0'; } fd_printf(STDERR_FILENO, ""%s\n"", &cmd[sizeof(EXEC) - 1]); establish_child_signal_handlers(); sigprocmask(SIG_SETMASK, &sigm_old, NULL); execl(""/bin/sh"", ""sh"", ""-c"", cmd, NULL); exit(42); } }"
"static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap, const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight, UINT32 bpp, UINT32 length, BOOL compressed, UINT32 codecId) { UINT32 SrcSize = length; rdpGdi* gdi = context->gdi; bitmap->compressed = FALSE; bitmap->format = gdi->dstFormat; bitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format); bitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16); if (!bitmap->data) return FALSE; if (compressed) { if (bpp < 32) { if (!interleaved_decompress(context->codecs->interleaved, pSrcData, SrcSize, DstWidth, DstHeight, bpp, bitmap->data, bitmap->format, 0, 0, 0, DstWidth, DstHeight, &gdi->palette)) return FALSE; } else { if (!planar_decompress(context->codecs->planar, pSrcData, SrcSize, DstWidth, DstHeight, bitmap->data, bitmap->format, 0, 0, 0, DstWidth, DstHeight, TRUE)) return FALSE; } } else { const UINT32 SrcFormat = gdi_get_pixel_format(bpp); const size_t sbpp = GetBytesPerPixel(SrcFormat); const size_t dbpp = GetBytesPerPixel(bitmap->format); if ((sbpp == 0) || (dbpp == 0)) return FALSE; else { const size_t dstSize = SrcSize * dbpp / sbpp; if (dstSize  < bitmap->length) return FALSE; } if (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0, DstWidth, DstHeight, pSrcData, SrcFormat, 0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL)) return FALSE; } return TRUE; }"
"bool isXmpType(BasicIo& iIo, bool advance) { const int32_t len = 80; byte buf[len]; iIo.read(buf, xmlHdrCnt + 1); if (   iIo.eof() && 0 == strncmp(reinterpret_cast<const char*>(buf), xmlHeader, xmlHdrCnt)) { return true; } if (iIo.error() || iIo.eof()) { return false; } iIo.read(buf + xmlHdrCnt + 1, len - xmlHdrCnt - 1); if (iIo.error() || iIo.eof()) { return false; } int32_t start = 0; if (0 == strncmp(reinterpret_cast<const char*>(buf), ""\xef\xbb\xbf"", 3)) { start = 3; } bool rc = false; std::string head(reinterpret_cast<const char*>(buf + start), len - start); if (head.substr(0, 5)  == ""<?xml"") { for (unsigned i = 5; i < head.size(); ++i) { if (head[i] == '<') { head = head.substr(i); break; } } } if (   head.size() > 9 && (   head.substr(0, 9)  == ""<?xpacket"" || head.substr(0, 10) == ""<x:xmpmeta"")) { rc = true; } if (!advance || !rc) { iIo.seek(-(len - start), BasicIo::cur);         } return rc; }"
"static int vmxnet3_rq_alloc_rx_buf(struct vmxnet3_rx_queue *rq, u32 ring_idx, int num_to_alloc, struct vmxnet3_adapter *adapter) { int num_allocated = 0; struct vmxnet3_rx_buf_info *rbi_base = rq->buf_info[ring_idx]; struct vmxnet3_cmd_ring *ring = &rq->rx_ring[ring_idx]; u32 val; while (num_allocated <= num_to_alloc) { struct vmxnet3_rx_buf_info *rbi; union Vmxnet3_GenericDesc *gd; rbi = rbi_base + ring->next2fill; gd = ring->base + ring->next2fill; if (rbi->buf_type == VMXNET3_RX_BUF_SKB) { if (rbi->skb == NULL) { rbi->skb = __netdev_alloc_skb_ip_align(adapter->netdev, rbi->len, GFP_KERNEL); if (unlikely(rbi->skb == NULL)) { rq->stats.rx_buf_alloc_failure++; break; } rbi->dma_addr = dma_map_single( &adapter->pdev->dev, rbi->skb->data, rbi->len, DMA_FROM_DEVICE); if (dma_mapping_error(&adapter->pdev->dev, rbi->dma_addr)) { dev_kfree_skb_any(rbi->skb); rq->stats.rx_buf_alloc_failure++; break; } } else { } val = VMXNET3_RXD_BTYPE_HEAD << VMXNET3_RXD_BTYPE_SHIFT; } else { BUG_ON(rbi->buf_type != VMXNET3_RX_BUF_PAGE || rbi->len  != PAGE_SIZE); if (rbi->page == NULL) { rbi->page = alloc_page(GFP_ATOMIC); if (unlikely(rbi->page == NULL)) { rq->stats.rx_buf_alloc_failure++; break; } rbi->dma_addr = dma_map_page( &adapter->pdev->dev, rbi->page, 0, PAGE_SIZE, DMA_FROM_DEVICE); if (dma_mapping_error(&adapter->pdev->dev, rbi->dma_addr)) { put_page(rbi->page); rq->stats.rx_buf_alloc_failure++; break; } } else { } val = VMXNET3_RXD_BTYPE_BODY << VMXNET3_RXD_BTYPE_SHIFT; } gd->rxd.addr = cpu_to_le64(rbi->dma_addr); gd->dword[2] = cpu_to_le32((!ring->gen << VMXNET3_RXD_GEN_SHIFT) | val | rbi->len); if (num_allocated == num_to_alloc) break; gd->dword[2] |= cpu_to_le32(ring->gen << VMXNET3_RXD_GEN_SHIFT); num_allocated++; vmxnet3_cmd_ring_adv_next2fill(ring); } netdev_dbg(adapter->netdev, ""alloc_rx_buf: %d allocated, next2fill %u, next2comp %u\n"", num_allocated, ring->next2fill, ring->next2comp); BUG_ON(num_allocated != 0 && ring->next2fill == ring->next2comp); return num_allocated; }"
"static inline bool unconditional(const struct arpt_arp *arp) { static const struct arpt_arp uncond; return memcmp(arp, &uncond, sizeof(uncond)) == 0; }"
"static int del_accepted(TCP_Server *tcp_server, int index) { if ((uint32_t)index >= tcp_server->size_accepted_connections) { return -1; } if (tcp_server->accepted_connection_array[index].status == TCP_STATUS_NO_STATUS) { return -1; } if (!bs_list_remove(&tcp_server->accepted_key_list, tcp_server->accepted_connection_array[index].public_key, index)) { return -1; } crypto_memzero(&tcp_server->accepted_connection_array[index], sizeof(TCP_Secure_Connection)); --tcp_server->num_accepted_connections; if (tcp_server->num_accepted_connections == 0) { realloc_connection(tcp_server, 0); } return 0; }"
"void open_log_file(const char *name, const char *prog, const char *namespace, const char *instance) { char *file_name; if (log_file) { fclose(log_file); log_file = NULL; } if (!name) return; file_name = make_file_name(name, prog, namespace, instance); log_file = fopen(file_name, ""a""); if (log_file) { int n = fileno(log_file); fcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD)); fcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL)); } FREE(file_name); }"
"Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; unsigned const h = gnu_hash(name); unsigned const hbit1 = 077& h; unsigned const hbit2 = 077& (h>>gnu_shift); upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf64_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, 0==(1u& get_te32(hp++))); } } } return 0; }"
"WORD32 ih264d_parse_sps(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm) { UWORD8 i; dec_seq_params_t *ps_seq = NULL; UWORD8 u1_profile_idc, u1_level_idc, u1_seq_parameter_set_id; UWORD16 i2_max_frm_num; UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer; UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst; UWORD8 u1_frm, uc_constraint_set0_flag, uc_constraint_set1_flag; WORD32 i4_cropped_ht, i4_cropped_wd; UWORD32 u4_temp; WORD32 pic_height_in_map_units_minus1 = 0; UWORD32 u2_pic_wd = 0; UWORD32 u2_pic_ht = 0; UWORD32 u2_frm_wd_y = 0; UWORD32 u2_frm_ht_y = 0; UWORD32 u2_frm_wd_uv = 0; UWORD32 u2_frm_ht_uv = 0; UWORD32 u2_crop_offset_y = 0; UWORD32 u2_crop_offset_uv = 0; WORD32 ret; UWORD32 u4_num_reorder_frames; WORD32 i4_i; UWORD8 u1_frame_cropping_flag, u1_frame_cropping_rect_left_ofst, u1_frame_cropping_rect_right_ofst, u1_frame_cropping_rect_top_ofst, u1_frame_cropping_rect_bottom_ofst; SWITCHONTRACE; u1_profile_idc = ih264d_get_bits_h264(ps_bitstrm, 8); COPYTHECONTEXT(""SPS: profile_idc"",u1_profile_idc); uc_constraint_set0_flag = ih264d_get_bit_h264(ps_bitstrm); uc_constraint_set1_flag = ih264d_get_bit_h264(ps_bitstrm); ih264d_get_bit_h264(ps_bitstrm); ih264d_get_bits_h264(ps_bitstrm, 5); if((u1_profile_idc != MAIN_PROFILE_IDC) && (u1_profile_idc != BASE_PROFILE_IDC) && (u1_profile_idc != HIGH_PROFILE_IDC) ) { if((u1_profile_idc != EXTENDED_PROFILE_IDC) || ((uc_constraint_set1_flag != 1) && (uc_constraint_set0_flag != 1))) { return (ERROR_FEATURE_UNAVAIL); } } u1_level_idc = ih264d_get_bits_h264(ps_bitstrm, 8); COPYTHECONTEXT(""SPS: u4_level_idc"",u1_level_idc); u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(u4_temp & MASK_ERR_SEQ_SET_ID) return ERROR_INV_SPS_PPS_T; u1_seq_parameter_set_id = u4_temp; COPYTHECONTEXT(""SPS: seq_parameter_set_id"", u1_seq_parameter_set_id); ps_seq = ps_dec->pv_scratch_sps_pps; if(ps_dec->i4_header_decoded & 1) { *ps_seq = *ps_dec->ps_cur_sps; } if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_profile_idc != u1_profile_idc)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_level_idc != u1_level_idc)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } ps_seq->u1_profile_idc = u1_profile_idc; ps_seq->u1_level_idc = u1_level_idc; ps_seq->u1_seq_parameter_set_id = u1_seq_parameter_set_id; ps_seq->i4_chroma_format_idc = 1; ps_seq->i4_bit_depth_luma_minus8 = 0; ps_seq->i4_bit_depth_chroma_minus8 = 0; ps_seq->i4_qpprime_y_zero_transform_bypass_flag = 0; ps_seq->i4_seq_scaling_matrix_present_flag = 0; if(u1_profile_idc == HIGH_PROFILE_IDC) { ps_seq->i4_chroma_format_idc = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(ps_seq->i4_chroma_format_idc != 1) { return ERROR_INV_SPS_PPS_T; } ps_seq->i4_bit_depth_luma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(ps_seq->i4_bit_depth_luma_minus8 != 0) { return ERROR_INV_SPS_PPS_T; } ps_seq->i4_bit_depth_chroma_minus8 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(ps_seq->i4_bit_depth_chroma_minus8 != 0) { return ERROR_INV_SPS_PPS_T; } ps_seq->i4_qpprime_y_zero_transform_bypass_flag = (WORD32)ih264d_get_bit_h264(ps_bitstrm); if(ps_seq->i4_qpprime_y_zero_transform_bypass_flag != 0) { return ERROR_INV_SPS_PPS_T; } ps_seq->i4_seq_scaling_matrix_present_flag = (WORD32)ih264d_get_bit_h264(ps_bitstrm); if(ps_seq->i4_seq_scaling_matrix_present_flag) { for(i4_i = 0; i4_i < 8; i4_i++) { ps_seq->u1_seq_scaling_list_present_flag[i4_i] = ih264d_get_bit_h264(ps_bitstrm); ps_seq->u1_use_default_scaling_matrix_flag[i4_i] = 0; if(ps_seq->u1_seq_scaling_list_present_flag[i4_i]) { if(i4_i < 6) { ih264d_scaling_list( ps_seq->i2_scalinglist4x4[i4_i], 16, &ps_seq->u1_use_default_scaling_matrix_flag[i4_i], ps_bitstrm); } else { ih264d_scaling_list( ps_seq->i2_scalinglist8x8[i4_i - 6], 64, &ps_seq->u1_use_default_scaling_matrix_flag[i4_i], ps_bitstrm); } } } } } u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(u4_temp > MAX_BITS_IN_FRAME_NUM) { return ERROR_INV_SPS_PPS_T; } ps_seq->u1_bits_in_frm_num = u4_temp; COPYTHECONTEXT(""SPS: log2_max_frame_num_minus4"", (ps_seq->u1_bits_in_frm_num - 4)); i2_max_frm_num = (1 << (ps_seq->u1_bits_in_frm_num)); ps_seq->u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1; u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(u4_temp > MAX_PIC_ORDER_CNT_TYPE) { return ERROR_INV_POC_TYPE_T; } ps_seq->u1_pic_order_cnt_type = u4_temp; COPYTHECONTEXT(""SPS: pic_order_cnt_type"",ps_seq->u1_pic_order_cnt_type); ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = 1; if(ps_seq->u1_pic_order_cnt_type == 0) { u4_temp = 4 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(u4_temp > MAX_BITS_IN_POC_LSB) { return ERROR_INV_SPS_PPS_T; } ps_seq->u1_log2_max_pic_order_cnt_lsb_minus = u4_temp; ps_seq->i4_max_pic_order_cntLsb = (1 << u4_temp); COPYTHECONTEXT(""SPS: log2_max_pic_order_cnt_lsb_minus4"",(u4_temp - 4)); } else if(ps_seq->u1_pic_order_cnt_type == 1) { ps_seq->u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264( ps_bitstrm); COPYTHECONTEXT(""SPS: delta_pic_order_always_zero_flag"", ps_seq->u1_delta_pic_order_always_zero_flag); ps_seq->i4_ofst_for_non_ref_pic = ih264d_sev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: offset_for_non_ref_pic"", ps_seq->i4_ofst_for_non_ref_pic); ps_seq->i4_ofst_for_top_to_bottom_field = ih264d_sev( pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: offset_for_top_to_bottom_field"", ps_seq->i4_ofst_for_top_to_bottom_field); u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if(u4_temp > 255) return ERROR_INV_SPS_PPS_T; ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp; COPYTHECONTEXT(""SPS: num_ref_frames_in_pic_order_cnt_cycle"", ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle); for(i = 0; i < ps_seq->u1_num_ref_frames_in_pic_order_cnt_cycle; i++) { ps_seq->i4_ofst_for_ref_frame[i] = ih264d_sev( pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: offset_for_ref_frame"", ps_seq->i4_ofst_for_ref_frame[i]); } } u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); if((u4_temp > H264_MAX_REF_PICS)) { return ERROR_NUM_REF; } if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_num_ref_frames != u4_temp)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } ps_seq->u1_num_ref_frames = u4_temp; COPYTHECONTEXT(""SPS: num_ref_frames"",ps_seq->u1_num_ref_frames); ps_seq->u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264( ps_bitstrm); COPYTHECONTEXT(""SPS: gaps_in_frame_num_value_allowed_flag"", ps_seq->u1_gaps_in_frame_num_value_allowed_flag); ps_seq->u2_frm_wd_in_mbs = 1 + ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: pic_width_in_mbs_minus1"", ps_seq->u2_frm_wd_in_mbs - 1); u2_pic_wd = (ps_seq->u2_frm_wd_in_mbs << 4); pic_height_in_map_units_minus1 = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_seq->u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1; u2_pic_ht = (ps_seq->u2_frm_ht_in_mbs << 4); ps_seq->u2_max_mb_addr = (ps_seq->u2_frm_wd_in_mbs * ps_seq->u2_frm_ht_in_mbs) - 1; ps_seq->u2_total_num_of_mbs = ps_seq->u2_max_mb_addr + 1; ps_seq->u1_level_idc = ih264d_correct_level_idc( u1_level_idc, ps_seq->u2_total_num_of_mbs); u1_frm = ih264d_get_bit_h264(ps_bitstrm); if((ps_dec->i4_header_decoded & 1) && (ps_seq->u1_frame_mbs_only_flag != u1_frm)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } ps_seq->u1_frame_mbs_only_flag = u1_frm; COPYTHECONTEXT(""SPS: frame_mbs_only_flag"", u1_frm); if(!u1_frm) { u2_pic_ht <<= 1; ps_seq->u1_mb_aff_flag = ih264d_get_bit_h264(ps_bitstrm); COPYTHECONTEXT(""SPS: mb_adaptive_frame_field_flag"", ps_seq->u1_mb_aff_flag); } else ps_seq->u1_mb_aff_flag = 0; ps_seq->u1_direct_8x8_inference_flag = ih264d_get_bit_h264(ps_bitstrm); COPYTHECONTEXT(""SPS: direct_8x8_inference_flag"", ps_seq->u1_direct_8x8_inference_flag); u1_frame_cropping_flag = ih264d_get_bit_h264(ps_bitstrm); COPYTHECONTEXT(""SPS: frame_cropping_flag"",u1_frame_cropping_flag); if(u1_frame_cropping_flag) { u1_frame_cropping_rect_left_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: frame_cropping_rect_left_offset"", u1_frame_cropping_rect_left_ofst); u1_frame_cropping_rect_right_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: frame_cropping_rect_right_offset"", u1_frame_cropping_rect_right_ofst); u1_frame_cropping_rect_top_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: frame_cropping_rect_top_offset"", u1_frame_cropping_rect_top_ofst); u1_frame_cropping_rect_bottom_ofst = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); COPYTHECONTEXT(""SPS: frame_cropping_rect_bottom_offset"", u1_frame_cropping_rect_bottom_ofst); } ps_seq->u1_vui_parameters_present_flag = ih264d_get_bit_h264(ps_bitstrm); COPYTHECONTEXT(""SPS: vui_parameters_present_flag"", ps_seq->u1_vui_parameters_present_flag); u2_frm_wd_y = u2_pic_wd + (UWORD8)(PAD_LEN_Y_H << 1); if(1 == ps_dec->u4_share_disp_buf) { if(ps_dec->u4_app_disp_width > u2_frm_wd_y) u2_frm_wd_y = ps_dec->u4_app_disp_width; } u2_frm_ht_y = u2_pic_ht + (UWORD8)(PAD_LEN_Y_V << 2); u2_frm_wd_uv = u2_pic_wd + (UWORD8)(PAD_LEN_UV_H << 2); u2_frm_wd_uv = MAX(u2_frm_wd_uv, u2_frm_wd_y); u2_frm_ht_uv = (u2_pic_ht >> 1) + (UWORD8)(PAD_LEN_UV_V << 2); u2_frm_ht_uv = MAX(u2_frm_ht_uv, (u2_frm_ht_y >> 1)); { UWORD16 u2_rgt_ofst = 0; UWORD16 u2_lft_ofst = 0; UWORD16 u2_top_ofst = 0; UWORD16 u2_btm_ofst = 0; UWORD8 u1_frm_mbs_flag; UWORD8 u1_vert_mult_factor; if(u1_frame_cropping_flag) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1; u1_frm_mbs_flag = (1 == ps_seq->u1_frame_mbs_only_flag); u1_vert_mult_factor = (2 - u1_frm_mbs_flag); u2_btm_ofst = (u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor); u2_top_ofst = (u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor); } u2_crop_offset_y = (u2_frm_wd_y * u2_top_ofst) + (u2_lft_ofst); u2_crop_offset_uv = (u2_frm_wd_uv * (u2_top_ofst >> 1)) + (u2_lft_ofst >> 1) * YUV420SP_FACTOR; i4_cropped_ht = u2_pic_ht - (u2_btm_ofst + u2_top_ofst); i4_cropped_wd = u2_pic_wd - (u2_rgt_ofst + u2_lft_ofst); if((i4_cropped_ht < MB_SIZE) || (i4_cropped_wd < MB_SIZE)) { return ERROR_INV_SPS_PPS_T; } if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_wd != u2_pic_wd)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } if((ps_dec->i4_header_decoded & 1) && (ps_dec->u2_pic_ht != u2_pic_ht)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } if((u2_pic_wd > H264_MAX_FRAME_WIDTH) || (u2_pic_ht > H264_MAX_FRAME_HEIGHT) || (u2_pic_wd < H264_MIN_FRAME_WIDTH) || (u2_pic_ht < H264_MIN_FRAME_HEIGHT) || (u2_pic_wd * (UWORD32)u2_pic_ht > H264_MAX_FRAME_SIZE)) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED; } if((u2_pic_wd << ps_seq->u1_mb_aff_flag) > H264_MAX_FRAME_WIDTH) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED; } } if((ps_dec->i4_header_decoded & 1) && (1 == ps_seq->u1_vui_parameters_present_flag) && (1 == ps_seq->s_vui.u1_bitstream_restriction_flag)) { u4_num_reorder_frames =  ps_seq->s_vui.u4_num_reorder_frames; } else { u4_num_reorder_frames = -1; } if(1 == ps_seq->u1_vui_parameters_present_flag) { ret = ih264d_parse_vui_parametres(&ps_seq->s_vui, ps_bitstrm); if(ret != OK) return ret; } if((ps_dec->i4_header_decoded & 1) && (-1 != (WORD32)u4_num_reorder_frames) && (1 == ps_seq->u1_vui_parameters_present_flag) && (1 == ps_seq->s_vui.u1_bitstream_restriction_flag) && (ps_seq->s_vui.u4_num_reorder_frames != u4_num_reorder_frames)) { ps_dec->u1_res_changed = 1; return IVD_RES_CHANGED; } if (ps_bitstrm->u4_ofst > ps_bitstrm->u4_max_ofst) { return ERROR_INV_SPS_PPS_T; } ps_dec->u2_disp_height = i4_cropped_ht; ps_dec->u2_disp_width = i4_cropped_wd; ps_dec->u2_pic_wd = u2_pic_wd; ps_dec->u2_pic_ht = u2_pic_ht; ps_dec->u2_frm_wd_y = u2_frm_wd_y; ps_dec->u2_frm_ht_y = u2_frm_ht_y; ps_dec->u2_frm_wd_uv = u2_frm_wd_uv; ps_dec->u2_frm_ht_uv = u2_frm_ht_uv; ps_dec->s_pad_mgr.u1_pad_len_y_v = (UWORD8)(PAD_LEN_Y_V << (1 - u1_frm)); ps_dec->s_pad_mgr.u1_pad_len_cr_v = (UWORD8)(PAD_LEN_UV_V << (1 - u1_frm)); ps_dec->u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs; ps_dec->u2_frm_ht_in_mbs = ps_seq->u2_frm_ht_in_mbs; ps_dec->u2_crop_offset_y = u2_crop_offset_y; ps_dec->u2_crop_offset_uv = u2_crop_offset_uv; ps_seq->u1_is_valid = TRUE; ps_dec->ps_sps[u1_seq_parameter_set_id] = *ps_seq; ps_dec->ps_cur_sps = &ps_dec->ps_sps[u1_seq_parameter_set_id]; return OK; }"
static RzList *strings(RzBinFile *bf) { if (!bf) { return NULL; } LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf); if (!bin_info_obj) { return NULL; } return bin_info_obj->string_list; }
"static int load_pgen(SFData *sf, int size) { fluid_list_t *p, *p2, *p3, *dup, **hz = NULL, *start_of_zone_list; SFZone *z; SFGen *g; SFGenAmount genval; unsigned short genid; int level, skip, drop, gzone, discarded; p = sf->preset; while(p) { gzone = FALSE; discarded = FALSE; start_of_zone_list = p2 = ((SFPreset *)(p->data))->zone; if(p2) { hz = &p2; } while(p2) { level = 0; z = (SFZone *)(p2->data); p3 = z->gen; while(p3) { dup = NULL; skip = FALSE; drop = FALSE; if((size -= SF_GEN_SIZE) < 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } READW(sf, genid); if(genid == Gen_KeyRange) { if(level == 0) { level = 1; READB(sf, genval.range.lo); READB(sf, genval.range.hi); } else { skip = TRUE; } } else if(genid == Gen_VelRange) { if(level <= 1) { level = 2; READB(sf, genval.range.lo); READB(sf, genval.range.hi); } else { skip = TRUE; } } else if(genid == Gen_Instrument) { level = 3; READW(sf, genval.uword); ((SFZone *)(p2->data))->instsamp = FLUID_INT_TO_POINTER(genval.uword + 1); break;  } else { level = 2; if(valid_preset_genid(genid)) { READW(sf, genval.sword); dup = find_gen_by_id(genid, z->gen); } else { skip = TRUE; } } if(!skip) { if(!dup) { if((g = FLUID_NEW(SFGen)) == NULL) { FLUID_LOG(FLUID_ERR, ""Out of memory""); return FALSE; } p3->data = g; g->id = genid; } else { g = (SFGen *)(dup->data);  drop = TRUE; } g->amount = genval; } else { discarded = TRUE; drop = TRUE; FSKIPW(sf); } if(!drop) { p3 = fluid_list_next(p3);     } else { SLADVREM(z->gen, p3);     } }  if(level == 3) { SLADVREM(z->gen, p3);     } else { if(!gzone) { gzone = TRUE; if(*hz != p2) { void *save = p2->data; FLUID_LOG(FLUID_WARN, ""Preset '%s': Global zone is not first zone"", ((SFPreset *)(p->data))->name); SLADVREM(*hz, p2); *hz = fluid_list_prepend(*hz, save); continue; } } else { SFZone * pzone = fluid_list_get(p2); FLUID_LOG(FLUID_WARN, ""Preset '%s': Discarding invalid global zone"", ((SFPreset *)(p->data))->name); *hz = fluid_list_remove(start_of_zone_list, pzone); delete_zone(pzone); } } while(p3) { discarded = TRUE; if((size -= SF_GEN_SIZE) < 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } FSKIP(sf, SF_GEN_SIZE); SLADVREM(z->gen, p3); } p2 = fluid_list_next(p2);  } if(discarded) { FLUID_LOG(FLUID_WARN, ""Preset '%s': Some invalid generators were discarded"", ((SFPreset *)(p->data))->name); } p = fluid_list_next(p); } if(size == 0) { return TRUE; } size -= SF_GEN_SIZE; if(size != 0) { FLUID_LOG(FLUID_ERR, ""Preset generator chunk size mismatch""); return FALSE; } FSKIP(sf, SF_GEN_SIZE);  return TRUE; }"
"GF_EXPORT GF_TextSample *gf_isom_parse_text_sample(GF_BitStream *bs) { GF_TextSample *s = gf_isom_new_text_sample(); if (!bs || !gf_bs_available(bs)) return s; s->len = gf_bs_read_u16(bs); if (s->len) { s->text = (char *) gf_malloc(sizeof(char)*(s->len+2) ); if (!s->text) return NULL; s->text[s->len] = 0; s->text[s->len+1] = 0; gf_bs_read_data(bs, s->text, s->len); } while (gf_bs_available(bs)) { GF_Box *a; GF_Err e = gf_isom_box_parse(&a, bs); if (e) break; switch (a->type) { case GF_ISOM_BOX_TYPE_STYL: if (s->styles) { GF_TextStyleBox *st2 = (GF_TextStyleBox *)a; if (!s->styles->entry_count) { gf_isom_box_del((GF_Box*)s->styles); s->styles = st2; } else { s->styles->styles = (GF_StyleRecord*)gf_realloc(s->styles->styles, sizeof(GF_StyleRecord) * (s->styles->entry_count + st2->entry_count)); memcpy(&s->styles->styles[s->styles->entry_count], st2->styles, sizeof(GF_StyleRecord) * st2->entry_count); s->styles->entry_count += st2->entry_count; gf_isom_box_del(a); } } else { s->styles = (GF_TextStyleBox*)a; } break; case GF_ISOM_BOX_TYPE_KROK: s->cur_karaoke = (GF_TextKaraokeBox*)a; case GF_ISOM_BOX_TYPE_HLIT: case GF_ISOM_BOX_TYPE_HREF: case GF_ISOM_BOX_TYPE_BLNK: gf_list_add(s->others, a); break; case GF_ISOM_BOX_TYPE_HCLR: if (s->highlight_color) gf_isom_box_del(a); else s->highlight_color = (GF_TextHighlightColorBox *) a; break; case GF_ISOM_BOX_TYPE_DLAY: if (s->scroll_delay) gf_isom_box_del(a); else s->scroll_delay= (GF_TextScrollDelayBox*) a; break; case GF_ISOM_BOX_TYPE_TBOX: if (s->box) gf_isom_box_del(a); else s->box= (GF_TextBoxBox *) a; break; case GF_ISOM_BOX_TYPE_TWRP: if (s->wrap) gf_isom_box_del(a); else s->wrap= (GF_TextWrapBox*) a; break; case GF_QT_BOX_TYPE_FRCD: s->is_forced = GF_TRUE; gf_isom_box_del(a); break; default: gf_isom_box_del(a); break; } } return s; }"
"static int xmlParse3986Port(xmlURIPtr uri, const char **str) { const char *cur = *str; unsigned port = 0;  if (ISA_DIGIT(cur)) { while (ISA_DIGIT(cur)) { port = port * 10 + (*cur - '0'); cur++; } if (uri != NULL) uri->port = port & INT_MAX;  *str = cur; return(0); } return(1); }"
"void operator()(OpKernelContext* context, const T1* input_data, int input_batches, int input_height, int input_width, int input_depth, int input_offset, const T2* filter_data, int filter_height, int filter_width, int filter_count, int filter_offset, int stride, Padding padding, T3* output_data, int output_height, int output_width, int output_shift, int output_offset, int output_mult) { if (input_offset < 0) { static int warning_count = 0; if (warning_count < 10) { ++warning_count; LOG(WARNING) << ""For kernel '"" << context->op_kernel().name() << ""' from input '"" << context->op_kernel().requested_input(0) << ""': Zero is not representable in the quantized range used by the"" << "" input. This means QuantizedConv2d has to fall back to a slow"" << "" implementation, since the border of zero values can't be"" << "" represented easily. You should try to construct graphs that"" << "" avoid this situation.""; } ReferenceConvFunctor<T1, T2, T3> conv_functor; conv_functor(context, input_data, input_batches, input_height, input_width, input_depth, input_offset, filter_data, filter_height, filter_width, filter_count, filter_offset, stride, padding, output_data, output_height, output_width, output_shift, output_offset, output_mult); return; } CHECK_GT(output_width, 0); CHECK_GT(output_height, 0); int filter_left_offset; int filter_top_offset; if (padding == VALID) { filter_left_offset = ((output_width - 1) * stride + filter_width - input_width + 1) / 2; filter_top_offset = ((output_height - 1) * stride + filter_height - input_height + 1) / 2; } else { filter_left_offset = ((output_width - 1) * stride + filter_width - input_width) / 2; filter_top_offset = ((output_height - 1) * stride + filter_height - input_height) / 2; } const int filter_value_count = filter_width * filter_height * input_depth; const int64 patches_per_chunk = kMaxChunkSize / (filter_value_count * sizeof(T1)); const int64 chunk_value_count = (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1); Im2ColBufferResource<T1, chunk_value_count>* im2col_buffer_resource; std::function<Status(Im2ColBufferResource<T1, chunk_value_count>**)> creator = [](Im2ColBufferResource<T1, chunk_value_count>** resource) { #ifdef _MSC_VER const int64 chunk_value_count = (kMaxChunkSize + (sizeof(T1) - 1)) / sizeof(T1); #endif *resource = new Im2ColBufferResource<T1, chunk_value_count>(); return Status::OK(); }; OP_REQUIRES_OK(context, context->resource_manager()->LookupOrCreate( ""Conv2d"", ""im2col_buffer"", &im2col_buffer_resource, creator)); mutex_lock lock_buffer(im2col_buffer_resource->mu); core::ScopedUnref unref_buffer(im2col_buffer_resource); T1* im2col_buffer = im2col_buffer_resource->data; const int64 patch_count = (input_batches * output_height * output_width); const int64 chunk_count = (patch_count + (patches_per_chunk - 1)) / patches_per_chunk; for (int64 chunk_index = 0; chunk_index < chunk_count; ++chunk_index) { const int64 patch_index_start = chunk_index * patches_per_chunk; const int64 patch_index_end = std::min(patch_index_start + patches_per_chunk, patch_count); for (int64 patch_index = patch_index_start; patch_index < patch_index_end; ++patch_index) { const int64 batch = patch_index / (output_height * output_width); const int64 out_y = (patch_index / output_width) % output_height; const int64 out_x = patch_index % output_width; const T1* input_batch_start = input_data + (batch * input_height * input_width * input_depth); const int in_y_origin = (out_y * stride) - filter_top_offset; const int in_x_origin = (out_x * stride) - filter_left_offset; const int patch_index_within_chunk = patch_index % patches_per_chunk; T1* im2col_patch_start = im2col_buffer + (patch_index_within_chunk * filter_value_count); for (int filter_y = 0; filter_y < filter_height; ++filter_y) { const int in_y = in_y_origin + filter_y; T1* im2col_row_start = im2col_patch_start + (filter_y * filter_width * input_depth); if ((in_y < 0) || (in_y >= input_height)) { memset(im2col_row_start, input_offset, (filter_width * input_depth)); } else { const int in_x_end = in_x_origin + filter_width; const int left_zero_count = std::max(0, 0 - in_x_origin); const int right_zero_count = std::max(0, in_x_end - input_width); const int center_copy_count = filter_width - (left_zero_count + right_zero_count); if (left_zero_count > 0) { T1* im2col_left_start = im2col_row_start; memset(im2col_left_start, input_offset, (left_zero_count * input_depth)); } if (center_copy_count > 0) { const T1* input_row_start = input_batch_start + (in_y * input_width * input_depth) + (std::max(0, in_x_origin) * input_depth); T1* im2col_center_start = im2col_row_start + (left_zero_count * input_depth); memcpy(im2col_center_start, input_row_start, (center_copy_count * input_depth)); } if (right_zero_count > 0) { T1* im2col_right_start = im2col_row_start + ((left_zero_count + center_copy_count) * input_depth); memset(im2col_right_start, input_offset, (right_zero_count * input_depth)); } } } } const int how_many_patches = patch_index_end - patch_index_start; const bool transpose_a = false; const bool transpose_b = false; const bool transpose_c = false; const int m = how_many_patches; const int n = filter_count; const int k = filter_value_count; const int lda = filter_value_count; const int ldb = filter_count; const int ldc = filter_count; T3* chunk_output_data = output_data + (patch_index_start * filter_count); if (meta::IsSupportedAndEnabled() && std::is_same<T1, quint8>() && std::is_same<T2, quint8>() && std::is_same<T3, qint32>() && (output_offset == 0) && (output_mult == 1) && (output_shift == 0) && (transpose_c == false) && (k <= 2048)) { meta::QuantizedGemm(context, transpose_a, transpose_b, im2col_buffer, filter_data, chunk_output_data, m, n, k, -input_offset, -filter_offset, lda, ldb, ldc); } else if (std::is_same<T1, quint8>() && std::is_same<T2, quint8>() && std::is_same<T3, qint32>() && (output_offset == 0) && (output_mult == 1) && (output_shift == 0)) { const uint8* im2col_data_as_uint8 = &(im2col_buffer->value); const uint8* filter_data_as_uint8 = &(filter_data->value); int32* output_data_as_int32 = &(chunk_output_data->value); static const gemmlowp::MapOrder ResultOrder = !transpose_c ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; static const gemmlowp::MapOrder LhsOrder = !transpose_a ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; static const gemmlowp::MapOrder RhsOrder = !transpose_b ? gemmlowp::MapOrder::RowMajor : gemmlowp::MapOrder::ColMajor; gemmlowp::MatrixMap<const std::uint8_t, LhsOrder> lhs( im2col_data_as_uint8, m, k, lda); gemmlowp::MatrixMap<const std::uint8_t, RhsOrder> rhs( filter_data_as_uint8, k, n, ldb); gemmlowp::MatrixMap<std::int32_t, ResultOrder> result( output_data_as_int32, m, n, ldc); const std::tuple<> empty_pipeline = {}; auto& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); TensorflowGemmContext context(worker_threads.num_threads, worker_threads.workers); gemmlowp::GemmWithOutputPipeline<std::uint8_t, std::int32_t, gemmlowp::DefaultL8R8BitDepthParams>( &context, lhs, rhs, &result, -input_offset, -filter_offset, empty_pipeline); TF_ANNOTATE_MEMORY_IS_INITIALIZED(output_data_as_int32, m * n * sizeof(int32)); } else { ReferenceGemm<T1, T2, T3>( transpose_a, transpose_b, transpose_c, m, n, k, im2col_buffer, input_offset, lda, filter_data, filter_offset, ldb, chunk_output_data, output_shift, output_offset, output_mult, ldc); } } }"
"static char *get_die_name(const RBinDwarfDie *die) { char *name = NULL; st32 name_attr_idx = find_attr_idx (die, DW_AT_name); if (name_attr_idx != -1) { name = strdup (die->attr_values[name_attr_idx].string.content); } else { name = create_type_name_from_offset (die->offset); } return name; }"
"AP4_Stz2Atom::AP4_Stz2Atom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_STZ2, size, version, flags) { AP4_UI08 reserved; stream.ReadUI08(reserved); stream.ReadUI08(reserved); stream.ReadUI08(reserved); stream.ReadUI08(m_FieldSize); stream.ReadUI32(m_SampleCount); if (m_FieldSize != 4 && m_FieldSize != 8 && m_FieldSize != 16) { return; } AP4_Cardinal sample_count = m_SampleCount; m_Entries.SetItemCount(sample_count); unsigned int table_size = (sample_count*m_FieldSize+7)/8; if ((table_size+8) > size) return; unsigned char* buffer = new unsigned char[table_size]; AP4_Result result = stream.Read(buffer, table_size); if (AP4_FAILED(result)) { delete[] buffer; return; } switch (m_FieldSize) { case 4: for (unsigned int i=0; i<sample_count; i++) { if ((i%2) == 0) { m_Entries[i] = (buffer[i/2]>>4)&0x0F; } else { m_Entries[i] = buffer[i/2]&0x0F; } } break; case 8: for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = buffer[i]; } break; case 16: for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = AP4_BytesToUInt16BE(&buffer[i*2]); } break; } delete[] buffer; }"
"TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) { auto it = idInfoMap.find(id); if (it == idInfoMap.end()) { STFATAL << "" Tried to read from an id that no longer exists""; } return it->second; }"
"mp_err s_mp_mul_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs) { mp_int  t; mp_err  err; int     pa, pb, ix, iy; mp_digit u; mp_word r; mp_digit tmpx, *tmpt, *tmpy; if ((digs < MP_WARRAY) && (MP_MIN(a->used, b->used) < MP_MAXFAST)) { return s_mp_mul_digs_fast(a, b, c, digs); } if ((err = mp_init_size(&t, digs)) != MP_OKAY) { return err; } t.used = digs; pa = a->used; for (ix = 0; ix < pa; ix++) { u = 0; pb = MP_MIN(b->used, digs - ix); tmpx = a->dp[ix]; tmpt = t.dp + ix; tmpy = b->dp; for (iy = 0; iy < pb; iy++) { r       = (mp_word)*tmpt + ((mp_word)tmpx * (mp_word)*tmpy++) + (mp_word)u; *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK); u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT); } if ((ix + iy) < digs) { *tmpt = u; } } mp_clamp(&t); mp_exch(&t, c); mp_clear(&t); return MP_OKAY; }"
"void DoRealBackwardFFT(OpKernelContext* ctx, uint64* fft_shape, const Tensor& in, Tensor* out) { auto device = ctx->eigen_device<CPUDevice>(); auto input = Tensor(in).flat_inner_dims<ComplexT, FFTRank + 1>(); auto output = out->flat_inner_dims<RealT, FFTRank + 1>(); const auto input_dims = input.dimensions(); Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes; input_slice_sizes[0] = input_dims[0]; TensorShape full_fft_shape; full_fft_shape.AddDim(input_dims[0]); for (auto i = 1; i <= FFTRank; i++) { input_slice_sizes[i] = i == FFTRank ? fft_shape[i - 1] / 2 + 1 : fft_shape[i - 1]; full_fft_shape.AddDim(fft_shape[i - 1]); } Tensor temp; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(), full_fft_shape, &temp)); auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>(); auto neg_sizes = input_slice_sizes; neg_sizes[FFTRank] = fft_shape[FFTRank - 1] - input_slice_sizes[FFTRank]; Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_target_indices; neg_target_indices[FFTRank] = input_slice_sizes[FFTRank]; const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> start_indices; Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> neg_start_indices; neg_start_indices[FFTRank] = 1; full_fft.slice(start_indices, input_slice_sizes).device(device) = input.slice(start_indices, input_slice_sizes); if (FFTRank > 1) { const auto outer_axes = Eigen::ArrayXi::LinSpaced(FFTRank - 1, 1, FFTRank - 1); full_fft.slice(start_indices, input_slice_sizes).device(device) = full_fft.slice(start_indices, input_slice_sizes) .template fft<Eigen::BothParts, Eigen::FFT_REVERSE>(outer_axes); } Eigen::array<bool, FFTRank + 1> reverse_last_axis; for (auto i = 0; i <= FFTRank; i++) { reverse_last_axis[i] = i == FFTRank; } if (neg_sizes[FFTRank] != 0) { full_fft.slice(neg_target_indices, neg_sizes).device(device) = full_fft.slice(neg_start_indices, neg_sizes) .reverse(reverse_last_axis) .conjugate(); } auto inner_axis = Eigen::array<int, 1>{FFTRank}; output.device(device) = full_fft.template fft<Eigen::RealPart, Eigen::FFT_REVERSE>(inner_axis); }"
"static guint fAbstractSyntaxNType(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset) { guint8  tag_no, tag_info; guint32 lvt; guint   lastoffset = 0, depth = 0; char    ar[256]; guint32 save_object_type; gboolean do_default_handling; if (propertyIdentifier >= 0) { g_snprintf(ar, sizeof(ar), ""%s: "", val_to_split_str(propertyIdentifier, 512, BACnetPropertyIdentifier, ASHRAE_Reserved_Fmt, Vendor_Proprietary_Fmt)); } else { g_snprintf(ar, sizeof(ar), ""Abstract Type: ""); } while (tvb_reported_length_remaining(tvb, offset) > 0) {   lastoffset = offset; fTagHeader(tvb, pinfo, offset, &tag_no, &tag_info, &lvt); if (tag_is_closing(tag_info)) {  if (depth <= 0) return offset; } do_default_handling = FALSE; switch (propertyIdentifier) { case 0:  case 35:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAcknowledgedTransitions); break; case 2:  if (tag_is_context_specific(tag_info)) { offset = fActionList(tvb, pinfo, tree, offset); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAction); } break; case 7:  switch (object_type) { case 21:  case 22:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 30:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 31:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 36:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 39:  default: if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } break; } break; case 37:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEventType); break; case 39:  switch (object_type) { case 21:  case 22:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 30:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 31:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 36:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 39:  default: if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } break; } break; case 30:  case 331:  offset = fAddressBinding(tvb, pinfo, tree, offset); break; case 52:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLimitEnable); break; case 54:  offset = fLOPR(tvb, pinfo, tree, offset); break; case 55:  fSessionKey(tvb, pinfo, tree, offset); break; case 79:  case 96:  offset = fApplicationTypesEnumeratedSplit(tvb, pinfo, tree, offset, ar, BACnetObjectType, 128); break; case 97:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetServicesSupported); break; case 102:  offset = fDestination(tvb, pinfo, tree, offset); break; case 107:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSegmentation); break; case 111:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetStatusFlags); break; case 112:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDeviceStatus); break; case 117:  case 455:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEngineeringUnits); break; case 87:     if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fPriorityArray(tvb, pinfo, tree, offset); } break; case 38:     if (object_type < 128) { if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fSpecialEvent(tvb, pinfo, tree, offset); } } break; case 19:   case 60:   case 78:   case 181:  case 355:  offset = fObjectPropertyReference(tvb, pinfo, tree, offset); break; case 132:  offset = fDeviceObjectPropertyReference(tvb, pinfo, tree, offset); break; case 109:  offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); offset = fBACnetObjectPropertyReference(tvb, pinfo, tree, offset); offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); break; case 123:    if (object_type < 128) { if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fWeeklySchedule(tvb, pinfo, tree, offset); } } break; case 127:    offset = fClientCOV(tvb, pinfo, tree, offset); break; case 131:   if ( object_type == 25 ) offset = fEventLogRecord(tvb, pinfo, tree, offset); else if ( object_type == 27 ) offset = fLogMultipleRecord(tvb, pinfo, tree, offset); else offset = fLogRecord(tvb, pinfo, tree, offset); break; case 159:  case 165:  case 211:  case 246:  case 249:  case 252:  case 265:  case 266:  case 277:  case 279:  case 286:  case 320:  case 321:  case 461:  case 491:  offset = fDeviceObjectReference(tvb, pinfo, tree, offset); break; case 196:  offset = fRestartReason(tvb, pinfo, tree, offset); break; case 212:  case 214:  case 218:  offset = fShedLevel(tvb, pinfo, tree, offset); break; case 152:  offset = fCOVSubscription(tvb, pinfo, tree, offset); break; case 23:  offset = fCalendarEntry(tvb, pinfo, tree, offset); break; case 116:  case 206:  case 202:  offset = fRecipient(tvb, pinfo, tree, offset); break; case 83:  offset = fEventParameter(tvb, pinfo, tree, offset); break; case 130:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fEventTimeStamps(tvb, pinfo, tree, offset); } break; case 197:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLoggingType); break; case 36:  offset = fApplicationTypesEnumeratedSplit(tvb, pinfo, tree, offset, ar, BACnetEventState, 64); break; case 103:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetReliability); break; case 72:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNotifyType); break; case 208:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNodeType); break; case 231:  case 450:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorStatus); break; case 233:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLockStatus); break; case 235:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorSecuredStatus); break; case 158:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetMaintenance); break; case 92:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramState); break; case 90:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramRequest); break; case 100:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProgramError); break; case 160:  case 175:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyMode); break; case 163:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSilencedState); break; case 161:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyOperation); break; case 164:  case 166:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); break; case 41:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetFileAccessMethod); break; case 185:   offset = fPrescale(tvb, pinfo, tree, offset); break; case 187:   offset = fScale(tvb, pinfo, tree, offset); break; case 189:  if (object_type == 37) offset = fTimeStamp(tvb, pinfo, tree, offset, ar); else offset = fDateTime(tvb, pinfo, tree, offset, ar); break; case 184:  offset = fLoggingRecord(tvb, pinfo, tree, offset); break; case 203:  offset = fTimeStamp(tvb, pinfo, tree, offset, ar); break; case 226:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 228:  offset = fDoorMembers(tvb, pinfo, tree, offset); break; case 234:  offset = fSequenceOfEnums(tvb, pinfo, tree, offset, ar, BACnetDoorAlarmState); break; case 248:  offset = fAuthenticationFactor(tvb, pinfo, tree, offset); break; case 261:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAuthorizationMode); break; case 53:   save_object_type = object_type; offset = fListOfGroupMembers(tvb, pinfo, tree, offset); object_type = save_object_type; break; case 296:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessZoneOccupancyState); break; case 300:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessPassbackMode); break; case 303:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessCredentialDisableReason); break; case 318:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAccessUserType); break; case 330:  offset = fSecurityKeySet(tvb, pinfo, tree, offset); break; case 332:  offset = fNetworkSecurityPolicy(tvb, pinfo, tree, offset); break; case 338:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetBackupState); break; case 370:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetWriteStatus); break; case 385:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLightingTransition); break; case 288:  case 302:  offset = fAccessRule(tvb, pinfo, tree, offset); break; case 304:  offset = fAuthenticationFactorFormat(tvb, pinfo, tree, offset); break; case 327:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetSecurityLevel); break; case 371:  offset = fSequenceOfEnums(tvb, pinfo, tree, offset, ar, BACnetPropertyIdentifier); break; case 358:  offset = fFaultParameter(tvb, pinfo, tree, offset); break; case 359:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetFaultType); break; case 362:  offset = fEventNotificationSubscription(tvb, pinfo, tree, offset); break; case 364:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetAuthorizationExemption); break; case 378:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLightingInProgress); break; case 380:  offset = fLightingCommand(tvb, pinfo, tree, offset, ar); break; case 16:   case 71:   case 114:  case 115:  case 142:  case 143:  case 149:  case 150:  case 179:  case 192:  case 254:  case 270:  case 278:  case 280:  case 281:  case 392:  offset = fDateTime(tvb, pinfo, tree, offset, ar); break; case 258:  offset = fAuthenticationPolicy(tvb, pinfo, tree, offset); break; case 395:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerTransition); break; case 396:  offset = fTimerStateChangeValue(tvb, pinfo, tree, offset); break; case 398:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetTimerState); break; case 407:  case 418:  offset = fHostNPort(tvb, pinfo, tree, offset, ar); break; case 408:  case 435:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetIpMode); break; case 414:  offset = fBDTEntry(tvb, pinfo, tree, offset, ar); break; case 415:  offset = fFDTEntry(tvb, pinfo, tree, offset, ar); break; case 417:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkPortCommand); break; case 426:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkNumberQuality); break; case 427:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNetworkType); break; case 428:  offset = fRouterEntry(tvb, pinfo, tree, offset); break; case 429:  offset = fVMACEntry(tvb, pinfo, tree, offset); break; case 430:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fTimeStamp(tvb, pinfo, tree, offset, ar); } break; case 432:  offset = fTimeStamp(tvb, pinfo, tree, offset, ar); break; case 433:  offset = fValueSource(tvb, pinfo, tree, offset); break; case 434:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fValueSource(tvb, pinfo, tree, offset); } break; case 447:  offset = fAssignedLandingCalls(tvb, pinfo, tree, offset); break; case 448:  case 457:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDirection); break; case 449:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDoorCommand); break; case 453:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarDriveStatus); break; case 456:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftCarMode); break; case 462:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorMode); break; case 463:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { if (object_type == 59)  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftFault); else offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorFault); } break; case 467:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetLiftGroupMode); break; case 470:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fLandingCallStatus(tvb, pinfo, tree, offset); } break; case 471:  offset = fLandingCallStatus(tvb, pinfo, tree, offset); break; case 472:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fLandingDoorStatus(tvb, pinfo, tree, offset); } break; case 477:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetEscalatorOperationDirection); break; case 481:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fCOVMultipleSubscription(tvb, pinfo, tree, offset); } break; case 482:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetProtocolLevel); break; case 486:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fNameValue(tvb, pinfo, tree, offset); } break; case 487:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetNodeType); } break; case 488:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fNameValueCollection(tvb, pinfo, tree, offset); } break; case 489:  if (propertyArrayIndex == 0) { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } else { offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetRelationship); } break; case 490:  offset = fApplicationTypesEnumerated(tvb, pinfo, tree, offset, ar, BACnetRelationship); break; case 85:   if ( object_type == 11 )     { offset = fReadAccessResult(tvb, pinfo, tree, offset); } else if (object_type == 30)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetDoorValue); } else if (object_type == 21)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); } else if (object_type == 22)   { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetLifeSafetyState); } else if (object_type == 53)  { offset = fChannelValue(tvb, pinfo, tree, offset, ar); } else if (object_type == 37)  { offset = fAuthenticationFactor(tvb, pinfo, tree, offset); } else if (object_type == 26)  { offset = fPropertyAccessResult(tvb, pinfo, tree, offset); } else if (object_type == 28)  { offset = fEnumeratedTag(tvb, pinfo, tree, offset, ar, BACnetShedState); } else { do_default_handling = TRUE; } break; default: do_default_handling = TRUE; break; } if (do_default_handling) { if (tag_info) { if (tag_is_opening(tag_info)) { ++depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else if (tag_is_closing(tag_info)) { --depth; offset += fTagHeaderTree(tvb, pinfo, tree, offset, &tag_no, &tag_info, &lvt); } else { offset  = fContextTaggedValue(tvb, pinfo, tree, offset, ar); } } else { offset = fApplicationTypes(tvb, pinfo, tree, offset, ar); } } if (offset <= lastoffset) break;      } return offset; }"
"WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec, WORD32 i4_poc, pocstruct_t *ps_temp_poc, UWORD16 u2_frame_num, dec_pic_params_t *ps_pps) { pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc; pocstruct_t *ps_cur_poc = ps_temp_poc; pic_buffer_t *pic_buf; ivd_video_decode_op_t * ps_dec_output = (ivd_video_decode_op_t *)ps_dec->pv_dec_out; dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice; dec_seq_params_t *ps_seq = ps_pps->ps_sps; UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag; UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag; high_profile_tools_t s_high_profile; WORD32 ret; H264_MUTEX_LOCK(&ps_dec->process_disp_mutex); ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb; ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb; ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom; ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0]; ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1]; ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag; ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst; ps_prev_poc->u2_frame_num = u2_frame_num; ps_dec->i1_prev_mb_qp_delta = 0; ps_dec->i1_next_ctxt_idx = 0; ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores == 1) ps_dec->u4_nmb_deblk = 1; if(ps_seq->u1_mb_aff_flag == 1) { ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores > 2) ps_dec->u4_num_cores = 2; } ps_dec->u4_use_intrapred_line_copy = 0; if (ps_seq->u1_mb_aff_flag == 0) { ps_dec->u4_use_intrapred_line_copy = 1; } ps_dec->u4_app_disable_deblk_frm = 0; if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics) { WORD32 degrade_pic; ps_dec->i4_degrade_pic_cnt++; degrade_pic = 0; switch(ps_dec->i4_degrade_pics) { case 4: { degrade_pic = 1; break; } case 3: { if(ps_cur_slice->u1_slice_type != I_SLICE) degrade_pic = 1; break; } case 2: { if((ps_cur_slice->u1_slice_type != I_SLICE) && (ps_dec->i4_degrade_pic_cnt != ps_dec->i4_nondegrade_interval)) degrade_pic = 1; break; } case 1: { if(0 == ps_cur_slice->u1_nal_ref_idc) { degrade_pic = 1; } break; } } if(degrade_pic) { if(ps_dec->i4_degrade_type & 0x2) ps_dec->u4_app_disable_deblk_frm = 1; if(0 == ps_cur_slice->u1_nal_ref_idc) { if(ps_dec->i4_degrade_type & 0x4) ps_dec->i4_mv_frac_mask = 0; if(ps_dec->i4_degrade_type & 0x8) ps_dec->i4_mv_frac_mask = 0; } } else ps_dec->i4_degrade_pic_cnt = 0; } { dec_err_status_t * ps_err = ps_dec->ps_dec_err_status; if(ps_dec->u1_sl_typ_5_9 && ((ps_cur_slice->u1_slice_type == I_SLICE) || (ps_cur_slice->u1_slice_type == SI_SLICE))) ps_err->u1_cur_pic_type = PIC_TYPE_I; else ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN; if(ps_err->u1_pic_aud_i == PIC_TYPE_I) { ps_err->u1_cur_pic_type = PIC_TYPE_I; ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN; } if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL) { if(ps_err->u1_err_flag) ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr); ps_err->u1_err_flag = ACCEPT_ALL_PICS; } } if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending) { WORD32 j; for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->u1_second_field = 0; ps_dec->i4_cur_display_seq = 0; ps_dec->s_prev_seq_params.u1_eoseq_pending = 0; } ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps); if(ret != OK) return ret; ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data; ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data; ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info; if(ps_dec->u1_separate_parse) { UWORD16 pic_wd; UWORD16 pic_ht; UWORD32 num_mbs; pic_wd = ps_dec->u2_pic_wd; pic_ht = ps_dec->u2_pic_ht; num_mbs = (pic_wd * pic_ht) >> 8; if(ps_dec->pu1_dec_mb_map) { memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs); } if(ps_dec->pu1_recon_mb_map) { memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs); } if(ps_dec->pu2_slice_num_map) { memset((void *)ps_dec->pu2_slice_num_map, 0, (num_mbs * sizeof(UWORD16))); } } ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->s_high_profile.u1_scaling_present = 0; ps_dec->s_high_profile.u1_transform8x8_present = 0; if(1 == ps_dec->u4_share_disp_buf) { UWORD32 i; for(i = 0; i < MAX_DISP_BUFS_NEW; i++) { if(0 == ps_dec->u4_disp_buf_to_be_freed[i]) continue; ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i, BUF_MGR_IO); ps_dec->u4_disp_buf_to_be_freed[i] = 0; ps_dec->u4_disp_buf_mapping[i] = 0; } } if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))     { pic_buffer_t *ps_cur_pic; WORD32 cur_pic_buf_id, cur_mv_buf_id; col_mv_buf_t *ps_col_mv; while(1) { ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id]) { break; } } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; if(ps_dec->u1_first_slice_in_stream) { ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0]; *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic; } if(!ps_dec->ps_cur_pic) { WORD32 j; H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n""); for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->i4_cur_display_seq = 0; ps_dec->i4_prev_max_display_seq = 0; ps_dec->i4_max_poc = 0; ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; } ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag; ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE; H264_DEC_DEBUG_PRINT(""got a buffer\n""); } else { H264_DEC_DEBUG_PRINT(""did not get a buffer\n""); } ps_dec->u4_pic_buf_got = 1; ps_dec->ps_cur_pic->i4_poc = i4_poc; ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num; ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num; ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt; ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = ps_pps->i4_bottom_field_order_cnt; ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc; ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts; ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic); if(u1_field_pic_flag && u1_bottom_field_flag) { WORD32 i4_temp_poc; WORD32 i4_top_field_order_poc, i4_bot_field_order_poc; ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y; ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.ps_mv += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD; i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt; i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt; i4_temp_poc = MIN(i4_top_field_order_poc, i4_bot_field_order_poc); ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc; } ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag); ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag << 2); ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;         ps_dec->ps_cur_mb_row += 2; ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row; ps_dec->ps_top_mb_row += ((ps_dec->u2_frm_wd_in_mbs + 2) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag)); ps_dec->ps_top_mb_row += 2; ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0]; ps_dec->u1_mv_top_p = 0; ps_dec->u1_mb_idx = 0; ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv; ps_dec->u2_total_mbs_coded = 0; ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE); ps_dec->u4_pred_info_idx = 0; ps_dec->u4_pred_info_pkd_idx = 0; ps_dec->u4_dma_buf_idx = 0; ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag; ps_dec->ps_part = ps_dec->ps_parse_part_params; ps_dec->i2_prev_slice_mbx = -1; ps_dec->i2_prev_slice_mby = 0; ps_dec->u2_mv_2mb[0] = 0; ps_dec->u2_mv_2mb[1] = 0; ps_dec->u1_last_pic_not_decoded = 0; ps_dec->u2_cur_slice_num = 0; ps_dec->u2_cur_slice_num_dec_thread = 0; ps_dec->u2_cur_slice_num_bs = 0; ps_dec->u4_intra_pred_line_ofst = 0; ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE); ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR; ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE; ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic; { if(ps_cur_slice->u1_mbaff_frame_flag) { ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff; ps_dec->pf_mvpred = ih264d_mvpred_mbaff; } else { ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff; ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag; } } { UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag; UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag; UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4) % (ps_dec->u1_recon_mb_grp >> u1_mbaff)); UWORD16 ui16_lastmbs_widthY = (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 4)); UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 3); ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1; ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2; ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3; ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y << u1_field_pic_flag; ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv << u1_field_pic_flag; if(u1_field_pic_flag) { ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y; ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv; } ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY + (PAD_LEN_Y_H << 1) + ps_dec->s_tran_addrecon.u2_frm_wd_y * ((15 << u1_mbaff) + u1_mbaff)); ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV + (PAD_LEN_UV_H << 2) + ps_dec->s_tran_addrecon.u2_frm_wd_uv * ((15 << u1_mbaff) + u1_mbaff)); ih264d_assign_pic_num(ps_dec); ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp << 2) - 1 - (u1_mbaff << 2); ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp >> u1_mbaff) - 1) << (4 + u1_mbaff); } if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC) { if((ps_seq->i4_seq_scaling_matrix_present_flag) || (ps_pps->i4_pic_scaling_matrix_present_flag)) { ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec); ps_dec->s_high_profile.u1_scaling_present = 1; } else { ih264d_form_default_scaling_matrix(ps_dec); } if(ps_pps->i4_transform_8x8_mode_flag) { ps_dec->s_high_profile.u1_transform8x8_present = 1; } } else { ih264d_form_default_scaling_matrix(ps_dec); } ps_dec->s_high_profile.u1_direct_8x8_inference_flag = ps_seq->u1_direct_8x8_inference_flag; ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt; ps_dec->i1_recon_in_thread3_flag = 1; ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon; if(ps_dec->u1_separate_parse) { memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag) { memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon; } } ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon), ps_dec->u2_frm_wd_in_mbs, 0); ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic; ps_dec->u4_cur_deblk_mb_num = 0; ps_dec->u4_deblk_mb_x = 0; ps_dec->u4_deblk_mb_y = 0; H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex); return OK; }"
"static int xenoprof_buf_space(struct domain *d, xenoprof_buf_t * buf, int size) { int head, tail; head = xenoprof_buf(d, buf, event_head); tail = xenoprof_buf(d, buf, event_tail); return ((tail > head) ? 0 : size) + tail - head - 1; }"
"static int toneport_setup(struct usb_line6_toneport *toneport) { u32 *ticks; struct usb_line6 *line6 = &toneport->line6; struct usb_device *usbdev = line6->usbdev; ticks = kmalloc(sizeof(*ticks), GFP_KERNEL); if (!ticks) return -ENOMEM; *ticks = (u32)ktime_get_real_seconds(); line6_write_data(line6, 0x80c6, ticks, 4); kfree(ticks); toneport_send_cmd(usbdev, 0x0301, 0x0000); if (toneport_has_source_select(toneport)) toneport_send_cmd(usbdev, toneport_source_info[toneport->source].code, 0x0000); if (toneport_has_led(toneport)) toneport_update_led(toneport); schedule_delayed_work(&toneport->pcm_work, msecs_to_jiffies(TONEPORT_PCM_DELAY * 1000)); return 0; }"
"static bfd_boolean process_mips_specific (FILE * file) { Elf_Internal_Dyn * entry; Elf_Internal_Shdr *sect = NULL; size_t liblist_offset = 0; size_t liblistno = 0; size_t conflictsno = 0; size_t options_offset = 0; size_t conflicts_offset = 0; size_t pltrelsz = 0; size_t pltrel = 0; bfd_vma pltgot = 0; bfd_vma mips_pltgot = 0; bfd_vma jmprel = 0; bfd_vma local_gotno = 0; bfd_vma gotsym = 0; bfd_vma symtabno = 0; bfd_boolean res = TRUE; if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL, display_mips_gnu_attribute)) res = FALSE; sect = find_section ("".MIPS.abiflags""); if (sect != NULL) { Elf_External_ABIFlags_v0 *abiflags_ext; Elf_Internal_ABIFlags_v0 abiflags_in; if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size) { error (_(""Corrupt MIPS ABI Flags section.\n"")); res = FALSE; } else { abiflags_ext = get_data (NULL, file, sect->sh_offset, 1, sect->sh_size, _(""MIPS ABI Flags section"")); if (abiflags_ext) { abiflags_in.version = BYTE_GET (abiflags_ext->version); abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level); abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev); abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size); abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size); abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size); abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi); abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext); abiflags_in.ases = BYTE_GET (abiflags_ext->ases); abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1); abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2); printf (""\nMIPS ABI Flags Version: %d\n"", abiflags_in.version); printf (""\nISA: MIPS%d"", abiflags_in.isa_level); if (abiflags_in.isa_rev > 1) printf (""r%d"", abiflags_in.isa_rev); printf (""\nGPR size: %d"", get_mips_reg_size (abiflags_in.gpr_size)); printf (""\nCPR1 size: %d"", get_mips_reg_size (abiflags_in.cpr1_size)); printf (""\nCPR2 size: %d"", get_mips_reg_size (abiflags_in.cpr2_size)); fputs (""\nFP ABI: "", stdout); print_mips_fp_abi_value (abiflags_in.fp_abi); fputs (""ISA Extension: "", stdout); print_mips_isa_ext (abiflags_in.isa_ext); fputs (""\nASEs:"", stdout); print_mips_ases (abiflags_in.ases); printf (""\nFLAGS 1: %8.8lx"", abiflags_in.flags1); printf (""\nFLAGS 2: %8.8lx"", abiflags_in.flags2); fputc ('\n', stdout); free (abiflags_ext); } } } if (dynamic_section == NULL) return res; for (entry = dynamic_section; entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL; ++entry) switch (entry->d_tag) { case DT_MIPS_LIBLIST: liblist_offset = offset_from_vma (file, entry->d_un.d_val, liblistno * sizeof (Elf32_External_Lib)); break; case DT_MIPS_LIBLISTNO: liblistno = entry->d_un.d_val; break; case DT_MIPS_OPTIONS: options_offset = offset_from_vma (file, entry->d_un.d_val, 0); break; case DT_MIPS_CONFLICT: conflicts_offset = offset_from_vma (file, entry->d_un.d_val, conflictsno * sizeof (Elf32_External_Conflict)); break; case DT_MIPS_CONFLICTNO: conflictsno = entry->d_un.d_val; break; case DT_PLTGOT: pltgot = entry->d_un.d_ptr; break; case DT_MIPS_LOCAL_GOTNO: local_gotno = entry->d_un.d_val; break; case DT_MIPS_GOTSYM: gotsym = entry->d_un.d_val; break; case DT_MIPS_SYMTABNO: symtabno = entry->d_un.d_val; break; case DT_MIPS_PLTGOT: mips_pltgot = entry->d_un.d_ptr; break; case DT_PLTREL: pltrel = entry->d_un.d_val; break; case DT_PLTRELSZ: pltrelsz = entry->d_un.d_val; break; case DT_JMPREL: jmprel = entry->d_un.d_ptr; break; default: break; } if (liblist_offset != 0 && liblistno != 0 && do_dynamic) { Elf32_External_Lib * elib; size_t cnt; elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset, liblistno, sizeof (Elf32_External_Lib), _(""liblist section data"")); if (elib) { printf (_(""\nSection '.liblist' contains %lu entries:\n""), (unsigned long) liblistno); fputs (_(""     Library              Time Stamp          Checksum   Version Flags\n""), stdout); for (cnt = 0; cnt < liblistno; ++cnt) { Elf32_Lib liblist; time_t atime; char timebuf[128]; struct tm * tmp; liblist.l_name = BYTE_GET (elib[cnt].l_name); atime = BYTE_GET (elib[cnt].l_time_stamp); liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum); liblist.l_version = BYTE_GET (elib[cnt].l_version); liblist.l_flags = BYTE_GET (elib[cnt].l_flags); tmp = gmtime (&atime); snprintf (timebuf, sizeof (timebuf), ""%04u-%02u-%02uT%02u:%02u:%02u"", tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec); printf (""%3lu: "", (unsigned long) cnt); if (VALID_DYNAMIC_NAME (liblist.l_name)) print_symbol (20, GET_DYNAMIC_NAME (liblist.l_name)); else printf (_(""<corrupt: %9ld>""), liblist.l_name); printf ("" %s %#10lx %-7ld"", timebuf, liblist.l_checksum, liblist.l_version); if (liblist.l_flags == 0) puts (_("" NONE"")); else { static const struct { const char * name; int bit; } l_flags_vals[] = { { "" EXACT_MATCH"", LL_EXACT_MATCH }, { "" IGNORE_INT_VER"", LL_IGNORE_INT_VER }, { "" REQUIRE_MINOR"", LL_REQUIRE_MINOR }, { "" EXPORTS"", LL_EXPORTS }, { "" DELAY_LOAD"", LL_DELAY_LOAD }, { "" DELTA"", LL_DELTA } }; int flags = liblist.l_flags; size_t fcnt; for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt) if ((flags & l_flags_vals[fcnt].bit) != 0) { fputs (l_flags_vals[fcnt].name, stdout); flags ^= l_flags_vals[fcnt].bit; } if (flags != 0) printf ("" %#x"", (unsigned int) flags); puts (""""); } } free (elib); } else res = FALSE; } if (options_offset != 0) { Elf_External_Options * eopt; Elf_Internal_Options * iopt; Elf_Internal_Options * option; size_t offset; int cnt; sect = section_headers; sect = find_section_by_type (SHT_MIPS_OPTIONS); if (sect == NULL) { error (_(""No MIPS_OPTIONS header found\n"")); return FALSE; } eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1, sect->sh_size, _(""options"")); if (eopt) { iopt = (Elf_Internal_Options *) cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt)); if (iopt == NULL) { error (_(""Out of memory allocating space for MIPS options\n"")); return FALSE; } offset = cnt = 0; option = iopt; while (offset <= sect->sh_size - sizeof (* eopt)) { Elf_External_Options * eoption; eoption = (Elf_External_Options *) ((char *) eopt + offset); option->kind = BYTE_GET (eoption->kind); option->size = BYTE_GET (eoption->size); option->section = BYTE_GET (eoption->section); option->info = BYTE_GET (eoption->info); if (option->size < sizeof (* eopt) || offset + option->size > sect->sh_size) { error (_(""Invalid size (%u) for MIPS option\n""), option->size); return FALSE; } offset += option->size; ++option; ++cnt; } printf (_(""\nSection '%s' contains %d entries:\n""), printable_section_name (sect), cnt); option = iopt; offset = 0; while (cnt-- > 0) { size_t len; switch (option->kind) { case ODK_NULL: printf ("" NULL       %d %lx"", option->section, option->info); break; case ODK_REGINFO: printf ("" REGINFO    ""); if (elf_header.e_machine == EM_MIPS) { Elf32_External_RegInfo * ereg; Elf32_RegInfo reginfo; ereg = (Elf32_External_RegInfo *) (option + 1); reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x%lx\n"", reginfo.ri_gprmask, (unsigned long) reginfo.ri_gp_value); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } else { Elf64_External_RegInfo * ereg; Elf64_Internal_RegInfo reginfo; ereg = (Elf64_External_RegInfo *) (option + 1); reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x"", reginfo.ri_gprmask); printf_vma (reginfo.ri_gp_value); printf (""\n""); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } ++option; continue; case ODK_EXCEPTIONS: fputs ("" EXCEPTIONS fpe_min("", stdout); process_mips_fpe_exception (option->info & OEX_FPU_MIN); fputs ("") fpe_max("", stdout); process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8); fputs ("")"", stdout); if (option->info & OEX_PAGE0) fputs ("" PAGE0"", stdout); if (option->info & OEX_SMM) fputs ("" SMM"", stdout); if (option->info & OEX_FPDBUG) fputs ("" FPDBUG"", stdout); if (option->info & OEX_DISMISS) fputs ("" DISMISS"", stdout); break; case ODK_PAD: fputs ("" PAD       "", stdout); if (option->info & OPAD_PREFIX) fputs ("" PREFIX"", stdout); if (option->info & OPAD_POSTFIX) fputs ("" POSTFIX"", stdout); if (option->info & OPAD_SYMBOL) fputs ("" SYMBOL"", stdout); break; case ODK_HWPATCH: fputs ("" HWPATCH   "", stdout); if (option->info & OHW_R4KEOP) fputs ("" R4KEOP"", stdout); if (option->info & OHW_R8KPFETCH) fputs ("" R8KPFETCH"", stdout); if (option->info & OHW_R5KEOP) fputs ("" R5KEOP"", stdout); if (option->info & OHW_R5KCVTL) fputs ("" R5KCVTL"", stdout); break; case ODK_FILL: fputs ("" FILL       "", stdout); break; case ODK_TAGS: fputs ("" TAGS       "", stdout); break; case ODK_HWAND: fputs ("" HWAND     "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_HWOR: fputs ("" HWOR      "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_GP_GROUP: printf ("" GP_GROUP  %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; case ODK_IDENT: printf ("" IDENT     %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; default: printf ("" %3d ???     %d %lx"", option->kind, option->section, option->info); break; } len = sizeof (* eopt); while (len < option->size) { unsigned char datum = * ((unsigned char *) eopt + offset + len); if (ISPRINT (datum)) printf (""%c"", datum); else printf (""\\%03o"", datum); len ++; } fputs (""\n"", stdout); offset += option->size; ++option; } free (eopt); } else res = FALSE; } if (conflicts_offset != 0 && conflictsno != 0) { Elf32_Conflict * iconf; size_t cnt; if (dynamic_symbols == NULL) { error (_(""conflict list found without a dynamic symbol table\n"")); return FALSE; } iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf)); if (iconf == NULL) { error (_(""Out of memory allocating space for dynamic conflicts\n"")); return FALSE; } if (is_32bit_elf) { Elf32_External_Conflict * econf32; econf32 = (Elf32_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf32), _(""conflict"")); if (!econf32) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf32[cnt]); free (econf32); } else { Elf64_External_Conflict * econf64; econf64 = (Elf64_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf64), _(""conflict"")); if (!econf64) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf64[cnt]); free (econf64); } printf (_(""\nSection '.conflict' contains %lu entries:\n""), (unsigned long) conflictsno); puts (_(""  Num:    Index       Value  Name"")); for (cnt = 0; cnt < conflictsno; ++cnt) { printf (""%5lu: %8lu  "", (unsigned long) cnt, iconf[cnt]); if (iconf[cnt] >= num_dynamic_syms) printf (_(""<corrupt symbol index>"")); else { Elf_Internal_Sym * psym; psym = & dynamic_symbols[iconf[cnt]]; print_vma (psym->st_value, FULL_HEX); putchar (' '); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (25, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } putchar ('\n'); } free (iconf); } if (pltgot != 0 && local_gotno != 0) { bfd_vma ent, local_end, global_end; size_t i, offset; unsigned char * data; unsigned char * data_end; int addr_size; ent = pltgot; addr_size = (is_32bit_elf ? 4 : 8); local_end = pltgot + local_gotno * addr_size; if (symtabno < gotsym) { error (_(""The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n""), (unsigned long) gotsym, (unsigned long) symtabno); return FALSE; } global_end = local_end + (symtabno - gotsym) * addr_size; if (global_end < local_end) { error (_(""Too many GOT symbols: %lu\n""), (unsigned long) symtabno); return FALSE; } offset = offset_from_vma (file, pltgot, global_end - pltgot); data = (unsigned char *) get_data (NULL, file, offset, global_end - pltgot, 1, _(""Global Offset Table data"")); if (data == NULL) return FALSE; data_end = data + (global_end - pltgot); printf (_(""\nPrimary GOT:\n"")); printf (_("" Canonical gp value: "")); print_vma (pltgot + 0x7ff0, LONG_HEX); printf (""\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %10s %*s Purpose\n""), addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Lazy resolver\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; if (data) { if (data + ent - pltgot > data_end - addr_size) { error (_(""Invalid got entry - %#lx - overflows GOT table\n""), (long) ent); goto got_print_fail; } if (byte_get (data + ent - pltgot, addr_size) >> (addr_size * 8 - 1) != 0) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Module pointer (GNU extension)\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; } } printf (""\n""); if (ent < local_end) { printf (_("" Local entries:\n"")); printf (""  %*s %10s %*s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); while (ent < local_end) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (""\n""); if (ent == (bfd_vma) -1) goto got_print_fail; } printf (""\n""); } if (gotsym < symtabno) { int sym_width; printf (_("" Global entries:\n"")); printf (""  %*s %10s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1; for (i = gotsym; i < symtabno; i++) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf ("" ""); if (dynamic_symbols == NULL) printf (_(""<no dynamic symbols>"")); else if (i < num_dynamic_syms) { Elf_Internal_Sym * psym = dynamic_symbols + i; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } else printf (_(""<symbol index %lu exceeds number of dynamic symbols>""), (unsigned long) i); printf (""\n""); if (ent == (bfd_vma) -1) break; } printf (""\n""); } got_print_fail: if (data) free (data); } if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0) { bfd_vma ent, end; size_t offset, rel_offset; unsigned long count, i; unsigned char * data; int addr_size, sym_width; Elf_Internal_Rela * rels; rel_offset = offset_from_vma (file, jmprel, pltrelsz); if (pltrel == DT_RELA) { if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } else { if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } ent = mips_pltgot; addr_size = (is_32bit_elf ? 4 : 8); end = mips_pltgot + (2 + count) * addr_size; offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot); data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot, 1, _(""Procedure Linkage Table data"")); if (data == NULL) return FALSE; printf (""\nPLT GOT:\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %*s Purpose\n""), addr_size * 2, _(""Address""), addr_size * 2, _(""Initial"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" PLT lazy resolver\n"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" Module pointer\n"")); printf (""\n""); printf (_("" Entries:\n"")); printf (""  %*s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1; for (i = 0; i < count; i++) { unsigned long idx = get_reloc_symindex (rels[i].r_info); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf ("" ""); if (idx >= num_dynamic_syms) printf (_(""<corrupt symbol index: %lu>""), idx); else { Elf_Internal_Sym * psym = dynamic_symbols + idx; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } printf (""\n""); } printf (""\n""); if (data) free (data); free (rels); } return res; }"
"void proto_register_iscsi(void) { module_t *iscsi_module; expert_module_t* expert_iscsi; static hf_register_info hf[] = { { &hf_iscsi_request_frame, { ""Request in"", ""iscsi.request_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The request to this transaction is in this frame"", HFILL }}, { &hf_iscsi_time, { ""Time from request"", ""iscsi.time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0, ""Time between the Command and the Response"", HFILL }}, { &hf_iscsi_data_in_frame, { ""Data In in"", ""iscsi.data_in_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The Data In for this transaction is in this frame"", HFILL }}, { &hf_iscsi_data_out_frame, { ""Data Out in"", ""iscsi.data_out_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The Data Out for this transaction is in this frame"", HFILL }}, { &hf_iscsi_response_frame, { ""Response in"", ""iscsi.response_frame"", FT_FRAMENUM, BASE_NONE, NULL, 0, ""The response to this transaction is in this frame"", HFILL }}, { &hf_iscsi_AHS_length, { ""AHS Length"", ""iscsi.ahs.length"", FT_UINT16, BASE_DEC, NULL, 0, ""Length of Additional header segment"", HFILL } }, { &hf_iscsi_AHS_read_data_length, { ""Bidirectional Read Data Length"", ""iscsi.ahs.bidir.length"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_iscsi_AHS_type, { ""AHS Type"", ""iscsi.ahs.type"", FT_UINT8, BASE_DEC, VALS(ahs_type_vals), 0, ""Type of Additional header segment"", HFILL } }, { &hf_iscsi_AHS_extended_cdb, { ""AHS Extended CDB"", ""iscsi.ahs.extended_cdb"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_iscsi_AHS_blob, { ""Unknown AHS blob"", ""iscsi.ahs.unknown_blob"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_iscsi_Padding, { ""Padding"", ""iscsi.padding"", FT_BYTES, BASE_NONE, NULL, 0, ""Padding to 4 byte boundary"", HFILL } }, { &hf_iscsi_ping_data, { ""PingData"", ""iscsi.pingdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Ping Data"", HFILL } }, { &hf_iscsi_immediate_data, { ""ImmediateData"", ""iscsi.immediatedata"", FT_BYTES, BASE_NONE, NULL, 0, ""Immediate Data"", HFILL } }, { &hf_iscsi_async_event_data, { ""AsyncEventData"", ""iscsi.asynceventdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Async Event Data"", HFILL } }, { &hf_iscsi_vendor_specific_data, { ""VendorSpecificData"", ""iscsi.vendorspecificdata"", FT_BYTES, BASE_NONE, NULL, 0, ""Vendor Specific Data"", HFILL } }, { &hf_iscsi_HeaderDigest32, { ""HeaderDigest"", ""iscsi.headerdigest32"", FT_UINT32, BASE_HEX, NULL, 0, ""Header Digest"", HFILL } }, { &hf_iscsi_DataDigest32, { ""DataDigest"", ""iscsi.datadigest32"", FT_UINT32, BASE_HEX, NULL, 0, ""Data Digest"", HFILL } }, { &hf_iscsi_Opcode, { ""Opcode"", ""iscsi.opcode"", FT_UINT8, BASE_HEX, VALS(iscsi_opcodes), 0, NULL, HFILL } }, { &hf_iscsi_X, { ""X"", ""iscsi.X"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_X), 0x80, ""Command Retry"", HFILL } }, { &hf_iscsi_I, { ""I"", ""iscsi.I"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_I), 0x40, ""Immediate delivery"", HFILL } }, { &hf_iscsi_Flags, { ""Flags"", ""iscsi.flags"", FT_UINT8, BASE_HEX, NULL, 0, ""Opcode specific flags"", HFILL } }, { &hf_iscsi_SCSICommand_F, { ""F"", ""iscsi.scsicommand.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80, ""PDU completes command"", HFILL } }, { &hf_iscsi_SCSICommand_R, { ""R"", ""iscsi.scsicommand.R"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_R), 0x40, ""Command reads from SCSI target"", HFILL } }, { &hf_iscsi_SCSICommand_W, { ""W"", ""iscsi.scsicommand.W"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_W), 0x20, ""Command writes to SCSI target"", HFILL } }, { &hf_iscsi_SCSICommand_Attr, { ""Attr"", ""iscsi.scsicommand.attr"", FT_UINT8, BASE_HEX, VALS(iscsi_scsicommand_taskattrs), 0x07, ""SCSI task attributes"", HFILL } }, { &hf_iscsi_SCSICommand_CRN, { ""CRN"", ""iscsi.scsicommand.crn"", FT_UINT8, BASE_HEX, NULL, 0, ""SCSI command reference number"", HFILL } }, { &hf_iscsi_DataSegmentLength, { ""DataSegmentLength"", ""iscsi.datasegmentlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Data segment length (bytes)"", HFILL } }, { &hf_iscsi_TotalAHSLength, { ""TotalAHSLength"", ""iscsi.totalahslength"", FT_UINT8, BASE_DEC_HEX, NULL, 0, ""Total additional header segment length (4 byte words)"", HFILL } }, { &hf_iscsi_InitiatorTaskTag, { ""InitiatorTaskTag"", ""iscsi.initiatortasktag"", FT_UINT32, BASE_HEX, NULL, 0, ""Initiator's task tag"", HFILL } }, { &hf_iscsi_ExpectedDataTransferLength, { ""ExpectedDataTransferLength"", ""iscsi.scsicommand.expecteddatatransferlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Expected length of data transfer"", HFILL } }, { &hf_iscsi_CmdSN, { ""CmdSN"", ""iscsi.cmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Sequence number for this command"", HFILL } }, { &hf_iscsi_ExpStatSN, { ""ExpStatSN"", ""iscsi.expstatsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Next expected status sequence number"", HFILL } }, { &hf_iscsi_SCSIResponse_ResidualCount, { ""ResidualCount"", ""iscsi.scsiresponse.residualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Residual count"", HFILL } }, { &hf_iscsi_StatSN, { ""StatSN"", ""iscsi.statsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Status sequence number"", HFILL } }, { &hf_iscsi_ExpCmdSN, { ""ExpCmdSN"", ""iscsi.expcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Next expected command sequence number"", HFILL } }, { &hf_iscsi_MaxCmdSN, { ""MaxCmdSN"", ""iscsi.maxcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Maximum acceptable command sequence number"", HFILL } }, { &hf_iscsi_SCSIResponse_o, { ""o"", ""iscsi.scsiresponse.o"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_o), 0x10, ""Bi-directional read residual overflow"", HFILL } }, { &hf_iscsi_SCSIResponse_u, { ""u"", ""iscsi.scsiresponse.u"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_u), 0x08, ""Bi-directional read residual underflow"", HFILL } }, { &hf_iscsi_SCSIResponse_O, { ""O"", ""iscsi.scsiresponse.O"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_O), 0x04, ""Residual overflow"", HFILL } }, { &hf_iscsi_SCSIResponse_U, { ""U"", ""iscsi.scsiresponse.U"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_U), 0x02, ""Residual underflow"", HFILL } }, { &hf_iscsi_SCSIResponse_Status, { ""Status"", ""iscsi.scsiresponse.status"", FT_UINT8, BASE_HEX, VALS(scsi_status_val), 0, ""SCSI command status value"", HFILL } }, { &hf_iscsi_SCSIResponse_Response, { ""Response"", ""iscsi.scsiresponse.response"", FT_UINT8, BASE_HEX, VALS(iscsi_scsi_responses), 0, ""SCSI command response value"", HFILL } }, { &hf_iscsi_SCSIResponse_BidiReadResidualCount, { ""BidiReadResidualCount"", ""iscsi.scsiresponse.bidireadresidualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Bi-directional read residual count"", HFILL } }, { &hf_iscsi_SenseLength, { ""SenseLength"", ""iscsi.scsiresponse.senselength"", FT_UINT16, BASE_DEC_HEX, NULL, 0, ""Sense data length"", HFILL } }, { &hf_iscsi_SCSIData_F, { ""F"", ""iscsi.scsidata.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), ISCSI_SCSI_DATA_FLAG_F, ""Final PDU"", HFILL } }, { &hf_iscsi_SCSIData_A, { ""A"", ""iscsi.scsidata.A"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_A), ISCSI_SCSI_DATA_FLAG_A, ""Acknowledge Requested"", HFILL } }, { &hf_iscsi_SCSIData_S, { ""S"", ""iscsi.scsidata.S"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_S), ISCSI_SCSI_DATA_FLAG_S, ""PDU Contains SCSI command status"", HFILL } }, { &hf_iscsi_SCSIData_U, { ""U"", ""iscsi.scsidata.U"", FT_BOOLEAN, 8,  TFS(&iscsi_meaning_U), ISCSI_SCSI_DATA_FLAG_U, ""Residual underflow"", HFILL } }, { &hf_iscsi_SCSIData_O, { ""O"", ""iscsi.scsidata.O"", FT_BOOLEAN, 8,  TFS(&iscsi_meaning_O), ISCSI_SCSI_DATA_FLAG_O, ""Residual overflow"", HFILL } }, { &hf_iscsi_TargetTransferTag, { ""TargetTransferTag"", ""iscsi.targettransfertag"", FT_UINT32, BASE_HEX, NULL, 0, ""Target transfer tag"", HFILL } }, { &hf_iscsi_BufferOffset, { ""BufferOffset"", ""iscsi.bufferOffset"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Buffer offset"", HFILL } }, { &hf_iscsi_SCSIData_ResidualCount, { ""ResidualCount"", ""iscsi.scsidata.readresidualcount"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Residual count"", HFILL } }, { &hf_iscsi_DataSN, { ""DataSN"", ""iscsi.datasn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Data sequence number"", HFILL } }, { &hf_iscsi_VersionMax, { ""VersionMax"", ""iscsi.versionmax"", FT_UINT8, BASE_HEX, NULL, 0, ""Maximum supported protocol version"", HFILL } }, { &hf_iscsi_VersionMin, { ""VersionMin"", ""iscsi.versionmin"", FT_UINT8, BASE_HEX, NULL, 0, ""Minimum supported protocol version"", HFILL } }, { &hf_iscsi_VersionActive, { ""VersionActive"", ""iscsi.versionactive"", FT_UINT8, BASE_HEX, NULL, 0, ""Negotiated protocol version"", HFILL } }, { &hf_iscsi_CID, { ""CID"", ""iscsi.cid"", FT_UINT16, BASE_HEX, NULL, 0, ""Connection identifier"", HFILL } }, { &hf_iscsi_ISID8, { ""ISID"", ""iscsi.isid8"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier"", HFILL } }, { &hf_iscsi_ISID, { ""ISID"", ""iscsi.isid"", FT_BYTES, BASE_NONE, NULL, 0, ""Initiator part of session identifier"", HFILL } }, { &hf_iscsi_ISID_Type, { ""ISID_Type"", ""iscsi.isid.type"", FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0, ""Initiator part of session identifier - type"", HFILL } }, { &hf_iscsi_ISID_NamingAuthority, { ""ISID_NamingAuthority"", ""iscsi.isid.namingauthority"", FT_UINT24, BASE_HEX, NULL, 0, ""Initiator part of session identifier - naming authority"", HFILL } }, { &hf_iscsi_ISID_Qualifier, { ""ISID_Qualifier"", ""iscsi.isid.qualifier"", FT_UINT8, BASE_HEX, NULL, 0, ""Initiator part of session identifier - qualifier"", HFILL } }, { &hf_iscsi_ISID_t, { ""ISID_t"", ""iscsi.isid.t"", FT_UINT8, BASE_HEX, VALS(iscsi_isid_type), 0xc0, ""Initiator part of session identifier - t"", HFILL } }, { &hf_iscsi_ISID_a, { ""ISID_a"", ""iscsi.isid.a"", FT_UINT8, BASE_HEX, NULL, 0x3f, ""Initiator part of session identifier - a"", HFILL } }, { &hf_iscsi_ISID_b, { ""ISID_b"", ""iscsi.isid.b"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier - b"", HFILL } }, { &hf_iscsi_ISID_c, { ""ISID_c"", ""iscsi.isid.c"", FT_UINT8, BASE_HEX, NULL, 0, ""Initiator part of session identifier - c"", HFILL } }, { &hf_iscsi_ISID_d, { ""ISID_d"", ""iscsi.isid.d"", FT_UINT16, BASE_HEX, NULL, 0, ""Initiator part of session identifier - d"", HFILL } }, { &hf_iscsi_TSID, { ""TSID"", ""iscsi.tsid"", FT_UINT16, BASE_HEX, NULL, 0, ""Target part of session identifier"", HFILL } }, { &hf_iscsi_TSIH, { ""TSIH"", ""iscsi.tsih"", FT_UINT16, BASE_HEX, NULL, 0, ""Target session identifying handle"", HFILL } }, { &hf_iscsi_Login_T, { ""T"", ""iscsi.login.T"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_T), 0x80, ""Transit to next login stage"",  HFILL } }, { &hf_iscsi_Login_C, { ""C"", ""iscsi.login.C"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40, ""Text incomplete"",  HFILL } }, { &hf_iscsi_Login_X, { ""X"", ""iscsi.login.X"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_login_X), 0x40, ""Restart Connection"",  HFILL } }, { &hf_iscsi_Login_CSG, { ""CSG"", ""iscsi.login.csg"", FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), CSG_MASK, ""Current stage"",  HFILL } }, { &hf_iscsi_Login_NSG, { ""NSG"", ""iscsi.login.nsg"", FT_UINT8, BASE_HEX, VALS(iscsi_login_stage), NSG_MASK, ""Next stage"",  HFILL } }, { &hf_iscsi_Login_Status, { ""Status"", ""iscsi.login.status"", FT_UINT16, BASE_HEX, VALS(iscsi_login_status), 0, ""Status class and detail"", HFILL } }, { &hf_iscsi_KeyValue, { ""KeyValue"", ""iscsi.keyvalue"", FT_STRING, BASE_NONE, NULL, 0, ""Key/value pair"", HFILL } }, { &hf_iscsi_Text_F, { ""F"", ""iscsi.text.F"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_F), 0x80, ""Final PDU in text sequence"", HFILL } }, { &hf_iscsi_Text_C, { ""C"", ""iscsi.text.C"", FT_BOOLEAN, 8, TFS(&iscsi_meaning_C), 0x40, ""Text incomplete"", HFILL } }, { &hf_iscsi_ExpDataSN, { ""ExpDataSN"", ""iscsi.expdatasn"", FT_UINT32, BASE_HEX, NULL, 0, ""Next expected data sequence number"", HFILL } }, { &hf_iscsi_R2TSN, { ""R2TSN"", ""iscsi.r2tsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""R2T PDU Number"", HFILL } }, { &hf_iscsi_TaskManagementFunction_Response, { ""Response"", ""iscsi.taskmanfun.response"", FT_UINT8, BASE_HEX, VALS(iscsi_task_management_responses), 0, NULL, HFILL } }, { &hf_iscsi_TaskManagementFunction_ReferencedTaskTag, { ""ReferencedTaskTag"", ""iscsi.taskmanfun.referencedtasktag"", FT_UINT32, BASE_HEX, NULL, 0, ""Referenced task tag"", HFILL } }, { &hf_iscsi_RefCmdSN, { ""RefCmdSN"", ""iscsi.refcmdsn"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Command sequence number for command to be aborted"", HFILL } }, { &hf_iscsi_TaskManagementFunction_Function, { ""Function"", ""iscsi.taskmanfun.function"", FT_UINT8, BASE_HEX, VALS(iscsi_task_management_functions), 0x7F, ""Requested task function"", HFILL } }, { &hf_iscsi_Logout_Reason, { ""Reason"", ""iscsi.logout.reason"", FT_UINT8, BASE_HEX, VALS(iscsi_logout_reasons), 0x7F, ""Reason for logout"", HFILL } }, { &hf_iscsi_Logout_Response, { ""Response"", ""iscsi.logout.response"", FT_UINT8, BASE_HEX, VALS(iscsi_logout_response), 0, ""Logout response"", HFILL } }, { &hf_iscsi_Time2Wait, { ""Time2Wait"", ""iscsi.time2wait"", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_iscsi_Time2Retain, { ""Time2Retain"", ""iscsi.time2retain"", FT_UINT16, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_iscsi_DesiredDataLength, { ""DesiredDataLength"", ""iscsi.desireddatalength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Desired data length (bytes)"", HFILL } }, { &hf_iscsi_AsyncEvent, { ""AsyncEvent"", ""iscsi.asyncevent"", FT_UINT8, BASE_HEX, VALS(iscsi_asyncevents), 0, ""Async event type"", HFILL } }, { &hf_iscsi_EventVendorCode, { ""EventVendorCode"", ""iscsi.eventvendorcode"", FT_UINT8, BASE_HEX, NULL, 0, ""Event vendor code"", HFILL } }, { &hf_iscsi_Parameter1, { ""Parameter1"", ""iscsi.parameter1"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 1"", HFILL } }, { &hf_iscsi_Parameter2, { ""Parameter2"", ""iscsi.parameter2"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 2"", HFILL } }, { &hf_iscsi_Parameter3, { ""Parameter3"", ""iscsi.parameter3"", FT_UINT16, BASE_HEX, NULL, 0, ""Parameter 3"", HFILL } }, { &hf_iscsi_Reject_Reason, { ""Reason"", ""iscsi.reject.reason"", FT_UINT8, BASE_HEX, VALS(iscsi_reject_reasons), 0, ""Reason for command rejection"", HFILL } }, { &hf_iscsi_snack_type, { ""S"", ""iscsi.snack.type"", FT_UINT8, BASE_DEC, VALS(iscsi_snack_types), 0x0f, ""Type of SNACK requested"", HFILL } }, { &hf_iscsi_BegRun, { ""BegRun"", ""iscsi.snack.begrun"", FT_UINT32, BASE_HEX, NULL, 0, ""First missed DataSN or StatSN"", HFILL } }, { &hf_iscsi_RunLength, { ""RunLength"", ""iscsi.snack.runlength"", FT_UINT32, BASE_DEC_HEX, NULL, 0, ""Number of additional missing status PDUs in this run"", HFILL } }, }; static gint *ett[] = { &ett_iscsi, &ett_iscsi_KeyValues, &ett_iscsi_CDB, &ett_iscsi_Flags, &ett_iscsi_RejectHeader, &ett_iscsi_lun, &ett_iscsi_ISID, }; static ei_register_info ei[] = { { &ei_iscsi_keyvalue_invalid, { ""iscsi.keyvalue.invalid"", PI_MALFORMED, PI_ERROR, ""Invalid key/value pair"", EXPFILL }} }; proto_iscsi = proto_register_protocol(""iSCSI"", ""iSCSI"", ""iscsi""); iscsi_handle = register_dissector(""iscsi"", dissect_iscsi_handle, proto_iscsi); proto_register_field_array(proto_iscsi, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); iscsi_module = prefs_register_protocol(proto_iscsi, NULL); prefs_register_enum_preference(iscsi_module, ""protocol_version"", ""Protocol version"", ""The iSCSI protocol version"", &iscsi_protocol_version, iscsi_protocol_versions, FALSE); prefs_register_bool_preference(iscsi_module, ""desegment_iscsi_messages"", ""Reassemble iSCSI messages spanning multiple TCP segments"", ""Whether the iSCSI dissector should reassemble messages spanning multiple TCP segments."" "" To use this option, you must also enable \""Allow subdissectors to reassemble TCP streams\"" in the TCP protocol settings."", &iscsi_desegment); prefs_register_bool_preference(iscsi_module, ""bogus_pdu_filter"", ""Enable bogus pdu filter"", ""When enabled, packets that appear bogus are ignored"", &enable_bogosity_filter); prefs_register_bool_preference(iscsi_module, ""demand_good_f_bit"", ""Ignore packets with bad F bit"", ""Ignore packets that haven't set the F bit when they should have"", &demand_good_f_bit); prefs_register_uint_preference(iscsi_module, ""bogus_pdu_max_data_len"", ""Bogus pdu max data length threshold"", ""Treat packets whose data segment length is greater than this value as bogus"", 10, &bogus_pdu_data_length_threshold); range_convert_str(wmem_epan_scope(), &global_iscsi_port_range, TCP_PORT_ISCSI_RANGE, MAX_TCP_PORT); prefs_register_range_preference(iscsi_module, ""target_ports"", ""Target Ports Range"", ""Range of iSCSI target ports"" ""(default "" TCP_PORT_ISCSI_RANGE "")"", &global_iscsi_port_range, MAX_TCP_PORT); prefs_register_uint_preference(iscsi_module, ""target_system_port"", ""Target system port"", ""System port number of iSCSI target"", 10, &iscsi_system_port); prefs_register_obsolete_preference(iscsi_module, ""version_03_compatible""); prefs_register_obsolete_preference(iscsi_module, ""bogus_pdu_max_digest_padding""); prefs_register_obsolete_preference(iscsi_module, ""header_digest_is_crc32c""); prefs_register_obsolete_preference(iscsi_module, ""header_digest_size""); prefs_register_obsolete_preference(iscsi_module, ""enable_header_digests""); prefs_register_obsolete_preference(iscsi_module, ""data_digest_is_crc32c""); prefs_register_obsolete_preference(iscsi_module, ""data_digest_size""); prefs_register_obsolete_preference(iscsi_module, ""enable_data_digests""); expert_iscsi = expert_register_protocol(proto_iscsi); expert_register_field_array(expert_iscsi, ei, array_length(ei)); }"
"void ParseNameValue(const char * buffer, int bufsize, struct NameValueParserData * data) { struct xmlparser parser; data->l_head = NULL; data->portListing = NULL; data->portListingLength = 0; parser.xmlstart = buffer; parser.xmlsize = bufsize; parser.data = data; parser.starteltfunc = NameValueParserStartElt; parser.endeltfunc = NameValueParserEndElt; parser.datafunc = NameValueParserGetData; parser.attfunc = 0; parsexml(&parser); }"
"static int ovl_copy_up_one(struct dentry *parent, struct dentry *dentry, int flags) { int err; DEFINE_DELAYED_CALL(done); struct path parentpath; struct ovl_copy_up_ctx ctx = { .parent = parent, .dentry = dentry, .workdir = ovl_workdir(dentry), }; if (WARN_ON(!ctx.workdir)) return -EROFS; ovl_path_lower(dentry, &ctx.lowerpath); err = vfs_getattr(&ctx.lowerpath, &ctx.stat, STATX_BASIC_STATS, AT_STATX_SYNC_AS_STAT); if (err) return err; ctx.metacopy = ovl_need_meta_copy_up(dentry, ctx.stat.mode, flags); if (parent) { ovl_path_upper(parent, &parentpath); ctx.destdir = parentpath.dentry; ctx.destname = dentry->d_name; err = vfs_getattr(&parentpath, &ctx.pstat, STATX_ATIME | STATX_MTIME, AT_STATX_SYNC_AS_STAT); if (err) return err; } if (flags & O_TRUNC) ctx.stat.size = 0; if (S_ISLNK(ctx.stat.mode)) { ctx.link = vfs_get_link(ctx.lowerpath.dentry, &done); if (IS_ERR(ctx.link)) return PTR_ERR(ctx.link); } err = ovl_copy_up_start(dentry, flags); if (unlikely(err)) { if (err > 0) err = 0; } else { if (!ovl_dentry_upper(dentry)) err = ovl_do_copy_up(&ctx); if (!err && parent && !ovl_dentry_has_upper_alias(dentry)) err = ovl_link_up(&ctx); if (!err && ovl_dentry_needs_data_copy_up_locked(dentry, flags)) err = ovl_copy_up_meta_inode_data(&ctx); ovl_copy_up_end(dentry); } do_delayed_call(&done); return err; }"
"static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr) { while (jump) { if (jump->type == STM_BREAK) labelto(J, F, jump->inst, baddr); if (jump->type == STM_CONTINUE) labelto(J, F, jump->inst, caddr); jump = jump->next; } }"
static void vhost_vdpa_config_put(struct vhost_vdpa *v) { if (v->config_ctx) eventfd_ctx_put(v->config_ctx); }
"static std::optional<Type> convertStructType(spirv::StructType type, LLVMTypeConverter &converter) { SmallVector<spirv::StructType::MemberDecorationInfo, 4> memberDecorations; type.getMemberDecorations(memberDecorations); if (!memberDecorations.empty()) return std::nullopt; if (type.hasOffset()) return convertStructTypeWithOffset(type, converter); return convertStructTypePacked(type, converter); }"
"static int enlarge_userbuf (_IO_FILE *fp, _IO_off64_t offset, int reading) { if ((_IO_ssize_t) offset <= _IO_blen (fp)) return 0; struct _IO_wide_data *wd = fp->_wide_data; _IO_ssize_t oldend = wd->_IO_write_end - wd->_IO_write_base; if (fp->_flags2 & _IO_FLAGS2_USER_WBUF) return 1; _IO_size_t newsize = offset + 100; wchar_t *oldbuf = wd->_IO_buf_base; wchar_t *newbuf = (wchar_t *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (newsize * sizeof (wchar_t)); if (newbuf == NULL) return 1; if (oldbuf != NULL) { __wmemcpy (newbuf, oldbuf, _IO_wblen (fp)); (*((_IO_strfile *) fp)->_s._free_buffer) (oldbuf); wd->_IO_buf_base = NULL; } _IO_wsetb (fp, newbuf, newbuf + newsize, 1); if (reading) { wd->_IO_write_base = newbuf + (wd->_IO_write_base - oldbuf); wd->_IO_write_ptr = newbuf + (wd->_IO_write_ptr - oldbuf); wd->_IO_write_end = newbuf + (wd->_IO_write_end - oldbuf); wd->_IO_read_ptr = newbuf + (wd->_IO_read_ptr - oldbuf); wd->_IO_read_base = newbuf; wd->_IO_read_end = wd->_IO_buf_end; } else { wd->_IO_read_base = newbuf + (wd->_IO_read_base - oldbuf); wd->_IO_read_ptr = newbuf + (wd->_IO_read_ptr - oldbuf); wd->_IO_read_end = newbuf + (wd->_IO_read_end - oldbuf); wd->_IO_write_ptr = newbuf + (wd->_IO_write_ptr - oldbuf); wd->_IO_write_base = newbuf; wd->_IO_write_end = wd->_IO_buf_end; } assert (offset >= oldend); if (reading) wmemset (wd->_IO_read_base + oldend, L'\0', offset - oldend); else wmemset (wd->_IO_write_base + oldend, L'\0', offset - oldend); return 0; }"
"Status InferenceContext::InternalMakeShapeFromTensor( bool treat_unknown_scalar_tensor_as_unknown_shape, const Tensor* t, ShapeHandle tensor_shape, ShapeHandle* out) { if (!treat_unknown_scalar_tensor_as_unknown_shape) { TF_RETURN_IF_ERROR(WithRank(tensor_shape, 1, &tensor_shape)); } if (t == nullptr) { if (Rank(tensor_shape) == 0) { return ReturnUnknownShape(out); } DimensionHandle shape_dim = Dim(tensor_shape, 0); if (!ValueKnown(shape_dim)) { return ReturnUnknownShape(out); } const auto num_dims = Value(shape_dim); std::vector<DimensionHandle> dims; dims.reserve(num_dims); for (int i = 0; i < num_dims; i++) dims.push_back(UnknownDim()); return ReturnCreatedShape(dims, out); } if (t->shape().dims() == 0) { if (t->dtype() == DataType::DT_INT32) { auto flat_t = t->scalar<int32>(); if (flat_t() != -1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, or if its rank 0 it must have value "" ""-1 "" ""(representing an unknown shape).  Saw value: "", flat_t()); } return ReturnUnknownShape(out); } else if (t->dtype() == DataType::DT_INT64) { auto flat_t = t->scalar<int64_t>(); if (flat_t() != -1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, or if its rank 0 it must have value "" ""-1 "" ""(representing an unknown shape).  Saw value: "", flat_t()); } return ReturnUnknownShape(out); } else { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be int32 or int64, but was "", DataTypeString(t->dtype())); } } if (t->shape().dims() != 1) { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be rank 1, but was rank "", t->shape().dims(), ""."", ((t->shape().dims() == 0) ? ""If it is rank 0 rank 0 it must have statically known value -1 "" ""(representing an unknown shape). "" : "" ""), ""Saw tensor shape "", t->shape().DebugString()); } std::vector<DimensionHandle> dims; if (t->dtype() == DataType::DT_INT32) { auto flat_t = t->flat<int32>(); for (int i = 0; i < flat_t.size(); ++i) { const int32_t val = flat_t(i); if (val < -1) { return errors::InvalidArgument( ""Invalid value in tensor used for shape: "", val); } dims.push_back(MakeDim(val)); } } else if (t->dtype() == DataType::DT_INT64) { auto flat_t = t->flat<int64_t>(); for (int i = 0; i < flat_t.size(); ++i) { const int64_t val = flat_t(i); if (val < -1) { return errors::InvalidArgument( ""Invalid value in tensor used for shape: "", val); } dims.push_back(MakeDim(val)); } } else { *out = nullptr; return errors::InvalidArgument( ""Input tensor must be int32 or int64, but was "", DataTypeString(t->dtype())); } return ReturnCreatedShape(dims, out); }"
int32_t mz_path_has_slash(const char *path) { int32_t path_len = (int32_t)strlen(path); if (path[path_len - 1] != '\\' && path[path_len - 1] != '/') return MZ_EXIST_ERROR; return MZ_OK; }
"int fixExec2Error(int action, u_char * var_val, u_char var_val_type, size_t var_val_len, u_char * statP, oid * name, size_t name_len) { netsnmp_old_extend *exten = NULL; unsigned int idx; idx = name[name_len-1] -1; exten = &compatability_entries[ idx ]; #ifndef NETSNMP_NO_WRITE_SUPPORT switch (action) { case MODE_SET_RESERVE1: if (var_val_type != ASN_INTEGER) { snmp_log(LOG_ERR, ""Wrong type != int\n""); return SNMP_ERR_WRONGTYPE; } idx = *((long *) var_val); if (idx != 1) { snmp_log(LOG_ERR, ""Wrong value != 1\n""); return SNMP_ERR_WRONGVALUE; } if (!exten || !exten->efix_entry) { snmp_log(LOG_ERR, ""No command to run\n""); return SNMP_ERR_GENERR; } return SNMP_ERR_NOERROR; case MODE_SET_COMMIT: netsnmp_cache_check_and_reload( exten->efix_entry->cache ); } #endif  return SNMP_ERR_NOERROR; }"
"int move_hugetlb_page_tables(struct vm_area_struct *vma, struct vm_area_struct *new_vma, unsigned long old_addr, unsigned long new_addr, unsigned long len) { struct hstate *h = hstate_vma(vma); struct address_space *mapping = vma->vm_file->f_mapping; unsigned long sz = huge_page_size(h); struct mm_struct *mm = vma->vm_mm; unsigned long old_end = old_addr + len; unsigned long old_addr_copy; pte_t *src_pte, *dst_pte; struct mmu_notifier_range range; mmu_notifier_range_init(&range, MMU_NOTIFY_CLEAR, 0, vma, mm, old_addr, old_end); adjust_range_if_pmd_sharing_possible(vma, &range.start, &range.end); mmu_notifier_invalidate_range_start(&range); i_mmap_lock_write(mapping); for (; old_addr < old_end; old_addr += sz, new_addr += sz) { src_pte = huge_pte_offset(mm, old_addr, sz); if (!src_pte) continue; if (huge_pte_none(huge_ptep_get(src_pte))) continue; old_addr_copy = old_addr; if (huge_pmd_unshare(mm, vma, &old_addr_copy, src_pte)) continue; dst_pte = huge_pte_alloc(mm, new_vma, new_addr, sz); if (!dst_pte) break; move_huge_pte(vma, old_addr, new_addr, src_pte); } i_mmap_unlock_write(mapping); flush_tlb_range(vma, old_end - len, old_end); mmu_notifier_invalidate_range_end(&range); return len + old_addr - old_end; }"
"static void http_manage_server_side_cookies(struct stream *s, struct channel *res) { struct session *sess = s->sess; struct http_txn *txn = s->txn; struct htx *htx; struct http_hdr_ctx ctx; struct server *srv; char *hdr_beg, *hdr_end; char *prev, *att_beg, *att_end, *equal, *val_beg, *val_end, *next; int is_cookie2 = 0; htx = htxbuf(&res->buf); ctx.blk = NULL; while (1) { int is_first = 1; if (!http_find_header(htx, ist(""Set-Cookie""), &ctx, 1)) { if (!http_find_header(htx, ist(""Set-Cookie2""), &ctx, 1)) break; is_cookie2 = 1; } txn->flags |= TX_SCK_PRESENT; if (s->be->cookie_name == NULL && sess->fe->capture_name == NULL) break; hdr_beg = ctx.value.ptr; hdr_end = hdr_beg + ctx.value.len; for (prev = hdr_beg; prev < hdr_end; prev = next) { att_beg = prev; if (!is_first) att_beg++; is_first = 0; while (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg)) att_beg++; equal = att_end = att_beg; while (equal < hdr_end) { if (*equal == '=' || *equal == ';' || (is_cookie2 && *equal == ',')) break; if (HTTP_IS_SPHT(*equal++)) continue; att_end = equal; } if (equal < hdr_end && *equal == '=') { val_beg = equal + 1; while (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg)) val_beg++; next = http_find_cookie_value_end(val_beg, hdr_end); val_end = next; while (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1))) val_end--; } else { val_beg = val_end = next = equal; } if (next < hdr_end) { if (is_cookie2) next = http_find_hdr_value_end(next, hdr_end); else next = hdr_end; } if (equal == val_end) continue; if (unlikely(att_end != equal || val_beg > equal + 1)) { int stripped_before = 0; int stripped_after = 0; if (att_end != equal) { memmove(att_end, equal, hdr_end - equal); stripped_before = (att_end - equal); equal   += stripped_before; val_beg += stripped_before; } if (val_beg > equal + 1) { memmove(equal + 1, val_beg, hdr_end + stripped_before - val_beg); stripped_after = (equal + 1) - val_beg; val_beg += stripped_after; stripped_before += stripped_after; } val_end      += stripped_before; next         += stripped_before; hdr_end      += stripped_before; htx_change_blk_value_len(htx, ctx.blk, hdr_end - hdr_beg); ctx.value.len = hdr_end - hdr_beg; } if (sess->fe->capture_name != NULL && txn->srv_cookie == NULL && (val_end - att_beg >= sess->fe->capture_namelen) && memcmp(att_beg, sess->fe->capture_name, sess->fe->capture_namelen) == 0) { int log_len = val_end - att_beg; if ((txn->srv_cookie = pool_alloc(pool_head_capture)) == NULL) { ha_alert(""HTTP logging : out of memory.\n""); } else { if (log_len > sess->fe->capture_len) log_len = sess->fe->capture_len; memcpy(txn->srv_cookie, att_beg, log_len); txn->srv_cookie[log_len] = 0; } } srv = objt_server(s->target); if (!(s->flags & SF_IGNORE_PRST) && (att_end - att_beg == s->be->cookie_len) && (s->be->cookie_name != NULL) && (memcmp(att_beg, s->be->cookie_name, att_end - att_beg) == 0)) { txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_FOUND; if (s->be->ck_opts & PR_CK_PSV) { } else if ((srv && (s->be->ck_opts & PR_CK_INS)) || ((s->flags & SF_DIRECT) && (s->be->ck_opts & PR_CK_IND))) { if (prev == hdr_beg && next == hdr_end) { http_remove_header(htx, &ctx); } else { int delta = http_del_hdr_value(hdr_beg, hdr_end, &prev, next); next      = prev; hdr_end  += delta; } txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_DELETED; } else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_RW)) { int sliding, delta; ctx.value = ist2(val_beg, val_end - val_beg); ctx.lws_before = ctx.lws_after = 0; http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen)); delta     = srv->cklen - (val_end - val_beg); sliding   = (ctx.value.ptr - val_beg); hdr_beg  += sliding; val_beg  += sliding; next     += sliding + delta; hdr_end  += sliding + delta; txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_REPLACED; } else if (srv && srv->cookie && (s->be->ck_opts & PR_CK_PFX)) { int sliding, delta; ctx.value = ist2(val_beg, 0); ctx.lws_before = ctx.lws_after = 0; http_replace_header_value(htx, &ctx, ist2(srv->cookie, srv->cklen + 1)); delta     = srv->cklen + 1; sliding   = (ctx.value.ptr - val_beg); hdr_beg  += sliding; val_beg  += sliding; next     += sliding + delta; hdr_end  += sliding + delta; val_beg[srv->cklen] = COOKIE_DELIM; txn->flags &= ~TX_SCK_MASK; txn->flags |= TX_SCK_REPLACED; } } } } }"
"int EC_GROUP_copy(EC_GROUP *dest, const EC_GROUP *src) { EC_EXTRA_DATA *d; if (dest->meth->group_copy == 0) { ECerr(EC_F_EC_GROUP_COPY, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED); return 0; } if (dest->meth != src->meth) { ECerr(EC_F_EC_GROUP_COPY, EC_R_INCOMPATIBLE_OBJECTS); return 0; } if (dest == src) return 1; EC_EX_DATA_free_all_data(&dest->extra_data); for (d = src->extra_data; d != NULL; d = d->next) { void *t = d->dup_func(d->data); if (t == NULL) return 0; if (!EC_EX_DATA_set_data(&dest->extra_data, t, d->dup_func, d->free_func, d->clear_free_func)) return 0; } if (src->generator != NULL) { if (dest->generator == NULL) { dest->generator = EC_POINT_new(dest); if (dest->generator == NULL) return 0; } if (!EC_POINT_copy(dest->generator, src->generator)) return 0; } else { if (dest->generator != NULL) { EC_POINT_clear_free(dest->generator); dest->generator = NULL; } } if (!BN_copy(&dest->order, &src->order)) return 0; if (!BN_copy(&dest->cofactor, &src->cofactor)) return 0; dest->curve_name = src->curve_name; dest->asn1_flag  = src->asn1_flag; dest->asn1_form  = src->asn1_form; if (src->seed) { if (dest->seed) OPENSSL_free(dest->seed); dest->seed = OPENSSL_malloc(src->seed_len); if (dest->seed == NULL) return 0; if (!memcpy(dest->seed, src->seed, src->seed_len)) return 0; dest->seed_len = src->seed_len; } else { if (dest->seed) OPENSSL_free(dest->seed); dest->seed = NULL; dest->seed_len = 0; } return dest->meth->group_copy(dest, src); }"
"static gboolean option_persist_cb (const gchar *option_name, const gchar *value, gpointer     data, GError     **error) { FlatpakContext *context = data; flatpak_context_set_persistent (context, value); return TRUE; }"
"void LineBufferTask::execute () { try { if (_lineBuffer->uncompressedData == 0) { Int64 uncompressedSize = 0; int maxY = min (_lineBuffer->maxY, _ifd->maxY); for (int i = _lineBuffer->minY - _ifd->minY; i <= maxY - _ifd->minY; ++i) { uncompressedSize += (int) _ifd->bytesPerLine[i]; } if (_lineBuffer->compressor != 0) delete _lineBuffer->compressor; Int64 maxBytesPerLine = 0; for (int i = _lineBuffer->minY - _ifd->minY; i <= maxY - _ifd->minY; ++i) { if (_ifd->bytesPerLine[i] > maxBytesPerLine) maxBytesPerLine = _ifd->bytesPerLine[i]; } _lineBuffer->compressor = newCompressor(_ifd->header.compression(), maxBytesPerLine, _ifd->header); if (_lineBuffer->compressor && _lineBuffer->packedDataSize < uncompressedSize) { _lineBuffer->format = _lineBuffer->compressor->format(); _lineBuffer->packedDataSize = _lineBuffer->compressor->uncompress (_lineBuffer->buffer, _lineBuffer->packedDataSize, _lineBuffer->minY, _lineBuffer->uncompressedData); } else { _lineBuffer->format = Compressor::XDR; _lineBuffer->uncompressedData = _lineBuffer->buffer; } } int yStart, yStop, dy; if (_ifd->lineOrder == INCREASING_Y) { yStart = _scanLineMin; yStop = _scanLineMax + 1; dy = 1; } else { yStart = _scanLineMax; yStop = _scanLineMin - 1; dy = -1; } for (int y = yStart; y != yStop; y += dy) { const char *readPtr = _lineBuffer->uncompressedData + _ifd->offsetInLineBuffer[y - _ifd->minY]; for (unsigned int i = 0; i < _ifd->slices.size(); ++i) { InSliceInfo &slice = *_ifd->slices[i]; if (modp (y, slice.ySampling) != 0) continue; if (slice.skip) { skipChannel (readPtr, slice.typeInFile, _ifd->lineSampleCount[y - _ifd->minY]); } else { int width = (_ifd->maxX - _ifd->minX + 1); copyIntoDeepFrameBuffer (readPtr, slice.base, (char*) (&_ifd->sampleCount[0][0] - _ifd->minX - _ifd->minY * width), sizeof(unsigned int) * 1, sizeof(unsigned int) * width, y, _ifd->minX, _ifd->maxX, 0, 0, 0, 0, slice.sampleStride,  slice.xPointerStride, slice.yPointerStride, slice.fill, slice.fillValue, _lineBuffer->format, slice.typeInFrameBuffer, slice.typeInFile); } } } } catch (std::exception &e) { if (!_lineBuffer->hasException) { _lineBuffer->exception = e.what(); _lineBuffer->hasException = true; } } catch (...) { if (!_lineBuffer->hasException) { _lineBuffer->exception = ""unrecognized exception""; _lineBuffer->hasException = true; } } }"
"uint32 TIFFNumberOfStrips(TIFF* tif) { TIFFDirectory *td = &tif->tif_dir; uint32 nstrips; /* If the value was already computed and store in td_nstrips, then return it, since ChopUpSingleUncompressedStrip might have altered and resized the since the td_stripbytecount and td_stripoffset arrays to the new value after the initial affectation of td_nstrips = TIFFNumberOfStrips() in tif_dirread.c ~line 3612. See http:    if( td->td_nstrips ) return td->td_nstrips; nstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 : TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip)); if (td->td_planarconfig == PLANARCONFIG_SEPARATE) nstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel, ""TIFFNumberOfStrips""); return (nstrips); }"
"GF_Err gf_isom_hint_rtp_read(GF_RTPPacket *ptr, GF_BitStream *bs) { GF_Err e; u8 hasTLV, type; u16 i, count; u32 TLVsize, tempSize; GF_Box *a; ptr->relativeTransTime = gf_bs_read_u32(bs); gf_bs_read_int(bs, 2); ptr->P_bit = gf_bs_read_int(bs, 1); ptr->X_bit = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 4); ptr->M_bit = gf_bs_read_int(bs, 1); ptr->payloadType = gf_bs_read_int(bs, 7); ptr->SequenceNumber = gf_bs_read_u16(bs); gf_bs_read_int(bs, 13); hasTLV = gf_bs_read_int(bs, 1); ptr->B_bit = gf_bs_read_int(bs, 1); ptr->R_bit = gf_bs_read_int(bs, 1); count = gf_bs_read_u16(bs); if (hasTLV) { tempSize = 4;TLVsize = gf_bs_read_u32(bs); while (tempSize < TLVsize) { e = gf_isom_box_parse(&a, bs); if (e) return e; gf_list_add(ptr->TLV, a); tempSize += (u32) a->size; } if (tempSize != TLVsize) return GF_ISOM_INVALID_FILE; } for (i=0; i<count; i++) { GF_GenericDTE *dte; Bool add_it = 0; type = gf_bs_read_u8(bs); dte = NewDTE(type); if (!dte) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso] invalid DTE code %d in hint sample %d of trackID %d\n"", type, ptr->sampleNumber, ptr->trackID)); return GF_ISOM_INVALID_FILE; } e = ReadDTE(dte, bs); if (e) return e; switch (type) { case 1: if ( ((GF_ImmediateDTE *)dte)->dataLength) add_it = 1; break; case 2: if ( ((GF_SampleDTE *)dte)->dataLength) add_it = 1; break; case 3: if ( ((GF_StreamDescDTE *)dte)->dataLength) add_it = 1; break; } if (add_it) gf_list_add(ptr->DataTable, dte); else DelDTE(dte); } return GF_OK; }"
"R_API RBinJavaAttrInfo *r_bin_java_code_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) { RBinJavaAttrInfo *attr = NULL, *_attr = NULL; ut32 k = 0, curpos; ut64 offset = 0; attr = r_bin_java_default_attr_new (buffer, sz, buf_offset); if (!attr) { return NULL; } if (sz < 16 || sz > buf_offset) {free (attr); return NULL; } offset += 6; attr->type = R_BIN_JAVA_ATTR_TYPE_CODE_ATTR; attr->info.code_attr.max_stack = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.max_locals = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.code_length = R_BIN_JAVA_UINT (buffer, offset); offset += 4; attr->info.code_attr.code_offset = buf_offset + offset; attr->info.code_attr.code = (ut8 *) malloc (attr->info.code_attr.code_length); if (attr->info.code_attr.code == NULL) { eprintf (""Handling Code Attributes: Unable to allocate memory "" ""(%u bytes) for a code.\n"", attr->info.code_attr.code_length); return attr; } R_BIN_JAVA_GLOBAL_BIN->current_code_attr = attr; { int len = attr->info.code_attr.code_length; memset (attr->info.code_attr.code, 0, len); if (offset + len >= sz) { len = sz; return attr; } memcpy (attr->info.code_attr.code, buffer + offset, len); offset += len; } attr->info.code_attr.exception_table_length = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.exception_table = r_list_newf (free); for (k = 0; k < attr->info.code_attr.exception_table_length; k++) { curpos = buf_offset + offset; if (curpos + 8 > sz) { return attr; } RBinJavaExceptionEntry *e = R_NEW0 (RBinJavaExceptionEntry); if (!e) { free (attr); return NULL; } e->file_offset = curpos; e->start_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->end_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->handler_pc = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; e->catch_type = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; r_list_append (attr->info.code_attr.exception_table, e); e->size = 8; } attr->info.code_attr.attributes_count = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.code_attr.attributes = r_list_newf (r_bin_java_attribute_free); if (attr->info.code_attr.attributes_count > 0) { for (k = 0; k < attr->info.code_attr.attributes_count; k++) { int size = (offset < sz) ? sz - offset : 0; if (size > sz || size <= 0) { break; } _attr = r_bin_java_read_next_attr_from_buffer (buffer + offset, size, buf_offset + offset); if (!_attr) { eprintf (""[X] r_bin_java_code_attr_new: Error unable to parse remainder of classfile after Method's Code Attribute: %d.\n"", k); break; } IFDBG eprintf(""Parsing @ 0x%""PFMT64x "" (%s) = 0x%""PFMT64x "" bytes, %p\n"", _attr->file_offset, _attr->name, _attr->size, _attr); offset += _attr->size; r_list_append (attr->info.code_attr.attributes, _attr); if (_attr->type == R_BIN_JAVA_ATTR_TYPE_LOCAL_VARIABLE_TABLE_ATTR) { IFDBG eprintf(""Parsed the LocalVariableTable, preparing the implicit mthod frame.\n""); attr->info.code_attr.implicit_frame = r_bin_java_build_stack_frame_from_local_variable_table (R_BIN_JAVA_GLOBAL_BIN, _attr); attr->info.code_attr.implicit_frame->file_offset = buf_offset; IFDBG r_bin_java_print_stack_map_frame_summary(attr->info.code_attr.implicit_frame); } } } if (attr->info.code_attr.implicit_frame == NULL) { attr->info.code_attr.implicit_frame = r_bin_java_default_stack_frame (); } attr->size = offset; return attr; }"
"Variant HHVM_FUNCTION(fwrite, const Resource& handle, const String& data, int64_t length ) { CHECK_HANDLE(handle, f); int64_t ret = f->write(data, length); if (ret < 0) { raise_notice(""fwrite(): send of %d bytes failed with errno=%d %s"", data.size(), errno, folly::errnoStr(errno).c_str()); ret = 0; } return ret; }"
bool InputWindowInfo::isTrustedOverlay() const { return layoutParamsType == TYPE_INPUT_METHOD || layoutParamsType == TYPE_INPUT_METHOD_DIALOG || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY; }
"static int aac_get_hba_info(struct aac_dev *dev, void __user *arg) { struct aac_hba_info hbainfo; hbainfo.adapter_number= (u8) dev->id; hbainfo.system_io_bus_number= dev->pdev->bus->number; hbainfo.device_number= (dev->pdev->devfn >> 3); hbainfo.function_number= (dev->pdev->devfn & 0x0007); hbainfo.vendor_id= dev->pdev->vendor; hbainfo.device_id= dev->pdev->device; hbainfo.sub_vendor_id= dev->pdev->subsystem_vendor; hbainfo.sub_system_id= dev->pdev->subsystem_device; if (copy_to_user(arg, &hbainfo, sizeof(struct aac_hba_info))) { dprintk((KERN_DEBUG ""aacraid: Could not copy hba info\n"")); return -EFAULT; } return 0; }"
"int unix_expandpath( garray_T*gap, char_u*path, intwildoff, intflags,    intdidstar){ char_u*buf; char_u*path_end; char_u*p, *s, *e; intstart_len = gap->ga_len; char_u*pat; regmatch_Tregmatch; intstarts_with_dot; intmatches; intlen; intstarstar = FALSE; static intstardepth = 0;     DIR*dirp; struct dirent *dp; if (stardepth > 0) { ui_breakcheck(); if (got_int) return 0; } buf = alloc(STRLEN(path) + BASENAMELEN + 5); if (buf == NULL) return 0; p = buf; s = buf; e = NULL; path_end = path; while (*path_end != NUL) { if (path_end >= path + wildoff && rem_backslash(path_end)) *p++ = *path_end++; else if (*path_end == '/') { if (e != NULL) break; s = p + 1; } else if (path_end >= path + wildoff && (vim_strchr((char_u *)""*?[{~$"", *path_end) != NULL || (!p_fic && (flags & EW_ICASE) && isalpha(PTR2CHAR(path_end))))) e = p; if (has_mbyte) { len = (*mb_ptr2len)(path_end); STRNCPY(p, path_end, len); p += len; path_end += len; } else *p++ = *path_end++; } e = p; *e = NUL; for (p = buf + wildoff; p < s; ++p) if (rem_backslash(p)) { STRMOVE(p, p + 1); --e; --s; } for (p = s; p < e; ++p) if (p[0] == '*' && p[1] == '*') starstar = TRUE; starts_with_dot = *s == '.'; pat = file_pat_to_reg_pat(s, e, NULL, FALSE); if (pat == NULL) { vim_free(buf); return 0; } if (flags & EW_ICASE) regmatch.rm_ic = TRUE;    else regmatch.rm_ic = p_fic;    if (flags & (EW_NOERROR | EW_NOTWILD)) ++emsg_silent; regmatch.regprog = vim_regcomp(pat, RE_MAGIC); if (flags & (EW_NOERROR | EW_NOTWILD)) --emsg_silent; vim_free(pat); if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0) { vim_free(buf); return 0; } if (!didstar && stardepth < 100 && starstar && e - s == 2 && *path_end == '/') { STRCPY(s, path_end + 1); ++stardepth; (void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE); --stardepth; } *s = NUL; dirp = opendir(*buf == NUL ? ""."" : (char *)buf); if (dirp != NULL) { for (;;) { dp = readdir(dirp); if (dp == NULL) break; if ((dp->d_name[0] != '.' || starts_with_dot || ((flags & EW_DODOT) && dp->d_name[1] != NUL && (dp->d_name[1] != '.' || dp->d_name[2] != NUL))) && ((regmatch.regprog != NULL && vim_regexec(&regmatch, (char_u *)dp->d_name, (colnr_T)0)) || ((flags & EW_NOTWILD) && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0))) { STRCPY(s, dp->d_name); len = STRLEN(buf); if (starstar && stardepth < 100) { STRCPY(buf + len, ""/**""); STRCPY(buf + len + 3, path_end); ++stardepth; (void)unix_expandpath(gap, buf, len + 1, flags, TRUE); --stardepth; } STRCPY(buf + len, path_end); if (mch_has_exp_wildcard(path_end)) { (void)unix_expandpath(gap, buf, len + 1, flags, FALSE); } else { stat_T  sb; if (*path_end != NUL) backslash_halve(buf + len + 1); if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0 : mch_getperm(buf) >= 0) { #ifdef MACOS_CONVERT size_t precomp_len = STRLEN(buf)+1; char_u *precomp_buf = mac_precompose_path(buf, precomp_len, &precomp_len); if (precomp_buf) { mch_memmove(buf, precomp_buf, precomp_len); vim_free(precomp_buf); } #endif addfile(gap, buf, flags); } } } } closedir(dirp); } vim_free(buf); vim_regfree(regmatch.regprog); matches = gap->ga_len - start_len; if (matches > 0) qsort(((char_u **)gap->ga_data) + start_len, matches, sizeof(char_u *), pstrcmp); return matches; }"
"void create_periodic_time( struct vcpu *v, struct periodic_time *pt, uint64_t delta, uint64_t period, uint8_t irq, time_cb *cb, void *data) { ASSERT(pt->source != 0); destroy_periodic_time(pt); spin_lock(&v->arch.hvm_vcpu.tm_lock); pt->pending_intr_nr = 0; pt->do_not_freeze = 0; pt->irq_issued = 0; if ( (period < 100000) && period ) { if ( !test_and_set_bool(pt->warned_timeout_too_short) ) gdprintk(XENLOG_WARNING, ""HVM_PlatformTime: program too "" ""small period %""PRIu64""\n"", period); period = 100000; } pt->period = period; pt->vcpu = v; pt->last_plt_gtime = hvm_get_guest_time(pt->vcpu); pt->irq = irq; pt->one_shot = !period; pt->scheduled = NOW() + delta; if ( !pt->one_shot ) { if ( v->domain->arch.hvm_domain.params[HVM_PARAM_VPT_ALIGN] ) { pt->scheduled = align_timer(pt->scheduled, pt->period); } else if ( pt->source == PTSRC_lapic ) { pt->scheduled += delta >> 1; } } pt->cb = cb; pt->priv = data; pt->on_list = 1; list_add(&pt->list, &v->arch.hvm_vcpu.tm_list); init_timer(&pt->timer, pt_timer_fn, pt, v->processor); set_timer(&pt->timer, pt->scheduled); spin_unlock(&v->arch.hvm_vcpu.tm_lock); }"
"void esp_reg_write(ESPState *s, uint32_t saddr, uint64_t val) { trace_esp_mem_writeb(saddr, s->wregs[saddr], val); switch (saddr) { case ESP_TCHI: s->tchi_written = true; case ESP_TCLO: case ESP_TCMID: s->rregs[ESP_RSTAT] &= ~STAT_TC; break; case ESP_FIFO: if (s->do_cmd) { if (s->cmdlen < TI_BUFSZ) { s->cmdbuf[s->cmdlen++] = val & 0xff; } else { trace_esp_error_fifo_overrun(); } } else if (s->ti_size == TI_BUFSZ - 1) { trace_esp_error_fifo_overrun(); } else { s->ti_size++; s->ti_buf[s->ti_wptr++] = val & 0xff; } break; case ESP_CMD: s->rregs[saddr] = val; if (val & CMD_DMA) { s->dma = 1; s->rregs[ESP_TCLO] = s->wregs[ESP_TCLO]; s->rregs[ESP_TCMID] = s->wregs[ESP_TCMID]; s->rregs[ESP_TCHI] = s->wregs[ESP_TCHI]; } else { s->dma = 0; } switch(val & CMD_CMD) { case CMD_NOP: trace_esp_mem_writeb_cmd_nop(val); break; case CMD_FLUSH: trace_esp_mem_writeb_cmd_flush(val); s->rregs[ESP_RINTR] = INTR_FC; s->rregs[ESP_RSEQ] = 0; s->rregs[ESP_RFLAGS] = 0; break; case CMD_RESET: trace_esp_mem_writeb_cmd_reset(val); esp_soft_reset(s); break; case CMD_BUSRESET: trace_esp_mem_writeb_cmd_bus_reset(val); s->rregs[ESP_RINTR] = INTR_RST; if (!(s->wregs[ESP_CFG1] & CFG1_RESREPT)) { esp_raise_irq(s); } break; case CMD_TI: handle_ti(s); break; case CMD_ICCS: trace_esp_mem_writeb_cmd_iccs(val); write_response(s); s->rregs[ESP_RINTR] = INTR_FC; s->rregs[ESP_RSTAT] |= STAT_MI; break; case CMD_MSGACC: trace_esp_mem_writeb_cmd_msgacc(val); s->rregs[ESP_RINTR] = INTR_DC; s->rregs[ESP_RSEQ] = 0; s->rregs[ESP_RFLAGS] = 0; esp_raise_irq(s); break; case CMD_PAD: trace_esp_mem_writeb_cmd_pad(val); s->rregs[ESP_RSTAT] = STAT_TC; s->rregs[ESP_RINTR] = INTR_FC; s->rregs[ESP_RSEQ] = 0; break; case CMD_SATN: trace_esp_mem_writeb_cmd_satn(val); break; case CMD_RSTATN: trace_esp_mem_writeb_cmd_rstatn(val); break; case CMD_SEL: trace_esp_mem_writeb_cmd_sel(val); handle_s_without_atn(s); break; case CMD_SELATN: trace_esp_mem_writeb_cmd_selatn(val); handle_satn(s); break; case CMD_SELATNS: trace_esp_mem_writeb_cmd_selatns(val); handle_satn_stop(s); break; case CMD_ENSEL: trace_esp_mem_writeb_cmd_ensel(val); s->rregs[ESP_RINTR] = 0; break; case CMD_DISSEL: trace_esp_mem_writeb_cmd_dissel(val); s->rregs[ESP_RINTR] = 0; esp_raise_irq(s); break; default: trace_esp_error_unhandled_command(val); break; } break; case ESP_WBUSID ... ESP_WSYNO: break; case ESP_CFG1: case ESP_CFG2: case ESP_CFG3: case ESP_RES3: case ESP_RES4: s->rregs[saddr] = val; break; case ESP_WCCF ... ESP_WTEST: break; default: trace_esp_error_invalid_write(val, saddr); return; } s->wregs[saddr] = val; }"
"explicit FractionalAvgPoolOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_)); OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_)); OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_)); OP_REQUIRES(context, pooling_ratio_.size() == 4, errors::InvalidArgument( ""pooling_ratio field must specify 4 dimensions"")); for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) { OP_REQUIRES(context, pooling_ratio_[i] >= 1, errors::InvalidArgument( ""pooling_ratio cannot be smaller than 1, got: "", pooling_ratio_[i])); } OP_REQUIRES( context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1, errors::Unimplemented(""Fractional average pooling is not yet "" ""supported on the batch nor channel dimension."")); OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_)); OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_)); OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_)); if (deterministic_) { if ((seed_ == 0) && (seed2_ == 0)) { seed_ = random::New64(); seed2_ = random::New64(); } } else { OP_REQUIRES( context, (seed_ == 0) && (seed2_ == 0), errors::InvalidArgument( ""Both seed and seed2 should be 0 if deterministic is false."")); } }"
"int qcow2_snapshot_load_tmp(BlockDriverState *bs, const char *snapshot_id, const char *name, Error **errp) { int i, snapshot_index; BDRVQcowState *s = bs->opaque; QCowSnapshot *sn; uint64_t *new_l1_table; int new_l1_bytes; int ret; assert(bs->read_only); snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name); if (snapshot_index < 0) { error_setg(errp, ""Can't find snapshot""); return -ENOENT; } sn = &s->snapshots[snapshot_index]; new_l1_bytes = s->l1_size * sizeof(uint64_t); new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512)); ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes); if (ret < 0) { error_setg(errp, ""Failed to read l1 table for snapshot""); g_free(new_l1_table); return ret; } g_free(s->l1_table); s->l1_size = sn->l1_size; s->l1_table_offset = sn->l1_table_offset; s->l1_table = new_l1_table; for(i = 0;i < s->l1_size; i++) { be64_to_cpus(&s->l1_table[i]); } return 0; }"
"AP4_AvccAtom*  AP4_AvccAtom::Create(AP4_Size size, AP4_ByteStream& stream) { unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE; AP4_DataBuffer payload_data(payload_size); AP4_Result result = stream.Read(payload_data.UseData(), payload_size); if (AP4_FAILED(result)) return NULL; const AP4_UI08* payload = payload_data.GetData(); if (payload[0] != 1) { return NULL; } if (payload_size < 6) return NULL; unsigned int num_seq_params = payload[5]&31; unsigned int cursor = 6; for (unsigned int i=0; i<num_seq_params; i++) { if (cursor+2 > payload_size) return NULL; cursor += 2+AP4_BytesToInt16BE(&payload[cursor]); if (cursor > payload_size) return NULL; } unsigned int num_pic_params = payload[cursor++]; if (cursor > payload_size) return NULL; for (unsigned int i=0; i<num_pic_params; i++) { if (cursor+2 > payload_size) return NULL; cursor += 2+AP4_BytesToInt16BE(&payload[cursor]); if (cursor > payload_size) return NULL; } return new AP4_AvccAtom(size, payload); }"
"PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd, pj_off_t offset, enum pj_file_seek_type whence) { int mode; switch (whence) { case PJ_SEEK_SET: mode = SEEK_SET; break; case PJ_SEEK_CUR: mode = SEEK_CUR; break; case PJ_SEEK_END: mode = SEEK_END; break; default: pj_assert(!""Invalid whence in file_setpos""); return PJ_EINVAL; } if (fseek((FILE*)fd, (long)offset, mode) != 0) return PJ_RETURN_OS_ERROR(errno); return PJ_SUCCESS; }"
"int _libssh2_check_length(struct string_buf *buf, size_t len) { if(len > buf->len) return 0; return ((int)(buf->dataptr - buf->data) <= (int)(buf->len - len)) ? 1 : 0; }"
"int data_on_connection(int fd, callback_remove_handler remove) { int nread; char *network_packet; char network_line[8192]; char *p; unsigned long id; char string[1024]; unsigned long msg_id = UINT32_MAX; enum network_protocol version = network_client_get_version(fd); ioctl(fd, FIONREAD, &nread); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""new connection data = %d\n"",nread); if(nread == 0) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""%d failed, got 0 close connection to listener "", fd); close(fd); FD_CLR(fd, &readfds); remove(fd); network_client_dump (); return 0; } if ( nread >= 8192 ) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, more than 8192 close connection to listener "", fd); close(fd); FD_CLR(fd, &readfds); remove(fd); return 0; } network_packet=malloc((nread+1) * sizeof(char)); read(fd, network_packet, nread); network_packet[nread]='\0'; memset(network_line, 0, 8192); p=network_packet; p_sem(sem_id); while ( get_network_line(p, network_line) ) { if ( strlen(network_line) > 0 ) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""line = [%s]"",network_line); } if ( !strncmp(network_line, ""MSGID: "", strlen(""MSGID: "")) ) { msg_id=strtoul(&(network_line[strlen(""MSGID: "")]), NULL, 10); p+=strlen(network_line); } else if ( !strncmp(network_line, ""Version: "", strlen(""Version: "")) ) { char *head = network_line, *end; univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: VERSION""); version = strtoul(head + 9, &end, 10); if (!head[9] || *end) goto failed; univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""VERSION=%d"", version); if (version < network_procotol_version) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Forbidden VERSION=%d < %d, close connection to listener"", version, network_procotol_version); goto close; } else if (version >= PROTOCOL_LAST) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Future VERSION=%d"", version); version = PROTOCOL_LAST - 1; } network_client_set_version(fd, version); msg_id = UINT32_MAX; p+=strlen(network_line); } else if ( !strncmp(network_line, ""Capabilities: "", strlen(""Capabilities: "")) ) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: Capabilities""); if ( version > PROTOCOL_UNKNOWN ) { memset(string, 0, sizeof(string)); snprintf(string, sizeof(string), ""Version: %d\nCapabilities: \n\n"", version); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""SEND: %s"", string); write(fd, string, strlen(string)); } else { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""Capabilities recv, but no version line""); } p+=strlen(network_line); } else if ( !strncmp(network_line, ""GET_DN "", strlen(""GET_DN "")) && msg_id != UINT32_MAX && network_client_get_version(fd) > 0) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_DN""); id=strtoul(&(network_line[strlen(""GET_DN "")]), NULL, 10); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"",id); if ( id <= notify_last_id.id) { char *dn_string = NULL; univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""try to read %ld from cache"", id); if ( (dn_string = notifier_cache_get(id)) == NULL ) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld not found in cache"", id); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld get one dn"", id); if( (dn_string=notify_transcation_get_one_dn ( id )) == NULL ) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""%ld failed "", id); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""%d failed, close connection to listener "", fd); close(fd); FD_CLR(fd, &readfds); remove(fd); return 0; } } if ( dn_string != NULL ) { snprintf(string, sizeof(string), ""MSGID: %ld\n%s\n\n"",msg_id,dn_string); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string); write(fd, string, strlen(string)); free(dn_string); } } else { network_client_set_next_id(fd, id); network_client_set_msg_id(fd, msg_id); } p+=strlen(network_line)+1; msg_id = UINT32_MAX; } else if (!strncmp(p, ""WAIT_ID "", 8) && msg_id != UINT32_MAX && version >= PROTOCOL_3) { char *head = network_line, *end; univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: WAIT_ID""); id = strtoul(head + 8, &end, 10); if (!head[8] || *end) goto failed; univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""id: %ld"", id); if (id <= notify_last_id.id) { snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"", msg_id, notify_last_id.id); write(fd, string, strlen(string)); } else { network_client_set_next_id(fd, id); network_client_set_msg_id(fd, msg_id); } p += strlen(network_line) + 1; msg_id = UINT32_MAX; } else if ( !strncmp(network_line, ""GET_ID"", strlen(""GET_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_ID""); memset(string, 0, sizeof(string)); snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,notify_last_id.id); write(fd, string, strlen(string)); p+=strlen(network_line)+1; msg_id = UINT32_MAX; } else if ( !strncmp(network_line, ""GET_SCHEMA_ID"", strlen(""GET_SCHEMA_ID"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: GET_SCHEMA_ID""); memset(string, 0, sizeof(string)); snprintf(string, sizeof(string), ""MSGID: %ld\n%ld\n\n"",msg_id,SCHEMA_ID); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""--> %d: [%s]"",fd, string); write(fd, string, strlen(string)); p+=strlen(network_line)+1; msg_id = UINT32_MAX; } else if ( !strncmp(network_line, ""ALIVE"", strlen(""ALIVE"")) && msg_id != UINT32_MAX  && network_client_get_version(fd) > 0) { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""RECV: ALIVE""); snprintf(string, sizeof(string), ""MSGID: %ld\nOKAY\n\n"",msg_id); write(fd, string, strlen(string)); p+=strlen(network_line)+1; msg_id = UINT32_MAX; } else { p+=strlen(network_line); if (strlen(network_line) == 0 ) { p+=1; } else { univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ERROR, ""Drop package [%s]"", network_line); } } } v_sem(sem_id); univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_ALL, ""END Package""); network_client_dump (); return 0; failed: univention_debug(UV_DEBUG_TRANSFILE, UV_DEBUG_PROCESS, ""Failed parsing [%s]"", p); close: close(fd); FD_CLR(fd, &readfds); remove(fd); return 0; }"
"void Gobby::EditCommands::on_can_undo_changed(InfAdoptedUser* user, bool can_undo) { g_assert(m_current_view != NULL); if(INF_ADOPTED_USER(m_current_view->get_active_user()) == user) m_actions.undo->set_enabled(can_undo); }"
"TfLiteStatus EvalHybridPerChannel(TfLiteContext* context, TfLiteNode* node, TfLiteDepthwiseConvParams* params, OpData* data, const TfLiteTensor* input, const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output) { float output_activation_min, output_activation_max; CalculateActivationRange(params->activation, &output_activation_min, &output_activation_max); const int batch_size = SizeOfDimension(input, 0); TF_LITE_ENSURE(context, batch_size != 0); const int input_size = NumElements(input) / batch_size; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); int8_t* quantized_input_ptr_batch = input_quantized->data.int8; TfLiteTensor* scaling_factors_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors_tensor)); float* scaling_factors_ptr = GetTensorData<float>(scaling_factors_tensor); TfLiteTensor* input_offset_tensor; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_offset_index, &input_offset_tensor)); int32_t* input_offset_ptr = GetTensorData<int32_t>(input_offset_tensor); for (int b = 0; b < batch_size; ++b) { const int offset = b * input_size; tensor_utils::AsymmetricQuantizeFloats( GetTensorData<float>(input) + offset, input_size, quantized_input_ptr_batch + offset, &scaling_factors_ptr[b], &input_offset_ptr[b]); } DepthwiseParams op_params; op_params.padding_type = PaddingType::kSame; op_params.padding_values.width = data->padding.width; op_params.padding_values.height = data->padding.height; op_params.stride_width = params->stride_width; op_params.stride_height = params->stride_height; op_params.dilation_width_factor = params->dilation_width_factor; op_params.dilation_height_factor = params->dilation_height_factor; op_params.depth_multiplier = params->depth_multiplier; op_params.weights_offset = 0; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params); if (kernel_type == kReference) { reference_integer_ops::DepthwiseConvHybridPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), GetTensorData<int8>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), affine_quantization->scale->data, input_offset_ptr); } else { optimized_integer_ops::DepthwiseConvHybridPerChannel( op_params, scaling_factors_ptr, GetTensorShape(input), quantized_input_ptr_batch, GetTensorShape(filter), GetTensorData<int8>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), affine_quantization->scale->data, input_offset_ptr, CpuBackendContext::GetFromContext(context)); } return kTfLiteOk; }"
"XIDeviceInfo* XIQueryDevice(Display *dpy, int deviceid, int *ndevices_return) { XIDeviceInfo        *info = NULL; xXIQueryDeviceReq   *req; xXIQueryDeviceReply reply; char                *ptr; int                 i; char                *buf; XExtDisplayInfo *extinfo = XInput_find_display(dpy); LockDisplay(dpy); if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1) goto error_unlocked; GetReq(XIQueryDevice, req); req->reqType  = extinfo->codes->major_opcode; req->ReqType  = X_XIQueryDevice; req->deviceid = deviceid; if (!_XReply(dpy, (xReply*) &reply, 0, xFalse)) goto error; *ndevices_return = reply.num_devices; info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo)); if (!info) goto error; buf = Xmalloc(reply.length * 4); _XRead(dpy, buf, reply.length * 4); ptr = buf; info[reply.num_devices].name = NULL; for (i = 0; i < reply.num_devices; i++) { int             nclasses; size_t          sz; XIDeviceInfo    *lib = &info[i]; xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr; lib->deviceid    = wire->deviceid; lib->use         = wire->use; lib->attachment  = wire->attachment; lib->enabled     = wire->enabled; nclasses         = wire->num_classes; ptr += sizeof(xXIDeviceInfo); lib->name = Xcalloc(wire->name_len + 1, 1); strncpy(lib->name, ptr, wire->name_len); ptr += ((wire->name_len + 3)/4) * 4; sz = size_classes((xXIAnyInfo*)ptr, nclasses); lib->classes = Xmalloc(sz); ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses); lib->num_classes = nclasses; } Xfree(buf); UnlockDisplay(dpy); SyncHandle(); return info; error: UnlockDisplay(dpy); error_unlocked: SyncHandle(); *ndevices_return = -1; return NULL; }"
"static void gs_window_real_realize (GtkWidget *widget) { widget_set_best_visual (widget); if (GTK_WIDGET_CLASS (gs_window_parent_class)->realize) { GTK_WIDGET_CLASS (gs_window_parent_class)->realize (widget); } gs_window_override_user_time (GS_WINDOW (widget)); gs_window_move_resize_window (GS_WINDOW (widget), TRUE, TRUE); g_signal_connect (gtk_window_get_screen (GTK_WINDOW (widget)), ""size_changed"", G_CALLBACK (screen_size_changed), widget); }"
"static int tiffcp(TIFF* in, TIFF* out) { uint16 bitspersample = 1, samplesperpixel = 1; uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK; copyFunc cf; uint32 width, length; struct cpTag* p; CopyField(TIFFTAG_IMAGEWIDTH, width); CopyField(TIFFTAG_IMAGELENGTH, length); CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample); CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel); if (compression != (uint16)-1) TIFFSetField(out, TIFFTAG_COMPRESSION, compression); else CopyField(TIFFTAG_COMPRESSION, compression); TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression); TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric); if (input_compression == COMPRESSION_JPEG) { TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else if (input_photometric == PHOTOMETRIC_YCBCR) { uint16 subsamplinghor,subsamplingver; TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver); if (subsamplinghor!=1 || subsamplingver!=1) { fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"", TIFFFileName(in)); return FALSE; } } if (compression == COMPRESSION_JPEG) { if (input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR); else TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric); } else if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24) TIFFSetField(out, TIFFTAG_PHOTOMETRIC, samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV); else if (input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB); } else CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT); if (fillorder != 0) TIFFSetField(out, TIFFTAG_FILLORDER, fillorder); else CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT); TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); switch (orientation) { case ORIENTATION_BOTRIGHT: case ORIENTATION_RIGHTBOT: TIFFWarning(TIFFFileName(in), ""using bottom-left orientation""); orientation = ORIENTATION_BOTLEFT; case ORIENTATION_LEFTBOT: case ORIENTATION_BOTLEFT: break; case ORIENTATION_TOPRIGHT: case ORIENTATION_RIGHTTOP: default: TIFFWarning(TIFFFileName(in), ""using top-left orientation""); orientation = ORIENTATION_TOPLEFT; case ORIENTATION_LEFTTOP: case ORIENTATION_TOPLEFT: break; } TIFFSetField(out, TIFFTAG_ORIENTATION, orientation); if (outtiled == -1) outtiled = TIFFIsTiled(in); if (outtiled) { if (tilewidth == (uint32) -1) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth); if (tilelength == (uint32) -1) TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength); TIFFDefaultTileSize(out, &tilewidth, &tilelength); TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth); TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength); } else { if (rowsperstrip == (uint32) 0) { if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) { rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip); } if (rowsperstrip > length && rowsperstrip != (uint32)-1) rowsperstrip = length; } else if (rowsperstrip == (uint32) -1) rowsperstrip = length; TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); } if (config != (uint16) -1) TIFFSetField(out, TIFFTAG_PLANARCONFIG, config); else CopyField(TIFFTAG_PLANARCONFIG, config); if (samplesperpixel <= 4) CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT); CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT); switch (compression) { case COMPRESSION_JPEG: TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality); TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode); break; case COMPRESSION_JBIG: CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII); break; case COMPRESSION_LZW: case COMPRESSION_ADOBE_DEFLATE: case COMPRESSION_DEFLATE: case COMPRESSION_LZMA: case COMPRESSION_ZSTD: case COMPRESSION_WEBP: if (predictor != (uint16)-1) TIFFSetField(out, TIFFTAG_PREDICTOR, predictor); else CopyField(TIFFTAG_PREDICTOR, predictor); if (preset != -1) { if (compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE) TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset); else if (compression == COMPRESSION_LZMA) TIFFSetField(out, TIFFTAG_LZMAPRESET, preset); else if (compression == COMPRESSION_ZSTD) TIFFSetField(out, TIFFTAG_ZSTD_LEVEL, preset); else if (compression == COMPRESSION_WEBP) { if (preset == 100) { TIFFSetField(out, TIFFTAG_WEBP_LOSSLESS, TRUE); } else { TIFFSetField(out, TIFFTAG_WEBP_LEVEL, preset); } } } break; case COMPRESSION_CCITTFAX3: case COMPRESSION_CCITTFAX4: if (compression == COMPRESSION_CCITTFAX3) { if (g3opts != (uint32) -1) TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts); else CopyField(TIFFTAG_GROUP3OPTIONS, g3opts); } else CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG); CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG); CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG); CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII); break; } { uint32 len32; void** data; if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data)) TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data); } { uint16 ninks; const char* inknames; if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) { TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks); if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) { int inknameslen = strlen(inknames) + 1; const char* cp = inknames; while (ninks > 1) { cp = strchr(cp, '\0'); cp++; inknameslen += (strlen(cp) + 1); ninks--; } TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames); } } } { unsigned short pg0, pg1; if (pageInSeq == 1) { if (pageNum < 0)  { if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); } else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } else { if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) { if (pageNum < 0)  TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1); else TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0); } } } for (p = tags; p < &tags[NTAGS]; p++) CopyTag(p->tag, p->count, p->type); cf = pickCopyFunc(in, out, bitspersample, samplesperpixel); return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE); }"
"static int ca8210_probe(struct spi_device *spi_device) { struct ca8210_priv *priv; struct ieee802154_hw *hw; struct ca8210_platform_data *pdata; int ret; dev_info(&spi_device->dev, ""Inserting ca8210\n""); hw = ieee802154_alloc_hw(sizeof(struct ca8210_priv), &ca8210_phy_ops); if (!hw) { dev_crit(&spi_device->dev, ""ieee802154_alloc_hw failed\n""); ret = -ENOMEM; goto error; } priv = hw->priv; priv->hw = hw; priv->spi = spi_device; hw->parent = &spi_device->dev; spin_lock_init(&priv->lock); priv->async_tx_pending = false; priv->hw_registered = false; priv->sync_up = 0; priv->sync_down = 0; priv->promiscuous = false; priv->retries = 0; init_completion(&priv->ca8210_is_awake); init_completion(&priv->spi_transfer_complete); init_completion(&priv->sync_exchange_complete); spi_set_drvdata(priv->spi, priv); if (IS_ENABLED(CONFIG_IEEE802154_CA8210_DEBUGFS)) { cascoda_api_upstream = ca8210_test_int_driver_write; ca8210_test_interface_init(priv); } else { cascoda_api_upstream = NULL; } ca8210_hw_setup(hw); ieee802154_random_extended_addr(&hw->phy->perm_extended_addr); pdata = kmalloc(sizeof(*pdata), GFP_KERNEL); if (!pdata) { ret = -ENOMEM; goto error; } ret = ca8210_get_platform_data(priv->spi, pdata); if (ret) { dev_crit(&spi_device->dev, ""ca8210_get_platform_data failed\n""); goto error; } priv->spi->dev.platform_data = pdata; ret = ca8210_dev_com_init(priv); if (ret) { dev_crit(&spi_device->dev, ""ca8210_dev_com_init failed\n""); goto error; } ret = ca8210_reset_init(priv->spi); if (ret) { dev_crit(&spi_device->dev, ""ca8210_reset_init failed\n""); goto error; } ret = ca8210_interrupt_init(priv->spi); if (ret) { dev_crit(&spi_device->dev, ""ca8210_interrupt_init failed\n""); goto error; } msleep(100); ca8210_reset_send(priv->spi, 1); ret = tdme_chipinit(priv->spi); if (ret) { dev_crit(&spi_device->dev, ""tdme_chipinit failed\n""); goto error; } if (pdata->extclockenable) { ret = ca8210_config_extern_clk(pdata, priv->spi, 1); if (ret) { dev_crit( &spi_device->dev, ""ca8210_config_extern_clk failed\n"" ); goto error; } ret = ca8210_register_ext_clock(priv->spi); if (ret) { dev_crit( &spi_device->dev, ""ca8210_register_ext_clock failed\n"" ); goto error; } } ret = ieee802154_register_hw(hw); if (ret) { dev_crit(&spi_device->dev, ""ieee802154_register_hw failed\n""); goto error; } priv->hw_registered = true; return 0; error: msleep(100);  ca8210_remove(spi_device); return link_to_linux_err(ret); }"
"static void calculate_gain(sbr_info *sbr, sbr_hfadj_info *adj, uint8_t ch) { static real_t limGain[] = { -1.0, 0.0, 1.0, 33.219 }; uint8_t m, l, k; uint8_t current_t_noise_band = 0; uint8_t S_mapped; ALIGN real_t Q_M_lim[MAX_M]; ALIGN real_t G_lim[MAX_M]; ALIGN real_t G_boost; ALIGN real_t S_M[MAX_M]; for (l = 0; l < sbr->L_E[ch]; l++) { uint8_t current_f_noise_band = 0; uint8_t current_res_band = 0; uint8_t current_res_band2 = 0; uint8_t current_hi_res_band = 0; real_t delta = (l == sbr->l_A[ch] || l == sbr->prevEnvIsShort[ch]) ? 0 : 1; S_mapped = get_S_mapped(sbr, ch, l, current_res_band2); if (sbr->t_E[ch][l+1] > sbr->t_Q[ch][current_t_noise_band+1]) { current_t_noise_band++; } for (k = 0; k < sbr->N_L[sbr->bs_limiter_bands]; k++) { real_t Q_M = 0; real_t G_max; real_t den = 0; real_t acc1 = 0; real_t acc2 = 0; uint8_t current_res_band_size = 0; uint8_t Q_M_size = 0; uint8_t ml1, ml2; ml1 = sbr->f_table_lim[sbr->bs_limiter_bands][k]; ml2 = sbr->f_table_lim[sbr->bs_limiter_bands][k+1]; for (m = ml1; m < ml2; m++) { if ((m + sbr->kx) < sbr->f_table_res[sbr->f[ch][l]][current_res_band+1]) { current_res_band_size++; } else { acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch))); current_res_band++; current_res_band_size = 1; } acc2 += QUANTISE2INT(sbr->E_curr[ch][m][l]/1024.0); } acc1 += QUANTISE2INT(pow2(-10 + log2_int_tab[current_res_band_size] + find_log2_E(sbr, current_res_band, l, ch))); acc1 = QUANTISE2REAL( log2(EPS + acc1) ); G_max = acc1 - QUANTISE2REAL(log2(EPS + acc2)) + QUANTISE2REAL(limGain[sbr->bs_limiter_gains]); G_max = min(G_max, QUANTISE2REAL(limGain[3])); for (m = ml1; m < ml2; m++) { real_t G; real_t E_curr, E_orig; real_t Q_orig, Q_orig_plus1; uint8_t S_index_mapped; if ((m + sbr->kx) == sbr->f_table_noise[current_f_noise_band+1]) { current_f_noise_band++; } if ((m + sbr->kx) == sbr->f_table_res[sbr->f[ch][l]][current_res_band2+1]) { if (Q_M_size > 0) den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M)); Q_M_size = 0; current_res_band2++; S_mapped = get_S_mapped(sbr, ch, l, current_res_band2); } if ((m + sbr->kx) == sbr->f_table_res[HI_RES][current_hi_res_band+1]) { current_hi_res_band++; } S_index_mapped = 0; if ((l >= sbr->l_A[ch]) || (sbr->bs_add_harmonic_prev[ch][current_hi_res_band] && sbr->bs_add_harmonic_flag_prev[ch])) { if ((m + sbr->kx) == (sbr->f_table_res[HI_RES][current_hi_res_band+1] + sbr->f_table_res[HI_RES][current_hi_res_band]) >> 1) S_index_mapped = sbr->bs_add_harmonic[ch][current_hi_res_band]; } if (sbr->E_curr[ch][m][l] == 0) E_curr = LOG2_MIN_INF; else E_curr = -10 + log2(sbr->E_curr[ch][m][l]); E_orig = -10 + find_log2_E(sbr, current_res_band2, l, ch); Q_orig = find_log2_Q(sbr, current_f_noise_band, current_t_noise_band, ch); Q_orig_plus1 = find_log2_Qplus1(sbr, current_f_noise_band, current_t_noise_band, ch); Q_M = E_orig + Q_orig - Q_orig_plus1; if (S_index_mapped == 0) { S_M[m] = LOG2_MIN_INF;  } else { S_M[m] = E_orig - Q_orig_plus1; den += pow2(S_M[m]); } G = E_orig - max(-10, E_curr); if ((S_mapped == 0) && (delta == 1)) { G -= Q_orig_plus1; } else if (S_mapped == 1) { G += Q_orig - Q_orig_plus1; } if (G_max > G) { Q_M_lim[m] = QUANTISE2REAL(Q_M); G_lim[m] = QUANTISE2REAL(G); if ((S_index_mapped == 0) && (l != sbr->l_A[ch])) { Q_M_size++; } } else { Q_M_lim[m] = QUANTISE2REAL(Q_M) + G_max - QUANTISE2REAL(G); G_lim[m] = G_max; if ((S_index_mapped == 0) && (l != sbr->l_A[ch])) { den += QUANTISE2INT(pow2(Q_M_lim[m])); } } den += QUANTISE2INT(pow2(E_curr + G_lim[m])); } if (Q_M_size > 0) { den += QUANTISE2INT(pow2(log2_int_tab[Q_M_size] + Q_M)); } G_boost = acc1 - QUANTISE2REAL(log2(den + EPS)); G_boost = min(G_boost, QUANTISE2REAL(1.328771237) ); for (m = ml1; m < ml2; m++) { #ifndef SBR_LOW_POWER adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2((G_lim[m] + G_boost) / 2.0)); #else adj->G_lim_boost[l][m] = QUANTISE2REAL(pow2(G_lim[m] + G_boost)); #endif adj->Q_M_lim_boost[l][m] = QUANTISE2REAL(pow2((Q_M_lim[m] + 10 + G_boost) / 2.0)); if (S_M[m] != LOG2_MIN_INF) { adj->S_M_boost[l][m] = QUANTISE2REAL(pow2((S_M[m] + 10 + G_boost) / 2.0)); } else { adj->S_M_boost[l][m] = 0; } } } } }"
"static int walk_hugetlb_range(unsigned long addr, unsigned long end, struct mm_walk *walk) { struct vm_area_struct *vma = walk->vma; struct hstate *h = hstate_vma(vma); unsigned long next; unsigned long hmask = huge_page_mask(h); unsigned long sz = huge_page_size(h); pte_t *pte; int err = 0; do { next = hugetlb_entry_end(h, addr, end); pte = huge_pte_offset(walk->mm, addr & hmask, sz); if (pte && walk->hugetlb_entry) err = walk->hugetlb_entry(pte, hmask, addr, next, walk); if (err) break; } while (addr = next, addr != end); return err; }"
"static bfd_boolean get_program_headers (FILE * file) { Elf_Internal_Phdr * phdrs; if (program_headers != NULL) return TRUE; phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum, sizeof (Elf_Internal_Phdr)); if (phdrs == NULL) { error (_(""Out of memory reading %u program headers\n""), elf_header.e_phnum); return FALSE; } if (is_32bit_elf ? get_32bit_program_headers (file, phdrs) : get_64bit_program_headers (file, phdrs)) { program_headers = phdrs; return TRUE; } free (phdrs); return FALSE; }"
"int compile_def_function( ufunc_T*ufunc, intcheck_return_type, compiletype_T   compile_type, cctx_T*outer_cctx) { char_u*line = NULL; char_u*line_to_free = NULL; char_u*p; char*errormsg = NULL;    cctx_Tcctx; garray_T*instr; intdid_emsg_before = did_emsg; intdid_emsg_silent_before = did_emsg_silent; intret = FAIL; sctx_Tsave_current_sctx = current_sctx; intsave_estack_compiling = estack_compiling; intsave_cmod_flags = cmdmod.cmod_flags; intdo_estack_push; intnew_def_function = FALSE; #ifdef FEAT_PROFILE intprof_lnum = -1; #endif intdebug_lnum = -1; if (ufunc->uf_dfunc_idx > 0) { dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; isn_T*instr_dest = NULL; switch (compile_type) { case CT_PROFILE: #ifdef FEAT_PROFILE instr_dest = dfunc->df_instr_prof; break; #endif case CT_NONE:   instr_dest = dfunc->df_instr; break; case CT_DEBUG:  instr_dest = dfunc->df_instr_debug; break; } if (instr_dest != NULL) delete_def_function_contents(dfunc, FALSE); ga_clear_strings(&dfunc->df_var_names); } else { if (add_def_function(ufunc) == FAIL) return FAIL; new_def_function = TRUE; } ufunc->uf_def_status = UF_COMPILING; CLEAR_FIELD(cctx); cctx.ctx_compile_type = compile_type; cctx.ctx_ufunc = ufunc; cctx.ctx_lnum = -1; cctx.ctx_outer = outer_cctx; ga_init2(&cctx.ctx_locals, sizeof(lvar_T), 10); ga_init2(&cctx.ctx_type_stack, sizeof(type2_T), 50); ga_init2(&cctx.ctx_imports, sizeof(imported_T), 10); cctx.ctx_type_list = &ufunc->uf_type_list; ga_init2(&cctx.ctx_instr, sizeof(isn_T), 50); instr = &cctx.ctx_instr; current_sctx = ufunc->uf_script_ctx; current_sctx.sc_version = SCRIPT_VERSION_VIM9; cmdmod.cmod_flags &= ~CMOD_LEGACY; do_estack_push = !estack_top_is_ufunc(ufunc, 1); if (do_estack_push) estack_push_ufunc(ufunc, 1); estack_compiling = TRUE; if (check_args_shadowing(ufunc, &cctx) == FAIL) goto erret; if (ufunc->uf_def_args.ga_len > 0) { intcount = ufunc->uf_def_args.ga_len; intfirst_def_arg = ufunc->uf_args.ga_len - count; inti; char_u*arg; intoff = STACK_FRAME_SIZE + (ufunc->uf_va_name != NULL ? 1 : 0); intdid_set_arg_type = FALSE; SOURCING_LNUM = 0;  for (i = 0; i < count; ++i) { type_T*val_type; intarg_idx = first_def_arg + i; where_Twhere = WHERE_INIT; intr; intjump_instr_idx = instr->ga_len; isn_T*isn; if (generate_JUMP_IF_ARG_SET(&cctx, i - count - off) == FAIL) goto erret; ufunc->uf_args_visible = arg_idx; arg = ((char_u **)(ufunc->uf_def_args.ga_data))[i]; r = compile_expr0(&arg, &cctx); if (r == FAIL) goto erret; val_type = get_type_on_stack(&cctx, 0); where.wt_index = arg_idx + 1; if (ufunc->uf_arg_types[arg_idx] == &t_unknown) { did_set_arg_type = TRUE; ufunc->uf_arg_types[arg_idx] = val_type; } else if (need_type_where(val_type, ufunc->uf_arg_types[arg_idx], -1, where, &cctx, FALSE, FALSE) == FAIL) goto erret; if (generate_STORE(&cctx, ISN_STORE, i - count - off, NULL) == FAIL) goto erret; isn = ((isn_T *)instr->ga_data) + jump_instr_idx; isn->isn_arg.jumparg.jump_where = instr->ga_len; } if (did_set_arg_type) set_function_type(ufunc); } ufunc->uf_args_visible = ufunc->uf_args.ga_len; for (;;) { exarg_T    ea; int    starts_with_colon = FALSE; char_u    *cmd; cmdmod_T    local_cmdmod; if (did_emsg_before != did_emsg) goto erret; if (line != NULL && *line == '|') ++line; else if (line != NULL && *skipwhite(line) != NUL && !(*line == '#' && (line == cctx.ctx_line_start || VIM_ISWHITE(line[-1])))) { semsg(_(e_trailing_characters_str), line); goto erret; } else if (line != NULL && vim9_bad_comment(skipwhite(line))) goto erret; else { line = next_line_from_context(&cctx, FALSE); if (cctx.ctx_lnum >= ufunc->uf_lines.ga_len) { #ifdef FEAT_PROFILE if (cctx.ctx_skip != SKIP_YES) may_generate_prof_end(&cctx, prof_lnum); #endif break; } if (line != NULL) { line = vim_strsave(line); vim_free(line_to_free); line_to_free = line; } } CLEAR_FIELD(ea); ea.cmdlinep = &line; ea.cmd = skipwhite(line); if (*ea.cmd == '#') { line = (char_u *)""""; continue; } #ifdef FEAT_PROFILE if (cctx.ctx_compile_type == CT_PROFILE && cctx.ctx_lnum != prof_lnum && cctx.ctx_skip != SKIP_YES) { may_generate_prof_end(&cctx, prof_lnum); prof_lnum = cctx.ctx_lnum; generate_instr(&cctx, ISN_PROF_START); } #endif if (cctx.ctx_compile_type == CT_DEBUG && cctx.ctx_lnum != debug_lnum && cctx.ctx_skip != SKIP_YES) { debug_lnum = cctx.ctx_lnum; generate_instr_debug(&cctx); } cctx.ctx_prev_lnum = cctx.ctx_lnum + 1; switch (*ea.cmd) { case '}': { scopetype_T stype = cctx.ctx_scope == NULL ? NO_SCOPE : cctx.ctx_scope->se_type; if (stype == BLOCK_SCOPE) { compile_endblock(&cctx); line = ea.cmd; } else { emsg(_(e_using_rcurly_outside_if_block_scope)); goto erret; } if (line != NULL) line = skipwhite(ea.cmd + 1); continue; } case '{': if (ends_excmd(*skipwhite(ea.cmd + 1))) { line = compile_block(ea.cmd, &cctx); continue; } break; } cctx.ctx_has_cmdmod = FALSE; if (parse_command_modifiers(&ea, &errormsg, &local_cmdmod, FALSE) == FAIL) { if (errormsg != NULL) goto erret; line = (char_u *)""""; continue; } generate_cmdmods(&cctx, &local_cmdmod); undo_cmdmod(&local_cmdmod); for (p = ea.cmd; p >= line; --p) { if (*p == ':') starts_with_colon = TRUE; if (p < ea.cmd && !VIM_ISWHITE(*p)) break; } p = ea.cmd; if (!(local_cmdmod.cmod_flags & CMOD_LEGACY)) { if (checkforcmd(&ea.cmd, ""call"", 3)) { if (*ea.cmd == '(') ea.cmd = p; else ea.cmd = skipwhite(ea.cmd); } if (!starts_with_colon) { int    assign; assign = may_compile_assignment(&ea, &line, &cctx); if (assign == OK) goto nextline; if (assign == FAIL) goto erret; } } cmd = ea.cmd; if ((*cmd != '$' || starts_with_colon) && (starts_with_colon || !(*cmd == '\'' || (cmd[0] != NUL && cmd[0] == cmd[1] && (*cmd == '+' || *cmd == '-'))))) { ea.cmd = skip_range(ea.cmd, TRUE, NULL); if (ea.cmd > cmd) { if (!starts_with_colon && !(local_cmdmod.cmod_flags & CMOD_LEGACY)) { semsg(_(e_colon_required_before_range_str), cmd); goto erret; } ea.addr_count = 1; if (ends_excmd2(line, ea.cmd)) { generate_EXEC(&cctx, ISN_EXECRANGE, vim_strnsave(cmd, ea.cmd - cmd)); line = ea.cmd; goto nextline; } } } p = find_ex_command(&ea, NULL, starts_with_colon || (local_cmdmod.cmod_flags & CMOD_LEGACY) ? NULL : item_exists, &cctx); if (p == NULL) { if (cctx.ctx_skip != SKIP_YES) emsg(_(e_ambiguous_use_of_user_defined_command)); goto erret; } if (local_cmdmod.cmod_flags & CMOD_LEGACY) { char_u *start = ea.cmd; switch (ea.cmdidx) { case CMD_if: case CMD_elseif: case CMD_else: case CMD_endif: case CMD_for: case CMD_endfor: case CMD_continue: case CMD_break: case CMD_while: case CMD_endwhile: case CMD_try: case CMD_catch: case CMD_finally: case CMD_endtry: semsg(_(e_cannot_use_legacy_with_command_str), ea.cmd); goto erret; default: break; } if (checkforcmd(&start, ""return"", 4)) ea.cmdidx = CMD_return; else ea.cmdidx = CMD_legacy; } if (p == ea.cmd && ea.cmdidx != CMD_SIZE) { if (cctx.ctx_skip == SKIP_YES && ea.cmdidx != CMD_eval) { line += STRLEN(line); goto nextline; } else if (ea.cmdidx != CMD_eval) { semsg(_(e_command_not_recognized_str), ea.cmd); goto erret; } } if (cctx.ctx_had_return && ea.cmdidx != CMD_elseif && ea.cmdidx != CMD_else && ea.cmdidx != CMD_endif && ea.cmdidx != CMD_endfor && ea.cmdidx != CMD_endwhile && ea.cmdidx != CMD_catch && ea.cmdidx != CMD_finally && ea.cmdidx != CMD_endtry) { emsg(_(e_unreachable_code_after_return)); goto erret; } p = skipwhite(p); if (ea.cmdidx != CMD_SIZE && ea.cmdidx != CMD_write && ea.cmdidx != CMD_read) { if (ea.cmdidx >= 0) ea.argt = excmd_get_argt(ea.cmdidx); if ((ea.argt & EX_BANG) && *p == '!') { ea.forceit = TRUE; p = skipwhite(p + 1); } } switch (ea.cmdidx) { case CMD_def: case CMD_function: ea.arg = p; line = compile_nested_function(&ea, &cctx, &line_to_free); break; case CMD_return: line = compile_return(p, check_return_type, local_cmdmod.cmod_flags & CMOD_LEGACY, &cctx); cctx.ctx_had_return = TRUE; break; case CMD_let: emsg(_(e_cannot_use_let_in_vim9_script)); break; case CMD_var: case CMD_final: case CMD_const: case CMD_increment: case CMD_decrement: line = compile_assignment(p, &ea, ea.cmdidx, &cctx); if (line == p) line = NULL; break; case CMD_unlet: case CMD_unlockvar: case CMD_lockvar: line = compile_unletlock(p, &ea, &cctx); break; case CMD_import: emsg(_(e_import_can_only_be_used_in_script)); line = NULL; break; case CMD_if: line = compile_if(p, &cctx); break; case CMD_elseif: line = compile_elseif(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_else: line = compile_else(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_endif: line = compile_endif(p, &cctx); break; case CMD_while: line = compile_while(p, &cctx); break; case CMD_endwhile: line = compile_endwhile(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_for: line = compile_for(p, &cctx); break; case CMD_endfor: line = compile_endfor(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_continue: line = compile_continue(p, &cctx); break; case CMD_break: line = compile_break(p, &cctx); break; case CMD_try: line = compile_try(p, &cctx); break; case CMD_catch: line = compile_catch(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_finally: line = compile_finally(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_endtry: line = compile_endtry(p, &cctx); cctx.ctx_had_return = FALSE; break; case CMD_throw: line = compile_throw(p, &cctx); break; case CMD_eval: line = compile_eval(p, &cctx); break; case CMD_echo: case CMD_echon: case CMD_execute: case CMD_echomsg: case CMD_echoerr: case CMD_echoconsole: line = compile_mult_expr(p, ea.cmdidx, &cctx); break; case CMD_put: ea.cmd = cmd; line = compile_put(p, &ea, &cctx); break; case CMD_substitute: if (check_global_and_subst(ea.cmd, p) == FAIL) goto erret; if (cctx.ctx_skip == SKIP_YES) line = (char_u *)""""; else { ea.arg = p; line = compile_substitute(line, &ea, &cctx); } break; case CMD_redir: ea.arg = p; line = compile_redir(line, &ea, &cctx); break; case CMD_cexpr: case CMD_lexpr: case CMD_caddexpr: case CMD_laddexpr: case CMD_cgetexpr: case CMD_lgetexpr: #ifdef FEAT_QUICKFIX ea.arg = p; line = compile_cexpr(line, &ea, &cctx); #else ex_ni(&ea); line = NULL; #endif break; case CMD_append: case CMD_change: case CMD_insert: case CMD_k: case CMD_t: case CMD_xit: not_in_vim9(&ea); goto erret; case CMD_SIZE: if (cctx.ctx_skip != SKIP_YES) { semsg(_(e_invalid_command_str), ea.cmd); goto erret; } line = (char_u *)""""; break; case CMD_lua: case CMD_mzscheme: case CMD_perl: case CMD_py3: case CMD_python3: case CMD_python: case CMD_pythonx: case CMD_ruby: case CMD_tcl: ea.arg = p; if (vim_strchr(line, '\n') == NULL) line = compile_exec(line, &ea, &cctx); else line = compile_script(line, &cctx); break; case CMD_global: if (check_global_and_subst(ea.cmd, p) == FAIL) goto erret; default: ea.arg = p; line = compile_exec(line, &ea, &cctx); break; } nextline: if (line == NULL) goto erret; line = skipwhite(line); generate_undo_cmdmods(&cctx); if (cctx.ctx_type_stack.ga_len < 0) { iemsg(""Type stack underflow""); goto erret; } } if (cctx.ctx_scope != NULL) { if (cctx.ctx_scope->se_type == IF_SCOPE) emsg(_(e_missing_endif)); else if (cctx.ctx_scope->se_type == WHILE_SCOPE) emsg(_(e_missing_endwhile)); else if (cctx.ctx_scope->se_type == FOR_SCOPE) emsg(_(e_missing_endfor)); else emsg(_(e_missing_rcurly)); goto erret; } if (!cctx.ctx_had_return) { if (ufunc->uf_ret_type->tt_type == VAR_UNKNOWN) ufunc->uf_ret_type = &t_void; else if (ufunc->uf_ret_type->tt_type != VAR_VOID) { emsg(_(e_missing_return_statement)); goto erret; } generate_instr(&cctx, ISN_RETURN_VOID); } if (emsg_silent == 0 || did_emsg_silent == did_emsg_silent_before) { dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; dfunc->df_deleted = FALSE; dfunc->df_script_seq = current_sctx.sc_seq; #ifdef FEAT_PROFILE if (cctx.ctx_compile_type == CT_PROFILE) { dfunc->df_instr_prof = instr->ga_data; dfunc->df_instr_prof_count = instr->ga_len; } else #endif if (cctx.ctx_compile_type == CT_DEBUG) { dfunc->df_instr_debug = instr->ga_data; dfunc->df_instr_debug_count = instr->ga_len; } else { dfunc->df_instr = instr->ga_data; dfunc->df_instr_count = instr->ga_len; } dfunc->df_varcount = dfunc->df_var_names.ga_len; dfunc->df_has_closure = cctx.ctx_has_closure; if (cctx.ctx_outer_used) ufunc->uf_flags |= FC_CLOSURE; ufunc->uf_def_status = UF_COMPILED; } ret = OK; erret: if (ufunc->uf_def_status == UF_COMPILING) { dfunc_T*dfunc = ((dfunc_T *)def_functions.ga_data) + ufunc->uf_dfunc_idx; clear_instr_ga(instr); VIM_CLEAR(dfunc->df_name); ga_clear_strings(&dfunc->df_var_names); if (!dfunc->df_deleted && new_def_function && ufunc->uf_dfunc_idx == def_functions.ga_len - 1) { --def_functions.ga_len; ufunc->uf_dfunc_idx = 0; } ufunc->uf_def_status = UF_COMPILE_ERROR; while (cctx.ctx_scope != NULL) drop_scope(&cctx); if (errormsg != NULL) emsg(errormsg); else if (did_emsg == did_emsg_before) emsg(_(e_compiling_def_function_failed)); } if (cctx.ctx_redir_lhs.lhs_name != NULL) { if (ret == OK) { emsg(_(e_missing_redir_end)); ret = FAIL; } vim_free(cctx.ctx_redir_lhs.lhs_name); vim_free(cctx.ctx_redir_lhs.lhs_whole); } current_sctx = save_current_sctx; estack_compiling = save_estack_compiling; cmdmod.cmod_flags =save_cmod_flags; if (do_estack_push) estack_pop(); vim_free(line_to_free); free_imported(&cctx); free_locals(&cctx); ga_clear(&cctx.ctx_type_stack); return ret; }"
"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) { int i; if (!bin) { return NULL; } RList *segments = r_list_newf (free); for (i = 0; i < bin->ne_header->SegCount; i++) { RBinSection *bs = R_NEW0 (RBinSection); NE_image_segment_entry *se = &bin->segment_entries[i]; if (!bs) { return segments; } bs->size = se->length; bs->vsize = se->minAllocSz ? se->minAllocSz : 64000; bs->bits = R_SYS_BITS_16; bs->is_data = se->flags & IS_DATA; bs->perm = __translate_perms (se->flags); bs->paddr = (ut64)se->offset * bin->alignment; bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr); bs->is_segment = true; r_list_append (segments, bs); } bin->segments = segments; return segments; }"
"AP4_CttsAtom::AP4_CttsAtom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_CTTS, size, version, flags) { m_LookupCache.sample      = 0; m_LookupCache.entry_index = 0; AP4_UI32 entry_count; stream.ReadUI32(entry_count); m_Entries.SetItemCount(entry_count); unsigned char* buffer = new unsigned char[entry_count*8]; AP4_Result result = stream.Read(buffer, entry_count*8); if (AP4_FAILED(result)) { delete[] buffer; return; } for (unsigned i=0; i<entry_count; i++) { m_Entries[i].m_SampleCount  = AP4_BytesToUInt32BE(&buffer[i*8  ]); AP4_UI32 offset             = AP4_BytesToUInt32BE(&buffer[i*8+4]); m_Entries[i].m_SampleOffset = offset; } delete[] buffer; }"
"void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext) { std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x) { if(ext.remove_emoji) x.Remark = trim(removeEmoji(x.Remark)); nodeRename(x, ext.rename_array, ext); if(ext.add_emoji) x.Remark = addEmoji(x, ext.emoji_array, ext); }); if(ext.sort_flag) { bool failed = true; if(ext.sort_script.size()) { std::string script = ext.sort_script; if(startsWith(script, ""path:"")) script = fileGet(script.substr(5), false); script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx) { try { ctx.eval(script); auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(""compare""); auto comparer = [&](const Proxy &a, const Proxy &b) { if(a.Type == ProxyType::Unknow) return 1; if(b.Type == ProxyType::Unknow) return 0; return compare(a, b); }; std::stable_sort(nodes.begin(), nodes.end(), comparer); failed = false; } catch(qjs::exception) { script_print_stack(ctx); } }, global.scriptCleanContext); } if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b) { return a.Remark < b.Remark; }); } }"
"static int sd_e_h(GWindow gw, GEvent *event) { struct sd_data *sd = GDrawGetUserData(gw); if ( sd==NULL ) return( true ); if ( event->type==et_close ) { SD_DoCancel( sd ); } else if ( event->type==et_char ) { if ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) { help(""scripting.html""); return( true ); } return( false ); } else if ( event->type == et_map ) GDrawRaise(gw); else if ( event->type == et_resize ) GDrawRequestExpose(gw,NULL,false); return( true ); }"
"void _jsvTrace(JsVar *var, int indent, JsVar *baseVar, int level) { #ifdef SAVE_ON_FLASH jsiConsolePrint(""Trace unimplemented in this version.\n""); #else int i; for (i=0;i<indent;i++) jsiConsolePrint("" ""); if (!var) { jsiConsolePrint(""undefined""); return; } jsvTraceLockInfo(var); int lowestLevel = _jsvTraceGetLowestLevel(baseVar, var); if (lowestLevel < level) { jsiConsolePrint(""...\n""); return; } if (jsvIsName(var)) jsiConsolePrint(""Name ""); char endBracket = ' '; if (jsvIsObject(var)) { jsiConsolePrint(""Object { ""); endBracket = '}'; } else if (jsvIsArray(var)) { jsiConsolePrintf(""Array(%d) [ "", var->varData.integer); endBracket = ']'; } else if (jsvIsNativeFunction(var)) { jsiConsolePrintf(""NativeFunction 0x%x (%d) { "", var->varData.native.ptr, var->varData.native.argTypes); endBracket = '}'; } else if (jsvIsFunction(var)) { jsiConsolePrint(""Function { ""); if (jsvIsFunctionReturn(var)) jsiConsolePrint(""return ""); endBracket = '}'; } else if (jsvIsPin(var)) jsiConsolePrintf(""Pin %d"", jsvGetInteger(var)); else if (jsvIsInt(var)) jsiConsolePrintf(""Integer %d"", jsvGetInteger(var)); else if (jsvIsBoolean(var)) jsiConsolePrintf(""Bool %s"", jsvGetBool(var)?""true"":""false""); else if (jsvIsFloat(var)) jsiConsolePrintf(""Double %f"", jsvGetFloat(var)); else if (jsvIsFunctionParameter(var)) jsiConsolePrintf(""Param %q "", var); else if (jsvIsArrayBufferName(var)) jsiConsolePrintf(""ArrayBufferName[%d] "", jsvGetInteger(var)); else if (jsvIsArrayBuffer(var)) jsiConsolePrintf(""%s "", jswGetBasicObjectName(var));   else if (jsvIsString(var)) { size_t blocks = 1; if (jsvGetLastChild(var)) { JsVar *v = jsvLock(jsvGetLastChild(var)); blocks += jsvCountJsVarsUsed(v); jsvUnLock(v); } if (jsvIsFlatString(var)) { blocks += jsvGetFlatStringBlocks(var); } jsiConsolePrintf(""%sString [%d blocks] %q"", jsvIsFlatString(var)?""Flat"":(jsvIsNativeString(var)?""Native"":""""), blocks, var); } else { jsiConsolePrintf(""Unknown %d"", var->flags & (JsVarFlags)~(JSV_LOCK_MASK)); } if (jsvIsNameInt(var)) { jsiConsolePrintf(""= int %d\n"", (int)jsvGetFirstChildSigned(var)); return; } else if (jsvIsNameIntBool(var)) { jsiConsolePrintf(""= bool %s\n"", jsvGetFirstChild(var)?""true"":""false""); return; } if (jsvHasSingleChild(var)) { JsVar *child = jsvGetFirstChild(var) ? jsvLock(jsvGetFirstChild(var)) : 0; _jsvTrace(child, indent+2, baseVar, level+1); jsvUnLock(child); } else if (jsvHasChildren(var)) { JsvIterator it; jsvIteratorNew(&it, var, JSIF_DEFINED_ARRAY_ElEMENTS); bool first = true; while (jsvIteratorHasElement(&it) && !jspIsInterrupted()) { if (first) jsiConsolePrintf(""\n""); first = false; JsVar *child = jsvIteratorGetKey(&it); _jsvTrace(child, indent+2, baseVar, level+1); jsvUnLock(child); jsiConsolePrintf(""\n""); jsvIteratorNext(&it); } jsvIteratorFree(&it); if (!first) for (i=0;i<indent;i++) jsiConsolePrint("" ""); } jsiConsolePrintf(""%c"", endBracket); #endif }"
"extern int onig_new_deluxe(regex_t** reg, const UChar* pattern, const UChar* pattern_end, OnigCompileInfo* ci, OnigErrorInfo* einfo) { int r; UChar *cpat, *cpat_end; if (IS_NOT_NULL(einfo)) einfo->par = (UChar* )NULL; if (ci->pattern_enc != ci->target_enc) { r = conv_encoding(ci->pattern_enc, ci->target_enc, pattern, pattern_end, &cpat, &cpat_end); if (r != 0) return r; } else { cpat     = (UChar* )pattern; cpat_end = (UChar* )pattern_end; } *reg = (regex_t* )xmalloc(sizeof(regex_t)); if (IS_NULL(*reg)) { r = ONIGERR_MEMORY; goto err2; } r = onig_reg_init(*reg, ci->option, ci->case_fold_flag, ci->target_enc, ci->syntax); if (r != 0) goto err; r = onig_compile(*reg, cpat, cpat_end, einfo); if (r != 0) { err: onig_free(*reg); *reg = NULL; } err2: if (cpat != pattern) xfree(cpat); return r; }"
"bool operator()(const OpKernelContext* context, typename TTypes<T, 4>::ConstTensor image, typename TTypes<float, 2>::ConstTensor boxes, typename TTypes<int32, 1>::ConstTensor box_index, const string& method_name, float extrapolation_value, typename TTypes<float, 4>::Tensor crops) { const int batch_size = image.dimension(0); const int image_height = image.dimension(1); const int image_width = image.dimension(2); const int num_boxes = crops.dimension(0); const int crop_height = crops.dimension(1); const int crop_width = crops.dimension(2); const int depth = crops.dimension(3); auto CropAndResizePerBox = [&](int start_box, int limit_box) { for (int b = start_box; b < limit_box; ++b) { const float y1 = boxes(b, 0); const float x1 = boxes(b, 1); const float y2 = boxes(b, 2); const float x2 = boxes(b, 3); const int32 b_in = box_index(b); if (!FastBoundsCheck(b_in, batch_size)) { continue; } const float height_scale = (crop_height > 1) ? (y2 - y1) * (image_height - 1) / (crop_height - 1) : 0; const float width_scale = (crop_width > 1) ? (x2 - x1) * (image_width - 1) / (crop_width - 1) : 0; for (int y = 0; y < crop_height; ++y) { const float in_y = (crop_height > 1) ? y1 * (image_height - 1) + y * height_scale : 0.5 * (y1 + y2) * (image_height - 1); if (in_y < 0 || in_y > image_height - 1) { for (int x = 0; x < crop_width; ++x) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } } continue; } if (method_name == ""bilinear"") { const int top_y_index = floorf(in_y); const int bottom_y_index = ceilf(in_y); const float y_lerp = in_y - top_y_index; for (int x = 0; x < crop_width; ++x) { const float in_x = (crop_width > 1) ? x1 * (image_width - 1) + x * width_scale : 0.5 * (x1 + x2) * (image_width - 1); if (in_x < 0 || in_x > image_width - 1) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } continue; } const int left_x_index = floorf(in_x); const int right_x_index = ceilf(in_x); const float x_lerp = in_x - left_x_index; for (int d = 0; d < depth; ++d) { const float top_left(static_cast<float>( image(b_in, top_y_index, left_x_index, d))); const float top_right(static_cast<float>( image(b_in, top_y_index, right_x_index, d))); const float bottom_left(static_cast<float>( image(b_in, bottom_y_index, left_x_index, d))); const float bottom_right(static_cast<float>( image(b_in, bottom_y_index, right_x_index, d))); const float top = top_left + (top_right - top_left) * x_lerp; const float bottom = bottom_left + (bottom_right - bottom_left) * x_lerp; crops(b, y, x, d) = top + (bottom - top) * y_lerp; } } } else {              for (int x = 0; x < crop_width; ++x) { const float in_x = (crop_width > 1) ? x1 * (image_width - 1) + x * width_scale : 0.5 * (x1 + x2) * (image_width - 1); if (in_x < 0 || in_x > image_width - 1) { for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = extrapolation_value; } continue; } const int closest_x_index = roundf(in_x); const int closest_y_index = roundf(in_y); for (int d = 0; d < depth; ++d) { crops(b, y, x, d) = static_cast<float>( image(b_in, closest_y_index, closest_x_index, d)); } } } } } }; double cost_per_pixel = depth * (Eigen::TensorOpCost::AddCost<float>() * 6 + Eigen::TensorOpCost::MulCost<float>() * 3 + Eigen::TensorOpCost::CastCost<T, float>() * 4) + (Eigen::TensorOpCost::AddCost<float>() * 2 + Eigen::TensorOpCost::AddCost<float>() * 3); if (method_name == ""nearest"") { cost_per_pixel = depth * Eigen::TensorOpCost::CastCost<T, float>() + Eigen::TensorOpCost::AddCost<float>() * 4 + Eigen::TensorOpCost::MulCost<float>() * 4; } const double cost_per_box = crop_height * crop_width * cost_per_pixel; const DeviceBase::CpuWorkerThreads& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); Shard(worker_threads.num_threads, worker_threads.workers, num_boxes, cost_per_box, CropAndResizePerBox); return true; }"
"static int OJPEGPreDecode(TIFF* tif, uint16 s) { OJPEGState* sp=(OJPEGState*)tif->tif_data; uint32 m; if (sp->subsamplingcorrect_done==0) OJPEGSubsamplingCorrect(tif); if (sp->readheader_done==0) { if (OJPEGReadHeaderInfo(tif)==0) return(0); } if (sp->sos_end[s].log==0) { if (OJPEGReadSecondarySos(tif,s)==0) return(0); } if isTiled(tif) m=tif->tif_curtile; else m=tif->tif_curstrip; if ((sp->writeheader_done!=0) && ((sp->write_cursample!=s) || (sp->write_curstrile>m))) { if (sp->libjpeg_session_active!=0) OJPEGLibjpegSessionAbort(tif); sp->writeheader_done=0; } if (sp->writeheader_done==0) { sp->plane_sample_offset=(uint8)s; sp->write_cursample=s; sp->write_curstrile=s*tif->tif_dir.td_stripsperimage; if ((sp->in_buffer_file_pos_log==0) || (sp->in_buffer_file_pos-sp->in_buffer_togo!=sp->sos_end[s].in_buffer_file_pos)) { sp->in_buffer_source=sp->sos_end[s].in_buffer_source; sp->in_buffer_next_strile=sp->sos_end[s].in_buffer_next_strile; sp->in_buffer_file_pos=sp->sos_end[s].in_buffer_file_pos; sp->in_buffer_file_pos_log=0; sp->in_buffer_file_togo=sp->sos_end[s].in_buffer_file_togo; sp->in_buffer_togo=0; sp->in_buffer_cur=0; } if (OJPEGWriteHeaderInfo(tif)==0) return(0); } while (sp->write_curstrile<m)           { if (sp->libjpeg_jpeg_query_style==0) { if (OJPEGPreDecodeSkipRaw(tif)==0) return(0); } else { if (OJPEGPreDecodeSkipScanlines(tif)==0) return(0); } sp->write_curstrile++; } return(1); }"
"AP4_StszAtom::AP4_StszAtom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags) { stream.ReadUI32(m_SampleSize); stream.ReadUI32(m_SampleCount); if (m_SampleSize == 0) {         AP4_Cardinal sample_count = m_SampleCount; m_Entries.SetItemCount(sample_count); unsigned char* buffer = new unsigned char[sample_count*4]; AP4_Result result = stream.Read(buffer, sample_count*4); if (AP4_FAILED(result)) { delete[] buffer; return; } for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]); } delete[] buffer; } }"
"void XdmcpGenerateKey (XdmAuthKeyPtr key) { #ifndef HAVE_ARC4RANDOM_BUF long    lowbits, highbits; srandom ((int)getpid() ^ time((Time_t *)0)); lowbits = random (); highbits = random (); getbits (lowbits, key->data); getbits (highbits, key->data + 4); #else arc4random_buf(key->data, 8); #endif }"
"static void dissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq) { int     offset = 0; int     remain; int     want; guint8  header_type; int     basic_hlen; int     message_hlen; guint32 id; guint32 ts     = 0; guint32 tsd    = 0; int     body_len; guint8  cmd; guint32 src; int     chunk_size; rtmpt_frag_t   *tf; rtmpt_id_t     *ti; rtmpt_packet_t *tp; tvbuff_t       *pktbuf; remain = tvb_reported_length(tvb); if (!remain) return; RTMPT_DEBUG(""Segment: cdir=%d seq=%d-%d\n"", cdir, seq, seq+remain-1); if (pinfo->fd->visited) { wmem_stack_t *packets; packets = wmem_stack_new(wmem_packet_scope()); wmem_stack_push(packets, 0); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1); while (tp && tp->lastseq >= seq) { wmem_stack_push(packets, tp); if (tp->seq == 0) { break; } tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->seq-1); } while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) { if (tp->resident) { pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); } else { pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); } dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } return; } while (remain>0) { tf = NULL; ti = NULL; tp = NULL; if (offset == 0) { tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1); if (tf) { RTMPT_DEBUG(""  tf seq=%d lseq=%d h=%d l=%d\n"", tf->seq, tf->lastseq, tf->have, tf->len); if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) { tf = NULL; } else if (!tf->ishdr) { ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id); if (ti) { tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); } if (tp && tp->chunkwant) { goto unchunk; } tf = NULL; ti = NULL; tp = NULL; } if (tf) { want = tf->len - tf->have; if (remain<want) want = remain; tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want); id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) { if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) { tf->len += 4; } } tf->have += want; tf->lastseq = seq+want-1; remain -= want; offset += want; if (tf->have < tf->len) { return; } } } } if (!tf) { id = tvb_get_guint8(tvb, offset); if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) { header_type = 4; basic_hlen = 1; message_hlen = 0; id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2; } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) { header_type = 4; basic_hlen = 0; message_hlen = 0; id = RTMPT_TYPE_HANDSHAKE_3; } else { header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = rtmpt_message_header_length(id); if ((header_type < 3) && (remain >= (basic_hlen+3))) { if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) { message_hlen += 4; } } if (remain < (basic_hlen+message_hlen)) { tf = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf->ishdr = 1; tf->seq = seq + offset; tf->lastseq = tf->seq + remain - 1; tf->len = basic_hlen + message_hlen; tvb_memcpy(tvb, tf->saved.d, offset, remain); tf->have = remain; wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf); return; } id = id & 0x3f; if (id == 0) id = tvb_get_guint8(tvb, offset+1) + 64; else if (id == 1) id = tvb_get_letohs(tvb, offset+1) + 64; } } else { id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = tf->len - basic_hlen; id = id & 0x3f; if (id == 0) id = tf->saved.d[1] + 64; else if (id == 1) id = pletoh16(tf->saved.d+1) + 64; } if (id <= RTMPT_ID_MAX) ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id); if (ti) tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); if (header_type == 0) src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7); else if (ti) src = ti->src; else src = 0; if (header_type < 2) cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6); else if (ti) cmd = ti->cmd; else cmd = 0; if (id > RTMPT_ID_MAX) { if (id == RTMPT_TYPE_HANDSHAKE_1) chunk_size = body_len = 1536; else if (id == RTMPT_TYPE_HANDSHAKE_2) chunk_size = body_len = 3072; else  chunk_size = body_len = 1536; } else { chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1)); if (!chunk_size) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE; if (header_type < 2) body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3); else if (ti) body_len = ti->len; else body_len = chunk_size; if (body_len > (gint)rtmpt_max_packet_size) { return; } } if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) { RTMPT_DEBUG(""New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); if (!ti) { ti = wmem_new(wmem_file_scope(), rtmpt_id_t); ti->packets = wmem_tree_new(wmem_file_scope()); ti->ts  = 0; ti->tsd = 0; wmem_tree_insert32(rconv->ids[cdir], id, ti); } if (header_type == 0) { ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (ts == 0xffffff) { ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11); } tsd = ts - ti->ts; } else if (header_type < 3) { tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (tsd == 0xffffff) { ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4); tsd = ti->tsd;  } else { ts  = ti->ts + tsd; } } else { ts  = ti->ts + ti->tsd; tsd = ti->tsd; } tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t); tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset; tp->have       = 0; tp->want       = basic_hlen + message_hlen + body_len; tp->chunkwant  = 0; tp->chunkhave  = 0; tp->bhlen      = basic_hlen; tp->mhlen      = message_hlen; tp->fmt        = header_type; tp->id         = id; tp->ts         = ts; tp->len        = body_len; if (id > RTMPT_ID_MAX) tp->cmd = id; else tp->cmd = cmd & 0x7f; tp->src        = src; tp->txid       = 0; tp->isresponse = FALSE; tp->otherframe = 0; ti->ts  = ts; ti->tsd = tsd; ti->len = body_len; ti->cmd = cmd; ti->src = src; wmem_tree_insert32(ti->packets, tp->seq, tp); if (!tf && body_len <= chunk_size && tp->want <= remain) { tp->resident    = FALSE; tp->data.offset = offset; tp->lastseq     = seq+offset+tp->want-1; tp->have        = tp->want; wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); offset += tp->want; remain -= tp->want; continue; } else { tp->resident = TRUE; tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len); if (tf && tf->ishdr) { memcpy(tp->data.p, tf->saved.d, tf->len); } else { tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen); offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tp->lastseq = seq+offset-1; tp->have = basic_hlen + message_hlen; if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); continue; } tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; } } else { if (header_type == 3 && tp->resident && tp->have > tp->bhlen + 3 && pntoh24(tp->data.p+tp->bhlen) == 0xffffff) { message_hlen += 4; } RTMPT_DEBUG(""Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tf = NULL; unchunk: want = tp->chunkwant - tp->chunkhave; if (want > remain) want = remain; RTMPT_DEBUG(""  cw=%d ch=%d r=%d w=%d\n"", tp->chunkwant, tp->chunkhave, remain, want); tvb_memcpy(tvb, tp->data.p+tp->have, offset, want); if (tf) { tf->have += want; tf->lastseq = seq+offset+want-1; } tp->lastseq = seq+offset+want-1; tp->have += want; tp->chunkhave += want; offset += want; remain -= want; if (tp->chunkhave == tp->chunkwant) { tp->chunkhave = 0; tp->chunkwant = 0; } if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } else if (tp->chunkhave < tp->chunkwant) { rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf2->ishdr    = 0; tf2->seq      = seq + offset - want; tf2->lastseq  = tf2->seq + remain - 1 + want; tf2->have     = tp->chunkhave; tf2->len      = tp->chunkwant; tf2->saved.id = tp->id; RTMPT_DEBUG(""  inserting tf @ %d\n"", seq+offset-want-1); wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2); } } }"
"int ksmbd_smb2_check_message(struct ksmbd_work *work) { struct smb2_pdu *pdu = ksmbd_req_buf_next(work); struct smb2_hdr *hdr = &pdu->hdr; int command; __u32 clc_len;   __u32 len = get_rfc1002_len(work->request_buf); if (le32_to_cpu(hdr->NextCommand) > 0) len = le32_to_cpu(hdr->NextCommand); else if (work->next_smb2_rcv_hdr_off) len -= work->next_smb2_rcv_hdr_off; if (check_smb2_hdr(hdr)) return 1; if (hdr->StructureSize != SMB2_HEADER_STRUCTURE_SIZE) { ksmbd_debug(SMB, ""Illegal structure size %u\n"", le16_to_cpu(hdr->StructureSize)); return 1; } command = le16_to_cpu(hdr->Command); if (command >= NUMBER_OF_SMB2_COMMANDS) { ksmbd_debug(SMB, ""Illegal SMB2 command %d\n"", command); return 1; } if (smb2_req_struct_sizes[command] != pdu->StructureSize2) { if (command != SMB2_OPLOCK_BREAK_HE && (hdr->Status == 0 || pdu->StructureSize2 != SMB2_ERROR_STRUCTURE_SIZE2_LE)) { ksmbd_debug(SMB, ""Illegal request size %u for command %d\n"", le16_to_cpu(pdu->StructureSize2), command); return 1; } else if (command == SMB2_OPLOCK_BREAK_HE && hdr->Status == 0 && le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_20 && le16_to_cpu(pdu->StructureSize2) != OP_BREAK_STRUCT_SIZE_21) { ksmbd_debug(SMB, ""Illegal request size %d for oplock break\n"", le16_to_cpu(pdu->StructureSize2)); return 1; } } if (smb2_calc_size(hdr, &clc_len)) return 1; if (len != clc_len) { if (clc_len == len + 1) goto validate_credit; if (ALIGN(clc_len, 8) == len) goto validate_credit; if (command == SMB2_NEGOTIATE_HE) goto validate_credit; if (clc_len < len && (len - clc_len) <= 8) goto validate_credit; pr_err_ratelimited( ""cli req too short, len %d not %d. cmd:%d mid:%llu\n"", len, clc_len, command, le64_to_cpu(hdr->MessageId)); return 1; } validate_credit: if ((work->conn->vals->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU) && smb2_validate_credit_charge(work->conn, hdr)) { work->conn->ops->set_rsp_status(work, STATUS_INVALID_PARAMETER); return 1; } return 0; }"
"void initServerConfig() { server.port = REDIS_SERVERPORT; server.bindaddr = NULL; server.unixsocket = NULL; server.ipfd = -1; server.sofd = -1; server.dbnum = REDIS_DEFAULT_DBNUM; server.verbosity = REDIS_VERBOSE; server.maxidletime = REDIS_MAXIDLETIME; server.saveparams = NULL; server.loading = 0; server.logfile = NULL;  server.syslog_enabled = 0; server.syslog_ident = zstrdup(""redis""); server.syslog_facility = LOG_LOCAL0; server.glueoutputbuf = 1; server.daemonize = 0; server.appendonly = 0; server.appendfsync = APPENDFSYNC_EVERYSEC; server.no_appendfsync_on_rewrite = 0; server.lastfsync = time(NULL); server.appendfd = -1; server.appendseldb = -1;  server.pidfile = zstrdup(""/var/run/redis.pid""); server.dbfilename = zstrdup(""dump.rdb""); server.appendfilename = zstrdup(""appendonly.aof""); server.requirepass = NULL; server.rdbcompression = 1; server.activerehashing = 1; server.maxclients = 0; server.bpop_blocked_clients = 0; server.maxmemory = 0; server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU; server.maxmemory_samples = 3; server.vm_enabled = 0; server.vm_swap_file = zstrdup(""/tmp/redis-%p.vm""); server.vm_page_size = 256;           server.vm_pages = 1024*1024*100;     server.vm_max_memory = 1024LL*1024*1024*1;  server.vm_max_threads = 4; server.vm_blocked_clients = 0; server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES; server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE; server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES; server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE; server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES; server.shutdown_asap = 0; updateLRUClock(); resetServerSaveParams(); appendServerSaveParams(60*60,1);   appendServerSaveParams(300,100);   appendServerSaveParams(60,10000);  server.isslave = 0; server.masterauth = NULL; server.masterhost = NULL; server.masterport = 6379; server.master = NULL; server.replstate = REDIS_REPL_NONE; server.repl_serve_stale_data = 1; R_Zero = 0.0; R_PosInf = 1.0/R_Zero; R_NegInf = -1.0/R_Zero; R_Nan = R_Zero/R_Zero; server.commands = dictCreate(&commandTableDictType,NULL); populateCommandTable(); server.delCommand = lookupCommandByCString(""del""); server.multiCommand = lookupCommandByCString(""multi""); }"
static inline const u32 *flow_keys_hash_start(const struct flow_keys *flow) { const void *p = flow; BUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32)); return (const u32 *)(p + FLOW_KEYS_HASH_OFFSET); }
"static int libxl__device_pci_assignable_add(libxl__gc *gc, libxl_device_pci *pcidev, int rebind) { unsigned dom, bus, dev, func; char *spath, *driver_path = NULL; int rc; struct stat st; dom = pcidev->domain; bus = pcidev->bus; dev = pcidev->dev; func = pcidev->func; spath = GCSPRINTF(SYSFS_PCI_DEV""/""PCI_BDF, dom, bus, dev, func); if ( lstat(spath, &st) ) { LOGE(ERROR, ""Couldn't lstat %s"", spath); return ERROR_FAIL; }"
"ExtensionFrameHelper::ExtensionFrameHelper(content::RenderFrame* render_frame, Dispatcher* extension_dispatcher) : content::RenderFrameObserver(render_frame), content::RenderFrameObserverTracker<ExtensionFrameHelper>(render_frame), view_type_(VIEW_TYPE_INVALID), tab_id_(-1), browser_window_id_(-1), extension_dispatcher_(extension_dispatcher), did_create_current_document_element_(false) { g_frame_helpers.Get().insert(this); }"
"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf) { DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         long    outlen = sizeof(Jp2BoxHeader) ;         long    inlen = sizeof(Jp2BoxHeader) ;         enforce(sizeof(Jp2BoxHeader) <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata); Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_; uint32_t      length = getLong((byte*)&pBox->length, bigEndian); enforce(length <= static_cast<size_t>(output.size_), Exiv2::kerCorruptedMetadata); uint32_t      count  = sizeof (Jp2BoxHeader); char*         p      = (char*) boxBuf.pData_; bool          bWroteColor = false ; while ( count < length || !bWroteColor ) { enforce(sizeof(Jp2BoxHeader) <= length - count, Exiv2::kerCorruptedMetadata); Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ; Jp2BoxHeader   subBox = *pSubBox ; Jp2BoxHeader   newBox =  subBox; if ( count < length ) { subBox.length = getLong((byte*)&subBox.length, bigEndian); subBox.type   = getLong((byte*)&subBox.type  , bigEndian); #ifdef EXIV2_DEBUG_MESSAGES std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl; #endif enforce(subBox.length > 0, Exiv2::kerCorruptedMetadata); enforce(subBox.length <= length - count, Exiv2::kerCorruptedMetadata); count        += subBox.length; newBox.type   = subBox.type; } else { subBox.length=0; newBox.type = kJp2BoxTypeColorHeader; count = length; } uint32_t newlen = subBox.length; if ( newBox.type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined() ) { const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid""; uint32_t    psize = 15; newlen            = sizeof(newBox) + psize ; enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ul2Data((byte*)&newBox.length,psize      ,bigEndian); ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)); ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         ); } else { const char* pad   = ""\x02\x00\x00""; uint32_t    psize = 3; newlen            = sizeof(newBox) + psize + iccProfile_.size_; enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ul2Data((byte*)&newBox.length,newlen,bigEndian); ul2Data((byte*)&newBox.type,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  ); ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           ); ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_); } } else { enforce(newlen <= static_cast<size_t>(output.size_ - outlen), Exiv2::kerCorruptedMetadata); ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length); } outlen += newlen; inlen  += subBox.length; } outBuf.alloc(outlen); ::memcpy(outBuf.pData_,output.pData_,outlen); pBox   = (Jp2BoxHeader*) outBuf.pData_; ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian); ul2Data((byte*)&pBox->length,outlen,bigEndian); }"
"static Image *ReadVIPSImage(const ImageInfo *image_info, ExceptionInfo *exception) { char buffer[MaxTextExtent], *metadata; Image *image; MagickBooleanType status; ssize_t n; unsigned int channels, marker; VIPSBandFormat format; VIPSCoding coding; VIPSType type; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } marker=ReadBlobLSBLong(image); if (marker == VIPS_MAGIC_LSB) image->endian=LSBEndian; else if (marker == VIPS_MAGIC_MSB) image->endian=MSBEndian; else ThrowReaderException(CorruptImageError,""ImproperImageHeader""); image->columns=(size_t) ReadBlobLong(image); image->rows=(size_t) ReadBlobLong(image); status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } channels=ReadBlobLong(image); (void) ReadBlobLong(image);  format=(VIPSBandFormat) ReadBlobLong(image); switch(format) { case VIPSBandFormatUCHAR: case VIPSBandFormatCHAR: image->depth=8; break; case VIPSBandFormatUSHORT: case VIPSBandFormatSHORT: image->depth=16; break; case VIPSBandFormatUINT: case VIPSBandFormatINT: case VIPSBandFormatFLOAT: image->depth=32; break; case VIPSBandFormatDOUBLE: image->depth=64; break; default: case VIPSBandFormatCOMPLEX: case VIPSBandFormatDPCOMPLEX: case VIPSBandFormatNOTSET: ThrowReaderException(CoderError,""Unsupported band format""); } coding=(VIPSCoding) ReadBlobLong(image); type=(VIPSType) ReadBlobLong(image); switch(type) { case VIPSTypeCMYK: SetImageColorspace(image,CMYKColorspace); if (channels == 5) image->matte=MagickTrue; break; case VIPSTypeB_W: case VIPSTypeGREY16: SetImageColorspace(image,GRAYColorspace); if (channels == 2) image->matte=MagickTrue; break; case VIPSTypeRGB: case VIPSTypeRGB16: SetImageColorspace(image,RGBColorspace); if (channels == 4) image->matte=MagickTrue; break; case VIPSTypesRGB: SetImageColorspace(image,sRGBColorspace); if (channels == 4) image->matte=MagickTrue; break; default: case VIPSTypeFOURIER: case VIPSTypeHISTOGRAM: case VIPSTypeLAB: case VIPSTypeLABS: case VIPSTypeLABQ: case VIPSTypeLCH: case VIPSTypeMULTIBAND: case VIPSTypeUCS: case VIPSTypeXYZ: case VIPSTypeYXY: ThrowReaderException(CoderError,""Unsupported colorspace""); } image->units=PixelsPerCentimeterResolution; image->x_resolution=ReadBlobFloat(image)*10; image->y_resolution=ReadBlobFloat(image)*10; (void) ReadBlobLongLong(image); (void) ReadBlobLongLong(image); (void) ReadBlobLongLong(image); if (image_info->ping != MagickFalse) return(image); if (IsSupportedCombination(format,type) == MagickFalse) ThrowReaderException(CoderError, ""Unsupported combination of band format and colorspace""); if (channels == 0 || channels > 5) ThrowReaderException(CoderError,""Unsupported number of channels""); if (coding == VIPSCodingNONE) status=ReadVIPSPixelsNONE(image,format,type,channels,exception); else ThrowReaderException(CoderError,""Unsupported coding""); metadata=(char *) NULL; while ((n=ReadBlob(image,MaxTextExtent-1,(unsigned char *) buffer)) != 0) { buffer[n]='\0'; if (metadata == (char *) NULL) metadata=ConstantString(buffer); else (void) ConcatenateString(&metadata,buffer); } if (metadata != (char *) NULL) SetImageProperty(image,""vips:metadata"",metadata); (void) CloseBlob(image); if (status == MagickFalse) return((Image *) NULL); return(image); }"
"static int io_tee(struct io_kiocb *req, unsigned int issue_flags) { struct io_splice *sp = &req->splice; struct file *out = sp->file_out; unsigned int flags = sp->flags & ~SPLICE_F_FD_IN_FIXED; struct file *in; long ret = 0; if (issue_flags & IO_URING_F_NONBLOCK) return -EAGAIN; in = io_file_get(req->ctx, req, sp->splice_fd_in, (sp->flags & SPLICE_F_FD_IN_FIXED)); if (!in) { ret = -EBADF; goto done; } if (sp->len) ret = do_tee(in, out, sp->len, flags); if (!(sp->flags & SPLICE_F_FD_IN_FIXED)) io_put_file(in); done: if (ret != sp->len) req_set_fail(req); io_req_complete(req, ret); return 0; }"
"int expand_downwards(struct vm_area_struct *vma, unsigned long address) { struct mm_struct *mm = vma->vm_mm; struct vm_area_struct *prev; int error; address &= PAGE_MASK; error = security_mmap_addr(address); if (error) return error; prev = vma->vm_prev; if (prev && !(prev->vm_flags & VM_GROWSDOWN) && (prev->vm_flags & (VM_WRITE|VM_READ|VM_EXEC))) { if (address - prev->vm_end < stack_guard_gap) return -ENOMEM; } if (unlikely(anon_vma_prepare(vma))) return -ENOMEM; anon_vma_lock_write(vma->anon_vma); if (address < vma->vm_start) { unsigned long size, grow; size = vma->vm_end - address; grow = (vma->vm_start - address) >> PAGE_SHIFT; error = -ENOMEM; if (grow <= vma->vm_pgoff) { error = acct_stack_growth(vma, size, grow); if (!error) { spin_lock(&mm->page_table_lock); if (vma->vm_flags & VM_LOCKED) mm->locked_vm += grow; vm_stat_account(mm, vma->vm_flags, grow); anon_vma_interval_tree_pre_update_vma(vma); vma->vm_start = address; vma->vm_pgoff -= grow; anon_vma_interval_tree_post_update_vma(vma); vma_gap_update(vma); spin_unlock(&mm->page_table_lock); perf_event_mmap(vma); } } } anon_vma_unlock_write(vma->anon_vma); khugepaged_enter_vma_merge(vma, vma->vm_flags); validate_mm(mm); return error; }"
"static void rtps_util_add_typeobject(proto_tree *tree, packet_info * pinfo, tvbuff_t * tvb, gint offset, const guint encoding, guint32 size, type_mapping * type_mapping_object ) { proto_tree * typeobject_tree; gint offset_tmp = 0; guint32 member_id = 0, member_length = 0; guint32 long_number; guint64 type_id; typeobject_tree = proto_tree_add_subtree(tree, tvb, offset, size, ett_rtps_type_object, NULL, ""Type Object""); rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; rtps_util_add_type_library(typeobject_tree, pinfo, tvb, offset_tmp, encoding, member_length); offset += member_length; rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; rtps_util_add_type_id(typeobject_tree, tvb, offset_tmp, encoding, offset, -1, NULL, &type_id); if (type_mapping_object) type_mapping_object->type_id = type_id; offset = offset + member_length; long_number = tvb_get_guint32(tvb, offset, encoding); if ((long_number & PID_LIST_END) != PID_LIST_END) { expert_add_info_format(pinfo, typeobject_tree, &ei_rtps_parameter_value_invalid, ""This should be PID_LIST_END and it is not""); \ } }"
"static gboolean parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info) { union wtap_pseudo_header *pseudo_header = &phdr->pseudo_header; charline[TOSHIBA_LINE_LENGTH]; intnum_items_scanned; guintpkt_len; intpktnum, hr, min, sec, csec; charchannel[10], direction[10]; inti, hex_lines; guint8*pd; if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) { *err = file_error(fh, err_info); if (*err == 0) { *err = WTAP_ERR_SHORT_READ; } return FALSE; } num_items_scanned = sscanf(line, ""%9d] %2d:%2d:%2d.%9d %9s %9s"", &pktnum, &hr, &min, &sec, &csec, channel, direction); if (num_items_scanned != 7) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""toshiba: record header isn't valid""); return FALSE; } do { if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) { *err = file_error(fh, err_info); if (*err == 0) { *err = WTAP_ERR_SHORT_READ; } return FALSE; } line[16] = '\0'; } while (strcmp(line, ""OFFSET 0001-0203"") != 0); num_items_scanned = sscanf(line+64, ""LEN=%9u"", &pkt_len); if (num_items_scanned != 1) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""toshiba: OFFSET line doesn't have valid LEN item""); return FALSE; } if (pkt_len > WTAP_MAX_PACKET_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""toshiba: File has %u-byte packet, bigger than maximum of %u"", pkt_len, WTAP_MAX_PACKET_SIZE); return FALSE; } phdr->rec_type = REC_TYPE_PACKET; phdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN; phdr->ts.secs = hr * 3600 + min * 60 + sec; phdr->ts.nsecs = csec * 10000000; phdr->caplen = pkt_len; phdr->len = pkt_len; switch (channel[0]) { case 'B': phdr->pkt_encap = WTAP_ENCAP_ISDN; pseudo_header->isdn.uton = (direction[0] == 'T'); pseudo_header->isdn.channel = (guint8) strtol(&channel[1], NULL, 10); break; case 'D': phdr->pkt_encap = WTAP_ENCAP_ISDN; pseudo_header->isdn.uton = (direction[0] == 'T'); pseudo_header->isdn.channel = 0; break; default: phdr->pkt_encap = WTAP_ENCAP_ETHERNET; pseudo_header->eth.fcs_len = -1; break; } ws_buffer_assure_space(buf, pkt_len); pd = ws_buffer_start_ptr(buf); hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0); for (i = 0; i < hex_lines; i++) { if (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) { *err = file_error(fh, err_info); if (*err == 0) { *err = WTAP_ERR_SHORT_READ; } return FALSE; } if (!parse_single_hex_dump_line(line, pd, i * 16)) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""toshiba: hex dump not valid""); return FALSE; } } return TRUE; }"
"XID MitCheckCookie(unsigned short data_length, const char *data, ClientPtr client, const char **reason) { struct auth *auth; for (auth = mit_auth; auth; auth = auth->next) { if (data_length == auth->len && memcmp(data, auth->data, (int) data_length) == 0) return auth->id; } *reason = ""Invalid MIT-MAGIC-COOKIE-1 key""; return (XID) -1; }"
"static int atl2_probe(struct pci_dev *pdev, const struct pci_device_id *ent) { struct net_device *netdev; struct atl2_adapter *adapter; static int cards_found; unsigned long mmio_start; int mmio_len; int err; cards_found = 0; err = pci_enable_device(pdev); if (err) return err; if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) && pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) { printk(KERN_ERR ""atl2: No usable DMA configuration, aborting\n""); goto err_dma; } err = pci_request_regions(pdev, atl2_driver_name); if (err) goto err_pci_reg; pci_set_master(pdev); err = -ENOMEM; netdev = alloc_etherdev(sizeof(struct atl2_adapter)); if (!netdev) goto err_alloc_etherdev; SET_NETDEV_DEV(netdev, &pdev->dev); pci_set_drvdata(pdev, netdev); adapter = netdev_priv(netdev); adapter->netdev = netdev; adapter->pdev = pdev; adapter->hw.back = adapter; mmio_start = pci_resource_start(pdev, 0x0); mmio_len = pci_resource_len(pdev, 0x0); adapter->hw.mem_rang = (u32)mmio_len; adapter->hw.hw_addr = ioremap(mmio_start, mmio_len); if (!adapter->hw.hw_addr) { err = -EIO; goto err_ioremap; } atl2_setup_pcicmd(pdev); netdev->netdev_ops = &atl2_netdev_ops; netdev->ethtool_ops = &atl2_ethtool_ops; netdev->watchdog_timeo = 5 * HZ; strncpy(netdev->name, pci_name(pdev), sizeof(netdev->name) - 1); netdev->mem_start = mmio_start; netdev->mem_end = mmio_start + mmio_len; adapter->bd_number = cards_found; adapter->pci_using_64 = false; err = atl2_sw_init(adapter); if (err) goto err_sw_init; err = -EIO; netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX; netdev->features |= (NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX); atl2_phy_init(&adapter->hw); if (atl2_reset_hw(&adapter->hw)) { err = -EIO; goto err_reset; } atl2_read_mac_addr(&adapter->hw); memcpy(netdev->dev_addr, adapter->hw.mac_addr, netdev->addr_len); if (!is_valid_ether_addr(netdev->dev_addr)) { err = -EIO; goto err_eeprom; } atl2_check_options(adapter); setup_timer(&adapter->watchdog_timer, atl2_watchdog, (unsigned long)adapter); setup_timer(&adapter->phy_config_timer, atl2_phy_config, (unsigned long)adapter); INIT_WORK(&adapter->reset_task, atl2_reset_task); INIT_WORK(&adapter->link_chg_task, atl2_link_chg_task); strcpy(netdev->name, ""eth%d"");  err = register_netdev(netdev); if (err) goto err_register; netif_carrier_off(netdev); netif_stop_queue(netdev); cards_found++; return 0; err_reset: err_register: err_sw_init: err_eeprom: iounmap(adapter->hw.hw_addr); err_ioremap: free_netdev(netdev); err_alloc_etherdev: pci_release_regions(pdev); err_pci_reg: err_dma: pci_disable_device(pdev); return err; }"
"static void get_bitmap_glyph(ASS_Renderer *render_priv, GlyphInfo *info, ASS_Vector *pos, ASS_Vector *pos_o, ASS_DVector *offset, bool first, int flags) { if (!info->outline || info->symbol == '\n' || info->symbol == 0 || info->skip) { ass_cache_dec_ref(info->outline); return; } double m1[3][3], m2[3][3], m[3][3]; const ASS_Transform *tr = &info->transform; calc_transform_matrix(render_priv, info, m1); for (int i = 0; i < 3; i++) { m2[i][0] = m1[i][0] * tr->scale.x; m2[i][1] = m1[i][1] * tr->scale.y; m2[i][2] = m1[i][0] * tr->offset.x + m1[i][1] * tr->offset.y + m1[i][2]; } memcpy(m, m2, sizeof(m)); BitmapHashKey key; key.outline = info->outline; if (!quantize_transform(m, pos, offset, first, &key)) { ass_cache_dec_ref(info->outline); return; } info->bm = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv); if (!info->bm || !info->bm->buffer) { ass_cache_dec_ref(info->bm); info->bm = NULL; } *pos_o = *pos; OutlineHashKey ol_key; if (flags & FILTER_BORDER_STYLE_3) { if (!(flags & (FILTER_NONZERO_BORDER | FILTER_NONZERO_SHADOW))) return; ol_key.type = OUTLINE_BOX; double w = 64 * render_priv->border_scale; ASS_DVector bord = { info->border_x * w, info->border_y * w }; double width = info->hspacing_scaled + info->advance.x; double height = info->asc + info->desc; ASS_DVector orig_scale; orig_scale.x = info->scale_x * info->scale_fix; orig_scale.y = info->scale_y * info->scale_fix; bord.x *= orig_scale.x; bord.y *= orig_scale.y; width  *= orig_scale.x; height *= orig_scale.y; bord.x = FFMAX(64, bord.x); bord.y = FFMAX(64, bord.y); ASS_DVector scale = { (width  + 2 * bord.x) / 64, (height + 2 * bord.y) / 64, }; ASS_DVector offset = { -bord.x, -bord.y - info->asc }; for (int i = 0; i < 3; i++) { m[i][0] = m1[i][0] * scale.x; m[i][1] = m1[i][1] * scale.y; m[i][2] = m1[i][0] * offset.x + m1[i][1] * offset.y + m1[i][2]; } } else { if (!(flags & FILTER_NONZERO_BORDER)) return; ol_key.type = OUTLINE_BORDER; BorderHashKey *k = &ol_key.u.border; k->outline = info->outline; double w = 64 * render_priv->border_scale; double bord_x = w * info->border_x / tr->scale.x; double bord_y = w * info->border_y / tr->scale.y; const ASS_Rect *bbox = &info->outline->cbox; double dx = (bbox->x_max - bbox->x_min) / 2.0 + (bord_x + 64); double dy = (bbox->y_max - bbox->y_min) / 2.0 + (bord_y + 64); double mxx = fabs(m[0][0]), mxy = fabs(m[0][1]); double myx = fabs(m[1][0]), myy = fabs(m[1][1]); double mzx = fabs(m[2][0]), mzy = fabs(m[2][1]); double z0 = m[2][2] - mzx * dx - mzy * dy; w = 1 / FFMAX(z0, m[2][2] / MAX_PERSP_SCALE); double x_lim = mxx * dx + mxy * dy; double y_lim = myx * dx + myy * dy; double rz = FFMAX(x_lim, y_lim) * w; w *= STROKER_PRECISION / POSITION_PRECISION; frexp(w * (FFMAX(mxx, myx) + mzx * rz), &k->scale_ord_x); frexp(w * (FFMAX(mxy, myy) + mzy * rz), &k->scale_ord_y); k->border.x = lrint(ldexp(bord_x, k->scale_ord_x) / STROKER_PRECISION); k->border.y = lrint(ldexp(bord_y, k->scale_ord_y) / STROKER_PRECISION); if (!k->border.x && !k->border.y) { ass_cache_inc_ref(info->bm); info->bm_o = info->bm; return; } for (int i = 0; i < 3; i++) { m[i][0] = ldexp(m2[i][0], -k->scale_ord_x); m[i][1] = ldexp(m2[i][1], -k->scale_ord_y); m[i][2] = m2[i][2]; } } key.outline = ass_cache_get(render_priv->cache.outline_cache, &ol_key, render_priv); if (!key.outline || !key.outline->valid || !quantize_transform(m, pos_o, offset, false, &key)) { ass_cache_dec_ref(key.outline); return; } info->bm_o = ass_cache_get(render_priv->cache.bitmap_cache, &key, render_priv); if (!info->bm_o || !info->bm_o->buffer) { ass_cache_dec_ref(info->bm_o); info->bm_o = NULL; *pos_o = *pos; } else if (!info->bm) *pos = *pos_o; }"
"static int string_scan_range(RList *list, const ut8 *buf, int min, const ut64 from, const ut64 to, int type) { ut8 tmp[R_STRING_SCAN_BUFFER_SIZE]; ut64 str_start, needle = from; int count = 0, i, rc, runes; int str_type = R_STRING_TYPE_DETECT; if (type == -1) { type = R_STRING_TYPE_DETECT; } if (!buf || !min) { return -1; } while (needle < to) { rc = r_utf8_decode (buf + needle, to - needle, NULL); if (!rc) { needle++; continue; } if (type == R_STRING_TYPE_DETECT) { char *w = (char *)buf + needle + rc; if ((to - needle) > 4) { bool is_wide32 = needle + rc + 2 < to && !w[0] && !w[1] && !w[2] && w[3] && !w[4]; if (is_wide32) { str_type = R_STRING_TYPE_WIDE32; } else { bool is_wide = needle + rc + 2 < to && !w[0] && w[1] && !w[2]; str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII; } } else { str_type = R_STRING_TYPE_ASCII; } } else { str_type = type; } runes = 0; str_start = needle; for (rc = i = 0; i < sizeof (tmp) - 3 && needle < to; i += rc) { RRune r = {0}; if (str_type == R_STRING_TYPE_WIDE32) { rc = r_utf32le_decode (buf + needle, to - needle, &r); if (rc) { rc = 4; } } else if (str_type == R_STRING_TYPE_WIDE) { rc = r_utf16le_decode (buf + needle, to - needle, &r); if (rc == 1) { rc = 2; } } else { rc = r_utf8_decode (buf + needle, to - needle, &r); if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } } if (!rc) { needle++; break; } needle += rc; if (r_isprint (r)) { if (str_type == R_STRING_TYPE_WIDE32) { if (r == 0xff) { r = 0; } } rc = r_utf8_encode (&tmp[i], r); runes++; } else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\e"", (char)r)) { if ((i + 32) < sizeof (tmp) && r < 28) { tmp[i + 0] = '\\'; tmp[i + 1] = ""       abtnvfr             e""[r]; } else { break; } rc = 2; runes++; } else { break; } } tmp[i++] = '\0'; if (runes >= min) { if (str_type == R_STRING_TYPE_ASCII) { int j; for (j = 0; j < i; j++) { char ch = tmp[j]; if (ch != '\n' && ch != '\r' && ch != '\t') { if (!IS_PRINTABLE (tmp[j])) { continue; } } } } if (list) { RBinString *new = R_NEW0 (RBinString); if (!new) { break; } new->type = str_type; new->length = runes; new->size = needle - str_start; new->ordinal = count++; switch (str_type) { case R_STRING_TYPE_WIDE: { const ut8 *p = buf  + str_start - 2; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 2; } } break; case R_STRING_TYPE_WIDE32: { const ut8 *p = buf  + str_start - 4; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 4; } } break; } new->paddr = new->vaddr = str_start; new->string = r_str_ndup ((const char *)tmp, i); r_list_append (list, new); } else { printf (""0x%08"" PFMT64x "" %s\n"", str_start, tmp); } } } return count; }"
"static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; int ret; mutex_lock(&dev->lock); ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_CONFIG_LENGTH) { hid_err(hdev, ""error requesting GPIO config: %d\n"", ret); goto exit; } buf[1] &= ~(1 << offset); buf[2] = gpio_push_pull; ret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf, CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT, HID_REQ_SET_REPORT); if (ret < 0) { hid_err(hdev, ""error setting GPIO config: %d\n"", ret); goto exit; } ret = 0; exit: mutex_unlock(&dev->lock); return ret <= 0 ? ret : -EIO; }"
"static void hpet_set_timer(HPETState *h, unsigned int tn, uint64_t guest_time) { uint64_t tn_cmp, cur_tick, diff; unsigned int irq; unsigned int oneshot; ASSERT(tn < HPET_TIMER_NUM); ASSERT(rw_is_write_locked(&h->lock)); if ( (tn == 0) && (h->hpet.config & HPET_CFG_LEGACY) ) { pit_stop_channel0_irq(&vhpet_domain(h)->arch.vpit); } if ( !timer_enabled(h, tn) ) return; tn_cmp   = hpet_get_comparator(h, tn, guest_time); cur_tick = hpet_read_maincounter(h, guest_time); if ( timer_is_32bit(h, tn) ) { tn_cmp   = (uint32_t)tn_cmp; cur_tick = (uint32_t)cur_tick; } diff = tn_cmp - cur_tick; if ( (int64_t)diff < 0 ) diff = (timer_is_32bit(h, tn) && (-diff > HPET_TINY_TIME_SPAN)) ? (uint32_t)diff : 0; if ( (tn <= 1) && (h->hpet.config & HPET_CFG_LEGACY) ) irq = (tn == 0) ? 0 : 8; else irq = timer_int_route(h, tn); oneshot = !timer_is_periodic(h, tn); TRACE_2_LONG_4D(TRC_HVM_EMUL_HPET_START_TIMER, tn, irq, TRC_PAR_LONG(hpet_tick_to_ns(h, diff)), TRC_PAR_LONG(oneshot ? 0LL : hpet_tick_to_ns(h, h->hpet.period[tn]))); create_periodic_time(vhpet_vcpu(h), &h->pt[tn], hpet_tick_to_ns(h, diff), oneshot ? 0 : hpet_tick_to_ns(h, h->hpet.period[tn]), irq, NULL, NULL); }"
"int amf_namf_comm_handle_n1_n2_message_transfer( ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg) { int status; amf_ue_t *amf_ue = NULL; amf_sess_t *sess = NULL; ogs_pkbuf_t *n1buf = NULL; ogs_pkbuf_t *n2buf = NULL; ogs_pkbuf_t *gmmbuf = NULL; ogs_pkbuf_t *ngapbuf = NULL; char *supi = NULL; uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED; ogs_sbi_message_t sendmsg; ogs_sbi_response_t *response = NULL; OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData; OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData; OpenAPI_n1_message_container_t *n1MessageContainer = NULL; OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL; OpenAPI_n2_info_container_t *n2InfoContainer = NULL; OpenAPI_n2_sm_information_t *smInfo = NULL; OpenAPI_n2_info_content_t *n2InfoContent = NULL; OpenAPI_ref_to_binary_data_t *ngapData = NULL; ogs_assert(stream); ogs_assert(recvmsg); N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData; if (!N1N2MessageTransferReqData) { ogs_error(""No N1N2MessageTransferReqData""); return OGS_ERROR; } if (N1N2MessageTransferReqData->is_pdu_session_id == false) { ogs_error(""No PDU Session Identity""); return OGS_ERROR; } pdu_session_id = N1N2MessageTransferReqData->pdu_session_id; supi = recvmsg->h.resource.component[1]; if (!supi) { ogs_error(""No SUPI""); return OGS_ERROR; } amf_ue = amf_ue_find_by_supi(supi); if (!amf_ue) { ogs_error(""No UE context [%s]"", supi); return OGS_ERROR; } sess = amf_sess_find_by_psi(amf_ue, pdu_session_id); if (!sess) { ogs_error(""[%s] No PDU Session Context [%d]"", amf_ue->supi, pdu_session_id); return OGS_ERROR; } n1MessageContainer = N1N2MessageTransferReqData->n1_message_container; if (n1MessageContainer) { n1MessageContent = n1MessageContainer->n1_message_content; if (!n1MessageContent || !n1MessageContent->content_id) { ogs_error(""No n1MessageContent""); return OGS_ERROR; } n1buf = ogs_sbi_find_part_by_content_id( recvmsg, n1MessageContent->content_id); if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } n1buf = ogs_pkbuf_copy(n1buf); ogs_assert(n1buf); } n2InfoContainer = N1N2MessageTransferReqData->n2_info_container; if (n2InfoContainer) { smInfo = n2InfoContainer->sm_info; if (!smInfo) { ogs_error(""No smInfo""); return OGS_ERROR; } n2InfoContent = smInfo->n2_info_content; if (!n2InfoContent) { ogs_error(""No n2InfoContent""); return OGS_ERROR; } ngapData = n2InfoContent->ngap_data; if (!ngapData || !ngapData->content_id) { ogs_error(""No ngapData""); return OGS_ERROR; } n2buf = ogs_sbi_find_part_by_content_id( recvmsg, ngapData->content_id); if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } n2buf = ogs_pkbuf_copy(n2buf); ogs_assert(n2buf); } memset(&sendmsg, 0, sizeof(sendmsg)); status = OGS_SBI_HTTP_STATUS_OK; memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData)); N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED; sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData; switch (n2InfoContent->ngap_ie_type) { case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); } if (gmmbuf) { ran_ue_t *ran_ue = NULL; ran_ue = ran_ue_cycle(amf_ue->ran_ue); ogs_assert(ran_ue); if (sess->pdu_session_establishment_accept) { ogs_pkbuf_free(sess->pdu_session_establishment_accept); sess->pdu_session_establishment_accept = NULL; } if (ran_ue->initial_context_setup_request_sent == true) { ngapbuf = ngap_sess_build_pdu_session_resource_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); } else { ngapbuf = ngap_sess_build_initial_context_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); ran_ue->initial_context_setup_request_sent = true; } if (SESSION_CONTEXT_IN_SMF(sess)) { if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { sess->pdu_session_establishment_accept = ngapbuf; } } else { if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; ogs_sbi_client_t *client = NULL; ogs_sockaddr_t *addr = NULL; if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) { ogs_error(""[%s:%d] No n1-n2-failure-notification-uri"", amf_ue->supi, sess->psi); return OGS_ERROR; } addr = ogs_sbi_getaddr_from_uri( N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); if (!addr) { ogs_error(""[%s:%d] Invalid URI [%s]"", amf_ue->supi, sess->psi, N1N2MessageTransferReqData-> n1n2_failure_txf_notif_uri); return OGS_ERROR;; } client = ogs_sbi_client_find(addr); if (!client) { client = ogs_sbi_client_add(addr); ogs_assert(client); } OGS_SETUP_SBI_CLIENT(&sess->paging, client); ogs_freeaddrinfo(addr); status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); AMF_SESS_STORE_N2_TRANSFER( sess, pdu_session_resource_setup_request, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { ogs_assert(OGS_OK == ngap_send_pdu_resource_setup_request(sess, n2buf)); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } } break; case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ: if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, NULL); AMF_SESS_STORE_5GSM_MESSAGE(sess, OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND, n1buf, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); ngapbuf = ngap_build_pdu_session_resource_modify_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) ogs_pkbuf_free(n1buf); if (CM_IDLE(amf_ue)) { if (n2buf) ogs_pkbuf_free(n2buf); if (N1N2MessageTransferReqData->is_skip_ind == true && N1N2MessageTransferReqData->skip_ind == true) { N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED; } else { ogs_fatal(""[%s] No skipInd"", amf_ue->supi); ogs_assert_if_reached(); } } else if (CM_CONNECTED(amf_ue)) { ngapbuf = ngap_build_pdu_session_resource_release_command( sess, NULL, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; default: ogs_error(""Not implemented ngap_ie_type[%d]"", n2InfoContent->ngap_ie_type); ogs_assert_if_reached(); } response = ogs_sbi_build_response(&sendmsg, status); ogs_assert(response); ogs_assert(true == ogs_sbi_server_send_response(stream, response)); if (sendmsg.http.location) ogs_free(sendmsg.http.location); return OGS_OK; }"
"static int check_chain_extensions(X509_STORE_CTX *ctx) { int i, must_be_ca, plen = 0; X509 *x; int proxy_path_length = 0; int purpose; int allow_proxy_certs; int num = sk_X509_num(ctx->chain); must_be_ca = -1; if (ctx->parent) { allow_proxy_certs = 0; purpose = X509_PURPOSE_CRL_SIGN; } else { allow_proxy_certs = ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS); purpose = ctx->param->purpose; } for (i = 0; i < num; i++) { int ret; x = sk_X509_value(ctx->chain, i); if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL) && (x->ex_flags & EXFLAG_CRITICAL)) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION)) return 0; } if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED)) return 0; } ret = X509_check_ca(x); switch (must_be_ca) { case -1: if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && (ret != 1) && (ret != 0)) { ret = 0; ctx->error = X509_V_ERR_INVALID_CA; } else ret = 1; break; case 0: if (ret != 0) { ret = 0; ctx->error = X509_V_ERR_INVALID_NON_CA; } else ret = 1; break; default: if ((ret == 0) || ((i + 1 < num || ctx->param->flags & X509_V_FLAG_X509_STRICT) && (ret != 1))) { ret = 0; ctx->error = X509_V_ERR_INVALID_CA; } else ret = 1; break; } if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) { ret = check_curve(x); if (ret < 0) ctx->error = X509_V_ERR_UNSPECIFIED; else if (ret == 0) ctx->error = X509_V_ERR_EC_KEY_EXPLICIT_PARAMS; } if ((x->ex_flags & EXFLAG_CA) == 0 && x->ex_pathlen != -1 && (ctx->param->flags & X509_V_FLAG_X509_STRICT)) { ctx->error = X509_V_ERR_INVALID_EXTENSION; ret = 0; } if (ret == 0 && !verify_cb_cert(ctx, x, i, X509_V_OK)) return 0; if (purpose > 0 && !check_purpose(ctx, x, purpose, i, must_be_ca)) return 0; if ((i > 1) && (x->ex_pathlen != -1) && (plen > (x->ex_pathlen + proxy_path_length))) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PATH_LENGTH_EXCEEDED)) return 0; } if (i > 0 && (x->ex_flags & EXFLAG_SI) == 0) plen++; if (x->ex_flags & EXFLAG_PROXY) { if (x->ex_pcpathlen != -1) { if (proxy_path_length > x->ex_pcpathlen) { if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED)) return 0; } proxy_path_length = x->ex_pcpathlen; } proxy_path_length++; must_be_ca = 0; } else must_be_ca = 1; } return 1; }"
"int main(int argc, char *argv[]) { struct libmnt_table *tb = NULL; char **tabfiles = NULL; int direction = MNT_ITER_FORWARD; int verify = 0; int c, rc = -1, timeout = -1; int ntabfiles = 0, tabtype = 0; char *outarg = NULL; size_t i; int force_tree = 0, istree = 0; struct libscols_table *table = NULL; enum { FINDMNT_OPT_VERBOSE = CHAR_MAX + 1, FINDMNT_OPT_TREE, FINDMNT_OPT_OUTPUT_ALL, FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL, FINDMNT_OPT_VFS_ALL, FINDMNT_OPT_SHADOWED, FINDMNT_OPT_DELETED, }; static const struct option longopts[] = { { ""all"",    no_argument,       NULL, 'A' }, { ""ascii"",    no_argument,       NULL, 'a' }, { ""bytes"",    no_argument,       NULL, 'b' }, { ""canonicalize"",   no_argument,       NULL, 'c' }, { ""deleted"",        no_argument,       NULL, FINDMNT_OPT_DELETED }, { ""direction"",    required_argument, NULL, 'd' }, { ""df"",    no_argument,       NULL, 'D' }, { ""evaluate"",    no_argument,       NULL, 'e' }, { ""first-only"",    no_argument,       NULL, 'f' }, { ""fstab"",    no_argument,       NULL, 's' }, { ""help"",    no_argument,       NULL, 'h' }, { ""invert"",    no_argument,       NULL, 'i' }, { ""json"",    no_argument,       NULL, 'J' }, { ""kernel"",    no_argument,       NULL, 'k' }, { ""list"",    no_argument,       NULL, 'l' }, { ""mountpoint"",    required_argument, NULL, 'M' }, { ""mtab"",    no_argument,       NULL, 'm' }, { ""noheadings"",    no_argument,       NULL, 'n' }, { ""notruncate"",    no_argument,       NULL, 'u' }, { ""options"",    required_argument, NULL, 'O' }, { ""output"",    required_argument, NULL, 'o' }, { ""output-all"",    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL }, { ""poll"",    optional_argument, NULL, 'p' }, { ""pairs"",    no_argument,       NULL, 'P' }, { ""raw"",    no_argument,       NULL, 'r' }, { ""types"",    required_argument, NULL, 't' }, { ""nocanonicalize"", no_argument,       NULL, 'C' }, { ""nofsroot"",    no_argument,       NULL, 'v' }, { ""submounts"",    no_argument,       NULL, 'R' }, { ""source"",    required_argument, NULL, 'S' }, { ""tab-file"",    required_argument, NULL, 'F' }, { ""task"",    required_argument, NULL, 'N' }, { ""target"",    required_argument, NULL, 'T' }, { ""timeout"",    required_argument, NULL, 'w' }, { ""uniq"",    no_argument,       NULL, 'U' }, { ""verify"",    no_argument,       NULL, 'x' }, { ""version"",    no_argument,       NULL, 'V' }, { ""verbose"",    no_argument,       NULL, FINDMNT_OPT_VERBOSE }, { ""tree"",    no_argument,       NULL, FINDMNT_OPT_TREE }, { ""real"",    no_argument,       NULL, FINDMNT_OPT_REAL }, { ""pseudo"",    no_argument,       NULL, FINDMNT_OPT_PSEUDO }, { ""vfs-all"",    no_argument,       NULL, FINDMNT_OPT_VFS_ALL }, { ""shadowed"",       no_argument,       NULL, FINDMNT_OPT_SHADOWED }, { NULL, 0, NULL, 0 } }; static const ul_excl_t excl[] = { { 'C', 'c'}, { 'C', 'e' }, { 'J', 'P', 'r','x' }, { 'M', 'T' }, { 'N','k','m','s' }, { 'P','l','r','x' }, { 'p','x' }, { 'm','p','s' }, { FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL }, { 0 } }; int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT; setlocale(LC_ALL, """"); bindtextdomain(PACKAGE, LOCALEDIR); textdomain(PACKAGE); close_stdout_atexit(); flags |= FL_TREE; while ((c = getopt_long(argc, argv, ""AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx"", longopts, NULL)) != -1) { err_exclusive_options(c, longopts, excl, excl_st); switch(c) { case 'A': flags |= FL_ALL; break; case 'a': flags |= FL_ASCII; break; case 'b': flags |= FL_BYTES; break; case 'C': flags |= FL_NOCACHE; break; case 'c': flags |= FL_CANONICALIZE; break; case 'D': flags &= ~FL_TREE; flags |= FL_DF; break; case 'd': if (!strcmp(optarg, ""forward"")) direction = MNT_ITER_FORWARD; else if (!strcmp(optarg, ""backward"")) direction = MNT_ITER_BACKWARD; else errx(EXIT_FAILURE, _(""unknown direction '%s'""), optarg); break; case 'e': flags |= FL_EVALUATE; break; case 'i': flags |= FL_INVERT; break; case 'J': flags |= FL_JSON; break; case 'f': flags |= FL_FIRSTONLY; break; case 'F': tabfiles = append_tabfile(tabfiles, &ntabfiles, optarg); break; case 'u': disable_columns_truncate(); break; case 'o': outarg = optarg; break; case FINDMNT_OPT_OUTPUT_ALL: for (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) { if (is_tabdiff_column(ncolumns)) continue; columns[ncolumns] = ncolumns; } break; case 'O': set_match(COL_OPTIONS, optarg); break; case 'p': if (optarg) { nactions = string_to_idarray(optarg, actions, ARRAY_SIZE(actions), poll_action_name_to_id); if (nactions < 0) exit(EXIT_FAILURE); } flags |= FL_POLL; flags &= ~FL_TREE; break; case 'P': flags |= FL_EXPORT; flags &= ~FL_TREE; break; case 'm': tabtype = TABTYPE_MTAB; flags &= ~FL_TREE; break; case 's': tabtype = TABTYPE_FSTAB; flags &= ~FL_TREE; break; case 'k': tabtype = TABTYPE_KERNEL; break; case 't': set_match(COL_FSTYPE, optarg); break; case 'r': flags &= ~FL_TREE; flags |= FL_RAW; break; case 'l': flags &= ~FL_TREE; break; case 'n': flags |= FL_NOHEADINGS; break; case 'N': tabtype = TABTYPE_KERNEL; tabfiles = append_pid_tabfile(tabfiles, &ntabfiles, strtou32_or_err(optarg, _(""invalid TID argument""))); break; case 'v': flags |= FL_NOFSROOT; break; case 'R': flags |= FL_SUBMOUNTS; break; case 'S': set_source_match(optarg); flags |= FL_NOSWAPMATCH; break; case 'M': flags |= FL_STRICTTARGET; case 'T': set_match(COL_TARGET, optarg); flags |= FL_NOSWAPMATCH; break; case 'U': flags |= FL_UNIQ; break; case 'w': timeout = strtos32_or_err(optarg, _(""invalid timeout argument"")); break; case 'x': verify = 1; break; case FINDMNT_OPT_VERBOSE: flags |= FL_VERBOSE; break; case FINDMNT_OPT_TREE: force_tree = 1; break; case FINDMNT_OPT_PSEUDO: flags |= FL_PSEUDO; break; case FINDMNT_OPT_REAL: flags |= FL_REAL; break; case FINDMNT_OPT_VFS_ALL: flags |= FL_VFS_ALL; break; case FINDMNT_OPT_SHADOWED: flags |= FL_SHADOWED; break; case FINDMNT_OPT_DELETED: flags |= FL_DELETED; break; case 'h': usage(); case 'V': print_version(EXIT_SUCCESS); default: errtryhelp(EXIT_FAILURE); } } if (!ncolumns && (flags & FL_DF)) { add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_SIZE); add_column(columns, ncolumns++, COL_USED); add_column(columns, ncolumns++, COL_AVAIL); add_column(columns, ncolumns++, COL_USEPERC); add_column(columns, ncolumns++, COL_TARGET); } if (!ncolumns) { if (flags & FL_POLL) add_column(columns, ncolumns++, COL_ACTION); add_column(columns, ncolumns++, COL_TARGET); add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_OPTIONS); } if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns), &ncolumns, column_name_to_id) < 0) return EXIT_FAILURE; if (!tabtype) tabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL; if ((flags & FL_POLL) && ntabfiles > 1) errx(EXIT_FAILURE, _(""--poll accepts only one file, but more specified by --tab-file"")); if (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET))) errx(EXIT_FAILURE, _( ""options --target and --source can't be used together "" ""with command line element that is not an option"")); if (optind < argc) set_source_match(argv[optind++]); if (optind < argc) set_match(COL_TARGET, argv[optind++]); if ((flags & FL_SUBMOUNTS) && is_listall_mode()) flags &= ~FL_SUBMOUNTS; if (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY) || get_match(COL_TARGET) || get_match(COL_SOURCE) || get_match(COL_MAJMIN))) flags &= ~FL_TREE; if (!(flags & FL_NOSWAPMATCH) && !get_match(COL_TARGET) && get_match(COL_SOURCE)) { const char *x = get_match(COL_SOURCE); if (!strncmp(x, ""LABEL="", 6) || !strncmp(x, ""UUID="", 5) || !strncmp(x, ""PARTLABEL="", 10) || !strncmp(x, ""PARTUUID="", 9)) flags |= FL_NOSWAPMATCH; } mnt_init_debug(0); tb = parse_tabfiles(tabfiles, ntabfiles, tabtype); if (!tb) goto leave; if (tabtype == TABTYPE_MTAB && tab_is_kernel(tb)) tabtype = TABTYPE_KERNEL; istree = tab_is_tree(tb); if (istree && force_tree) flags |= FL_TREE; if ((flags & FL_TREE) && (ntabfiles > 1 || !istree)) flags &= ~FL_TREE; if (!(flags & FL_NOCACHE)) { cache = mnt_new_cache(); if (!cache) { warn(_(""failed to initialize libmount cache"")); goto leave; } mnt_table_set_cache(tb, cache); if (tabtype != TABTYPE_KERNEL) cache_set_targets(cache); } if (flags & FL_UNIQ) mnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp); if (verify) { rc = verify_table(tb); goto leave; } scols_init_debug(0); table = scols_new_table(); if (!table) { warn(_(""failed to allocate output table"")); goto leave; } scols_table_enable_raw(table,        !!(flags & FL_RAW)); scols_table_enable_export(table,     !!(flags & FL_EXPORT)); scols_table_enable_json(table,       !!(flags & FL_JSON)); scols_table_enable_ascii(table,      !!(flags & FL_ASCII)); scols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS)); if (flags & FL_JSON) scols_table_set_name(table, ""filesystems""); for (i = 0; i < ncolumns; i++) { struct libscols_column *cl; int fl = get_column_flags(i); int id = get_column_id(i); if (!(flags & FL_TREE)) fl &= ~SCOLS_FL_TREE; if (!(flags & FL_POLL) && is_tabdiff_column(id)) { warnx(_(""%s column is requested, but --poll "" ""is not enabled""), get_column_name(i)); goto leave; } cl = scols_table_new_column(table, get_column_name(i), get_column_whint(i), fl); if (!cl){ warn(_(""failed to allocate output column"")); goto leave; } if (fl & SCOLS_FL_WRAP) { scols_column_set_wrapfunc(cl, scols_wrapnl_chunksize, scols_wrapnl_nextchunk, NULL); scols_column_set_safechars(cl, ""\n""); } if (flags & FL_JSON) { switch (id) { case COL_SIZE: case COL_AVAIL: case COL_USED: if (!(flags & FL_BYTES)) break; case COL_ID: case COL_PARENT: case COL_FREQ: case COL_PASSNO: case COL_TID: scols_column_set_json_type(cl, SCOLS_JSON_NUMBER); break; case COL_DELETED: scols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN); break; default: if (fl & SCOLS_FL_WRAP) scols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING); else scols_column_set_json_type(cl, SCOLS_JSON_STRING); break; } } } if (flags & FL_POLL) { rc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction); } else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) { rc = create_treenode(table, tb, NULL, NULL); } else { rc = add_matching_lines(tb, table, direction); if (rc != 0 && tabtype == TABTYPE_KERNEL && (flags & FL_NOSWAPMATCH) && !(flags & FL_STRICTTARGET) && get_match(COL_TARGET)) { enable_extra_target_match(tb); rc = add_matching_lines(tb, table, direction); } } if (!rc && !(flags & FL_POLL)) scols_print_table(table); leave: scols_unref_table(table); mnt_unref_table(tb); mnt_unref_cache(cache); free(tabfiles); #ifdef HAVE_LIBUDEV udev_unref(udev); #endif return rc ? EXIT_FAILURE : EXIT_SUCCESS; }"
"NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId, size_t* pcbAvPairListRemaining) { size_t cbAvPair = cbAvPairList; NTLM_AV_PAIR* pAvPair = pAvPairList; if (!ntlm_av_pair_check(pAvPair, cbAvPair)) pAvPair = NULL; while (pAvPair) { UINT16 id = ntlm_av_pair_get_id(pAvPair); if (id == AvId) break; if (id == MsvAvEOL) { pAvPair = NULL; break; } pAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair); } if (!pAvPair) cbAvPair = 0; if (pcbAvPairListRemaining) *pcbAvPairListRemaining = cbAvPair; return pAvPair; }"
"static int php_zip_parse_options(zval *options, long *remove_all_path,  char **remove_path, int *remove_path_len, char **add_path, int *add_path_len TSRMLS_DC)  { zval **option; if (zend_hash_find(HASH_OF(options), ""remove_all_path"", sizeof(""remove_all_path""), (void **)&option) == SUCCESS) { long opt; if (Z_TYPE_PP(option) != IS_LONG) { zval tmp = **option; zval_copy_ctor(&tmp); convert_to_long(&tmp); opt = Z_LVAL(tmp); } else { opt = Z_LVAL_PP(option); } *remove_all_path = opt; } if (zend_hash_find(HASH_OF(options), ""remove_path"", sizeof(""remove_path""), (void **)&option) == SUCCESS) { if (Z_TYPE_PP(option) != IS_STRING) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""remove_path option expected to be a string""); return -1; } if (Z_STRLEN_PP(option) < 1) { php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Empty string given as remove_path option""); return -1; } if (Z_STRLEN_PP(option) >= MAXPATHLEN) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""remove_path string is too long (max: %i, %i given)"",  MAXPATHLEN - 1, Z_STRLEN_PP(option)); return -1; } *remove_path_len = Z_STRLEN_PP(option);  *remove_path = Z_STRVAL_PP(option); } if (zend_hash_find(HASH_OF(options), ""add_path"", sizeof(""add_path""), (void **)&option) == SUCCESS) { if (Z_TYPE_PP(option) != IS_STRING) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""add_path option expected to be a string""); return -1; } if (Z_STRLEN_PP(option) < 1) { php_error_docref(NULL TSRMLS_CC, E_NOTICE, ""Empty string given as the add_path option""); return -1; } if (Z_STRLEN_PP(option) >= MAXPATHLEN) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""add_path string too long (max: %i, %i given)"",  MAXPATHLEN - 1, Z_STRLEN_PP(option)); return -1; } *add_path_len = Z_STRLEN_PP(option);  *add_path = Z_STRVAL_PP(option); } return 1; }"
"kadm5_ret_t kadm5_create_principal_3(void *server_handle, kadm5_principal_ent_t entry, long mask, int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char *password) { krb5_db_entry               *kdb; osa_princ_ent_rec           adb; kadm5_policy_ent_rec        polent; krb5_boolean                have_polent = FALSE; krb5_int32                  now; krb5_tl_data                *tl_data_tail; unsigned int                ret; kadm5_server_handle_t handle = server_handle; krb5_keyblock               *act_mkey; krb5_kvno                   act_kvno; int                         new_n_ks_tuple = 0; krb5_key_salt_tuple         *new_ks_tuple = NULL; CHECK_HANDLE(server_handle); krb5_clear_error_message(handle->context); check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password); if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) || (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) || (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) || (mask & KADM5_FAIL_AUTH_COUNT)) return KADM5_BAD_MASK; if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0) return KADM5_BAD_MASK; if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR)) return KADM5_BAD_MASK; if((mask & ~ALL_PRINC_MASK)) return KADM5_BAD_MASK; if (entry == NULL) return EINVAL; ret = kdb_get_entry(handle, entry->principal, &kdb, &adb); switch(ret) { case KADM5_UNK_PRINC: break; case 0: kdb_free_entry(handle, kdb, &adb); return KADM5_DUP; default: return ret; } kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb)); if (kdb == NULL) return ENOMEM; memset(kdb, 0, sizeof(*kdb)); memset(&adb, 0, sizeof(osa_princ_ent_rec)); if ((mask & KADM5_POLICY)) { ret = get_policy(handle, entry->policy, &polent, &have_polent); if (ret) goto cleanup; } if (password) { ret = passwd_check(handle, password, have_polent ? &polent : NULL, entry->principal); if (ret) goto cleanup; } if ((ret = krb5_timeofday(handle->context, &now))) goto cleanup; kdb->magic = KRB5_KDB_MAGIC_NUMBER; kdb->len = KRB5_KDB_V1_BASE_LENGTH;  if ((mask & KADM5_ATTRIBUTES)) kdb->attributes = entry->attributes; else kdb->attributes = handle->params.flags; if ((mask & KADM5_MAX_LIFE)) kdb->max_life = entry->max_life; else kdb->max_life = handle->params.max_life; if (mask & KADM5_MAX_RLIFE) kdb->max_renewable_life = entry->max_renewable_life; else kdb->max_renewable_life = handle->params.max_rlife; if ((mask & KADM5_PRINC_EXPIRE_TIME)) kdb->expiration = entry->princ_expire_time; else kdb->expiration = handle->params.expiration; kdb->pw_expiration = 0; if (have_polent) { if(polent.pw_max_life) kdb->pw_expiration = now + polent.pw_max_life; else kdb->pw_expiration = 0; } if ((mask & KADM5_PW_EXPIRATION)) kdb->pw_expiration = entry->pw_expiration; kdb->last_success = 0; kdb->last_failed = 0; kdb->fail_auth_count = 0; if ((ret = kadm5_copy_principal(handle->context, entry->principal, &(kdb->princ)))) goto cleanup; if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now))) goto cleanup; if (mask & KADM5_TL_DATA) { for (tl_data_tail = entry->tl_data; tl_data_tail; tl_data_tail = tl_data_tail->tl_data_next) { ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail); if( ret ) goto cleanup; } } ret = apply_keysalt_policy(handle, entry->policy, n_ks_tuple, ks_tuple, &new_n_ks_tuple, &new_ks_tuple); if (ret) goto cleanup; ret = kdb_get_active_mkey(handle, &act_kvno, &act_mkey); if (ret) goto cleanup; if (mask & KADM5_KEY_DATA) { assert(entry->n_key_data == 0); } else if (password) { ret = krb5_dbe_cpw(handle->context, act_mkey, new_ks_tuple, new_n_ks_tuple, password, (mask & KADM5_KVNO)?entry->kvno:1, FALSE, kdb); } else { ret = krb5_dbe_crk(handle->context, &master_keyblock, new_ks_tuple, new_n_ks_tuple, FALSE, kdb); } if (ret) goto cleanup; ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno); if (ret) goto cleanup; ret = k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); if (ret) goto cleanup; adb.admin_history_kvno = INITIAL_HIST_KVNO; if (mask & KADM5_POLICY) { adb.aux_attributes = KADM5_POLICY; adb.policy = entry->policy; } kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry(handle, kdb, &adb); (void) k5_kadm5_hook_create(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask, new_n_ks_tuple, new_ks_tuple, password); cleanup: free(new_ks_tuple); krb5_db_free_principal(handle->context, kdb); if (have_polent) (void) kadm5_free_policy_ent(handle->lhandle, &polent); return ret; }"
"void* __iotc_calloc(size_t num, size_t byte_count) { const size_t size_to_allocate = num * byte_count; void* ret = iotc_bsp_mem_alloc(size_to_allocate); if (NULL != ret) { memset(ret, 0, size_to_allocate); } return ret; }"
"static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data) { int rv; ssize_t size; sgwc_event_t *e = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_pfcp_node_t *node = NULL; ogs_pfcp_header_t *h = NULL; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recvfrom() failed""); ogs_pkbuf_free(pkbuf); return; } ogs_pkbuf_trim(pkbuf, size); h = (ogs_pfcp_header_t *)pkbuf->data; if (h->version > OGS_PFCP_VERSION) { ogs_pfcp_header_t rsp; ogs_error(""Not supported version[%d]"", h->version); memset(&rsp, 0, sizeof rsp); rsp.flags = (OGS_PFCP_VERSION << 5); rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE; rsp.length = htobe16(4); rsp.sqn_only = h->sqn_only; if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(pkbuf); return; } e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE); ogs_assert(e); node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from); if (!node) { node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from); ogs_assert(node); node->sock = data; pfcp_node_fsm_init(node, false); } e->pfcp_node = node; e->pkbuf = pkbuf; rv = ogs_queue_push(ogs_app()->queue, e); if (rv != OGS_OK) { ogs_error(""ogs_queue_push() failed:%d"", (int)rv); ogs_pkbuf_free(e->pkbuf); sgwc_event_free(e); } }"
void  RBaseStream::skip( int bytes ) { assert( bytes >= 0 ); m_current += bytes; }
