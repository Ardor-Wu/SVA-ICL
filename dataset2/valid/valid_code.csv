"int DefaultCertValidator::initializeSslContexts(std::vector<SSL_CTX*> contexts, bool provides_certificates) { int verify_mode = SSL_VERIFY_NONE; int verify_mode_validation_context = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT; if (config_ != nullptr) { envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext:: TrustChainVerification verification = config_->trustChainVerification(); if (verification == envoy::extensions::transport_sockets::tls::v3:: CertificateValidationContext::ACCEPT_UNTRUSTED) { verify_mode = SSL_VERIFY_PEER;                                            verify_mode_validation_context = SSL_VERIFY_PEER; } } if (config_ != nullptr && !config_->caCert().empty() && !provides_certificates) { ca_file_path_ = config_->caCertPath(); bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->caCert().data()), config_->caCert().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); bool has_crl = false; for (const X509_INFO* item : list.get()) { if (item->x509) { X509_STORE_add_cert(store, item->x509); if (ca_cert_ == nullptr) { X509_up_ref(item->x509); ca_cert_.reset(item->x509); } } if (item->crl) { X509_STORE_add_crl(store, item->crl); has_crl = true; } } if (ca_cert_ == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load trusted CA certificates from "", config_->caCertPath())); } if (has_crl) { X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } verify_mode = SSL_VERIFY_PEER; verify_trusted_ca_ = true; if (config_->allowExpiredCertificate()) { X509_STORE_set_verify_cb(store, CertValidatorUtil::ignoreCertificateExpirationCallback); } } } if (config_ != nullptr && !config_->certificateRevocationList().empty()) { bssl::UniquePtr<BIO> bio( BIO_new_mem_buf(const_cast<char*>(config_->certificateRevocationList().data()), config_->certificateRevocationList().size())); RELEASE_ASSERT(bio != nullptr, """"); bssl::UniquePtr<STACK_OF(X509_INFO)> list( PEM_X509_INFO_read_bio(bio.get(), nullptr, nullptr, nullptr)); if (list == nullptr) { throw EnvoyException( absl::StrCat(""Failed to load CRL from "", config_->certificateRevocationListPath())); } for (auto& ctx : contexts) { X509_STORE* store = SSL_CTX_get_cert_store(ctx); for (const X509_INFO* item : list.get()) { if (item->crl) { X509_STORE_add_crl(store, item->crl); } } X509_STORE_set_flags(store, config_->onlyVerifyLeafCertificateCrl() ? X509_V_FLAG_CRL_CHECK : X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL); } } const Envoy::Ssl::CertificateValidationContextConfig* cert_validation_config = config_; if (cert_validation_config != nullptr) { if (!cert_validation_config->subjectAltNameMatchers().empty()) { for (const envoy::type::matcher::v3::StringMatcher& matcher : cert_validation_config->subjectAltNameMatchers()) { subject_alt_name_matchers_.push_back(Matchers::StringMatcherImpl(matcher)); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateHashList().empty()) { for (auto hash : cert_validation_config->verifyCertificateHashList()) { if (hash.size() == 95) { hash.erase(std::remove(hash.begin(), hash.end(), ':'), hash.end()); } const auto& decoded = Hex::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid hex-encoded SHA-256 "", hash)); } verify_certificate_hash_list_.push_back(decoded); } verify_mode = verify_mode_validation_context; } if (!cert_validation_config->verifyCertificateSpkiList().empty()) { for (const auto& hash : cert_validation_config->verifyCertificateSpkiList()) { const auto decoded = Base64::decode(hash); if (decoded.size() != SHA256_DIGEST_LENGTH) { throw EnvoyException(absl::StrCat(""Invalid base64-encoded SHA-256 "", hash)); } verify_certificate_spki_list_.emplace_back(decoded.begin(), decoded.end()); } verify_mode = verify_mode_validation_context; } } return verify_mode; }"
"static int rtsx_usb_ms_drv_probe(struct platform_device *pdev) { struct memstick_host *msh; struct rtsx_usb_ms *host; struct rtsx_ucr *ucr; int err; ucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent)); if (!ucr) return -ENXIO; dev_dbg(&(pdev->dev), ""Realtek USB Memstick controller found\n""); msh = memstick_alloc_host(sizeof(*host), &pdev->dev); if (!msh) return -ENOMEM; host = memstick_priv(msh); host->ucr = ucr; host->msh = msh; host->pdev = pdev; host->power_mode = MEMSTICK_POWER_OFF; platform_set_drvdata(pdev, host); mutex_init(&host->host_mutex); INIT_WORK(&host->handle_req, rtsx_usb_ms_handle_req); INIT_DELAYED_WORK(&host->poll_card, rtsx_usb_ms_poll_card); msh->request = rtsx_usb_ms_request; msh->set_param = rtsx_usb_ms_set_param; msh->caps = MEMSTICK_CAP_PAR4; pm_runtime_get_noresume(ms_dev(host)); pm_runtime_set_active(ms_dev(host)); pm_runtime_enable(ms_dev(host)); err = memstick_add_host(msh); if (err) goto err_out; pm_runtime_put(ms_dev(host)); return 0; err_out: memstick_free_host(msh); pm_runtime_disable(ms_dev(host)); pm_runtime_put_noidle(ms_dev(host)); return err; }"
"static int get_entries(struct net *net, struct arpt_get_entries __user *uptr, const int *len) { int ret; struct arpt_get_entries get; struct xt_table *t; if (*len < sizeof(get)) return -EINVAL; if (copy_from_user(&get, uptr, sizeof(get)) != 0) return -EFAULT; if (*len != sizeof(struct arpt_get_entries) + get.size) return -EINVAL; get.name[sizeof(get.name) - 1] = '\0'; t = xt_find_table_lock(net, NFPROTO_ARP, get.name); if (!IS_ERR(t)) { const struct xt_table_info *private = t->private; if (get.size == private->size) ret = copy_entries_to_user(private->size, t, uptr->entrytable); else ret = -EAGAIN; module_put(t->me); xt_table_unlock(t); } else ret = PTR_ERR(t); return ret; }"
"Jsi_RC Jsi_GetIntFromValueBase(Jsi_Interp* interp, Jsi_Value *value, int *n, int base, int flags) { int noMsg = (flags & JSI_NO_ERRMSG); if (!value) return JSI_ERROR; Jsi_Number d = Jsi_ValueToNumberInt(interp, value, 1); if (!Jsi_NumberIsFinite(d)) { if (!noMsg) Jsi_LogError(""invalid number""); return JSI_ERROR; } Jsi_ValueReset(interp,&value); Jsi_ValueMakeNumber(interp, &value, d); *n = (int)d; return JSI_OK; }"
"static BT_HDR *create_pbuf(UINT16 len, UINT8 *data) { BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR))); if (p_buf) { UINT8* pbuf_data; p_buf->len = len; p_buf->offset = BTA_HH_MIN_OFFSET; pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset; memcpy(pbuf_data, data, len); } return p_buf; }"
"static proto_item * _proto_tree_add_bits_ret_val(proto_tree *tree, const int hfindex, tvbuff_t *tvb, const guint bit_offset, const gint no_of_bits, guint64 *return_value, const guint encoding) { gint     offset; guint    length; guint8   tot_no_bits; char    *bf_str; char     lbl_str[ITEM_LABEL_LENGTH]; guint64  value = 0; guint8  *bytes = NULL; size_t bytes_length = 0; proto_item        *pi; header_field_info *hf_field; const true_false_string *tfstring; PROTO_REGISTRAR_GET_NTH(hfindex, hf_field); if (hf_field->bitmask != 0) { REPORT_DISSECTOR_BUG(""Incompatible use of proto_tree_add_bits_ret_val"" "" with field '%s' (%s) with bitmask != 0"", hf_field->abbrev, hf_field->name); } if (no_of_bits == 0) { REPORT_DISSECTOR_BUG(""field %s passed to proto_tree_add_bits_ret_val() has a bit width of 0"", hf_field->abbrev); } offset = bit_offset>>3; tot_no_bits = ((bit_offset&0x7) + no_of_bits); length = (tot_no_bits + 7) >> 3; if (no_of_bits < 65) { value = tvb_get_bits64(tvb, bit_offset, no_of_bits, encoding); } else if (hf_field->type != FT_BYTES) { REPORT_DISSECTOR_BUG(""field %s passed to proto_tree_add_bits_ret_val() has a bit width of %u > 65"", hf_field->abbrev, no_of_bits); return NULL; } switch (hf_field->type) { case FT_INT8: case FT_INT16: case FT_INT24: case FT_INT32: case FT_INT40: case FT_INT48: case FT_INT56: case FT_INT64: value = ws_sign_ext64(value, no_of_bits); break; default: break; } if (return_value) { *return_value = value; } CHECK_FOR_NULL_TREE(tree); TRY_TO_FAKE_THIS_ITEM(tree, hfindex, hf_field); bf_str = decode_bits_in_field(bit_offset, no_of_bits, value); switch (hf_field->type) { case FT_BOOLEAN: tfstring = &tfs_true_false; if (hf_field->strings) tfstring = (const true_false_string *)hf_field->strings; return proto_tree_add_boolean_format(tree, hfindex, tvb, offset, length, (guint32)value, ""%s = %s: %s"", bf_str, hf_field->name, tfs_get_string(!!value, tfstring)); break; case FT_CHAR: pi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value); fill_label_char(PITEM_FINFO(pi), lbl_str); break; case FT_UINT8: case FT_UINT16: case FT_UINT24: case FT_UINT32: pi = proto_tree_add_uint(tree, hfindex, tvb, offset, length, (guint32)value); fill_label_number(PITEM_FINFO(pi), lbl_str, FALSE); break; case FT_INT8: case FT_INT16: case FT_INT24: case FT_INT32: pi = proto_tree_add_int(tree, hfindex, tvb, offset, length, (gint32)value); fill_label_number(PITEM_FINFO(pi), lbl_str, TRUE); break; case FT_UINT40: case FT_UINT48: case FT_UINT56: case FT_UINT64: pi = proto_tree_add_uint64(tree, hfindex, tvb, offset, length, value); fill_label_number64(PITEM_FINFO(pi), lbl_str, FALSE); break; case FT_INT40: case FT_INT48: case FT_INT56: case FT_INT64: pi = proto_tree_add_int64(tree, hfindex, tvb, offset, length, (gint64)value); fill_label_number64(PITEM_FINFO(pi), lbl_str, TRUE); break; case FT_BYTES: bytes = tvb_get_bits_array(NULL, tvb, bit_offset, no_of_bits, &bytes_length); pi = proto_tree_add_bytes_with_length(tree, hfindex, tvb, offset, length, bytes, (gint) bytes_length); proto_item_fill_label(PITEM_FINFO(pi), lbl_str); proto_item_set_text(pi, ""%s"", lbl_str); return pi; break; default: REPORT_DISSECTOR_BUG(""field %s has type %d (%s) not handled in proto_tree_add_bits_ret_val()"", hf_field->abbrev, hf_field->type, ftype_name(hf_field->type)); return NULL; break; } proto_item_set_text(pi, ""%s = %s"", bf_str, lbl_str); return pi; }"
"void Gfx::go(GBool topLevel) { Object obj; Object args[maxArgs]; int numArgs, i; int lastAbortCheck; updateLevel = lastAbortCheck = 0; numArgs = 0; parser->getObj(&obj); while (!obj.isEOF()) { if (obj.isCmd()) { if (printCommands) { obj.print(stdout); for (i = 0; i < numArgs; ++i) { printf("" ""); args[i].print(stdout); } printf(""\n""); fflush(stdout); } GooTimer timer; execOp(&obj, args, numArgs); if (profileCommands) { GooHash *hash; hash = out->getProfileHash (); if (hash) { GooString *cmd_g; ProfileData *data_p; cmd_g = new GooString (obj.getCmd()); data_p = (ProfileData *)hash->lookup (cmd_g); if (data_p == NULL) { data_p = new ProfileData(); hash->add (cmd_g, data_p); } data_p->addElement(timer.getElapsed ()); } } obj.free(); for (i = 0; i < numArgs; ++i) args[i].free(); numArgs = 0; if (++updateLevel >= 20000) { out->dump(); updateLevel = 0; } if (abortCheckCbk) { if (updateLevel - lastAbortCheck > 10) { if ((*abortCheckCbk)(abortCheckCbkData)) { break; } lastAbortCheck = updateLevel; } } } else if (numArgs < maxArgs) { args[numArgs++] = obj; } else { error(getPos(), ""Too many args in content stream""); if (printCommands) { printf(""throwing away arg: ""); obj.print(stdout); printf(""\n""); fflush(stdout); } obj.free(); } parser->getObj(&obj); } obj.free(); if (numArgs > 0) { error(getPos(), ""Leftover args in content stream""); if (printCommands) { printf(""%d leftovers:"", numArgs); for (i = 0; i < numArgs; ++i) { printf("" ""); args[i].print(stdout); } printf(""\n""); fflush(stdout); } for (i = 0; i < numArgs; ++i) args[i].free(); } if (topLevel && updateLevel > 0) { out->dump(); } }"
"int ReplaceThumbnail(const char * ThumbFileName) { FILE * ThumbnailFile; int ThumbLen, NewExifSize; Section_t * ExifSection; uchar * ThumbnailPointer; if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){ if (ThumbFileName == NULL){ return FALSE; } fprintf(stderr,""Image contains no thumbnail to replace - add is not possible\n""); return FALSE; } if (ThumbFileName){ ThumbnailFile = fopen(ThumbFileName,""rb""); if (ThumbnailFile == NULL){ noread: ErrFatal(""Could not read thumbnail file""); return FALSE; } fseek(ThumbnailFile, 0, SEEK_END); ThumbLen = ftell(ThumbnailFile); fseek(ThumbnailFile, 0, SEEK_SET); if (ThumbLen + ImageInfo.ThumbnailOffset > 0x10000-20){ ErrFatal(""Thumbnail is too large to insert into exif header""); } }else{ if (ImageInfo.ThumbnailSize == 0){ return FALSE; } ThumbLen = 0; ThumbnailFile = NULL; } ExifSection = FindSection(M_EXIF); NewExifSize = ImageInfo.ThumbnailOffset+8+ThumbLen; ExifSection->Data = (uchar *)realloc(ExifSection->Data, NewExifSize); ThumbnailPointer = ExifSection->Data+ImageInfo.ThumbnailOffset+8; if (ThumbnailFile){ if (fread(ThumbnailPointer, 1, ThumbLen, ThumbnailFile) != ThumbLen){ goto noread; } fclose(ThumbnailFile); } ImageInfo.ThumbnailSize = ThumbLen; Put32u(ExifSection->Data+ImageInfo.ThumbnailSizeOffset+8, ThumbLen); ExifSection->Data[0] = (uchar)(NewExifSize >> 8); ExifSection->Data[1] = (uchar)NewExifSize; ExifSection->Size = NewExifSize; return TRUE; }"
"MagickExport MagickBooleanType AnnotateImage(Image *image, const DrawInfo *draw_info,ExceptionInfo *exception) { char *p, primitive[MagickPathExtent], *text, **textlist; DrawInfo *annotate, *annotate_info; GeometryInfo geometry_info; MagickBooleanType status; PointInfo offset; RectangleInfo geometry; register ssize_t i; TypeMetric metrics; size_t height, number_lines; assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(draw_info != (DrawInfo *) NULL); assert(draw_info->signature == MagickCoreSignature); if (draw_info->text == (char *) NULL) return(MagickFalse); if (*draw_info->text == '\0') return(MagickTrue); annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info); text=annotate->text; annotate->text=(char *) NULL; annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); number_lines=1; for (p=text; *p != '\0'; p++) if (*p == '\n') number_lines++; textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist)); if (textlist == (char **) NULL) { annotate_info=DestroyDrawInfo(annotate_info); annotate=DestroyDrawInfo(annotate); return(MagickFalse); } p=text; for (i=0; i < number_lines; i++) { char *q; textlist[i]=p; for (q=p; *q != '\0'; q++) if ((*q == '\r') || (*q == '\n')) break; if (*q == '\r') { *q='\0'; q++; } *q='\0'; p=q+1; } textlist[i]=(char *) NULL; SetGeometry(image,&geometry); SetGeometryInfo(&geometry_info); if (annotate_info->geometry != (char *) NULL) { (void) ParsePageGeometry(image,annotate_info->geometry,&geometry, exception); (void) ParseGeometry(annotate_info->geometry,&geometry_info); } if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) { annotate_info=DestroyDrawInfo(annotate_info); annotate=DestroyDrawInfo(annotate); textlist=(char **) RelinquishMagickMemory(textlist); return(MagickFalse); } if (IsGrayColorspace(image->colorspace) != MagickFalse) (void) SetImageColorspace(image,sRGBColorspace,exception); status=MagickTrue; (void) memset(&metrics,0,sizeof(metrics)); for (i=0; textlist[i] != (char *) NULL; i++) { if (*textlist[i] == '\0') continue; annotate_info->affine.tx=geometry_info.xi-image->page.x; annotate_info->affine.ty=geometry_info.psi-image->page.y; (void) CloneString(&annotate->text,textlist[i]); if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity)) (void) GetTypeMetrics(image,annotate,&metrics,exception); height=(ssize_t) (metrics.ascent-metrics.descent+ draw_info->interline_spacing+0.5); switch (annotate->gravity) { case UndefinedGravity: default: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height; break; } case NorthWestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height+annotate_info->affine.ry* (metrics.ascent+metrics.descent); offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent; break; } case NorthGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry* (metrics.ascent+metrics.descent); offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent-annotate_info->affine.rx*metrics.width/2.0; break; } case NorthEastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width+annotate_info->affine.ry* (metrics.ascent+metrics.descent)-1.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent-annotate_info->affine.rx*metrics.width; break; } case WestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height+annotate_info->affine.ry* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height+ annotate_info->affine.sy*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0; break; } case CenterGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; break; } case EastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width+ annotate_info->affine.ry*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0-1.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width+ annotate_info->affine.sy*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0; break; } case SouthWestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height-annotate_info->affine.ry* (number_lines-1.0)*height; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } case SouthGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0- annotate_info->affine.ry*(number_lines-1.0)*height/2.0; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } case SouthEastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width- annotate_info->affine.ry*(number_lines-1.0)*height-1.0; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } } switch (annotate->align) { case LeftAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height; break; } case CenterAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0; break; } case RightAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width; break; } default: break; } if (draw_info->undercolor.alpha != TransparentAlpha) { DrawInfo *undercolor_info; undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL); undercolor_info->fill=draw_info->undercolor; undercolor_info->affine=draw_info->affine; undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent; undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent; (void) FormatLocaleString(primitive,MagickPathExtent, ""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height); (void) CloneString(&undercolor_info->primitive,primitive); (void) DrawImage(image,undercolor_info,exception); (void) DestroyDrawInfo(undercolor_info); } annotate_info->affine.tx=offset.x; annotate_info->affine.ty=offset.y; (void) FormatLocaleString(primitive,MagickPathExtent,""stroke-width %g "" ""line 0,0 %g,0"",metrics.underline_thickness,metrics.width); if (annotate->decorate == OverlineDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+ metrics.descent-metrics.underline_position)); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } else if (annotate->decorate == UnderlineDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy* metrics.underline_position); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } status=RenderType(image,annotate,&offset,&metrics,exception); if (status == MagickFalse) break; if (annotate->decorate == LineThroughDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy*(height+ metrics.underline_position+metrics.descent)/2.0); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } } annotate_info=DestroyDrawInfo(annotate_info); annotate=DestroyDrawInfo(annotate); textlist=(char **) RelinquishMagickMemory(textlist); return(status); }"
"static void dissect_q931_IEs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *root_tree, proto_tree *q931_tree, gboolean is_over_ip, int offset, int initial_codeset) { proto_item  *ti; proto_tree  *ie_tree = NULL; guint8      info_element; guint8      dummy; guint16     info_element_len; int         codeset, locked_codeset; gboolean    non_locking_shift, first_segment; tvbuff_t    *h225_tvb, *next_tvb; e164_info_t e164_info; e164_info.e164_number_type = NONE; e164_info.nature_of_address = NONE; e164_info.E164_number_str = """"; e164_info.E164_number_length = NONE; codeset = locked_codeset = initial_codeset; first_segment = FALSE; while (tvb_reported_length_remaining(tvb, offset) > 0) { info_element = tvb_get_guint8(tvb, offset); if ((info_element & Q931_IE_SO_MASK) && ((info_element & Q931_IE_SO_IDENTIFIER_MASK) == Q931_IE_SHIFT)) { non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING; codeset = info_element & Q931_IE_SHIFT_CODESET; if (!non_locking_shift) locked_codeset = codeset; if (q931_tree != NULL) { proto_tree_add_uint_format(q931_tree, hf_q931_locking_codeset, tvb, offset, 1, codeset, ""%s shift to codeset %u: %s"", (non_locking_shift ? ""Non-locking"" : ""Locking""), codeset, val_to_str(codeset, q931_codeset_vals, ""Unknown (0x%02X)"")); } offset += 1; continue; } if (info_element & Q931_IE_SO_MASK) { if (dissector_get_uint_handle(codeset_dissector_table, codeset) || dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK))) { next_tvb = tvb_new_subset_length (tvb, offset, 1); if (dissector_try_uint(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK), next_tvb, pinfo, q931_tree) || dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) { offset += 1; codeset = locked_codeset; continue; } } switch ((codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK)) { case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP: switch (info_element) { case Q931_IE_MORE_DATA: proto_tree_add_item(q931_tree, hf_q931_more_data, tvb, offset, 1, ENC_NA); break; case Q931_IE_SENDING_COMPLETE: proto_tree_add_item(q931_tree, hf_q931_sending_complete, tvb, offset, 1, ENC_NA); break; default: proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1, ""Unknown information element (0x%02X)"", info_element); break; } break; case CS0 | Q931_IE_CONGESTION_LEVEL: proto_tree_add_item(q931_tree, hf_q931_congestion_level, tvb, offset, 1, ENC_BIG_ENDIAN); break; case CS0 | Q931_IE_REPEAT_INDICATOR: proto_tree_add_item(q931_tree, hf_q931_repeat_indicator, tvb, offset, 1, ENC_BIG_ENDIAN); break; default: proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1, ""Unknown information element (0x%02X)"", info_element); break; } offset += 1; codeset = locked_codeset; continue; } if (is_over_ip && tvb_bytes_exist(tvb, offset, 4) && codeset == 0 && tvb_get_guint8(tvb, offset) == Q931_IE_USER_USER && tvb_get_guint8(tvb, offset + 3) == Q931_PROTOCOL_DISCRIMINATOR_ASN1)  { info_element_len = tvb_get_ntohs(tvb, offset + 1); if (q931_tree != NULL) { ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset, 1+2+info_element_len, ett_q931_ie[info_element], NULL, val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown information element (0x%02X)"")); proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, ""%s"", val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown (0x%02X)"")); proto_tree_add_item(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN); proto_tree_add_item(ie_tree, hf_q931_user_protocol_discriminator, tvb, offset + 3, 1, ENC_NA); } if (info_element_len > 1) { if (!pinfo->can_desegment) { info_element_len = MIN(info_element_len, tvb_captured_length_remaining(tvb, offset + 3)); } if (h225_handle != NULL) { h225_tvb = tvb_new_subset_length(tvb, offset + 4, info_element_len - 1); call_dissector(h225_handle, h225_tvb, pinfo, root_tree); } else { proto_tree_add_item(ie_tree, hf_q931_user_information_bytes, tvb, offset + 4, info_element_len - 1, ENC_NA); } } offset += 1 + 2 + info_element_len; } else { info_element_len = tvb_get_guint8(tvb, offset + 1); if (first_segment && (tvb_reported_length_remaining(tvb, offset + 2) < info_element_len)) {   proto_tree_add_expert(q931_tree, pinfo, &ei_q931_incomplete_ie, tvb, offset, -1); break; } if (dissector_get_uint_handle(codeset_dissector_table, codeset) || dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | info_element)) { next_tvb = tvb_new_subset_length (tvb, offset, info_element_len + 2); if (dissector_try_uint(ie_dissector_table, (codeset << 8) | info_element, next_tvb, pinfo, q931_tree) || dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) { offset += 2 + info_element_len; codeset = locked_codeset; continue; } } ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset, 1+1+info_element_len, ett_q931_ie[info_element], &ti, val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown information element (0x%02X)"")); proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, ""%s"", val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown (0x%02X)"")); proto_tree_add_uint(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 1, info_element_len); if (((codeset << 8) | info_element) == (CS0 | Q931_IE_SEGMENTED_MESSAGE)) { dissect_q931_segmented_message_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); col_append_fstr(pinfo->cinfo, COL_INFO, "" of %s"", val_to_str_ext(tvb_get_guint8(tvb, offset + 3), &q931_message_type_vals_ext, ""Unknown message type (0x%02X)"")); if (tvb_get_guint8(tvb, offset + 2) & 0x80) {   first_segment = TRUE; } else {   proto_tree_add_item(q931_tree, hf_q931_message_segment, tvb, offset + 4, -1, ENC_NA); info_element_len += tvb_reported_length_remaining(tvb, offset + 4); } } else { switch ((codeset << 8) | info_element) { case CS0 | Q931_IE_BEARER_CAPABILITY: case CS0 | Q931_IE_LOW_LAYER_COMPAT: if (q931_tree != NULL) { dissect_q931_bearer_capability_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CAUSE: dissect_q931_cause_ie_unsafe(tvb, offset + 2, info_element_len, ie_tree, hf_q931_cause_value, &dummy, q931_info_element_vals0); break; case CS0 | Q931_IE_CHANGE_STATUS: if (q931_tree != NULL) { dissect_q931_change_status_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CALL_STATE: if (q931_tree != NULL) { dissect_q931_call_state_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CHANNEL_IDENTIFICATION: if (q931_tree != NULL) { dissect_q931_channel_identification_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PROGRESS_INDICATOR: if (q931_tree != NULL) { dissect_q931_progress_indicator_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL: case CS0 | Q931_IE_TRANSIT_NETWORK_SEL: if (q931_tree != NULL) { dissect_q931_ns_facilities_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_NOTIFICATION_INDICATOR: if (q931_tree != NULL) { dissect_q931_notification_indicator_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_DISPLAY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_display_information); } break; case CS0 | Q931_IE_DATE_TIME: dissect_q931_date_time_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree); break; case CS0 | Q931_IE_KEYPAD_FACILITY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_keypad_facility); } break; case CS0 | Q931_IE_SIGNAL: dissect_q931_signal_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_INFORMATION_RATE: dissect_q931_information_rate_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_E2E_TRANSIT_DELAY: dissect_q931_e2e_transit_delay_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_TD_SELECTION_AND_INT: dissect_q931_td_selection_and_int_ie( tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_PL_BINARY_PARAMETERS: if (q931_tree != NULL) { dissect_q931_pl_binary_parameters_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PL_WINDOW_SIZE: if (q931_tree != NULL) { dissect_q931_pl_window_size_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PACKET_SIZE: if (q931_tree != NULL) { dissect_q931_packet_size_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CUG: if (q931_tree != NULL) { dissect_q931_cug_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_REVERSE_CHARGE_IND: if (q931_tree != NULL) { dissect_q931_reverse_charge_ind_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT: if (q931_tree != NULL) { dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_connected_number, e164_info); } break; case CS0 | Q931_IE_CALLING_PARTY_NUMBER: e164_info.e164_number_type = CALLING_PARTY_NUMBER; dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_calling_party_number, e164_info); break; case CS0 | Q931_IE_CALLED_PARTY_NUMBER: e164_info.e164_number_type = CALLED_PARTY_NUMBER; dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_called_party_number, e164_info); break; case CS0 | Q931_IE_CALLING_PARTY_SUBADDR: case CS0 | Q931_IE_CALLED_PARTY_SUBADDR: if (q931_tree != NULL) { dissect_q931_party_subaddr_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_REDIRECTING_NUMBER: if (q931_tree != NULL) { dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_redirecting_number, e164_info); } break; case CS0 | Q931_IE_RESTART_INDICATOR: dissect_q931_restart_indicator_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_HIGH_LAYER_COMPAT: if (q931_tree != NULL) { dissect_q931_high_layer_compat_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_USER_USER: if (q931_tree != NULL) { dissect_q931_user_user_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree); } break; case CS5 | Q931_IE_PARTY_CATEGORY: if (q931_tree != NULL) { dissect_q931_party_category_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS6 | Q931_IE_DISPLAY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_avaya_display); } break; default: if (q931_tree != NULL) { proto_tree_add_item(ie_tree, hf_q931_data, tvb, offset + 2, info_element_len, ENC_NA); } break; } } offset += 1 + 1 + info_element_len; } codeset = locked_codeset; } if(have_valid_q931_pi) { tap_queue_packet(q931_tap, pinfo, q931_pi); } have_valid_q931_pi=FALSE; }"
"TypedValue HHVM_FUNCTION(substr_compare, const String& main_str, const String& str, int offset, int length , bool case_insensitivity ) { int s1_len = main_str.size(); int s2_len = str.size(); if (length <= 0) { raise_warning(""The length must be greater than zero""); return make_tv<KindOfBoolean>(false); } if (offset < 0) { offset = s1_len + offset; if (offset < 0) offset = 0; } if (offset >= s1_len) { raise_warning(""The start position cannot exceed initial string length""); return make_tv<KindOfBoolean>(false); } int cmp_len = s1_len - offset; if (cmp_len < s2_len) cmp_len = s2_len; if (cmp_len > length) cmp_len = length; const char *s1 = main_str.data(); if (case_insensitivity) { return tvReturn(bstrcasecmp(s1 + offset, cmp_len, str.data(), cmp_len)); } return tvReturn(string_ncmp(s1 + offset, str.data(), cmp_len)); }"
"int hugetlb_mcopy_atomic_pte(struct mm_struct *dst_mm, pte_t *dst_pte, struct vm_area_struct *dst_vma, unsigned long dst_addr, unsigned long src_addr, struct page **pagep) { int vm_shared = dst_vma->vm_flags & VM_SHARED; struct hstate *h = hstate_vma(dst_vma); pte_t _dst_pte; spinlock_t *ptl; int ret; struct page *page; if (!*pagep) { ret = -ENOMEM; page = alloc_huge_page(dst_vma, dst_addr, 0); if (IS_ERR(page)) goto out; ret = copy_huge_page_from_user(page, (const void __user *) src_addr, pages_per_huge_page(h), false); if (unlikely(ret)) { ret = -EFAULT; *pagep = page; goto out; } } else { page = *pagep; *pagep = NULL; } __SetPageUptodate(page); set_page_huge_active(page); if (vm_shared) { struct address_space *mapping = dst_vma->vm_file->f_mapping; pgoff_t idx = vma_hugecache_offset(h, dst_vma, dst_addr); ret = huge_add_to_page_cache(page, mapping, idx); if (ret) goto out_release_nounlock; } ptl = huge_pte_lockptr(h, dst_mm, dst_pte); spin_lock(ptl); ret = -EEXIST; if (!huge_pte_none(huge_ptep_get(dst_pte))) goto out_release_unlock; if (vm_shared) { page_dup_rmap(page, true); } else { ClearPagePrivate(page); hugepage_add_new_anon_rmap(page, dst_vma, dst_addr); } _dst_pte = make_huge_pte(dst_vma, page, dst_vma->vm_flags & VM_WRITE); if (dst_vma->vm_flags & VM_WRITE) _dst_pte = huge_pte_mkdirty(_dst_pte); _dst_pte = pte_mkyoung(_dst_pte); set_huge_pte_at(dst_mm, dst_addr, dst_pte, _dst_pte); (void)huge_ptep_set_access_flags(dst_vma, dst_addr, dst_pte, _dst_pte, dst_vma->vm_flags & VM_WRITE); hugetlb_count_add(pages_per_huge_page(h), dst_mm); update_mmu_cache(dst_vma, dst_addr, dst_pte); spin_unlock(ptl); if (vm_shared) unlock_page(page); ret = 0; out: return ret; out_release_unlock: spin_unlock(ptl); if (vm_shared) unlock_page(page); out_release_nounlock: put_page(page); goto out; }"
"static int sendMessageEnet(short ptype, short paylen, const void* payload) { PNVCTL_ENET_PACKET_HEADER packet; ENetPacket* enetPacket; ENetEvent event; int err; LC_ASSERT(ServerMajorVersion >= 5); if (peer == NULL) { return 0; } packet = malloc(sizeof(*packet) + paylen); if (packet == NULL) { return 0; } packet->type = ptype; memcpy(&packet[1], payload, paylen); while ((err = serviceEnetHost(client, &event, 0)) > 0) { if (event.type == ENET_EVENT_TYPE_RECEIVE) { enet_packet_destroy(event.packet); } else if (event.type == ENET_EVENT_TYPE_DISCONNECT) { Limelog(""Control stream received disconnect event\n""); free(packet); return 0; } } if (err < 0) { Limelog(""Control stream connection failed\n""); return 0; } enetPacket = enet_packet_create(packet, sizeof(*packet) + paylen, ENET_PACKET_FLAG_RELIABLE); if (packet == NULL) { free(packet); return 0; } if (enet_peer_send(peer, 0, enetPacket) < 0) { Limelog(""Failed to send ENet control packet\n""); enet_packet_destroy(enetPacket); free(packet); return 0; } enet_host_flush(client); free(packet); return 1; }"
"bool ATSParser::PSISection::isCRCOkay() const { if (!isComplete()) { return false; } uint8_t* data = mBuffer->data(); if ((data[1] & 0x80) == 0) { return true; } unsigned sectionLength = U16_AT(data + 1) & 0xfff; ALOGV(""sectionLength %u, skip %u"", sectionLength, mSkipBytes); sectionLength -= mSkipBytes; uint32_t crc = 0xffffffff; for(unsigned i = 0; i < sectionLength + 4 ; i++) { uint8_t b = data[i]; int index = ((crc >> 24) ^ (b & 0xff)) & 0xff; crc = CRC_TABLE[index] ^ (crc << 8); } ALOGV(""crc: %08x\n"", crc); return (crc == 0); }"
"int process_netbios_name(const guchar *name_ptr, char *name_ret, int name_ret_len) { int    i; int    name_type = *(name_ptr + NETBIOS_NAME_LEN - 1); guchar name_char; static const char hex_digits[16] = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'}; for (i = 0; i < NETBIOS_NAME_LEN - 1; i++) { name_char = *name_ptr++; if (name_char >= ' ' && name_char <= '~') { if (--name_ret_len > 0) *name_ret++ = name_char; } else { if (--name_ret_len > 0) *name_ret++ = '<'; if (--name_ret_len > 0) *name_ret++ = hex_digits[(name_char >> 4)]; if (--name_ret_len > 0) *name_ret++ = hex_digits[(name_char & 0x0F)]; if (--name_ret_len > 0) *name_ret++ = '>'; } } *name_ret = '\0'; name_ret--; for (i = 0; i < NETBIOS_NAME_LEN - 1; i++) { if (*name_ret != ' ') { *(name_ret + 1) = 0; break; } name_ret--; } return name_type; }"
"void getvcol( win_T*wp, pos_T*pos, colnr_T*start, colnr_T*cursor, colnr_T*end) { colnr_Tvcol; char_u*ptr;    char_u*posptr;    char_u*line;    intincr; inthead; #ifdef FEAT_VARTABS int*vts = wp->w_buffer->b_p_vts_array; #endif intts = wp->w_buffer->b_p_ts; intc; vcol = 0; line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE); if (pos->col == MAXCOL) posptr = NULL;      else { if (*ptr == NUL) pos->col = 0; posptr = ptr + pos->col; if (has_mbyte) posptr -= (*mb_head_off)(line, posptr); } if ((!wp->w_p_list || wp->w_lcs_chars.tab1 != NUL) #ifdef FEAT_LINEBREAK && !wp->w_p_lbr && *get_showbreak_value(wp) == NUL && !wp->w_p_bri #endif ) { for (;;) { head = 0; c = *ptr; if (c == NUL) { incr = 1;break; } if (c == TAB) #ifdef FEAT_VARTABS incr = tabstop_padding(vcol, ts, vts); #else incr = ts - (vcol % ts); #endif else { if (has_mbyte) { if (enc_utf8 && c >= 0x80) incr = utf_ptr2cells(ptr); else incr = g_chartab[c] & CT_CELL_MASK; if (incr == 2 && wp->w_p_wrap && MB_BYTE2LEN(*ptr) > 1 && in_win_border(wp, vcol)) { ++incr; head = 1; } } else incr = g_chartab[c] & CT_CELL_MASK; } if (posptr != NULL && ptr >= posptr) break; vcol += incr; MB_PTR_ADV(ptr); } } else { for (;;) { head = 0; incr = win_lbr_chartabsize(wp, line, ptr, vcol, &head); if (*ptr == NUL) { incr = 1;break; } if (posptr != NULL && ptr >= posptr) break; vcol += incr; MB_PTR_ADV(ptr); } } if (start != NULL) *start = vcol + head; if (end != NULL) *end = vcol + incr - 1; if (cursor != NULL) { if (*ptr == TAB && (State & NORMAL) && !wp->w_p_list && !virtual_active() && !(VIsual_active && (*p_sel == 'e' || LTOREQ_POS(*pos, VIsual))) ) *cursor = vcol + incr - 1;    else *cursor = vcol + head;        } }"
"static guint dissect_llrp_impinj_parameter(tvbuff_t *tvb, packet_info *pinfo, proto_tree *param_tree, guint suboffset, const guint param_end) { guint32 subtype; subtype = tvb_get_ntohl(tvb, suboffset); proto_item_append_text(param_tree, "" (Impinj - %s)"", val_to_str_ext(subtype, &impinj_param_type_ext, ""Unknown Type: %d"")); proto_tree_add_item(param_tree, hf_llrp_impinj_param_type, tvb, suboffset, 4, ENC_BIG_ENDIAN); suboffset += 4; switch(subtype) { case LLRP_IMPINJ_PARAM_TAG_INFORMATION: case LLRP_IMPINJ_PARAM_FORKLIFT_CONFIGURATION: case LLRP_IMPINJ_PARAM_ACCESS_SPEC_CONFIGURATION: case LLRP_IMPINJ_PARAM_TAG_REPORT_CONTENT_SELECTOR: case LLRP_IMPINJ_PARAM_GPS_NMEA_SENTENCES: case LLRP_IMPINJ_PARAM_HUB_VERSIONS: break; case LLRP_IMPINJ_PARAM_REQUESTED_DATA: PARAM_TREE_ADD(impinj_req_data, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_SUBREGULATORY_REGION: PARAM_TREE_ADD(impinj_reg_region, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_INVENTORY_SEARCH_MODE: PARAM_TREE_ADD(impinj_search_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_TAG_DIRECTION_REPORTING: PARAM_TREE_ADD(impinj_en_tag_dir, 2, ENC_NA); PARAM_TREE_ADD(impinj_antenna_conf, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(rfu, 4, ENC_NA); break; case LLRP_IMPINJ_PARAM_TAG_DIRECTION: PARAM_TREE_ADD(decision_time, 8, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_tag_dir, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(confidence, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_FIXED_FREQUENCY_LIST: PARAM_TREE_ADD(impinj_fix_freq_mode, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(rfu, 2, ENC_NA); suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree, hf_llrp_num_channels, hf_llrp_channel, 2, suboffset); break; case LLRP_IMPINJ_PARAM_REDUCED_POWER_FREQUENCY_LIST: PARAM_TREE_ADD(impinj_reduce_power_mode, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(rfu, 2, ENC_NA); suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree, hf_llrp_num_channels, hf_llrp_channel, 2, suboffset); break; case LLRP_IMPINJ_PARAM_LOW_DUTY_CYCLE: PARAM_TREE_ADD(impinj_low_duty_mode, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(empty_field_timeout, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(field_ping_interval, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_DETAILED_VERSION: suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_model_name, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_soft_ver, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_fpga_ver, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset); break; case LLRP_IMPINJ_PARAM_FREQUENCY_CAPABILITIES: suboffset = dissect_llrp_item_array(tvb, pinfo, param_tree, hf_llrp_num_freqs, hf_llrp_frequency, 4, suboffset); break; case LLRP_IMPINJ_PARAM_FORKLIFT_HEIGHT_THRESHOLD: PARAM_TREE_ADD(height_thresh, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_FORKLIFT_ZEROMOTION_TIME_THRESHOLD: PARAM_TREE_ADD(zero_motion_thresh, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_FORKLIFT_COMPANION_BOARD_INFO: suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_board_manufacturer, suboffset); PARAM_TREE_ADD(fw_ver_hex, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(hw_ver_hex, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GPI_DEBOUNCE_CONFIGURATION: PARAM_TREE_ADD(gpi_port, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(gpi_debounce, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_READER_TEMPERATURE: PARAM_TREE_ADD(temperature, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_LINK_MONITOR_CONFIGURATION: PARAM_TREE_ADD(impinj_link_monitor_mode, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(link_down_thresh, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_REPORT_BUFFER_CONFIGURATION: PARAM_TREE_ADD(impinj_report_buff_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_BLOCK_WRITE_WORD_COUNT: PARAM_TREE_ADD(word_count, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK: PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN); PARAM_TREE_ADD(mb, 1, ENC_NA); PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(block_mask, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_BLOCK_PERMALOCK_OPSPEC_RESULT: PARAM_TREE_ADD(permalock_result, 1, ENC_NA); PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS: PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN); PARAM_TREE_ADD(mb, 1, ENC_NA); PARAM_TREE_ADD(block_pointer, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(block_range, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GET_BLOCK_PERMALOCK_STATUS_OPSPEC_RESULT: PARAM_TREE_ADD(block_permalock_result, 1, ENC_NA); PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_SET_QT_CONFIG: PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA); PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA); PARAM_TREE_ADD(impinj_persistence, 1, ENC_NA); PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_SET_QT_CONFIG_OPSPEC_RESULT: PARAM_TREE_ADD(set_qt_config_result, 1, ENC_NA); PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GET_QT_CONFIG: PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(access_pass, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GET_QT_CONFIG_OPSPEC_RESULT: PARAM_TREE_ADD(get_qt_config_result, 1, ENC_NA); PARAM_TREE_ADD(opspec_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_data_profile, 1, ENC_NA); PARAM_TREE_ADD(impinj_access_range, 1, ENC_NA); PARAM_TREE_ADD(rfu, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_SERIALIZED_TID: PARAM_TREE_ADD(impinj_serialized_tid_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_RF_PHASE_ANGLE: PARAM_TREE_ADD(impinj_rf_phase_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_PEAK_RSSI: PARAM_TREE_ADD(impinj_peak_rssi_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_GPS_COORDINATES: PARAM_TREE_ADD(impinj_gps_coordinates_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_SERIALIZED_TID: PARAM_TREE_ADD(impinj_tid, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_RF_PHASE_ANGLE: PARAM_TREE_ADD(phase_angle, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_PEAK_RSSI: PARAM_TREE_ADD(rssi, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GPS_COORDINATES: PARAM_TREE_ADD(latitude, 4, ENC_BIG_ENDIAN); PARAM_TREE_ADD(longitude, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_LOOP_SPEC: PARAM_TREE_ADD(loop_count, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_GGA_SENTENCE: suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_gga_sentence, suboffset); break; case LLRP_IMPINJ_PARAM_RMC_SENTENCE: suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_rmc_sentence, suboffset); break; case LLRP_IMPINJ_PARAM_OPSPEC_RETRY_COUNT: PARAM_TREE_ADD(retry_count, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ADVANCE_GPO_CONFIG: PARAM_TREE_ADD(gpo_port, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_gpo_mode, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(gpo_pulse_dur, 4, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_OPTIM_READ: PARAM_TREE_ADD(impinj_optim_read_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ACCESS_SPEC_ORDERING: PARAM_TREE_ADD(impinj_access_spec_ordering, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ENABLE_RF_DOPPLER_FREQ: PARAM_TREE_ADD(impinj_rf_doppler_mode, 2, ENC_BIG_ENDIAN); break; case LLRP_IMPINJ_PARAM_ARRAY_VERSION: suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_serial_number, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_firm_ver, suboffset); suboffset = dissect_llrp_utf8_parameter(tvb, pinfo, param_tree, hf_llrp_pcba_ver, suboffset); break; case LLRP_IMPINJ_PARAM_HUB_CONFIGURATION: PARAM_TREE_ADD(impinj_hub_id, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_hub_connected_type, 2, ENC_BIG_ENDIAN); PARAM_TREE_ADD(impinj_hub_fault_type, 2, ENC_BIG_ENDIAN); break; default: return suboffset; break; } return dissect_llrp_parameters(tvb, pinfo, param_tree, suboffset, param_end); }"
"static int io_init_req(struct io_ring_ctx *ctx, struct io_kiocb *req, const struct io_uring_sqe *sqe) __must_hold(&ctx->uring_lock) { struct io_submit_state *state; unsigned int sqe_flags; int personality, ret = 0; req->opcode = READ_ONCE(sqe->opcode); req->flags = sqe_flags = READ_ONCE(sqe->flags); req->user_data = READ_ONCE(sqe->user_data); req->file = NULL; req->fixed_rsrc_refs = NULL; req->task = current; if (unlikely(sqe_flags & ~SQE_VALID_FLAGS)) return -EINVAL; if (unlikely(req->opcode >= IORING_OP_LAST)) return -EINVAL; if (!io_check_restriction(ctx, req, sqe_flags)) return -EACCES; if ((sqe_flags & IOSQE_BUFFER_SELECT) && !io_op_defs[req->opcode].buffer_select) return -EOPNOTSUPP; if (unlikely(sqe_flags & IOSQE_IO_DRAIN)) ctx->drain_active = true; personality = READ_ONCE(sqe->personality); if (personality) { req->creds = xa_load(&ctx->personalities, personality); if (!req->creds) return -EINVAL; get_cred(req->creds); req->flags |= REQ_F_CREDS; } state = &ctx->submit_state; if (!state->plug_started && state->ios_left > 1 && io_op_defs[req->opcode].plug) { blk_start_plug(&state->plug); state->plug_started = true; } if (io_op_defs[req->opcode].needs_file) { req->file = io_file_get(ctx, req, READ_ONCE(sqe->fd), (sqe_flags & IOSQE_FIXED_FILE), 0); if (unlikely(!req->file)) ret = -EBADF; } state->ios_left--; return ret; }"
"bool CmapCoverage::getCoverage(SparseBitSet& coverage, const uint8_t* cmap_data, size_t cmap_size) { vector<uint32_t> coverageVec; const size_t kHeaderSize = 4; const size_t kNumTablesOffset = 2; const size_t kTableSize = 8; const size_t kPlatformIdOffset = 0; const size_t kEncodingIdOffset = 2; const size_t kOffsetOffset = 4; const int kMicrosoftPlatformId = 3; const int kUnicodeBmpEncodingId = 1; const int kUnicodeUcs4EncodingId = 10; if (kHeaderSize > cmap_size) { return false; } int numTables = readU16(cmap_data, kNumTablesOffset); if (kHeaderSize + numTables * kTableSize > cmap_size) { return false; } int bestTable = -1; for (int i = 0; i < numTables; i++) { uint16_t platformId = readU16(cmap_data, kHeaderSize + i * kTableSize + kPlatformIdOffset); uint16_t encodingId = readU16(cmap_data, kHeaderSize + i * kTableSize + kEncodingIdOffset); if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeUcs4EncodingId) { bestTable = i; break; } else if (platformId == kMicrosoftPlatformId && encodingId == kUnicodeBmpEncodingId) { bestTable = i; } } #ifdef PRINTF_DEBUG printf(""best table = %d\n"", bestTable); #endif if (bestTable < 0) { return false; } uint32_t offset = readU32(cmap_data, kHeaderSize + bestTable * kTableSize + kOffsetOffset); if (offset + 2 > cmap_size) { return false; } uint16_t format = readU16(cmap_data, offset); bool success = false; const uint8_t* tableData = cmap_data + offset; const size_t tableSize = cmap_size - offset; if (format == 4) { success = getCoverageFormat4(coverageVec, tableData, tableSize); } else if (format == 12) { success = getCoverageFormat12(coverageVec, tableData, tableSize); } if (success) { coverage.initFromRanges(&coverageVec.front(), coverageVec.size() >> 1); } #ifdef PRINTF_DEBUG for (int i = 0; i < coverageVec.size(); i += 2) { printf(""%x:%x\n"", coverageVec[i], coverageVec[i + 1]); } #endif return success; }"
"void operator()(OpKernelContext* ctx, const Index num_segments, const TensorShape& segment_ids_shape, typename TTypes<Index>::ConstFlat segment_ids, const Index data_size, const T* data, typename TTypes<T, 2>::Tensor output) { if (output.size() == 0) { return; } GPUDevice d = ctx->template eigen_device<GPUDevice>(); GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d); TF_CHECK_OK(GpuLaunchKernel( SetToValue<T>, config.block_count, config.thread_per_block, 0, d.stream(), output.size(), output.data(), InitialValueF()())); if (data_size == 0 || segment_ids_shape.num_elements() == 0) { return; } const Index input_outer_dim_size = segment_ids.dimension(0); const Index input_inner_dim_size = data_size / input_outer_dim_size; config = GetGpuLaunchConfig(data_size, d); TF_CHECK_OK( GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>, config.block_count, config.thread_per_block, 0, d.stream(), input_outer_dim_size, input_inner_dim_size, num_segments, segment_ids.data(), data, output.data())); }"
"static void rq17(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree) { static const value_string vals_17_cmd_fromshmm[] = { { 0x00, ""Query"" }, { 0x01, ""Release"" }, { 0x02, ""Force"" }, { 0x03, ""Bus Free"" }, { 0, NULL } }; static const value_string vals_17_cmd_toshmm[] = { { 0x00, ""Request"" }, { 0x01, ""Relinquish"" }, { 0x02, ""Notify"" }, { 0, NULL } }; guint to_shmm = ipmi_get_hdr(pinfo)->rs_sa == 0x20; guint cmd = tvb_get_guint8(tvb, 0); ipmi_set_data(pinfo, 0, (to_shmm << 8) | cmd); if (!tree) { return; } proto_tree_add_uint_format_value(tree, hf_ipmi_picmg_17_cmd, tvb, 0, 1, cmd, ""%s (0x%02x)"", val_to_str_const(cmd, to_shmm ? vals_17_cmd_toshmm : vals_17_cmd_fromshmm, ""Reserved""), cmd); proto_tree_add_item(tree, hf_ipmi_picmg_17_resid, tvb, 1, 1, ENC_LITTLE_ENDIAN); }"
"State() : codec_saw_local_complete_(false), codec_encode_complete_(false), on_reset_stream_called_(false), is_zombie_stream_(false), successful_upgrade_(false), is_internally_destroyed_(false), is_internally_created_(false), is_tunneling_(false), decorated_propagate_(true) {}"
int  WBaseStream::getPos() { assert( isOpened() ); return m_block_pos + (int)(m_current - m_start); }
"static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit, const struct assoc_array_ops *ops, const void *index_key, struct assoc_array_walk_result *result) { struct assoc_array_shortcut *shortcut, *new_s0; struct assoc_array_node *node, *new_n0, *new_n1, *side; struct assoc_array_ptr *ptr; unsigned long dissimilarity, base_seg, blank; size_t keylen; bool have_meta; int level, diff; int slot, next_slot, free_slot, i, j; node= result->terminal_node.node; level= result->terminal_node.level; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = result->terminal_node.slot; pr_devel(""-->%s()\n"", __func__); free_slot = -1; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (!ptr) { free_slot = i; continue; } if (ops->compare_object(assoc_array_ptr_to_leaf(ptr), index_key)) { pr_devel(""replace in slot %d\n"", i); edit->leaf_p = &node->slots[i]; edit->dead_leaf = node->slots[i]; pr_devel(""<--%s() = ok [replace]\n"", __func__); return true; } } if (free_slot >= 0) { pr_devel(""insert in free slot %d\n"", free_slot); edit->leaf_p = &node->slots[free_slot]; edit->adjust_count_on = node; pr_devel(""<--%s() = ok [insert]\n"", __func__); return true; } new_n0 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n0) return false; edit->new_meta[0] = assoc_array_node_to_ptr(new_n0); new_n1 = kzalloc(sizeof(struct assoc_array_node), GFP_KERNEL); if (!new_n1) return false; edit->new_meta[1] = assoc_array_node_to_ptr(new_n1); pr_devel(""no spare slots\n""); have_meta = false; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; if (assoc_array_ptr_is_meta(ptr)) { edit->segment_cache[i] = 0xff; have_meta = true; continue; } base_seg = ops->get_object_key_chunk( assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } if (have_meta) { pr_devel(""have meta\n""); goto split_node; } dissimilarity = 0; base_seg = edit->segment_cache[0]; for (i = 1; i < ASSOC_ARRAY_FAN_OUT; i++) dissimilarity |= edit->segment_cache[i] ^ base_seg; pr_devel(""only leaves; dissimilarity=%lx\n"", dissimilarity); if ((dissimilarity & ASSOC_ARRAY_FAN_MASK) == 0) { if ((edit->segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0) goto all_leaves_cluster_together; goto present_leaves_cluster_but_not_new_leaf; } split_node: pr_devel(""split node\n""); edit->set[0].to = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = node->back_pointer; new_n0->parent_slot = node->parent_slot; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1;  do_split_node: pr_devel(""do_split_node\n""); new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch; new_n1->nr_leaves_on_branch = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { slot = edit->segment_cache[i]; if (slot != 0xff) for (j = i + 1; j < ASSOC_ARRAY_FAN_OUT + 1; j++) if (edit->segment_cache[j] == slot) goto found_slot_for_multiple_occupancy; } found_slot_for_multiple_occupancy: pr_devel(""same slot: %x %x [%02x]\n"", i, j, slot); BUG_ON(i >= ASSOC_ARRAY_FAN_OUT); BUG_ON(j >= ASSOC_ARRAY_FAN_OUT + 1); BUG_ON(slot >= ASSOC_ARRAY_FAN_OUT); new_n1->parent_slot = slot; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) if (assoc_array_ptr_is_meta(node->slots[i])) new_n0->slots[i] = node->slots[i]; else new_n0->slots[i] = NULL; BUG_ON(new_n0->slots[slot] != NULL); new_n0->slots[slot] = assoc_array_node_to_ptr(new_n1); free_slot = -1; next_slot = 0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (assoc_array_ptr_is_meta(node->slots[i])) continue; if (edit->segment_cache[i] == slot) { new_n1->slots[next_slot++] = node->slots[i]; new_n1->nr_leaves_on_branch++; } else { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); new_n0->slots[free_slot] = node->slots[i]; } } pr_devel(""filtered: f=%x n=%x\n"", free_slot, next_slot); if (edit->segment_cache[ASSOC_ARRAY_FAN_OUT] != slot) { do { free_slot++; } while (new_n0->slots[free_slot] != NULL); edit->leaf_p = &new_n0->slots[free_slot]; edit->adjust_count_on = new_n0; } else { edit->leaf_p = &new_n1->slots[next_slot++]; edit->adjust_count_on = new_n1; } BUG_ON(next_slot <= 1); edit->set_backpointers_to = assoc_array_node_to_ptr(new_n0); for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { if (edit->segment_cache[i] == 0xff) { ptr = node->slots[i]; BUG_ON(assoc_array_ptr_is_leaf(ptr)); if (assoc_array_ptr_is_node(ptr)) { side = assoc_array_ptr_to_node(ptr); edit->set_backpointers[i] = &side->back_pointer; } else { shortcut = assoc_array_ptr_to_shortcut(ptr); edit->set_backpointers[i] = &shortcut->back_pointer; } } } ptr = node->back_pointer; if (!ptr) edit->set[0].ptr = &edit->array->root; else if (assoc_array_ptr_is_node(ptr)) edit->set[0].ptr = &assoc_array_ptr_to_node(ptr)->slots[node->parent_slot]; else edit->set[0].ptr = &assoc_array_ptr_to_shortcut(ptr)->next_node; edit->excised_meta[0] = assoc_array_node_to_ptr(node); pr_devel(""<--%s() = ok [split node]\n"", __func__); return true; present_leaves_cluster_but_not_new_leaf: pr_devel(""present leaves cluster but not new leaf\n""); new_n0->back_pointer = node->back_pointer; new_n0->parent_slot = node->parent_slot; new_n0->nr_leaves_on_branch = node->nr_leaves_on_branch; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = edit->segment_cache[0]; new_n1->nr_leaves_on_branch = node->nr_leaves_on_branch; edit->adjust_count_on = new_n0; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) new_n1->slots[i] = node->slots[i]; new_n0->slots[edit->segment_cache[0]] = assoc_array_node_to_ptr(new_n0); edit->leaf_p = &new_n0->slots[edit->segment_cache[ASSOC_ARRAY_FAN_OUT]]; edit->set[0].ptr = &assoc_array_ptr_to_node(node->back_pointer)->slots[node->parent_slot]; edit->set[0].to = assoc_array_node_to_ptr(new_n0); edit->excised_meta[0] = assoc_array_node_to_ptr(node); pr_devel(""<--%s() = ok [insert node before]\n"", __func__); return true; all_leaves_cluster_together: pr_devel(""all leaves cluster together\n""); diff = INT_MAX; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { int x = ops->diff_objects(assoc_array_ptr_to_leaf(node->slots[i]), index_key); if (x < diff) { BUG_ON(x < 0); diff = x; } } BUG_ON(diff == INT_MAX); BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP); keylen = round_up(diff, ASSOC_ARRAY_KEY_CHUNK_SIZE); keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT; new_s0 = kzalloc(sizeof(struct assoc_array_shortcut) + keylen * sizeof(unsigned long), GFP_KERNEL); if (!new_s0) return false; edit->new_meta[2] = assoc_array_shortcut_to_ptr(new_s0); edit->set[0].to = assoc_array_shortcut_to_ptr(new_s0); new_s0->back_pointer = node->back_pointer; new_s0->parent_slot = node->parent_slot; new_s0->next_node = assoc_array_node_to_ptr(new_n0); new_n0->back_pointer = assoc_array_shortcut_to_ptr(new_s0); new_n0->parent_slot = 0; new_n1->back_pointer = assoc_array_node_to_ptr(new_n0); new_n1->parent_slot = -1;  new_s0->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK; pr_devel(""skip_to_level = %d [diff %d]\n"", level, diff); BUG_ON(level <= 0); for (i = 0; i < keylen; i++) new_s0->index_key[i] = ops->get_key_chunk(index_key, i * ASSOC_ARRAY_KEY_CHUNK_SIZE); blank = ULONG_MAX << (level & ASSOC_ARRAY_KEY_CHUNK_MASK); pr_devel(""blank off [%zu] %d: %lx\n"", keylen - 1, level, blank); new_s0->index_key[keylen - 1] &= ~blank; for (i = 0; i < ASSOC_ARRAY_FAN_OUT; i++) { ptr = node->slots[i]; base_seg = ops->get_object_key_chunk(assoc_array_ptr_to_leaf(ptr), level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[i] = base_seg & ASSOC_ARRAY_FAN_MASK; } base_seg = ops->get_key_chunk(index_key, level); base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK; edit->segment_cache[ASSOC_ARRAY_FAN_OUT] = base_seg & ASSOC_ARRAY_FAN_MASK; goto do_split_node; }"
"static bool evtchn_2l_is_pending(const struct domain *d, evtchn_port_t port) { unsigned int max_ports = BITS_PER_EVTCHN_WORD(d) * BITS_PER_EVTCHN_WORD(d); ASSERT(port < max_ports); return (port < max_ports && guest_test_bit(d, port, &shared_info(d, evtchn_pending))); }"
"static void candump_write_packet(wtap_rec *rec, Buffer *buf, const msg_t *msg) { static const char can_proto_name[]   = ""can-hostendian""; static const char canfd_proto_name[] = ""canfd""; ws_buffer_clean(buf); if (msg->is_fd) { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)canfd_proto_name, sizeof canfd_proto_name - 1); } else { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)can_proto_name, sizeof can_proto_name - 1); } wtap_buffer_append_epdu_end(buf); if (msg->is_fd) { canfd_frame_t canfd_frame = {0}; canfd_frame.can_id = msg->id; canfd_frame.flags  = msg->flags; canfd_frame.len    = msg->data.length; memcpy(canfd_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&canfd_frame, sizeof(canfd_frame)); } else { can_frame_t can_frame = {0}; can_frame.can_id  = msg->id; can_frame.can_dlc = msg->data.length; memcpy(can_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&can_frame, sizeof(can_frame)); } rec->rec_type       = REC_TYPE_PACKET; rec->block          = wtap_block_create(WTAP_BLOCK_PACKET); rec->presence_flags = WTAP_HAS_TS; rec->ts             = msg->ts; rec->tsprec         = WTAP_TSPREC_USEC; rec->rec_header.packet_header.caplen = (guint32)ws_buffer_length(buf); rec->rec_header.packet_header.len    = (guint32)ws_buffer_length(buf); }"
"opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image, opj_cp_t *p_cp, OPJ_UINT32 p_tile_no) { OPJ_UINT32 pino; OPJ_UINT32 compno, resno; OPJ_UINT32 * l_tmp_data; OPJ_UINT32 ** l_tmp_ptr; OPJ_UINT32 l_max_res; OPJ_UINT32 l_max_prec; OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1; OPJ_UINT32 l_dx_min,l_dy_min; OPJ_UINT32 l_bound; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride; opj_pi_iterator_t *l_pi = 00; opj_tcp_t *l_tcp = 00; const opj_tccp_t *l_tccp = 00; opj_pi_comp_t *l_current_comp = 00; opj_image_comp_t * l_img_comp = 00; opj_pi_iterator_t * l_current_pi = 00; OPJ_UINT32 * l_encoding_value_ptr = 00; assert(p_cp != 00); assert(p_image != 00); assert(p_tile_no < p_cp->tw * p_cp->th); l_tcp = &p_cp->tcps[p_tile_no]; l_bound = l_tcp->numpocs+1; l_data_stride = 4 * OPJ_J2K_MAXRLVLS; l_tmp_data = (OPJ_UINT32*)opj_malloc( l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32)); if (! l_tmp_data) { return 00; } l_tmp_ptr = (OPJ_UINT32**)opj_malloc( p_image->numcomps * sizeof(OPJ_UINT32 *)); if (! l_tmp_ptr) { opj_free(l_tmp_data); return 00; } l_pi = opj_pi_create(p_image, p_cp, p_tile_no); if (!l_pi) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); return 00; } l_encoding_value_ptr = l_tmp_data; for (compno = 0; compno < p_image->numcomps; ++compno) { l_tmp_ptr[compno] = l_encoding_value_ptr; l_encoding_value_ptr += l_data_stride; } opj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr); l_step_p = 1; l_step_c = l_max_prec * l_step_p; l_step_r = p_image->numcomps * l_step_c; l_step_l = l_max_res * l_step_r; l_current_pi = l_pi; l_current_pi->include = 00; if (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U))) { l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16)); } if (!l_current_pi->include) { opj_free(l_tmp_data); opj_free(l_tmp_ptr); opj_pi_destroy(l_pi, l_bound); return 00; } l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw =  *(l_encoding_value_ptr++); l_res->ph =  *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } ++l_current_pi; for (pino = 1 ; pino<l_bound ; ++pino ) { l_current_comp = l_current_pi->comps; l_img_comp = p_image->comps; l_tccp = l_tcp->tccps; l_current_pi->tx0 = l_tx0; l_current_pi->ty0 = l_ty0; l_current_pi->tx1 = l_tx1; l_current_pi->ty1 = l_ty1; l_current_pi->step_p = l_step_p; l_current_pi->step_c = l_step_c; l_current_pi->step_r = l_step_r; l_current_pi->step_l = l_step_l; for (compno = 0; compno < l_current_pi->numcomps; ++compno) { opj_pi_resolution_t *l_res = l_current_comp->resolutions; l_encoding_value_ptr = l_tmp_ptr[compno]; l_current_comp->dx = l_img_comp->dx; l_current_comp->dy = l_img_comp->dy; for (resno = 0; resno < l_current_comp->numresolutions; resno++) { l_res->pdx = *(l_encoding_value_ptr++); l_res->pdy = *(l_encoding_value_ptr++); l_res->pw =  *(l_encoding_value_ptr++); l_res->ph =  *(l_encoding_value_ptr++); ++l_res; } ++l_current_comp; ++l_img_comp; ++l_tccp; } l_current_pi->include = (l_current_pi-1)->include; ++l_current_pi; } opj_free(l_tmp_data); l_tmp_data = 00; opj_free(l_tmp_ptr); l_tmp_ptr = 00; if (l_tcp->POC) { opj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res); } else { opj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res); } return l_pi; }"
"int vfs_open(const struct path *path, struct file *file, const struct cred *cred) { struct dentry *dentry = path->dentry; struct inode *inode = dentry->d_inode; file->f_path = *path; if (dentry->d_flags & DCACHE_OP_SELECT_INODE) { inode = dentry->d_op->d_select_inode(dentry, file->f_flags); if (IS_ERR(inode)) return PTR_ERR(inode); } return do_dentry_open(file, inode, NULL, cred); }"
"rosbag::RecorderOptions parseOptions(int argc, char** argv) { rosbag::RecorderOptions opts; po::options_description desc(""Allowed options""); desc.add_options() (""help,h"", ""produce help message"") (""all,a"", ""record all topics"") (""regex,e"", ""match topics using regular expressions"") (""exclude,x"", po::value<std::string>(), ""exclude topics matching regular expressions"") (""quiet,q"", ""suppress console output"") (""publish,p"", ""Publish a msg when the record begin"") (""output-prefix,o"", po::value<std::string>(), ""prepend PREFIX to beginning of bag name"") (""output-name,O"", po::value<std::string>(), ""record bagnamed NAME.bag"") (""buffsize,b"", po::value<int>()->default_value(256), ""Use an internal buffer of SIZE MB (Default: 256)"") (""chunksize"", po::value<int>()->default_value(768), ""Set chunk size of message data, in KB (Default: 768. Advanced)"") (""limit,l"", po::value<int>()->default_value(0), ""Only record NUM messages on each topic"") (""min-space,L"", po::value<std::string>()->default_value(""1G""), ""Minimum allowed space on recording device (use G,M,k multipliers)"") (""bz2,j"", ""use BZ2 compression"") (""lz4"", ""use LZ4 compression"") (""split"", po::value<int>()->implicit_value(0), ""Split the bag file and continue recording when maximum size or maximum duration reached."") (""max-splits"", po::value<int>(), ""Keep a maximum of N bag files, when reaching the maximum erase the oldest one to keep a constant number of files."") (""topic"", po::value< std::vector<std::string> >(), ""topic to record"") (""size"", po::value<uint64_t>(), ""The maximum size of the bag to record in MB."") (""duration"", po::value<std::string>(), ""Record a bag of maximum duration in seconds, unless 'm', or 'h' is appended."") (""node"", po::value<std::string>(), ""Record all topics subscribed to by a specific node."") (""tcpnodelay"", ""Use the TCP_NODELAY transport hint when subscribing to topics."") (""udp"", ""Use the UDP transport hint when subscribing to topics.""); po::positional_options_description p; p.add(""topic"", -1); po::variables_map vm; try  { po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm); } catch (boost::program_options::invalid_command_line_syntax& e) { throw ros::Exception(e.what()); }  catch (boost::program_options::unknown_option& e) { throw ros::Exception(e.what()); } if (vm.count(""help"")) { std::cout << desc << std::endl; exit(0); } if (vm.count(""all"")) opts.record_all = true; if (vm.count(""regex"")) opts.regex = true; if (vm.count(""exclude"")) { opts.do_exclude = true; opts.exclude_regex = vm[""exclude""].as<std::string>(); } if (vm.count(""quiet"")) opts.quiet = true; if (vm.count(""publish"")) opts.publish = true; if (vm.count(""output-prefix"")) { opts.prefix = vm[""output-prefix""].as<std::string>(); opts.append_date = true; } if (vm.count(""output-name"")) { opts.prefix = vm[""output-name""].as<std::string>(); opts.append_date = false; } if (vm.count(""split"")) { opts.split = true; int S = vm[""split""].as<int>(); if (S != 0) { ROS_WARN(""Use of \""--split <MAX_SIZE>\"" has been deprecated.  Please use --split --size <MAX_SIZE> or --split --duration <MAX_DURATION>""); if (S < 0) throw ros::Exception(""Split size must be 0 or positive""); opts.max_size = 1048576 * S; } } if(vm.count(""max-splits"")) { if(!opts.split) { ROS_WARN(""--max-splits is ignored without --split""); } else { opts.max_splits = vm[""max-splits""].as<int>(); } } if (vm.count(""buffsize"")) { int m = vm[""buffsize""].as<int>(); if (m < 0) throw ros::Exception(""Buffer size must be 0 or positive""); opts.buffer_size = 1048576 * m; } if (vm.count(""chunksize"")) { int chnk_sz = vm[""chunksize""].as<int>(); if (chnk_sz < 0) throw ros::Exception(""Chunk size must be 0 or positive""); opts.chunk_size = 1024 * chnk_sz; } if (vm.count(""limit"")) { opts.limit = vm[""limit""].as<int>(); } if (vm.count(""min-space"")) { std::string ms = vm[""min-space""].as<std::string>(); long long int value = 1073741824ull; char mul = 0; opts.min_space_str = ""1G""; opts.min_space = value; if (sscanf(ms.c_str(), "" %lld%c"", &value, &mul) > 0) { opts.min_space_str = ms; switch (mul) { case 'G': case 'g': opts.min_space = value * 1073741824ull; break; case 'M': case 'm': opts.min_space = value * 1048576ull; break; case 'K': case 'k': opts.min_space = value * 1024ull; break; default: opts.min_space = value; break; } } ROS_DEBUG(""Rosbag using minimum space of %lld bytes, or %s"", opts.min_space, opts.min_space_str.c_str()); } if (vm.count(""bz2"") && vm.count(""lz4"")) { throw ros::Exception(""Can only use one type of compression""); } if (vm.count(""bz2"")) { opts.compression = rosbag::compression::BZ2; } if (vm.count(""lz4"")) { opts.compression = rosbag::compression::LZ4; } if (vm.count(""duration"")) { std::string duration_str = vm[""duration""].as<std::string>(); double duration; double multiplier = 1.0; std::string unit(""""); std::istringstream iss(duration_str); if ((iss >> duration).fail()) throw ros::Exception(""Duration must start with a floating point number.""); if ( (!iss.eof() && ((iss >> unit).fail())) ) { throw ros::Exception(""Duration unit must be s, m, or h""); } if (unit == std::string("""")) multiplier = 1.0; else if (unit == std::string(""s"")) multiplier = 1.0; else if (unit == std::string(""m"")) multiplier = 60.0; else if (unit == std::string(""h"")) multiplier = 3600.0; else throw ros::Exception(""Duration unit must be s, m, or h""); opts.max_duration = ros::Duration(duration * multiplier); if (opts.max_duration <= ros::Duration(0)) throw ros::Exception(""Duration must be positive.""); } if (vm.count(""size"")) { opts.max_size = vm[""size""].as<uint64_t>() * 1048576; if (opts.max_size <= 0) throw ros::Exception(""Split size must be 0 or positive""); } if (vm.count(""node"")) { opts.node = vm[""node""].as<std::string>(); std::cout << ""Recording from: "" << opts.node << std::endl; } if (vm.count(""tcpnodelay"")) { opts.transport_hints.tcpNoDelay(); } if (vm.count(""udp"")) { opts.transport_hints.udp(); } if (vm.count(""topic"")) { std::vector<std::string> bags = vm[""topic""].as< std::vector<std::string> >(); std::sort(bags.begin(), bags.end()); bags.erase(std::unique(bags.begin(), bags.end()), bags.end()); for (std::vector<std::string>::iterator i = bags.begin(); i != bags.end(); i++) opts.topics.push_back(*i); } if(opts.exclude_regex.size() > 0 && !(opts.record_all || opts.regex)) { fprintf(stderr, ""Warning: Exclusion regex given, but no topics to subscribe to.\n"" ""Adding implicit 'record all'.""); opts.record_all = true; } return opts; }"
"static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, struct task_struct *tsk) { if (unlikely(prev == next)) return; cpu_set(smp_processor_id(), next->cpu_vm_mask); update_mm(next, tsk); }"
"ecma_value_t opfunc_private_set (ecma_value_t base,  ecma_value_t property,  ecma_value_t value)  { ecma_object_t *obj_p = ecma_get_object_from_value (base); ecma_string_t *prop_name_p = ecma_get_string_from_value (property); ecma_string_t *private_key_p = NULL; ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true); if (prop_p == NULL) { return ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT); } if (*prop_p & ECMA_PROPERTY_FLAG_DATA) { JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p)); if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD) { return ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE); } ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value); return ecma_copy_value (value); } ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p)); if (get_set_pair_p->setter_cp == JMEM_CP_NULL) { return ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER); } ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp); return ecma_op_function_call (setter_p, base, &value, 1); }"
"QList<MPPlatformDef> MPDevice_win::enumerateDevices() { HID.load(); QList<MPPlatformDef> devlist; SP_DEVINFO_DATA devinfo_data; SP_DEVICE_INTERFACE_DATA dev_data; SP_DEVICE_INTERFACE_DETAIL_DATA_A *dev_detail_data = NULL; HDEVINFO dev_info_set = INVALID_HANDLE_VALUE; int idx = 0; ::ZeroMemory(&devinfo_data, sizeof(devinfo_data)); devinfo_data.cbSize = sizeof(SP_DEVINFO_DATA); dev_data.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); dev_info_set = SetupDiGetClassDevsA(&IClassGuid, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE); while (SetupDiEnumDeviceInterfaces(dev_info_set, nullptr, &IClassGuid, idx, &dev_data)) { DWORD required_size = 0; bool ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set, &dev_data, nullptr, 0, &required_size, nullptr); dev_detail_data = (SP_DEVICE_INTERFACE_DETAIL_DATA_A*) malloc(required_size); dev_detail_data->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A); ret = SetupDiGetDeviceInterfaceDetailA(dev_info_set, &dev_data, dev_detail_data, required_size, nullptr, nullptr); ++idx; if (!ret) { free(dev_detail_data); continue; } QString path = QString(dev_detail_data->DevicePath); free(dev_detail_data); bool isBLE = false; bool isBluetooth = false; if (!checkDevice(path, isBLE, isBluetooth)) { continue; } qDebug() << ""Found mooltipass: "" << path; devlist << getPlatDef(path, isBLE, isBluetooth); } SetupDiDestroyDeviceInfoList(dev_info_set); return devlist; }"
"void ex_diffgetput(exarg_T *eap) { linenr_Tlnum; intcount; linenr_Toff = 0; diff_T*dp; diff_T*dprev; diff_T*dfree; intidx_cur; intidx_other; intidx_from; intidx_to; inti; intadded; char_u*p; aco_save_Taco; buf_T*buf; intstart_skip, end_skip; intnew_count; intbuf_empty; intfound_not_ma = FALSE; idx_cur = diff_buf_idx(curbuf); if (idx_cur == DB_COUNT) { emsg(_(e_current_buffer_is_not_in_diff_mode)); return; } if (*eap->arg == NUL) { for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) if (curtab->tp_diffbuf[idx_other] != curbuf && curtab->tp_diffbuf[idx_other] != NULL) { if (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[idx_other]->b_p_ma) break; found_not_ma = TRUE; } if (idx_other == DB_COUNT) { if (found_not_ma) emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable)); else emsg(_(e_no_other_buffer_in_diff_mode)); return; } for (i = idx_other + 1; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != curbuf && curtab->tp_diffbuf[i] != NULL && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma)) { emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use)); return; } } else { p = eap->arg + STRLEN(eap->arg); while (p > eap->arg && VIM_ISWHITE(p[-1])) --p; for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) ; if (eap->arg + i == p)        i = atol((char *)eap->arg); else { i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE); if (i < 0) return;} buf = buflist_findnr(i); if (buf == NULL) { semsg(_(e_cant_find_buffer_str), eap->arg); return; } if (buf == curbuf) return;idx_other = diff_buf_idx(buf); if (idx_other == DB_COUNT) { semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg); return; } } diff_busy = TRUE; if (eap->addr_count == 0) { if (eap->cmdidx == CMD_diffget && eap->line1 == curbuf->b_ml.ml_line_count && diff_check(curwin, eap->line1) == 0 && (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0)) ++eap->line2; else if (eap->line1 > 0) --eap->line1; } if (eap->cmdidx == CMD_diffget) { idx_from = idx_other; idx_to = idx_cur; } else { idx_from = idx_cur; idx_to = idx_other; aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]); } if (!curbuf->b_changed) { change_warning(0); if (diff_buf_idx(curbuf) != idx_to) { emsg(_(e_buffer_changed_unexpectedly)); goto theend; } } dprev = NULL; for (dp = curtab->tp_first_diff; dp != NULL; ) { if (dp->df_lnum[idx_cur] > eap->line2 + off) break; dfree = NULL; lnum = dp->df_lnum[idx_to]; count = dp->df_count[idx_to]; if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off && u_save(lnum - 1, lnum + count) != FAIL) { start_skip = 0; end_skip = 0; if (eap->addr_count > 0) { start_skip = eap->line1 + off - dp->df_lnum[idx_cur]; if (start_skip > 0) { if (start_skip > count) { lnum += count; count = 0; } else { count -= start_skip; lnum += start_skip; } } else start_skip = 0; end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1 - (eap->line2 + off); if (end_skip > 0) { if (idx_cur == idx_from)    { i = dp->df_count[idx_cur] - start_skip - end_skip; if (count > i) count = i; } else    { count -= end_skip; end_skip = dp->df_count[idx_from] - start_skip - count; if (end_skip < 0) end_skip = 0; } } else end_skip = 0; } buf_empty = BUFEMPTY(); added = 0; for (i = 0; i < count; ++i) { buf_empty = curbuf->b_ml.ml_line_count == 1; ml_delete(lnum); --added; } for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) { linenr_T nr; nr = dp->df_lnum[idx_from] + start_skip + i; if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count) break; p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE)); if (p != NULL) { ml_append(lnum + i - 1, p, 0, FALSE); vim_free(p); ++added; if (buf_empty && curbuf->b_ml.ml_line_count == 2) { buf_empty = FALSE; ml_delete((linenr_T)2); } } } new_count = dp->df_count[idx_to] + added; dp->df_count[idx_to] = new_count; if (start_skip == 0 && end_skip == 0) { for (i = 0; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != NULL && i != idx_from && i != idx_to && !diff_equal_entry(dp, idx_from, i)) break; if (i == DB_COUNT) { dfree = dp; dp = dp->df_next; if (dprev == NULL) curtab->tp_first_diff = dp; else dprev->df_next = dp; } } if (added != 0) { mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added); if (curwin->w_cursor.lnum >= lnum) { if (curwin->w_cursor.lnum >= lnum + count) curwin->w_cursor.lnum += added; else if (added < 0) curwin->w_cursor.lnum = lnum; } } changed_lines(lnum, 0, lnum + count, (long)added); if (dfree != NULL) { #ifdef FEAT_FOLDING diff_fold_update(dfree, idx_to); #endif vim_free(dfree); } else dp->df_count[idx_to] = new_count; if (idx_cur == idx_to) off += added; } if (dfree == NULL) { dprev = dp; dp = dp->df_next; } } if (eap->cmdidx != CMD_diffget) { if (KeyTyped) u_sync(FALSE); aucmd_restbuf(&aco); } theend: diff_busy = FALSE; if (diff_need_update) ex_diffupdate(NULL); check_cursor(); changed_line_abv_curs(); if (diff_need_update) diff_need_update = FALSE; else { diff_redraw(FALSE); apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf); } }"
"void win_new_width(win_T *wp, int width) { wp->w_width = width; wp->w_lines_valid = 0; changed_line_abv_curs_win(wp); if (p_spsc) { invalidate_botline_win(wp); if (wp == curwin) { update_topline(); curs_columns(TRUE);} } redraw_win_later(wp, UPD_NOT_VALID); wp->w_redr_status = TRUE; }"
"static int emulator_read_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception) { struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt); return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, 0, exception); }"
"int xenmem_add_to_physmap(struct domain *d, struct xen_add_to_physmap *xatp, unsigned int start) { unsigned int done = 0; long rc = 0; union add_to_physmap_extra extra = {}; struct page_info *pages[16]; ASSERT(paging_mode_translate(d)); if ( xatp->space == XENMAPSPACE_gmfn_foreign ) extra.foreign_domid = DOMID_INVALID; if ( xatp->space != XENMAPSPACE_gmfn_range ) return xenmem_add_to_physmap_one(d, xatp->space, extra, xatp->idx, _gfn(xatp->gpfn)); if ( xatp->size < start ) return -EILSEQ; xatp->idx += start; xatp->gpfn += start; xatp->size -= start; if ( is_iommu_enabled(d) ) { this_cpu(iommu_dont_flush_iotlb) = 1; extra.ppage = &pages[0]; } while ( xatp->size > done ) { rc = xenmem_add_to_physmap_one(d, XENMAPSPACE_gmfn, extra, xatp->idx, _gfn(xatp->gpfn)); if ( rc < 0 ) break; xatp->idx++; xatp->gpfn++; if ( extra.ppage ) ++extra.ppage; if ( (++done > ARRAY_SIZE(pages) && extra.ppage) || (xatp->size > done && hypercall_preempt_check()) ) { rc = start + done; break; } } if ( is_iommu_enabled(d) ) { int ret; unsigned int i; this_cpu(iommu_dont_flush_iotlb) = 0; ret = iommu_iotlb_flush(d, _dfn(xatp->idx - done), done, IOMMU_FLUSHF_modified); if ( unlikely(ret) && rc >= 0 ) rc = ret; for ( i = 0; i < done; ++i ) put_page(pages[i]); ret = iommu_iotlb_flush(d, _dfn(xatp->gpfn - done), done, IOMMU_FLUSHF_added | IOMMU_FLUSHF_modified); if ( unlikely(ret) && rc >= 0 ) rc = ret; } return rc; }"
"static int bgp_attr_check(struct peer *peer, struct attr *attr, bgp_size_t length) { uint8_t type = 0; if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag && !length) return BGP_ATTR_PARSE_PROCEED; if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) && CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))) return BGP_ATTR_PARSE_PROCEED; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN))) type = BGP_ATTR_ORIGIN; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) type = BGP_ATTR_AS_PATH; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) type = BGP_ATTR_NEXT_HOP; if (peer->sort == BGP_PEER_IBGP && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF))) type = BGP_ATTR_LOCAL_PREF; if (type) { flog_warn(EC_BGP_MISSING_ATTRIBUTE, ""%s Missing well-known attribute %s."", peer->host, lookup_msg(attr_str, type, NULL)); return BGP_ATTR_PARSE_WITHDRAW; } return BGP_ATTR_PARSE_PROCEED; }"
"static int _Unpickler_ResizeMemoList(UnpicklerObject *self, Py_ssize_t new_size) { Py_ssize_t i; assert(new_size > self->memo_size); PyObject **memo_new = self->memo; PyMem_RESIZE(memo_new, PyObject *, new_size); if (memo_new == NULL) { PyErr_NoMemory(); return -1; } self->memo = memo_new; for (i = self->memo_size; i < new_size; i++) self->memo[i] = NULL; self->memo_size = new_size; return 0; }"
"GF_Err stbl_AppendTime(GF_SampleTableBox *stbl, u32 duration, u32 nb_pack) { GF_TimeToSampleBox *stts = stbl->TimeToSample; if (!nb_pack) nb_pack = 1; if (stts->nb_entries) { if (stts->entries[stts->nb_entries-1].sampleDelta == duration) { stts->entries[stts->nb_entries-1].sampleCount += nb_pack; return GF_OK; } } if (stts->nb_entries==stts->alloc_size) { ALLOC_INC(stts->alloc_size); stts->entries = gf_realloc(stts->entries, sizeof(GF_SttsEntry)*stts->alloc_size); if (!stts->entries) return GF_OUT_OF_MEM; memset(&stts->entries[stts->nb_entries], 0, sizeof(GF_SttsEntry)*(stts->alloc_size-stts->nb_entries) ); } stts->entries[stts->nb_entries].sampleCount = nb_pack; stts->entries[stts->nb_entries].sampleDelta = duration; stts->nb_entries++; if (stts->max_ts_delta < duration ) stts->max_ts_delta = duration; return GF_OK; }"
"pe_exports_t *pe_exports(pe_ctx_t *ctx) { if (ctx->cached_data.exports != NULL) return ctx->cached_data.exports; pe_exports_t *exports = ctx->cached_data.exports = calloc(1, sizeof(pe_exports_t)); if (exports == NULL) { return NULL; } exports->err = LIBPE_E_OK; const IMAGE_DATA_DIRECTORY *dir = pe_directory_by_entry(ctx, IMAGE_DIRECTORY_ENTRY_EXPORT); if (dir == NULL) {  return exports; } const uint64_t va = dir->VirtualAddress; if (va == 0) { return exports; } uint64_t ofs; ofs = pe_rva2ofs(ctx, va); const IMAGE_EXPORT_DIRECTORY *exp = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, exp, sizeof(IMAGE_EXPORT_DIRECTORY))) { exports->err = LIBPE_E_EXPORTS_CANT_READ_DIR; return exports; } ofs = pe_rva2ofs(ctx, exp->Name); const char *name_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, name_ptr, 1)) { exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA; return exports; } exports->name = strdup(name_ptr); const uint32_t ordinal_base = exp->Base; ofs = pe_rva2ofs(ctx, exp->AddressOfNames); const uint32_t *rva_ptr = LIBPE_PTR_ADD(ctx->map_addr, ofs); if (!pe_can_read(ctx, rva_ptr, sizeof(uint32_t))) { exports->err = LIBPE_E_EXPORTS_CANT_READ_RVA; return exports; } exports->functions_count = exp->NumberOfFunctions; exports->functions = calloc(exp->NumberOfFunctions, sizeof(pe_exported_function_t)); if (exports->functions == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } const uint64_t offset_to_AddressOfFunctions = pe_rva2ofs(ctx, exp->AddressOfFunctions); const uint64_t offset_to_AddressOfNames = pe_rva2ofs(ctx, exp->AddressOfNames); const uint64_t offset_to_AddressOfNameOrdinals = pe_rva2ofs(ctx, exp->AddressOfNameOrdinals); uint64_t offsets_to_Names[exp->NumberOfFunctions]; memset(offsets_to_Names, 0, sizeof(offsets_to_Names));   for (uint32_t i=0; i < exp->NumberOfNames; i++) { uint64_t entry_ordinal_list_ptr = offset_to_AddressOfNameOrdinals + sizeof(uint16_t) * i; uint16_t *entry_ordinal_list = LIBPE_PTR_ADD(ctx->map_addr, entry_ordinal_list_ptr); if (!pe_can_read(ctx, entry_ordinal_list, sizeof(uint16_t))) { break; } const uint16_t ordinal = *entry_ordinal_list; uint64_t entry_name_list_ptr = offset_to_AddressOfNames + sizeof(uint32_t) * i; uint32_t *entry_name_list = LIBPE_PTR_ADD(ctx->map_addr, entry_name_list_ptr); if (!pe_can_read(ctx, entry_name_list, sizeof(uint32_t))) { break; } const uint32_t entry_name_rva = *entry_name_list; const uint64_t entry_name_ofs = pe_rva2ofs(ctx, entry_name_rva); offsets_to_Names[ordinal] = entry_name_ofs; } for (uint32_t i=0; i < exp->NumberOfFunctions; i++) { uint64_t entry_va_list_ptr = offset_to_AddressOfFunctions + sizeof(uint32_t) * i; uint32_t *entry_va_list = LIBPE_PTR_ADD(ctx->map_addr, entry_va_list_ptr); if (!pe_can_read(ctx, entry_va_list, sizeof(uint32_t))) { break; } const uint32_t entry_va = *entry_va_list; const uint64_t entry_name_ofs = offsets_to_Names[i]; char fname[300]; fname[0] = 0; if (entry_name_ofs != 0) { const char *entry_name = LIBPE_PTR_ADD(ctx->map_addr, entry_name_ofs); if (!pe_can_read(ctx, entry_name, 1)) { break; } const size_t fname_size = sizeof(fname); strncpy(fname, entry_name, fname_size-1); fname[fname_size - 1] = '\0'; } exports->functions[i].ordinal = ordinal_base + i; exports->functions[i].address = entry_va; exports->functions[i].name = strdup(fname); if (exports->functions[i].name == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } if (entry_va >= va && entry_va <= va + dir->Size) { const uint64_t fw_entry_name_ofs = pe_rva2ofs(ctx, entry_va); const char *fw_entry_name = LIBPE_PTR_ADD(ctx->map_addr, fw_entry_name_ofs); if (!pe_can_read(ctx, fw_entry_name, 1)) { break; } exports->functions[i].fwd_name = strdup(fw_entry_name); if (exports->functions[i].fwd_name == NULL) { exports->err = LIBPE_E_ALLOCATION_FAILURE; return exports; } } } return exports; }"
"MagickExport MagickBooleanType SetQuantumDepth(const Image *image, QuantumInfo *quantum_info,const size_t depth) { size_t extent, quantum; assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(quantum_info != (QuantumInfo *) NULL); assert(quantum_info->signature == MagickSignature); quantum_info->depth=depth; if (quantum_info->format == FloatingPointQuantumFormat) { if (quantum_info->depth > 32) quantum_info->depth=64; else if (quantum_info->depth > 16) quantum_info->depth=32; else quantum_info->depth=16; } if (quantum_info->pixels != (unsigned char **) NULL) DestroyQuantumPixels(quantum_info); quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8; extent=image->columns*quantum; if (quantum != (extent/image->columns)) return(MagickFalse); return(AcquireQuantumPixels(quantum_info,extent)); }"
"dwg_object_ref ** dwg_obj_block_control_get_block_headers(const dwg_obj_block_control *restrict ctrl, int *restrict error) { dwg_object_ref **ptx = (dwg_object_ref**) malloc(ctrl->num_entries * sizeof(Dwg_Object_Ref *)); if (ptx) { BITCODE_BS i; *error = 0; for (i=0; i < ctrl->num_entries; i++) { ptx[i] = ctrl->block_headers[i]; } return ptx; } else { *error = 1; LOG_ERROR(""%s: null malloc"", __FUNCTION__) return NULL; } }"
static void ohci_bus_stop(OHCIState *ohci) { trace_usb_ohci_stop(ohci->name); if (ohci->eof_timer) { timer_del(ohci->eof_timer); timer_free(ohci->eof_timer); } ohci->eof_timer = NULL; }
"static void sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo) { Sg_request *srp; int val; unsigned int ms; val = 0; list_for_each_entry(srp, &sfp->rq_list, entry) { if (val > SG_MAX_QUEUE) break; memset(&rinfo[val], 0, SZ_SG_REQ_INFO); rinfo[val].req_state = srp->done + 1; rinfo[val].problem = srp->header.masked_status & srp->header.host_status & srp->header.driver_status; if (srp->done) rinfo[val].duration = srp->header.duration; else { ms = jiffies_to_msecs(jiffies); rinfo[val].duration = (ms > srp->header.duration) ? (ms - srp->header.duration) : 0; } rinfo[val].orphan = srp->orphan; rinfo[val].sg_io_owned = srp->sg_io_owned; rinfo[val].pack_id = srp->header.pack_id; rinfo[val].usr_ptr = srp->header.usr_ptr; val++; } }"
"static MagickBooleanType WriteOneJNGImage(MngInfo *mng_info, const ImageInfo *image_info,Image *image) { Image *jpeg_image; ImageInfo *jpeg_image_info; int unique_filenames; MagickBooleanType logging, status; size_t length; unsigned char *blob, chunk[80], *p; unsigned int jng_alpha_compression_method, jng_alpha_sample_depth, jng_color_type, transparent; size_t jng_alpha_quality, jng_quality; logging=LogMagickEvent(CoderEvent,GetMagickModule(), ""  Enter WriteOneJNGImage()""); blob=(unsigned char *) NULL; jpeg_image=(Image *) NULL; jpeg_image_info=(ImageInfo *) NULL; length=0; unique_filenames=0; status=MagickTrue; transparent=image_info->type==GrayscaleMatteType || image_info->type==TrueColorMatteType || image->matte != MagickFalse; jng_alpha_sample_depth = 0; jng_quality=image_info->quality == 0UL ? 75UL : image_info->quality%1000; jng_alpha_compression_method=image->compression==JPEGCompression? 8 : 0; jng_alpha_quality=image_info->quality == 0UL ? 75UL : image_info->quality; if (jng_alpha_quality >= 1000) jng_alpha_quality /= 1000; if (transparent != 0) { jng_color_type=14; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating jpeg_image_info for opacity.""); jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info); if (jpeg_image_info == (ImageInfo *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating jpeg_image.""); jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception); if (jpeg_image == (Image *) NULL) { jpeg_image_info=DestroyImageInfo(jpeg_image_info); ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); } (void) CopyMagickString(jpeg_image->magick,""JPEG"",MaxTextExtent); status=SeparateImageChannel(jpeg_image,OpacityChannel); if (status == MagickFalse) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); status=NegateImage(jpeg_image,MagickFalse); if (status == MagickFalse) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); jpeg_image->matte=MagickFalse; jpeg_image_info->type=GrayscaleType; jpeg_image->quality=jng_alpha_quality; (void) SetImageType(jpeg_image,GrayscaleType); (void) AcquireUniqueFilename(jpeg_image->filename); unique_filenames++; (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent, ""%s"",jpeg_image->filename); } else { jng_alpha_compression_method=0; jng_color_type=10; jng_alpha_sample_depth=0; } if (image_info->type != TrueColorMatteType && image_info->type != TrueColorType && SetImageGray(image,&image->exception)) jng_color_type-=2; if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG Quality           = %d"",(int) jng_quality); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG Color Type        = %d"",jng_color_type); if (transparent != 0) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG Alpha Compression = %d"",jng_alpha_compression_method); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG Alpha Depth       = %d"",jng_alpha_sample_depth); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG Alpha Quality     = %d"",(int) jng_alpha_quality); } } if (transparent != 0) { if (jng_alpha_compression_method==0) { const char *value; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating PNG blob for alpha.""); status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode, &image->exception); if (status == MagickFalse) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); length=0; (void) CopyMagickString(jpeg_image_info->magick,""PNG"",MaxTextExtent); (void) CopyMagickString(jpeg_image->magick,""PNG"",MaxTextExtent); jpeg_image_info->interlace=NoInterlace; (void) SetImageArtifact(jpeg_image,""png:exclude-chunks"",""all""); blob=ImageToBlob(jpeg_image_info,jpeg_image,&length, &image->exception); value=GetImageProperty(jpeg_image,""png:bit-depth-written""); if (value != (char *) NULL) jng_alpha_sample_depth= (unsigned int) value[0]; } else { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating JPEG blob for alpha.""); status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode, &image->exception); if (status == MagickFalse) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",MaxTextExtent); (void) CopyMagickString(jpeg_image->magick,""JPEG"",MaxTextExtent); jpeg_image_info->interlace=NoInterlace; blob=ImageToBlob(jpeg_image_info,jpeg_image,&length, &image->exception); jng_alpha_sample_depth=8; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Successfully read jpeg_image into a blob, length=%.20g."", (double) length); } jpeg_image=DestroyImage(jpeg_image); (void) RelinquishUniqueFileResource(jpeg_image_info->filename); unique_filenames--; jpeg_image_info=DestroyImageInfo(jpeg_image_info); } (void) WriteBlobMSBULong(image,16L);   PNGType(chunk,mng_JHDR); LogPNGChunk(logging,mng_JHDR,16L); PNGLong(chunk+4,(png_uint_32) image->columns); PNGLong(chunk+8,(png_uint_32) image->rows); chunk[12]=jng_color_type; chunk[13]=8;   chunk[14]=8;  chunk[15]=(unsigned char) (image_info->interlace == NoInterlace ? 0 : 8); chunk[16]=jng_alpha_sample_depth; chunk[17]=jng_alpha_compression_method; chunk[18]=0;  chunk[19]=0;  (void) WriteBlob(image,20,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,20)); if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG width:%15lu"",(unsigned long) image->columns); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG height:%14lu"",(unsigned long) image->rows); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG color type:%10d"",jng_color_type); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG sample depth:%8d"",8); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG compression:%9d"",8); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG interlace:%11d"",0); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG alpha depth:%9d"",jng_alpha_sample_depth); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG alpha compression:%3d"",jng_alpha_compression_method); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG alpha filter:%8d"",0); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    JNG alpha interlace:%5d"",0); } if (transparent != 0) { unsigned char blue, green, red; ssize_t num_bytes; if (jng_color_type == 8 || jng_color_type == 12) num_bytes=6L; else num_bytes=10L; (void) WriteBlobMSBULong(image,(size_t) (num_bytes-4L)); PNGType(chunk,mng_bKGD); LogPNGChunk(logging,mng_bKGD,(size_t) (num_bytes-4L)); red=ScaleQuantumToChar(image->background_color.red); green=ScaleQuantumToChar(image->background_color.green); blue=ScaleQuantumToChar(image->background_color.blue); *(chunk+4)=0; *(chunk+5)=red; *(chunk+6)=0; *(chunk+7)=green; *(chunk+8)=0; *(chunk+9)=blue; (void) WriteBlob(image,(size_t) num_bytes,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,(uInt) num_bytes)); } if ((image->colorspace == sRGBColorspace || image->rendering_intent)) { (void) WriteBlobMSBULong(image,1L); PNGType(chunk,mng_sRGB); LogPNGChunk(logging,mng_sRGB,1L); if (image->rendering_intent != UndefinedIntent) chunk[4]=(unsigned char) Magick_RenderingIntent_to_PNG_RenderingIntent( (image->rendering_intent)); else chunk[4]=(unsigned char) Magick_RenderingIntent_to_PNG_RenderingIntent( (PerceptualIntent)); (void) WriteBlob(image,5,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,5)); } else { if (image->gamma != 0.0) { (void) WriteBlobMSBULong(image,4L); PNGType(chunk,mng_gAMA); LogPNGChunk(logging,mng_gAMA,4L); PNGLong(chunk+4,(png_uint_32) (100000*image->gamma+0.5)); (void) WriteBlob(image,8,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,8)); } if ((mng_info->equal_chrms == MagickFalse) && (image->chromaticity.red_primary.x != 0.0)) { PrimaryInfo primary; (void) WriteBlobMSBULong(image,32L); PNGType(chunk,mng_cHRM); LogPNGChunk(logging,mng_cHRM,32L); primary=image->chromaticity.white_point; PNGLong(chunk+4,(png_uint_32) (100000*primary.x+0.5)); PNGLong(chunk+8,(png_uint_32) (100000*primary.y+0.5)); primary=image->chromaticity.red_primary; PNGLong(chunk+12,(png_uint_32) (100000*primary.x+0.5)); PNGLong(chunk+16,(png_uint_32) (100000*primary.y+0.5)); primary=image->chromaticity.green_primary; PNGLong(chunk+20,(png_uint_32) (100000*primary.x+0.5)); PNGLong(chunk+24,(png_uint_32) (100000*primary.y+0.5)); primary=image->chromaticity.blue_primary; PNGLong(chunk+28,(png_uint_32) (100000*primary.x+0.5)); PNGLong(chunk+32,(png_uint_32) (100000*primary.y+0.5)); (void) WriteBlob(image,36,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,36)); } } if (image->x_resolution && image->y_resolution && !mng_info->equal_physs) { (void) WriteBlobMSBULong(image,9L); PNGType(chunk,mng_pHYs); LogPNGChunk(logging,mng_pHYs,9L); if (image->units == PixelsPerInchResolution) { PNGLong(chunk+4,(png_uint_32) (image->x_resolution*100.0/2.54+0.5)); PNGLong(chunk+8,(png_uint_32) (image->y_resolution*100.0/2.54+0.5)); chunk[12]=1; } else { if (image->units == PixelsPerCentimeterResolution) { PNGLong(chunk+4,(png_uint_32) (image->x_resolution*100.0+0.5)); PNGLong(chunk+8,(png_uint_32) (image->y_resolution*100.0+0.5)); chunk[12]=1; } else { PNGLong(chunk+4,(png_uint_32) (image->x_resolution+0.5)); PNGLong(chunk+8,(png_uint_32) (image->y_resolution+0.5)); chunk[12]=0; } } (void) WriteBlob(image,13,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,13)); } if (mng_info->write_mng == 0 && (image->page.x || image->page.y)) { (void) WriteBlobMSBULong(image,9L); PNGType(chunk,mng_oFFs); LogPNGChunk(logging,mng_oFFs,9L); PNGsLong(chunk+4,(ssize_t) (image->page.x)); PNGsLong(chunk+8,(ssize_t) (image->page.y)); chunk[12]=0; (void) WriteBlob(image,13,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,13)); } if (transparent != 0) { if (jng_alpha_compression_method==0) { register ssize_t i; size_t len; if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Write IDAT chunks from blob, length=%.20g."",(double) length); len=0; p=blob+8; for (i=8; i<(ssize_t) length; i+=len+12) { len=(((unsigned int) *(p    ) & 0xff) << 24) + (((unsigned int) *(p + 1) & 0xff) << 16) + (((unsigned int) *(p + 2) & 0xff) <<  8) + (((unsigned int) *(p + 3) & 0xff)      ) ; p+=4; if (*(p)==73 && *(p+1)==68 && *(p+2)==65 && *(p+3)==84)  { (void) WriteBlobMSBULong(image,len); LogPNGChunk(logging,mng_IDAT,len); (void) WriteBlob(image,len+4,p); (void) WriteBlobMSBULong(image,crc32(0,p,(uInt) len+4)); } else { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""    Skipping %c%c%c%c chunk, length=%.20g."", *(p),*(p+1),*(p+2),*(p+3),(double) len); } p+=(8+len); } } else if (length != 0) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Write JDAA chunk, length=%.20g."",(double) length); (void) WriteBlobMSBULong(image,(size_t) length); PNGType(chunk,mng_JDAA); LogPNGChunk(logging,mng_JDAA,length); (void) WriteBlob(image,4,chunk); (void) WriteBlob(image,length,blob); (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob, (uInt) length)); } blob=(unsigned char *) RelinquishMagickMemory(blob); } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating jpeg_image_info.""); jpeg_image_info=(ImageInfo *) CloneImageInfo(image_info); if (jpeg_image_info == (ImageInfo *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating jpeg_image.""); jpeg_image=CloneImage(image,0,0,MagickTrue,&image->exception); if (jpeg_image == (Image *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); (void) CopyMagickString(jpeg_image->magick,""JPEG"",MaxTextExtent); (void) AcquireUniqueFilename(jpeg_image->filename); unique_filenames++; (void) FormatLocaleString(jpeg_image_info->filename,MaxTextExtent,""%s"", jpeg_image->filename); status=OpenBlob(jpeg_image_info,jpeg_image,WriteBinaryBlobMode, &image->exception); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Created jpeg_image, %.20g x %.20g."",(double) jpeg_image->columns, (double) jpeg_image->rows); if (status == MagickFalse) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); if (jng_color_type == 8 || jng_color_type == 12) jpeg_image_info->type=GrayscaleType; jpeg_image_info->quality=jng_quality; jpeg_image->quality=jng_quality; (void) CopyMagickString(jpeg_image_info->magick,""JPEG"",MaxTextExtent); (void) CopyMagickString(jpeg_image->magick,""JPEG"",MaxTextExtent); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Creating blob.""); blob=ImageToBlob(jpeg_image_info,jpeg_image,&length,&image->exception); if (logging != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Successfully read jpeg_image into a blob, length=%.20g."", (double) length); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Write JDAT chunk, length=%.20g."",(double) length); } (void) WriteBlobMSBULong(image,(size_t) length); PNGType(chunk,mng_JDAT); LogPNGChunk(logging,mng_JDAT,length); (void) WriteBlob(image,4,chunk); (void) WriteBlob(image,length,blob); (void) WriteBlobMSBULong(image,crc32(crc32(0,chunk,4),blob,(uInt) length)); jpeg_image=DestroyImage(jpeg_image); (void) RelinquishUniqueFileResource(jpeg_image_info->filename); unique_filenames--; jpeg_image_info=DestroyImageInfo(jpeg_image_info); blob=(unsigned char *) RelinquishMagickMemory(blob); (void) WriteBlobMSBULong(image,0L); PNGType(chunk,mng_IEND); LogPNGChunk(logging,mng_IEND,0); (void) WriteBlob(image,4,chunk); (void) WriteBlobMSBULong(image,crc32(0,chunk,4)); if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  exit WriteOneJNGImage(); unique_filenames=%d"",unique_filenames); return(status); }"
static byte parseHexByte(const char * &str) { byte b = parseHexChar(str[0]); if (str[1] == ':' || str[1] == '\0') { str += 2; return b; } else { b = b << 4 | parseHexChar(str[1]); str += 3; return b; } }
"void Compute(OpKernelContext* context) override { int32_t dim = context->input(0).scalar<int32_t>()(); int32_t num_results = context->input(1).scalar<int32_t>()(); int32_t skip = context->input(2).scalar<int32_t>()(); OP_REQUIRES(context, dim >= 1, errors::InvalidArgument(""dim must be at least one"")); OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim, errors::InvalidArgument(""dim must be at most "", sobol_data::kMaxSobolDim)); OP_REQUIRES(context, num_results >= 1, errors::InvalidArgument(""num_results must be at least one"")); OP_REQUIRES(context, skip >= 0, errors::InvalidArgument(""skip must be non-negative"")); OP_REQUIRES(context, num_results < std::numeric_limits<int32_t>::max() - skip, errors::InvalidArgument(""num_results+skip must be less than "", std::numeric_limits<int32_t>::max())); Tensor* output = nullptr; OP_REQUIRES_OK(context, context->allocate_output( 0, TensorShape({num_results, dim}), &output)); auto output_flat = output->flat<T>(); const DeviceBase::CpuWorkerThreads& worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); int num_threads = worker_threads.num_threads; int block_size = std::max( kMinBlockSize, static_cast<int>(std::ceil( static_cast<float>(num_results) / num_threads))); worker_threads.workers->TransformRangeConcurrently( block_size, num_results , [&dim, &skip, &output_flat](const int start, const int end) { CalculateSobolSample<T>(dim, end - start , skip, start, output_flat); }); }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_rpsi( pjmedia_rtcp_session *session,  void *buf, pj_size_t *length, const pjmedia_rtcp_fb_rpsi *rpsi) { pjmedia_rtcp_common *hdr; pj_uint8_t *p; unsigned bitlen, padlen, len; PJ_ASSERT_RETURN(session && buf && length && rpsi, PJ_EINVAL); bitlen = (unsigned)rpsi->rpsi_bit_len + 16; padlen = (32 - (bitlen % 32)) % 32; len = (3 + (bitlen+padlen)/32) * 4; if (len > *length) return PJ_ETOOSMALL; hdr = (pjmedia_rtcp_common*)buf; pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr)); hdr->pt = RTCP_PSFB; hdr->count = 3;  hdr->length = pj_htons((pj_uint16_t)(len/4 - 1)); p = (pj_uint8_t*)hdr + sizeof(*hdr); *p++ = (pj_uint8_t)padlen; *p++ = rpsi->pt & 0x7F; pj_memcpy(p, rpsi->rpsi.ptr, rpsi->rpsi_bit_len/8); p += rpsi->rpsi_bit_len/8; if (rpsi->rpsi_bit_len % 8) { *p++ = *(rpsi->rpsi.ptr + rpsi->rpsi_bit_len/8); } if (padlen >= 8) pj_bzero(p, padlen/8); *length = len; return PJ_SUCCESS; }"
"GSWindow * gs_window_new (GdkDisplay *display, GdkMonitor *monitor, gboolean   lock_enabled) { GObject   *result; GdkScreen *screen = gdk_display_get_default_screen (display); result = g_object_new (GS_TYPE_WINDOW, ""type"", GTK_WINDOW_POPUP, ""screen"", screen, ""monitor"", monitor, ""lock-enabled"", lock_enabled, ""app-paintable"", TRUE, NULL); return GS_WINDOW (result); }"
"static int msOGRFileNextShape(layerObj *layer, shapeObj *shape, msOGRFileInfo *psInfo ) { OGRFeatureH hFeature = NULL; if (psInfo == NULL || psInfo->hLayer == NULL) { msSetError(MS_MISCERR, ""Assertion failed: OGR layer not opened!!!"", ""msOGRFileNextShape()""); return(MS_FAILURE); } msFreeShape(shape); shape->type = MS_SHAPE_NULL; ACQUIRE_OGR_LOCK; while (shape->type == MS_SHAPE_NULL) { if( hFeature ) OGR_F_Destroy( hFeature ); if( (hFeature = OGR_L_GetNextFeature( psInfo->hLayer )) == NULL ) { psInfo->last_record_index_read = -1; if( CPLGetLastErrorType() == CE_Failure ) { msSetError(MS_OGRERR, ""%s"", ""msOGRFileNextShape()"", CPLGetLastErrorMsg() ); RELEASE_OGR_LOCK; return MS_FAILURE; } else { RELEASE_OGR_LOCK; if (layer->debug >= MS_DEBUGLEVEL_VV) msDebug(""msOGRFileNextShape: Returning MS_DONE (no more shapes)\n"" ); return MS_DONE;        } } psInfo->last_record_index_read++; if(layer->numitems > 0) { shape->values = msOGRGetValues(layer, hFeature); shape->numvalues = layer->numitems; if(!shape->values) { OGR_F_Destroy( hFeature ); RELEASE_OGR_LOCK; return(MS_FAILURE); } } if (ogrConvertGeometry(ogrGetLinearGeometry( hFeature ), shape, layer->type) == MS_SUCCESS) { if (shape->type != MS_SHAPE_NULL) break;  if (layer->debug >= MS_DEBUGLEVEL_VVV) msDebug(""msOGRFileNextShape: Rejecting feature (shapeid = "" CPL_FRMT_GIB "", tileid=%d) of incompatible type for this layer (feature wkbType %d, layer type %d)\n"", (GIntBig)OGR_F_GetFID( hFeature ), psInfo->nTileId, OGR_F_GetGeometryRef( hFeature )==NULL ? wkbFlatten(wkbUnknown):wkbFlatten( OGR_G_GetGeometryType( OGR_F_GetGeometryRef( hFeature ) ) ), layer->type); } else { msFreeShape(shape); OGR_F_Destroy( hFeature ); RELEASE_OGR_LOCK; return MS_FAILURE;     } msFreeShape(shape); shape->type = MS_SHAPE_NULL; } shape->index =  (int)OGR_F_GetFID( hFeature );   shape->resultindex = psInfo->last_record_index_read; shape->tileindex = psInfo->nTileId; if (layer->debug >= MS_DEBUGLEVEL_VVV) msDebug(""msOGRFileNextShape: Returning shape=%ld, tile=%d\n"", shape->index, shape->tileindex ); if (psInfo->hLastFeature) OGR_F_Destroy( psInfo->hLastFeature ); psInfo->hLastFeature = hFeature; RELEASE_OGR_LOCK; return MS_SUCCESS; }"
"static void xml_sax_parse_entity(GF_SAXParser *parser) { char szC[2]; char *ent_name=NULL; u32 i = 0; XML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities); char *skip_chars = "" \t\n\r""; i=0; if (ent && ent->value) ent = NULL; if (ent) skip_chars = NULL; szC[1]=0; while (parser->current_pos+i < parser->line_size) { u8 c = parser->buffer[parser->current_pos+i]; if (skip_chars && strchr(skip_chars, c)) { if (c=='\n') parser->line++; parser->current_pos++; continue; } if (!ent && (c=='%')) { parser->current_pos+=i+1; parser->sax_state = SAX_STATE_SKIP_DOCTYPE; if (ent_name) gf_free(ent_name); return; } else if (!ent && ((c=='\""') || (c=='\'')) ) { GF_SAFEALLOC(ent, XML_Entity); if (!ent) { parser->sax_state = SAX_STATE_ALLOC_ERROR; if (ent_name) gf_free(ent_name); return; } if (!ent_name) gf_dynstrcat(&ent_name, """", NULL); ent->name = ent_name; ent_name=NULL; ent->namelen = (u32) strlen(ent->name); ent->sep = c; parser->current_pos += 1+i; assert(parser->current_pos < parser->line_size); xml_sax_swap(parser); i=0; gf_list_add(parser->entities, ent); skip_chars = NULL; } else if (ent && c==ent->sep) { if (ent_name) gf_free(ent_name); xml_sax_store_text(parser, i); ent->value = xml_get_current_text(parser); if (!ent->value) ent->value = gf_strdup(""""); parser->current_pos += 1; assert(parser->current_pos < parser->line_size); xml_sax_swap(parser); parser->sax_state = SAX_STATE_SKIP_DOCTYPE; return; } else if (!ent) { szC[0] = c; gf_dynstrcat(&ent_name, szC, NULL); i++; } else { i++; } } if (ent_name) gf_free(ent_name); xml_sax_store_text(parser, i); }"
"bool XmlRpcClient::readResponse() { if (int(_response.length()) < _contentLength) { std::string buff; if ( ! XmlRpcSocket::nbRead(this->getfd(), buff, &_eof)) { XmlRpcUtil::error(""Error in XmlRpcClient::readResponse: read error (%s)."",XmlRpcSocket::getErrorMsg().c_str()); close(); return false; } _response += buff; if (int(_response.length()) < _contentLength) { if (_eof) { XmlRpcUtil::error(""Error in XmlRpcClient::readResponse: EOF while reading response""); close(); return false; } return true; } } XmlRpcUtil::log(3, ""XmlRpcClient::readResponse (read %d bytes)"", _response.length()); XmlRpcUtil::log(5, ""response:\n%s"", _response.c_str()); _connectionState = IDLE; return false;    }"
"static bfd_boolean read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp, bfd_byte *buf_end, struct line_info_table *table, bfd_boolean (*callback) (struct line_info_table *table, char *cur_file, unsigned int dir, unsigned int time, unsigned int size)) { bfd *abfd = unit->abfd; bfd_byte format_count, formati; bfd_vma data_count, datai; bfd_byte *buf = *bufp; bfd_byte *format_header_data; unsigned int bytes_read; format_count = read_1_byte (abfd, buf, buf_end); buf += 1; format_header_data = buf; for (formati = 0; formati < format_count; formati++) { _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; } data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; if (format_count == 0 && data_count != 0) { _bfd_error_handler (_(""Dwarf Error: Zero format count."")); bfd_set_error (bfd_error_bad_value); return FALSE; } for (datai = 0; datai < data_count; datai++) { bfd_byte *format = format_header_data; struct fileinfo fe; memset (&fe, 0, sizeof fe); for (formati = 0; formati < format_count; formati++) { bfd_vma content_type, form; char *string_trash; char **stringp = &string_trash; unsigned int uint_trash, *uintp = &uint_trash; content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (content_type) { case DW_LNCT_path: stringp = &fe.name; break; case DW_LNCT_directory_index: uintp = &fe.dir; break; case DW_LNCT_timestamp: uintp = &fe.time; break; case DW_LNCT_size: uintp = &fe.size; break; case DW_LNCT_MD5: break; default: _bfd_error_handler (_(""Dwarf Error: Unknown format content type %Lu.""), content_type); bfd_set_error (bfd_error_bad_value); return FALSE; } form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (form) { case DW_FORM_string: *stringp = read_string (abfd, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_line_strp: *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_data1: *uintp = read_1_byte (abfd, buf, buf_end); buf += 1; break; case DW_FORM_data2: *uintp = read_2_bytes (abfd, buf, buf_end); buf += 2; break; case DW_FORM_data4: *uintp = read_4_bytes (abfd, buf, buf_end); buf += 4; break; case DW_FORM_data8: *uintp = read_8_bytes (abfd, buf, buf_end); buf += 8; break; case DW_FORM_udata: *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; break; case DW_FORM_block: break; } } if (!callback (table, fe.name, fe.dir, fe.time, fe.size)) return FALSE; } *bufp = buf; return TRUE; }"
"XFontStruct *XLoadQueryFont( register Display *dpy, _Xconst char *name) { XFontStruct *font_result; register long nbytes; Font fid; xOpenFontReq *req; unsigned long seq; #ifdef USE_XF86BIGFONT XF86BigfontCodes *extcodes = _XF86BigfontCodes(dpy); #endif if (_XF86LoadQueryLocaleFont(dpy, name, &font_result, (Font *)0)) return font_result; LockDisplay(dpy); GetReq(OpenFont, req); seq = dpy->request;  nbytes = req->nbytes = (CARD16) (name ? strlen(name) : 0); req->fid = fid = XAllocID(dpy); req->length += (nbytes+3)>>2; Data (dpy, name, nbytes); font_result = NULL; #ifdef USE_XF86BIGFONT if (extcodes) { font_result = _XF86BigfontQueryFont(dpy, extcodes, fid, seq); seq = 0; } #endif if (!font_result) font_result = _XQueryFont(dpy, fid, seq); UnlockDisplay(dpy); SyncHandle(); return font_result; }"
"static int start_decoder(vorb *f) { uint8 header[6], x,y; int len,i,j,k, max_submaps = 0; int longest_floorlist=0; if (!start_page(f))                              return FALSE; if (!(f->page_flag & PAGEFLAG_first_page))       return error(f, VORBIS_invalid_first_page); if (f->page_flag & PAGEFLAG_last_page)           return error(f, VORBIS_invalid_first_page); if (f->page_flag & PAGEFLAG_continued_packet)    return error(f, VORBIS_invalid_first_page); if (f->segment_count != 1)                       return error(f, VORBIS_invalid_first_page); if (f->segments[0] != 30) { if (f->segments[0] == 64 && getn(f, header, 6) && header[0] == 'f' && header[1] == 'i' && header[2] == 's' && header[3] == 'h' && header[4] == 'e' && header[5] == 'a' && get8(f)   == 'd' && get8(f)   == '\0')                        return error(f, VORBIS_ogg_skeleton_not_supported); else return error(f, VORBIS_invalid_first_page); } if (get8(f) != VORBIS_packet_id)                 return error(f, VORBIS_invalid_first_page); if (!getn(f, header, 6))                         return error(f, VORBIS_unexpected_eof); if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_first_page); if (get32(f) != 0)                               return error(f, VORBIS_invalid_first_page); f->channels = get8(f); if (!f->channels)         return error(f, VORBIS_invalid_first_page); if (f->channels > STB_VORBIS_MAX_CHANNELS)       return error(f, VORBIS_too_many_channels); f->sample_rate = get32(f); if (!f->sample_rate)  return error(f, VORBIS_invalid_first_page); get32(f);    get32(f);    get32(f);    x = get8(f); { int log0,log1; log0 = x & 15; log1 = x >> 4; f->blocksize_0 = 1 << log0; f->blocksize_1 = 1 << log1; if (log0 < 6 || log0 > 13)                       return error(f, VORBIS_invalid_setup); if (log1 < 6 || log1 > 13)                       return error(f, VORBIS_invalid_setup); if (log0 > log1)                                 return error(f, VORBIS_invalid_setup); } x = get8(f); if (!(x & 1))                                    return error(f, VORBIS_invalid_first_page); if (!start_page(f))                              return FALSE; if (!start_packet(f))                            return FALSE; do { len = next_segment(f); skip(f, len); f->bytes_in_seg = 0; } while (len); if (!start_packet(f))                            return FALSE; #ifndef STB_VORBIS_NO_PUSHDATA_API if (IS_PUSH_MODE(f)) { if (!is_whole_packet_present(f, TRUE)) { if (f->error == VORBIS_invalid_stream) f->error = VORBIS_invalid_setup; return FALSE; } } #endif crc32_init();  if (get8_packet(f) != VORBIS_packet_setup)       return error(f, VORBIS_invalid_setup); for (i=0; i < 6; ++i) header[i] = get8_packet(f); if (!vorbis_validate(header))                    return error(f, VORBIS_invalid_setup); f->codebook_count = get_bits(f,8) + 1; f->codebooks = (Codebook *) setup_malloc(f, sizeof(*f->codebooks) * f->codebook_count); if (f->codebooks == NULL)                        return error(f, VORBIS_outofmem); memset(f->codebooks, 0, sizeof(*f->codebooks) * f->codebook_count); for (i=0; i < f->codebook_count; ++i) { uint32 *values; int ordered, sorted_count; int total=0; uint8 *lengths; Codebook *c = f->codebooks+i; CHECK(f); x = get_bits(f, 8); if (x != 0x42)            return error(f, VORBIS_invalid_setup); x = get_bits(f, 8); if (x != 0x43)            return error(f, VORBIS_invalid_setup); x = get_bits(f, 8); if (x != 0x56)            return error(f, VORBIS_invalid_setup); x = get_bits(f, 8); c->dimensions = (get_bits(f, 8)<<8) + x; x = get_bits(f, 8); y = get_bits(f, 8); c->entries = (get_bits(f, 8)<<16) + (y<<8) + x; ordered = get_bits(f,1); c->sparse = ordered ? 0 : get_bits(f,1); if (c->dimensions == 0 && c->entries != 0)    return error(f, VORBIS_invalid_setup); if (c->sparse) lengths = (uint8 *) setup_temp_malloc(f, c->entries); else lengths = c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries); if (!lengths) return error(f, VORBIS_outofmem); if (ordered) { int current_entry = 0; int current_length = get_bits(f,5) + 1; while (current_entry < c->entries) { int limit = c->entries - current_entry; int n = get_bits(f, ilog(limit)); if (current_entry + n > (int) c->entries) { return error(f, VORBIS_invalid_setup); } memset(lengths + current_entry, current_length, n); current_entry += n; ++current_length; } } else { for (j=0; j < c->entries; ++j) { int present = c->sparse ? get_bits(f,1) : 1; if (present) { lengths[j] = get_bits(f, 5) + 1; ++total; if (lengths[j] == 32) return error(f, VORBIS_invalid_setup); } else { lengths[j] = NO_CODE; } } } if (c->sparse && total >= c->entries >> 2) { if (c->entries > (int) f->setup_temp_memory_required) f->setup_temp_memory_required = c->entries; c->codeword_lengths = (uint8 *) setup_malloc(f, c->entries); if (c->codeword_lengths == NULL) return error(f, VORBIS_outofmem); memcpy(c->codeword_lengths, lengths, c->entries); setup_temp_free(f, lengths, c->entries);          lengths = c->codeword_lengths; c->sparse = 0; } if (c->sparse) { sorted_count = total; } else { sorted_count = 0; #ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for (j=0; j < c->entries; ++j) if (lengths[j] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths[j] != NO_CODE) ++sorted_count; #endif } c->sorted_entries = sorted_count; values = NULL; CHECK(f); if (!c->sparse) { c->codewords = (uint32 *) setup_malloc(f, sizeof(c->codewords[0]) * c->entries); if (!c->codewords)                  return error(f, VORBIS_outofmem); } else { unsigned int size; if (c->sorted_entries) { c->codeword_lengths = (uint8 *) setup_malloc(f, c->sorted_entries); if (!c->codeword_lengths)           return error(f, VORBIS_outofmem); c->codewords = (uint32 *) setup_temp_malloc(f, sizeof(*c->codewords) * c->sorted_entries); if (!c->codewords)                  return error(f, VORBIS_outofmem); values = (uint32 *) setup_temp_malloc(f, sizeof(*values) * c->sorted_entries); if (!values)                        return error(f, VORBIS_outofmem); } size = c->entries + (sizeof(*c->codewords) + sizeof(*values)) * c->sorted_entries; if (size > f->setup_temp_memory_required) f->setup_temp_memory_required = size; } if (!compute_codewords(c, lengths, c->entries, values)) { if (c->sparse) setup_temp_free(f, values, 0); return error(f, VORBIS_invalid_setup); } if (c->sorted_entries) { c->sorted_codewords = (uint32 *) setup_malloc(f, sizeof(*c->sorted_codewords) * (c->sorted_entries+1)); if (c->sorted_codewords == NULL) return error(f, VORBIS_outofmem); c->sorted_values    = ( int   *) setup_malloc(f, sizeof(*c->sorted_values   ) * (c->sorted_entries+1)); if (c->sorted_values == NULL) return error(f, VORBIS_outofmem); ++c->sorted_values; c->sorted_values[-1] = -1; compute_sorted_huffman(c, lengths, values); } if (c->sparse) { setup_temp_free(f, values, sizeof(*values)*c->sorted_entries); setup_temp_free(f, c->codewords, sizeof(*c->codewords)*c->sorted_entries); setup_temp_free(f, lengths, c->entries); c->codewords = NULL; } compute_accelerated_huffman(c); CHECK(f); c->lookup_type = get_bits(f, 4); if (c->lookup_type > 2) return error(f, VORBIS_invalid_setup); if (c->lookup_type > 0) { uint16 *mults; c->minimum_value = float32_unpack(get_bits(f, 32)); c->delta_value = float32_unpack(get_bits(f, 32)); c->value_bits = get_bits(f, 4)+1; c->sequence_p = get_bits(f,1); if (c->lookup_type == 1) { c->lookup_values = lookup1_values(c->entries, c->dimensions); } else { c->lookup_values = c->entries * c->dimensions; } if (c->lookup_values == 0) return error(f, VORBIS_invalid_setup); mults = (uint16 *) setup_temp_malloc(f, sizeof(mults[0]) * c->lookup_values); if (mults == NULL) return error(f, VORBIS_outofmem); for (j=0; j < (int) c->lookup_values; ++j) { int q = get_bits(f, c->value_bits); if (q == EOP) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); } mults[j] = q; } #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if (c->lookup_type == 1) { int len, sparse = c->sparse; float last=0; if (sparse) { if (c->sorted_entries == 0) goto skip; c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->sorted_entries * c->dimensions); } else c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->entries        * c->dimensions); if (c->multiplicands == NULL) { setup_temp_free(f,mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); } len = sparse ? c->sorted_entries : c->entries; for (j=0; j < len; ++j) { unsigned int z = sparse ? c->sorted_values[j] : j; unsigned int div=1; for (k=0; k < c->dimensions; ++k) { int off = (z / div) % c->lookup_values; float val = mults[off]; val = mults[off]*c->delta_value + c->minimum_value + last; c->multiplicands[j*c->dimensions + k] = val; if (c->sequence_p) last = val; if (k+1 < c->dimensions) { if (div > UINT_MAX / (unsigned int) c->lookup_values) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_invalid_setup); } div *= c->lookup_values; } } } c->lookup_type = 2; } else #endif { float last=0; CHECK(f); c->multiplicands = (codetype *) setup_malloc(f, sizeof(c->multiplicands[0]) * c->lookup_values); if (c->multiplicands == NULL) { setup_temp_free(f, mults,sizeof(mults[0])*c->lookup_values); return error(f, VORBIS_outofmem); } for (j=0; j < (int) c->lookup_values; ++j) { float val = mults[j] * c->delta_value + c->minimum_value + last; c->multiplicands[j] = val; if (c->sequence_p) last = val; } } #ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip:; #endif setup_temp_free(f, mults, sizeof(mults[0])*c->lookup_values); CHECK(f); } CHECK(f); } x = get_bits(f, 6) + 1; for (i=0; i < x; ++i) { uint32 z = get_bits(f, 16); if (z != 0) return error(f, VORBIS_invalid_setup); } f->floor_count = get_bits(f, 6)+1; f->floor_config = (Floor *)  setup_malloc(f, f->floor_count * sizeof(*f->floor_config)); if (f->floor_config == NULL) return error(f, VORBIS_outofmem); for (i=0; i < f->floor_count; ++i) { f->floor_types[i] = get_bits(f, 16); if (f->floor_types[i] > 1) return error(f, VORBIS_invalid_setup); if (f->floor_types[i] == 0) { Floor0 *g = &f->floor_config[i].floor0; g->order = get_bits(f,8); g->rate = get_bits(f,16); g->bark_map_size = get_bits(f,16); g->amplitude_bits = get_bits(f,6); g->amplitude_offset = get_bits(f,8); g->number_of_books = get_bits(f,4) + 1; for (j=0; j < g->number_of_books; ++j) g->book_list[j] = get_bits(f,8); return error(f, VORBIS_feature_not_supported); } else { stbv__floor_ordering p[31*8+2]; Floor1 *g = &f->floor_config[i].floor1; int max_class = -1;  g->partitions = get_bits(f, 5); for (j=0; j < g->partitions; ++j) { g->partition_class_list[j] = get_bits(f, 4); if (g->partition_class_list[j] > max_class) max_class = g->partition_class_list[j]; } for (j=0; j <= max_class; ++j) { g->class_dimensions[j] = get_bits(f, 3)+1; g->class_subclasses[j] = get_bits(f, 2); if (g->class_subclasses[j]) { g->class_masterbooks[j] = get_bits(f, 8); if (g->class_masterbooks[j] >= f->codebook_count) return error(f, VORBIS_invalid_setup); } for (k=0; k < 1 << g->class_subclasses[j]; ++k) { g->subclass_books[j][k] = get_bits(f,8)-1; if (g->subclass_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup); } } g->floor1_multiplier = get_bits(f,2)+1; g->rangebits = get_bits(f,4); g->Xlist[0] = 0; g->Xlist[1] = 1 << g->rangebits; g->values = 2; for (j=0; j < g->partitions; ++j) { int c = g->partition_class_list[j]; for (k=0; k < g->class_dimensions[c]; ++k) { g->Xlist[g->values] = get_bits(f, g->rangebits); ++g->values; } } for (j=0; j < g->values; ++j) { p[j].x = g->Xlist[j]; p[j].id = j; } qsort(p, g->values, sizeof(p[0]), point_compare); for (j=0; j < g->values; ++j) g->sorted_order[j] = (uint8) p[j].id; for (j=2; j < g->values; ++j) { int low,hi; neighbors(g->Xlist, j, &low,&hi); g->neighbors[j][0] = low; g->neighbors[j][1] = hi; } if (g->values > longest_floorlist) longest_floorlist = g->values; } } f->residue_count = get_bits(f, 6)+1; f->residue_config = (Residue *) setup_malloc(f, f->residue_count * sizeof(f->residue_config[0])); if (f->residue_config == NULL) return error(f, VORBIS_outofmem); memset(f->residue_config, 0, f->residue_count * sizeof(f->residue_config[0])); for (i=0; i < f->residue_count; ++i) { uint8 residue_cascade[64]; Residue *r = f->residue_config+i; f->residue_types[i] = get_bits(f, 16); if (f->residue_types[i] > 2) return error(f, VORBIS_invalid_setup); r->begin = get_bits(f, 24); r->end = get_bits(f, 24); if (r->end < r->begin) return error(f, VORBIS_invalid_setup); r->part_size = get_bits(f,24)+1; r->classifications = get_bits(f,6)+1; r->classbook = get_bits(f,8); if (r->classbook >= f->codebook_count) return error(f, VORBIS_invalid_setup); for (j=0; j < r->classifications; ++j) { uint8 high_bits=0; uint8 low_bits=get_bits(f,3); if (get_bits(f,1)) high_bits = get_bits(f,5); residue_cascade[j] = high_bits*8 + low_bits; } r->residue_books = (short (*)[8]) setup_malloc(f, sizeof(r->residue_books[0]) * r->classifications); if (r->residue_books == NULL) return error(f, VORBIS_outofmem); for (j=0; j < r->classifications; ++j) { for (k=0; k < 8; ++k) { if (residue_cascade[j] & (1 << k)) { r->residue_books[j][k] = get_bits(f, 8); if (r->residue_books[j][k] >= f->codebook_count) return error(f, VORBIS_invalid_setup); } else { r->residue_books[j][k] = -1; } } } r->classdata = (uint8 **) setup_malloc(f, sizeof(*r->classdata) * f->codebooks[r->classbook].entries); if (!r->classdata) return error(f, VORBIS_outofmem); memset(r->classdata, 0, sizeof(*r->classdata) * f->codebooks[r->classbook].entries); for (j=0; j < f->codebooks[r->classbook].entries; ++j) { int classwords = f->codebooks[r->classbook].dimensions; int temp = j; r->classdata[j] = (uint8 *) setup_malloc(f, sizeof(r->classdata[j][0]) * classwords); if (r->classdata[j] == NULL) return error(f, VORBIS_outofmem); for (k=classwords-1; k >= 0; --k) { r->classdata[j][k] = temp % r->classifications; temp /= r->classifications; } } } f->mapping_count = get_bits(f,6)+1; f->mapping = (Mapping *) setup_malloc(f, f->mapping_count * sizeof(*f->mapping)); if (f->mapping == NULL) return error(f, VORBIS_outofmem); memset(f->mapping, 0, f->mapping_count * sizeof(*f->mapping)); for (i=0; i < f->mapping_count; ++i) { Mapping *m = f->mapping + i;       int mapping_type = get_bits(f,16); if (mapping_type != 0) return error(f, VORBIS_invalid_setup); m->chan = (MappingChannel *) setup_malloc(f, f->channels * sizeof(*m->chan)); if (m->chan == NULL) return error(f, VORBIS_outofmem); if (get_bits(f,1)) m->submaps = get_bits(f,4)+1; else m->submaps = 1; if (m->submaps > max_submaps) max_submaps = m->submaps; if (get_bits(f,1)) { m->coupling_steps = get_bits(f,8)+1; for (k=0; k < m->coupling_steps; ++k) { m->chan[k].magnitude = get_bits(f, ilog(f->channels-1)); m->chan[k].angle = get_bits(f, ilog(f->channels-1)); if (m->chan[k].magnitude >= f->channels)        return error(f, VORBIS_invalid_setup); if (m->chan[k].angle     >= f->channels)        return error(f, VORBIS_invalid_setup); if (m->chan[k].magnitude == m->chan[k].angle)   return error(f, VORBIS_invalid_setup); } } else m->coupling_steps = 0; if (get_bits(f,2)) return error(f, VORBIS_invalid_setup); if (m->submaps > 1) { for (j=0; j < f->channels; ++j) { m->chan[j].mux = get_bits(f, 4); if (m->chan[j].mux >= m->submaps)                return error(f, VORBIS_invalid_setup); } } else for (j=0; j < f->channels; ++j) m->chan[j].mux = 0; for (j=0; j < m->submaps; ++j) { get_bits(f,8);          m->submap_floor[j] = get_bits(f,8); m->submap_residue[j] = get_bits(f,8); if (m->submap_floor[j] >= f->floor_count)      return error(f, VORBIS_invalid_setup); if (m->submap_residue[j] >= f->residue_count)  return error(f, VORBIS_invalid_setup); } } f->mode_count = get_bits(f, 6)+1; for (i=0; i < f->mode_count; ++i) { Mode *m = f->mode_config+i; m->blockflag = get_bits(f,1); m->windowtype = get_bits(f,16); m->transformtype = get_bits(f,16); m->mapping = get_bits(f,8); if (m->windowtype != 0)                 return error(f, VORBIS_invalid_setup); if (m->transformtype != 0)              return error(f, VORBIS_invalid_setup); if (m->mapping >= f->mapping_count)     return error(f, VORBIS_invalid_setup); } flush_packet(f); f->previous_length = 0; for (i=0; i < f->channels; ++i) { f->channel_buffers[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1); f->previous_window[i] = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2); f->finalY[i]          = (int16 *) setup_malloc(f, sizeof(int16) * longest_floorlist); if (f->channel_buffers[i] == NULL || f->previous_window[i] == NULL || f->finalY[i] == NULL) return error(f, VORBIS_outofmem); memset(f->channel_buffers[i], 0, sizeof(float) * f->blocksize_1); #ifdef STB_VORBIS_NO_DEFER_FLOOR f->floor_buffers[i]   = (float *) setup_malloc(f, sizeof(float) * f->blocksize_1/2); if (f->floor_buffers[i] == NULL) return error(f, VORBIS_outofmem); #endif } if (!init_blocksize(f, 0, f->blocksize_0)) return FALSE; if (!init_blocksize(f, 1, f->blocksize_1)) return FALSE; f->blocksize[0] = f->blocksize_0; f->blocksize[1] = f->blocksize_1; #ifdef STB_VORBIS_DIVIDE_TABLE if (integer_divide_table[1][1]==0) for (i=0; i < DIVTAB_NUMER; ++i) for (j=1; j < DIVTAB_DENOM; ++j) integer_divide_table[i][j] = i / j; #endif { uint32 imdct_mem = (f->blocksize_1 * sizeof(float) >> 1); uint32 classify_mem; int i,max_part_read=0; for (i=0; i < f->residue_count; ++i) { Residue *r = f->residue_config + i; unsigned int actual_size = f->blocksize_1 / 2; unsigned int limit_r_begin = r->begin < actual_size ? r->begin : actual_size; unsigned int limit_r_end   = r->end   < actual_size ? r->end   : actual_size; int n_read = limit_r_end - limit_r_begin; int part_read = n_read / r->part_size; if (part_read > max_part_read) max_part_read = part_read; } #ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(uint8 *)); #else classify_mem = f->channels * (sizeof(void*) + max_part_read * sizeof(int *)); #endif f->temp_memory_required = classify_mem; if (imdct_mem > f->temp_memory_required) f->temp_memory_required = imdct_mem; } f->first_decode = TRUE; if (f->alloc.alloc_buffer) { assert(f->temp_offset == f->alloc.alloc_buffer_length_in_bytes); if (f->setup_offset + sizeof(*f) + f->temp_memory_required > (unsigned) f->temp_offset) return error(f, VORBIS_outofmem); } f->first_audio_page_offset = stb_vorbis_get_file_offset(f); return TRUE; }"
"static byte * i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements, uint elt_size, client_name_t cname) { gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem; obj_header_t *obj; #ifdef MEMENTO if (Memento_failThisEvent()) return NULL; #endif obj = alloc_obj(imem, (ulong) num_elements * elt_size, &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT, cname); if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"", alloc_trace_space(imem), client_name_string(cname), (ulong) num_elements * elt_size, num_elements, elt_size, (ulong) obj); return (byte *) obj; }"
"void task_numa_free(struct task_struct *p) { struct numa_group *grp = p->numa_group; void *numa_faults = p->numa_faults; unsigned long flags; int i; if (grp) { spin_lock_irqsave(&grp->lock, flags); for (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++) grp->faults[i] -= p->numa_faults[i]; grp->total_faults -= p->total_numa_faults; grp->nr_tasks--; spin_unlock_irqrestore(&grp->lock, flags); RCU_INIT_POINTER(p->numa_group, NULL); put_numa_group(grp); } p->numa_faults = NULL; kfree(numa_faults); }"
"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len) { int rlen, remain; dpIOCtxPtr dctx; dynamicPtr *dp; dctx = (dpIOCtxPtr) ctx; dp = dctx->dp; remain = dp->logicalSize - dp->pos; if(remain >= len) { rlen = len; } else { if(remain <= 0) { return 0;  } rlen = remain; } memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen); dp->pos += rlen; return rlen; }"
"static Image *ReadXBMImage(const ImageInfo *image_info,ExceptionInfo *exception) { char buffer[MagickPathExtent], name[MagickPathExtent]; Image *image; MagickBooleanType status; register ssize_t i, x; register Quantum *q; register unsigned char *p; short int hex_digits[256]; ssize_t y; unsigned char *data; unsigned int bit, byte, bytes_per_line, height, length, padding, value, version, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } width=0; height=0; while (ReadBlobString(image,buffer) != (char *) NULL) if (sscanf(buffer,""#define %32s %u"",name,&width) == 2) if ((strlen(name) >= 6) && (LocaleCompare(name+strlen(name)-6,""_width"") == 0)) break; while (ReadBlobString(image,buffer) != (char *) NULL) if (sscanf(buffer,""#define %32s %u"",name,&height) == 2) if ((strlen(name) >= 7) && (LocaleCompare(name+strlen(name)-7,""_height"") == 0)) break; image->columns=width; image->rows=height; image->depth=8; image->storage_class=PseudoClass; image->colors=2; version=11; while (ReadBlobString(image,buffer) != (char *) NULL) { if (sscanf(buffer,""static short %32s = {"",name) == 1) version=10; else if (sscanf(buffer,""static unsigned char %32s = {"",name) == 1) version=11; else if (sscanf(buffer,""static char %32s = {"",name) == 1) version=11; else continue; p=(unsigned char *) strrchr(name,'_'); if (p == (unsigned char *) NULL) p=(unsigned char *) name; else p++; if (LocaleCompare(""bits[]"",(char *) p) == 0) break; } if ((image->columns == 0) || (image->rows == 0) || (EOFBlob(image) != MagickFalse)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); image->colormap[0].red=QuantumRange; image->colormap[0].green=QuantumRange; image->colormap[0].blue=QuantumRange; image->colormap[1].red=(Quantum) 0; image->colormap[1].green=(Quantum) 0; image->colormap[1].blue=(Quantum) 0; if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); hex_digits[(int) '0']=0; hex_digits[(int) '1']=1; hex_digits[(int) '2']=2; hex_digits[(int) '3']=3; hex_digits[(int) '4']=4; hex_digits[(int) '5']=5; hex_digits[(int) '6']=6; hex_digits[(int) '7']=7; hex_digits[(int) '8']=8; hex_digits[(int) '9']=9; hex_digits[(int) 'A']=10; hex_digits[(int) 'B']=11; hex_digits[(int) 'C']=12; hex_digits[(int) 'D']=13; hex_digits[(int) 'E']=14; hex_digits[(int) 'F']=15; hex_digits[(int) 'a']=10; hex_digits[(int) 'b']=11; hex_digits[(int) 'c']=12; hex_digits[(int) 'd']=13; hex_digits[(int) 'e']=14; hex_digits[(int) 'f']=15; hex_digits[(int) 'x']=0; hex_digits[(int) ' ']=(-1); hex_digits[(int) ',']=(-1); hex_digits[(int) '}']=(-1); hex_digits[(int) '\n']=(-1); hex_digits[(int) '\t']=(-1); padding=0; if (((image->columns % 16) != 0) && ((image->columns % 16) < 9) && (version == 10)) padding=1; bytes_per_line=(unsigned int) (image->columns+7)/8+padding; length=(unsigned int) image->rows; data=(unsigned char *) AcquireQuantumMemory(length,bytes_per_line* sizeof(*data)); if (data == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); p=data; if (version == 10) for (i=0; i < (ssize_t) (bytes_per_line*image->rows); (i+=2)) { value=XBMInteger(image,hex_digits); *p++=(unsigned char) value; if ((padding == 0) || (((i+2) % bytes_per_line) != 0)) *p++=(unsigned char) (value >> 8); } else for (i=0; i < (ssize_t) (bytes_per_line*image->rows); i++) { value=XBMInteger(image,hex_digits); *p++=(unsigned char) value; } p=data; for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; bit=0; byte=0; for (x=0; x < (ssize_t) image->columns; x++) { if (bit == 0) byte=(size_t) (*p++); SetPixelIndex(image,(Quantum) ((byte & 0x01) != 0 ? 0x01 : 0x00),q); bit++; byte>>=1; if (bit == 8) bit=0; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } data=(unsigned char *) RelinquishMagickMemory(data); (void) SyncImage(image,exception); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"StatusOr<std::vector<int64_t>> GetStride(XlaOpKernelContext* ctx) { if (ctx->num_inputs() == 1) { return stride_; } const TensorShape stride_shape = ctx->InputShape(2); if (!TensorShapeUtils::IsVector(stride_shape)) { return errors::InvalidArgument(""stride must be a vector, not shape "", stride_shape.DebugString()); } if (stride_shape.num_elements() != num_dims()) { return errors::InvalidArgument( ""Sliding window stride field must "" ""specify "", num_dims(), "" dimensions""); } std::vector<int64_t> stride; auto status = ctx->ConstantInputAsIntVector(2, &stride); if (!status.ok()) { return status; } return stride; }"
"static bfd_boolean read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp, bfd_byte *buf_end, struct line_info_table *table, bfd_boolean (*callback) (struct line_info_table *table, char *cur_file, unsigned int dir, unsigned int time, unsigned int size)) { bfd *abfd = unit->abfd; bfd_byte format_count, formati; bfd_vma data_count, datai; bfd_byte *buf = *bufp; bfd_byte *format_header_data; unsigned int bytes_read; format_count = read_1_byte (abfd, buf, buf_end); buf += 1; format_header_data = buf; for (formati = 0; formati < format_count; formati++) { _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; } data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; if (format_count == 0 && data_count != 0) { _bfd_error_handler (_(""Dwarf Error: Zero format count."")); bfd_set_error (bfd_error_bad_value); return FALSE; } for (datai = 0; datai < data_count; datai++) { bfd_byte *format = format_header_data; struct fileinfo fe; for (formati = 0; formati < format_count; formati++) { bfd_vma content_type, form; char *string_trash; char **stringp = &string_trash; unsigned int uint_trash, *uintp = &uint_trash; content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (content_type) { case DW_LNCT_path: stringp = &fe.name; break; case DW_LNCT_directory_index: uintp = &fe.dir; break; case DW_LNCT_timestamp: uintp = &fe.time; break; case DW_LNCT_size: uintp = &fe.size; break; case DW_LNCT_MD5: break; default: _bfd_error_handler (_(""Dwarf Error: Unknown format content type %Lu.""), content_type); bfd_set_error (bfd_error_bad_value); return FALSE; } form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, FALSE, buf_end); format += bytes_read; switch (form) { case DW_FORM_string: *stringp = read_string (abfd, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_line_strp: *stringp = read_indirect_line_string (unit, buf, buf_end, &bytes_read); buf += bytes_read; break; case DW_FORM_data1: *uintp = read_1_byte (abfd, buf, buf_end); buf += 1; break; case DW_FORM_data2: *uintp = read_2_bytes (abfd, buf, buf_end); buf += 2; break; case DW_FORM_data4: *uintp = read_4_bytes (abfd, buf, buf_end); buf += 4; break; case DW_FORM_data8: *uintp = read_8_bytes (abfd, buf, buf_end); buf += 8; break; case DW_FORM_udata: *uintp = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, FALSE, buf_end); buf += bytes_read; break; case DW_FORM_block: break; } } if (!callback (table, fe.name, fe.dir, fe.time, fe.size)) return FALSE; } *bufp = buf; return TRUE; }"
"void XRef::add(int num, int gen, Goffset offs, bool used) { xrefLocker(); if (num >= size) { if (num >= capacity) { entries = (XRefEntry *)greallocn(entries, num + 1, sizeof(XRefEntry)); capacity = num + 1; } for (int i = size; i < num + 1; ++i) { entries[i].offset = -1; entries[i].type = xrefEntryFree; new (&entries[i].obj) Object(objNull); entries[i].flags = 0; entries[i].gen = 0; } size = num + 1; } XRefEntry *e = getEntry(num); e->gen = gen; e->obj.setToNull(); e->flags = 0; if (used) { e->type = xrefEntryUncompressed; e->offset = offs; } else { e->type = xrefEntryFree; e->offset = 0; } }"
"static int fdtv_ca_pmt(struct firedtv *fdtv, void *arg) { struct ca_msg *msg = arg; int data_pos; int data_length; int i; data_pos = 4; if (msg->msg[3] & 0x80) { data_length = 0; for (i = 0; i < (msg->msg[3] & 0x7f); i++) data_length = (data_length << 8) + msg->msg[data_pos++]; } else { data_length = msg->msg[3]; } return avc_ca_pmt(fdtv, &msg->msg[data_pos], data_length); }"
static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t * p_code_block) { OPJ_UINT32 l_data_size; l_data_size = (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) * (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32)); if (l_data_size > p_code_block->data_size) { if (p_code_block->data) { opj_free(p_code_block->data - 1); } p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1); if (! p_code_block->data) { p_code_block->data_size = 0U; return OPJ_FALSE; } p_code_block->data_size = l_data_size; p_code_block->data[0] = 0; p_code_block->data += 1;  } return OPJ_TRUE; }
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, buffsize, col_offset, pix_offset; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) buffsize = (colsize + 1) * width; else buffsize = (rowsize + 1) * length; bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %1u bytes"", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"static char * resolveSubtable(const char *table, const char *base, const char *searchPath) { char *tableFile; static struct stat info; if (table == NULL || table[0] == '\0' || strlen(table) >= MAXSTRING * sizeof(char) * 2) return NULL; tableFile = (char *)malloc(MAXSTRING * sizeof(char) * 2); if (base) { int k; if (strlen(base) >= MAXSTRING * sizeof(char) * 2) goto failure; strcpy(tableFile, base); k = (int)strlen(tableFile); while (k >= 0 && tableFile[k] != '/' && tableFile[k] != '\\') k--; tableFile[++k] = '\0'; if (strlen(tableFile) + strlen(table) >= MAXSTRING * sizeof(char) * 2) goto failure; strcat(tableFile, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); return tableFile; } } strcpy(tableFile, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); return tableFile; } if (searchPath[0] != '\0') { char *dir; int last; char *cp; char *searchPath_copy = strdup(searchPath); for (dir = searchPath_copy;; dir = cp + 1) { for (cp = dir; *cp != '\0' && *cp != ','; cp++) ; last = (*cp == '\0'); *cp = '\0'; if (dir == cp) dir = "".""; if (strlen(dir) + strlen(table) + 1 >= MAXSTRING * sizeof(char) * 2) { free(searchPath_copy); goto failure; } sprintf(tableFile, ""%s%c%s"", dir, DIR_SEP, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); free(searchPath_copy); return tableFile; } if (last) break; if (strlen(dir) + strlen(table) + 16 >= MAXSTRING * sizeof(char) * 2) { free(searchPath_copy); goto failure; } sprintf(tableFile, ""%s%c%s%c%s%c%s"", dir, DIR_SEP, ""liblouis"", DIR_SEP, ""tables"", DIR_SEP, table); if (stat(tableFile, &info) == 0 && !(info.st_mode & S_IFDIR)) { _lou_logMessage(LOU_LOG_DEBUG, ""found table %s"", tableFile); free(searchPath_copy); return tableFile; } if (last) break; } free(searchPath_copy); } failure: free(tableFile); return NULL; }"
"static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat) { ssize_t ret; #ifdef CONFIG_COMPAT if (compat) ret = compat_rw_copy_check_uvector(type, (struct compat_iovec __user *)kiocb->ki_buf, kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec, &kiocb->ki_iovec, 1); else #endif ret = rw_copy_check_uvector(type, (struct iovec __user *)kiocb->ki_buf, kiocb->ki_nbytes, 1, &kiocb->ki_inline_vec, &kiocb->ki_iovec, 1); if (ret < 0) goto out; kiocb->ki_nr_segs = kiocb->ki_nbytes; kiocb->ki_cur_seg = 0; kiocb->ki_nbytes = ret; kiocb->ki_left = ret; ret = 0; out: return ret; }"
"static SIXELSTATUS gif_process_raster( gif_context_t  *s, gif_t          *g ) { SIXELSTATUS status = SIXEL_FALSE; unsigned char lzw_cs; signed int len, code; unsigned int first; signed int codesize, codemask, avail, oldcode, bits, valid_bits, clear; gif_lzw *p; lzw_cs = gif_get8(s); clear = 1 << lzw_cs; first = 1; codesize = lzw_cs + 1; codemask = (1 << codesize) - 1; bits = 0; valid_bits = 0; for (code = 0; code < clear; code++) { g->codes[code].prefix = -1; g->codes[code].first = (unsigned char) code; g->codes[code].suffix = (unsigned char) code; } avail = clear + 2; oldcode = (-1); len = 0; for(;;) { if (valid_bits < codesize) { if (len == 0) { len = gif_get8(s);  if (len == 0) { return SIXEL_OK; } } --len; bits |= (signed int) gif_get8(s) << valid_bits; valid_bits += 8; } else { code = bits & codemask; bits >>= codesize; valid_bits -= codesize; if (code == clear) {   codesize = lzw_cs + 1; codemask = (1 << codesize) - 1; avail = clear + 2; oldcode = -1; first = 0; } else if (code == clear + 1) {  s->img_buffer += len; while ((len = gif_get8(s)) > 0) { s->img_buffer += len; } return SIXEL_OK; } else if (code <= avail) { if (first) { sixel_helper_set_additional_message( ""corrupt GIF (reason: no clear code).""); status = SIXEL_RUNTIME_ERROR; goto end; } if (oldcode >= 0) { if (avail < 4096) { p = &g->codes[avail++]; p->prefix = (signed short) oldcode; p->first = g->codes[oldcode].first; p->suffix = (code == avail) ? p->first : g->codes[code].first; } } else if (code == avail) { sixel_helper_set_additional_message( ""corrupt GIF (reason: illegal code in raster).""); status = SIXEL_RUNTIME_ERROR; goto end; } gif_out_code(g, (unsigned short) code); if ((avail & codemask) == 0 && avail <= 0x0FFF) { codesize++; codemask = (1 << codesize) - 1; } oldcode = code; } else { sixel_helper_set_additional_message( ""corrupt GIF (reason: illegal code in raster).""); status = SIXEL_RUNTIME_ERROR; goto end; } } } status = SIXEL_OK; end: return status; }"
"bool Tensor::FromProto(Allocator* a, const TensorProto& proto) { CHECK_NOTNULL(a); TensorBuffer* p = nullptr; if (!TensorShape::IsValid(proto.tensor_shape())) return false; if (proto.dtype() == DT_INVALID) return false; TensorShape shape(proto.tensor_shape()); const int64_t N = shape.num_elements(); if (N > 0 && proto.dtype()) { bool dtype_error = false; if (!proto.tensor_content().empty()) { const auto& content = proto.tensor_content(); CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N), dtype_error = true, dtype_error = true); } else { CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N), dtype_error = true, dtype_error = true); } if (dtype_error || p == nullptr) return false; } shape_ = shape; set_dtype(proto.dtype()); UnrefIfNonNull(buf_); buf_ = p; if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) { LogMemory::RecordTensorAllocation(""Unknown (from Proto)"", LogMemory::UNKNOWN_STEP_ID, *this); } return true; }"
"void imx_register_uart_clocks(unsigned int clk_count) { imx_enabled_uart_clocks = 0; #ifdef CONFIG_OF if (imx_keep_uart_clocks) { int i; imx_uart_clocks = kcalloc(clk_count, sizeof(struct clk *), GFP_KERNEL); if (!of_stdout) return; for (i = 0; i < clk_count; i++) { imx_uart_clocks[imx_enabled_uart_clocks] = of_clk_get(of_stdout, i); if (IS_ERR(imx_uart_clocks[imx_enabled_uart_clocks])) return; if (imx_uart_clocks[imx_enabled_uart_clocks]) clk_prepare_enable(imx_uart_clocks[imx_enabled_uart_clocks++]); } } #endif }"
"static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter) { double width_d; double scale_f_d = 1.0; const double filter_width_d = DEFAULT_BOX_RADIUS; int windows_size; unsigned int u; LineContribType *res; if (scale_d < 1.0) { width_d = filter_width_d / scale_d; scale_f_d = scale_d; }  else { width_d= filter_width_d; } windows_size = 2 * (int)ceil(width_d) + 1; res = _gdContributionsAlloc(line_size, windows_size); for (u = 0; u < line_size; u++) { const double dCenter = (double)u / scale_d; register int iLeft = MAX(0, (int)floor (dCenter - width_d)); int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1); double dTotalWeight = 0.0; int iSrc; res->ContribRow[u].Left = iLeft; res->ContribRow[u].Right = iRight; if (iRight - iLeft + 1 > windows_size)  { if (iLeft < ((int)src_size - 1 / 2))  { iLeft++; } else { iRight--; } } for (iSrc = iLeft; iSrc <= iRight; iSrc++) { dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc))); } if (dTotalWeight < 0.0) { _gdContributionsFree(res); return NULL; } if (dTotalWeight > 0.0) { for (iSrc = iLeft; iSrc <= iRight; iSrc++) { res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight; } } } return res; }"
"static GF_Err svg_report(GF_SVG_Parser *parser, GF_Err e, char *format, ...) { #ifndef GPAC_DISABLE_LOG if (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) { char szMsg[2048]; va_list args; va_start(args, format); vsprintf(szMsg, format, args); va_end(args); GF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[SVG Parsing] line %d - %s\n"", gf_xml_sax_get_line(parser->sax_parser), szMsg)); } #endif if (e) { parser->last_error = e; gf_xml_sax_suspend(parser->sax_parser, GF_TRUE); } return e; }"
"std::vector<std::vector<SelectorComponentObj>> weaveParents( std::vector<SelectorComponentObj> queue1, std::vector<SelectorComponentObj> queue2) { std::vector<SelectorComponentObj> leads; std::vector<std::vector<std::vector<SelectorComponentObj>>> trails; if (!mergeInitialCombinators(queue1, queue2, leads)) return {}; if (!mergeFinalCombinators(queue1, queue2, trails)) return {}; std::reverse(trails.begin(), trails.end()); CompoundSelectorObj root1 = getFirstIfRoot(queue1); CompoundSelectorObj root2 = getFirstIfRoot(queue2); if (!root1.isNull() && !root2.isNull()) { CompoundSelectorObj root = root1->unifyWith(root2); if (root.isNull()) return {};       queue1.insert(queue1.begin(), root); queue2.insert(queue2.begin(), root); } else if (!root1.isNull()) { queue2.insert(queue2.begin(), root1); } else if (!root2.isNull()) { queue1.insert(queue1.begin(), root2); } std::vector<std::vector<SelectorComponentObj>> groups1 = groupSelectors(queue1); std::vector<std::vector<SelectorComponentObj>> groups2 = groupSelectors(queue2); std::vector<std::vector<std::vector<SelectorComponentObj>>> choices; choices.push_back({ leads }); std::vector<std::vector<SelectorComponentObj>> LCS = lcs<std::vector<SelectorComponentObj>>(groups1, groups2, cmpGroups); for (auto group : LCS) { std::vector<std::vector<std::vector<SelectorComponentObj>>> chunks = getChunks<std::vector<SelectorComponentObj>>( groups1, groups2, group, cmpChunkForParentSuperselector); std::vector<std::vector<SelectorComponentObj>> expanded = flattenInner(chunks); choices.push_back(expanded); choices.push_back({ group }); groups1.erase(groups1.begin()); groups2.erase(groups2.begin()); } std::vector<std::vector<std::vector<SelectorComponentObj>>> chunks = getChunks<std::vector<SelectorComponentObj>>( groups1, groups2, {}, cmpChunkForEmptySequence); choices.emplace_back(flattenInner(chunks)); std::move(std::begin(trails), std::end(trails), std::inserter(choices, std::end(choices))); choices.erase(std::remove_if(choices.begin(), choices.end(), checkForEmptyChild <std::vector<std::vector<SelectorComponentObj>>>), choices.end()); std::vector<std::vector<SelectorComponentObj>> results = flattenInner(permutate(choices)); return results; }"
"static int dissect_p_mul (tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) { proto_tree    *p_mul_tree, *field_tree, *checksum_tree; proto_item    *ti, *en, *len_en; gboolean       save_fragmented; guint32        message_id = 0; guint16        no_dest = 0, count = 0, len, data_len = 0; guint16        checksum_calc, checksum_found; guint16        pdu_length, no_pdus = 0, seq_no = 0; guint8         pdu_type, *value, map = 0, fec_len; gint           i, tot_no_missing = 0, no_missing = 0, offset = 0; address        src, dst; wmem_strbuf_t *message_id_list = NULL; nstime_t       ts; gboolean       fletcher = FALSE; col_set_str (pinfo->cinfo, COL_PROTOCOL, ""P_MUL""); col_clear (pinfo->cinfo, COL_INFO); pdu_type = tvb_get_guint8 (tvb, offset + 3) & 0x3F; ti = proto_tree_add_item (tree, proto_p_mul, tvb, offset, -1, ENC_NA); proto_item_append_text (ti, "", %s"", get_type (pdu_type)); p_mul_tree = proto_item_add_subtree (ti, ett_p_mul); pdu_length = tvb_get_ntohs (tvb, offset); len_en = proto_tree_add_item (p_mul_tree, hf_length, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; switch (pdu_type) { case Data_PDU: case Ack_PDU: case Address_PDU: case Discard_Message_PDU: case Extra_Address_PDU: case FEC_Address_PDU: case Extra_FEC_Address_PDU: proto_tree_add_item (p_mul_tree, hf_priority, tvb, offset, 1, ENC_BIG_ENDIAN); break; default: proto_tree_add_item (p_mul_tree, hf_unused8, tvb, offset, 1, ENC_BIG_ENDIAN); } offset += 1; en = proto_tree_add_uint_format (p_mul_tree, hf_pdu_type, tvb, offset, 1, pdu_type, ""PDU Type: %s (0x%02x)"", get_type (pdu_type), pdu_type); field_tree = proto_item_add_subtree (en, ett_pdu_type); if (pdu_type == Discard_Message_PDU) { expert_add_info(pinfo, en, &ei_message_discarded); } switch (pdu_type) { case Address_PDU: case Announce_PDU: case Extra_Address_PDU: case FEC_Address_PDU: case Extra_FEC_Address_PDU: map = tvb_get_guint8 (tvb, offset); proto_tree_add_item (field_tree, hf_map_first, tvb, offset, 1, ENC_BIG_ENDIAN); proto_tree_add_item (field_tree, hf_map_last, tvb, offset, 1, ENC_BIG_ENDIAN); if ((map & 0x80) || (map & 0x40)) { proto_item_append_text (en, "", %s / %s"", (map & 0x80) ? ""Not first"" : ""First"", (map & 0x40) ? ""Not last"" : ""Last""); } else { proto_item_append_text (en, "", Only one PDU""); } break; default: proto_tree_add_item (field_tree, hf_map_unused, tvb, offset, 1, ENC_BIG_ENDIAN); break; } proto_tree_add_item (field_tree, hf_pdu_type_value, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; switch (pdu_type) { case Address_PDU: case Extra_Address_PDU: case FEC_Address_PDU: case Extra_FEC_Address_PDU: no_pdus = tvb_get_ntohs (tvb, offset); seq_no = 0; proto_tree_add_item (p_mul_tree, hf_no_pdus, tvb, offset, 2, ENC_BIG_ENDIAN); proto_item_append_text (ti, "", No PDUs: %u"", no_pdus); break; case Data_PDU: seq_no = tvb_get_ntohs (tvb, offset); proto_tree_add_item (p_mul_tree, hf_seq_no, tvb, offset, 2, ENC_BIG_ENDIAN); proto_item_append_text (ti, "", Seq no: %u"", seq_no); break; case Announce_PDU: count = tvb_get_ntohs (tvb, offset); proto_tree_add_item (p_mul_tree, hf_count_of_dest, tvb, offset, 2, ENC_BIG_ENDIAN); break; default: proto_tree_add_item (p_mul_tree, hf_unused16, tvb, offset, 2, ENC_BIG_ENDIAN); break; } offset += 2; en = proto_tree_add_item (p_mul_tree, hf_checksum, tvb, offset, 2, ENC_BIG_ENDIAN); checksum_tree = proto_item_add_subtree (en, ett_checksum); len = tvb_captured_length (tvb); value = (guint8 *)tvb_memdup (wmem_packet_scope(), tvb, 0, len); if (len >= offset+2) { value[offset] = 0; value[offset+1] = 0; } checksum_found = tvb_get_ntohs (tvb, offset); checksum_calc = g_ntohs (ip_checksum (value, len)); if (checksum_calc != checksum_found) { guint16 checksum1 = checksum_acp142 (value, len, offset); if (checksum1 == checksum_found) { checksum_calc = checksum1; fletcher = TRUE; } } if (checksum_calc == checksum_found) { if (fletcher) { proto_item_append_text (en, "" [Fletcher algorithm]""); } proto_item_append_text (en, "" (correct)""); en = proto_tree_add_boolean (checksum_tree, hf_checksum_good, tvb, offset, 2, TRUE); PROTO_ITEM_SET_GENERATED (en); en = proto_tree_add_boolean (checksum_tree, hf_checksum_bad, tvb, offset, 2, FALSE); PROTO_ITEM_SET_GENERATED (en); } else { proto_item_append_text (en, "" (incorrect, should be 0x%04x)"", checksum_calc); expert_add_info(pinfo, en, &ei_checksum_bad); en = proto_tree_add_boolean (checksum_tree, hf_checksum_good, tvb, offset, 2, FALSE); PROTO_ITEM_SET_GENERATED (en); en = proto_tree_add_boolean (checksum_tree, hf_checksum_bad, tvb, offset, 2, TRUE); PROTO_ITEM_SET_GENERATED (en); } offset += 2; if (pdu_type == Ack_PDU) { set_address_tvb (&dst, AT_IPv4, 4, tvb, offset); proto_tree_add_item (p_mul_tree, hf_source_id_ack, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; count = tvb_get_ntohs (tvb, offset); proto_tree_add_item (p_mul_tree, hf_ack_count, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; } else { set_address_tvb (&src, AT_IPv4, 4, tvb, offset); proto_tree_add_item (p_mul_tree, hf_source_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; message_id = tvb_get_ntohl (tvb, offset); if (use_relative_msgid) { if (message_id_offset == 0) { message_id_offset = message_id; } message_id -= message_id_offset; proto_tree_add_uint_format_value(p_mul_tree, hf_message_id, tvb, offset, 4, message_id, ""%u    (relative message id)"", message_id); } else { proto_tree_add_item (p_mul_tree, hf_message_id, tvb, offset, 4, ENC_BIG_ENDIAN); } offset += 4; proto_item_append_text (ti, "", MSID: %u"", message_id); } if (pdu_type == Address_PDU || pdu_type == Announce_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) { ts.secs = tvb_get_ntohl (tvb, offset); ts.nsecs = 0; proto_tree_add_time (p_mul_tree, hf_expiry_time, tvb, offset, 4, &ts); offset += 4; } if (pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) { fec_len = tvb_get_guint8 (tvb, offset); proto_tree_add_item (p_mul_tree, hf_fec_len, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item (p_mul_tree, hf_fec_id, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; if (fec_len > 0) { proto_tree_add_none_format (p_mul_tree, hf_fec_parameters, tvb, offset, fec_len, ""FEC Parameters (%d byte%s)"", fec_len, plurality (fec_len, """", ""s"")); offset += fec_len; } } switch (pdu_type) { case Address_PDU: case Extra_Address_PDU: case FEC_Address_PDU: case Extra_FEC_Address_PDU: no_dest = tvb_get_ntohs (tvb, offset); proto_tree_add_item (p_mul_tree, hf_count_of_dest, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; len = tvb_get_ntohs (tvb, offset); proto_tree_add_item (p_mul_tree, hf_length_of_res, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; for (i = 0; i < no_dest; i++) { en = proto_tree_add_none_format (p_mul_tree, hf_dest_entry, tvb, offset, 8 + len, ""Destination Entry #%d"", i + 1); field_tree = proto_item_add_subtree (en, ett_dest_entry); set_address_tvb (&dst, AT_IPv4, 4, tvb, offset); proto_tree_add_item (field_tree, hf_dest_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; proto_tree_add_item (field_tree, hf_msg_seq_no, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; if (len > 0) { proto_tree_add_none_format (field_tree, hf_sym_key, tvb, offset, len, ""Symmetric Key (%d byte%s)"", len, plurality (len, """", ""s"")); offset += len; } if (use_seq_ack_analysis) { add_ack_analysis (tvb, pinfo, field_tree, offset, pdu_type, &src, &dst, message_id, 0); } } if (no_dest == 0 && use_seq_ack_analysis) { add_ack_analysis (tvb, pinfo, p_mul_tree, offset, pdu_type, &src, NULL, message_id, 0); } proto_item_append_text (ti, "", Count of Dest: %u"", no_dest); break; case Data_PDU: data_len = tvb_captured_length_remaining (tvb, offset); proto_tree_add_none_format (p_mul_tree, hf_data_fragment, tvb, offset, data_len, ""Fragment %d of Data (%d byte%s)"", seq_no, data_len, plurality (data_len, """", ""s"")); break; case Ack_PDU: message_id_list = wmem_strbuf_new_label(wmem_packet_scope()); for (i = 0; i < count; i++) { len = tvb_get_ntohs (tvb, offset); en = proto_tree_add_none_format (p_mul_tree, hf_ack_entry, tvb, offset, len, ""Ack Info Entry #%d"", i + 1); field_tree = proto_item_add_subtree (en, ett_ack_entry); en = proto_tree_add_item (field_tree, hf_ack_length, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; if (len < 10) { proto_item_append_text (en, ""    (invalid length)""); expert_add_info(pinfo, en, &ei_ack_length); } set_address_tvb (&src, AT_IPv4, 4, tvb, offset); proto_tree_add_item (field_tree, hf_source_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; message_id = tvb_get_ntohl (tvb, offset); if (use_relative_msgid) { if (message_id_offset == 0) { message_id_offset = message_id; } message_id -= message_id_offset; proto_tree_add_uint_format_value(field_tree, hf_message_id, tvb, offset, 4, message_id, ""%u    (relative message id)"", message_id); } else { proto_tree_add_item (field_tree, hf_message_id, tvb, offset, 4, ENC_BIG_ENDIAN); } offset += 4; if (i == 0) { wmem_strbuf_append_printf (message_id_list, ""%u"", message_id); } else { wmem_strbuf_append_printf (message_id_list, "",%u"", message_id); } if (len > 10) { gint num_seq_no = (len - 10) / 2; guint16 ack_seq_no, prev_ack_seq_no = 0; for (no_missing = 0; no_missing < num_seq_no; no_missing++) { ack_seq_no = tvb_get_ntohs (tvb, offset); if ((ack_seq_no != 0) && (no_missing < num_seq_no - 2) && tvb_get_ntohs (tvb, offset + 2) == 0) { guint16 end_seq_no = tvb_get_ntohs (tvb, offset + 4); en = proto_tree_add_bytes_format_value(field_tree, hf_miss_seq_range, tvb, offset, 6, NULL, ""%d - %d"", ack_seq_no, end_seq_no); if (ack_seq_no >= end_seq_no) { proto_item_append_text (en, ""    (invalid)""); expert_add_info(pinfo, en, &ei_miss_seq_range); } else { proto_tree *missing_tree; guint16 sno; missing_tree = proto_item_add_subtree (en, ett_range_entry); for (sno = ack_seq_no; sno <= end_seq_no; sno++) { en = proto_tree_add_uint_format_value(missing_tree, hf_miss_seq_no, tvb, offset, 6, sno, ""%d"", sno); PROTO_ITEM_SET_GENERATED (en); } tot_no_missing += (end_seq_no - ack_seq_no + 1); } offset += 6; no_missing += 2;  prev_ack_seq_no = end_seq_no; } else { en = proto_tree_add_item (field_tree, hf_miss_seq_no, tvb,offset, 2, ENC_BIG_ENDIAN); offset += 2; if (ack_seq_no == 0) { proto_item_append_text (en, ""    (invalid)""); expert_add_info(pinfo, en, &ei_miss_seq_no); } else if (ack_seq_no <= prev_ack_seq_no) { proto_item_append_text (en, ""    (end of list indicator)""); } else { tot_no_missing++; } prev_ack_seq_no = ack_seq_no; } } } if (use_seq_ack_analysis) { add_ack_analysis (tvb, pinfo, field_tree, offset, pdu_type, &src, &dst, message_id, no_missing); } } proto_item_append_text (ti, "", Count of Ack: %u"", count); if (tvb_reported_length_remaining (tvb, offset) >= 8) { guint64 timestamp; timestamp = tvb_get_ntoh64 (tvb, offset); proto_tree_add_uint64_format_value(p_mul_tree, hf_timestamp_option, tvb, offset, 8, timestamp, ""%"" G_GINT64_MODIFIER ""d.%d second%s (%"" G_GINT64_MODIFIER ""u)"", timestamp / 10, (int) timestamp % 10, (timestamp == 10) ? """" : ""s"", timestamp); offset += 8; } if (tot_no_missing) { proto_item_append_text (ti, "", Missing seq numbers: %u"", tot_no_missing); en = proto_tree_add_uint (p_mul_tree, hf_tot_miss_seq_no, tvb, 0, 0, tot_no_missing); PROTO_ITEM_SET_GENERATED (en); expert_add_info_format(pinfo, en, &ei_tot_miss_seq_no, ""Missing seq numbers: %d"", tot_no_missing); } break; case Discard_Message_PDU: seq_no = G_MAXUINT16;        break; case Announce_PDU: proto_tree_add_item (p_mul_tree, hf_ann_mc_group, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; for (i = 0; i < count; i++) { proto_tree_add_item (p_mul_tree, hf_dest_id, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; } break; case Request_PDU: case Reject_PDU: case Release_PDU: proto_tree_add_item (p_mul_tree, hf_mc_group, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; default: break; } if (use_seq_ack_analysis && (pdu_type <= Discard_Message_PDU) && (pdu_type != Ack_PDU) && (pdu_type != Address_PDU || no_dest != 0)) { add_seq_analysis (tvb, pinfo, p_mul_tree, &src, offset, pdu_type, message_id, seq_no, tot_no_missing); } if (pdu_type == Address_PDU && no_dest == 0) { col_append_str (pinfo->cinfo, COL_INFO, get_type (Ack_Ack_PDU)); } else { col_append_str (pinfo->cinfo, COL_INFO, get_type (pdu_type)); } if (pdu_type == Address_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) { col_append_fstr (pinfo->cinfo, COL_INFO, "", No PDUs: %u"", no_pdus); } else if (pdu_type == Data_PDU) { col_append_fstr (pinfo->cinfo, COL_INFO, "", Seq no: %u"", seq_no); } if (pdu_type == Address_PDU || pdu_type == Extra_Address_PDU || pdu_type == FEC_Address_PDU || pdu_type == Extra_FEC_Address_PDU) { if (no_dest > 0) { col_append_fstr (pinfo->cinfo, COL_INFO, "", Count of Dest: %u"", no_dest); } } else if (pdu_type == Ack_PDU) { if (tot_no_missing) { col_append_fstr (pinfo->cinfo, COL_INFO, "", Missing seq numbers: %u"", tot_no_missing); } col_append_fstr (pinfo->cinfo, COL_INFO, "", Count of Ack: %u"", count); } if (pdu_type != Ack_PDU) { col_append_fstr (pinfo->cinfo, COL_INFO, "", MSID: %u"", message_id); } else { if (message_id_list && wmem_strbuf_get_len(message_id_list) > 0) { col_append_fstr (pinfo->cinfo, COL_INFO, "", MSID: %s"", wmem_strbuf_get_str(message_id_list)); } } if (p_mul_reassemble) { save_fragmented = pinfo->fragmented; if (pdu_type == Address_PDU && no_pdus > 0) { fragment_start_seq_check (&p_mul_reassembly_table, pinfo, message_id, NULL, no_pdus - 1); } else if (pdu_type == Data_PDU) { fragment_head *frag_msg; tvbuff_t      *new_tvb; pinfo->fragmented = TRUE; frag_msg = fragment_add_seq_check (&p_mul_reassembly_table, tvb, offset, pinfo, message_id, NULL, seq_no - 1, data_len, TRUE); new_tvb = process_reassembled_data (tvb, offset, pinfo, ""Reassembled P_MUL"", frag_msg, &p_mul_frag_items, NULL, tree); if (frag_msg) col_append_str (pinfo->cinfo, COL_INFO, "" (Message Reassembled)""); if (new_tvb) { dissect_reassembled_data (new_tvb, pinfo, tree); } } pinfo->fragmented = save_fragmented; } proto_item_set_len (ti, offset); if (pdu_length != (offset + data_len)) { proto_item_append_text (len_en, "" (incorrect, should be: %d)"", offset + data_len); expert_add_info(pinfo, len_en, &ei_length); } else if ((len = tvb_reported_length_remaining (tvb, pdu_length)) > 0) { proto_item_append_text (len_en, "" (more data in packet: %d)"", len); expert_add_info(pinfo, len_en, &ei_more_data); } return offset; }"
const mbfl_encoding *mbfl_encoding_detector_judge2(mbfl_encoding_detector *identd) { mbfl_identify_filter *filter; const mbfl_encoding *encoding = NULL; int n; if (identd != NULL) { n = identd->filter_list_size - 1; while (n >= 0) { filter = identd->filter_list[n]; if (!filter->flag) { if (!identd->strict || !filter->status) { encoding = filter->encoding; } } n--; } if (!encoding) { n = identd->filter_list_size - 1; while (n >= 0) { filter = identd->filter_list[n]; if (!filter->flag) { encoding = filter->encoding; } n--; } } } return encoding; }
"void eigrp_print(netdissect_options *ndo, register const u_char *pptr, register u_int len) { const struct eigrp_common_header *eigrp_com_header; const struct eigrp_tlv_header *eigrp_tlv_header; const u_char *tptr,*tlv_tptr; u_int tlen,eigrp_tlv_len,eigrp_tlv_type,tlv_tlen, byte_length, bit_length; uint8_t prefix[4]; union { const struct eigrp_tlv_general_parm_t *eigrp_tlv_general_parm; const struct eigrp_tlv_sw_version_t *eigrp_tlv_sw_version; const struct eigrp_tlv_ip_int_t *eigrp_tlv_ip_int; const struct eigrp_tlv_ip_ext_t *eigrp_tlv_ip_ext; const struct eigrp_tlv_at_cable_setup_t *eigrp_tlv_at_cable_setup; const struct eigrp_tlv_at_int_t *eigrp_tlv_at_int; const struct eigrp_tlv_at_ext_t *eigrp_tlv_at_ext; } tlv_ptr; tptr=pptr; eigrp_com_header = (const struct eigrp_common_header *)pptr; ND_TCHECK(*eigrp_com_header); if (eigrp_com_header->version != EIGRP_VERSION) { ND_PRINT((ndo, ""EIGRP version %u packet not supported"",eigrp_com_header->version)); return; } if (ndo->ndo_vflag < 1) { ND_PRINT((ndo, ""EIGRP %s, length: %u"", tok2str(eigrp_opcode_values, ""unknown (%u)"",eigrp_com_header->opcode), len)); return; } tlen=len-sizeof(struct eigrp_common_header); ND_PRINT((ndo, ""\n\tEIGRP v%u, opcode: %s (%u), chksum: 0x%04x, Flags: [%s]\n\tseq: 0x%08x, ack: 0x%08x, AS: %u, length: %u"", eigrp_com_header->version, tok2str(eigrp_opcode_values, ""unknown, type: %u"",eigrp_com_header->opcode), eigrp_com_header->opcode, EXTRACT_16BITS(&eigrp_com_header->checksum), tok2str(eigrp_common_header_flag_values, ""none"", EXTRACT_32BITS(&eigrp_com_header->flags)), EXTRACT_32BITS(&eigrp_com_header->seq), EXTRACT_32BITS(&eigrp_com_header->ack), EXTRACT_32BITS(&eigrp_com_header->asn), tlen)); tptr+=sizeof(const struct eigrp_common_header); while(tlen>0) { ND_TCHECK2(*tptr, sizeof(struct eigrp_tlv_header)); eigrp_tlv_header = (const struct eigrp_tlv_header *)tptr; eigrp_tlv_len=EXTRACT_16BITS(&eigrp_tlv_header->length); eigrp_tlv_type=EXTRACT_16BITS(&eigrp_tlv_header->type); if (eigrp_tlv_len < sizeof(struct eigrp_tlv_header) || eigrp_tlv_len > tlen) { print_unknown_data(ndo,tptr+sizeof(struct eigrp_tlv_header),""\n\t    "",tlen); return; } ND_PRINT((ndo, ""\n\t  %s TLV (0x%04x), length: %u"", tok2str(eigrp_tlv_values, ""Unknown"", eigrp_tlv_type), eigrp_tlv_type, eigrp_tlv_len)); tlv_tptr=tptr+sizeof(struct eigrp_tlv_header); tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header); ND_TCHECK2(*tptr, eigrp_tlv_len); switch(eigrp_tlv_type) { case EIGRP_TLV_GENERAL_PARM: tlv_ptr.eigrp_tlv_general_parm = (const struct eigrp_tlv_general_parm_t *)tlv_tptr; ND_PRINT((ndo, ""\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u"", EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime), tlv_ptr.eigrp_tlv_general_parm->k1, tlv_ptr.eigrp_tlv_general_parm->k2, tlv_ptr.eigrp_tlv_general_parm->k3, tlv_ptr.eigrp_tlv_general_parm->k4, tlv_ptr.eigrp_tlv_general_parm->k5)); break; case EIGRP_TLV_SW_VERSION: tlv_ptr.eigrp_tlv_sw_version = (const struct eigrp_tlv_sw_version_t *)tlv_tptr; ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"", tlv_ptr.eigrp_tlv_sw_version->ios_major, tlv_ptr.eigrp_tlv_sw_version->ios_minor, tlv_ptr.eigrp_tlv_sw_version->eigrp_major, tlv_ptr.eigrp_tlv_sw_version->eigrp_minor)); break; case EIGRP_TLV_IP_INT: tlv_ptr.eigrp_tlv_ip_int = (const struct eigrp_tlv_ip_int_t *)tlv_tptr; bit_length = tlv_ptr.eigrp_tlv_ip_int->plen; if (bit_length > 32) { ND_PRINT((ndo, ""\n\t    illegal prefix length %u"",bit_length)); break; } byte_length = (bit_length + 7) / 8;  memset(prefix, 0, 4); memcpy(prefix,&tlv_ptr.eigrp_tlv_ip_int->destination,byte_length); ND_PRINT((ndo, ""\n\t    IPv4 prefix: %15s/%u, nexthop: "", ipaddr_string(ndo, prefix), bit_length)); if (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->nexthop) == 0) ND_PRINT((ndo, ""self"")); else ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_int->nexthop))); ND_PRINT((ndo, ""\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u"", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_int->mtu), tlv_ptr.eigrp_tlv_ip_int->hopcount, tlv_ptr.eigrp_tlv_ip_int->reliability, tlv_ptr.eigrp_tlv_ip_int->load)); break; case EIGRP_TLV_IP_EXT: tlv_ptr.eigrp_tlv_ip_ext = (const struct eigrp_tlv_ip_ext_t *)tlv_tptr; bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen; if (bit_length > 32) { ND_PRINT((ndo, ""\n\t    illegal prefix length %u"",bit_length)); break; } byte_length = (bit_length + 7) / 8;  memset(prefix, 0, 4); memcpy(prefix,&tlv_ptr.eigrp_tlv_ip_ext->destination,byte_length); ND_PRINT((ndo, ""\n\t    IPv4 prefix: %15s/%u, nexthop: "", ipaddr_string(ndo, prefix), bit_length)); if (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->nexthop) == 0) ND_PRINT((ndo, ""self"")); else ND_PRINT((ndo, ""%s"",ipaddr_string(ndo, &tlv_ptr.eigrp_tlv_ip_ext->nexthop))); ND_PRINT((ndo, ""\n\t      origin-router %s, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u"", ipaddr_string(ndo, tlv_ptr.eigrp_tlv_ip_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->origin_as), tok2str(eigrp_ext_proto_id_values,""unknown"",tlv_ptr.eigrp_tlv_ip_ext->proto_id), tlv_ptr.eigrp_tlv_ip_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->tag), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_ip_ext->metric))); ND_PRINT((ndo, ""\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u"", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_ip_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_ip_ext->mtu), tlv_ptr.eigrp_tlv_ip_ext->hopcount, tlv_ptr.eigrp_tlv_ip_ext->reliability, tlv_ptr.eigrp_tlv_ip_ext->load)); break; case EIGRP_TLV_AT_CABLE_SETUP: tlv_ptr.eigrp_tlv_at_cable_setup = (const struct eigrp_tlv_at_cable_setup_t *)tlv_tptr; ND_PRINT((ndo, ""\n\t    Cable-range: %u-%u, Router-ID %u"", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_end), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->router_id))); break; case EIGRP_TLV_AT_INT: tlv_ptr.eigrp_tlv_at_int = (const struct eigrp_tlv_at_int_t *)tlv_tptr; ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_end))); if (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop) == 0) ND_PRINT((ndo, ""self"")); else ND_PRINT((ndo, ""%u.%u"", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->nexthop[2]))); ND_PRINT((ndo, ""\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u"", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_int->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_int->mtu), tlv_ptr.eigrp_tlv_at_int->hopcount, tlv_ptr.eigrp_tlv_at_int->reliability, tlv_ptr.eigrp_tlv_at_int->load)); break; case EIGRP_TLV_AT_EXT: tlv_ptr.eigrp_tlv_at_ext = (const struct eigrp_tlv_at_ext_t *)tlv_tptr; ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_end))); if (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop) == 0) ND_PRINT((ndo, ""self"")); else ND_PRINT((ndo, ""%u.%u"", EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop), EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->nexthop[2]))); ND_PRINT((ndo, ""\n\t      origin-router %u, origin-as %u, origin-proto %s, flags [0x%02x], tag 0x%08x, metric %u"", EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_router), EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->origin_as), tok2str(eigrp_ext_proto_id_values,""unknown"",tlv_ptr.eigrp_tlv_at_ext->proto_id), tlv_ptr.eigrp_tlv_at_ext->flags, EXTRACT_32BITS(tlv_ptr.eigrp_tlv_at_ext->tag), EXTRACT_16BITS(tlv_ptr.eigrp_tlv_at_ext->metric))); ND_PRINT((ndo, ""\n\t      delay %u ms, bandwidth %u Kbps, mtu %u, hop %u, reliability %u, load %u"", (EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->delay)/100), EXTRACT_32BITS(&tlv_ptr.eigrp_tlv_at_ext->bandwidth), EXTRACT_24BITS(&tlv_ptr.eigrp_tlv_at_ext->mtu), tlv_ptr.eigrp_tlv_at_ext->hopcount, tlv_ptr.eigrp_tlv_at_ext->reliability, tlv_ptr.eigrp_tlv_at_ext->load)); break; case EIGRP_TLV_AUTH: case EIGRP_TLV_SEQ: case EIGRP_TLV_MCAST_SEQ: case EIGRP_TLV_IPX_INT: case EIGRP_TLV_IPX_EXT: default: if (ndo->ndo_vflag <= 1) print_unknown_data(ndo,tlv_tptr,""\n\t    "",tlv_tlen); break; } if (ndo->ndo_vflag > 1) print_unknown_data(ndo,tptr+sizeof(struct eigrp_tlv_header),""\n\t    "", eigrp_tlv_len-sizeof(struct eigrp_tlv_header)); tptr+=eigrp_tlv_len; tlen-=eigrp_tlv_len; } return; trunc: ND_PRINT((ndo, ""\n\t\t packet exceeded snapshot"")); }"
"GVariant * g_variant_byteswap (GVariant *value) { GVariantTypeInfo *type_info; guint alignment; GVariant *new; type_info = g_variant_get_type_info (value); g_variant_type_info_query (type_info, &alignment, NULL); if (alignment) { GVariantSerialised serialised = { 0, }; GVariant *trusted; GBytes *bytes; trusted = g_variant_get_normal_form (value); serialised.type_info = g_variant_get_type_info (trusted); serialised.size = g_variant_get_size (trusted); serialised.data = g_malloc (serialised.size); serialised.depth = g_variant_get_depth (trusted); serialised.ordered_offsets_up_to = G_MAXSIZE;   serialised.checked_offsets_up_to = G_MAXSIZE; g_variant_store (trusted, serialised.data); g_variant_unref (trusted); g_variant_serialised_byteswap (serialised); bytes = g_bytes_new_take (serialised.data, serialised.size); new = g_variant_ref_sink (g_variant_new_from_bytes (g_variant_get_type (value), bytes, TRUE)); g_bytes_unref (bytes); } else new = g_variant_get_normal_form (value); g_assert (g_variant_is_trusted (new)); return g_steal_pointer (&new); }"
"static int tree_evaluate(X509_POLICY_TREE *tree) { int ret, i; X509_POLICY_LEVEL *curr = tree->levels + 1; const X509_POLICY_CACHE *cache; for (i = 1; i < tree->nlevel; i++, curr++) { cache = policy_cache_set(curr->cert); if (!tree_link_nodes(curr, cache)) return X509_PCY_TREE_INTERNAL; if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY) && !tree_link_any(curr, cache, tree)) return X509_PCY_TREE_INTERNAL; #ifdef OPENSSL_POLICY_DEBUG tree_print(""before tree_prune()"", tree, curr); #endif ret = tree_prune(tree, curr); if (ret != X509_PCY_TREE_VALID) return ret; } return X509_PCY_TREE_VALID; }"
"static void cairo_ft_apply_variations (FT_Face                 face, cairo_ft_scaled_font_t *scaled_font) { FT_MM_Var *ft_mm_var; FT_Error ret; unsigned int instance_id = scaled_font->unscaled->id >> 16; ret = FT_Get_MM_Var (face, &ft_mm_var); if (ret == 0) { FT_Fixed *current_coords; FT_Fixed *coords; unsigned int i; const char *p; coords = malloc (sizeof (FT_Fixed) * ft_mm_var->num_axis); if (scaled_font->unscaled->variations) { memcpy (coords, scaled_font->unscaled->variations, ft_mm_var->num_axis * sizeof (*coords)); } else if (instance_id && instance_id <= ft_mm_var->num_namedstyles) { FT_Var_Named_Style *instance = &ft_mm_var->namedstyle[instance_id - 1]; memcpy (coords, instance->coords, ft_mm_var->num_axis * sizeof (*coords)); } else for (i = 0; i < ft_mm_var->num_axis; i++) coords[i] = ft_mm_var->axis[i].def; p = scaled_font->ft_options.base.variations; while (p && *p) { const char *start; const char *end, *end2; FT_ULong tag; double value; while (_cairo_isspace (*p)) p++; start = p; end = strchr (p, ','); if (end && (end - p < 6)) goto skip; tag = FT_MAKE_TAG(p[0], p[1], p[2], p[3]); p += 4; while (_cairo_isspace (*p)) p++; if (*p == '=') p++; if (p - start < 5) goto skip; value = _cairo_strtod (p, (char **) &end2); while (end2 && _cairo_isspace (*end2)) end2++; if (end2 && (*end2 != ',' && *end2 != '\0')) goto skip; for (i = 0; i < ft_mm_var->num_axis; i++) { if (ft_mm_var->axis[i].tag == tag) { coords[i] = (FT_Fixed)(value*65536); break; } } skip: p = end ? end + 1 : NULL; } current_coords = malloc (sizeof (FT_Fixed) * ft_mm_var->num_axis); #ifdef HAVE_FT_GET_VAR_DESIGN_COORDINATES ret = FT_Get_Var_Design_Coordinates (face, ft_mm_var->num_axis, current_coords); if (ret == 0) { for (i = 0; i < ft_mm_var->num_axis; i++) { if (coords[i] != current_coords[i]) break; } if (i == ft_mm_var->num_axis) goto done; } #endif FT_Set_Var_Design_Coordinates (face, ft_mm_var->num_axis, coords); done: free (coords); free (current_coords); free (ft_mm_var); } }"
"njs_typed_array_t * njs_typed_array_alloc(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_bool_t zeroing, njs_object_type_t type) { double              num; int64_t             i, length; uint32_t            element_size; uint64_t            size, offset; njs_int_t           ret; njs_value_t         *value, prop; njs_array_t         *src_array; njs_typed_array_t   *array, *src_tarray; njs_array_buffer_t  *buffer; size = 0; length = 0; offset = 0; buffer = NULL; src_array = NULL; src_tarray = NULL; element_size = njs_typed_array_element_size(type); value = njs_arg(args, nargs, 0); if (njs_is_array_buffer(value)) { buffer = njs_array_buffer(value); ret = njs_value_to_index(vm, njs_arg(args, nargs, 1), &offset); if (njs_slow_path(ret != NJS_OK)) { return NULL; } if (njs_slow_path((offset % element_size) != 0)) { njs_range_error(vm, ""start offset must be multiple of %uD"", element_size); return NULL; } if (njs_is_defined(njs_arg(args, nargs, 2))) { ret = njs_value_to_index(vm, njs_argument(args, 2), &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } } if (njs_slow_path(njs_is_detached_buffer(buffer))) { njs_type_error(vm, ""detached buffer""); return NULL; } if (njs_is_defined(njs_arg(args, nargs, 2))) { ret = njs_value_to_index(vm, njs_argument(args, 2), &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } size *= element_size; if (njs_slow_path((offset + size) > buffer->size)) { njs_range_error(vm, ""Invalid typed array length: %uL"", size); return NULL; } } else { if (njs_slow_path((buffer->size % element_size) != 0)) { njs_range_error(vm, ""byteLength of buffer must be "" ""multiple of %uD"", element_size); return NULL; } if (offset > buffer->size) { njs_range_error(vm, ""byteOffset %uL is outside the bound of "" ""the buffer"", offset); return NULL; } size = buffer->size - offset; } } else if (njs_is_typed_array(value)) { src_tarray = njs_typed_array(value); if (njs_slow_path(njs_is_detached_buffer(src_tarray->buffer))) { njs_type_error(vm, ""detached buffer""); return NULL; } size = (uint64_t) njs_typed_array_length(src_tarray) * element_size; } else if (njs_is_object(value)) { if (njs_is_fast_array(value)) { src_array = njs_array(value); length = src_array->length; } else { ret = njs_object_length(vm, value, &length); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } } size = length * element_size; } else { ret = njs_value_to_index(vm, value, &size); if (njs_slow_path(ret != NJS_OK)) { return NULL; } size *= element_size; } if (buffer == NULL) { buffer = njs_array_buffer_alloc(vm, size, zeroing); if (njs_slow_path(buffer == NULL)) { return NULL; } } array = njs_mp_zalloc(vm->mem_pool, sizeof(njs_typed_array_t)); if (njs_slow_path(array == NULL)) { goto memory_error; } array->buffer = buffer; array->offset = offset / element_size; array->byte_length = size; array->type = type; if (src_tarray != NULL) { if (type != src_tarray->type) { length = njs_typed_array_length(src_tarray); for (i = 0; i < length; i++) { njs_typed_array_prop_set(vm, array, i, njs_typed_array_prop(src_tarray, i)); } } else { memcpy(&buffer->u.u8[0], &src_tarray->buffer->u.u8[0], size); } } else if (src_array != NULL) { for (i = 0; i < length; i++) { ret = njs_value_to_number(vm, &src_array->start[i], &num); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { njs_typed_array_prop_set(vm, array, i, num); } } } else if (!njs_is_array_buffer(value) && njs_is_object(value)) { for (i = 0; i < length; i++) { ret = njs_value_property_i64(vm, value, i, &prop); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } num = NAN; if (ret == NJS_OK) { ret = njs_value_to_number(vm, &prop, &num); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } } njs_typed_array_prop_set(vm, array, i, num); } } njs_lvlhsh_init(&array->object.hash); njs_lvlhsh_init(&array->object.shared_hash); array->object.__proto__ = &vm->prototypes[type].object; array->object.type = NJS_TYPED_ARRAY; array->object.extensible = 1; array->object.fast_array = 1; return array; memory_error: njs_memory_error(vm); return NULL; }"
"static inline void enable_each_ist(idt_entry_t *idt) { set_ist(&idt[TRAP_double_fault],  IST_DF); set_ist(&idt[TRAP_nmi],           IST_NMI); set_ist(&idt[TRAP_machine_check], IST_MCE); }"
"static int hvmemul_get_fpu( void (*exception_callback)(void *, struct cpu_user_regs *), void *exception_callback_arg, enum x86_emulate_fpu_type type, struct x86_emulate_ctxt *ctxt) { struct vcpu *curr = current; switch ( type ) { case X86EMUL_FPU_fpu: break; case X86EMUL_FPU_mmx: if ( !cpu_has_mmx ) return X86EMUL_UNHANDLEABLE; break; case X86EMUL_FPU_xmm: if ( (curr->arch.hvm_vcpu.guest_cr[0] & X86_CR0_EM) || !(curr->arch.hvm_vcpu.guest_cr[4] & X86_CR4_OSFXSR) ) return X86EMUL_UNHANDLEABLE; break; case X86EMUL_FPU_ymm: if ( !(curr->arch.hvm_vcpu.guest_cr[0] & X86_CR0_PE) || (ctxt->regs->eflags & X86_EFLAGS_VM) || !(curr->arch.hvm_vcpu.guest_cr[4] & X86_CR4_OSXSAVE) || !(curr->arch.xcr0 & XSTATE_SSE) || !(curr->arch.xcr0 & XSTATE_YMM) ) return X86EMUL_UNHANDLEABLE; break; default: return X86EMUL_UNHANDLEABLE; } if ( !curr->fpu_dirtied ) hvm_funcs.fpu_dirty_intercept(); curr->arch.hvm_vcpu.fpu_exception_callback = exception_callback; curr->arch.hvm_vcpu.fpu_exception_callback_arg = exception_callback_arg; return X86EMUL_OKAY; }"
"int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret) { int ok = 0; BIGNUM *q = NULL; *ret = 0; q = BN_new(); if (q == NULL) goto err; BN_set_word(q, 1); if (BN_cmp(pub_key, q) <= 0) *ret |= DH_CHECK_PUBKEY_TOO_SMALL; BN_copy(q, dh->p); BN_sub_word(q, 1); if (BN_cmp(pub_key, q) >= 0) *ret |= DH_CHECK_PUBKEY_TOO_LARGE; ok = 1; err: if (q != NULL) BN_free(q); return (ok); }"
"static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt) { struct f_midi *midi = func_to_midi(f); unsigned i; int err; if (intf != midi->ms_id) return 0; err = f_midi_start_ep(midi, f, midi->in_ep); if (err) return err; err = f_midi_start_ep(midi, f, midi->out_ep); if (err) return err; while (kfifo_avail(&midi->in_req_fifo)) { struct usb_request *req = midi_alloc_ep_req(midi->in_ep, midi->buflen); if (req == NULL) return -ENOMEM; req->length = 0; req->complete = f_midi_complete; kfifo_put(&midi->in_req_fifo, req); } for (i = 0; i < midi->qlen && err == 0; i++) { struct usb_request *req = midi_alloc_ep_req(midi->out_ep, midi->buflen); if (req == NULL) return -ENOMEM; req->complete = f_midi_complete; err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC); if (err) { ERROR(midi, ""%s: couldn't enqueue request: %d\n"", midi->out_ep->name, err); free_ep_req(midi->out_ep, req); return err; } } return 0; }"
"int vq_getchain(struct virtio_vq_info *vq, uint16_t *pidx, struct iovec *iov, int n_iov, uint16_t *flags) { int i; u_int ndesc, n_indir; u_int idx, next; volatile struct vring_desc *vdir, *vindir, *vp; struct vmctx *ctx; struct virtio_base *base; const char *name; base = vq->base; name = base->vops->name; idx = vq->last_avail; ndesc = (uint16_t)((u_int)vq->avail->idx - idx); if (ndesc == 0) return 0; if (ndesc > vq->qsize) { pr_err(""%s: ndesc (%u) out of range, driver confused?\r\n"", name, (u_int)ndesc); return -1; } ctx = base->dev->vmctx; *pidx = next = vq->avail->ring[idx & (vq->qsize - 1)]; vq->last_avail++; for (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) { if (next >= vq->qsize) { pr_err(""%s: descriptor index %u out of range, "" ""driver confused?\r\n"", name, next); return -1; } vdir = &vq->desc[next]; if ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) { _vq_record(i, vdir, ctx, iov, n_iov, flags); i++; } else if ((base->device_caps & (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) { pr_err(""%s: descriptor has forbidden INDIRECT flag, "" ""driver confused?\r\n"", name); return -1; } else { n_indir = vdir->len / 16; if ((vdir->len & 0xf) || n_indir == 0) { pr_err(""%s: invalid indir len 0x%x, "" ""driver confused?\r\n"", name, (u_int)vdir->len); return -1; } vindir = paddr_guest2host(ctx, vdir->addr, vdir->len); next = 0; for (;;) { vp = &vindir[next]; if (vp->flags & VRING_DESC_F_INDIRECT) { pr_err(""%s: indirect desc has INDIR flag,"" "" driver confused?\r\n"", name); return -1; } _vq_record(i, vp, ctx, iov, n_iov, flags); if (++i > VQ_MAX_DESCRIPTORS) goto loopy; if ((vp->flags & VRING_DESC_F_NEXT) == 0) break; next = vp->next; if (next >= n_indir) { pr_err(""%s: invalid next %u > %u, "" ""driver confused?\r\n"", name, (u_int)next, n_indir); return -1; } } } if ((vdir->flags & VRING_DESC_F_NEXT) == 0) return i; } loopy: pr_err(""%s: descriptor loop? count > %d - driver confused?\r\n"", name, i); return -1; }"
"static int input_default_setkeycode(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode) { unsigned int index; int error; int i; if (!dev->keycodesize) return -EINVAL; if (ke->flags & INPUT_KEYMAP_BY_INDEX) { index = ke->index; } else { error = input_scancode_to_scalar(ke, &index); if (error) return error; } if (index >= dev->keycodemax) return -EINVAL; if (dev->keycodesize < sizeof(ke->keycode) && (ke->keycode >> (dev->keycodesize * 8))) return -EINVAL; switch (dev->keycodesize) { case 1: { u8 *k = (u8 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } case 2: { u16 *k = (u16 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } default: { u32 *k = (u32 *)dev->keycode; *old_keycode = k[index]; k[index] = ke->keycode; break; } } __clear_bit(*old_keycode, dev->keybit); __set_bit(ke->keycode, dev->keybit); for (i = 0; i < dev->keycodemax; i++) { if (input_fetch_keycode(dev, i) == *old_keycode) { __set_bit(*old_keycode, dev->keybit); break;  } } return 0; }"
"void gf_dom_event_remove_all_listeners(GF_DOMEventTarget *event_target) { while (gf_list_count(event_target->listeners)) { GF_Node *n = (GF_Node *)gf_list_get(event_target->listeners, 0); gf_dom_listener_del(n, event_target); } }"
"static void coroutine_fn v9fs_link(void *opaque) { V9fsPDU *pdu = opaque; int32_t dfid, oldfid; V9fsFidState *dfidp, *oldfidp; V9fsString name; size_t offset = 7; int err = 0; v9fs_string_init(&name); err = pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name); if (err < 0) { goto out_nofid; } trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data); if (name_is_illegal(name.data)) { err = -ENOENT; goto out_nofid; } if (!strcmp(""."", name.data) || !strcmp("".."", name.data)) { err = -EEXIST; goto out_nofid; } dfidp = get_fid(pdu, dfid); if (dfidp == NULL) { err = -ENOENT; goto out_nofid; } oldfidp = get_fid(pdu, oldfid); if (oldfidp == NULL) { err = -ENOENT; goto out; } err = v9fs_co_link(pdu, oldfidp, dfidp, &name); if (!err) { err = offset; } out: put_fid(pdu, dfidp); out_nofid: v9fs_string_free(&name); pdu_complete(pdu, err); }"
"static void usage(int status) { FILE *dest = (status == 0) ? stdout : stderr; if(status == 0){ fprintf(dest, ""%s(1)\t\t\tcopyright <Pierre-François Monville>\t\t\t%s(1)\n\nNAME\n\t%s -- crypt or decrypt any data\n\nSYNOPSIS\n\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\n\nDESCRIPTION\n\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\n\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\n\nOPTIONS\n\tthe options are as follows:\n\n\t-h | --help\tfurther help.\n\n\t-s | --standard\tput the scrambler on off.\n\n\t-i | --inverted\tinverts the coding/decoding process, first it xors then it scrambles.\n\nEXIT STATUS\n\tthe %s program exits 0 on success, and anything else if an error occurs.\n\nEXAMPLES\n\tthe command:\t%s file1\n\n\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\n\n\tthe command:\t%s file2 keyfile1\n\n\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\n\n\tthe command:\t%s file3 -s\n\n\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\n"", progName, progName, progName, progName, progName, progName, progName, progName); } else{ fprintf(dest, ""Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\nOptions :\n  -h --help :\t\tfurther help\n  -s --standard :\tput the scrambler off\n  -i --inverted :\tinverts the coding/decoding process\n  KEYFILE :\t\tpath to a keyfile that generates the scrambler instead of the password\n"", progName); } exit(status); }"
"void ex_diffgetput(exarg_T *eap) { linenr_Tlnum; intcount; linenr_Toff = 0; diff_T*dp; diff_T*dprev; diff_T*dfree; intidx_cur; intidx_other; intidx_from; intidx_to; inti; intadded; char_u*p; aco_save_Taco; buf_T*buf; intstart_skip, end_skip; intnew_count; intbuf_empty; intfound_not_ma = FALSE; idx_cur = diff_buf_idx(curbuf); if (idx_cur == DB_COUNT) { emsg(_(e_current_buffer_is_not_in_diff_mode)); return; } if (*eap->arg == NUL) { for (idx_other = 0; idx_other < DB_COUNT; ++idx_other) if (curtab->tp_diffbuf[idx_other] != curbuf && curtab->tp_diffbuf[idx_other] != NULL) { if (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[idx_other]->b_p_ma) break; found_not_ma = TRUE; } if (idx_other == DB_COUNT) { if (found_not_ma) emsg(_(e_no_other_buffer_in_diff_mode_is_modifiable)); else emsg(_(e_no_other_buffer_in_diff_mode)); return; } for (i = idx_other + 1; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != curbuf && curtab->tp_diffbuf[i] != NULL && (eap->cmdidx != CMD_diffput || curtab->tp_diffbuf[i]->b_p_ma)) { emsg(_(e_more_than_two_buffers_in_diff_mode_dont_know_which_one_to_use)); return; } } else { p = eap->arg + STRLEN(eap->arg); while (p > eap->arg && VIM_ISWHITE(p[-1])) --p; for (i = 0; vim_isdigit(eap->arg[i]) && eap->arg + i < p; ++i) ; if (eap->arg + i == p)        i = atol((char *)eap->arg); else { i = buflist_findpat(eap->arg, p, FALSE, TRUE, FALSE); if (i < 0) return;} buf = buflist_findnr(i); if (buf == NULL) { semsg(_(e_cant_find_buffer_str), eap->arg); return; } if (buf == curbuf) return;idx_other = diff_buf_idx(buf); if (idx_other == DB_COUNT) { semsg(_(e_buffer_str_is_not_in_diff_mode), eap->arg); return; } } diff_busy = TRUE; if (eap->addr_count == 0) { if (eap->cmdidx == CMD_diffget && eap->line1 == curbuf->b_ml.ml_line_count && diff_check(curwin, eap->line1) == 0 && (eap->line1 == 1 || diff_check(curwin, eap->line1 - 1) == 0)) ++eap->line2; else if (eap->line1 > 0) --eap->line1; } if (eap->cmdidx == CMD_diffget) { idx_from = idx_other; idx_to = idx_cur; } else { idx_from = idx_cur; idx_to = idx_other; aucmd_prepbuf(&aco, curtab->tp_diffbuf[idx_other]); } if (!curbuf->b_changed) { change_warning(0); if (diff_buf_idx(curbuf) != idx_to) { emsg(_(e_buffer_changed_unexpectedly)); goto theend; } } dprev = NULL; for (dp = curtab->tp_first_diff; dp != NULL; ) { if (dp->df_lnum[idx_cur] > eap->line2 + off) break; dfree = NULL; lnum = dp->df_lnum[idx_to]; count = dp->df_count[idx_to]; if (dp->df_lnum[idx_cur] + dp->df_count[idx_cur] > eap->line1 + off && u_save(lnum - 1, lnum + count) != FAIL) { start_skip = 0; end_skip = 0; if (eap->addr_count > 0) { start_skip = eap->line1 + off - dp->df_lnum[idx_cur]; if (start_skip > 0) { if (start_skip > count) { lnum += count; count = 0; } else { count -= start_skip; lnum += start_skip; } } else start_skip = 0; end_skip = dp->df_lnum[idx_cur] + dp->df_count[idx_cur] - 1 - (eap->line2 + off); if (end_skip > 0) { if (idx_cur == idx_from)    { i = dp->df_count[idx_cur] - start_skip - end_skip; if (count > i) count = i; } else    { count -= end_skip; end_skip = dp->df_count[idx_from] - start_skip - count; if (end_skip < 0) end_skip = 0; } } else end_skip = 0; } buf_empty = BUFEMPTY(); added = 0; for (i = 0; i < count; ++i) { buf_empty = curbuf->b_ml.ml_line_count == 1; ml_delete(lnum); --added; } for (i = 0; i < dp->df_count[idx_from] - start_skip - end_skip; ++i) { linenr_T nr; nr = dp->df_lnum[idx_from] + start_skip + i; if (nr > curtab->tp_diffbuf[idx_from]->b_ml.ml_line_count) break; p = vim_strsave(ml_get_buf(curtab->tp_diffbuf[idx_from], nr, FALSE)); if (p != NULL) { ml_append(lnum + i - 1, p, 0, FALSE); vim_free(p); ++added; if (buf_empty && curbuf->b_ml.ml_line_count == 2) { buf_empty = FALSE; ml_delete((linenr_T)2); } } } new_count = dp->df_count[idx_to] + added; dp->df_count[idx_to] = new_count; if (start_skip == 0 && end_skip == 0) { for (i = 0; i < DB_COUNT; ++i) if (curtab->tp_diffbuf[i] != NULL && i != idx_from && i != idx_to && !diff_equal_entry(dp, idx_from, i)) break; if (i == DB_COUNT) { dfree = dp; dp = dp->df_next; if (dprev == NULL) curtab->tp_first_diff = dp; else dprev->df_next = dp; } } if (added != 0) { mark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added); if (curwin->w_cursor.lnum >= lnum) { if (curwin->w_cursor.lnum >= lnum + count) curwin->w_cursor.lnum += added; else if (added < 0) curwin->w_cursor.lnum = lnum; } } changed_lines(lnum, 0, lnum + count, (long)added); if (dfree != NULL) { #ifdef FEAT_FOLDING diff_fold_update(dfree, idx_to); #endif vim_free(dfree); } if (added != 0 && !valid_diff(dp)) break; if (dfree == NULL) dp->df_count[idx_to] = new_count; if (idx_cur == idx_to) off += added; } if (dfree == NULL) { dprev = dp; dp = dp->df_next; } } if (eap->cmdidx != CMD_diffget) { if (KeyTyped) u_sync(FALSE); aucmd_restbuf(&aco); } theend: diff_busy = FALSE; if (diff_need_update) ex_diffupdate(NULL); check_cursor(); changed_line_abv_curs(); if (diff_need_update) diff_need_update = FALSE; else { diff_redraw(FALSE); apply_autocmds(EVENT_DIFFUPDATED, NULL, NULL, FALSE, curbuf); } }"
"void saxEndElement(const xchar *name) { int elm_ptr; xchar elm_name[ELM_NAME_LEN]; tree_node_t *nodo; EPRINTF1(""SAX.endElement(%s)\n"",name); if (state!=ST_PARSING) return; xtolower(elm_name,name,ELM_NAME_LEN); if ((elm_ptr= dtd_elm_search(elm_name))<0) { if ((elm_ptr= err_elm_desconocido(elm_name))<0) { INFORM(""elemento no encontrado\n""); return; } } for (nodo=actual_element; (nodo) && (ELM_ID(nodo)!=elm_ptr);  nodo=nodo->padre); if (!nodo) DEBUG(""cerrado elemento no abierto"") else { tree_node_t *p; for (p=actual_element; p != nodo; p=p->padre) elm_close(p); elm_close(nodo); if (!new_place_recovery_on || new_place_recovery_elm != actual_element) { actual_element= nodo->padre; } else { new_place_recovery_on = 0; actual_element = new_place_recovery_father; } if (!actual_element) state= ST_END; } }"
"static RList *relocs(RBinFile *arch) { struct r_bin_bflt_obj *obj = (struct r_bin_bflt_obj*)arch->o->bin_obj; RList *list = r_list_newf ((RListFree)free); int i, len, n_got, amount; if (!list || !obj) { r_list_free (list); return NULL; } if (obj->hdr->flags & FLAT_FLAG_GOTPIC) { n_got = get_ngot_entries (obj); if (n_got) { amount = n_got *  sizeof (ut32); if (amount < n_got || amount > UT32_MAX) { goto out_error; } struct reloc_struct_t *got_table = calloc (1, n_got * sizeof (ut32)); if (got_table) { ut32 offset = 0; for (i = 0; i < n_got ; offset += 4, i++) { ut32 got_entry; if (obj->hdr->data_start + offset + 4 > obj->size || obj->hdr->data_start + offset + 4 < offset) { break; } len = r_buf_read_at (obj->b, obj->hdr->data_start + offset, (ut8 *)&got_entry, sizeof (ut32)); if (!VALID_GOT_ENTRY (got_entry) || len != sizeof (ut32)) { break; } got_table[i].addr_to_patch = got_entry; got_table[i].data_offset = got_entry + BFLT_HDR_SIZE; } obj->n_got = n_got; obj->got_table = got_table; } } } if (obj->hdr->reloc_count > 0) { int n_reloc = obj->hdr->reloc_count;  amount = n_reloc * sizeof (struct reloc_struct_t); if (amount < n_reloc || amount > UT32_MAX) { goto out_error; } struct reloc_struct_t *reloc_table = calloc (1, amount + 1); if (!reloc_table) { goto out_error; } amount = n_reloc * sizeof (ut32); if (amount < n_reloc || amount > UT32_MAX) { free (reloc_table); goto out_error; } ut32 *reloc_pointer_table = calloc (1, amount + 1); if (!reloc_pointer_table) { free (reloc_table); goto out_error; } if (obj->hdr->reloc_start + amount > obj->size || obj->hdr->reloc_start + amount < amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, obj->hdr->reloc_start, (ut8 *)reloc_pointer_table, amount); if (len != amount) { free (reloc_table); free (reloc_pointer_table); goto out_error; } for (i = 0; i < obj->hdr->reloc_count; i++) { ut32 reloc_offset = r_swap_ut32 (reloc_pointer_table[i]) + BFLT_HDR_SIZE; if (reloc_offset < obj->hdr->bss_end && reloc_offset < obj->size) { ut32 reloc_fixed, reloc_data_offset; if (reloc_offset + sizeof (ut32) > obj->size || reloc_offset + sizeof (ut32) < reloc_offset) { free (reloc_table); free (reloc_pointer_table); goto out_error; } len = r_buf_read_at (obj->b, reloc_offset, (ut8 *)&reloc_fixed, sizeof (ut32)); if (len != sizeof (ut32)) { eprintf (""problem while reading relocation entries\n""); free (reloc_table); free (reloc_pointer_table); goto out_error; } reloc_data_offset = r_swap_ut32 (reloc_fixed) + BFLT_HDR_SIZE; reloc_table[i].addr_to_patch = reloc_offset; reloc_table[i].data_offset = reloc_data_offset; RBinReloc *reloc = R_NEW0 (RBinReloc); if (reloc) { reloc->type = R_BIN_RELOC_32; reloc->paddr = reloc_table[i].addr_to_patch; reloc->vaddr = reloc->paddr; r_list_append (list, reloc); } } } free (reloc_pointer_table); obj->reloc_table = reloc_table; } return list; out_error: r_list_free (list); return NULL; }"
"static int sysMapFD(int fd, MemMapping* pMap) { off_t start; size_t length; void* memPtr; assert(pMap != NULL); if (getFileStartAndLength(fd, &start, &length) < 0) return -1; memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start); if (memPtr == MAP_FAILED) { LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length, fd, (int) start, strerror(errno)); return -1; } pMap->addr = memPtr; pMap->length = length; pMap->range_count = 1; pMap->ranges = malloc(sizeof(MappedRange)); pMap->ranges[0].addr = memPtr; pMap->ranges[0].length = length; return 0; }"
"static int is_atomic(struct jsonparse_state *state) { char v = state->vtype; if(v == 'N' || v == '""' || v == '0' || v == 'n' || v == 't' || v == 'f') { return 1; } else { return 0; } }"
"int common_timer_set(struct k_itimer *timr, int flags, struct itimerspec64 *new_setting, struct itimerspec64 *old_setting) { const struct k_clock *kc = timr->kclock; bool sigev_none; ktime_t expires; if (old_setting) common_timer_get(timr, old_setting); timr->it_interval = 0; if (kc->timer_try_to_cancel(timr) < 0) return TIMER_RETRY; timr->it_active = 0; timr->it_requeue_pending = (timr->it_requeue_pending + 2) & ~REQUEUE_PENDING; timr->it_overrun_last = 0; if (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec) return 0; timr->it_interval = timespec64_to_ktime(new_setting->it_interval); expires = timespec64_to_ktime(new_setting->it_value); sigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE; kc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none); timr->it_active = !sigev_none; return 0; }"
"bool ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr, bool *set_rtrn) { bool ok = false; const char *ident; switch (expr->expr.op) { case EXPR_VALUE: if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) { log_err(ctx, ""Found constant of type %s where boolean was expected\n"", expr_value_type_to_string(expr->expr.value_type)); return false; } *set_rtrn = expr->boolean.set; return true; case EXPR_IDENT: ident = xkb_atom_text(ctx, expr->ident.ident); if (ident) { if (istreq(ident, ""true"") || istreq(ident, ""yes"") || istreq(ident, ""on"")) { *set_rtrn = true; return true; } else if (istreq(ident, ""false"") || istreq(ident, ""no"") || istreq(ident, ""off"")) { *set_rtrn = false; return true; } } log_err(ctx, ""Identifier \""%s\"" of type boolean is unknown\n"", ident); return false; case EXPR_FIELD_REF: log_err(ctx, ""Default \""%s.%s\"" of type boolean is unknown\n"", xkb_atom_text(ctx, expr->field_ref.element), xkb_atom_text(ctx, expr->field_ref.field)); return false; case EXPR_INVERT: case EXPR_NOT: ok = ExprResolveBoolean(ctx, expr, set_rtrn); if (ok) *set_rtrn = !*set_rtrn; return ok; case EXPR_ADD: case EXPR_SUBTRACT: case EXPR_MULTIPLY: case EXPR_DIVIDE: case EXPR_ASSIGN: case EXPR_NEGATE: case EXPR_UNARY_PLUS: log_err(ctx, ""%s of boolean values not permitted\n"", expr_op_type_to_string(expr->expr.op)); break; default: log_wsgo(ctx, ""Unknown operator %d in ResolveBoolean\n"", expr->expr.op); break; } return false; }"
"int base64_encode(const void *data_in, size_t data_in_size, unsigned char *base64_out, size_t *base64_out_size) { return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, false); }"
"JsVar *jswrap_json_stringify(JsVar *v, JsVar *replacer, JsVar *space) { NOT_USED(replacer); JSONFlags flags = JSON_IGNORE_FUNCTIONS|JSON_NO_UNDEFINED|JSON_ARRAYBUFFER_AS_ARRAY|JSON_JSON_COMPATIBILE|JSON_ALLOW_TOJSON; JsVar *result = jsvNewFromEmptyString(); if (result) {    char whitespace[11] = """"; if (jsvIsUndefined(space) || jsvIsNull(space)) { } else if (jsvIsNumeric(space)) { unsigned int s = (unsigned int)jsvGetInteger(space); if (s>10) s=10; whitespace[s] = 0; while (s) whitespace[--s]=' '; } else { jsvGetString(space, whitespace, sizeof(whitespace)); } if (strlen(whitespace)) flags |= JSON_ALL_NEWLINES|JSON_PRETTY; jsfGetJSONWhitespace(v, result, flags, whitespace); } return result; }"
"static int get_gate_page(struct mm_struct *mm, unsigned long address, unsigned int gup_flags, struct vm_area_struct **vma, struct page **page) { pgd_t *pgd; p4d_t *p4d; pud_t *pud; pmd_t *pmd; pte_t *pte; int ret = -EFAULT; if (gup_flags & FOLL_WRITE) return -EFAULT; if (address > TASK_SIZE) pgd = pgd_offset_k(address); else pgd = pgd_offset_gate(mm, address); if (pgd_none(*pgd)) return -EFAULT; p4d = p4d_offset(pgd, address); if (p4d_none(*p4d)) return -EFAULT; pud = pud_offset(p4d, address); if (pud_none(*pud)) return -EFAULT; pmd = pmd_offset(pud, address); if (!pmd_present(*pmd)) return -EFAULT; VM_BUG_ON(pmd_trans_huge(*pmd)); pte = pte_offset_map(pmd, address); if (pte_none(*pte)) goto unmap; *vma = get_gate_vma(mm); if (!page) goto out; *page = vm_normal_page(*vma, address, *pte); if (!*page) { if ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte))) goto unmap; *page = pte_page(*pte); } if (unlikely(!try_get_page(*page))) { ret = -ENOMEM; goto unmap; } out: ret = 0; unmap: pte_unmap(pte); return ret; }"
"static char_u * fname_match( regmatch_T*rmp, char_u*name, intignore_case)  { char_u*match = NULL; char_u*p; if (name != NULL) { rmp->rm_ic = p_fic || ignore_case; if (vim_regexec(rmp, name, (colnr_T)0)) match = name; else { p = home_replace_save(NULL, name); if (p != NULL && vim_regexec(rmp, p, (colnr_T)0)) match = name; vim_free(p); } } return match; }"
void rose_start_heartbeat(struct sock *sk) { del_timer(&sk->sk_timer); sk->sk_timer.function = rose_heartbeat_expiry; sk->sk_timer.expires  = jiffies + 5 * HZ; add_timer(&sk->sk_timer); }
static int asymmetric_key_match_preparse(struct key_match_data *match_data) { match_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE; return 0; }
"static int route4_change(struct net *net, struct sk_buff *in_skb, struct tcf_proto *tp, unsigned long base, u32 handle, struct nlattr **tca, void **arg, u32 flags, struct netlink_ext_ack *extack) { struct route4_head *head = rtnl_dereference(tp->root); struct route4_filter __rcu **fp; struct route4_filter *fold, *f1, *pfp, *f = NULL; struct route4_bucket *b; struct nlattr *opt = tca[TCA_OPTIONS]; struct nlattr *tb[TCA_ROUTE4_MAX + 1]; unsigned int h, th; int err; bool new = true; if (!handle) { NL_SET_ERR_MSG(extack, ""Creating with handle of 0 is invalid""); return -EINVAL; } if (opt == NULL) return -EINVAL; err = nla_parse_nested_deprecated(tb, TCA_ROUTE4_MAX, opt, route4_policy, NULL); if (err < 0) return err; fold = *arg; if (fold && fold->handle != handle) return -EINVAL; err = -ENOBUFS; f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL); if (!f) goto errout; err = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE); if (err < 0) goto errout; if (fold) { f->id = fold->id; f->iif = fold->iif; f->res = fold->res; f->handle = fold->handle; f->tp = fold->tp; f->bkt = fold->bkt; new = false; } err = route4_set_parms(net, tp, base, f, handle, head, tb, tca[TCA_RATE], new, flags, extack); if (err < 0) goto errout; h = from_hash(f->handle >> 16); fp = &f->bkt->ht[h]; for (pfp = rtnl_dereference(*fp); (f1 = rtnl_dereference(*fp)) != NULL; fp = &f1->next) if (f->handle < f1->handle) break; tcf_block_netif_keep_dst(tp->chain->block); rcu_assign_pointer(f->next, f1); rcu_assign_pointer(*fp, f); if (fold) { th = to_hash(fold->handle); h = from_hash(fold->handle >> 16); b = rtnl_dereference(head->table[th]); if (b) { fp = &b->ht[h]; for (pfp = rtnl_dereference(*fp); pfp; fp = &pfp->next, pfp = rtnl_dereference(*fp)) { if (pfp == fold) { rcu_assign_pointer(*fp, fold->next); break; } } } } route4_reset_fastmap(head); *arg = f; if (fold) { tcf_unbind_filter(tp, &fold->res); tcf_exts_get_net(&fold->exts); tcf_queue_work(&fold->rwork, route4_delete_filter_work); } return 0; errout: if (f) tcf_exts_destroy(&f->exts); kfree(f); return err; }"
"int read_image_tga( gdIOCtx *ctx, oTga *tga ) { int pixel_block_size = (tga->bits / 8); int image_block_size = (tga->width * tga->height) * pixel_block_size; int* decompression_buffer = NULL; unsigned char* conversion_buffer = NULL; int buffer_caret = 0; int bitmap_caret = 0; int i = 0; int encoded_pixels; int rle_size; if(overflow2(tga->width, tga->height)) { return -1; } if(overflow2(tga->width * tga->height, pixel_block_size)) { return -1; } if(overflow2(image_block_size, sizeof(int))) { return -1; } if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE) return -1; tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int)); if (tga->bitmap == NULL) return -1; switch (tga->imagetype) { case TGA_TYPE_RGB: conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { return -1; } if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) { gd_error(""gd-tga: premature end of image data\n""); gdFree(conversion_buffer); return -1; } while (buffer_caret < image_block_size) { tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret]; buffer_caret++; } gdFree(conversion_buffer); break; case TGA_TYPE_RGB_RLE: decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int)); if (decompression_buffer == NULL) { return -1; } conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { gd_error(""gd-tga: premature end of image data\n""); gdFree( decompression_buffer ); return -1; } rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx); if (rle_size <= 0) { gdFree(conversion_buffer); gdFree(decompression_buffer); return -1; } buffer_caret = 0; while( buffer_caret < rle_size) { decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret]; buffer_caret++; } buffer_caret = 0; while( bitmap_caret < image_block_size ) { if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) { encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 ); buffer_caret++; if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) { gdFree( decompression_buffer ); gdFree( conversion_buffer ); return -1; } for (i = 0; i < encoded_pixels; i++) { memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int)); bitmap_caret += pixel_block_size; } buffer_caret += pixel_block_size; } else { encoded_pixels = decompression_buffer[ buffer_caret ] + 1; buffer_caret++; if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) { gdFree( decompression_buffer ); gdFree( conversion_buffer ); return -1; } memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int)); bitmap_caret += (encoded_pixels * pixel_block_size); buffer_caret += (encoded_pixels * pixel_block_size); } } gdFree( decompression_buffer ); gdFree( conversion_buffer ); break; } return 1; }"
"static Var* Pe_r_bin_pe_parse_var(RBinPEObj* pe, PE_DWord* curAddr) { Var* var = calloc (1, sizeof (*var)); if (!var) { pe_printf (""Warning: calloc (Var)\n""); return NULL; } if ((var->wLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wLength)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wLength); if ((var->wValueLength = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wValueLength)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wValueLength); if ((var->wType = r_buf_read_le16_at (pe->b, *curAddr)) == UT16_MAX) { pe_printf (""Warning: read (Var wType)\n""); free_Var (var); return NULL; } *curAddr += sizeof (var->wType); if (var->wType != 0 && var->wType != 1) { pe_printf (""Warning: check (Var wType)\n""); free_Var (var); return NULL; } var->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  if (!var->szKey) { pe_printf (""Warning: malloc (Var szKey)\n""); free_Var (var); return NULL; } if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) { pe_printf (""Warning: read (Var szKey)\n""); free_Var (var); return NULL; } *curAddr += TRANSLATION_UTF_16_LEN; if (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) { pe_printf (""Warning: check (Var szKey)\n""); free_Var (var); return NULL; } align32 (*curAddr); var->numOfValues = var->wValueLength / 4; if (!var->numOfValues) { pe_printf (""Warning: check (Var numOfValues)\n""); free_Var (var); return NULL; } var->Value = (ut32*) malloc (var->wValueLength); if (!var->Value) { pe_printf (""Warning: malloc (Var Value)\n""); free_Var (var); return NULL; } if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->Value, var->wValueLength) != var->wValueLength) { pe_printf (""Warning: read (Var Value)\n""); free_Var (var); return NULL; } *curAddr += var->wValueLength; return var; }"
"static void voutf(struct GlobalConfig *config, const char *prefix, const char *fmt, va_list ap) { size_t width = (79 - strlen(prefix)); if(!config->mute) { size_t len; char *ptr; char *print_buffer; print_buffer = curlx_mvaprintf(fmt, ap); if(!print_buffer) return; len = strlen(print_buffer); ptr = print_buffer; while(len > 0) { fputs(prefix, config->errors); if(len > width) { size_t cut = width-1; while(!ISSPACE(ptr[cut]) && cut) { cut--; } if(0 == cut) cut = width-1; (void)fwrite(ptr, cut + 1, 1, config->errors); fputs(""\n"", config->errors); ptr += cut + 1;  len -= cut; } else { fputs(ptr, config->errors); len = 0; } } curl_free(print_buffer); } }"
"u_int juniper_atm2_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { int llc_hdrlen; struct juniper_l2info_t l2info; l2info.pictype = DLT_JUNIPER_ATM2; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) {  oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC); return l2info.header_len; } if (EXTRACT_24BITS(p) == 0xfefe03 ||  EXTRACT_24BITS(p) == 0xaaaa03) {  llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); if (llc_hdrlen > 0) return l2info.header_len; } if (l2info.direction != JUNIPER_BPF_PKT_IN &&  (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) { ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL); return l2info.header_len; } if (p[0] == 0x03) {  isoclns_print(ndo, p + 1, l2info.length - 1); return l2info.header_len; } if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0)  return l2info.header_len; if (ip_heuristic_guess(ndo, p, l2info.length) != 0)  return l2info.header_len; return l2info.header_len; }"
"static int n_tty_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg) { struct n_tty_data *ldata = tty->disc_data; int retval; switch (cmd) { case TIOCOUTQ: return put_user(tty_chars_in_buffer(tty), (int __user *) arg); case TIOCINQ: down_write(&tty->termios_rwsem); if (L_ICANON(tty)) retval = inq_canon(ldata); else retval = read_cnt(ldata); up_write(&tty->termios_rwsem); return put_user(retval, (unsigned int __user *) arg); default: return n_tty_ioctl_helper(tty, file, cmd, arg); } }"
"int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, int emulation_type, void *insn, int insn_len) { int r; struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt; bool writeback = true; bool write_fault_to_spt; if (unlikely(!kvm_can_emulate_insn(vcpu, emulation_type, insn, insn_len))) return 1; vcpu->arch.l1tf_flush_l1d = true; write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable; vcpu->arch.write_fault_to_shadow_pgtable = false; if (!(emulation_type & EMULTYPE_NO_DECODE)) { kvm_clear_exception_queue(vcpu); r = x86_decode_emulated_instruction(vcpu, emulation_type, insn, insn_len); if (r != EMULATION_OK)  { if ((emulation_type & EMULTYPE_TRAP_UD) || (emulation_type & EMULTYPE_TRAP_UD_FORCED)) { kvm_queue_exception(vcpu, UD_VECTOR); return 1; } if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt, emulation_type)) return 1; if (ctxt->have_exception) { WARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR || exception_type(ctxt->exception.vector) == EXCPT_TRAP); inject_emulated_exception(vcpu); return 1; } return handle_emulation_failure(vcpu, emulation_type); } } if ((emulation_type & EMULTYPE_VMWARE_GP) && !is_vmware_backdoor_opcode(ctxt)) { kvm_queue_exception_e(vcpu, GP_VECTOR, 0); return 1; } if (emulation_type & EMULTYPE_SKIP) { if (ctxt->mode != X86EMUL_MODE_PROT64) ctxt->eip = (u32)ctxt->_eip; else ctxt->eip = ctxt->_eip; if (emulation_type & EMULTYPE_COMPLETE_USER_EXIT) { r = 1; goto writeback; } kvm_rip_write(vcpu, ctxt->eip); if (ctxt->eflags & X86_EFLAGS_RF) kvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF); return 1; } if (retry_instruction(ctxt, cr2_or_gpa, emulation_type)) return 1; if (vcpu->arch.emulate_regs_need_sync_from_vcpu) { vcpu->arch.emulate_regs_need_sync_from_vcpu = false; emulator_invalidate_register_cache(ctxt); } restart: if (emulation_type & EMULTYPE_PF) { ctxt->exception.address = cr2_or_gpa; if (vcpu->arch.mmu->root_role.direct) { ctxt->gpa_available = true; ctxt->gpa_val = cr2_or_gpa; } } else { ctxt->exception.address = 0; } r = x86_emulate_insn(ctxt); if (r == EMULATION_INTERCEPTED) return 1; if (r == EMULATION_FAILED) { if (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt, emulation_type)) return 1; return handle_emulation_failure(vcpu, emulation_type); } if (ctxt->have_exception) { r = 1; if (inject_emulated_exception(vcpu)) return r; } else if (vcpu->arch.pio.count) { if (!vcpu->arch.pio.in) { vcpu->arch.pio.count = 0; } else { writeback = false; vcpu->arch.complete_userspace_io = complete_emulated_pio; } r = 0; } else if (vcpu->mmio_needed) { ++vcpu->stat.mmio_exits; if (!vcpu->mmio_is_write) writeback = false; r = 0; vcpu->arch.complete_userspace_io = complete_emulated_mmio; } else if (vcpu->arch.complete_userspace_io) { writeback = false; r = 0; } else if (r == EMULATION_RESTART) goto restart; else r = 1; writeback: if (writeback) { unsigned long rflags = static_call(kvm_x86_get_rflags)(vcpu); toggle_interruptibility(vcpu, ctxt->interruptibility); vcpu->arch.emulate_regs_need_sync_to_vcpu = false; if (!ctxt->have_exception || exception_type(ctxt->exception.vector) == EXCPT_TRAP) { kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_INSTRUCTIONS); if (ctxt->is_branch) kvm_pmu_trigger_event(vcpu, PERF_COUNT_HW_BRANCH_INSTRUCTIONS); kvm_rip_write(vcpu, ctxt->eip); if (r && (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP))) r = kvm_vcpu_do_singlestep(vcpu); static_call_cond(kvm_x86_update_emulated_instruction)(vcpu); __kvm_set_rflags(vcpu, ctxt->eflags); } if (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF)) kvm_make_request(KVM_REQ_EVENT, vcpu); } else vcpu->arch.emulate_regs_need_sync_to_vcpu = true; return r; }"
"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kNGroupsOffset = 12; const size_t kFirstGroupOffset = 16; const size_t kGroupSize = 12; const size_t kStartCharCodeOffset = 0; const size_t kEndCharCodeOffset = 4; if (kFirstGroupOffset > size) { return false; } uint32_t nGroups = readU32(data, kNGroupsOffset); if (kFirstGroupOffset + nGroups * kGroupSize > size) { return false; } for (uint32_t i = 0; i < nGroups; i++) { uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize; uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset); uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset); addRange(coverage, start, end + 1);      } return true; }"
"Status XvMCGetDRInfo(Display *dpy, XvPortID port, char **name, char **busID, int *major, int *minor, int *patchLevel, int *isLocal) { XExtDisplayInfo *info = xvmc_find_display(dpy); xvmcGetDRInfoReply rep; xvmcGetDRInfoReq  *req; CARD32 magic; #ifdef HAVE_SHMAT volatile CARD32 *shMem; struct timezone here; struct timeval now; here.tz_minuteswest = 0; here.tz_dsttime = 0; #endif *name = NULL; *busID = NULL; XvMCCheckExtension (dpy, info, BadImplementation); LockDisplay (dpy); XvMCGetReq (GetDRInfo, req); req->port = port; magic = 0; req->magic = 0; #ifdef HAVE_SHMAT req->shmKey = shmget(IPC_PRIVATE, 1024, IPC_CREAT | 0600); if (req->shmKey >= 0) { shMem = (CARD32 *) shmat(req->shmKey, NULL, 0); shmctl( req->shmKey, IPC_RMID, NULL); if ( shMem ) { register volatile CARD32 *shMemC = shMem; register int i; gettimeofday( &now, &here); magic = now.tv_usec & 0x000FFFFF; req->magic = magic; i = 1024 / sizeof(CARD32); while(i--) { *shMemC++ = magic; magic = ~magic; } } else { req->shmKey = -1; } } #else req->shmKey = 0; #endif if (!_XReply (dpy, (xReply *) &rep, 0, xFalse)) { UnlockDisplay (dpy); SyncHandle (); #ifdef HAVE_SHMAT if ( req->shmKey >= 0) { shmdt( (const void *) shMem ); } #endif return -1; } #ifdef HAVE_SHMAT shmdt( (const void *) shMem ); #endif if (rep.length > 0) { unsigned long realSize = 0; char *tmpBuf = NULL; if ((rep.length < (INT_MAX >> 2)) && (rep.nameLen + rep.busIDLen > rep.nameLen)) { realSize = rep.length << 2; if (realSize >= (rep.nameLen + rep.busIDLen)) { tmpBuf = Xmalloc(realSize); *name = Xmalloc(rep.nameLen); *busID = Xmalloc(rep.busIDLen); } } if (*name && *busID && tmpBuf) { _XRead(dpy, tmpBuf, realSize); strncpy(*name,tmpBuf,rep.nameLen); (*name)[rep.nameLen - 1] = '\0'; strncpy(*busID,tmpBuf+rep.nameLen,rep.busIDLen); (*busID)[rep.busIDLen - 1] = '\0'; XFree(tmpBuf); } else { XFree(*name); *name = NULL; XFree(*busID); *busID = NULL; XFree(tmpBuf); _XEatDataWords(dpy, rep.length); UnlockDisplay (dpy); SyncHandle (); return -1; } } UnlockDisplay (dpy); SyncHandle (); *major = rep.major; *minor = rep.minor; *patchLevel = rep.patchLevel; *isLocal = (req->shmKey > 0) ? rep.isLocal : 1; return (rep.length > 0) ? Success : BadImplementation; }"
"__kprobes do_int3(struct pt_regs *regs, long error_code) { #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP if (kgdb_ll_trap(DIE_INT3, ""int3"", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP) return; #endif  #ifdef CONFIG_KPROBES if (notify_die(DIE_INT3, ""int3"", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP) return; #else if (notify_die(DIE_TRAP, ""int3"", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP) return; #endif preempt_conditional_sti(regs); do_trap(3, SIGTRAP, ""int3"", regs, error_code, NULL); preempt_conditional_cli(regs); }"
"static int bgp_route_refresh_receive(struct peer *peer, bgp_size_t size) { iana_afi_t pkt_afi; afi_t afi; iana_safi_t pkt_safi; safi_t safi; struct stream *s; struct peer_af *paf; struct update_group *updgrp; struct peer *updgrp_peer; uint8_t subtype; bool force_update = false; bgp_size_t msg_length = size - (BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE); if (!CHECK_FLAG(peer->cap, PEER_CAP_REFRESH_ADV)) { flog_err(EC_BGP_NO_CAP, ""%s [Error] BGP route refresh is not enabled"", peer->host); bgp_notify_send(peer, BGP_NOTIFY_HEADER_ERR, BGP_NOTIFY_HEADER_BAD_MESTYPE); return BGP_Stop; } if (!peer_established(peer)) { flog_err( EC_BGP_INVALID_STATUS, ""%s [Error] Route refresh packet received under status %s"", peer->host, lookup_msg(bgp_status_msg, peer->status, NULL)); bgp_notify_send(peer, BGP_NOTIFY_FSM_ERR, bgp_fsm_error_subcode(peer->status)); return BGP_Stop; } s = peer->curr; pkt_afi = stream_getw(s); subtype = stream_getc(s); pkt_safi = stream_getc(s); if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi, &safi)) { zlog_info( ""%s REFRESH_REQ for unrecognized afi/safi: %s/%s - ignored"", peer->host, iana_afi2str(pkt_afi), iana_safi2str(pkt_safi)); return BGP_PACKET_NOOP; } if (size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE - BGP_HEADER_SIZE) { uint8_t *end; uint8_t when_to_refresh; uint8_t orf_type; uint16_t orf_len; if (subtype) { if (msg_length != 4) { zlog_err( ""%s Enhanced Route Refresh message length error"", peer->host); bgp_notify_send( peer, BGP_NOTIFY_ROUTE_REFRESH_ERR, BGP_NOTIFY_ROUTE_REFRESH_INVALID_MSG_LEN); } if (subtype > 2) zlog_err( ""%s Enhanced Route Refresh invalid subtype"", peer->host); } if (msg_length < 5) { zlog_info(""%s ORF route refresh length error"", peer->host); bgp_notify_send(peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_SUBCODE_UNSPECIFIC); return BGP_Stop; } when_to_refresh = stream_getc(s); end = stream_pnt(s) + (size - 5); while ((stream_pnt(s) + 2) < end) { orf_type = stream_getc(s); orf_len = stream_getw(s); if ((stream_pnt(s) + orf_len) > end) break;  if (orf_type == ORF_TYPE_PREFIX) { uint8_t *p_pnt = stream_pnt(s); uint8_t *p_end = stream_pnt(s) + orf_len; struct orf_prefix orfp; uint8_t common = 0; uint32_t seq; int psize; char name[BUFSIZ]; int ret = CMD_SUCCESS; if (bgp_debug_neighbor_events(peer)) { zlog_debug( ""%pBP rcvd Prefixlist ORF(%d) length %d"", peer, orf_type, orf_len); } snprintf(name, sizeof(name), ""%s.%d.%d"", peer->host, afi, safi); if (*p_pnt & ORF_COMMON_PART_REMOVE_ALL) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd Remove-All pfxlist ORF request"", peer); prefix_bgp_orf_remove_all(afi, name); break; } if (orf_len < 7) break; while (p_pnt < p_end) { int ok; memset(&orfp, 0, sizeof(orfp)); common = *p_pnt++; ok = ((uint32_t)(p_end - p_pnt) >= sizeof(uint32_t)); if (ok) { memcpy(&seq, p_pnt, sizeof(uint32_t)); p_pnt += sizeof(uint32_t); orfp.seq = ntohl(seq); } else p_pnt = p_end; if (p_pnt < p_end) orfp.ge = *p_pnt++; if (p_pnt < p_end) orfp.le = *p_pnt++; if ((ok = (p_pnt < p_end))) orfp.p.prefixlen = *p_pnt++; orfp.p.family = afi2family(afi); psize = PSIZE(orfp.p.prefixlen); if (psize > prefix_blen(&orfp.p)) { ok = 0; psize = prefix_blen(&orfp.p); } if (psize > (p_end - p_pnt)) { ok = 0; psize = p_end - p_pnt; } if (psize > 0) memcpy(&orfp.p.u.prefix, p_pnt, psize); p_pnt += psize; if (bgp_debug_neighbor_events(peer)) { char buf[INET6_BUFSIZ]; zlog_debug( ""%pBP rcvd %s %s seq %u %s/%d ge %d le %d%s"", peer, (common & ORF_COMMON_PART_REMOVE ? ""Remove"" : ""Add""), (common & ORF_COMMON_PART_DENY ? ""deny"" : ""permit""), orfp.seq, inet_ntop( orfp.p.family, &orfp.p.u.prefix, buf, INET6_BUFSIZ), orfp.p.prefixlen, orfp.ge, orfp.le, ok ? """" : "" MALFORMED""); } if (ok) ret = prefix_bgp_orf_set( name, afi, &orfp, (common & ORF_COMMON_PART_DENY ? 0 : 1), (common & ORF_COMMON_PART_REMOVE ? 0 : 1)); if (!ok || (ok && ret != CMD_SUCCESS)) { zlog_info( ""%pBP Received misformatted prefixlist ORF. Remove All pfxlist"", peer); prefix_bgp_orf_remove_all(afi, name); break; } } peer->orf_plist[afi][safi] = prefix_bgp_orf_lookup(afi, name); } stream_forward_getp(s, orf_len); } if (bgp_debug_neighbor_events(peer)) zlog_debug(""%pBP rcvd Refresh %s ORF request"", peer, when_to_refresh == REFRESH_DEFER ? ""Defer"" : ""Immediate""); if (when_to_refresh == REFRESH_DEFER) return BGP_PACKET_NOOP; } if (CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH)) UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ORF_WAIT_REFRESH); paf = peer_af_find(peer, afi, safi); if (paf && paf->subgroup) { if (peer->orf_plist[afi][safi]) { updgrp = PAF_UPDGRP(paf); updgrp_peer = UPDGRP_PEER(updgrp); updgrp_peer->orf_plist[afi][safi] = peer->orf_plist[afi][safi]; } force_update = true; if (CHECK_FLAG(paf->subgroup->sflags, SUBGRP_STATUS_DEFAULT_ORIGINATE)) UNSET_FLAG(paf->subgroup->sflags, SUBGRP_STATUS_DEFAULT_ORIGINATE); } if (subtype == BGP_ROUTE_REFRESH_BORR) { if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EOR_RECEIVED)) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s before EoR"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } if (peer->t_refresh_stalepath) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s, whereas BoRR already received"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_RECEIVED); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_RECEIVED); if (peer_active_nego(peer)) { SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_ENHANCED_REFRESH); bgp_set_stale_route(peer, afi, safi); } if (peer_established(peer)) event_add_timer(bm->master, bgp_refresh_stalepath_timer_expire, paf, peer->bgp->stalepath_time, &peer->t_refresh_stalepath); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (BoRR) for %s/%s, triggering timer for %u seconds"", peer, afi2str(afi), safi2str(safi), peer->bgp->stalepath_time); } else if (subtype == BGP_ROUTE_REFRESH_EORR) { if (!peer->t_refresh_stalepath) { zlog_err( ""%pBP rcvd route-refresh (EoRR) for %s/%s, whereas no BoRR received"", peer, afi2str(afi), safi2str(safi)); return BGP_PACKET_NOOP; } EVENT_OFF(peer->t_refresh_stalepath); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_RECEIVED); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_RECEIVED); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (EoRR) for %s/%s, stopping BoRR timer"", peer, afi2str(afi), safi2str(safi)); if (peer->nsf[afi][safi]) bgp_clear_stale_route(peer, afi, safi); } else { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (REQUEST) for %s/%s"", peer, afi2str(afi), safi2str(safi)); if (CHECK_FLAG(peer->cap, PEER_CAP_ENHANCED_RR_RCV)) { if (!CHECK_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EOR_SEND)) { if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP rcvd route-refresh (REQUEST) for %s/%s before EoR"", peer, afi2str(afi), safi2str(safi)); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_REFRESH_PENDING); return BGP_PACKET_NOOP; } bgp_route_refresh_send(peer, afi, safi, 0, 0, 0, BGP_ROUTE_REFRESH_BORR); if (bgp_debug_neighbor_events(peer)) zlog_debug( ""%pBP sending route-refresh (BoRR) for %s/%s"", peer, afi2str(afi), safi2str(safi)); SET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_BORR_SEND); UNSET_FLAG(peer->af_sflags[afi][safi], PEER_STATUS_EORR_SEND); } } bgp_announce_route(peer, afi, safi, force_update); return BGP_PACKET_NOOP; }"
"static MagickBooleanType ReadDDSInfo(Image *image, DDSInfo *dds_info) { size_t hdr_size, required; (void) SeekBlob(image, 4, SEEK_SET); hdr_size = ReadBlobLSBLong(image); if (hdr_size != 124) return MagickFalse; dds_info->flags = ReadBlobLSBLong(image); required=(size_t) (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT); if ((dds_info->flags & required) != required) return MagickFalse; dds_info->height = ReadBlobLSBLong(image); dds_info->width = ReadBlobLSBLong(image); dds_info->pitchOrLinearSize = ReadBlobLSBLong(image); dds_info->depth = ReadBlobLSBLong(image); dds_info->mipmapcount = ReadBlobLSBLong(image); (void) SeekBlob(image, 44, SEEK_CUR);    hdr_size = ReadBlobLSBLong(image); if (hdr_size != 32) return MagickFalse; dds_info->pixelformat.flags = ReadBlobLSBLong(image); dds_info->pixelformat.fourcc = ReadBlobLSBLong(image); dds_info->pixelformat.rgb_bitcount = ReadBlobLSBLong(image); dds_info->pixelformat.r_bitmask = ReadBlobLSBLong(image); dds_info->pixelformat.g_bitmask = ReadBlobLSBLong(image); dds_info->pixelformat.b_bitmask = ReadBlobLSBLong(image); dds_info->pixelformat.alpha_bitmask = ReadBlobLSBLong(image); dds_info->ddscaps1 = ReadBlobLSBLong(image); dds_info->ddscaps2 = ReadBlobLSBLong(image); (void) SeekBlob(image, 12, SEEK_CUR);  return MagickTrue; }"
"int modbus_reply(modbus_t *ctx, const uint8_t *req, int req_length, modbus_mapping_t *mb_mapping) { int offset; int slave; int function; uint16_t address; uint8_t rsp[MAX_MESSAGE_LENGTH]; int rsp_length = 0; sft_t sft; if (ctx == NULL) { errno = EINVAL; return -1; } offset = ctx->backend->header_length; slave = req[offset - 1]; function = req[offset]; address = (req[offset + 1] << 8) + req[offset + 2]; sft.slave = slave; sft.function = function; sft.t_id = ctx->backend->prepare_response_tid(req, &req_length); switch (function) { case MODBUS_FC_READ_COILS: case MODBUS_FC_READ_DISCRETE_INPUTS: { unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS); int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits; int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits; uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits; const char * const name = is_input ? ""read_input_bits"" : ""read_bits""; int nb = (req[offset + 3] << 8) + req[offset + 4]; int mapping_address = address - start_bits; if (nb < 1 || MODBUS_MAX_READ_BITS < nb) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE, ""Illegal nb of values %d in %s (max %d)\n"", nb, name, MODBUS_MAX_READ_BITS); } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in %s\n"", mapping_address < 0 ? address : address + nb, name); } else { rsp_length = ctx->backend->build_response_basis(&sft, rsp); rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0); rsp_length = response_io_status(tab_bits, mapping_address, nb, rsp, rsp_length); } } break; case MODBUS_FC_READ_HOLDING_REGISTERS: case MODBUS_FC_READ_INPUT_REGISTERS: { unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS); int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers; int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers; uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers; const char * const name = is_input ? ""read_input_registers"" : ""read_registers""; int nb = (req[offset + 3] << 8) + req[offset + 4]; int mapping_address = address - start_registers; if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE, ""Illegal nb of values %d in %s (max %d)\n"", nb, name, MODBUS_MAX_READ_REGISTERS); } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in %s\n"", mapping_address < 0 ? address : address + nb, name); } else { int i; rsp_length = ctx->backend->build_response_basis(&sft, rsp); rsp[rsp_length++] = nb << 1; for (i = mapping_address; i < mapping_address + nb; i++) { rsp[rsp_length++] = tab_registers[i] >> 8; rsp[rsp_length++] = tab_registers[i] & 0xFF; } } } break; case MODBUS_FC_WRITE_SINGLE_COIL: { int mapping_address = address - mb_mapping->start_bits; if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in write_bit\n"", address); } else { int data = (req[offset + 3] << 8) + req[offset + 4]; if (data == 0xFF00 || data == 0x0) { mb_mapping->tab_bits[mapping_address] = data ? ON : OFF; memcpy(rsp, req, req_length); rsp_length = req_length; } else { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE, ""Illegal data value 0x%0X in write_bit request at address %0X\n"", data, address); } } } break; case MODBUS_FC_WRITE_SINGLE_REGISTER: { int mapping_address = address - mb_mapping->start_registers; if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in write_register\n"", address); } else { int data = (req[offset + 3] << 8) + req[offset + 4]; mb_mapping->tab_registers[mapping_address] = data; memcpy(rsp, req, req_length); rsp_length = req_length; } } break; case MODBUS_FC_WRITE_MULTIPLE_COILS: { int nb = (req[offset + 3] << 8) + req[offset + 4]; int mapping_address = address - mb_mapping->start_bits; if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE, ""Illegal number of values %d in write_bits (max %d)\n"", nb, MODBUS_MAX_WRITE_BITS); } else if (mapping_address < 0 || (mapping_address + nb) > mb_mapping->nb_bits) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in write_bits\n"", mapping_address < 0 ? address : address + nb); } else { modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb, &req[offset + 6]); rsp_length = ctx->backend->build_response_basis(&sft, rsp); memcpy(rsp + rsp_length, req + rsp_length, 4); rsp_length += 4; } } break; case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: { int nb = (req[offset + 3] << 8) + req[offset + 4]; int mapping_address = address - mb_mapping->start_registers; if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE, ""Illegal number of values %d in write_registers (max %d)\n"", nb, MODBUS_MAX_WRITE_REGISTERS); } else if (mapping_address < 0 || (mapping_address + nb) > mb_mapping->nb_registers) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in write_registers\n"", mapping_address < 0 ? address : address + nb); } else { int i, j; for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) { mb_mapping->tab_registers[i] = (req[offset + j] << 8) + req[offset + j + 1]; } rsp_length = ctx->backend->build_response_basis(&sft, rsp); memcpy(rsp + rsp_length, req + rsp_length, 4); rsp_length += 4; } } break; case MODBUS_FC_REPORT_SLAVE_ID: { int str_len; int byte_count_pos; rsp_length = ctx->backend->build_response_basis(&sft, rsp); byte_count_pos = rsp_length++; rsp[rsp_length++] = _REPORT_SLAVE_ID; rsp[rsp_length++] = 0xFF; str_len = 3 + strlen(LIBMODBUS_VERSION_STRING); memcpy(rsp + rsp_length, ""LMB"" LIBMODBUS_VERSION_STRING, str_len); rsp_length += str_len; rsp[byte_count_pos] = rsp_length - byte_count_pos - 1; } break; case MODBUS_FC_READ_EXCEPTION_STATUS: if (ctx->debug) { fprintf(stderr, ""FIXME Not implemented\n""); } errno = ENOPROTOOPT; return -1; break; case MODBUS_FC_MASK_WRITE_REGISTER: { int mapping_address = address - mb_mapping->start_registers; if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data address 0x%0X in write_register\n"", address); } else { uint16_t data = mb_mapping->tab_registers[mapping_address]; uint16_t and = (req[offset + 3] << 8) + req[offset + 4]; uint16_t or = (req[offset + 5] << 8) + req[offset + 6]; data = (data & and) | (or & (~and)); mb_mapping->tab_registers[mapping_address] = data; memcpy(rsp, req, req_length); rsp_length = req_length; } } break; case MODBUS_FC_WRITE_AND_READ_REGISTERS: { int nb = (req[offset + 3] << 8) + req[offset + 4]; uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6]; int nb_write = (req[offset + 7] << 8) + req[offset + 8]; int nb_write_bytes = req[offset + 9]; int mapping_address = address - mb_mapping->start_registers; int mapping_address_write = address_write - mb_mapping->start_registers; if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write || nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb || nb_write_bytes != nb_write * 2) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE, ""Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n"", nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS); } else if (mapping_address < 0 || (mapping_address + nb) > mb_mapping->nb_registers || mapping_address < 0 || (mapping_address_write + nb_write) > mb_mapping->nb_registers) { rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE, ""Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n"", mapping_address < 0 ? address : address + nb, mapping_address_write < 0 ? address_write : address_write + nb_write); } else { int i, j; rsp_length = ctx->backend->build_response_basis(&sft, rsp); rsp[rsp_length++] = nb << 1; for (i = mapping_address_write, j = 10; i < mapping_address_write + nb_write; i++, j += 2) { mb_mapping->tab_registers[i] = (req[offset + j] << 8) + req[offset + j + 1]; } for (i = mapping_address; i < mapping_address + nb; i++) { rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8; rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF; } } } break; default: rsp_length = response_exception( ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE, ""Unknown Modbus function code: 0x%0X\n"", function); break; } return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU && slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length); }"
"int Tar::Extract(wxString destdir, wxProgressDialog* aProgressDialog) { wxString strBuf; int lError = 0; wxString strCwd = ::wxGetCwd(); wxFile wx_In(mFilePath, wxFile::read); if(!wx_In.IsOpened()) { lError = 1; wxLogFatalError(_(""Error: File '%s' not found!  Cannot extract data.""), mFilePath.c_str()); throw; } if (!::wxDirExists(destdir)) wxFileName::Mkdir(destdir, 0777, wxPATH_MKDIR_FULL);     if (!::wxDirExists(destdir)) { wxLogFatalError(_(""Error: Cannot create directory '%s'.  Cannot extract data.""), destdir.c_str()); throw; } ::wxSetWorkingDirectory(destdir); __gnu_cxx::stdio_filebuf<char> filebuf(wx_In.fd(), std::ios::in); std::istream f_In(&filebuf); if (ExtractData(f_In, destdir, aProgressDialog) != 0) { lError = 1; } wx_In.Close(); ::wxSetWorkingDirectory(strCwd); return lError; }"
"static int xhci_ring_chain_length(XHCIState *xhci, const XHCIRing *ring) { PCIDevice *pci_dev = PCI_DEVICE(xhci); XHCITRB trb; int length = 0; dma_addr_t dequeue = ring->dequeue; bool ccs = ring->ccs; bool control_td_set = 0; while (1) { TRBType type; pci_dma_read(pci_dev, dequeue, &trb, TRB_SIZE); le64_to_cpus(&trb.parameter); le32_to_cpus(&trb.status); le32_to_cpus(&trb.control); if ((trb.control & TRB_C) != ccs) { return -length; } type = TRB_TYPE(trb); if (type == TR_LINK) { dequeue = xhci_mask64(trb.parameter); if (trb.control & TRB_LK_TC) { ccs = !ccs; } continue; } length += 1; dequeue += TRB_SIZE; if (type == TR_SETUP) { control_td_set = 1; } else if (type == TR_STATUS) { control_td_set = 0; } if (!control_td_set && !(trb.control & TRB_TR_CH)) { return length; } } }"
"explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""num_buckets"", &num_buckets_)); int64 signed_hash_key_; OP_REQUIRES_OK(context, context->GetAttr(""hash_key"", &signed_hash_key_)); hash_key_ = static_cast<uint64>(signed_hash_key_); }"
"void __fsnotify_update_child_dentry_flags(struct inode *inode) { struct dentry *alias; int watched; if (!S_ISDIR(inode->i_mode)) return; watched = fsnotify_inode_watches_children(inode); spin_lock(&inode->i_lock); hlist_for_each_entry(alias, &inode->i_dentry, d_alias) { struct dentry *child; spin_lock(&alias->d_lock); list_for_each_entry(child, &alias->d_subdirs, d_u.d_child) { if (!child->d_inode) continue; spin_lock_nested(&child->d_lock, DENTRY_D_LOCK_NESTED); if (watched) child->d_flags |= DCACHE_FSNOTIFY_PARENT_WATCHED; else child->d_flags &= ~DCACHE_FSNOTIFY_PARENT_WATCHED; spin_unlock(&child->d_lock); } spin_unlock(&alias->d_lock); } spin_unlock(&inode->i_lock); }"
"static unsigned int set_iommu_pte_present(unsigned long pt_mfn, unsigned long dfn, unsigned long next_mfn, int pde_level, bool iw, bool ir) { struct amd_iommu_pte *table, *pde; unsigned int flush_flags; table = map_domain_page(_mfn(pt_mfn)); pde = &table[pfn_to_pde_idx(dfn, pde_level)]; flush_flags = set_iommu_pde_present(pde, next_mfn, 0, iw, ir); unmap_domain_page(table); return flush_flags; }"
"bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers) { for (const auto &h : headers) { if (h.first == ""Strict-Transport-Security"") { header = h.second; if (parseSTSHeader() && maxAgeFound) { expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge); return true; } } } subDomainsFound = false; return false; }"
"int fit_check_format(const void *fit, ulong size) { int ret; ret = fdt_check_header(fit); if (ret) { log_debug(""Wrong FIT format: not a flattened device tree (err=%d)\n"", ret); return -ENOEXEC; } if (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) { log_debug(""Wrong FIT format: no description\n""); return -ENOMSG; } if (IMAGE_ENABLE_TIMESTAMP) { if (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) { log_debug(""Wrong FIT format: no timestamp\n""); return -ENODATA; } } if (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) { log_debug(""Wrong FIT format: no images parent node\n""); return -ENOENT; } return 0; }"
void Gobby::EditCommands::on_mark_set() { g_assert(m_current_view != NULL); GtkTextBuffer* buffer = GTK_TEXT_BUFFER(m_current_view->get_text_buffer()); m_actions.copy->set_enabled( gtk_text_buffer_get_has_selection(buffer)); if(m_current_view->get_active_user() != NULL) { m_actions.cut->set_enabled( gtk_text_buffer_get_has_selection(buffer)); } }
"static int dissect_tds7_colmetadata_token(tvbuff_t *tvb, struct _netlib_data *nl_data, guint offset, proto_tree *tree, tds_conv_info_t *tds_info) { guint cur = offset; guint16 num_columns, flags, numparts, parti, partlen, msg_len; guint8 type; int i, col_offset; proto_tree* col_tree, *flags_tree; proto_item* flags_item, * type_item, *col_item; int encoding = tds_little_endian ? ENC_LITTLE_ENDIAN : ENC_BIG_ENDIAN; num_columns = tvb_get_letohs(tvb, cur); nl_data->num_cols = num_columns; proto_tree_add_item(tree, hf_tds_colmetadata_columns, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur +=2; for(i=0; i != num_columns; i++) { col_offset = cur; col_item = proto_tree_add_item(tree, hf_tds_colmetadata_field, tvb, cur, 0, ENC_NA); col_tree = proto_item_add_subtree(col_item, ett_tds_col); proto_item_set_text(col_item, ""Column %d"", i + 1); nl_data->columns[i] = wmem_new(wmem_packet_scope(), struct _tds_col); nl_data->columns[i]->name[0] ='\0'; if (TDS_PROTO_TDS7_1_OR_LESS) { proto_tree_add_item(col_tree, hf_tds_colmetadata_usertype16, tvb, cur, 2, ENC_LITTLE_ENDIAN); nl_data->columns[i]->utype = tvb_get_guint16(tvb, cur, encoding); cur +=2; } else { proto_tree_add_item_ret_uint(col_tree, hf_tds_colmetadata_usertype32, tvb, cur, 4, ENC_LITTLE_ENDIAN, &(nl_data->columns[i]->utype)); cur +=4; } flags = tvb_get_letohs(tvb, cur); flags_item = proto_tree_add_uint(col_tree, hf_tds_colmetadata_results_token_flags, tvb, cur, 2, flags); if(flags_item) { flags_tree = proto_item_add_subtree(flags_item, ett_tds_flags); if(flags_tree) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_nullable, tvb, cur, 2, ENC_BIG_ENDIAN); proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_casesen, tvb, cur, 2, ENC_BIG_ENDIAN); proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_updateable, tvb, cur, 2, ENC_BIG_ENDIAN); proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_identity, tvb, cur, 2, ENC_BIG_ENDIAN); if(TDS_PROTO_TDS7_2_OR_GREATER) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_computed, tvb, cur, 2, ENC_BIG_ENDIAN); } if(TDS_PROTO_TDS7_3A_OR_LESS) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_reservedodbc, tvb, cur, 2, ENC_BIG_ENDIAN); } if(TDS_PROTO_TDS7_2_OR_GREATER) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_fixedlenclrtype, tvb, cur, 2, ENC_BIG_ENDIAN); } if(TDS_PROTO_TDS7_3B_OR_GREATER) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_sparsecolumnset, tvb, cur, 2, ENC_BIG_ENDIAN); } if(TDS_PROTO_TDS7_4_OR_GREATER) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_encrypted, tvb, cur, 2, ENC_BIG_ENDIAN); } if(TDS_PROTO_TDS7_2_OR_GREATER) { proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_hidden, tvb, cur, 2, ENC_BIG_ENDIAN); proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_key, tvb, cur, 2, ENC_BIG_ENDIAN); proto_tree_add_item(flags_tree, hf_tds_colmetadata_flags_nullableunknown, tvb, cur, 2, ENC_BIG_ENDIAN); } } } cur +=2; type  = tvb_get_guint8(tvb, cur); type_item = proto_tree_add_item(col_tree, hf_tds_colmetadata_results_token_type, tvb, cur, 1, ENC_NA); proto_item_append_text(type_item, "" (%s)"", val_to_str(type, tds_data_type_names, ""Invalid data type: %02X"")); nl_data->columns[i]->ctype = type; cur++; if(is_fixedlen_type_tds(type)) { nl_data->columns[i]->csize = get_size_by_coltype(type); } else if(is_varlen_type_tds(type)) { switch(type) { case TDS_DATA_TYPE_GUID: case TDS_DATA_TYPE_INTN: case TDS_DATA_TYPE_BITN: case TDS_DATA_TYPE_FLTN: case TDS_DATA_TYPE_MONEYN: case TDS_DATA_TYPE_DATETIMN: case TDS_DATA_TYPE_CHAR: case TDS_DATA_TYPE_VARCHAR: case TDS_DATA_TYPE_BINARY: case TDS_DATA_TYPE_VARBINARY: { proto_tree_add_item(col_tree, hf_tds_colmetadata_csize, tvb, cur, 1, ENC_LITTLE_ENDIAN ); nl_data->columns[i]->csize = tvb_get_guint8(tvb, cur); cur++; break; } case TDS_DATA_TYPE_DATEN: { break; } case TDS_DATA_TYPE_DECIMAL: case TDS_DATA_TYPE_NUMERIC: case TDS_DATA_TYPE_DECIMALN: case TDS_DATA_TYPE_NUMERICN: { proto_tree_add_item(col_tree, hf_tds_colmetadata_csize, tvb, cur, 1, ENC_LITTLE_ENDIAN ); nl_data->columns[i]->csize = tvb_get_guint8(tvb,cur); cur++; proto_tree_add_item(col_tree, hf_tds_colmetadata_precision, tvb, cur, 1, ENC_LITTLE_ENDIAN ); nl_data->columns[i]->precision = tvb_get_guint8(tvb,cur); cur++; proto_tree_add_item(col_tree, hf_tds_colmetadata_scale, tvb, cur, 1, ENC_LITTLE_ENDIAN ); nl_data->columns[i]->scale = tvb_get_guint8(tvb,cur); cur++; break; } case TDS_DATA_TYPE_TIMEN: case TDS_DATA_TYPE_DATETIME2N: case TDS_DATA_TYPE_DATETIMEOFFSETN: { proto_tree_add_item(col_tree, hf_tds_colmetadata_scale, tvb, cur, 1, ENC_LITTLE_ENDIAN ); nl_data->columns[i]->scale = tvb_get_guint8(tvb,cur); cur++; break; } case TDS_DATA_TYPE_BIGVARBIN: { nl_data->columns[i]->csize = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_large_type_size, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; break; } case TDS_DATA_TYPE_BIGVARCHR: { nl_data->columns[i]->csize = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_large_type_size, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_codepage, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_flags, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_charset_id, tvb, cur, 1, ENC_LITTLE_ENDIAN ); cur +=1; break; } case TDS_DATA_TYPE_BIGBINARY: { nl_data->columns[i]->csize = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_large_type_size, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; break; } case TDS_DATA_TYPE_BIGCHAR: case TDS_DATA_TYPE_NVARCHAR: case TDS_DATA_TYPE_NCHAR: { nl_data->columns[i]->csize = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_large_type_size, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_codepage, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_flags, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_charset_id, tvb, cur, 1, ENC_LITTLE_ENDIAN ); cur +=1; break; } case TDS_DATA_TYPE_XML: { guint8 schema_present; schema_present = tvb_get_guint8(tvb, cur); cur += 1; if(schema_present) { msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_dbname_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_dbname, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_owningschema_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_owningschema, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_typename_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_typename, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_xmlschemacollection_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_xmlschemacollection, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } } break; } case TDS_DATA_TYPE_UDT: { proto_tree_add_item(col_tree, hf_tds_colmetadata_maxbytesize, tvb, cur, 2, ENC_NA|ENC_LITTLE_ENDIAN); cur += 2; msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_dbname_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_dbname, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_schemaname_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_schemaname, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_typename_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_typename, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } msg_len = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_assemblyqualifiedname_length, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_assemblyqualifiedname, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } break; } case TDS_DATA_TYPE_IMAGE: { cur += 4; numparts = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name_parts, tvb, cur, 1, ENC_LITTLE_ENDIAN); cur += 1; for(parti = 0; parti < numparts; parti++) { partlen = tvb_get_letohs(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name_length, tvb, cur, 2, ENC_LITTLE_ENDIAN); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name, tvb, cur + 2, partlen * 2, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += 2 + (partlen * 2); } break; } case TDS_DATA_TYPE_TEXT: case TDS_DATA_TYPE_NTEXT: { cur += 2; nl_data->columns[i]->csize = tvb_get_guint16(tvb, cur, encoding); proto_tree_add_item(col_tree, hf_tds_colmetadata_large_type_size, tvb, cur, 2, ENC_LITTLE_ENDIAN); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_codepage, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_flags, tvb, cur, 2, ENC_LITTLE_ENDIAN ); cur += 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_collate_charset_id, tvb, cur, 1, ENC_LITTLE_ENDIAN ); cur +=1; numparts = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name_parts, tvb, cur, 1, ENC_LITTLE_ENDIAN); cur += 1; for(parti = 0; parti < numparts; parti++) { partlen = tvb_get_letohs(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name_length, tvb, cur, 2, ENC_LITTLE_ENDIAN); proto_tree_add_item(col_tree, hf_tds_colmetadata_table_name, tvb, cur + 2, partlen * 2, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += 2 + (partlen * 2); } break; } case TDS_DATA_TYPE_SSVARIANT: { cur += 4; break; } } } msg_len = tvb_get_guint8(tvb, cur); proto_tree_add_item(col_tree, hf_tds_colmetadata_colname_length, tvb, cur, 1, ENC_NA); cur += 1; if(msg_len != 0) { msg_len *= 2; proto_tree_add_item(col_tree, hf_tds_colmetadata_colname, tvb, cur, msg_len, ENC_UTF_16|ENC_LITTLE_ENDIAN); cur += msg_len; } proto_item_set_len(col_item, cur - col_offset); } return cur - offset; }"
"CFX_GlyphBitmap* CFX_FaceCache::RenderGlyph(CFX_Font* pFont, uint32_t glyph_index, FX_BOOL bFontStyle, const CFX_Matrix* pMatrix, int dest_width, int anti_alias) { if (!m_Face) { return NULL; } FXFT_Matrix ft_matrix; ft_matrix.xx = (signed long)(pMatrix->GetA() / 64 * 65536); ft_matrix.xy = (signed long)(pMatrix->GetC() / 64 * 65536); ft_matrix.yx = (signed long)(pMatrix->GetB() / 64 * 65536); ft_matrix.yy = (signed long)(pMatrix->GetD() / 64 * 65536); FX_BOOL bUseCJKSubFont = FALSE; const CFX_SubstFont* pSubstFont = pFont->GetSubstFont(); if (pSubstFont) { bUseCJKSubFont = pSubstFont->m_bSubstOfCJK && bFontStyle; int skew = 0; if (bUseCJKSubFont) { skew = pSubstFont->m_bItlicCJK ? -15 : 0; } else { skew = pSubstFont->m_ItalicAngle; } if (skew) { skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE) ? -58 : -g_AngleSkew[-skew]; if (pFont->IsVertical()) ft_matrix.yx += ft_matrix.yy * skew / 100; else ft_matrix.xy += -ft_matrix.xx * skew / 100; } if (pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) { pFont->AdjustMMParams(glyph_index, dest_width, pFont->GetSubstFont()->m_Weight); } } ScopedFontTransform scoped_transform(m_Face, &ft_matrix); int load_flags = (m_Face->face_flags & FT_FACE_FLAG_SFNT) ? FXFT_LOAD_NO_BITMAP : (FXFT_LOAD_NO_BITMAP | FT_LOAD_NO_HINTING); int error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags); if (error) { if (load_flags & FT_LOAD_NO_HINTING || load_flags & FT_LOAD_NO_SCALE) { return NULL; } load_flags |= FT_LOAD_NO_HINTING; error = FXFT_Load_Glyph(m_Face, glyph_index, load_flags); if (error) { return NULL; } } int weight = 0; if (bUseCJKSubFont) { weight = pSubstFont->m_WeightCJK; } else { weight = pSubstFont ? pSubstFont->m_Weight : 0; } if (pSubstFont && !(pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) && weight > 400) { uint32_t index = (weight - 400) / 10; if (index >= WEIGHTPOW_ARRAY_SIZE) return NULL; int level = 0; if (pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET) { level = g_WeightPow_SHIFTJIS[index] * 2 * (FXSYS_abs((int)(ft_matrix.xx)) + FXSYS_abs((int)(ft_matrix.xy))) / 36655; } else { level = g_WeightPow_11[index] * (FXSYS_abs((int)(ft_matrix.xx)) + FXSYS_abs((int)(ft_matrix.xy))) / 36655; } FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level); } FXFT_Library_SetLcdFilter(CFX_GEModule::Get()->GetFontMgr()->GetFTLibrary(), FT_LCD_FILTER_DEFAULT); error = FXFT_Render_Glyph(m_Face, anti_alias); if (error) { return NULL; } int bmwidth = FXFT_Get_Bitmap_Width(FXFT_Get_Glyph_Bitmap(m_Face)); int bmheight = FXFT_Get_Bitmap_Rows(FXFT_Get_Glyph_Bitmap(m_Face)); if (bmwidth > 2048 || bmheight > 2048) { return NULL; } int dib_width = bmwidth; CFX_GlyphBitmap* pGlyphBitmap = new CFX_GlyphBitmap; pGlyphBitmap->m_Bitmap.Create( dib_width, bmheight, anti_alias == FXFT_RENDER_MODE_MONO ? FXDIB_1bppMask : FXDIB_8bppMask); pGlyphBitmap->m_Left = FXFT_Get_Glyph_BitmapLeft(m_Face); pGlyphBitmap->m_Top = FXFT_Get_Glyph_BitmapTop(m_Face); int dest_pitch = pGlyphBitmap->m_Bitmap.GetPitch(); int src_pitch = FXFT_Get_Bitmap_Pitch(FXFT_Get_Glyph_Bitmap(m_Face)); uint8_t* pDestBuf = pGlyphBitmap->m_Bitmap.GetBuffer(); uint8_t* pSrcBuf = (uint8_t*)FXFT_Get_Bitmap_Buffer(FXFT_Get_Glyph_Bitmap(m_Face)); if (anti_alias != FXFT_RENDER_MODE_MONO && FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) == FXFT_PIXEL_MODE_MONO) { int bytes = anti_alias == FXFT_RENDER_MODE_LCD ? 3 : 1; for (int i = 0; i < bmheight; i++) for (int n = 0; n < bmwidth; n++) { uint8_t data = (pSrcBuf[i * src_pitch + n / 8] & (0x80 >> (n % 8))) ? 255 : 0; for (int b = 0; b < bytes; b++) { pDestBuf[i * dest_pitch + n * bytes + b] = data; } } } else { FXSYS_memset(pDestBuf, 0, dest_pitch * bmheight); if (anti_alias == FXFT_RENDER_MODE_MONO && FXFT_Get_Bitmap_PixelMode(FXFT_Get_Glyph_Bitmap(m_Face)) == FXFT_PIXEL_MODE_MONO) { int rowbytes = FXSYS_abs(src_pitch) > dest_pitch ? dest_pitch : FXSYS_abs(src_pitch); for (int row = 0; row < bmheight; row++) { FXSYS_memcpy(pDestBuf + row * dest_pitch, pSrcBuf + row * src_pitch, rowbytes); } } else { _ContrastAdjust(pSrcBuf, pDestBuf, bmwidth, bmheight, src_pitch, dest_pitch); _GammaAdjust(pDestBuf, bmwidth, bmheight, dest_pitch, CFX_GEModule::Get()->GetTextGammaTable()); } } return pGlyphBitmap; }"
"static gboolean gvs_fixed_sized_maybe_is_normal (GVariantSerialised value) { if (value.size > 0) { gsize element_fixed_size; g_variant_type_info_query_element (value.type_info, NULL, &element_fixed_size); if (value.size != element_fixed_size) return FALSE; value.type_info = g_variant_type_info_element (value.type_info); value.depth++; return g_variant_serialised_is_normal (value); } return TRUE; }"
"static RAnalStructMember *parse_struct_member (const RBinDwarfDie *all_dies, const ut64 all_dies_count, ut64 curr_die_idx, RAnalStructMember *result) { r_return_val_if_fail (all_dies && result, NULL); const RBinDwarfDie *die = &all_dies[curr_die_idx]; char *name = NULL; char *type = NULL; ut64 offset = 0; ut64 size = 0; RStrBuf strbuf; r_strbuf_init (&strbuf); size_t i; for (i = 0; i < die->count; i++) { RBinDwarfAttrValue *value = &die->attr_values[i]; switch (die->attr_values[i].attr_name) { case DW_AT_name: name = strdup (value->string.content); if (!name) { goto cleanup; } break; case DW_AT_type: parse_type (all_dies, all_dies_count, value->reference, &strbuf, &size); type = r_strbuf_drain_nofree (&strbuf); if (!type || !*type) { goto cleanup; } break; case DW_AT_data_member_location: offset = value->data; break; case DW_AT_accessibility: case DW_AT_mutable: case DW_AT_data_bit_offset: break; case DW_AT_byte_size: size = value->data * CHAR_BIT; break; case DW_AT_bit_size: size = value->data; break; case DW_AT_containing_type: default: break; } } result->name = name; result->type = type; result->offset = offset; result->size = size; return result; cleanup: free (name); free (type); return NULL; }"
ImageResource* ImageDocument::cachedImage() { if (!m_imageElement) createDocumentStructure(); return m_imageElement->cachedImage(); }
"int treeRead(struct READER *reader, struct DATAOBJECT *data) { int i, j, err, olen, elements, size, x, y, z, b, e, dy, dz, sx, sy, sz, dzy, szy; char *input, *output; uint8_t node_type, node_level; uint16_t entries_used; uint32_t size_of_chunk; uint32_t filter_mask; uint64_t address_of_left_sibling, address_of_right_sibling, start[4], child_pointer, key, store; char buf[4]; UNUSED(node_level); UNUSED(address_of_right_sibling); UNUSED(address_of_left_sibling); UNUSED(key); if (data->ds.dimensionality > 3) { log(""TREE dimensions > 3""); return MYSOFA_INVALID_FORMAT; } if (fread(buf, 1, 4, reader->fhd) != 4 || strncmp(buf, ""TREE"", 4)) { log(""cannot read signature of TREE\n""); return MYSOFA_INVALID_FORMAT; } log(""%08lX %.4s\n"", (uint64_t )ftell(reader->fhd) - 4, buf); node_type = (uint8_t)fgetc(reader->fhd); node_level = (uint8_t)fgetc(reader->fhd); entries_used = (uint16_t)readValue(reader, 2); if(entries_used>0x1000) return MYSOFA_UNSUPPORTED_FORMAT; address_of_left_sibling = readValue(reader, reader->superblock.size_of_offsets); address_of_right_sibling = readValue(reader, reader->superblock.size_of_offsets); elements = 1; for (j = 0; j < data->ds.dimensionality; j++) elements *= data->datalayout_chunk[j]; dy = data->datalayout_chunk[1]; dz = data->datalayout_chunk[2]; sx = data->ds.dimension_size[0]; sy = data->ds.dimension_size[1]; sz = data->ds.dimension_size[2]; dzy = dz * dy; szy = sz * sy; size = data->datalayout_chunk[data->ds.dimensionality]; log(""elements %d size %d\n"",elements,size); if (!(output = malloc(elements * size))) { return MYSOFA_NO_MEMORY; } for (e = 0; e < entries_used * 2; e++) { if (node_type == 0) { key = readValue(reader, reader->superblock.size_of_lengths); } else { size_of_chunk = (uint32_t)readValue(reader, 4); filter_mask = (uint32_t)readValue(reader, 4); if (filter_mask) { log(""TREE all filters must be enabled\n""); free(output); return MYSOFA_INVALID_FORMAT; } for (j = 0; j < data->ds.dimensionality; j++) { start[j] = readValue(reader, 8); log(""start %d %lu\n"",j,start[j]); } if (readValue(reader, 8)) { break; } child_pointer = readValue(reader, reader->superblock.size_of_offsets); log("" data at %lX len %u\n"", child_pointer, size_of_chunk); store = ftell(reader->fhd); if (fseek(reader->fhd, child_pointer, SEEK_SET)<0) { free(output); return errno; } if (!(input = malloc(size_of_chunk))) { free(output); return MYSOFA_NO_MEMORY; } if (fread(input, 1, size_of_chunk, reader->fhd) != size_of_chunk) { free(output); free(input); return MYSOFA_INVALID_FORMAT; } olen = elements * size; err = gunzip(size_of_chunk, input, &olen, output); free(input); log(""   gunzip %d %d %d\n"",err, olen, elements*size); if (err || olen != elements * size) { free(output); return MYSOFA_INVALID_FORMAT; } switch (data->ds.dimensionality) { case 1: for (i = 0; i < olen; i++) { b = i / elements; x = i % elements + start[0]; if (x < sx) { j = x * size + b; ((char*)data->data)[j] = output[i]; } } break; case 2: for (i = 0; i < olen; i++) { b = i / elements; x = i % elements; y = x % dy + start[1]; x = x / dy + start[0]; if (y < sy && x < sx) { j = ((x * sy + y) * size) + b; ((char*)data->data)[j] = output[i]; } } break; case 3: for (i = 0; i < olen; i++) { b = i / elements; x = i % elements; z = x % dz + start[2]; y = (x / dz) % dy + start[1]; x = (x / dzy) + start[0]; if (z < sz && y < sy && x < sx) { j = (x * szy + y * sz + z) * size + b; ((char*)data->data)[j] = output[i]; } } break; default: log(""invalid dim\n""); return MYSOFA_INTERNAL_ERROR; } if(fseek(reader->fhd, store, SEEK_SET)<0) { free(output); return errno; } } } free(output); if(fseek(reader->fhd, 4, SEEK_CUR)<0)  return errno; return MYSOFA_OK; }"
"int php_zip_glob(char *pattern, int pattern_len, long flags, zval *return_value TSRMLS_DC)  { #ifdef HAVE_GLOB char cwd[MAXPATHLEN]; int cwd_skip = 0; #ifdef ZTS char work_pattern[MAXPATHLEN]; char *result; #endif glob_t globbuf; int n; int ret; if (pattern_len >= MAXPATHLEN) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Pattern exceeds the maximum allowed length of %d characters"", MAXPATHLEN); return -1; } if ((GLOB_AVAILABLE_FLAGS & flags) != flags) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""At least one of the passed flags is invalid or not supported on this platform""); return -1; } #ifdef ZTS  if (!IS_ABSOLUTE_PATH(pattern, pattern_len)) { result = VCWD_GETCWD(cwd, MAXPATHLEN); if (!result) { cwd[0] = '\0'; } #ifdef PHP_WIN32 if (IS_SLASH(*pattern)) { cwd[2] = '\0'; } #endif cwd_skip = strlen(cwd)+1; snprintf(work_pattern, MAXPATHLEN, ""%s%c%s"", cwd, DEFAULT_SLASH, pattern); pattern = work_pattern; }  #endif globbuf.gl_offs = 0; if (0 != (ret = glob(pattern, flags & GLOB_FLAGMASK, NULL, &globbuf))) { #ifdef GLOB_NOMATCH if (GLOB_NOMATCH == ret) { array_init(return_value); return 0; } #endif return 0; } if (!globbuf.gl_pathc || !globbuf.gl_pathv) { array_init(return_value); return 0; } strncpy(cwd, globbuf.gl_pathv[0], MAXPATHLEN); if (ZIP_OPENBASEDIR_CHECKPATH(cwd)) { return -1; } array_init(return_value); for (n = 0; n < globbuf.gl_pathc; n++) { if (flags & GLOB_ONLYDIR) { struct stat s; if (0 != VCWD_STAT(globbuf.gl_pathv[n], &s)) { continue; } if (S_IFDIR != (s.st_mode & S_IFMT)) { continue; } } add_next_index_string(return_value, globbuf.gl_pathv[n]+cwd_skip, 1); } globfree(&globbuf); return globbuf.gl_pathc; #else php_error_docref(NULL TSRMLS_CC, E_ERROR, ""Glob support is not available""); return 0; #endif   }"
"static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p, int chunk_size, RTMPPacket **prev_pkt_ptr, int *nb_prev_pkt, uint8_t hdr) { uint8_t buf[16]; int channel_id, timestamp, size; uint32_t ts_field;     uint32_t extra = 0; enum RTMPPacketType type; int written = 0; int ret, toread; RTMPPacket *prev_pkt; written++; channel_id = hdr & 0x3F; if (channel_id < 2) {         buf[1] = 0; if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1) return AVERROR(EIO); written += channel_id + 1; channel_id = AV_RL16(buf) + 64; } if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt, channel_id)) < 0) return ret; prev_pkt = *prev_pkt_ptr; size  = prev_pkt[channel_id].size; type  = prev_pkt[channel_id].type; extra = prev_pkt[channel_id].extra; hdr >>= 6;     if (hdr == RTMP_PS_ONEBYTE) { ts_field = prev_pkt[channel_id].ts_field; } else { if (ffurl_read_complete(h, buf, 3) != 3) return AVERROR(EIO); written += 3; ts_field = AV_RB24(buf); if (hdr != RTMP_PS_FOURBYTES) { if (ffurl_read_complete(h, buf, 3) != 3) return AVERROR(EIO); written += 3; size = AV_RB24(buf); if (ffurl_read_complete(h, buf, 1) != 1) return AVERROR(EIO); written++; type = buf[0]; if (hdr == RTMP_PS_TWELVEBYTES) { if (ffurl_read_complete(h, buf, 4) != 4) return AVERROR(EIO); written += 4; extra = AV_RL32(buf); } } } if (ts_field == 0xFFFFFF) { if (ffurl_read_complete(h, buf, 4) != 4) return AVERROR(EIO); timestamp = AV_RB32(buf); } else { timestamp = ts_field; } if (hdr != RTMP_PS_TWELVEBYTES) timestamp += prev_pkt[channel_id].timestamp; if (!prev_pkt[channel_id].read) { if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp, size)) < 0) return ret; p->read = written; p->offset = 0; prev_pkt[channel_id].ts_field   = ts_field; prev_pkt[channel_id].timestamp  = timestamp; } else { RTMPPacket *prev = &prev_pkt[channel_id]; p->data          = prev->data; p->size          = prev->size; p->channel_id    = prev->channel_id; p->type          = prev->type; p->ts_field      = prev->ts_field; p->extra         = prev->extra; p->offset        = prev->offset; p->read          = prev->read + written; p->timestamp     = prev->timestamp; prev->data       = NULL; } p->extra = extra; prev_pkt[channel_id].channel_id = channel_id; prev_pkt[channel_id].type       = type; prev_pkt[channel_id].size       = size; prev_pkt[channel_id].extra      = extra; size = size - p->offset; toread = FFMIN(size, chunk_size); if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) { ff_rtmp_packet_destroy(p); return AVERROR(EIO); } size      -= toread; p->read   += toread; p->offset += toread; if (size > 0) { RTMPPacket *prev = &prev_pkt[channel_id]; prev->data = p->data; prev->read = p->read; prev->offset = p->offset; p->data      = NULL; return AVERROR(EAGAIN); } prev_pkt[channel_id].read = 0;     return p->read; }"
"void ConnectionManagerImpl::doEndStream(ActiveStream& stream) { bool reset_stream = false; if (stream.response_encoder_ != nullptr && (!stream.filter_manager_.remoteComplete() || !stream.state_.codec_saw_local_complete_)) { ENVOY_STREAM_LOG(debug, ""doEndStream() resetting stream"", stream); stream.filter_manager_.setLocalComplete(); stream.state_.codec_saw_local_complete_ = true; if (requestWasConnect(stream.request_headers_, codec_->protocol()) && (stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamConnectionFailure) || stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamConnectionTermination))) { stream.response_encoder_->getStream().resetStream(StreamResetReason::ConnectError); } else { if (stream.filter_manager_.streamInfo().hasResponseFlag( StreamInfo::ResponseFlag::UpstreamProtocolError)) { stream.response_encoder_->getStream().resetStream(StreamResetReason::ProtocolError); } else { stream.response_encoder_->getStream().resetStream(StreamResetReason::LocalReset); } } reset_stream = true; } if (!reset_stream) { doDeferredStreamDestroy(stream); } if (reset_stream && codec_->protocol() < Protocol::Http2) { drain_state_ = DrainState::Closing; } bool http_10_sans_cl = (codec_->protocol() == Protocol::Http10) && (!stream.response_headers_ || !stream.response_headers_->ContentLength()); bool connection_close = stream.state_.saw_connection_close_; bool request_complete = stream.filter_manager_.remoteComplete(); checkForDeferredClose(connection_close && (request_complete || http_10_sans_cl)); }"
"static void dissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq) { int     offset = 0; int     remain; int     want; guint8  header_type; int     basic_hlen; int     message_hlen; guint32 id; guint32 ts     = 0; guint32 tsd    = 0; int     body_len; guint8  cmd; guint32 src; int     chunk_size; rtmpt_frag_t   *tf; rtmpt_id_t     *ti; rtmpt_packet_t *tp; tvbuff_t       *pktbuf; remain = tvb_reported_length(tvb); if (!remain) return; RTMPT_DEBUG(""Segment: cdir=%d seq=%d-%d\n"", cdir, seq, seq+remain-1); if (pinfo->fd->flags.visited) { wmem_stack_t *packets; packets = wmem_stack_new(wmem_packet_scope()); wmem_stack_push(packets, 0); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1); while (tp && tp->lastseq >= seq) { wmem_stack_push(packets, tp); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1); } while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) { if (tp->resident) { pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); } else { pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); } dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } return; } while (remain>0) { tf = NULL; ti = NULL; tp = NULL; if (offset == 0) { tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1); if (tf) { RTMPT_DEBUG(""  tf seq=%d lseq=%d h=%d l=%d\n"", tf->seq, tf->lastseq, tf->have, tf->len); if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) { tf = NULL; } else if (!tf->ishdr) { ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id); if (ti) { tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); } if (tp && tp->chunkwant) { goto unchunk; } tf = NULL; ti = NULL; tp = NULL; } if (tf) { want = tf->len - tf->have; if (remain<want) want = remain; tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want); id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) { if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) { tf->len += 4; } } tf->have += want; tf->lastseq = seq+want-1; remain -= want; offset += want; if (tf->have < tf->len) { return; } } } } if (!tf) { id = tvb_get_guint8(tvb, offset); if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) { header_type = 4; basic_hlen = 1; message_hlen = 0; id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2; } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) { header_type = 4; basic_hlen = 0; message_hlen = 0; id = RTMPT_TYPE_HANDSHAKE_3; } else { header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = rtmpt_message_header_length(id); if ((header_type < 3) && (remain >= (basic_hlen+3))) { if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) { message_hlen += 4; } } if (remain < (basic_hlen+message_hlen)) { tf = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf->ishdr = 1; tf->seq = seq + offset; tf->lastseq = tf->seq + remain - 1; tf->len = basic_hlen + message_hlen; tvb_memcpy(tvb, tf->saved.d, offset, remain); tf->have = remain; wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf); return; } id = id & 0x3f; if (id == 0) id = tvb_get_guint8(tvb, offset+1) + 64; else if (id == 1) id = tvb_get_letohs(tvb, offset+1) + 64; } } else { id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = tf->len - basic_hlen; id = id & 0x3f; if (id == 0) id = tf->saved.d[1] + 64; else if (id == 1) id = pletoh16(tf->saved.d+1) + 64; } if (id <= RTMPT_ID_MAX) ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id); if (ti) tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); if (header_type == 0) src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7); else if (ti) src = ti->src; else src = 0; if (header_type < 2) cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6); else if (ti) cmd = ti->cmd; else cmd = 0; if (id > RTMPT_ID_MAX) { if (id == RTMPT_TYPE_HANDSHAKE_1) chunk_size = body_len = 1536; else if (id == RTMPT_TYPE_HANDSHAKE_2) chunk_size = body_len = 3072; else  chunk_size = body_len = 1536; } else { chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1)); if (!chunk_size) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE; if (header_type < 2) body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3); else if (ti) body_len = ti->len; else body_len = chunk_size; if (body_len > (gint)rtmpt_max_packet_size) { return; } } if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) { RTMPT_DEBUG(""New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); if (!ti) { ti = wmem_new(wmem_file_scope(), rtmpt_id_t); ti->packets = wmem_tree_new(wmem_file_scope()); ti->ts  = 0; ti->tsd = 0; wmem_tree_insert32(rconv->ids[cdir], id, ti); } if (header_type == 0) { ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (ts == 0xffffff) { ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11); } tsd = ts - ti->ts; } else if (header_type < 3) { tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (tsd == 0xffffff) { ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4); tsd = ti->tsd;  } else { ts  = ti->ts + tsd; } } else { ts  = ti->ts + ti->tsd; tsd = ti->tsd; } tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t); tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset; tp->have       = 0; tp->want       = basic_hlen + message_hlen + body_len; tp->chunkwant  = 0; tp->chunkhave  = 0; tp->bhlen      = basic_hlen; tp->mhlen      = message_hlen; tp->fmt        = header_type; tp->id         = id; tp->ts         = ts; tp->len        = body_len; if (id > RTMPT_ID_MAX) tp->cmd = id; else tp->cmd = cmd & 0x7f; tp->src        = src; tp->txid       = 0; tp->isresponse = FALSE; tp->otherframe = 0; ti->ts  = ts; ti->tsd = tsd; ti->len = body_len; ti->cmd = cmd; ti->src = src; wmem_tree_insert32(ti->packets, tp->seq, tp); if (!tf && body_len <= chunk_size && tp->want <= remain) { tp->resident    = FALSE; tp->data.offset = offset; tp->lastseq     = seq+offset+tp->want-1; tp->have        = tp->want; wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); offset += tp->want; remain -= tp->want; continue; } else { tp->resident = TRUE; tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len); if (tf && tf->ishdr) { memcpy(tp->data.p, tf->saved.d, tf->len); } else { tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen); offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tp->lastseq = seq+offset-1; tp->have = basic_hlen + message_hlen; if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); continue; } tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; } } else { RTMPT_DEBUG(""Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tf = NULL; unchunk: want = tp->chunkwant - tp->chunkhave; if (want > remain) want = remain; RTMPT_DEBUG(""  cw=%d ch=%d r=%d w=%d\n"", tp->chunkwant, tp->chunkhave, remain, want); tvb_memcpy(tvb, tp->data.p+tp->have, offset, want); if (tf) { tf->have += want; tf->lastseq = seq+offset+want-1; } tp->lastseq = seq+offset+want-1; tp->have += want; tp->chunkhave += want; offset += want; remain -= want; if (tp->chunkhave == tp->chunkwant) { tp->chunkhave = 0; tp->chunkwant = 0; } if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } else if (tp->chunkhave < tp->chunkwant) { rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf2->ishdr    = 0; tf2->seq      = seq + offset - want; tf2->lastseq  = tf2->seq + remain - 1 + want; tf2->have     = tp->chunkhave; tf2->len      = tp->chunkwant; tf2->saved.id = tp->id; RTMPT_DEBUG(""  inserting tf @ %d\n"", seq+offset-want-1); wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2); } } }"
"Status UncompressElement(const CompressedElement& compressed, std::vector<Tensor>* out) { int num_components = compressed.component_metadata_size(); out->clear(); out->reserve(num_components); std::vector<struct iovec> iov(num_components); std::vector<tstring> tensor_proto_strs; tensor_proto_strs.reserve(num_components); int64 total_size = 0; for (int i = 0; i < num_components; ++i) { const CompressedComponentMetadata& metadata = compressed.component_metadata(i); if (DataTypeCanUseMemcpy(metadata.dtype())) { out->emplace_back(metadata.dtype(), metadata.tensor_shape()); TensorBuffer* buffer = DMAHelper::buffer(&out->back()); iov[i].iov_base = buffer->data(); iov[i].iov_len = buffer->size(); } else { out->emplace_back(); tensor_proto_strs.emplace_back(); tstring& tensor_proto_str = tensor_proto_strs.back(); tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes()); iov[i].iov_base = tensor_proto_str.mdata(); iov[i].iov_len = tensor_proto_str.size(); } total_size += iov[i].iov_len; } const std::string& compressed_data = compressed.data(); size_t uncompressed_size; if (!port::Snappy_GetUncompressedLength( compressed_data.data(), compressed_data.size(), &uncompressed_size)) { return errors::Internal( ""Could not get snappy uncompressed length. Compressed data size: "", compressed_data.size()); } if (uncompressed_size != static_cast<size_t>(total_size)) { return errors::Internal( ""Uncompressed size mismatch. Snappy expects "", uncompressed_size, "" whereas the tensor metadata suggests "", total_size); } if (!port::Snappy_UncompressToIOVec(compressed_data.data(), compressed_data.size(), iov.data(), num_components)) { return errors::Internal(""Failed to perform snappy decompression.""); } int tensor_proto_strs_index = 0; for (int i = 0; i < num_components; ++i) { if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) { continue; } TensorProto tp; if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) { return errors::Internal(""Could not parse TensorProto""); } if (!out->at(i).FromProto(tp)) { return errors::Internal(""Could not parse Tensor""); } } return Status::OK(); }"
static void free_clt(struct rtrs_clt_sess *clt) { free_permits(clt); free_percpu(clt->pcpu_path); mutex_destroy(&clt->paths_ev_mutex); mutex_destroy(&clt->paths_mutex); device_unregister(&clt->dev); }
"void GPClient::onSettingsButtonClicked() { settingsDialog->setExtraArgs(settings::get(""extraArgs"", """").toString()); settingsDialog->setClientos(settings::get(""clientos"", ""Linux"").toString()); settingsDialog->show(); }"
void CUser::SetClientEncoding(const CString& s) { m_sClientEncoding = s; for (CClient* pClient : GetAllClients()) { pClient->SetEncoding(s); } }
"unsigned long hypercall_create_continuation( unsigned int op, const char *format, ...) { struct vcpu *curr = current; struct mc_state *mcs = &curr->mc_state; const char *p = format; unsigned long arg; unsigned int i; va_list args; curr->hcall_preempted = true; va_start(args, format); if ( mcs->flags & MCSF_in_multicall ) { for ( i = 0; *p != '\0'; i++ ) mcs->call.args[i] = next_arg(p, args); } else { struct cpu_user_regs *regs = guest_cpu_user_regs(); regs->rax = op; if ( !curr->hcall_compat ) { for ( i = 0; *p != '\0'; i++ ) { arg = next_arg(p, args); switch ( i ) { case 0: regs->rdi = arg; break; case 1: regs->rsi = arg; break; case 2: regs->rdx = arg; break; case 3: regs->r10 = arg; break; case 4: regs->r8  = arg; break; case 5: regs->r9  = arg; break; } } } else { for ( i = 0; *p != '\0'; i++ ) { arg = next_arg(p, args); switch ( i ) { case 0: regs->rbx = arg; break; case 1: regs->rcx = arg; break; case 2: regs->rdx = arg; break; case 3: regs->rsi = arg; break; case 4: regs->rdi = arg; break; case 5: regs->rbp = arg; break; } } } } va_end(args); return op; }"
"static int snd_ctl_elem_read(struct snd_card *card, struct snd_ctl_elem_value *control) { struct snd_kcontrol *kctl; struct snd_kcontrol_volatile *vd; unsigned int index_offset; int result; down_read(&card->controls_rwsem); kctl = snd_ctl_find_id(card, &control->id); if (kctl == NULL) { result = -ENOENT; } else { index_offset = snd_ctl_get_ioff(kctl, &control->id); vd = &kctl->vd[index_offset]; if ((vd->access & SNDRV_CTL_ELEM_ACCESS_READ) && kctl->get != NULL) { snd_ctl_build_ioff(&control->id, kctl, index_offset); result = kctl->get(kctl, control); } else result = -EPERM; } up_read(&card->controls_rwsem); return result; }"
"static int forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s, UChar* range, UChar** low, UChar** high, UChar** low_prev) { UChar *p, *pprev = (UChar* )NULL; #ifdef ONIG_DEBUG_SEARCH fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"", (int )str, (int )end, (int )s, (int )range); #endif p = s; if (reg->dmin > 0) { if (ONIGENC_IS_SINGLEBYTE(reg->enc)) { p += reg->dmin; } else { UChar *q = p + reg->dmin; while (p < q) p += enclen(reg->enc, p); } } retry: switch (reg->optimize) { case ONIG_OPTIMIZE_EXACT: p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_IC: p = slow_search_ic(reg->enc, reg->case_fold_flag, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_BM: p = bm_search(reg, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV: p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_MAP: p = map_search(reg->enc, reg->map, p, range); break; } if (p && p < range) { if (p - reg->dmin < s) { retry_gate: pprev = p; p += enclen(reg->enc, p); goto retry; } if (reg->sub_anchor) { UChar* prev; switch (reg->sub_anchor) { case ANCHOR_BEGIN_LINE: if (!ON_STR_BEGIN(p)) { prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) goto retry_gate; } break; case ANCHOR_END_LINE: if (ON_STR_END(p)) { #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = (UChar* )onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) goto retry_gate; #endif } else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end) #ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end) #endif ) goto retry_gate; break; } } if (reg->dmax == 0) { *low = p; if (low_prev) { if (*low > s) *low_prev = onigenc_get_prev_char_head(reg->enc, s, p); else *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); } } else { if (reg->dmax != ONIG_INFINITE_DISTANCE) { *low = p - reg->dmax; if (*low > s) { *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s, *low, (const UChar** )low_prev); if (low_prev && IS_NULL(*low_prev)) *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : s), *low); } else { if (low_prev) *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), *low); } } } *high = p - reg->dmin; #ifdef ONIG_DEBUG_SEARCH fprintf(stderr, ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"", (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax); #endif return 1;  } return 0;  }"
"GF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec) { GF_BitStream *bs; GF_Err e; CommandBufferItem *cbi; u32 NbPass = gf_list_count(codec->command_buffers); GF_List *nextPass = gf_list_new(); while (NbPass) { while (gf_list_count(codec->command_buffers)) { cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0); gf_list_rem(codec->command_buffers, 0); codec->current_graph = gf_node_get_graph(cbi->node); e = GF_OK; if (cbi->cb->bufferSize) { bs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ); gf_bs_set_eos_callback(bs, BM_EndOfStream, codec); e = BM_ParseCommand(codec, bs, cbi->cb->commandList); gf_bs_del(bs); } if (!e) { gf_free(cbi); continue; } while (gf_list_count(cbi->cb->commandList)) { u32 i; GF_CommandField *cf; GF_Command *com = (GF_Command *)gf_list_get(cbi->cb->commandList, 0); gf_list_rem(cbi->cb->commandList, 0); cf = (GF_CommandField *) gf_list_get(com->command_fields, 0); if (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) { for (i=0; i<gf_list_count(codec->command_buffers); i++) { CommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i); if (cbi2->cb == cf->field_ptr) { gf_free(cbi2); gf_list_rem(codec->command_buffers, i); i--; } } } gf_sg_command_del(com); } gf_list_add(nextPass, cbi); } if (!gf_list_count(nextPass)) break; while (gf_list_count(nextPass)) { cbi = (CommandBufferItem *)gf_list_get(nextPass, 0); gf_list_rem(nextPass, 0); gf_list_add(codec->command_buffers, cbi); } NbPass --; if (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers); codec->LastError = GF_OK; } gf_list_del(nextPass); return GF_OK; }"
"int blk_init_allocated_queue(struct request_queue *q) { WARN_ON_ONCE(q->mq_ops); q->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size); if (!q->fq) return -ENOMEM; if (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL)) goto out_free_flush_queue; if (blk_init_rl(&q->root_rl, q, GFP_KERNEL)) goto out_exit_flush_rq; INIT_WORK(&q->timeout_work, blk_timeout_work); q->queue_flags|= QUEUE_FLAG_DEFAULT; blk_queue_make_request(q, blk_queue_bio); q->sg_reserved_size = INT_MAX; if (elevator_init(q)) goto out_exit_flush_rq; return 0; out_exit_flush_rq: if (q->exit_rq_fn) q->exit_rq_fn(q, q->fq->flush_rq); out_free_flush_queue: blk_free_flush_queue(q->fq); return -ENOMEM; }"
"static int sampled_data_continue(i_ctx_t *i_ctx_p) { os_ptr op = osp; gs_sampled_data_enum *penum = senum; gs_function_Sd_params_t * params = (gs_function_Sd_params_t *)&penum->pfn->params; int i, j, num_out = params->n; int code = 0; byte * data_ptr; double sampled_data_value_max = (double)((1 << params->BitsPerSample) - 1); int bps = bits2bytes(params->BitsPerSample), stack_depth_adjust = 0; if (num_out + O_STACK_PAD + penum->o_stack_depth != ref_stack_count(&o_stack)) { stack_depth_adjust = ref_stack_count(&o_stack) - penum->o_stack_depth; if (stack_depth_adjust < 0) { push(-stack_depth_adjust); ifree_object(penum->pfn, ""sampled_data_continue(pfn)""); ifree_object(penum, ""sampled_data_continue((enum)""); return_error(gs_error_undefinedresult); } } data_ptr = cube_ptr_from_index(params, penum->indexes); for (i=0; i < num_out; i++) { ulong cv; double value; double rmin = params->Range[2 * i]; double rmax = params->Range[2 * i + 1]; code = real_param(op + i - num_out + 1, &value); if (code < 0) { esp -= estack_storage; return code; } if (value < rmin) value = rmin; else if (value > rmax) value = rmax; value = (value - rmin) / (rmax - rmin); cv = (int) (value * sampled_data_value_max + 0.5); for (j = 0; j < bps; j++) data_ptr[bps * i + j] = (byte)(cv >> ((bps - 1 - j) * 8)); } pop(num_out);     if (increment_cube_indexes(params, penum->indexes)) { if (stack_depth_adjust == 0) pop(O_STACK_PAD);     else pop(stack_depth_adjust - num_out); code = 0; if (esp_finish_proc != 0) code = esp_finish_proc(i_ctx_p); return code; } else { if (stack_depth_adjust) { stack_depth_adjust -= num_out; push(O_STACK_PAD - stack_depth_adjust); for (i=0;i<O_STACK_PAD - stack_depth_adjust;i++) make_null(op - i); } } return sampled_data_sample(i_ctx_p); }"
"void WebstoreStandaloneInstaller::OnWebstoreRequestFailure() { OnWebStoreDataFetcherDone(); CompleteInstall(webstore_install::WEBSTORE_REQUEST_ERROR, kWebstoreRequestError); }"
int re_yyget_column  (yyscan_t yyscanner) { struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; if (! YY_CURRENT_BUFFER) return 0; return yycolumn; }
"void WasmBinaryBuilder::visitRethrow(Rethrow* curr) { BYN_TRACE(""zz node: Rethrow\n""); curr->target = getExceptionTargetName(getU32LEB()); assert(curr->target != DELEGATE_CALLER_TARGET); curr->finalize(); }"
"void SEIUnit::deserialize(SPSUnit& sps, int orig_hrd_parameters_present_flag) { pic_struct = -1; uint8_t* nalEnd = m_nalBuffer + m_nalBufferLen; try { int rez = NALUnit::deserialize(m_nalBuffer, nalEnd); if (rez != 0) return; uint8_t* curBuff = m_nalBuffer + 1; while (curBuff < nalEnd - 1) { int payloadType = 0; for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadType += 0xFF; if (curBuff >= nalEnd) return; payloadType += *curBuff++; if (curBuff >= nalEnd) return; int payloadSize = 0; for (; *curBuff == 0xFF && curBuff < nalEnd; curBuff++) payloadSize += 0xFF; if (curBuff >= nalEnd) return; payloadSize += *curBuff++; if (curBuff >= nalEnd) return; sei_payload(sps, payloadType, curBuff, payloadSize, orig_hrd_parameters_present_flag); m_processedMessages.insert(payloadType); curBuff += payloadSize; } } catch (BitStreamException) { LTRACE(LT_WARN, 2, ""Bad SEI detected. SEI too short""); } return; }"
"static gboolean gvs_tuple_is_normal (GVariantSerialised value) { guint offset_size; gsize offset_ptr; gsize length; gsize offset; gsize i; if G_UNLIKELY (value.data == NULL && value.size != 0) return FALSE; offset_size = gvs_get_offset_size (value.size); length = g_variant_type_info_n_members (value.type_info); offset_ptr = value.size; offset = 0; for (i = 0; i < length; i++) { const GVariantMemberInfo *member_info; GVariantSerialised child; gsize fixed_size; guint alignment; gsize end; member_info = g_variant_type_info_member_info (value.type_info, i); child.type_info = member_info->type_info; child.depth = value.depth + 1; g_variant_type_info_query (child.type_info, &alignment, &fixed_size); while (offset & alignment) { if (offset > value.size || value.data[offset] != '\0') return FALSE; offset++; } child.data = value.data + offset; switch (member_info->ending_type) { case G_VARIANT_MEMBER_ENDING_FIXED: end = offset + fixed_size; break; case G_VARIANT_MEMBER_ENDING_LAST: end = offset_ptr; break; case G_VARIANT_MEMBER_ENDING_OFFSET: if (offset_ptr < offset_size) return FALSE; offset_ptr -= offset_size; if (offset_ptr < offset) return FALSE; end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size); break; default: g_assert_not_reached (); } if (end < offset || end > offset_ptr) return FALSE; child.size = end - offset; if (child.size == 0) child.data = NULL; if (!g_variant_serialised_is_normal (child)) return FALSE; offset = end; } { gsize fixed_size; guint alignment; g_variant_type_info_query (value.type_info, &alignment, &fixed_size); if (fixed_size) { g_assert (fixed_size == value.size); g_assert (offset_ptr == value.size); if (i == 0) { if (value.data[offset++] != '\0') return FALSE; } else { while (offset & alignment) if (value.data[offset++] != '\0') return FALSE; } g_assert (offset == value.size); } } return offset_ptr == offset; }"
"static void enip_open_cip_connection( packet_info *pinfo, cip_conn_info_t* connInfo) { enip_conn_key_t  *conn_key; enip_conn_val_t  *conn_val; conversation_t   *conversation, *conversationTO; enip_conv_info_t *enip_info; address           dest_address; struct e_in6_addr ipv6_zero; if (pinfo->fd->flags.visited) return; conn_key = wmem_new(wmem_file_scope(), enip_conn_key_t); conn_key->ConnSerialNumber = connInfo->ConnSerialNumber; conn_key->VendorID = connInfo->VendorID; conn_key->DeviceSerialNumber = connInfo->DeviceSerialNumber; conn_key->O2TConnID = connInfo->O2T.connID; conn_key->T2OConnID = connInfo->T2O.connID; conn_val = (enip_conn_val_t *)wmem_map_lookup( enip_conn_hashtable, conn_key ); if ( conn_val == NULL ) { conn_val = wmem_new(wmem_file_scope(), enip_conn_val_t); conn_val->ConnSerialNumber       = connInfo->ConnSerialNumber; conn_val->VendorID               = connInfo->VendorID; conn_val->DeviceSerialNumber     = connInfo->DeviceSerialNumber; conn_val->O2TConnID              = connInfo->O2T.connID; conn_val->T2OConnID              = connInfo->T2O.connID; conn_val->TransportClass_trigger = connInfo->TransportClass_trigger; conn_val->safety                 = connInfo->safety; conn_val->motion                 = connInfo->motion; conn_val->ClassID                = connInfo->ClassID; conn_val->open_frame             = connInfo->forward_open_frame; conn_val->open_reply_frame       = pinfo->num; conn_val->close_frame            = 0; conn_val->connid                 = enip_unique_connid++; wmem_map_insert(enip_conn_hashtable, conn_key, conn_val ); if (((connInfo->TransportClass_trigger & CI_TRANSPORT_CLASS_MASK) == 0) || ((connInfo->TransportClass_trigger & CI_TRANSPORT_CLASS_MASK) == 1)) { memset(&ipv6_zero, 0, sizeof(ipv6_zero)); if ((connInfo->O2T.port == 0) || (connInfo->O2T.type == CONN_TYPE_MULTICAST)) connInfo->O2T.port = ENIP_IO_PORT; if ((connInfo->O2T.ipaddress.type == AT_NONE) || ((connInfo->O2T.ipaddress.type == AT_IPv4) && ((*(const guint32*)connInfo->O2T.ipaddress.data)) == 0) || ((connInfo->O2T.ipaddress.type == AT_IPv6) && (memcmp(connInfo->O2T.ipaddress.data, &ipv6_zero, sizeof(ipv6_zero)) == 0)) || (connInfo->O2T.type != CONN_TYPE_MULTICAST)) copy_address_shallow(&connInfo->O2T.ipaddress, &pinfo->src); if ((connInfo->T2O.port == 0) || (connInfo->T2O.type == CONN_TYPE_MULTICAST)) connInfo->T2O.port = ENIP_IO_PORT; if ((connInfo->T2O.ipaddress.type == AT_NONE) || ((connInfo->T2O.ipaddress.type == AT_IPv4) && ((*(const guint32*)connInfo->T2O.ipaddress.data)) == 0) || ((connInfo->T2O.ipaddress.type == AT_IPv6) && (memcmp(connInfo->T2O.ipaddress.data, &ipv6_zero, sizeof(ipv6_zero)) == 0)) || (connInfo->T2O.type != CONN_TYPE_MULTICAST)) copy_address_shallow(&connInfo->T2O.ipaddress, &pinfo->dst); if (connInfo->O2T.ipaddress.type == AT_IPv6) { dest_address.type = AT_IPv6; dest_address.len  = 16; } else { dest_address.type = AT_IPv4; dest_address.len  = 4; } dest_address.data = connInfo->O2T.ipaddress.data; if ((conversation = find_conversation(pinfo->num, &pinfo->dst, &dest_address, PT_UDP, connInfo->O2T.port, 0, NO_PORT_B)) == NULL) { conversation = conversation_new(pinfo->num, &pinfo->dst, &dest_address, PT_UDP, connInfo->O2T.port, 0, NO_PORT2); } enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversation, proto_enip); if (enip_info == NULL) { enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t); enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope()); enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope()); conversation_add_proto_data(conversation, proto_enip, enip_info); } wmem_tree_insert32(enip_info->O2TConnIDs, connInfo->O2T.connID, (void *)conn_val); dest_address.data = connInfo->T2O.ipaddress.data; if ((conversationTO = find_conversation(pinfo->num, &pinfo->src, &dest_address, PT_UDP, connInfo->T2O.port, 0, NO_PORT_B)) == NULL) { conversationTO = conversation_new(pinfo->num, &pinfo->src, &dest_address, PT_UDP, connInfo->T2O.port, 0, NO_PORT2); } enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversationTO, proto_enip); if (enip_info == NULL) { enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t); enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope()); enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope()); conversation_add_proto_data(conversationTO, proto_enip, enip_info); } wmem_tree_insert32(enip_info->T2OConnIDs, connInfo->T2O.connID, (void *)conn_val); } else { conversation = find_or_create_conversation(pinfo); enip_info = (enip_conv_info_t *)conversation_get_proto_data(conversation, proto_enip); if (!enip_info) { enip_info = wmem_new(wmem_file_scope(), enip_conv_info_t); enip_info->O2TConnIDs = wmem_tree_new(wmem_file_scope()); enip_info->T2OConnIDs = wmem_tree_new(wmem_file_scope()); conversation_add_proto_data(conversation, proto_enip, enip_info); } wmem_tree_insert32(enip_info->O2TConnIDs, connInfo->O2T.connID, (void *)conn_val); wmem_tree_insert32(enip_info->T2OConnIDs, connInfo->T2O.connID, (void *)conn_val); } } if (!pinfo->fd->flags.visited) p_add_proto_data(wmem_file_scope(), pinfo, proto_enip, ENIP_CONNECTION_INFO, conn_val); }"
"tChecksumCheckResult ParaNdis_CheckRxChecksum( PARANDIS_ADAPTER *pContext, ULONG virtioFlags, tCompletePhysicalAddress *pPacketPages, ULONG ulPacketLength, ULONG ulDataOffset) { tOffloadSettingsFlags f = pContext->Offload.flags; tChecksumCheckResult res, resIp; tTcpIpPacketParsingResult ppr; ULONG flagsToCalculate = 0; res.value = 0; resIp.value = 0; if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)) { if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM) { flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum; } else { if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum; if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum; if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum; if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum; } } ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__); if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID) { pContext->extraStatistics.framesRxCSHwOK++; ppr.xxpCheckSum = ppresCSOK; } if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment) { if (f.fRxIPChecksum) { res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK; res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad; } if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP)  { if (f.fRxTCPChecksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else  { if (f.fRxUDPChecksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } else if (ppr.ipStatus == ppresIPV6) { if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP)  { if (f.fRxTCPv6Checksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else  { if (f.fRxUDPv6Checksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } return res; }"
"static krb5_error_code get_tag(const uint8_t *asn1, size_t len, taginfo *tag_out, const uint8_t **contents_out, size_t *clen_out, const uint8_t **remainder_out, size_t *rlen_out) { krb5_error_code ret; uint8_t o; const uint8_t *c, *p, *tag_start = asn1; size_t clen, llen, i; taginfo t; *contents_out = *remainder_out = NULL; *clen_out = *rlen_out = 0; if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; tag_out->asn1class = o & 0xC0; tag_out->construction = o & 0x20; if ((o & 0x1F) != 0x1F) { tag_out->tagnum = o & 0x1F; } else { tag_out->tagnum = 0; do { if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; tag_out->tagnum = (tag_out->tagnum << 7) | (o & 0x7F); } while (o & 0x80); } if (len == 0) return ASN1_OVERRUN; o = *asn1++; len--; if (o == 0x80) { if (tag_out->construction != CONSTRUCTED) return ASN1_MISMATCH_INDEF; p = asn1; while (!(len >= 2 && p[0] == 0 && p[1] == 0)) { ret = get_tag(p, len, &t, &c, &clen, &p, &len); if (ret) return ret; } tag_out->tag_end_len = 2; *contents_out = asn1; *clen_out = p - asn1; *remainder_out = p + 2; *rlen_out = len - 2; } else if ((o & 0x80) == 0) { if (o > len) return ASN1_OVERRUN; tag_out->tag_end_len = 0; *contents_out = asn1; *clen_out = o; *remainder_out = asn1 + *clen_out; *rlen_out = len - (*remainder_out - asn1); } else { llen = o & 0x7F; if (llen > len) return ASN1_OVERRUN; if (llen > sizeof(*clen_out)) return ASN1_OVERFLOW; for (i = 0, clen = 0; i < llen; i++) clen = (clen << 8) | asn1[i]; if (clen > len - llen) return ASN1_OVERRUN; tag_out->tag_end_len = 0; *contents_out = asn1 + llen; *clen_out = clen; *remainder_out = *contents_out + clen; *rlen_out = len - (*remainder_out - asn1); } tag_out->tag_len = *contents_out - tag_start; return 0; }"
static int uv__rwlock_fallback_tryrdlock(uv_rwlock_t* rwlock) { int err; err = uv_mutex_trylock(&rwlock->fallback_.read_mutex_); if (err) goto out; err = 0; if (rwlock->fallback_.num_readers_ == 0) err = uv_mutex_trylock(&rwlock->fallback_.write_mutex_); if (err == 0) rwlock->fallback_.num_readers_++; uv_mutex_unlock(&rwlock->fallback_.read_mutex_); out: return err; }
"static const xmlChar * xmlParseStartTag2(xmlParserCtxtPtr ctxt, const xmlChar **pref, const xmlChar **URI, int *tlen) { const xmlChar *localname; const xmlChar *prefix; const xmlChar *attname; const xmlChar *aprefix; const xmlChar *nsname; xmlChar *attvalue; const xmlChar **atts = ctxt->atts; int maxatts = ctxt->maxatts; int nratts, nbatts, nbdef; int i, j, nbNs, attval, oldline, oldcol, inputNr; const xmlChar *base; unsigned long cur; int nsNr = ctxt->nsNr; if (RAW != '<') return(NULL); NEXT1; reparse: SHRINK; base = ctxt->input->base; cur = ctxt->input->cur - ctxt->input->base; inputNr = ctxt->inputNr; oldline = ctxt->input->line; oldcol = ctxt->input->col; nbatts = 0; nratts = 0; nbdef = 0; nbNs = 0; attval = 0; ctxt->nsNr = nsNr; localname = xmlParseQName(ctxt, &prefix); if (localname == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, ""StartTag: invalid element name\n""); return(NULL); } *tlen = ctxt->input->cur - ctxt->input->base - cur; SKIP_BLANKS; GROW; if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) goto base_changed; while (((RAW != '>') && ((RAW != '/') || (NXT(1) != '>')) && (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) { const xmlChar *q = CUR_PTR; unsigned int cons = ctxt->input->consumed; int len = -1, alloc = 0; attname = xmlParseAttribute2(ctxt, prefix, localname, &aprefix, &attvalue, &len, &alloc); if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) { if ((attvalue != NULL) && (alloc != 0)) xmlFree(attvalue); attvalue = NULL; goto base_changed; } if ((attname != NULL) && (attvalue != NULL)) { if (len < 0) len = xmlStrlen(attvalue); if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); xmlURIPtr uri; if (URL == NULL) { xmlErrMemory(ctxt, ""dictionary allocation failure""); if ((attvalue != NULL) && (alloc != 0)) xmlFree(attvalue); return(NULL); } if (*URL != 0) { uri = xmlParseURI((const char *) URL); if (uri == NULL) { xmlNsErr(ctxt, XML_WAR_NS_URI, ""xmlns: '%s' is not a valid URI\n"", URL, NULL, NULL); } else { if (uri->scheme == NULL) { xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, ""xmlns: URI %s is not absolute\n"", URL, NULL, NULL); } xmlFreeURI(uri); } if (URL == ctxt->str_xml_ns) { if (attname != ctxt->str_xml) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""xml namespace URI cannot be the default namespace\n"", NULL, NULL, NULL); } goto skip_default_ns; } if ((len == 29) && (xmlStrEqual(URL, BAD_CAST ""http:xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""reuse of the xmlns namespace name is forbidden\n"", NULL, NULL, NULL); goto skip_default_ns; } } for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) break; if (j <= nbNs) xmlErrAttributeDup(ctxt, NULL, attname); else if (nsPush(ctxt, NULL, URL) > 0) nbNs++; skip_default_ns: if (alloc != 0) xmlFree(attvalue); if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) break; if (!IS_BLANK_CH(RAW)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, ""attributes construct error\n""); break; } SKIP_BLANKS; continue; } if (aprefix == ctxt->str_xmlns) { const xmlChar *URL = xmlDictLookup(ctxt->dict, attvalue, len); xmlURIPtr uri; if (attname == ctxt->str_xml) { if (URL != ctxt->str_xml_ns) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""xml namespace prefix mapped to wrong URI\n"", NULL, NULL, NULL); } goto skip_ns; } if (URL == ctxt->str_xml_ns) { if (attname != ctxt->str_xml) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""xml namespace URI mapped to wrong prefix\n"", NULL, NULL, NULL); } goto skip_ns; } if (attname == ctxt->str_xmlns) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""redefinition of the xmlns prefix is forbidden\n"", NULL, NULL, NULL); goto skip_ns; } if ((len == 29) && (xmlStrEqual(URL, BAD_CAST ""http:    xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""reuse of the xmlns namespace name is forbidden\n"", NULL, NULL, NULL); goto skip_ns; } if ((URL == NULL) || (URL[0] == 0)) { xmlNsErr(ctxt, XML_NS_ERR_XML_NAMESPACE, ""xmlns:%s: Empty XML namespace is not allowed\n"", attname, NULL, NULL); goto skip_ns; } else { uri = xmlParseURI((const char *) URL); if (uri == NULL) { xmlNsErr(ctxt, XML_WAR_NS_URI, ""xmlns:%s: '%s' is not a valid URI\n"", attname, URL, NULL); } else { if ((ctxt->pedantic) && (uri->scheme == NULL)) { xmlNsWarn(ctxt, XML_WAR_NS_URI_RELATIVE, ""xmlns:%s: URI %s is not absolute\n"", attname, URL, NULL); } xmlFreeURI(uri); } } for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) break; if (j <= nbNs) xmlErrAttributeDup(ctxt, aprefix, attname); else if (nsPush(ctxt, attname, URL) > 0) nbNs++; skip_ns: if (alloc != 0) xmlFree(attvalue); if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) break; if (!IS_BLANK_CH(RAW)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, ""attributes construct error\n""); break; } SKIP_BLANKS; if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) goto base_changed; continue; } if ((atts == NULL) || (nbatts + 5 > maxatts)) { if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { if (attvalue[len] == 0) xmlFree(attvalue); goto failed; } maxatts = ctxt->maxatts; atts = ctxt->atts; } ctxt->attallocs[nratts++] = alloc; atts[nbatts++] = attname; atts[nbatts++] = aprefix; atts[nbatts++] = NULL;  atts[nbatts++] = attvalue; attvalue += len; atts[nbatts++] = attvalue; if (alloc != 0) attval = 1; } else { if ((attvalue != NULL) && (attvalue[len] == 0)) xmlFree(attvalue); } failed: GROW if (ctxt->instate == XML_PARSER_EOF) break; if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) goto base_changed; if ((RAW == '>') || (((RAW == '/') && (NXT(1) == '>')))) break; if (!IS_BLANK_CH(RAW)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, ""attributes construct error\n""); break; } SKIP_BLANKS; if ((cons == ctxt->input->consumed) && (q == CUR_PTR) && (attname == NULL) && (attvalue == NULL)) { xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""xmlParseStartTag: problem parsing attributes\n""); break; } GROW; if ((ctxt->input->base != base) || (inputNr != ctxt->inputNr)) goto base_changed; } if (ctxt->attsDefault != NULL) { xmlDefAttrsPtr defaults; defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix); if (defaults != NULL) { for (i = 0;i < defaults->nbAttrs;i++) { attname = defaults->values[5 * i]; aprefix = defaults->values[5 * i + 1]; if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) { for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL) break; if (j <= nbNs) continue; nsname = xmlGetNamespace(ctxt, NULL); if (nsname != defaults->values[5 * i + 2]) { if (nsPush(ctxt, NULL, defaults->values[5 * i + 2]) > 0) nbNs++; } } else if (aprefix == ctxt->str_xmlns) { for (j = 1;j <= nbNs;j++) if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname) break; if (j <= nbNs) continue; nsname = xmlGetNamespace(ctxt, attname); if (nsname != defaults->values[2]) { if (nsPush(ctxt, attname, defaults->values[5 * i + 2]) > 0) nbNs++; } } else { for (j = 0;j < nbatts;j+=5) { if ((attname == atts[j]) && (aprefix == atts[j+1])) break; } if (j < nbatts) continue; if ((atts == NULL) || (nbatts + 5 > maxatts)) { if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) { return(NULL); } maxatts = ctxt->maxatts; atts = ctxt->atts; } atts[nbatts++] = attname; atts[nbatts++] = aprefix; if (aprefix == NULL) atts[nbatts++] = NULL; else atts[nbatts++] = xmlGetNamespace(ctxt, aprefix); atts[nbatts++] = defaults->values[5 * i + 2]; atts[nbatts++] = defaults->values[5 * i + 3]; if ((ctxt->standalone == 1) && (defaults->values[5 * i + 4] != NULL)) { xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED, ""standalone: attribute %s on %s defaulted from external subset\n"", attname, localname); } nbdef++; } } } } for (i = 0; i < nbatts;i += 5) { if (atts[i + 1] != NULL) { nsname = xmlGetNamespace(ctxt, atts[i + 1]); if (nsname == NULL) { xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, ""Namespace prefix %s for %s on %s is not defined\n"", atts[i + 1], atts[i], localname); } atts[i + 2] = nsname; } else nsname = NULL; for (j = 0; j < i;j += 5) { if (atts[i] == atts[j]) { if (atts[i+1] == atts[j+1]) { xmlErrAttributeDup(ctxt, atts[i+1], atts[i]); break; } if ((nsname != NULL) && (atts[j + 2] == nsname)) { xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED, ""Namespaced Attribute %s in '%s' redefined\n"", atts[i], nsname, NULL); break; } } } } nsname = xmlGetNamespace(ctxt, prefix); if ((prefix != NULL) && (nsname == NULL)) { xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE, ""Namespace prefix %s on %s is not defined\n"", prefix, localname, NULL); } *pref = prefix; *URI = nsname; if ((ctxt->sax != NULL) && (ctxt->sax->startElementNs != NULL) && (!ctxt->disableSAX)) { if (nbNs > 0) ctxt->sax->startElementNs(ctxt->userData, localname, prefix, nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs], nbatts / 5, nbdef, atts); else ctxt->sax->startElementNs(ctxt->userData, localname, prefix, nsname, 0, NULL, nbatts / 5, nbdef, atts); } if (attval != 0) { for (i = 3,j = 0; j < nratts;i += 5,j++) if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) xmlFree((xmlChar *) atts[i]); } return(localname); base_changed: if (attval != 0) { for (i = 3,j = 0; j < nratts;i += 5,j++) if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL)) xmlFree((xmlChar *) atts[i]); } if (inputNr != ctxt->inputNr) { xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, ""Start tag doesn't start and stop in the same entity\n""); return(NULL); } ctxt->input->cur = ctxt->input->base + cur; ctxt->input->line = oldline; ctxt->input->col = oldcol; if (ctxt->wellFormed == 1) { goto reparse; } return(NULL); }"
"static gboolean pcapng_read_simple_packet_block(FILE_T fh, pcapng_block_header_t *bh, pcapng_t *pn, wtapng_block_t *wblock, int *err, gchar **err_info) { interface_info_t iface_info; pcapng_simple_packet_block_t spb; wtapng_simple_packet_t simple_packet; guint32 block_total_length; guint32 padding; int pseudo_header_len; if (bh->block_total_length < MIN_SPB_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""pcapng_read_simple_packet_block: total block length %u of an SPB is less than the minimum SPB size %u"", bh->block_total_length, MIN_SPB_SIZE); return FALSE; } if (bh->block_total_length > MAX_BLOCK_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""pcapng_read_simple_packet_block: total block length %u is too large (> %u)"", bh->block_total_length, MAX_BLOCK_SIZE); return FALSE; } if (!wtap_read_bytes(fh, &spb, sizeof spb, err, err_info)) { pcapng_debug(""pcapng_read_simple_packet_block: failed to read packet data""); return FALSE; } if (0 >= pn->interfaces->len) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup(""pcapng_read_simple_packet_block: SPB appeared before any IDBs""); return FALSE; } iface_info = g_array_index(pn->interfaces, interface_info_t, 0); if (pn->byte_swapped) { simple_packet.packet_len   = GUINT32_SWAP_LE_BE(spb.packet_len); } else { simple_packet.packet_len   = spb.packet_len; } simple_packet.cap_len = simple_packet.packet_len; if (simple_packet.cap_len > iface_info.snap_len && iface_info.snap_len != 0) simple_packet.cap_len = iface_info.snap_len; if ((simple_packet.cap_len % 4) != 0) padding = 4 - (simple_packet.cap_len % 4); else padding = 0; if (bh->block_total_length % 4) { block_total_length = bh->block_total_length + 4 - (bh->block_total_length % 4); } else { block_total_length = bh->block_total_length; } pcapng_debug(""pcapng_read_simple_packet_block: block_total_length %d"", block_total_length); if (block_total_length < MIN_SPB_SIZE + simple_packet.cap_len + padding) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""pcapng_read_simple_packet_block: total block length %u of PB is too small for %u bytes of packet data"", block_total_length, simple_packet.packet_len); return FALSE; } if (simple_packet.cap_len > WTAP_MAX_PACKET_SIZE) { *err = WTAP_ERR_BAD_FILE; *err_info = g_strdup_printf(""pcapng_read_simple_packet_block: cap_len %u is larger than WTAP_MAX_PACKET_SIZE %u"", simple_packet.cap_len, WTAP_MAX_PACKET_SIZE); return FALSE; } pcapng_debug(""pcapng_read_simple_packet_block: packet data: packet_len %u"", simple_packet.packet_len); pcapng_debug(""pcapng_read_simple_packet_block: Need to read pseudo header of size %d"", pcap_get_phdr_size(iface_info.wtap_encap, &wblock->packet_header->pseudo_header)); wblock->packet_header->rec_type = REC_TYPE_PACKET; wblock->packet_header->presence_flags = WTAP_HAS_CAP_LEN|WTAP_HAS_INTERFACE_ID; wblock->packet_header->interface_id = 0; wblock->packet_header->pkt_encap = iface_info.wtap_encap; wblock->packet_header->pkt_tsprec = iface_info.tsprecision; wblock->packet_header->ts.secs = 0; wblock->packet_header->ts.nsecs = 0; wblock->packet_header->interface_id = 0; wblock->packet_header->opt_comment = NULL; wblock->packet_header->drop_count = 0; wblock->packet_header->pack_flags = 0; memset((void *)&wblock->packet_header->pseudo_header, 0, sizeof(union wtap_pseudo_header)); pseudo_header_len = pcap_process_pseudo_header(fh, WTAP_FILE_TYPE_SUBTYPE_PCAPNG, iface_info.wtap_encap, simple_packet.cap_len, TRUE, wblock->packet_header, err, err_info); if (pseudo_header_len < 0) { return FALSE; } wblock->packet_header->caplen = simple_packet.cap_len - pseudo_header_len; wblock->packet_header->len = simple_packet.packet_len - pseudo_header_len; if (pseudo_header_len != pcap_get_phdr_size(iface_info.wtap_encap, &wblock->packet_header->pseudo_header)) { pcapng_debug(""pcapng_read_simple_packet_block: Could only read %d bytes for pseudo header."", pseudo_header_len); } memset((void *)&wblock->packet_header->pseudo_header, 0, sizeof(union wtap_pseudo_header)); if (!wtap_read_packet_bytes(fh, wblock->frame_buffer, simple_packet.cap_len, err, err_info)) return FALSE; if ((simple_packet.cap_len % 4) != 0) { if (!file_skip(fh, 4 - (simple_packet.cap_len % 4), err)) return FALSE; } pcap_read_post_process(WTAP_FILE_TYPE_SUBTYPE_PCAPNG, iface_info.wtap_encap, wblock->packet_header, ws_buffer_start_ptr(wblock->frame_buffer), pn->byte_swapped, pn->if_fcslen); return TRUE; }"
"status_t MPEG4Source::fragmentedRead( MediaBuffer **out, const ReadOptions *options) { ALOGV(""MPEG4Source::fragmentedRead""); CHECK(mStarted); *out = NULL; int64_t targetSampleTimeUs = -1; int64_t seekTimeUs; ReadOptions::SeekMode mode; if (options && options->getSeekTo(&seekTimeUs, &mode)) { int numSidxEntries = mSegments.size(); if (numSidxEntries != 0) { int64_t totalTime = 0; off64_t totalOffset = mFirstMoofOffset; for (int i = 0; i < numSidxEntries; i++) { const SidxEntry *se = &mSegments[i]; if (totalTime + se->mDurationUs > seekTimeUs) { if ((mode == ReadOptions::SEEK_NEXT_SYNC) || (mode == ReadOptions::SEEK_CLOSEST_SYNC && (seekTimeUs - totalTime) > (totalTime + se->mDurationUs - seekTimeUs))) { totalTime += se->mDurationUs; totalOffset += se->mSize; } break; } totalTime += se->mDurationUs; totalOffset += se->mSize; } mCurrentMoofOffset = totalOffset; mCurrentSamples.clear(); mCurrentSampleIndex = 0; parseChunk(&totalOffset); mCurrentTime = totalTime * mTimescale / 1000000ll; } if (mBuffer != NULL) { mBuffer->release(); mBuffer = NULL; } } off64_t offset = 0; size_t size; uint32_t cts = 0; bool isSyncSample = false; bool newBuffer = false; if (mBuffer == NULL) { newBuffer = true; if (mCurrentSampleIndex >= mCurrentSamples.size()) { Sample lastSample = mCurrentSamples[mCurrentSamples.size() - 1]; off64_t nextMoof = mNextMoofOffset;             mCurrentMoofOffset = nextMoof; mCurrentSamples.clear(); mCurrentSampleIndex = 0; parseChunk(&nextMoof); if (mCurrentSampleIndex >= mCurrentSamples.size()) { return ERROR_END_OF_STREAM; } } const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex]; offset = smpl->offset; size = smpl->size; cts = mCurrentTime; mCurrentTime += smpl->duration; isSyncSample = (mCurrentSampleIndex == 0);  status_t err = mGroup->acquire_buffer(&mBuffer); if (err != OK) { CHECK(mBuffer == NULL); ALOGV(""acquire_buffer returned %d"", err); return err; } if (size > mBuffer->size()) { ALOGE(""buffer too small: %zu > %zu"", size, mBuffer->size()); return ERROR_BUFFER_TOO_SMALL; } } const Sample *smpl = &mCurrentSamples[mCurrentSampleIndex]; const sp<MetaData> bufmeta = mBuffer->meta_data(); bufmeta->clear(); if (smpl->encryptedsizes.size()) { bufmeta->setData(kKeyPlainSizes, 0, smpl->clearsizes.array(), smpl->clearsizes.size() * 4); bufmeta->setData(kKeyEncryptedSizes, 0, smpl->encryptedsizes.array(), smpl->encryptedsizes.size() * 4); bufmeta->setData(kKeyCryptoIV, 0, smpl->iv, 16);         bufmeta->setInt32(kKeyCryptoDefaultIVSize, mDefaultIVSize); bufmeta->setInt32(kKeyCryptoMode, mCryptoMode); bufmeta->setData(kKeyCryptoKey, 0, mCryptoKey, 16); } if (!mIsAVC || mWantsNALFragments) { if (newBuffer) { if (!isInRange((size_t)0u, mBuffer->size(), size)) { mBuffer->release(); mBuffer = NULL; ALOGE(""fragmentedRead ERROR_MALFORMED size %zu"", size); return ERROR_MALFORMED; } ssize_t num_bytes_read = mDataSource->readAt(offset, (uint8_t *)mBuffer->data(), size); if (num_bytes_read < (ssize_t)size) { mBuffer->release(); mBuffer = NULL; ALOGE(""i/o error""); return ERROR_IO; } CHECK(mBuffer != NULL); mBuffer->set_range(0, size); mBuffer->meta_data()->setInt64( kKeyTime, ((int64_t)cts * 1000000) / mTimescale); if (targetSampleTimeUs >= 0) { mBuffer->meta_data()->setInt64( kKeyTargetTime, targetSampleTimeUs); } if (isSyncSample) { mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1); } ++mCurrentSampleIndex; } if (!mIsAVC) { *out = mBuffer; mBuffer = NULL; return OK; } CHECK(mBuffer->range_length() >= mNALLengthSize); const uint8_t *src = (const uint8_t *)mBuffer->data() + mBuffer->range_offset(); size_t nal_size = parseNALSize(src); if (mNALLengthSize > SIZE_MAX - nal_size) { ALOGE(""b/24441553, b/24445122""); } if (mBuffer->range_length() - mNALLengthSize < nal_size) { ALOGE(""incomplete NAL unit.""); mBuffer->release(); mBuffer = NULL; return ERROR_MALFORMED; } MediaBuffer *clone = mBuffer->clone(); CHECK(clone != NULL); clone->set_range(mBuffer->range_offset() + mNALLengthSize, nal_size); CHECK(mBuffer != NULL); mBuffer->set_range( mBuffer->range_offset() + mNALLengthSize + nal_size, mBuffer->range_length() - mNALLengthSize - nal_size); if (mBuffer->range_length() == 0) { mBuffer->release(); mBuffer = NULL; } *out = clone; return OK; } else { ALOGV(""whole NAL""); ssize_t num_bytes_read = 0; int32_t drm = 0; bool usesDRM = (mFormat->findInt32(kKeyIsDRM, &drm) && drm != 0); void *data = NULL; bool isMalFormed = false; if (usesDRM) { if (mBuffer == NULL || !isInRange((size_t)0u, mBuffer->size(), size)) { isMalFormed = true; } else { data = mBuffer->data(); } } else { int32_t max_size; if (mFormat == NULL || !mFormat->findInt32(kKeyMaxInputSize, &max_size) || !isInRange((size_t)0u, (size_t)max_size, size)) { isMalFormed = true; } else { data = mSrcBuffer; } } if (isMalFormed || data == NULL) { ALOGE(""isMalFormed size %zu"", size); if (mBuffer != NULL) { mBuffer->release(); mBuffer = NULL; } return ERROR_MALFORMED; } num_bytes_read = mDataSource->readAt(offset, data, size); if (num_bytes_read < (ssize_t)size) { mBuffer->release(); mBuffer = NULL; ALOGE(""i/o error""); return ERROR_IO; } if (usesDRM) { CHECK(mBuffer != NULL); mBuffer->set_range(0, size); } else { uint8_t *dstData = (uint8_t *)mBuffer->data(); size_t srcOffset = 0; size_t dstOffset = 0; while (srcOffset < size) { isMalFormed = !isInRange((size_t)0u, size, srcOffset, mNALLengthSize); size_t nalLength = 0; if (!isMalFormed) { nalLength = parseNALSize(&mSrcBuffer[srcOffset]); srcOffset += mNALLengthSize; isMalFormed = !isInRange((size_t)0u, size, srcOffset, nalLength) || !isInRange((size_t)0u, mBuffer->size(), dstOffset, (size_t)4u) || !isInRange((size_t)0u, mBuffer->size(), dstOffset + 4, nalLength); } if (isMalFormed) { ALOGE(""Video is malformed; nalLength %zu"", nalLength); mBuffer->release(); mBuffer = NULL; return ERROR_MALFORMED; } if (nalLength == 0) { continue; } CHECK(dstOffset + 4 <= mBuffer->size()); dstData[dstOffset++] = 0; dstData[dstOffset++] = 0; dstData[dstOffset++] = 0; dstData[dstOffset++] = 1; memcpy(&dstData[dstOffset], &mSrcBuffer[srcOffset], nalLength); srcOffset += nalLength; dstOffset += nalLength; } CHECK_EQ(srcOffset, size); CHECK(mBuffer != NULL); mBuffer->set_range(0, dstOffset); } mBuffer->meta_data()->setInt64( kKeyTime, ((int64_t)cts * 1000000) / mTimescale); if (targetSampleTimeUs >= 0) { mBuffer->meta_data()->setInt64( kKeyTargetTime, targetSampleTimeUs); } if (isSyncSample) { mBuffer->meta_data()->setInt32(kKeyIsSyncFrame, 1); } ++mCurrentSampleIndex; *out = mBuffer; mBuffer = NULL; return OK; } }"
"static int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) { if (c->redirect_uri == NULL) { oidc_error(r, ""configuration error: the authentication type is set to \""openid-connect\"" but OIDCRedirectURI has not been set""); return HTTP_INTERNAL_SERVER_ERROR; } if (ap_is_initial_req(r)) { int rc = OK; oidc_session_t *session = NULL; oidc_session_load(r, &session); if (oidc_util_request_matches_url(r, c->redirect_uri)) { rc = oidc_handle_redirect_uri_request(r, c, session); oidc_session_free(r, session); return rc; } else if (session->remote_user != NULL) { r->user = (char *) session->remote_user; rc = oidc_handle_existing_session(r, c, session); oidc_session_free(r, session); oidc_strip_cookies(r); return rc; } oidc_session_free(r, session); } else { if (r->main != NULL) r->user = r->main->user; else if (r->prev != NULL) r->user = r->prev->user; if (r->user != NULL) { oidc_debug(r, ""recycling user '%s' from initial request for sub-request"", r->user); const char *s_id_token = oidc_request_state_get(r, OIDC_IDTOKEN_CLAIMS_SESSION_KEY); if (s_id_token == NULL) { oidc_session_t *session = NULL; oidc_session_load(r, &session); oidc_copy_tokens_to_request_state(r, session, NULL, NULL); oidc_session_free(r, session); } oidc_strip_cookies(r); return OK; } } switch (oidc_dir_cfg_unauth_action(r)) { case OIDC_UNAUTH_RETURN410: return HTTP_GONE; case OIDC_UNAUTH_RETURN401: return HTTP_UNAUTHORIZED; case OIDC_UNAUTH_PASS: r->user = """"; return OK; case OIDC_UNAUTH_AUTHENTICATE: if (apr_table_get(r->headers_in, ""X-Requested-With"") != NULL) return HTTP_UNAUTHORIZED; break; } return oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL, NULL, NULL, NULL); }"
"static bool check_underflow(const struct ipt_entry *e) { const struct xt_entry_target *t; unsigned int verdict; if (!unconditional(&e->ip)) return false; t = ipt_get_target_c(e); if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0) return false; verdict = ((struct xt_standard_target *)t)->verdict; verdict = -verdict - 1; return verdict == NF_DROP || verdict == NF_ACCEPT; }"
"FLACParser::FLACParser( const sp<DataSource> &dataSource, const sp<MetaData> &fileMetadata, const sp<MetaData> &trackMetadata) : mDataSource(dataSource), mFileMetadata(fileMetadata), mTrackMetadata(trackMetadata), mInitCheck(false), mMaxBufferSize(0), mGroup(NULL), mCopy(copyTrespass), mDecoder(NULL), mCurrentPos(0LL), mEOF(false), mStreamInfoValid(false), mWriteRequested(false), mWriteCompleted(false), mWriteBuffer(NULL), mErrorStatus((FLAC__StreamDecoderErrorStatus) -1) { ALOGV(""FLACParser::FLACParser""); memset(&mStreamInfo, 0, sizeof(mStreamInfo)); memset(&mWriteHeader, 0, sizeof(mWriteHeader)); mInitCheck = init(); }"
"gboolean flatpak_dir_deploy (FlatpakDir          *self, const char          *origin, const char          *ref, const char          *checksum_or_latest, const char * const * subpaths, GVariant            *old_deploy_data, GCancellable        *cancellable, GError             **error) { g_autofree char *resolved_ref = NULL; g_autoptr(GFile) root = NULL; g_autoptr(GFile) deploy_base = NULL; g_autoptr(GFile) checkoutdir = NULL; g_autofree char *checkoutdirpath = NULL; g_autoptr(GFile) real_checkoutdir = NULL; g_autoptr(GFile) dotref = NULL; g_autoptr(GFile) files_etc = NULL; g_autoptr(GFile) metadata = NULL; g_autoptr(GFile) deploy_data_file = NULL; g_autoptr(GVariant) deploy_data = NULL; g_autoptr(GFile) export = NULL; g_autoptr(GFile) extradir = NULL; g_autoptr(GKeyFile) keyfile = NULL; guint64 installed_size = 0; OstreeRepoCheckoutAtOptions options = { 0, }; const char *checksum; glnx_fd_close int checkoutdir_dfd = -1; g_autoptr(GFile) tmp_dir_template = NULL; g_autoptr(GVariant) commit_data = NULL; g_autofree char *tmp_dir_path = NULL; g_autofree char *alt_id = NULL; const char *xa_metadata = NULL; const char *xa_ref = NULL; g_autofree char *checkout_basename = NULL; gboolean created_extra_data = FALSE; g_autoptr(GVariant) commit_metadata = NULL; GVariantBuilder metadata_builder; if (!flatpak_dir_ensure_repo (self, cancellable, error)) return FALSE; deploy_base = flatpak_dir_get_deploy_dir (self, ref); if (checksum_or_latest == NULL) { g_debug (""No checksum specified, getting tip of %s"", ref); resolved_ref = flatpak_dir_read_latest (self, origin, ref, NULL, cancellable, error); if (resolved_ref == NULL) { g_prefix_error (error, _(""While trying to resolve ref %s: ""), ref); return FALSE; } checksum = resolved_ref; g_debug (""tip resolved to: %s"", checksum); } else { g_autoptr(GFile) root = NULL; g_autofree char *commit = NULL; checksum = checksum_or_latest; g_debug (""Looking for checksum %s in local repo"", checksum); if (!ostree_repo_read_commit (self->repo, checksum, &root, &commit, cancellable, NULL)) return flatpak_fail (error, _(""%s is not available""), ref); } if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error)) return FALSE; commit_metadata = g_variant_get_child_value (commit_data, 0); g_variant_lookup (commit_metadata, ""xa.alt-id"", ""s"", &alt_id); if (subpaths == NULL || *subpaths == NULL) checkout_basename = g_strdup (checksum); else { GString *str = g_string_new (checksum); int i; for (i = 0; subpaths[i] != NULL; i++) { const char *s = subpaths[i]; g_string_append_c (str, '-'); while (*s) { if (*s != '/') g_string_append_c (str, *s); s++; } } checkout_basename = g_string_free (str, FALSE); } real_checkoutdir = g_file_get_child (deploy_base, checkout_basename); if (g_file_query_exists (real_checkoutdir, cancellable)) { g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED, _(""%s branch %s already installed""), ref, checksum); return FALSE; } g_autofree char *template = g_strdup_printf ("".%s-XXXXXX"", checkout_basename); tmp_dir_template = g_file_get_child (deploy_base, template); tmp_dir_path = g_file_get_path (tmp_dir_template); if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL) { g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED, _(""Can't create deploy directory"")); return FALSE; } checkoutdir = g_file_new_for_path (tmp_dir_path); if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error)) { g_prefix_error (error, _(""Failed to read commit %s: ""), checksum); return FALSE; } if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error)) return FALSE; options.mode = OSTREE_REPO_CHECKOUT_MODE_USER; options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES; options.enable_fsync = FALSE;  checkoutdirpath = g_file_get_path (checkoutdir); if (subpaths == NULL || *subpaths == NULL) { if (!ostree_repo_checkout_at (self->repo, &options, AT_FDCWD, checkoutdirpath, checksum, cancellable, error)) { g_prefix_error (error, _(""While trying to checkout %s into %s: ""), checksum, checkoutdirpath); return FALSE; } } else { g_autofree char *checkoutdirpath = g_file_get_path (checkoutdir); g_autoptr(GFile) files = g_file_get_child (checkoutdir, ""files""); g_autoptr(GFile) root = NULL; g_autofree char *commit = NULL; int i; if (!g_file_make_directory_with_parents (files, cancellable, error)) return FALSE; options.subpath = ""/metadata""; if (!ostree_repo_read_commit (self->repo, checksum, &root,  &commit, cancellable, error)) return FALSE; if (!ostree_repo_checkout_at (self->repo, &options, AT_FDCWD, checkoutdirpath, checksum, cancellable, error)) { g_prefix_error (error, _(""While trying to checkout metadata subpath: "")); return FALSE; } for (i = 0; subpaths[i] != NULL; i++) { g_autofree char *subpath = g_build_filename (""/files"", subpaths[i], NULL); g_autofree char *dstpath = g_build_filename (checkoutdirpath, ""/files"", subpaths[i], NULL); g_autofree char *dstpath_parent = g_path_get_dirname (dstpath); g_autoptr(GFile) child = NULL; child = g_file_resolve_relative_path (root, subpath); if (!g_file_query_exists (child, cancellable)) { g_debug (""subpath %s not in tree"", subpaths[i]); continue; } if (g_mkdir_with_parents (dstpath_parent, 0755)) { glnx_set_error_from_errno (error); return FALSE; } options.subpath = subpath; if (!ostree_repo_checkout_at (self->repo, &options, AT_FDCWD, dstpath, checksum, cancellable, error)) { g_prefix_error (error, _(""While trying to checkout metadata subpath: "")); return FALSE; } } } extradir = g_file_resolve_relative_path (checkoutdir, ""files/extra""); if (!flatpak_rm_rf (extradir, cancellable, error)) { g_prefix_error (error, _(""While trying to remove existing extra dir: "")); return FALSE; } if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error)) return FALSE; if (created_extra_data) { if (!apply_extra_data (self, checkoutdir, cancellable, error)) { g_prefix_error (error, _(""While trying to apply extra data: "")); return FALSE; } } g_variant_lookup (commit_metadata, ""xa.ref"", ""s"", &xa_ref); if (xa_ref != NULL) { if (strcmp (ref, xa_ref) != 0) { g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED, _(""Deployed ref %s does not match commit (%s)""), ref, xa_ref); return FALSE; } } g_variant_lookup (commit_metadata, ""xa.metadata"", ""s"", &xa_metadata); if (xa_metadata != NULL) { g_autoptr(GFile) metadata_file = g_file_resolve_relative_path (checkoutdir, ""metadata""); char *metadata_contents; if (!g_file_load_contents (metadata_file, NULL, &metadata_contents, NULL, NULL, NULL) || strcmp (metadata_contents, xa_metadata) != 0) { g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED, _(""Deployed metadata does not match commit"")); return FALSE; } } dotref = g_file_resolve_relative_path (checkoutdir, ""files/.ref""); if (!g_file_replace_contents (dotref, """", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error)) return TRUE; files_etc = g_file_resolve_relative_path (checkoutdir, ""files/etc""); if (g_file_query_exists (files_etc, cancellable)) { char *etcfiles[] = {""passwd"", ""group"", ""machine-id"" }; g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, ""resolv.conf""); int i; for (i = 0; i < G_N_ELEMENTS (etcfiles); i++) { g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]); GFileType type; type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, cancellable); if (type == G_FILE_TYPE_REGULAR) continue; if (type != G_FILE_TYPE_UNKNOWN) { if (!g_file_delete (etc_file, cancellable, error)) return FALSE; } if (!g_file_replace_contents (etc_file, """", 0, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error)) return FALSE; } if (g_file_query_exists (etc_resolve_conf, cancellable) && !g_file_delete (etc_resolve_conf, cancellable, error)) return TRUE; if (!g_file_make_symbolic_link (etc_resolve_conf, ""/run/host/monitor/resolv.conf"", cancellable, error)) return FALSE; } keyfile = g_key_file_new (); metadata = g_file_get_child (checkoutdir, ""metadata""); if (g_file_query_exists (metadata, cancellable)) { g_autofree char *path = g_file_get_path (metadata); if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, error)) return FALSE; } export = g_file_get_child (checkoutdir, ""export""); if (g_file_query_exists (export, cancellable)) { g_auto(GStrv) ref_parts = NULL; ref_parts = g_strsplit (ref, ""/"", -1); if (!flatpak_rewrite_export_dir (ref_parts[1], ref_parts[3], ref_parts[2], keyfile, export, cancellable, error)) return FALSE; } g_variant_builder_init (&metadata_builder, G_VARIANT_TYPE (""a{sv}"")); if (alt_id) g_variant_builder_add (&metadata_builder, ""{s@v}"", ""alt-id"", g_variant_new_variant (g_variant_new_string (alt_id))); deploy_data = flatpak_dir_new_deploy_data (origin, checksum, (char **) subpaths, installed_size, g_variant_builder_end (&metadata_builder)); deploy_data_file = g_file_get_child (checkoutdir, ""deploy""); if (!flatpak_variant_save (deploy_data_file, deploy_data, cancellable, error)) return FALSE; if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error)) return FALSE; if (syncfs (checkoutdir_dfd) != 0) { glnx_set_error_from_errno (error); return FALSE; } if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE, cancellable, NULL, NULL, error)) return FALSE; if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error)) return FALSE; return TRUE; }"
"static void headerMergeLegacySigs(Header h, Header sigh) { HeaderIterator hi; struct rpmtd_s td; hi = headerInitIterator(sigh); for (; headerNext(hi, &td); rpmtdFreeData(&td)) { switch (td.tag) { case RPMSIGTAG_SIZE: td.tag = RPMTAG_SIGSIZE; break; case RPMSIGTAG_PGP: td.tag = RPMTAG_SIGPGP; break; case RPMSIGTAG_MD5: td.tag = RPMTAG_SIGMD5; break; case RPMSIGTAG_GPG: td.tag = RPMTAG_SIGGPG; break; case RPMSIGTAG_PGP5: td.tag = RPMTAG_SIGPGP5; break; case RPMSIGTAG_PAYLOADSIZE: td.tag = RPMTAG_ARCHIVESIZE; break; case RPMSIGTAG_FILESIGNATURES: td.tag = RPMTAG_FILESIGNATURES; break; case RPMSIGTAG_FILESIGNATURELENGTH: td.tag = RPMTAG_FILESIGNATURELENGTH; break; case RPMSIGTAG_VERITYSIGNATURES: case RPMSIGTAG_VERITYSIGNATUREALGO: case RPMSIGTAG_SHA1: case RPMSIGTAG_SHA256: case RPMSIGTAG_DSA: case RPMSIGTAG_RSA: default: if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE)) continue; break; } if (!headerIsEntry(h, td.tag)) { switch (td.type) { case RPM_NULL_TYPE: continue; break; case RPM_CHAR_TYPE: case RPM_INT8_TYPE: case RPM_INT16_TYPE: case RPM_INT32_TYPE: case RPM_INT64_TYPE: if (td.count != 1) continue; break; case RPM_STRING_TYPE: case RPM_STRING_ARRAY_TYPE: case RPM_BIN_TYPE: if (td.count >= 16*1024) continue; break; case RPM_I18NSTRING_TYPE: continue; break; } (void) headerPut(h, &td, HEADERPUT_DEFAULT); } } headerFreeIterator(hi); }"
"u8 spectre_bhb_loop_affected(int scope) { u8 k = 0; static u8 max_bhb_k; if (scope == SCOPE_LOCAL_CPU) { static const struct midr_range spectre_bhb_k32_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A78), MIDR_ALL_VERSIONS(MIDR_CORTEX_A78AE), MIDR_ALL_VERSIONS(MIDR_CORTEX_A78C), MIDR_ALL_VERSIONS(MIDR_CORTEX_X1), MIDR_ALL_VERSIONS(MIDR_CORTEX_A710), MIDR_ALL_VERSIONS(MIDR_CORTEX_X2), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_N2), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_V1), {}, }; static const struct midr_range spectre_bhb_k24_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A76), MIDR_ALL_VERSIONS(MIDR_CORTEX_A77), MIDR_ALL_VERSIONS(MIDR_NEOVERSE_N1), {}, }; static const struct midr_range spectre_bhb_k8_list[] = { MIDR_ALL_VERSIONS(MIDR_CORTEX_A72), MIDR_ALL_VERSIONS(MIDR_CORTEX_A57), {}, }; if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k32_list)) k = 32; else if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k24_list)) k = 24; else if (is_midr_in_range_list(read_cpuid_id(), spectre_bhb_k8_list)) k =  8; max_bhb_k = max(max_bhb_k, k); } else { k = max_bhb_k; } return k; }"
"void sqlc_insert_view (sql_comp_t * sc, ST * view, ST * tree, dbe_table_t * tb) { int inx; ST **cols = tree->_.insert.cols; dk_set_t aliases = NULL; dk_set_t new_cols = NULL, new_vals = NULL; if (!sqlc_view_is_updatable (view)) sqlc_new_error (sc->sc_cc, ""37000"", ""SQ114"", ""View %s is not updatable in insert."", tb->tb_name); tree->_.insert.table = (ST *) t_box_copy_tree ( (caddr_t) view->_.select_stmt.table_exp->_.table_exp.from[0]->_.table_ref.table); _DO_BOX (inx, tree->_.insert.cols) { sqlc_col_to_view_scope (sc, &cols[inx], view, &aliases); if (!ST_P (tree->_.insert.vals, SELECT_STMT)) sinv_sqlo_check_col_val (&cols[inx], &(tree->_.insert.vals->_.ins_vals.vals[inx]), &new_cols, &new_vals); } END_DO_BOX; if (new_cols) { ST ** new_cols_box = (ST **) t_alloc_box ( (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t), DV_ARRAY_OF_POINTER); ST ** new_vals_box = (ST **) t_alloc_box ( (BOX_ELEMENTS (cols) + dk_set_length (new_cols)) * sizeof (caddr_t), DV_ARRAY_OF_POINTER); memcpy (new_cols_box, cols, box_length (cols)); memcpy (new_vals_box, tree->_.insert.vals->_.ins_vals.vals, box_length (cols)); inx = BOX_ELEMENTS (cols); DO_SET (ST *, new_col, &new_cols) { new_cols_box[inx] = new_col; new_vals_box[inx] = (ST *) new_vals->data; new_vals = new_vals->next; inx ++; } END_DO_SET (); tree->_.insert.cols = cols = new_cols_box; tree->_.insert.vals->_.ins_vals.vals = new_vals_box; } _DO_BOX (inx, tree->_.insert.cols) { if (ST_COLUMN (cols[inx], COL_DOTTED)) { ST *c = (ST *) t_box_copy_tree (cols[inx]->_.col_ref.name); cols[inx] = c; } else { sqlc_new_error (sc->sc_cc, ""37000"", ""SQ115"", ""Non-updatable column in view %s (expression or constant)"", tb->tb_name); } } END_DO_BOX; sc->sc_col_ref_recs = t_NCONC (aliases, sc->sc_col_ref_recs); sqlc_insert (sc, tree); }"
"static void hci_extended_inquiry_result_evt(struct hci_dev *hdev, struct sk_buff *skb) { struct inquiry_data data; struct extended_inquiry_info *info = (void *) (skb->data + 1); int num_rsp = *((__u8 *) skb->data); size_t eir_len; BT_DBG(""%s num_rsp %d"", hdev->name, num_rsp); if (!num_rsp) return; if (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ)) return; hci_dev_lock(hdev); for (; num_rsp; num_rsp--, info++) { u32 flags; bool name_known; bacpy(&data.bdaddr, &info->bdaddr); data.pscan_rep_mode= info->pscan_rep_mode; data.pscan_period_mode= info->pscan_period_mode; data.pscan_mode= 0x00; memcpy(data.dev_class, info->dev_class, 3); data.clock_offset= info->clock_offset; data.rssi= info->rssi; data.ssp_mode= 0x01; if (hci_dev_test_flag(hdev, HCI_MGMT)) name_known = eir_get_data(info->data, sizeof(info->data), EIR_NAME_COMPLETE, NULL); else name_known = true; flags = hci_inquiry_cache_update(hdev, &data, name_known); eir_len = eir_get_length(info->data, sizeof(info->data)); mgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00, info->dev_class, info->rssi, flags, info->data, eir_len, NULL, 0); } hci_dev_unlock(hdev); }"
"void luaD_shrinkstack (lua_State *L) { int inuse = stackinuse(L); int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK; if (goodsize > LUAI_MAXSTACK) goodsize = LUAI_MAXSTACK;   if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize) luaD_reallocstack(L, goodsize, 0);   else   condmovestack(L,{},{});   luaE_shrinkCI(L);   }"
"static struct topdicts *readcfftopdict(FILE *ttf, char *fontname, int len, struct ttfinfo *info) { struct topdicts *td = calloc(1,sizeof(struct topdicts)); long base = ftell(ttf); int ival, oval, sp, ret, i; real stack[50]; if ( fontname!=NULL ) ValidatePostScriptFontName(info,fontname); td->fontname = fontname; td->underlinepos = -100; td->underlinewidth = 50; td->charstringtype = 2; td->fontmatrix[0] = td->fontmatrix[3] = .001; td->notice = td->copyright = td->fullname = td->familyname = td->weight = td->version = -1; td->postscript_code = td->basefontname = -1; td->synthetic_base = td->ros_registry = -1; td->fdarrayoff = td->fdselectoff = td->sid_fontname = -1; td->blendaxistypes[0] = -1; while ( ftell(ttf)<base+len ) { sp = 0; while ( (ret=readcffthing(ttf,&ival,&stack[sp],&oval,info))!=3 && ftell(ttf)<base+len ) { if ( ret==1 ) stack[sp]=ival; if ( ret!=0 && sp<45 ) ++sp; } if ( ret==3 && oval==31  ) { skipcfft2thing(ttf); } else if ( sp==0 ) { LogError( _(""No argument to operator\n"") ); info->bad_cff = true; } else if ( ret==3 ) switch( oval ) { case 0: td->version = stack[sp-1]; break; case 1: td->notice = stack[sp-1]; break; case (12<<8)+0: td->copyright = stack[sp-1]; break; case 2: td->fullname = stack[sp-1]; break; case 3: td->familyname = stack[sp-1]; break; case 4: td->weight = stack[sp-1]; break; case (12<<8)+1: td->isfixedpitch = stack[sp-1]; break; case (12<<8)+2: td->italicangle = stack[sp-1]; break; case (12<<8)+3: td->underlinepos = stack[sp-1]; break; case (12<<8)+4: td->underlinewidth = stack[sp-1]; break; case (12<<8)+5: td->painttype = stack[sp-1]; break; case (12<<8)+6: td->charstringtype = stack[sp-1]; break; case (12<<8)+7: memcpy(td->fontmatrix,stack,(sp>=6?6:sp)*sizeof(real)); td->fontmatrix_set = 1; break; case 13: td->uniqueid = stack[sp-1]; break; case 5: memcpy(td->fontbb,stack,(sp>=4?4:sp)*sizeof(real)); break; case (12<<8)+8: td->strokewidth = stack[sp-1]; break; case 14: for ( i=0; i<sp && i<20; ++i ) td->xuid[i] = stack[i]; break; case 15: td->charsetoff = stack[sp-1]; break; case 16: td->encodingoff = stack[sp-1]; break; case 17: td->charstringsoff = stack[sp-1]; break; case 18: td->private_size = stack[0]; td->private_offset = stack[1]; break; case (12<<8)+20: LogError( _(""FontForge does not support synthetic fonts\n"") ); td->synthetic_base = stack[sp-1]; break; case (12<<8)+21: td->postscript_code = stack[sp-1]; break; case (12<<8)+22: td->basefontname = stack[sp-1]; break; case (12<<8)+23: for ( i=0; i<sp && i<16; ++i ) td->basefontblend[i] = stack[i]; break; case (12<<8)+24: LogError( _(""FontForge does not support type2 multiple master fonts\n"") ); info->bad_cff = true; if (sp < 4) { LogError(_(""CFF dict stack underflow detected: %d < 4\n""), sp); break; } td->nMasters = stack[0]; td->nAxes = sp-4; memcpy(td->weightvector,stack+1,(sp-4)*sizeof(real)); td->lenBuildCharArray = stack[sp-3]; td->NormalizeDesignVector = stack[sp-2]; td->ConvertDesignVector = stack[sp-1]; break; case (12<<8)+26: for ( i=0; i<sp && i<16; ++i ) td->blendaxistypes[i] = stack[i]; td->blendaxistypes[i] = -1; break; case (12<<8)+30: td->ros_registry = stack[0]; td->ros_ordering = stack[1]; td->ros_supplement = stack[2]; break; case (12<<8)+31: td->cidfontversion = stack[sp-1]; break; case (12<<8)+32: td->cidfontrevision = stack[sp-1]; break; case (12<<8)+33: td->cidfonttype = stack[sp-1]; break; case (12<<8)+34: td->cidcount = stack[sp-1]; break; case (12<<8)+35: td->uidbase = stack[sp-1]; break; case (12<<8)+36: td->fdarrayoff = stack[sp-1]; break; case (12<<8)+37: td->fdselectoff = stack[sp-1]; break; case (12<<8)+38: td->sid_fontname = stack[sp-1]; break; case (12<<8)+39: LogError(_(""FontForge does not support Chameleon fonts\n""));; break; default: LogError(_(""Unknown operator in %s: %x\n""), fontname, oval ); info->bad_cff = true; break; } } return( td ); }"
"int evtchn_send(struct domain *ld, unsigned int lport) { struct evtchn *lchn, *rchn; struct domain *rd; int            rport, ret = 0; if ( !port_is_valid(ld, lport) ) return -EINVAL; lchn = evtchn_from_port(ld, lport); spin_lock(&lchn->lock); if ( unlikely(consumer_is_xen(lchn)) ) { ret = -EINVAL; goto out; } ret = xsm_evtchn_send(XSM_HOOK, ld, lchn); if ( ret ) goto out; switch ( lchn->state ) { case ECS_INTERDOMAIN: rd    = lchn->u.interdomain.remote_dom; rport = lchn->u.interdomain.remote_port; rchn  = evtchn_from_port(rd, rport); if ( consumer_is_xen(rchn) ) xen_notification_fn(rchn)(rd->vcpu[rchn->notify_vcpu_id], rport); else evtchn_port_set_pending(rd, rchn->notify_vcpu_id, rchn); break; case ECS_IPI: evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn); break; case ECS_UNBOUND: break; default: ret = -EINVAL; } out: spin_unlock(&lchn->lock); return ret; }"
"zmq::stream_engine_base_t::stream_engine_base_t ( fd_t fd_, const options_t &options_, const endpoint_uri_pair_t &endpoint_uri_pair_) : _options (options_), _inpos (NULL), _insize (0), _decoder (NULL), _outpos (NULL), _outsize (0), _encoder (NULL), _mechanism (NULL), _next_msg (NULL), _process_msg (NULL), _metadata (NULL), _input_stopped (false), _output_stopped (false), _endpoint_uri_pair (endpoint_uri_pair_), _has_handshake_timer (false), _has_ttl_timer (false), _has_timeout_timer (false), _has_heartbeat_timer (false), _peer_address (get_peer_address (fd_)), _s (fd_), _handle (static_cast<handle_t> (NULL)), _plugged (false), _handshaking (true), _io_error (false), _session (NULL), _socket (NULL) { const int rc = _tx_msg.init (); errno_assert (rc == 0); unblock_socket (_s); }"
void timeoutExpired() noexcept override { if (counter > 0 && httpSessionStats) { httpSessionStats->recordControlMsgsInInterval(counter); } counter = 0; }
"static char_u * cstrchr(char_u *s, int c) { char_u*p; intcc; if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1)) return vim_strchr(s, c); if (enc_utf8 && c > 0x80) cc = utf_fold(c); else if (MB_ISUPPER(c)) cc = MB_TOLOWER(c); else if (MB_ISLOWER(c)) cc = MB_TOUPPER(c); else return vim_strchr(s, c); if (has_mbyte) { for (p = s; *p != NUL; p += (*mb_ptr2len)(p)) { if (enc_utf8 && c > 0x80) { if (utf_fold(utf_ptr2char(p)) == cc) return p; } else if (*p == c || *p == cc) return p; } } else for (p = s; *p != NUL; ++p) if (*p == c || *p == cc) return p; return NULL; }"
static Status ValidateSavedTensors(const GraphDef& graph_def) { for (const auto& node : graph_def.node()) { TF_RETURN_IF_ERROR(ValidateNode(node)); } if (graph_def.has_library()) { const FunctionDefLibrary& library = graph_def.library(); for (const auto& function : library.function()) { for (const auto& node : function.node_def()) { TF_RETURN_IF_ERROR(ValidateNode(node)); } } } return Status::OK(); }
"int rds_cmsg_atomic(struct rds_sock *rs, struct rds_message *rm, struct cmsghdr *cmsg) { struct page *page = NULL; struct rds_atomic_args *args; int ret = 0; if (cmsg->cmsg_len < CMSG_LEN(sizeof(struct rds_atomic_args)) || rm->atomic.op_active) return -EINVAL; args = CMSG_DATA(cmsg); switch (cmsg->cmsg_type) { case RDS_CMSG_ATOMIC_FADD: rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; rm->atomic.op_m_fadd.add = args->fadd.add; rm->atomic.op_m_fadd.nocarry_mask = 0; break; case RDS_CMSG_MASKED_ATOMIC_FADD: rm->atomic.op_type = RDS_ATOMIC_TYPE_FADD; rm->atomic.op_m_fadd.add = args->m_fadd.add; rm->atomic.op_m_fadd.nocarry_mask = args->m_fadd.nocarry_mask; break; case RDS_CMSG_ATOMIC_CSWP: rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; rm->atomic.op_m_cswp.compare = args->cswp.compare; rm->atomic.op_m_cswp.swap = args->cswp.swap; rm->atomic.op_m_cswp.compare_mask = ~0; rm->atomic.op_m_cswp.swap_mask = ~0; break; case RDS_CMSG_MASKED_ATOMIC_CSWP: rm->atomic.op_type = RDS_ATOMIC_TYPE_CSWP; rm->atomic.op_m_cswp.compare = args->m_cswp.compare; rm->atomic.op_m_cswp.swap = args->m_cswp.swap; rm->atomic.op_m_cswp.compare_mask = args->m_cswp.compare_mask; rm->atomic.op_m_cswp.swap_mask = args->m_cswp.swap_mask; break; default: BUG();  } rm->atomic.op_notify = !!(args->flags & RDS_RDMA_NOTIFY_ME); rm->atomic.op_silent = !!(args->flags & RDS_RDMA_SILENT); rm->atomic.op_active = 1; rm->atomic.op_recverr = rs->rs_recverr; rm->atomic.op_sg = rds_message_alloc_sgs(rm, 1); if (!rm->atomic.op_sg) { ret = -ENOMEM; goto err; } if (args->local_addr & 0x7) { ret = -EFAULT; goto err; } ret = rds_pin_pages(args->local_addr, 1, &page, 1); if (ret != 1) goto err; ret = 0; sg_set_page(rm->atomic.op_sg, page, 8, offset_in_page(args->local_addr)); if (rm->atomic.op_notify || rm->atomic.op_recverr) { rm->atomic.op_notifier = kmalloc(sizeof(*rm->atomic.op_notifier), GFP_KERNEL); if (!rm->atomic.op_notifier) { ret = -ENOMEM; goto err; } rm->atomic.op_notifier->n_user_token = args->user_token; rm->atomic.op_notifier->n_status = RDS_RDMA_SUCCESS; } rm->atomic.op_rkey = rds_rdma_cookie_key(args->cookie); rm->atomic.op_remote_addr = args->remote_addr + rds_rdma_cookie_offset(args->cookie); return ret; err: if (page) put_page(page); kfree(rm->atomic.op_notifier); return ret; }"
"static void dissect_routing6_rpl(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *rthdr_tree, struct rthdr_proto_item *rthdr_ti, struct ip6_rthdr rt) { proto_item *pi = proto_tree_get_parent(rthdr_tree); proto_item *ti; guint8 cmprI, cmprE, cmprX, pad; guint32 reserved; gint idx; gint rpl_addr_count; struct e_in6_addr rpl_fulladdr; const struct e_in6_addr *ip6_dst_addr, *ip6_src_addr; wmem_array_t *rpl_addr_vector = NULL; guint i; ip6_dst_addr = (const struct e_in6_addr *)pinfo->dst.data; ip6_src_addr = (const struct e_in6_addr *)pinfo->src.data; if (in6_is_addr_multicast(ip6_dst_addr)) { expert_add_info(pinfo, pi, &ei_ipv6_dst_addr_not_multicast); } proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprI, tvb, offset, 4, ENC_BIG_ENDIAN); proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_cmprE, tvb, offset, 4, ENC_BIG_ENDIAN); ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_pad, tvb, offset, 4, ENC_BIG_ENDIAN); cmprI = tvb_get_guint8(tvb, offset) & 0xF0; cmprE = tvb_get_guint8(tvb, offset) & 0x0F; pad   = tvb_get_guint8(tvb, offset + 1) & 0xF0; cmprI >>= 4; pad >>= 4; if (cmprI == 0 && cmprE == 0 && pad != 0) { expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_cmpri_cmpre_pad, ""When cmprI equals 0 and cmprE equals 0, pad MUST equal 0 but instead was %d"", pad); } ti = proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_reserved, tvb, offset, 4, ENC_BIG_ENDIAN); reserved = tvb_get_bits32(tvb, ((offset + 1) * 8) + 4, 20, ENC_BIG_ENDIAN); if (reserved != 0) { expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_reserved, ""Reserved field must equal 0 but instead was %d"", reserved); } rpl_addr_count = 0; if (rt.ip6r_len > 0) { rpl_addr_count = (((rt.ip6r_len * 8) - pad - (16 - cmprE)) / (16 - cmprI)) + 1; } ti = proto_tree_add_int(rthdr_tree, hf_ipv6_routing_rpl_addr_count, tvb, offset, 2, rpl_addr_count); PROTO_ITEM_SET_GENERATED(ti); if (rpl_addr_count < 0) { expert_add_info_format(pinfo, ti, &ei_ipv6_routing_rpl_addr_count_ge0, ""Calculated total address count must be greater than or equal to 0, instead was %d"", rpl_addr_count); } else if (rt.ip6r_segleft > (guint)rpl_addr_count) { expert_add_info_format(pinfo, rthdr_ti->segs, &ei_ipv6_routing_invalid_segleft, ""IPv6 RPL Routing Header segments left field must not exceed address count (%d)"", rpl_addr_count); } if (rpl_addr_count > 0) { offset += 4; if (g_ipv6_rpl_srh_strict_rfc_checking) rpl_addr_vector = wmem_array_sized_new(wmem_packet_scope(), IPv6_ADDR_SIZE, rpl_addr_count); for (idx = 1; idx <= rpl_addr_count; idx++) { if (idx == rpl_addr_count) cmprX = 16 - cmprE; else cmprX = 16 - cmprI; proto_tree_add_item(rthdr_tree, hf_ipv6_routing_rpl_addr, tvb, offset, cmprX, ENC_NA); memcpy(&rpl_fulladdr, ip6_dst_addr, IPv6_ADDR_SIZE); tvb_memcpy(tvb, &rpl_fulladdr.bytes[16-cmprX], offset, cmprX); ti = _proto_tree_add_ipv6_vector_address(rthdr_tree, hf_ipv6_routing_rpl_fulladdr, tvb, offset, cmprX, &rpl_fulladdr, idx); PROTO_ITEM_SET_GENERATED(ti); offset += cmprX; if (memcmp(&rpl_fulladdr, ip6_src_addr, IPv6_ADDR_SIZE) == 0) { expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_src_addr); } if (memcmp(&rpl_fulladdr, ip6_dst_addr, IPv6_ADDR_SIZE) == 0) { expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_dst_addr); } if (in6_is_addr_multicast(&rpl_fulladdr)) { expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_multicast_addr); } if (g_ipv6_rpl_srh_strict_rfc_checking) { for (i = 0; i < wmem_array_get_count(rpl_addr_vector); i++) { if (memcmp(&rpl_fulladdr, wmem_array_index(rpl_addr_vector, i), IPv6_ADDR_SIZE) == 0) { expert_add_info(pinfo, ti, &ei_ipv6_src_route_list_mult_inst_same_addr); break; } } wmem_array_append(rpl_addr_vector, &rpl_fulladdr, 1); } if (rt.ip6r_segleft > 0) { alloc_address_wmem(pinfo->pool, &pinfo->dst, AT_IPv6, IPv6_ADDR_SIZE, &rpl_fulladdr); } } } }"
"GF_Err gnrm_box_dump(GF_Box *a, FILE * trace) { GF_GenericSampleEntryBox *p = (GF_GenericSampleEntryBox *)a; if (p->EntryType) { a->type = p->EntryType; if (a->type==GF_ISOM_BOX_TYPE_UNKNOWN) a->type = GF_4CC('u','k','n','w'); } gf_isom_box_dump_start(a, ""SampleDescriptionEntryBox"", trace); gf_fprintf(trace, ""DataReferenceIndex=\""%d\"" ExtensionDataSize=\""%d\"""", p->dataReferenceIndex, p->data_size); a->type = GF_ISOM_BOX_TYPE_GNRM; gnr_dump_exts(p->data, p->data_size, trace); gf_isom_box_dump_done(""SampleDescriptionEntryBox"", a, trace); return GF_OK; }"
"static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd, unsigned long old_addr, unsigned long old_end, struct vm_area_struct *new_vma, pmd_t *new_pmd, unsigned long new_addr, bool need_rmap_locks, bool *need_flush) { struct mm_struct *mm = vma->vm_mm; pte_t *old_pte, *new_pte, pte; spinlock_t *old_ptl, *new_ptl; bool force_flush = false; unsigned long len = old_end - old_addr; if (need_rmap_locks) take_rmap_locks(vma); old_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl); new_pte = pte_offset_map(new_pmd, new_addr); new_ptl = pte_lockptr(mm, new_pmd); if (new_ptl != old_ptl) spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING); flush_tlb_batched_pending(vma->vm_mm); arch_enter_lazy_mmu_mode(); for (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE, new_pte++, new_addr += PAGE_SIZE) { if (pte_none(*old_pte)) continue; pte = ptep_get_and_clear(mm, old_addr, old_pte); if (pte_present(pte) && pte_dirty(pte)) force_flush = true; pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr); pte = move_soft_dirty_pte(pte); set_pte_at(mm, new_addr, new_pte, pte); } arch_leave_lazy_mmu_mode(); if (new_ptl != old_ptl) spin_unlock(new_ptl); pte_unmap(new_pte - 1); if (force_flush) flush_tlb_range(vma, old_end - len, old_end); else *need_flush = true; pte_unmap_unlock(old_pte - 1, old_ptl); if (need_rmap_locks) drop_rmap_locks(vma); }"
"static void nbd_teardown_connection(BlockDriverState *bs) { NBDClientSession *client = nbd_get_client_session(bs); if (!client->ioc) {  return; } qio_channel_shutdown(client->ioc, QIO_CHANNEL_SHUTDOWN_BOTH, NULL); nbd_recv_coroutines_enter_all(client); nbd_client_detach_aio_context(bs); object_unref(OBJECT(client->sioc)); client->sioc = NULL; object_unref(OBJECT(client->ioc)); client->ioc = NULL; }"
"WORD32 ih264d_parse_islice_data_cabac(dec_struct_t * ps_dec, dec_slice_params_t * ps_slice, UWORD16 u2_first_mb_in_slice) { UWORD8 uc_more_data_flag; UWORD8 u1_num_mbs, u1_mb_idx; dec_mb_info_t *ps_cur_mb_info; deblk_mb_t *ps_cur_deblk_mb; dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm; UWORD16 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs; WORD16 i2_cur_mb_addr; UWORD8 u1_mbaff; UWORD8 u1_num_mbs_next, u1_end_of_row, u1_tfr_n_mb; WORD32 ret = OK; ps_dec->u1_qp = ps_slice->u1_slice_qp; ih264d_update_qp(ps_dec, 0); u1_mbaff = ps_slice->u1_mbaff_frame_flag; if(ps_bitstrm->u4_ofst & 0x07) { ps_bitstrm->u4_ofst += 8; ps_bitstrm->u4_ofst &= 0xFFFFFFF8; } ret = ih264d_init_cabac_dec_envirnoment(&(ps_dec->s_cab_dec_env), ps_bitstrm); if(ret != OK) return ret; ih264d_init_cabac_contexts(I_SLICE, ps_dec); ps_dec->i1_prev_mb_qp_delta = 0; u1_mb_idx = ps_dec->u1_mb_idx; u1_num_mbs = u1_mb_idx; uc_more_data_flag = 1; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff; do { UWORD16 u2_mbx; ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data; if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr) { ret = ERROR_MB_ADDRESS_T; break; } { UWORD8 u1_mb_type; ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs; ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs; ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff); ps_cur_mb_info->u1_end_of_slice = 0; ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, 0); u2_mbx = ps_dec->u2_mbx; ps_cur_mb_info->u1_tran_form8x8 = 0; ps_cur_mb_info->ps_curmb->u1_tran_form8x8 = 0; ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs; if(ps_dec->u4_app_disable_deblk_frm == 0) ih264d_set_deblocking_parameters( ps_cur_deblk_mb, ps_slice, ps_dec->u1_mb_ngbr_availablity, ps_dec->u1_cur_mb_fld_dec_flag); ps_cur_deblk_mb->u1_mb_type = ps_cur_deblk_mb->u1_mb_type | D_INTRA_MB; u1_mb_type = ih264d_parse_mb_type_intra_cabac(0, ps_dec); if(u1_mb_type > 25) return ERROR_MB_TYPE; ps_cur_mb_info->u1_mb_type = u1_mb_type; COPYTHECONTEXT(""u1_mb_type"", u1_mb_type); if(25 == u1_mb_type) { ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB; ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs); if(ret != OK) return ret; ps_cur_deblk_mb->u1_mb_qp = 0; } else { ret = ih264d_parse_imb_cabac(ps_dec, ps_cur_mb_info, u1_mb_type); if(ret != OK) return ret; ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp; } if(u1_mbaff) { ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info); } i2_cur_mb_addr++; if(ps_cur_mb_info->u1_topmb && u1_mbaff) uc_more_data_flag = 1; else { uc_more_data_flag = ih264d_decode_terminate(&ps_dec->s_cab_dec_env, ps_bitstrm); uc_more_data_flag = !uc_more_data_flag; COPYTHECONTEXT(""Decode Sliceterm"",!uc_more_data_flag); } { mv_pred_t *ps_mv_nmb_start = ps_dec->ps_mv_cur + (u1_num_mbs << 4); mv_pred_t s_mvPred = { { 0, 0, 0, 0 }, { -1, -1 }, 0, 0}; ih264d_rep_mv_colz( ps_dec, &s_mvPred, ps_mv_nmb_start, 0, (UWORD8)(ps_dec->u1_cur_mb_fld_dec_flag << 1), 4, 4); } if(ps_dec->u4_num_cores < 3) { if(ps_dec->u4_app_disable_deblk_frm == 0) ps_dec->pf_compute_bs(ps_dec, ps_cur_mb_info, (UWORD16)(u1_num_mbs >> u1_mbaff)); } u1_num_mbs++; ps_dec->u2_total_mbs_coded++; } u1_num_mbs_next = i2_pic_wdin_mbs - u2_mbx - 1; u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01))); u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row || (!uc_more_data_flag); ps_cur_mb_info->u1_end_of_slice = (!uc_more_data_flag); if(u1_tfr_n_mb || (!uc_more_data_flag)) { if(ps_dec->u1_separate_parse) { ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row); ps_dec->ps_nmb_info +=  u1_num_mbs; } else { ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row); } if(u1_tfr_n_mb) u1_num_mbs = 0; u1_mb_idx = u1_num_mbs; ps_dec->u1_mb_idx = u1_num_mbs; } } while(uc_more_data_flag); ps_dec->u4_num_mbs_cur_nmb = 0; ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr - (u2_first_mb_in_slice << u1_mbaff); return ret; }"
"int fuse_set_acl(struct inode *inode, struct posix_acl *acl, int type) { struct fuse_conn *fc = get_fuse_conn(inode); const char *name; int ret; if (!fc->posix_acl || fc->no_setxattr) return -EOPNOTSUPP; if (type == ACL_TYPE_ACCESS) name = XATTR_NAME_POSIX_ACL_ACCESS; else if (type == ACL_TYPE_DEFAULT) name = XATTR_NAME_POSIX_ACL_DEFAULT; else return -EINVAL; if (acl) { size_t size = posix_acl_xattr_size(acl->a_count); void *value; if (size > PAGE_SIZE) return -E2BIG; value = kmalloc(size, GFP_KERNEL); if (!value) return -ENOMEM; ret = posix_acl_to_xattr(fc->user_ns, acl, value, size); if (ret < 0) { kfree(value); return ret; } ret = fuse_setxattr(inode, name, value, size, 0); kfree(value); } else { ret = fuse_removexattr(inode, name); } forget_all_cached_acls(inode); fuse_invalidate_attr(inode); return ret; }"
"void PpapiThread::OnCreateChannel(base::ProcessId renderer_pid, int renderer_child_id, bool incognito) { IPC::ChannelHandle channel_handle; if (!plugin_entry_points_.get_interface ||        !SetupRendererChannel(renderer_pid, renderer_child_id, incognito, &channel_handle)) { Send(new PpapiHostMsg_ChannelCreated(IPC::ChannelHandle())); return; } Send(new PpapiHostMsg_ChannelCreated(channel_handle)); }"
"static struct lys_restr * lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres) { struct lys_restr *result; int i; if (!size) { return NULL; } result = calloc(size, sizeof *result); LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL); for (i = 0; i < size; i++) { result[i].ext_size = old[i].ext_size; lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres); result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0); result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0); result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0); result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0); result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0); } return result; }"
"void HttpConfig::startup() { http_rsb = RecAllocateRawStatBlock((int)http_stat_count); register_stat_callbacks(); HttpConfigParams &c = m_master; http_config_cont = new HttpConfigCont; HttpEstablishStaticConfigStringAlloc(c.proxy_hostname, ""proxy.config.proxy_name""); c.proxy_hostname_len = -1; if (c.proxy_hostname == nullptr) { c.proxy_hostname    = (char *)ats_malloc(sizeof(char)); c.proxy_hostname[0] = '\0'; } RecHttpLoadIp(""proxy.local.incoming_ip_to_bind"", c.inbound_ip4, c.inbound_ip6); RecHttpLoadIp(""proxy.local.outgoing_ip_to_bind"", c.outbound_ip4, c.outbound_ip6); HttpEstablishStaticConfigLongLong(c.server_max_connections, ""proxy.config.http.server_max_connections""); HttpEstablishStaticConfigLongLong(c.max_websocket_connections, ""proxy.config.http.websocket.max_number_of_connections""); HttpEstablishStaticConfigLongLong(c.oride.server_tcp_init_cwnd, ""proxy.config.http.server_tcp_init_cwnd""); HttpEstablishStaticConfigLongLong(c.oride.origin_max_connections, ""proxy.config.http.origin_max_connections""); HttpEstablishStaticConfigLongLong(c.oride.origin_max_connections_queue, ""proxy.config.http.origin_max_connections_queue""); HttpEstablishStaticConfigLongLong(c.origin_min_keep_alive_connections, ""proxy.config.http.origin_min_keep_alive_connections""); HttpEstablishStaticConfigByte(c.oride.attach_server_session_to_client, ""proxy.config.http.attach_server_session_to_client""); HttpEstablishStaticConfigByte(c.disable_ssl_parenting, ""proxy.local.http.parent_proxy.disable_connect_tunneling""); HttpEstablishStaticConfigByte(c.oride.forward_connect_method, ""proxy.config.http.forward_connect_method""); HttpEstablishStaticConfigByte(c.no_dns_forward_to_parent, ""proxy.config.http.no_dns_just_forward_to_parent""); HttpEstablishStaticConfigByte(c.oride.uncacheable_requests_bypass_parent, ""proxy.config.http.uncacheable_requests_bypass_parent""); HttpEstablishStaticConfigByte(c.oride.doc_in_cache_skip_dns, ""proxy.config.http.doc_in_cache_skip_dns""); HttpEstablishStaticConfigByte(c.no_origin_server_dns, ""proxy.config.http.no_origin_server_dns""); HttpEstablishStaticConfigByte(c.use_client_target_addr, ""proxy.config.http.use_client_target_addr""); HttpEstablishStaticConfigByte(c.use_client_source_port, ""proxy.config.http.use_client_source_port""); HttpEstablishStaticConfigByte(c.oride.maintain_pristine_host_hdr, ""proxy.config.url_remap.pristine_host_hdr""); HttpEstablishStaticConfigByte(c.oride.insert_request_via_string, ""proxy.config.http.insert_request_via_str""); HttpEstablishStaticConfigByte(c.oride.insert_response_via_string, ""proxy.config.http.insert_response_via_str""); HttpEstablishStaticConfigLongLong(c.oride.proxy_response_hsts_max_age, ""proxy.config.ssl.hsts_max_age""); HttpEstablishStaticConfigByte(c.oride.proxy_response_hsts_include_subdomains, ""proxy.config.ssl.hsts_include_subdomains""); HttpEstablishStaticConfigStringAlloc(c.oride.client_cert_filename, ""proxy.config.ssl.client.cert.filename""); HttpEstablishStaticConfigStringAlloc(c.oride.client_cert_filepath, ""proxy.config.ssl.client.cert.path""); HttpEstablishStaticConfigStringAlloc(c.proxy_request_via_string, ""proxy.config.http.request_via_str""); c.proxy_request_via_string_len = -1; HttpEstablishStaticConfigStringAlloc(c.proxy_response_via_string, ""proxy.config.http.response_via_str""); c.proxy_response_via_string_len = -1; HttpEstablishStaticConfigByte(c.oride.keep_alive_enabled_in, ""proxy.config.http.keep_alive_enabled_in""); HttpEstablishStaticConfigByte(c.oride.keep_alive_enabled_out, ""proxy.config.http.keep_alive_enabled_out""); HttpEstablishStaticConfigByte(c.oride.chunking_enabled, ""proxy.config.http.chunking_enabled""); HttpEstablishStaticConfigLongLong(c.oride.http_chunking_size, ""proxy.config.http.chunking.size""); HttpEstablishStaticConfigByte(c.oride.flow_control_enabled, ""proxy.config.http.flow_control.enabled""); HttpEstablishStaticConfigLongLong(c.oride.flow_high_water_mark, ""proxy.config.http.flow_control.high_water""); HttpEstablishStaticConfigLongLong(c.oride.flow_low_water_mark, ""proxy.config.http.flow_control.low_water""); HttpEstablishStaticConfigByte(c.oride.post_check_content_length_enabled, ""proxy.config.http.post.check.content_length.enabled""); HttpEstablishStaticConfigByte(c.strict_uri_parsing, ""proxy.config.http.strict_uri_parsing""); RecRegisterConfigUpdateCb(""proxy.config.http.server_session_sharing.match"", &http_server_session_sharing_cb, &c); http_config_enum_read(""proxy.config.http.server_session_sharing.match"", SessionSharingMatchStrings, c.oride.server_session_sharing_match); http_config_enum_read(""proxy.config.http.server_session_sharing.pool"", SessionSharingPoolStrings, c.server_session_sharing_pool); RecRegisterConfigUpdateCb(""proxy.config.http.insert_forwarded"", &http_insert_forwarded_cb, &c); { char str[512]; if (REC_ERR_OKAY == RecGetRecordString(""proxy.config.http.insert_forwarded"", str, sizeof(str))) { ts::LocalBufferWriter<1024> error; HttpForwarded::OptionBitSet bs = HttpForwarded::optStrToBitset(ts::string_view(str), error); if (!error.size()) { c.oride.insert_forwarded = bs; } else { Error(""HTTP %.*s"", static_cast<int>(error.size()), error.data()); } } } HttpEstablishStaticConfigByte(c.oride.auth_server_session_private, ""proxy.config.http.auth_server_session_private""); HttpEstablishStaticConfigByte(c.oride.keep_alive_post_out, ""proxy.config.http.keep_alive_post_out""); HttpEstablishStaticConfigLongLong(c.oride.keep_alive_no_activity_timeout_in, ""proxy.config.http.keep_alive_no_activity_timeout_in""); HttpEstablishStaticConfigLongLong(c.oride.keep_alive_no_activity_timeout_out, ""proxy.config.http.keep_alive_no_activity_timeout_out""); HttpEstablishStaticConfigLongLong(c.oride.transaction_no_activity_timeout_in, ""proxy.config.http.transaction_no_activity_timeout_in""); HttpEstablishStaticConfigLongLong(c.oride.transaction_no_activity_timeout_out, ""proxy.config.http.transaction_no_activity_timeout_out""); HttpEstablishStaticConfigLongLong(c.oride.websocket_active_timeout, ""proxy.config.websocket.active_timeout""); HttpEstablishStaticConfigLongLong(c.oride.websocket_inactive_timeout, ""proxy.config.websocket.no_activity_timeout""); HttpEstablishStaticConfigLongLong(c.oride.transaction_active_timeout_in, ""proxy.config.http.transaction_active_timeout_in""); HttpEstablishStaticConfigLongLong(c.oride.transaction_active_timeout_out, ""proxy.config.http.transaction_active_timeout_out""); HttpEstablishStaticConfigLongLong(c.accept_no_activity_timeout, ""proxy.config.http.accept_no_activity_timeout""); HttpEstablishStaticConfigLongLong(c.oride.background_fill_active_timeout, ""proxy.config.http.background_fill_active_timeout""); HttpEstablishStaticConfigFloat(c.oride.background_fill_threshold, ""proxy.config.http.background_fill_completed_threshold""); HttpEstablishStaticConfigLongLong(c.oride.connect_attempts_max_retries, ""proxy.config.http.connect_attempts_max_retries""); HttpEstablishStaticConfigLongLong(c.oride.connect_attempts_max_retries_dead_server, ""proxy.config.http.connect_attempts_max_retries_dead_server""); HttpEstablishStaticConfigLongLong(c.oride.connect_attempts_rr_retries, ""proxy.config.http.connect_attempts_rr_retries""); HttpEstablishStaticConfigLongLong(c.oride.connect_attempts_timeout, ""proxy.config.http.connect_attempts_timeout""); HttpEstablishStaticConfigLongLong(c.oride.post_connect_attempts_timeout, ""proxy.config.http.post_connect_attempts_timeout""); HttpEstablishStaticConfigLongLong(c.oride.parent_connect_attempts, ""proxy.config.http.parent_proxy.total_connect_attempts""); HttpEstablishStaticConfigLongLong(c.oride.parent_retry_time, ""proxy.config.http.parent_proxy.retry_time""); HttpEstablishStaticConfigLongLong(c.oride.parent_fail_threshold, ""proxy.config.http.parent_proxy.fail_threshold""); HttpEstablishStaticConfigLongLong(c.oride.per_parent_connect_attempts, ""proxy.config.http.parent_proxy.per_parent_connect_attempts""); HttpEstablishStaticConfigLongLong(c.oride.parent_connect_timeout, ""proxy.config.http.parent_proxy.connect_attempts_timeout""); HttpEstablishStaticConfigByte(c.oride.parent_failures_update_hostdb, ""proxy.config.http.parent_proxy.mark_down_hostdb""); HttpEstablishStaticConfigLongLong(c.oride.sock_recv_buffer_size_out, ""proxy.config.net.sock_recv_buffer_size_out""); HttpEstablishStaticConfigLongLong(c.oride.sock_send_buffer_size_out, ""proxy.config.net.sock_send_buffer_size_out""); HttpEstablishStaticConfigLongLong(c.oride.sock_option_flag_out, ""proxy.config.net.sock_option_flag_out""); HttpEstablishStaticConfigLongLong(c.oride.sock_packet_mark_out, ""proxy.config.net.sock_packet_mark_out""); HttpEstablishStaticConfigLongLong(c.oride.sock_packet_tos_out, ""proxy.config.net.sock_packet_tos_out""); HttpEstablishStaticConfigByte(c.oride.fwd_proxy_auth_to_parent, ""proxy.config.http.forward.proxy_auth_to_parent""); HttpEstablishStaticConfigByte(c.oride.anonymize_remove_from, ""proxy.config.http.anonymize_remove_from""); HttpEstablishStaticConfigByte(c.oride.anonymize_remove_referer, ""proxy.config.http.anonymize_remove_referer""); HttpEstablishStaticConfigByte(c.oride.anonymize_remove_user_agent, ""proxy.config.http.anonymize_remove_user_agent""); HttpEstablishStaticConfigByte(c.oride.anonymize_remove_cookie, ""proxy.config.http.anonymize_remove_cookie""); HttpEstablishStaticConfigByte(c.oride.anonymize_remove_client_ip, ""proxy.config.http.anonymize_remove_client_ip""); HttpEstablishStaticConfigByte(c.oride.anonymize_insert_client_ip, ""proxy.config.http.insert_client_ip""); HttpEstablishStaticConfigStringAlloc(c.anonymize_other_header_list, ""proxy.config.http.anonymize_other_header_list""); HttpEstablishStaticConfigStringAlloc(c.oride.global_user_agent_header, ""proxy.config.http.global_user_agent_header""); c.oride.global_user_agent_header_size = c.oride.global_user_agent_header ? strlen(c.oride.global_user_agent_header) : 0; HttpEstablishStaticConfigByte(c.oride.proxy_response_server_enabled, ""proxy.config.http.response_server_enabled""); HttpEstablishStaticConfigStringAlloc(c.oride.proxy_response_server_string, ""proxy.config.http.response_server_str""); c.oride.proxy_response_server_string_len = c.oride.proxy_response_server_string ? strlen(c.oride.proxy_response_server_string) : 0; HttpEstablishStaticConfigByte(c.oride.insert_squid_x_forwarded_for, ""proxy.config.http.insert_squid_x_forwarded_for""); HttpEstablishStaticConfigByte(c.oride.insert_age_in_response, ""proxy.config.http.insert_age_in_response""); HttpEstablishStaticConfigByte(c.enable_http_stats, ""proxy.config.http.enable_http_stats""); HttpEstablishStaticConfigByte(c.oride.normalize_ae, ""proxy.config.http.normalize_ae""); HttpEstablishStaticConfigLongLong(c.oride.cache_heuristic_min_lifetime, ""proxy.config.http.cache.heuristic_min_lifetime""); HttpEstablishStaticConfigLongLong(c.oride.cache_heuristic_max_lifetime, ""proxy.config.http.cache.heuristic_max_lifetime""); HttpEstablishStaticConfigFloat(c.oride.cache_heuristic_lm_factor, ""proxy.config.http.cache.heuristic_lm_factor""); HttpEstablishStaticConfigLongLong(c.oride.cache_guaranteed_min_lifetime, ""proxy.config.http.cache.guaranteed_min_lifetime""); HttpEstablishStaticConfigLongLong(c.oride.cache_guaranteed_max_lifetime, ""proxy.config.http.cache.guaranteed_max_lifetime""); HttpEstablishStaticConfigLongLong(c.oride.cache_max_stale_age, ""proxy.config.http.cache.max_stale_age""); HttpEstablishStaticConfigByte(c.oride.srv_enabled, ""proxy.config.srv_enabled""); HttpEstablishStaticConfigStringAlloc(c.oride.cache_vary_default_text, ""proxy.config.http.cache.vary_default_text""); HttpEstablishStaticConfigStringAlloc(c.oride.cache_vary_default_images, ""proxy.config.http.cache.vary_default_images""); HttpEstablishStaticConfigStringAlloc(c.oride.cache_vary_default_other, ""proxy.config.http.cache.vary_default_other""); HttpEstablishStaticConfigLongLong(c.oride.max_cache_open_read_retries, ""proxy.config.http.cache.max_open_read_retries""); HttpEstablishStaticConfigLongLong(c.oride.cache_open_read_retry_time, ""proxy.config.http.cache.open_read_retry_time""); HttpEstablishStaticConfigLongLong(c.oride.cache_generation_number, ""proxy.config.http.cache.generation""); HttpEstablishStaticConfigLongLong(c.oride.max_cache_open_write_retries, ""proxy.config.http.cache.max_open_write_retries""); HttpEstablishStaticConfigByte(c.oride.cache_http, ""proxy.config.http.cache.http""); HttpEstablishStaticConfigByte(c.oride.cache_ignore_client_no_cache, ""proxy.config.http.cache.ignore_client_no_cache""); HttpEstablishStaticConfigByte(c.oride.cache_ignore_client_cc_max_age, ""proxy.config.http.cache.ignore_client_cc_max_age""); HttpEstablishStaticConfigByte(c.oride.cache_ims_on_client_no_cache, ""proxy.config.http.cache.ims_on_client_no_cache""); HttpEstablishStaticConfigByte(c.oride.cache_ignore_server_no_cache, ""proxy.config.http.cache.ignore_server_no_cache""); HttpEstablishStaticConfigByte(c.oride.cache_responses_to_cookies, ""proxy.config.http.cache.cache_responses_to_cookies""); HttpEstablishStaticConfigByte(c.oride.cache_ignore_auth, ""proxy.config.http.cache.ignore_authentication""); HttpEstablishStaticConfigByte(c.oride.cache_urls_that_look_dynamic, ""proxy.config.http.cache.cache_urls_that_look_dynamic""); HttpEstablishStaticConfigByte(c.oride.cache_enable_default_vary_headers, ""proxy.config.http.cache.enable_default_vary_headers""); HttpEstablishStaticConfigByte(c.cache_post_method, ""proxy.config.http.cache.post_method""); HttpEstablishStaticConfigByte(c.oride.ignore_accept_mismatch, ""proxy.config.http.cache.ignore_accept_mismatch""); HttpEstablishStaticConfigByte(c.oride.ignore_accept_language_mismatch, ""proxy.config.http.cache.ignore_accept_language_mismatch""); HttpEstablishStaticConfigByte(c.oride.ignore_accept_encoding_mismatch, ""proxy.config.http.cache.ignore_accept_encoding_mismatch""); HttpEstablishStaticConfigByte(c.oride.ignore_accept_charset_mismatch, ""proxy.config.http.cache.ignore_accept_charset_mismatch""); HttpEstablishStaticConfigByte(c.send_100_continue_response, ""proxy.config.http.send_100_continue_response""); HttpEstablishStaticConfigByte(c.disallow_post_100_continue, ""proxy.config.http.disallow_post_100_continue""); HttpEstablishStaticConfigByte(c.parser_allow_non_http, ""proxy.config.http.parse.allow_non_http""); HttpEstablishStaticConfigByte(c.keepalive_internal_vc, ""proxy.config.http.keepalive_internal_vc""); HttpEstablishStaticConfigByte(c.oride.cache_open_write_fail_action, ""proxy.config.http.cache.open_write_fail_action""); HttpEstablishStaticConfigByte(c.oride.cache_when_to_revalidate, ""proxy.config.http.cache.when_to_revalidate""); HttpEstablishStaticConfigByte(c.oride.cache_required_headers, ""proxy.config.http.cache.required_headers""); HttpEstablishStaticConfigByte(c.oride.cache_range_lookup, ""proxy.config.http.cache.range.lookup""); HttpEstablishStaticConfigByte(c.oride.cache_range_write, ""proxy.config.http.cache.range.write""); HttpEstablishStaticConfigStringAlloc(c.connect_ports_string, ""proxy.config.http.connect_ports""); HttpEstablishStaticConfigLongLong(c.oride.request_hdr_max_size, ""proxy.config.http.request_header_max_size""); HttpEstablishStaticConfigLongLong(c.oride.response_hdr_max_size, ""proxy.config.http.response_header_max_size""); HttpEstablishStaticConfigByte(c.push_method_enabled, ""proxy.config.http.push_method_enabled""); HttpEstablishStaticConfigByte(c.reverse_proxy_enabled, ""proxy.config.reverse_proxy.enabled""); HttpEstablishStaticConfigByte(c.url_remap_required, ""proxy.config.url_remap.remap_required""); HttpEstablishStaticConfigStringAlloc(c.reverse_proxy_no_host_redirect, ""proxy.config.header.parse.no_host_url_redirect""); c.reverse_proxy_no_host_redirect_len = -1; HttpEstablishStaticConfigStringAlloc(c.oride.body_factory_template_base, ""proxy.config.body_factory.template_base""); c.oride.body_factory_template_base_len = c.oride.body_factory_template_base ? strlen(c.oride.body_factory_template_base) : 0; HttpEstablishStaticConfigLongLong(c.body_factory_response_max_size, ""proxy.config.body_factory.response_max_size""); HttpEstablishStaticConfigByte(c.errors_log_error_pages, ""proxy.config.http.errors.log_error_pages""); HttpEstablishStaticConfigLongLong(c.oride.slow_log_threshold, ""proxy.config.http.slow.log.threshold""); HttpEstablishStaticConfigByte(c.oride.ssl_client_verify_server, ""proxy.config.ssl.client.verify.server""); HttpEstablishStaticConfigByte(c.record_cop_page, ""proxy.config.http.record_heartbeat""); HttpEstablishStaticConfigByte(c.oride.send_http11_requests, ""proxy.config.http.send_http11_requests""); HttpEstablishStaticConfigByte(c.referer_filter_enabled, ""proxy.config.http.referer_filter""); HttpEstablishStaticConfigByte(c.referer_format_redirect, ""proxy.config.http.referer_format_redirect""); HttpEstablishStaticConfigLongLong(c.oride.down_server_timeout, ""proxy.config.http.down_server.cache_time""); HttpEstablishStaticConfigLongLong(c.oride.client_abort_threshold, ""proxy.config.http.down_server.abort_threshold""); HttpEstablishStaticConfigByte(c.oride.negative_caching_enabled, ""proxy.config.http.negative_caching_enabled""); HttpEstablishStaticConfigLongLong(c.oride.negative_caching_lifetime, ""proxy.config.http.negative_caching_lifetime""); HttpEstablishStaticConfigByte(c.oride.negative_revalidating_enabled, ""proxy.config.http.negative_revalidating_enabled""); HttpEstablishStaticConfigLongLong(c.oride.negative_revalidating_lifetime, ""proxy.config.http.negative_revalidating_lifetime""); HttpEstablishStaticConfigLongLong(c.oride.default_buffer_size_index, ""proxy.config.http.default_buffer_size""); HttpEstablishStaticConfigLongLong(c.oride.default_buffer_water_mark, ""proxy.config.http.default_buffer_water_mark""); HttpEstablishStaticConfigByte(c.enable_http_info, ""proxy.config.http.enable_http_info""); HttpEstablishStaticConfigLongLong(c.max_post_size, ""proxy.config.http.max_post_size""); HttpEstablishStaticConfigByte(c.oride.redirect_use_orig_cache_key, ""proxy.config.http.redirect_use_orig_cache_key""); HttpEstablishStaticConfigByte(c.redirection_host_no_port, ""proxy.config.http.redirect_host_no_port""); HttpEstablishStaticConfigLongLong(c.oride.number_of_redirections, ""proxy.config.http.number_of_redirections""); HttpEstablishStaticConfigLongLong(c.post_copy_size, ""proxy.config.http.post_copy_size""); HttpEstablishStaticConfigLongLong(c.synthetic_port, ""proxy.config.admin.synthetic_port""); http_config_cont->handleEvent(EVENT_NONE, nullptr); return; }"
"int git_delta_apply( void **out, size_t *out_len, const unsigned char *base, size_t base_len, const unsigned char *delta, size_t delta_len) { const unsigned char *delta_end = delta + delta_len; size_t base_sz, res_sz, alloc_sz; unsigned char *res_dp; *out = NULL; *out_len = 0; if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) { giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data""); return -1; } if (hdr_sz(&res_sz, &delta, delta_end) < 0) { giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data""); return -1; } GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1); res_dp = git__malloc(alloc_sz); GITERR_CHECK_ALLOC(res_dp); res_dp[res_sz] = '\0'; *out = res_dp; *out_len = res_sz; while (delta < delta_end) { unsigned char cmd = *delta++; if (cmd & 0x80) { size_t off = 0, len = 0; if (cmd & 0x01) off = *delta++; if (cmd & 0x02) off |= *delta++ << 8UL; if (cmd & 0x04) off |= *delta++ << 16UL; if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL); if (cmd & 0x10) len = *delta++; if (cmd & 0x20) len |= *delta++ << 8UL; if (cmd & 0x40) len |= *delta++ << 16UL; if (!len)       len = 0x10000; if (base_len < off + len || res_sz < len) goto fail; memcpy(res_dp, base + off, len); res_dp += len; res_sz -= len; } else if (cmd) { if (delta_end - delta < cmd || res_sz < cmd) goto fail; memcpy(res_dp, delta, cmd); delta += cmd; res_dp += cmd; res_sz -= cmd; } else { goto fail; } } if (delta != delta_end || res_sz) goto fail; return 0; fail: git__free(*out); *out = NULL; *out_len = 0; giterr_set(GITERR_INVALID, ""failed to apply delta""); return -1; }"
"void hvm_set_callback_via(struct domain *d, uint64_t via) { struct hvm_irq *hvm_irq = &d->arch.hvm_domain.irq; unsigned int gsi=0, pdev=0, pintx=0; uint8_t via_type; via_type = (uint8_t)(via >> 56) + 1; if ( ((via_type == HVMIRQ_callback_gsi) && (via == 0)) || (via_type > HVMIRQ_callback_vector) ) via_type = HVMIRQ_callback_none; if ( via_type != HVMIRQ_callback_vector && (!has_vlapic(d) || !has_vioapic(d) || !has_vpic(d)) ) return; spin_lock(&d->arch.hvm_domain.irq_lock); if ( hvm_irq->callback_via_asserted ) { switch ( hvm_irq->callback_via_type ) { case HVMIRQ_callback_gsi: gsi = hvm_irq->callback_via.gsi; if ( (--hvm_irq->gsi_assert_count[gsi] == 0) && (gsi <= 15) ) vpic_irq_negative_edge(d, gsi); break; case HVMIRQ_callback_pci_intx: pdev  = hvm_irq->callback_via.pci.dev; pintx = hvm_irq->callback_via.pci.intx; __hvm_pci_intx_deassert(d, pdev, pintx); break; default: break; } } switch ( hvm_irq->callback_via_type = via_type ) { case HVMIRQ_callback_gsi: gsi = hvm_irq->callback_via.gsi = (uint8_t)via; if ( (gsi == 0) || (gsi >= ARRAY_SIZE(hvm_irq->gsi_assert_count)) ) hvm_irq->callback_via_type = HVMIRQ_callback_none; else if ( hvm_irq->callback_via_asserted && (hvm_irq->gsi_assert_count[gsi]++ == 0) ) { vioapic_irq_positive_edge(d, gsi); if ( gsi <= 15 ) vpic_irq_positive_edge(d, gsi); } break; case HVMIRQ_callback_pci_intx: pdev  = hvm_irq->callback_via.pci.dev  = (uint8_t)(via >> 11) & 31; pintx = hvm_irq->callback_via.pci.intx = (uint8_t)via & 3; if ( hvm_irq->callback_via_asserted ) __hvm_pci_intx_assert(d, pdev, pintx); break; case HVMIRQ_callback_vector: hvm_irq->callback_via.vector = (uint8_t)via; break; default: break; } spin_unlock(&d->arch.hvm_domain.irq_lock); dprintk(XENLOG_G_INFO, ""Dom%u callback via changed to "", d->domain_id); switch ( via_type ) { case HVMIRQ_callback_gsi: printk(""GSI %u\n"", gsi); break; case HVMIRQ_callback_pci_intx: printk(""PCI INTx Dev 0x%02x Int%c\n"", pdev, 'A' + pintx); break; case HVMIRQ_callback_vector: printk(""Direct Vector 0x%02x\n"", (uint8_t)via); break; default: printk(""None\n""); break; } }"
"static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value) { if (*pStackPtr >= CDL_STACK_SIZE) return EAS_ERROR_FILE_FORMAT; *pStackPtr = *pStackPtr + 1; pStack[*pStackPtr] = value; return EAS_SUCCESS; }"
"static int dissect_nfs4_dirlist(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, rpc_call_info_value *civ) { guint32    val_follows; guint32    name_len; char   *name; proto_tree *dirlist_tree; proto_item *eitem; proto_tree *entry_tree; dirlist_tree = proto_tree_add_subtree(tree, tvb, offset, 0, ett_nfs4_dirlist, NULL, ""Directory Listing""); while (1) { val_follows = tvb_get_ntohl(tvb, offset); if (val_follows) { int start_off = offset; name_len = tvb_get_ntohl(tvb, offset + 12); tvb_ensure_bytes_exist(tvb, offset, 16 + name_len); name = (char *)tvb_memcpy(tvb, wmem_alloc(wmem_packet_scope(), name_len+1), offset + 16, name_len); name[name_len] = '\0'; eitem = proto_tree_add_string_format( dirlist_tree, hf_nfs_name, tvb, offset, -1, name, ""Entry: %s"", name); entry_tree = proto_item_add_subtree(eitem, ett_nfs4_dir_entry); proto_tree_add_boolean(entry_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows); offset += 4; if (entry_tree) dissect_rpc_uint64(tvb, entry_tree, hf_nfs4_cookie, offset); offset += 8; offset = dissect_nfs_utf8string(tvb, offset, entry_tree, hf_nfs4_dir_entry_name, NULL); offset = dissect_nfs4_fattrs(tvb, offset, pinfo, entry_tree, FATTR4_DISSECT_VALUES, civ); proto_item_set_len(eitem, offset - start_off); } else { break; } } if (dirlist_tree) { proto_tree_add_boolean(dirlist_tree, hf_nfs4_value_follows, tvb, offset, 4, val_follows); offset += 4; offset = dissect_rpc_bool(tvb, dirlist_tree, hf_nfs4_dirlist_eof, offset); } else { offset += 8; } return offset; }"
"static int get_filter(struct sss_certmap_ctx *ctx, struct ldap_mapping_rule *parsed_mapping_rule, struct sss_cert_content *cert_content, char **filter) { struct ldap_mapping_rule_comp *comp; char *result = NULL; char *expanded = NULL; int ret; result = talloc_strdup(ctx, """"); if (result == NULL) { return ENOMEM; } for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) { if (comp->type == comp_string) { result = talloc_strdup_append(result, comp->val); } else if (comp->type == comp_template) { ret = expand_template(ctx, comp->parsed_template, cert_content, &expanded); if (ret != 0) { CM_DEBUG(ctx, ""Failed to expanded template.""); goto done; } result = talloc_strdup_append(result, expanded); talloc_free(expanded); expanded = NULL; if (result == NULL) { ret = ENOMEM; goto done; } } else { ret = EINVAL; CM_DEBUG(ctx, ""Unsupported component type.""); goto done; } } ret = 0; done: talloc_free(expanded); if (ret == 0) { *filter = result; } else { talloc_free(result); } return ret; }"
"int fix_ipv4_checksums(tcpedit_t *tcpedit, struct pcap_pkthdr *pkthdr, ipv4_hdr_t *ip_hdr) { int ret1 = 0, ret2 = 0, ip_len; assert(tcpedit); assert(pkthdr); assert(ip_hdr); if (pkthdr->caplen < sizeof(*ip_hdr)) { tcpedit_setwarn(tcpedit, ""caplen too small to read IPv4 header: %u"", pkthdr->caplen); return TCPEDIT_WARN; } if (ip_hdr->ip_v != 4) { tcpedit_seterr(tcpedit, ""Invalid packet: Expected IPv4 packet: got %u"", ip_hdr->ip_v); return TCPEDIT_ERROR; } if (pkthdr->caplen == pkthdr->len && (htons(ip_hdr->ip_off) & (IP_MF | IP_OFFMASK)) == 0) { ip_len = (int)ntohs(ip_hdr->ip_len); ret1 = do_checksum(tcpedit, (u_char *) ip_hdr, ip_hdr->ip_p, ip_len - (ip_hdr->ip_hl << 2)); if (ret1 < 0) return TCPEDIT_ERROR; } ip_len = (int)ntohs(ip_hdr->ip_len); ret2 = do_checksum(tcpedit, (u_char *) ip_hdr, IPPROTO_IP, ip_len); if (ret2 < 0) return TCPEDIT_ERROR; if (ret1 == TCPEDIT_WARN || ret2 == TCPEDIT_WARN) return TCPEDIT_WARN; return TCPEDIT_OK; }"
"X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level, X509_POLICY_DATA *data, X509_POLICY_NODE *parent, X509_POLICY_TREE *tree) { X509_POLICY_NODE *node; node = OPENSSL_zalloc(sizeof(*node)); if (node == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); return NULL; } node->data = data; node->parent = parent; if (level) { if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) { if (level->anyPolicy) goto node_error; level->anyPolicy = node; } else { if (level->nodes == NULL) level->nodes = ossl_policy_node_cmp_new(); if (level->nodes == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_NODE_push(level->nodes, node)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } } if (tree) { if (tree->extra_data == NULL) tree->extra_data = sk_X509_POLICY_DATA_new_null(); if (tree->extra_data == NULL){ ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } if (parent) parent->nchild++; return node; node_error: ossl_policy_node_free(node); return NULL; }"
"static int rtnl_getlink(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack) { struct net *net = sock_net(skb->sk); struct net *tgt_net = net; struct ifinfomsg *ifm; char ifname[IFNAMSIZ]; struct nlattr *tb[IFLA_MAX+1]; struct net_device *dev = NULL; struct sk_buff *nskb; int netnsid = -1; int err; u32 ext_filter_mask = 0; err = nlmsg_parse(nlh, sizeof(*ifm), tb, IFLA_MAX, ifla_policy, extack); if (err < 0) return err; if (tb[IFLA_IF_NETNSID]) { netnsid = nla_get_s32(tb[IFLA_IF_NETNSID]); tgt_net = get_target_net(skb, netnsid); if (IS_ERR(tgt_net)) return PTR_ERR(tgt_net); } if (tb[IFLA_IFNAME]) nla_strlcpy(ifname, tb[IFLA_IFNAME], IFNAMSIZ); if (tb[IFLA_EXT_MASK]) ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]); err = -EINVAL; ifm = nlmsg_data(nlh); if (ifm->ifi_index > 0) dev = __dev_get_by_index(tgt_net, ifm->ifi_index); else if (tb[IFLA_IFNAME]) dev = __dev_get_by_name(tgt_net, ifname); else goto out; err = -ENODEV; if (dev == NULL) goto out; err = -ENOBUFS; nskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL); if (nskb == NULL) goto out; err = rtnl_fill_ifinfo(nskb, dev, net, RTM_NEWLINK, NETLINK_CB(skb).portid, nlh->nlmsg_seq, 0, 0, ext_filter_mask, 0, NULL, netnsid); if (err < 0) { WARN_ON(err == -EMSGSIZE); kfree_skb(nskb); } else err = rtnl_unicast(nskb, net, NETLINK_CB(skb).portid); out: if (netnsid >= 0) put_net(tgt_net); return err; }"
"static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx, struct wire_field_hdr *str_hdr, struct ntlm_buffer *buffer, size_t payload_offs, char **str) { char *in, *out = NULL; uint16_t str_len; uint32_t str_offs; size_t outlen; int ret = 0; str_len = le16toh(str_hdr->len); if (str_len == 0) goto done; str_offs = le32toh(str_hdr->offset); if ((str_offs < payload_offs) || (str_offs > buffer->length) || (str_offs + str_len > buffer->length)) { return ERR_DECODE; } in = (char *)&buffer->data[str_offs]; out = malloc(str_len * 2 + 1); if (!out) return ENOMEM; ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen); out[outlen] = '\0'; done: if (ret) { safefree(out); } *str = out; return ret; }"
"TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteEvalTensor* params, const TfLiteEvalTensor* indices, TfLiteEvalTensor* output) { switch (params->type) { case kTfLiteFloat32: return GatherNd<float, IndicesT>(params, indices, output); break; case kTfLiteInt8: return GatherNd<int8_t, IndicesT>(params, indices, output); break; default: TF_LITE_KERNEL_LOG(context, ""Params type '%s' are not supported by gather_nd."", TfLiteTypeGetName(params->type)); return kTfLiteError; } }"
"static pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory, const pjmedia_codec_info *id, pjmedia_codec **p_codec) { and_media_private_t *codec_data; pjmedia_codec *codec; int idx; pj_pool_t *pool; unsigned i; PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL); PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL); pj_mutex_lock(and_media_factory.mutex); idx = -1; for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) { pj_str_t name = pj_str((char*)and_media_codec[i].name); if ((pj_stricmp(&id->encoding_name, &name) == 0) && (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) && (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) && (and_media_codec[i].enabled)) { idx = i; break; } } if (idx == -1) { *p_codec = NULL; return PJMEDIA_CODEC_EFAILED; } pool = pjmedia_endpt_create_pool(and_media_factory.endpt, ""andmedaud%p"", 512, 512); codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec); PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM); codec->op = &and_media_op; codec->factory = factory; codec->codec_data = PJ_POOL_ZALLOC_T(pool, and_media_private_t); codec_data = (and_media_private_t*) codec->codec_data; if (!and_media_codec[idx].has_native_plc) { pj_status_t status; status = pjmedia_plc_create(pool, and_media_codec[idx].clock_rate, and_media_codec[idx].samples_per_frame, 0, &codec_data->plc); if (status != PJ_SUCCESS) { goto on_error; } } if (!and_media_codec[idx].has_native_vad) { pj_status_t status; status = pjmedia_silence_det_create(pool, and_media_codec[idx].clock_rate, and_media_codec[idx].samples_per_frame, &codec_data->vad); if (status != PJ_SUCCESS) { goto on_error; } } codec_data->pool = pool; codec_data->codec_idx = idx; create_codec(codec_data); if (!codec_data->enc || !codec_data->dec) { goto on_error; } pj_mutex_unlock(and_media_factory.mutex); *p_codec = codec; return PJ_SUCCESS; on_error: pj_mutex_unlock(and_media_factory.mutex); and_media_dealloc_codec(factory, codec); return PJMEDIA_CODEC_EFAILED; }"
bool lcTexture::Load(int Flags) { for (Image& Image : mImages) Image.ResizePow2(); mFlags = Flags; lcGetPiecesLibrary()->QueueTextureUpload(this); return true; }
"static int apng_encode_frame(AVCodecContext *avctx, const AVFrame *pict, APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk) { PNGEncContext *s = avctx->priv_data; int ret; unsigned int y; AVFrame* diffFrame; uint8_t bpp = (s->bits_per_pixel + 7) >> 3; uint8_t *original_bytestream, *original_bytestream_end; uint8_t *temp_bytestream = 0, *temp_bytestream_end; uint32_t best_sequence_number; uint8_t *best_bytestream; size_t best_bytestream_size = SIZE_MAX; APNGFctlChunk last_fctl_chunk = *best_last_fctl_chunk; APNGFctlChunk fctl_chunk = *best_fctl_chunk; if (avctx->frame_number == 0) { best_fctl_chunk->width = pict->width; best_fctl_chunk->height = pict->height; best_fctl_chunk->x_offset = 0; best_fctl_chunk->y_offset = 0; best_fctl_chunk->blend_op = APNG_BLEND_OP_SOURCE; return encode_frame(avctx, pict); } diffFrame = av_frame_alloc(); if (!diffFrame) return AVERROR(ENOMEM); diffFrame->format = pict->format; diffFrame->width = pict->width; diffFrame->height = pict->height; if ((ret = av_frame_get_buffer(diffFrame, 32)) < 0) goto fail; original_bytestream = s->bytestream; original_bytestream_end = s->bytestream_end; temp_bytestream = av_malloc(original_bytestream_end - original_bytestream); temp_bytestream_end = temp_bytestream + (original_bytestream_end - original_bytestream); if (!temp_bytestream) { ret = AVERROR(ENOMEM); goto fail; } for (last_fctl_chunk.dispose_op = 0; last_fctl_chunk.dispose_op < 3; ++last_fctl_chunk.dispose_op) { for (fctl_chunk.blend_op = 0; fctl_chunk.blend_op < 2; ++fctl_chunk.blend_op) { uint32_t original_sequence_number = s->sequence_number, sequence_number; uint8_t *bytestream_start = s->bytestream; size_t bytestream_size; if (last_fctl_chunk.dispose_op != APNG_DISPOSE_OP_PREVIOUS) { av_frame_copy(diffFrame, s->last_frame); if (last_fctl_chunk.dispose_op == APNG_DISPOSE_OP_BACKGROUND) { for (y = last_fctl_chunk.y_offset; y < last_fctl_chunk.y_offset + last_fctl_chunk.height; ++y) { size_t row_start = s->last_frame->linesize[0] * y + bpp * last_fctl_chunk.x_offset; memset(diffFrame->data[0] + row_start, 0, bpp * last_fctl_chunk.width); } } } else { if (!s->prev_frame) continue; av_frame_copy(diffFrame, s->prev_frame); } if (apng_do_inverse_blend(diffFrame, pict, &fctl_chunk, bpp) < 0) continue; ret = encode_frame(avctx, diffFrame); sequence_number = s->sequence_number; s->sequence_number = original_sequence_number; bytestream_size = s->bytestream - bytestream_start; s->bytestream = bytestream_start; if (ret < 0) goto fail; if (bytestream_size < best_bytestream_size) { *best_fctl_chunk = fctl_chunk; *best_last_fctl_chunk = last_fctl_chunk; best_sequence_number = sequence_number; best_bytestream = s->bytestream; best_bytestream_size = bytestream_size; if (best_bytestream == original_bytestream) { s->bytestream = temp_bytestream; s->bytestream_end = temp_bytestream_end; } else { s->bytestream = original_bytestream; s->bytestream_end = original_bytestream_end; } } } } s->sequence_number = best_sequence_number; s->bytestream = original_bytestream + best_bytestream_size; s->bytestream_end = original_bytestream_end; if (best_bytestream != original_bytestream) memcpy(original_bytestream, best_bytestream, best_bytestream_size); ret = 0; fail: av_freep(&temp_bytestream); av_frame_free(&diffFrame); return ret; }"
"void __attribute__((cold)) dump_obj(FILE* f, obj_t* obj) { if (!obj) { fprintf(f, ""null\n""); return; } obj_ty_t type = obj->obj_ty; if (type <= OT_LAST_PRIMITIVE) { dump_primitive_obj(f, obj); fputc('\n', f); } obj_composite_t* cobj = (obj_composite_t*)(void*)obj; for (; cobj; cobj = cobj->reverse_nesting_order) { dump_composite_obj(f, cobj); } }"
"static int pci_xhci_complete_commands(struct pci_xhci_vdev *xdev) { struct xhci_trbevtrb; struct xhci_trb*trb; uint64_tcrcr; uint32_tccs; uint32_ttype; uint32_tslot; uint32_tcmderr; xdev->opregs.crcr |= XHCI_CRCR_LO_CRR; trb = xdev->opregs.cr_p; ccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS; crcr = xdev->opregs.crcr & ~0xF; while (1) { xdev->opregs.cr_p = trb; type = XHCI_TRB_3_TYPE_GET(trb->dwTrb3); if ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) != (ccs & XHCI_TRB_3_CYCLE_BIT)) break; UPRINTF(LDBG, ""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x"" "" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\r\n"", type, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3, trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs); cmderr = XHCI_TRB_ERROR_SUCCESS; evtrb.dwTrb2 = 0; evtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) | XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE); slot = 0; switch (type) { case XHCI_TRB_TYPE_LINK: if (trb->dwTrb3 & XHCI_TRB_3_TC_BIT) ccs ^= XHCI_CRCR_LO_RCS; break; case XHCI_TRB_TYPE_ENABLE_SLOT: cmderr = pci_xhci_cmd_enable_slot(xdev, &slot); break; case XHCI_TRB_TYPE_DISABLE_SLOT: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_disable_slot(xdev, slot); break; case XHCI_TRB_TYPE_ADDRESS_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_address_device(xdev, slot, trb); break; case XHCI_TRB_TYPE_CONFIGURE_EP: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_config_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_EVALUATE_CTX: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_EP: UPRINTF(LDBG, ""Reset Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_STOP_EP: UPRINTF(LDBG, ""Stop Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_SET_TR_DEQUEUE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_set_tr(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_device(xdev, slot); break; case XHCI_TRB_TYPE_FORCE_EVENT: break; case XHCI_TRB_TYPE_NEGOTIATE_BW: break; case XHCI_TRB_TYPE_SET_LATENCY_TOL: break; case XHCI_TRB_TYPE_GET_PORT_BW: break; case XHCI_TRB_TYPE_FORCE_HEADER: break; case XHCI_TRB_TYPE_NOOP_CMD: break; default: UPRINTF(LDBG, ""unsupported cmd %x\r\n"", type); break; } if (type != XHCI_TRB_TYPE_LINK) { evtrb.qwTrb0 = crcr; evtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr); evtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot); UPRINTF(LDBG, ""command 0x%x result: 0x%x\r\n"", type, cmderr); if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) { UPRINTF(LFTL, ""Failed to inject command completion event!\r\n""); return -ENAVAIL; } } trb = pci_xhci_trb_next(xdev, trb, &crcr); if (!trb) { UPRINTF(LDBG, ""Get the invalid trb in %s!\r\n"", __func__); break; } } xdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs; xdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR; return 0; }"
"static long do_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg) { const struct fb_ops *fb; struct fb_var_screeninfo var; struct fb_fix_screeninfo fix; struct fb_cmap cmap_from; struct fb_cmap_user cmap; void __user *argp = (void __user *)arg; long ret = 0; switch (cmd) { case FBIOGET_VSCREENINFO: lock_fb_info(info); var = info->var; unlock_fb_info(info); ret = copy_to_user(argp, &var, sizeof(var)) ? -EFAULT : 0; break; case FBIOPUT_VSCREENINFO: if (copy_from_user(&var, argp, sizeof(var))) return -EFAULT; console_lock(); lock_fb_info(info); ret = fb_set_var(info, &var); if (!ret) fbcon_update_vcs(info, var.activate & FB_ACTIVATE_ALL); unlock_fb_info(info); console_unlock(); if (!ret && copy_to_user(argp, &var, sizeof(var))) ret = -EFAULT; break; case FBIOGET_FSCREENINFO: lock_fb_info(info); memcpy(&fix, &info->fix, sizeof(fix)); if (info->flags & FBINFO_HIDE_SMEM_START) fix.smem_start = 0; unlock_fb_info(info); ret = copy_to_user(argp, &fix, sizeof(fix)) ? -EFAULT : 0; break; case FBIOPUTCMAP: if (copy_from_user(&cmap, argp, sizeof(cmap))) return -EFAULT; ret = fb_set_user_cmap(&cmap, info); break; case FBIOGETCMAP: if (copy_from_user(&cmap, argp, sizeof(cmap))) return -EFAULT; lock_fb_info(info); cmap_from = info->cmap; unlock_fb_info(info); ret = fb_cmap_to_user(&cmap_from, &cmap); break; case FBIOPAN_DISPLAY: if (copy_from_user(&var, argp, sizeof(var))) return -EFAULT; console_lock(); lock_fb_info(info); ret = fb_pan_display(info, &var); unlock_fb_info(info); console_unlock(); if (ret == 0 && copy_to_user(argp, &var, sizeof(var))) return -EFAULT; break; case FBIO_CURSOR: ret = -EINVAL; break; case FBIOGET_CON2FBMAP: ret = fbcon_get_con2fb_map_ioctl(argp); break; case FBIOPUT_CON2FBMAP: ret = fbcon_set_con2fb_map_ioctl(argp); break; case FBIOBLANK: if (arg > FB_BLANK_POWERDOWN) return -EINVAL; console_lock(); lock_fb_info(info); ret = fb_blank(info, arg); fbcon_fb_blanked(info, arg); unlock_fb_info(info); console_unlock(); break; default: lock_fb_info(info); fb = info->fbops; if (fb->fb_ioctl) ret = fb->fb_ioctl(info, cmd, arg); else ret = -ENOTTY; unlock_fb_info(info); } return ret; }"
"static RAND_DRBG *rand_drbg_new(int secure, int type, unsigned int flags, RAND_DRBG *parent) { RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg)) : OPENSSL_zalloc(sizeof(*drbg)); if (drbg == NULL) { RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE); return NULL; } drbg->secure = secure && CRYPTO_secure_allocated(drbg); drbg->fork_count = rand_fork_count; drbg->parent = parent; if (parent == NULL) { drbg->get_entropy = rand_drbg_get_entropy; drbg->cleanup_entropy = rand_drbg_cleanup_entropy; #ifndef RAND_DRBG_GET_RANDOM_NONCE drbg->get_nonce = rand_drbg_get_nonce; drbg->cleanup_nonce = rand_drbg_cleanup_nonce; #endif drbg->reseed_interval = master_reseed_interval; drbg->reseed_time_interval = master_reseed_time_interval; } else { drbg->get_entropy = rand_drbg_get_entropy; drbg->cleanup_entropy = rand_drbg_cleanup_entropy; drbg->reseed_interval = slave_reseed_interval; drbg->reseed_time_interval = slave_reseed_time_interval; } if (RAND_DRBG_set(drbg, type, flags) == 0) goto err; if (parent != NULL) { rand_drbg_lock(parent); if (drbg->strength > parent->strength) { rand_drbg_unlock(parent); RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK); goto err; } rand_drbg_unlock(parent); } return drbg; err: RAND_DRBG_free(drbg); return NULL; }"
"static bool check_allocations(ASS_Shaper *shaper, size_t new_size) { if (new_size > shaper->n_glyphs) { if (!ASS_REALLOC_ARRAY(shaper->event_text, new_size) || !ASS_REALLOC_ARRAY(shaper->ctypes, new_size) || !ASS_REALLOC_ARRAY(shaper->emblevels, new_size) || !ASS_REALLOC_ARRAY(shaper->cmap, new_size)) return false; } return true; }"
"std::string queueloader::get_filename(const std::string& str) { std::string fn = ctrl->get_dlpath(); if (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0]) fn.append(NEWSBEUTER_PATH_SEP); char buf[1024]; snprintf(buf, sizeof(buf), ""%s"", str.c_str()); char * base = basename(buf); if (!base || strlen(base) == 0) { char lbuf[128]; time_t t = time(NULL); strftime(lbuf, sizeof(lbuf), ""%Y-%b-%d-%H%M%S.unknown"", localtime(&t)); fn.append(lbuf); } else { fn.append(base); } return fn; }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"char* url::get_pac() { int sock = -1; bool chunked = false; unsigned long int content_length = 0, status = 0; char* buffer = NULL; string request; if (m_scheme == ""file"" || m_scheme == ""pac+file"") { struct stat st; if ((sock = ::open(m_path.c_str(), O_RDONLY)) < 0) return NULL; if (!fstat(sock, &st) && st.st_size < PAC_MAX_SIZE) { buffer = new char[st.st_size+1]; memset(buffer, 0, st.st_size+1); if (read(sock, buffer, st.st_size) == 0) { delete[] buffer; buffer = NULL; } } close(sock); return buffer; } if (!get_ips(true)) return NULL; for (int i=0 ; m_ips[i] ; i++) { sock = socket(m_ips[i]->sa_family, SOCK_STREAM, 0); if (sock < 0) continue; if (m_ips[i]->sa_family == AF_INET && !connect(sock, m_ips[i], sizeof(struct sockaddr_in))) break; else if (m_ips[i]->sa_family == AF_INET6 && !connect(sock, m_ips[i], sizeof(struct sockaddr_in6))) break; closesocket(sock); sock = -1; } if (sock < 0) return NULL; request  = ""GET "" + (m_path.size() > 0 ? m_path : ""/"") + m_query + "" HTTP/1.1\r\n""; request += ""Host: "" + m_host + ""\r\n""; request += ""Accept: "" + string(PAC_MIME_TYPE) + ""\r\n""; request += ""Connection: close\r\n""; request += ""\r\n""; if ((size_t) send(sock, request.c_str(), request.size(), 0) != request.size()) { closesocket(sock); return NULL; } string line = recvline(sock); if (sscanf(line.c_str(), ""HTTP/1.%*d %lu"", &status) == 1 && status == 200) { content_length = 0; for (line = recvline(sock) ; line != ""\r"" && line != """" ; line = recvline(sock)) { if (line.find(""Content-Transfer-Encoding: chunked"") == 0 || line.find(""Transfer-Encoding: chunked"") == 0) chunked = true; else if (content_length == 0) sscanf(line.c_str(), ""Content-Length: %lu"", &content_length); } unsigned int recvd = 0; buffer = new char[PAC_MAX_SIZE]; memset(buffer, 0, PAC_MAX_SIZE); do { unsigned int chunk_length; if (chunked) { if (recvd > 0) recvline(sock); if (sscanf(recvline(sock).c_str(), ""%x"", &chunk_length) != 1 || chunk_length == 0) break; content_length += chunk_length; } if (content_length >= PAC_MAX_SIZE) break; while (content_length == 0 || recvd != content_length) { int r = recv(sock, buffer + recvd, content_length == 0 ? PAC_HTTP_BLOCK_SIZE : content_length - recvd, 0); if (r <= 0) { chunked = false; break; } recvd += r; } } while (chunked); if (content_length != 0 && string(buffer).size() != content_length) { delete[] buffer; buffer = NULL; } } shutdown(sock, SHUT_RDWR); closesocket(sock); return buffer; }"
"njs_ret_t njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend, uint32_t append) { uint64_t     size; njs_value_t  *start, *old; size = (uint64_t) append + array->length; if (nxt_fast_path(size <= array->size && prepend == 0)) { return NXT_OK; } if (size < 16) { size *= 2; } else { size += size / 2; } if (nxt_slow_path((prepend + size) > NJS_ARRAY_MAX_LENGTH)) { goto memory_error; } start = nxt_mp_align(vm->mem_pool, sizeof(njs_value_t), (prepend + size) * sizeof(njs_value_t)); if (nxt_slow_path(start == NULL)) { goto memory_error; } array->size = size; old = array->data; array->data = start; start += prepend; memcpy(start, array->start, array->length * sizeof(njs_value_t)); array->start = start; nxt_mp_free(vm->mem_pool, old); return NXT_OK; memory_error: njs_memory_error(vm); return NXT_ERROR; }"
"static FILE *RK_File(const char *agent, int *agent_id) { int i = 0; char rk_buf[OS_SIZE_1024 + 1]; while (rk_agent_ips[i] != NULL) { if (strcmp(rk_agent_ips[i], agent) == 0) { fseek(rk_agent_fps[i], 0, SEEK_SET); *agent_id = i; return (rk_agent_fps[i]); } i++; } rk_agent_ips[i] = strdup(agent); if (rk_agent_ips[i] != NULL) { snprintf(rk_buf, OS_SIZE_1024, ""%s/%s"", ROOTCHECK_DIR, agent); rk_agent_fps[i] = fopen(rk_buf, ""r+""); if (!rk_agent_fps[i]) { rk_agent_fps[i] = fopen(rk_buf, ""w""); if (rk_agent_fps[i]) { fclose(rk_agent_fps[i]); rk_agent_fps[i] = fopen(rk_buf, ""r+""); } } if (!rk_agent_fps[i]) { merror(FOPEN_ERROR, ARGV0, rk_buf, errno, strerror(errno)); free(rk_agent_ips[i]); rk_agent_ips[i] = NULL; return (NULL); } fseek(rk_agent_fps[i], 0, SEEK_SET); *agent_id = i; return (rk_agent_fps[i]); } else { merror(MEM_ERROR, ARGV0, errno, strerror(errno)); return (NULL); } return (NULL); }"
"static int print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length) { int plenbytes; char buf[sizeof(""xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128"")]; if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 && is_ipv4_mapped_address(&prefix[1])) { struct in_addr addr; u_int plen; plen = prefix[0]-96; if (32 < plen) return -1; max_length -= 1; memset(&addr, 0, sizeof(addr)); plenbytes = (plen + 7) / 8; if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN) return -3; memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes); if (plen % 8) { ((u_char *)&addr)[plenbytes - 1] &= ((0xff00 >> (plen % 8)) & 0xff); } snprintf(buf, sizeof(buf), ""%s/%d"", ipaddr_string(ndo, &addr), plen); plenbytes += 1 + IPV4_MAPPED_HEADING_LEN; } else { plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf)); } ND_PRINT((ndo, ""%s"", buf)); return plenbytes; }"
"static void load_segments(struct vcpu *n) { struct cpu_user_regs *uregs = &n->arch.user_regs; int all_segs_okay = 1; unsigned int dirty_segment_mask, cpu = smp_processor_id(); bool fs_gs_done = false; dirty_segment_mask = per_cpu(dirty_segment_mask, cpu); per_cpu(dirty_segment_mask, cpu) = 0; #ifdef CONFIG_HVM if ( !is_pv_32bit_vcpu(n) && !cpu_has_fsgsbase && cpu_has_svm && !((uregs->fs | uregs->gs) & ~3) && (n->arch.pv.fs_base | n->arch.pv.gs_base_user | n->arch.pv.ldt_ents) ) { unsigned long gsb = n->arch.flags & TF_kernel_mode ? n->arch.pv.gs_base_kernel : n->arch.pv.gs_base_user; unsigned long gss = n->arch.flags & TF_kernel_mode ? n->arch.pv.gs_base_user : n->arch.pv.gs_base_kernel; fs_gs_done = svm_load_segs(n->arch.pv.ldt_ents, LDT_VIRT_START(n), uregs->fs, n->arch.pv.fs_base, uregs->gs, gsb, gss); } #endif if ( !fs_gs_done ) load_LDT(n); if ( unlikely((dirty_segment_mask & DIRTY_DS) | uregs->ds) ) { preload_segment(ds, uregs->ds); all_segs_okay &= loadsegment(ds, uregs->ds); } if ( unlikely((dirty_segment_mask & DIRTY_ES) | uregs->es) ) { preload_segment(es, uregs->es); all_segs_okay &= loadsegment(es, uregs->es); } if ( unlikely((dirty_segment_mask & DIRTY_FS) | uregs->fs) && !fs_gs_done ) { all_segs_okay &= loadsegment(fs, uregs->fs); if ( uregs->fs & ~3 ) dirty_segment_mask &= ~DIRTY_FS_BASE; } if ( unlikely((dirty_segment_mask & DIRTY_GS) | uregs->gs) && !fs_gs_done ) { all_segs_okay &= loadsegment(gs, uregs->gs); if ( uregs->gs & ~3 ) dirty_segment_mask &= ~DIRTY_GS_BASE; } if ( !fs_gs_done && !is_pv_32bit_vcpu(n) ) { if ( n->arch.pv.fs_base | (dirty_segment_mask & DIRTY_FS_BASE) ) wrfsbase(n->arch.pv.fs_base); wrgsshadow(n->arch.pv.gs_base_kernel); if ( n->arch.pv.gs_base_user | (dirty_segment_mask & DIRTY_GS_BASE) ) wrgsbase(n->arch.pv.gs_base_user); if ( (n->arch.flags & TF_kernel_mode) ) asm volatile ( ""swapgs"" ); } if ( unlikely(!all_segs_okay) ) { struct pv_vcpu *pv = &n->arch.pv; struct cpu_user_regs *regs = guest_cpu_user_regs(); unsigned long *rsp = (unsigned long *)(((n->arch.flags & TF_kernel_mode) ? regs->rsp : pv->kernel_sp) & ~0xf); unsigned long cs_and_mask, rflags; rflags  = regs->rflags & ~(X86_EFLAGS_IF|X86_EFLAGS_IOPL); rflags |= !vcpu_info(n, evtchn_upcall_mask) << 9; if ( VM_ASSIST(n->domain, architectural_iopl) ) rflags |= n->arch.pv.iopl; if ( is_pv_32bit_vcpu(n) ) { unsigned int *esp = ring_1(regs) ? (unsigned int *)regs->rsp : (unsigned int *)pv->kernel_sp; int ret = 0; cs_and_mask = (unsigned short)regs->cs | ((unsigned int)vcpu_info(n, evtchn_upcall_mask) << 16); if ( !ring_1(regs) ) { ret  = put_user(regs->ss,       esp-1); ret |= put_user(regs->esp,      esp-2); esp -= 2; } if ( ret | put_user(rflags,              esp-1) | put_user(cs_and_mask,         esp-2) | put_user(regs->eip,           esp-3) | put_user(uregs->gs,           esp-4) | put_user(uregs->fs,           esp-5) | put_user(uregs->es,           esp-6) | put_user(uregs->ds,           esp-7) ) { gprintk(XENLOG_ERR, ""error while creating compat failsafe callback frame\n""); domain_crash(n->domain); } if ( n->arch.vgc_flags & VGCF_failsafe_disables_events ) vcpu_info(n, evtchn_upcall_mask) = 1; regs->entry_vector |= TRAP_syscall; regs->eflags       &= ~(X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT| X86_EFLAGS_IOPL|X86_EFLAGS_TF); regs->ss            = FLAT_COMPAT_KERNEL_SS; regs->esp           = (unsigned long)(esp-7); regs->cs            = FLAT_COMPAT_KERNEL_CS; regs->eip           = pv->failsafe_callback_eip; return; } if ( !(n->arch.flags & TF_kernel_mode) ) toggle_guest_mode(n); else regs->cs &= ~3; cs_and_mask = (unsigned long)regs->cs | ((unsigned long)vcpu_info(n, evtchn_upcall_mask) << 32); if ( put_user(regs->ss,            rsp- 1) | put_user(regs->rsp,           rsp- 2) | put_user(rflags,              rsp- 3) | put_user(cs_and_mask,         rsp- 4) | put_user(regs->rip,           rsp- 5) | put_user(uregs->gs,           rsp- 6) | put_user(uregs->fs,           rsp- 7) | put_user(uregs->es,           rsp- 8) | put_user(uregs->ds,           rsp- 9) | put_user(regs->r11,           rsp-10) | put_user(regs->rcx,           rsp-11) ) { gprintk(XENLOG_ERR, ""error while creating failsafe callback frame\n""); domain_crash(n->domain); } if ( n->arch.vgc_flags & VGCF_failsafe_disables_events ) vcpu_info(n, evtchn_upcall_mask) = 1; regs->entry_vector |= TRAP_syscall; regs->rflags       &= ~(X86_EFLAGS_AC|X86_EFLAGS_VM|X86_EFLAGS_RF| X86_EFLAGS_NT|X86_EFLAGS_IOPL|X86_EFLAGS_TF); regs->ss            = FLAT_KERNEL_SS; regs->rsp           = (unsigned long)(rsp-11); regs->cs            = FLAT_KERNEL_CS; regs->rip           = pv->failsafe_callback_eip; } }"
"SkCodec* SkIcoCodec::NewFromStream(SkStream* stream, Result* result) { std::unique_ptr<SkStream> inputStream(stream); static const uint32_t kIcoDirectoryBytes = 6; static const uint32_t kIcoDirEntryBytes = 16; std::unique_ptr<uint8_t[]> dirBuffer(new uint8_t[kIcoDirectoryBytes]); if (inputStream.get()->read(dirBuffer.get(), kIcoDirectoryBytes) != kIcoDirectoryBytes) { SkCodecPrintf(""Error: unable to read ico directory header.\n""); *result = kIncompleteInput; return nullptr; } const uint16_t numImages = get_short(dirBuffer.get(), 4); if (0 == numImages) { SkCodecPrintf(""Error: No images embedded in ico.\n""); *result = kInvalidInput; return nullptr; } struct Entry { uint32_t offset; uint32_t size; }; SkAutoFree dirEntryBuffer(sk_malloc_flags(sizeof(Entry) * numImages, SK_MALLOC_TEMP)); if (!dirEntryBuffer) { SkCodecPrintf(""Error: OOM allocating ICO directory for %i images.\n"", numImages); *result = kInternalError; return nullptr; } auto* directoryEntries = reinterpret_cast<Entry*>(dirEntryBuffer.get()); for (uint32_t i = 0; i < numImages; i++) { uint8_t entryBuffer[kIcoDirEntryBytes]; if (inputStream->read(entryBuffer, kIcoDirEntryBytes) != kIcoDirEntryBytes) { SkCodecPrintf(""Error: Dir entries truncated in ico.\n""); *result = kIncompleteInput; return nullptr; } uint32_t size = get_int(entryBuffer, 8); uint32_t offset = get_int(entryBuffer, 12); directoryEntries[i].offset = offset; directoryEntries[i].size = size; } *result = kInvalidInput; struct EntryLessThan { bool operator() (Entry a, Entry b) const { return a.offset < b.offset; } }; EntryLessThan lessThan; SkTQSort(directoryEntries, &directoryEntries[numImages - 1], lessThan); uint32_t bytesRead = kIcoDirectoryBytes + numImages * kIcoDirEntryBytes; std::unique_ptr<SkTArray<std::unique_ptr<SkCodec>, true>> codecs( new (SkTArray<std::unique_ptr<SkCodec>, true>)(numImages)); for (uint32_t i = 0; i < numImages; i++) { uint32_t offset = directoryEntries[i].offset; uint32_t size = directoryEntries[i].size; if (offset < bytesRead) { SkCodecPrintf(""Warning: invalid ico offset.\n""); continue; } if (inputStream.get()->skip(offset - bytesRead) != offset - bytesRead) { SkCodecPrintf(""Warning: could not skip to ico offset.\n""); break; } bytesRead = offset; SkAutoFree buffer(sk_malloc_flags(size, 0)); if (!buffer) { SkCodecPrintf(""Warning: OOM trying to create embedded stream.\n""); break; } if (inputStream->read(buffer.get(), size) != size) { SkCodecPrintf(""Warning: could not create embedded stream.\n""); *result = kIncompleteInput; break; } sk_sp<SkData> data(SkData::MakeFromMalloc(buffer.release(), size)); std::unique_ptr<SkMemoryStream> embeddedStream(new SkMemoryStream(data)); bytesRead += size; SkCodec* codec = nullptr; Result dummyResult; if (SkPngCodec::IsPng((const char*) data->bytes(), data->size())) { codec = SkPngCodec::NewFromStream(embeddedStream.release(), &dummyResult); } else { codec = SkBmpCodec::NewFromIco(embeddedStream.release(), &dummyResult); } if (nullptr != codec) { codecs->push_back().reset(codec); } } if (0 == codecs->count()) { SkCodecPrintf(""Error: could not find any valid embedded ico codecs.\n""); return nullptr; } size_t maxSize = 0; int maxIndex = 0; for (int i = 0; i < codecs->count(); i++) { SkImageInfo info = codecs->operator[](i)->getInfo(); size_t size = info.getSafeSize(info.minRowBytes()); if (size > maxSize) { maxSize = size; maxIndex = i; } } int width = codecs->operator[](maxIndex)->getInfo().width(); int height = codecs->operator[](maxIndex)->getInfo().height(); SkEncodedInfo info = codecs->operator[](maxIndex)->getEncodedInfo(); SkColorSpace* colorSpace = codecs->operator[](maxIndex)->getInfo().colorSpace(); *result = kSuccess; return new SkIcoCodec(width, height, info, codecs.release(), sk_ref_sp(colorSpace)); }"
"OPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd, OPJ_BYTE * p_dest, OPJ_UINT32 p_dest_length ) { OPJ_UINT32 i,j,k,l_data_size = 0; opj_image_comp_t * l_img_comp = 00; opj_tcd_tilecomp_t * l_tilec = 00; opj_tcd_resolution_t * l_res; OPJ_UINT32 l_size_comp, l_remaining; OPJ_UINT32 l_stride, l_width,l_height; l_data_size = opj_tcd_get_decoded_tile_size(p_tcd); if (l_data_size > p_dest_length) { return OPJ_FALSE; } l_tilec = p_tcd->tcd_image->tiles->comps; l_img_comp = p_tcd->image->comps; for (i=0;i<p_tcd->image->numcomps;++i) { l_size_comp = l_img_comp->prec >> 3;  l_remaining = l_img_comp->prec & 7;   l_res = l_tilec->resolutions + l_img_comp->resno_decoded; l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0); l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0); l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width; if (l_remaining) { ++l_size_comp; } if (l_size_comp == 3) { l_size_comp = 4; } switch (l_size_comp) { case 1: { OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest; const OPJ_INT32 * l_src_ptr = l_tilec->data; if (l_img_comp->sgnd) { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++)); } l_src_ptr += l_stride; } } else { for (j=0;j<l_height;++j) { for     (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff); } l_src_ptr += l_stride; } } p_dest = (OPJ_BYTE *)l_dest_ptr; } break; case 2: { const OPJ_INT32 * l_src_ptr = l_tilec->data; OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest; if (l_img_comp->sgnd) { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++)); } l_src_ptr += l_stride; } } else { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff); } l_src_ptr += l_stride; } } p_dest = (OPJ_BYTE*) l_dest_ptr; } break; case 4: { OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest; OPJ_INT32 * l_src_ptr = l_tilec->data; for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (*(l_src_ptr++)); } l_src_ptr += l_stride; } p_dest = (OPJ_BYTE*) l_dest_ptr; } break; } ++l_img_comp; ++l_tilec; } return OPJ_TRUE; }"
"GF_EXPORT GF_M2TS_Mux_Stream *gf_m2ts_program_stream_add(GF_M2TS_Mux_Program *program, struct __elementary_stream_ifce *ifce, u32 pid, Bool is_pcr, Bool force_pes) { GF_M2TS_Mux_Stream *stream, *st; stream = gf_m2ts_stream_new(pid); stream->ifce = ifce; stream->pid = pid; stream->program = program; if (is_pcr) program->pcr = stream; stream->loop_descriptors = gf_list_new(); stream->set_initial_disc = program->initial_disc_set; if (program->streams) { if (is_pcr) { stream->next = program->streams; program->streams = stream; } else { st = program->streams; while (st->next) st = st->next; st->next = stream; } } else { program->streams = stream; } if (program->pmt) program->pmt->table_needs_update = GF_TRUE; stream->bit_rate = ifce->bit_rate; stream->scheduling_priority = 1; stream->force_single_au = (stream->program->mux->au_pes_mode == GF_M2TS_PACK_ALL) ? GF_FALSE : GF_TRUE; switch (ifce->stream_type) { case GF_STREAM_VISUAL: stream->mpeg2_stream_id = 0xE0; stream->prevent_two_au_start_in_pes = GF_TRUE; switch (ifce->object_type_indication) { case GPAC_OTI_VIDEO_MPEG4_PART2: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG4; break; case GPAC_OTI_VIDEO_AVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_H264; stream->min_bytes_copy_from_next = 11; break; case GPAC_OTI_VIDEO_SVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_SVC; stream->min_bytes_copy_from_next = 11; gf_m2ts_stream_add_hierarchy_descriptor(stream); break; case GPAC_OTI_VIDEO_HEVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_HEVC; if (ifce->depends_on_stream) { GF_M2TS_Mux_Stream *base_st; stream->mpeg2_stream_type = GF_M2TS_VIDEO_HEVC_TEMPORAL; gf_m2ts_stream_add_hierarchy_descriptor(stream); stream->force_single_au = GF_TRUE; base_st = gf_m2ts_find_stream(program, 0, ifce->depends_on_stream); if (base_st) base_st->force_single_au = GF_TRUE; } stream->min_bytes_copy_from_next = 12; break; case GPAC_OTI_VIDEO_LHVC: stream->mpeg2_stream_type = GF_M2TS_VIDEO_SHVC; stream->min_bytes_copy_from_next = 12; gf_m2ts_stream_add_hierarchy_descriptor(stream); stream->force_single_au = GF_TRUE; break; case GPAC_OTI_VIDEO_MPEG1: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG1; break; case GPAC_OTI_VIDEO_MPEG2_SIMPLE: case GPAC_OTI_VIDEO_MPEG2_MAIN: case GPAC_OTI_VIDEO_MPEG2_SNR: case GPAC_OTI_VIDEO_MPEG2_SPATIAL: case GPAC_OTI_VIDEO_MPEG2_HIGH: case GPAC_OTI_VIDEO_MPEG2_422: stream->mpeg2_stream_type = GF_M2TS_VIDEO_MPEG2; break; case GPAC_OTI_IMAGE_JPEG: case GPAC_OTI_IMAGE_PNG: stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; stream->mpeg2_stream_id = 0xFA; gf_m2ts_stream_set_default_slconfig(stream); break; default: break; } break; case GF_STREAM_AUDIO: stream->force_single_au = (stream->program->mux->au_pes_mode == GF_M2TS_PACK_NONE) ? GF_TRUE : GF_FALSE; switch (ifce->object_type_indication) { case GPAC_OTI_AUDIO_MPEG1: stream->mpeg2_stream_type = GF_M2TS_AUDIO_MPEG1; break; case GPAC_OTI_AUDIO_MPEG2_PART3: stream->mpeg2_stream_type = GF_M2TS_AUDIO_MPEG2; break; case GPAC_OTI_AUDIO_AAC_MPEG4: case GPAC_OTI_AUDIO_AAC_MPEG2_MP: case GPAC_OTI_AUDIO_AAC_MPEG2_LCP: case GPAC_OTI_AUDIO_AAC_MPEG2_SSRP: stream->mpeg2_stream_type = GF_M2TS_AUDIO_LATM_AAC; stream->mpeg2_stream_type = GF_M2TS_AUDIO_AAC; if (!ifce->repeat_rate) ifce->repeat_rate = 500; break; case GPAC_OTI_AUDIO_AC3: stream->mpeg2_stream_type = GF_M2TS_AUDIO_AC3; break; } stream->mpeg2_stream_id = 0xC0; break; case GF_STREAM_OD: stream->scheduling_priority = 20; stream->mpeg2_stream_id = 0xFA; stream->table_id = GF_M2TS_TABLE_ID_MPEG4_OD; gf_m2ts_stream_set_default_slconfig(stream); if (force_pes) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; } else { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_SECTIONS; } break; case GF_STREAM_SCENE: stream->mpeg2_stream_id = 0xFA; stream->table_id = GF_M2TS_TABLE_ID_MPEG4_BIFS; gf_m2ts_stream_set_default_slconfig(stream); if (force_pes) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; } else { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_SECTIONS; } break; case GF_STREAM_TEXT: stream->mpeg2_stream_id = 0xBD; stream->mpeg2_stream_type = GF_M2TS_METADATA_PES; gf_m2ts_stream_add_metadata_pointer_descriptor(stream->program); gf_m2ts_stream_add_metadata_descriptor(stream); } if (! (ifce->caps & GF_ESI_STREAM_WITHOUT_MPEG4_SYSTEMS)) { if (program->mpeg4_signaling==GF_M2TS_MPEG4_SIGNALING_FULL) { if (stream->mpeg2_stream_type != GF_M2TS_SYSTEMS_MPEG4_SECTIONS) { stream->mpeg2_stream_type = GF_M2TS_SYSTEMS_MPEG4_PES; stream->force_single_au = GF_TRUE; stream->mpeg2_stream_id = 0xFA; gf_m2ts_stream_set_default_slconfig(stream); } } } stream->ifce->output_ctrl = gf_m2ts_output_ctrl; stream->ifce->output_udta = stream; stream->mx = gf_mx_new(""M2TS PID""); if (ifce->timescale != 90000) { stream->ts_scale.num = 90000; stream->ts_scale.den = ifce->timescale; } return stream; }"
"static gboolean polkit_backend_interactive_authority_authentication_agent_response (PolkitBackendAuthority   *authority, PolkitSubject            *caller, uid_t                     uid, const gchar              *cookie, PolkitIdentity           *identity, GError                  **error) { PolkitBackendInteractiveAuthority *interactive_authority; PolkitBackendInteractiveAuthorityPrivate *priv; PolkitIdentity *user_of_caller; gchar *identity_str; AuthenticationSession *session; GList *l; gboolean ret; interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority); priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority); ret = FALSE; user_of_caller = NULL; identity_str = polkit_identity_to_string (identity); g_debug (""In authentication_agent_response for cookie '%s' and identity %s"", cookie, identity_str); user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, error); if (user_of_caller == NULL) goto out; if (!identity_is_root_user (user_of_caller)) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""Only uid 0 may invoke this method. This incident has been logged.""); goto out; } session = get_authentication_session_for_uid_and_cookie (interactive_authority, uid, cookie); if (session == NULL) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""No session for cookie""); goto out; } for (l = session->identities; l != NULL; l = l->next) { PolkitIdentity *i = POLKIT_IDENTITY (l->data); if (polkit_identity_equal (i, identity)) break; } if (l == NULL) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""The authenticated identity is wrong""); goto out; } session->is_authenticated = TRUE; session->authenticated_identity = g_object_ref (identity); ret = TRUE; out: g_free (identity_str); if (user_of_caller != NULL) g_object_unref (user_of_caller); return ret; }"
"static void removeduplicateobjs(fz_context *ctx, pdf_document *doc, pdf_write_state *opts) { int num, other; int xref_len = pdf_xref_len(ctx, doc); for (num = 1; num < xref_len; num++) { for (other = 1; other < num; other++) { pdf_obj *a, *b; int newnum, streama = 0, streamb = 0, differ = 0; if (num == other || !opts->use_list[num] || !opts->use_list[other]) continue; fz_try(ctx) { streama = pdf_obj_num_is_stream(ctx, doc, num); streamb = pdf_obj_num_is_stream(ctx, doc, other); differ = streama || streamb; if (streama && streamb && opts->do_garbage >= 4) differ = 0; } fz_catch(ctx) { differ = 1; } if (differ) continue; a = pdf_get_xref_entry(ctx, doc, num)->obj; b = pdf_get_xref_entry(ctx, doc, other)->obj; if (pdf_objcmp(ctx, a, b)) continue; if (streama && streamb) { fz_buffer *sa = NULL; fz_buffer *sb = NULL; fz_var(sa); fz_var(sb); differ = 1; fz_try(ctx) { unsigned char *dataa, *datab; size_t lena, lenb; sa = pdf_load_raw_stream_number(ctx, doc, num); sb = pdf_load_raw_stream_number(ctx, doc, other); lena = fz_buffer_storage(ctx, sa, &dataa); lenb = fz_buffer_storage(ctx, sb, &datab); if (lena == lenb && memcmp(dataa, datab, lena) == 0) differ = 0; } fz_always(ctx) { fz_drop_buffer(ctx, sa); fz_drop_buffer(ctx, sb); } fz_catch(ctx) { fz_rethrow(ctx); } if (differ) continue; } newnum = fz_mini(num, other); opts->renumber_map[num] = newnum; opts->renumber_map[other] = newnum; opts->rev_renumber_map[newnum] = num;  opts->use_list[fz_maxi(num, other)] = 0; break; } } }"
"bool http_parser::parse_chunk_header(buffer::const_interval buf , boost::int64_t* chunk_size, int* header_size) { char const* pos = buf.begin; if (pos < buf.end && pos[0] == '\r') ++pos; if (pos < buf.end && pos[0] == '\n') ++pos; if (pos == buf.end) return false; char const* newline = std::find(pos, buf.end, '\n'); if (newline == buf.end) return false; ++newline; *chunk_size = strtoll(pos, 0, 16); if (*chunk_size != 0) { *header_size = newline - buf.begin; TORRENT_ASSERT(newline - buf.begin > 2); return true; } std::map<std::string, std::string> tail_headers; pos = newline; newline = std::find(pos, buf.end, '\n'); std::string line; while (newline != buf.end) { char const* line_end = newline; if (pos != line_end && *(line_end - 1) == '\r') --line_end; line.assign(pos, line_end); ++newline; pos = newline; std::string::size_type separator = line.find(':'); if (separator == std::string::npos) { *header_size = newline - buf.begin; TORRENT_ASSERT(newline - buf.begin > 2); for (std::map<std::string, std::string>::const_iterator i = tail_headers.begin(); i != tail_headers.end(); ++i) m_header.insert(std::make_pair(i->first, i->second)); return true; } std::string name = line.substr(0, separator); std::transform(name.begin(), name.end(), name.begin(), &to_lower); ++separator; while (separator < line.size() && (line[separator] == ' ' || line[separator] == '\t')) ++separator; std::string value = line.substr(separator, std::string::npos); tail_headers.insert(std::make_pair(name, value)); newline = std::find(pos, buf.end, '\n'); } return false; }"
"CallResult<HermesValue> hermesBuiltinApply(void *, Runtime *runtime, NativeArgs args) { GCScopeMarkerRAII marker{runtime}; Handle<Callable> fn = args.dyncastArg<Callable>(0); if (LLVM_UNLIKELY(!fn)) { return runtime->raiseTypeErrorForValue( args.getArgHandle(0), "" is not a function""); } Handle<JSArray> argArray = args.dyncastArg<JSArray>(1); if (LLVM_UNLIKELY(!argArray)) { return runtime->raiseTypeError(""args must be an array""); } uint32_t len = JSArray::getLength(*argArray); bool isConstructor = args.getArgCount() == 2; MutableHandle<> thisVal{runtime}; if (isConstructor) { auto thisValRes = Callable::createThisForConstruct(fn, runtime); if (LLVM_UNLIKELY(thisValRes == ExecutionStatus::EXCEPTION)) { return ExecutionStatus::EXCEPTION; } thisVal = *thisValRes; } else { thisVal = args.getArg(2); } ScopedNativeCallFrame newFrame{ runtime, len, *fn, isConstructor, thisVal.getHermesValue()}; for (uint32_t i = 0; i < len; ++i) { newFrame->getArgRef(i) = argArray->at(runtime, i); } return isConstructor ? Callable::construct(fn, runtime, thisVal) : Callable::call(fn, runtime); }"
"void JsonApiJob::start() { addRawHeader(""OCS-APIREQUEST"", ""true""); auto query = _additionalParams; query.addQueryItem(QLatin1String(""format""), QLatin1String(""json"")); QUrl url = Utility::concatUrlPath(account()->url(), path(), query); const auto httpVerb = verbToString(); if (!_body.isEmpty()) { sendRequest(httpVerb, url, _request, _body); } else { sendRequest(httpVerb, url, _request); } AbstractNetworkJob::start(); }"
"PJ_DEF(pj_status_t) pjsip_auth_create_aka_response(  pj_pool_t *pool, const pjsip_digest_challenge *chal, const pjsip_cred_info *cred, const pj_str_t *method, pjsip_digest_credential *auth) { pj_str_t nonce_bin; int aka_version; const pj_str_t pjsip_AKAv1_MD5 = { ""AKAv1-MD5"", 9 }; const pj_str_t pjsip_AKAv2_MD5 = { ""AKAv2-MD5"", 9 }; pj_uint8_t *chal_rand, *chal_sqnxoraka, *chal_mac; pj_uint8_t k[PJSIP_AKA_KLEN]; pj_uint8_t op[PJSIP_AKA_OPLEN]; pj_uint8_t amf[PJSIP_AKA_AMFLEN]; pj_uint8_t res[PJSIP_AKA_RESLEN]; pj_uint8_t ck[PJSIP_AKA_CKLEN]; pj_uint8_t ik[PJSIP_AKA_IKLEN]; pj_uint8_t ak[PJSIP_AKA_AKLEN]; pj_uint8_t sqn[PJSIP_AKA_SQNLEN]; pj_uint8_t xmac[PJSIP_AKA_MACLEN]; pjsip_cred_info aka_cred; int i, len; pj_status_t status; if (chal->algorithm.slen==0 || pj_stricmp2(&chal->algorithm, ""md5"") == 0) { pjsip_auth_create_digest(&auth->response, &auth->nonce, &auth->nc, &auth->cnonce, &auth->qop, &auth->uri, &auth->realm, cred, method); return PJ_SUCCESS; } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv1_MD5) == 0) { aka_version = 1; } else if (pj_stricmp(&chal->algorithm, &pjsip_AKAv2_MD5) == 0) { aka_version = 2; } else { return PJSIP_EINVALIDALGORITHM; } nonce_bin.slen = len = PJ_BASE64_TO_BASE256_LEN(chal->nonce.slen); nonce_bin.ptr = pj_pool_alloc(pool, nonce_bin.slen + 1); status = pj_base64_decode(&chal->nonce, (pj_uint8_t*)nonce_bin.ptr, &len); nonce_bin.slen = len; if (status != PJ_SUCCESS) return PJSIP_EAUTHINNONCE; if (nonce_bin.slen < PJSIP_AKA_RANDLEN + PJSIP_AKA_AUTNLEN) return PJSIP_EAUTHINNONCE; chal_rand = (pj_uint8_t*)(nonce_bin.ptr + 0); chal_sqnxoraka = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN); chal_mac = (pj_uint8_t*) (nonce_bin.ptr + PJSIP_AKA_RANDLEN +  PJSIP_AKA_SQNLEN + PJSIP_AKA_AMFLEN); pj_bzero(k, sizeof(k)); pj_bzero(op, sizeof(op)); pj_bzero(amf, sizeof(amf)); if (cred->ext.aka.k.slen) pj_memcpy(k, cred->ext.aka.k.ptr, cred->ext.aka.k.slen); if (cred->ext.aka.op.slen) pj_memcpy(op, cred->ext.aka.op.ptr, cred->ext.aka.op.slen); if (cred->ext.aka.amf.slen) pj_memcpy(amf, cred->ext.aka.amf.ptr, cred->ext.aka.amf.slen); f2345(k, chal_rand, res, ck, ik, ak, op); for (i=0; i<PJSIP_AKA_SQNLEN; ++i) sqn[i] = (pj_uint8_t) (chal_sqnxoraka[i] ^ ak[i]); f1(k, chal_rand, sqn, amf, xmac, op); if (pj_memcmp(chal_mac, xmac, PJSIP_AKA_MACLEN) != 0) { return PJSIP_EAUTHINNONCE; } pj_memcpy(&aka_cred, cred, sizeof(aka_cred)); aka_cred.data_type = PJSIP_CRED_DATA_PLAIN_PASSWD; if (aka_version == 1) { aka_cred.data.ptr = (char*)res; aka_cred.data.slen = PJSIP_AKA_RESLEN; pjsip_auth_create_digest(&auth->response, &chal->nonce,  &auth->nc, &auth->cnonce, &auth->qop,  &auth->uri, &chal->realm, &aka_cred, method); } else if (aka_version == 2) { pj_str_t resikck; const pj_str_t AKAv2_Passwd = { ""http-digest-akav2-password"", 26 }; pj_uint8_t hmac_digest[16]; char tmp_buf[48]; int hmac64_len; resikck.slen = PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN + PJSIP_AKA_CKLEN; pj_assert(resikck.slen <= PJ_ARRAY_SIZE(tmp_buf)); resikck.ptr = tmp_buf; pj_memcpy(resikck.ptr + 0, res, PJSIP_AKA_RESLEN); pj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN, ik, PJSIP_AKA_IKLEN); pj_memcpy(resikck.ptr + PJSIP_AKA_RESLEN + PJSIP_AKA_IKLEN, ck, PJSIP_AKA_CKLEN); pj_hmac_md5((const pj_uint8_t*)AKAv2_Passwd.ptr, AKAv2_Passwd.slen, (const pj_uint8_t*)resikck.ptr, resikck.slen, hmac_digest); aka_cred.data.slen = hmac64_len = PJ_BASE256_TO_BASE64_LEN(PJ_ARRAY_SIZE(hmac_digest)); pj_assert(aka_cred.data.slen+1 <= PJ_ARRAY_SIZE(tmp_buf)); aka_cred.data.ptr = tmp_buf; pj_base64_encode(hmac_digest, PJ_ARRAY_SIZE(hmac_digest), aka_cred.data.ptr, &len); aka_cred.data.slen = hmac64_len; pjsip_auth_create_digest(&auth->response, &chal->nonce,  &auth->nc, &auth->cnonce, &auth->qop,  &auth->uri, &chal->realm, &aka_cred, method); } else { pj_assert(!""Bug!""); return PJ_EBUG; } return PJ_SUCCESS; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& input = ctx->input(0); const float input_min_float = ctx->input(1).flat<float>()(0); const float input_max_float = ctx->input(2).flat<float>()(0); Tensor* output_min = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min)); Tensor* output_max = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max)); qint32 used_min_quantized; qint32 used_max_quantized; CalculateUsedRange(input, &used_min_quantized, &used_max_quantized); const float used_min_float = std::min( 0.0f, QuantizedToFloat(used_min_quantized, input_min_float, input_max_float)); const float used_max_float = QuantizedToFloat(used_max_quantized, input_min_float, input_max_float); output_min->flat<float>().setConstant(used_min_float); output_max->flat<float>().setConstant(used_max_float); }"
"int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = NULL; rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); int rc = 0; int fx = -1; int fc = rpmfilesFC(files); int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firstlinkfile = -1; char *tid = NULL; struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata)); struct filedata_s *firstlink = NULL; struct diriter_s di = { -1 }; rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); fi = rpmfilesIter(files, RPMFI_ITER_FWD); while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (rpmfiFFlags(fi) & RPMFILE_GHOST) fp->action = FA_SKIP; else fp->action = rpmfsGetAction(fs, fx); fp->skip = XFA_SKIPPING(fp->action); if (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi))) fp->suffix = tid; fp->fpath = fsmFsPath(fi, fp->suffix); rc = rpmfiStat(fi, 1, &fp->sb); fp->setmeta = (fp->skip == 0) && (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH); setFileState(fs, fx); fsmDebug(fp->fpath, fp->action, &fp->sb); fp->stage = FILE_PRE; } fi = rpmfiFree(fi); if (rc) goto exit; fi = fsmIter(payload, files, payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di); if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (fp->skip && firstlink && rpmfiArchiveHasContent(fi)) fp = firstlink; if (!fp->skip) { int fd = -1; if (!fp->suffix && fp != firstlink) { rc = fsmBackup(di.dirfd, fi, fp->action); } if (!rc) { rc = ensureDir(plugins, rpmfiDN(fi), 0, (fp->action == FA_CREATE), 0, &di.dirfd); } rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath, fp->sb.st_mode, fp->action); if (rc) goto setmeta;  if (!fp->suffix) { if (fp->action == FA_TOUCH) { struct stat sb; rc = fsmStat(di.dirfd, fp->fpath, 1, &sb); } else { rc = fsmVerify(di.dirfd, fp->fpath, fi); } } else { rc = RPMERR_ENOENT; } if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) { rpmlog(RPMLOG_DEBUG, ""file %s vanished unexpectedly\n"", fp->fpath); fp->action = FA_CREATE; fsmDebug(fp->fpath, fp->action, &fp->sb); } if (fp->action == FA_TOUCH) goto setmeta; if (S_ISREG(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest, &firstlink, &firstlinkfile, &fd); } } else if (S_ISDIR(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = fp->sb.st_mode; mode &= ~07777; mode |=  00700; rc = fsmMkdir(di.dirfd, fp->fpath, mode); } } else if (S_ISLNK(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath); } } else if (S_ISFIFO(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(di.dirfd, fp->fpath, 0000); } } else if (S_ISCHR(fp->sb.st_mode) || S_ISBLK(fp->sb.st_mode) || S_ISSOCK(fp->sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev); } } else { if (!IS_DEV_LOG(fp->fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } setmeta: if (!rc && fp->setmeta) { rc = fsmSetmeta(fd, di.dirfd, fp->fpath, fi, plugins, fp->action, &fp->sb, nofcaps); } if (fd != firstlinkfile) fsmClose(&fd); } if (rc) *failedFile = xstrdup(fp->fpath); else rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); fp->stage = FILE_UNPACK; } fi = fsmIterFini(fi, &di); if (!rc && fx < 0 && fx != RPMERR_ITER_END) rc = fx; fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di); while (!rc && (fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (!fp->skip) { if (!rc) rc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd); if (!rc && fp->suffix) rc = fsmBackup(di.dirfd, fi, fp->action); if (!rc) rc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix); if (!rc) fp->stage = FILE_COMMIT; else *failedFile = xstrdup(fp->fpath); rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath, fp->sb.st_mode, fp->action, rc); } } fi = fsmIterFini(fi, &di); if (rc) { fi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di); while ((fx = rpmfiNext(fi)) >= 0) { struct filedata_s *fp = &fdata[fx]; if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd)) continue; if (fp->stage > FILE_NONE && !fp->skip) { (void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode); } } } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: fi = fsmIterFini(fi, &di); Fclose(payload); free(tid); for (int i = 0; i < fc; i++) free(fdata[i].fpath); free(fdata); return rc; }"
"static float vips_mask_point( VipsPoint *point, int x, int y ) { VipsMask *mask = VIPS_MASK( point );  VipsMaskClass *class = VIPS_MASK_GET_CLASS( point );  int half_width = point->width / 2; int half_height = point->height / 2; double result; if( !mask->optical ) { x = (x + half_width) % point->width; y = (y + half_height) % point->height; } x = x - half_width; y = y - half_height; if( !mask->nodc &&  x == 0 && y == 0 ) result = 1.0; else { double dx, dy; dx = (double) x / half_width; dy = (double) y / half_height; result = class->point( mask, dx, dy ); if( mask->reject ) result = 1.0 - result; } return( result );  }"
void usb_serial_console_disconnect(struct usb_serial *serial) { if (serial->port[0] == usbcons_info.port) { usb_serial_console_exit(); usb_serial_put(serial); } }
"void goto_tabpage_tp( tabpage_T*tp, inttrigger_enter_autocmds, inttrigger_leave_autocmds) { set_keep_msg(NULL, 0); if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer, trigger_leave_autocmds) == OK) { if (valid_tabpage(tp)) enter_tabpage(tp, curbuf, trigger_enter_autocmds, trigger_leave_autocmds); else enter_tabpage(curtab, curbuf, trigger_enter_autocmds, trigger_leave_autocmds); } }"
"static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) { int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj); if (len <= 0) return JSI_OK; Jsi_RC rc = JSI_OK; int clen = jsi_SizeOfArray(interp, nobj); for (i = 0; i < len && rc == JSI_OK; i++) { Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i); if (t && depth>0 && Jsi_ValueIsArray(interp, t)) rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1); else if (!Jsi_ValueIsUndef(interp, t)) Jsi_ObjArrayAdd(interp, nobj, t); if ((++n + clen)>interp->maxArrayList) return Jsi_LogError(""array size exceeded""); } return rc; }"
"PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr, pjsip_transport_type_e type, const pj_sockaddr_t *remote, int addr_len, const pjsip_tpselector *sel, pjsip_tx_data *tdata, pjsip_transport **tp) { pjsip_tpfactory *factory; pj_status_t status; TRACE_((THIS_FILE,""Acquiring transport type=%s, sel=%s remote=%s:%d"", pjsip_transport_get_type_name(type), print_tpsel_info(sel), addr_string(remote), pj_sockaddr_get_port(remote))); pj_lock_acquire(mgr->lock); if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT && sel->u.transport)  { pjsip_transport *seltp = sel->u.transport; if (seltp->key.type != type) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""Transport type in tpsel not matched"")); return PJSIP_ETPNOTSUITABLE; } if (seltp->is_destroying) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE,""Transport to be acquired is being destroyed"")); return PJ_ENOTFOUND; } pjsip_transport_add_ref(seltp); pj_lock_release(mgr->lock); *tp = seltp; TRACE_((THIS_FILE, ""Transport %s acquired"", seltp->obj_name)); return PJ_SUCCESS; } else { pjsip_transport_key key; int key_len; pjsip_transport *tp_ref = NULL; transport *tp_entry = NULL; if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { if (sel->u.listener->type != type) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""Listener type in tpsel not matched"")); return PJSIP_ETPNOTSUITABLE; } } if (!sel || sel->disable_connection_reuse == PJ_FALSE) { pj_bzero(&key, sizeof(key)); key_len = sizeof(key.type) + addr_len; key.type = type; pj_memcpy(&key.rem_addr, remote, addr_len); tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { transport *tp_iter = tp_entry; do { if (!tp_iter->tp->is_shutdown && !tp_iter->tp->is_destroying) { if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { if (tp_iter->tp->factory == sel->u.listener) { tp_ref = tp_iter->tp; break; } } else { tp_ref = tp_iter->tp; break; } } tp_iter = tp_iter->next; } while (tp_iter != tp_entry); } } if (tp_ref == NULL && (!sel || sel->disable_connection_reuse == PJ_FALSE)) { unsigned flag = pjsip_transport_get_flag_from_type(type); const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote; if (type == PJSIP_TRANSPORT_LOOP || type == PJSIP_TRANSPORT_LOOP_DGRAM) { pj_sockaddr *addr = &key.rem_addr; pj_bzero(addr, addr_len); key_len = sizeof(key.type) + addr_len; tp_entry = (transport *) pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { tp_ref = tp_entry->tp; } } else if (flag & PJSIP_TRANSPORT_DATAGRAM) { pj_sockaddr *addr = &key.rem_addr; pj_bzero(addr, addr_len); addr->addr.sa_family = remote_addr->addr.sa_family; key_len = sizeof(key.type) + addr_len; tp_entry = (transport *) pj_hash_get(mgr->table, &key, key_len, NULL); if (tp_entry) { tp_ref = tp_entry->tp; } } } else if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener && tp_ref->factory != sel->u.listener) { tp_ref = NULL; TRACE_((THIS_FILE, ""Transport found but from different listener"")); } if (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) { pjsip_transport_add_ref(tp_ref); pj_lock_release(mgr->lock); *tp = tp_ref; TRACE_((THIS_FILE, ""Transport %s acquired"", tp_ref->obj_name)); return PJ_SUCCESS; } if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener) { factory = sel->u.listener; if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) { pj_lock_release(mgr->lock); PJ_LOG(3,(THIS_FILE, ""Specified factory for creating "" ""transport is not found"")); return PJ_ENOTFOUND; } } else { factory = mgr->factory_list.next; while (factory != &mgr->factory_list) { if (factory->type == type) break; factory = factory->next; } if (factory == &mgr->factory_list) { pj_lock_release(mgr->lock); TRACE_((THIS_FILE, ""No suitable factory was found either"")); return PJSIP_EUNSUPTRANSPORT; } } } TRACE_((THIS_FILE, ""Creating new transport from factory"")); if (factory->create_transport2) { status = factory->create_transport2(factory, mgr, mgr->endpt, (const pj_sockaddr*) remote, addr_len, tdata, tp); } else { status = factory->create_transport(factory, mgr, mgr->endpt, (const pj_sockaddr*) remote, addr_len, tp); } if (status == PJ_SUCCESS) { PJ_ASSERT_ON_FAIL(tp!=NULL, {pj_lock_release(mgr->lock); return PJ_EBUG;}); pjsip_transport_add_ref(*tp); (*tp)->factory = factory; }"
"Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) { if (t.shape() == TensorShape({})) { if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) || (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) { *out = PartialTensorShape(); return OkStatus(); } return errors::InvalidArgument( ""The only valid scalar shape tensor is the fully unknown shape "" ""specified as -1.""); } if (t.dtype() == DT_INT32) { return PartialTensorShape::MakePartialShape(t.vec<int32>().data(), t.NumElements(), out); } else if (t.dtype() == DT_INT64) { return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(), t.NumElements(), out); } return errors::InvalidArgument( ""Expected an int32 or int64 shape tensor; found "", DataTypeString(t.dtype())); }"
"static void exif_iif_add_value(image_info_type *image_info, int section_index, char *name, int tag, int format, int length, void* value, int motorola_intel) { size_t idex; void *vptr; image_info_value *info_value; image_info_data  *info_data; image_info_data  *list; if (length < 0) { return; } list = safe_erealloc(image_info->info_list[section_index].list, (image_info->info_list[section_index].count+1), sizeof(image_info_data), 0); image_info->info_list[section_index].list = list; info_data  = &image_info->info_list[section_index].list[image_info->info_list[section_index].count]; memset(info_data, 0, sizeof(image_info_data)); info_data->tag    = tag; info_data->format = format; info_data->length = length; info_data->name   = estrdup(name); info_value        = &info_data->value; switch (format) { case TAG_FMT_STRING: if (value) { length = php_strnlen(value, length); info_value->s = estrndup(value, length); info_data->length = length; } else { info_data->length = 0; info_value->s = estrdup(""""); } break; default: info_data->tag = TAG_FMT_UNDEFINED; case TAG_FMT_SBYTE: case TAG_FMT_BYTE: if (!length) break; case TAG_FMT_UNDEFINED: if (value) { if (tag == TAG_MAKER_NOTE) { length = (int) php_strnlen(value, length); } info_value->s = estrndup(value, length); info_data->length = length; } else { info_data->length = 0; info_value->s = estrdup(""""); } break; case TAG_FMT_USHORT: case TAG_FMT_ULONG: case TAG_FMT_URATIONAL: case TAG_FMT_SSHORT: case TAG_FMT_SLONG: case TAG_FMT_SRATIONAL: case TAG_FMT_SINGLE: case TAG_FMT_DOUBLE: if (length==0) { break; } else if (length>1) { info_value->list = safe_emalloc(length, sizeof(image_info_value), 0); } else { info_value = &info_data->value; } for (idex=0,vptr=value; idex<(size_t)length; idex++,vptr=(char *) vptr + php_tiff_bytes_per_format[format]) { if (length>1) { info_value = &info_data->value.list[idex]; } switch (format) { case TAG_FMT_USHORT: info_value->u = php_ifd_get16u(vptr, motorola_intel); break; case TAG_FMT_ULONG: info_value->u = php_ifd_get32u(vptr, motorola_intel); break; case TAG_FMT_URATIONAL: info_value->ur.num = php_ifd_get32u(vptr, motorola_intel); info_value->ur.den = php_ifd_get32u(4+(char *)vptr, motorola_intel); break; case TAG_FMT_SSHORT: info_value->i = php_ifd_get16s(vptr, motorola_intel); break; case TAG_FMT_SLONG: info_value->i = php_ifd_get32s(vptr, motorola_intel); break; case TAG_FMT_SRATIONAL: info_value->sr.num = php_ifd_get32u(vptr, motorola_intel); info_value->sr.den = php_ifd_get32u(4+(char *)vptr, motorola_intel); break; case TAG_FMT_SINGLE: #ifdef EXIF_DEBUG php_error_docref(NULL, E_WARNING, ""Found value of type single""); #endif info_value->f = *(float *)value; case TAG_FMT_DOUBLE: #ifdef EXIF_DEBUG php_error_docref(NULL, E_WARNING, ""Found value of type double""); #endif info_value->d = *(double *)value; break; } } } image_info->sections_found |= 1<<section_index; image_info->info_list[section_index].count++; }"
void * alloc_top(size_t size) { top -= size; if (top < bottom) {new_chunk(); top -= size;} return top; }
"Value GetValueOrCreatePlaceholder(StringRef full_name) { StringRef node_name; StringRef output_name = """"; bool is_control_dep = full_name[0] == '^'; int output_num = 0; if (is_control_dep) full_name = full_name.drop_front(); { size_t colon_sep = full_name.find_first_of(':'); if (colon_sep == StringRef::npos) { node_name = full_name; } else { node_name = full_name.take_front(colon_sep); output_name = full_name.drop_front(colon_sep + 1); } colon_sep = output_name.find_last_of(':'); if (colon_sep != StringRef::npos) { unsigned long long value; if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1), 10, value)) output_num = value; output_name = output_name.take_front(colon_sep); } } llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name]; SmallVector<Value, 1>& base_operation = op_info[""^""]; if (base_operation.empty()) { OperationState state(loc_, mlir_placeholder_); state.addAttribute(TFGraphDialect::getNameAttrKey(), builder_.getStringAttr(node_name)); state.types.push_back(placeholder_ty_); state.types.push_back(control_ty_); Operation* placeholder = builder_.create(state); base_operation.push_back(placeholder->getResult(1)); base_operation.push_back(placeholder->getResult(0)); } if (is_control_dep) return base_operation[0]; SmallVector<Value, 1>& value_info = op_info[output_name]; if (value_info.size() <= output_num) value_info.resize(output_num + 1, Value{}); if (!value_info[output_num]) { value_info[output_num] = builder_.create<GetResultOp>( loc_, base_operation[1], output_name, output_num); } return value_info[output_num]; }"
"static int netlink_dump(struct sock *sk) { struct netlink_sock *nlk = nlk_sk(sk); struct netlink_callback *cb; struct sk_buff *skb = NULL; struct nlmsghdr *nlh; int len, err = -ENOBUFS; int alloc_min_size; int alloc_size; mutex_lock(nlk->cb_mutex); if (!nlk->cb_running) { err = -EINVAL; goto errout_skb; } if (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf) goto errout_skb; cb = &nlk->cb; alloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE); if (alloc_min_size < nlk->max_recvmsg_len) { alloc_size = nlk->max_recvmsg_len; skb = alloc_skb(alloc_size, GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY); } if (!skb) { alloc_size = alloc_min_size; skb = alloc_skb(alloc_size, GFP_KERNEL); } if (!skb) goto errout_skb; skb_reserve(skb, skb_tailroom(skb) - alloc_size); netlink_skb_set_owner_r(skb, sk); len = cb->dump(skb, cb); if (len > 0) { mutex_unlock(nlk->cb_mutex); if (sk_filter(sk, skb)) kfree_skb(skb); else __netlink_sendskb(sk, skb); return 0; } nlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI); if (!nlh) goto errout_skb; nl_dump_check_consistent(cb, nlh); memcpy(nlmsg_data(nlh), &len, sizeof(len)); if (sk_filter(sk, skb)) kfree_skb(skb); else __netlink_sendskb(sk, skb); if (cb->done) cb->done(cb); nlk->cb_running = false; mutex_unlock(nlk->cb_mutex); module_put(cb->module); consume_skb(cb->skb); return 0; errout_skb: mutex_unlock(nlk->cb_mutex); kfree_skb(skb); return err; }"
"static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12) { unsigned long exit_qualification; unsigned int port; int size; if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS)) return nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING); exit_qualification = vmcs_readl(EXIT_QUALIFICATION); port = exit_qualification >> 16; size = (exit_qualification & 7) + 1; return nested_vmx_check_io_bitmaps(vcpu, port, size); }"
"WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec, dec_bit_stream_t *ps_bitstrm) { UWORD32 ui4_payload_type, ui4_payload_size; UWORD32 u4_bits; WORD32 i4_status = 0; do { ui4_payload_type = 0; u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8); while(0xff == u4_bits) { u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8); ui4_payload_type += 255; } ui4_payload_type += u4_bits; ui4_payload_size = 0; u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8); while(0xff == u4_bits) { u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8); ui4_payload_size += 255; } ui4_payload_size += u4_bits; i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type, ui4_payload_size, ps_dec); if(i4_status == -1) { i4_status = 0; break; } if(i4_status != OK) return i4_status; if(ih264d_check_byte_aligned(ps_bitstrm) == 0) { u4_bits = ih264d_get_bit_h264(ps_bitstrm); if(0 == u4_bits) { H264_DEC_DEBUG_PRINT(""\nError in parsing SEI message""); } while(0 == ih264d_check_byte_aligned(ps_bitstrm)) { u4_bits = ih264d_get_bit_h264(ps_bitstrm); if(u4_bits) { H264_DEC_DEBUG_PRINT(""\nError in parsing SEI message""); } } } } while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst); return (i4_status); }"
"NAN_METHOD(DetectCharacterEncoding) { Nan::HandleScope scope; v8::Local<v8::Object> inputBuffer = info[0]->ToObject(); UCharsetDetector *charsetDetector; const UCharsetMatch *charsetMatch; UErrorCode errorCode = U_ZERO_ERROR; charsetDetector = ucsdet_open(&errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to open ICU charset detector.""); return; } ucsdet_setText( charsetDetector, node::Buffer::Data(inputBuffer), node::Buffer::Length(inputBuffer), &errorCode ); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to set ICU charset detector’s text.""); return; } charsetMatch = ucsdet_detect(charsetDetector, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to detect charset.""); return; } const char *charsetName = ucsdet_getName(charsetMatch, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to get name from charset match.""); return; } int32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode); if(U_FAILURE(errorCode)) { Nan::ThrowError(""Failed to get confidence from charset match.""); return; } v8::Local<v8::Object> obj = Nan::New<v8::Object>(); obj->Set(Nan::New<v8::String>(""encoding"").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked()); obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence)); info.GetReturnValue().Set(obj); }"
"static int image_load_bmp(image_t *img, FILE    *fp, int     gray, int     load_data) { intinfo_size, depth, compression, colors_used, x, y, color, count, temp, align; ucharbit, byte; uchar*ptr; ucharcolormap[256][4]; getc(fp); getc(fp); read_dword(fp); read_word(fp); read_word(fp); read_dword(fp); info_size        = (int)read_dword(fp); img->width       = read_long(fp); img->height      = read_long(fp); read_word(fp); depth            = read_word(fp); compression      = (int)read_dword(fp); read_dword(fp); read_long(fp); read_long(fp); colors_used      = (int)read_dword(fp); read_dword(fp); if (img->width <= 0 || img->width > 8192 || img->height <= 0 || img->height > 8192 || info_size < 0) return (-1); if (info_size > 40) { for (info_size -= 40; info_size > 0; info_size --) getc(fp); } if (colors_used == 0 && depth <= 8) colors_used = 1 << depth; else if (colors_used < 0 || colors_used > 256) return (-1); fread(colormap, (size_t)colors_used, 4, fp); img->depth = gray ? 1 : 3; if (depth <= 8 && Encryption) img->use ++; if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); if (gray && depth <= 8) { for (color = colors_used - 1; color >= 0; color --) colormap[color][0] = (colormap[color][2] * 31 + colormap[color][1] * 61 + colormap[color][0] * 8) / 100; } color = 0; count = 0; align = 0; byte  = 0; temp  = 0; for (y = img->height - 1; y >= 0; y --) { ptr = img->pixels + y * img->width * img->depth; switch (depth) { case 1 :  for (x = img->width, bit = 128; x > 0; x --) { if (bit == 128) byte = (uchar)getc(fp); if (byte & bit) { if (!gray) { *ptr++ = colormap[1][2]; *ptr++ = colormap[1][1]; } *ptr++ = colormap[1][0]; } else { if (!gray) { *ptr++ = colormap[0][2]; *ptr++ = colormap[0][1]; } *ptr++ = colormap[0][0]; } if (bit > 1) bit >>= 1; else bit = 128; } for (temp = (img->width + 7) / 8; temp & 3; temp ++) getc(fp); break; case 4 :  for (x = img->width, bit = 0xf0; x > 0; x --) { if (compression != BI_RLE4 && count == 0) { count = 2; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = ((4 - (count & 3)) / 2) & 1; } } else color = getc(fp); } count --; if (bit == 0xf0) { if (color < 0) temp = getc(fp) & 255; else temp = color; if (!gray) { *ptr++ = colormap[temp >> 4][2]; *ptr++ = colormap[temp >> 4][1]; } *ptr++ = colormap[temp >> 4][0]; bit    = 0x0f; } else { if (!gray) { *ptr++ = colormap[temp & 15][2]; *ptr++ = colormap[temp & 15][1]; } *ptr++ = colormap[temp & 15][0]; bit    = 0xf0; } } break; case 8 :  for (x = img->width; x > 0; x --) { if (compression != BI_RLE8) { count = 1; color = -1; } if (count == 0) { while (align > 0) { align --; getc(fp); } if ((count = getc(fp)) == 0) { if ((count = getc(fp)) == 0) { x ++; continue; } else if (count == 1) { break; } else if (count == 2) { count = getc(fp) * getc(fp) * img->width; color = 0; } else { color = -1; align = (2 - (count & 1)) & 1; } } else color = getc(fp); } if (color < 0) temp = getc(fp) & 255; else temp = color; count --; if (!gray) { *ptr++ = colormap[temp][2]; *ptr++ = colormap[temp][1]; } *ptr++ = colormap[temp][0]; } break; case 24 :  if (gray) { for (x = img->width; x > 0; x --) { temp = getc(fp) * 8; temp += getc(fp) * 61; temp += getc(fp) * 31; *ptr++ = (uchar)(temp / 100); } } else { for (x = img->width; x > 0; x --, ptr += 3) { ptr[2] = (uchar)getc(fp); ptr[1] = (uchar)getc(fp); ptr[0] = (uchar)getc(fp); } } for (temp = img->width * 3; temp & 3; temp ++) getc(fp); break; } } return (0); }"
"static Idx proceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs, Idx *pidx, Idx node, re_node_set *eps_via_nodes, struct re_fail_stack_t *fs) { const re_dfa_t *const dfa = mctx->dfa; Idx i; bool ok; if (IS_EPSILON_NODE (dfa->nodes[node].type)) { re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes; re_node_set *edests = &dfa->edests[node]; Idx dest_node; ok = re_node_set_insert (eps_via_nodes, node); if (__glibc_unlikely (! ok)) return -2; for (dest_node = -1, i = 0; i < edests->nelem; ++i) { Idx candidate = edests->elems[i]; if (!re_node_set_contains (cur_nodes, candidate)) continue; if (dest_node == -1) dest_node = candidate; else { if (re_node_set_contains (eps_via_nodes, dest_node)) return candidate; else if (fs != NULL && push_fail_stack (fs, *pidx, candidate, nregs, regs, eps_via_nodes)) return -2; break; } } return dest_node; } else { Idx naccepted = 0; re_token_type_t type = dfa->nodes[node].type; #ifdef RE_ENABLE_I18N if (dfa->nodes[node].accept_mb) naccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx); else #endif  if (type == OP_BACK_REF) { Idx subexp_idx = dfa->nodes[node].opr.idx + 1; naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so; if (fs != NULL) { if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1) return -1; else if (naccepted) { char *buf = (char *) re_string_get_buffer (&mctx->input); if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx, naccepted) != 0) return -1; } } if (naccepted == 0) { Idx dest_node; ok = re_node_set_insert (eps_via_nodes, node); if (__glibc_unlikely (! ok)) return -2; dest_node = dfa->edests[node].elems[0]; if (re_node_set_contains (&mctx->state_log[*pidx]->nodes, dest_node)) return dest_node; } } if (naccepted != 0 || check_node_accept (mctx, dfa->nodes + node, *pidx)) { Idx dest_node = dfa->nexts[node]; *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted; if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL || !re_node_set_contains (&mctx->state_log[*pidx]->nodes, dest_node))) return -1; re_node_set_empty (eps_via_nodes); return dest_node; } } return -1; }"
"static void gdm_manager_class_init (GdmManagerClass *klass) { GObjectClass   *object_class = G_OBJECT_CLASS (klass); object_class->get_property = gdm_manager_get_property; object_class->set_property = gdm_manager_set_property; object_class->constructor = gdm_manager_constructor; object_class->dispose = gdm_manager_dispose; signals [DISPLAY_ADDED] = g_signal_new (""display-added"", G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GdmManagerClass, display_added), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING); signals [DISPLAY_REMOVED] = g_signal_new (""display-removed"", G_TYPE_FROM_CLASS (object_class), G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GdmManagerClass, display_removed), NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING); g_object_class_install_property (object_class, PROP_XDMCP_ENABLED, g_param_spec_boolean (""xdmcp-enabled"", NULL, NULL, FALSE, G_PARAM_READWRITE | G_PARAM_CONSTRUCT)); g_type_class_add_private (klass, sizeof (GdmManagerPrivate)); }"
"int main (int argc, char * argv []) {const char*progname, *infilename, *outfilename ; SNDFILE*infile = NULL, *outfile = NULL ; SF_INFOsfinfo ; intk, outfilemajor, outfileminor = 0, infileminor ; intoverride_sample_rate = 0 ;  intendian = SF_ENDIAN_FILE, normalize = SF_FALSE ; progname = program_name (argv [0]) ; if (argc < 3 || argc > 5) usage_exit (progname) ; infilename = argv [argc-2] ; outfilename = argv [argc-1] ; if (strcmp (infilename, outfilename) == 0) {printf (""Error : Input and output filenames are the same.\n\n"") ; usage_exit (progname) ; } ; if (strlen (infilename) > 1 && infilename [0] == '-') {printf (""Error : Input filename (%s) looks like an option.\n\n"", infilename) ; usage_exit (progname) ; } ; if (outfilename [0] == '-') {printf (""Error : Output filename (%s) looks like an option.\n\n"", outfilename) ; usage_exit (progname) ; } ; for (k = 1 ; k < argc - 2 ; k++) {if (! strcmp (argv [k], ""-pcms8"")) {outfileminor = SF_FORMAT_PCM_S8 ; continue ; } ; if (! strcmp (argv [k], ""-pcmu8"")) {outfileminor = SF_FORMAT_PCM_U8 ; continue ; } ; if (! strcmp (argv [k], ""-pcm16"")) {outfileminor = SF_FORMAT_PCM_16 ; continue ; } ; if (! strcmp (argv [k], ""-pcm24"")) {outfileminor = SF_FORMAT_PCM_24 ; continue ; } ; if (! strcmp (argv [k], ""-pcm32"")) {outfileminor = SF_FORMAT_PCM_32 ; continue ; } ; if (! strcmp (argv [k], ""-float32"")) {outfileminor = SF_FORMAT_FLOAT ; continue ; } ; if (! strcmp (argv [k], ""-float64"")) {outfileminor = SF_FORMAT_DOUBLE ; continue ; } ; if (! strcmp (argv [k], ""-ulaw"")) {outfileminor = SF_FORMAT_ULAW ; continue ; } ; if (! strcmp (argv [k], ""-alaw"")) {outfileminor = SF_FORMAT_ALAW ; continue ; } ; if (! strcmp (argv [k], ""-alac16"")) {outfileminor = SF_FORMAT_ALAC_16 ; continue ; } ; if (! strcmp (argv [k], ""-alac20"")) {outfileminor = SF_FORMAT_ALAC_20 ; continue ; } ; if (! strcmp (argv [k], ""-alac24"")) {outfileminor = SF_FORMAT_ALAC_24 ; continue ; } ; if (! strcmp (argv [k], ""-alac32"")) {outfileminor = SF_FORMAT_ALAC_32 ; continue ; } ; if (! strcmp (argv [k], ""-ima-adpcm"")) {outfileminor = SF_FORMAT_IMA_ADPCM ; continue ; } ; if (! strcmp (argv [k], ""-ms-adpcm"")) {outfileminor = SF_FORMAT_MS_ADPCM ; continue ; } ; if (! strcmp (argv [k], ""-gsm610"")) {outfileminor = SF_FORMAT_GSM610 ; continue ; } ; if (! strcmp (argv [k], ""-dwvw12"")) {outfileminor = SF_FORMAT_DWVW_12 ; continue ; } ; if (! strcmp (argv [k], ""-dwvw16"")) {outfileminor = SF_FORMAT_DWVW_16 ; continue ; } ; if (! strcmp (argv [k], ""-dwvw24"")) {outfileminor = SF_FORMAT_DWVW_24 ; continue ; } ; if (! strcmp (argv [k], ""-vorbis"")) {outfileminor = SF_FORMAT_VORBIS ; continue ; } ; if (! strcmp (argv [k], ""-opus"")) {outfileminor = SF_FORMAT_OPUS ; continue ; } ; if (strstr (argv [k], ""-override-sample-rate="") == argv [k]) {const char *ptr ; ptr = argv [k] + strlen (""-override-sample-rate="") ; override_sample_rate = atoi (ptr) ; continue ; } ; if (! strcmp (argv [k], ""-endian=little"")) {endian = SF_ENDIAN_LITTLE ; continue ; } ; if (! strcmp (argv [k], ""-endian=big"")) {endian = SF_ENDIAN_BIG ; continue ; } ; if (! strcmp (argv [k], ""-endian=cpu"")) {endian = SF_ENDIAN_CPU ; continue ; } ; if (! strcmp (argv [k], ""-endian=file"")) {endian = SF_ENDIAN_FILE ; continue ; } ; if (! strcmp (argv [k], ""-normalize"")) {normalize = SF_TRUE ; continue ; } ; printf (""Error : Not able to decode argunment '%s'.\n"", argv [k]) ; exit (1) ; } ; memset (&sfinfo, 0, sizeof (sfinfo)) ; if ((infile = sf_open (infilename, SFM_READ, &sfinfo)) == NULL) {printf (""Not able to open input file %s.\n"", infilename) ; puts (sf_strerror (NULL)) ; return 1 ; } ; if (override_sample_rate) sfinfo.samplerate = override_sample_rate ; infileminor = sfinfo.format & SF_FORMAT_SUBMASK ; if ((sfinfo.format = sfe_file_type_of_ext (outfilename, sfinfo.format)) == 0) {printf (""Error : Not able to determine output file type for %s.\n"", outfilename) ; return 1 ; } ; outfilemajor = sfinfo.format & (SF_FORMAT_TYPEMASK | SF_FORMAT_ENDMASK) ; if (outfileminor == 0) outfileminor = sfinfo.format & SF_FORMAT_SUBMASK ; if (outfileminor != 0) sfinfo.format = outfilemajor | outfileminor ; else sfinfo.format = outfilemajor | (sfinfo.format & SF_FORMAT_SUBMASK) ; sfinfo.format |= endian ; if ((sfinfo.format & SF_FORMAT_TYPEMASK) == SF_FORMAT_XI) switch (sfinfo.format & SF_FORMAT_SUBMASK) {case SF_FORMAT_PCM_16 : sfinfo.format = outfilemajor | SF_FORMAT_DPCM_16 ; break ; case SF_FORMAT_PCM_S8 : case SF_FORMAT_PCM_U8 : sfinfo.format = outfilemajor | SF_FORMAT_DPCM_8 ; break ; } ; if (sf_format_check (&sfinfo) == 0) {sf_close (infile) ; report_format_error_exit (argv [0], &sfinfo) ; } ; if ((sfinfo.format & SF_FORMAT_SUBMASK) == SF_FORMAT_GSM610 && sfinfo.samplerate != 8000) {printf ( ""WARNING: GSM 6.10 data format only supports 8kHz sample rate. The converted\n"" ""ouput file will contain the input data converted to the GSM 6.10 data format\n"" ""but not re-sampled.\n"" ) ; } ; if ((outfile = sf_open (outfilename, SFM_WRITE, &sfinfo)) == NULL) {printf (""Not able to open output file %s : %s\n"", outfilename, sf_strerror (NULL)) ; return 1 ; } ; copy_metadata (outfile, infile, sfinfo.channels) ; if (normalize || (outfileminor == SF_FORMAT_DOUBLE) || (outfileminor == SF_FORMAT_FLOAT) || (infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT) || (infileminor == SF_FORMAT_OPUS) || (outfileminor == SF_FORMAT_OPUS) || (infileminor == SF_FORMAT_VORBIS) || (outfileminor == SF_FORMAT_VORBIS)) sfe_copy_data_fp (outfile, infile, sfinfo.channels, normalize) ; else sfe_copy_data_int (outfile, infile, sfinfo.channels) ; sf_close (infile) ; sf_close (outfile) ; return 0 ; }"
"static void StreamTcpPacketSetState(Packet *p, TcpSession *ssn, uint8_t state) { if (state == ssn->state || PKT_IS_PSEUDOPKT(p)) return; ssn->state = state; switch(ssn->state) { case TCP_ESTABLISHED: case TCP_FIN_WAIT1: case TCP_FIN_WAIT2: case TCP_CLOSING: case TCP_CLOSE_WAIT: FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED); break; case TCP_LAST_ACK: case TCP_TIME_WAIT: case TCP_CLOSED: FlowUpdateState(p->flow, FLOW_STATE_CLOSED); break; } }"
"static int dtls1_retrieve_buffered_fragment(SSL *s, int *ok) { pitem *item; hm_fragment *frag; int al; *ok = 0; item = pqueue_peek(s->d1->buffered_messages); if (item == NULL) return 0; frag = (hm_fragment *)item->data; if (frag->reassembly != NULL) return 0; if (s->d1->handshake_read_seq == frag->msg_header.seq) { unsigned long frag_len = frag->msg_header.frag_len; pqueue_pop(s->d1->buffered_messages); al = dtls1_preprocess_fragment(s, &frag->msg_header); if (al == 0) {           unsigned char *p = (unsigned char *)s->init_buf->data + DTLS1_HM_HEADER_LENGTH; memcpy(&p[frag->msg_header.frag_off], frag->fragment, frag->msg_header.frag_len); } dtls1_hm_fragment_free(frag); pitem_free(item); if (al == 0) { *ok = 1; return frag_len; } ssl3_send_alert(s, SSL3_AL_FATAL, al); s->init_num = 0; *ok = 0; return -1; } else return 0; }"
"int tls1_setup_key_block(SSL *s) { unsigned char *p; const EVP_CIPHER *c; const EVP_MD *hash; int num; SSL_COMP *comp; int mac_type = NID_undef, mac_secret_size = 0; int ret = 0; if (s->s3->tmp.key_block_length != 0) return (1); if (!ssl_cipher_get_evp (s->session, &c, &hash, &mac_type, &mac_secret_size, &comp, SSL_USE_ETM(s))) { SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, SSL_R_CIPHER_OR_HASH_UNAVAILABLE); return (0); } s->s3->tmp.new_sym_enc = c; s->s3->tmp.new_hash = hash; s->s3->tmp.new_mac_pkey_type = mac_type; s->s3->tmp.new_mac_secret_size = mac_secret_size; num = EVP_CIPHER_key_length(c) + mac_secret_size + EVP_CIPHER_iv_length(c); num *= 2; ssl3_cleanup_key_block(s); if ((p = OPENSSL_malloc(num)) == NULL) { SSLerr(SSL_F_TLS1_SETUP_KEY_BLOCK, ERR_R_MALLOC_FAILURE); goto err; } s->s3->tmp.key_block_length = num; s->s3->tmp.key_block = p; #ifdef SSL_DEBUG printf(""client random\n""); { int z; for (z = 0; z < SSL3_RANDOM_SIZE; z++) printf(""%02X%c"", s->s3->client_random[z], ((z + 1) % 16) ? ' ' : '\n'); } printf(""server random\n""); { int z; for (z = 0; z < SSL3_RANDOM_SIZE; z++) printf(""%02X%c"", s->s3->server_random[z], ((z + 1) % 16) ? ' ' : '\n'); } printf(""master key\n""); { int z; for (z = 0; z < s->session->master_key_length; z++) printf(""%02X%c"", s->session->master_key[z], ((z + 1) % 16) ? ' ' : '\n'); } #endif if (!tls1_generate_key_block(s, p, num)) goto err; #ifdef SSL_DEBUG printf(""\nkey block\n""); { int z; for (z = 0; z < num; z++) printf(""%02X%c"", p[z], ((z + 1) % 16) ? ' ' : '\n'); } #endif if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) && s->method->version <= TLS1_VERSION) { s->s3->need_empty_fragments = 1; if (s->session->cipher != NULL) { if (s->session->cipher->algorithm_enc == SSL_eNULL) s->s3->need_empty_fragments = 0; #ifndef OPENSSL_NO_RC4 if (s->session->cipher->algorithm_enc == SSL_RC4) s->s3->need_empty_fragments = 0; #endif } } ret = 1; err: return (ret); }"
"long __sys_sendmsg_sock(struct socket *sock, struct user_msghdr __user *msg, unsigned int flags) { struct msghdr msg_sys; return ___sys_sendmsg(sock, msg, &msg_sys, flags, NULL, 0); }"
"LogicalResult matchAndRewriteSortOp(OpTy op, ValueRange xys, uint64_t nx, uint64_t ny, bool isCoo, PatternRewriter &rewriter) { Location loc = op.getLoc(); SmallVector<Value> operands{constantIndex(rewriter, loc, 0), op.getN()}; for (Value v : xys) { auto mtp = getMemRefType(v); if (!mtp.isDynamicDim(0)) { auto newMtp = MemRefType::get({ShapedType::kDynamic}, mtp.getElementType()); v = rewriter.create<memref::CastOp>(loc, newMtp, v); } operands.push_back(v); } auto insertPoint = op->template getParentOfType<func::FuncOp>(); SmallString<32> funcName; FuncGeneratorType funcGenerator; uint32_t nTrailingP = 0; switch (op.getAlgorithm()) { case SparseTensorSortKind::HybridQuickSort: { funcName = kHybridQuickSortFuncNamePrefix; funcGenerator = createQuickSortFunc; nTrailingP = 1; Value pDepthLimit = rewriter.create<memref::AllocaOp>( loc, MemRefType::get({}, rewriter.getI64Type())); operands.push_back(pDepthLimit); Value lo = operands[loIdx]; Value hi = operands[hiIdx]; Value len = rewriter.create<arith::IndexCastOp>( loc, rewriter.getI64Type(), rewriter.create<arith::SubIOp>(loc, hi, lo)); Value depthLimit = rewriter.create<arith::SubIOp>( loc, constantI64(rewriter, loc, 64), rewriter.create<math::CountLeadingZerosOp>(loc, len)); depthLimit = rewriter.create<arith::ShLIOp>(loc, depthLimit, constantI64(rewriter, loc, 1)); rewriter.create<memref::StoreOp>(loc, depthLimit, pDepthLimit); break; } case SparseTensorSortKind::QuickSort: funcName = kQuickSortFuncNamePrefix; funcGenerator = createQuickSortFunc; break; case SparseTensorSortKind::InsertionSortStable: funcName = kSortStableFuncNamePrefix; funcGenerator = createSortStableFunc; break; case SparseTensorSortKind::HeapSort: funcName = kHeapSortFuncNamePrefix; funcGenerator = createHeapSortFunc; break; } FlatSymbolRefAttr func = getMangledSortHelperFunc(rewriter, insertPoint, TypeRange(), funcName, nx, ny, isCoo, operands, funcGenerator, nTrailingP); rewriter.replaceOpWithNewOp<func::CallOp>(op, func, TypeRange(), operands); return success(); }"
"static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int istart = 0, iend, n, nsiz; Jsi_Number nstart; Jsi_Obj *nobj, *obj; Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0), *end = Jsi_ValueArrayIndex(interp, args, 1); if (!start) { goto bail; } obj = _this->d.obj; n = Jsi_ObjGetLength(interp, obj); if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) { istart = (int)nstart; if (istart > n) goto done; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (n == 0) { done: Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY)); return JSI_OK; } Jsi_Number nend; iend = n-1; if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) { iend = (int) nend; if (iend >= n) iend = n; if (iend < 0) iend = (n+iend); if (iend<0) goto bail; } nsiz = iend-istart+1; if (nsiz<=0) goto done; Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { rc = Jsi_LogError(""index too large: %d"", nsiz); goto bail; } int i, m; for (m = 0, i = istart; i <= iend; i++, m++) { if (!obj->arr[i]) continue; nobj->arr[m] = NULL; Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]); } Jsi_ObjSetLength(interp, nobj, nsiz); Jsi_ValueMakeArrayObject(interp, ret, nobj); return JSI_OK; bail: Jsi_ValueMakeNull(interp, ret); return rc; }"
void printAst() { print(ast); buffer[used] = 0; }
"static GF_XMTParser *xmt_new_parser(GF_SceneLoader *load) { GF_XMTParser *parser; if ((load->type==GF_SM_LOAD_XSR) && !load->ctx) return NULL; GF_SAFEALLOC(parser, GF_XMTParser); if (!parser) return NULL; parser->nodes = gf_list_new(); parser->descriptors = gf_list_new(); parser->od_links = gf_list_new(); parser->esd_links = gf_list_new(); parser->def_nodes = gf_list_new(); parser->peeked_nodes = gf_list_new(); parser->inserted_routes = gf_list_new(); parser->unresolved_routes = gf_list_new(); parser->sax_parser = gf_xml_sax_new(xmt_node_start, xmt_node_end, xmt_text_content, parser); parser->load = load; load->loader_priv = parser; if (load->ctx) load->ctx->is_pixel_metrics = 1; return parser; }"
"static void error_diffuse(unsigned char     *data,       int               pos,         int               depth,       int               error,       int               numerator,   int               denominator ) { int c; data += pos * depth; c = *data + error * numerator / denominator; if (c < 0) { c = 0; } if (c >= 1 << 8) { c = (1 << 8) - 1; } *data = (unsigned char)c; }"
"static GF_Err mp4_input_ctrl(GF_ESInterface *ifce, u32 act_type, void *param) { char af_data[188]; GF_ESIMP4 *priv = (GF_ESIMP4 *)ifce->input_udta; if (!priv) return GF_BAD_PARAM; switch (act_type) { case GF_ESI_INPUT_DATA_FLUSH: { GF_ESIPacket pck; #ifndef GPAC_DISABLE_TTXT GF_List *cues = NULL; #endif if (!priv->sample) priv->sample = gf_isom_get_sample(priv->mp4, priv->track, priv->sample_number+1, NULL); if (!priv->sample) { return GF_IO_ERR; } memset(&pck, 0, sizeof(GF_ESIPacket)); pck.flags = GF_ESI_DATA_AU_START | GF_ESI_DATA_HAS_CTS; if (priv->sample->IsRAP) pck.flags |= GF_ESI_DATA_AU_RAP; pck.cts = priv->sample->DTS + priv->ts_offset; if (priv->is_repeat) pck.flags |= GF_ESI_DATA_REPEAT; if (priv->timeline_id) { Bool deactivate_temi=GF_FALSE; u64 ntp=0; u64 tc = priv->sample->DTS + priv->sample->CTS_Offset + priv->cts_dts_shift; Bool insert_temi=GF_FALSE; if (temi_disable_loop) { tc += priv->ts_offset; } if (temi_offset) { tc += ((u64) temi_offset) * ifce->timescale / 1000; } if (priv->insert_ntp) { u32 sec, frac; gf_net_get_ntp(&sec, &frac); ntp = sec; ntp <<= 32; ntp |= frac; } if (!temi_period) { if (request_temi_toggle && priv->sample->IsRAP) { temi_on = !temi_on; if (!temi_on) { deactivate_temi = GF_TRUE; } fprintf(stderr, ""Turning TEMI %st at DTS ""LLU"" (%g sec)\n"", temi_on ? ""on"" : ""off"" , priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); request_temi_toggle = GF_FALSE; } insert_temi = temi_on; } else { if (!temi_on) { if (priv->sample->IsRAP && ((priv->sample->DTS - temi_period_last_dts) >= temi_period * ifce->timescale)) { temi_on = GF_TRUE; temi_period_last_dts = priv->sample->DTS; fprintf(stderr, ""Turning TEMI on at DTS ""LLU"" (%g sec)\n"", priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); } } else { if (!temi_single_toggle && priv->sample->IsRAP && ((priv->sample->DTS - temi_period_last_dts) >= temi_period * ifce->timescale)) { temi_on = GF_FALSE; temi_period_last_dts = priv->sample->DTS; fprintf(stderr, ""Turning TEMI off at DTS ""LLU"" (%g sec)\n"", priv->sample->DTS, ((Double)priv->sample->DTS)/ifce->timescale); deactivate_temi = GF_TRUE; } } insert_temi = temi_on; } if (insert_temi) { pck.mpeg2_af_descriptors_size = format_af_descriptor(af_data, priv->timeline_id - 1, tc, ifce->timescale, ntp, priv->temi_url, &priv->last_temi_url); pck.mpeg2_af_descriptors = af_data; } else if (deactivate_temi) { pck.mpeg2_af_descriptors_size = format_af_descriptor(af_data, priv->timeline_id - 1, 0, 0, 0, """", &priv->last_temi_url); pck.mpeg2_af_descriptors = af_data; } } if (priv->nb_repeat_last) { pck.cts += priv->nb_repeat_last*ifce->timescale * priv->image_repeat_ms / 1000; } pck.dts = pck.cts; if (priv->cts_dts_shift) { pck.cts += + priv->cts_dts_shift; pck.flags |= GF_ESI_DATA_HAS_DTS; } if (priv->sample->CTS_Offset) { pck.cts += priv->sample->CTS_Offset; pck.flags |= GF_ESI_DATA_HAS_DTS; } if (priv->sample->IsRAP && priv->dsi && priv->dsi_size) { pck.data = (char*)priv->dsi; pck.data_len = priv->dsi_size; ifce->output_ctrl(ifce, GF_ESI_OUTPUT_DATA_DISPATCH, &pck); pck.flags &= ~GF_ESI_DATA_AU_START; } pck.flags |= GF_ESI_DATA_AU_END; pck.data = priv->sample->data; pck.data_len = priv->sample->dataLength; pck.duration = gf_isom_get_sample_duration(priv->mp4, priv->track, priv->sample_number+1); #ifndef GPAC_DISABLE_TTXT if (priv->mtype==GF_ISOM_MEDIA_TEXT && priv->mstype==GF_ISOM_SUBTYPE_WVTT) { u64             start; GF_WebVTTCue    *cue; GF_List *gf_webvtt_parse_iso_cues(GF_ISOSample *iso_sample, u64 start); start = (priv->sample->DTS * 1000) / ifce->timescale; cues = gf_webvtt_parse_iso_cues(priv->sample, start); if (gf_list_count(cues)>1) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS Muxer] More than one cue in sample\n"")); } cue = (GF_WebVTTCue *)gf_list_get(cues, 0); if (cue) { pck.data = cue->text; pck.data_len = (u32)strlen(cue->text)+1; } else { pck.data = NULL; pck.data_len = 0; } } #endif ifce->output_ctrl(ifce, GF_ESI_OUTPUT_DATA_DISPATCH, &pck); GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[MPEG-2 TS Muxer] Track %d: sample %d CTS %d\n"", priv->track, priv->sample_number+1, pck.cts)); #ifndef GPAC_DISABLE_VTT if (cues) { while (gf_list_count(cues)) { GF_WebVTTCue *cue = (GF_WebVTTCue *)gf_list_get(cues, 0); gf_list_rem(cues, 0); gf_webvtt_cue_del(cue); } gf_list_del(cues); cues = NULL; } #endif gf_isom_sample_del(&priv->sample); priv->sample_number++; if (!priv->source->real_time && !priv->is_repeat) { priv->source->samples_done++; gf_set_progress(""MPEG-2 TS Muxing"", priv->source->samples_done, priv->source->samples_count); } if (priv->sample_number==priv->sample_count) { if (priv->loop) { Double scale; u64 duration; scale = gf_isom_get_media_timescale(priv->mp4, priv->track); scale /= gf_isom_get_timescale(priv->mp4); duration = (u64) (gf_isom_get_duration(priv->mp4) * scale); priv->ts_offset += duration; priv->sample_number = 0; priv->is_repeat = (priv->sample_count==1) ? GF_TRUE : GF_FALSE; } else if (priv->image_repeat_ms && priv->source->nb_real_streams) { priv->nb_repeat_last++; priv->sample_number--; priv->is_repeat = GF_TRUE; } else { if (!(ifce->caps & GF_ESI_STREAM_IS_OVER)) { ifce->caps |= GF_ESI_STREAM_IS_OVER; if (priv->sample_count>1) { assert(priv->source->nb_real_streams); priv->source->nb_real_streams--; } } } } } return GF_OK; case GF_ESI_INPUT_DESTROY: if (priv->dsi) gf_free(priv->dsi); if (ifce->decoder_config) { gf_free(ifce->decoder_config); ifce->decoder_config = NULL; } gf_free(priv); ifce->input_udta = NULL; return GF_OK; default: return GF_BAD_PARAM; } }"
"int __cil_build_ast_last_child_helper(struct cil_tree_node *parse_current, void *extra_args) { struct cil_args_build *args = extra_args; struct cil_tree_node *ast = args->ast; if (ast->flavor == CIL_ROOT) { return SEPOL_OK; } args->ast = ast->parent; if (ast->flavor == CIL_TUNABLEIF) { args->tunif = NULL; } if (ast->flavor == CIL_IN) { args->in = NULL; } if (ast->flavor == CIL_MACRO) { args->macro = NULL; } if (ast->flavor == CIL_BOOLEANIF) { args->boolif = NULL; } cil_tree_children_destroy(parse_current->parent); return SEPOL_OK; }"
void gf_isom_delete_movie(GF_ISOFile *mov) { if (!mov) return; if (mov->movieFileMap) gf_isom_datamap_del(mov->movieFileMap); #ifndef GPAC_DISABLE_ISOM_WRITE if (mov->editFileMap) { gf_isom_datamap_del(mov->editFileMap); } if (mov->finalName) gf_free(mov->finalName); #endif gf_isom_box_array_del(mov->TopBoxes); #ifndef GPAC_DISABLE_ISOM_FRAGMENTS gf_isom_box_array_del(mov->moof_list); if (mov->mfra) gf_isom_box_del((GF_Box*)mov->mfra); if (mov->sidx_pts_store) gf_free(mov->sidx_pts_store); if (mov->sidx_pts_next_store) gf_free(mov->sidx_pts_next_store); if (mov->main_sidx) gf_isom_box_del((GF_Box*)mov->main_sidx); if (mov->block_buffer) gf_free(mov->block_buffer); #endif if (mov->last_producer_ref_time) gf_isom_box_del((GF_Box *) mov->last_producer_ref_time); if (mov->fileName) gf_free(mov->fileName); gf_free(mov); }
"static int base_sock_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; if (sock->type != SOCK_RAW) return -ESOCKTNOSUPPORT; sk = sk_alloc(net, PF_ISDN, GFP_KERNEL, &mISDN_proto, kern); if (!sk) return -ENOMEM; sock_init_data(sock, sk); sock->ops = &base_sock_ops; sock->state = SS_UNCONNECTED; sock_reset_flag(sk, SOCK_ZAPPED); sk->sk_protocol = protocol; sk->sk_state    = MISDN_OPEN; mISDN_sock_link(&base_sockets, sk); return 0; }"
"void tcp_v4_err(struct sk_buff *icmp_skb, u32 info) { const struct iphdr *iph = (const struct iphdr *)icmp_skb->data; struct tcphdr *th = (struct tcphdr *)(icmp_skb->data + (iph->ihl << 2)); struct inet_connection_sock *icsk; struct tcp_sock *tp; struct inet_sock *inet; const int type = icmp_hdr(icmp_skb)->type; const int code = icmp_hdr(icmp_skb)->code; struct sock *sk; struct sk_buff *skb; struct request_sock *fastopen; __u32 seq, snd_una; __u32 remaining; int err; struct net *net = dev_net(icmp_skb->dev); sk = __inet_lookup_established(net, &tcp_hashinfo, iph->daddr, th->dest, iph->saddr, ntohs(th->source), inet_iif(icmp_skb)); if (!sk) { __ICMP_INC_STATS(net, ICMP_MIB_INERRORS); return; } if (sk->sk_state == TCP_TIME_WAIT) { inet_twsk_put(inet_twsk(sk)); return; } seq = ntohl(th->seq); if (sk->sk_state == TCP_NEW_SYN_RECV) return tcp_req_err(sk, seq, type == ICMP_PARAMETERPROB || type == ICMP_TIME_EXCEEDED || (type == ICMP_DEST_UNREACH && (code == ICMP_NET_UNREACH || code == ICMP_HOST_UNREACH))); bh_lock_sock(sk); if (sock_owned_by_user(sk)) { if (!(type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED)) __NET_INC_STATS(net, LINUX_MIB_LOCKDROPPEDICMPS); } if (sk->sk_state == TCP_CLOSE) goto out; if (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) { __NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP); goto out; } icsk = inet_csk(sk); tp = tcp_sk(sk); fastopen = tp->fastopen_rsk; snd_una = fastopen ? tcp_rsk(fastopen)->snt_isn : tp->snd_una; if (sk->sk_state != TCP_LISTEN && !between(seq, snd_una, tp->snd_nxt)) { __NET_INC_STATS(net, LINUX_MIB_OUTOFWINDOWICMPS); goto out; } switch (type) { case ICMP_REDIRECT: do_redirect(icmp_skb, sk); goto out; case ICMP_SOURCE_QUENCH: goto out; case ICMP_PARAMETERPROB: err = EPROTO; break; case ICMP_DEST_UNREACH: if (code > NR_ICMP_UNREACH) goto out; if (code == ICMP_FRAG_NEEDED) {  if (sk->sk_state == TCP_LISTEN) goto out; tp->mtu_info = info; if (!sock_owned_by_user(sk)) { tcp_v4_mtu_reduced(sk); } else { if (!test_and_set_bit(TCP_MTU_REDUCED_DEFERRED, &sk->sk_tsq_flags)) sock_hold(sk); } goto out; } err = icmp_err_convert[code].errno; if (code != ICMP_NET_UNREACH && code != ICMP_HOST_UNREACH) break; if (seq != tp->snd_una  || !icsk->icsk_retransmits || !icsk->icsk_backoff || fastopen) break; if (sock_owned_by_user(sk)) break; icsk->icsk_backoff--; icsk->icsk_rto = tp->srtt_us ? __tcp_set_rto(tp) : TCP_TIMEOUT_INIT; icsk->icsk_rto = inet_csk_rto_backoff(icsk, TCP_RTO_MAX); skb = tcp_write_queue_head(sk); BUG_ON(!skb); remaining = icsk->icsk_rto - min(icsk->icsk_rto, tcp_time_stamp - tcp_skb_timestamp(skb)); if (remaining) { inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, remaining, TCP_RTO_MAX); } else { tcp_retransmit_timer(sk); } break; case ICMP_TIME_EXCEEDED: err = EHOSTUNREACH; break; default: goto out; } switch (sk->sk_state) { case TCP_SYN_SENT: case TCP_SYN_RECV: if (fastopen && !fastopen->sk) break; if (!sock_owned_by_user(sk)) { sk->sk_err = err; sk->sk_error_report(sk); tcp_done(sk); } else { sk->sk_err_soft = err; } goto out; } inet = inet_sk(sk); if (!sock_owned_by_user(sk) && inet->recverr) { sk->sk_err = err; sk->sk_error_report(sk); } else{  sk->sk_err_soft = err; } out: bh_unlock_sock(sk); sock_put(sk); }"
"FT_LOCAL_DEF( FT_Error ) T1_Get_Private_Dict( T1_Parser      parser, PSAux_Service  psaux ) { FT_Stream  stream = parser->stream; FT_Memory  memory = parser->root.memory; FT_Error   error  = FT_Err_Ok; FT_ULong   size; if ( parser->in_pfb ) { FT_ULong   start_pos = FT_STREAM_POS(); FT_UShort  tag; parser->private_len = 0; for (;;) { error = read_pfb_tag( stream, &tag, &size ); if ( error ) goto Fail; if ( tag != 0x8002U ) break; parser->private_len += size; if ( FT_STREAM_SKIP( size ) ) goto Fail; } if ( parser->private_len == 0 ) { FT_ERROR(( ""T1_Get_Private_Dict:"" "" invalid private dictionary section\n"" )); error = FT_THROW( Invalid_File_Format ); goto Fail; } if ( FT_STREAM_SEEK( start_pos )                           || FT_ALLOC( parser->private_dict, parser->private_len ) ) goto Fail; parser->private_len = 0; for (;;) { error = read_pfb_tag( stream, &tag, &size ); if ( error || tag != 0x8002U ) { error = FT_Err_Ok; break; } if ( FT_STREAM_READ( parser->private_dict + parser->private_len, size ) ) goto Fail; parser->private_len += size; } } else { FT_Byte*    cur   = parser->base_dict; FT_Byte*    limit = cur + parser->base_len; FT_Byte     c; FT_Pointer  pos_lf; FT_Bool     test_cr; Again: for (;;) { c = cur[0]; if ( c == 'e' && cur + 9 < limit )   { if ( cur[1] == 'e' && cur[2] == 'x' && cur[3] == 'e' && cur[4] == 'c' ) break; } cur++; if ( cur >= limit ) { FT_ERROR(( ""T1_Get_Private_Dict:"" "" could not find `eexec' keyword\n"" )); error = FT_THROW( Invalid_File_Format ); goto Exit; } } parser->root.cursor = parser->base_dict; parser->root.limit  = cur + 10; cur   = parser->root.cursor; limit = parser->root.limit; while ( cur < limit ) { if ( *cur == 'e' && ft_strncmp( (char*)cur, ""eexec"", 5 ) == 0 ) goto Found; T1_Skip_PS_Token( parser ); if ( parser->root.error ) break; T1_Skip_Spaces  ( parser ); cur = parser->root.cursor; } cur   = limit; limit = parser->base_dict + parser->base_len; goto Again; Found: parser->root.limit = parser->base_dict + parser->base_len; T1_Skip_PS_Token( parser ); cur   = parser->root.cursor; limit = parser->root.limit; pos_lf  = ft_memchr( cur, '\n', (size_t)( limit - cur ) ); test_cr = FT_BOOL( !pos_lf                                       || pos_lf > ft_memchr( cur, '\r', (size_t)( limit - cur ) ) ); while ( cur < limit                    && ( *cur == ' '                || *cur == '\t'               || (test_cr && *cur == '\r' ) || *cur == '\n'               ) ) ++cur; if ( cur >= limit ) { FT_ERROR(( ""T1_Get_Private_Dict:"" "" `eexec' not properly terminated\n"" )); error = FT_THROW( Invalid_File_Format ); goto Exit; } size = parser->base_len - (FT_ULong)( cur - parser->base_dict ); if ( parser->in_memory ) { if ( FT_ALLOC( parser->private_dict, size + 1 ) ) goto Fail; parser->private_len = size; } else { parser->single_block = 1; parser->private_dict = parser->base_dict; parser->private_len  = size; parser->base_dict    = NULL; parser->base_len     = 0; } if ( cur + 3 < limit                                && ft_isxdigit( cur[0] ) && ft_isxdigit( cur[1] ) && ft_isxdigit( cur[2] ) && ft_isxdigit( cur[3] ) ) { FT_ULong  len; parser->root.cursor = cur; (void)psaux->ps_parser_funcs->to_bytes( &parser->root, parser->private_dict, parser->private_len, &len, 0 ); parser->private_len = len; parser->private_dict[len] = '\0'; } else FT_MEM_MOVE( parser->private_dict, cur, size ); } psaux->t1_decrypt( parser->private_dict, parser->private_len, 55665U ); if ( parser->private_len < 4 ) { FT_ERROR(( ""T1_Get_Private_Dict:"" "" invalid private dictionary section\n"" )); error = FT_THROW( Invalid_File_Format ); goto Fail; } parser->private_dict[0] = ' '; parser->private_dict[1] = ' '; parser->private_dict[2] = ' '; parser->private_dict[3] = ' '; parser->root.base   = parser->private_dict; parser->root.cursor = parser->private_dict; parser->root.limit  = parser->root.cursor + parser->private_len; Fail: Exit: return error; }"
"static int aacDecoder_drcExtractAndMap ( HANDLE_AAC_DRC  self, HANDLE_FDK_BITSTREAM hBs, CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo[], UCHAR  pceInstanceTag, UCHAR  channelMapping[],  int    validChannels ) { CDrcPayload  threadBs[MAX_DRC_THREADS]; CDrcPayload *validThreadBs[MAX_DRC_THREADS]; CDrcParams  *pParams; UINT backupBsPosition; int  i, thread, validThreads = 0; int  numExcludedChns[MAX_DRC_THREADS]; FDK_ASSERT(self != NULL); FDK_ASSERT(hBs != NULL); FDK_ASSERT(pAacDecoderStaticChannelInfo != NULL); pParams = &self->params; self->numThreads = 0; backupBsPosition = FDKgetValidBits(hBs); for (i = 0; i < self->numPayloads && self->numThreads < MAX_DRC_THREADS; i++) { int bitsParsed; FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload)); threadBs[self->numThreads].channelData.bandTop[0]  = (1024 >> 2) - 1; bitsParsed = aacDecoder_drcParse( hBs, &threadBs[self->numThreads], self->drcPayloadPosition[i] ); if (bitsParsed > 0) { self->numThreads++; } } self->numPayloads = 0; if (self->dvbAncDataAvailable) {  int bitsParsed; FDKmemclear(&threadBs[self->numThreads], sizeof(CDrcPayload)); threadBs[self->numThreads].channelData.bandTop[0]  = (1024 >> 2) - 1; bitsParsed = aacDecoder_drcReadCompression( hBs, &threadBs[self->numThreads], self->dvbAncDataPosition ); if (bitsParsed > 0) { self->numThreads++; } } self->dvbAncDataAvailable = 0; FDKpushBiDirectional(hBs, FDKgetValidBits(hBs) - backupBsPosition); for (thread = 0; thread < self->numThreads; thread++) { CDrcPayload *pThreadBs = &threadBs[thread]; int numExclChns = 0; switch ((AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType) { default: continue; case MPEG_DRC_EXT_DATA: case DVB_DRC_ANC_DATA: break; } if (pThreadBs->pceInstanceTag >= 0) {   if (pThreadBs->pceInstanceTag != pceInstanceTag) { continue;   } } if (pThreadBs->excludedChnsMask > 0) { INT exclMask = pThreadBs->excludedChnsMask; int ch; for (ch = 0; ch < validChannels; ch++) { numExclChns += exclMask & 0x1; exclMask >>= 1; } } if (numExclChns < validChannels) { validThreadBs[validThreads]   = pThreadBs; numExcludedChns[validThreads] = numExclChns; validThreads++; } } if (validThreads > 1) { int ch; for (ch = 0; ch < validChannels; ch++) { int present = 0; for (thread = 0; thread < validThreads; thread++) { CDrcPayload *pThreadBs = validThreadBs[thread]; if ( (pThreadBs->channelData.drcDataType == MPEG_DRC_EXT_DATA) && ( (numExcludedChns[thread] == 0) || (!(pThreadBs->excludedChnsMask & (1<<ch))) ) ) { present++; } } if (present > 1) { return -1; } } } for (thread = 0; thread < validThreads; thread++) { CDrcPayload *pThreadBs = validThreadBs[thread]; INT exclMask = pThreadBs->excludedChnsMask; AACDEC_DRC_PAYLOAD_TYPE drcPayloadType = (AACDEC_DRC_PAYLOAD_TYPE)pThreadBs->channelData.drcDataType; int ch; if (pThreadBs->progRefLevel >= 0) { self->progRefLevel = pThreadBs->progRefLevel; self->progRefLevelPresent = 1; self->prlExpiryCount = 0;   } if (drcPayloadType == DVB_DRC_ANC_DATA) { self->presMode = pThreadBs->presMode; } for (ch = 0; ch < validChannels; ch++) { int mapedChannel = channelMapping[ch]; if ( ((exclMask & (1<<mapedChannel)) == 0) && ( (drcPayloadType == MPEG_DRC_EXT_DATA) || ((drcPayloadType == DVB_DRC_ANC_DATA) && self->params.applyHeavyCompression) ) ) { pAacDecoderStaticChannelInfo[ch]->drcData = pThreadBs->channelData; } } } if ( (pParams->expiryFrame > 0) && (self->prlExpiryCount++ > pParams->expiryFrame) ) {  self->progRefLevelPresent = 0; self->progRefLevel = pParams->targetRefLevel; self->prlExpiryCount = 0; } return 0; }"
"void bigint_monty_mul(BigInt& z, const BigInt& x, const BigInt& y, const word p[], size_t p_size, word p_dash, word ws[]) { bigint_mul(z, x, y, &ws[0]); bigint_monty_redc(z.mutable_data(), &p[0], p_size, p_dash, &ws[0]); }"
"void irc_mode_channel_update (struct t_irc_server *server, struct t_irc_channel *channel, char set_flag, char chanmode, const char *argument) { char *pos_args, *str_modes, **argv, *pos, *ptr_arg; char *new_modes, *new_args, str_mode[2], *str_temp; int argc, current_arg, chanmode_found, length; if (!channel->modes) channel->modes = strdup (""+""); if (!channel->modes) return; argc = 0; argv = NULL; pos_args = strchr (channel->modes, ' '); if (pos_args) { str_modes = weechat_strndup (channel->modes, pos_args - channel->modes); if (!str_modes) return; pos_args++; while (pos_args[0] == ' ') pos_args++; argv = weechat_string_split (pos_args, "" "", NULL, WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS, 0, &argc); } else { str_modes = strdup (channel->modes); if (!str_modes) return; } new_modes = malloc (strlen (channel->modes) + 1 + 1); new_args = malloc (((pos_args) ? strlen (pos_args) : 0) + ((argument) ? 1 + strlen (argument) : 0) + 1); if (new_modes && new_args) { new_modes[0] = '\0'; new_args[0] = '\0'; current_arg = 0; chanmode_found = 0; pos = str_modes; while (pos && pos[0]) { if ((pos[0] == '+') || (pos[0] == '-')) { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); } else { ptr_arg = NULL; switch (irc_mode_get_chanmode_type (server, pos[0])) { case 'A':  case 'B':  case 'C':  ptr_arg = (current_arg < argc) ? argv[current_arg] : NULL; break; case 'D':  break; } if (ptr_arg) current_arg++; if (pos[0] == chanmode) { chanmode_found = 1; if (set_flag == '+') { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (argument) { if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, argument); } } } else { str_mode[0] = pos[0]; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (ptr_arg) { if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, ptr_arg); } } } pos++; } if (!chanmode_found) { if (set_flag == '+') { if (argument) { str_mode[0] = chanmode; str_mode[1] = '\0'; strcat (new_modes, str_mode); if (new_args[0]) strcat (new_args, "" ""); strcat (new_args, argument); } else { pos = new_modes; while (pos[0] == '+') pos++; memmove (pos + 1, pos, strlen (pos) + 1); pos[0] = chanmode; } } } if (new_args[0]) { length = strlen (new_modes) + 1 + strlen (new_args) + 1; str_temp = malloc (length); if (str_temp) { snprintf (str_temp, length, ""%s %s"", new_modes, new_args); if (channel->modes) free (channel->modes); channel->modes = str_temp; } } else { if (channel->modes) free (channel->modes); channel->modes = strdup (new_modes); } } if (new_modes) free (new_modes); if (new_args) free (new_args); if (str_modes) free (str_modes); if (argv) weechat_string_free_split (argv); }"
"static int write_cr(unsigned int reg, unsigned long val, struct x86_emulate_ctxt *ctxt) { struct vcpu *curr = current; switch ( reg ) { case 0:  if ( (val ^ read_cr0()) & ~X86_CR0_TS ) { gdprintk(XENLOG_WARNING, ""Attempt to change unmodifiable CR0 flags\n""); break; } do_fpu_taskswitch(!!(val & X86_CR0_TS)); return X86EMUL_OKAY; case 2:  curr->arch.pv.ctrlreg[2] = val; arch_set_cr2(curr, val); return X86EMUL_OKAY; case 3:  { struct domain *currd = curr->domain; unsigned long gfn; struct page_info *page; int rc; gfn = !is_pv_32bit_domain(currd) ? xen_cr3_to_pfn(val) : compat_cr3_to_pfn(val); page = get_page_from_gfn(currd, gfn, NULL, P2M_ALLOC); if ( !page ) break; rc = new_guest_cr3(page_to_mfn(page)); put_page(page); switch ( rc ) { case 0: return X86EMUL_OKAY; case -ERESTART:  return X86EMUL_RETRY; } break; } case 4:  curr->arch.pv.ctrlreg[4] = pv_fixup_guest_cr4(curr, val); write_cr4(pv_make_cr4(curr)); ctxt_switch_levelling(curr); return X86EMUL_OKAY; } return X86EMUL_UNHANDLEABLE; }"
"lyd_node * lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name) { const struct lys_node *snode = NULL, *siblings; if ((!parent && !module) || !name) { LOGARG; return NULL; } siblings = lyd_new_find_schema(parent, module, 0); if (!siblings) { LOGARG; return NULL; } if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF | LYS_RPC | LYS_ACTION, &snode) || !snode) { LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."", name, lys_node_module(siblings)->name, siblings->name); return NULL; } return _lyd_new(parent, snode, 0); }"
"lyd_node * lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name, void *value, LYD_ANYDATA_VALUETYPE value_type) { const struct lys_node *siblings, *snode; if ((!parent && !module) || !name) { LOGARG; return NULL; } siblings = lyd_new_find_schema(parent, module, 1); if (!siblings) { LOGARG; return NULL; } if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) { LOGERR(siblings->module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a sibling to \""%s:%s\""."", name, lys_node_module(siblings)->name, siblings->name); return NULL; } return lyd_create_anydata(parent, snode, value, value_type); }"
void arch_pick_mmap_layout(struct mm_struct *mm) { unsigned long random_factor = 0UL; if (current->flags & PF_RANDOMIZE) random_factor = arch_mmap_rnd(); mm->mmap_legacy_base = mmap_legacy_base(random_factor); if (mmap_is_legacy()) { mm->mmap_base = mm->mmap_legacy_base; mm->get_unmapped_area = arch_get_unmapped_area; } else { mm->mmap_base = mmap_base(random_factor); mm->get_unmapped_area = arch_get_unmapped_area_topdown; } }
"static void g_socket_client_tls_handshake (GSocketClientAsyncConnectData *data) { GIOStream *tlsconn; if (!data->client->priv->tls) { g_socket_client_async_connect_complete (data); return; } tlsconn = g_tls_client_connection_new (data->connection, data->connectable, &data->last_error); if (tlsconn) { g_tls_client_connection_set_validation_flags (G_TLS_CLIENT_CONNECTION (tlsconn), data->client->priv->tls_validation_flags); g_socket_client_emit_event (data->client, G_SOCKET_CLIENT_TLS_HANDSHAKING, data->connectable, G_IO_STREAM (tlsconn)); g_tls_connection_handshake_async (G_TLS_CONNECTION (tlsconn), G_PRIORITY_DEFAULT, g_task_get_cancellable (data->task), g_socket_client_tls_handshake_callback, data); } else { enumerator_next_async (data); } }"
"static void lsr_translate_anim_trans_values(GF_LASeRCodec *lsr, SMIL_AnimateValues *val, u32 transform_type) { u32 count, i, coded_type; SVG_Point_Angle *p; SVG_Point *pt; Fixed *f; GF_List *l; Bool handled = GF_FALSE; coded_type = val->type; switch(transform_type) { case SVG_TRANSFORM_TRANSLATE: val->type = SVG_Transform_Translate_datatype; break; case SVG_TRANSFORM_SCALE: if (coded_type==8) handled = GF_TRUE; val->type = SVG_Transform_Scale_datatype; break; case SVG_TRANSFORM_ROTATE: if ((coded_type==8) || (coded_type==1)) handled = GF_TRUE; val->type = SVG_Transform_Rotate_datatype; break; case SVG_TRANSFORM_SKEWX: if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE; val->type = SVG_Transform_SkewX_datatype; break; case SVG_TRANSFORM_SKEWY: if ((coded_type==1) || (coded_type==4)) handled = GF_TRUE; val->type = SVG_Transform_SkewY_datatype; break; case SVG_TRANSFORM_MATRIX: val->type = SVG_Transform_datatype; break; default: GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[SVG Parsing] unknown datatype for animate transform.\n"")); break; } if (!handled) { while (gf_list_count(val->values)) { SMIL_AnimateValue a_val; a_val.type = 0; a_val.value = gf_list_pop_back(val->values); lsr_delete_anim_value(lsr, &a_val, coded_type); } return; } count = gf_list_count(val->values); if (!count) return; if (transform_type==SVG_TRANSFORM_TRANSLATE) return; for (i=0; i<count; i++) { void *a_val = gf_list_get(val->values, i); switch (transform_type) { case SVG_TRANSFORM_ROTATE: GF_SAFEALLOC(p, SVG_Point_Angle); if (!p) return; if (coded_type==8) { l = (GF_List*)a_val; f = (Fixed*)gf_list_get(l, 0); p->angle = *f; f = (Fixed*)gf_list_get(l, 1); if (f) p->x = *f; f = (Fixed*)gf_list_get(l, 2); if (f) p->y = *f; while (gf_list_count(l)) { f = (Fixed*)gf_list_last(l); gf_list_rem_last(l); gf_free(f); } gf_list_del(l); } else if (coded_type==1) { p->angle = ((SVG_Number *)a_val)->value; gf_free(a_val); } p->angle = gf_muldiv(p->angle, GF_PI, INT2FIX(180) ); gf_list_rem(val->values, i); gf_list_insert(val->values, p, i); break; case SVG_TRANSFORM_SKEWX: case SVG_TRANSFORM_SKEWY: f = (Fixed*)gf_malloc(sizeof(Fixed)); *f = ((SVG_Number *)a_val)->value; gf_free(a_val); gf_list_rem(val->values, i); gf_list_insert(val->values, f, i); break; case SVG_TRANSFORM_SCALE: pt = (SVG_Point*)gf_malloc(sizeof(SVG_Point)); l = (GF_List*)a_val; f = (Fixed*)gf_list_get(l, 0); if (f) pt->x = *f; f = (Fixed*)gf_list_get(l, 1); if (f) pt->y = *f; else pt->y = pt->x; while (gf_list_count(l)) { f = (Fixed*)gf_list_last(l); gf_list_rem_last(l); gf_free(f); } gf_list_del(l); gf_list_rem(val->values, i); gf_list_insert(val->values, pt, i); break; default: GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[LASeR] unknown transform type %d\n"", transform_type)); break; } } }"
"static struct topdicts **readcfftopdicts(FILE *ttf, char **fontnames, int32 cff_start, struct ttfinfo *info, struct topdicts *parent_dict) { uint16 count = getushort(ttf); int offsize; uint32 *offsets; struct topdicts **dicts; int i; if ( count==0 ) return( NULL ); offsets = malloc((count+1)*sizeof(uint32)); offsize = getc(ttf); for ( i=0; i<=count; ++i ) offsets[i] = getoffset(ttf,offsize); dicts = malloc((count+1)*sizeof(struct topdicts *)); for ( i=0; i<count; ++i ) { dicts[i] = readcfftopdict(ttf,fontnames!=NULL?fontnames[i]:NULL, offsets[i+1]-offsets[i], info); if ( parent_dict!=NULL && parent_dict->fontmatrix_set ) { MatMultiply(parent_dict->fontmatrix,dicts[i]->fontmatrix,dicts[i]->fontmatrix); } dicts[i]->cff_start = cff_start; } dicts[i] = NULL; free(offsets); return( dicts ); }"
"static void tiffsep_initialize_device_procs(gx_device *dev) { gdev_prn_initialize_device_procs(dev); set_dev_proc(dev, open_device, tiffsep_prn_open); set_dev_proc(dev, close_device, tiffsep_prn_close); set_dev_proc(dev, map_color_rgb, tiffsep_decode_color); set_dev_proc(dev, get_params, tiffsep_get_params); set_dev_proc(dev, put_params, tiffsep_put_params); set_dev_proc(dev, get_color_mapping_procs, tiffsep_get_color_mapping_procs); set_dev_proc(dev, get_color_comp_index, tiffsep_get_color_comp_index); set_dev_proc(dev, encode_color, tiffsep_encode_color); set_dev_proc(dev, decode_color, tiffsep_decode_color); set_dev_proc(dev, update_spot_equivalent_colors, tiffsep_update_spot_equivalent_colors); set_dev_proc(dev, ret_devn_params, tiffsep_ret_devn_params); set_dev_proc(dev, dev_spec_op, tiffsep_spec_op); }"
"void isis_notif_max_area_addr_mismatch(const struct isis_circuit *circuit, uint8_t max_area_addrs, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:max-area-addresses-mismatch""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/max-area-addresses"", xpath); data = yang_data_new_uint8(xpath_arg, max_area_addrs); listnode_add(arguments, data); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_max_area_addr_mismatch, circuit, max_area_addrs, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"static int llcp_sock_create(struct net *net, struct socket *sock, const struct nfc_protocol *nfc_proto, int kern) { struct sock *sk; pr_debug(""%p\n"", sock); if (sock->type != SOCK_STREAM && sock->type != SOCK_DGRAM && sock->type != SOCK_RAW) return -ESOCKTNOSUPPORT; if (sock->type == SOCK_RAW) sock->ops = &llcp_rawsock_ops; else sock->ops = &llcp_sock_ops; sk = nfc_llcp_sock_alloc(sock, sock->type, GFP_ATOMIC, kern); if (sk == NULL) return -ENOMEM; return 0; }"
"static char *clean_path(char *path) { char *ch; char *ch2; char *str; str = xmalloc(strlen(path)); ch = path; ch2 = str; while (true) { *ch2 = *ch; ch++; ch2++; if (!*(ch-1)) break; while (*(ch - 1) == '/' && *ch == '/') ch++; } while ((ch = strrchr(str, '/'))) { if (ch == str) break; if (!*(ch+1)) *ch = 0; else break; } return str; }"
"ssize_t P2PMessageRC2::decode(const byte* buffer, size_t size) { if (size < HEADER_LENGTH) { return dev::network::PACKET_INCOMPLETE; } m_deliveredLength = size; int32_t offset = 0; m_length = ntohl(*((uint32_t*)&buffer[offset])); if (size < m_length) { return dev::network::PACKET_INCOMPLETE; } m_cache->clear(); m_cache->insert(m_cache->end(), buffer, buffer + m_length); offset += sizeof(m_length); m_version = ntohs(*((VERSION_TYPE*)&buffer[offset])); offset += sizeof(m_version); m_protocolID = ntohl(*((PROTOCOL_ID*)&buffer[offset])); offset += sizeof(m_protocolID); m_packetType = ntohs(*((PACKET_TYPE*)&buffer[offset])); offset += sizeof(m_packetType); m_seq = ntohl(*((uint32_t*)&buffer[offset])); if (g_BCOSConfig.compressEnabled() && ((m_version & dev::eth::CompressFlag) == dev::eth::CompressFlag)) { SnappyCompress::uncompress( bytesConstRef((const byte*)(&buffer[HEADER_LENGTH]), m_length - HEADER_LENGTH), *m_buffer); m_version &= (~dev::eth::CompressFlag); } else { m_buffer->assign(&buffer[HEADER_LENGTH], &buffer[HEADER_LENGTH] + m_length - HEADER_LENGTH); } return m_length; }"
"int domain_entry_inc(struct connection *conn, struct node *node) { struct domain *d; unsigned int domid; if (!conn) return 0; domid = node->perms.p ? node->perms.p[0].id : conn->id; if (conn->transaction) { transaction_entry_inc(conn->transaction, domid); } else { d = (domid == conn->id && conn->domain) ? conn->domain : find_or_alloc_existing_domain(domid); if (d) d->nbentry++; else return ENOMEM; } return 0; }"
"static int snd_pcm_control_ioctl(struct snd_card *card, struct snd_ctl_file *control, unsigned int cmd, unsigned long arg) { switch (cmd) { case SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE: { int device; if (get_user(device, (int __user *)arg)) return -EFAULT; mutex_lock(&register_mutex); device = snd_pcm_next(card, device); mutex_unlock(&register_mutex); if (put_user(device, (int __user *)arg)) return -EFAULT; return 0; } case SNDRV_CTL_IOCTL_PCM_INFO: { struct snd_pcm_info __user *info; unsigned int device, subdevice; int stream; struct snd_pcm *pcm; struct snd_pcm_str *pstr; struct snd_pcm_substream *substream; int err; info = (struct snd_pcm_info __user *)arg; if (get_user(device, &info->device)) return -EFAULT; if (get_user(stream, &info->stream)) return -EFAULT; if (stream < 0 || stream > 1) return -EINVAL; if (get_user(subdevice, &info->subdevice)) return -EFAULT; mutex_lock(&register_mutex); pcm = snd_pcm_get(card, device); if (pcm == NULL) { err = -ENXIO; goto _error; } pstr = &pcm->streams[stream]; if (pstr->substream_count == 0) { err = -ENOENT; goto _error; } if (subdevice >= pstr->substream_count) { err = -ENXIO; goto _error; } for (substream = pstr->substream; substream; substream = substream->next) if (substream->number == (int)subdevice) break; if (substream == NULL) { err = -ENXIO; goto _error; } err = snd_pcm_info_user(substream, info); _error: mutex_unlock(&register_mutex); return err; } case SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE: { int val; if (get_user(val, (int __user *)arg)) return -EFAULT; control->preferred_subdevice[SND_CTL_SUBDEV_PCM] = val; return 0; } } return -ENOIOCTLCMD; }"
"void jswrap_spi_send4bit(JsVar *parent, JsVar *srcdata, int bit0, int bit1, Pin nss_pin) { NOT_USED(parent); IOEventFlags device = jsiGetDeviceFromClass(parent); if (!DEVICE_IS_SPI(device)) { jsExceptionHere(JSET_ERROR, ""SPI.send4bit only works on hardware SPI""); return; } jshSPISet16(device, true);  if (bit0==0 && bit1==0) { bit0 = 0x01; bit1 = 0x03; } bit0 = bit0 & 0x0F; bit1 = bit1 & 0x0F; if (!jshIsDeviceInitialised(device)) { JshSPIInfo inf; jshSPIInitInfo(&inf); jshSPISetup(device, &inf); } jshSPISetReceive(device, false); if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, false); if (jsvIsNumeric(srcdata)) { jsspiSend4bit(device, (unsigned char)jsvGetInteger(srcdata), bit0, bit1); } else if (jsvIsIterable(srcdata)) { jshInterruptOff(); JsvIterator it; jsvIteratorNew(&it, srcdata, JSIF_EVERY_ARRAY_ELEMENT); while (jsvIteratorHasElement(&it)) { unsigned char in = (unsigned char)jsvIteratorGetIntegerValue(&it); jsspiSend4bit(device, in, bit0, bit1); jsvIteratorNext(&it); } jsvIteratorFree(&it); jshInterruptOn(); } else { jsExceptionHere(JSET_ERROR, ""Variable type %t not suited to transmit operation"", srcdata); } jshSPIWait(device);  if (nss_pin!=PIN_UNDEFINED) jshPinOutput(nss_pin, true); jshSPISet16(device, false); }"
"OM_uint32 KRB5_CALLCONV gss_pseudo_random (OM_uint32 *minor_status, gss_ctx_id_t context_handle, int prf_key, const gss_buffer_t prf_in, ssize_t desired_output_len, gss_buffer_t prf_out) { OM_uint32status; gss_union_ctx_id_tctx; gss_mechanismmech; if (minor_status == NULL) return GSS_S_CALL_INACCESSIBLE_WRITE; if (context_handle == GSS_C_NO_CONTEXT) return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT; if (prf_in == GSS_C_NO_BUFFER) return GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT; if (prf_out == GSS_C_NO_BUFFER) return GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT; prf_out->length = 0; prf_out->value = NULL; ctx = (gss_union_ctx_id_t) context_handle; mech = gssint_get_mechanism (ctx->mech_type); if (mech != NULL) { if (mech->gss_pseudo_random != NULL) { status = mech->gss_pseudo_random(minor_status, ctx->internal_ctx_id, prf_key, prf_in, desired_output_len, prf_out); if (status != GSS_S_COMPLETE) map_error(minor_status, mech); } else status = GSS_S_UNAVAILABLE; return status; } return GSS_S_BAD_MECH; }"
"static int ssl_verify_cert(struct tunnel *tunnel) { int ret = -1; int cert_valid = 0; unsigned char digest[SHA256LEN]; unsigned int len; struct x509_digest *elem; char digest_str[SHA256STRLEN], *subject, *issuer; char *line; int i; X509_NAME *subj; char common_name[FIELD_SIZE + 1]; SSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL); X509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle); if (cert == NULL) { log_error(""Unable to get gateway certificate.\n""); return 1; } subj = X509_get_subject_name(cert); #ifdef HAVE_X509_CHECK_HOST if (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL)) cert_valid = 1; #else if (subj && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name, FIELD_SIZE) > 0 && strncasecmp(common_name, tunnel->config->gateway_host, FIELD_SIZE) == 0) cert_valid = 1; #endif if (cert_valid && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) { log_debug(""Gateway certificate validation succeeded.\n""); ret = 0; goto free_cert; } log_debug(""Gateway certificate validation failed.\n""); if (X509_digest(cert, EVP_sha256(), digest, &len) <= 0 || len != SHA256LEN) { log_error(""Could not compute certificate sha256 digest.\n""); goto free_cert; } for (i = 0; i < SHA256LEN; i++) sprintf(&digest_str[2 * i], ""%02x"", digest[i]); digest_str[SHA256STRLEN - 1] = '\0'; for (elem = tunnel->config->cert_whitelist; elem != NULL; elem = elem->next) if (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0) break; if (elem != NULL) { log_debug(""Gateway certificate digest found in white list.\n""); ret = 0; goto free_cert; } subject = X509_NAME_oneline(subj, NULL, 0); issuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0); log_error(""Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\n""); log_error(""    --trusted-cert %s\n"", digest_str); log_error(""or add this line to your config file:\n""); log_error(""    trusted-cert = %s\n"", digest_str); log_error(""Gateway certificate:\n""); log_error(""    subject:\n""); for (line = strtok(subject, ""/""); line != NULL; line = strtok(NULL, ""/"")) log_error(""        %s\n"", line); log_error(""    issuer:\n""); for (line = strtok(issuer, ""/""); line != NULL; line = strtok(NULL, ""/"")) log_error(""        %s\n"", line); log_error(""    sha256 digest:\n""); log_error(""        %s\n"", digest_str); free_cert: X509_free(cert); return ret; }"
"static int am_handle_login(request_rec *r) { am_dir_cfg_rec *cfg = am_get_dir_cfg(r); char *idp_param; const char *idp; char *return_to; int is_passive; int ret; return_to = am_extract_query_parameter(r->pool, r->args, ""ReturnTo""); if(return_to == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Missing required ReturnTo parameter.""); return HTTP_BAD_REQUEST; } ret = am_urldecode(return_to); if(ret != OK) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Error urldecoding ReturnTo parameter.""); return ret; } idp_param = am_extract_query_parameter(r->pool, r->args, ""IdP""); if(idp_param != NULL) { ret = am_urldecode(idp_param); if(ret != OK) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Error urldecoding IdP parameter.""); return ret; } } ret = am_get_boolean_query_parameter(r, ""IsPassive"", &is_passive, FALSE); if (ret != OK) { return ret; } if(idp_param != NULL) { idp = idp_param; } else if(cfg->discovery_url) { if(is_passive) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Discovery service with passive authentication request unsupported.""); return HTTP_INTERNAL_SERVER_ERROR; } return am_start_disco(r, return_to); } else { idp = am_get_idp(r); } return am_send_login_authn_request(r, idp, return_to, is_passive); }"
"int handle__publish(struct mosquitto *context) { uint8_t dup; int rc = 0; int rc2; uint8_t header = context->in_packet.command; int res = 0; struct mosquitto_msg_store *msg, *stored = NULL; size_t len; uint16_t slen; char *topic_mount; mosquitto_property *properties = NULL; mosquitto_property *p, *p_prev; mosquitto_property *msg_properties_last; uint32_t message_expiry_interval = 0; int topic_alias = -1; uint8_t reason_code = 0; uint16_t mid = 0; if(context->state != mosq_cs_active){ return MOSQ_ERR_PROTOCOL; } msg = mosquitto__calloc(1, sizeof(struct mosquitto_msg_store)); if(msg == NULL){ return MOSQ_ERR_NOMEM; } dup = (header & 0x08)>>3; msg->qos = (header & 0x06)>>1; if(dup == 1 && msg->qos == 0){ log__printf(NULL, MOSQ_LOG_INFO, ""Invalid PUBLISH (QoS=0 and DUP=1) from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos == 3){ log__printf(NULL, MOSQ_LOG_INFO, ""Invalid QoS in PUBLISH from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos > context->max_qos){ log__printf(NULL, MOSQ_LOG_INFO, ""Too high QoS in PUBLISH from %s, disconnecting."", context->id); db__msg_store_free(msg); return MOSQ_ERR_QOS_NOT_SUPPORTED; } msg->retain = (header & 0x01); if(msg->retain && db.config->retain_available == false){ db__msg_store_free(msg); return MOSQ_ERR_RETAIN_NOT_SUPPORTED; } if(packet__read_string(&context->in_packet, &msg->topic, &slen)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(!slen && context->protocol != mosq_p_mqtt5){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(msg->qos > 0){ if(packet__read_uint16(&context->in_packet, &mid)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } if(mid == 0){ db__msg_store_free(msg); return MOSQ_ERR_PROTOCOL; } msg->source_mid = mid; } if(context->protocol == mosq_p_mqtt5){ rc = property__read_all(CMD_PUBLISH, &context->in_packet, &properties); if(rc){ db__msg_store_free(msg); return rc; } p = properties; p_prev = NULL; msg->properties = NULL; msg_properties_last = NULL; while(p){ switch(p->identifier){ case MQTT_PROP_CONTENT_TYPE: case MQTT_PROP_CORRELATION_DATA: case MQTT_PROP_PAYLOAD_FORMAT_INDICATOR: case MQTT_PROP_RESPONSE_TOPIC: case MQTT_PROP_USER_PROPERTY: if(msg->properties){ msg_properties_last->next = p; msg_properties_last = p; }else{ msg->properties = p; msg_properties_last = p; } if(p_prev){ p_prev->next = p->next; p = p_prev->next; }else{ properties = p->next; p = properties; } msg_properties_last->next = NULL; break; case MQTT_PROP_TOPIC_ALIAS: topic_alias = p->value.i16; p_prev = p; p = p->next; break; case MQTT_PROP_MESSAGE_EXPIRY_INTERVAL: message_expiry_interval = p->value.i32; p_prev = p; p = p->next; break; case MQTT_PROP_SUBSCRIPTION_IDENTIFIER: p_prev = p; p = p->next; break; default: p = p->next; break; } } } mosquitto_property_free_all(&properties); if(topic_alias == 0 || (context->listener && topic_alias > context->listener->max_topic_alias)){ db__msg_store_free(msg); return MOSQ_ERR_TOPIC_ALIAS_INVALID; }else if(topic_alias > 0){ if(msg->topic){ rc = alias__add(context, msg->topic, (uint16_t)topic_alias); if(rc){ db__msg_store_free(msg); return rc; } }else{ rc = alias__find(context, &msg->topic, (uint16_t)topic_alias); if(rc){ db__msg_store_free(msg); return MOSQ_ERR_PROTOCOL; } } } #ifdef WITH_BRIDGE rc = bridge__remap_topic_in(context, &msg->topic); if(rc){ db__msg_store_free(msg); return rc; } #endif if(mosquitto_pub_topic_check(msg->topic) != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } msg->payloadlen = context->in_packet.remaining_length - context->in_packet.pos; G_PUB_BYTES_RECEIVED_INC(msg->payloadlen); if(context->listener && context->listener->mount_point){ len = strlen(context->listener->mount_point) + strlen(msg->topic) + 1; topic_mount = mosquitto__malloc(len+1); if(!topic_mount){ db__msg_store_free(msg); return MOSQ_ERR_NOMEM; } snprintf(topic_mount, len, ""%s%s"", context->listener->mount_point, msg->topic); topic_mount[len] = '\0'; mosquitto__free(msg->topic); msg->topic = topic_mount; } if(msg->payloadlen){ if(db.config->message_size_limit && msg->payloadlen > db.config->message_size_limit){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_PACKET_TOO_LARGE; goto process_bad_message; } msg->payload = mosquitto__malloc(msg->payloadlen+1); if(msg->payload == NULL){ db__msg_store_free(msg); return MOSQ_ERR_NOMEM; } ((uint8_t *)msg->payload)[msg->payloadlen] = 0; if(packet__read_bytes(&context->in_packet, msg->payload, msg->payloadlen)){ db__msg_store_free(msg); return MOSQ_ERR_MALFORMED_PACKET; } } rc = mosquitto_acl_check(context, msg->topic, msg->payloadlen, msg->payload, msg->qos, msg->retain, MOSQ_ACL_WRITE); if(rc == MOSQ_ERR_ACL_DENIED){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_NOT_AUTHORIZED; goto process_bad_message; }else if(rc != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return rc; } log__printf(NULL, MOSQ_LOG_DEBUG, ""Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); if(!strncmp(msg->topic, ""$CONTROL/"", 9)){ #ifdef WITH_CONTROL rc = control__process(context, msg); db__msg_store_free(msg); return rc; #else reason_code = MQTT_RC_IMPLEMENTATION_SPECIFIC; goto process_bad_message; #endif } { rc = plugin__handle_message(context, msg); if(rc == MOSQ_ERR_ACL_DENIED){ log__printf(NULL, MOSQ_LOG_DEBUG, ""Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))"", context->id, dup, msg->qos, msg->retain, msg->source_mid, msg->topic, (long)msg->payloadlen); reason_code = MQTT_RC_NOT_AUTHORIZED; goto process_bad_message; }else if(rc != MOSQ_ERR_SUCCESS){ db__msg_store_free(msg); return rc; } } if(msg->qos > 0){ db__message_store_find(context, msg->source_mid, &stored); } if(stored && msg->source_mid != 0 && (stored->qos != msg->qos || stored->payloadlen != msg->payloadlen || strcmp(stored->topic, msg->topic) || memcmp(stored->payload, msg->payload, msg->payloadlen) )){ log__printf(NULL, MOSQ_LOG_WARNING, ""Reused message ID %u from %s detected. Clearing from storage."", msg->source_mid, context->id); db__message_remove_incoming(context, msg->source_mid); stored = NULL; } if(!stored){ if(msg->qos == 0 || db__ready_for_flight(context, mosq_md_in, msg->qos) || db__ready_for_queue(context, msg->qos, &context->msgs_in)){ dup = 0; rc = db__message_store(context, msg, message_expiry_interval, 0, mosq_mo_client); if(rc) return rc; }else{ reason_code = MQTT_RC_QUOTA_EXCEEDED; goto process_bad_message; } stored = msg; msg = NULL; }else{ db__msg_store_free(msg); msg = NULL; dup = 1; } switch(stored->qos){ case 0: rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored); if(rc2 > 0) rc = 1; break; case 1: util__decrement_receive_quota(context); rc2 = sub__messages_queue(context->id, stored->topic, stored->qos, stored->retain, &stored); if(rc2 == MOSQ_ERR_SUCCESS || context->protocol != mosq_p_mqtt5){ if(send__puback(context, mid, 0, NULL)) rc = 1; }else if(rc2 == MOSQ_ERR_NO_SUBSCRIBERS){ if(send__puback(context, mid, MQTT_RC_NO_MATCHING_SUBSCRIBERS, NULL)) rc = 1; }else{ rc = rc2; } break; case 2: if(dup == 0){ res = db__message_insert(context, stored->source_mid, mosq_md_in, stored->qos, stored->retain, stored, NULL, false); }else{ res = 0; } if(!res){ if(send__pubrec(context, stored->source_mid, 0, NULL)) rc = 1; }else if(res == 1){ rc = 1; } break; } db__message_write_queued_in(context); return rc; process_bad_message: rc = 1; if(msg){ switch(msg->qos){ case 0: rc = MOSQ_ERR_SUCCESS; break; case 1: rc = send__puback(context, msg->source_mid, reason_code, NULL); break; case 2: rc = send__pubrec(context, msg->source_mid, reason_code, NULL); break; } db__msg_store_free(msg); } return rc; }"
"static int hostlist_matches_int(const struct sudoers_parse_tree *parse_tree, const struct passwd *pw, const char *lhost, const char *shost, const struct member_list *list) { struct member *m; int matched = UNSPEC; debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH); TAILQ_FOREACH_REVERSE(m, list, member_list, entries) { matched = host_matches(parse_tree, pw, lhost, shost, m); if (matched != UNSPEC) break; } debug_return_int(matched); }"
"static ssize_t ib_ucm_write(struct file *filp, const char __user *buf, size_t len, loff_t *pos) { struct ib_ucm_file *file = filp->private_data; struct ib_ucm_cmd_hdr hdr; ssize_t result; if (len < sizeof(hdr)) return -EINVAL; if (copy_from_user(&hdr, buf, sizeof(hdr))) return -EFAULT; if (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table)) return -EINVAL; if (hdr.in + sizeof(hdr) > len) return -EINVAL; result = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out); if (!result) result = len; return result; }"
"AsyncSocket::WriteResult AsyncSSLSocket::performWrite( const iovec* vec, uint32_t count, WriteFlags flags, uint32_t* countWritten, uint32_t* partialWritten) { if (sslState_ == STATE_UNENCRYPTED) { return AsyncSocket::performWrite( vec, count, flags, countWritten, partialWritten); } if (sslState_ != STATE_ESTABLISHED) { LOG(ERROR) << ""AsyncSSLSocket(fd="" << fd_ << "", state="" << int(state_) << "", sslState="" << sslState_ << "", events="" << eventFlags_ << ""): "" << ""TODO: AsyncSSLSocket currently does not support calling "" << ""write() before the handshake has fully completed""; return WriteResult( WRITE_ERROR, std::make_unique<SSLException>(SSLError::EARLY_WRITE)); } char* combinedBuf{nullptr}; SCOPE_EXIT { if (combinedBuf != nullptr && minWriteSize_ > MAX_STACK_BUF_SIZE) { delete[] combinedBuf; } }; *countWritten = 0; *partialWritten = 0; ssize_t totalWritten = 0; size_t bytesStolenFromNextBuffer = 0; for (uint32_t i = 0; i < count; i++) { const iovec* v = vec + i; size_t offset = bytesStolenFromNextBuffer; bytesStolenFromNextBuffer = 0; size_t len = v->iov_len - offset; const void* buf; if (len == 0) { (*countWritten)++; continue; } buf = ((const char*)v->iov_base) + offset; ssize_t bytes; uint32_t buffersStolen = 0; auto sslWriteBuf = buf; if ((len < minWriteSize_) && ((i + 1) < count)) { if (combinedBuf == nullptr) { if (minWriteSize_ > MAX_STACK_BUF_SIZE) { combinedBuf = new char[minWriteSize_]; } else { combinedBuf = (char*)alloca(minWriteSize_); } } assert(combinedBuf != nullptr); sslWriteBuf = combinedBuf; memcpy(combinedBuf, buf, len); do { uint32_t nextIndex = i + buffersStolen + 1; bytesStolenFromNextBuffer = std::min(vec[nextIndex].iov_len, minWriteSize_ - len); if (bytesStolenFromNextBuffer > 0) { assert(vec[nextIndex].iov_base != nullptr); ::memcpy( combinedBuf + len, vec[nextIndex].iov_base, bytesStolenFromNextBuffer); } len += bytesStolenFromNextBuffer; if (bytesStolenFromNextBuffer < vec[nextIndex].iov_len) { break; } else { bytesStolenFromNextBuffer = 0; buffersStolen++; } } while ((i + buffersStolen + 1) < count && (len < minWriteSize_)); } if (bytesStolenFromNextBuffer == 0) { while ((i + buffersStolen + 1) < count && vec[i + buffersStolen + 1].iov_len == 0) { buffersStolen++; } } corkCurrentWrite_ = isSet(flags, WriteFlags::CORK) || (i + buffersStolen + 1 < count); appEorByteWriteFlags_ = flags & kEorRelevantWriteFlags; bool trackEor = appEorByteWriteFlags_ != folly::WriteFlags::NONE && (i + buffersStolen + 1 == count); bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor); if (bytes <= 0) { int error = SSL_get_error(ssl_.get(), int(bytes)); if (error == SSL_ERROR_WANT_WRITE) { *partialWritten = uint32_t(offset); return WriteResult(totalWritten); } auto writeResult = interpretSSLError(int(bytes), error); if (writeResult.writeReturn < 0) { return writeResult; }     } totalWritten += bytes; if (bytes == (ssize_t)len) { (*countWritten) += 1 + buffersStolen; i += buffersStolen; } else { bytes += offset;       while (bytes >= (ssize_t)v->iov_len) { bytes -= v->iov_len; (*countWritten)++; v = &(vec[++i]); } *partialWritten = uint32_t(bytes); return WriteResult(totalWritten); } } return WriteResult(totalWritten); }"
"static char *uncompress(int16_t field_count, char *start, char *end, char *ptr, char *uncompressed, int uncomp_len, char **uncompressed_ptr) { char *uptr = *uncompressed_ptr;  debug(""count %d ptr %p end %p uptr %p"", field_count, ptr, end, uptr); while (field_count-- > 0 && ptr < end) { int dlen; int ulen; int pos; char name[NS_MAXLABEL];  uint16_t dns_type, dns_class; int comp_pos; if (!convert_label(start, end, ptr, name, NS_MAXLABEL, &pos, &comp_pos)) goto out; ulen = strlen(name); strncpy(uptr, name, uncomp_len - (uptr - uncompressed)); debug(""pos %d ulen %d left %d name %s"", pos, ulen, (int)(uncomp_len - (uptr - uncompressed)), uptr); uptr += ulen; *uptr++ = '\0'; ptr += pos; memcpy(uptr, ptr, NS_RRFIXEDSZ); dns_type = uptr[0] << 8 | uptr[1]; dns_class = uptr[2] << 8 | uptr[3]; if (dns_class != ns_c_in) goto out; ptr += NS_RRFIXEDSZ; uptr += NS_RRFIXEDSZ; if (dns_type == ns_t_cname) { if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; uptr[-2] = comp_pos << 8; uptr[-1] = comp_pos & 0xff; uptr += comp_pos; ptr += pos; } else if (dns_type == ns_t_a || dns_type == ns_t_aaaa) { dlen = uptr[-2] << 8 | uptr[-1]; if (ptr + dlen > end) { debug(""data len %d too long"", dlen); goto out; } memcpy(uptr, ptr, dlen); uptr += dlen; ptr += dlen; } else if (dns_type == ns_t_soa) { int total_len = 0; char *len_ptr; if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; total_len += comp_pos; len_ptr = &uptr[-2]; ptr += pos; uptr += comp_pos; if (!convert_label(start, end, ptr, uptr, uncomp_len - (uptr - uncompressed), &pos, &comp_pos)) goto out; total_len += comp_pos; ptr += pos; uptr += comp_pos; memcpy(uptr, ptr, 20); uptr += 20; ptr += 20; total_len += 20; len_ptr[0] = total_len << 8; len_ptr[1] = total_len & 0xff; } *uncompressed_ptr = uptr; } return ptr; out: return NULL; }"
"void irc_server_set_prefix_modes_chars (struct t_irc_server *server, const char *prefix) { char *pos; int i, length_modes, length_chars; if (!server || !prefix) return; if (server->prefix_modes) { free (server->prefix_modes); server->prefix_modes = NULL; } if (server->prefix_chars) { free (server->prefix_chars); server->prefix_chars = NULL; } pos = strchr (prefix, ')'); if (pos) { server->prefix_modes = weechat_strndup (prefix + 1, pos - prefix - 1); if (server->prefix_modes) { pos++; length_modes = strlen (server->prefix_modes); length_chars = strlen (pos); server->prefix_chars = malloc (length_modes + 1); if (server->prefix_chars) { for (i = 0; i < length_modes; i++) { server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' '; } server->prefix_chars[length_modes] = '\0'; } else { free (server->prefix_modes); server->prefix_modes = NULL; } } } }"
"static gboolean imapx_connect_to_server (CamelIMAPXServer *is, GCancellable *cancellable, GError **error) { CamelNetworkSettings *network_settings; CamelNetworkSecurityMethod method; CamelIMAPXStore *store; CamelSettings *settings; GIOStream *connection = NULL; GIOStream *tls_stream; GSocket *socket; guint len; guchar *token; gint tok; CamelIMAPXCommand *ic; gchar *shell_command = NULL; gboolean use_shell_command; gboolean success = TRUE; gchar *host; store = camel_imapx_server_ref_store (is); settings = camel_service_ref_settings (CAMEL_SERVICE (store)); network_settings = CAMEL_NETWORK_SETTINGS (settings); host = camel_network_settings_dup_host (network_settings); method = camel_network_settings_get_security_method (network_settings); use_shell_command = camel_imapx_settings_get_use_shell_command ( CAMEL_IMAPX_SETTINGS (settings)); if (use_shell_command) shell_command = camel_imapx_settings_dup_shell_command ( CAMEL_IMAPX_SETTINGS (settings)); g_object_unref (settings); if (shell_command != NULL) { success = connect_to_server_process (is, shell_command, error); g_free (shell_command); if (success) goto connected; else goto exit; } connection = camel_network_service_connect_sync ( CAMEL_NETWORK_SERVICE (store), cancellable, error); if (connection != NULL) { GInputStream *input_stream; GOutputStream *output_stream; GError *local_error = NULL; socket = g_socket_connection_get_socket ( G_SOCKET_CONNECTION (connection)); g_socket_set_option ( socket, IPPROTO_TCP, TCP_NODELAY, 1, &local_error); if (local_error != NULL) { g_warning (""%s: %s"", G_STRFUNC, local_error->message); g_clear_error (&local_error); } g_mutex_lock (&is->priv->stream_lock); g_warn_if_fail (is->priv->connection == NULL); is->priv->connection = g_object_ref (connection); g_mutex_unlock (&is->priv->stream_lock); input_stream = g_io_stream_get_input_stream (connection); output_stream = g_io_stream_get_output_stream (connection); imapx_server_set_streams (is, input_stream, output_stream); } else { success = FALSE; goto exit; } connected: while (1) { GInputStream *input_stream; input_stream = camel_imapx_server_ref_input_stream (is); token = NULL; tok = camel_imapx_input_stream_token ( CAMEL_IMAPX_INPUT_STREAM (input_stream), &token, &len, cancellable, error); if (tok < 0) { success = FALSE; } else if (tok == '*') { success = imapx_untagged ( is, input_stream, cancellable, error); if (success) { g_object_unref (input_stream); break; } } else { camel_imapx_input_stream_ungettoken ( CAMEL_IMAPX_INPUT_STREAM (input_stream), tok, token, len); success = camel_imapx_input_stream_text ( CAMEL_IMAPX_INPUT_STREAM (input_stream), &token, cancellable, error); g_free (token); } g_object_unref (input_stream); if (!success) goto exit; } g_mutex_lock (&is->priv->stream_lock); if (!is->priv->cinfo) { g_mutex_unlock (&is->priv->stream_lock); ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, ""CAPABILITY""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to get capabilities""), cancellable, error); camel_imapx_command_unref (ic); if (!success) goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } if (method == CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) { g_mutex_lock (&is->priv->stream_lock); if (CAMEL_IMAPX_LACK_CAPABILITY (is->priv->cinfo, STARTTLS)) { g_mutex_unlock (&is->priv->stream_lock); g_set_error ( error, CAMEL_ERROR, CAMEL_ERROR_GENERIC, _(""Failed to connect to IMAP server %s in secure mode: %s""), host, _(""STARTTLS not supported"")); success = FALSE; goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_STARTTLS, ""STARTTLS""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to issue STARTTLS""), cancellable, error); if (success) { g_mutex_lock (&is->priv->stream_lock); imapx_free_capability (is->priv->cinfo); is->priv->cinfo = NULL; if (ic->status->condition == IMAPX_CAPABILITY) { is->priv->cinfo = ic->status->u.cinfo; ic->status->u.cinfo = NULL; c (is->priv->tagprefix, ""got capability flags %08x\n"", is->priv->cinfo ? is->priv->cinfo->capa : 0xFFFFFFFF); imapx_server_stash_command_arguments (is); } g_mutex_unlock (&is->priv->stream_lock); } camel_imapx_command_unref (ic); if (!success) goto exit; tls_stream = camel_network_service_starttls ( CAMEL_NETWORK_SERVICE (store), connection, error); if (tls_stream != NULL) { GInputStream *input_stream; GOutputStream *output_stream; g_mutex_lock (&is->priv->stream_lock); g_object_unref (is->priv->connection); is->priv->connection = g_object_ref (tls_stream); g_mutex_unlock (&is->priv->stream_lock); input_stream = g_io_stream_get_input_stream (tls_stream); output_stream = g_io_stream_get_output_stream (tls_stream); imapx_server_set_streams ( is, input_stream, output_stream); g_object_unref (tls_stream); } else { g_prefix_error ( error, _(""Failed to connect to IMAP server %s in secure mode: ""), host); success = FALSE; goto exit; } g_mutex_lock (&is->priv->stream_lock); if (is->priv->cinfo == NULL) { g_mutex_unlock (&is->priv->stream_lock); ic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_CAPABILITY, ""CAPABILITY""); success = camel_imapx_server_process_command_sync (is, ic, _(""Failed to get capabilities""), cancellable, error); camel_imapx_command_unref (ic); if (!success) goto exit; } else { g_mutex_unlock (&is->priv->stream_lock); } } exit: if (!success) { g_mutex_lock (&is->priv->stream_lock); g_clear_object (&is->priv->input_stream); g_clear_object (&is->priv->output_stream); g_clear_object (&is->priv->connection); g_clear_object (&is->priv->subprocess); if (is->priv->cinfo != NULL) { imapx_free_capability (is->priv->cinfo); is->priv->cinfo = NULL; } g_mutex_unlock (&is->priv->stream_lock); } g_free (host); g_clear_object (&connection); g_clear_object (&store); return success; }"
"bool HHVM_FUNCTION(apc_store_as_primed_do_not_use, const String& key, const Variant& var) { if (!apcExtension::Enable) return false; apc_store().setWithoutTTL(key, var); return true; }"
"static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx) { uint16_t mss; if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0) return; t->mss_ok = 1; mss = short_from(opt + *idx); *idx += (uint32_t)sizeof(uint16_t); if (t->mss > short_be(mss)) t->mss = short_be(mss); }"
"static const struct nfsd4_layout_ops * nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type) { if (!exp->ex_layout_types) { dprintk(""%s: export does not support pNFS\n"", __func__); return NULL; } if (!(exp->ex_layout_types & (1 << layout_type))) { dprintk(""%s: layout type %d not supported\n"", __func__, layout_type); return NULL; } return nfsd4_layout_ops[layout_type]; }"
"void Compile(XlaOpKernelContext* ctx) override { int64_t output_size; xla::XlaOp output_size_param = ctx->Input(""size""); StatusOr<xla::Shape> output_shape_or = ctx->builder()->GetShape(output_size_param); OP_REQUIRES_OK(ctx, output_shape_or.status()); auto output_shape_param = output_shape_or.ValueOrDie(); auto output_rank = output_shape_param.rank(); OP_REQUIRES(ctx, output_rank == 0, errors::InvalidArgument(""Shape must be rank 0 but is rank "", output_rank)); OP_REQUIRES_OK(ctx, ctx->ConstantInputAsIntScalar(""size"", &output_size)); OP_REQUIRES(ctx, output_size >= 0, errors::InvalidArgument(""size ("", output_size, "") must be non-negative"")); xla::XlaOp idx, updates, output; xla::XlaOp input = ctx->Input(0); auto input_xla_type = ctx->input_xla_type(0); xla::PrimitiveType dtype = ctx->InputXlaType(""weights""); auto zero = xla::Zero(ctx->builder(), dtype); auto one = xla::One(ctx->builder(), dtype); StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input); OP_REQUIRES_OK(ctx, input_shape_or.status()); auto input_shape = input_shape_or.ValueOrDie(); auto size = input_shape.dimensions(0); if (!size) { output = xla::Broadcast(zero, {output_size}); ctx->SetOutput(0, output); return; } auto rank = input_shape.rank(); OP_REQUIRES(ctx, rank <= 2, errors::InvalidArgument( ""Shape must be at most rank 2 but is rank "", rank)); xla::XlaOp weights = ctx->Input(2); StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights); OP_REQUIRES_OK(ctx, weights_shape_or.status()); auto weights_shape = weights_shape_or.ValueOrDie(); auto weights_size = weights_shape.dimensions(0); bool has_weights = false; if (weights_size) { has_weights = true; } xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size}); xla::ScatterDimensionNumbers scatter_dnums; scatter_dnums.set_index_vector_dim(1); scatter_dnums.add_inserted_window_dims(0); scatter_dnums.add_scatter_dims_to_operand_dims(0); if (rank == 2) { output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size}); scatter_dnums.add_inserted_window_dims(1); scatter_dnums.add_scatter_dims_to_operand_dims(1); auto i_shape = xla::ShapeUtil::MakeShape(input_xla_type, {input_shape.dimensions()}); auto i = xla::Iota(ctx->builder(), i_shape, 0); i = xla::Reshape( i, {input_shape.dimensions(0) * input_shape.dimensions(1), 1}); auto j = xla::Reshape( input, {input_shape.dimensions(0) * input_shape.dimensions(1), 1}); std::vector<xla::XlaOp> iotas_to_concat; iotas_to_concat.push_back(i); iotas_to_concat.push_back(j); idx = xla::ConcatInDim(ctx->builder(), iotas_to_concat, 1); updates = xla::Broadcast( one, {input_shape.dimensions(0) * input_shape.dimensions(1)}); output = xla::Broadcast( zero, {output_shape.dimensions(0), output_shape.dimensions(1)}); if (has_weights && !binary_output_) { weights = xla::Reshape( weights, {input_shape.dimensions(0) * input_shape.dimensions(1)}); updates = weights; } } else { input = xla::Reshape(input, {size, 1}); idx = xla::Reshape(input, {size, 1}); updates = xla::Broadcast(one, {size}); output = xla::Broadcast(zero, {output_size}); if (has_weights && !binary_output_) { updates = weights; } } xla::XlaComputation assn_computation = [&] { std::unique_ptr<xla::XlaBuilder> subb = ctx->builder()->CreateSubBuilder(""scatter_bincount""); xla::Shape param_shape = xla::ShapeUtil::MakeShape(dtype, {}); auto p0 = xla::Parameter(subb.get(), 0, param_shape, ""p0""); auto p1 = xla::Parameter(subb.get(), 1, param_shape, ""p1""); if (!binary_output_) { xla::Add(p0, p1); } return subb->BuildAndNoteError(); }(); output = xla::Scatter(output, idx, updates, assn_computation, scatter_dnums, false, false); ctx->SetOutput(0, output); }"
"static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_Obj *obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) { Jsi_ValueMakeNumber(interp, ret, 0); return JSI_OK; } obj = _this->d.obj; int argc = Jsi_ValueGetLength(interp, args); int curlen = jsi_SizeOfArray(interp, obj);     int i; for (i = 0; i < argc; ++i) { Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i); if (!ov) { Jsi_LogBug(""Arguments Error""); ov = Jsi_ValueNew(interp); } Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0); } Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj)); return JSI_OK; }"
"combined_entry_type * coff_get_normalized_symtab (bfd *abfd) { combined_entry_type *internal; combined_entry_type *internal_ptr; combined_entry_type *symbol_ptr; combined_entry_type *internal_end; size_t symesz; char *raw_src; char *raw_end; const char *string_table = NULL; asection * debug_sec = NULL; char *debug_sec_data = NULL; bfd_size_type size; if (obj_raw_syments (abfd) != NULL) return obj_raw_syments (abfd); if (! _bfd_coff_get_external_symbols (abfd)) return NULL; size = obj_raw_syment_count (abfd) * sizeof (combined_entry_type); internal = (combined_entry_type *) bfd_zalloc (abfd, size); if (internal == NULL && size != 0) return NULL; internal_end = internal + obj_raw_syment_count (abfd); raw_src = (char *) obj_coff_external_syms (abfd); symesz = bfd_coff_symesz (abfd); raw_end = (char *) raw_src + obj_raw_syment_count (abfd) * symesz; for (internal_ptr = internal; raw_src < raw_end; raw_src += symesz, internal_ptr++) { unsigned int i; bfd_coff_swap_sym_in (abfd, (void *) raw_src, (void *) & internal_ptr->u.syment); symbol_ptr = internal_ptr; internal_ptr->is_sym = TRUE; if (symbol_ptr->u.syment.n_sclass == C_FILE && symbol_ptr->u.syment.n_numaux > 0 && raw_src + symesz + symbol_ptr->u.syment.n_numaux * symesz > raw_end) { bfd_release (abfd, internal); return NULL; } for (i = 0; i < symbol_ptr->u.syment.n_numaux; i++) { internal_ptr++; if (internal_ptr >= internal_end) { bfd_release (abfd, internal); return NULL; } raw_src += symesz; bfd_coff_swap_aux_in (abfd, (void *) raw_src, symbol_ptr->u.syment.n_type, symbol_ptr->u.syment.n_sclass, (int) i, symbol_ptr->u.syment.n_numaux, &(internal_ptr->u.auxent)); internal_ptr->is_sym = FALSE; coff_pointerize_aux (abfd, internal, symbol_ptr, i, internal_ptr); } } obj_coff_keep_strings (abfd) = TRUE; if (! _bfd_coff_free_symbols (abfd)) return NULL; for (internal_ptr = internal; internal_ptr < internal_end; internal_ptr++) { BFD_ASSERT (internal_ptr->is_sym); if (internal_ptr->u.syment.n_sclass == C_FILE && internal_ptr->u.syment.n_numaux > 0) { combined_entry_type * aux = internal_ptr + 1; BFD_ASSERT (! aux->is_sym); if (aux->u.auxent.x_file.x_n.x_zeroes == 0) { if (string_table == NULL) { string_table = _bfd_coff_read_string_table (abfd); if (string_table == NULL) return NULL; } if ((bfd_size_type)(aux->u.auxent.x_file.x_n.x_offset) >= obj_coff_strings_len (abfd)) internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(""<corrupt>""); else internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) (string_table + (aux->u.auxent.x_file.x_n.x_offset)); } else { if (internal_ptr->u.syment.n_numaux > 1 && coff_data (abfd)->pe) internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) copy_name (abfd, aux->u.auxent.x_file.x_fname, internal_ptr->u.syment.n_numaux * symesz); else internal_ptr->u.syment._n._n_n._n_offset = ((bfd_hostptr_t) copy_name (abfd, aux->u.auxent.x_file.x_fname, (size_t) bfd_coff_filnmlen (abfd))); } } else { if (internal_ptr->u.syment._n._n_n._n_zeroes != 0) { size_t i; char *newstring; for (i = 0; i < 8; ++i) if (internal_ptr->u.syment._n._n_name[i] == '\0') break; newstring = (char *) bfd_zalloc (abfd, (bfd_size_type) (i + 1)); if (newstring == NULL) return NULL; strncpy (newstring, internal_ptr->u.syment._n._n_name, i); internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) newstring; internal_ptr->u.syment._n._n_n._n_zeroes = 0; } else if (internal_ptr->u.syment._n._n_n._n_offset == 0) internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) """"; else if (!bfd_coff_symname_in_debug (abfd, &internal_ptr->u.syment)) { if (string_table == NULL) { string_table = _bfd_coff_read_string_table (abfd); if (string_table == NULL) return NULL; } if (internal_ptr->u.syment._n._n_n._n_offset >= obj_coff_strings_len (abfd) || string_table + internal_ptr->u.syment._n._n_n._n_offset < string_table) internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(""<corrupt>""); else internal_ptr->u.syment._n._n_n._n_offset = ((bfd_hostptr_t) (string_table + internal_ptr->u.syment._n._n_n._n_offset)); } else { if (debug_sec_data == NULL) debug_sec_data = build_debug_section (abfd, & debug_sec); if (debug_sec_data != NULL) { BFD_ASSERT (debug_sec != NULL); if (internal_ptr->u.syment._n._n_n._n_offset > debug_sec->size || debug_sec_data + internal_ptr->u.syment._n._n_n._n_offset < debug_sec_data) internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) _(""<corrupt>""); else internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) (debug_sec_data + internal_ptr->u.syment._n._n_n._n_offset); } else internal_ptr->u.syment._n._n_n._n_offset = (bfd_hostptr_t) """"; } } internal_ptr += internal_ptr->u.syment.n_numaux; } obj_raw_syments (abfd) = internal; BFD_ASSERT (obj_raw_syment_count (abfd) == (unsigned int) (internal_ptr - internal)); return internal; }"
"status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) { if (mSyncSampleOffset >= 0 || data_size < 8) { return ERROR_MALFORMED; } uint8_t header[8]; if (mDataSource->readAt( data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) { return ERROR_IO; } if (U32_AT(header) != 0) { return ERROR_MALFORMED; } uint32_t numSyncSamples = U32_AT(&header[4]); if (numSyncSamples < 2) { ALOGV(""Table of sync samples is empty or has only a single entry!""); } uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t); if (allocSize > kMaxTotalSize) { ALOGE(""Sync sample table size too large.""); return ERROR_OUT_OF_RANGE; } mTotalSize += allocSize; if (mTotalSize > kMaxTotalSize) { ALOGE(""Sync sample table size would make sample table too large.\n"" ""    Requested sync sample table size = %llu\n"" ""    Eventual sample table size >= %llu\n"" ""    Allowed sample table size = %llu\n"", (unsigned long long)allocSize, (unsigned long long)mTotalSize, (unsigned long long)kMaxTotalSize); return ERROR_OUT_OF_RANGE; } mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples]; if (!mSyncSamples) { ALOGE(""Cannot allocate sync sample table with %llu entries."", (unsigned long long)numSyncSamples); return ERROR_OUT_OF_RANGE; } if (mDataSource->readAt(data_offset + 8, mSyncSamples, (size_t)allocSize) != (ssize_t)allocSize) { delete mSyncSamples; mSyncSamples = NULL; return ERROR_IO; } for (size_t i = 0; i < numSyncSamples; ++i) { if (mSyncSamples[i] == 0) { ALOGE(""b/32423862, unexpected zero value in stss""); continue; } mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1; } mSyncSampleOffset = data_offset; mNumSyncSamples = numSyncSamples; return OK; }"
"static int bpf_map_do_batch(const union bpf_attr *attr, union bpf_attr __user *uattr, int cmd) { struct bpf_map *map; int err, ufd; struct fd f; if (CHECK_ATTR(BPF_MAP_BATCH)) return -EINVAL; ufd = attr->batch.map_fd; f = fdget(ufd); map = __bpf_map_get(f); if (IS_ERR(map)) return PTR_ERR(map); if ((cmd == BPF_MAP_LOOKUP_BATCH || cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) && !(map_get_sys_perms(map, f) & FMODE_CAN_READ)) { err = -EPERM; goto err_put; } if (cmd != BPF_MAP_LOOKUP_BATCH && !(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) { err = -EPERM; goto err_put; } if (cmd == BPF_MAP_LOOKUP_BATCH) BPF_DO_BATCH(map->ops->map_lookup_batch); else if (cmd == BPF_MAP_LOOKUP_AND_DELETE_BATCH) BPF_DO_BATCH(map->ops->map_lookup_and_delete_batch); else if (cmd == BPF_MAP_UPDATE_BATCH) BPF_DO_BATCH(map->ops->map_update_batch); else BPF_DO_BATCH(map->ops->map_delete_batch); err_put: fdput(f); return err; }"
"CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id, UncompressedComponents *const colldata) { Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks; BlockBasedImagePerChannel<false> image_data; for (int i = 0; i < colldata->get_num_components(); ++i) { component_size_in_blocks[i] = colldata->component_size_in_blocks(i); image_data[i] = &colldata->full_component_write((BlockType)i); } Sirikata::Array1d<uint32_t, (size_t)ColorChannel::NumBlockTypes> max_coded_heights = colldata->get_max_coded_heights(); dev_assert(luma_splits_.size() == 2);     int min_y = luma_splits_[0]; int max_y = luma_splits_[1]; while(true) { RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights); if (cur_row.done) { break; } if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) { break; } if (cur_row.skip) { continue; } if (cur_row.luma_y < min_y) { continue; } decode_rowf(image_data, component_size_in_blocks, cur_row.component, cur_row.curr_y); if (thread_id == 0) { colldata->worker_update_cmp_progress((BlockType)cur_row.component, image_data[cur_row.component]->block_width() ); } return CODING_PARTIAL; } return CODING_DONE; }"
"INLINE LOCAL(void) h2v2_merged_upsample_565_internal(j_decompress_ptr cinfo, JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf) { my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample; register int y, cred, cgreen, cblue; int cb, cr; register JSAMPROW outptr0, outptr1; JSAMPROW inptr00, inptr01, inptr1, inptr2; JDIMENSION col; register JSAMPLE *range_limit = cinfo->sample_range_limit; int *Crrtab = upsample->Cr_r_tab; int *Cbbtab = upsample->Cb_b_tab; JLONG *Crgtab = upsample->Cr_g_tab; JLONG *Cbgtab = upsample->Cb_g_tab; unsigned int r, g, b; JLONG rgb; SHIFT_TEMPS inptr00 = input_buf[0][in_row_group_ctr * 2]; inptr01 = input_buf[0][in_row_group_ctr * 2 + 1]; inptr1 = input_buf[1][in_row_group_ctr]; inptr2 = input_buf[2][in_row_group_ctr]; outptr0 = output_buf[0]; outptr1 = output_buf[1]; for (col = cinfo->output_width >> 1; col > 0; col--) { cb = GETJSAMPLE(*inptr1++); cr = GETJSAMPLE(*inptr2++); cred = Crrtab[cr]; cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS); cblue = Cbbtab[cb]; y  = GETJSAMPLE(*inptr00++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); y  = GETJSAMPLE(*inptr00++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b)); WRITE_TWO_PIXELS(outptr0, rgb); outptr0 += 4; y  = GETJSAMPLE(*inptr01++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); y  = GETJSAMPLE(*inptr01++); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_TWO_PIXELS(rgb, PACK_SHORT_565(r, g, b)); WRITE_TWO_PIXELS(outptr1, rgb); outptr1 += 4; } if (cinfo->output_width & 1) { cb = GETJSAMPLE(*inptr1); cr = GETJSAMPLE(*inptr2); cred = Crrtab[cr]; cgreen = (int)RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS); cblue = Cbbtab[cb]; y  = GETJSAMPLE(*inptr00); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); *(INT16 *)outptr0 = (INT16)rgb; y  = GETJSAMPLE(*inptr01); r = range_limit[y + cred]; g = range_limit[y + cgreen]; b = range_limit[y + cblue]; rgb = PACK_SHORT_565(r, g, b); *(INT16 *)outptr1 = (INT16)rgb; } }"
"static int get_info(struct net *net, void __user *user, const int *len) { char name[XT_TABLE_MAXNAMELEN]; struct xt_table *t; int ret; if (*len != sizeof(struct ipt_getinfo)) return -EINVAL; if (copy_from_user(name, user, sizeof(name)) != 0) return -EFAULT; name[XT_TABLE_MAXNAMELEN-1] = '\0'; #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_lock(AF_INET); #endif t = xt_request_find_table_lock(net, AF_INET, name); if (!IS_ERR(t)) { struct ipt_getinfo info; const struct xt_table_info *private = t->private; #ifdef CONFIG_COMPAT struct xt_table_info tmp; if (in_compat_syscall()) { ret = compat_table_info(private, &tmp); xt_compat_flush_offsets(AF_INET); private = &tmp; } #endif memset(&info, 0, sizeof(info)); info.valid_hooks = t->valid_hooks; memcpy(info.hook_entry, private->hook_entry, sizeof(info.hook_entry)); memcpy(info.underflow, private->underflow, sizeof(info.underflow)); info.num_entries = private->number; info.size = private->size; strcpy(info.name, name); if (copy_to_user(user, &info, *len) != 0) ret = -EFAULT; else ret = 0; xt_table_unlock(t); module_put(t->me); } else ret = PTR_ERR(t); #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_unlock(AF_INET); #endif return ret; }"
"int is_manager_apk(char *path) { return check_v2_signature(path, ksu_expected_size, ksu_expected_hash); }"
"static int ohci_bus_start(OHCIState *ohci) { ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, ohci_frame_boundary, ohci); if (ohci->eof_timer == NULL) { trace_usb_ohci_bus_eof_timer_failed(ohci->name); ohci_die(ohci); return 0; } trace_usb_ohci_start(ohci->name); ohci_eof_timer(ohci); return 1; }"
"static int ins_compl_add( char_u*str, intlen, char_u*fname, char_u**cptext,        typval_T*user_data UNUSED,      intcdir, intflags_arg, intadup){ compl_T*match; intdir = (cdir == 0 ? compl_direction : cdir); intflags = flags_arg; if (flags & CP_FAST) fast_breakcheck(); else ui_breakcheck(); if (got_int) return FAIL; if (len < 0) len = (int)STRLEN(str); if (compl_first_match != NULL && !adup) { match = compl_first_match; do { if (!match_at_original_text(match) && STRNCMP(match->cp_str, str, len) == 0 && match->cp_str[len] == NUL) return NOTDONE; match = match->cp_next; } while (match != NULL && !is_first_match(match)); } ins_compl_del_pum(); match = ALLOC_CLEAR_ONE(compl_T); if (match == NULL) return FAIL; match->cp_number = -1; if (flags & CP_ORIGINAL_TEXT) match->cp_number = 0; if ((match->cp_str = vim_strnsave(str, len)) == NULL) { vim_free(match); return FAIL; } if (fname != NULL && compl_curr_match != NULL && compl_curr_match->cp_fname != NULL && STRCMP(fname, compl_curr_match->cp_fname) == 0) match->cp_fname = compl_curr_match->cp_fname; else if (fname != NULL) { match->cp_fname = vim_strsave(fname); flags |= CP_FREE_FNAME; } else match->cp_fname = NULL; match->cp_flags = flags; if (cptext != NULL) { int i; for (i = 0; i < CPT_COUNT; ++i) if (cptext[i] != NULL && *cptext[i] != NUL) match->cp_text[i] = vim_strsave(cptext[i]); } #ifdef FEAT_EVAL if (user_data != NULL) match->cp_user_data = *user_data; #endif if (compl_first_match == NULL) match->cp_next = match->cp_prev = NULL; else if (dir == FORWARD) { match->cp_next = compl_curr_match->cp_next; match->cp_prev = compl_curr_match; } else    { match->cp_next = compl_curr_match; match->cp_prev = compl_curr_match->cp_prev; } if (match->cp_next) match->cp_next->cp_prev = match; if (match->cp_prev) match->cp_prev->cp_next = match; elsecompl_first_match = match; compl_curr_match = match; if (compl_get_longest && (flags & CP_ORIGINAL_TEXT) == 0) ins_compl_longest_match(match); return OK; }"
"static bool php_mb_parse_encoding(const Variant& encoding, mbfl_encoding ***return_list, int *return_size, bool persistent) { bool ret; if (encoding.isArray()) { ret = php_mb_parse_encoding_array(encoding.toArray(), return_list, return_size, persistent ? 1 : 0); } else { String enc = encoding.toString(); ret = php_mb_parse_encoding_list(enc.data(), enc.size(), return_list, return_size, persistent ? 1 : 0); } if (!ret) { if (return_list && *return_list) { free(*return_list); *return_list = nullptr; } return_size = 0; } return ret; }"
"void evtchn_free(struct domain *d, struct evtchn *chn) { evtchn_port_clear_pending(d, chn); chn->state          = ECS_FREE; chn->notify_vcpu_id = 0; chn->xen_consumer   = 0; xsm_evtchn_close_post(chn); }"
"static void virtio_gpio_deinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts) { struct virtio_gpio *gpio; int i; DPRINTF((""%s"", ""virtio gpio: pci_gpio_deinit\r\n"")); virtio_gpio_is_active = false; gpio = (struct virtio_gpio *)dev->arg; if (gpio) { pthread_mutex_destroy(&gpio->mtx); gpio_irq_deinit(gpio); for (i = 0; i < gpio->nchip; i++) native_gpio_close_chip(&gpio->chips[i]); free(gpio); dev->arg = NULL; } }"
void Abort() override { if (!waiting_for_callback_) return; self_ref_ = this; aborted_ = true; }
"void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) { options->addOption(""--server.harden"", ""lock down REST APIs that reveal version information or server "" ""internals for non-admin users"", new BooleanParameter(&_hardenedRestApi)) .setIntroducedIn(30500); options->addOption(""--foxx.api"", ""enables Foxx management REST APIs"", new BooleanParameter(&_enableFoxxApi), arangodb::options::makeFlags( arangodb::options::Flags::DefaultNoComponents, arangodb::options::Flags::OnCoordinator, arangodb::options::Flags::OnSingle)) .setIntroducedIn(30500); options->addOption(""--foxx.store"", ""enables Foxx store in web interface"", new BooleanParameter(&_enableFoxxStore), arangodb::options::makeFlags( arangodb::options::Flags::DefaultNoComponents, arangodb::options::Flags::OnCoordinator, arangodb::options::Flags::OnSingle)) .setIntroducedIn(30500); }"
"static void dissect_transform(tvbuff_t *tvb, packet_info *pinfo, int offset, int length, proto_tree *tree, int isakmp_version, int protocol_id, void* decr_data) { if (isakmp_version == 1) { guint8              transform_id; guint8              transform_num; decrypt_data_t *decr = (decrypt_data_t *)decr_data; int offset_end = 0; offset_end = offset + length; transform_num = tvb_get_guint8(tvb, offset); proto_item_append_text(tree,"" # %d"",transform_num); proto_tree_add_item(tree, hf_isakmp_trans_number, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; transform_id = tvb_get_guint8(tvb, offset); switch (protocol_id) { case 1:      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1, transform_id, ""%s (%u)"", val_to_str_const(transform_id, vs_v1_trans_isakmp, ""UNKNOWN-TRANS-TYPE""), transform_id); break; case 2:      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1, transform_id, ""%s (%u)"", val_to_str_const(transform_id, vs_v1_trans_ah, ""UNKNOWN-AH-TRANS-TYPE""), transform_id); break; case 3:      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1, transform_id, ""%s (%u)"", val_to_str_const(transform_id, vs_v1_trans_esp, ""UNKNOWN-ESP-TRANS-TYPE""), transform_id); break; case 4:      proto_tree_add_uint_format_value(tree, hf_isakmp_trans_id, tvb, offset, 1, transform_id, ""%s (%u)"", val_to_str_const(transform_id, transform_id_ipcomp, ""UNKNOWN-IPCOMP-TRANS-TYPE""), transform_id); break; default: proto_tree_add_item(tree, hf_isakmp_trans_id, tvb, offset, 1, ENC_BIG_ENDIAN); break; } offset += 1; proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 2, ENC_NA); offset += 2; if (protocol_id == 1 && transform_id == 1) { decr->ike_encr_alg = 0; decr->ike_encr_keylen = 0; decr->ike_hash_alg = 0; while (offset < offset_end) { offset += dissect_ike_attribute(tvb, pinfo, tree, offset, decr); } } else { while (offset < offset_end) { offset += dissect_ipsec_attribute(tvb, pinfo, tree, offset); } } } else if(isakmp_version == 2) { guint8 transform_type; int offset_end = 0; offset_end = offset + length; transform_type = tvb_get_guint8(tvb, offset); proto_tree_add_item(tree, hf_isakmp_trans_type, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(tree, hf_isakmp_reserved, tvb, offset, 1, ENC_NA); offset += 1; switch(transform_type){ case TF_IKE2_ENCR: proto_tree_add_item(tree, hf_isakmp_trans_encr, tvb, offset, 2, ENC_BIG_ENDIAN); break; case TF_IKE2_PRF: proto_tree_add_item(tree, hf_isakmp_trans_prf, tvb, offset, 2, ENC_BIG_ENDIAN); break; case TF_IKE2_INTEG: proto_tree_add_item(tree, hf_isakmp_trans_integ, tvb, offset, 2, ENC_BIG_ENDIAN); break; case TF_IKE2_DH: proto_tree_add_item(tree, hf_isakmp_trans_dh, tvb, offset, 2, ENC_BIG_ENDIAN); break; case TF_IKE2_ESN: proto_tree_add_item(tree, hf_isakmp_trans_esn, tvb, offset, 2, ENC_BIG_ENDIAN); break; default: proto_tree_add_item(tree, hf_isakmp_trans_id_v2, tvb, offset, 2, ENC_BIG_ENDIAN); break; } offset += 2; while (offset < offset_end) { offset += dissect_ike2_transform_attribute(tvb, pinfo, tree, offset); } } }"
"static void zep_print_ts(netdissect_options *ndo, const u_char *p) { int32_t i; uint32_t uf; uint32_t f; float ff; i = GET_BE_U_4(p); uf = GET_BE_U_4(p + 4); ff = (float) uf; if (ff < 0.0)            ff += FMAXINT; ff = (float) (ff / FMAXINT);  f = (uint32_t) (ff * 1000000000.0);   ND_PRINT(""%u.%09d"", i, f); if (i) { time_t seconds = i - JAN_1970; struct tm *tm; char time_buf[128]; tm = localtime(&seconds); strftime(time_buf, sizeof (time_buf), ""%Y/%m/%d %H:%M:%S"", tm); ND_PRINT("" (%s)"", time_buf); } }"
"static int archive_read_format_cpio_read_header(struct archive_read *a, struct archive_entry *entry) { struct cpio *cpio; const void *h; struct archive_string_conv *sconv; size_t namelength; size_t name_pad; int r; cpio = (struct cpio *)(a->format->data); sconv = cpio->opt_sconv; if (sconv == NULL) { if (!cpio->init_default_conversion) { cpio->sconv_default = archive_string_default_conversion_for_read( &(a->archive)); cpio->init_default_conversion = 1; } sconv = cpio->sconv_default; } r = (cpio->read_header(a, cpio, entry, &namelength, &name_pad)); if (r < ARCHIVE_WARN) return (r); h = __archive_read_ahead(a, namelength + name_pad, NULL); if (h == NULL) return (ARCHIVE_FATAL); if (archive_entry_copy_pathname_l(entry, (const char *)h, namelength, sconv) != 0) { if (errno == ENOMEM) { archive_set_error(&a->archive, ENOMEM, ""Can't allocate memory for Pathname""); return (ARCHIVE_FATAL); } archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Pathname can't be converted from %s to current locale."", archive_string_conversion_charset_name(sconv)); r = ARCHIVE_WARN; } cpio->entry_offset = 0; __archive_read_consume(a, namelength + name_pad); if (archive_entry_filetype(entry) == AE_IFLNK) { h = __archive_read_ahead(a, (size_t)cpio->entry_bytes_remaining, NULL); if (h == NULL) return (ARCHIVE_FATAL); if (archive_entry_copy_symlink_l(entry, (const char *)h, (size_t)cpio->entry_bytes_remaining, sconv) != 0) { if (errno == ENOMEM) { archive_set_error(&a->archive, ENOMEM, ""Can't allocate memory for Linkname""); return (ARCHIVE_FATAL); } archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Linkname can't be converted from %s to "" ""current locale."", archive_string_conversion_charset_name(sconv)); r = ARCHIVE_WARN; } __archive_read_consume(a, cpio->entry_bytes_remaining); cpio->entry_bytes_remaining = 0; } if (namelength == 11 && strcmp((const char *)h, ""TRAILER!!!"") == 0) { archive_clear_error(&a->archive); return (ARCHIVE_EOF); } if (record_hardlink(a, cpio, entry) != ARCHIVE_OK) { return (ARCHIVE_FATAL); } return (r); }"
"static struct inode *ntfs_read_mft(struct inode *inode, const struct cpu_str *name, const struct MFT_REF *ref) { int err = 0; struct ntfs_inode *ni = ntfs_i(inode); struct super_block *sb = inode->i_sb; struct ntfs_sb_info *sbi = sb->s_fs_info; mode_t mode = 0; struct ATTR_STD_INFO5 *std5 = NULL; struct ATTR_LIST_ENTRY *le; struct ATTRIB *attr; bool is_match = false; bool is_root = false; bool is_dir; unsigned long ino = inode->i_ino; u32 rp_fa = 0, asize, t32; u16 roff, rsize, names = 0; const struct ATTR_FILE_NAME *fname = NULL; const struct INDEX_ROOT *root; struct REPARSE_DATA_BUFFER rp; u64 t64; struct MFT_REC *rec; struct runs_tree *run; inode->i_op = NULL; inode->i_uid = sbi->options->fs_uid; inode->i_gid = sbi->options->fs_gid; err = mi_init(&ni->mi, sbi, ino); if (err) goto out; if (!sbi->mft.ni && ino == MFT_REC_MFT && !sb->s_root) { t64 = sbi->mft.lbo >> sbi->cluster_bits; t32 = bytes_to_cluster(sbi, MFT_REC_VOL * sbi->record_size); sbi->mft.ni = ni; init_rwsem(&ni->file.run_lock); if (!run_add_entry(&ni->file.run, 0, t64, t32, true)) { err = -ENOMEM; goto out; } } err = mi_read(&ni->mi, ino == MFT_REC_MFT); if (err) goto out; rec = ni->mi.mrec; if (sbi->flags & NTFS_FLAGS_LOG_REPLAYING) { ; } else if (ref->seq != rec->seq) { err = -EINVAL; ntfs_err(sb, ""MFT: r=%lx, expect seq=%x instead of %x!"", ino, le16_to_cpu(ref->seq), le16_to_cpu(rec->seq)); goto out; } else if (!is_rec_inuse(rec)) { err = -EINVAL; ntfs_err(sb, ""Inode r=%x is not in use!"", (u32)ino); goto out; } if (le32_to_cpu(rec->total) != sbi->record_size) { err = -EINVAL; goto out; } if (!is_rec_base(rec)) goto Ok; is_dir = rec->flags & RECORD_FLAG_DIR; inode->i_generation = le16_to_cpu(rec->seq); le = NULL; attr = NULL; next_attr: run = NULL; err = -EINVAL; attr = ni_enum_attr_ex(ni, attr, &le, NULL); if (!attr) goto end_enum; if (le && le->vcn) { if (ino != MFT_REC_MFT || attr->type != ATTR_DATA) goto next_attr; run = &ni->file.run; asize = le32_to_cpu(attr->size); goto attr_unpack_run; } roff = attr->non_res ? 0 : le16_to_cpu(attr->res.data_off); rsize = attr->non_res ? 0 : le32_to_cpu(attr->res.data_size); asize = le32_to_cpu(attr->size); if (le16_to_cpu(attr->name_off) + attr->name_len > asize) goto out; switch (attr->type) { case ATTR_STD: if (attr->non_res || asize < sizeof(struct ATTR_STD_INFO) + roff || rsize < sizeof(struct ATTR_STD_INFO)) goto out; if (std5) goto next_attr; std5 = Add2Ptr(attr, roff); #ifdef STATX_BTIME nt2kernel(std5->cr_time, &ni->i_crtime); #endif nt2kernel(std5->a_time, &inode->i_atime); nt2kernel(std5->c_time, &inode->i_ctime); nt2kernel(std5->m_time, &inode->i_mtime); ni->std_fa = std5->fa; if (asize >= sizeof(struct ATTR_STD_INFO5) + roff && rsize >= sizeof(struct ATTR_STD_INFO5)) ni->std_security_id = std5->security_id; goto next_attr; case ATTR_LIST: if (attr->name_len || le || ino == MFT_REC_LOG) goto out; err = ntfs_load_attr_list(ni, attr); if (err) goto out; le = NULL; attr = NULL; goto next_attr; case ATTR_NAME: if (attr->non_res || asize < SIZEOF_ATTRIBUTE_FILENAME + roff || rsize < SIZEOF_ATTRIBUTE_FILENAME) goto out; fname = Add2Ptr(attr, roff); if (fname->type == FILE_NAME_DOS) goto next_attr; names += 1; if (name && name->len == fname->name_len && !ntfs_cmp_names_cpu(name, (struct le_str *)&fname->name_len, NULL, false)) is_match = true; goto next_attr; case ATTR_DATA: if (is_dir) { goto next_attr; } if (ino == MFT_REC_BADCLUST && !attr->non_res) goto next_attr; if (attr->name_len && ((ino != MFT_REC_BADCLUST || !attr->non_res || attr->name_len != ARRAY_SIZE(BAD_NAME) || memcmp(attr_name(attr), BAD_NAME, sizeof(BAD_NAME))) && (ino != MFT_REC_SECURE || !attr->non_res || attr->name_len != ARRAY_SIZE(SDS_NAME) || memcmp(attr_name(attr), SDS_NAME, sizeof(SDS_NAME))))) { goto next_attr; } if (is_attr_sparsed(attr)) ni->std_fa |= FILE_ATTRIBUTE_SPARSE_FILE; else ni->std_fa &= ~FILE_ATTRIBUTE_SPARSE_FILE; if (is_attr_compressed(attr)) ni->std_fa |= FILE_ATTRIBUTE_COMPRESSED; else ni->std_fa &= ~FILE_ATTRIBUTE_COMPRESSED; if (is_attr_encrypted(attr)) ni->std_fa |= FILE_ATTRIBUTE_ENCRYPTED; else ni->std_fa &= ~FILE_ATTRIBUTE_ENCRYPTED; if (!attr->non_res) { ni->i_valid = inode->i_size = rsize; inode_set_bytes(inode, rsize); } mode = S_IFREG | (0777 & sbi->options->fs_fmask_inv); if (!attr->non_res) { ni->ni_flags |= NI_FLAG_RESIDENT; goto next_attr; } inode_set_bytes(inode, attr_ondisk_size(attr)); ni->i_valid = le64_to_cpu(attr->nres.valid_size); inode->i_size = le64_to_cpu(attr->nres.data_size); if (!attr->nres.alloc_size) goto next_attr; run = ino == MFT_REC_BITMAP ? &sbi->used.bitmap.run : &ni->file.run; break; case ATTR_ROOT: if (attr->non_res) goto out; root = Add2Ptr(attr, roff); is_root = true; if (attr->name_len != ARRAY_SIZE(I30_NAME) || memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME))) goto next_attr; if (root->type != ATTR_NAME || root->rule != NTFS_COLLATION_TYPE_FILENAME) goto out; if (!is_dir) goto next_attr; ni->ni_flags |= NI_FLAG_DIR; err = indx_init(&ni->dir, sbi, attr, INDEX_MUTEX_I30); if (err) goto out; mode = sb->s_root ? (S_IFDIR | (0777 & sbi->options->fs_dmask_inv)) : (S_IFDIR | 0777); goto next_attr; case ATTR_ALLOC: if (!is_root || attr->name_len != ARRAY_SIZE(I30_NAME) || memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME))) goto next_attr; inode->i_size = le64_to_cpu(attr->nres.data_size); ni->i_valid = le64_to_cpu(attr->nres.valid_size); inode_set_bytes(inode, le64_to_cpu(attr->nres.alloc_size)); run = &ni->dir.alloc_run; break; case ATTR_BITMAP: if (ino == MFT_REC_MFT) { if (!attr->non_res) goto out; #ifndef CONFIG_NTFS3_64BIT_CLUSTER if (le64_to_cpu(attr->nres.alloc_size) >= 0x20000000) goto out; #endif run = &sbi->mft.bitmap.run; break; } else if (is_dir && attr->name_len == ARRAY_SIZE(I30_NAME) && !memcmp(attr_name(attr), I30_NAME, sizeof(I30_NAME)) && attr->non_res) { run = &ni->dir.bitmap_run; break; } goto next_attr; case ATTR_REPARSE: if (attr->name_len) goto next_attr; rp_fa = ni_parse_reparse(ni, attr, &rp); switch (rp_fa) { case REPARSE_LINK: inode->i_size = le16_to_cpu(rp.SymbolicLinkReparseBuffer .PrintNameLength) / sizeof(u16); ni->i_valid = inode->i_size; if (ni->ni_flags & NI_FLAG_DIR) { indx_clear(&ni->dir); memset(&ni->dir, 0, sizeof(ni->dir)); ni->ni_flags &= ~NI_FLAG_DIR; } else { run_close(&ni->file.run); } mode = S_IFLNK | 0777; is_dir = false; if (attr->non_res) { run = &ni->file.run; goto attr_unpack_run; } break; case REPARSE_COMPRESSED: break; case REPARSE_DEDUPLICATED: break; } goto next_attr; case ATTR_EA_INFO: if (!attr->name_len && resident_data_ex(attr, sizeof(struct EA_INFO))) { ni->ni_flags |= NI_FLAG_EA; inode->i_mode = mode; ntfs_get_wsl_perm(inode); mode = inode->i_mode; } goto next_attr; default: goto next_attr; } attr_unpack_run: roff = le16_to_cpu(attr->nres.run_off); if (roff > asize) { err = -EINVAL; goto out; } t64 = le64_to_cpu(attr->nres.svcn); err = run_unpack_ex(run, sbi, ino, t64, le64_to_cpu(attr->nres.evcn), t64, Add2Ptr(attr, roff), asize - roff); if (err < 0) goto out; err = 0; goto next_attr; end_enum: if (!std5) goto out; if (!is_match && name) { err = -ENOENT; goto out; } if (std5->fa & FILE_ATTRIBUTE_READONLY) mode &= ~0222; if (!names) { err = -EINVAL; goto out; } if (names != le16_to_cpu(rec->hard_links)) { rec->hard_links = cpu_to_le16(names); ni->mi.dirty = true; } set_nlink(inode, names); if (S_ISDIR(mode)) { ni->std_fa |= FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_dir_inode_operations; inode->i_fop = &ntfs_dir_operations; ni->i_valid = 0; } else if (S_ISLNK(mode)) { ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_link_inode_operations; inode->i_fop = NULL; inode_nohighmem(inode); } else if (S_ISREG(mode)) { ni->std_fa &= ~FILE_ATTRIBUTE_DIRECTORY; inode->i_op = &ntfs_file_inode_operations; inode->i_fop = &ntfs_file_operations; inode->i_mapping->a_ops = is_compressed(ni) ? &ntfs_aops_cmpr : &ntfs_aops; if (ino != MFT_REC_MFT) init_rwsem(&ni->file.run_lock); } else if (S_ISCHR(mode) || S_ISBLK(mode) || S_ISFIFO(mode) || S_ISSOCK(mode)) { inode->i_op = &ntfs_special_inode_operations; init_special_inode(inode, mode, inode->i_rdev); } else if (fname && fname->home.low == cpu_to_le32(MFT_REC_EXTEND) && fname->home.seq == cpu_to_le16(MFT_REC_EXTEND)) { inode->i_op = &ntfs_file_inode_operations; } else { err = -EINVAL; goto out; } if ((sbi->options->sys_immutable && (std5->fa & FILE_ATTRIBUTE_SYSTEM)) && !S_ISFIFO(mode) && !S_ISSOCK(mode) && !S_ISLNK(mode)) { inode->i_flags |= S_IMMUTABLE; } else { inode->i_flags &= ~S_IMMUTABLE; } inode->i_mode = mode; if (!(ni->ni_flags & NI_FLAG_EA)) { inode->i_flags |= S_NOSEC; } Ok: if (ino == MFT_REC_MFT && !sb->s_root) sbi->mft.ni = NULL; unlock_new_inode(inode); return inode; out: if (ino == MFT_REC_MFT && !sb->s_root) sbi->mft.ni = NULL; iget_failed(inode); return ERR_PTR(err); }"
"static inline int _write_trylock(rwlock_t *lock) { u32 cnts; preempt_disable(); cnts = atomic_read(&lock->cnts); if ( unlikely(cnts) || unlikely(atomic_cmpxchg(&lock->cnts, 0, _write_lock_val()) != 0) ) { preempt_enable(); return 0; } return 1; }"
"static int remove_tree(struct qtree_mem_dqinfo *info, struct dquot *dquot, uint *blk, int depth) { char *buf = kmalloc(info->dqi_usable_bs, GFP_NOFS); int ret = 0; uint newblk; __le32 *ref = (__le32 *)buf; if (!buf) return -ENOMEM; ret = read_blk(info, *blk, buf); if (ret < 0) { quota_error(dquot->dq_sb, ""Can't read quota data block %u"", *blk); goto out_buf; } newblk = le32_to_cpu(ref[get_index(info, dquot->dq_id, depth)]); if (depth == info->dqi_qtree_depth - 1) { ret = free_dqentry(info, dquot, newblk); newblk = 0; } else { ret = remove_tree(info, dquot, &newblk, depth+1); } if (ret >= 0 && !newblk) { int i; ref[get_index(info, dquot->dq_id, depth)] = cpu_to_le32(0); for (i = 0; i < (info->dqi_usable_bs >> 2) && !ref[i]; i++) ; if (i == (info->dqi_usable_bs >> 2) && *blk != QT_TREEOFF) { put_free_dqblk(info, buf, *blk); *blk = 0; } else { ret = write_blk(info, *blk, buf); if (ret < 0) quota_error(dquot->dq_sb, ""Can't write quota tree block %u"", *blk); } } out_buf: kfree(buf); return ret; }"
"static void file_asynch_write (struct rw *rw, struct command *command, nbd_completion_callback cb) { int dummy = 0; file_synch_write (rw, slice_ptr (command->slice), command->slice.len, command->offset); if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { squashfs_dir_header_2 dirh; char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; long long start; int bytes; int dir_count, size; struct dir_ent *new_dir; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n""); dir->dir_count = 0; dir->cur_entry = 0; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 0) return dir; start = sBlk.s.directory_table_start + (*i)->start; bytes = lookup_entry(directory_table_hash, start); if(bytes == -1) EXIT_UNSQUASH(""squashfs_opendir: directory block %d not "" ""found!\n"", block_start); bytes += (*i)->offset; size = (*i)->data + bytes; while(bytes < size) { if(swap) { squashfs_dir_header_2 sdirh; memcpy(&sdirh, directory_table + bytes, sizeof(sdirh)); SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); } else memcpy(&dirh, directory_table + bytes, sizeof(dirh)); dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { if(swap) { squashfs_dir_entry_2 sdire; memcpy(&sdire, directory_table + bytes, sizeof(sdire)); SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); } else memcpy(dire, directory_table + bytes, sizeof(*dire)); bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } memcpy(dire->name, directory_table + bytes, dire->size + 1); dire->name[dire->size + 1] = '\0'; TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); if((dir->dir_count % DIR_ENT_SIZE) == 0) { new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent)); if(new_dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: "" ""realloc failed!\n""); dir->dirs = new_dir; } strcpy(dir->dirs[dir->dir_count].name, dire->name); dir->dirs[dir->dir_count].start_block = dirh.start_block; dir->dirs[dir->dir_count].offset = dire->offset; dir->dirs[dir->dir_count].type = dire->type; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: free(dir->dirs); free(dir); return NULL; }"
"static int stex_queuecommand_lck(struct scsi_cmnd *cmd) { void (*done)(struct scsi_cmnd *) = scsi_done; struct st_hba *hba; struct Scsi_Host *host; unsigned int id, lun; struct req_msg *req; u16 tag; host = cmd->device->host; id = cmd->device->id; lun = cmd->device->lun; hba = (struct st_hba *) &host->hostdata[0]; if (hba->mu_status == MU_STATE_NOCONNECT) { cmd->result = DID_NO_CONNECT; done(cmd); return 0; } if (unlikely(hba->mu_status != MU_STATE_STARTED)) return SCSI_MLQUEUE_HOST_BUSY; switch (cmd->cmnd[0]) { case MODE_SENSE_10: { static char ms10_caching_page[12] = { 0, 0x12, 0, 0, 0, 0, 0, 0, 0x8, 0xa, 0x4, 0 }; unsigned char page; page = cmd->cmnd[2] & 0x3f; if (page == 0x8 || page == 0x3f) { scsi_sg_copy_from_buffer(cmd, ms10_caching_page, sizeof(ms10_caching_page)); cmd->result = DID_OK << 16; done(cmd); } else stex_invalid_field(cmd, done); return 0; } case REPORT_LUNS: if (hba->cardtype == st_shasta || id == host->max_id - 1) { stex_invalid_field(cmd, done); return 0; } break; case TEST_UNIT_READY: if (id == host->max_id - 1) { cmd->result = DID_OK << 16; done(cmd); return 0; } break; case INQUIRY: if (lun >= host->max_lun) { cmd->result = DID_NO_CONNECT << 16; done(cmd); return 0; } if (id != host->max_id - 1) break; if (!lun && !cmd->device->channel && (cmd->cmnd[1] & INQUIRY_EVPD) == 0) { scsi_sg_copy_from_buffer(cmd, (void *)console_inq_page, sizeof(console_inq_page)); cmd->result = DID_OK << 16; done(cmd); } else stex_invalid_field(cmd, done); return 0; case PASSTHRU_CMD: if (cmd->cmnd[1] == PASSTHRU_GET_DRVVER) { struct st_drvver ver; size_t cp_len = sizeof(ver); ver.major = ST_VER_MAJOR; ver.minor = ST_VER_MINOR; ver.oem = ST_OEM; ver.build = ST_BUILD_VER; ver.signature[0] = PASSTHRU_SIGNATURE; ver.console_id = host->max_id - 1; ver.host_no = hba->host->host_no; cp_len = scsi_sg_copy_from_buffer(cmd, &ver, cp_len); if (sizeof(ver) == cp_len) cmd->result = DID_OK << 16; else cmd->result = DID_ERROR << 16; done(cmd); return 0; } break; default: break; } tag = scsi_cmd_to_rq(cmd)->tag; if (unlikely(tag >= host->can_queue)) return SCSI_MLQUEUE_HOST_BUSY; req = hba->alloc_rq(hba); req->lun = lun; req->target = id; memcpy(req->cdb, cmd->cmnd, STEX_CDB_LENGTH); if (cmd->sc_data_direction == DMA_FROM_DEVICE) req->data_dir = MSG_DATA_DIR_IN; else if (cmd->sc_data_direction == DMA_TO_DEVICE) req->data_dir = MSG_DATA_DIR_OUT; else req->data_dir = MSG_DATA_DIR_ND; hba->ccb[tag].cmd = cmd; hba->ccb[tag].sense_bufflen = SCSI_SENSE_BUFFERSIZE; hba->ccb[tag].sense_buffer = cmd->sense_buffer; if (!hba->map_sg(hba, req, &hba->ccb[tag])) { hba->ccb[tag].sg_count = 0; memset(&req->variable[0], 0, 8); } hba->send(hba, req, tag); return 0; }"
long readSInt32(FILE *f) { return (long)readUInt8(f) + (readUInt8(f)<<8) + (readUInt8(f)<<16) + (readUInt8(f)<<24); }
"void PackLinuxElf64::invert_pt_dynamic(Elf64_Dyn const *dynp) { if (dt_table[Elf64_Dyn::DT_NULL]) { return;      } Elf64_Dyn const *const dynp0 = dynp; unsigned ndx = 1+ 0; if (dynp) for (; ; ++ndx, ++dynp) { upx_uint64_t const d_tag = get_te64(&dynp->d_tag); if (d_tag>>32) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad Elf64_Dyn[%d].d_tag %#lx"", -1+ ndx, (long unsigned)d_tag); throwCantPack(msg); } if (d_tag < DT_NUM) { if (Elf64_Dyn::DT_NEEDED != d_tag &&  dt_table[d_tag] &&    get_te64(&dynp->d_val) != get_te64(&dynp0[-1+ dt_table[d_tag]].d_val)) { char msg[50]; snprintf(msg, sizeof(msg), ""duplicate DT_%#x: [%#x] [%#x]"", (unsigned)d_tag, -1+ dt_table[d_tag], -1+ ndx); throwCantPack(msg); } dt_table[d_tag] = ndx; } if (Elf64_Dyn::DT_NULL == d_tag) { break;          } } upx_dt_init = 0; if (dt_table[Elf64_Dyn::DT_INIT])          upx_dt_init = Elf64_Dyn::DT_INIT; else if (dt_table[Elf64_Dyn::DT_PREINIT_ARRAY]) upx_dt_init = Elf64_Dyn::DT_PREINIT_ARRAY; else if (dt_table[Elf64_Dyn::DT_INIT_ARRAY])    upx_dt_init = Elf64_Dyn::DT_INIT_ARRAY; unsigned const z_str = dt_table[Elf64_Dyn::DT_STRSZ]; if (z_str) { strtab_end = get_te64(&dynp0[-1+ z_str].d_val); if ((u64_t)file_size <= strtab_end) {             char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_STRSZ %#x"", strtab_end); throwCantPack(msg); } } unsigned const x_sym = dt_table[Elf64_Dyn::DT_SYMTAB]; unsigned const x_str = dt_table[Elf64_Dyn::DT_STRTAB]; if (x_sym && x_str) { upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val); upx_uint64_t const v_str = get_te64(&dynp0[-1+ x_str].d_val); unsigned const  z_sym = dt_table[Elf64_Dyn::DT_SYMENT]; unsigned const sz_sym = !z_sym ? sizeof(Elf64_Sym) : get_te64(&dynp0[-1+ z_sym].d_val); if (sz_sym < sizeof(Elf64_Sym)) { char msg[50]; snprintf(msg, sizeof(msg), ""bad DT_SYMENT %x"", sz_sym); throwCantPack(msg); } if (v_sym < v_str) { symnum_end = (v_str - v_sym) / sz_sym; } if (symnum_end < 1) { throwCantPack(""bad DT_SYMTAB""); } } unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); if (v_hsh && file_image) { hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH); if (!hashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_HASH %#x"", v_hsh); throwCantPack(msg); } unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; (void)chains; unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val); if (!nbucket || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)          || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2                  + sizeof(*buckets)*nbucket                  + sizeof(*chains) *nbucket             )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_HASH nbucket=%#x  len=%#x"", nbucket, (v_sym - v_hsh)); throwCantPack(msg); } } unsigned const v_gsh = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); if (v_gsh && file_image) { gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH); if (!gashtab) { char msg[40]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH %#x"", v_gsh); throwCantPack(msg); } unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr; upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val); if (!n_bucket || !n_bitmask || (-1+ n_bitmask) & n_bitmask          || 8*sizeof(upx_uint64_t) <= gnu_shift          || (n_bucket>>30)          || (n_bitmask>>30) || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)                  || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4                  + sizeof(*bitmask)*n_bitmask                  + sizeof(*buckets)*n_bucket                  + sizeof(*hasharr)*n_bucket              )) ) { char msg[90]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket=%#x  n_bitmask=%#x  len=%#lx"", n_bucket, n_bitmask, (long unsigned)(v_sym - v_gsh)); throwCantPack(msg); } } unsigned const e_shstrndx = get_te16(&ehdri.e_shstrndx); if (e_shnum <= e_shstrndx &&  !(0==e_shnum && 0==e_shstrndx) ) { char msg[40]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx %d >= .e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } }"
"int ovl_setattr(struct dentry *dentry, struct iattr *attr) { int err; struct dentry *upperdentry; err = ovl_want_write(dentry); if (err) goto out; err = ovl_copy_up(dentry); if (!err) { upperdentry = ovl_dentry_upper(dentry); mutex_lock(&upperdentry->d_inode->i_mutex); err = notify_change(upperdentry, attr, NULL); mutex_unlock(&upperdentry->d_inode->i_mutex); } ovl_drop_write(dentry); out: return err; }"
"void vrend_renderer_context_create_internal(uint32_t handle, uint32_t nlen, const char *debug_name) { struct vrend_decode_ctx *dctx; if (handle >= VREND_MAX_CTX) return; dctx = malloc(sizeof(struct vrend_decode_ctx)); if (!dctx) return; dctx->grctx = vrend_create_context(handle, nlen, debug_name); if (!dctx->grctx) { free(dctx); return; } dctx->ds = &dctx->ids; dec_ctx[handle] = dctx; }"
"int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len) { struct sc_path path; struct sc_file *file; unsigned char *p; int ok = 0; int r; size_t len; sc_format_path(str_path, &path); if (SC_SUCCESS != sc_select_file(card, &path, &file)) { goto err; } len = file ? file->size : 4096; p = realloc(*data, len); if (!p) { goto err; } *data = p; *data_len = len; r = sc_read_binary(card, 0, p, len, 0); if (r < 0) goto err; *data_len = r; ok = 1; err: sc_file_free(file); return ok; }"
"int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset, int max_beb_per1024, bool disable_fm) { struct ubi_device *ubi; int i, err; if (max_beb_per1024 < 0 || max_beb_per1024 > MAX_MTD_UBI_BEB_LIMIT) return -EINVAL; if (!max_beb_per1024) max_beb_per1024 = CONFIG_MTD_UBI_BEB_LIMIT; for (i = 0; i < UBI_MAX_DEVICES; i++) { ubi = ubi_devices[i]; if (ubi && mtd->index == ubi->mtd->index) { pr_err(""ubi: mtd%d is already attached to ubi%d\n"", mtd->index, i); return -EEXIST; } } if (mtd->type == MTD_UBIVOLUME) { pr_err(""ubi: refuse attaching mtd%d - it is already emulated on top of UBI\n"", mtd->index); return -EINVAL; } if (mtd->type == MTD_MLCNANDFLASH && !(mtd->flags & MTD_SLC_ON_MLC_EMULATION)) { pr_err(""ubi: refuse attaching mtd%d - MLC NAND is not supported\n"", mtd->index); return -EINVAL; } if (ubi_num == UBI_DEV_NUM_AUTO) { for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) if (!ubi_devices[ubi_num]) break; if (ubi_num == UBI_MAX_DEVICES) { pr_err(""ubi: only %d UBI devices may be created\n"", UBI_MAX_DEVICES); return -ENFILE; } } else { if (ubi_num >= UBI_MAX_DEVICES) return -EINVAL; if (ubi_devices[ubi_num]) { pr_err(""ubi: ubi%i already exists\n"", ubi_num); return -EEXIST; } } ubi = kzalloc(sizeof(struct ubi_device), GFP_KERNEL); if (!ubi) return -ENOMEM; device_initialize(&ubi->dev); ubi->dev.release = dev_release; ubi->dev.class = &ubi_class; ubi->dev.groups = ubi_dev_groups; ubi->dev.parent = &mtd->dev; ubi->mtd = mtd; ubi->ubi_num = ubi_num; ubi->vid_hdr_offset = vid_hdr_offset; ubi->autoresize_vol_id = -1; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_pool.used = ubi->fm_pool.size = 0; ubi->fm_wl_pool.used = ubi->fm_wl_pool.size = 0; ubi->fm_pool.max_size = min(((int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) / 100) * 5, UBI_FM_MAX_POOL_SIZE); ubi->fm_pool.max_size = max(ubi->fm_pool.max_size, UBI_FM_MIN_POOL_SIZE); ubi->fm_wl_pool.max_size = ubi->fm_pool.max_size / 2; ubi->fm_disabled = (!fm_autoconvert || disable_fm) ? 1 : 0; if (fm_debug) ubi_enable_dbg_chk_fastmap(ubi); if (!ubi->fm_disabled && (int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) <= UBI_FM_MAX_START) { ubi_err(ubi, ""More than %i PEBs are needed for fastmap, sorry."", UBI_FM_MAX_START); ubi->fm_disabled = 1; } ubi_msg(ubi, ""default fastmap pool size: %d"", ubi->fm_pool.max_size); ubi_msg(ubi, ""default fastmap WL pool size: %d"", ubi->fm_wl_pool.max_size); #else ubi->fm_disabled = 1; #endif mutex_init(&ubi->buf_mutex); mutex_init(&ubi->ckvol_mutex); mutex_init(&ubi->device_mutex); spin_lock_init(&ubi->volumes_lock); init_rwsem(&ubi->fm_protect); init_rwsem(&ubi->fm_eba_sem); ubi_msg(ubi, ""attaching mtd%d"", mtd->index); err = io_init(ubi, max_beb_per1024); if (err) goto out_free; err = -ENOMEM; ubi->peb_buf = vmalloc(ubi->peb_size); if (!ubi->peb_buf) goto out_free; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_size = ubi_calc_fm_size(ubi); ubi->fm_buf = vzalloc(ubi->fm_size); if (!ubi->fm_buf) goto out_free; #endif err = ubi_attach(ubi, disable_fm ? 1 : 0); if (err) { ubi_err(ubi, ""failed to attach mtd%d, error %d"", mtd->index, err); goto out_free; } if (ubi->autoresize_vol_id != -1) { err = autoresize(ubi, ubi->autoresize_vol_id); if (err) goto out_detach; } err = uif_init(ubi); if (err) goto out_detach; err = ubi_debugfs_init_dev(ubi); if (err) goto out_uif; ubi->bgt_thread = kthread_create(ubi_thread, ubi, ""%s"", ubi->bgt_name); if (IS_ERR(ubi->bgt_thread)) { err = PTR_ERR(ubi->bgt_thread); ubi_err(ubi, ""cannot spawn \""%s\"", error %d"", ubi->bgt_name, err); goto out_debugfs; } ubi_msg(ubi, ""attached mtd%d (name \""%s\"", size %llu MiB)"", mtd->index, mtd->name, ubi->flash_size >> 20); ubi_msg(ubi, ""PEB size: %d bytes (%d KiB), LEB size: %d bytes"", ubi->peb_size, ubi->peb_size >> 10, ubi->leb_size); ubi_msg(ubi, ""min./max. I/O unit sizes: %d/%d, sub-page size %d"", ubi->min_io_size, ubi->max_write_size, ubi->hdrs_min_io_size); ubi_msg(ubi, ""VID header offset: %d (aligned %d), data offset: %d"", ubi->vid_hdr_offset, ubi->vid_hdr_aloffset, ubi->leb_start); ubi_msg(ubi, ""good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d"", ubi->good_peb_count, ubi->bad_peb_count, ubi->corr_peb_count); ubi_msg(ubi, ""user volume: %d, internal volumes: %d, max. volumes count: %d"", ubi->vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT, ubi->vtbl_slots); ubi_msg(ubi, ""max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u"", ubi->max_ec, ubi->mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD, ubi->image_seq); ubi_msg(ubi, ""available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d"", ubi->avail_pebs, ubi->rsvd_pebs, ubi->beb_rsvd_pebs); spin_lock(&ubi->wl_lock); ubi->thread_enabled = 1; wake_up_process(ubi->bgt_thread); spin_unlock(&ubi->wl_lock); ubi_devices[ubi_num] = ubi; ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL); return ubi_num; out_debugfs: ubi_debugfs_exit_dev(ubi); out_uif: uif_close(ubi); out_detach: ubi_wl_close(ubi); ubi_free_all_volumes(ubi); vfree(ubi->vtbl); out_free: vfree(ubi->peb_buf); vfree(ubi->fm_buf); put_device(&ubi->dev); return err; }"
"int CEditorMap::Load(class IStorage *pStorage, const char *pFileName, int StorageType) { CDataFileReader DataFile; if(!DataFile.Open(pStorage, pFileName, StorageType)) return 0; Clean(); CMapItemVersion *pItem = (CMapItemVersion *)DataFile.FindItem(MAPITEMTYPE_VERSION, 0); if(!pItem) { return 0; } else if(pItem->m_Version == CMapItemVersion::CURRENT_VERSION) { { CMapItemInfo *pItem = (CMapItemInfo *)DataFile.FindItem(MAPITEMTYPE_INFO, 0); if(pItem && pItem->m_Version == 1) { if(pItem->m_Author > -1) str_copy(m_MapInfo.m_aAuthor, (char *)DataFile.GetData(pItem->m_Author), sizeof(m_MapInfo.m_aAuthor)); if(pItem->m_MapVersion > -1) str_copy(m_MapInfo.m_aVersion, (char *)DataFile.GetData(pItem->m_MapVersion), sizeof(m_MapInfo.m_aVersion)); if(pItem->m_Credits > -1) str_copy(m_MapInfo.m_aCredits, (char *)DataFile.GetData(pItem->m_Credits), sizeof(m_MapInfo.m_aCredits)); if(pItem->m_License > -1) str_copy(m_MapInfo.m_aLicense, (char *)DataFile.GetData(pItem->m_License), sizeof(m_MapInfo.m_aLicense)); } } { int Start, Num; DataFile.GetType( MAPITEMTYPE_IMAGE, &Start, &Num); for(int i = 0; i < Num; i++) { CMapItemImage *pItem = (CMapItemImage *)DataFile.GetItem(Start+i, 0, 0); char *pName = (char *)DataFile.GetData(pItem->m_ImageName); CEditorImage *pImg = new CEditorImage(m_pEditor); pImg->m_External = pItem->m_External; if(pItem->m_External || (pItem->m_Version > 1 && pItem->m_Format != CImageInfo::FORMAT_RGB && pItem->m_Format != CImageInfo::FORMAT_RGBA)) { char aBuf[IO_MAX_PATH_LENGTH]; str_format(aBuf, sizeof(aBuf),""mapres/%s.png"", pName); CEditorImage ImgInfo(m_pEditor); if(m_pEditor->Graphics()->LoadPNG(&ImgInfo, aBuf, IStorage::TYPE_ALL)) { *pImg = ImgInfo; pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(ImgInfo.m_Width, ImgInfo.m_Height, ImgInfo.m_Format, ImgInfo.m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION); ImgInfo.m_pData = 0; pImg->m_External = 1; } } else { pImg->m_Width = pItem->m_Width; pImg->m_Height = pItem->m_Height; pImg->m_Format = pItem->m_Version == 1 ? CImageInfo::FORMAT_RGBA : pItem->m_Format; int PixelSize = pImg->m_Format == CImageInfo::FORMAT_RGB ? 3 : 4; int DataSize = pImg->m_Width * pImg->m_Height * PixelSize; void *pData = DataFile.GetData(pItem->m_ImageData); pImg->m_pData = mem_alloc(DataSize); mem_copy(pImg->m_pData, pData, DataSize); pImg->m_Texture = m_pEditor->Graphics()->LoadTextureRaw(pImg->m_Width, pImg->m_Height, pImg->m_Format, pImg->m_pData, CImageInfo::FORMAT_AUTO, IGraphics::TEXLOAD_MULTI_DIMENSION); } if(pName) str_copy(pImg->m_aName, pName, 128); pImg->LoadAutoMapper(); m_lImages.add(pImg); DataFile.UnloadData(pItem->m_ImageData); DataFile.UnloadData(pItem->m_ImageName); } } { int LayersStart, LayersNum; DataFile.GetType(MAPITEMTYPE_LAYER, &LayersStart, &LayersNum); int Start, Num; DataFile.GetType(MAPITEMTYPE_GROUP, &Start, &Num); for(int g = 0; g < Num; g++) { CMapItemGroup *pGItem = (CMapItemGroup *)DataFile.GetItem(Start+g, 0, 0); if(pGItem->m_Version < 1 || pGItem->m_Version > CMapItemGroup::CURRENT_VERSION) continue; CLayerGroup *pGroup = NewGroup(); pGroup->m_ParallaxX = pGItem->m_ParallaxX; pGroup->m_ParallaxY = pGItem->m_ParallaxY; pGroup->m_OffsetX = pGItem->m_OffsetX; pGroup->m_OffsetY = pGItem->m_OffsetY; if(pGItem->m_Version >= 2) { pGroup->m_UseClipping = pGItem->m_UseClipping; pGroup->m_ClipX = pGItem->m_ClipX; pGroup->m_ClipY = pGItem->m_ClipY; pGroup->m_ClipW = pGItem->m_ClipW; pGroup->m_ClipH = pGItem->m_ClipH; } if(pGItem->m_Version >= 3) IntsToStr(pGItem->m_aName, sizeof(pGroup->m_aName)/sizeof(int), pGroup->m_aName); for(int l = 0; l < pGItem->m_NumLayers; l++) { CLayer *pLayer = 0; CMapItemLayer *pLayerItem = (CMapItemLayer *)DataFile.GetItem(LayersStart+pGItem->m_StartLayer+l, 0, 0); if(!pLayerItem) continue; if(pLayerItem->m_Type == LAYERTYPE_TILES) { CMapItemLayerTilemap *pTilemapItem = (CMapItemLayerTilemap *)pLayerItem; CLayerTiles *pTiles = 0; if(pTilemapItem->m_Flags&TILESLAYERFLAG_GAME) { pTiles = new CLayerGame(pTilemapItem->m_Width, pTilemapItem->m_Height); MakeGameLayer(pTiles); MakeGameGroup(pGroup); } else { pTiles = new CLayerTiles(pTilemapItem->m_Width, pTilemapItem->m_Height); pTiles->m_pEditor = m_pEditor; pTiles->m_Color = pTilemapItem->m_Color; pTiles->m_ColorEnv = pTilemapItem->m_ColorEnv; pTiles->m_ColorEnvOffset = pTilemapItem->m_ColorEnvOffset; } pLayer = pTiles; pGroup->AddLayer(pTiles); void *pData = DataFile.GetData(pTilemapItem->m_Data); pTiles->m_Image = pTilemapItem->m_Image; pTiles->m_Game = pTilemapItem->m_Flags&TILESLAYERFLAG_GAME; if(pTilemapItem->m_Version >= 3) IntsToStr(pTilemapItem->m_aName, sizeof(pTiles->m_aName)/sizeof(int), pTiles->m_aName); if(pTilemapItem->m_Version > 3) pTiles->ExtractTiles((CTile *)pData); else mem_copy(pTiles->m_pTiles, pData, pTiles->m_Width*pTiles->m_Height*sizeof(CTile)); if(pTiles->m_Game && pTilemapItem->m_Version == MakeVersion(1, *pTilemapItem)) { for(int i = 0; i < pTiles->m_Width*pTiles->m_Height; i++) { if(pTiles->m_pTiles[i].m_Index) pTiles->m_pTiles[i].m_Index += ENTITY_OFFSET; } } DataFile.UnloadData(pTilemapItem->m_Data); } else if(pLayerItem->m_Type == LAYERTYPE_QUADS) { CMapItemLayerQuads *pQuadsItem = (CMapItemLayerQuads *)pLayerItem; CLayerQuads *pQuads = new CLayerQuads; pQuads->m_pEditor = m_pEditor; pLayer = pQuads; pQuads->m_Image = pQuadsItem->m_Image; if(pQuads->m_Image < -1 || pQuads->m_Image >= m_lImages.size()) pQuads->m_Image = -1; if(pQuadsItem->m_Version >= 2) IntsToStr(pQuadsItem->m_aName, sizeof(pQuads->m_aName)/sizeof(int), pQuads->m_aName); void *pData = DataFile.GetDataSwapped(pQuadsItem->m_Data); pGroup->AddLayer(pQuads); pQuads->m_lQuads.set_size(pQuadsItem->m_NumQuads); mem_copy(pQuads->m_lQuads.base_ptr(), pData, sizeof(CQuad)*pQuadsItem->m_NumQuads); DataFile.UnloadData(pQuadsItem->m_Data); } if(pLayer) pLayer->m_Flags = pLayerItem->m_Flags; } } } { CEnvPoint *pEnvPoints = 0; { int Start, Num; DataFile.GetType(MAPITEMTYPE_ENVPOINTS, &Start, &Num); if(Num) pEnvPoints = (CEnvPoint *)DataFile.GetItem(Start, 0, 0); } int Start, Num; DataFile.GetType(MAPITEMTYPE_ENVELOPE, &Start, &Num); for(int e = 0; e < Num; e++) { CMapItemEnvelope *pItem = (CMapItemEnvelope *)DataFile.GetItem(Start+e, 0, 0); CEnvelope *pEnv = new CEnvelope(pItem->m_Channels); pEnv->m_lPoints.set_size(pItem->m_NumPoints); for(int n = 0; n < pItem->m_NumPoints; n++) { if(pItem->m_Version >= 3) { pEnv->m_lPoints[n] = pEnvPoints[pItem->m_StartPoint + n]; } else { CEnvPoint_v1 *pEnvPoint_v1 = &((CEnvPoint_v1 *)pEnvPoints)[pItem->m_StartPoint + n]; mem_zero((void*)&pEnv->m_lPoints[n], sizeof(CEnvPoint)); pEnv->m_lPoints[n].m_Time = pEnvPoint_v1->m_Time; pEnv->m_lPoints[n].m_Curvetype = pEnvPoint_v1->m_Curvetype; for(int c = 0; c < pItem->m_Channels; c++) { pEnv->m_lPoints[n].m_aValues[c] = pEnvPoint_v1->m_aValues[c]; } } } if(pItem->m_aName[0] != -1)IntsToStr(pItem->m_aName, sizeof(pItem->m_aName)/sizeof(int), pEnv->m_aName); m_lEnvelopes.add(pEnv); if(pItem->m_Version >= 2) pEnv->m_Synchronized = pItem->m_Synchronized; } } } else return 0; return 1; }"
"static int parse_token(char **name, char **value, char **cp) { char *end; if (!name || !value || !cp) return -BLKID_ERR_PARAM; if (!(*value = strchr(*cp, '='))) return 0; **value = '\0'; *name = strip_line(*cp); *value = skip_over_blank(*value + 1); if (**value == '""') { end = strchr(*value + 1, '""'); if (!end) { DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value)); *cp = *value; return -BLKID_ERR_CACHE; } (*value)++; *end = '\0'; end++; } else { end = skip_over_word(*value); if (*end) { *end = '\0'; end++; } } *cp = end; return 1; }"
"static int cp2112_gpio_get_all(struct gpio_chip *chip) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; unsigned long flags; int ret; spin_lock_irqsave(&dev->lock, flags); ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf, CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_GET_LENGTH) { hid_err(hdev, ""error requesting GPIO values: %d\n"", ret); ret = ret < 0 ? ret : -EIO; goto exit; } ret = buf[1]; exit: spin_unlock_irqrestore(&dev->lock, flags); return ret; }"
"static int uac_mixer_unit_get_channels(struct mixer_build *state, struct uac_mixer_unit_descriptor *desc) { int mu_channels; void *c; if (desc->bLength < sizeof(*desc)) return -EINVAL; if (!desc->bNrInPins) return -EINVAL; switch (state->mixer->protocol) { case UAC_VERSION_1: case UAC_VERSION_2: default: if (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1) return 0;  mu_channels = uac_mixer_unit_bNrChannels(desc); break; case UAC_VERSION_3: mu_channels = get_cluster_channels_v3(state, uac3_mixer_unit_wClusterDescrID(desc)); break; } if (!mu_channels) return 0; c = uac_mixer_unit_bmControls(desc, state->mixer->protocol); if (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength) return 0;  return mu_channels; }"
"void gtkui_icmp_redir(void) { GtkWidget *dialog, *table, *hbox, *image, *label, *entry1, *entry2, *frame; gint response = 0; DEBUG_MSG(""gtk_icmp_redir""); dialog = gtk_dialog_new_with_buttons(""MITM Attack: ICMP Redirect"", GTK_WINDOW (window), GTK_DIALOG_MODAL, GTK_STOCK_OK, GTK_RESPONSE_OK, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, NULL); gtk_container_set_border_width(GTK_CONTAINER (dialog), 5); gtk_dialog_set_has_separator(GTK_DIALOG (dialog), FALSE); hbox = gtk_hbox_new (FALSE, 5); gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox), hbox, FALSE, FALSE, 0); gtk_widget_show(hbox); image = gtk_image_new_from_stock (GTK_STOCK_DIALOG_QUESTION, GTK_ICON_SIZE_DIALOG); gtk_misc_set_alignment (GTK_MISC (image), 0.5, 0.1); gtk_box_pack_start (GTK_BOX (hbox), image, FALSE, FALSE, 5); gtk_widget_show(image); frame = gtk_frame_new(""Gateway Information""); gtk_container_set_border_width(GTK_CONTAINER (frame), 5); gtk_box_pack_start (GTK_BOX (hbox), frame, TRUE, TRUE, 0); gtk_widget_show(frame); table = gtk_table_new(2, 2, FALSE); gtk_table_set_row_spacings(GTK_TABLE (table), 5); gtk_table_set_col_spacings(GTK_TABLE (table), 5); gtk_container_set_border_width(GTK_CONTAINER (table), 8); gtk_container_add(GTK_CONTAINER (frame), table); gtk_widget_show(table); label = gtk_label_new(""MAC Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 0, 1, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry1 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry1), ETH_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry1, 1, 2, 0, 1);  gtk_widget_show(entry1); label = gtk_label_new(""IP Address""); gtk_misc_set_alignment(GTK_MISC (label), 0, 0.5); gtk_table_attach(GTK_TABLE (table), label, 0, 1, 1, 2, GTK_FILL, GTK_FILL, 0, 0); gtk_widget_show(label); entry2 = gtk_entry_new(); gtk_entry_set_max_length(GTK_ENTRY (entry2), IP6_ASCII_ADDR_LEN); gtk_table_attach_defaults(GTK_TABLE (table), entry2, 1, 2, 1, 2); gtk_widget_show(entry2); response = gtk_dialog_run(GTK_DIALOG(dialog)); if(response == GTK_RESPONSE_OK) { gtk_widget_hide(dialog); snprintf(params, 6, ""icmp:""); strncat(params, gtk_entry_get_text(GTK_ENTRY(entry1)), PARAMS_LEN); strncat(params, ""/"", PARAMS_LEN); strncat(params, gtk_entry_get_text(GTK_ENTRY(entry2)), PARAMS_LEN); gtkui_start_mitm(); } gtk_widget_destroy(dialog); }"
"void Compute(OpKernelContext* ctx) override { const Tensor& values_tensor = ctx->input(0); const Tensor& value_range_tensor = ctx->input(1); const Tensor& nbins_tensor = ctx->input(2); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()), errors::InvalidArgument(""value_range should be a vector."")); OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2), errors::InvalidArgument( ""value_range should be a vector of 2 elements."")); OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()), errors::InvalidArgument(""nbins should be a scalar."")); const auto values = values_tensor.flat<T>(); const auto value_range = value_range_tensor.flat<T>(); const auto nbins = nbins_tensor.scalar<int32>()(); OP_REQUIRES( ctx, (value_range(0) < value_range(1)), errors::InvalidArgument(""value_range should satisfy value_range[0] < "" ""value_range[1], but got '["", value_range(0), "", "", value_range(1), ""]'"")); OP_REQUIRES( ctx, (nbins > 0), errors::InvalidArgument(""nbins should be a positive number, but got '"", nbins, ""'"")); Tensor* out_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({nbins}), &out_tensor)); auto out = out_tensor->flat<Tout>(); OP_REQUIRES_OK( ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute( ctx, values, value_range, nbins, out)); }"
"SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username) { int i; SRP_user_pwd *user; unsigned char digv[SHA_DIGEST_LENGTH]; unsigned char digs[SHA_DIGEST_LENGTH]; EVP_MD_CTX ctxt; if (vb == NULL) return NULL; for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) { user = sk_SRP_user_pwd_value(vb->users_pwd, i); if (strcmp(user->id, username) == 0) return user; } if ((vb->seed_key == NULL) || (vb->default_g == NULL) || (vb->default_N == NULL)) return NULL; if ((user = SRP_user_pwd_new()) == NULL) return NULL; SRP_user_pwd_set_gN(user, vb->default_g, vb->default_N); if (!SRP_user_pwd_set_ids(user, username, NULL)) goto err; if (RAND_pseudo_bytes(digv, SHA_DIGEST_LENGTH) < 0) goto err; EVP_MD_CTX_init(&ctxt); EVP_DigestInit_ex(&ctxt, EVP_sha1(), NULL); EVP_DigestUpdate(&ctxt, vb->seed_key, strlen(vb->seed_key)); EVP_DigestUpdate(&ctxt, username, strlen(username)); EVP_DigestFinal_ex(&ctxt, digs, NULL); EVP_MD_CTX_cleanup(&ctxt); if (SRP_user_pwd_set_sv_BN (user, BN_bin2bn(digs, SHA_DIGEST_LENGTH, NULL), BN_bin2bn(digv, SHA_DIGEST_LENGTH, NULL))) return user; err:SRP_user_pwd_free(user); return NULL; }"
"Elf32_Sym const *PackLinuxElf32::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); unsigned const *const bitmask = &gashtab[4]; unsigned const *const buckets = &bitmask[n_bitmask]; unsigned const *const hasharr = &buckets[n_bucket]; unsigned const h = gnu_hash(name); unsigned const hbit1 = 037& h; unsigned const hbit2 = 037& (h>>gnu_shift); unsigned const w = get_te32(&bitmask[(n_bitmask -1) & (h>>5)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf32_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, 0==(1u& get_te32(hp++))); } } } return 0; }"
"void dump_mm(const struct mm_struct *mm) { pr_emerg(""mm %px mmap %px seqnum %d task_size %lu\n"" #ifdef CONFIG_MMU ""get_unmapped_area %px\n"" #endif ""mmap_base %lu mmap_legacy_base %lu highest_vm_end %lu\n"" ""pgd %px mm_users %d mm_count %d pgtables_bytes %lu map_count %d\n"" ""hiwater_rss %lx hiwater_vm %lx total_vm %lx locked_vm %lx\n"" ""pinned_vm %lx data_vm %lx exec_vm %lx stack_vm %lx\n"" ""start_code %lx end_code %lx start_data %lx end_data %lx\n"" ""start_brk %lx brk %lx start_stack %lx\n"" ""arg_start %lx arg_end %lx env_start %lx env_end %lx\n"" ""binfmt %px flags %lx core_state %px\n"" #ifdef CONFIG_AIO ""ioctx_table %px\n"" #endif #ifdef CONFIG_MEMCG ""owner %px "" #endif ""exe_file %px\n"" #ifdef CONFIG_MMU_NOTIFIER ""mmu_notifier_mm %px\n"" #endif #ifdef CONFIG_NUMA_BALANCING ""numa_next_scan %lu numa_scan_offset %lu numa_scan_seq %d\n"" #endif ""tlb_flush_pending %d\n"" ""def_flags: %#lx(%pGv)\n"", mm, mm->mmap, mm->vmacache_seqnum, mm->task_size, #ifdef CONFIG_MMU mm->get_unmapped_area, #endif mm->mmap_base, mm->mmap_legacy_base, mm->highest_vm_end, mm->pgd, atomic_read(&mm->mm_users), atomic_read(&mm->mm_count), mm_pgtables_bytes(mm), mm->map_count, mm->hiwater_rss, mm->hiwater_vm, mm->total_vm, mm->locked_vm, mm->pinned_vm, mm->data_vm, mm->exec_vm, mm->stack_vm, mm->start_code, mm->end_code, mm->start_data, mm->end_data, mm->start_brk, mm->brk, mm->start_stack, mm->arg_start, mm->arg_end, mm->env_start, mm->env_end, mm->binfmt, mm->flags, mm->core_state, #ifdef CONFIG_AIO mm->ioctx_table, #endif #ifdef CONFIG_MEMCG mm->owner, #endif mm->exe_file, #ifdef CONFIG_MMU_NOTIFIER mm->mmu_notifier_mm, #endif #ifdef CONFIG_NUMA_BALANCING mm->numa_next_scan, mm->numa_scan_offset, mm->numa_scan_seq, #endif atomic_read(&mm->tlb_flush_pending), mm->def_flags, &mm->def_flags ); }"
"static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id) { struct elo_priv *priv; int ret; struct usb_device *udev; if (!hid_is_usb(hdev)) return -EINVAL; priv = kzalloc(sizeof(*priv), GFP_KERNEL); if (!priv) return -ENOMEM; INIT_DELAYED_WORK(&priv->work, elo_work); udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent)); priv->usbdev = usb_get_dev(udev); hid_set_drvdata(hdev, priv); ret = hid_parse(hdev); if (ret) { hid_err(hdev, ""parse failed\n""); goto err_free; } ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT); if (ret) { hid_err(hdev, ""hw start failed\n""); goto err_free; } if (elo_broken_firmware(priv->usbdev)) { hid_info(hdev, ""broken firmware found, installing workaround\n""); queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL); } return 0; err_free: kfree(priv); return ret; }"
"void readConf() { guarded_mutex guard(gMutexConfigure); writeLog(0, ""Reading preference settings..."", LOG_LEVEL_INFO); eraseElements(global.excludeRemarks); eraseElements(global.includeRemarks); eraseElements(global.customProxyGroups); eraseElements(global.customRulesets); try { std::string prefdata = fileGet(global.prefPath, false); if(prefdata.find(""common:"") != prefdata.npos) { YAML::Node yaml = YAML::Load(prefdata); if(yaml.size() && yaml[""common""]) return readYAMLConf(yaml); } toml::value conf = parseToml(prefdata, global.prefPath); if(!conf.is_uninitialized() && toml::find_or<int>(conf, ""version"", 0)) return readTOMLConf(conf); } catch (YAML::Exception &e) { } catch (toml::exception &e) { writeLog(0, e.what(), LOG_LEVEL_DEBUG); } INIReader ini; ini.allow_dup_section_titles = true; int retVal = ini.ParseFile(global.prefPath); if(retVal != INIREADER_EXCEPTION_NONE) { writeLog(0, ""Unable to load preference settings. Reason: "" + ini.GetLastError(), LOG_LEVEL_FATAL); return; } string_array tempArray; ini.EnterSection(""common""); ini.GetBoolIfExist(""api_mode"", global.APIMode); ini.GetIfExist(""api_access_token"", global.accessToken); ini.GetIfExist(""default_url"", global.defaultUrls); global.enableInsert = ini.Get(""enable_insert""); ini.GetIfExist(""insert_url"", global.insertUrls); ini.GetBoolIfExist(""prepend_insert_url"", global.prependInsert); if(ini.ItemPrefixExist(""exclude_remarks"")) ini.GetAll(""exclude_remarks"", global.excludeRemarks); if(ini.ItemPrefixExist(""include_remarks"")) ini.GetAll(""include_remarks"", global.includeRemarks); global.filterScript = ini.GetBool(""enable_filter"") ? ini.Get(""filter_script""): """"; ini.GetIfExist(""base_path"", global.basePath); ini.GetIfExist(""clash_rule_base"", global.clashBase); ini.GetIfExist(""surge_rule_base"", global.surgeBase); ini.GetIfExist(""surfboard_rule_base"", global.surfboardBase); ini.GetIfExist(""mellow_rule_base"", global.mellowBase); ini.GetIfExist(""quan_rule_base"", global.quanBase); ini.GetIfExist(""quanx_rule_base"", global.quanXBase); ini.GetIfExist(""loon_rule_base"", global.loonBase); ini.GetIfExist(""default_external_config"", global.defaultExtConfig); ini.GetBoolIfExist(""append_proxy_type"", global.appendType); ini.GetIfExist(""proxy_config"", global.proxyConfig); ini.GetIfExist(""proxy_ruleset"", global.proxyRuleset); ini.GetIfExist(""proxy_subscription"", global.proxySubscription); if(ini.SectionExist(""surge_external_proxy"")) { ini.EnterSection(""surge_external_proxy""); ini.GetIfExist(""surge_ssr_path"", global.surgeSSRPath); ini.GetBoolIfExist(""resolve_hostname"", global.surgeResolveHostname); } if(ini.SectionExist(""node_pref"")) { ini.EnterSection(""node_pref""); global.UDPFlag.set(ini.Get(""udp_flag"")); global.TFOFlag.set(ini.Get(""tcp_fast_open_flag"")); global.skipCertVerify.set(ini.Get(""skip_cert_verify_flag"")); global.TLS13Flag.set(ini.Get(""tls13_flag"")); ini.GetBoolIfExist(""sort_flag"", global.enableSort); global.sortScript = ini.Get(""sort_script""); ini.GetBoolIfExist(""filter_deprecated_nodes"", global.filterDeprecated); ini.GetBoolIfExist(""append_sub_userinfo"", global.appendUserinfo); ini.GetBoolIfExist(""clash_use_new_field_name"", global.clashUseNewField); ini.GetIfExist(""clash_proxies_style"", global.clashProxiesStyle); if(ini.ItemPrefixExist(""rename_node"")) { ini.GetAll(""rename_node"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""@""); safe_set_renames(configs); eraseElements(tempArray); } } if(ini.SectionExist(""userinfo"")) { ini.EnterSection(""userinfo""); if(ini.ItemPrefixExist(""stream_rule"")) { ini.GetAll(""stream_rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""|""); safe_set_streams(configs); eraseElements(tempArray); } if(ini.ItemPrefixExist(""time_rule"")) { ini.GetAll(""time_rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, ""|""); safe_set_times(configs); eraseElements(tempArray); } } ini.EnterSection(""managed_config""); ini.GetBoolIfExist(""write_managed_config"", global.writeManagedConfig); ini.GetIfExist(""managed_config_prefix"", global.managedConfigPrefix); ini.GetIntIfExist(""config_update_interval"", global.updateInterval); ini.GetBoolIfExist(""config_update_strict"", global.updateStrict); ini.GetIfExist(""quanx_device_id"", global.quanXDevID); ini.EnterSection(""emojis""); ini.GetBoolIfExist(""add_emoji"", global.addEmoji); ini.GetBoolIfExist(""remove_old_emoji"", global.removeEmoji); if(ini.ItemPrefixExist(""rule"")) { ini.GetAll(""rule"", tempArray); importItems(tempArray, false); auto configs = INIBinding::from<RegexMatchConfig>::from_ini(tempArray, "",""); safe_set_emojis(configs); eraseElements(tempArray); } if(ini.SectionExist(""rulesets"")) ini.EnterSection(""rulesets""); else ini.EnterSection(""ruleset""); global.enableRuleGen = ini.GetBool(""enabled""); if(global.enableRuleGen) { ini.GetBoolIfExist(""overwrite_original_rules"", global.overwriteOriginalRules); ini.GetBoolIfExist(""update_ruleset_on_request"", global.updateRulesetOnRequest); if(ini.ItemPrefixExist(""ruleset"")) { string_array vArray; ini.GetAll(""ruleset"", vArray); importItems(vArray, false); global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray); } else if(ini.ItemPrefixExist(""surge_ruleset"")) { string_array vArray; ini.GetAll(""surge_ruleset"", vArray); importItems(vArray, false); global.customRulesets = INIBinding::from<RulesetConfig>::from_ini(vArray); } } else { global.overwriteOriginalRules = false; global.updateRulesetOnRequest = false; } if(ini.SectionExist(""proxy_groups"")) ini.EnterSection(""proxy_groups""); else ini.EnterSection(""clash_proxy_group""); if(ini.ItemPrefixExist(""custom_proxy_group"")) { string_array vArray; ini.GetAll(""custom_proxy_group"", vArray); importItems(vArray, false); global.customProxyGroups = INIBinding::from<ProxyGroupConfig>::from_ini(vArray); } ini.EnterSection(""template""); ini.GetIfExist(""template_path"", global.templatePath); string_multimap tempmap; ini.GetItems(tempmap); eraseElements(global.templateVars); for(auto &x : tempmap) { if(x.first == ""template_path"") continue; global.templateVars[x.first] = x.second; } global.templateVars[""managed_config_prefix""] = global.managedConfigPrefix; if(ini.SectionExist(""aliases"")) { ini.EnterSection(""aliases""); ini.GetItems(tempmap); webServer.reset_redirect(); for(auto &x : tempmap) webServer.append_redirect(x.first, x.second); } if(ini.SectionExist(""tasks"")) { string_array vArray; ini.EnterSection(""tasks""); ini.GetAll(""task"", vArray); importItems(vArray, false); global.enableCron = !vArray.empty(); global.cronTasks = INIBinding::from<CronTaskConfig>::from_ini(vArray); refresh_schedule(); } ini.EnterSection(""server""); ini.GetIfExist(""listen"", global.listenAddress); ini.GetIntIfExist(""port"", global.listenPort); webServer.serve_file_root = ini.Get(""serve_file_root""); webServer.serve_file = !webServer.serve_file_root.empty(); ini.EnterSection(""advanced""); std::string log_level; ini.GetIfExist(""log_level"", log_level); ini.GetBoolIfExist(""print_debug_info"", global.printDbgInfo); if(global.printDbgInfo) global.logLevel = LOG_LEVEL_VERBOSE; else { switch(hash_(log_level)) { case ""warn""_hash: global.logLevel = LOG_LEVEL_WARNING; break; case ""error""_hash: global.logLevel = LOG_LEVEL_ERROR; break; case ""fatal""_hash: global.logLevel = LOG_LEVEL_FATAL; break; case ""verbose""_hash: global.logLevel = LOG_LEVEL_VERBOSE; break; case ""debug""_hash: global.logLevel = LOG_LEVEL_DEBUG; break; default: global.logLevel = LOG_LEVEL_INFO; } } ini.GetIntIfExist(""max_pending_connections"", global.maxPendingConns); ini.GetIntIfExist(""max_concurrent_threads"", global.maxConcurThreads); ini.GetNumberIfExist(""max_allowed_rulesets"", global.maxAllowedRulesets); ini.GetNumberIfExist(""max_allowed_rules"", global.maxAllowedRules); ini.GetNumberIfExist(""max_allowed_download_size"", global.maxAllowedDownloadSize); if(ini.ItemExist(""enable_cache"")) { if(ini.GetBool(""enable_cache"")) { ini.GetIntIfExist(""cache_subscription"", global.cacheSubscription); ini.GetIntIfExist(""cache_config"", global.cacheConfig); ini.GetIntIfExist(""cache_ruleset"", global.cacheRuleset); ini.GetBoolIfExist(""serve_cache_on_fetch_fail"", global.serveCacheOnFetchFail); } else { global.cacheSubscription = global.cacheConfig = global.cacheRuleset = 0;             global.serveCacheOnFetchFail = false; } } ini.GetBoolIfExist(""script_clean_context"", global.scriptCleanContext); ini.GetBoolIfExist(""async_fetch_ruleset"", global.asyncFetchRuleset); ini.GetBoolIfExist(""skip_failed_links"", global.skipFailedLinks); writeLog(0, ""Read preference settings completed."", LOG_LEVEL_INFO); }"
"static int compat_copy_entries_to_user(unsigned int total_size, struct xt_table *table, void __user *userptr) { struct xt_counters *counters; const struct xt_table_info *private = table->private; void __user *pos; unsigned int size; int ret = 0; unsigned int i = 0; struct arpt_entry *iter; counters = alloc_counters(table); if (IS_ERR(counters)) return PTR_ERR(counters); pos = userptr; size = total_size; xt_entry_foreach(iter, private->entries, total_size) { ret = compat_copy_entry_to_user(iter, &pos, &size, counters, i++); if (ret != 0) break; } vfree(counters); return ret; }"
"void init_rc(void) { int i; struct stat st; FILE *f; if (rc_dir != NULL) goto open_rc; rc_dir = expandPath(RC_DIR); i = strlen(rc_dir); if (i > 1 && rc_dir[i - 1] == '/') rc_dir[i - 1] = '\0'; #ifdef USE_M17N display_charset_str = wc_get_ces_list(); document_charset_str = display_charset_str; system_charset_str = display_charset_str; #endif if (stat(rc_dir, &st) < 0) { if (errno == ENOENT) { if (do_mkdir(rc_dir, 0700) < 0) { goto rc_dir_err; } else { stat(rc_dir, &st); } } else { goto rc_dir_err; } } if (!S_ISDIR(st.st_mode)) { goto rc_dir_err; } if (!(st.st_mode & S_IWUSR)) { goto rc_dir_err; } no_rc_dir = FALSE; tmp_dir = rc_dir; if (config_file == NULL) config_file = rcFile(CONFIG_FILE); create_option_search_table(); open_rc: if ((f = fopen(etcFile(W3MCONFIG), ""rt"")) != NULL) { interpret_rc(f); fclose(f); } if ((f = fopen(confFile(CONFIG_FILE), ""rt"")) != NULL) { interpret_rc(f); fclose(f); } if (config_file && (f = fopen(config_file, ""rt"")) != NULL) { interpret_rc(f); fclose(f); } return; rc_dir_err: no_rc_dir = TRUE; if (((tmp_dir = getenv(""TMPDIR"")) == NULL || *tmp_dir == '\0') && ((tmp_dir = getenv(""TMP"")) == NULL || *tmp_dir == '\0') && ((tmp_dir = getenv(""TEMP"")) == NULL || *tmp_dir == '\0')) tmp_dir = ""/tmp""; create_option_search_table(); goto open_rc; }"
"static char * find_abstract_instance_name (struct comp_unit *unit, struct attribute *attr_ptr, bfd_boolean *is_linkage) { bfd *abfd = unit->abfd; bfd_byte *info_ptr; bfd_byte *info_ptr_end; unsigned int abbrev_number, bytes_read, i; struct abbrev_info *abbrev; bfd_uint64_t die_ref = attr_ptr->u.val; struct attribute attr; char *name = NULL; if (attr_ptr->form == DW_FORM_ref_addr) { if (!die_ref) abort (); info_ptr = unit->sec_info_ptr + die_ref; info_ptr_end = unit->end_ptr; if (info_ptr >= unit->info_ptr_unit && info_ptr < unit->end_ptr) ; else { struct comp_unit * u; for (u = unit->prev_unit; u != NULL; u = u->prev_unit) if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr) break; if (u == NULL) for (u = unit->next_unit; u != NULL; u = u->next_unit) if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr) break; if (u) unit = u; } } else if (attr_ptr->form == DW_FORM_GNU_ref_alt) { info_ptr = read_alt_indirect_ref (unit, die_ref); if (info_ptr == NULL) { _bfd_error_handler (_(""Dwarf Error: Unable to read alt ref %llu.""), (long long) die_ref); bfd_set_error (bfd_error_bad_value); return NULL; } info_ptr_end = unit->stash->alt_dwarf_info_buffer + unit->stash->alt_dwarf_info_size; } else { info_ptr = unit->info_ptr_unit + die_ref; info_ptr_end = unit->end_ptr; } abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, info_ptr_end); info_ptr += bytes_read; if (abbrev_number) { abbrev = lookup_abbrev (abbrev_number, unit->abbrevs); if (! abbrev) { _bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""), abbrev_number); bfd_set_error (bfd_error_bad_value); } else { for (i = 0; i < abbrev->num_attrs; ++i) { info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end); if (info_ptr == NULL) break; switch (attr.name) { case DW_AT_name: if (name == NULL && is_str_attr (attr.form)) { name = attr.u.str; if (non_mangled (unit->lang)) *is_linkage = TRUE; } break; case DW_AT_specification: name = find_abstract_instance_name (unit, &attr, is_linkage); break; case DW_AT_linkage_name: case DW_AT_MIPS_linkage_name: if (is_str_attr (attr.form)) { name = attr.u.str; *is_linkage = TRUE; } break; default: break; } } } } return name; }"
"void SExpressionWasmBuilder::parseGlobal(Element& s, bool preParseImport) { std::unique_ptr<Global> global = make_unique<Global>(); size_t i = 1; if (s[i]->dollared() && !(s[i]->isStr() && isType(s[i]->str()))) { global->name = s[i++]->str(); } else { global->name = Name::fromInt(globalCounter); } globalCounter++; globalNames.push_back(global->name); bool mutable_ = false; Type type = none; bool exported = false; Name importModule, importBase; while (i < s.size() && s[i]->isList()) { auto& inner = *s[i]; if (inner[0]->str() == EXPORT) { auto ex = make_unique<Export>(); ex->name = inner[1]->str(); ex->value = global->name; ex->kind = ExternalKind::Global; if (wasm.getExportOrNull(ex->name)) throw ParseException(""duplicate export"", s.line, s.col); wasm.addExport(ex.release()); exported = true; i++; } else if (inner[0]->str() == IMPORT) { importModule = inner[1]->str(); importBase = inner[2]->str(); i++; } else if (inner[0]->str() == MUT) { mutable_ = true; type = stringToType(inner[1]->str()); i++; } else { break; } } if (exported && mutable_) throw ParseException(""cannot export a mutable global"", s.line, s.col); if (type == none) { type = stringToType(s[i++]->str()); } if (importModule.is()) { if (!preParseImport) throw ParseException(""!preParseImport in global""); auto im = make_unique<Global>(); im->name = global->name; im->module = importModule; im->base = importBase; im->type = type; im->mutable_ = mutable_; if (wasm.getGlobalOrNull(im->name)) throw ParseException(""duplicate import"", s.line, s.col); wasm.addGlobal(im.release()); return; } if (preParseImport) throw ParseException(""preParseImport in global""); global->type = type; if (i < s.size()) { global->init = parseExpression(s[i++]); } else { throw ParseException(""global without init"", s.line, s.col); } global->mutable_ = mutable_; if (i != s.size()) throw ParseException(""extra import elements""); if (wasm.getGlobalOrNull(global->name)) throw ParseException(""duplicate import"", s.line, s.col); wasm.addGlobal(global.release()); }"
"void free_xen_event_channel(struct domain *d, int port) { BUG_ON(!port_is_valid(d, port)); evtchn_close(d, port, 0); }"
"Imaging ImagingResampleHorizontal(Imaging imIn, int xsize, int filter) { ImagingSectionCookie cookie; Imaging imOut; struct filter *filterp; float support, scale, filterscale; float center, ww, ss, ss0, ss1, ss2, ss3; int xx, yy, x, kmax, xmin, xmax; int *xbounds; float *k, *kk; switch (filter) { case IMAGING_TRANSFORM_LANCZOS: filterp = &LANCZOS; break; case IMAGING_TRANSFORM_BILINEAR: filterp = &BILINEAR; break; case IMAGING_TRANSFORM_BICUBIC: filterp = &BICUBIC; break; default: return (Imaging) ImagingError_ValueError( ""unsupported resampling filter"" ); } filterscale = scale = (float) imIn->xsize / xsize; support = filterp->support; if (filterscale < 1.0) { filterscale = 1.0; } support = support * filterscale; kmax = (int) ceil(support) * 2 + 1; kk = malloc(xsize * kmax * sizeof(float)); if ( ! kk) return (Imaging) ImagingError_MemoryError(); xbounds = malloc(xsize * 2 * sizeof(int)); if ( ! xbounds) { free(kk); return (Imaging) ImagingError_MemoryError(); } for (xx = 0; xx < xsize; xx++) { k = &kk[xx * kmax]; center = (xx + 0.5) * scale; ww = 0.0; ss = 1.0 / filterscale; xmin = (int) floor(center - support); if (xmin < 0) xmin = 0; xmax = (int) ceil(center + support); if (xmax > imIn->xsize) xmax = imIn->xsize; for (x = xmin; x < xmax; x++) { float w = filterp->filter((x - center + 0.5) * ss) * ss; k[x - xmin] = w; ww += w; } for (x = 0; x < xmax - xmin; x++) { if (ww != 0.0) k[x] /= ww; } xbounds[xx * 2 + 0] = xmin; xbounds[xx * 2 + 1] = xmax; } imOut = ImagingNew(imIn->mode, xsize, imIn->ysize); if ( ! imOut) { free(kk); free(xbounds); return NULL; } ImagingSectionEnter(&cookie); for (yy = 0; yy < imOut->ysize; yy++) { if (imIn->image8) { for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss = 0.5; for (x = xmin; x < xmax; x++) ss += i2f(imIn->image8[yy][x]) * k[x - xmin]; imOut->image8[yy][xx] = clip8(ss); } } else { switch(imIn->type) { case IMAGING_TYPE_UINT8: if (imIn->bands == 2) { for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss0 = ss1 = 0.5; for (x = xmin; x < xmax; x++) { ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin]; ss1 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin]; } imOut->image[yy][xx*4 + 0] = clip8(ss0); imOut->image[yy][xx*4 + 3] = clip8(ss1); } } else if (imIn->bands == 3) { for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss0 = ss1 = ss2 = 0.5; for (x = xmin; x < xmax; x++) { ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin]; ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin]; ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin]; } imOut->image[yy][xx*4 + 0] = clip8(ss0); imOut->image[yy][xx*4 + 1] = clip8(ss1); imOut->image[yy][xx*4 + 2] = clip8(ss2); } } else { for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss0 = ss1 = ss2 = ss3 = 0.5; for (x = xmin; x < xmax; x++) { ss0 += i2f((UINT8) imIn->image[yy][x*4 + 0]) * k[x - xmin]; ss1 += i2f((UINT8) imIn->image[yy][x*4 + 1]) * k[x - xmin]; ss2 += i2f((UINT8) imIn->image[yy][x*4 + 2]) * k[x - xmin]; ss3 += i2f((UINT8) imIn->image[yy][x*4 + 3]) * k[x - xmin]; } imOut->image[yy][xx*4 + 0] = clip8(ss0); imOut->image[yy][xx*4 + 1] = clip8(ss1); imOut->image[yy][xx*4 + 2] = clip8(ss2); imOut->image[yy][xx*4 + 3] = clip8(ss3); } } break; case IMAGING_TYPE_INT32: for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss = 0.0; for (x = xmin; x < xmax; x++) ss += i2f(IMAGING_PIXEL_I(imIn, x, yy)) * k[x - xmin]; IMAGING_PIXEL_I(imOut, xx, yy) = (int) ss; } break; case IMAGING_TYPE_FLOAT32: for (xx = 0; xx < xsize; xx++) { xmin = xbounds[xx * 2 + 0]; xmax = xbounds[xx * 2 + 1]; k = &kk[xx * kmax]; ss = 0.0; for (x = xmin; x < xmax; x++) ss += IMAGING_PIXEL_F(imIn, x, yy) * k[x - xmin]; IMAGING_PIXEL_F(imOut, xx, yy) = ss; } break; } } } ImagingSectionLeave(&cookie); free(kk); free(xbounds); return imOut; }"
int hns_rcb_get_ring_sset_count(int stringset) { if (stringset == ETH_SS_STATS) return HNS_RING_STATIC_REG_NUM; return 0; }
"static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct legacy_fs_context *ctx = fc->fs_private; unsigned int size = ctx->data_size; size_t len = 0; int ret; ret = vfs_parse_fs_param_source(fc, param); if (ret != -ENOPARAM) return ret; if (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS) return invalf(fc, ""VFS: Legacy: Can't mix monolithic and individual options""); switch (param->type) { case fs_value_is_string: len = 1 + param->size; fallthrough; case fs_value_is_flag: len += strlen(param->key); break; default: return invalf(fc, ""VFS: Legacy: Parameter type for '%s' not supported"", param->key); } if (len > PAGE_SIZE - 2 - size) return invalf(fc, ""VFS: Legacy: Cumulative options too large""); if (strchr(param->key, ',') || (param->type == fs_value_is_string && memchr(param->string, ',', param->size))) return invalf(fc, ""VFS: Legacy: Option '%s' contained comma"", param->key); if (!ctx->legacy_data) { ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL); if (!ctx->legacy_data) return -ENOMEM; } ctx->legacy_data[size++] = ','; len = strlen(param->key); memcpy(ctx->legacy_data + size, param->key, len); size += len; if (param->type == fs_value_is_string) { ctx->legacy_data[size++] = '='; memcpy(ctx->legacy_data + size, param->string, param->size); size += param->size; } ctx->legacy_data[size] = '\0'; ctx->data_size = size; ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS; return 0; }"
"int idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags) { uint32_t *input_u32; uint8_t *input_u8, *output_u8; size_t length; int rc; if (!input) { if (output) *output = 0; return IDN2_OK; } input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t)); if (!input_u32) return IDN2_MALLOC; u32_cpy (input_u32, input, inlen); input_u32[inlen] = 0; input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length); free (input_u32); if (!input_u8) { if (errno == ENOMEM) return IDN2_MALLOC; return IDN2_ENCODING_ERROR; } rc = idn2_lookup_u8 (input_u8, &output_u8, flags); free (input_u8); if (rc == IDN2_OK) { if (output) strcpy (output, (const char *) output_u8); free(output_u8); } return rc; }"
"int wl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data) { union map_entry *start; uint32_t count; struct wl_array *entries; if (i < WL_SERVER_ID_START) { entries = &map->client_entries; } else { entries = &map->server_entries; i -= WL_SERVER_ID_START; } count = entries->size / sizeof *start; if (count < i) { errno = EINVAL; return -1; } if (count == i) { if (!wl_array_add(entries, sizeof *start)) return -1; } start = entries->data; start[i].data = data; start[i].next |= (flags & 0x1) << 1; return 0; }"
"std::shared_ptr<Grammar> perform_core(const char *s, size_t n, const Rules &rules, std::string &start, Log log) { Data data; any dt = &data; auto r = g[""Grammar""].parse(s, n, dt); if (!r.ret) { if (log) { if (r.message_pos) { auto line = line_info(s, r.message_pos); log(line.first, line.second, r.message); } else { auto line = line_info(s, r.error_pos); log(line.first, line.second, ""syntax error""); } } return nullptr; } auto &grammar = *data.grammar; for (const auto &x : rules) { auto name = x.first; bool ignore = false; if (!name.empty() && name[0] == '~') { ignore = true; name.erase(0, 1); } if (!name.empty()) { auto &rule = grammar[name]; rule <= x.second; rule.name = name; rule.ignoreSemanticValue = ignore; } } bool ret = data.duplicates.empty(); for (const auto &x : data.duplicates) { if (log) { const auto &name = x.first; auto ptr = x.second; auto line = line_info(s, ptr); log(line.first, line.second, ""'"" + name + ""' is already defined.""); } } for (auto &x : grammar) { auto &rule = x.second; ReferenceChecker vis(*data.grammar, rule.params); rule.accept(vis); for (const auto &y : vis.error_s) { const auto &name = y.first; const auto ptr = y.second; if (log) { auto line = line_info(s, ptr); log(line.first, line.second, vis.error_message[name]); } ret = false; } } if (!ret) { return nullptr; } for (auto &x : grammar) { auto &rule = x.second; LinkReferences vis(*data.grammar, rule.params); rule.accept(vis); } ret = true; for (auto &x : grammar) { const auto &name = x.first; auto &rule = x.second; DetectLeftRecursion vis(name); rule.accept(vis); if (vis.error_s) { if (log) { auto line = line_info(s, vis.error_s); log(line.first, line.second, ""'"" + name + ""' is left recursive.""); } ret = false; } } if (!ret) { return nullptr; } auto &start_rule = (*data.grammar)[data.start]; { DetectInfiniteLoop vis(data.start_pos, data.start); start_rule.accept(vis); if (vis.has_error) { if (log) { auto line = line_info(s, vis.error_s); log(line.first, line.second, ""infinite loop is detected in '"" + vis.error_name + ""'.""); } return nullptr; } } if (grammar.count(WHITESPACE_DEFINITION_NAME)) { for (auto &x : grammar) { auto &rule = x.second; auto ope = rule.get_core_operator(); if (IsLiteralToken::check(*ope)) { rule <= tok(ope); } } start_rule.whitespaceOpe = wsp((*data.grammar)[WHITESPACE_DEFINITION_NAME].get_core_operator()); } if (grammar.count(WORD_DEFINITION_NAME)) { start_rule.wordOpe = (*data.grammar)[WORD_DEFINITION_NAME].get_core_operator(); } for (const auto &item : data.instructions) { const auto &name = item.first; const auto &instruction = item.second; auto &rule = grammar[name]; if (instruction.type == ""precedence"") { const auto &info = any_cast<PrecedenceClimbing::BinOpeInfo>(instruction.data); if (!apply_precedence_instruction(rule, info, s, log)) { return nullptr; } } } start = data.start; return data.grammar; }"
"static int op_get_data(OggOpusFile *_of,int _nbytes){ unsigned char *buffer; int            nbytes; OP_ASSERT(_nbytes>0); buffer=(unsigned char *)ogg_sync_buffer(&_of->oy,_nbytes); nbytes=(int)(*_of->callbacks.read)(_of->stream,buffer,_nbytes); OP_ASSERT(nbytes<=_nbytes); if(OP_LIKELY(nbytes>0))ogg_sync_wrote(&_of->oy,nbytes); return nbytes; }"
"char *strstr(char *s1, char *s2) {                                char *p; int len = strlen(s2); if (*s2 == '\0')             return s1; for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) { if (strncmp(p, s2, len) == 0) return (p); } return NULL; }"
"static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags) { if ((ctx->clockid == CLOCK_REALTIME || ctx->clockid == CLOCK_REALTIME_ALARM) && (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) { if (!ctx->might_cancel) { ctx->might_cancel = true; spin_lock(&cancel_lock); list_add_rcu(&ctx->clist, &cancel_list); spin_unlock(&cancel_lock); } } else if (ctx->might_cancel) { timerfd_remove_cancel(ctx); } }"
"static void pdf_dev_clip_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm, fz_rect scissor) { pdf_device *pdev = (pdf_device*)dev; fz_text_span *span; for (span = text->head; span; span = span->next) { pdf_dev_begin_text(ctx, pdev, span->trm, 0); pdf_dev_ctm(ctx, pdev, ctm); pdf_dev_font(ctx, pdev, span->font); pdf_dev_text_span(ctx, pdev, span); } }"
"int xmlParseElementDecl(xmlParserCtxtPtr ctxt) { const xmlChar *name; int ret = -1; xmlElementContentPtr content  = NULL; if (CMP9(CUR_PTR, '<', '!', 'E', 'L', 'E', 'M', 'E', 'N', 'T')) { xmlParserInputPtr input = ctxt->input; SKIP(9); if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, ""Space required after 'ELEMENT'\n""); } SKIP_BLANKS; name = xmlParseName(ctxt); if (name == NULL) { xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED, ""xmlParseElementDecl: no name for Element\n""); return(-1); } while ((RAW == 0) && (ctxt->inputNr > 1)) xmlPopInput(ctxt); if (!IS_BLANK_CH(CUR)) { xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, ""Space required after the element name\n""); } SKIP_BLANKS; if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) { SKIP(5); ret = XML_ELEMENT_TYPE_EMPTY; } else if ((RAW == 'A') && (NXT(1) == 'N') && (NXT(2) == 'Y')) { SKIP(3); ret = XML_ELEMENT_TYPE_ANY; } else if (RAW == '(') { ret = xmlParseElementContentDecl(ctxt, name, &content); } else { if ((RAW == '%') && (ctxt->external == 0) && (ctxt->inputNr == 1)) { xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET, ""PEReference: forbidden within markup decl in internal subset\n""); } else { xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, ""xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\n""); } return(-1); } SKIP_BLANKS; while ((RAW == 0) && (ctxt->inputNr > 1)) xmlPopInput(ctxt); SKIP_BLANKS; if (RAW != '>') { xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL); if (content != NULL) { xmlFreeDocElementContent(ctxt->myDoc, content); } } else { if (input != ctxt->input) { xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY, ""Element declaration doesn't start and stop in the same entity\n""); } NEXT; if ((ctxt->sax != NULL) && (!ctxt->disableSAX) && (ctxt->sax->elementDecl != NULL)) { if (content != NULL) content->parent = NULL; ctxt->sax->elementDecl(ctxt->userData, name, ret, content); if ((content != NULL) && (content->parent == NULL)) { xmlFreeDocElementContent(ctxt->myDoc, content); } } else if (content != NULL) { xmlFreeDocElementContent(ctxt->myDoc, content); } } } return(ret); }"
"void xps_load_sfnt_name(xps_font_t *font, char *namep) { byte *namedata; int offset, length; int count, stringoffset; int found; int i, k; found = 0; strcpy(namep, ""Unknown""); offset = xps_find_sfnt_table(font, ""name"", &length); if (offset < 0 || length < 6) { gs_warn(""cannot find name table""); return; } if (offset + 6 > font->length) { gs_warn(""name table byte offset invalid""); return; } namedata = font->data + offset; count = u16(namedata + 2); stringoffset = u16(namedata + 4); if (stringoffset + offset > font->length || offset + 6 + count * 12 > font->length) { gs_warn(""name table invalid""); return; } if (length < 6 + (count * 12)) { gs_warn(""name table too short""); return; } for (i = 0; i < count; i++) { byte *record = namedata + 6 + i * 12; int pid = u16(record + 0); int eid = u16(record + 2); int langid = u16(record + 4); int nameid = u16(record + 6); length = u16(record + 8); offset = u16(record + 10); if (nameid == 4 || nameid == 6) { if (pid == 1 && eid == 0 && langid == 0)  { if (found < 3) { memcpy(namep, namedata + stringoffset + offset, length); namep[length] = 0; found = 3; } } if (pid == 3 && eid == 1 && langid == 0x409)  { if (found < 2) { unsigned char *s = namedata + stringoffset + offset; int n = length / 2; for (k = 0; k < n; k ++) { int c = u16(s + k * 2); namep[k] = isprint(c) ? c : '?'; } namep[k] = 0; found = 2; } } if (pid == 3 && eid == 10 && langid == 0x409)  { if (found < 1) { unsigned char *s = namedata + stringoffset + offset; int n = length / 4; for (k = 0; k < n; k ++) { int c = u32(s + k * 4); namep[k] = isprint(c) ? c : '?'; } namep[k] = 0; found = 1; } } } } }"
void exit_files(struct task_struct *tsk) { struct files_struct * files = tsk->files; if (files) { task_lock(tsk); tsk->files = NULL; task_unlock(tsk); put_files_struct(files); } }
"static int rtsx_usb_ms_drv_remove(struct platform_device *pdev) { struct rtsx_usb_ms *host = platform_get_drvdata(pdev); struct memstick_host *msh = host->msh; int err; host->eject = true; cancel_work_sync(&host->handle_req); mutex_lock(&host->host_mutex); if (host->req) { dev_dbg(ms_dev(host), ""%s: Controller removed during transfer\n"", dev_name(&msh->dev)); host->req->error = -ENOMEDIUM; do { err = memstick_next_req(msh, &host->req); if (!err) host->req->error = -ENOMEDIUM; } while (!err); } mutex_unlock(&host->host_mutex); memstick_remove_host(msh); memstick_free_host(msh); if (pm_runtime_active(ms_dev(host))) pm_runtime_put(ms_dev(host)); pm_runtime_disable(ms_dev(host)); platform_set_drvdata(pdev, NULL); dev_dbg(ms_dev(host), "": Realtek USB Memstick controller has been removed\n""); return 0; }"
"static int handle_input_expect_headers(struct st_h2o_http3_server_stream_t *stream, const uint8_t **src, const uint8_t *src_end, const char **err_desc) { struct st_h2o_http3_server_conn_t *conn = get_conn(stream); h2o_http3_read_frame_t frame; int header_exists_map = 0, ret; uint8_t header_ack[H2O_HPACK_ENCODE_INT_MAX_LENGTH]; size_t header_ack_len; if ((ret = h2o_http3_read_frame(&frame, 0, H2O_HTTP3_STREAM_TYPE_REQUEST, src, src_end, err_desc)) != 0) return ret; if (frame.type != H2O_HTTP3_FRAME_TYPE_HEADERS) { switch (frame.type) { case H2O_HTTP3_FRAME_TYPE_DATA: return H2O_HTTP3_ERROR_FRAME_UNEXPECTED; default: break; } return 0; } stream->recvbuf.handle_input = handle_input_expect_data; if ((ret = h2o_qpack_parse_request(&stream->req.pool, get_conn(stream)->h3.qpack.dec, stream->quic->stream_id, &stream->req.input.method, &stream->req.input.scheme, &stream->req.input.authority, &stream->req.input.path, &stream->req.headers, &header_exists_map, &stream->req.content_length, NULL , header_ack, &header_ack_len, frame.payload, frame.length, err_desc)) != 0 && ret != H2O_HTTP2_ERROR_INVALID_HEADER_CHAR) return ret; if (header_ack_len != 0) h2o_http3_send_qpack_header_ack(&conn->h3, header_ack, header_ack_len); if (stream->req.input.scheme == NULL) stream->req.input.scheme = &H2O_URL_SCHEME_HTTPS; h2o_probe_log_request(&stream->req, stream->quic->stream_id); int is_connect = h2o_memis(stream->req.input.method.base, stream->req.input.method.len, H2O_STRLIT(""CONNECT"")); int expected_map = H2O_HPACK_PARSE_HEADERS_METHOD_EXISTS | H2O_HPACK_PARSE_HEADERS_AUTHORITY_EXISTS; if (!is_connect) expected_map |= H2O_HPACK_PARSE_HEADERS_SCHEME_EXISTS | H2O_HPACK_PARSE_HEADERS_PATH_EXISTS; if (header_exists_map != expected_map) { shutdown_stream(stream, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, H2O_HTTP3_ERROR_GENERAL_PROTOCOL, 0); return 0; } if (ret == H2O_HTTP2_ERROR_INVALID_HEADER_CHAR) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"", *err_desc, err_desc); if (stream->req.content_length != SIZE_MAX && stream->req.content_length > conn->super.ctx->globalconf->max_request_entity_size) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_413, ""Request Entity Too Large"", ""request entity is too large"", err_desc); assert(!h2o_linklist_is_linked(&stream->scheduler.link)); if (!stream->received_priority_update) { ssize_t index; if ((index = h2o_find_header(&stream->req.headers, H2O_TOKEN_PRIORITY, -1)) != -1) { h2o_iovec_t *value = &stream->req.headers.entries[index].value; h2o_absprio_parse_priority(value->base, value->len, &stream->scheduler.priority); } } if (is_connect) { if (stream->req.content_length != SIZE_MAX) return handle_input_expect_headers_send_http_error(stream, h2o_send_error_400, ""Invalid Request"", ""CONNECT request cannot have request body"", err_desc); set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_SEND_HEADERS, 0); stream->tunnel = h2o_mem_alloc(sizeof(*stream->tunnel)); stream->tunnel->tunnel = NULL; stream->tunnel->stream = stream; stream->tunnel->up.is_inflight = 0; stream->tunnel->up.delayed_write = (h2o_timer_t){.cb = tunnel_write_delayed}; h2o_process_request(&stream->req); return 0; } set_state(stream, H2O_HTTP3_SERVER_STREAM_STATE_RECV_BODY_BEFORE_BLOCK, 0); return 0; }"
"static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd) { struct inode *inode = dentry->d_inode; int error = -EACCES; path_put(&nd->path); if (!proc_fd_access_allowed(inode)) goto out; error = PROC_I(inode)->op.proc_get_link(inode, &nd->path); nd->last_type = LAST_BIND; out: return ERR_PTR(error); }"
"void PsdImage::readMetadata() { #ifdef DEBUG std::cerr << ""Exiv2::PsdImage::readMetadata: Reading Photoshop file "" << io_->path() << ""\n""; #endif if (io_->open() != 0) { throw Error(kerDataSourceOpenFailed, io_->path(), strError()); } IoCloser closer(*io_); if (!isPsdType(*io_, false)) { if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData); throw Error(kerNotAnImage, ""Photoshop""); } clearMetadata(); byte buf[26]; if (io_->read(buf, 26) != 26) { throw Error(kerNotAnImage, ""Photoshop""); } pixelWidth_ = getLong(buf + 18, bigEndian); pixelHeight_ = getLong(buf + 14, bigEndian); if (io_->read(buf, 4) != 4) { throw Error(kerNotAnImage, ""Photoshop""); } uint32_t colorDataLength = getULong(buf, bigEndian); if (io_->seek(colorDataLength, BasicIo::cur)) { throw Error(kerNotAnImage, ""Photoshop""); } if (io_->read(buf, 4) != 4) { throw Error(kerNotAnImage, ""Photoshop""); } uint32_t resourcesLength = getULong(buf, bigEndian); while (resourcesLength > 0) { if (io_->read(buf, 8) != 8) { throw Error(kerNotAnImage, ""Photoshop""); } if (!Photoshop::isIrb(buf, 4)) { break;             } uint16_t resourceId = getUShort(buf + 4, bigEndian); uint32_t resourceNameLength = buf[6] & ~1; io_->seek(resourceNameLength, BasicIo::cur); if (io_->read(buf, 4) != 4) { throw Error(kerNotAnImage, ""Photoshop""); } uint32_t resourceSize = getULong(buf, bigEndian); uint32_t curOffset = io_->tell(); #ifdef DEBUG std::cerr << std::hex << ""resourceId: "" << resourceId << std::dec << "" length: "" << resourceSize << std::hex << ""\n""; #endif readResourceBlock(resourceId, resourceSize); resourceSize = (resourceSize + 1) & ~1;                    io_->seek(curOffset + resourceSize, BasicIo::beg); resourcesLength -= (12 + resourceNameLength + resourceSize); } }"
"int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num) { if (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) { return -1; } unsigned short value = DNS_HTTPS_T_IPV6HINT; dns_add_rr_nested_memcpy(svcparam, &value, 2); value = addr_num * DNS_RR_AAAA_LEN; dns_add_rr_nested_memcpy(svcparam, &value, 2); for (int i = 0; i < addr_num; i++) { dns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN); } return 0; }"
"static void mbim_dissect_providers(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset) { proto_tree *subtree; gint base_offset; guint32 i, elem_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_providers_elem_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &elem_count); offset += 4; if (elem_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), elem_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*elem_count, ett_mbim_pair_list, NULL, ""Providers Ref List""); for (i = 0; i < elem_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < elem_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""Provider #%u"", i+1); mbim_dissect_provider(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } } } }"
"Values::Field* Statement::BindParameter(const Napi::Value source, T pos) { if (source.IsString()) { std::string val = source.As<Napi::String>().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else if (OtherInstanceOf(source.As<Object>(), ""RegExp"")) { std::string val = source.ToString().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else if (source.IsNumber()) { if (OtherIsInt(source.As<Napi::Number>())) { return new Values::Integer(pos, source.As<Napi::Number>().Int32Value()); } else { return new Values::Float(pos, source.As<Napi::Number>().DoubleValue()); } } else if (source.IsBoolean()) { return new Values::Integer(pos, source.As<Napi::Boolean>().Value() ? 1 : 0); } else if (source.IsNull()) { return new Values::Null(pos); } else if (source.IsBuffer()) { Napi::Buffer<char> buffer = source.As<Napi::Buffer<char>>(); return new Values::Blob(pos, buffer.Length(), buffer.Data()); } else if (OtherInstanceOf(source.As<Object>(), ""Date"")) { return new Values::Float(pos, source.ToNumber().DoubleValue()); } else if (source.IsObject()) { std::string val = source.ToString().Utf8Value(); return new Values::Text(pos, val.length(), val.c_str()); } else { return NULL; } }"
"static inline int compat_copy_match_to_user(struct ipt_entry_match *m, void __user **dstptr, compat_uint_t *size) { if (m->u.kernel.match->compat) return m->u.kernel.match->compat(m, dstptr, size, COMPAT_TO_USER); else return xt_compat_match(m, dstptr, size, COMPAT_TO_USER); }"
"static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies, size_t mincodes, size_t numcodes, unsigned maxbitlen) { unsigned error = 0; while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--;  tree->maxbitlen = maxbitlen; tree->numcodes = (unsigned)numcodes;  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned)); if(!tree->lengths) return 83;  memset(tree->lengths, 0, numcodes * sizeof(unsigned)); error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen); if(!error) error = HuffmanTree_makeFromLengths2(tree); return error; }"
"static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, struct netlink_ext_ack *extack) { struct net *net = sock_net(skb->sk); struct nlattr *attrs[XFRMA_MAX+1]; const struct xfrm_link *link; int type, err; #ifdef CONFIG_COMPAT if (in_compat_syscall()) return -EOPNOTSUPP; #endif type = nlh->nlmsg_type; if (type > XFRM_MSG_MAX) return -EINVAL; type -= XFRM_MSG_BASE; link = &xfrm_dispatch[type]; if (!netlink_net_capable(skb, CAP_NET_ADMIN)) return -EPERM; if ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) || type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) && (nlh->nlmsg_flags & NLM_F_DUMP)) { if (link->dump == NULL) return -EINVAL; { struct netlink_dump_control c = { .dump = link->dump, .done = link->done, }; return netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c); } } err = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, link->nla_max ? : XFRMA_MAX, link->nla_pol ? : xfrma_policy, extack); if (err < 0) return err; if (link->doit == NULL) return -EINVAL; return link->doit(skb, nlh, attrs); }"
"static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset) { MXFContext *mxf = arg; int item_num = avio_rb32(pb); int item_len = avio_rb32(pb); if (item_len != 18) { avpriv_request_sample(pb, ""Primer pack item length %d"", item_len); return AVERROR_PATCHWELCOME; } if (item_num > 65536) { av_log(mxf->fc, AV_LOG_ERROR, ""item_num %d is too large\n"", item_num); return AVERROR_INVALIDDATA; } if (mxf->local_tags) av_log(mxf->fc, AV_LOG_VERBOSE, ""Multiple primer packs\n""); av_free(mxf->local_tags); mxf->local_tags_count = 0; mxf->local_tags = av_calloc(item_num, item_len); if (!mxf->local_tags) return AVERROR(ENOMEM); mxf->local_tags_count = item_num; avio_read(pb, mxf->local_tags, item_num*item_len); return 0; }"
"static void *sgpd_parse_entry(u32 grouping_type, GF_BitStream *bs, u32 entry_size, u32 *total_bytes) { Bool null_size_ok = GF_FALSE; GF_DefaultSampleGroupDescriptionEntry *ptr; switch (grouping_type) { case GF_ISOM_SAMPLE_GROUP_ROLL: case GF_ISOM_SAMPLE_GROUP_PROL: { GF_RollRecoveryEntry *ptr; GF_SAFEALLOC(ptr, GF_RollRecoveryEntry); if (!ptr) return NULL; ptr->roll_distance = gf_bs_read_int(bs, 16); *total_bytes = 2; return ptr; } case GF_ISOM_SAMPLE_GROUP_RAP: { GF_VisualRandomAccessEntry *ptr; GF_SAFEALLOC(ptr, GF_VisualRandomAccessEntry); if (!ptr) return NULL; ptr->num_leading_samples_known = gf_bs_read_int(bs, 1); ptr->num_leading_samples = gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SAP: { GF_SAPEntry *ptr; GF_SAFEALLOC(ptr, GF_SAPEntry); if (!ptr) return NULL; ptr->dependent_flag = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 3); ptr->SAP_type = gf_bs_read_int(bs, 4); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SYNC: { GF_SYNCEntry *ptr; GF_SAFEALLOC(ptr, GF_SYNCEntry); if (!ptr) return NULL; gf_bs_read_int(bs, 2); ptr->NALU_type = gf_bs_read_int(bs, 6); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_TELE: { GF_TemporalLevelEntry *ptr; GF_SAFEALLOC(ptr, GF_TemporalLevelEntry); if (!ptr) return NULL; ptr->level_independently_decodable = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 7); *total_bytes = 1; return ptr; } case GF_ISOM_SAMPLE_GROUP_SEIG: { GF_CENCSampleEncryptionGroupEntry *ptr; GF_SAFEALLOC(ptr, GF_CENCSampleEncryptionGroupEntry); if (!ptr) return NULL; gf_bs_read_u8(bs); ptr->crypt_byte_block = gf_bs_read_int(bs, 4); ptr->skip_byte_block = gf_bs_read_int(bs, 4); ptr->IsProtected = gf_bs_read_u8(bs); ptr->Per_Sample_IV_size = gf_bs_read_u8(bs); gf_bs_read_data(bs, (char *)ptr->KID, 16); *total_bytes = 20; if ((ptr->IsProtected == 1) && !ptr->Per_Sample_IV_size) { ptr->constant_IV_size = gf_bs_read_u8(bs); assert((ptr->constant_IV_size == 8) || (ptr->constant_IV_size == 16)); gf_bs_read_data(bs, (char *)ptr->constant_IV, ptr->constant_IV_size); *total_bytes += 1 + ptr->constant_IV_size; } if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] seig sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_OINF: { GF_OperatingPointsInformation *ptr = gf_isom_oinf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_oinf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] oinf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_LINF: { GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry(); u32 s = (u32) gf_bs_get_position(bs); gf_isom_linf_read_entry(ptr, bs); *total_bytes = (u32) gf_bs_get_position(bs) - s; if (!entry_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] linf sample group does not indicate entry size, deprecated in spec\n"")); } return ptr; } case GF_ISOM_SAMPLE_GROUP_TRIF: if (! entry_size) { u32 flags = gf_bs_peek_bits(bs, 24, 0); if (flags & 0x10000) entry_size=3; else { if (flags & 0x80000) entry_size=7; else entry_size=11; if (flags & 0x200000) { u32 nb_entries = gf_bs_peek_bits(bs, 16, entry_size); entry_size += 2 + 2*nb_entries; } } GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] trif sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_NALM: if (! entry_size) { u64 start = gf_bs_get_position(bs); Bool rle, large_size; u32 entry_count; gf_bs_read_int(bs, 6); large_size = gf_bs_read_int(bs, 1); rle = gf_bs_read_int(bs, 1); entry_count = gf_bs_read_int(bs, large_size ? 16 : 8); gf_bs_seek(bs, start); entry_size = 1 + large_size ? 2 : 1; entry_size += entry_count * 2; if (rle) entry_size += entry_count * (large_size ? 2 : 1); GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] nalm sample group does not indicate entry size, deprecated in spec\n"")); } break; case GF_ISOM_SAMPLE_GROUP_TSAS: case GF_ISOM_SAMPLE_GROUP_STSA: null_size_ok = GF_TRUE; break; case GF_ISOM_SAMPLE_GROUP_TSCL: entry_size = 20; break; case GF_ISOM_SAMPLE_GROUP_LBLI: entry_size = 2; break; default: break; } if (!entry_size && !null_size_ok) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] %s sample group does not indicate entry size and is not implemented, cannot parse!\n"", gf_4cc_to_str( grouping_type) )); return NULL; } GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry); if (!ptr) return NULL; if (entry_size) { ptr->length = entry_size; ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length); gf_bs_read_data(bs, (char *) ptr->data, ptr->length); *total_bytes = entry_size; } return ptr; }"
"bool move_huge_pmd(struct vm_area_struct *vma, unsigned long old_addr, unsigned long new_addr, unsigned long old_end, pmd_t *old_pmd, pmd_t *new_pmd, bool *need_flush) { spinlock_t *old_ptl, *new_ptl; pmd_t pmd; struct mm_struct *mm = vma->vm_mm; bool force_flush = false; if ((old_addr & ~HPAGE_PMD_MASK) || (new_addr & ~HPAGE_PMD_MASK) || old_end - old_addr < HPAGE_PMD_SIZE) return false; if (WARN_ON(!pmd_none(*new_pmd))) { VM_BUG_ON(pmd_trans_huge(*new_pmd)); return false; } old_ptl = __pmd_trans_huge_lock(old_pmd, vma); if (old_ptl) { new_ptl = pmd_lockptr(mm, new_pmd); if (new_ptl != old_ptl) spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING); pmd = pmdp_huge_get_and_clear(mm, old_addr, old_pmd); if (pmd_present(pmd) && pmd_dirty(pmd)) force_flush = true; VM_BUG_ON(!pmd_none(*new_pmd)); if (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) { pgtable_t pgtable; pgtable = pgtable_trans_huge_withdraw(mm, old_pmd); pgtable_trans_huge_deposit(mm, new_pmd, pgtable); } pmd = move_soft_dirty_pmd(pmd); set_pmd_at(mm, new_addr, new_pmd, pmd); if (new_ptl != old_ptl) spin_unlock(new_ptl); if (force_flush) flush_tlb_range(vma, old_addr, old_addr + PMD_SIZE); else *need_flush = true; spin_unlock(old_ptl); return true; } return false; }"
"void spell_suggest(int count) { char_u*line; pos_Tprev_cursor = curwin->w_cursor; char_uwcopy[MAXWLEN + 2]; char_u*p; inti; intc; suginfo_Tsug; suggest_T*stp; intmouse_used; intneed_cap; intlimit; intselected = count; intbadlen = 0; intmsg_scroll_save = msg_scroll; intwo_spell_save = curwin->w_p_spell; if (!curwin->w_p_spell) { did_set_spelllang(curwin); curwin->w_p_spell = TRUE; } if (*curwin->w_s->b_p_spl == NUL) { emsg(_(e_spell_checking_is_not_possible)); return; } if (VIsual_active) { if (curwin->w_cursor.lnum != VIsual.lnum) { vim_beep(BO_SPELL); return; } badlen = (int)curwin->w_cursor.col - (int)VIsual.col; if (badlen < 0) badlen = -badlen; else curwin->w_cursor.col = VIsual.col; ++badlen; end_visual_mode(); } else if (spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL) == 0 || curwin->w_cursor.col > prev_cursor.col) { curwin->w_cursor = prev_cursor; line = ml_get_curline(); p = line + curwin->w_cursor.col; while (p > line && spell_iswordp_nmw(p, curwin)) MB_PTR_BACK(line, p); while (*p != NUL && !spell_iswordp_nmw(p, curwin)) MB_PTR_ADV(p); if (!spell_iswordp_nmw(p, curwin)){ beep_flush(); return; } curwin->w_cursor.col = (colnr_T)(p - line); } need_cap = check_need_cap(curwin->w_cursor.lnum, curwin->w_cursor.col); line = vim_strsave(ml_get_curline()); if (line == NULL) goto skip; if (sps_limit > (int)Rows - 2) limit = (int)Rows - 2; else limit = sps_limit; spell_find_suggest(line + curwin->w_cursor.col, badlen, &sug, limit, TRUE, need_cap, TRUE); if (sug.su_ga.ga_len == 0) msg(_(""Sorry, no suggestions"")); else if (count > 0) { if (count > sug.su_ga.ga_len) smsg(_(""Sorry, only %ld suggestions""), (long)sug.su_ga.ga_len); } else { #ifdef FEAT_RIGHTLEFT cmdmsg_rl = curwin->w_p_rl; if (cmdmsg_rl) msg_col = Columns - 1; #endif msg_start(); msg_row = Rows - 1;lines_left = Rows;vim_snprintf((char *)IObuff, IOSIZE, _(""Change \""%.*s\"" to:""), sug.su_badlen, sug.su_badptr); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl && STRNCMP(IObuff, ""Change"", 6) == 0) { vim_snprintf((char *)IObuff, IOSIZE, "":ot \""%.*s\"" egnahC"", sug.su_badlen, sug.su_badptr); } #endif msg_puts((char *)IObuff); msg_clr_eos(); msg_putchar('\n'); msg_scroll = TRUE; for (i = 0; i < sug.su_ga.ga_len; ++i) { stp = &SUG(sug.su_ga, i); vim_strncpy(wcopy, stp->st_word, MAXWLEN); if (sug.su_badlen > stp->st_orglen) vim_strncpy(wcopy + stp->st_wordlen, sug.su_badptr + stp->st_orglen, sug.su_badlen - stp->st_orglen); vim_snprintf((char *)IObuff, IOSIZE, ""%2d"", i + 1); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl) rl_mirror(IObuff); #endif msg_puts((char *)IObuff); vim_snprintf((char *)IObuff, IOSIZE, "" \""%s\"""", wcopy); msg_puts((char *)IObuff); if (sug.su_badlen < stp->st_orglen) { vim_snprintf((char *)IObuff, IOSIZE, _("" < \""%.*s\""""), stp->st_orglen, sug.su_badptr); msg_puts((char *)IObuff); } if (p_verbose > 0) { if (sps_flags & (SPS_DOUBLE | SPS_BEST)) vim_snprintf((char *)IObuff, IOSIZE, "" (%s%d - %d)"", stp->st_salscore ? ""s "" : """", stp->st_score, stp->st_altscore); else vim_snprintf((char *)IObuff, IOSIZE, "" (%d)"", stp->st_score); #ifdef FEAT_RIGHTLEFT if (cmdmsg_rl) rl_mirror(IObuff + 1); #endif msg_advance(30); msg_puts((char *)IObuff); } msg_putchar('\n'); } #ifdef FEAT_RIGHTLEFT cmdmsg_rl = FALSE; msg_col = 0; #endif selected = prompt_for_number(&mouse_used); if (mouse_used) selected -= lines_left; lines_left = Rows;msg_scroll = msg_scroll_save; } if (selected > 0 && selected <= sug.su_ga.ga_len && u_save_cursor() == OK) { VIM_CLEAR(repl_from); VIM_CLEAR(repl_to); stp = &SUG(sug.su_ga, selected - 1); if (sug.su_badlen > stp->st_orglen) { repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen); vim_snprintf((char *)IObuff, IOSIZE, ""%s%.*s"", stp->st_word, sug.su_badlen - stp->st_orglen, sug.su_badptr + stp->st_orglen); repl_to = vim_strsave(IObuff); } else { repl_from = vim_strnsave(sug.su_badptr, stp->st_orglen); repl_to = vim_strsave(stp->st_word); } p = alloc(STRLEN(line) - stp->st_orglen + stp->st_wordlen + 1); if (p != NULL) { c = (int)(sug.su_badptr - line); mch_memmove(p, line, c); STRCPY(p + c, stp->st_word); STRCAT(p, sug.su_badptr + stp->st_orglen); ResetRedobuff(); AppendToRedobuff((char_u *)""ciw""); AppendToRedobuffLit(p + c, stp->st_wordlen + sug.su_badlen - stp->st_orglen); AppendCharToRedobuff(ESC); ml_replace(curwin->w_cursor.lnum, p, FALSE); curwin->w_cursor.col = c; changed_bytes(curwin->w_cursor.lnum, c); } } else curwin->w_cursor = prev_cursor; spell_find_cleanup(&sug); skip: vim_free(line); curwin->w_p_spell = wo_spell_save; }"
"static inline size_t flow_keys_hash_length(const struct flow_keys *flow) { size_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs); BUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32)); BUILD_BUG_ON(offsetof(typeof(*flow), addrs) != sizeof(*flow) - sizeof(flow->addrs)); switch (flow->control.addr_type) { case FLOW_DISSECTOR_KEY_IPV4_ADDRS: diff -= sizeof(flow->addrs.v4addrs); break; case FLOW_DISSECTOR_KEY_IPV6_ADDRS: diff -= sizeof(flow->addrs.v6addrs); break; case FLOW_DISSECTOR_KEY_TIPC: diff -= sizeof(flow->addrs.tipckey); break; } return (sizeof(*flow) - diff) / sizeof(u32); }"
"uchar * htmlGetText(tree_t *t) { uchar*s,*s2,*tdata = NULL,*talloc = NULL;  size_tslen,tlen; slen = 0; s    = NULL; while (t != NULL) { if (t->child) tdata = talloc = htmlGetText(t->child); else tdata = t->data; if (tdata != NULL) { tlen = strlen((char *)tdata); if (s) s2 = (uchar *)realloc(s, 1 + slen + tlen); else s2 = (uchar *)malloc(1 + tlen); if (!s2) break; s = s2; memcpy((char *)s + slen, (char *)tdata, tlen); slen += tlen; if (talloc) { free(talloc); talloc = NULL; } } t = t->next; } if (slen) s[slen] = '\0'; if (talloc) free(talloc); return (s); }"
"static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen) { struct sock *sk = sock->sk; struct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk); struct nfc_llcp_local *local; struct nfc_dev *dev; struct sockaddr_nfc_llcp llcp_addr; int len, ret = 0; if (!addr || alen < offsetofend(struct sockaddr, sa_family) || addr->sa_family != AF_NFC) return -EINVAL; pr_debug(""sk %p addr %p family %d\n"", sk, addr, addr->sa_family); memset(&llcp_addr, 0, sizeof(llcp_addr)); len = min_t(unsigned int, sizeof(llcp_addr), alen); memcpy(&llcp_addr, addr, len); if (llcp_addr.dsap != 0) return -EINVAL; lock_sock(sk); if (sk->sk_state != LLCP_CLOSED) { ret = -EBADFD; goto error; } dev = nfc_get_device(llcp_addr.dev_idx); if (dev == NULL) { ret = -ENODEV; goto error; } local = nfc_llcp_find_local(dev); if (local == NULL) { ret = -ENODEV; goto put_dev; } llcp_sock->dev = dev; llcp_sock->local = nfc_llcp_local_get(local); llcp_sock->nfc_protocol = llcp_addr.nfc_protocol; llcp_sock->service_name_len = min_t(unsigned int, llcp_addr.service_name_len, NFC_LLCP_MAX_SERVICE_NAME); llcp_sock->service_name = kmemdup(llcp_addr.service_name, llcp_sock->service_name_len, GFP_KERNEL); if (!llcp_sock->service_name) { nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; ret = -ENOMEM; goto put_dev; } llcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock); if (llcp_sock->ssap == LLCP_SAP_MAX) { nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; kfree(llcp_sock->service_name); llcp_sock->service_name = NULL; ret = -EADDRINUSE; goto put_dev; } llcp_sock->reserved_ssap = llcp_sock->ssap; nfc_llcp_sock_link(&local->sockets, sk); pr_debug(""Socket bound to SAP %d\n"", llcp_sock->ssap); sk->sk_state = LLCP_BOUND; put_dev: nfc_put_device(dev); error: release_sock(sk); return ret; }"
"static int dmg_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVDMGState *s = bs->opaque; uint64_t info_begin, info_end, last_in_offset, last_out_offset; uint32_t count, tmp; uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i; int64_t offset; int ret; bs->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = bdrv_getlength(bs->file); if (offset < 0) { ret = offset; goto fail; } offset -= 0x1d8; ret = read_uint64(bs, offset, &info_begin); if (ret < 0) { goto fail; } else if (info_begin == 0) { ret = -EINVAL; goto fail; } ret = read_uint32(bs, info_begin, &tmp); if (ret < 0) { goto fail; } else if (tmp != 0x100) { ret = -EINVAL; goto fail; } ret = read_uint32(bs, info_begin + 4, &count); if (ret < 0) { goto fail; } else if (count == 0) { ret = -EINVAL; goto fail; } info_end = info_begin + count; offset = info_begin + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t type; ret = read_uint32(bs, offset, &count); if (ret < 0) { goto fail; } else if (count == 0) { ret = -EINVAL; goto fail; } offset += 4; ret = read_uint32(bs, offset, &type); if (ret < 0) { goto fail; } if (type == 0x6d697368 && count >= 244) { size_t new_size; uint32_t chunk_count; offset += 4; offset += 200; chunk_count = (count - 204) / 40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = g_realloc(s->types, new_size / 2); s->offsets = g_realloc(s->offsets, new_size); s->lengths = g_realloc(s->lengths, new_size); s->sectors = g_realloc(s->sectors, new_size); s->sectorcounts = g_realloc(s->sectorcounts, new_size); for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) { ret = read_uint32(bs, offset, &s->types[i]); if (ret < 0) { goto fail; } offset += 4; if (s->types[i] != 0x80000005 && s->types[i] != 1 && s->types[i] != 2) { if (s->types[i] == 0xffffffff && i > 0) { last_in_offset = s->offsets[i - 1] + s->lengths[i - 1]; last_out_offset = s->sectors[i - 1] + s->sectorcounts[i - 1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; ret = read_uint64(bs, offset, &s->sectors[i]); if (ret < 0) { goto fail; } s->sectors[i] += last_out_offset; offset += 8; ret = read_uint64(bs, offset, &s->sectorcounts[i]); if (ret < 0) { goto fail; } offset += 8; ret = read_uint64(bs, offset, &s->offsets[i]); if (ret < 0) { goto fail; } s->offsets[i] += last_in_offset; offset += 8; ret = read_uint64(bs, offset, &s->lengths[i]); if (ret < 0) { goto fail; } offset += 8; if (s->lengths[i] > max_compressed_size) { max_compressed_size = s->lengths[i]; } if (s->sectorcounts[i] > max_sectors_per_chunk) { max_sectors_per_chunk = s->sectorcounts[i]; } } s->n_chunks += chunk_count; } } s->compressed_chunk = g_malloc(max_compressed_size + 1); s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk); if (inflateInit(&s->zstream) != Z_OK) { ret = -EINVAL; goto fail; } s->current_chunk = s->n_chunks; qemu_co_mutex_init(&s->lock); return 0; fail: g_free(s->types); g_free(s->offsets); g_free(s->lengths); g_free(s->sectors); g_free(s->sectorcounts); g_free(s->compressed_chunk); g_free(s->uncompressed_chunk); return ret; }"
"static void extract_archive_thread (GSimpleAsyncResult *result, GObject            *object, GCancellable       *cancellable) { ExtractData          *extract_data; LoadData             *load_data; GHashTable           *checked_folders; GHashTable           *created_files; GHashTable           *folders_created_during_extraction; struct archive       *a; struct archive_entry *entry; int                   r; extract_data = g_simple_async_result_get_op_res_gpointer (result); load_data = LOAD_DATA (extract_data); r = create_read_object (load_data, &a); if (r != ARCHIVE_OK) { archive_read_free(a); return; } checked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL); created_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref); folders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL); fr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract); while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) { const char    *pathname; char          *fullpath; const char    *relative_path; GFile         *file; GFile         *parent; GOutputStream *ostream; const void    *buffer; size_t         buffer_size; int64_t        target_offset, actual_offset; GError        *local_error = NULL; __LA_MODE_T    filetype; if (g_cancellable_is_cancelled (cancellable)) break; pathname = archive_entry_pathname (entry); if (! extract_data_get_extraction_requested (extract_data, pathname)) { archive_read_data_skip (a); continue; } fullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (""/"", pathname, NULL); relative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths); if (relative_path == NULL) { archive_read_data_skip (a); continue; } file = g_file_get_child (extract_data->destination, relative_path); if ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL) && (extract_data->skip_older || ! extract_data->overwrite)) { GFileInfo *info; info = g_file_query_info (file, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME "","" G_FILE_ATTRIBUTE_TIME_MODIFIED, G_FILE_QUERY_INFO_NONE, cancellable, &local_error); if (info != NULL) { gboolean skip = FALSE; if (! extract_data->overwrite) { skip = TRUE; } else if (extract_data->skip_older) { GTimeVal modification_time; g_file_info_get_modification_time (info, &modification_time); if (archive_entry_mtime (entry) < modification_time.tv_sec) skip = TRUE; } g_object_unref (info); if (skip) { g_object_unref (file); archive_read_data_skip (a); fr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0); if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { r = ARCHIVE_EOF; break; } continue; } } else { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) { load_data->error = local_error; g_object_unref (info); break; } g_clear_error (&local_error); } } fr_archive_progress_inc_completed_files (load_data->archive, 1); parent = g_file_get_parent (file); if ((parent != NULL) && (g_hash_table_lookup (checked_folders, parent) == NULL) && ! g_file_query_exists (parent, cancellable)) { if (! _g_file_make_directory_with_parents (parent, folders_created_during_extraction, cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = local_error; else g_clear_error (&local_error); } if (load_data->error == NULL) { GFile *grandparent; grandparent = g_object_ref (parent); while (grandparent != NULL) { if (g_hash_table_lookup (checked_folders, grandparent) == NULL) g_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1)); grandparent = g_file_get_parent (grandparent); } } } g_object_unref (parent); filetype = archive_entry_filetype (entry); if (load_data->error == NULL) { const char  *linkname; linkname = archive_entry_hardlink (entry); if (linkname != NULL) { char        *link_fullpath; const char  *relative_path; GFile       *link_file; char        *oldname; char        *newname; int          r; link_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (""/"", linkname, NULL); relative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths); if (relative_path == NULL) { g_free (link_fullpath); archive_read_data_skip (a); continue; } link_file = g_file_get_child (extract_data->destination, relative_path); oldname = g_file_get_path (link_file); newname = g_file_get_path (file); if ((oldname != NULL) && (newname != NULL)) r = link (oldname, newname); else r = -1; if (r == 0) { __LA_INT64_T filesize; if (archive_entry_size_is_set (entry)) filesize = archive_entry_size (entry); else filesize = -1; if (filesize > 0) filetype = AE_IFREG;  } else { char *uri; char *msg; uri = g_file_get_uri (file); msg = g_strdup_printf (""Could not create the hard link %s"", uri); load_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg); g_free (msg); g_free (uri); } g_free (newname); g_free (oldname); g_object_unref (link_file); g_free (link_fullpath); } } if (load_data->error == NULL) { switch (filetype) { case AE_IFDIR: if (! g_file_make_directory (file, cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = g_error_copy (local_error); g_clear_error (&local_error); } if (load_data->error == NULL) g_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data)); archive_read_data_skip (a); break; case AE_IFREG: ostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error); if (ostream == NULL) break; actual_offset = 0; while ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) { gsize bytes_written; if (target_offset > actual_offset) { if (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error)) break; fr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset); actual_offset = target_offset; } if (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error)) break; actual_offset += bytes_written; fr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written); } if ((r == ARCHIVE_EOF) && (target_offset > actual_offset)) _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error); _g_object_unref (ostream); if (r != ARCHIVE_EOF) load_data->error = _g_error_new_from_archive_error (archive_error_string (a)); else g_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data)); break; case AE_IFLNK: if (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) { if (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) load_data->error = g_error_copy (local_error); g_clear_error (&local_error); } archive_read_data_skip (a); break; default: archive_read_data_skip (a); break; } } g_object_unref (file); g_free (fullpath); if (load_data->error != NULL) break; if ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) { r = ARCHIVE_EOF; break; } } if (load_data->error == NULL) restore_original_file_attributes (created_files, cancellable); if ((load_data->error == NULL) && (r != ARCHIVE_EOF)) load_data->error = _g_error_new_from_archive_error (archive_error_string (a)); if (load_data->error == NULL) g_cancellable_set_error_if_cancelled (cancellable, &load_data->error); if (load_data->error != NULL) g_simple_async_result_set_from_error (result, load_data->error); g_hash_table_unref (folders_created_during_extraction); g_hash_table_unref (created_files); g_hash_table_unref (checked_folders); archive_read_free (a); extract_data_free (extract_data); }"
"static int get_name(int counter, unsigned char *pkt, unsigned char *start, unsigned char *max, unsigned char *output, int output_max, int *output_len, unsigned char **end, char *name, int *name_len) { unsigned char *p; if (counter > 10) return -EINVAL; p = start; while (*p) { if ((*p & NS_CMPRSFLGS) == NS_CMPRSFLGS) { uint16_t offset = (*p & 0x3F) * 256 + *(p + 1); if (offset >= max - pkt) return -ENOBUFS; if (!*end) *end = p + 2; return get_name(counter + 1, pkt, pkt + offset, max, output, output_max, output_len, end, name, name_len); } else { unsigned label_len = *p; if (pkt + label_len > max) return -ENOBUFS; if (*output_len > output_max) return -ENOBUFS; name[(*name_len)++] = label_len; memcpy(name + *name_len, p + 1,label_len + 1); *name_len += label_len; output[0] = NS_CMPRSFLGS; output[1] = 0x0C; *output_len = 2; p += label_len + 1; if (!*end) *end = p; if (p >= max) return -ENOBUFS; } } return 0; }"
"static int gs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors, int *pexit_code, ref * perror_object) { ref *epref = pref; ref doref; ref *perrordict; ref error_name; int code, ccode; ref saref; i_ctx_t *i_ctx_p = *pi_ctx_p; int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal; *pexit_code = 0; *gc_signal = 0; ialloc_reset_requested(idmemory); again: make_null(perror_object); o_stack.requested = e_stack.requested = d_stack.requested = 0; while (*gc_signal) {  gs_gc_root_t epref_root; *gc_signal = 0; gs_register_ref_root(imemory_system, &epref_root, (void **)&epref, ""gs_call_interp(epref)""); code = interp_reclaim(pi_ctx_p, -1); i_ctx_p = *pi_ctx_p; gs_unregister_root(imemory_system, &epref_root, ""gs_call_interp(epref)""); if (code < 0) return code; } code = interp(pi_ctx_p, epref, perror_object); i_ctx_p = *pi_ctx_p; if (!r_has_type(&i_ctx_p->error_object, t__invalid)) { *perror_object = i_ctx_p->error_object; make_t(&i_ctx_p->error_object, t__invalid); } *gc_signal = 0; set_gc_signal(i_ctx_p, 1); if (esp < esbot)             esp = esbot; switch (code) { case gs_error_Fatal: *pexit_code = 255; return code; case gs_error_Quit: *perror_object = osp[-1]; *pexit_code = code = osp->value.intval; osp -= 2; return (code == 0 ? gs_error_Quit : code < 0 && code > -100 ? code : gs_error_Fatal); case gs_error_InterpreterExit: return 0; case gs_error_ExecStackUnderflow: ref_stack_pop_block(&e_stack); doref = *perror_object; epref = &doref; goto again; case gs_error_VMreclaim: (void)interp_reclaim(pi_ctx_p, (osp->value.intval == 2 ? avm_global : avm_local)); i_ctx_p = *pi_ctx_p; make_oper(&doref, 0, zpop); epref = &doref; goto again; case gs_error_NeedInput: case gs_error_interrupt: return code; } if (osp < osbot - 1) osp = osbot - 1; switch (code) { case gs_error_dictstackoverflow: if (osp >= ostop) { if ((ccode = ref_stack_extend(&o_stack, 1)) < 0) return ccode; } ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref); if (ccode < 0) return ccode; ref_stack_pop_to(&d_stack, min_dstack_size); dict_set_top(); *++osp = saref; break; case gs_error_dictstackunderflow: if (ref_stack_pop_block(&d_stack) >= 0) { dict_set_top(); doref = *perror_object; epref = &doref; goto again; } break; case gs_error_execstackoverflow: if (osp >= ostop) { if ((ccode = ref_stack_extend(&o_stack, 1)) < 0) return ccode; } ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref); if (ccode < 0) return ccode; { uint count = ref_stack_count(&e_stack); uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM; if (count > limit) { int skip = count - limit; int i; for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) { const ref *ep = ref_stack_index(&e_stack, i); if (r_has_type_attrs(ep, t_null, a_executable)) { skip = i + 1; break; } } pop_estack(i_ctx_p, skip); } } *++osp = saref; break; case gs_error_stackoverflow: if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {    doref = *perror_object; if (r_is_proc(&doref)) { *++osp = doref; make_null_proc(&doref); } epref = &doref; goto again; } ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref); if (ccode < 0) return ccode; ref_stack_clear(&o_stack); *++osp = saref; break; case gs_error_stackunderflow: if (ref_stack_pop_block(&o_stack) >= 0) { doref = *perror_object; epref = &doref; goto again; } break; } if (user_errors < 0) return code; if (gs_errorname(i_ctx_p, code, &error_name) < 0) return code;             if (dict_find_string(systemdict, ""errordict"", &perrordict) <= 0 || (dict_find(perrordict, &error_name, &epref) <= 0 && (dict_find_string(systemdict, ""gserrordict"", &perrordict) <= 0 || dict_find(perrordict, &error_name, &epref) <= 0)) ) return code;             doref = *epref; epref = &doref; if (!GS_ERROR_IS_INTERRUPT(code)) { osp++; if (osp >= ostop) { *pexit_code = gs_error_Fatal; return_error(gs_error_Fatal); } *osp = *perror_object; errorexec_find(i_ctx_p, osp); } goto again; }"
"int ipmi_si_port_setup(struct si_sm_io *io) { unsigned int addr = io->addr_data; int          idx; if (!addr) return -ENODEV; io->io_cleanup = port_cleanup; switch (io->regsize) { case 1: io->inputb = port_inb; io->outputb = port_outb; break; case 2: io->inputb = port_inw; io->outputb = port_outw; break; case 4: io->inputb = port_inl; io->outputb = port_outl; break; default: dev_warn(io->dev, ""Invalid register size: %d\n"", io->regsize); return -EINVAL; } for (idx = 0; idx < io->io_size; idx++) { if (request_region(addr + idx * io->regspacing, io->regsize, DEVICE_NAME) == NULL) { while (idx--) release_region(addr + idx * io->regspacing, io->regsize); return -EIO; } } return 0; }"
"json_t* find_jws(struct tang_keys_info* tki, const char* thp) { if (!tki) { return NULL; } if (thp == NULL) { json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign); if (!jws) { return NULL; } return json_incref(jws); } return find_by_thp(tki, thp); }"
"static int pagemap_open(struct inode *inode, struct file *file) { pr_warn_once(""Bits 55-60 of /proc/PID/pagemap entries are about "" ""to stop being page-shift some time soon. See the "" ""linux/Documentation/vm/pagemap.txt for details.\n""); return 0; }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli( const void *buf, pj_size_t length) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; PJ_ASSERT_RETURN(buf, PJ_EINVAL); if (length < 12) return PJ_ETOOSMALL; if (hdr->pt != RTCP_PSFB || hdr->count != 1) return PJ_ENOTFOUND; return PJ_SUCCESS; }"
"int nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd3_writeargs *args) { unsigned int len, v, hdr, dlen; u32 max_blocksize = svc_max_payload(rqstp); struct kvec *head = rqstp->rq_arg.head; struct kvec *tail = rqstp->rq_arg.tail; p = decode_fh(p, &args->fh); if (!p) return 0; p = xdr_decode_hyper(p, &args->offset); args->count = ntohl(*p++); args->stable = ntohl(*p++); len = args->len = ntohl(*p++); if (args->count != args->len) return 0; hdr = (void*)p - head->iov_base; dlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr; if (dlen < XDR_QUADLEN(len)*4) return 0; if (args->count > max_blocksize) { args->count = max_blocksize; len = args->len = max_blocksize; } rqstp->rq_vec[0].iov_base = (void*)p; rqstp->rq_vec[0].iov_len = head->iov_len - hdr; v = 0; while (len > rqstp->rq_vec[v].iov_len) { len -= rqstp->rq_vec[v].iov_len; v++; rqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]); rqstp->rq_vec[v].iov_len = PAGE_SIZE; } rqstp->rq_vec[v].iov_len = len; args->vlen = v + 1; return 1; }"
"XModifierKeymap * XGetDeviceModifierMapping( register Display*dpy, XDevice*dev) { unsigned long nbytes; XModifierKeymap *res; xGetDeviceModifierMappingReq *req; xGetDeviceModifierMappingReply rep; XExtDisplayInfo *info = XInput_find_display(dpy); LockDisplay(dpy); if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1) return NULL; GetReq(GetDeviceModifierMapping, req); req->reqType = info->codes->major_opcode; req->ReqType = X_GetDeviceModifierMapping; req->deviceid = dev->device_id; if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) { UnlockDisplay(dpy); SyncHandle(); return (XModifierKeymap *) NULL; } nbytes = (unsigned long)rep.length << 2; res = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap)); if (res) { res->modifiermap = (KeyCode *) Xmalloc(nbytes); if (res->modifiermap) _XReadPad(dpy, (char *)res->modifiermap, nbytes); else _XEatDataWords(dpy, rep.length); res->max_keypermod = rep.numKeyPerModifier; } UnlockDisplay(dpy); SyncHandle(); return (res); }"
"void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength) { int i; if(isCodingInverted){ for (i = 0; i < bufferLength; ++i) { xoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])]; } }else{ for (i = 0; i < bufferLength; ++i) { xoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i]; } } }"
"int URIParser::parse(const char *str, ParsedURI& uri) { uri.state = URI_STATE_INVALID; int start_idx[URI_PART_ELEMENTS] = {0}; int end_idx[URI_PART_ELEMENTS] = {0}; int pre_state = URI_SCHEME;; int i; bool in_ipv6 = false; for (i = 0; str[i]; i++) { if (str[i] == ':') { end_idx[URI_SCHEME] = i++; break; } } if (end_idx[URI_SCHEME] == 0) return -1; if (str[i] == '/' && str[i + 1] == '/') { pre_state = URI_HOST; i += 2; if (str[i] == '[') in_ipv6= true; else start_idx[URI_USERINFO] = i; start_idx[URI_HOST] = i; } else { pre_state = URI_PATH; start_idx[URI_PATH] = i; } bool skip_path = false; if (start_idx[URI_PATH] == 0) { for (; ; i++) { switch (authority_map[(unsigned char)str[i]]) { case 0: continue; case URI_USERINFO: if (str[i + 1] == '[') in_ipv6 = true; end_idx[URI_USERINFO] = i; start_idx[URI_HOST] = i + 1; pre_state = URI_HOST; continue; case URI_HOST: if (str[i - 1] == ']') in_ipv6 = false; if (!in_ipv6) { end_idx[URI_HOST] = i; start_idx[URI_PORT] = i + 1; pre_state = URI_PORT; } continue; case URI_QUERY: end_idx[pre_state] = i; start_idx[URI_QUERY] = i + 1; pre_state = URI_QUERY; skip_path = true; continue; case URI_FRAGMENT: end_idx[pre_state] = i; start_idx[URI_FRAGMENT] = i + 1; end_idx[URI_FRAGMENT] = i + strlen(str + i); pre_state = URI_PART_ELEMENTS; skip_path = true; break; case URI_PATH: if (skip_path) continue; start_idx[URI_PATH] = i; break; case URI_PART_ELEMENTS: skip_path = true; break; } break; } } if (pre_state != URI_PART_ELEMENTS) end_idx[pre_state] = i; if (!skip_path) { pre_state = URI_PATH; for (; str[i]; i++) { if (str[i] == '?') { end_idx[URI_PATH] = i; start_idx[URI_QUERY] = i + 1; pre_state = URI_QUERY; while (str[i + 1]) { if (str[++i] == '#') break; } } if (str[i] == '#') { end_idx[pre_state] = i; start_idx[URI_FRAGMENT] = i + 1; pre_state = URI_FRAGMENT; break; } } end_idx[pre_state] = i + strlen(str + i); } for (int i = 0; i < URI_QUERY; i++) { for (int j = start_idx[i]; j < end_idx[i]; j++) { if (!valid_char[i][(unsigned char)str[j]]) return -1;} } char **dst[URI_PART_ELEMENTS] = {&uri.scheme, &uri.userinfo, &uri.host, &uri.port, &uri.query, &uri.fragment, &uri.path}; for (int i = 0; i < URI_PART_ELEMENTS; i++) { if (end_idx[i] > start_idx[i]) { size_t len = end_idx[i] - start_idx[i]; *dst[i] = (char *)realloc(*dst[i], len + 1); if (*dst[i] == NULL) { uri.state = URI_STATE_ERROR; uri.error = errno; return -1; } if (i == URI_HOST && str[start_idx[i]] == '[') { len -= 2; memcpy(*dst[i], str + start_idx[i] + 1, len); } else memcpy(*dst[i], str + start_idx[i], len); (*dst[i])[len] = '\0'; } else { free(*dst[i]); *dst[i] = NULL; } } uri.state = URI_STATE_SUCCESS; return 0; }"
"ACPI_STATUS AcpiPsCompleteFinalOp ( ACPI_WALK_STATE         *WalkState, ACPI_PARSE_OBJECT       *Op, ACPI_STATUS             Status) { ACPI_STATUS             Status2; ACPI_FUNCTION_TRACE_PTR (PsCompleteFinalOp, WalkState); ACPI_DEBUG_PRINT ((ACPI_DB_PARSE, ""AML package complete at Op %p\n"", Op)); do { if (Op) { if (WalkState->AscendingCallback != NULL) { WalkState->Op = Op; WalkState->OpInfo = AcpiPsGetOpcodeInfo (Op->Common.AmlOpcode); WalkState->Opcode = Op->Common.AmlOpcode; Status = WalkState->AscendingCallback (WalkState); Status = AcpiPsNextParseState (WalkState, Op, Status); if (Status == AE_CTRL_PENDING) { Status = AcpiPsCompleteOp (WalkState, &Op, AE_OK); if (ACPI_FAILURE (Status)) { return_ACPI_STATUS (Status); } } if (Status == AE_CTRL_TERMINATE) { Status = AE_OK; do { if (Op) { Status2 = AcpiPsCompleteThisOp (WalkState, Op); if (ACPI_FAILURE (Status2)) { return_ACPI_STATUS (Status2); } } AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes, &WalkState->ArgCount); } while (Op); return_ACPI_STATUS (Status); } else if (ACPI_FAILURE (Status)) { (void) AcpiPsCompleteThisOp (WalkState, Op); return_ACPI_STATUS (Status); } } Status2 = AcpiPsCompleteThisOp (WalkState, Op); if (ACPI_FAILURE (Status2)) { return_ACPI_STATUS (Status2); } } AcpiPsPopScope (&(WalkState->ParserState), &Op, &WalkState->ArgTypes, &WalkState->ArgCount); } while (Op); return_ACPI_STATUS (Status); }"
"static gboolean listener_event(GIOChannel *channel, GIOCondition condition, gpointer user_data) { GDHCPClient *dhcp_client = user_data; struct sockaddr_in dst_addr = { 0 }; struct dhcp_packet packet; struct dhcpv6_packet *packet6 = NULL; uint8_t *message_type = NULL, *client_id = NULL, *option, *server_id = NULL; uint16_t option_len = 0, status = 0; uint32_t xid = 0; gpointer pkt; unsigned char buf[MAX_DHCPV6_PKT_SIZE]; uint16_t pkt_len = 0; int count; int re; if (condition & (G_IO_NVAL | G_IO_ERR | G_IO_HUP)) { dhcp_client->listener_watch = 0; return FALSE; } if (dhcp_client->listen_mode == L_NONE) return FALSE; pkt = &packet; dhcp_client->status_code = 0; if (dhcp_client->listen_mode == L2) { re = dhcp_recv_l2_packet(&packet, dhcp_client->listener_sockfd, &dst_addr); xid = packet.xid; } else if (dhcp_client->listen_mode == L3) { if (dhcp_client->type == G_DHCP_IPV6) { re = dhcpv6_recv_l3_packet(&packet6, buf, sizeof(buf), dhcp_client->listener_sockfd); if (re < 0) return TRUE; pkt_len = re; pkt = packet6; xid = packet6->transaction_id[0] << 16 | packet6->transaction_id[1] << 8 | packet6->transaction_id[2]; } else { re = dhcp_recv_l3_packet(&packet, dhcp_client->listener_sockfd); xid = packet.xid; } } else if (dhcp_client->listen_mode == L_ARP) { ipv4ll_recv_arp_packet(dhcp_client); return TRUE; } else re = -EIO; if (re < 0) return TRUE; if (!check_package_owner(dhcp_client, pkt)) return TRUE; if (dhcp_client->type == G_DHCP_IPV6) { if (!packet6) return TRUE; count = 0; client_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_CLIENTID, &option_len,&count); if (!client_id || count == 0 || option_len == 0 || memcmp(dhcp_client->duid, client_id, dhcp_client->duid_len) != 0) { debug(dhcp_client, ""client duid error, discarding msg %p/%d/%d"", client_id, option_len, count); return TRUE; } option = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_STATUS_CODE, &option_len, NULL); if (option != 0 && option_len > 0) { status = option[0]<<8 | option[1]; if (status != 0) { debug(dhcp_client, ""error code %d"", status); if (option_len > 2) { gchar *txt = g_strndup( (gchar *)&option[2], option_len - 2); debug(dhcp_client, ""error text: %s"", txt); g_free(txt); } } dhcp_client->status_code = status; } } else { message_type = dhcp_get_option(&packet, DHCP_MESSAGE_TYPE); if (!message_type) return TRUE; } debug(dhcp_client, ""received DHCP packet xid 0x%04x "" ""(current state %d)"", ntohl(xid), dhcp_client->state); switch (dhcp_client->state) { case INIT_SELECTING: if (*message_type != DHCPOFFER) return TRUE; remove_timeouts(dhcp_client); dhcp_client->timeout = 0; dhcp_client->retry_times = 0; option = dhcp_get_option(&packet, DHCP_SERVER_ID); dhcp_client->server_ip = get_be32(option); dhcp_client->requested_ip = ntohl(packet.yiaddr); dhcp_client->state = REQUESTING; dhcp_client->request_bcast = dst_addr.sin_addr.s_addr == INADDR_BROADCAST && g_hash_table_contains(dhcp_client->secs_bcast_hash, GINT_TO_POINTER(packet.secs)); debug(dhcp_client, ""init ip %s secs %hu -> broadcast flag %s"", inet_ntoa(dst_addr.sin_addr), packet.secs, dhcp_client->request_bcast ? ""on"" : ""off""); start_request(dhcp_client); return TRUE; case REBOOTING: if (dst_addr.sin_addr.s_addr == INADDR_BROADCAST) dhcp_client->request_bcast = true; else dhcp_client->request_bcast = false; debug(dhcp_client, ""ip %s -> %sadding broadcast flag"", inet_ntoa(dst_addr.sin_addr), dhcp_client->request_bcast ? """" : ""not ""); case REQUESTING: case RENEWING: case REBINDING: if (*message_type == DHCPACK) { dhcp_client->retry_times = 0; remove_timeouts(dhcp_client); dhcp_client->lease_seconds = get_lease(&packet); get_request(dhcp_client, &packet); switch_listening_mode(dhcp_client, L_NONE); g_free(dhcp_client->assigned_ip); dhcp_client->assigned_ip = get_ip(packet.yiaddr); if (dhcp_client->state == REBOOTING) { option = dhcp_get_option(&packet, DHCP_SERVER_ID); dhcp_client->server_ip = get_be32(option); } if (dhcp_client->lease_available_cb) dhcp_client->lease_available_cb(dhcp_client, dhcp_client->lease_available_data); start_bound(dhcp_client); } else if (*message_type == DHCPNAK) { dhcp_client->retry_times = 0; remove_timeouts(dhcp_client); dhcp_client->timeout = g_timeout_add_seconds_full( G_PRIORITY_HIGH, 3, restart_dhcp_timeout, dhcp_client, NULL); } break; case SOLICITATION: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; if (packet6->message != DHCPV6_REPLY && packet6->message != DHCPV6_ADVERTISE) return TRUE; count = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len,&count); if (!server_id || count != 1 || option_len == 0) { debug(dhcp_client, ""server duid error, discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; if (packet6->message == DHCPV6_REPLY) { uint8_t *rapid_commit; count = 0; option_len = 0; rapid_commit = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_RAPID_COMMIT, &option_len, &count); if (!rapid_commit || option_len != 0 || count != 1) return TRUE; } switch_listening_mode(dhcp_client, L_NONE); if (dhcp_client->status_code == 0) get_dhcpv6_request(dhcp_client, packet6, pkt_len, &dhcp_client->status_code); if (packet6->message == DHCPV6_ADVERTISE) { if (dhcp_client->advertise_cb) dhcp_client->advertise_cb(dhcp_client, dhcp_client->advertise_data); return TRUE; } if (dhcp_client->solicitation_cb) { dhcp_client->solicitation_cb(dhcp_client, dhcp_client->solicitation_data); return TRUE; } break; case REBIND: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len,&count); if (!dhcp_client->server_duid && server_id && count == 1) { dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; } case INFORMATION_REQ: case REQUEST: case RENEW: case RELEASE: case CONFIRM: case DECLINE: if (dhcp_client->type != G_DHCP_IPV6) return TRUE; if (packet6->message != DHCPV6_REPLY) return TRUE; count = 0; option_len = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len, &count); if (!server_id || count != 1 || option_len == 0 || (dhcp_client->server_duid_len > 0 && memcmp(dhcp_client->server_duid, server_id, dhcp_client->server_duid_len) != 0)) { debug(dhcp_client, ""server duid error, discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } switch_listening_mode(dhcp_client, L_NONE); get_dhcpv6_request(dhcp_client, packet6, pkt_len, &dhcp_client->status_code); if (dhcp_client->information_req_cb) { dhcp_client->information_req_cb(dhcp_client, dhcp_client->information_req_data); return TRUE; } if (dhcp_client->request_cb) { dhcp_client->request_cb(dhcp_client, dhcp_client->request_data); return TRUE; } if (dhcp_client->renew_cb) { dhcp_client->renew_cb(dhcp_client, dhcp_client->renew_data); return TRUE; } if (dhcp_client->rebind_cb) { dhcp_client->rebind_cb(dhcp_client, dhcp_client->rebind_data); return TRUE; } if (dhcp_client->release_cb) { dhcp_client->release_cb(dhcp_client, dhcp_client->release_data); return TRUE; } if (dhcp_client->decline_cb) { dhcp_client->decline_cb(dhcp_client, dhcp_client->decline_data); return TRUE; } if (dhcp_client->confirm_cb) { count = 0; server_id = dhcpv6_get_option(packet6, pkt_len, G_DHCPV6_SERVERID, &option_len, &count); if (!server_id || count != 1 || option_len == 0) { debug(dhcp_client, ""confirm server duid error, "" ""discarding msg %p/%d/%d"", server_id, option_len, count); return TRUE; } dhcp_client->server_duid = g_try_malloc(option_len); if (!dhcp_client->server_duid) return TRUE; memcpy(dhcp_client->server_duid, server_id, option_len); dhcp_client->server_duid_len = option_len; dhcp_client->confirm_cb(dhcp_client, dhcp_client->confirm_data); return TRUE; } break; default: break; } debug(dhcp_client, ""processed DHCP packet (new state %d)"", dhcp_client->state); return TRUE; }"
"void init_xml_relax_ng() { VALUE nokogiri = rb_define_module(""Nokogiri""); VALUE xml = rb_define_module_under(nokogiri, ""XML""); VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema); cNokogiriXmlRelaxNG = klass; rb_define_singleton_method(klass, ""read_memory"", read_memory, 1); rb_define_singleton_method(klass, ""from_document"", from_document, 1); rb_define_private_method(klass, ""validate_document"", validate_document, 1); }"
"int main(int argc, char *argv[]) { char buff[1024]; int fd, nr, nw; if (argc < 2) { fprintf(stderr, ""usage: %s output-filename\n"" ""       %s |output-command\n"" ""       %s :host:port\n"", argv[0], argv[0], argv[0]); return 1; } fd = open_gen_fd(argv[1]); if (fd < 0) { perror(""open_gen_fd""); exit(EXIT_FAILURE); } while ((nr = read(0, buff, sizeof (buff))) != 0) { if (nr < 0) { if (errno == EINTR) continue; perror(""read""); exit(EXIT_FAILURE); } nw = write(fd, buff, nr); if (nw < 0) { perror(""write""); exit(EXIT_FAILURE); } } return 0; }"
bool PixelFormat::is888(void) const { if (!trueColour) return false; if (bpp != 32) return false; if (depth != 24) return false; if (redMax != 255) return false; if (greenMax != 255) return false; if (blueMax != 255) return false; return true; }
"static int ospf6_decode_v3(netdissect_options *ndo, register const struct ospf6hdr *op, register const u_char *dataend) { register const rtrid_t *ap; register const struct lsr6 *lsrp; register const struct lsa6_hdr *lshp; register const struct lsa6 *lsap; register int i; switch (op->ospf6_type) { case OSPF_TYPE_HELLO: { register const struct hello6 *hellop = (const struct hello6 *)((const uint8_t *)op + OSPF6HDR_LEN); ND_PRINT((ndo, ""\n\tOptions [%s]"", bittok2str(ospf6_option_values, ""none"", EXTRACT_32BITS(&hellop->hello_options)))); ND_TCHECK(hellop->hello_deadint); ND_PRINT((ndo, ""\n\t  Hello Timer %us, Dead Timer %us, Interface-ID %s, Priority %u"", EXTRACT_16BITS(&hellop->hello_helloint), EXTRACT_16BITS(&hellop->hello_deadint), ipaddr_string(ndo, &hellop->hello_ifid), hellop->hello_priority)); ND_TCHECK(hellop->hello_dr); if (EXTRACT_32BITS(&hellop->hello_dr) != 0) ND_PRINT((ndo, ""\n\t  Designated Router %s"", ipaddr_string(ndo, &hellop->hello_dr))); ND_TCHECK(hellop->hello_bdr); if (EXTRACT_32BITS(&hellop->hello_bdr) != 0) ND_PRINT((ndo, "", Backup Designated Router %s"", ipaddr_string(ndo, &hellop->hello_bdr))); if (ndo->ndo_vflag > 1) { ND_PRINT((ndo, ""\n\t  Neighbor List:"")); ap = hellop->hello_neighbor; while ((const u_char *)ap < dataend) { ND_TCHECK(*ap); ND_PRINT((ndo, ""\n\t    %s"", ipaddr_string(ndo, ap))); ++ap; } } break; } case OSPF_TYPE_DD: { register const struct dd6 *ddp = (const struct dd6 *)((const uint8_t *)op + OSPF6HDR_LEN); ND_TCHECK(ddp->db_options); ND_PRINT((ndo, ""\n\tOptions [%s]"", bittok2str(ospf6_option_values, ""none"", EXTRACT_32BITS(&ddp->db_options)))); ND_TCHECK(ddp->db_flags); ND_PRINT((ndo, "", DD Flags [%s]"", bittok2str(ospf6_dd_flag_values,""none"",ddp->db_flags))); ND_TCHECK(ddp->db_seq); ND_PRINT((ndo, "", MTU %u, DD-Sequence 0x%08x"", EXTRACT_16BITS(&ddp->db_mtu), EXTRACT_32BITS(&ddp->db_seq))); if (ndo->ndo_vflag > 1) { lshp = ddp->db_lshdr; while ((const u_char *)lshp < dataend) { if (ospf6_print_lshdr(ndo, lshp++, dataend)) goto trunc; } } break; } case OSPF_TYPE_LS_REQ: if (ndo->ndo_vflag > 1) { lsrp = (const struct lsr6 *)((const uint8_t *)op + OSPF6HDR_LEN); while ((const u_char *)lsrp < dataend) { ND_TCHECK(*lsrp); ND_PRINT((ndo, ""\n\t  Advertising Router %s"", ipaddr_string(ndo, &lsrp->ls_router))); ospf6_print_ls_type(ndo, EXTRACT_16BITS(&lsrp->ls_type), &lsrp->ls_stateid); ++lsrp; } } break; case OSPF_TYPE_LS_UPDATE: if (ndo->ndo_vflag > 1) { register const struct lsu6 *lsup = (const struct lsu6 *)((const uint8_t *)op + OSPF6HDR_LEN); ND_TCHECK(lsup->lsu_count); i = EXTRACT_32BITS(&lsup->lsu_count); lsap = lsup->lsu_lsa; while ((const u_char *)lsap < dataend && i--) { if (ospf6_print_lsa(ndo, lsap, dataend)) goto trunc; lsap = (const struct lsa6 *)((const u_char *)lsap + EXTRACT_16BITS(&lsap->ls_hdr.ls_length)); } } break; case OSPF_TYPE_LS_ACK: if (ndo->ndo_vflag > 1) { lshp = (const struct lsa6_hdr *)((const uint8_t *)op + OSPF6HDR_LEN); while ((const u_char *)lshp < dataend) { if (ospf6_print_lshdr(ndo, lshp++, dataend)) goto trunc; } } break; default: break; } return (0); trunc: return (1); }"
"mp_sint32 LoaderS3M::load(XMFileBase& f, XModule* module) { module->cleanUp(); TXMHeader*header = &module->header; TXMInstrument*instr  = module->instr; TXMSample*smp   = module->smp; TXMPattern*phead  = module->phead; if (!phead || !instr || !smp) return MP_OUT_OF_MEMORY; f.read(&header->name,1,28); header->whythis1a = f.readByte(); if (f.readByte() != 16)  return MP_LOADER_FAILED; f.readByte(); f.readByte();  header->ordnum = f.readWord();  mp_ubyte* orders = new mp_ubyte[header->ordnum]; if (orders == NULL)  return MP_OUT_OF_MEMORY; header->insnum = f.readWord(); header->patnum = f.readWord();  mp_sint32 flags = f.readWord();  mp_sint32 Cvt = f.readWord(); header->flags = XModule::MODULE_ST3NEWINSTRUMENT | XModule::MODULE_ST3DUALCOMMANDS; if (Cvt == 0x1300 || (flags & 64)) header->flags |= module->MODULE_OLDS3MVOLSLIDES; header->flags |= module->MODULE_ST3NOTECUT; f.readWord(); f.read(header->sig,1,4); header->mainvol = module->vol64to255(f.readByte());  header->tempo = f.readByte();  header->speed = f.readByte();  f.readByte();  f.readByte();  f.readByte(); f.readDword();f.readDword();f.readWord(); mp_ubyte channelSettings[32]; f.read(channelSettings,1,32); mp_sint32 numChannels = 0; for (numChannels = 0; numChannels < 32; numChannels++) if (channelSettings[numChannels] == 255) break; header->channum = numChannels;  f.read(orders,1,header->ordnum); mp_sint32 j = 0, i = 0; for (i = 0; i < header->ordnum; i++) { if (orders[i] == 255)  break; header->ord[j++] = orders[i]; } header->ordnum = j;  delete[] orders; mp_uword* insParaPtrs = new mp_uword[header->insnum]; if (insParaPtrs == NULL) return MP_OUT_OF_MEMORY; f.readWords(insParaPtrs,header->insnum); mp_uword* patParaPtrs = new mp_uword[header->patnum]; if (patParaPtrs == NULL) { delete[] insParaPtrs; return MP_OUT_OF_MEMORY; } f.readWords(patParaPtrs,header->patnum); mp_uint32* samplePtrs = new mp_uint32[header->insnum]; if (samplePtrs == NULL) { delete[] insParaPtrs; delete[] patParaPtrs; return MP_OUT_OF_MEMORY; } memset(samplePtrs,0,sizeof(mp_uint32)*header->insnum); mp_sint32 s = 0; for (i = 0; i < header->insnum; i++) { mp_uint32 insOffs = insParaPtrs[i]*16; if (insOffs) { f.seekWithBaseOffset(insOffs); mp_ubyte type = f.readByte(); if (type == 1) { f.read(smp[s].name,1,12); mp_ubyte bOffs = f.readByte(); mp_uword wOffs = f.readWord(); samplePtrs[i] = (((mp_uint32)bOffs<<16)+(mp_uint32)wOffs)*16; smp[s].flags = 1; smp[s].pan = 0x80; smp[s].samplen = f.readDword(); smp[s].loopstart = f.readDword(); mp_sint32 looplen = ((mp_sint32)f.readDword() - (mp_sint32)smp[s].loopstart); if (looplen < 0)  looplen = 0; smp[s].looplen = looplen; smp[s].vol = module->vol64to255(f.readByte()); f.readByte();  smp[s].res = f.readByte() == 0x04 ? 0xAD : 0;  mp_ubyte flags = f.readByte(); if (flags & 1) { smp[s].type = 1; } if (flags & 4) { smp[s].type |= 16; smp[s].samplen >>= 1; smp[s].loopstart >>= 1; smp[s].looplen >>= 1; } mp_uint32 c4spd = f.readDword(); XModule::convertc4spd(c4spd,&smp[s].finetune,&smp[s].relnote); #ifdef VERBOSE printf(""%i, %i\n"",c4spd,module->getc4spd(smp[s].relnote,smp[s].finetune)); #endif f.readDword();  f.readDword();  f.readDword();  f.read(instr[i].name,1,28);  f.readDword();  if (samplePtrs[i] && smp[s].samplen) { instr[i].samp=1; for (j=0;j<120;j++)  instr[i].snum[j] = s; s++; } } else if (type == 0) { samplePtrs[i] = 0; mp_ubyte buffer[12]; f.read(buffer,1,12); f.readByte(); f.readWord(); f.readDword(); f.readDword(); f.readDword(); f.readByte(); f.readByte(); f.readByte();  f.readByte(); f.readDword(); f.readDword();  f.readDword();  f.readDword();  f.read(instr[i].name,1,28);  f.readDword(); } else  { samplePtrs[i] = 0; } } } mp_ubyte* pattern = new mp_ubyte[64*32*5]; if (pattern == NULL) { delete[] insParaPtrs; delete[] patParaPtrs; delete[] samplePtrs; return MP_OUT_OF_MEMORY; } mp_uint32 songMaxChannels = 1; for (i = 0; i < header->patnum; i++) { for (j = 0; j < 32*64; j++) { pattern[j*5] = 0xFF; pattern[j*5+1] = 0; pattern[j*5+2] = 0xFF; pattern[j*5+3] = 0xFF; pattern[j*5+4] = 0; } mp_uint32 patOffs = patParaPtrs[i]*16; mp_uint32 maxChannels = 1; if (patOffs) { f.seekWithBaseOffset(patOffs); mp_uint32 size = f.readWord(); if (size > 2) { size-=2; mp_ubyte* packed = new mp_ubyte[size+5]; if (packed == NULL) { delete[] insParaPtrs; delete[] patParaPtrs; delete[] samplePtrs; delete[] pattern; return MP_OUT_OF_MEMORY; } memset(packed, 0, size); f.read(packed, 1, size); mp_uint32 index = 0; mp_uint32 row = 0; while (index<size) { mp_ubyte pi = safeRead(packed, index, size); if (pi == 0)  { row++; if (row >= 64) { int i = 0; i++; i--; break; } continue; } mp_uint32 chn = pi&31; if (chn>maxChannels && (pi & (32+64+128))) { maxChannels = chn; } mp_ubyte* slot = pattern+(row*32*5)+chn*5; if (pi & 32) { slot[0] = safeRead(packed, index, size, 0xFF); slot[1] = safeRead(packed, index, size); } if (pi & 64) { slot[2] = safeRead(packed, index, size, 0xFF); } if (pi & 128) { slot[3] = safeRead(packed, index, size, 0xFF); slot[4] = safeRead(packed, index, size); } } maxChannels++; if (maxChannels > header->channum) maxChannels = header->channum; delete[] packed; } if (maxChannels > songMaxChannels) songMaxChannels = maxChannels; } convertS3MPattern(&phead[i], pattern, maxChannels, i); } if (header->channum > songMaxChannels) header->channum = songMaxChannels; delete[] pattern; delete[] insParaPtrs; delete[] patParaPtrs; s = 0; for (i = 0; i < header->insnum; i++) { mp_uint32 smpOffs = samplePtrs[i]; if (smpOffs) { f.seekWithBaseOffset(smpOffs); if (!smp[s].samplen) continue; bool adpcm = (smp[s].res == 0xAD); mp_sint32 result = module->loadModuleSample(f, s,  adpcm ? XModule::ST_PACKING_ADPCM : XModule::ST_UNSIGNED,  adpcm ? (XModule::ST_16BIT | XModule::ST_PACKING_ADPCM) : (XModule::ST_16BIT | XModule::ST_UNSIGNED)); if (result != MP_OK) { delete[] samplePtrs; return result; } if (adpcm) smp[s].res = 0; s++; } } delete[] samplePtrs; header->smpnum = s; strcpy(header->tracker,""Screamtracker 3""); module->setDefaultPanning(); module->postProcessSamples(); return MP_OK; }"
"static void  USBH_ParseInterfaceDesc(USBH_InterfaceDescTypeDef *if_descriptor, uint8_t *buf) { if_descriptor->bLength            = *(uint8_t *)(buf + 0); if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1); if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2); if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3); if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4); if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5); if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6); if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7); if_descriptor->iInterface         = *(uint8_t *)(buf + 8); }"
"static ogs_tlv_t *ogs_tlv_parse_block_desc(uint32_t length, void *data, uint8_t msg_mode, ogs_tlv_desc_t *desc) { uint8_t *pos = data; uint8_t *blk = data; ogs_tlv_t *root = NULL; ogs_tlv_t *prev = NULL; ogs_tlv_t *curr = NULL; root = curr = ogs_tlv_get(); ogs_assert(curr); pos = tlv_get_element_desc(curr, pos, msg_mode, desc); ogs_assert(pos); while(pos - blk < length) { prev = curr; curr = ogs_tlv_get(); ogs_assert(curr); prev->next = curr; pos = tlv_get_element_desc(curr, pos, msg_mode, desc); ogs_assert(pos); } ogs_assert(length == (pos - blk)); return root; }"
"static void TIFFGetProperties(TIFF *tiff,Image *image,ExceptionInfo *exception) { char message[MagickPathExtent], *text; uint32 count, length, type; unsigned long *tietz; if (TIFFGetField(tiff,TIFFTAG_ARTIST,&text) == 1) (void) SetImageProperty(image,""tiff:artist"",text,exception); if (TIFFGetField(tiff,TIFFTAG_COPYRIGHT,&text) == 1) (void) SetImageProperty(image,""tiff:copyright"",text,exception); if (TIFFGetField(tiff,TIFFTAG_DATETIME,&text) == 1) (void) SetImageProperty(image,""tiff:timestamp"",text,exception); if (TIFFGetField(tiff,TIFFTAG_DOCUMENTNAME,&text) == 1) (void) SetImageProperty(image,""tiff:document"",text,exception); if (TIFFGetField(tiff,TIFFTAG_HOSTCOMPUTER,&text) == 1) (void) SetImageProperty(image,""tiff:hostcomputer"",text,exception); if (TIFFGetField(tiff,TIFFTAG_IMAGEDESCRIPTION,&text) == 1) (void) SetImageProperty(image,""comment"",text,exception); if (TIFFGetField(tiff,TIFFTAG_MAKE,&text) == 1) (void) SetImageProperty(image,""tiff:make"",text,exception); if (TIFFGetField(tiff,TIFFTAG_MODEL,&text) == 1) (void) SetImageProperty(image,""tiff:model"",text,exception); if (TIFFGetField(tiff,TIFFTAG_OPIIMAGEID,&count,&text) == 1) { if (count >= MagickPathExtent) count=MagickPathExtent-1; (void) CopyMagickString(message,text,count+1); (void) SetImageProperty(image,""tiff:image-id"",message,exception); } if (TIFFGetField(tiff,TIFFTAG_PAGENAME,&text) == 1) (void) SetImageProperty(image,""label"",text,exception); if (TIFFGetField(tiff,TIFFTAG_SOFTWARE,&text) == 1) (void) SetImageProperty(image,""tiff:software"",text,exception); if (TIFFGetField(tiff,33423,&count,&text) == 1) { if (count >= MagickPathExtent) count=MagickPathExtent-1; (void) CopyMagickString(message,text,count+1); (void) SetImageProperty(image,""tiff:kodak-33423"",message,exception); } if (TIFFGetField(tiff,36867,&count,&text) == 1) { if (count >= MagickPathExtent) count=MagickPathExtent-1; (void) CopyMagickString(message,text,count+1); (void) SetImageProperty(image,""tiff:kodak-36867"",message,exception); } if (TIFFGetField(tiff,TIFFTAG_SUBFILETYPE,&type) == 1) switch (type) { case 0x01: { (void) SetImageProperty(image,""tiff:subfiletype"",""REDUCEDIMAGE"", exception); break; } case 0x02: { (void) SetImageProperty(image,""tiff:subfiletype"",""PAGE"",exception); break; } case 0x04: { (void) SetImageProperty(image,""tiff:subfiletype"",""MASK"",exception); break; } default: break; } if (TIFFGetField(tiff,37706,&length,&tietz) == 1) { (void) FormatLocaleString(message,MagickPathExtent,""%lu"",tietz[0]); (void) SetImageProperty(image,""tiff:tietz_offset"",message,exception); } }"
"static void * helper_thread (void *arg) { while (1) { union notify_data data; ssize_t n = __recv (netlink_socket, &data, sizeof (data), MSG_NOSIGNAL | MSG_WAITALL); if (n < NOTIFY_COOKIE_LEN) continue; if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_WOKENUP) { pthread_t th; if (__pthread_create (&th, data.attr, notification_function, &data) == 0) (void) __pthread_barrier_wait (&notify_barrier); } else if (data.raw[NOTIFY_COOKIE_LEN - 1] == NOTIFY_REMOVED) { __pthread_attr_destroy (data.attr); free (data.attr); } } return NULL; }"
"int parse_cmd_address(exarg_T *eap, char **errormsg, int silent) { intaddress_count = 1; linenr_Tlnum; intneed_check_cursor = FALSE; intret = FAIL; for (;;) { eap->line1 = eap->line2; eap->line2 = default_address(eap); eap->cmd = skipwhite(eap->cmd); lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent, eap->addr_count == 0, address_count++); if (eap->cmd == NULL)    goto theend; if (lnum == MAXLNUM) { if (*eap->cmd == '%')       { ++eap->cmd; switch (eap->addr_type) { case ADDR_LINES: case ADDR_OTHER: eap->line1 = 1; eap->line2 = curbuf->b_ml.ml_line_count; break; case ADDR_LOADED_BUFFERS: { buf_T*buf = firstbuf; while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_next; eap->line1 = buf->b_fnum; buf = lastbuf; while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_prev; eap->line2 = buf->b_fnum; break; } case ADDR_BUFFERS: eap->line1 = firstbuf->b_fnum; eap->line2 = lastbuf->b_fnum; break; case ADDR_WINDOWS: case ADDR_TABS: if (IS_USER_CMDIDX(eap->cmdidx)) { eap->line1 = 1; eap->line2 = eap->addr_type == ADDR_WINDOWS ? LAST_WIN_NR : LAST_TAB_NR; } else { *errormsg = _(e_invalid_range); goto theend; } break; case ADDR_TABS_RELATIVE: case ADDR_UNSIGNED: case ADDR_QUICKFIX: *errormsg = _(e_invalid_range); goto theend; case ADDR_ARGUMENTS: if (ARGCOUNT == 0) eap->line1 = eap->line2 = 0; else { eap->line1 = 1; eap->line2 = ARGCOUNT; } break; case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX eap->line1 = 1; eap->line2 = qf_get_valid_size(eap); if (eap->line2 == 0) eap->line2 = 1; #endif break; case ADDR_NONE: break; } ++eap->addr_count; } else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL) { pos_T    *fp; if (eap->addr_type != ADDR_LINES) { *errormsg = _(e_invalid_range); goto theend; } ++eap->cmd; if (!eap->skip) { fp = getmark('<', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line1 = fp->lnum; fp = getmark('>', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line2 = fp->lnum; ++eap->addr_count; } } } else eap->line2 = lnum; eap->addr_count++; if (*eap->cmd == ';') { if (!eap->skip) { curwin->w_cursor.lnum = eap->line2; if (eap->line2 > 0) check_cursor(); need_check_cursor = TRUE; } } else if (*eap->cmd != ',') break; ++eap->cmd; } if (eap->addr_count == 1) { eap->line1 = eap->line2; if (lnum == MAXLNUM) eap->addr_count = 0; } ret = OK; theend: if (need_check_cursor) check_cursor(); return ret; }"
"rdpBitmapCache* bitmap_cache_new(rdpSettings* settings) { int i; rdpBitmapCache* bitmapCache; bitmapCache = (rdpBitmapCache*)calloc(1, sizeof(rdpBitmapCache)); if (!bitmapCache) return NULL; bitmapCache->settings = settings; bitmapCache->update = ((freerdp*)settings->instance)->update; bitmapCache->context = bitmapCache->update->context; bitmapCache->maxCells = settings->BitmapCacheV2NumCells; bitmapCache->cells = (BITMAP_V2_CELL*)calloc(bitmapCache->maxCells, sizeof(BITMAP_V2_CELL)); if (!bitmapCache->cells) goto fail; for (i = 0; i < (int)bitmapCache->maxCells; i++) { bitmapCache->cells[i].number = settings->BitmapCacheV2CellInfo[i].numEntries; bitmapCache->cells[i].entries = (rdpBitmap**)calloc((bitmapCache->cells[i].number + 1), sizeof(rdpBitmap*)); if (!bitmapCache->cells[i].entries) goto fail; } return bitmapCache; fail: if (bitmapCache->cells) { for (i = 0; i < (int)bitmapCache->maxCells; i++) free(bitmapCache->cells[i].entries); } free(bitmapCache); return NULL; }"
"int _gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag) { int i; if (gd2xFlag) { int trueColorFlag; if (!gdGetByte (&trueColorFlag, in)) { goto fail1; } if (trueColorFlag != im->trueColor) { goto fail1; } if (!im->trueColor) { if (!gdGetWord (&im->colorsTotal, in)) { goto fail1; } if (im->colorsTotal > gdMaxColors) { goto fail1; } } if (!gdGetInt (&im->transparent, in)) { goto fail1; } } else { if (!gdGetByte (&im->colorsTotal, in)) { goto fail1; } if (!gdGetWord (&im->transparent, in)) { goto fail1; } if (im->transparent == 257) { im->transparent = (-1); } } GD2_DBG (printf (""Palette had %d colours (T=%d)\n"", im->colorsTotal, im->transparent)); if (im->trueColor) { return TRUE; } for (i = 0; (i < gdMaxColors); i++) { if (!gdGetByte (&im->red[i], in)) { goto fail1; } if (!gdGetByte (&im->green[i], in)) { goto fail1; } if (!gdGetByte (&im->blue[i], in)) { goto fail1; } if (gd2xFlag) { if (!gdGetByte (&im->alpha[i], in)) { goto fail1; } } } for (i = 0; (i < im->colorsTotal); i++) { im->open[i] = 0; }; return TRUE; fail1: return FALSE; }"
"Status Conv2DShapeImpl(shape_inference::InferenceContext* c, bool supports_explicit_padding) { string data_format_str, filter_format_str; if (!c->GetAttr(""data_format"", &data_format_str).ok()) { data_format_str = ""NHWC""; } if (!c->GetAttr(""filter_format"", &filter_format_str).ok()) { filter_format_str = ""HWIO""; } TensorFormat data_format; if (!FormatFromString(data_format_str, &data_format)) { return errors::InvalidArgument(""Invalid data format string: "", data_format_str); } FilterTensorFormat filter_format; if (!FilterFormatFromString(filter_format_str, &filter_format)) { return errors::InvalidArgument(""Invalid filter format string: "", filter_format_str); } constexpr int num_spatial_dims = 2; const int rank = GetTensorDimsFromSpatialDims(num_spatial_dims, data_format); ShapeHandle conv_input_shape; TF_RETURN_IF_ERROR(c->WithRank(c->input(0), rank, &conv_input_shape)); TF_RETURN_IF_ERROR(CheckFormatConstraintsOnShape( data_format, conv_input_shape, ""conv_input"", c)); ShapeHandle filter_shape; TF_RETURN_IF_ERROR(c->WithRank(c->input(1), rank, &filter_shape)); TF_RETURN_IF_ERROR( CheckFormatConstraintsOnShape(data_format, filter_shape, ""filter"", c)); std::vector<int32> dilations; TF_RETURN_IF_ERROR(c->GetAttr(""dilations"", &dilations)); if (dilations.size() != 4) { return errors::InvalidArgument( ""Conv2D requires the dilation attribute to contain 4 values, but got: "", dilations.size()); } std::vector<int32> strides; TF_RETURN_IF_ERROR(c->GetAttr(""strides"", &strides)); if (strides.size() != 4) { return errors::InvalidArgument(""Conv2D on data format "", data_format_str, "" requires the stride attribute to contain"" "" 4 values, but got: "", strides.size()); } const int32_t stride_rows = GetTensorDim(strides, data_format, 'H'); const int32_t stride_cols = GetTensorDim(strides, data_format, 'W'); const int32_t dilation_rows = GetTensorDim(dilations, data_format, 'H'); const int32_t dilation_cols = GetTensorDim(dilations, data_format, 'W'); DimensionHandle batch_size_dim; DimensionHandle input_depth_dim; gtl::InlinedVector<DimensionHandle, 2> input_spatial_dims(2); TF_RETURN_IF_ERROR(DimensionsFromShape( conv_input_shape, data_format, &batch_size_dim, absl::MakeSpan(input_spatial_dims), &input_depth_dim, c)); DimensionHandle output_depth_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'O')); DimensionHandle filter_rows_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'H')); DimensionHandle filter_cols_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'W')); DimensionHandle filter_input_depth_dim; if (filter_format == FORMAT_OIHW_VECT_I) { TF_RETURN_IF_ERROR(c->Multiply( c->Dim(filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'I')), c->Dim(filter_shape, GetFilterTensorInnerInputChannelsDimIndex(rank, filter_format)), &filter_input_depth_dim)); } else { filter_input_depth_dim = c->Dim( filter_shape, GetFilterDimIndex<num_spatial_dims>(filter_format, 'I')); } if (c->ValueKnown(input_depth_dim) && c->ValueKnown(filter_input_depth_dim)) { int64_t input_depth_value = c->Value(input_depth_dim), filter_input_depth_value = c->Value(filter_input_depth_dim); if (input_depth_value % filter_input_depth_value != 0) return errors::InvalidArgument( ""Depth of input ("", input_depth_value, "") is not a multiple of input depth of filter ("", filter_input_depth_value, "")""); if (input_depth_value != filter_input_depth_value) { int64_t num_groups = input_depth_value / filter_input_depth_value; if (c->ValueKnown(output_depth_dim)) { int64_t output_depth_value = c->Value(output_depth_dim); if (output_depth_value % num_groups != 0) return errors::InvalidArgument( ""Depth of output ("", output_depth_value, "") is not a multiple of the number of groups ("", num_groups, "")""); } } } Padding padding; TF_RETURN_IF_ERROR(c->GetAttr(""padding"", &padding)); std::vector<int64> explicit_paddings; if (supports_explicit_padding) { Status s = c->GetAttr(""explicit_paddings"", &explicit_paddings); if (!s.ok() && !errors::IsNotFound(s)) { return s; } TF_RETURN_IF_ERROR(CheckValidPadding(padding, explicit_paddings, 4, data_format)); } else { CHECK(padding != Padding::EXPLICIT);    } DimensionHandle output_rows, output_cols; int64_t pad_rows_before = -1, pad_rows_after = -1; int64_t pad_cols_before = -1, pad_cols_after = -1; if (padding == Padding::EXPLICIT) { GetExplicitPaddingForDim(explicit_paddings, data_format, 'H', &pad_rows_before, &pad_rows_after); GetExplicitPaddingForDim(explicit_paddings, data_format, 'W', &pad_cols_before, &pad_cols_after); } TF_RETURN_IF_ERROR(GetWindowedOutputSizeFromDimsV2( c, input_spatial_dims[0], filter_rows_dim, dilation_rows, stride_rows, padding, pad_rows_before, pad_rows_after, &output_rows)); TF_RETURN_IF_ERROR(GetWindowedOutputSizeFromDimsV2( c, input_spatial_dims[1], filter_cols_dim, dilation_cols, stride_cols, padding, pad_cols_before, pad_cols_after, &output_cols)); absl::optional<DimensionHandle> vect_size; if (data_format == FORMAT_NCHW_VECT_C) { vect_size.emplace(c->Dim(conv_input_shape, GetTensorInnerFeatureDimIndex(rank, data_format))); } ShapeHandle output_shape; TF_RETURN_IF_ERROR(ShapeFromDimensions( batch_size_dim, {output_rows, output_cols}, output_depth_dim, data_format, vect_size, c, &output_shape)); c->set_output(0, output_shape); return Status::OK(); }"
"static int processCropSelections(struct image_data *image, struct crop_mask *crop, unsigned char **read_buff_ptr, struct buffinfo seg_buffs[]) { int i; uint32_t width, length, total_width, total_length; tsize_t cropsize; unsigned char *crop_buff = NULL; unsigned char *read_buff = NULL; unsigned char *next_buff = NULL; tsize_t prev_cropsize = 0; read_buff = *read_buff_ptr; if (crop->img_mode == COMPOSITE_IMAGES) { cropsize = crop->bufftotal; crop_buff = seg_buffs[0].buffer; if (!crop_buff) crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES); else { prev_cropsize = seg_buffs[0].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!next_buff) { _TIFFfree(crop_buff); crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(""processCropSelections"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = cropsize; if (extractCompositeRegions(image, crop, read_buff, crop_buff) != 0) return (1); if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: image->photometric = crop->photometric; break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG: if (invertImage(image->photometric, image->spp, image->bps, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to invert colorspace for composite "" ""regions""); return (-1); } if (crop->photometric == INVERT_DATA_AND_TAG) { switch (image->photometric) { case PHOTOMETRIC_MINISWHITE: image->photometric = PHOTOMETRIC_MINISBLACK; break; case PHOTOMETRIC_MINISBLACK: image->photometric = PHOTOMETRIC_MINISWHITE; break; default: break; } } break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to mirror composite regions %s"", (crop->rotation == MIRROR_HORIZ) ? ""horizontally"" : ""vertically""); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { size_t rot_buf_size = 0; if (rotateImage(crop->rotation, image, &crop->combined_width, &crop->combined_length, &crop_buff, &rot_buf_size)) { TIFFError(""processCropSelections"", ""Failed to rotate composite regions by %"" PRIu32 "" degrees"", crop->rotation); return (-1); } seg_buffs[0].buffer = crop_buff; seg_buffs[0].size = rot_buf_size; } } else  { total_width = total_length = 0; for (i = 0; i < crop->selections; i++) { cropsize = crop->bufftotal; crop_buff = seg_buffs[i].buffer; if (!crop_buff) crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); else { prev_cropsize = seg_buffs[i].size; if (prev_cropsize < cropsize) { next_buff = _TIFFrealloc( crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!next_buff) { _TIFFfree(crop_buff); crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); } else crop_buff = next_buff; } } if (!crop_buff) { TIFFError(""processCropSelections"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = cropsize; if (extractSeparateRegion(image, crop, read_buff, crop_buff, i)) { TIFFError(""processCropSelections"", ""Unable to extract cropped region %d from image"", i); return (-1); } width = crop->regionlist[i].width; length = crop->regionlist[i].length; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: image->photometric = crop->photometric; break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG: if (invertImage(image->photometric, image->spp, image->bps, width, length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to invert colorspace for region""); return (-1); } if (crop->photometric == INVERT_DATA_AND_TAG) { switch (image->photometric) { case PHOTOMETRIC_MINISWHITE: image->photometric = PHOTOMETRIC_MINISBLACK; break; case PHOTOMETRIC_MINISBLACK: image->photometric = PHOTOMETRIC_MINISWHITE; break; default: break; } } break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror, width, length, crop_buff)) { TIFFError(""processCropSelections"", ""Failed to mirror crop region %s"", (crop->rotation == MIRROR_HORIZ) ? ""horizontally"" : ""vertically""); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { size_t rot_buf_size = 0; if (rotateImage( crop->rotation, image, &crop->regionlist[i].width, &crop->regionlist[i].length, &crop_buff, &rot_buf_size)) { TIFFError(""processCropSelections"", ""Failed to rotate crop region by %"" PRIu16 "" degrees"", crop->rotation); return (-1); } total_width += crop->regionlist[i].width; total_length += crop->regionlist[i].length; crop->combined_width = total_width; crop->combined_length = total_length; seg_buffs[i].buffer = crop_buff; seg_buffs[i].size = rot_buf_size; } }  }      return (0); }"
"void arp_print(netdissect_options *ndo, const u_char *bp, u_int length, u_int caplen) { const struct arp_pkthdr *ap; u_short pro, hrd, op, linkaddr; ap = (const struct arp_pkthdr *)bp; ND_TCHECK(*ap); hrd = HRD(ap); pro = PRO(ap); op = OP(ap); switch(hrd) { case ARPHRD_ATM2225: atmarp_print(ndo, bp, length, caplen); return; case ARPHRD_FRELAY: linkaddr = LINKADDR_FRELAY; break; default: linkaddr = LINKADDR_ETHER; break; } if (!ND_TTEST2(*ar_tpa(ap), PROTO_LEN(ap))) { ND_PRINT((ndo, ""%s"", tstr)); ND_DEFAULTPRINT((const u_char *)ap, length); return; } if (!ndo->ndo_eflag) { ND_PRINT((ndo, ""ARP, "")); } if ((pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL) || PROTO_LEN(ap) != 4 || HRD_LEN(ap) == 0 || ndo->ndo_vflag) { ND_PRINT((ndo, ""%s (len %u), %s (len %u)"", tok2str(arphrd_values, ""Unknown Hardware (%u)"", hrd), HRD_LEN(ap), tok2str(ethertype_values, ""Unknown Protocol (0x%04x)"", pro), PROTO_LEN(ap))); if (!ndo->ndo_vflag) { goto out; } } ND_PRINT((ndo, ""%s%s "", ndo->ndo_vflag ? "", "" : """", tok2str(arpop_values, ""Unknown (%u)"", op))); switch (op) { case ARPOP_REQUEST: ND_PRINT((ndo, ""who-has %s"", ipaddr_string(ndo, TPA(ap)))); if (isnonzero((const u_char *)THA(ap), HRD_LEN(ap))) ND_PRINT((ndo, "" (%s)"", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)))); ND_PRINT((ndo, "" tell %s"", ipaddr_string(ndo, SPA(ap)))); break; case ARPOP_REPLY: ND_PRINT((ndo, ""%s is-at %s"", ipaddr_string(ndo, SPA(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))); break; case ARPOP_REVREQUEST: ND_PRINT((ndo, ""who-is %s tell %s"", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))); break; case ARPOP_REVREPLY: ND_PRINT((ndo, ""%s at %s"", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), ipaddr_string(ndo, TPA(ap)))); break; case ARPOP_INVREQUEST: ND_PRINT((ndo, ""who-is %s tell %s"", linkaddr_string(ndo, THA(ap), linkaddr, HRD_LEN(ap)), linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)))); break; case ARPOP_INVREPLY: ND_PRINT((ndo,""%s at %s"", linkaddr_string(ndo, SHA(ap), linkaddr, HRD_LEN(ap)), ipaddr_string(ndo, SPA(ap)))); break; default: ND_DEFAULTPRINT((const u_char *)ap, caplen); return; } out: ND_PRINT((ndo, "", length %u"", length)); return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
"void * gstd_accept(int fd, char **display_creds, char **export_name, char **mech) { gss_name_t client; gss_OID mech_oid; struct gstd_tok *tok; gss_ctx_id_t ctx = GSS_C_NO_CONTEXT; gss_buffer_desc in, out; OM_uint32 maj, min; int ret; *display_creds = NULL; *export_name = NULL; out.length = 0; in.length = 0; read_packet(fd, &in, 60000, 1); again: while ((ret = read_packet(fd, &in, 60000, 0)) == -2) ; if (ret < 1) return NULL; maj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL, &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL, NULL, NULL); if (out.length && write_packet(fd, &out)) { gss_release_buffer(&min, &out); return NULL; } GSTD_GSS_ERROR(maj, min, NULL, ""gss_accept_sec_context""); if (maj & GSS_S_CONTINUE_NEEDED) goto again; *display_creds = gstd_get_display_name(client); *export_name = gstd_get_export_name(client); *mech = gstd_get_mech(mech_oid); gss_release_name(&min, &client); SETUP_GSTD_TOK(tok, ctx, fd, ""gstd_accept""); return tok; }"
void btf_dump__free(struct btf_dump *d) { int i; if (IS_ERR_OR_NULL(d)) return; free(d->type_states); if (d->cached_names) { for (i = 0; i <= d->last_id; i++) { if (d->cached_names[i]) free((void *)d->cached_names[i]); } } free(d->cached_names); free(d->emit_queue); free(d->decl_stack); hashmap__free(d->type_names); hashmap__free(d->ident_names); free(d); }
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"static struct dump_dir *open_directory_for_modification_of_element( GDBusMethodInvocation *invocation, uid_t caller_uid, const char *problem_id, const char *element) { static const char *const protected_elements[] = { FILENAME_TIME, FILENAME_UID, NULL, }; for (const char *const *protected = protected_elements; *protected; ++protected) { if (strcmp(*protected, element) == 0) { log_notice(""'%s' element of '%s' can't be modified"", element, problem_id); char *error = xasprintf(_(""'%s' element can't be modified""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.ProtectedElement"", error); free(error); return NULL; } } if (!dump_dir_accessible_by_uid(problem_id, caller_uid)) { if (errno == ENOTDIR) { log_notice(""'%s' is not a valid problem directory"", problem_id); return_InvalidProblemDir_error(invocation, problem_id); } else { log_notice(""UID(%d) is not Authorized to access '%s'"", caller_uid, problem_id); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.AuthFailure"", _(""Not Authorized"")); } return NULL; } struct dump_dir *dd = dd_opendir(problem_id,  0); if (!dd) {    log_notice(""Can't access the problem '%s' for modification"", problem_id); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", _(""Can't access the problem for modification"")); return NULL; } return dd; }"
"bool  Jpeg2KDecoder::readHeader() { bool result = false; close(); jas_stream_t* stream = jas_stream_fopen( m_filename.c_str(), ""rb"" ); m_stream = stream; if( stream ) { jas_image_t* image = jas_image_decode( stream, -1, 0 ); m_image = image; if( image ) { m_width = jas_image_width( image ); m_height = jas_image_height( image ); int cntcmpts = 0;             int numcmpts = jas_image_numcmpts( image ); int depth = 0; for( int i = 0; i < numcmpts; i++ ) { int depth_i = jas_image_cmptprec( image, i ); depth = MAX(depth, depth_i); if( jas_image_cmpttype( image, i ) > 2 ) continue; cntcmpts++; } if( cntcmpts ) { m_type = CV_MAKETYPE(depth <= 8 ? CV_8U : CV_16U, cntcmpts > 1 ? 3 : 1); result = true; } } } if( !result ) close(); return result; }"
"ResponsePtr Server::ServeStatic(RequestPtr request) { assert(request->method() == methods::kGet); if (doc_root_.empty()) { LOG_INFO(""The doc root was not specified""); return {}; } fs::path path = doc_root_ / request->url().path(); try { auto body = std::make_shared<FileBody>(path, file_chunk_size_); auto response = std::make_shared<Response>(Status::kOK); std::string extension = path.extension().string(); response->SetContentType(media_types::FromExtension(extension), """"); response->SetBody(body, true); return response; } catch (const Error& error) { LOG_ERRO(""File error: %s"", error.message().c_str()); return {}; } }"
"int vc_allocate(unsigned int currcons) { struct vt_notifier_param param; struct vc_data *vc; WARN_CONSOLE_UNLOCKED(); if (currcons >= MAX_NR_CONSOLES) return -ENXIO; if (vc_cons[currcons].d) return 0; param.vc = vc = kzalloc(sizeof(struct vc_data), GFP_KERNEL); if (!vc) return -ENOMEM; vc_cons[currcons].d = vc; tty_port_init(&vc->port); INIT_WORK(&vc_cons[currcons].SAK_work, vc_SAK); visual_init(vc, currcons, 1); if (!*vc->vc_uni_pagedir_loc) con_set_default_unimap(vc); vc->vc_screenbuf = kzalloc(vc->vc_screenbuf_size, GFP_KERNEL); if (!vc->vc_screenbuf) goto err_free; if (global_cursor_default == -1) global_cursor_default = 1; vc_init(vc, vc->vc_rows, vc->vc_cols, 1); vcs_make_sysfs(currcons); atomic_notifier_call_chain(&vt_notifier_list, VT_ALLOCATE, &param); return 0; err_free: visual_deinit(vc); kfree(vc); vc_cons[currcons].d = NULL; return -ENOMEM; }"
"static int iwpnm_read_pam_header(struct iwpnmrcontext *rctx) { char linebuf[100]; char tokenbuf[100]; char token2buf[100]; int retval = 0; int curpos = 0; while(1) { if(!read_pam_header_line(rctx, linebuf, sizeof(linebuf))) goto done; if(linebuf[0]=='#') { continue; } curpos = 0; if(!read_next_pam_token(rctx, linebuf, tokenbuf, sizeof(tokenbuf), &curpos)) goto done; if(!strcmp(tokenbuf,""ENDHDR"")) { break; } if(!strcmp(tokenbuf,"""")) { continue; } if(!read_next_pam_token(rctx, linebuf, token2buf, sizeof(token2buf), &curpos)) goto done; if(!strcmp(tokenbuf,""WIDTH"")) { rctx->img->width = atoi(token2buf); } else if(!strcmp(tokenbuf,""HEIGHT"")) { rctx->img->height = atoi(token2buf); } else if(!strcmp(tokenbuf,""DEPTH"")) { rctx->num_channels_pam = atoi(token2buf); } else if(!strcmp(tokenbuf,""MAXVAL"")) { rctx->color_count = atoi(token2buf); } else if(!strcmp(tokenbuf,""TUPLTYPE"")) { } } if(rctx->color_count<1 || rctx->color_count>65535) { iw_set_errorf(rctx->ctx, ""Invalid max color value (%d)\n"", rctx->color_count); goto done; } retval = 1; done: return retval; }"
"struct ngiflibSDL_animation * SDL_LoadAnimatedGif(const char * file) { SDL_Surface * surface; struct ngiflib_gif * gif; FILE *fgif; int err,i; u8 * pdst, * psrc; u8 * p = NULL; #ifdef NGIFLIB_NO_FILE u8 * buffer; long filesize; #endif  int image_count = 0; int image_count_max = 50; struct ngiflibSDL_animation * animation = NULL; struct ngiflib_rgb * current_palette = NULL; int current_palette_size = 0; fgif = fopen(file, ""rb""); if(fgif==NULL) return NULL; gif = (struct ngiflib_gif *)ngiflib_malloc(sizeof(struct ngiflib_gif)); #ifdef EXTRA_MALLOC_CHECK if(gif == NULL) { return NULL; } #endif  ngiflib_memset(gif, 0, sizeof(struct ngiflib_gif)); #ifdef NGIFLIB_NO_FILE fseek(fgif, 0, SEEK_END); filesize = ftell(fgif); fseek(fgif, 0, SEEK_SET); buffer = malloc(filesize); if(buffer == NULL) { GifDestroy(gif); return NULL; } fread(buffer, 1, filesize, fgif); gif->input.buffer.bytes = buffer; gif->input.buffer.count = (unsigned long)filesize; gif->mode = NGIFLIB_MODE_FROM_MEM | NGIFLIB_MODE_INDEXED; #else  gif->input.file = fgif; gif->mode = NGIFLIB_MODE_FROM_FILE | NGIFLIB_MODE_INDEXED; #ifdef NGIFLIBSDL_LOG gif->log = stdout; #endif  #endif  while((err = LoadGif(gif)) == 1) { if(animation == NULL) { animation = ngiflib_malloc(sizeof(struct ngiflibSDL_animation) + image_count_max*sizeof(struct ngiflibSDL_image)); if(animation == NULL) return NULL; } else if(image_count >= image_count_max) { image_count_max += 50; struct ngiflibSDL_animation * tmp; tmp = realloc(animation, sizeof(struct ngiflibSDL_animation) + image_count_max*sizeof(struct ngiflibSDL_image)); if(tmp == NULL) { fprintf(stderr, ""realloc() failed, cannot decode more images\n""); break; } animation = tmp; } p = gif->frbuff.p8; surface = SDL_CreateRGBSurface(SDL_SWSURFACE | SDL_SRCCOLORKEY, gif->width, gif->height, 8, 0,0,0,0); SDL_LockSurface(surface); if(gif->palette != gif->cur_img->palette) { current_palette = gif->cur_img->palette; current_palette_size = (1 << gif->cur_img->localpalbits); } else if(current_palette == NULL) { current_palette = gif->palette; current_palette_size = gif->ncolors; } for(i = 0; i < current_palette_size; i++) { surface->format->palette->colors[i].r = current_palette[i].r; surface->format->palette->colors[i].g = current_palette[i].g; surface->format->palette->colors[i].b = current_palette[i].b; } for(; i < gif->ncolors; i++) { surface->format->palette->colors[i].r = gif->palette[i].r; surface->format->palette->colors[i].g = gif->palette[i].g; surface->format->palette->colors[i].b = gif->palette[i].b; } printf(""\n""); psrc = p; pdst = surface->pixels; for(i=0; i<gif->height; i++) { ngiflib_memcpy(pdst, psrc, gif->width); pdst += surface->pitch; psrc += gif->width; } SDL_UnlockSurface(surface); animation->images[image_count].delay_time = -1; if(gif->cur_img->gce.gce_present) { animation->images[image_count].delay_time = gif->cur_img->gce.delay_time; } animation->images[image_count].surface = surface; image_count++; } fclose(fgif); #ifdef NGIFLIB_NO_FILE free(buffer); #endif  GifDestroy(gif); if(animation) animation->image_count = image_count; return animation; }"
"void SnippetContext_t::BuildExcerpt ( ExcerptQuery_t & tOptions, const CSphIndex * pIndex ) const { auto pStripper = m_tStripper.Ptr (); CSphString &sError = tOptions.m_sError; tOptions.m_dSeparators.Resize ( 0 ); if ( tOptions.m_sStripMode==""retain"" && !( tOptions.m_iLimit==0 && tOptions.m_iLimitPassages==0 && tOptions.m_iLimitWords==0 ) ) { sError = ""html_strip_mode=retain requires that all limits are zero""; return; } auto * pData = const_cast<char*> ( tOptions.m_sSource.cstr() ); CSphFixedVector<char> pBuffer { 0 }; if ( tOptions.m_uFilesMode ) { CSphAutofile tFile; CSphString sFilename; sFilename.SetSprintf ( ""%s%s"", g_sSnippetsFilePrefix.cstr(), tOptions.m_sSource.scstr() ); if ( !sFilename.IsEmpty () && tFile.Open ( sFilename.cstr(), SPH_O_READ, sError )<0 ) return; else if ( tOptions.m_sSource.IsEmpty() ) { sError.SetSprintf ( ""snippet file name is empty"" ); return; } if ( tFile.GetSize()+1>=(SphOffset_t)INT_MAX ) { sError.SetSprintf ( ""%s too big for snippet (over 2 GB)"", pData ); return; } auto iFileSize = (int)tFile.GetSize(); if ( iFileSize<0 ) return; pBuffer.Reset ( iFileSize+1 ); if ( !tFile.Read ( pBuffer.Begin(), iFileSize, sError ) ) return; pData = pBuffer.Begin(); pData[iFileSize] = '\0'; } if ( pStripper && ( tOptions.m_sStripMode==""strip"" || tOptions.m_sStripMode==""index"" ) ) pStripper->Strip ( (BYTE*)pData ); if ( tOptions.m_sStripMode!=""retain"" ) pStripper = NULL; int iDataLen = pData ? strlen ( pData ) : 0; DoHighlighting ( tOptions, pIndex->GetSettings(), m_tExtQuery, m_eExtQuerySPZ, pData, iDataLen, m_pDict, m_pTokenizer, pStripper, m_pQueryTokenizer, tOptions.m_dRes, tOptions.m_dSeparators ); }"
"static void nbd_trip(void *opaque) { NBDClient *client = opaque; NBDExport *exp = client->exp; NBDRequestData *req; NBDRequest request; NBDReply reply; ssize_t ret; int flags; TRACE(""Reading request.""); if (client->closing) { return; } req = nbd_request_get(client); ret = nbd_co_receive_request(req, &request); if (ret == -EAGAIN) { goto done; } if (ret == -EIO) { goto out; } reply.handle = request.handle; reply.error = 0; if (ret < 0) { reply.error = -ret; goto error_reply; } if (client->closing) { goto done; } switch (request.type) { case NBD_CMD_READ: TRACE(""Request type is READ""); if (request.flags & NBD_CMD_FLAG_FUA) { ret = blk_co_flush(exp->blk); if (ret < 0) { LOG(""flush failed""); reply.error = -ret; goto error_reply; } } ret = blk_pread(exp->blk, request.from + exp->dev_offset, req->data, request.len); if (ret < 0) { LOG(""reading from file failed""); reply.error = -ret; goto error_reply; } TRACE(""Read %"" PRIu32"" byte(s)"", request.len); if (nbd_co_send_reply(req, &reply, request.len) < 0) goto out; break; case NBD_CMD_WRITE: TRACE(""Request type is WRITE""); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE(""Server is read-only, return error""); reply.error = EROFS; goto error_reply; } TRACE(""Writing to device""); flags = 0; if (request.flags & NBD_CMD_FLAG_FUA) { flags |= BDRV_REQ_FUA; } ret = blk_pwrite(exp->blk, request.from + exp->dev_offset, req->data, request.len, flags); if (ret < 0) { LOG(""writing to file failed""); reply.error = -ret; goto error_reply; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_WRITE_ZEROES: TRACE(""Request type is WRITE_ZEROES""); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE(""Server is read-only, return error""); reply.error = EROFS; goto error_reply; } TRACE(""Writing to device""); flags = 0; if (request.flags & NBD_CMD_FLAG_FUA) { flags |= BDRV_REQ_FUA; } if (!(request.flags & NBD_CMD_FLAG_NO_HOLE)) { flags |= BDRV_REQ_MAY_UNMAP; } ret = blk_pwrite_zeroes(exp->blk, request.from + exp->dev_offset, request.len, flags); if (ret < 0) { LOG(""writing to file failed""); reply.error = -ret; goto error_reply; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_DISC: abort(); case NBD_CMD_FLUSH: TRACE(""Request type is FLUSH""); ret = blk_co_flush(exp->blk); if (ret < 0) { LOG(""flush failed""); reply.error = -ret; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_TRIM: TRACE(""Request type is TRIM""); ret = blk_co_pdiscard(exp->blk, request.from + exp->dev_offset, request.len); if (ret < 0) { LOG(""discard failed""); reply.error = -ret; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; default: LOG(""invalid request type (%"" PRIu32 "") received"", request.type); reply.error = EINVAL; error_reply: if (nbd_co_send_reply(req, &reply, 0) < 0 || !req->complete) { goto out; } break; } TRACE(""Request/Reply complete""); done: nbd_request_put(req); return; out: nbd_request_put(req); client_close(client); }"
"static int usb_console_setup(struct console *co, char *options) { struct usbcons_info *info = &usbcons_info; int baud = 9600; int bits = 8; int parity = 'n'; int doflow = 0; int cflag = CREAD | HUPCL | CLOCAL; char *s; struct usb_serial *serial; struct usb_serial_port *port; int retval; struct tty_struct *tty = NULL; struct ktermios dummy; if (options) { baud = simple_strtoul(options, NULL, 10); s = options; while (*s >= '0' && *s <= '9') s++; if (*s) parity = *s++; if (*s) bits   = *s++ - '0'; if (*s) doflow = (*s++ == 'r'); } if (baud == 0) baud = 9600; switch (bits) { case 7: cflag |= CS7; break; default: case 8: cflag |= CS8; break; } switch (parity) { case 'o': case 'O': cflag |= PARODD; break; case 'e': case 'E': cflag |= PARENB; break; } co->cflag = cflag; port = usb_serial_port_get_by_minor(co->index); if (port == NULL) { pr_err(""No USB device connected to ttyUSB%i\n"", co->index); return -ENODEV; } serial = port->serial; retval = usb_autopm_get_interface(serial->interface); if (retval) goto error_get_interface; tty_port_tty_set(&port->port, NULL); info->port = port; ++port->port.count; if (!tty_port_initialized(&port->port)) { if (serial->type->set_termios) { tty = kzalloc(sizeof(*tty), GFP_KERNEL); if (!tty) { retval = -ENOMEM; goto reset_open_count; } kref_init(&tty->kref); tty->driver = usb_serial_tty_driver; tty->index = co->index; init_ldsem(&tty->ldisc_sem); spin_lock_init(&tty->files_lock); INIT_LIST_HEAD(&tty->tty_files); kref_get(&tty->driver->kref); __module_get(tty->driver->owner); tty->ops = &usb_console_fake_tty_ops; tty_init_termios(tty); tty_port_tty_set(&port->port, tty); } retval = serial->type->open(NULL, port); if (retval) { dev_err(&port->dev, ""could not open USB console port\n""); goto fail; } if (serial->type->set_termios) { tty->termios.c_cflag = cflag; tty_termios_encode_baud_rate(&tty->termios, baud, baud); memset(&dummy, 0, sizeof(struct ktermios)); serial->type->set_termios(tty, port, &dummy); tty_port_tty_set(&port->port, NULL); tty_kref_put(tty); } tty_port_set_initialized(&port->port, 1); } --port->port.count; port->port.console = 1; mutex_unlock(&serial->disc_mutex); return retval; fail: tty_port_tty_set(&port->port, NULL); tty_kref_put(tty); reset_open_count: port->port.count = 0; usb_autopm_put_interface(serial->interface); error_get_interface: usb_serial_put(serial); mutex_unlock(&serial->disc_mutex); return retval; }"
"void TR_InvariantArgumentPreexistence::processIndirectCall(TR::Node *node, TR::TreeTop *treeTop, vcount_t visitCount) { #ifdef J9_PROJECT_SPECIFIC if (trace()) traceMsg(comp(), ""PREX:      [%p] %s %s\n"", node, node->getOpCode().getName(), node->getSymbolReference()->getName(comp()->getDebug())); if (!node->getSymbol()->castToMethodSymbol()->firstArgumentIsReceiver()) { if (trace()) traceMsg(comp(), ""PREX:        - First arg is not receiver\n""); return; } bool  isInterface             = false; ParmInfo           tmpInfo;  tmpInfo.clear(); ParmInfo           *receiverInfo = &tmpInfo; TR::Symbol          *receiverSymbol = NULL; bool               receiverFromParm = false; int32_t            receiverParmOrdinal = -1; ParmInfo *existingInfo = NULL; TR::MethodSymbol   *methodSymbol   = node->getSymbol()->castToMethodSymbol(); TR_ResolvedMethod *resolvedMethod = methodSymbol->getResolvedMethodSymbol()? methodSymbol->getResolvedMethodSymbol()->getResolvedMethod() : NULL; if (!resolvedMethod) { if (methodSymbol->isInterface()) { isInterface = true; } else { if (trace()) traceMsg(comp(), ""PREX:        - Unresolved\n""); return; } } TR::Node *receiver = node->getChild(node->getFirstArgumentIndex()); if (receiver->getOpCode().isLoadDirect()) { existingInfo = getSuitableParmInfo(receiver); if (!existingInfo) { if (trace()) traceMsg(comp(), ""PREX:        - No parm info for receiver\n""); return; } receiverInfo = existingInfo; receiverFromParm = true; receiverSymbol = receiver->getSymbolReference()->getSymbol(); receiverParmOrdinal = receiverSymbol->getParmSymbol()->getOrdinal(); if (methodSymbol->isVirtual() || methodSymbol->isInterface()) { if (node->getSymbolReference() == getSymRefTab()->findObjectNewInstanceImplSymbol()) { if (trace()) traceMsg(comp(), ""PREX:        - newInstancePrototype\n""); return; } if (trace()) traceMsg(comp(), ""PREX:        Receiver is %p incoming Parm %d parmInfo %p\n"", receiver, receiverParmOrdinal, existingInfo); } } if (receiver->getSymbolReference() && receiver->getSymbolReference()->hasKnownObjectIndex() && !comp()->isOutOfProcessCompilation() ) { if (trace()) traceMsg(comp(), ""PREX:          Receiver is obj%d\n"", receiver->getSymbolReference()->getKnownObjectIndex()); receiverInfo->setKnownObjectIndex(receiver->getSymbolReference()->getKnownObjectIndex()); receiverInfo->setClassIsFixed(); TR::KnownObjectTable *knot = comp()->getKnownObjectTable(); { TR::ClassTableCriticalSection setClass(comp()->fe()); receiverInfo->setClass(TR::Compiler->cls.objectClass(comp(), knot->getPointer(receiver->getSymbolReference()->getKnownObjectIndex()))); } } if (resolvedMethod && receiverInfo->getClass() && !classIsCompatibleWithMethod(receiverInfo->getClass(), resolvedMethod)) return; if (methodSymbol->isComputed()) { #ifdef J9_PROJECT_SPECIFIC if (methodSymbol->getRecognizedMethod() == TR::java_lang_invoke_MethodHandle_invokeExact && receiverInfo->hasKnownObjectIndex()) specializeInvokeExactSymbol(node, receiverInfo->getKnownObjectIndex(), comp(), this); if (node->getSymbol()->castToMethodSymbol()->getMethod()->isArchetypeSpecimen()) return; #endif } else if (!isInterface && receiverInfo->classIsFixed()) { devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass()); } else if (!isInterface && receiverInfo->classIsCurrentlyFinal() && comp()->ilGenRequest().details().supportsInvalidation()) { TR_PersistentClassInfo* classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp()); bool canDevirtualize = true; if (comp()->getMethodHotness() == warm && classInfo && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) canDevirtualize = false; if (canDevirtualize && devirtualizeVirtualCall(node, treeTop, receiverInfo->getClass())) { if (trace()) traceMsg(comp(), ""devirtualize with assumption\n""); receiverInfo->setClassIsFixed(); if (_isOutermostMethod && receiverFromParm) { receiverSymbol->getParmSymbol()->setFixedType(receiverInfo->getClass()); } else if (receiverFromParm && comp()->getCurrentInlinedCallArgInfo()) { TR_PrexArgInfo *argInfo = comp()->getCurrentInlinedCallArgInfo(); TR_PrexArgument *arg = argInfo->get(receiverParmOrdinal); if (arg && !(arg->classIsFixed() && arg->getClass())) { arg->setClassIsFixed(receiverInfo->getClass()); } } TR_ASSERT(receiverInfo->getClass(), ""Currently final classes must have a valid class pointer""); bool inc = comp()->getCHTable()->recompileOnClassExtend(comp(), receiverInfo->getClass()); if (classInfo && inc) classInfo->incNumPrexAssumptions(); } } else if (receiverFromParm) { if (!isInterface && !resolvedMethod->virtualMethodIsOverridden() && !resolvedMethod->isAbstract()) { bool addAssumptions = false; TR_PersistentMethodInfo *callInfo = NULL; if (comp()->ilGenRequest().details().supportsInvalidation()) { addAssumptions = true; if ((comp()->getMethodHotness() == warm) && (callInfo = TR_PersistentMethodInfo::get(resolvedMethod)) && callInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) addAssumptions = false; } if (addAssumptions && performTransformation(comp(), ""%sdevirtualizing invoke [%p] on preexistent argument %d [%p]\n"", optDetailString(), node, receiverParmOrdinal, receiverSymbol)) { if (trace()) traceMsg(comp(), ""secs devirtualizing invoke on preexistent argument %d in %s\n"", receiverParmOrdinal, comp()->signature()); node->devirtualizeCall(treeTop); bool inc = comp()->getCHTable()->recompileOnMethodOverride(comp(), resolvedMethod); if (callInfo && inc) callInfo->incNumPrexAssumptions(); } } else if (receiverInfo->getClass()) { #ifdef J9_PROJECT_SPECIFIC TR::ClassTableCriticalSection processIndirectCall(comp()->fe()); TR::SymbolReference *symRef = node->getSymbolReference(); TR_PersistentCHTable * chTable = comp()->getPersistentInfo()->getPersistentCHTable(); TR::MethodSymbol *methSymbol = node->getSymbol()->getMethodSymbol(); if (methSymbol->isInterface() || methodSymbol) { TR_ResolvedMethod * method = NULL; bool newMethod = true; TR::Recompilation *recompInfo = comp()->getRecompilationInfo(); if (recompInfo && recompInfo->getMethodInfo()->getNumberOfInvalidations() >= 1 && !chTable->findSingleConcreteSubClass(receiverInfo->getClass(), comp())) { } else if (methSymbol->isInterface()) { if (comp()->getPersistentInfo()->getRuntimeAssumptionTable()->getAssumptionCount(RuntimeAssumptionOnClassExtend) < 100000) method = chTable->findSingleInterfaceImplementer(receiverInfo->getClass(), node->getSymbolReference()->getCPIndex(), node->getSymbolReference()->getOwningMethod(comp()), comp()); } else { if (resolvedMethod->isAbstract()) method = chTable->findSingleAbstractImplementer(receiverInfo->getClass(), symRef->getOffset(), node->getSymbolReference()->getOwningMethod(comp()), comp()); else if (!chTable->isOverriddenInThisHierarchy(resolvedMethod, receiverInfo->getClass(), symRef->getOffset(), comp())) { method = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), symRef->getOffset()); newMethod = false; } } if (method && !method->virtualMethodIsOverridden()) { TR_PersistentClassInfo *classInfo = comp()->getPersistentInfo()->getPersistentCHTable()->findClassInfoAfterLocking(receiverInfo->getClass(), comp()); bool addAssumptions = false; if (comp()->ilGenRequest().details().supportsInvalidation()) { addAssumptions = true; if ((comp()->getMethodHotness() == warm) && classInfo && classInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) addAssumptions = false; if (classInfo && addAssumptions) { TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory()); TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp()); ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses); for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext()) { if (subClassInfo->getNumPrexAssumptions() > comp()->getOptions()->getMaxNumPrexAssumptions()) { addAssumptions = false; break; } } } } if (addAssumptions && performTransformation(comp(), ""%sspecialize and devirtualize invoke [%p] based on only a single implementation for call on parameter %d [%p]\n"", optDetailString(), node, receiverParmOrdinal, receiverSymbol)) { if (newMethod || !method->isSameMethod(resolvedMethod)) { TR::SymbolReference *newSymRef = getSymRefTab()->findOrCreateMethodSymbol (symRef->getOwningMethodIndex(), -1, method, TR::MethodSymbol::Virtual); newSymRef->copyAliasSets(symRef, getSymRefTab()); int32_t offset = -1; if (methSymbol->isInterface()) offset = node->getSymbolReference()->getOwningMethod(comp())->getResolvedInterfaceMethodOffset(method->containingClass(), node->getSymbolReference()->getCPIndex()); else offset = symRef->getOffset(); newSymRef->setOffset(offset); node->setSymbolReference(newSymRef); } node->devirtualizeCall(treeTop); if (treeTop->getNode()->getOpCodeValue() == TR::ResolveCHK) TR::Node::recreate(treeTop->getNode(), TR::treetop); else if (treeTop->getNode()->getOpCodeValue() == TR::ResolveAndNULLCHK) TR::Node::recreate(treeTop->getNode(), TR::NULLCHK); bool doInc = comp()->getCHTable()->recompileOnNewClassExtend(comp(), receiverInfo->getClass()); if (classInfo) { classInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID()); if (doInc) classInfo->incNumPrexAssumptions(); TR_ScratchList<TR_PersistentClassInfo> subClasses(trMemory()); TR_ClassQueries::collectAllSubClasses(classInfo, &subClasses, comp()); ListIterator<TR_PersistentClassInfo> subClassesIt(&subClasses); for (TR_PersistentClassInfo *subClassInfo = subClassesIt.getFirst(); subClassInfo; subClassInfo = subClassesIt.getNext()) { TR_OpaqueClassBlock *subClass = (TR_OpaqueClassBlock *) subClassInfo->getClassId(); subClassInfo->setShouldNotBeNewlyExtended(comp()->getCompThreadID()); if (comp()->getCHTable()->recompileOnNewClassExtend(comp(), subClass)) subClassInfo->incNumPrexAssumptions(); } } _success = true; } else { return; } } else { return; } } #endif } } if (comp()->isPeekingMethod() && receiverInfo->getClass() && !isInterface) { TR::SymbolReference *symRef = node->getSymbolReference(); int32_t offset = symRef->getOffset(); TR_ResolvedMethod *originalResolvedMethod = resolvedMethod; TR_OpaqueClassBlock *originalClazz = originalResolvedMethod->containingClass(); bool canRefine = true; if (originalClazz != receiverInfo->getClass()) { TR_YesNoMaybe isInstance = fe()->isInstanceOf(originalClazz, receiverInfo->getClass(), true); if (isInstance == TR_yes) canRefine = false; isInstance = fe()->isInstanceOf(receiverInfo->getClass(), originalClazz, true); if (isInstance == TR_no) canRefine = false; } TR_ResolvedMethod *resolvedMethod = NULL; if (canRefine) resolvedMethod = symRef->getOwningMethod(comp())->getResolvedVirtualMethod(comp(), receiverInfo->getClass(), offset); if (resolvedMethod) { if (!originalResolvedMethod || !resolvedMethod->isSameMethod(originalResolvedMethod)) { TR::SymbolReference * newSymRef = _peekingSymRefTab->findOrCreateMethodSymbol( symRef->getOwningMethodIndex(), -1, resolvedMethod, TR::MethodSymbol::Virtual); newSymRef->copyAliasSets(symRef, _peekingSymRefTab); newSymRef->setOffset(offset); node->setSymbolReference(newSymRef); } } } #endif }"
"int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns) { struct kvm_lapic *apic; ASSERT(vcpu != NULL); apic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT); if (!apic) goto nomem; vcpu->arch.apic = apic; apic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT); if (!apic->regs) { printk(KERN_ERR ""malloc apic regs error for vcpu %x\n"", vcpu->vcpu_id); goto nomem_free_apic; } apic->vcpu = vcpu; hrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_HARD); apic->lapic_timer.timer.function = apic_timer_fn; if (timer_advance_ns == -1) { apic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT; lapic_timer_advance_dynamic = true; } else { apic->lapic_timer.timer_advance_ns = timer_advance_ns; lapic_timer_advance_dynamic = false; } static_branch_inc(&apic_sw_disabled.key);  kvm_iodevice_init(&apic->dev, &apic_mmio_ops); return 0; nomem_free_apic: kfree(apic); vcpu->arch.apic = NULL; nomem: return -ENOMEM; }"
"static cmsPipeline* DefaultICCintents(cmsContext       ContextID, cmsUInt32Number  nProfiles, cmsUInt32Number  TheIntents[], cmsHPROFILE      hProfiles[], cmsBool          BPC[], cmsFloat64Number AdaptationStates[], cmsUInt32Number  dwFlags) { cmsPipeline* Lut = NULL; cmsPipeline* Result; cmsHPROFILE hProfile; cmsMAT3 m; cmsVEC3 off; cmsColorSpaceSignature ColorSpaceIn, ColorSpaceOut, CurrentColorSpace; cmsProfileClassSignature ClassSig; cmsUInt32Number  i, Intent; if (nProfiles == 0) return NULL; Result = cmsPipelineAlloc(ContextID, 0, 0); if (Result == NULL) return NULL; CurrentColorSpace = cmsGetColorSpace(hProfiles[0]); for (i=0; i < nProfiles; i++) { cmsBool  lIsDeviceLink, lIsInput; hProfile      = hProfiles[i]; ClassSig      = cmsGetDeviceClass(hProfile); lIsDeviceLink = (ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ); if ((i == 0) && !lIsDeviceLink) { lIsInput = TRUE; } else { lIsInput      = (CurrentColorSpace != cmsSigXYZData) && (CurrentColorSpace != cmsSigLabData); } Intent        = TheIntents[i]; if (lIsInput || lIsDeviceLink) { ColorSpaceIn    = cmsGetColorSpace(hProfile); ColorSpaceOut   = cmsGetPCS(hProfile); } else { ColorSpaceIn    = cmsGetPCS(hProfile); ColorSpaceOut   = cmsGetColorSpace(hProfile); } if (!ColorSpaceIsCompatible(ColorSpaceIn, CurrentColorSpace)) { cmsSignalError(ContextID, cmsERROR_COLORSPACE_CHECK, ""ColorSpace mismatch""); goto Error; } if (lIsDeviceLink || ((ClassSig == cmsSigNamedColorClass) && (nProfiles == 1))) { Lut = _cmsReadDevicelinkLUT(hProfile, Intent); if (Lut == NULL) goto Error; if (ClassSig == cmsSigAbstractClass && i > 0) { if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error; } else { _cmsMAT3identity(&m); _cmsVEC3init(&off, 0, 0, 0); } if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error; } else { if (lIsInput) { Lut = _cmsReadInputLUT(hProfile, Intent); if (Lut == NULL) goto Error; } else { Lut = _cmsReadOutputLUT(hProfile, Intent); if (Lut == NULL) goto Error; if (!ComputeConversion(i, hProfiles, Intent, BPC[i], AdaptationStates[i], &m, &off)) goto Error; if (!AddConversion(Result, CurrentColorSpace, ColorSpaceIn, &m, &off)) goto Error; } } if (!cmsPipelineCat(Result, Lut)) goto Error; cmsPipelineFree(Lut); CurrentColorSpace = ColorSpaceOut; } return Result; Error: cmsPipelineFree(Lut); if (Result != NULL) cmsPipelineFree(Result); return NULL; cmsUNUSED_PARAMETER(dwFlags); }"
"void * ulfius_uri_logger (void * cls, const char * uri) { struct connection_info_struct * con_info = o_malloc (sizeof (struct connection_info_struct)); UNUSED(cls); if (con_info != NULL) { con_info->callback_first_iteration = 1; con_info->u_instance = NULL; u_map_init(&con_info->map_url_initial); con_info->request = o_malloc(sizeof(struct _u_request)); if (con_info->request == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info->request""); o_free(con_info); return NULL; } if (NULL == con_info->request || ulfius_init_request(con_info->request) != U_OK) { ulfius_clean_request_full(con_info->request); o_free(con_info); return NULL; } con_info->request->http_url = o_strdup(uri); if (o_strchr(uri, '?') != NULL) { con_info->request->url_path = o_strndup(uri, o_strchr(uri, '?') - uri); } else { con_info->request->url_path = o_strdup(uri); } if (con_info->request->http_url == NULL || con_info->request->url_path == NULL) { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info->request->http_url or con_info->request->url_path""); ulfius_clean_request_full(con_info->request); o_free(con_info); return NULL; } con_info->max_post_param_size = 0; } else { y_log_message(Y_LOG_LEVEL_ERROR, ""Ulfius - Error allocating memory for con_info""); } return con_info; }"
"const char* WinPKIErrorString(void) { static char error_string[64]; DWORD error_code = GetLastError(); if ((error_code >> 16) != 0x8009) return WindowsErrorString(); switch (error_code) { case NTE_BAD_UID: return ""Bad UID.""; case CRYPT_E_MSG_ERROR: return ""An error occurred while performing an operation on a cryptographic message.""; case CRYPT_E_UNKNOWN_ALGO: return ""Unknown cryptographic algorithm.""; case CRYPT_E_INVALID_MSG_TYPE: return ""Invalid cryptographic message type.""; case CRYPT_E_HASH_VALUE: return ""The hash value is not correct""; case CRYPT_E_ISSUER_SERIALNUMBER: return ""Invalid issuer and/or serial number.""; case CRYPT_E_BAD_LEN: return ""The length specified for the output data was insufficient.""; case CRYPT_E_BAD_ENCODE: return ""An error occurred during encode or decode operation.""; case CRYPT_E_FILE_ERROR: return ""An error occurred while reading or writing to a file.""; case CRYPT_E_NOT_FOUND: return ""Cannot find object or property.""; case CRYPT_E_EXISTS: return ""The object or property already exists.""; case CRYPT_E_NO_PROVIDER: return ""No provider was specified for the store or object.""; case CRYPT_E_DELETED_PREV: return ""The previous certificate or CRL context was deleted.""; case CRYPT_E_NO_MATCH: return ""Cannot find the requested object.""; case CRYPT_E_UNEXPECTED_MSG_TYPE: case CRYPT_E_NO_KEY_PROPERTY: case CRYPT_E_NO_DECRYPT_CERT: return ""Private key or certificate issue""; case CRYPT_E_BAD_MSG: return ""Not a cryptographic message.""; case CRYPT_E_NO_SIGNER: return ""The signed cryptographic message does not have a signer for the specified signer index.""; case CRYPT_E_REVOKED: return ""The certificate is revoked.""; case CRYPT_E_NO_REVOCATION_DLL: case CRYPT_E_NO_REVOCATION_CHECK: case CRYPT_E_REVOCATION_OFFLINE: case CRYPT_E_NOT_IN_REVOCATION_DATABASE: return ""Cannot check certificate revocation.""; case CRYPT_E_INVALID_NUMERIC_STRING: case CRYPT_E_INVALID_PRINTABLE_STRING: case CRYPT_E_INVALID_IA5_STRING: case CRYPT_E_INVALID_X500_STRING: case  CRYPT_E_NOT_CHAR_STRING: return ""Invalid string.""; case CRYPT_E_SECURITY_SETTINGS: return ""The cryptographic operation failed due to a local security option setting.""; case CRYPT_E_NO_VERIFY_USAGE_CHECK: case CRYPT_E_VERIFY_USAGE_OFFLINE: return ""Cannot complete usage check.""; case CRYPT_E_NO_TRUSTED_SIGNER: return ""None of the signers of the cryptographic message or certificate trust list is trusted.""; default: static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code); return error_string; } }"
"Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){ Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0); if( p ){ struct SrcList_item *pItem = &pSrc->a[iSrc]; p->y.pTab = pItem->pTab; p->iTable = pItem->iCursor; if( p->y.pTab->iPKey==iCol ){ p->iColumn = -1; }else{ p->iColumn = (ynVar)iCol; testcase( iCol==BMS ); testcase( iCol==BMS-1 ); pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol); } } return p; }"
"void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) { if (len > outHeader->nAllocLen) { ALOGE(""memset buffer too small: got %lu, expected %zu"", outHeader->nAllocLen, len); android_errorWriteLog(0x534e4554, ""29422022""); notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL); mSignalledError = true; return NULL; } return memset(outHeader->pBuffer, c, len); }"
"static void ok_mo_decode2(ok_mo_decoder *decoder) { ok_mo *mo = decoder->mo; uint8_t header[20]; if (!ok_read(decoder, header, sizeof(header))) { return; } uint32_t magic = read32(header, true); bool little_endian; if (magic == 0x950412de) { little_endian = true; } else if (magic == 0xde120495) { little_endian = false; } else { ok_mo_error(mo, ""Not a gettext MO file""); return; } const uint16_t major_version = read16(header + 4, little_endian); mo->num_strings = read32(header + 8, little_endian); const uint32_t key_offset = read32(header + 12, little_endian); const uint32_t value_offset = read32(header + 16, little_endian); if (!(major_version == 0 || major_version == 1)) { ok_mo_error(mo, ""Unsupported gettext MO file. Only version 0 or 1 supported""); return; } if (mo->num_strings == 0) { ok_mo_error(mo, ""No strings found""); return; } mo->strings = calloc(mo->num_strings, sizeof(struct ok_mo_string)); decoder->key_offset_buffer = malloc(8 * mo->num_strings); decoder->value_offset_buffer = malloc(8 * mo->num_strings); if (!mo->strings || !decoder->key_offset_buffer || !decoder->value_offset_buffer) { ok_mo_error(mo, ""Couldn't allocate arrays""); return; } size_t tell = sizeof(header); if (!ok_seek(decoder, (long)(key_offset - tell))) { return; } if (!ok_read(decoder, decoder->key_offset_buffer, 8 * mo->num_strings)) { ok_mo_error(mo, ""Couldn't get key offsets""); return; } tell = key_offset + 8 * mo->num_strings; if (!ok_seek(decoder, (long)(value_offset - tell))) { return; } if (!ok_read(decoder, decoder->value_offset_buffer, 8 * mo->num_strings)) { ok_mo_error(mo, ""Couldn't get value offsets""); return; } tell = value_offset + 8 * mo->num_strings; for (uint32_t i = 0; i < mo->num_strings; i++) { uint32_t length = read32(decoder->key_offset_buffer + 8 * i, little_endian); uint32_t offset = read32(decoder->key_offset_buffer + 8 * i + 4, little_endian); mo->strings[i].key = malloc(length + 1); if (!mo->strings[i].key) { ok_mo_error(mo, ""Couldn't allocate strings""); return; } if (!ok_seek(decoder, (long)(offset - tell))) { return; } if (!ok_read(decoder, (uint8_t *)mo->strings[i].key, length + 1)) { return; } tell = offset + length + 1; } for (uint32_t i = 0; i < mo->num_strings; i++) { uint32_t length = read32(decoder->value_offset_buffer + 8 * i, little_endian); uint32_t offset = read32(decoder->value_offset_buffer + 8 * i + 4, little_endian); mo->strings[i].value = malloc(length + 1); if (!mo->strings[i].value) { ok_mo_error(mo, ""Couldn't allocate strings""); return; } if (!ok_seek(decoder, (long)(offset - tell))) { return; } if (!ok_read(decoder, (uint8_t *)mo->strings[i].value, length + 1)) { return; } mo->strings[i].num_plural_variants = 0; const char *ch = mo->strings[i].value; const char *end = mo->strings[i].value + length; while (ch < end) { if (*ch++ == 0) { mo->strings[i].num_plural_variants++; } } tell = offset + length + 1; } }"
"Reprog *regcomp(const char *pattern, int cflags, const char **errorp) { struct cstate g; Renode *node; Reinst *split, *jump; int i; g.prog = malloc(sizeof (Reprog)); g.pstart = g.pend = malloc(sizeof (Renode) * strlen(pattern) * 2); if (setjmp(g.kaboom)) { if (errorp) *errorp = g.error; free(g.pstart); free(g.prog); return NULL; } g.source = pattern; g.ncclass = 0; g.nsub = 1; for (i = 0; i < MAXSUB; ++i) g.sub[i] = 0; g.prog->flags = cflags; next(&g); node = parsealt(&g); if (g.lookahead == ')') die(&g, ""unmatched ')'""); if (g.lookahead != 0) die(&g, ""syntax error""); g.prog->nsub = g.nsub; g.prog->start = g.prog->end = malloc((count(node) + 6) * sizeof (Reinst)); split = emit(g.prog, I_SPLIT); split->x = split + 3; split->y = split + 1; emit(g.prog, I_ANYNL); jump = emit(g.prog, I_JUMP); jump->x = split; emit(g.prog, I_LPAR); compile(g.prog, node); emit(g.prog, I_RPAR); emit(g.prog, I_END); #ifdef TEST dumpnode(node); putchar('\n'); dumpprog(g.prog); #endif free(g.pstart); if (errorp) *errorp = NULL; return g.prog; }"
"static int instance_rmdir(struct inode *inode, struct dentry *dentry) { struct dentry *parent; int ret; parent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias); if (WARN_ON_ONCE(parent != trace_instance_dir)) return -ENOENT; mutex_unlock(&dentry->d_inode->i_mutex); mutex_unlock(&inode->i_mutex); ret = instance_delete(dentry->d_iname); mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT); mutex_lock(&dentry->d_inode->i_mutex); return ret; }"
"int ext4_xattr_ibody_set(handle_t *handle, struct inode *inode, struct ext4_xattr_info *i, struct ext4_xattr_ibody_find *is) { struct ext4_xattr_ibody_header *header; struct ext4_xattr_search *s = &is->s; int error; if (EXT4_I(inode)->i_extra_isize == 0) return -ENOSPC; error = ext4_xattr_set_entry(i, s, handle, inode, false ); if (error) return error; header = IHDR(inode, ext4_raw_inode(&is->iloc)); if (!IS_LAST_ENTRY(s->first)) { header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC); ext4_set_inode_state(inode, EXT4_STATE_XATTR); } else { header->h_magic = cpu_to_le32(0); ext4_clear_inode_state(inode, EXT4_STATE_XATTR); } return 0; }"
"FT_LOCAL_DEF( FT_Error ) sfnt_init_face( FT_Stream      stream, TT_Face        face, FT_Int         face_instance_index, FT_Int         num_params, FT_Parameter*  params ) { FT_Error      error; FT_Memory     memory = face->root.memory; FT_Library    library = face->root.driver->root.library; SFNT_Service  sfnt; FT_Int        face_index; FT_UNUSED( num_params ); FT_UNUSED( params ); sfnt = (SFNT_Service)face->sfnt; if ( !sfnt ) { sfnt = (SFNT_Service)FT_Get_Module_Interface( library, ""sfnt"" ); if ( !sfnt ) { FT_ERROR(( ""sfnt_init_face: cannot access `sfnt' module\n"" )); return FT_THROW( Missing_Module ); } face->sfnt       = sfnt; face->goto_table = sfnt->goto_table; } FT_FACE_FIND_GLOBAL_SERVICE( face, face->psnames, POSTSCRIPT_CMAPS ); #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT if ( !face->mm ) { FT_Module  tt_module = FT_Get_Module( library, ""truetype"" ); face->mm = ft_module_get_service( tt_module, FT_SERVICE_ID_MULTI_MASTERS, 0 ); } if ( !face->var ) { FT_Module  tt_module = FT_Get_Module( library, ""truetype"" ); face->var = ft_module_get_service( tt_module, FT_SERVICE_ID_METRICS_VARIATIONS, 0 ); } #endif FT_TRACE2(( ""SFNT driver\n"" )); error = sfnt_open_font( stream, face ); if ( error ) return error; stream = face->root.stream; FT_TRACE2(( ""sfnt_init_face: %08p, %d\n"", face, face_instance_index )); face_index = FT_ABS( face_instance_index ) & 0xFFFF; if ( face_instance_index < 0 ) face_index--; if ( face_index >= face->ttc_header.count ) { if ( face_instance_index >= 0 ) return FT_THROW( Invalid_Argument ); else face_index = 0; } if ( FT_STREAM_SEEK( face->ttc_header.offsets[face_index] ) ) return error; error = sfnt->load_font_dir( face, stream ); if ( error ) return error; #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT { FT_ULong  fvar_len; FT_ULong  version; FT_ULong  offset; FT_UShort  num_axes; FT_UShort  axis_size; FT_UShort  num_instances; FT_UShort  instance_size; FT_Int  instance_index; FT_Byte*  default_values  = NULL; FT_Byte*  instance_values = NULL; face->is_default_instance = 1; instance_index = FT_ABS( face_instance_index ) >> 16; if ( face->goto_table( face, TTAG_fvar, stream, &fvar_len ) || fvar_len < 20                                          || FT_READ_ULONG( version )                               || FT_READ_USHORT( offset )                               || FT_STREAM_SKIP( 2 )                      || FT_READ_USHORT( num_axes )                             || FT_READ_USHORT( axis_size )                            || FT_READ_USHORT( num_instances )                        || FT_READ_USHORT( instance_size )                        ) { version       = 0; offset        = 0; num_axes      = 0; axis_size     = 0; num_instances = 0; instance_size = 0; } if ( version != 0x00010000UL                    || axis_size != 20                            || num_axes == 0                              || num_axes > 0x3FFE                          || !( instance_size == 4 + 4 * num_axes || instance_size == 6 + 4 * num_axes )     || num_instances > 0x7EFF                     || offset                          + axis_size * num_axes          + instance_size * num_instances > fvar_len ) num_instances = 0; else face->variation_support |= TT_FACE_FLAG_VAR_FVAR; if ( !face->goto_table( face, TTAG_CFF, stream, 0 ) ) num_instances = 0; if ( !( FT_ALLOC( default_values, num_axes * 2 )  || FT_ALLOC( instance_values, num_axes * 2 ) ) ) { FT_ULong  array_start = FT_STREAM_POS() - 16 + offset; FT_ULong  default_value_offset, instance_offset; FT_Byte*  p; FT_UInt   i; default_value_offset = array_start + 8; p                    = default_values; for ( i = 0; i < num_axes; i++ ) { (void)FT_STREAM_READ_AT( default_value_offset, p, 2 ); default_value_offset += axis_size; p                    += 2; } instance_offset = array_start + axis_size * num_axes + 4; for ( i = 0; i < num_instances; i++ ) { (void)FT_STREAM_READ_AT( instance_offset, instance_values, num_axes * 2 ); if ( !ft_memcmp( default_values, instance_values, num_axes * 2 ) ) break; instance_offset += instance_size; } if ( i == num_instances ) { num_instances++; } } FT_FREE( default_values ); FT_FREE( instance_values ); if ( instance_index > num_instances ) { if ( face_instance_index >= 0 ) return FT_THROW( Invalid_Argument ); else num_instances = 0; } face->root.style_flags = (FT_Long)num_instances << 16; } #endif face->root.num_faces  = face->ttc_header.count; face->root.face_index = face_instance_index; return error; }"
"static int privsep_preauth(Authctxt *authctxt) { int status, r; pid_t pid; struct ssh_sandbox *box = NULL; pmonitor = monitor_init(); pmonitor->m_pkex = &active_state->kex; if (use_privsep == PRIVSEP_ON) box = ssh_sandbox_init(); pid = fork(); if (pid == -1) { fatal(""fork of unprivileged child failed""); } else if (pid != 0) { debug2(""Network child is on pid %ld"", (long)pid); pmonitor->m_pid = pid; if (have_agent) { r = ssh_get_authentication_socket(&auth_sock); if (r != 0) { error(""Could not get agent socket: %s"", ssh_err(r)); have_agent = 0; } } if (box != NULL) ssh_sandbox_parent_preauth(box, pid); monitor_child_preauth(authctxt, pmonitor); monitor_sync(pmonitor); while (waitpid(pid, &status, 0) < 0) { if (errno == EINTR) continue; pmonitor->m_pid = -1; fatal(""%s: waitpid: %s"", __func__, strerror(errno)); } privsep_is_preauth = 0; pmonitor->m_pid = -1; if (WIFEXITED(status)) { if (WEXITSTATUS(status) != 0) fatal(""%s: preauth child exited with status %d"", __func__, WEXITSTATUS(status)); } else if (WIFSIGNALED(status)) fatal(""%s: preauth child terminated by signal %d"", __func__, WTERMSIG(status)); if (box != NULL) ssh_sandbox_parent_finish(box); return 1; } else { close(pmonitor->m_sendfd); close(pmonitor->m_log_recvfd); set_log_handler(mm_log_handler, pmonitor); privsep_preauth_child(); setproctitle(""%s"", ""[net]""); if (box != NULL) ssh_sandbox_child(box); return 0; } }"
"int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags) { struct sock *sk = sock->sk; int err; if (addr_len < sizeof(uaddr->sa_family)) return -EINVAL; if (uaddr->sa_family == AF_UNSPEC) return sk->sk_prot->disconnect(sk, flags); if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) { err = sk->sk_prot->pre_connect(sk, uaddr, addr_len); if (err) return err; } if (data_race(!inet_sk(sk)->inet_num) && inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->connect(sk, uaddr, addr_len); }"
"void isis_notif_version_skew(const struct isis_circuit *circuit, uint8_t version, const char *raw_pdu, size_t raw_pdu_len) { const char *xpath = ""/frr-isisd:version-skew""; struct list *arguments = yang_data_list_new(); char xpath_arg[XPATH_MAXLEN]; struct yang_data *data; struct isis_area *area = circuit->area; notif_prep_instance_hdr(xpath, area, ""default"", arguments); notif_prepr_iface_hdr(xpath, circuit, arguments); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/protocol-version"", xpath); data = yang_data_new_uint8(xpath_arg, version); listnode_add(arguments, data); snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath); data = yang_data_new(xpath_arg, raw_pdu); listnode_add(arguments, data); hook_call(isis_hook_version_skew, circuit, version, raw_pdu, raw_pdu_len); nb_notification_send(xpath, arguments); }"
"static void psi_trigger_destroy(struct kref *ref) { struct psi_trigger *t = container_of(ref, struct psi_trigger, refcount); struct psi_group *group = t->group; struct task_struct *task_to_destroy = NULL; if (static_branch_likely(&psi_disabled)) return; wake_up_interruptible(&t->event_wait); mutex_lock(&group->trigger_lock); if (!list_empty(&t->node)) { struct psi_trigger *tmp; u64 period = ULLONG_MAX; list_del(&t->node); group->nr_triggers[t->state]--; if (!group->nr_triggers[t->state]) group->poll_states &= ~(1 << t->state); list_for_each_entry(tmp, &group->triggers, node) period = min(period, div_u64(tmp->win.size, UPDATES_PER_WINDOW)); group->poll_min_period = period; if (group->poll_states == 0) { group->polling_until = 0; task_to_destroy = rcu_dereference_protected( group->poll_task, lockdep_is_held(&group->trigger_lock)); rcu_assign_pointer(group->poll_task, NULL); del_timer(&group->poll_timer); } } mutex_unlock(&group->trigger_lock); synchronize_rcu(); if (task_to_destroy) { kthread_stop(task_to_destroy); } kfree(t); }"
"int ff_mpeg4_decode_picture_header(Mpeg4DecContext *ctx, GetBitContext *gb) { MpegEncContext *s = &ctx->m; unsigned startcode, v; int ret; int vol = 0; align_get_bits(gb); if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8) s->avctx->bits_per_raw_sample = 0; if (s->codec_tag == AV_RL32(""WV1F"") && show_bits(gb, 24) == 0x575630) { skip_bits(gb, 24); if (get_bits(gb, 8) == 0xF0) goto end; } startcode = 0xff; for (;;) { if (get_bits_count(gb) >= gb->size_in_bits) { if (gb->size_in_bits == 8 && (ctx->divx_version >= 0 || ctx->xvid_build >= 0) || s->codec_tag == AV_RL32(""QMP4"")) { av_log(s->avctx, AV_LOG_VERBOSE, ""frame skip %d\n"", gb->size_in_bits); return FRAME_SKIPPED;              } else return AVERROR_INVALIDDATA;          } v = get_bits(gb, 8); startcode = ((startcode << 8) | v) & 0xffffffff; if ((startcode & 0xFFFFFF00) != 0x100) continue;   if (s->avctx->debug & FF_DEBUG_STARTCODE) { av_log(s->avctx, AV_LOG_DEBUG, ""startcode: %3X "", startcode); if (startcode <= 0x11F) av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Start""); else if (startcode <= 0x12F) av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Layer Start""); else if (startcode <= 0x13F) av_log(s->avctx, AV_LOG_DEBUG, ""Reserved""); else if (startcode <= 0x15F) av_log(s->avctx, AV_LOG_DEBUG, ""FGS bp start""); else if (startcode <= 0x1AF) av_log(s->avctx, AV_LOG_DEBUG, ""Reserved""); else if (startcode == 0x1B0) av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq Start""); else if (startcode == 0x1B1) av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Seq End""); else if (startcode == 0x1B2) av_log(s->avctx, AV_LOG_DEBUG, ""User Data""); else if (startcode == 0x1B3) av_log(s->avctx, AV_LOG_DEBUG, ""Group of VOP start""); else if (startcode == 0x1B4) av_log(s->avctx, AV_LOG_DEBUG, ""Video Session Error""); else if (startcode == 0x1B5) av_log(s->avctx, AV_LOG_DEBUG, ""Visual Object Start""); else if (startcode == 0x1B6) av_log(s->avctx, AV_LOG_DEBUG, ""Video Object Plane start""); else if (startcode == 0x1B7) av_log(s->avctx, AV_LOG_DEBUG, ""slice start""); else if (startcode == 0x1B8) av_log(s->avctx, AV_LOG_DEBUG, ""extension start""); else if (startcode == 0x1B9) av_log(s->avctx, AV_LOG_DEBUG, ""fgs start""); else if (startcode == 0x1BA) av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object start""); else if (startcode == 0x1BB) av_log(s->avctx, AV_LOG_DEBUG, ""FBA Object Plane start""); else if (startcode == 0x1BC) av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object start""); else if (startcode == 0x1BD) av_log(s->avctx, AV_LOG_DEBUG, ""Mesh Object Plane start""); else if (startcode == 0x1BE) av_log(s->avctx, AV_LOG_DEBUG, ""Still Texture Object start""); else if (startcode == 0x1BF) av_log(s->avctx, AV_LOG_DEBUG, ""Texture Spatial Layer start""); else if (startcode == 0x1C0) av_log(s->avctx, AV_LOG_DEBUG, ""Texture SNR Layer start""); else if (startcode == 0x1C1) av_log(s->avctx, AV_LOG_DEBUG, ""Texture Tile start""); else if (startcode == 0x1C2) av_log(s->avctx, AV_LOG_DEBUG, ""Texture Shape Layer start""); else if (startcode == 0x1C3) av_log(s->avctx, AV_LOG_DEBUG, ""stuffing start""); else if (startcode <= 0x1C5) av_log(s->avctx, AV_LOG_DEBUG, ""reserved""); else if (startcode <= 0x1FF) av_log(s->avctx, AV_LOG_DEBUG, ""System start""); av_log(s->avctx, AV_LOG_DEBUG, "" at %d\n"", get_bits_count(gb)); } if (startcode >= 0x120 && startcode <= 0x12F) { if (vol) { av_log(s->avctx, AV_LOG_WARNING, ""Ignoring multiple VOL headers\n""); continue; } vol++; if ((ret = decode_vol_header(ctx, gb)) < 0) return ret; } else if (startcode == USER_DATA_STARTCODE) { decode_user_data(ctx, gb); } else if (startcode == GOP_STARTCODE) { mpeg4_decode_gop_header(s, gb); } else if (startcode == VOS_STARTCODE) { int profile, level; mpeg4_decode_profile_level(s, gb, &profile, &level); if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO && (level > 0 && level < 9)) { s->studio_profile = 1; next_start_code_studio(gb); extension_and_user_data(s, gb, 0); } else if (s->studio_profile) { avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n""); return AVERROR_PATCHWELCOME; } s->avctx->profile = profile; s->avctx->level   = level; } else if (startcode == VISUAL_OBJ_STARTCODE) { if (s->studio_profile) { if ((ret = decode_studiovisualobject(ctx, gb)) < 0) return ret; } else mpeg4_decode_visual_object(s, gb); } else if (startcode == VOP_STARTCODE) { break; } align_get_bits(gb); startcode = 0xff; } end: if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY) s->low_delay = 1; s->avctx->has_b_frames = !s->low_delay; if (s->studio_profile) { av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO); if (!s->avctx->bits_per_raw_sample) { av_log(s->avctx, AV_LOG_ERROR, ""Missing VOL header\n""); return AVERROR_INVALIDDATA; } return decode_studio_vop_header(ctx, gb); } else return decode_vop_header(ctx, gb); }"
"void *malloc_wrapper(size_t size, void *caller) { void *ptr = NULL; #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_lock(); #endif #ifdef MBED_HEAP_STATS_ENABLED malloc_stats_mutex->lock(); alloc_info_t *alloc_info = (alloc_info_t *)SUPER_MALLOC(size + sizeof(alloc_info_t)); if (alloc_info != NULL) { alloc_info->size = size; alloc_info->signature = MBED_HEAP_STATS_SIGNATURE; ptr = (void *)(alloc_info + 1); heap_stats.current_size += size; heap_stats.total_size += size; heap_stats.alloc_cnt += 1; if (heap_stats.current_size > heap_stats.max_size) { heap_stats.max_size = heap_stats.current_size; } heap_stats.overhead_size += MALLOC_HEAP_TOTAL_SIZE(MALLOC_HEADER_PTR(alloc_info)) - size; } else { heap_stats.alloc_fail_cnt += 1; } malloc_stats_mutex->unlock(); #else     ptr = SUPER_MALLOC(size); #endif #ifdef MBED_MEM_TRACING_ENABLED mbed_mem_trace_malloc(ptr, size, caller); mbed_mem_trace_unlock(); #endif     return ptr; }"
"static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_Obj *obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) { Jsi_ValueMakeNumber(interp, ret, 0); return JSI_OK; } obj = _this->d.obj; int argc = Jsi_ValueGetLength(interp, args); int curlen = Jsi_ObjGetLength(interp, obj); if (curlen < 0) { Jsi_ObjSetLength(interp, obj, 0); } int i; for (i = 0; i < argc; ++i) { Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i); if (!ov) { Jsi_LogBug(""Arguments Error""); ov = Jsi_ValueNew(interp); } Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0); } Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj)); return JSI_OK; }"
"int MMDB_vget_value(MMDB_entry_s *const start, MMDB_entry_data_s *const entry_data, va_list va_path) { int length = path_length(va_path); const char *path_elem; int i = 0; MAYBE_CHECK_SIZE_OVERFLOW(length, SIZE_MAX / sizeof(const char *) - 1, MMDB_INVALID_METADATA_ERROR); const char **path = malloc((length + 1) * sizeof(const char *)); if (NULL == path) { return MMDB_OUT_OF_MEMORY_ERROR; } while (NULL != (path_elem = va_arg(va_path, char *))) { path[i] = path_elem; i++; } path[i] = NULL; int status = MMDB_aget_value(start, entry_data, path); free((char **)path); return status; }"
"void native_tss_update_io_bitmap(void) { struct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw); struct thread_struct *t = &current->thread; u16 *base = &tss->x86_tss.io_bitmap_base; if (!test_thread_flag(TIF_IO_BITMAP)) { tss_invalidate_io_bitmap(tss); return; } if (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) { *base = IO_BITMAP_OFFSET_VALID_ALL; } else { struct io_bitmap *iobm = t->io_bitmap; if (tss->io_bitmap.prev_sequence != iobm->sequence) tss_copy_io_bitmap(tss, iobm); *base = IO_BITMAP_OFFSET_VALID_MAP; } refresh_tss_limit(); }"
void flash_option_bytes_init(int boot_from_dfu) { uint32_t val = 0xfffff8aa; if (boot_from_dfu){ val &= ~(1<<27);     } else { if (solo_is_locked()) { val = 0xfffff8cc; } } val &= ~(1<<26);     val &= ~(1<<25);     val &= ~(1<<24);  if (FLASH->OPTR == val) { return; } __disable_irq(); while (FLASH->SR & (1<<16)) ; flash_unlock(); if (FLASH->CR & (1<<30)) { FLASH->OPTKEYR = 0x08192A3B; FLASH->OPTKEYR = 0x4C5D6E7F; } FLASH->OPTR =val; FLASH->CR |= (1<<17); while (FLASH->SR & (1<<16)) ; flash_lock(); __enable_irq(); }
"struct xt_table *xt_register_table(struct net *net, const struct xt_table *input_table, struct xt_table_info *bootstrap, struct xt_table_info *newinfo) { int ret; struct xt_table_info *private; struct xt_table *t, *table; table = kmemdup(input_table, sizeof(struct xt_table), GFP_KERNEL); if (!table) { ret = -ENOMEM; goto out; } mutex_lock(&xt[table->af].mutex); list_for_each_entry(t, &net->xt.tables[table->af], list) { if (strcmp(t->name, table->name) == 0) { ret = -EEXIST; goto unlock; } } table->private = bootstrap; if (!xt_replace_table(table, 0, newinfo, &ret)) goto unlock; private = table->private; pr_debug(""table->private->number = %u\n"", private->number); private->initial_entries = private->number; list_add(&table->list, &net->xt.tables[table->af]); mutex_unlock(&xt[table->af].mutex); return table; unlock: mutex_unlock(&xt[table->af].mutex); kfree(table); out: return ERR_PTR(ret); }"
"static bool vtable_is_value_in_text_section(RVTableContext *context, ut64 curAddress, ut64 *value) { ut64 curAddressValue; if (!context->read_addr (context->anal, curAddress, &curAddressValue)) { return false; } bool ret = vtable_addr_in_text_section (context, curAddressValue); if (value) { *value = curAddressValue; } return ret; }"
"int RLByteStream::getBytes( void* buffer, int count ) { uchar*  data = (uchar*)buffer; int readed = 0; assert( count >= 0 ); while( count > 0 ) { int l; for(;;) { l = (int)(m_end - m_current); if( l > count ) l = count; if( l > 0 ) break; readBlock(); } memcpy( data, m_current, l ); m_current += l; data += l; count -= l; readed += l; } return readed; }"
"PIX * pixBlockconvGrayUnnormalized(PIX     *pixs, l_int32  wc, l_int32  hc) { l_int32    i, j, w, h, d, wpla, wpld, jmax; l_uint32  *linemina, *linemaxa, *lined, *dataa, *datad; PIX       *pixsb, *pixacc, *pixd; PROCNAME(""pixBlockconvGrayUnnormalized""); if (!pixs) return (PIX *)ERROR_PTR(""pixs not defined"", procName, NULL); pixGetDimensions(pixs, &w, &h, &d); if (d != 8) return (PIX *)ERROR_PTR(""pixs not 8 bpp"", procName, NULL); if (wc < 0) wc = 0; if (hc < 0) hc = 0; if (w < 2 * wc + 1 || h < 2 * hc + 1) { wc = L_MIN(wc, (w - 1) / 2); hc = L_MIN(hc, (h - 1) / 2); L_WARNING(""kernel too large; reducing!\n"", procName); L_INFO(""wc = %d, hc = %d\n"", procName, wc, hc); } if (wc == 0 && hc == 0)    return pixCopy(NULL, pixs); if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL) return (PIX *)ERROR_PTR(""pixsb not made"", procName, NULL); pixacc = pixBlockconvAccum(pixsb); pixDestroy(&pixsb); if (!pixacc) return (PIX *)ERROR_PTR(""pixacc not made"", procName, NULL); if ((pixd = pixCreate(w, h, 32)) == NULL) { pixDestroy(&pixacc); return (PIX *)ERROR_PTR(""pixd not made"", procName, NULL); } wpla = pixGetWpl(pixacc); wpld = pixGetWpl(pixd); datad = pixGetData(pixd); dataa = pixGetData(pixacc); for (i = 0; i < h; i++) { lined = datad + i * wpld; linemina = dataa + i * wpla; linemaxa = dataa + (i + 2 * hc + 1) * wpla; for (j = 0; j < w; j++) { jmax = j + 2 * wc + 1; lined[j] = linemaxa[jmax] - linemaxa[j] - linemina[jmax] + linemina[j]; } } pixDestroy(&pixacc); return pixd; }"
"static int dwc3_qcom_probe(struct platform_device *pdev) { struct device_node*np = pdev->dev.of_node; struct device*dev = &pdev->dev; struct dwc3_qcom*qcom; struct resource*res, *parent_res = NULL; intret, i; boolignore_pipe_clk; qcom = devm_kzalloc(&pdev->dev, sizeof(*qcom), GFP_KERNEL); if (!qcom) return -ENOMEM; platform_set_drvdata(pdev, qcom); qcom->dev = &pdev->dev; if (has_acpi_companion(dev)) { qcom->acpi_pdata = acpi_device_get_match_data(dev); if (!qcom->acpi_pdata) { dev_err(&pdev->dev, ""no supporting ACPI device data\n""); return -EINVAL; } } qcom->resets = devm_reset_control_array_get_optional_exclusive(dev); if (IS_ERR(qcom->resets)) { ret = PTR_ERR(qcom->resets); dev_err(&pdev->dev, ""failed to get resets, err=%d\n"", ret); return ret; } ret = reset_control_assert(qcom->resets); if (ret) { dev_err(&pdev->dev, ""failed to assert resets, err=%d\n"", ret); return ret; } usleep_range(10, 1000); ret = reset_control_deassert(qcom->resets); if (ret) { dev_err(&pdev->dev, ""failed to deassert resets, err=%d\n"", ret); goto reset_assert; } ret = dwc3_qcom_clk_init(qcom, of_clk_get_parent_count(np)); if (ret) { dev_err(dev, ""failed to get clocks\n""); goto reset_assert; } res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (np) { parent_res = res; } else { parent_res = kmemdup(res, sizeof(struct resource), GFP_KERNEL); if (!parent_res) return -ENOMEM; parent_res->start = res->start + qcom->acpi_pdata->qscratch_base_offset; parent_res->end = parent_res->start + qcom->acpi_pdata->qscratch_base_size; if (qcom->acpi_pdata->is_urs) { qcom->urs_usb = dwc3_qcom_create_urs_usb_platdev(dev); if (!qcom->urs_usb) { dev_err(dev, ""failed to create URS USB platdev\n""); return -ENODEV; } } } qcom->qscratch_base = devm_ioremap_resource(dev, parent_res); if (IS_ERR(qcom->qscratch_base)) { ret = PTR_ERR(qcom->qscratch_base); goto clk_disable; } ret = dwc3_qcom_setup_irq(pdev); if (ret) { dev_err(dev, ""failed to setup IRQs, err=%d\n"", ret); goto clk_disable; } ignore_pipe_clk = device_property_read_bool(dev, ""qcom,select-utmi-as-pipe-clk""); if (ignore_pipe_clk) dwc3_qcom_select_utmi_clk(qcom); if (np) ret = dwc3_qcom_of_register_core(pdev); else ret = dwc3_qcom_acpi_register_core(pdev); if (ret) { dev_err(dev, ""failed to register DWC3 Core, err=%d\n"", ret); goto depopulate; } ret = dwc3_qcom_interconnect_init(qcom); if (ret) goto depopulate; qcom->mode = usb_get_dr_mode(&qcom->dwc3->dev); if (qcom->mode == USB_DR_MODE_PERIPHERAL) dwc3_qcom_vbus_override_enable(qcom, true); ret = dwc3_qcom_register_extcon(qcom); if (ret) goto interconnect_exit; device_init_wakeup(&pdev->dev, 1); qcom->is_suspended = false; pm_runtime_set_active(dev); pm_runtime_enable(dev); pm_runtime_forbid(dev); return 0; interconnect_exit: dwc3_qcom_interconnect_exit(qcom); depopulate: if (np) of_platform_depopulate(&pdev->dev); else platform_device_put(pdev); clk_disable: for (i = qcom->num_clocks - 1; i >= 0; i--) { clk_disable_unprepare(qcom->clks[i]); clk_put(qcom->clks[i]); } reset_assert: reset_control_assert(qcom->resets); return ret; }"
"int LibRaw::unpack(void) { CHECK_ORDER_HIGH(LIBRAW_PROGRESS_LOAD_RAW); CHECK_ORDER_LOW(LIBRAW_PROGRESS_IDENTIFY); try { if(!libraw_internal_data.internal_data.input) return LIBRAW_INPUT_CLOSED; RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,0,2); if (O.shot_select >= P1.raw_count) return LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE; if(!load_raw) return LIBRAW_UNSPECIFIED_ERROR; if(imgdata.image) { free(imgdata.image); imgdata.image = 0; } if(imgdata.rawdata.raw_alloc) { free(imgdata.rawdata.raw_alloc); imgdata.rawdata.raw_alloc = 0; } if (libraw_internal_data.unpacker_data.meta_length) { libraw_internal_data.internal_data.meta_data = (char *) malloc (libraw_internal_data.unpacker_data.meta_length); merror (libraw_internal_data.internal_data.meta_data, ""LibRaw::unpack()""); } libraw_decoder_info_t decoder_info; get_decoder_info(&decoder_info); int save_iwidth = S.iwidth, save_iheight = S.iheight, save_shrink = IO.shrink; int rwidth = S.raw_width, rheight = S.raw_height; if( !IO.fuji_width) { if(rwidth < S.width + S.left_margin) rwidth = S.width + S.left_margin; if(rheight < S.height + S.top_margin) rheight = S.height + S.top_margin; } imgdata.rawdata.raw_image = 0; imgdata.rawdata.color4_image = 0; imgdata.rawdata.color3_image = 0; imgdata.rawdata.float_image = 0; imgdata.rawdata.float3_image = 0; #ifdef USE_DNGSDK if(imgdata.idata.dng_version && dnghost && valid_for_dngsdk() && load_raw != &LibRaw::pentax_4shot_load_raw) { int rr = try_dngsdk(); } #endif #ifdef USE_RAWSPEED if(!raw_was_read()) { int rawspeed_enabled = 1; if(imgdata.idata.dng_version && libraw_internal_data.unpacker_data.tiff_samples == 2) rawspeed_enabled = 0; if(imgdata.idata.raw_count > 1) rawspeed_enabled = 0; if(!strncasecmp(imgdata.idata.make,""Olympus"",7) && ( ( imgdata.sizes.raw_width > 6000) || !strncasecmp(imgdata.idata.model,""SH-2"",4) || !strncasecmp(imgdata.idata.model,""SH-3"",4) || !strncasecmp(imgdata.idata.model,""TG-4"",4)) ) rawspeed_enabled = 0; if(imgdata.idata.dng_version && imgdata.idata.filters==0 && libraw_internal_data.unpacker_data.tiff_bps == 8) rawspeed_enabled = 0; if(load_raw == &LibRaw::packed_load_raw && !strncasecmp(imgdata.idata.make,""Nikon"",5) && !strncasecmp(imgdata.idata.model,""E"",1) ) rawspeed_enabled = 0; if(O.use_rawspeed  && rawspeed_enabled && !(is_sraw() && (O.raw_processing_options & (LIBRAW_PROCESSING_SRAW_NO_RGB | LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE))) && (decoder_info.decoder_flags & LIBRAW_DECODER_TRYRAWSPEED) && _rawspeed_camerameta) { int rr = try_rawspeed(); } } #endif if(!raw_was_read())       { int zero_rawimage = 0; if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC) { } else if(imgdata.idata.filters || P1.colors == 1)           { imgdata.rawdata.raw_alloc = malloc(rwidth*(rheight+8)*sizeof(imgdata.rawdata.raw_image[0])); imgdata.rawdata.raw_image = (ushort*) imgdata.rawdata.raw_alloc; if(!S.raw_pitch) S.raw_pitch = S.raw_width*2;           } else           { S.iwidth = S.width; S.iheight= S.height; IO.shrink = 0; if(!S.raw_pitch) S.raw_pitch = (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY_WITH_MARGINS) ? S.raw_width*8 : S.width*8; imgdata.rawdata.raw_alloc = 0; imgdata.image = (ushort (*)[4]) calloc(unsigned(S.raw_width)*unsigned(S.raw_height),sizeof(*imgdata.image)); if(!(decoder_info.decoder_flags &  LIBRAW_DECODER_ADOBECOPYPIXEL)) { imgdata.rawdata.raw_image = (ushort*) imgdata.image ; zero_rawimage = 1; } } ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET); unsigned m_save = C.maximum; if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,""Nikon"")) C.maximum=65535; (this->*load_raw)(); if(zero_rawimage) imgdata.rawdata.raw_image = 0; if(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,""Nikon"")) C.maximum = m_save; if(decoder_info.decoder_flags &  LIBRAW_DECODER_OWNALLOC) { } else if (!(imgdata.idata.filters || P1.colors == 1) )           { imgdata.rawdata.raw_alloc = imgdata.image; imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc; imgdata.image = 0; if(!(libraw_internal_data.unpacker_data.load_flags & 256)) { S.raw_width = S.width; S.left_margin = 0; S.raw_height = S.height; S.top_margin = 0; } } } if(imgdata.rawdata.raw_image) crop_masked_pixels();  S.iwidth = save_iwidth; S.iheight = save_iheight; IO.shrink = save_shrink; unsigned int i = C.cblack[3]; unsigned int c; for(c=0;c<3;c++) if (i > C.cblack[c]) i = C.cblack[c]; for (c=0;c<4;c++) C.cblack[c] -= i; C.black += i; memmove(&imgdata.rawdata.color,&imgdata.color,sizeof(imgdata.color)); memmove(&imgdata.rawdata.sizes,&imgdata.sizes,sizeof(imgdata.sizes)); memmove(&imgdata.rawdata.iparams,&imgdata.idata,sizeof(imgdata.idata)); memmove(&imgdata.rawdata.ioparams,&libraw_internal_data.internal_output_params,sizeof(libraw_internal_data.internal_output_params)); SET_PROC_FLAG(LIBRAW_PROGRESS_LOAD_RAW); RUN_CALLBACK(LIBRAW_PROGRESS_LOAD_RAW,1,2); return 0; } catch ( LibRaw_exceptions err) { EXCEPTION_HANDLER(err); } catch (std::exception ee) { EXCEPTION_HANDLER(LIBRAW_EXCEPTION_IO_CORRUPT); } }"
"u_int juniper_monitor_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; struct juniper_monitor_header { uint8_t pkt_type; uint8_t padding; uint8_t iif[2]; uint8_t service_id[4]; }; const struct juniper_monitor_header *mh; l2info.pictype = DLT_JUNIPER_MONITOR; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; mh = (const struct juniper_monitor_header *)p; if (ndo->ndo_eflag) ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "", EXTRACT_32BITS(&mh->service_id), EXTRACT_16BITS(&mh->iif), mh->pkt_type)); ip_heuristic_guess (ndo, p, l2info.length); return l2info.header_len; }"
"void proto_register_sysdig_event(void) { static hf_register_info hf[] = { { &hf_se_cpu_id, { ""CPU ID"", ""sysdig.cpu_id"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_thread_id, { ""Thread ID"", ""sysdig.thread_id"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_event_length, { ""Event length"", ""sysdig.event_len"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_nparams, { ""Number of parameters"", ""sysdig.nparams"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_se_event_type, { ""Event type"", ""sysdig.event_type"", FT_UINT16, BASE_DEC, VALS(event_type_vals), 0, NULL, HFILL } }, { &hf_se_param_lens, { ""Parameter lengths"", ""sysdig.param.lens"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_se_param_len, { ""Parameter length"", ""sysdig.param.len"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ID_bytes, { ""ID"", ""sysdig.param.syscall.ID"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_action_uint32, { ""action"", ""sysdig.param.cpu_hotplug.action"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_addr_bytes, { ""addr"", ""sysdig.param.ptrace.addr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_addr_uint64, { ""addr"", ""sysdig.param.page_fault.addr"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_args_string, { ""Program arguments"", ""sysdig.param.execve.args"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_argument_uint64, { ""I/O control: argument"", ""sysdig.param.ioctl.argument"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_backlog_uint32, { ""backlog"", ""sysdig.param.listen.backlog"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cgroups_bytes, { ""cgroups"", ""sysdig.param.execve.cgroups"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_clockid_uint8, { ""clockid"", ""sysdig.param.timerfd_create.clockid"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cmd_bytes, { ""cmd"", ""sysdig.param.semctl.cmd"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_cmd_int64, { ""cmd"", ""sysdig.param.bpf.cmd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_comm_string, { ""Command"", ""sysdig.param.execve.comm"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_sys_uint64, { ""cpu_sys"", ""sysdig.param.procinfo.cpu_sys"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_uint32, { ""cpu"", ""sysdig.param.cpu_hotplug.cpu"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cpu_usr_uint64, { ""cpu_usr"", ""sysdig.param.procinfo.cpu_usr"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cur_int64, { ""cur"", ""sysdig.param.setrlimit.cur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_cwd_string, { ""Current working directory"", ""sysdig.param.execve.cwd"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_data_bytes, { ""data"", ""sysdig.param.ptrace.data"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_desc_string, { ""desc"", ""sysdig.param.notification.desc"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_description_string, { ""description"", ""sysdig.param.infra.description"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dev_string, { ""dev"", ""sysdig.param.mount.dev"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dev_uint32, { ""dev"", ""sysdig.param.openat.dev"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_dir_string, { ""dir"", ""sysdig.param.mount.dir"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dirfd_int64, { ""dirfd"", ""sysdig.param.openat.dirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_domain_bytes, { ""domain"", ""sysdig.param.socketpair.domain"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dpid_bytes, { ""dpid"", ""sysdig.param.signaldeliver.dpid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_bhardlimit_uint64, { ""dqb_bhardlimit"", ""sysdig.param.quotactl.dqb_bhardlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_bsoftlimit_uint64, { ""dqb_bsoftlimit"", ""sysdig.param.quotactl.dqb_bsoftlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_btime_bytes, { ""dqb_btime"", ""sysdig.param.quotactl.dqb_btime"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_curspace_uint64, { ""dqb_curspace"", ""sysdig.param.quotactl.dqb_curspace"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_ihardlimit_uint64, { ""dqb_ihardlimit"", ""sysdig.param.quotactl.dqb_ihardlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_isoftlimit_uint64, { ""dqb_isoftlimit"", ""sysdig.param.quotactl.dqb_isoftlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_dqb_itime_bytes, { ""dqb_itime"", ""sysdig.param.quotactl.dqb_itime"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_bgrace_bytes, { ""dqi_bgrace"", ""sysdig.param.quotactl.dqi_bgrace"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_flags_bytes, { ""dqi_flags"", ""sysdig.param.quotactl.dqi_flags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_dqi_igrace_bytes, { ""dqi_igrace"", ""sysdig.param.quotactl.dqi_igrace"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_egid_bytes, { ""egid"", ""sysdig.param.getresgid.egid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_env_string, { ""env"", ""sysdig.param.execve.env"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_error_bytes, { ""error"", ""sysdig.param.page_fault.error"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_euid_bytes, { ""euid"", ""sysdig.param.getresuid.euid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_event_data_uint64, { ""event_data"", ""sysdig.param.sysdigevent.event_data"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_event_type_uint32, { ""event_type"", ""sysdig.param.sysdigevent.event_type"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_exe_string, { ""exe"", ""sysdig.param.execve.exe"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_fd1_int64, { ""fd1"", ""sysdig.param.pipe.fd1"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd2_int64, { ""fd2"", ""sysdig.param.pipe.fd2"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_in_int64, { ""fd_in"", ""sysdig.param.splice.fd_in"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_int64, { ""fd"", ""sysdig.param.openat.fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fd_out_int64, { ""fd_out"", ""sysdig.param.splice.fd_out"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fdlimit_int64, { ""fdlimit"", ""sysdig.param.vfork.fdlimit"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fdlimit_uint64, { ""fdlimit"", ""sysdig.param.execve.fdlimit"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_fds_bytes, { ""fds"", ""sysdig.param.ppoll.fds"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_filename_string, { ""filename"", ""sysdig.param.execve.filename"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_flags_bytes, { ""flags"", ""sysdig.param.linkat.flags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_flags_uint32, { ""flags"", ""sysdig.param.accept.flags"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_gid_bytes, { ""gid"", ""sysdig.param.getgid.gid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_gid_uint32, { ""gid"", ""sysdig.param.vfork.gid"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_how_bytes, { ""how"", ""sysdig.param.shutdown.how"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_id_int64, { ""id"", ""sysdig.param.tracer.id"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_id_string, { ""id"", ""sysdig.param.notification.id"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_id_uint32, { ""id"", ""sysdig.param.quotactl.id"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_image_string, { ""image"", ""sysdig.param.container.image"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_in_fd_int64, { ""in_fd"", ""sysdig.param.sendfile.in_fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_initval_uint64, { ""initval"", ""sysdig.param.eventfd.initval"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ino_uint64, { ""ino"", ""sysdig.param.pipe.ino"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_interval_bytes, { ""interval"", ""sysdig.param.nanosleep.interval"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ip_uint64, { ""ip"", ""sysdig.param.page_fault.ip"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_json_string, { ""json"", ""sysdig.param.container.json"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_key_int32, { ""key"", ""sysdig.param.semget.key"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_length_uint64, { ""length"", ""sysdig.param.munmap.length"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_level_bytes, { ""level"", ""sysdig.param.getsockopt.level"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_linkdirfd_int64, { ""linkdirfd"", ""sysdig.param.symlinkat.linkdirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_linkpath_string, { ""linkpath"", ""sysdig.param.symlinkat.linkpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_loginuid_int32, { ""loginuid"", ""sysdig.param.execve.loginuid"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_mask_uint32, { ""mask"", ""sysdig.param.signalfd.mask"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_max_int64, { ""max"", ""sysdig.param.setrlimit.max"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_maxevents_bytes, { ""maxevents"", ""sysdig.param.epoll_wait.maxevents"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_mode_bytes, { ""mode"", ""sysdig.param.access.mode"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_mode_uint32, { ""mode"", ""sysdig.param.openat.mode"", FT_UINT32, BASE_OCT, NULL, 0, NULL, HFILL } }, { &hf_param_name_string, { ""name"", ""sysdig.param.openat.name"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_nativeID_uint16, { ""nativeID"", ""sysdig.param.syscall.nativeID"", FT_UINT16, BASE_DEC, VALS(nativeID_uint16_vals), 0, NULL, HFILL } }, { &hf_param_newcur_int64, { ""newcur"", ""sysdig.param.prlimit.newcur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newdir_int64, { ""newdir"", ""sysdig.param.linkat.newdir"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newdirfd_int64, { ""newdirfd"", ""sysdig.param.renameat.newdirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newmax_int64, { ""newmax"", ""sysdig.param.prlimit.newmax"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_newpath_string, { ""newpath"", ""sysdig.param.linkat.newpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_next_bytes, { ""next"", ""sysdig.param.switch.next"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_nsems_int32, { ""nsems"", ""sysdig.param.semget.nsems"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_nsops_uint32, { ""nsops"", ""sysdig.param.semop.nsops"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_nstype_bytes, { ""nstype"", ""sysdig.param.setns.nstype"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_offset_uint64, { ""offset"", ""sysdig.param.sendfile.offset"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldcur_int64, { ""oldcur"", ""sysdig.param.prlimit.oldcur"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_olddir_int64, { ""olddir"", ""sysdig.param.linkat.olddir"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_olddirfd_int64, { ""olddirfd"", ""sysdig.param.renameat.olddirfd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldmax_int64, { ""oldmax"", ""sysdig.param.prlimit.oldmax"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_oldpath_string, { ""oldpath"", ""sysdig.param.linkat.oldpath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_op_bytes, { ""op"", ""sysdig.param.futex.op"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_op_uint64, { ""op"", ""sysdig.param.seccomp.op"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_operation_bytes, { ""operation"", ""sysdig.param.flock.operation"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_optlen_uint32, { ""optlen"", ""sysdig.param.getsockopt.optlen"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_optname_bytes, { ""optname"", ""sysdig.param.getsockopt.optname"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_out_fd_int64, { ""out_fd"", ""sysdig.param.sendfile.out_fd"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_path_string, { ""path"", ""sysdig.param.mkdirat.path"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_peer_uint64, { ""peer"", ""sysdig.param.socketpair.peer"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_pgft_maj_uint64, { ""pgft_maj"", ""sysdig.param.execve.pgft_maj"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pgft_min_uint64, { ""pgft_min"", ""sysdig.param.execve.pgft_min"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pgid_bytes, { ""pgid"", ""sysdig.param.setpgid.pgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_pgoffset_uint64, { ""pgoffset"", ""sysdig.param.mmap2.pgoffset"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_pid_bytes, { ""pid"", ""sysdig.param.setpgid.pid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_pos_uint64, { ""pos"", ""sysdig.param.pwritev.pos"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_prot_bytes, { ""prot"", ""sysdig.param.mmap2.prot"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_proto_uint32, { ""proto"", ""sysdig.param.socketpair.proto"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_ptid_bytes, { ""ptid"", ""sysdig.param.execve.ptid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_queuelen_uint32, { ""queuelen"", ""sysdig.param.accept.queuelen"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_queuemax_uint32, { ""queuemax"", ""sysdig.param.accept.queuemax"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_queuepct_uint8, { ""Accept queue per connection"", ""sysdig.param.accept.queuepct"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_quota_fmt_bytes, { ""quota_fmt"", ""sysdig.param.quotactl.quota_fmt"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_quota_fmt_out_bytes, { ""quota_fmt_out"", ""sysdig.param.quotactl.quota_fmt_out"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_quotafilepath_string, { ""quotafilepath"", ""sysdig.param.quotactl.quotafilepath"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ratio_uint32, { ""ratio"", ""sysdig.param.drop.ratio"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_request_bytes, { ""request"", ""sysdig.param.ptrace.request"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_request_uint64, { ""I/O control: request"", ""sysdig.param.ioctl.request"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_res_bytes, { ""res"", ""sysdig.param.linkat.res"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_res_int64, { ""res"", ""sysdig.param.fcntl.res"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_res_or_fd_bytes, { ""res_or_fd"", ""sysdig.param.bpf.res_or_fd"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_res_uint64, { ""res"", ""sysdig.param.mmap2.res"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_resource_bytes, { ""resource"", ""sysdig.param.prlimit.resource"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_rgid_bytes, { ""rgid"", ""sysdig.param.getresgid.rgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ruid_bytes, { ""ruid"", ""sysdig.param.getresuid.ruid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_scope_string, { ""scope"", ""sysdig.param.infra.scope"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_flg_0_bytes, { ""sem_flg_0"", ""sysdig.param.semop.sem_flg_0"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_flg_1_bytes, { ""sem_flg_1"", ""sysdig.param.semop.sem_flg_1"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sem_num_0_uint16, { ""sem_num_0"", ""sysdig.param.semop.sem_num_0"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_num_1_uint16, { ""sem_num_1"", ""sysdig.param.semop.sem_num_1"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_op_0_int16, { ""sem_op_0"", ""sysdig.param.semop.sem_op_0"", FT_INT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sem_op_1_int16, { ""sem_op_1"", ""sysdig.param.semop.sem_op_1"", FT_INT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_semflg_bytes, { ""semflg"", ""sysdig.param.semget.semflg"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_semid_int32, { ""semid"", ""sysdig.param.semctl.semid"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_semnum_int32, { ""semnum"", ""sysdig.param.semctl.semnum"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_sgid_bytes, { ""sgid"", ""sysdig.param.getresgid.sgid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sig_bytes, { ""sig"", ""sysdig.param.signaldeliver.sig"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_sigmask_bytes, { ""sigmask"", ""sysdig.param.ppoll.sigmask"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_size_uint32, { ""size"", ""sysdig.param.pwritev.size"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_size_uint64, { ""size"", ""sysdig.param.sendfile.size"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_source_string, { ""source"", ""sysdig.param.infra.source"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_source_uint64, { ""source"", ""sysdig.param.socketpair.source"", FT_UINT64, BASE_HEX, NULL, 0, NULL, HFILL } }, { &hf_param_special_string, { ""special"", ""sysdig.param.quotactl.special"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_spid_bytes, { ""spid"", ""sysdig.param.signaldeliver.spid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_status_bytes, { ""status"", ""sysdig.param.procexit.status"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_suid_bytes, { ""suid"", ""sysdig.param.getresuid.suid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_tags_bytes, { ""tags"", ""sysdig.param.tracer.tags"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_target_string, { ""target"", ""sysdig.param.symlinkat.target"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_tid_bytes, { ""tid"", ""sysdig.param.execve.tid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_timeout_bytes, { ""timeout"", ""sysdig.param.ppoll.timeout"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_timeout_int64, { ""timeout"", ""sysdig.param.poll.timeout"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_tty_int32, { ""tty"", ""sysdig.param.execve.tty"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_tuple_bytes, { ""tuple"", ""sysdig.param.accept.tuple"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_bytes, { ""type"", ""sysdig.param.quotactl.type"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_string, { ""type"", ""sysdig.param.mount.type"", FT_STRING, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_type_uint32, { ""type"", ""sysdig.param.container.type"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_uid_bytes, { ""uid"", ""sysdig.param.getuid.uid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_uid_uint32, { ""uid"", ""sysdig.param.vfork.uid"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_val_bytes, { ""val"", ""sysdig.param.getsockopt.val"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_val_int32, { ""val"", ""sysdig.param.semctl.val"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_val_uint64, { ""val"", ""sysdig.param.futex.val"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_rss_uint32, { ""vm_rss"", ""sysdig.param.execve.vm_rss"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_size_uint32, { ""vm_size"", ""sysdig.param.execve.vm_size"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vm_swap_uint32, { ""vm_swap"", ""sysdig.param.execve.vm_swap"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_param_vpid_bytes, { ""vpid"", ""sysdig.param.vfork.vpid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_vtid_bytes, { ""vtid"", ""sysdig.param.vfork.vtid"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_whence_bytes, { ""whence"", ""sysdig.param.llseek.whence"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_ret_bytes, { ""ret"", ""sysdig.param.procexit.ret"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_param_core_uint8, { ""core"", ""sysdig.param.procexit.core"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, }; static gint *ett[] = { &ett_sysdig_event, &ett_sysdig_parm_lens, &ett_sysdig_syscall }; proto_sysdig_event = proto_register_protocol(""Sysdig System Call"", ""Sysdig Event"", ""sysdig""); proto_register_field_array(proto_sysdig_event, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); register_dissector(""sysdig"", dissect_sysdig_event, proto_sysdig_event); }"
"static int mlx5_fw_fatal_reporter_dump(struct devlink_health_reporter *reporter, struct devlink_fmsg *fmsg, void *priv_ctx) { struct mlx5_core_dev *dev = devlink_health_reporter_priv(reporter); u32 crdump_size = dev->priv.health.crdump_size; u32 *cr_data; u32 data_size; u32 offset; int err; if (!mlx5_core_is_pf(dev)) return -EPERM; cr_data = kvmalloc(crdump_size, GFP_KERNEL); if (!cr_data) return -ENOMEM; err = mlx5_crdump_collect(dev, cr_data); if (err) return err; if (priv_ctx) { struct mlx5_fw_reporter_ctx *fw_reporter_ctx = priv_ctx; err = mlx5_fw_reporter_ctx_pairs_put(fmsg, fw_reporter_ctx); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_start(fmsg, ""crdump_data""); if (err) goto free_data; for (offset = 0; offset < crdump_size; offset += data_size) { if (crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE) data_size = crdump_size - offset; else data_size = MLX5_CR_DUMP_CHUNK_SIZE; err = devlink_fmsg_binary_put(fmsg, (char *)cr_data + offset, data_size); if (err) goto free_data; } err = devlink_fmsg_arr_pair_nest_end(fmsg); free_data: kvfree(cr_data); return err; }"
"static struct sock *tcp_v6_syn_recv_sock(const struct sock *sk, struct sk_buff *skb, struct request_sock *req, struct dst_entry *dst, struct request_sock *req_unhash, bool *own_req) { struct inet_request_sock *ireq; struct ipv6_pinfo *newnp; const struct ipv6_pinfo *np = inet6_sk(sk); struct ipv6_txoptions *opt; struct tcp6_sock *newtcp6sk; struct inet_sock *newinet; struct tcp_sock *newtp; struct sock *newsk; #ifdef CONFIG_TCP_MD5SIG struct tcp_md5sig_key *key; #endif struct flowi6 fl6; if (skb->protocol == htons(ETH_P_IP)) { newsk = tcp_v4_syn_recv_sock(sk, skb, req, dst, req_unhash, own_req); if (!newsk) return NULL; newtcp6sk = (struct tcp6_sock *)newsk; inet_sk(newsk)->pinet6 = &newtcp6sk->inet6; newinet = inet_sk(newsk); newnp = inet6_sk(newsk); newtp = tcp_sk(newsk); memcpy(newnp, np, sizeof(struct ipv6_pinfo)); newnp->saddr = newsk->sk_v6_rcv_saddr; inet_csk(newsk)->icsk_af_ops = &ipv6_mapped; newsk->sk_backlog_rcv = tcp_v4_do_rcv; #ifdef CONFIG_TCP_MD5SIG newtp->af_specific = &tcp_sock_ipv6_mapped_specific; #endif newnp->ipv6_ac_list = NULL; newnp->ipv6_fl_list = NULL; newnp->pktoptions  = NULL; newnp->opt   = NULL; newnp->mcast_oif   = tcp_v6_iif(skb); newnp->mcast_hops  = ipv6_hdr(skb)->hop_limit; newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb)); if (np->repflow) newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb)); tcp_sync_mss(newsk, inet_csk(newsk)->icsk_pmtu_cookie); return newsk; } ireq = inet_rsk(req); if (sk_acceptq_is_full(sk)) goto out_overflow; if (!dst) { dst = inet6_csk_route_req(sk, &fl6, req, IPPROTO_TCP); if (!dst) goto out; } newsk = tcp_create_openreq_child(sk, req, skb); if (!newsk) goto out_nonewsk; newsk->sk_gso_type = SKB_GSO_TCPV6; ip6_dst_store(newsk, dst, NULL, NULL); inet6_sk_rx_dst_set(newsk, skb); newtcp6sk = (struct tcp6_sock *)newsk; inet_sk(newsk)->pinet6 = &newtcp6sk->inet6; newtp = tcp_sk(newsk); newinet = inet_sk(newsk); newnp = inet6_sk(newsk); memcpy(newnp, np, sizeof(struct ipv6_pinfo)); newsk->sk_v6_daddr = ireq->ir_v6_rmt_addr; newnp->saddr = ireq->ir_v6_loc_addr; newsk->sk_v6_rcv_saddr = ireq->ir_v6_loc_addr; newsk->sk_bound_dev_if = ireq->ir_iif; newinet->inet_opt = NULL; newnp->ipv6_ac_list = NULL; newnp->ipv6_fl_list = NULL; newnp->rxopt.all = np->rxopt.all; newnp->pktoptions = NULL; newnp->opt  = NULL; newnp->mcast_oif  = tcp_v6_iif(skb); newnp->mcast_hops = ipv6_hdr(skb)->hop_limit; newnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(skb)); if (np->repflow) newnp->flow_label = ip6_flowlabel(ipv6_hdr(skb)); opt = ireq->ipv6_opt; if (!opt) opt = rcu_dereference(np->opt); if (opt) { opt = ipv6_dup_options(newsk, opt); RCU_INIT_POINTER(newnp->opt, opt); } inet_csk(newsk)->icsk_ext_hdr_len = 0; if (opt) inet_csk(newsk)->icsk_ext_hdr_len = opt->opt_nflen + opt->opt_flen; tcp_ca_openreq_child(newsk, dst); tcp_sync_mss(newsk, dst_mtu(dst)); newtp->advmss = tcp_mss_clamp(tcp_sk(sk), dst_metric_advmss(dst)); tcp_initialize_rcv_mss(newsk); newinet->inet_daddr = newinet->inet_saddr = LOOPBACK4_IPV6; newinet->inet_rcv_saddr = LOOPBACK4_IPV6; #ifdef CONFIG_TCP_MD5SIG key = tcp_v6_md5_do_lookup(sk, &newsk->sk_v6_daddr); if (key) { tcp_md5_do_add(newsk, (union tcp_md5_addr *)&newsk->sk_v6_daddr, AF_INET6, key->key, key->keylen, sk_gfp_mask(sk, GFP_ATOMIC)); } #endif if (__inet_inherit_port(sk, newsk) < 0) { inet_csk_prepare_forced_close(newsk); tcp_done(newsk); goto out; } *own_req = inet_ehash_nolisten(newsk, req_to_sk(req_unhash)); if (*own_req) { tcp_move_syn(newtp, req); if (ireq->pktopts) { newnp->pktoptions = skb_clone(ireq->pktopts, sk_gfp_mask(sk, GFP_ATOMIC)); consume_skb(ireq->pktopts); ireq->pktopts = NULL; if (newnp->pktoptions) { tcp_v6_restore_cb(newnp->pktoptions); skb_set_owner_r(newnp->pktoptions, newsk); } } } return newsk; out_overflow: __NET_INC_STATS(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS); out_nonewsk: dst_release(dst); out: tcp_listendrop(sk); return NULL; }"
"static int list_devices(struct file *filp, struct dm_ioctl *param, size_t param_size) { unsigned int i; struct hash_cell *hc; size_t len, needed = 0; struct gendisk *disk; struct dm_name_list *orig_nl, *nl, *old_nl = NULL; uint32_t *event_nr; down_write(&_hash_lock); for (i = 0; i < NUM_BUCKETS; i++) { list_for_each_entry (hc, _name_buckets + i, name_list) { needed += align_val(offsetof(struct dm_name_list, name) + strlen(hc->name) + 1); needed += align_val(sizeof(uint32_t)); } } nl = orig_nl = get_result_buffer(param, param_size, &len); if (len < needed) { param->flags |= DM_BUFFER_FULL_FLAG; goto out; } param->data_size = param->data_start + needed; nl->dev = 0; for (i = 0; i < NUM_BUCKETS; i++) { list_for_each_entry (hc, _name_buckets + i, name_list) { if (old_nl) old_nl->next = (uint32_t) ((void *) nl - (void *) old_nl); disk = dm_disk(hc->md); nl->dev = huge_encode_dev(disk_devt(disk)); nl->next = 0; strcpy(nl->name, hc->name); old_nl = nl; event_nr = align_ptr(nl->name + strlen(hc->name) + 1); *event_nr = dm_get_event_nr(hc->md); nl = align_ptr(event_nr + 1); } } BUG_ON((char *)nl - (char *)orig_nl != needed); out: up_write(&_hash_lock); return 0; }"
"static void dump_od_to_saf(GF_SceneDumper *dumper, GF_AUContext *au, u32 indent) { u32 i, count; count = gf_list_count(au->commands); for (i=0; i<count; i++) { u32 j, c2; GF_ODUpdate *com = (GF_ODUpdate *)gf_list_get(au->commands, i); if (com->tag != GF_ODF_OD_UPDATE_TAG) continue; c2 = gf_list_count(com->objectDescriptors); for (j=0; j<c2; j++) { GF_ObjectDescriptor *od = (GF_ObjectDescriptor *)gf_list_get(com->objectDescriptors, j); GF_ESD *esd = (GF_ESD *) gf_list_get(od->ESDescriptors, 0); GF_MuxInfo *mux; if (!esd || (esd->tag != GF_ODF_ESD_TAG)) { if (od->URLString) { gf_fprintf(dumper->trace, ""<saf:RemoteStreamHeader streamID=\""stream%d\"" url=\""%s\"""", au->owner->ESID, od->URLString); if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing); gf_fprintf(dumper->trace, ""/>\n""); } continue; } mux = (GF_MuxInfo *)gf_list_get(esd->extensionDescriptors, 0); if (!mux || (mux->tag!=GF_ODF_MUXINFO_TAG)) mux = NULL; gf_fprintf(dumper->trace, ""<saf:mediaHeader streamID=\""stream%d\"""", esd->ESID); gf_fprintf(dumper->trace, "" streamType=\""%d\"" objectTypeIndication=\""%d\"" timeStampResolution=\""%d\"""", esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication, au->owner->timeScale); if (au->timing) gf_fprintf(dumper->trace, "" time=\""""LLD""\"""", au->timing); if (mux && mux->file_name) gf_fprintf(dumper->trace, "" source=\""%s\"""", mux->file_name); gf_fprintf(dumper->trace, ""/>\n""); } } gf_fprintf(dumper->trace, ""</saf:mediaUnit>\n""); }"
static int amd_gpio_remove(struct platform_device *pdev) { struct amd_gpio *gpio_dev; gpio_dev = platform_get_drvdata(pdev); gpiochip_remove(&gpio_dev->gc); pinctrl_unregister(gpio_dev->pctrl); return 0; }
"int ReadJpegSections (FILE * infile, ReadMode_t ReadMode) { int a; int HaveCom = FALSE; a = fgetc(infile); if (a != 0xff || fgetc(infile) != M_SOI){ return FALSE; } ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300; ImageInfo.JfifHeader.ResolutionUnits = 1; for(;;){ int itemlen; int prev; int marker = 0; int ll,lh, got; uchar * Data; CheckSectionsAllocated(); prev = 0; for (a=0;;a++){ marker = fgetc(infile); if (marker != 0xff && prev == 0xff) break; if (marker == EOF){ ErrFatal(""Unexpected end of file""); } prev = marker; } if (a > 10){ ErrNonfatal(""Extraneous %d padding bytes before section %02X"",a-1,marker); } Sections[SectionsRead].Type = marker; lh = fgetc(infile); ll = fgetc(infile); if (lh == EOF || ll == EOF){ ErrFatal(""Unexpected end of file""); } itemlen = (lh << 8) | ll; if (itemlen < 2){ ErrFatal(""invalid marker""); } Sections[SectionsRead].Size = itemlen; Data = (uchar *)malloc(itemlen); if (Data == NULL){ ErrFatal(""Could not allocate memory""); } Sections[SectionsRead].Data = Data; Data[0] = (uchar)lh; Data[1] = (uchar)ll; got = fread(Data+2, 1, itemlen-2, infile);         if (got != itemlen-2){ ErrFatal(""Premature end of file?""); } SectionsRead += 1; switch(marker){ case M_SOS:                                   if (ReadMode & READ_IMAGE){ int cp, ep, size; cp = ftell(infile); fseek(infile, 0, SEEK_END); ep = ftell(infile); fseek(infile, cp, SEEK_SET); size = ep-cp; Data = (uchar *)malloc(size); if (Data == NULL){ ErrFatal(""could not allocate data for entire image""); } got = fread(Data, 1, size, infile); if (got != size){ ErrFatal(""could not read the rest of the image""); } CheckSectionsAllocated(); Sections[SectionsRead].Data = Data; Sections[SectionsRead].Size = size; Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER; SectionsRead ++; HaveAll = 1; } return TRUE; case M_DQT: process_DQT(Data, itemlen); break; case M_DHT:    process_DHT(Data, itemlen); break; case M_EOI:                   fprintf(stderr,""No image in jpeg!\n""); return FALSE; case M_COM:                 if (HaveCom || ((ReadMode & READ_METADATA) == 0)){ free(Sections[--SectionsRead].Data); }else{ process_COM(Data, itemlen); HaveCom = TRUE; } break; case M_JFIF: if (itemlen < 16){ fprintf(stderr,""Jfif header too short\n""); goto ignore; } if (memcmp(Data+2, ""JFIF\0"",5)){ fprintf(stderr,""Header missing JFIF marker\n""); } ImageInfo.JfifHeader.Present = TRUE; ImageInfo.JfifHeader.ResolutionUnits = Data[9]; ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11]; ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13]; if (ShowTags){ printf(""JFIF SOI marker: Units: %d "",ImageInfo.JfifHeader.ResolutionUnits); switch(ImageInfo.JfifHeader.ResolutionUnits){ case 0: printf(""(aspect ratio)""); break; case 1: printf(""(dots per inch)""); break; case 2: printf(""(dots per cm)""); break; default: printf(""(unknown)""); break; } printf(""  X-density=%d Y-density=%d\n"",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity); if (Data[14] || Data[15]){ fprintf(stderr,""Ignoring jfif header thumbnail\n""); } } ignore: free(Sections[--SectionsRead].Data); break; case M_EXIF: if (ReadMode & READ_METADATA){ if (memcmp(Data+2, ""Exif"", 4) == 0){ process_EXIF(Data, itemlen); break; }else if (memcmp(Data+2, ""http:"", 5) == 0){ Sections[SectionsRead-1].Type = M_XMP;                         if (ShowTags){ printf(""Image contains XMP section, %d bytes long\n"", itemlen); if (ShowTags){ ShowXmp(Sections[SectionsRead-1]); } } break; } } free(Sections[--SectionsRead].Data); break; case M_IPTC: if (ReadMode & READ_METADATA){ if (ShowTags){ printf(""Image contains IPTC section, %d bytes long\n"", itemlen); } }else{ free(Sections[--SectionsRead].Data); } break; case M_SOF0:  case M_SOF1:  case M_SOF2:  case M_SOF3:  case M_SOF5:  case M_SOF6:  case M_SOF7:  case M_SOF9:  case M_SOF10: case M_SOF11: case M_SOF13: case M_SOF14: case M_SOF15: if (itemlen < 8){ fprintf(stderr,""Section too short\n""); break; } process_SOFn(Data, marker); break; default: if (ShowTags){ printf(""Jpeg section marker 0x%02x size %d\n"",marker, itemlen); } break; } } return TRUE; }"
struct bpf_prog *bpf_prog_get(u32 ufd) { struct fd f = fdget(ufd); struct bpf_prog *prog; prog = __bpf_prog_get(f); if (IS_ERR(prog)) return prog; atomic_inc(&prog->aux->refcnt); fdput(f); return prog; }
"static BOOL zgfx_decompress_segment(ZGFX_CONTEXT* zgfx, wStream* stream, size_t segmentSize) { BYTE c; BYTE flags; UINT32 extra = 0; int opIndex; int haveBits; int inPrefix; UINT32 count; UINT32 distance; BYTE* pbSegment; size_t cbSegment = segmentSize - 1; if ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1)) return FALSE; Stream_Read_UINT8(stream, flags);  zgfx->OutputCount = 0; pbSegment = Stream_Pointer(stream); Stream_Seek(stream, cbSegment); if (!(flags & PACKET_COMPRESSED)) { zgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment); CopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment); zgfx->OutputCount = cbSegment; return TRUE; } zgfx->pbInputCurrent = pbSegment; zgfx->pbInputEnd = &pbSegment[cbSegment - 1]; zgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd; zgfx->cBitsCurrent = 0; zgfx->BitsCurrent = 0; while (zgfx->cBitsRemaining) { haveBits = 0; inPrefix = 0; for (opIndex = 0; ZGFX_TOKEN_TABLE[opIndex].prefixLength != 0; opIndex++) { while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength) { zgfx_GetBits(zgfx, 1); inPrefix = (inPrefix << 1) + zgfx->bits; haveBits++; } if (inPrefix == ZGFX_TOKEN_TABLE[opIndex].prefixCode) { if (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0) { zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits); c = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits); zgfx->HistoryBuffer[zgfx->HistoryIndex] = c; if (++zgfx->HistoryIndex == zgfx->HistoryBufferSize) zgfx->HistoryIndex = 0; zgfx->OutputBuffer[zgfx->OutputCount++] = c; } else { zgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits); distance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits; if (distance != 0) { zgfx_GetBits(zgfx, 1); if (zgfx->bits == 0) { count = 3; } else { count = 4; extra = 2; zgfx_GetBits(zgfx, 1); while (zgfx->bits == 1) { count *= 2; extra++; zgfx_GetBits(zgfx, 1); } zgfx_GetBits(zgfx, extra); count += zgfx->bits; } zgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count); zgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count); zgfx->OutputCount += count; } else { zgfx_GetBits(zgfx, 15); count = zgfx->bits; zgfx->cBitsRemaining -= zgfx->cBitsCurrent; zgfx->cBitsCurrent = 0; zgfx->BitsCurrent = 0; CopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count); zgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count); zgfx->pbInputCurrent += count; zgfx->cBitsRemaining -= (8 * count); zgfx->OutputCount += count; } } break; } } } return TRUE; }"
"bool SoftVPX::outputBuffers(bool flushDecoder, bool display, bool eos, bool *portWillReset) { List<BufferInfo *> &outQueue = getPortQueue(1); BufferInfo *outInfo = NULL; OMX_BUFFERHEADERTYPE *outHeader = NULL; vpx_codec_iter_t iter = NULL; if (flushDecoder && mFrameParallelMode) { if (vpx_codec_decode((vpx_codec_ctx_t *)mCtx, NULL, 0, NULL, 0)) { ALOGE(""Failed to flush on2 decoder.""); return false; } } if (!display) { if (!flushDecoder) { ALOGE(""Invalid operation.""); return false; } while ((mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter))) { } return true; } while (!outQueue.empty()) { if (mImg == NULL) { mImg = vpx_codec_get_frame((vpx_codec_ctx_t *)mCtx, &iter); if (mImg == NULL) { break; } } uint32_t width = mImg->d_w; uint32_t height = mImg->d_h; outInfo = *outQueue.begin(); outHeader = outInfo->mHeader; CHECK_EQ(mImg->fmt, VPX_IMG_FMT_I420); handlePortSettingsChange(portWillReset, width, height); if (*portWillReset) { return true; } outHeader->nOffset = 0; outHeader->nFlags = 0; outHeader->nFilledLen = (outputBufferWidth() * outputBufferHeight() * 3) / 2; outHeader->nTimeStamp = *(OMX_TICKS *)mImg->user_priv; if (outHeader->nAllocLen >= outHeader->nFilledLen) { uint8_t *dst = outHeader->pBuffer; const uint8_t *srcY = (const uint8_t *)mImg->planes[VPX_PLANE_Y]; const uint8_t *srcU = (const uint8_t *)mImg->planes[VPX_PLANE_U]; const uint8_t *srcV = (const uint8_t *)mImg->planes[VPX_PLANE_V]; size_t srcYStride = mImg->stride[VPX_PLANE_Y]; size_t srcUStride = mImg->stride[VPX_PLANE_U]; size_t srcVStride = mImg->stride[VPX_PLANE_V]; copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride); } else { ALOGE(""b/27597103, buffer too small""); android_errorWriteLog(0x534e4554, ""27597103""); outHeader->nFilledLen = 0; } mImg = NULL; outInfo->mOwnedByUs = false; outQueue.erase(outQueue.begin()); outInfo = NULL; notifyFillBufferDone(outHeader); outHeader = NULL; } if (!eos) { return true; } if (!outQueue.empty()) { outInfo = *outQueue.begin(); outQueue.erase(outQueue.begin()); outHeader = outInfo->mHeader; outHeader->nTimeStamp = 0; outHeader->nFilledLen = 0; outHeader->nFlags = OMX_BUFFERFLAG_EOS; outInfo->mOwnedByUs = false; notifyFillBufferDone(outHeader); mEOSStatus = OUTPUT_FRAMES_FLUSHED; } return true; }"
"static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data) { int rv; ssize_t size; sgwc_event_t *e = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_pfcp_node_t *node = NULL; ogs_pfcp_header_t *h = NULL; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recvfrom() failed""); ogs_pkbuf_free(pkbuf); return; } ogs_pkbuf_trim(pkbuf, size); h = (ogs_pfcp_header_t *)pkbuf->data; if (h->version > OGS_PFCP_VERSION) { ogs_pfcp_header_t rsp; ogs_error(""Not supported version[%d]"", h->version); memset(&rsp, 0, sizeof rsp); rsp.flags = (OGS_PFCP_VERSION << 5); rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE; rsp.length = htobe16(4); rsp.sqn_only = h->sqn_only; if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(pkbuf); return; } e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE); ogs_assert(e); node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from); if (!node) { node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from); ogs_assert(node); node->sock = data; pfcp_node_fsm_init(node, false); } e->pfcp_node = node; e->pkbuf = pkbuf; rv = ogs_queue_push(ogs_app()->queue, e); if (rv != OGS_OK) { ogs_error(""ogs_queue_push() failed:%d"", (int)rv); ogs_pkbuf_free(e->pkbuf); sgwc_event_free(e); } }"
"static bfd_boolean coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols) { RELOC *native_relocs; arelent *reloc_cache; arelent *cache_ptr; unsigned int idx; bfd_size_type amt; if (asect->relocation) return TRUE; if (asect->reloc_count == 0) return TRUE; if (asect->flags & SEC_CONSTRUCTOR) return TRUE; if (!coff_slurp_symbol_table (abfd)) return FALSE; amt = (bfd_size_type) bfd_coff_relsz (abfd) * asect->reloc_count; native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos, amt); amt = (bfd_size_type) asect->reloc_count * sizeof (arelent); reloc_cache = (arelent *) bfd_alloc (abfd, amt); if (reloc_cache == NULL || native_relocs == NULL) return FALSE; for (idx = 0; idx < asect->reloc_count; idx++) { struct internal_reloc dst; struct external_reloc *src; #ifndef RELOC_PROCESSING asymbol *ptr; #endif cache_ptr = reloc_cache + idx; src = native_relocs + idx; dst.r_offset = 0; coff_swap_reloc_in (abfd, src, &dst); #ifdef RELOC_PROCESSING RELOC_PROCESSING (cache_ptr, &dst, symbols, abfd, asect); #else cache_ptr->address = dst.r_vaddr; if (dst.r_symndx != -1) { if (dst.r_symndx < 0 || dst.r_symndx >= obj_conv_table_size (abfd)) { _bfd_error_handler (_(""%B: warning: illegal symbol index %ld in relocs""), abfd, dst.r_symndx); cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr; ptr = NULL; } else { cache_ptr->sym_ptr_ptr = (symbols + obj_convert (abfd)[dst.r_symndx]); ptr = *(cache_ptr->sym_ptr_ptr); } } else { cache_ptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr; ptr = NULL; } CALC_ADDEND (abfd, ptr, dst, cache_ptr); (void) ptr; cache_ptr->address -= asect->vma; RTYPE2HOWTO (cache_ptr, &dst); #endif if (cache_ptr->howto == NULL) { _bfd_error_handler (_(""%B: illegal relocation type %d at address %#Lx""), abfd, dst.r_type, dst.r_vaddr); bfd_set_error (bfd_error_bad_value); return FALSE; } } asect->relocation = reloc_cache; return TRUE; }"
"int snd_pcm_info(struct snd_pcm_substream *substream, struct snd_pcm_info *info) { struct snd_pcm_runtime *runtime; struct snd_pcm *pcm = substream->pcm; struct snd_pcm_str *pstr = substream->pstr; memset(info, 0, sizeof(*info)); info->card = pcm->card->number; info->device = pcm->device; info->stream = substream->stream; info->subdevice = substream->number; strlcpy(info->id, pcm->id, sizeof(info->id)); strlcpy(info->name, pcm->name, sizeof(info->name)); info->dev_class = pcm->dev_class; info->dev_subclass = pcm->dev_subclass; info->subdevices_count = pstr->substream_count; info->subdevices_avail = pstr->substream_count - pstr->substream_opened; strlcpy(info->subname, substream->name, sizeof(info->subname)); runtime = substream->runtime; if (runtime) { info->sync = runtime->sync; substream->ops->ioctl(substream, SNDRV_PCM_IOCTL1_INFO, info); } return 0; }"
"void do_debug(struct cpu_user_regs *regs) { unsigned long dr6; struct vcpu *v = current; dr6 = read_debugreg(6); if ( debugger_trap_entry(TRAP_debug, regs) ) return; write_debugreg(6, X86_DR6_DEFAULT); if ( !guest_mode(regs) ) { if ( regs->eflags & X86_EFLAGS_TF ) { if ( (regs->rip >= (unsigned long)sysenter_entry) && (regs->rip <= (unsigned long)sysenter_eflags_saved) ) { if ( regs->rip == (unsigned long)sysenter_eflags_saved ) regs->eflags &= ~X86_EFLAGS_TF; goto out; } if ( !debugger_trap_fatal(TRAP_debug, regs) ) { WARN(); regs->eflags &= ~X86_EFLAGS_TF; } } else { WARN_ON(!search_exception_table(regs)); } goto out; } v->arch.debugreg[6] |= (dr6 & ~X86_DR6_DEFAULT); v->arch.debugreg[6] &= (dr6 | ~X86_DR6_DEFAULT); ler_enable(); pv_inject_hw_exception(TRAP_debug, X86_EVENT_NO_EC); return; out: ler_enable(); return; }"
"static long sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg) { void __user *p = (void __user *)arg; int __user *ip = p; int result, val, read_only; Sg_device *sdp; Sg_fd *sfp; Sg_request *srp; unsigned long iflags; if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp))) return -ENXIO; SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, ""sg_ioctl: cmd=0x%x\n"", (int) cmd_in)); read_only = (O_RDWR != (filp->f_flags & O_ACCMODE)); switch (cmd_in) { case SG_IO: if (atomic_read(&sdp->detaching)) return -ENODEV; if (!scsi_block_when_processing_errors(sdp->device)) return -ENXIO; if (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR)) return -EFAULT; result = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR, 1, read_only, 1, &srp); if (result < 0) return result; result = wait_event_interruptible(sfp->read_wait, (srp_done(sfp, srp) || atomic_read(&sdp->detaching))); if (atomic_read(&sdp->detaching)) return -ENODEV; write_lock_irq(&sfp->rq_list_lock); if (srp->done) { srp->done = 2; write_unlock_irq(&sfp->rq_list_lock); result = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp); return (result < 0) ? result : 0; } srp->orphan = 1; write_unlock_irq(&sfp->rq_list_lock); return result; case SG_SET_TIMEOUT: result = get_user(val, ip); if (result) return result; if (val < 0) return -EIO; if (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ)) val = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ), INT_MAX); sfp->timeout_user = val; sfp->timeout = mult_frac(val, HZ, USER_HZ); return 0; case SG_GET_TIMEOUT: return sfp->timeout_user; case SG_SET_FORCE_LOW_DMA: result = get_user(val, ip); if (result) return result; if (val) { sfp->low_dma = 1; if ((0 == sfp->low_dma) && (0 == sg_res_in_use(sfp))) { val = (int) sfp->reserve.bufflen; sg_remove_scat(sfp, &sfp->reserve); sg_build_reserve(sfp, val); } } else { if (atomic_read(&sdp->detaching)) return -ENODEV; sfp->low_dma = sdp->device->host->unchecked_isa_dma; } return 0; case SG_GET_LOW_DMA: return put_user((int) sfp->low_dma, ip); case SG_GET_SCSI_ID: if (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t))) return -EFAULT; else { sg_scsi_id_t __user *sg_idp = p; if (atomic_read(&sdp->detaching)) return -ENODEV; __put_user((int) sdp->device->host->host_no, &sg_idp->host_no); __put_user((int) sdp->device->channel, &sg_idp->channel); __put_user((int) sdp->device->id, &sg_idp->scsi_id); __put_user((int) sdp->device->lun, &sg_idp->lun); __put_user((int) sdp->device->type, &sg_idp->scsi_type); __put_user((short) sdp->device->host->cmd_per_lun, &sg_idp->h_cmd_per_lun); __put_user((short) sdp->device->queue_depth, &sg_idp->d_queue_depth); __put_user(0, &sg_idp->unused[0]); __put_user(0, &sg_idp->unused[1]); return 0; } case SG_SET_FORCE_PACK_ID: result = get_user(val, ip); if (result) return result; sfp->force_packid = val ? 1 : 0; return 0; case SG_GET_PACK_ID: if (!access_ok(VERIFY_WRITE, ip, sizeof (int))) return -EFAULT; read_lock_irqsave(&sfp->rq_list_lock, iflags); for (srp = sfp->headrp; srp; srp = srp->nextrp) { if ((1 == srp->done) && (!srp->sg_io_owned)) { read_unlock_irqrestore(&sfp->rq_list_lock, iflags); __put_user(srp->header.pack_id, ip); return 0; } } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); __put_user(-1, ip); return 0; case SG_GET_NUM_WAITING: read_lock_irqsave(&sfp->rq_list_lock, iflags); for (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) { if ((1 == srp->done) && (!srp->sg_io_owned)) ++val; } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); return put_user(val, ip); case SG_GET_SG_TABLESIZE: return put_user(sdp->sg_tablesize, ip); case SG_SET_RESERVED_SIZE: result = get_user(val, ip); if (result) return result; if (val < 0) return -EINVAL; val = min_t(int, val, max_sectors_bytes(sdp->device->request_queue)); if (val != sfp->reserve.bufflen) { if (sg_res_in_use(sfp) || sfp->mmap_called) return -EBUSY; sg_remove_scat(sfp, &sfp->reserve); sg_build_reserve(sfp, val); } return 0; case SG_GET_RESERVED_SIZE: val = min_t(int, sfp->reserve.bufflen, max_sectors_bytes(sdp->device->request_queue)); return put_user(val, ip); case SG_SET_COMMAND_Q: result = get_user(val, ip); if (result) return result; sfp->cmd_q = val ? 1 : 0; return 0; case SG_GET_COMMAND_Q: return put_user((int) sfp->cmd_q, ip); case SG_SET_KEEP_ORPHAN: result = get_user(val, ip); if (result) return result; sfp->keep_orphan = val; return 0; case SG_GET_KEEP_ORPHAN: return put_user((int) sfp->keep_orphan, ip); case SG_NEXT_CMD_LEN: result = get_user(val, ip); if (result) return result; sfp->next_cmd_len = (val > 0) ? val : 0; return 0; case SG_GET_VERSION_NUM: return put_user(sg_version_num, ip); case SG_GET_ACCESS_COUNT: val = (sdp->device ? 1 : 0); return put_user(val, ip); case SG_GET_REQUEST_TABLE: if (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE)) return -EFAULT; else { sg_req_info_t *rinfo; unsigned int ms; rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE, GFP_KERNEL); if (!rinfo) return -ENOMEM; read_lock_irqsave(&sfp->rq_list_lock, iflags); for (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE; ++val, srp = srp ? srp->nextrp : srp) { memset(&rinfo[val], 0, SZ_SG_REQ_INFO); if (srp) { rinfo[val].req_state = srp->done + 1; rinfo[val].problem = srp->header.masked_status &  srp->header.host_status &  srp->header.driver_status; if (srp->done) rinfo[val].duration = srp->header.duration; else { ms = jiffies_to_msecs(jiffies); rinfo[val].duration = (ms > srp->header.duration) ? (ms - srp->header.duration) : 0; } rinfo[val].orphan = srp->orphan; rinfo[val].sg_io_owned = srp->sg_io_owned; rinfo[val].pack_id = srp->header.pack_id; rinfo[val].usr_ptr = srp->header.usr_ptr; } } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); result = __copy_to_user(p, rinfo,  SZ_SG_REQ_INFO * SG_MAX_QUEUE); result = result ? -EFAULT : 0; kfree(rinfo); return result; } case SG_EMULATED_HOST: if (atomic_read(&sdp->detaching)) return -ENODEV; return put_user(sdp->device->host->hostt->emulated, ip); case SCSI_IOCTL_SEND_COMMAND: if (atomic_read(&sdp->detaching)) return -ENODEV; if (read_only) { unsigned char opcode = WRITE_6; Scsi_Ioctl_Command __user *siocp = p; if (copy_from_user(&opcode, siocp->data, 1)) return -EFAULT; if (sg_allow_access(filp, &opcode)) return -EPERM; } return sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p); case SG_SET_DEBUG: result = get_user(val, ip); if (result) return result; sdp->sgdebug = (char) val; return 0; case BLKSECTGET: return put_user(max_sectors_bytes(sdp->device->request_queue), ip); case BLKTRACESETUP: return blk_trace_setup(sdp->device->request_queue, sdp->disk->disk_name, MKDEV(SCSI_GENERIC_MAJOR, sdp->index), NULL, (char *)arg); case BLKTRACESTART: return blk_trace_startstop(sdp->device->request_queue, 1); case BLKTRACESTOP: return blk_trace_startstop(sdp->device->request_queue, 0); case BLKTRACETEARDOWN: return blk_trace_remove(sdp->device->request_queue); case SCSI_IOCTL_GET_IDLUN: case SCSI_IOCTL_GET_BUS_NUMBER: case SCSI_IOCTL_PROBE_HOST: case SG_GET_TRANSFORM: case SG_SCSI_RESET: if (atomic_read(&sdp->detaching)) return -ENODEV; break; default: if (read_only) return -EPERM; break; } result = scsi_ioctl_block_when_processing_errors(sdp->device, cmd_in, filp->f_flags & O_NDELAY); if (result) return result; return scsi_ioctl(sdp->device, cmd_in, p); }"
"MagickExport MagickBooleanType SetImageType(Image *image,const ImageType type, ExceptionInfo *exception) { const char *artifact; ImageInfo *image_info; MagickBooleanType status; QuantizeInfo *quantize_info; assert(image != (Image *) NULL); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""...""); assert(image->signature == MagickCoreSignature); status=MagickTrue; image_info=AcquireImageInfo(); image_info->dither=image->dither; artifact=GetImageArtifact(image,""dither""); if (artifact != (const char *) NULL) (void) SetImageOption(image_info,""dither"",artifact); switch (type) { case BilevelType: { if (SetImageMonochrome(image,exception) == MagickFalse) { status=TransformImageColorspace(image,GRAYColorspace,exception); (void) NormalizeImage(image,exception); quantize_info=AcquireQuantizeInfo(image_info); quantize_info->number_colors=2; quantize_info->colorspace=GRAYColorspace; status=QuantizeImage(quantize_info,image,exception); quantize_info=DestroyQuantizeInfo(quantize_info); } image->colors=2; image->alpha_trait=UndefinedPixelTrait; break; } case GrayscaleType: { if (SetImageGray(image,exception) == MagickFalse) status=TransformImageColorspace(image,GRAYColorspace,exception); image->alpha_trait=UndefinedPixelTrait; break; } case GrayscaleAlphaType: { if (SetImageGray(image,exception) == MagickFalse) status=TransformImageColorspace(image,GRAYColorspace,exception); if (image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); break; } case PaletteType: { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); if ((image->storage_class == DirectClass) || (image->colors > 256)) { quantize_info=AcquireQuantizeInfo(image_info); quantize_info->number_colors=256; status=QuantizeImage(quantize_info,image,exception); quantize_info=DestroyQuantizeInfo(quantize_info); } image->alpha_trait=UndefinedPixelTrait; break; } case PaletteBilevelAlphaType: { ChannelType channel_mask; if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); if (image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); channel_mask=SetImageChannelMask(image,AlphaChannel); (void) BilevelImage(image,(double) QuantumRange/2.0,exception); (void) SetImageChannelMask(image,channel_mask); quantize_info=AcquireQuantizeInfo(image_info); status=QuantizeImage(quantize_info,image,exception); quantize_info=DestroyQuantizeInfo(quantize_info); break; } case PaletteAlphaType: { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); if (image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); quantize_info=AcquireQuantizeInfo(image_info); quantize_info->colorspace=TransparentColorspace; status=QuantizeImage(quantize_info,image,exception); quantize_info=DestroyQuantizeInfo(quantize_info); break; } case TrueColorType: { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); if (image->storage_class != DirectClass) status=SetImageStorageClass(image,DirectClass,exception); image->alpha_trait=UndefinedPixelTrait; break; } case TrueColorAlphaType: { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); if (image->storage_class != DirectClass) status=SetImageStorageClass(image,DirectClass,exception); if (image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); break; } case ColorSeparationType: { if (image->colorspace != CMYKColorspace) { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); status=TransformImageColorspace(image,CMYKColorspace,exception); } if (image->storage_class != DirectClass) status=SetImageStorageClass(image,DirectClass,exception); image->alpha_trait=UndefinedPixelTrait; break; } case ColorSeparationAlphaType: { if (image->colorspace != CMYKColorspace) { if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) status=TransformImageColorspace(image,sRGBColorspace,exception); status=TransformImageColorspace(image,CMYKColorspace,exception); } if (image->storage_class != DirectClass) status=SetImageStorageClass(image,DirectClass,exception); if (image->alpha_trait == UndefinedPixelTrait) status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); break; } case OptimizeType: case UndefinedType: break; } image_info=DestroyImageInfo(image_info); if (status == MagickFalse) return(status); image->type=type; return(MagickTrue); }"
"int vrend_create_vertex_elements_state(struct vrend_context *ctx, uint32_t handle, unsigned num_elements, const struct pipe_vertex_element *elements) { struct vrend_vertex_element_array *v = CALLOC_STRUCT(vrend_vertex_element_array); const struct util_format_description *desc; GLenum type; int i; uint32_t ret_handle; if (!v) return ENOMEM; if (num_elements > PIPE_MAX_ATTRIBS) return EINVAL; v->count = num_elements; for (i = 0; i < num_elements; i++) { memcpy(&v->elements[i].base, &elements[i], sizeof(struct pipe_vertex_element)); desc = util_format_description(elements[i].src_format); if (!desc) { FREE(v); return EINVAL; } type = GL_FALSE; if (desc->channel[0].type == UTIL_FORMAT_TYPE_FLOAT) { if (desc->channel[0].size == 32) type = GL_FLOAT; else if (desc->channel[0].size == 64) type = GL_DOUBLE; else if (desc->channel[0].size == 16) type = GL_HALF_FLOAT; } else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 8) type = GL_UNSIGNED_BYTE; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 8) type = GL_BYTE; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 16) type = GL_UNSIGNED_SHORT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 16) type = GL_SHORT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_UNSIGNED && desc->channel[0].size == 32) type = GL_UNSIGNED_INT; else if (desc->channel[0].type == UTIL_FORMAT_TYPE_SIGNED && desc->channel[0].size == 32) type = GL_INT; else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SSCALED || elements[i].src_format == PIPE_FORMAT_R10G10B10A2_SNORM || elements[i].src_format == PIPE_FORMAT_B10G10R10A2_SNORM) type = GL_INT_2_10_10_10_REV; else if (elements[i].src_format == PIPE_FORMAT_R10G10B10A2_USCALED || elements[i].src_format == PIPE_FORMAT_R10G10B10A2_UNORM || elements[i].src_format == PIPE_FORMAT_B10G10R10A2_UNORM) type = GL_UNSIGNED_INT_2_10_10_10_REV; else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) type = GL_UNSIGNED_INT_10F_11F_11F_REV; if (type == GL_FALSE) { report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_VERTEX_FORMAT, elements[i].src_format); FREE(v); return EINVAL; } v->elements[i].type = type; if (desc->channel[0].normalized) v->elements[i].norm = GL_TRUE; if (desc->nr_channels == 4 && desc->swizzle[0] == UTIL_FORMAT_SWIZZLE_Z) v->elements[i].nr_chan = GL_BGRA; else if (elements[i].src_format == PIPE_FORMAT_R11G11B10_FLOAT) v->elements[i].nr_chan = 3; else v->elements[i].nr_chan = desc->nr_channels; } if (vrend_state.have_vertex_attrib_binding) { glGenVertexArrays(1, &v->id); glBindVertexArray(v->id); for (i = 0; i < num_elements; i++) { struct vrend_vertex_element *ve = &v->elements[i]; if (util_format_is_pure_integer(ve->base.src_format)) glVertexAttribIFormat(i, ve->nr_chan, ve->type, ve->base.src_offset); else glVertexAttribFormat(i, ve->nr_chan, ve->type, ve->norm, ve->base.src_offset); glVertexAttribBinding(i, ve->base.vertex_buffer_index); glVertexBindingDivisor(i, ve->base.instance_divisor); glEnableVertexAttribArray(i); } } ret_handle = vrend_renderer_object_insert(ctx, v, sizeof(struct vrend_vertex_element), handle, VIRGL_OBJECT_VERTEX_ELEMENTS); if (!ret_handle) { FREE(v); return ENOMEM; } return 0; }"
"void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) { uint8_t* p = p_data->p_data; SMP_TRACE_DEBUG(""%s"", __func__); STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN); smp_key_distribution(p_cb, NULL); }"
"int nfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp) { struct svc_procedure*proc; kxdrproc_txdr; __be32nfserr; __be32*nfserrp; dprintk(""nfsd_dispatch: vers %d proc %d\n"", rqstp->rq_vers, rqstp->rq_proc); proc = rqstp->rq_procinfo; rqstp->rq_cachetype = proc->pc_cachetype; xdr = proc->pc_decode; if (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base, rqstp->rq_argp)) { dprintk(""nfsd: failed to decode arguments!\n""); *statp = rpc_garbage_args; return 1; } switch (nfsd_cache_lookup(rqstp)) { case RC_DROPIT: return 0; case RC_REPLY: return 1; case RC_DOIT:; } nfserrp = rqstp->rq_res.head[0].iov_base + rqstp->rq_res.head[0].iov_len; rqstp->rq_res.head[0].iov_len += sizeof(__be32); nfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp); nfserr = map_new_errors(rqstp->rq_vers, nfserr); if (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) { dprintk(""nfsd: Dropping request; may be revisited later\n""); nfsd_cache_update(rqstp, RC_NOCACHE, NULL); return 0; } if (rqstp->rq_proc != 0) *nfserrp++ = nfserr; if (!(nfserr && rqstp->rq_vers == 2)) { xdr = proc->pc_encode; if (xdr && !xdr(rqstp, nfserrp, rqstp->rq_resp)) { dprintk(""nfsd: failed to encode result!\n""); nfsd_cache_update(rqstp, RC_NOCACHE, NULL); *statp = rpc_system_err; return 1; } } nfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1); return 1; }"
"int LibRaw::ljpeg_start(struct jhead *jh, int info_only) { ushort c, tag, len; int cnt = 0; uchar data[0x10000]; const uchar *dp; memset(jh, 0, sizeof *jh); jh->restart = INT_MAX; if ((fgetc(ifp), fgetc(ifp)) != 0xd8) return 0; do { if (feof(ifp)) return 0; if (cnt++ > 1024) return 0;     if (!fread(data, 2, 2, ifp)) return 0; tag = data[0] << 8 | data[1]; len = (data[2] << 8 | data[3]) - 2; if (tag <= 0xff00) return 0; fread(data, 1, len, ifp); switch (tag) { case 0xffc3:       jh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3; case 0xffc1: case 0xffc0: jh->algo = tag & 0xff; jh->bits = data[0]; jh->high = data[1] << 8 | data[2]; jh->wide = data[3] << 8 | data[4]; jh->clrs = data[5] + jh->sraw; if (len == 9 && !dng_version) getc(ifp); break; case 0xffc4:       if (info_only) break; for (dp = data; dp < data + len && !((c = *dp++) & -20);) jh->free[c] = jh->huff[c] = make_decoder_ref(&dp); break; case 0xffda:       jh->psv = data[1 + data[0] * 2]; jh->bits -= data[3 + data[0] * 2] & 15; break; case 0xffdb: FORC(64) jh->quant[c] = data[c * 2 + 1] << 8 | data[c * 2 + 2]; break; case 0xffdd: jh->restart = data[0] << 8 | data[1]; } } while (tag != 0xffda); if (jh->bits > 16 || jh->clrs > 6 || !jh->bits || !jh->high || !jh->wide || !jh->clrs) return 0; if (info_only) return 1; if (!jh->huff[0]) return 0; FORC(19) if (!jh->huff[c + 1]) jh->huff[c + 1] = jh->huff[c]; if (jh->sraw) { FORC(4) jh->huff[2 + c] = jh->huff[1]; FORC(jh->sraw) jh->huff[1 + c] = jh->huff[0]; } jh->row = (ushort *)calloc(jh->wide * jh->clrs, 4); merror(jh->row, ""ljpeg_start()""); return zero_after_ff = 1; }"
void const * PackLinuxElf64::elf_find_dynamic(unsigned int key) const { Elf64_Dyn const *dynp= dynseg; if (dynp) for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) { upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val)); if (t) { return &((unsigned char const *)file_image)[(size_t)t]; } break; } return 0; }
"static void uc_list(char_u *name, size_t name_len) { inti, j; intfound = FALSE; ucmd_T*cmd; intlen; intover; longa; garray_T*gap; gap = #ifdef FEAT_CMDWIN is_in_cmdwin() ? &prevwin->w_buffer->b_ucmds : #endif &curbuf->b_ucmds; for (;;) { for (i = 0; i < gap->ga_len; ++i) { cmd = USER_CMD_GA(gap, i); a = (long)cmd->uc_argt; if (STRNCMP(name, cmd->uc_name, name_len) != 0 || message_filtered(cmd->uc_name)) continue; if (!found) msg_puts_title(_(""\n    Name              Args Address Complete    Definition"")); found = TRUE; msg_putchar('\n'); if (got_int) break; len = 4; if (a & EX_BANG) { msg_putchar('!'); --len; } if (a & EX_REGSTR) { msg_putchar('""'); --len; } if (gap != &ucmds) { msg_putchar('b'); --len; } if (a & EX_TRLBAR) { msg_putchar('|'); --len; } while (len-- > 0) msg_putchar(' '); msg_outtrans_attr(cmd->uc_name, HL_ATTR(HLF_D)); len = (int)STRLEN(cmd->uc_name) + 4; do { msg_putchar(' '); ++len; } while (len < 22); over = len - 22; len = 0; switch ((int)(a & (EX_EXTRA|EX_NOSPC|EX_NEEDARG))) { case 0:IObuff[len++] = '0'; break; case (EX_EXTRA):IObuff[len++] = '*'; break; case (EX_EXTRA|EX_NOSPC):IObuff[len++] = '?'; break; case (EX_EXTRA|EX_NEEDARG):IObuff[len++] = '+'; break; case (EX_EXTRA|EX_NOSPC|EX_NEEDARG): IObuff[len++] = '1'; break; } do { IObuff[len++] = ' '; } while (len < 5 - over); if (a & (EX_RANGE|EX_COUNT)) { if (a & EX_COUNT) { sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def); len += (int)STRLEN(IObuff + len); } else if (a & EX_DFLALL) IObuff[len++] = '%'; else if (cmd->uc_def >= 0) { sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def); len += (int)STRLEN(IObuff + len); } else IObuff[len++] = '.'; } do { IObuff[len++] = ' '; } while (len < 8 - over); for (j = 0; addr_type_complete[j].expand != ADDR_NONE; ++j) if (addr_type_complete[j].expand != ADDR_LINES && addr_type_complete[j].expand == cmd->uc_addr_type) { STRCPY(IObuff + len, addr_type_complete[j].shortname); len += (int)STRLEN(IObuff + len); break; } do { IObuff[len++] = ' '; } while (len < 13 - over); for (j = 0; command_complete[j].expand != 0; ++j) if (command_complete[j].expand == cmd->uc_compl) { STRCPY(IObuff + len, command_complete[j].name); len += (int)STRLEN(IObuff + len); #ifdef FEAT_EVAL if (p_verbose > 0 && cmd->uc_compl_arg != NULL && STRLEN(cmd->uc_compl_arg) < 200) { IObuff[len] = ','; STRCPY(IObuff + len + 1, cmd->uc_compl_arg); len += (int)STRLEN(IObuff + len); } #endif break; } do { IObuff[len++] = ' '; } while (len < 25 - over); IObuff[len] = '\0'; msg_outtrans(IObuff); msg_outtrans_special(cmd->uc_rep, FALSE, name_len == 0 ? Columns - 47 : 0); #ifdef FEAT_EVAL if (p_verbose > 0) last_set_msg(cmd->uc_script_ctx); #endif out_flush(); ui_breakcheck(); if (got_int) break; } if (gap == &ucmds || i < gap->ga_len) break; gap = &ucmds; } if (!found) msg(_(""No user-defined commands found"")); }"
"void ValidateInputs(OpKernelContext* ctx, const CSRSparseMatrix& sparse_matrix, const Tensor& permutation_indices, int* batch_size, int64* num_rows) { OP_REQUIRES(ctx, sparse_matrix.dtype() == DataTypeToEnum<T>::value, errors::InvalidArgument( ""Asked for a CSRSparseMatrix of type "", DataTypeString(DataTypeToEnum<T>::value), "" but saw dtype: "", DataTypeString(sparse_matrix.dtype()))); const Tensor& dense_shape = sparse_matrix.dense_shape(); const int rank = dense_shape.dim_size(0); OP_REQUIRES(ctx, rank == 2 || rank == 3, errors::InvalidArgument(""sparse matrix must have rank 2 or 3; "", ""but dense_shape has size "", rank)); const int row_dim = (rank == 2) ? 0 : 1; auto dense_shape_vec = dense_shape.vec<int64>(); *num_rows = dense_shape_vec(row_dim); const int64 num_cols = dense_shape_vec(row_dim + 1); OP_REQUIRES(ctx, *num_rows == num_cols, errors::InvalidArgument(""sparse matrix must be square; got: "", *num_rows, "" != "", num_cols)); const TensorShape& perm_shape = permutation_indices.shape(); OP_REQUIRES( ctx, perm_shape.dims() + 1 == rank, errors::InvalidArgument( ""sparse matrix must have the same rank as permutation; got: "", rank, "" != "", perm_shape.dims(), "" + 1."")); OP_REQUIRES( ctx, perm_shape.dim_size(rank - 2) == *num_rows, errors::InvalidArgument( ""permutation must have the same number of elements in each batch "" ""as the number of rows in sparse matrix; got: "", perm_shape.dim_size(rank - 2), "" != "", *num_rows)); *batch_size = sparse_matrix.batch_size(); if (*batch_size > 1) { OP_REQUIRES( ctx, perm_shape.dim_size(0) == *batch_size, errors::InvalidArgument(""permutation must have the same batch size "" ""as sparse matrix; got: "", perm_shape.dim_size(0), "" != "", *batch_size)); } }"
"static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason) { time_t t = time(NULL); const char *iso_date = iso_date_string(&t); uid_t my_euid = (uid_t)-1L; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH; if (!(g_opts & OPT_x)) { mode = DEFAULT_DUMP_DIR_MODE; my_euid = geteuid(); } pid_t my_pid = getpid(); char base[sizeof(""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"") + 2 * sizeof(long)*3]; sprintf(base, ""xorg-%s-%lu-%u"", iso_date, (long)my_pid, g_bt_count); char *path = concat_path_file(debug_dumps_dir, base); struct dump_dir *dd = dd_create(path,  my_euid, mode); if (dd) { dd_create_basic_files(dd,  my_euid, NULL); dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION); dd_save_text(dd, FILENAME_ANALYZER, ""xorg""); dd_save_text(dd, FILENAME_TYPE, ""xorg""); dd_save_text(dd, FILENAME_REASON, reason); dd_save_text(dd, FILENAME_BACKTRACE, bt); if (!exe) { exe = ""/usr/bin/X""; if (access(""/usr/bin/Xorg"", X_OK) == 0) exe = ""/usr/bin/Xorg""; } dd_save_text(dd, FILENAME_EXECUTABLE, exe); dd_close(dd); notify_new_path(path); } free(path); }"
"static int z2restore(i_ctx_t *i_ctx_p) { while (gs_gstate_saved(gs_gstate_saved(igs))) { if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restore1pagedevice""); gs_grestore(igs); } if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restorepagedevice""); return zrestore(i_ctx_p); }"
"TEE_Result syscall_obj_generate_key(unsigned long obj, unsigned long key_size, const struct utee_attribute *usr_params, unsigned long param_count) { TEE_Result res; struct tee_ta_session *sess; const struct tee_cryp_obj_type_props *type_props; struct tee_obj *o; struct tee_cryp_obj_secret *key; size_t byte_size; TEE_Attribute *params = NULL; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; res = tee_obj_get(to_user_ta_ctx(sess->ctx), tee_svc_uref_to_vaddr(obj), &o); if (res != TEE_SUCCESS) return res; if ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0) return TEE_ERROR_BAD_STATE; if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0) return TEE_ERROR_BAD_STATE; type_props = tee_svc_find_type_props(o->info.objectType); if (!type_props) return TEE_ERROR_NOT_SUPPORTED; if (key_size % type_props->quanta != 0) return TEE_ERROR_NOT_SUPPORTED; if (key_size < type_props->min_size) return TEE_ERROR_NOT_SUPPORTED; if (key_size > type_props->max_size) return TEE_ERROR_NOT_SUPPORTED; params = malloc(sizeof(TEE_Attribute) * param_count); if (!params) return TEE_ERROR_OUT_OF_MEMORY; res = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_params, param_count, params); if (res != TEE_SUCCESS) goto out; res = tee_svc_cryp_check_attr(ATTR_USAGE_GENERATE_KEY, type_props, params, param_count); if (res != TEE_SUCCESS) goto out; switch (o->info.objectType) { case TEE_TYPE_AES: case TEE_TYPE_DES: case TEE_TYPE_DES3: case TEE_TYPE_HMAC_MD5: case TEE_TYPE_HMAC_SHA1: case TEE_TYPE_HMAC_SHA224: case TEE_TYPE_HMAC_SHA256: case TEE_TYPE_HMAC_SHA384: case TEE_TYPE_HMAC_SHA512: case TEE_TYPE_GENERIC_SECRET: byte_size = key_size / 8; if (o->info.objectType == TEE_TYPE_DES || o->info.objectType == TEE_TYPE_DES3) { byte_size = (key_size + key_size / 7) / 8; } key = (struct tee_cryp_obj_secret *)o->attr; if (byte_size > key->alloc_size) { res = TEE_ERROR_EXCESS_DATA; goto out; } res = crypto_rng_read((void *)(key + 1), byte_size); if (res != TEE_SUCCESS) goto out; key->key_size = byte_size; o->have_attrs = (1 << type_props->num_type_attrs) - 1; break; case TEE_TYPE_RSA_KEYPAIR: res = tee_svc_obj_generate_key_rsa(o, type_props, key_size, params, param_count); if (res != TEE_SUCCESS) goto out; break; case TEE_TYPE_DSA_KEYPAIR: res = tee_svc_obj_generate_key_dsa(o, type_props, key_size); if (res != TEE_SUCCESS) goto out; break; case TEE_TYPE_DH_KEYPAIR: res = tee_svc_obj_generate_key_dh(o, type_props, key_size, params, param_count); if (res != TEE_SUCCESS) goto out; break; case TEE_TYPE_ECDSA_KEYPAIR: case TEE_TYPE_ECDH_KEYPAIR: res = tee_svc_obj_generate_key_ecc(o, type_props, key_size, params, param_count); if (res != TEE_SUCCESS) goto out; break; default: res = TEE_ERROR_BAD_FORMAT; } out: free(params); if (res == TEE_SUCCESS) { o->info.keySize = key_size; o->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED; } return res; }"
"static void get_over(struct SYMBOL *s) { struct VOICE_S *p_voice, *p_voice2, *p_voice3; int range, voice, voice2, voice3; static char tx_wrong_dur[] = ""Wrong duration in voice overlay""; static char txt_no_note[] = ""No note in voice overlay""; p_voice = curvoice; if (p_voice->ignore) return; if (s->abc_type == ABC_T_BAR || s->u.v_over.type == V_OVER_E)  { if (!p_voice->last_sym) { error(1, s, txt_no_note); return; } p_voice->last_sym->sflags |= S_BEAM_END; over_bar = 0; if (over_time < 0) { error(1, s, ""Erroneous end of voice overlap""); return; } if (p_voice->time != over_mxtime) error(1, s, tx_wrong_dur); curvoice = &voice_tb[over_voice]; over_mxtime = 0; over_voice = -1; over_time = -1; return; } if (s->u.v_over.type == V_OVER_S) { over_voice = p_voice - voice_tb; over_time = p_voice->time; return; } if (!p_voice->last_sym) { error(1, s, txt_no_note); return; } p_voice->last_sym->sflags |= S_BEAM_END; voice2 = s->u.v_over.voice; p_voice2 = &voice_tb[voice2]; if (parsys->voice[voice2].range < 0) { int clone; if (cfmt.abc2pscompat) { error(1, s, ""Cannot have %%%%abc2pscompat""); cfmt.abc2pscompat = 0; } clone = p_voice->clone >= 0; p_voice2->id[0] = '&'; p_voice2->id[1] = '\0'; p_voice2->second = 1; parsys->voice[voice2].second = 1; p_voice2->scale = p_voice->scale; p_voice2->octave = p_voice->octave; p_voice2->transpose = p_voice->transpose; memcpy(&p_voice2->key, &p_voice->key, sizeof p_voice2->key); memcpy(&p_voice2->ckey, &p_voice->ckey, sizeof p_voice2->ckey); memcpy(&p_voice2->okey, &p_voice->okey, sizeof p_voice2->okey); p_voice2->posit = p_voice->posit; p_voice2->staff = p_voice->staff; p_voice2->cstaff = p_voice->cstaff; p_voice2->color = p_voice->color; p_voice2->map_name = p_voice->map_name; range = parsys->voice[p_voice - voice_tb].range; for (voice = 0; voice < MAXVOICE; voice++) { if (parsys->voice[voice].range > range) parsys->voice[voice].range += clone + 1; } parsys->voice[voice2].range = range + 1; voice_link(p_voice2); if (clone) { for (voice3 = MAXVOICE; --voice3 >= 0; ) { if (parsys->voice[voice3].range < 0) break; } if (voice3 > 0) { p_voice3 = &voice_tb[voice3]; strcpy(p_voice3->id, p_voice2->id); p_voice3->second = 1; parsys->voice[voice3].second = 1; p_voice3->scale = voice_tb[p_voice->clone].scale; parsys->voice[voice3].range = range + 2; voice_link(p_voice3); p_voice2->clone = voice3; } else { error(1, s, ""Too many voices for overlay cloning""); } } } voice = p_voice - voice_tb; if (over_time < 0) { int time; over_bar = 1; over_mxtime = p_voice->time; over_voice = voice; time = p_voice2->time; for (s = p_voice->last_sym; ; s = s->prev) { if (s->type == BAR || s->time <= time) break; } over_time = s->time; } else { if (over_mxtime == 0) over_mxtime = p_voice->time; else if (p_voice->time != over_mxtime) error(1, s, tx_wrong_dur); } p_voice2->time = over_time; curvoice = p_voice2; }"
"status_t OMXNodeInstance::updateGraphicBufferInMeta( OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer, OMX::buffer_id buffer) { Mutex::Autolock autoLock(mLock); OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer); return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header); }"
"static int snd_timer_user_tselect(struct file *file, struct snd_timer_select __user *_tselect) { struct snd_timer_user *tu; struct snd_timer_select tselect; char str[32]; int err = 0; tu = file->private_data; mutex_lock(&tu->tread_sem); if (tu->timeri) { snd_timer_close(tu->timeri); tu->timeri = NULL; } if (copy_from_user(&tselect, _tselect, sizeof(tselect))) { err = -EFAULT; goto __err; } sprintf(str, ""application %i"", current->pid); if (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE) tselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION; err = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid); if (err < 0) goto __err; kfree(tu->queue); tu->queue = NULL; kfree(tu->tqueue); tu->tqueue = NULL; if (tu->tread) { tu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread), GFP_KERNEL); if (tu->tqueue == NULL) err = -ENOMEM; } else { tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu->queue == NULL) err = -ENOMEM; } if (err < 0) { snd_timer_close(tu->timeri); tu->timeri = NULL; } else { tu->timeri->flags |= SNDRV_TIMER_IFLG_FAST; tu->timeri->callback = tu->tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt; tu->timeri->ccallback = snd_timer_user_ccallback; tu->timeri->callback_data = (void *)tu; } __err: mutex_unlock(&tu->tread_sem); return err; }"
"static unsigned long get_num_dynamic_syms (Filedata * filedata) { unsigned long num_of_syms = 0; if (!do_histogram && (!do_using_dynamic || do_dyn_syms)) return num_of_syms; if (dynamic_info[DT_HASH]) { unsigned char nb[8]; unsigned char nc[8]; unsigned int hash_ent_size = 4; if ((filedata->file_header.e_machine == EM_ALPHA || filedata->file_header.e_machine == EM_S390 || filedata->file_header.e_machine == EM_S390_OLD) && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64) hash_ent_size = 8; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, dynamic_info[DT_HASH], sizeof nb + sizeof nc)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); goto no_hash; } if (fread (nb, hash_ent_size, 1, filedata->handle) != 1) { error (_(""Failed to read in number of buckets\n"")); goto no_hash; } if (fread (nc, hash_ent_size, 1, filedata->handle) != 1) { error (_(""Failed to read in number of chains\n"")); goto no_hash; } nbuckets = byte_get (nb, hash_ent_size); nchains = byte_get (nc, hash_ent_size); num_of_syms = nchains; buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size); chains  = get_dynamic_data (filedata, nchains, hash_ent_size); no_hash: if (num_of_syms == 0) { if (buckets) { free (buckets); buckets = NULL; } if (chains) { free (chains); chains = NULL; } nbuckets = 0; } } if (dynamic_info_DT_GNU_HASH) { unsigned char nb[16]; bfd_vma i, maxchain = 0xffffffff, bitmaskwords; bfd_vma buckets_vma; unsigned long hn; bfd_boolean gnu_hash_error = FALSE; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH, sizeof nb)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } if (fread (nb, 16, 1, filedata->handle) != 1) { error (_(""Failed to read in number of buckets\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } ngnubuckets = byte_get (nb, 4); gnusymidx = byte_get (nb + 4, 4); bitmaskwords = byte_get (nb + 8, 4); buckets_vma = dynamic_info_DT_GNU_HASH + 16; if (is_32bit_elf) buckets_vma += bitmaskwords * 4; else buckets_vma += bitmaskwords * 8; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma, 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4); if (gnubuckets == NULL) { gnu_hash_error = TRUE; goto no_gnu_hash; } for (i = 0; i < ngnubuckets; i++) if (gnubuckets[i] != 0) { if (gnubuckets[i] < gnusymidx) { gnu_hash_error = TRUE; return FALSE; } if (maxchain == 0xffffffff || gnubuckets[i] > maxchain) maxchain = gnubuckets[i]; } if (maxchain == 0xffffffff) { gnu_hash_error = TRUE; goto no_gnu_hash; } maxchain -= gnusymidx; if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma + 4 * (ngnubuckets + maxchain), 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } do { if (fread (nb, 4, 1, filedata->handle) != 1) { error (_(""Failed to determine last chain length\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } if (maxchain + 1 == 0) { gnu_hash_error = TRUE; goto no_gnu_hash; } ++maxchain; } while ((byte_get (nb, 4) & 1) == 0); if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } gnuchains = get_dynamic_data (filedata, maxchain, 4); ngnuchains = maxchain; if (gnuchains == NULL) { gnu_hash_error = TRUE; goto no_gnu_hash; } if (dynamic_info_DT_MIPS_XHASH) { if (fseek (filedata->handle, (archive_file_offset + offset_from_vma (filedata, (buckets_vma + 4 * (ngnubuckets + maxchain)), 4)), SEEK_SET)) { error (_(""Unable to seek to start of dynamic information\n"")); gnu_hash_error = TRUE; goto no_gnu_hash; } mipsxlat = get_dynamic_data (filedata, maxchain, 4); } for (hn = 0; hn < ngnubuckets; ++hn) if (gnubuckets[hn] != 0) { bfd_vma si = gnubuckets[hn]; bfd_vma off = si - gnusymidx; do { if (dynamic_info_DT_MIPS_XHASH) { if (mipsxlat[off] >= num_of_syms) num_of_syms = mipsxlat[off] + 1; } else { if (si >= num_of_syms) num_of_syms = si + 1; } si++; } while (off < ngnuchains && (gnuchains[off++] & 1) == 0); } no_gnu_hash: if (gnu_hash_error) { if (mipsxlat) { free (mipsxlat); mipsxlat = NULL; } if (gnuchains) { free (gnuchains); gnuchains = NULL; } if (gnubuckets) { free (gnubuckets); gnubuckets = NULL; } ngnubuckets = 0; ngnuchains = 0; } } return num_of_syms; }"
"static void fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type) { int ret; int sav_errno; if (fifo->name) { sav_errno = 0; if (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH))) fifo->created_fifo = true; else { sav_errno = errno; if (sav_errno != EEXIST) log_message(LOG_INFO, ""Unable to create %snotify fifo %s"", type, fifo->name); } if (!sav_errno || sav_errno == EEXIST) { if (fifo->script) notify_fifo_exec(master, script_exit, fifo, fifo->script); if ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) { log_message(LOG_INFO, ""Unable to open %snotify fifo %s - errno %d"", type, fifo->name, errno); if (fifo->created_fifo) { unlink(fifo->name); fifo->created_fifo = false; } } } if (fifo->fd == -1) { FREE(fifo->name); fifo->name = NULL; } } }"
"static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) { struct xc2028_data *priv = fe->tuner_priv; struct xc2028_ctrl *p    = priv_cfg; int                 rc   = 0; tuner_dbg(""%s called\n"", __func__); mutex_lock(&priv->lock); kfree(priv->ctrl.fname); memcpy(&priv->ctrl, p, sizeof(priv->ctrl)); if (p->fname) { priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL); if (priv->ctrl.fname == NULL) rc = -ENOMEM; } if (!firmware_name[0] && p->fname && priv->fname && strcmp(p->fname, priv->fname)) free_firmware(priv); if (priv->ctrl.max_len < 9) priv->ctrl.max_len = 13; if (priv->state == XC2028_NO_FIRMWARE) { if (!firmware_name[0]) priv->fname = priv->ctrl.fname; else priv->fname = firmware_name; rc = request_firmware_nowait(THIS_MODULE, 1, priv->fname, priv->i2c_props.adap->dev.parent, GFP_KERNEL, fe, load_firmware_cb); if (rc < 0) { tuner_err(""Failed to request firmware %s\n"", priv->fname); priv->state = XC2028_NODEV; } else priv->state = XC2028_WAITING_FIRMWARE; } mutex_unlock(&priv->lock); return rc; }"
"int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags) { struct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg); int ret; ret = -EBADFD; if (!io_is_uring_fops(req->file)) goto done; switch (msg->cmd) { case IORING_MSG_DATA: ret = io_msg_ring_data(req); break; case IORING_MSG_SEND_FD: ret = io_msg_send_fd(req, issue_flags); break; default: ret = -EINVAL; break; } done: if (ret < 0) req_set_fail(req); io_req_set_res(req, ret, 0); io_put_file(req->file); req->file = NULL; return IOU_OK; }"
"static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q) { if ( !bcf_hdr_nsamples(h) ) return 0; static int extreme_val_warned = 0; char *r, *t; int j, l, m, g, overflow = 0; khint_t k; ks_tokaux_t aux1; vdict_t *d = (vdict_t*)h->dict[BCF_DT_ID]; kstring_t *mem = (kstring_t*)&h->mem; fmt_aux_t fmt[MAX_N_FMT]; mem->l = 0; char *end = s->s + s->l; if ( q>=end ) { hts_log_error(""FORMAT column with no sample columns starting at %s:%""PRIhts_pos"""", bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_NCOLS; return -1; } v->n_fmt = 0; if ( p[0]=='.' && p[1]==0 )     { v->n_sample = bcf_hdr_nsamples(h); return 0; } for (j = 0, t = kstrtok(p, "":"", &aux1); t; t = kstrtok(0, 0, &aux1), ++j) { if (j >= MAX_N_FMT) { v->errcode |= BCF_ERR_LIMITS; hts_log_error(""FORMAT column at %s:%""PRIhts_pos"" lists more identifiers than htslib can handle"", bcf_seqname_safe(h,v), v->pos+1); return -1; } *(char*)aux1.p = 0; k = kh_get(vdict, d, t); if (k == kh_end(d) || kh_val(d, k).info[BCF_HL_FMT] == 15) { if ( t[0]=='.' && t[1]==0 ) { hts_log_error(""Invalid FORMAT tag name '.' at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } hts_log_warning(""FORMAT '%s' at %s:%""PRIhts_pos"" is not defined in the header, assuming Type=String"", t, bcf_seqname_safe(h,v), v->pos+1); kstring_t tmp = {0,0,0}; int l; ksprintf(&tmp, ""##FORMAT=<ID=%s,Number=1,Type=String,Description=\""Dummy\"">"", t); bcf_hrec_t *hrec = bcf_hdr_parse_line(h,tmp.s,&l); free(tmp.s); int res = hrec ? bcf_hdr_add_hrec((bcf_hdr_t*)h, hrec) : -1; if (res < 0) bcf_hrec_destroy(hrec); if (res > 0) res = bcf_hdr_sync((bcf_hdr_t*)h); k = kh_get(vdict, d, t); v->errcode = BCF_ERR_TAG_UNDEF; if (res || k == kh_end(d)) { hts_log_error(""Could not add dummy header for FORMAT '%s' at %s:%""PRIhts_pos, t, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } } fmt[j].max_l = fmt[j].max_m = fmt[j].max_g = 0; fmt[j].key = kh_val(d, k).id; fmt[j].is_gt = !strcmp(t, ""GT""); fmt[j].y = h->id[0][fmt[j].key].val->info[BCF_HL_FMT]; v->n_fmt++; } int n_sample_ori = -1; r = q + 1;      l = 0, m = g = 1, v->n_sample = 0;      while ( r<end ) { if ( h->keep_samples ) { n_sample_ori++; if ( !bit_array_test(h->keep_samples,n_sample_ori) ) { while ( *r!='\t' && r<end ) r++; if ( *r=='\t' ) { *r = 0; r++; } continue; } } j = 0;          fmt_aux_t *f = fmt; for (;;) { switch (*r) { case ',': m++; break; case '|': case '/': if (f->is_gt) g++; break; case '\t': *r = 0;  case '\0': case ':': if (f->max_m < m) f->max_m = m; if (f->max_l < l) f->max_l = l; if (f->is_gt && f->max_g < g) f->max_g = g; l = 0, m = g = 1; if ( *r==':' ) { j++; f++; if ( j>=v->n_fmt ) { hts_log_error(""Incorrect number of FORMAT fields at %s:%""PRIhts_pos"""", h->id[BCF_DT_CTG][v->rid].key, v->pos+1); v->errcode |= BCF_ERR_NCOLS; return -1; } } else goto end_for; break; } if ( r>=end ) break; r++; l++; } end_for: v->n_sample++; if ( v->n_sample == bcf_hdr_nsamples(h) ) break; r++; } for (j = 0; j < v->n_fmt; ++j) { fmt_aux_t *f = &fmt[j]; if ( !f->max_m ) f->max_m = 1;          if ((f->y>>4&0xf) == BCF_HT_STR) { f->size = f->is_gt? f->max_g << 2 : f->max_l; } else if ((f->y>>4&0xf) == BCF_HT_REAL || (f->y>>4&0xf) == BCF_HT_INT) { f->size = f->max_m << 2; } else { hts_log_error(""The format type %d at %s:%""PRIhts_pos"" is currently not supported"", f->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } if (align_mem(mem) < 0) { hts_log_error(""Memory allocation failure at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } f->offset = mem->l; if (v->n_sample * (uint64_t)f->size > INT_MAX) { hts_log_error(""Excessive memory required by FORMAT fields at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } if (ks_resize(mem, mem->l + v->n_sample * (size_t)f->size) < 0) { hts_log_error(""Memory allocation failure at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } mem->l += v->n_sample * f->size; } for (j = 0; j < v->n_fmt; ++j) fmt[j].buf = (uint8_t*)mem->s + fmt[j].offset; n_sample_ori = -1; t = q + 1; m = 0;       while ( t<end ) { if ( h->keep_samples ) { n_sample_ori++; if ( !bit_array_test(h->keep_samples,n_sample_ori) ) { while ( *t && t<end ) t++; t++; continue; } } if ( m == bcf_hdr_nsamples(h) ) break; j = 0;         while ( t < end ) { fmt_aux_t *z = &fmt[j++]; if (!z->buf) { hts_log_error(""Memory allocation failure for FORMAT field type %d at %s:%""PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; return -1; } if ((z->y>>4&0xf) == BCF_HT_STR) { if (z->is_gt) {                     int32_t is_phased = 0; uint32_t *x = (uint32_t*)(z->buf + z->size * (size_t)m); uint32_t unreadable = 0; uint32_t max = 0; overflow = 0; for (l = 0;; ++t) { if (*t == '.') { ++t, x[l++] = is_phased; } else { char *tt = t; uint32_t val = hts_str2uint(t, &t, sizeof(val) * CHAR_MAX - 2, &overflow); unreadable |= tt == t; if (max < val) max = val; x[l++] = (val + 1) << 1 | is_phased; } is_phased = (*t == '|'); if (*t != '|' && *t != '/') break; } if (overflow || max > (INT32_MAX >> 1) - 1) { hts_log_error(""Couldn't read GT data: value too large at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } if (unreadable) { hts_log_error(""Couldn't read GT data: value not a number or '.' at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } if ( !l ) x[l++] = 0;                       for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else { char *x = (char*)z->buf + z->size * (size_t)m; for (r = t, l = 0; *t != ':' && *t; ++t) x[l++] = *t; for (; l < z->size; ++l) x[l] = 0; } } else if ((z->y>>4&0xf) == BCF_HT_INT) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); for (l = 0;; ++t) { if (*t == '.') { x[l++] = bcf_int32_missing, ++t;                     } else { overflow = 0; char *te; long int tmp_val = hts_str2int(t, &te, sizeof(tmp_val)*CHAR_BIT, &overflow); if ( te==t || overflow || tmp_val<BCF_MIN_BT_INT32 || tmp_val>BCF_MAX_BT_INT32 ) { if ( !extreme_val_warned ) { hts_log_warning(""Extreme FORMAT/%s value encountered and set to missing at %s:%""PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname_safe(h,v), v->pos+1); extreme_val_warned = 1; } tmp_val = bcf_int32_missing; } x[l++] = tmp_val; t = te; } if (*t != ',') break; } if ( !l ) x[l++] = bcf_int32_missing; for (; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else if ((z->y>>4&0xf) == BCF_HT_REAL) { float *x = (float*)(z->buf + z->size * (size_t)m); for (l = 0;; ++t) { if (*t == '.' && !isdigit_c(t[1])) { bcf_float_set_missing(x[l++]), ++t;                     } else { overflow = 0; char *te; float tmp_val = hts_str2dbl(t, &te, &overflow); if ( (te==t || overflow) && !extreme_val_warned ) { hts_log_warning(""Extreme FORMAT/%s value encountered at %s:%""PRIhts_pos, h->id[BCF_DT_ID][fmt[j-1].key].key, bcf_seqname(h,v), v->pos+1); extreme_val_warned = 1; } x[l++] = tmp_val; t = te; } if (*t != ',') break; } if ( !l ) bcf_float_set_missing(x[l++]);                    for (; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]); } else { hts_log_error(""Unknown FORMAT field type %d at %s:%""PRIhts_pos, z->y>>4&0xf, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_TAG_INVALID; return -1; } if (*t == '\0') { break; } else if (*t == ':') { t++; } else { char buffer[8]; hts_log_error(""Invalid character %s in '%s' FORMAT field at %s:%""PRIhts_pos"""", hts_strprint(buffer, sizeof buffer, '\'', t, 1), h->id[BCF_DT_ID][z->key].key, bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_CHAR; return -1; } } for (; j < v->n_fmt; ++j) {             fmt_aux_t *z = &fmt[j]; if ((z->y>>4&0xf) == BCF_HT_STR) { if (z->is_gt) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); if (z->size) x[0] = bcf_int32_missing; for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else { char *x = (char*)z->buf + z->size * (size_t)m; if ( z->size ) x[0] = '.'; for (l = 1; l < z->size; ++l) x[l] = 0; } } else if ((z->y>>4&0xf) == BCF_HT_INT) { int32_t *x = (int32_t*)(z->buf + z->size * (size_t)m); x[0] = bcf_int32_missing; for (l = 1; l < z->size>>2; ++l) x[l] = bcf_int32_vector_end; } else if ((z->y>>4&0xf) == BCF_HT_REAL) { float *x = (float*)(z->buf + z->size * (size_t)m); bcf_float_set_missing(x[0]); for (l = 1; l < z->size>>2; ++l) bcf_float_set_vector_end(x[l]); } } m++; t++; } kstring_t *str = &v->indiv; int i; if (v->n_sample > 0) { for (i = 0; i < v->n_fmt; ++i) { fmt_aux_t *z = &fmt[i]; bcf_enc_int1(str, z->key); if ((z->y>>4&0xf) == BCF_HT_STR && !z->is_gt) { bcf_enc_size(str, z->size, BCF_BT_CHAR); kputsn((char*)z->buf, z->size * (size_t)v->n_sample, str); } else if ((z->y>>4&0xf) == BCF_HT_INT || z->is_gt) { bcf_enc_vint(str, (z->size>>2) * v->n_sample, (int32_t*)z->buf, z->size>>2); } else { bcf_enc_size(str, z->size>>2, BCF_BT_FLOAT); if (serialize_float_array(str, (z->size>>2) * (size_t)v->n_sample, (float *) z->buf) != 0) { v->errcode |= BCF_ERR_LIMITS; hts_log_error(""Out of memory at %s:%""PRIhts_pos, bcf_seqname_safe(h,v), v->pos+1); return -1; } } } } if ( v->n_sample!=bcf_hdr_nsamples(h) ) { hts_log_error(""Number of columns at %s:%""PRIhts_pos"" does not match the number of samples (%d vs %d)"", bcf_seqname_safe(h,v), v->pos+1, v->n_sample, bcf_hdr_nsamples(h)); v->errcode |= BCF_ERR_NCOLS; return -1; } if ( v->indiv.l > 0xffffffff ) { hts_log_error(""The FORMAT at %s:%""PRIhts_pos"" is too long"", bcf_seqname_safe(h,v), v->pos+1); v->errcode |= BCF_ERR_LIMITS; v->n_fmt = 0; return -1; } return 0; }"
"static Image *ExtractPostscript(Image *image,const ImageInfo *image_info, MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception) { char postscript_file[MaxTextExtent]; const MagicInfo *magic_info; FILE *ps_file; ImageInfo *clone_info; Image *image2; unsigned char magick[2*MaxTextExtent]; if ((clone_info=CloneImageInfo(image_info)) == NULL) return(image); clone_info->blob=(void *) NULL; clone_info->length=0; (void) AcquireUniqueFilename(postscript_file); ps_file=fopen_utf8(postscript_file,""wb""); if (ps_file == (FILE *) NULL) goto FINISH; (void) SeekBlob(image,PS_Offset,SEEK_SET); (void) ReadBlob(image, 2*MaxTextExtent, magick); (void) SeekBlob(image,PS_Offset,SEEK_SET); while(PS_Size-- > 0) { (void) fputc(ReadBlobByte(image),ps_file); } (void) fclose(ps_file); magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception); if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL; if(exception->severity != UndefinedException) goto FINISH_UNL; if(magic_info->name == (char *) NULL) goto FINISH_UNL; (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1); FormatLocaleString(clone_info->filename,MaxTextExtent,""%s"",postscript_file); image2=ReadImage(clone_info,exception); if (!image2) goto FINISH_UNL; (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent); (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent); (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent); image2->depth=image->depth; DestroyBlob(image2); image2->blob=ReferenceBlob(image->blob); if ((image->rows == 0) || (image->columns == 0)) DeleteImageFromList(&image); AppendImageToList(&image,image2); FINISH_UNL: (void) RelinquishUniqueFileResource(postscript_file); FINISH: DestroyImageInfo(clone_info); return(image); }"
"static int pop_fetch_headers(struct Context *ctx) { struct PopData *pop_data = (struct PopData *) ctx->data; struct Progress progress; #ifdef USE_HCACHE header_cache_t *hc = pop_hcache_open(pop_data, ctx->path); #endif time(&pop_data->check_time); pop_data->clear_cache = false; for (int i = 0; i < ctx->msgcount; i++) ctx->hdrs[i]->refno = -1; const int old_count = ctx->msgcount; int ret = pop_fetch_data(pop_data, ""UIDL\r\n"", NULL, fetch_uidl, ctx); const int new_count = ctx->msgcount; ctx->msgcount = old_count; if (pop_data->cmd_uidl == 2) { if (ret == 0) { pop_data->cmd_uidl = 1; mutt_debug(1, ""set UIDL capability\n""); } if (ret == -2 && pop_data->cmd_uidl == 2) { pop_data->cmd_uidl = 0; mutt_debug(1, ""unset UIDL capability\n""); snprintf(pop_data->err_msg, sizeof(pop_data->err_msg), ""%s"", _(""Command UIDL is not supported by server."")); } } if (!ctx->quiet) { mutt_progress_init(&progress, _(""Fetching message headers...""), MUTT_PROGRESS_MSG, ReadInc, new_count - old_count); } if (ret == 0) { int i, deleted; for (i = 0, deleted = 0; i < old_count; i++) { if (ctx->hdrs[i]->refno == -1) { ctx->hdrs[i]->deleted = true; deleted++; } } if (deleted > 0) { mutt_error( ngettext(""%d message has been lost. Try reopening the mailbox."", ""%d messages have been lost. Try reopening the mailbox."", deleted), deleted); } bool hcached = false; for (i = old_count; i < new_count; i++) { if (!ctx->quiet) mutt_progress_update(&progress, i + 1 - old_count, -1); #ifdef USE_HCACHE void *data = mutt_hcache_fetch(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data)); if (data) { char *uidl = mutt_str_strdup(ctx->hdrs[i]->data); int refno = ctx->hdrs[i]->refno; int index = ctx->hdrs[i]->index; struct Header *h = mutt_hcache_restore((unsigned char *) data); mutt_hcache_free(hc, &data); mutt_header_free(&ctx->hdrs[i]); ctx->hdrs[i] = h; ctx->hdrs[i]->refno = refno; ctx->hdrs[i]->index = index; ctx->hdrs[i]->data = uidl; ret = 0; hcached = true; } else #endif if ((ret = pop_read_header(pop_data, ctx->hdrs[i])) < 0) break; #ifdef USE_HCACHE else { mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data), ctx->hdrs[i], 0); } #endif const bool bcached = (mutt_bcache_exists(pop_data->bcache, ctx->hdrs[i]->data) == 0); ctx->hdrs[i]->old = false; ctx->hdrs[i]->read = false; if (hcached) { if (bcached) ctx->hdrs[i]->read = true; else if (MarkOld) ctx->hdrs[i]->old = true; } else { if (bcached) ctx->hdrs[i]->read = true; } ctx->msgcount++; } if (i > old_count) mx_update_context(ctx, i - old_count); } #ifdef USE_HCACHE mutt_hcache_close(hc); #endif if (ret < 0) { for (int i = ctx->msgcount; i < new_count; i++) mutt_header_free(&ctx->hdrs[i]); return ret; } if (MessageCacheClean) mutt_bcache_list(pop_data->bcache, msg_cache_check, (void *) ctx); mutt_clear_error(); return (new_count - old_count); }"
"static int am_handle_repost(request_rec *r) { am_mod_cfg_rec *mod_cfg; const char *query; const char *enctype; char *charset; char *psf_id; char *cp; char *psf_filename; char *post_data; const char *post_form; char *output; char *return_url; const char *(*post_mkform)(request_rec *, const char *); if (am_cookie_get(r) == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Repost query without a session""); return HTTP_FORBIDDEN; } mod_cfg = am_get_mod_cfg(r->server); if (!mod_cfg->post_dir) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Repost query without MellonPostDirectory.""); return HTTP_NOT_FOUND; } query = r->parsed_uri.query; enctype = am_extract_query_parameter(r->pool, query, ""enctype""); if (enctype == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: missing enctype""); return HTTP_BAD_REQUEST; } if (strcmp(enctype, ""urlencoded"") == 0) { enctype = ""application/x-www-form-urlencoded""; post_mkform = am_post_mkform_urlencoded; } else if (strcmp(enctype, ""multipart"") == 0) { enctype = ""multipart/form-data""; post_mkform = am_post_mkform_multipart; } else { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: invalid enctype \""%s\""."", enctype); return HTTP_BAD_REQUEST; } charset = am_extract_query_parameter(r->pool, query, ""charset""); if (charset != NULL) { if (am_urldecode(charset) != OK) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: invalid charset \""%s\"""", charset); return HTTP_BAD_REQUEST; } for (cp = charset; *cp; cp++) { if (!apr_isalnum(*cp) && (*cp != '-') && (*cp != '_')) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: invalid charset \""%s\"""", charset); return HTTP_BAD_REQUEST; } } } psf_id = am_extract_query_parameter(r->pool, query, ""id""); if (psf_id == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: missing id""); return HTTP_BAD_REQUEST; } for (cp = psf_id; *cp; cp++) { if (!apr_isalnum(*cp)) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,  ""Bad repost query: invalid id \""%s\"""", psf_id); return HTTP_BAD_REQUEST; } } return_url = am_extract_query_parameter(r->pool, query, ""ReturnTo""); if (return_url == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Invalid or missing query ReturnTo parameter.""); return HTTP_BAD_REQUEST; } if (am_urldecode(return_url) != OK) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""Bad repost query: return""); return HTTP_BAD_REQUEST; } psf_filename = apr_psprintf(r->pool, ""%s/%s"", mod_cfg->post_dir, psf_id); post_data = am_getfile(r->pool, r->server, psf_filename); if (post_data == NULL) { ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, ""Bad repost query: cannot find \""%s\"""", psf_filename); apr_table_setn(r->headers_out, ""Location"", return_url); return HTTP_SEE_OTHER; } if ((post_form = (*post_mkform)(r, post_data)) == NULL) { ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, ""am_post_mkform() failed""); return HTTP_INTERNAL_SERVER_ERROR; } if (charset != NULL) { ap_set_content_type(r, apr_psprintf(r->pool, ""text/html; charset=\""%s\"""", charset)); charset = apr_psprintf(r->pool, "" accept-charset=\""%s\"""", charset); } else { ap_set_content_type(r, ""text/html""); charset = (char *)""""; } output = apr_psprintf(r->pool, ""<!DOCTYPE HTML PUBLIC \""-      ""<html>\n"" "" <head>\n""  ""  <title>SAML rePOST request</title>\n""  "" </head>\n""  "" <body onload=\""document.getElementById('form').submit();\"">\n""  ""  <noscript>\n"" ""   Your browser does not support Javascript, \n"" ""   you must click the button below to proceed.\n"" ""  </noscript>\n"" ""   <form id=\""form\"" method=\""POST\"" action=\""%s\"" enctype=\""%s\""%s>\n%s"" ""    <noscript>\n"" ""     <input type=\""submit\"">\n"" ""    </noscript>\n"" ""   </form>\n"" "" </body>\n""  ""</html>\n"", am_htmlencode(r, return_url), enctype, charset, post_form); ap_rputs(output, r); return OK; }"
"void  png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length) { png_alloc_size_t limit = PNG_UINT_31_MAX; # ifdef PNG_SET_USER_LIMITS_SUPPORTED if (png_ptr->user_chunk_malloc_max > 0 && png_ptr->user_chunk_malloc_max < limit) limit = png_ptr->user_chunk_malloc_max; # elif PNG_USER_CHUNK_MALLOC_MAX > 0 if (PNG_USER_CHUNK_MALLOC_MAX < limit) limit = PNG_USER_CHUNK_MALLOC_MAX; # endif if (png_ptr->chunk_name == png_IDAT) { png_alloc_size_t idat_limit = PNG_UINT_31_MAX; size_t row_factor = (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1) + 1 + (png_ptr->interlaced? 6: 0)); if (png_ptr->height > PNG_UINT_32_MAX/row_factor) idat_limit=PNG_UINT_31_MAX; else idat_limit = png_ptr->height * row_factor; row_factor = row_factor > 32566? 32566 : row_factor; idat_limit += 6 + 5*(idat_limit/row_factor+1);  idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX; limit = limit < idat_limit? idat_limit : limit; } if (length > limit) { png_debug2(0,"" length = %lu, limit = %lu"", (unsigned long)length,(unsigned long)limit); png_chunk_error(png_ptr, ""chunk data is too large""); } }"
"static void mntput_no_expire(struct mount *mnt) { rcu_read_lock(); mnt_add_count(mnt, -1); if (likely(mnt->mnt_ns)) {  rcu_read_unlock(); return; } lock_mount_hash(); if (mnt_get_count(mnt)) { rcu_read_unlock(); unlock_mount_hash(); return; } if (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) { rcu_read_unlock(); unlock_mount_hash(); return; } mnt->mnt.mnt_flags |= MNT_DOOMED; rcu_read_unlock(); list_del(&mnt->mnt_instance); unlock_mount_hash(); if (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) { struct task_struct *task = current; if (likely(!(task->flags & PF_KTHREAD))) { init_task_work(&mnt->mnt_rcu, __cleanup_mnt); if (!task_work_add(task, &mnt->mnt_rcu, true)) return; } if (llist_add(&mnt->mnt_llist, &delayed_mntput_list)) schedule_delayed_work(&delayed_mntput_work, 1); return; } cleanup_mnt(mnt); }"
"int Tar::ExtractData(std::istream& aTarStreamIn, wxString destdir, wxProgressDialog* aProgressDialog) { int lError = 0; unsigned long lTotalBytes = 0; unsigned long lTotalBytesRead = 0; aTarStreamIn.seekg(0, std::ios::end); unsigned long lEnd = static_cast<unsigned long>(aTarStreamIn.tellg()); aTarStreamIn.seekg(0, std::ios::beg); lTotalBytes = lEnd - static_cast<unsigned long>(aTarStreamIn.tellg()); wxString lPreviousWorkingDirectory(::wxGetCwd()); ::wxSetWorkingDirectory(destdir); int ebufsiz = 8192; char buffer[ebufsiz]; for (unsigned int lTarRecordIndex = 0; lTarRecordIndex < TarRecords.size(); ++lTarRecordIndex) { TarRecord lCurrentTarRecord = TarRecords.at(lTarRecordIndex); wxString lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvUTF8); if (lCurrentFilePath.IsEmpty()) { lCurrentFilePath = wxString(lCurrentTarRecord.Name, wxConvISO8859_1); } wxString lCurrentDirectory(lCurrentFilePath.substr(0, lCurrentFilePath.find_last_of('/'))); if (lCurrentFilePath.compare(_T(""\xFF"")) == 0)         { if (lTarRecordIndex != TarRecords.size() - 1) { lError = 1; wxLogError(_(""Got bad file %d/%d.  Skipping.""), lTarRecordIndex, TarRecords.size() ); } } else { if (::wxDirExists(lCurrentDirectory) == false) { wxFileName::Mkdir(lCurrentDirectory, 0777, wxPATH_MKDIR_FULL); } char lLastCharacter = lCurrentFilePath[lCurrentFilePath.length() - 1]; if (lLastCharacter != '\\' && lLastCharacter != '/') { wxFile wx_Out(lCurrentFilePath, wxFile::write); if (!wx_Out.IsOpened()) { wxLogError(_(""Error: Improperly archived file '%s'.  Skipping.""), lCurrentFilePath); lError = 1; continue; } __gnu_cxx::stdio_filebuf<char> filebuf(wx_Out.fd(), std::ios::out); std::ostream lStreamOut(&filebuf); aTarStreamIn.seekg(lCurrentTarRecord.iFilePosBegin, std::ios::beg); long remaining = lCurrentTarRecord.iFileSize; while (remaining > 0) { int bufsiz = remaining; if (bufsiz > ebufsiz) bufsiz = ebufsiz; aTarStreamIn.read(buffer, bufsiz); lStreamOut.write(buffer, bufsiz); remaining -= bufsiz; } lTotalBytesRead += lCurrentTarRecord.iFileSize; lStreamOut.flush(); wx_Out.Close(); } if( aProgressDialog != NULL ) { double lPercent( 100.0 * lTotalBytesRead / lTotalBytes ) ; if ( lPercent >= 100 ) { lPercent = 99.0; } aProgressDialog->Update(static_cast<int>(lPercent), lCurrentFilePath); ::wxYield(); } } } aProgressDialog->Update(100, _(""Done."")); ::wxSetWorkingDirectory(lPreviousWorkingDirectory); return lError; }"
"static void input_l2cap_frame_flow_channel(l2cap_channel_t *channel, uint8_t *data, uint16_t data_len) { uint16_t frame_len; uint16_t payload_len; if(data_len < 4) { LOG_WARN(""l2cap_frame: illegal L2CAP frame data_len: %d\n"", data_len); return; } if(channel->rx_buffer.sdu_length == 0) { memcpy(&frame_len, &data[0], 2); payload_len = frame_len - 2; if(payload_len > BLE_L2CAP_NODE_MTU) { LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len); return; } memcpy(&channel->rx_buffer.sdu_length, &data[4], 2); memcpy(channel->rx_buffer.sdu, &data[6], payload_len); channel->rx_buffer.current_index = payload_len; } else { memcpy(&frame_len, &data[0], 2); payload_len = frame_len; if(payload_len > BLE_L2CAP_NODE_MTU - channel->rx_buffer.current_index) { LOG_WARN(""l2cap_frame: illegal L2CAP frame payload_len: %d\n"", payload_len); return; } memcpy(&channel->rx_buffer.sdu[channel->rx_buffer.current_index], &data[4], payload_len); channel->rx_buffer.current_index += payload_len; } if((channel->rx_buffer.sdu_length > 0) && (channel->rx_buffer.sdu_length == channel->rx_buffer.current_index)) { memcpy(packetbuf_dataptr(), channel->rx_buffer.sdu, channel->rx_buffer.sdu_length); packetbuf_set_datalen(channel->rx_buffer.sdu_length); NETSTACK_NETWORK.input(); channel->rx_buffer.sdu_length = 0; channel->rx_buffer.current_index = 0; } }"
"static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) { redisContext *c = &(ac->c); redisAeEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisAeEvents*)hiredis_safe_malloc(sizeof(*e)); e->context = ac; e->loop = loop; e->fd = c->fd; e->reading = e->writing = 0; ac->ev.addRead = redisAeAddRead; ac->ev.delRead = redisAeDelRead; ac->ev.addWrite = redisAeAddWrite; ac->ev.delWrite = redisAeDelWrite; ac->ev.cleanup = redisAeCleanup; ac->ev.data = e; return REDIS_OK; }"
"bz3_state * bz3_new(s32 block_size) { if (block_size < KiB(65) || block_size > MiB(511)) { return NULL; } struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state)); if (!bz3_state) { return NULL; } bz3_state->cm_state = malloc(sizeof(state)); bz3_state->swap_buffer = malloc(bz3_bound(block_size)); bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32)); memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128)); bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32)); if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) { if (bz3_state->cm_state) free(bz3_state->cm_state); if (bz3_state->swap_buffer) free(bz3_state->swap_buffer); if (bz3_state->sais_array) free(bz3_state->sais_array); if (bz3_state->lzp_lut) free(bz3_state->lzp_lut); free(bz3_state); return NULL; } bz3_state->block_size = block_size; bz3_state->last_error = BZ3_OK; return bz3_state; }"
"static request_data_t * get_request(tvbuff_t *tvb, gint offset, packet_info *pinfo, guint8 opcode, bluetooth_data_t *bluetooth_data) { request_data_t  *request_data; wmem_tree_key_t  key[4]; wmem_tree_t     *sub_wmemtree; gint             frame_number; key[0].length = 1; key[0].key    = &bluetooth_data->interface_id; key[1].length = 1; key[1].key    = &bluetooth_data->adapter_id; key[2].length = 0; key[2].key    = NULL; frame_number = pinfo->num; sub_wmemtree = (wmem_tree_t *) wmem_tree_lookup32_array(requests, key); request_data = (sub_wmemtree) ? (request_data_t *) wmem_tree_lookup32_le(sub_wmemtree, frame_number) : NULL; if (request_data && request_data->request_in_frame == pinfo->num) return request_data; if (request_data) do { frame_number = request_data->request_in_frame - 1; if (request_data->request_in_frame == pinfo->num) break; switch (opcode) { case 0x01:  if (tvb_captured_length_remaining(tvb, offset) < 1) return NULL; opcode = tvb_get_guint8(tvb, 1) + 1; case 0x03:  case 0x05:  case 0x07:  case 0x09:  case 0x0b:  case 0x0d:  case 0x0f:  case 0x11:  case 0x13:  case 0x17:  case 0x19:  case 0x1E:  if (request_data->opcode == opcode -1) return request_data; break; } } while(0); request_data = (sub_wmemtree) ? (request_data_t *) wmem_tree_lookup32_le(sub_wmemtree, frame_number) : NULL; if (!request_data) return NULL; if (request_data->request_in_frame == pinfo->num) return request_data; switch (opcode) { case 0x01:  if (tvb_captured_length_remaining(tvb, offset) < 1) return NULL; opcode = tvb_get_guint8(tvb, 1) + 1; case 0x03:  case 0x05:  case 0x07:  case 0x09:  case 0x0b:  case 0x0d:  case 0x0f:  case 0x11:  case 0x13:  case 0x17:  case 0x19:  case 0x1E:  if (request_data->opcode == opcode -1) return request_data; break; case 0x1B:  case 0x52:  case 0xD2:  return NULL; case 0x02:  case 0x04:  case 0x06:  case 0x08:  case 0x0a:  case 0x0c:  case 0x0e:  case 0x10:  case 0x12:  case 0x16:  case 0x18:  case 0x1D:  default: return NULL; } return NULL; }"
"static struct clock_source *dce120_clock_source_create( struct dc_context *ctx, struct dc_bios *bios, enum clock_source_id id, const struct dce110_clk_src_regs *regs, bool dp_clk_src) { struct dce110_clk_src *clk_src = kzalloc(sizeof(*clk_src), GFP_KERNEL); if (!clk_src) return NULL; if (dce112_clk_src_construct(clk_src, ctx, bios, id, regs, &cs_shift, &cs_mask)) { clk_src->base.dp_clk_src = dp_clk_src; return &clk_src->base; } BREAK_TO_DEBUGGER(); return NULL; }"
"static void g_socket_client_async_connect_data_free (GSocketClientAsyncConnectData *data) { g_clear_object (&data->connectable); g_clear_object (&data->enumerator); g_clear_object (&data->proxy_addr); g_clear_object (&data->socket); g_clear_object (&data->connection); g_slist_free_full (data->connection_attempts, connection_attempt_unref); g_clear_error (&data->last_error); g_slice_free (GSocketClientAsyncConnectData, data); }"
"void eap_print(netdissect_options *ndo, register const u_char *cp, u_int length) { const struct eap_frame_t *eap; const u_char *tptr; u_int tlen, type, subtype; int count=0, len; tptr = cp; tlen = length; eap = (const struct eap_frame_t *)cp; ND_TCHECK(*eap); if (ndo->ndo_vflag < 1) { ND_PRINT((ndo, ""%s (%u) v%u, len %u"", tok2str(eap_frame_type_values, ""unknown"", eap->type), eap->type, eap->version, EXTRACT_16BITS(eap->length))); return; } ND_PRINT((ndo, ""%s (%u) v%u, len %u"", tok2str(eap_frame_type_values, ""unknown"", eap->type), eap->type, eap->version, EXTRACT_16BITS(eap->length))); tptr += sizeof(const struct eap_frame_t); tlen -= sizeof(const struct eap_frame_t); switch (eap->type) { case EAP_FRAME_TYPE_PACKET: type = *(tptr); len = EXTRACT_16BITS(tptr+2); ND_PRINT((ndo, "", %s (%u), id %u, len %u"", tok2str(eap_code_values, ""unknown"", type), type, *(tptr+1), len)); ND_TCHECK2(*tptr, len); if (type <= 2) {  subtype = *(tptr+4); ND_PRINT((ndo, ""\n\t\t Type %s (%u)"", tok2str(eap_type_values, ""unknown"", *(tptr+4)), *(tptr + 4))); switch (subtype) { case EAP_TYPE_IDENTITY: if (len - 5 > 0) { ND_PRINT((ndo, "", Identity: "")); safeputs(ndo, tptr + 5, len - 5); } break; case EAP_TYPE_NOTIFICATION: if (len - 5 > 0) { ND_PRINT((ndo, "", Notification: "")); safeputs(ndo, tptr + 5, len - 5); } break; case EAP_TYPE_NAK: count = 5; while (count < len) { ND_PRINT((ndo, "" %s (%u),"", tok2str(eap_type_values, ""unknown"", *(tptr+count)), *(tptr + count))); count++; } break; case EAP_TYPE_TTLS: ND_PRINT((ndo, "" TTLSv%u"", EAP_TTLS_VERSION(*(tptr + 5))));  case EAP_TYPE_TLS: ND_PRINT((ndo, "" flags [%s] 0x%02x,"", bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)), *(tptr + 5))); if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) { ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6))); } break; case EAP_TYPE_FAST: ND_PRINT((ndo, "" FASTv%u"", EAP_TTLS_VERSION(*(tptr + 5)))); ND_PRINT((ndo, "" flags [%s] 0x%02x,"", bittok2str(eap_tls_flags_values, ""none"", *(tptr+5)), *(tptr + 5))); if (EAP_TLS_EXTRACT_BIT_L(*(tptr+5))) { ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6))); } break; case EAP_TYPE_AKA: case EAP_TYPE_SIM: ND_PRINT((ndo, "" subtype [%s] 0x%02x,"", tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)), *(tptr + 5))); break; case EAP_TYPE_MD5_CHALLENGE: case EAP_TYPE_OTP: case EAP_TYPE_GTC: case EAP_TYPE_EXPANDED_TYPES: case EAP_TYPE_EXPERIMENTAL: default: break; } } break; case EAP_FRAME_TYPE_LOGOFF: case EAP_FRAME_TYPE_ENCAP_ASF_ALERT: default: break; } return; trunc: ND_PRINT((ndo, ""\n\t[|EAP]"")); }"
"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) { OpData* op_data = reinterpret_cast<OpData*>(node->user_data); int num_inputs = node->inputs->size; TF_LITE_ENSURE_EQ(context, node->outputs->size, num_inputs); Subgraph* this_subgraph = reinterpret_cast<Subgraph*>(context->impl_); auto* subgraphs = this_subgraph->GetSubgraphs(); TF_LITE_ENSURE(context, op_data->cond_subgraph_index < subgraphs->size()); TF_LITE_ENSURE(context, op_data->body_subgraph_index < subgraphs->size()); Subgraph* cond_subgraph = (*subgraphs)[op_data->cond_subgraph_index].get(); Subgraph* body_subgraph = (*subgraphs)[op_data->body_subgraph_index].get(); TF_LITE_ENSURE_EQ(context, cond_subgraph->inputs().size(), num_inputs); TF_LITE_ENSURE_EQ(context, cond_subgraph->outputs().size(), 1); TF_LITE_ENSURE_EQ(context, body_subgraph->inputs().size(), num_inputs); TF_LITE_ENSURE_EQ(context, body_subgraph->outputs().size(), num_inputs); TF_LITE_ENSURE_OK( context, CopyTensorsShapeAndType( context, this_subgraph, TfLiteIntArrayView(node->inputs), cond_subgraph, cond_subgraph->inputs(), true)); TF_LITE_ENSURE_OK(context, cond_subgraph->AllocateTensors()); TfLiteTensor* cond_output = cond_subgraph->tensor(cond_subgraph->outputs()[0]); if (IsDynamicTensor(cond_output)) { op_data->cond_has_dynamic_output_tensors = true; } else { TF_LITE_ENSURE_STATUS(CheckCondOutput(context, cond_output)); } TF_LITE_ENSURE_OK( context, CopyTensorsShapeAndType( context, this_subgraph, TfLiteIntArrayView(node->inputs), body_subgraph, body_subgraph->inputs(), true)); TF_LITE_ENSURE_OK(context, body_subgraph->AllocateTensors()); if (body_subgraph->HasDynamicTensors()) { op_data->body_has_dynamic_output_tensors = true; } else { for (int i = 0; i < num_inputs; ++i) { TfLiteTensor* body_input = body_subgraph->tensor(body_subgraph->inputs()[i]); TfLiteTensor* body_output = body_subgraph->tensor(body_subgraph->outputs()[i]); TF_LITE_ENSURE_TYPES_EQ(context, body_input->type, body_output->type); TF_LITE_ENSURE(context, !IsDynamicTensor(body_output)); if (!TfLiteIntArrayEqual(body_input->dims, body_output->dims)) { op_data->body_has_dynamic_output_tensors = true; break; } } } for (int i = 0; i < num_inputs; ++i) { TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output)); if (op_data->body_has_dynamic_output_tensors) { SetTensorToDynamic(output); } else { TfLiteTensor* body_output = body_subgraph->tensor(body_subgraph->outputs()[i]); TfLiteIntArray* output_size = TfLiteIntArrayCopy(body_output->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, output, output_size)); } } return kTfLiteOk; }"
"static RzList  *__io_maps(RzDebug *dbg) { RzList *list = rz_list_new(); char *str = dbg->iob.system(dbg->iob.io, ""dm""); if (!str) { rz_list_free(list); return NULL; } char *ostr = str; ut64 map_start, map_end; char perm[32]; char name[512]; for (;;) { char *nl = strchr(str, '\n'); if (nl) { *nl = 0; *name = 0; *perm = 0; map_start = map_end = 0LL; if (!strncmp(str, ""sys "", 4)) { char *sp = strchr(str + 4, ' '); if (sp) { str = sp + 1; } else { str += 4; } } char *_s_ = strstr(str, "" s ""); if (_s_) { memmove(_s_, _s_ + 2, strlen(_s_)); } _s_ = strstr(str, "" ? ""); if (_s_) { memmove(_s_, _s_ + 2, strlen(_s_)); } sscanf(str, ""0x%"" PFMT64x "" - 0x%"" PFMT64x "" %s %s"", &map_start, &map_end, perm, name); if (map_end != 0LL) { RzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0); rz_list_append(list, map); } str = nl + 1; } else { break; } } free(ostr); rz_cons_reset(); return list; }"
"void blk_cleanup_queue(struct request_queue *q) { mutex_lock(&q->sysfs_lock); blk_set_queue_dying(q); blk_queue_flag_set(QUEUE_FLAG_NOMERGES, q); blk_queue_flag_set(QUEUE_FLAG_NOXMERGES, q); blk_queue_flag_set(QUEUE_FLAG_DYING, q); mutex_unlock(&q->sysfs_lock); blk_freeze_queue(q); rq_qos_exit(q); blk_queue_flag_set(QUEUE_FLAG_DEAD, q); blk_flush_integrity(); del_timer_sync(&q->backing_dev_info->laptop_mode_wb_timer); blk_sync_queue(q); if (queue_is_mq(q)) blk_mq_exit_queue(q); percpu_ref_exit(&q->q_usage_counter); blk_put_queue(q); }"
"void proto_register_blip(void) { static hf_register_info hf[] = { { &hf_blip_message_number, { ""Message Number"", ""blip.messagenum"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_frame_flags, { ""Frame Flags"", ""blip.frameflags"", FT_UINT8, BASE_HEX | BASE_EXT_STRING, &flag_combos_ext, 0x0, NULL, HFILL } }, { &hf_blip_properties_length, { ""Properties Length"", ""blip.propslength"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_properties, { ""Properties"", ""blip.props"", FT_STRING, STR_UNICODE, NULL, 0x0, NULL, HFILL } }, { &hf_blip_message_body, { ""Message Body"", ""blip.messagebody"", FT_STRING, STR_UNICODE, NULL, 0x0, NULL, HFILL } }, { &hf_blip_ack_size, { ""ACK num bytes"", ""blip.numackbytes"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_blip_checksum, { ""Checksum"", ""blip.checksum"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } } }; static gint *ett[] = { &ett_blip }; proto_blip = proto_register_protocol(""BLIP Couchbase Mobile"", ""BLIP"", ""blip""); proto_register_field_array(proto_blip, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); blip_handle = register_dissector(""blip"", dissect_blip, proto_blip); }"
"void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) { if (!req->parse()) { std::cout << ""["" << cl->getClientIP() << ""] There was an error processing the request of type: "" << req->methodIntToStr(req->getMethod()) << std::endl; std::cout << req->getParseError() << std::endl; sendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError()); return; } std::cout << ""["" << cl->getClientIP() << ""] "" << req->methodIntToStr(req->getMethod()) << "" "" << req->getRequestUri() << std::endl; ResourceHost* resHost = NULL; std::string host = """"; if (req->getVersion().compare(HTTP_VERSION_11) == 0) { host = req->getHeaderValue(""Host""); if (host.find("":"") == std::string::npos) { host.append("":"" + std::to_string(listenPort)); } std::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host); if (it != vhosts.end()) resHost = it->second; } else { if (hostList.size() > 0) resHost = hostList[0]; } if (resHost == NULL) { sendStatusResponse(cl, Status(BAD_REQUEST), ""Invalid/No Host specified: "" + host); return; } switch (req->getMethod()) { case Method(HEAD): case Method(GET): handleGet(cl, req, resHost); break; case Method(OPTIONS): handleOptions(cl, req); break; case Method(TRACE): handleTrace(cl, req); break; default: std::cout << ""["" << cl->getClientIP() << ""] Could not handle or determine request of type "" << req->methodIntToStr(req->getMethod()) << std::endl; sendStatusResponse(cl, Status(NOT_IMPLEMENTED)); break; } }"
"static int sctp_init_sock(struct sock *sk) { struct net *net = sock_net(sk); struct sctp_sock *sp; pr_debug(""%s: sk:%p\n"", __func__, sk); sp = sctp_sk(sk); switch (sk->sk_type) { case SOCK_SEQPACKET: sp->type = SCTP_SOCKET_UDP; break; case SOCK_STREAM: sp->type = SCTP_SOCKET_TCP; break; default: return -ESOCKTNOSUPPORT; } sk->sk_gso_type = SKB_GSO_SCTP; sp->default_stream = 0; sp->default_ppid = 0; sp->default_flags = 0; sp->default_context = 0; sp->default_timetolive = 0; sp->default_rcv_context = 0; sp->max_burst = net->sctp.max_burst; sp->sctp_hmac_alg = net->sctp.sctp_hmac_alg; sp->initmsg.sinit_num_ostreams   = sctp_max_outstreams; sp->initmsg.sinit_max_instreams  = sctp_max_instreams; sp->initmsg.sinit_max_attempts   = net->sctp.max_retrans_init; sp->initmsg.sinit_max_init_timeo = net->sctp.rto_max; sp->rtoinfo.srto_initial = net->sctp.rto_initial; sp->rtoinfo.srto_max     = net->sctp.rto_max; sp->rtoinfo.srto_min     = net->sctp.rto_min; sp->assocparams.sasoc_asocmaxrxt = net->sctp.max_retrans_association; sp->assocparams.sasoc_number_peer_destinations = 0; sp->assocparams.sasoc_peer_rwnd = 0; sp->assocparams.sasoc_local_rwnd = 0; sp->assocparams.sasoc_cookie_life = net->sctp.valid_cookie_life; sp->subscribe = 0; sp->hbinterval  = net->sctp.hb_interval; sp->udp_port    = htons(net->sctp.udp_port); sp->encap_port  = htons(net->sctp.encap_port); sp->pathmaxrxt  = net->sctp.max_retrans_path; sp->pf_retrans  = net->sctp.pf_retrans; sp->ps_retrans  = net->sctp.ps_retrans; sp->pf_expose   = net->sctp.pf_expose; sp->pathmtu     = 0;  sp->sackdelay   = net->sctp.sack_timeout; sp->sackfreq= 2; sp->param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE; sp->default_ss = SCTP_SS_DEFAULT; sp->disable_fragments = 0; sp->nodelay           = 0; sp->recvrcvinfo = 0; sp->recvnxtinfo = 0; sp->v4mapped          = 1; sp->autoclose         = 0; sp->user_frag         = 0; sp->adaptation_ind = 0; sp->pf = sctp_get_pf_specific(sk->sk_family); atomic_set(&sp->pd_mode, 0); skb_queue_head_init(&sp->pd_lobby); sp->frag_interleave = 0; sp->ep = sctp_endpoint_new(sk, GFP_KERNEL); if (!sp->ep) return -ENOMEM; sp->hmac = NULL; sk->sk_destruct = sctp_destruct_sock; SCTP_DBG_OBJCNT_INC(sock); local_bh_disable(); sk_sockets_allocated_inc(sk); sock_prot_inuse_add(net, sk->sk_prot, 1); if (net->sctp.default_auto_asconf) { spin_lock(&sock_net(sk)->sctp.addr_wq_lock); list_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist); sp->do_auto_asconf = 1; spin_unlock(&sock_net(sk)->sctp.addr_wq_lock); } else { sp->do_auto_asconf = 0; } local_bh_enable(); return 0; }"
"ret_t cherokee_handler_cgi_new (cherokee_handler_t **hdl, void *cnt, cherokee_module_props_t *props) { int i; CHEROKEE_NEW_STRUCT (n, handler_cgi); cherokee_handler_cgi_base_init (HDL_CGI_BASE(n), cnt, PLUGIN_INFO_HANDLER_PTR(cgi), HANDLER_PROPS(props), cherokee_handler_cgi_add_env_pair, read_from_cgi); MODULE(n)->init         = (module_func_init_t) cherokee_handler_cgi_init; MODULE(n)->free         = (module_func_free_t) cherokee_handler_cgi_free; HANDLER(n)->read_post   = (handler_func_read_post_t) cherokee_handler_cgi_read_post; HANDLER(n)->add_headers = (handler_func_add_headers_t) cherokee_handler_cgi_base_add_headers; HANDLER(n)->step        = (handler_func_step_t) cherokee_handler_cgi_base_step; n->pipeInput  = -1; n->pipeOutput = -1; n->pid       = -1; n->envp_last =  0; for (i=0; i<ENV_VAR_NUM; i++) n->envp[i] = NULL; *hdl = HANDLER(n); return ret_ok; }"
"void ntlm_print_negotiate_flags(UINT32 flags) { int i; const char* str; WLog_INFO(TAG, ""negotiateFlags \""0x%08""PRIX32""\"""", flags); for (i = 31; i >= 0; i--) { if ((flags >> i) & 1) { str = NTLM_NEGOTIATE_STRINGS[(31 - i)]; WLog_INFO(TAG, ""\t%s (%d),"", str, (31 - i)); } } }"
"int main (int argc, char *argv[]) { struct gengetopt_args_info args_info; char *line = NULL; size_t linelen = 0; char *p, *r; uint32_t *q; unsigned cmdn = 0; int rc; setlocale (LC_ALL, """"); set_program_name (argv[0]); bindtextdomain (PACKAGE, LOCALEDIR); textdomain (PACKAGE); if (cmdline_parser (argc, argv, &args_info) != 0) return EXIT_FAILURE; if (args_info.version_given) { version_etc (stdout, ""idn"", PACKAGE_NAME, VERSION, ""Simon Josefsson"", (char *) NULL); return EXIT_SUCCESS; } if (args_info.help_given) usage (EXIT_SUCCESS); if (args_info.hidden_nfkc_given) args_info.nfkc_given = 1; if (!args_info.stringprep_given && !args_info.punycode_encode_given && !args_info.punycode_decode_given && !args_info.idna_to_ascii_given && !args_info.idna_to_unicode_given && !args_info.nfkc_given) args_info.idna_to_ascii_given = 1; if ((args_info.stringprep_given ? 1 : 0) + (args_info.punycode_encode_given ? 1 : 0) + (args_info.punycode_decode_given ? 1 : 0) + (args_info.idna_to_ascii_given ? 1 : 0) + (args_info.idna_to_unicode_given ? 1 : 0) + (args_info.nfkc_given ? 1 : 0) != 1) { error (0, 0, _(""only one of -s, -e, -d, -a, -u or -n can be specified"")); usage (EXIT_FAILURE); } if (!args_info.quiet_given && args_info.inputs_num == 0 && isatty (fileno (stdin))) fprintf (stderr, ""%s %s\n"" GREETING, PACKAGE, VERSION); if (args_info.debug_given) fprintf (stderr, _(""Charset `%s'.\n""), stringprep_locale_charset ()); if (!args_info.quiet_given && args_info.inputs_num == 0 && isatty (fileno (stdin))) fprintf (stderr, _(""Type each input string on a line by itself, "" ""terminated by a newline character.\n"")); do { if (cmdn < args_info.inputs_num) line = strdup (args_info.inputs[cmdn++]); else if (getline (&line, &linelen, stdin) == -1) { if (feof (stdin)) break; error (EXIT_FAILURE, errno, _(""input error"")); } if (line[strlen (line) - 1] == '\n') line[strlen (line) - 1] = '\0'; if (args_info.stringprep_given) { p = stringprep_locale_to_utf8 (line); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""), stringprep_locale_charset ()); q = stringprep_utf8_to_ucs4 (p, -1, NULL); if (!q) { free (p); error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); } if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""input[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } free (q); rc = stringprep_profile (p, &r, args_info.profile_given ? args_info.profile_arg : ""Nameprep"", 0); free (p); if (rc != STRINGPREP_OK) error (EXIT_FAILURE, 0, _(""stringprep_profile: %s""), stringprep_strerror (rc)); q = stringprep_utf8_to_ucs4 (r, -1, NULL); if (!q) { free (r); error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); } if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""output[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } free (q); p = stringprep_utf8_to_locale (r); free (r); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""), stringprep_locale_charset ()); fprintf (stdout, ""%s\n"", p); free (p); } if (args_info.punycode_encode_given) { char encbuf[BUFSIZ]; size_t len, len2; p = stringprep_locale_to_utf8 (line); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""), stringprep_locale_charset ()); q = stringprep_utf8_to_ucs4 (p, -1, &len); free (p); if (!q) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); if (args_info.debug_given) { size_t i; for (i = 0; i < len; i++) fprintf (stderr, ""input[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } len2 = BUFSIZ - 1; rc = punycode_encode (len, q, NULL, &len2, encbuf); free (q); if (rc != PUNYCODE_SUCCESS) error (EXIT_FAILURE, 0, _(""punycode_encode: %s""), punycode_strerror (rc)); encbuf[len2] = '\0'; p = stringprep_utf8_to_locale (encbuf); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""), stringprep_locale_charset ()); fprintf (stdout, ""%s\n"", p); free (p); } if (args_info.punycode_decode_given) { size_t len; len = BUFSIZ; q = (uint32_t *) malloc (len * sizeof (q[0])); if (!q) error (EXIT_FAILURE, ENOMEM, N_(""malloc"")); rc = punycode_decode (strlen (line), line, &len, q, NULL); if (rc != PUNYCODE_SUCCESS) { free (q); error (EXIT_FAILURE, 0, _(""punycode_decode: %s""), punycode_strerror (rc)); } if (args_info.debug_given) { size_t i; for (i = 0; i < len; i++) fprintf (stderr, ""output[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } q[len] = 0; r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL); free (q); if (!r) error (EXIT_FAILURE, 0, _(""could not convert from UCS-4 to UTF-8"")); p = stringprep_utf8_to_locale (r); free (r); if (!r) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""), stringprep_locale_charset ()); fprintf (stdout, ""%s\n"", p); free (p); } if (args_info.idna_to_ascii_given) { p = stringprep_locale_to_utf8 (line); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""), stringprep_locale_charset ()); q = stringprep_utf8_to_ucs4 (p, -1, NULL); free (p); if (!q) error (EXIT_FAILURE, 0, _(""could not convert from UCS-4 to UTF-8"")); if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""input[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } rc = idna_to_ascii_4z (q, &p, (args_info.allow_unassigned_given ? IDNA_ALLOW_UNASSIGNED : 0) | (args_info.usestd3asciirules_given ? IDNA_USE_STD3_ASCII_RULES : 0)); free (q); if (rc != IDNA_SUCCESS) error (EXIT_FAILURE, 0, _(""idna_to_ascii_4z: %s""), idna_strerror (rc)); #ifdef WITH_TLD if (args_info.tld_flag && !args_info.no_tld_flag) { size_t errpos; rc = idna_to_unicode_8z4z (p, &q, (args_info.allow_unassigned_given ? IDNA_ALLOW_UNASSIGNED : 0) | (args_info.usestd3asciirules_given ? IDNA_USE_STD3_ASCII_RULES : 0)); if (rc != IDNA_SUCCESS) error (EXIT_FAILURE, 0, _(""idna_to_unicode_8z4z (TLD): %s""), idna_strerror (rc)); if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""tld[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } rc = tld_check_4z (q, &errpos, NULL); free (q); if (rc == TLD_INVALID) error (EXIT_FAILURE, 0, _(""tld_check_4z (position %lu): %s""), (unsigned long) errpos, tld_strerror (rc)); if (rc != TLD_SUCCESS) error (EXIT_FAILURE, 0, _(""tld_check_4z: %s""), tld_strerror (rc)); } #endif if (args_info.debug_given) { size_t i; for (i = 0; p[i]; i++) fprintf (stderr, ""output[%lu] = U+%04x\n"", (unsigned long) i, p[i]); } fprintf (stdout, ""%s\n"", p); free (p); } if (args_info.idna_to_unicode_given) { p = stringprep_locale_to_utf8 (line); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""), stringprep_locale_charset ()); q = stringprep_utf8_to_ucs4 (p, -1, NULL); if (!q) { free (p); error (EXIT_FAILURE, 0, _(""could not convert from UCS-4 to UTF-8"")); } if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""input[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } free (q); rc = idna_to_unicode_8z4z (p, &q, (args_info.allow_unassigned_given ? IDNA_ALLOW_UNASSIGNED : 0) | (args_info.usestd3asciirules_given ? IDNA_USE_STD3_ASCII_RULES : 0)); free (p); if (rc != IDNA_SUCCESS) error (EXIT_FAILURE, 0, _(""idna_to_unicode_8z4z: %s""), idna_strerror (rc)); if (args_info.debug_given) { size_t i; for (i = 0; q[i]; i++) fprintf (stderr, ""output[%lu] = U+%04x\n"", (unsigned long) i, q[i]); } #ifdef WITH_TLD if (args_info.tld_flag) { size_t errpos; rc = tld_check_4z (q, &errpos, NULL); if (rc == TLD_INVALID) { free (q); error (EXIT_FAILURE, 0, _(""tld_check_4z (position %lu): %s""), (unsigned long) errpos, tld_strerror (rc)); } if (rc != TLD_SUCCESS) { free (q); error (EXIT_FAILURE, 0, _(""tld_check_4z: %s""), tld_strerror (rc)); } } #endif r = stringprep_ucs4_to_utf8 (q, -1, NULL, NULL); free (q); if (!r) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); p = stringprep_utf8_to_locale (r); free (r); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""), stringprep_locale_charset ()); fprintf (stdout, ""%s\n"", p); free (p); } if (args_info.nfkc_given) { p = stringprep_locale_to_utf8 (line); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from %s to UTF-8""), stringprep_locale_charset ()); if (args_info.debug_given) { size_t i; q = stringprep_utf8_to_ucs4 (p, -1, NULL); if (!q) { free (p); error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); } for (i = 0; q[i]; i++) fprintf (stderr, ""input[%lu] = U+%04x\n"", (unsigned long) i, q[i]); free (q); } r = stringprep_utf8_nfkc_normalize (p, -1); free (p); if (!r) error (EXIT_FAILURE, 0, _(""could not do NFKC normalization"")); if (args_info.debug_given) { size_t i; q = stringprep_utf8_to_ucs4 (r, -1, NULL); if (!q) { free (r); error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to UCS-4"")); } for (i = 0; q[i]; i++) fprintf (stderr, ""output[%lu] = U+%04x\n"", (unsigned long) i, q[i]); free (q); } p = stringprep_utf8_to_locale (r); free (r); if (!p) error (EXIT_FAILURE, 0, _(""could not convert from UTF-8 to %s""), stringprep_locale_charset ()); fprintf (stdout, ""%s\n"", p); free (p); } fflush (stdout); } while (!feof (stdin) && !ferror (stdin) && (args_info.inputs_num == 0 || cmdn < args_info.inputs_num)); free (line); return EXIT_SUCCESS; }"
"RList *r_bin_ne_get_relocs(r_bin_ne_obj_t *bin) { RList *segments = bin->segments; if (!segments) { return NULL; } RList *entries = bin->entries; if (!entries) { return NULL; } RList *symbols = bin->symbols; if (!symbols) { return NULL; } ut16 *modref = malloc (bin->ne_header->ModRefs * sizeof (ut16)); if (!modref) { return NULL; } r_buf_read_at (bin->buf, (ut64)bin->ne_header->ModRefTable + bin->header_offset, (ut8 *)modref, bin->ne_header->ModRefs * sizeof (ut16)); RList *relocs = r_list_newf (free); if (!relocs) { free (modref); return NULL; } RListIter *it; RBinSection *seg; int index = -1; r_list_foreach (segments, it, seg) { index++; if (!(bin->segment_entries[index].flags & RELOCINFO)) { continue; } ut32 off, start = off = seg->paddr + seg->size; ut16 length = r_buf_read_le16_at (bin->buf, off); if (!length) { continue; } off += 2; while (off < start + length * sizeof (NE_image_reloc_item)) { RBinReloc *reloc = R_NEW0 (RBinReloc); if (!reloc) { return NULL; } NE_image_reloc_item rel; r_buf_read_at (bin->buf, off, (ut8 *)&rel, sizeof (rel)); reloc->paddr = seg->paddr + rel.offset; switch (rel.type) { case LOBYTE: reloc->type = R_BIN_RELOC_8; break; case SEL_16: case OFF_16: reloc->type = R_BIN_RELOC_16; break; case POI_32: case OFF_32: reloc->type = R_BIN_RELOC_32; break; case POI_48: reloc->type = R_BIN_RELOC_64; break; } ut32 offset; if (rel.flags & (IMPORTED_ORD | IMPORTED_NAME)) { RBinImport *imp = R_NEW0 (RBinImport); if (!imp) { free (reloc); break; } char *name; if (rel.index > bin->ne_header->ModRefs) { name = r_str_newf (""UnknownModule%d_%x"", rel.index, off); } else { offset = modref[rel.index - 1] + bin->header_offset + bin->ne_header->ImportNameTable; name = __read_nonnull_str_at (bin->buf, offset); } if (rel.flags & IMPORTED_ORD) { imp->ordinal = rel.func_ord; imp->name = r_str_newf (""%s.%s"", name, __func_name_from_ord(name, rel.func_ord)); } else { offset = bin->header_offset + bin->ne_header->ImportNameTable + rel.name_off; char *func = __read_nonnull_str_at (bin->buf, offset); imp->name = r_str_newf (""%s.%s"", name, func); free (func); } free (name); reloc->import = imp; } else if (rel.flags & OSFIXUP) { } else { if (strstr (seg->name, ""FIXED"")) { RBinSection *s = r_list_get_n (segments, rel.segnum - 1); if (s) { offset = s->paddr + rel.segoff; } else { offset = -1; } } else { RBinAddr *entry = r_list_get_n (entries, rel.entry_ordinal - 1); if (entry) { offset = entry->paddr; } else { offset = -1; } } reloc->addend = offset; RBinSymbol *sym = NULL; RListIter *sit; r_list_foreach (symbols, sit, sym) { if (sym->paddr == reloc->addend) { reloc->symbol = sym; break; } } } if (rel.flags & ADDITIVE) { reloc->additive = 1; r_list_append (relocs, reloc); } else { do { r_list_append (relocs, reloc); offset = r_buf_read_le16_at (bin->buf, reloc->paddr); RBinReloc *tmp = reloc; reloc = R_NEW0 (RBinReloc); if (!reloc) { break; } *reloc = *tmp; reloc->paddr = seg->paddr + offset; } while (offset != 0xFFFF); free (reloc); } off += sizeof (NE_image_reloc_item); } } free (modref); return relocs; }"
"static VTermScreen *screen_new(VTerm *vt) { VTermState *state = vterm_obtain_state(vt); VTermScreen *screen; int rows, cols; if(!state) return NULL; screen = vterm_allocator_malloc(vt, sizeof(VTermScreen)); vterm_get_size(vt, &rows, &cols); screen->vt = vt; screen->state = state; screen->damage_merge = VTERM_DAMAGE_CELL; screen->damaged.start_row = -1; screen->pending_scrollrect.start_row = -1; screen->rows = rows; screen->cols = cols; screen->callbacks = NULL; screen->cbdata    = NULL; screen->buffers[0] = realloc_buffer(screen, NULL, rows, cols); screen->buffer = screen->buffers[0]; screen->sb_buffer = vterm_allocator_malloc(screen->vt, sizeof(VTermScreenCell) * cols); vterm_state_set_callbacks(screen->state, &state_cbs, screen); return screen; }"
"static njs_ret_t njs_array_prototype_to_string(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs, njs_index_t retval) { njs_object_prop_t   *prop; njs_continuation_t  *cont; nxt_lvlhsh_query_t  lhq; cont = njs_vm_continuation(vm); cont->function = njs_array_prototype_to_string_continuation; if (njs_is_object(&args[0])) { lhq.key_hash = NJS_JOIN_HASH; lhq.key = nxt_string_value(""join""); prop = njs_object_property(vm, args[0].data.u.object, &lhq); if (nxt_fast_path(prop != NULL && njs_is_function(&prop->value))) { return njs_function_apply(vm, prop->value.data.u.function, args, nargs, retval); } } return njs_object_prototype_to_string(vm, args, nargs, retval); }"
"njs_int_t njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array, uint32_t index, njs_value_t *setval) { double              num; njs_int_t           ret; njs_array_buffer_t  *buffer; ret = njs_value_to_number(vm, setval, &num); if (njs_slow_path(ret != NJS_OK)) { return ret; } buffer = njs_typed_array_writable(vm, array); if (njs_slow_path(buffer == NULL)) { return NJS_ERROR; } njs_typed_array_prop_set(vm, array, index, num); njs_set_number(setval, num); return NJS_OK; }"
"long fuse_ioctl_common(struct file *file, unsigned int cmd, unsigned long arg, unsigned int flags) { struct inode *inode = file_inode(file); struct fuse_conn *fc = get_fuse_conn(inode); if (!fuse_allow_current_process(fc)) return -EACCES; if (is_bad_inode(inode)) return -EIO; return fuse_do_ioctl(file, cmd, arg, flags); }"
"struct mtk_vcodec_fw *mtk_vcodec_fw_vpu_init(struct mtk_vcodec_dev *dev, enum mtk_vcodec_fw_use fw_use) { struct platform_device *fw_pdev; struct mtk_vcodec_fw *fw; enum rst_id rst_id; switch (fw_use) { case ENCODER: rst_id = VPU_RST_ENC; break; case DECODER: default: rst_id = VPU_RST_DEC; break; } fw_pdev = vpu_get_plat_device(dev->plat_dev); if (!fw_pdev) { mtk_v4l2_err(""firmware device is not ready""); return ERR_PTR(-EINVAL); } vpu_wdt_reg_handler(fw_pdev, mtk_vcodec_vpu_reset_handler, dev, rst_id); fw = devm_kzalloc(&dev->plat_dev->dev, sizeof(*fw), GFP_KERNEL); fw->type = VPU; fw->ops = &mtk_vcodec_vpu_msg; fw->pdev = fw_pdev; return fw; }"
"__be32 ipv6_select_ident(struct net *net, const struct in6_addr *daddr, const struct in6_addr *saddr) { static u32 ip6_idents_hashrnd __read_mostly; u32 id; net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd)); id = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr); return htonl(id); }"
"static const char* ConvertScalar(PyObject* v, Eigen::half* out) { Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v)); double v_double = PyFloat_AS_DOUBLE(as_float.get()); *out = Eigen::half(v_double); return nullptr; }"
"void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet) { if (!checkEvidenceAccess(area)) return; bool is_int = false; int idx = argv[0].toInt(&is_int); AreaData::Evidence evi = {argv[1], argv[2], argv[3]}; if (is_int && idx <= area->evidence().size() && idx >= 0) { area->replaceEvidence(idx, evi); } sendEvidenceList(area); }"
"size_t calculate_camera_metadata_entry_data_size(uint8_t type, size_t data_count) { if (type >= NUM_TYPES) return 0; size_t data_bytes = data_count * camera_metadata_type_size[type]; return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT); }"
"void CExifParse::ProcessGpsInfo( const unsigned char* const DirStart, int ByteCountUnused, const unsigned char* const OffsetBase, unsigned ExifLength) { int NumDirEntries = Get16(DirStart, m_MotorolaOrder); for (int de=0;de<NumDirEntries;de++) { const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de); if (DirEntry + 12 > OffsetBase + ExifLength) { ErrNonfatal(""GPS info directory goes past end of exif"", 0, 0); return; } unsigned Tag        = Get16(DirEntry, m_MotorolaOrder); unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder); unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder); if (Format == 0 || Format > NUM_FORMATS) { ErrNonfatal(""Illegal number format %d for tag %04x"", Format, Tag); continue; } unsigned ComponentSize = BytesPerFormat[Format - 1]; unsigned ByteCount = Components * ComponentSize; const unsigned char* ValuePtr; if (ByteCount > 4) { unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder); if (OffsetVal+ByteCount > ExifLength) { ErrNonfatal(""Illegal value pointer for tag %04x"", Tag,0); continue; } ValuePtr = OffsetBase+OffsetVal; } else { ValuePtr = DirEntry+8; } switch(Tag) { case TAG_GPS_LAT_REF: m_ExifInfo->GpsLat[0] = ValuePtr[0]; m_ExifInfo->GpsLat[1] = 0; break; case TAG_GPS_LONG_REF: m_ExifInfo->GpsLong[0] = ValuePtr[0]; m_ExifInfo->GpsLong[1] = 0; break; case TAG_GPS_LAT: GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat); break; case TAG_GPS_LONG: GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong); break; case TAG_GPS_ALT_REF: if (ValuePtr[0] != 0) m_ExifInfo->GpsAlt[0] = '-'; m_ExifInfo->GpsAlt[1] = 0; break; case TAG_GPS_ALT: { char temp[18]; sprintf(temp, ""%.2fm"", static_cast<double>(ConvertAnyFormat(ValuePtr, Format))); strcat(m_ExifInfo->GpsAlt, temp); } break; } } }"
"static int chap_gen_challenge( struct iscsi_conn *conn, int caller, char *c_str, unsigned int *c_len) { int ret; unsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1]; struct iscsi_chap *chap = conn->auth_protocol; memset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1); ret = get_random_bytes_wait(chap->challenge, CHAP_CHALLENGE_LENGTH); if (unlikely(ret)) return ret; chap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge, CHAP_CHALLENGE_LENGTH); *c_len += sprintf(c_str + *c_len, ""CHAP_C=0x%s"", challenge_asciihex); *c_len += 1; pr_debug(""[%s] Sending CHAP_C=0x%s\n\n"", (caller) ? ""server"" : ""client"", challenge_asciihex); return 0; }"
"inline bool ClientImpl::write_request(Stream &strm, Request &req, bool close_connection, Error &error) { if (close_connection) { if (!req.has_header(""Connection"")) { req.headers.emplace(""Connection"", ""close""); } } if (!req.has_header(""Host"")) { if (is_ssl()) { if (port_ == 443) { req.headers.emplace(""Host"", host_); } else { req.headers.emplace(""Host"", host_and_port_); } } else { if (port_ == 80) { req.headers.emplace(""Host"", host_); } else { req.headers.emplace(""Host"", host_and_port_); } } } if (!req.has_header(""Accept"")) { req.headers.emplace(""Accept"", ""*/*""); } #ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT if (!req.has_header(""User-Agent"")) { auto agent = std::string(""cpp-httplib/"") + CPPHTTPLIB_VERSION; req.headers.emplace(""User-Agent"", agent); } #endif if (req.body.empty()) { if (req.content_provider_) { if (!req.is_chunked_content_provider_) { if (!req.has_header(""Content-Length"")) { auto length = std::to_string(req.content_length_); req.headers.emplace(""Content-Length"", length); } } } else { if (req.method == ""POST"" || req.method == ""PUT"" || req.method == ""PATCH"") { req.headers.emplace(""Content-Length"", ""0""); } } } else { if (!req.has_header(""Content-Type"")) { req.headers.emplace(""Content-Type"", ""text/plain""); } if (!req.has_header(""Content-Length"")) { auto length = std::to_string(req.body.size()); req.headers.emplace(""Content-Length"", length); } } if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) { if (!req.has_header(""Authorization"")) { req.headers.insert(make_basic_authentication_header( basic_auth_username_, basic_auth_password_, false)); } } if (!proxy_basic_auth_username_.empty() && !proxy_basic_auth_password_.empty()) { if (!req.has_header(""Proxy-Authorization"")) { req.headers.insert(make_basic_authentication_header( proxy_basic_auth_username_, proxy_basic_auth_password_, true)); } } if (!bearer_token_auth_token_.empty()) { if (!req.has_header(""Authorization"")) { req.headers.insert(make_bearer_token_authentication_header( bearer_token_auth_token_, false)); } } if (!proxy_bearer_token_auth_token_.empty()) { if (!req.has_header(""Proxy-Authorization"")) { req.headers.insert(make_bearer_token_authentication_header( proxy_bearer_token_auth_token_, true)); } } { detail::BufferStream bstrm; const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path; bstrm.write_format(""%s %s HTTP/1.1\r\n"", req.method.c_str(), path.c_str()); detail::write_headers(bstrm, req.headers); auto &data = bstrm.get_buffer(); if (!detail::write_data(strm, data.data(), data.size())) { error = Error::Write; return false; } } if (req.body.empty()) { return write_content_with_provider(strm, req, error); } if (!detail::write_data(strm, req.body.data(), req.body.size())) { error = Error::Write; return false; } return true; }"
static vm_fault_t udmabuf_vm_fault(struct vm_fault *vmf) { struct vm_area_struct *vma = vmf->vma; struct udmabuf *ubuf = vma->vm_private_data; vmf->page = ubuf->pages[vmf->pgoff]; get_page(vmf->page); return 0; }
void AccountSettings::slotOpenOC() { if (_OCUrl.isValid()) QDesktopServices::openUrl(_OCUrl); }
"status_t CursorWindow::writeToParcel(Parcel* parcel) { LOG(DEBUG) << ""Writing to parcel: "" << this->toString(); if (parcel->writeString8(mName)) goto fail; if (parcel->writeUint32(mNumRows)) goto fail; if (parcel->writeUint32(mNumColumns)) goto fail; if (mAshmemFd != -1) { if (parcel->writeUint32(mSize)) goto fail; if (parcel->writeBool(true)) goto fail; if (parcel->writeDupFileDescriptor(mAshmemFd)) goto fail; } else { size_t slotsSize = mSize - mSlotsOffset; size_t compactedSize = mAllocOffset + slotsSize; compactedSize = (compactedSize + 3) & ~3; if (parcel->writeUint32(compactedSize)) goto fail; if (parcel->writeBool(false)) goto fail; void* dest = parcel->writeInplace(compactedSize); if (!dest) goto fail; memcpy(static_cast<uint8_t*>(dest), static_cast<uint8_t*>(mData), mAllocOffset); memcpy(static_cast<uint8_t*>(dest) + compactedSize - slotsSize, static_cast<uint8_t*>(mData) + mSlotsOffset, slotsSize); } return OK; fail: LOG(ERROR) << ""Failed writeToParcel""; fail_silent: return UNKNOWN_ERROR; }"
"int nbd_unlocked_opt_info (struct nbd_handle *h) { int err; nbd_completion_callback c = { .callback = go_complete, .user_data = &err }; int r = nbd_unlocked_aio_opt_info (h, &c); if (r == -1) return r; r = wait_for_option (h); if (r == 0 && err) { assert (nbd_internal_is_state_negotiating (get_next_state (h))); set_error (err, ""server replied with error to opt_info request""); return -1; } return r; }"
"static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest) { uint32_t size; size_t alloc_size; bool status; if (!pb_decode_varint32(stream, &size)) return false; alloc_size = size + 1; if (PB_ATYPE(field->type) == PB_ATYPE_POINTER) { #ifndef PB_ENABLE_MALLOC PB_RETURN_ERROR(stream, ""no malloc support""); #else if (!allocate_field(stream, dest, alloc_size, 1)) return false; dest = *(void**)dest; #endif } else { if (alloc_size > field->data_size) PB_RETURN_ERROR(stream, ""string overflow""); } status = pb_read(stream, (uint8_t*)dest, size); *((uint8_t*)dest + size) = 0; return status; }"
"static int on_header(nghttp2_session *session, const nghttp2_frame *frame, const uint8_t *name, size_t namelen, const uint8_t *value, size_t valuelen, uint8_t flags, void *userp) { struct HTTP *stream; struct Curl_easy *data_s; int32_t stream_id = frame->hd.stream_id; struct connectdata *conn = (struct connectdata *)userp; (void)flags; DEBUGASSERT(stream_id);  data_s = nghttp2_session_get_stream_user_data(session, stream_id); if(!data_s) return NGHTTP2_ERR_CALLBACK_FAILURE; stream = data_s->req.protop; if(!stream) { failf(data_s, ""Internal NULL stream! 5\n""); return NGHTTP2_ERR_CALLBACK_FAILURE; } if(frame->hd.type == NGHTTP2_PUSH_PROMISE) { char *h; if(!stream->push_headers) { stream->push_headers_alloc = 10; stream->push_headers = malloc(stream->push_headers_alloc * sizeof(char *)); stream->push_headers_used = 0; } else if(stream->push_headers_used == stream->push_headers_alloc) { char **headp; stream->push_headers_alloc *= 2; headp = Curl_saferealloc(stream->push_headers, stream->push_headers_alloc * sizeof(char *)); if(!headp) { stream->push_headers = NULL; return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE; } stream->push_headers = headp; } h = aprintf(""%s:%s"", name, value); if(h) stream->push_headers[stream->push_headers_used++] = h; return 0; } if(stream->bodystarted) { uint32_t n = (uint32_t)(namelen + valuelen + 3); DEBUGF(infof(data_s, ""h2 trailer: %.*s: %.*s\n"", namelen, name, valuelen, value)); Curl_add_buffer(stream->trailer_recvbuf, &n, sizeof(n)); Curl_add_buffer(stream->trailer_recvbuf, name, namelen); Curl_add_buffer(stream->trailer_recvbuf, "": "", 2); Curl_add_buffer(stream->trailer_recvbuf, value, valuelen); Curl_add_buffer(stream->trailer_recvbuf, ""\r\n\0"", 3); return 0; } if(namelen == sizeof("":status"") - 1 && memcmp("":status"", name, namelen) == 0) { stream->status_code = decode_status_code(value, valuelen); DEBUGASSERT(stream->status_code != -1); Curl_add_buffer(stream->header_recvbuf, ""HTTP/2 "", 7); Curl_add_buffer(stream->header_recvbuf, value, valuelen); Curl_add_buffer(stream->header_recvbuf, "" \r\n"", 3); if(conn->data != data_s) Curl_expire(data_s, 0, EXPIRE_RUN_NOW); DEBUGF(infof(data_s, ""h2 status: HTTP/2 %03d (easy %p)\n"", stream->status_code, data_s)); return 0; } Curl_add_buffer(stream->header_recvbuf, name, namelen); Curl_add_buffer(stream->header_recvbuf, "": "", 2); Curl_add_buffer(stream->header_recvbuf, value, valuelen); Curl_add_buffer(stream->header_recvbuf, ""\r\n"", 2); if(conn->data != data_s) Curl_expire(data_s, 0, EXPIRE_RUN_NOW); DEBUGF(infof(data_s, ""h2 header: %.*s: %.*s\n"", namelen, name, valuelen, value)); return 0;  }"
"mbfl_buffer_converter * mbfl_buffer_converter_new2( const mbfl_encoding *from, const mbfl_encoding *to,  int buf_initsz) { mbfl_buffer_converter *convd; convd = (mbfl_buffer_converter*)mbfl_malloc(sizeof (mbfl_buffer_converter)); if (convd == NULL) { return NULL; } convd->from = from; convd->to = to; convd->filter1 = NULL; convd->filter2 = NULL; if (mbfl_convert_filter_get_vtbl(convd->from->no_encoding, convd->to->no_encoding) != NULL) { convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, convd->to->no_encoding, mbfl_memory_device_output, NULL, &convd->device); } else { convd->filter2 = mbfl_convert_filter_new(mbfl_no_encoding_wchar, convd->to->no_encoding, mbfl_memory_device_output, NULL, &convd->device); if (convd->filter2 != NULL) { convd->filter1 = mbfl_convert_filter_new(convd->from->no_encoding, mbfl_no_encoding_wchar, (int (*)(int, void*))convd->filter2->filter_function, (int (*)(void*))convd->filter2->filter_flush, convd->filter2); if (convd->filter1 == NULL) { mbfl_convert_filter_delete(convd->filter2); } } } if (convd->filter1 == NULL) { return NULL; } mbfl_memory_device_init(&convd->device, buf_initsz, buf_initsz/4); return convd; }"
"static int check_compat_entry_size_and_hooks(struct compat_ipt_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_match *ematch; struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; unsigned int j; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 || (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_ipt_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } if (!ip_checkentry(&e->ip)) return -EINVAL; ret = xt_compat_check_entry_offsets(e, e->target_offset, e->next_offset); if (ret) return ret; off = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry); entry_offset = (void *)e - (void *)base; j = 0; xt_ematch_foreach(ematch, e) { ret = compat_find_calc_match(ematch, name, &e->ip, &off); if (ret != 0) goto release_matches; ++j; } t = compat_ipt_get_target(e); target = xt_request_find_target(NFPROTO_IPV4, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto release_matches; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(AF_INET, entry_offset, off); if (ret) goto out; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; out: module_put(t->u.kernel.target->me); release_matches: xt_ematch_foreach(ematch, e) { if (j-- == 0) break; module_put(ematch->u.kernel.match->me); } return ret; }"
"static njs_ret_t njs_array_prototype_unshift(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs, njs_index_t unused) { njs_ret_t    ret; nxt_uint_t   n; njs_array_t  *array; if (njs_is_array(&args[0])) { array = args[0].data.u.array; n = nargs - 1; if (n != 0) { if ((intptr_t) n > (array->start - array->data)) { ret = njs_array_expand(vm, array, n, 0); if (nxt_slow_path(ret != NXT_OK)) { return ret; } } array->length += n; n = nargs; do { n--; array->start--; array->start[0] = args[n]; } while (n > 1); } njs_value_number_set(&vm->retval, array->length); } return NXT_OK; }"
"int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused) { ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"", fd, offset, length, priority); Mutex::Autolock lock(&mLock); sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length); mSamples.add(sample->sampleID(), sample); doLoad(sample); return sample->sampleID(); }"
"static int dissect_channel_switch_wrapper(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int offset, guint32 tag_len) { int tmp_sublen; while (tag_len > 0){ tmp_sublen = tvb_get_guint8(tvb, offset + 1); if(add_tagged_field(pinfo, tree, tvb, offset, 0) == 0){ break; } tag_len -= (tmp_sublen + 2); offset += (tmp_sublen + 2); } return offset; }"
"void my_error_exit( j_common_ptr cinfo ) { my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err); longjmp( myerr->setjmp_buffer, 1 ); }"
"static int pushParseTest(const char *filename, const char *result, const char *err ATTRIBUTE_UNUSED, int options) { xmlParserCtxtPtr ctxt; xmlDocPtr doc; const char *base; int size, res; int cur = 0; nb_tests++; if (loadMem(filename, &base, &size) != 0) { fprintf(stderr, ""Failed to load %s\n"", filename); return(-1); } #ifdef LIBXML_HTML_ENABLED if (options & XML_PARSE_HTML) ctxt = htmlCreatePushParserCtxt(NULL, NULL, base + cur, 4, filename, XML_CHAR_ENCODING_NONE); else #endif ctxt = xmlCreatePushParserCtxt(NULL, NULL, base + cur, 4, filename); xmlCtxtUseOptions(ctxt, options); cur += 4; while (cur < size) { if (cur + 1024 >= size) { #ifdef LIBXML_HTML_ENABLED if (options & XML_PARSE_HTML) htmlParseChunk(ctxt, base + cur, size - cur, 1); else #endif xmlParseChunk(ctxt, base + cur, size - cur, 1); break; } else { #ifdef LIBXML_HTML_ENABLED if (options & XML_PARSE_HTML) htmlParseChunk(ctxt, base + cur, 1024, 0); else #endif xmlParseChunk(ctxt, base + cur, 1024, 0); cur += 1024; } } doc = ctxt->myDoc; #ifdef LIBXML_HTML_ENABLED if (options & XML_PARSE_HTML) res = 1; else #endif res = ctxt->wellFormed; xmlFreeParserCtxt(ctxt); free((char *)base); if (!res) { xmlFreeDoc(doc); fprintf(stderr, ""Failed to parse %s\n"", filename); return(-1); } #ifdef LIBXML_HTML_ENABLED if (options & XML_PARSE_HTML) htmlDocDumpMemory(doc, (xmlChar **) &base, &size); else #endif xmlDocDumpMemory(doc, (xmlChar **) &base, &size); xmlFreeDoc(doc); res = compareFileMem(result, base, size); if ((base == NULL) || (res != 0)) { if (base != NULL) xmlFree((char *)base); fprintf(stderr, ""Result for %s failed in %s\n"", filename, result); return(-1); } xmlFree((char *)base); if (err != NULL) { res = compareFileMem(err, testErrors, testErrorsSize); if (res != 0) { fprintf(stderr, ""Error for %s failed\n"", filename); return(-1); } } return(0); }"
"void agoo_http_init() { const char**kp = header_keys; memset(&key_cache, 0, sizeof(struct _cache)); for (; NULL != *kp; kp++) { key_set(*kp); } }"
"int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags) { uint8_t b[192]; uint8_t nchan, nord, npat, nsmp; uint16_t ntrk, comment_len; int n, pat, chan, smp, rows, todo = 0; song_note_t *note; uint16_t tmp; uint32_t tmplong; song_note_t **trackdata, *tracknote; song_sample_t *sample; slurp_read(fp, b, 3); if (memcmp(b, ""MTM"", 3) != 0) return LOAD_UNSUPPORTED; n = slurp_getc(fp); sprintf(song->tracker_id, ""MultiTracker %d.%d"", n >> 4, n & 0xf); slurp_read(fp, song->title, 20); song->title[20] = 0; slurp_read(fp, &ntrk, 2); ntrk = bswapLE16(ntrk); npat = slurp_getc(fp); nord = slurp_getc(fp) + 1; slurp_read(fp, &comment_len, 2); comment_len = bswapLE16(comment_len); nsmp = slurp_getc(fp); slurp_getc(fp);  rows = slurp_getc(fp);  if (rows != 64) todo |= 64; rows = MIN(rows, 64); nchan = slurp_getc(fp); if (slurp_eof(fp)) { return LOAD_FORMAT_ERROR; } for (n = 0; n < 32; n++) { int pan = slurp_getc(fp) & 0xf; pan = SHORT_PANNING(pan); pan *= 4; song->channels[n].panning = pan; } for (n = nchan; n < MAX_CHANNELS; n++) song->channels[n].flags = CHN_MUTE; if (nsmp > MAX_SAMPLES) { log_appendf(4, "" Warning: Too many samples""); } for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) { if (n > MAX_SAMPLES) { slurp_seek(fp, 37, SEEK_CUR); continue; } char name[23]; slurp_read(fp, name, 22); name[22] = '\0'; strcpy(sample->name, name); slurp_read(fp, &tmplong, 4); sample->length = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_start = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_end = bswapLE32(tmplong); if ((sample->loop_end - sample->loop_start) > 2) { sample->flags |= CHN_LOOP; } else { sample->loop_start = 0; sample->loop_end = 0; } song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp)); sample->volume = slurp_getc(fp); sample->volume *= 4; sample->global_volume = 64; if (slurp_getc(fp) & 1) { todo |= 16; sample->flags |= CHN_16BIT; sample->length >>= 1; sample->loop_start >>= 1; sample->loop_end >>= 1; } song->samples[n].vib_type = 0; song->samples[n].vib_rate = 0; song->samples[n].vib_depth = 0; song->samples[n].vib_speed = 0; } slurp_read(fp, song->orderlist, 128); memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord); trackdata = mem_calloc(ntrk, sizeof(song_note_t *)); for (n = 0; n < ntrk; n++) { slurp_read(fp, b, 3 * rows); trackdata[n] = mem_calloc(rows, sizeof(song_note_t)); mtm_unpack_track(b, trackdata[n], rows); } if (npat >= MAX_PATTERNS) { log_appendf(4, "" Warning: Too many patterns""); } for (pat = 0; pat <= npat; pat++) { if (pat >= MAX_PATTERNS) { slurp_seek(fp, 64, SEEK_CUR); continue; } song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32)); song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64; tracknote = trackdata[n]; for (chan = 0; chan < 32; chan++) { slurp_read(fp, &tmp, 2); tmp = bswapLE16(tmp); if (tmp == 0) { continue; } else if (tmp > ntrk) { for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); return LOAD_FORMAT_ERROR; } note = song->patterns[pat] + chan; tracknote = trackdata[tmp - 1]; for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS) *note = *tracknote; } if (rows < 32) { note = song->patterns[pat] + 64 * (rows - 1); while (note->effect || note->param) note++; note->effect = FX_PATTERNBREAK; } } for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); read_lined_message(song->message, fp, comment_len, 40); if (!(lflags & LOAD_NOSAMPLES)) { for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) { uint32_t ssize; if (song->samples[smp].length == 0) continue; ssize = csf_read_sample(song->samples + smp, (SF_LE | SF_PCMU | SF_M | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)), fp->data + fp->pos, fp->length - fp->pos); slurp_seek(fp, ssize, SEEK_CUR); } } song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX; if (todo & 64) log_appendf(2, "" TODO: test this file with other players (beats per track != 64)""); if (todo & 16) log_appendf(2, "" TODO: double check 16 bit sample loading""); return LOAD_SUCCESS; }"
"static int replace_grant_va_mapping( unsigned long addr, unsigned long frame, l1_pgentry_t nl1e, struct vcpu *v) { l1_pgentry_t *pl1e, ol1e; unsigned long gl1mfn; struct page_info *l1pg; int rc = 0; pl1e = guest_map_l1e(addr, &gl1mfn); if ( !pl1e ) { gdprintk(XENLOG_WARNING, ""Could not find L1 PTE for address %lx\n"", addr); return GNTST_general_error; } if ( !get_page_from_mfn(_mfn(gl1mfn), current->domain) ) { rc = GNTST_general_error; goto out; } l1pg = mfn_to_page(_mfn(gl1mfn)); if ( !page_lock(l1pg) ) { rc = GNTST_general_error; put_page(l1pg); goto out; } if ( (l1pg->u.inuse.type_info & PGT_type_mask) != PGT_l1_page_table ) { rc = GNTST_general_error; goto unlock_and_out; } ol1e = *pl1e; if ( unlikely(l1e_get_pfn(ol1e) != frame) ) { gdprintk(XENLOG_WARNING, ""PTE entry %lx for address %lx doesn't match frame %lx\n"", l1e_get_pfn(ol1e), addr, frame); rc = GNTST_general_error; goto unlock_and_out; } if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, v, 0)) ) { gdprintk(XENLOG_WARNING, ""Cannot delete PTE entry at %p\n"", pl1e); rc = GNTST_general_error; goto unlock_and_out; } unlock_and_out: page_unlock(l1pg); put_page(l1pg); out: guest_unmap_l1e(pl1e); return rc; }"
"struct passwd *hyper_getpwnam(const char *name) { uid_t uid = (uid_t)id_or_max(name); FILE *file = fopen(""/etc/passwd"", ""r""); if (!file) { perror(""faile to open /etc/passwd""); return NULL; } for (;;) { struct passwd *pwd = fgetpwent(file); if (!pwd) break; if (!strcmp(pwd->pw_name, name) || pwd->pw_uid == uid) { fclose(file); return pwd; } } fclose(file); return NULL; }"
"static Http2Error rcv_priority_frame(Http2ConnectionState &cstate, const Http2Frame &frame) { const Http2StreamId stream_id = frame.header().streamid; const uint32_t payload_length = frame.header().length; Http2StreamDebug(cstate.session, stream_id, ""Received PRIORITY frame""); if (cstate.get_zombie_event()) { Warning(""Priority frame for zombied session %"" PRId64, cstate.session->get_connection_id()); } if (stream_id == 0) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""priority 0 stream_id""); } if (payload_length != HTTP2_PRIORITY_LEN) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_STREAM, Http2ErrorCode::HTTP2_ERROR_FRAME_SIZE_ERROR, ""priority bad length""); } uint8_t buf[HTTP2_PRIORITY_LEN] = {0}; frame.reader()->memcpy(buf, HTTP2_PRIORITY_LEN, 0); Http2Priority priority; if (!http2_parse_priority_parameter(make_iovec(buf, HTTP2_PRIORITY_LEN), priority)) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""priority parse error""); } if (stream_id == priority.stream_dependency) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_STREAM, Http2ErrorCode::HTTP2_ERROR_PROTOCOL_ERROR, ""PRIORITY frame depends on itself""); } if (!Http2::stream_priority_enabled) { return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_NONE); } cstate.increment_received_priority_frame_count(); if (Http2::max_priority_frames_per_minute != 0 && cstate.get_received_priority_frame_count() > Http2::max_priority_frames_per_minute) { HTTP2_INCREMENT_THREAD_DYN_STAT(HTTP2_STAT_MAX_PRIORITY_FRAMES_PER_MINUTE_EXCEEDED, this_ethread()); Http2StreamDebug(cstate.session, stream_id, ""Observed too frequent priority changes: %u priority changes within a last minute"", cstate.get_received_priority_frame_count()); return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_CONNECTION, Http2ErrorCode::HTTP2_ERROR_ENHANCE_YOUR_CALM, ""recv priority too frequent priority changes""); } Http2StreamDebug(cstate.session, stream_id, ""PRIORITY - dep: %d, weight: %d, excl: %d, tree size: %d"", priority.stream_dependency, priority.weight, priority.exclusive_flag, cstate.dependency_tree->size()); Http2DependencyTree::Node *node = cstate.dependency_tree->find(stream_id); if (node != nullptr) { Http2StreamDebug(cstate.session, stream_id, ""Reprioritize""); cstate.dependency_tree->reprioritize(node, priority.stream_dependency, priority.exclusive_flag); if (is_debug_tag_set(""http2_priority"")) { std::stringstream output; cstate.dependency_tree->dump_tree(output); Debug(""http2_priority"", ""[%"" PRId64 ""] reprioritize %s"", cstate.session->get_connection_id(), output.str().c_str()); } } else { if (Http2::max_concurrent_streams_in > cstate.dependency_tree->size() - cstate.get_client_stream_count() + 1) { cstate.dependency_tree->add(priority.stream_dependency, stream_id, priority.weight, priority.exclusive_flag, nullptr); } } return Http2Error(Http2ErrorClass::HTTP2_ERROR_CLASS_NONE); }"
"static uint32_t * create_bits (pixman_format_code_t format, int                  width, int                  height, int *  rowstride_bytes, pixman_bool_t  clear) { int stride; size_t buf_size; int bpp; bpp = PIXMAN_FORMAT_BPP (format); if (_pixman_multiply_overflows_int (width, bpp)) return NULL; stride = width * bpp; if (_pixman_addition_overflows_int (stride, 0x1f)) return NULL; stride += 0x1f; stride >>= 5; stride *= sizeof (uint32_t); if (_pixman_multiply_overflows_size (height, stride)) return NULL; buf_size = height * stride; if (rowstride_bytes) *rowstride_bytes = stride; if (clear) return calloc (buf_size, 1); else return malloc (buf_size); }"
"static void naludmx_check_pid(GF_Filter *filter, GF_NALUDmxCtx *ctx, Bool force_au_flush) { u32 w, h, ew, eh; u8 *dsi, *dsi_enh; u32 dsi_size, dsi_enh_size; u32 crc_cfg, crc_cfg_enh; GF_Fraction sar; Bool has_hevc_base = GF_TRUE; Bool has_colr_info = GF_FALSE; if (ctx->analyze) { if (ctx->opid && !ctx->ps_modified) return; } else { if (!ctx->ps_modified) return; if (ctx->opid && (!gf_list_count(ctx->sps) || !gf_list_count(ctx->pps))) return; } ctx->ps_modified = GF_FALSE; dsi = dsi_enh = NULL; if (ctx->notime) { ctx->cur_fps = ctx->fps; if (!ctx->cur_fps.num || !ctx->cur_fps.den) { ctx->cur_fps.num = 25000; ctx->cur_fps.den = 1000; } } if (ctx->codecid==GF_CODECID_HEVC) { naludmx_create_hevc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base); } else if (ctx->codecid==GF_CODECID_VVC) { naludmx_create_vvc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar, &has_hevc_base); } else { naludmx_create_avc_decoder_config(ctx, &dsi, &dsi_size, &dsi_enh, &dsi_enh_size, &w, &h, &ew, &eh, &sar); } crc_cfg = crc_cfg_enh = 0; if (dsi) crc_cfg = gf_crc_32(dsi, dsi_size); if (dsi_enh) crc_cfg_enh = gf_crc_32(dsi_enh, dsi_enh_size); if (!ctx->analyze && (!w || !h)) { if (dsi) gf_free(dsi); if (dsi_enh) gf_free(dsi_enh); return; } if (!ctx->opid) { u32 slice_in_au = ctx->nb_slices_in_au; ctx->opid = gf_filter_pid_new(filter); naludmx_check_dur(filter, ctx); ctx->nb_slices_in_au = slice_in_au; } if ((ctx->crc_cfg == crc_cfg) && (ctx->crc_cfg_enh == crc_cfg_enh) && (ctx->width==w) && (ctx->height==h) && (ctx->sar.num * sar.den == ctx->sar.den * sar.num) ) { if (dsi) gf_free(dsi); if (dsi_enh) gf_free(dsi_enh); return; } if (force_au_flush) { naludmx_end_access_unit(ctx); } naludmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE); if (!ctx->analyze && (gf_list_count(ctx->pck_queue)>1))  { GF_LOG(dsi_enh ? GF_LOG_DEBUG : GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] xPS changed but could not flush frames before signaling state change %s\n"", ctx->log_name, dsi_enh ? ""- likely scalable xPS update"" : ""!"")); } gf_filter_pid_copy_properties(ctx->opid, ctx->ipid); if (!ctx->timescale) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT(GF_STREAM_VISUAL)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL); if (!gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_ID)) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(1)); ctx->width = w; ctx->height = h; ctx->sar = sar; ctx->crc_cfg = crc_cfg; ctx->crc_cfg_enh = crc_cfg_enh; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, & PROP_UINT( ctx->width)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, & PROP_UINT( ctx->height)); if (ew && eh) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH_MAX, & PROP_UINT( ew )); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT_MAX, & PROP_UINT( eh )); } if (ctx->sar.den) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, & PROP_FRAC(ctx->sar)); else gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAR, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_FPS, & PROP_FRAC(ctx->cur_fps)); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->cur_fps.num)); if (ctx->explicit || !has_hevc_base) { u32 enh_cid = GF_CODECID_SVC; if (ctx->codecid==GF_CODECID_HEVC) enh_cid = GF_CODECID_LHVC; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(enh_cid)); if (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) ); } else { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT(ctx->codecid)); if (dsi) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_size) ); if (dsi_enh) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT, &PROP_DATA_NO_COPY(dsi_enh, dsi_enh_size) ); } if (ctx->bitrate) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate)); } if ((ctx->codecid==GF_CODECID_HEVC) && gf_list_count(ctx->vps) ) { GF_Err e = naludmx_set_hevc_oinf(ctx, NULL); if (e) { GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (""[%s] Failed to create OINF chunk\n"", ctx->log_name)); } naludmx_set_hevc_linf(ctx); } if (ctx->duration.num) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration)); if (ctx->is_file ) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) ); } gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_INTERLACED, ctx->interlaced ? & PROP_UINT(GF_TRUE) : NULL); if (ctx->codecid==GF_CODECID_HEVC) { HEVC_SPS *sps = &ctx->hevc_state->sps[ctx->hevc_state->sps_active_idx]; if (sps->colour_description_present_flag) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(sps->colour_primaries) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(sps->transfer_characteristic) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(sps->matrix_coeffs) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(sps->video_full_range_flag) ); has_colr_info = GF_TRUE; } } else if (ctx->codecid==GF_CODECID_VVC) { } else { if (ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui_parameters_present_flag && ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui.colour_description_present_flag) { AVC_VUI *vui = &ctx->avc_state->sps[ctx->avc_state->sps_active_idx].vui; gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, & PROP_UINT(vui->colour_primaries) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, & PROP_UINT(vui->transfer_characteristics) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, & PROP_UINT(vui->matrix_coefficients) ); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, & PROP_BOOL(vui->video_full_range_flag) ); has_colr_info = GF_TRUE; } } if (!has_colr_info) { gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_PRIMARIES, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_TRANSFER, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_MX, NULL); gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_COLR_RANGE, NULL); } naludmx_update_clli_mdcv(ctx, GF_TRUE); naludmx_set_dolby_vision(ctx); }"
"void Compute(tensorflow::OpKernelContext* context) override { for (int ngram_width : ngram_widths_) { OP_REQUIRES( context, ngram_width > 0, errors::InvalidArgument(""ngram_widths must contain positive values"")); } const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); const int input_data_size = data->flat<tstring>().size(); const int splits_vec_size = splits_vec.size(); if (splits_vec_size > 0) { int prev_split = splits_vec(0); OP_REQUIRES(context, prev_split == 0, errors::InvalidArgument(""First split value must be 0, got "", prev_split)); for (int i = 1; i < splits_vec_size; ++i) { bool valid_splits = splits_vec(i) >= prev_split; valid_splits = valid_splits && (splits_vec(i) <= input_data_size); OP_REQUIRES(context, valid_splits, errors::InvalidArgument( ""Invalid split value "", splits_vec(i), "", must be in ["", prev_split, "", "", input_data_size, ""]"")); prev_split = splits_vec(i); } OP_REQUIRES(context, prev_split == input_data_size, errors::InvalidArgument( ""Last split value must be data size. Expected "", input_data_size, "", got "", prev_split)); } int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
"void * vips_malloc( VipsObject *object, size_t size ) { void *buf; buf = g_malloc( size ); if( object ) { g_signal_connect( object, ""postclose"",  G_CALLBACK( vips_malloc_cb ), buf ); object->local_memory += size; } return( buf ); }"
"void Compute(OpKernelContext* context) override { Tensor encoded_t = context->input(0); auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>(); auto expected_class = metadata_.type_spec_proto().type_spec_class(); auto actual_class = encoded->metadata().type_spec_proto().type_spec_class(); OP_REQUIRES( context, expected_class == actual_class, errors::InvalidArgument( ""Expected a "", TypeSpecProto::TypeSpecClass_Name(expected_class), "" (based on `type_spec`), but `encoded` contains a "", TypeSpecProto::TypeSpecClass_Name(actual_class))); OpOutputList components; OP_REQUIRES_OK(context, context->output_list(""components"", &components)); int num_components = encoded->flat_components().size(); OP_REQUIRES(context, component_dtypes_.size() == num_components, errors::InvalidArgument(""Encoded value has "", num_components, "" tensor components; expected "", component_dtypes_.size(), "" components based on type_spec"")); for (int i = 0; i < component_dtypes_.size(); i++) { const Tensor& component = encoded->flat_components()[i]; OP_REQUIRES(context, component_dtypes_[i] == component.dtype(), errors::InvalidArgument(""Tensor component "", i, "" had dtype "", DataType_Name(component.dtype()), ""; expected dtype "", DataType_Name(component_dtypes_[i]))); components.set(i, component); } }"
"static Image *ReadLABELImage(const ImageInfo *image_info, ExceptionInfo *exception) { char geometry[MagickPathExtent], *label; DrawInfo *draw_info; Image *image; MagickBooleanType left_bearing, status; TypeMetric metrics; size_t height, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); if (IsEventLogging() != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); image=AcquireImage(image_info,exception); (void) ResetImagePage(image,""0x0+0+0""); if ((image->columns != 0) && (image->rows != 0)) { status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); (void) SetImageBackgroundColor(image,exception); } label=InterpretImageProperties((ImageInfo *) image_info,image, image_info->filename,exception); if (label == (char *) NULL) return(DestroyImageList(image)); (void) SetImageProperty(image,""label"",label,exception); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); width=(size_t) floor(0.5*draw_info->pointsize*strlen(label)+0.5); if (AcquireMagickResource(WidthResource,width) == MagickFalse) { label=DestroyString(label); draw_info=DestroyDrawInfo(draw_info); ThrowReaderException(ImageError,""WidthOrHeightExceedsLimit""); } draw_info->text=ConstantString(label); (void) memset(&metrics,0,sizeof(metrics)); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); AdjustTypeMetricBounds(&metrics); if ((image->columns == 0) && (image->rows == 0)) { image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); } else if ((status != MagickFalse) && (strlen(label) > 0) && (((image->columns == 0) || (image->rows == 0)) || (fabs(image_info->pointsize) < MagickEpsilon))) { const char *option; double high, low; ssize_t n; low=1.0; option=GetImageOption(image_info,""label:max-pointsize""); if (option != (const char*) NULL) { high=StringToDouble(option,(char**) NULL); if (high < 1.0) high=1.0; high+=1.0; } else { option=GetImageOption(image_info,""label:start-pointsize""); if (option != (const char *) NULL) { draw_info->pointsize=StringToDouble(option,(char**) NULL); if (draw_info->pointsize < 1.0) draw_info->pointsize=1.0; } for (n=0; n < 32; n++, draw_info->pointsize*=2.0) { (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics, exception); if (status == MagickFalse) break; AdjustTypeMetricBounds(&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height-metrics.underline_position+ draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) || (height >= image->rows)) break; if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } if (status == MagickFalse) { label=DestroyString(label); draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } high=draw_info->pointsize; } while((high-low) > 0.5) { draw_info->pointsize=(low+high)/2.0; (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); if (status == MagickFalse) break; AdjustTypeMetricBounds(&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height-metrics.underline_position+ draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } if (status != MagickFalse) { draw_info->pointsize=floor((low+high)/2.0-0.5); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); AdjustTypeMetricBounds(&metrics); } } label=DestroyString(label); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } if (image->columns == 0) image->columns=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); if (image->columns == 0) image->columns=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+ 0.5); if (image->rows == 0) image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if (image->rows == 0) image->rows=(size_t) floor(draw_info->pointsize+draw_info->stroke_width+ 0.5); status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image,exception) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } left_bearing=((draw_info->gravity == UndefinedGravity) || (draw_info->gravity == NorthWestGravity) || (draw_info->gravity == WestGravity) || (draw_info->gravity == SouthWestGravity)) ? MagickTrue : MagickFalse; (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", (draw_info->direction == RightToLeftDirection ? (double) image->columns- (draw_info->gravity == UndefinedGravity ? metrics.bounds.x2 : 0.0) :  (left_bearing != MagickFalse ? metrics.bounds.x1 : 0.0)), (draw_info->gravity == UndefinedGravity ?  MagickMax(metrics.ascent,metrics.bounds.y2) : 0.0)); (void) CloneString(&draw_info->geometry,geometry); status=AnnotateImage(image,draw_info,exception); if (image_info->pointsize == 0.0) (void) FormatImageProperty(image,""label:pointsize"",""%.20g"", draw_info->pointsize); draw_info=DestroyDrawInfo(draw_info); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }"
"void HttpSM::do_range_setup_if_necessary() { MIMEField *field; INKVConnInternal *range_trans; int field_content_type_len = -1; const char *content_type; ink_assert(t_state.cache_info.object_read != nullptr); field = t_state.hdr_info.client_request.field_find(MIME_FIELD_RANGE, MIME_LEN_RANGE); ink_assert(field != nullptr); t_state.range_setup = HttpTransact::RANGE_NONE; if (t_state.method == HTTP_WKSIDX_GET && t_state.hdr_info.client_request.version_get() == HTTPVersion(1, 1)) { do_range_parse(field); if (t_state.range_setup == HttpTransact::RANGE_REQUESTED) { if (!t_state.range_in_cache) { Debug(""http_range"", ""range can't be satisfied from cache, force origin request""); t_state.cache_lookup_result = HttpTransact::CACHE_LOOKUP_MISS; return; } if (t_state.num_range_fields == 1 && cache_sm.cache_read_vc->is_pread_capable()) { t_state.range_setup = HttpTransact::RANGE_NOT_TRANSFORM_REQUESTED; } else if (api_hooks.get(TS_HTTP_RESPONSE_TRANSFORM_HOOK) == nullptr) { Debug(""http_trans"", ""Unable to accelerate range request, fallback to transform""); content_type = t_state.cache_info.object_read->response_get()->value_get(MIME_FIELD_CONTENT_TYPE, MIME_LEN_CONTENT_TYPE, &field_content_type_len); range_trans = transformProcessor.range_transform(mutex.get(), t_state.ranges, t_state.num_range_fields, &t_state.hdr_info.transform_response, content_type, field_content_type_len, t_state.cache_info.object_read->object_size_get()); api_hooks.append(TS_HTTP_RESPONSE_TRANSFORM_HOOK, range_trans); } } } }"
"static inline struct file *io_file_get_fixed(struct io_ring_ctx *ctx, struct io_kiocb *req, int fd) { struct file *file; unsigned long file_ptr; if (unlikely((unsigned int)fd >= ctx->nr_user_files)) return NULL; fd = array_index_nospec(fd, ctx->nr_user_files); file_ptr = io_fixed_file_slot(&ctx->file_table, fd)->file_ptr; file = (struct file *) (file_ptr & FFS_MASK); file_ptr &= ~FFS_MASK; req->flags |= (file_ptr << REQ_F_NOWAIT_READ_BIT); io_req_set_rsrc_node(req); return file; }"
"static MOBI_RET mobi_parse_index_entry(MOBIIndx *indx, const MOBIIdxt idxt, const MOBITagx *tagx, const MOBIOrdt *ordt, MOBIBuffer *buf, const size_t curr_number) { if (indx == NULL) { debug_print(""%s"", ""INDX structure not initialized\n""); return MOBI_INIT_FAILED; } const size_t entry_offset = indx->entries_count; const size_t entry_length = idxt.offsets[curr_number + 1] - idxt.offsets[curr_number]; mobi_buffer_setpos(buf, idxt.offsets[curr_number]); size_t entry_number = curr_number + entry_offset; if (entry_number >= indx->total_entries_count) { debug_print(""Entry number beyond array: %zu\n"", entry_number); return MOBI_DATA_CORRUPT; } const size_t buf_maxlen = buf->maxlen; if (buf->offset + entry_length >= buf_maxlen) { debug_print(""Entry length too long: %zu\n"", entry_length); return MOBI_DATA_CORRUPT; } buf->maxlen = buf->offset + entry_length; size_t label_length = mobi_buffer_get8(buf); if (label_length > entry_length) { debug_print(""Label length too long: %zu\n"", label_length); return MOBI_DATA_CORRUPT; } char text[INDX_LABEL_SIZEMAX]; if (ordt->ordt2) { label_length = mobi_getstring_ordt(ordt, buf, (unsigned char*) text, label_length); } else { label_length = mobi_indx_get_label((unsigned char*) text, buf, label_length, indx->ligt_entries_count); } indx->entries[entry_number].label = malloc(label_length + 1); if (indx->entries[entry_number].label == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", label_length); return MOBI_MALLOC_FAILED; } strncpy(indx->entries[entry_number].label, text, label_length + 1); unsigned char *control_bytes; control_bytes = buf->data + buf->offset; mobi_buffer_seek(buf, (int) tagx->control_byte_count); indx->entries[entry_number].tags_count = 0; indx->entries[entry_number].tags = NULL; if (tagx->tags_count > 0) { typedef struct { uint8_t tag; uint8_t tag_value_count; uint32_t value_count; uint32_t value_bytes; } MOBIPtagx; MOBIPtagx *ptagx = malloc(tagx->tags_count * sizeof(MOBIPtagx)); if (ptagx == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIPtagx)); return MOBI_MALLOC_FAILED; } uint32_t ptagx_count = 0; size_t len; size_t i = 0; while (i < tagx->tags_count) { if (tagx->tags[i].control_byte == 1) { control_bytes++; i++; continue; } uint32_t value = control_bytes[0] & tagx->tags[i].bitmask; if (value != 0) { uint32_t value_count = MOBI_NOTSET; uint32_t value_bytes = MOBI_NOTSET; if (value == tagx->tags[i].bitmask) { if (mobi_bitcount(tagx->tags[i].bitmask) > 1) { len = 0; value_bytes = mobi_buffer_get_varlen(buf, &len); } else { value_count = 1; } } else { uint8_t mask = tagx->tags[i].bitmask; while ((mask & 1) == 0) { mask >>= 1; value >>= 1; } value_count = value; } ptagx[ptagx_count].tag = tagx->tags[i].tag; ptagx[ptagx_count].tag_value_count = tagx->tags[i].values_count; ptagx[ptagx_count].value_count = value_count; ptagx[ptagx_count].value_bytes = value_bytes; ptagx_count++; } i++; } indx->entries[entry_number].tags = malloc(tagx->tags_count * sizeof(MOBIIndexTag)); if (indx->entries[entry_number].tags == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", tagx->tags_count * sizeof(MOBIIndexTag)); free(ptagx); return MOBI_MALLOC_FAILED; } i = 0; while (i < ptagx_count) { uint32_t tagvalues_count = 0; uint32_t tagvalues[INDX_TAGVALUES_MAX]; if (ptagx[i].value_count != MOBI_NOTSET) { size_t count = ptagx[i].value_count * ptagx[i].tag_value_count; while (count-- && tagvalues_count < INDX_TAGVALUES_MAX) { len = 0; const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len); tagvalues[tagvalues_count++] = value_bytes; } } else { len = 0; while (len < ptagx[i].value_bytes && tagvalues_count < INDX_TAGVALUES_MAX) { const uint32_t value_bytes = mobi_buffer_get_varlen(buf, &len); tagvalues[tagvalues_count++] = value_bytes; } } if (tagvalues_count) { const size_t arr_size = tagvalues_count * sizeof(*indx->entries[entry_number].tags[i].tagvalues); indx->entries[entry_number].tags[i].tagvalues = malloc(arr_size); if (indx->entries[entry_number].tags[i].tagvalues == NULL) { debug_print(""Memory allocation failed (%zu bytes)\n"", arr_size); free(ptagx); return MOBI_MALLOC_FAILED; } memcpy(indx->entries[entry_number].tags[i].tagvalues, tagvalues, arr_size); } else { indx->entries[entry_number].tags[i].tagvalues = NULL; } indx->entries[entry_number].tags[i].tagid = ptagx[i].tag; indx->entries[entry_number].tags[i].tagvalues_count = tagvalues_count; indx->entries[entry_number].tags_count++; i++; } free(ptagx); } buf->maxlen = buf_maxlen; return MOBI_SUCCESS; }"
"inline void LayoutObject::setChildNeedsLayout(MarkingBehavior markParents, SubtreeLayoutScope* layouter) { ASSERT(!isSetNeedsLayoutForbidden()); bool alreadyNeededLayout = normalChildNeedsLayout(); setNormalChildNeedsLayout(true); if (!alreadyNeededLayout && markParents == MarkContainerChain && (!layouter || layouter->root() != this)) markContainerChainForLayout(true, layouter); }"
"static int iasecc_select_file(struct sc_card *card, const struct sc_path *path, struct sc_file **file_out) { struct sc_context *ctx = card->ctx; struct sc_path lpath; int cache_valid = card->cache.valid, df_from_cache = 0; int rv, ii; LOG_FUNC_CALLED(ctx); memcpy(&lpath, path, sizeof(struct sc_path)); if (file_out) *file_out = NULL; sc_log(ctx, ""iasecc_select_file(card:%p) path.len %""SC_FORMAT_LEN_SIZE_T""u; path.type %i; aid_len %""SC_FORMAT_LEN_SIZE_T""u"", card, path->len, path->type, path->aid.len); sc_log(ctx, ""iasecc_select_file() path:%s"", sc_print_path(path)); sc_print_cache(card); if (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   { sc_log(ctx, ""EF.ATR(aid:'%s')"", card->ef_atr ? sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len) : """"); rv = iasecc_select_mf(card, file_out); LOG_TEST_RET(ctx, rv, ""MF selection error""); if (lpath.len >= 2 && lpath.value[0] == 0x3F && lpath.value[1] == 0x00)   { memmove(&lpath.value[0], &lpath.value[2], lpath.len - 2); lpath.len -=  2; } } if (lpath.aid.len){ struct sc_file *file = NULL; struct sc_path ppath; sc_log(ctx, ""iasecc_select_file() select parent AID:%p/%""SC_FORMAT_LEN_SIZE_T""u"", lpath.aid.value, lpath.aid.len); sc_log(ctx, ""iasecc_select_file() select parent AID:%s"", sc_dump_hex(lpath.aid.value, lpath.aid.len)); memset(&ppath, 0, sizeof(ppath)); memcpy(ppath.value, lpath.aid.value, lpath.aid.len); ppath.len = lpath.aid.len; ppath.type = SC_PATH_TYPE_DF_NAME; if (card->cache.valid && card->cache.current_df && card->cache.current_df->path.len == lpath.aid.len && !memcmp(card->cache.current_df->path.value, lpath.aid.value, lpath.aid.len)) df_from_cache = 1; rv = iasecc_select_file(card, &ppath, &file); LOG_TEST_RET(ctx, rv, ""select AID path failed""); if (file_out) *file_out = file; else sc_file_free(file); if (lpath.type == SC_PATH_TYPE_DF_NAME) lpath.type = SC_PATH_TYPE_FROM_CURRENT; } if (lpath.type == SC_PATH_TYPE_PATH) lpath.type = SC_PATH_TYPE_FROM_CURRENT; if (!lpath.len) LOG_FUNC_RETURN(ctx, SC_SUCCESS); sc_print_cache(card); if (card->cache.valid && card->cache.current_df && lpath.type == SC_PATH_TYPE_DF_NAME && card->cache.current_df->path.len == lpath.len && !memcmp(card->cache.current_df->path.value, lpath.value, lpath.len))   { sc_log(ctx, ""returns current DF path %s"", sc_print_path(&card->cache.current_df->path)); if (file_out)   { sc_file_free(*file_out); sc_file_dup(file_out, card->cache.current_df); } sc_print_cache(card); LOG_FUNC_RETURN(ctx, SC_SUCCESS); } do   { struct sc_apdu apdu; struct sc_file *file = NULL; unsigned char rbuf[SC_MAX_APDU_BUFFER_SIZE]; int pathlen = lpath.len; sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0x00, 0x00); if (card->type != SC_CARD_TYPE_IASECC_GEMALTO && card->type != SC_CARD_TYPE_IASECC_OBERTHUR && card->type != SC_CARD_TYPE_IASECC_SAGEM && card->type != SC_CARD_TYPE_IASECC_AMOS && card->type != SC_CARD_TYPE_IASECC_MI && card->type != SC_CARD_TYPE_IASECC_MI2) LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, ""Unsupported card""); if (lpath.type == SC_PATH_TYPE_FILE_ID)   { apdu.p1 = 0x02; if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR)   { apdu.p1 = 0x01; apdu.p2 = 0x04; } if (card->type == SC_CARD_TYPE_IASECC_AMOS) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_MI) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_MI2) apdu.p2 = 0x04; } else if (lpath.type == SC_PATH_TYPE_FROM_CURRENT)  { apdu.p1 = 0x09; if (card->type == SC_CARD_TYPE_IASECC_OBERTHUR) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_AMOS) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_MI) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_MI2) apdu.p2 = 0x04; } else if (lpath.type == SC_PATH_TYPE_PARENT)   { apdu.p1 = 0x03; pathlen = 0; apdu.cse = SC_APDU_CASE_2_SHORT; } else if (lpath.type == SC_PATH_TYPE_DF_NAME)   { apdu.p1 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_AMOS) apdu.p2 = 0x04; if (card->type == SC_CARD_TYPE_IASECC_MI2) apdu.p2 = 0x04; } else   { sc_log(ctx, ""Invalid PATH type: 0x%X"", lpath.type); LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, ""iasecc_select_file() invalid PATH type""); } for (ii=0; ii<2; ii++)   { apdu.lc = pathlen; apdu.data = lpath.value; apdu.datalen = pathlen; apdu.resp = rbuf; apdu.resplen = sizeof(rbuf); apdu.le = 256; rv = sc_transmit_apdu(card, &apdu); LOG_TEST_RET(ctx, rv, ""APDU transmit failed""); rv = sc_check_sw(card, apdu.sw1, apdu.sw2); if (rv == SC_ERROR_INCORRECT_PARAMETERS && lpath.type == SC_PATH_TYPE_DF_NAME && apdu.p2 == 0x00)   { apdu.p2 = 0x0C; continue; } if (ii)   { apdu.resplen = sizeof(rbuf); rv = iasecc_emulate_fcp(ctx, &apdu); LOG_TEST_RET(ctx, rv, ""Failed to emulate DF FCP""); } break; } if (rv == SC_ERROR_FILE_NOT_FOUND && cache_valid && df_from_cache)   { sc_invalidate_cache(card); sc_log(ctx, ""iasecc_select_file() file not found, retry without cached DF""); if (file_out)   { sc_file_free(*file_out); *file_out = NULL; } rv = iasecc_select_file(card, path, file_out); LOG_FUNC_RETURN(ctx, rv); } LOG_TEST_RET(ctx, rv, ""iasecc_select_file() check SW failed""); sc_log(ctx, ""iasecc_select_file() apdu.resp %""SC_FORMAT_LEN_SIZE_T""u"", apdu.resplen); if (apdu.resplen)   { sc_log(ctx, ""apdu.resp %02X:%02X:%02X..."", apdu.resp[0], apdu.resp[1], apdu.resp[2]); switch (apdu.resp[0]) { case 0x62: case 0x6F: file = sc_file_new(); if (file == NULL) LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); file->path = lpath; rv = iasecc_process_fci(card, file, apdu.resp, apdu.resplen); if (rv) LOG_FUNC_RETURN(ctx, rv); break; default: LOG_FUNC_RETURN(ctx, SC_ERROR_UNKNOWN_DATA_RECEIVED); } sc_log(ctx, ""FileType %i"", file->type); if (file->type == SC_FILE_TYPE_DF)   { if (card->cache.valid) sc_file_free(card->cache.current_df); card->cache.current_df = NULL; if (card->cache.valid) sc_file_free(card->cache.current_ef); card->cache.current_ef = NULL; sc_file_dup(&card->cache.current_df, file); card->cache.valid = 1; } else   { if (card->cache.valid) sc_file_free(card->cache.current_ef); card->cache.current_ef = NULL; sc_file_dup(&card->cache.current_ef, file); } if (file_out)   { sc_file_free(*file_out); *file_out = file; } else   { sc_file_free(file); } } else if (lpath.type == SC_PATH_TYPE_DF_NAME)   { sc_file_free(card->cache.current_df); card->cache.current_df = NULL; sc_file_free(card->cache.current_ef); card->cache.current_ef = NULL; card->cache.valid = 1; } } while(0); sc_print_cache(card); LOG_FUNC_RETURN(ctx, SC_SUCCESS); }"
"void CSndUList::update(const CUDT* u, EReschedule reschedule) { CGuard listguard(m_ListLock); CSNode* n = u->m_pSNode; if (n->m_iHeapLoc >= 0) { if (!reschedule)          return; if (n->m_iHeapLoc == 0) { n->m_llTimeStamp_tk = 1; m_pTimer->interrupt(); return; } remove_(u); insert_norealloc(1, u); return; } insert_(1, u); }"
"static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key, unsigned int keylen) { return -ENOSYS; }"
"void retreat (octet_iterator& it, distance_type n, octet_iterator start) { for (distance_type i = 0; i < n; ++i) utf8::prior(it, start); }"
"static int get_exif_tag_int_value(struct iw_exif_state *e, unsigned int tag_pos, unsigned int *pv) { unsigned int field_type; unsigned int value_count; field_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian); value_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian); if(value_count!=1) return 0; if(field_type==3) { *pv = iw_get_ui16_e(&e->d[tag_pos+8],e->endian); return 1; } else if(field_type==4) { *pv = iw_get_ui32_e(&e->d[tag_pos+8],e->endian); return 1; } return 0; }"
"bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs) { { LOCK(mempool.cs); BOOST_FOREACH(CMerkleTx& tx, vtxPrev) { if (!tx.IsCoinBase()) { uint256 hash = tx.GetHash(); if (!mempool.exists(hash) && !txdb.ContainsTx(hash)) tx.AcceptToMemoryPool(txdb, fCheckInputs); } } return AcceptToMemoryPool(txdb, fCheckInputs); } return false; }"
"static int renameColumnSelectCb(Walker *pWalker, Select *p){ renameWalkWith(pWalker, p); return WRC_Continue; }"
"int htc_connect_service(struct htc_target *target, struct htc_service_connreq *service_connreq, enum htc_endpoint_id *conn_rsp_epid) { struct sk_buff *skb; struct htc_endpoint *endpoint; struct htc_conn_svc_msg *conn_msg; int ret; unsigned long time_left; endpoint = get_next_avail_ep(target->endpoint); if (!endpoint) { dev_err(target->dev, ""Endpoint is not available for service %d\n"", service_connreq->service_id); return -EINVAL; } endpoint->service_id = service_connreq->service_id; endpoint->max_txqdepth = service_connreq->max_send_qdepth; endpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id); endpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id); endpoint->ep_callbacks = service_connreq->ep_callbacks; skb = alloc_skb(sizeof(struct htc_conn_svc_msg) + sizeof(struct htc_frame_hdr), GFP_ATOMIC); if (!skb) { dev_err(target->dev, ""Failed to allocate buf to send"" ""service connect req\n""); return -ENOMEM; } skb_reserve(skb, sizeof(struct htc_frame_hdr)); conn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg)); conn_msg->service_id = cpu_to_be16(service_connreq->service_id); conn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID); conn_msg->con_flags = cpu_to_be16(service_connreq->con_flags); conn_msg->dl_pipeid = endpoint->dl_pipeid; conn_msg->ul_pipeid = endpoint->ul_pipeid; ret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0); if (ret) goto err; time_left = wait_for_completion_timeout(&target->cmd_wait, HZ); if (!time_left) { dev_err(target->dev, ""Service connection timeout for: %d\n"", service_connreq->service_id); return -ETIMEDOUT; } *conn_rsp_epid = target->conn_rsp_epid; return 0; err: kfree_skb(skb); return ret; }"
"void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) { if (MinSize > UINT32_MAX) report_bad_alloc_error(""SmallVector capacity overflow during allocation""); size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2)); NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX)); T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T))); this->uninitialized_move(this->begin(), this->end(), NewElts); destroy_range(this->begin(), this->end()); if (!this->isSmall()) free(this->begin()); this->BeginX = NewElts; this->Capacity = NewCapacity; }"
"void Gobby::EditCommands::on_redo() { g_assert(m_current_view != NULL); gulong i_ = g_signal_connect_after(m_current_view->get_text_buffer(), ""insert-text"", G_CALLBACK(recaret_i), NULL); gulong e_ = g_signal_connect_after(m_current_view->get_text_buffer(), ""delete-range"", G_CALLBACK(recaret_e), NULL); inf_adopted_session_redo( INF_ADOPTED_SESSION(m_current_view->get_session()), INF_ADOPTED_USER(m_current_view->get_active_user()), m_current_view->get_undo_grouping().get_redo_size() ); g_signal_handler_disconnect(m_current_view->get_text_buffer(), i_); g_signal_handler_disconnect(m_current_view->get_text_buffer(), e_); if(check) { GtkTextIter check_iter; gtk_text_buffer_get_iter_at_mark(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), &check_iter, check); gtk_text_buffer_select_range(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), &check_iter, &check_iter); gtk_text_buffer_delete_mark(GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), check); check = NULL; } m_current_view->scroll_to_cursor_position(0.0); }"
"static int ssl_scan_serverhello_tlsext(SSL *s, PACKET *pkt, int *al) { unsigned int length, type, size; int tlsext_servername = 0; int renegotiate_seen = 0; #ifndef OPENSSL_NO_NEXTPROTONEG s->s3->next_proto_neg_seen = 0; #endif s->tlsext_ticket_expected = 0; OPENSSL_free(s->s3->alpn_selected); s->s3->alpn_selected = NULL; #ifndef OPENSSL_NO_HEARTBEATS s->tlsext_heartbeat &= ~(SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS); #endif s->s3->flags &= ~TLS1_FLAGS_ENCRYPT_THEN_MAC; s->s3->flags &= ~TLS1_FLAGS_RECEIVED_EXTMS; if (!PACKET_get_net_2(pkt, &length)) goto ri_check; if (PACKET_remaining(pkt) != length) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!tls1_check_duplicate_extensions(pkt)) { *al = SSL_AD_DECODE_ERROR; return 0; } while (PACKET_get_net_2(pkt, &type) && PACKET_get_net_2(pkt, &size)) { const unsigned char *data; PACKET spkt; if (!PACKET_get_sub_packet(pkt, &spkt, size) || !PACKET_peek_bytes(&spkt, &data, size)) goto ri_check; if (s->tlsext_debug_cb) s->tlsext_debug_cb(s, 1, type, data, size, s->tlsext_debug_arg); if (type == TLSEXT_TYPE_renegotiate) { if (!ssl_parse_serverhello_renegotiate_ext(s, &spkt, al)) return 0; renegotiate_seen = 1; } else if (s->version == SSL3_VERSION) { } else if (type == TLSEXT_TYPE_server_name) { if (s->tlsext_hostname == NULL || size > 0) { *al = TLS1_AD_UNRECOGNIZED_NAME; return 0; } tlsext_servername = 1; } #ifndef OPENSSL_NO_EC else if (type == TLSEXT_TYPE_ec_point_formats) { unsigned int ecpointformatlist_length; if (!PACKET_get_1(&spkt, &ecpointformatlist_length) || ecpointformatlist_length != size - 1) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (!s->hit) { s->session->tlsext_ecpointformatlist_length = 0; OPENSSL_free(s->session->tlsext_ecpointformatlist); if ((s->session->tlsext_ecpointformatlist = OPENSSL_malloc(ecpointformatlist_length)) == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } s->session->tlsext_ecpointformatlist_length = ecpointformatlist_length; if (!PACKET_copy_bytes(&spkt, s->session->tlsext_ecpointformatlist, ecpointformatlist_length)) { *al = TLS1_AD_DECODE_ERROR; return 0; } } } #endif                           else if (type == TLSEXT_TYPE_session_ticket) { if (s->tls_session_ticket_ext_cb && !s->tls_session_ticket_ext_cb(s, data, size, s->tls_session_ticket_ext_cb_arg)) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } if (!tls_use_ticket(s) || (size > 0)) { *al = TLS1_AD_UNSUPPORTED_EXTENSION; return 0; } s->tlsext_ticket_expected = 1; } else if (type == TLSEXT_TYPE_status_request) { if ((s->tlsext_status_type == -1) || (size > 0)) { *al = TLS1_AD_UNSUPPORTED_EXTENSION; return 0; } s->tlsext_status_expected = 1; } #ifndef OPENSSL_NO_CT else if (type == TLSEXT_TYPE_signed_certificate_timestamp && s->ct_validation_callback != NULL) { if (s->tlsext_scts != NULL) { OPENSSL_free(s->tlsext_scts); s->tlsext_scts = NULL; } s->tlsext_scts_len = size; if (size > 0) { s->tlsext_scts = OPENSSL_malloc(size); if (s->tlsext_scts == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } memcpy(s->tlsext_scts, data, size); } } #endif #ifndef OPENSSL_NO_NEXTPROTONEG else if (type == TLSEXT_TYPE_next_proto_neg && s->s3->tmp.finish_md_len == 0) { unsigned char *selected; unsigned char selected_len; if (s->ctx->next_proto_select_cb == NULL) { *al = TLS1_AD_UNSUPPORTED_EXTENSION; return 0; } if (!ssl_next_proto_validate(&spkt)) { *al = TLS1_AD_DECODE_ERROR; return 0; } if (s->ctx->next_proto_select_cb(s, &selected, &selected_len, data, size, s-> ctx->next_proto_select_cb_arg) != SSL_TLSEXT_ERR_OK) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } OPENSSL_free(s->next_proto_negotiated); s->next_proto_negotiated = OPENSSL_malloc(selected_len); if (s->next_proto_negotiated == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } memcpy(s->next_proto_negotiated, selected, selected_len); s->next_proto_negotiated_len = selected_len; s->s3->next_proto_neg_seen = 1; } #endif else if (type == TLSEXT_TYPE_application_layer_protocol_negotiation) { unsigned len; if (!s->s3->alpn_sent) { *al = TLS1_AD_UNSUPPORTED_EXTENSION; return 0; } if (!PACKET_get_net_2(&spkt, &len) || PACKET_remaining(&spkt) != len || !PACKET_get_1(&spkt, &len) || PACKET_remaining(&spkt) != len) { *al = TLS1_AD_DECODE_ERROR; return 0; } OPENSSL_free(s->s3->alpn_selected); s->s3->alpn_selected = OPENSSL_malloc(len); if (s->s3->alpn_selected == NULL) { *al = TLS1_AD_INTERNAL_ERROR; return 0; } if (!PACKET_copy_bytes(&spkt, s->s3->alpn_selected, len)) { *al = TLS1_AD_DECODE_ERROR; return 0; } s->s3->alpn_selected_len = len; } #ifndef OPENSSL_NO_HEARTBEATS else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_heartbeat) { unsigned int hbtype; if (!PACKET_get_1(&spkt, &hbtype)) { *al = SSL_AD_DECODE_ERROR; return 0; } switch (hbtype) { case 0x01:          s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; break; case 0x02:          s->tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED; s->tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS; break; default: *al = SSL_AD_ILLEGAL_PARAMETER; return 0; } } #endif #ifndef OPENSSL_NO_SRTP else if (SSL_IS_DTLS(s) && type == TLSEXT_TYPE_use_srtp) { if (ssl_parse_serverhello_use_srtp_ext(s, &spkt, al)) return 0; } #endif else if (type == TLSEXT_TYPE_encrypt_then_mac) { if (s->s3->tmp.new_cipher->algorithm_mac != SSL_AEAD && s->s3->tmp.new_cipher->algorithm_enc != SSL_RC4) s->s3->flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC; } else if (type == TLSEXT_TYPE_extended_master_secret) { s->s3->flags |= TLS1_FLAGS_RECEIVED_EXTMS; if (!s->hit) s->session->flags |= SSL_SESS_FLAG_EXTMS; } else if (custom_ext_parse(s, 0, type, data, size, al) <= 0) return 0; } if (PACKET_remaining(pkt) != 0) { *al = SSL_AD_DECODE_ERROR; return 0; } if (!s->hit && tlsext_servername == 1) { if (s->tlsext_hostname) { if (s->session->tlsext_hostname == NULL) { s->session->tlsext_hostname = OPENSSL_strdup(s->tlsext_hostname); if (!s->session->tlsext_hostname) { *al = SSL_AD_UNRECOGNIZED_NAME; return 0; } } else { *al = SSL_AD_DECODE_ERROR; return 0; } } } ri_check: if (!renegotiate_seen && !(s->options & SSL_OP_LEGACY_SERVER_CONNECT) && !(s->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED); return 0; } if (s->hit) { if (!(s->s3->flags & TLS1_FLAGS_RECEIVED_EXTMS) != !(s->session->flags & SSL_SESS_FLAG_EXTMS)) { *al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT, SSL_R_INCONSISTENT_EXTMS); return 0; } } return 1; }"
"int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm, const char *dir) { char offset[40] = """", name[200] = """", path[256]; mg_http_get_var(&hm->query, ""offset"", offset, sizeof(offset)); mg_http_get_var(&hm->query, ""name"", name, sizeof(name)); if (name[0] == '\0') { mg_http_reply(c, 400, """", ""%s"", ""name required""); return -1; } else { FILE *fp; size_t oft = strtoul(offset, NULL, 0); snprintf(path, sizeof(path), ""%s%c%s"", dir, MG_DIRSEP, name); LOG(LL_DEBUG, (""%p %d bytes @ %d [%s]"", c->fd, (int) hm->body.len, (int) oft, name)); if ((fp = fopen(path, oft == 0 ? ""wb"" : ""ab"")) == NULL) { mg_http_reply(c, 400, """", ""fopen(%s): %d"", name, errno); return -2; } else { fwrite(hm->body.ptr, 1, hm->body.len, fp); fclose(fp); mg_http_reply(c, 200, """", """"); return (int) hm->body.len; } } }"
"static u_int ldp_pdu_print(netdissect_options *ndo, register const u_char *pptr) { const struct ldp_common_header *ldp_com_header; const struct ldp_msg_header *ldp_msg_header; const u_char *tptr,*msg_tptr; u_short tlen; u_short pdu_len,msg_len,msg_type,msg_tlen; int hexdump,processed; ldp_com_header = (const struct ldp_common_header *)pptr; ND_TCHECK(*ldp_com_header); if (EXTRACT_16BITS(&ldp_com_header->version) != LDP_VERSION) { ND_PRINT((ndo, ""%sLDP version %u packet not supported"", (ndo->ndo_vflag < 1) ? """" : ""\n\t"", EXTRACT_16BITS(&ldp_com_header->version))); return 0; } pdu_len = EXTRACT_16BITS(&ldp_com_header->pdu_length); if (pdu_len < sizeof(const struct ldp_common_header)-4) { ND_PRINT((ndo, ""%sLDP, pdu-length: %u (too short, < %u)"", (ndo->ndo_vflag < 1) ? """" : ""\n\t"", pdu_len, (u_int)(sizeof(const struct ldp_common_header)-4))); return 0; } ND_PRINT((ndo, ""%sLDP, Label-Space-ID: %s:%u, pdu-length: %u"", (ndo->ndo_vflag < 1) ? """" : ""\n\t"", ipaddr_string(ndo, &ldp_com_header->lsr_id), EXTRACT_16BITS(&ldp_com_header->label_space), pdu_len)); if (ndo->ndo_vflag < 1) return 0; tptr = pptr + sizeof(const struct ldp_common_header); tlen = pdu_len - (sizeof(const struct ldp_common_header)-4); while(tlen>0) { ND_TCHECK2(*tptr, sizeof(struct ldp_msg_header)); ldp_msg_header = (const struct ldp_msg_header *)tptr; msg_len=EXTRACT_16BITS(ldp_msg_header->length); msg_type=LDP_MASK_MSG_TYPE(EXTRACT_16BITS(ldp_msg_header->type)); if (msg_len < sizeof(struct ldp_msg_header)-4) { ND_PRINT((ndo, ""\n\t  %s Message (0x%04x), length: %u (too short, < %u)"", tok2str(ldp_msg_values, ""Unknown"", msg_type), msg_type, msg_len, (u_int)(sizeof(struct ldp_msg_header)-4))); return 0; } ND_PRINT((ndo, ""\n\t  %s Message (0x%04x), length: %u, Message ID: 0x%08x, Flags: [%s if unknown]"", tok2str(ldp_msg_values, ""Unknown"", msg_type), msg_type, msg_len, EXTRACT_32BITS(&ldp_msg_header->id), LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_msg_header->type)) ? ""continue processing"" : ""ignore"")); msg_tptr=tptr+sizeof(struct ldp_msg_header); msg_tlen=msg_len-(sizeof(struct ldp_msg_header)-4);  ND_TCHECK2(*tptr, msg_len); hexdump=FALSE; switch(msg_type) { case LDP_MSG_NOTIF: case LDP_MSG_HELLO: case LDP_MSG_INIT: case LDP_MSG_KEEPALIVE: case LDP_MSG_ADDRESS: case LDP_MSG_LABEL_MAPPING: case LDP_MSG_ADDRESS_WITHDRAW: case LDP_MSG_LABEL_WITHDRAW: while(msg_tlen >= 4) { processed = ldp_tlv_print(ndo, msg_tptr, msg_tlen); if (processed == 0) break; msg_tlen-=processed; msg_tptr+=processed; } break; case LDP_MSG_LABEL_REQUEST: case LDP_MSG_LABEL_RELEASE: case LDP_MSG_LABEL_ABORT_REQUEST: default: if (ndo->ndo_vflag <= 1) print_unknown_data(ndo, msg_tptr, ""\n\t  "", msg_tlen); break; } if (ndo->ndo_vflag > 1 || hexdump==TRUE) print_unknown_data(ndo, tptr+sizeof(struct ldp_msg_header), ""\n\t  "", msg_len); tptr += msg_len+4; tlen -= msg_len+4; } return pdu_len+4; trunc: ND_PRINT((ndo, ""\n\t\t packet exceeded snapshot"")); return 0; }"
"static void binder_free_buf(struct binder_proc *proc, struct binder_thread *thread, struct binder_buffer *buffer, bool is_failure) { binder_inner_proc_lock(proc); if (buffer->transaction) { buffer->transaction->buffer = NULL; buffer->transaction = NULL; } binder_inner_proc_unlock(proc); if (buffer->async_transaction && buffer->target_node) { struct binder_node *buf_node; struct binder_work *w; buf_node = buffer->target_node; binder_node_inner_lock(buf_node); BUG_ON(!buf_node->has_async_transaction); BUG_ON(buf_node->proc != proc); w = binder_dequeue_work_head_ilocked( &buf_node->async_todo); if (!w) { buf_node->has_async_transaction = false; } else { binder_enqueue_work_ilocked( w, &proc->todo); binder_wakeup_proc_ilocked(proc); } binder_node_inner_unlock(buf_node); } trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, thread, buffer, 0, is_failure); binder_alloc_free_buf(&proc->alloc, buffer); }"
"void swf_report(SWFReader *read, GF_Err e, char *format, ...) { #ifndef GPAC_DISABLE_LOG if (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) { char szMsg[2048]; va_list args; va_start(args, format); vsprintf(szMsg, format, args); va_end(args); GF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[SWF Parsing] %s (frame %d)\n"", szMsg, read->current_frame+1) ); } #endif }"
"int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb) { int err; u32 tsk_portid = cb->args[0]; u32 last_publ = cb->args[1]; u32 done = cb->args[2]; struct net *net = sock_net(skb->sk); struct tipc_sock *tsk; if (!tsk_portid) { struct nlattr **attrs; struct nlattr *sock[TIPC_NLA_SOCK_MAX + 1]; err = tipc_nlmsg_parse(cb->nlh, &attrs); if (err) return err; err = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX, attrs[TIPC_NLA_SOCK], tipc_nl_sock_policy); if (err) return err; if (!sock[TIPC_NLA_SOCK_REF]) return -EINVAL; tsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]); } if (done) return 0; tsk = tipc_sk_lookup(net, tsk_portid); if (!tsk) return -EINVAL; lock_sock(&tsk->sk); err = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ); if (!err) done = 1; release_sock(&tsk->sk); sock_put(&tsk->sk); cb->args[0] = tsk_portid; cb->args[1] = last_publ; cb->args[2] = done; return skb->len; }"
"int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb, data_exchange_cb_t cb, void *cb_context) { int rc; pr_debug(""dev_name=%s target_idx=%u skb->len=%u\n"", dev_name(&dev->dev), target_idx, skb->len); device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; kfree_skb(skb); goto error; } if (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) { if (dev->active_target->idx != target_idx) { rc = -EADDRNOTAVAIL; kfree_skb(skb); goto error; } if (dev->ops->check_presence) del_timer_sync(&dev->check_pres_timer); rc = dev->ops->im_transceive(dev, dev->active_target, skb, cb, cb_context); if (!rc && dev->ops->check_presence && !dev->shutting_down) mod_timer(&dev->check_pres_timer, jiffies + msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS)); } else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) { rc = dev->ops->tm_send(dev, skb); } else { rc = -ENOTCONN; kfree_skb(skb); goto error; } error: device_unlock(&dev->dev); return rc; }"
"static __inline tTcpIpPacketParsingResult QualifyIpPacket(IPHeader *pIpHeader, ULONG len) { tTcpIpPacketParsingResult res; UCHAR  ver_len = pIpHeader->v4.ip_verlen; UCHAR  ip_version = (ver_len & 0xF0) >> 4; USHORT ipHeaderSize = 0; USHORT fullLength = 0; res.value = 0; if (ip_version == 4) { ipHeaderSize = (ver_len & 0xF) << 2; fullLength = swap_short(pIpHeader->v4.ip_length); DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\n"", ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength)); res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP; if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort; if (fullLength) {} else { DPrintf(2, (""ip v.%d, iplen %d\n"", ip_version, fullLength)); } } else if (ip_version == 6) { UCHAR nextHeader = pIpHeader->v6.ip6_next_header; BOOLEAN bParsingDone = FALSE; ipHeaderSize = sizeof(pIpHeader->v6); res.ipStatus = ppresIPV6; res.ipCheckSum = ppresCSOK; fullLength = swap_short(pIpHeader->v6.ip6_payload_len); fullLength += ipHeaderSize; while (nextHeader != 59) { IPv6ExtHeader *pExt; switch (nextHeader) { case PROTOCOL_TCP: bParsingDone = TRUE; res.xxpStatus = ppresXxpKnown; res.TcpUdp = ppresIsTCP; res.xxpFull = len >= fullLength ? 1 : 0; res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize); break; case PROTOCOL_UDP: bParsingDone = TRUE; res.xxpStatus = ppresXxpKnown; res.TcpUdp = ppresIsUDP; res.xxpFull = len >= fullLength ? 1 : 0; res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize); break; case 0: case 60: case 43: case 44: case 51: case 50: case 135: if (len >= ((ULONG)ipHeaderSize + 8)) { pExt = (IPv6ExtHeader *)((PUCHAR)pIpHeader + ipHeaderSize); nextHeader = pExt->ip6ext_next_header; ipHeaderSize += 8; ipHeaderSize += pExt->ip6ext_hdr_len * 8; } else { DPrintf(0, (""[%s] ERROR: Break in the middle of ext. headers(len %d, hdr > %d)\n"", __FUNCTION__, len, ipHeaderSize)); res.ipStatus = ppresNotIP; bParsingDone = TRUE; } break; default: res.xxpStatus = ppresXxpOther; bParsingDone = TRUE; break; } if (bParsingDone) break; } if (ipHeaderSize <= MAX_SUPPORTED_IPV6_HEADERS) { DPrintf(3, (""ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\n"", ip_version, ipHeaderSize, nextHeader, fullLength)); res.ipHeaderSize = ipHeaderSize; } else { DPrintf(0, (""[%s] ERROR: IP chain is too large (%d)\n"", __FUNCTION__, ipHeaderSize)); res.ipStatus = ppresNotIP; } } if (res.ipStatus == ppresIPV4) { res.ipHeaderSize = ipHeaderSize; res.xxpFull = len >= fullLength ? 1 : 0; res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0; switch (pIpHeader->v4.ip_protocol) { case PROTOCOL_TCP: { res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize); } break; case PROTOCOL_UDP: { res = ProcessUDPHeader(res, pIpHeader, len, ipHeaderSize); } break; default: res.xxpStatus = ppresXxpOther; break; } } return res; }"
"ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size) { struct inode *inode = d_inode(entry); struct fuse_mount *fm = get_fuse_mount(inode); FUSE_ARGS(args); struct fuse_getxattr_in inarg; struct fuse_getxattr_out outarg; ssize_t ret; if (!fuse_allow_current_process(fm->fc)) return -EACCES; if (fm->fc->no_listxattr) return -EOPNOTSUPP; memset(&inarg, 0, sizeof(inarg)); inarg.size = size; args.opcode = FUSE_LISTXATTR; args.nodeid = get_node_id(inode); args.in_numargs = 1; args.in_args[0].size = sizeof(inarg); args.in_args[0].value = &inarg; args.out_numargs = 1; if (size) { args.out_argvar = true; args.out_args[0].size = size; args.out_args[0].value = list; } else { args.out_args[0].size = sizeof(outarg); args.out_args[0].value = &outarg; } ret = fuse_simple_request(fm, &args); if (!ret && !size) ret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX); if (ret > 0 && size) ret = fuse_verify_xattr_list(list, ret); if (ret == -ENOSYS) { fm->fc->no_listxattr = 1; ret = -EOPNOTSUPP; } return ret; }"
"int yc_decrypt(char *fbuf, unsigned int filesize, struct cli_exe_section *sections, unsigned int sectcount, uint32_t peoffset, int desc, uint32_t ecx,int16_t offset) { uint32_t ycsect = sections[sectcount].raw+offset; unsigned int i; struct pe_image_file_hdr *pe = (struct pe_image_file_hdr*) (fbuf + peoffset); char *sname = (char *)pe + EC16(pe->SizeOfOptionalHeader) + 0x18; cli_dbgmsg(""yC: offset: %x, length: %x\n"", offset, ecx); cli_dbgmsg(""yC: decrypting decryptor on sect %d\n"", sectcount); if (yc_poly_emulator(fbuf + ycsect + 0x93, fbuf + ycsect + 0xc6, ecx)) return 1; filesize-=sections[sectcount].ursz; for(i=0;i<sectcount;i++) { uint32_t name = (uint32_t) cli_readint32(sname+i*0x28); if (!sections[i].raw || !sections[i].rsz || name == 0x63727372 ||  name == 0x7273722E ||  name == 0x6F6C6572 ||  name == 0x6C65722E ||  name == 0x6164652E ||  name == 0x6164722E ||  name == 0x6164692E ||  name == 0x736C742E ||  (name&0xffff) == 0x4379   ) continue; cli_dbgmsg(""yC: decrypting sect%d\n"",i); if (yc_poly_emulator(fbuf + ycsect + (offset == -0x18 ? 0x3ea : 0x457), fbuf + sections[i].raw, sections[i].ursz)) return 1; } pe->NumberOfSections=EC16(sectcount); memset((char *)pe + sizeof(struct pe_image_file_hdr) + 0x68, 0, 8); cli_writeint32((char *)pe + sizeof(struct pe_image_file_hdr) + 16, cli_readint32(fbuf + ycsect + 0xa0f)); cli_writeint32((char *)pe + sizeof(struct pe_image_file_hdr) + 0x38, cli_readint32((char *)pe + sizeof(struct pe_image_file_hdr) + 0x38) - sections[sectcount].vsz); if (cli_writen(desc, fbuf, filesize)==-1) { cli_dbgmsg(""yC: Cannot write unpacked file\n""); return 1; } return 0; }"
"static int write_msr(unsigned int reg, uint64_t val, struct x86_emulate_ctxt *ctxt) { struct vcpu *curr = current; const struct domain *currd = curr->domain; bool vpmu_msr = false; int ret; if ( (ret = guest_wrmsr(curr, reg, val)) != X86EMUL_UNHANDLEABLE ) { if ( ret == X86EMUL_EXCEPTION ) x86_emul_hw_exception(TRAP_gp_fault, 0, ctxt); return ret; } switch ( reg ) { uint64_t temp; case MSR_FS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrfsbase(val); return X86EMUL_OKAY; case MSR_GS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrgsbase(val); return X86EMUL_OKAY; case MSR_SHADOW_GS_BASE: if ( is_pv_32bit_domain(currd) || !is_canonical_address(val) ) break; wrgsshadow(val); curr->arch.pv.gs_base_user = val; return X86EMUL_OKAY; case MSR_EFER: if ( val != guest_efer(currd) ) break; return X86EMUL_OKAY; case MSR_K7_FID_VID_STATUS: case MSR_K7_FID_VID_CTL: case MSR_K8_PSTATE_LIMIT: case MSR_K8_PSTATE_CTRL: case MSR_K8_PSTATE_STATUS: case MSR_K8_PSTATE0: case MSR_K8_PSTATE1: case MSR_K8_PSTATE2: case MSR_K8_PSTATE3: case MSR_K8_PSTATE4: case MSR_K8_PSTATE5: case MSR_K8_PSTATE6: case MSR_K8_PSTATE7: case MSR_K8_HWCR: if ( !(boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_AMD64_NB_CFG: if ( !is_hwdom_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) || ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) ) goto invalid; if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 ) return X86EMUL_OKAY; break; case MSR_FAM10H_MMIO_CONF_BASE: if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD || boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 >= 0x17 ) break; if ( !is_hwdom_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 ) break; if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ? temp != val : ((temp ^ val) & ~(FAM10H_MMIO_CONF_ENABLE | (FAM10H_MMIO_CONF_BUSRANGE_MASK << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) | ((u64)FAM10H_MMIO_CONF_BASE_MASK << FAM10H_MMIO_CONF_BASE_SHIFT))) ) goto invalid; if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_MISC_ENABLE: rdmsrl(reg, temp); if ( val != guest_misc_enable(temp) ) goto invalid; return X86EMUL_OKAY; case MSR_IA32_MPERF: case MSR_IA32_APERF: if ( !(boot_cpu_data.x86_vendor & (X86_VENDOR_INTEL | X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_PERF_CTL: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_THERM_CONTROL: case MSR_IA32_ENERGY_PERF_BIAS: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( !is_hwdom_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_P6_PERFCTR(0) ... MSR_P6_PERFCTR(7): case MSR_P6_EVNTSEL(0) ... MSR_P6_EVNTSEL(3): case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR2: case MSR_CORE_PERF_FIXED_CTR_CTRL ... MSR_CORE_PERF_GLOBAL_OVF_CTRL: if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL ) { vpmu_msr = true; case MSR_AMD_FAM15H_EVNTSEL0 ... MSR_AMD_FAM15H_PERFCTR5: case MSR_K7_EVNTSEL0 ... MSR_K7_PERFCTR3: if ( vpmu_msr || (boot_cpu_data.x86_vendor & (X86_VENDOR_AMD | X86_VENDOR_HYGON)) ) { if ( (vpmu_mode & XENPMU_MODE_ALL) && !is_hardware_domain(currd) ) return X86EMUL_OKAY; if ( vpmu_do_wrmsr(reg, val, 0) ) break; return X86EMUL_OKAY; } } default: gdprintk(XENLOG_WARNING, ""WRMSR 0x%08x val 0x%016""PRIx64"" unimplemented\n"", reg, val); break; invalid: gdprintk(XENLOG_WARNING, ""Domain attempted WRMSR 0x%08x from 0x%016""PRIx64"" to 0x%016""PRIx64""\n"", reg, temp, val); return X86EMUL_OKAY; } return X86EMUL_UNHANDLEABLE; }"
"void Compute(OpKernelContext* ctx) override { const Tensor& indices_tensor = ctx->input(0); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(indices_tensor.shape()) || TensorShapeUtils::IsScalar(indices_tensor.shape()), errors::InvalidArgument( ""The indices can only be scalar or vector, got \"""", indices_tensor.shape().DebugString(), ""\"""")); const Tensor& dims_tensor = ctx->input(1); OP_REQUIRES( ctx, TensorShapeUtils::IsVector(dims_tensor.shape()), errors::InvalidArgument(""The indices can only be 1-D, got \"""", dims_tensor.shape().DebugString(), ""\"""")); auto dims = dims_tensor.vec<Tidx>(); Eigen::Tensor<Tidx, 0, Eigen::RowMajor> dims_prod_eigen = dims.prod(); Tidx dims_prod = dims_prod_eigen(); const Tidx* indices = indices_tensor.flat<Tidx>().data(); int64 size = indices_tensor.NumElements(); bool check = std::all_of(indices, indices + size, [&](Tidx index) { return index < dims_prod; }); OP_REQUIRES(ctx, check, errors::InvalidArgument(""index is out of bound as with dims"")); Eigen::array<bool, 1> reverse({true}); Tensor strides_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<Tidx>::value, TensorShape({dims_tensor.NumElements()}), &strides_tensor)); auto strides = strides_tensor.vec<Tidx>(); strides = dims.reverse(reverse) .scan(0, Eigen::internal::ProdReducer<Tidx>(), false) .reverse(reverse); Tensor strides_shifted_tensor; OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<Tidx>::value, TensorShape({dims_tensor.NumElements()}), &strides_shifted_tensor)); auto strides_shifted = strides_shifted_tensor.vec<Tidx>(); strides_shifted = dims.reverse(reverse) .scan(0, Eigen::internal::ProdReducer<Tidx>(), true) .reverse(reverse); Tensor* output_tensor = nullptr; if (TensorShapeUtils::IsScalar(indices_tensor.shape())) { OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements()}), &output_tensor)); auto output = output_tensor->vec<Tidx>(); output = output.constant(indices_tensor.scalar<Tidx>()()); output = output.binaryExpr(strides, mod_op<Tidx>()) / strides_shifted; } else { OP_REQUIRES_OK( ctx, ctx->allocate_output(0, TensorShape({dims_tensor.NumElements(), indices_tensor.NumElements()}), &output_tensor)); auto output = output_tensor->matrix<Tidx>(); Eigen::array<Eigen::Index, 2> reshape{ {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}}; Eigen::array<Eigen::Index, 2> bcast( {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}); Eigen::array<Eigen::Index, 2> indices_reshape{ {1, static_cast<Eigen::Index>(indices_tensor.NumElements())}}; Eigen::array<Eigen::Index, 2> indices_bcast( {static_cast<Eigen::Index>(dims_tensor.NumElements()), 1}); output = indices_tensor.vec<Tidx>() .reshape(indices_reshape) .broadcast(indices_bcast); output = output.binaryExpr(strides.reshape(reshape).broadcast(bcast), mod_op<Tidx>()) / strides_shifted.reshape(reshape).broadcast(bcast); } }"
"static BOOL GetStartupData(HANDLE pipe, STARTUP_DATA *sud) { size_t size, len; BOOL ret = FALSE; WCHAR *data = NULL; DWORD bytes, read; bytes = PeekNamedPipeAsync(pipe, 1, &exit_event); if (bytes == 0) { MsgToEventLog(M_SYSERR, TEXT(""PeekNamedPipeAsync failed"")); ReturnLastError(pipe, L""PeekNamedPipeAsync""); goto out; } size = bytes / sizeof(*data); if (size == 0) { MsgToEventLog(M_SYSERR, TEXT(""malformed startup data: 1 byte received"")); ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event); goto out; } data = malloc(bytes); if (data == NULL) { MsgToEventLog(M_SYSERR, TEXT(""malloc failed"")); ReturnLastError(pipe, L""malloc""); goto out; } read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event); if (bytes != read) { MsgToEventLog(M_SYSERR, TEXT(""ReadPipeAsync failed"")); ReturnLastError(pipe, L""ReadPipeAsync""); goto out; } if (data[size - 1] != 0) { MsgToEventLog(M_ERR, TEXT(""Startup data is not NULL terminated"")); ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event); goto out; } sud->directory = data; len = wcslen(sud->directory) + 1; size -= len; if (size <= 0) { MsgToEventLog(M_ERR, TEXT(""Startup data ends at working directory"")); ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event); goto out; } sud->options = sud->directory + len; len = wcslen(sud->options) + 1; size -= len; if (size <= 0) { MsgToEventLog(M_ERR, TEXT(""Startup data ends at command line options"")); ReturnError(pipe, ERROR_STARTUP_DATA, L""GetStartupData"", 1, &exit_event); goto out; } sud->std_input = sud->options + len; data = NULL;  ret = TRUE; out: free(data); return ret; }"
"static int llcp_sock_connect(struct socket *sock, struct sockaddr *_addr, int len, int flags) { struct sock *sk = sock->sk; struct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk); struct sockaddr_nfc_llcp *addr = (struct sockaddr_nfc_llcp *)_addr; struct nfc_dev *dev; struct nfc_llcp_local *local; int ret = 0; pr_debug(""sock %p sk %p flags 0x%x\n"", sock, sk, flags); if (!addr || len < sizeof(*addr) || addr->sa_family != AF_NFC) return -EINVAL; if (addr->service_name_len == 0 && addr->dsap == 0) return -EINVAL; pr_debug(""addr dev_idx=%u target_idx=%u protocol=%u\n"", addr->dev_idx, addr->target_idx, addr->nfc_protocol); lock_sock(sk); if (sk->sk_state == LLCP_CONNECTED) { ret = -EISCONN; goto error; } if (sk->sk_state == LLCP_CONNECTING) { ret = -EINPROGRESS; goto error; } dev = nfc_get_device(addr->dev_idx); if (dev == NULL) { ret = -ENODEV; goto error; } local = nfc_llcp_find_local(dev); if (local == NULL) { ret = -ENODEV; goto put_dev; } device_lock(&dev->dev); if (dev->dep_link_up == false) { ret = -ENOLINK; device_unlock(&dev->dev); goto put_dev; } device_unlock(&dev->dev); if (local->rf_mode == NFC_RF_INITIATOR && addr->target_idx != local->target_idx) { ret = -ENOLINK; goto put_dev; } llcp_sock->dev = dev; llcp_sock->local = nfc_llcp_local_get(local); llcp_sock->ssap = nfc_llcp_get_local_ssap(local); if (llcp_sock->ssap == LLCP_SAP_MAX) { ret = -ENOMEM; goto sock_llcp_put_local; } llcp_sock->reserved_ssap = llcp_sock->ssap; if (addr->service_name_len == 0) llcp_sock->dsap = addr->dsap; else llcp_sock->dsap = LLCP_SAP_SDP; llcp_sock->nfc_protocol = addr->nfc_protocol; llcp_sock->service_name_len = min_t(unsigned int, addr->service_name_len, NFC_LLCP_MAX_SERVICE_NAME); llcp_sock->service_name = kmemdup(addr->service_name, llcp_sock->service_name_len, GFP_KERNEL); if (!llcp_sock->service_name) { ret = -ENOMEM; goto sock_llcp_release; } nfc_llcp_sock_link(&local->connecting_sockets, sk); ret = nfc_llcp_send_connect(llcp_sock); if (ret) goto sock_unlink; sk->sk_state = LLCP_CONNECTING; ret = sock_wait_state(sk, LLCP_CONNECTED, sock_sndtimeo(sk, flags & O_NONBLOCK)); if (ret && ret != -EINPROGRESS) goto sock_unlink; release_sock(sk); return ret; sock_unlink: nfc_llcp_sock_unlink(&local->connecting_sockets, sk); kfree(llcp_sock->service_name); llcp_sock->service_name = NULL; sock_llcp_release: nfc_llcp_put_ssap(local, llcp_sock->ssap); sock_llcp_put_local: nfc_llcp_local_put(llcp_sock->local); llcp_sock->local = NULL; llcp_sock->dev = NULL; put_dev: nfc_put_device(dev); error: release_sock(sk); return ret; }"
"static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size, int uncompressed_size, EXRThreadData *td) { int64_t version, lo_usize, lo_size; int64_t ac_size, dc_size, rle_usize, rle_csize, rle_raw_size; int64_t ac_count, dc_count, ac_compression; const int dc_w = td->xsize >> 3; const int dc_h = td->ysize >> 3; GetByteContext gb, agb; int skip, ret; if (compressed_size <= 88) return AVERROR_INVALIDDATA; version = AV_RL64(src + 0); if (version != 2) return AVERROR_INVALIDDATA; lo_usize = AV_RL64(src + 8); lo_size = AV_RL64(src + 16); ac_size = AV_RL64(src + 24); dc_size = AV_RL64(src + 32); rle_csize = AV_RL64(src + 40); rle_usize = AV_RL64(src + 48); rle_raw_size = AV_RL64(src + 56); ac_count = AV_RL64(src + 64); dc_count = AV_RL64(src + 72); ac_compression = AV_RL64(src + 80); if (compressed_size < 88LL + lo_size + ac_size + dc_size + rle_csize) return AVERROR_INVALIDDATA; bytestream2_init(&gb, src + 88, compressed_size - 88); skip = bytestream2_get_le16(&gb); if (skip < 2) return AVERROR_INVALIDDATA; bytestream2_skip(&gb, skip - 2); if (lo_size > 0) { if (lo_usize > uncompressed_size) return AVERROR_INVALIDDATA; bytestream2_skip(&gb, lo_size); } if (ac_size > 0) { unsigned long dest_len = ac_count * 2LL; GetByteContext agb = gb; if (ac_count > 3LL * td->xsize * s->scan_lines_per_block) return AVERROR_INVALIDDATA; av_fast_padded_malloc(&td->ac_data, &td->ac_size, dest_len); if (!td->ac_data) return AVERROR(ENOMEM); switch (ac_compression) { case 0: ret = huf_uncompress(s, td, &agb, (int16_t *)td->ac_data, ac_count); if (ret < 0) return ret; break; case 1: if (uncompress(td->ac_data, &dest_len, agb.buffer, ac_size) != Z_OK || dest_len != ac_count * 2LL) return AVERROR_INVALIDDATA; break; default: return AVERROR_INVALIDDATA; } bytestream2_skip(&gb, ac_size); } if (dc_size > 0) { unsigned long dest_len = dc_count * 2LL; GetByteContext agb = gb; if (dc_count > (6LL * td->xsize * td->ysize + 63) / 64) return AVERROR_INVALIDDATA; av_fast_padded_malloc(&td->dc_data, &td->dc_size, FFALIGN(dest_len, 64) * 2); if (!td->dc_data) return AVERROR(ENOMEM); if (uncompress(td->dc_data + FFALIGN(dest_len, 64), &dest_len, agb.buffer, dc_size) != Z_OK || (dest_len != dc_count * 2LL)) return AVERROR_INVALIDDATA; s->dsp.predictor(td->dc_data + FFALIGN(dest_len, 64), dest_len); s->dsp.reorder_pixels(td->dc_data, td->dc_data + FFALIGN(dest_len, 64), dest_len); bytestream2_skip(&gb, dc_size); } if (rle_raw_size > 0 && rle_csize > 0 && rle_usize > 0) { unsigned long dest_len = rle_usize; av_fast_padded_malloc(&td->rle_data, &td->rle_size, rle_usize); if (!td->rle_data) return AVERROR(ENOMEM); av_fast_padded_malloc(&td->rle_raw_data, &td->rle_raw_size, rle_raw_size); if (!td->rle_raw_data) return AVERROR(ENOMEM); if (uncompress(td->rle_data, &dest_len, gb.buffer, rle_csize) != Z_OK || (dest_len != rle_usize)) return AVERROR_INVALIDDATA; ret = rle(td->rle_raw_data, td->rle_data, rle_usize, rle_raw_size); if (ret < 0) return ret; bytestream2_skip(&gb, rle_csize); } bytestream2_init(&agb, td->ac_data, ac_count * 2); for (int y = 0; y < td->ysize; y += 8) { for (int x = 0; x < td->xsize; x += 8) { memset(td->block, 0, sizeof(td->block)); for (int j = 0; j < 3; j++) { float *block = td->block[j]; const int idx = (x >> 3) + (y >> 3) * dc_w + dc_w * dc_h * j; uint16_t *dc = (uint16_t *)td->dc_data; union av_intfloat32 dc_val; dc_val.i = half2float(dc[idx], s->mantissatable, s->exponenttable, s->offsettable); block[0] = dc_val.f; ac_uncompress(s, &agb, block); dct_inverse(block); } { const float scale = s->pixel_type == EXR_FLOAT ? 2.f : 1.f; const int o = s->nb_channels == 4; float *bo = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 0) + x; float *go = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 1) + x; float *ro = ((float *)td->uncompressed_data) + y * td->xsize * s->nb_channels + td->xsize * (o + 2) + x; float *yb = td->block[0]; float *ub = td->block[1]; float *vb = td->block[2]; for (int yy = 0; yy < 8; yy++) { for (int xx = 0; xx < 8; xx++) { const int idx = xx + yy * 8; convert(yb[idx], ub[idx], vb[idx], &bo[xx], &go[xx], &ro[xx]); bo[xx] = to_linear(bo[xx], scale); go[xx] = to_linear(go[xx], scale); ro[xx] = to_linear(ro[xx], scale); } bo += td->xsize * s->nb_channels; go += td->xsize * s->nb_channels; ro += td->xsize * s->nb_channels; } } } } if (s->nb_channels < 4) return 0; for (int y = 0; y < td->ysize && td->rle_raw_data; y++) { uint32_t *ao = ((uint32_t *)td->uncompressed_data) + y * td->xsize * s->nb_channels; uint8_t *ai0 = td->rle_raw_data + y * td->xsize; uint8_t *ai1 = td->rle_raw_data + y * td->xsize + rle_raw_size / 2; for (int x = 0; x < td->xsize; x++) { uint16_t ha = ai0[x] | (ai1[x] << 8); ao[x] = half2float(ha, s->mantissatable, s->exponenttable, s->offsettable); } } return 0; }"
"static bool bgp_attr_aigp_valid(uint8_t *pnt, int length) { uint8_t *data = pnt; uint8_t tlv_type; uint16_t tlv_length; if (length < 3) { zlog_err(""Bad AIGP attribute length (MUST be minimum 3): %u"", length); return false; } while (length) { tlv_type = *data; ptr_get_be16(data + 1, &tlv_length); (void)data; if (length < tlv_length) { zlog_err( ""Bad AIGP attribute length: %u, but TLV length: %u"", length, tlv_length); return false; } if (tlv_length < 3) { zlog_err(""Bad AIGP TLV length (MUST be minimum 3): %u"", tlv_length); return false; } if (tlv_type == BGP_AIGP_TLV_METRIC && tlv_length != BGP_AIGP_TLV_METRIC_LEN) { zlog_err(""Bad AIGP TLV (%s) length: %u"", BGP_AIGP_TLV_METRIC_DESC, tlv_length); return false; } data += tlv_length; length -= tlv_length; } return true; }"
"static void btif_av_event_free_data(btif_sm_event_t event, void* p_data) { switch (event) { case BTA_AV_META_MSG_EVT: { tBTA_AV* av = (tBTA_AV*)p_data; osi_free_and_reset((void**)&av->meta_msg.p_data); if (av->meta_msg.p_msg) { if (av->meta_msg.p_msg->hdr.opcode == AVRC_OP_VENDOR) { osi_free(av->meta_msg.p_msg->vendor.p_vendor_data); } osi_free_and_reset((void**)&av->meta_msg.p_msg); } } break; default: break; } }"
"DataBuf PngChunk::parseTXTChunk(const DataBuf& data, int            keysize, TxtChunkType   type) { DataBuf arr; if(type == zTXt_Chunk) { const byte* compressionMethod = data.pData_ + keysize + 1; if ( *compressionMethod != 0x00 ) { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::parseTXTChunk: Non-standard zTXt compression method.\n""; #endif throw Error(kerFailedToReadImageData); } const byte* compressedText      = data.pData_ + keysize + 2; unsigned int compressedTextSize = data.size_  - keysize - 2; zlibUncompress(compressedText, compressedTextSize, arr); } else if(type == tEXt_Chunk) { const byte* text = data.pData_ + keysize + 1; long textsize    = data.size_  - keysize - 1; arr = DataBuf(text, textsize); } else if(type == iTXt_Chunk) { const int nullSeparators = std::count(&data.pData_[keysize+3], &data.pData_[data.size_], '\0'); enforce(nullSeparators >= 2, Exiv2::kerCorruptedMetadata); const byte compressionFlag   = data.pData_[keysize + 1]; const byte compressionMethod = data.pData_[keysize + 2]; enforce(compressionFlag == 0x00 || compressionFlag == 0x01, Exiv2::kerCorruptedMetadata); enforce(compressionMethod == 0x00, Exiv2::kerCorruptedMetadata); std::string languageText((const char*)(data.pData_ + keysize + 3)); unsigned int languageTextSize = static_cast<unsigned int>(languageText.size()); std::string translatedKeyText((const char*)(data.pData_ + keysize + 3 + languageTextSize +1)); unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size()); if ( compressionFlag == 0x00 ) { #ifdef DEBUG std::cout << ""Exiv2::PngChunk::parseTXTChunk: We found an uncompressed iTXt field\n""; #endif const byte* text = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1; long textsize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1); arr.alloc(textsize); arr = DataBuf(text, textsize); } else if ( compressionFlag == 0x01 && compressionMethod == 0x00 ) { #ifdef DEBUG std::cout << ""Exiv2::PngChunk::parseTXTChunk: We found a zlib compressed iTXt field\n""; #endif const byte* compressedText = data.pData_ + keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1; long compressedTextSize    = data.size_ - (keysize + 3 + languageTextSize + 1 + translatedKeyTextSize + 1); zlibUncompress(compressedText, compressedTextSize, arr); } else { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::parseTXTChunk: Non-standard iTXt compression method.\n""; #endif throw Error(kerFailedToReadImageData); } } else { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::parseTXTChunk: We found a field, not expected though\n""; #endif throw Error(kerFailedToReadImageData); } return arr; }"
"static gboolean dissect_cbor_byte_string(tvbuff_t *tvb, packet_info *pinfo, proto_tree *cbor_tree, gint *offset, guint8 type_minor) { guint64  length; gint     eof_type; proto_tree *subtree; proto_item *item; item = proto_tree_add_item(cbor_tree, hf_cbor_item_byte_string, tvb, *offset, -1, ENC_NA); subtree = proto_item_add_subtree(item, ett_cbor_byte_string); proto_tree_add_item(subtree, hf_cbor_item_major_type, tvb, *offset, 1, ENC_BIG_ENDIAN); if (type_minor <= 0x17) { proto_tree_add_item(subtree, hf_cbor_item_length5, tvb, *offset, 1, ENC_BIG_ENDIAN); length = type_minor; } else { proto_tree_add_item(subtree, hf_cbor_item_length_size, tvb, *offset, 1, ENC_BIG_ENDIAN); } *offset += 1; switch (type_minor) { case 0x18: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 1, ENC_BIG_ENDIAN, &length); *offset += 1; break; case 0x19: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 2, ENC_BIG_ENDIAN, &length); *offset += 2; break; case 0x1a: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 4, ENC_BIG_ENDIAN, &length); *offset += 4; break; case 0x1b: proto_tree_add_item_ret_uint64(subtree, hf_cbor_item_length, tvb, *offset, 8, ENC_BIG_ENDIAN, &length); *offset += 8; break; case 0x1f: proto_item_append_text(item, "": (indefinite length)""); item = proto_tree_add_item(subtree, hf_cbor_type_byte_string_indef, tvb, *offset, 1, ENC_NA); subtree = proto_item_add_subtree(item, ett_cbor_byte_string_indef); while (1) { eof_type = tvb_get_guint8(tvb, *offset); if (eof_type == 0xff) { dissect_cbor_float_simple_data(tvb, pinfo, subtree, offset, 0x1f); proto_item_set_end(item, tvb, *offset); return TRUE; } if (((eof_type & 0xe0) >> 5) != CBOR_TYPE_BYTE_STRING) { expert_add_info_format(pinfo, subtree, &ei_cbor_invalid_element, ""invalid element %i, expected byte string"", (eof_type & 0xe0) >> 5); return FALSE; } if (!dissect_cbor_byte_string(tvb, pinfo, subtree, offset, eof_type & 0x1f)) { return FALSE; } } DISSECTOR_ASSERT_NOT_REACHED(); return FALSE; default: if (type_minor > 0x17) { expert_add_info_format(pinfo, subtree, &ei_cbor_invalid_minor_type, ""invalid minor type %i in byte string"", type_minor); return FALSE; } break; } if (length > G_MAXINT32 || *offset + (gint)length < *offset) { expert_add_info_format(pinfo, subtree, &ei_cbor_too_long_length, ""the length (%"" PRIu64 "") of the byte string too long"", length); return FALSE; } proto_tree_add_item(subtree, hf_cbor_type_byte_string, tvb, *offset, (gint)length, ENC_BIG_ENDIAN|ENC_NA); *offset += (gint)length; proto_item_append_text(item, "": (%"" PRIu64 "" byte%s)"", length, plurality(length, """", ""s"")); proto_item_set_end(item, tvb, *offset); return TRUE; }"
"static void lo_release(struct gendisk *disk, fmode_t mode) { struct loop_device *lo = disk->private_data; int err; if (atomic_dec_return(&lo->lo_refcnt)) return; mutex_lock(&lo->lo_ctl_mutex); if (lo->lo_flags & LO_FLAGS_AUTOCLEAR) { err = loop_clr_fd(lo); if (!err) return; } else if (lo->lo_state == Lo_bound) { blk_mq_freeze_queue(lo->lo_queue); blk_mq_unfreeze_queue(lo->lo_queue); } mutex_unlock(&lo->lo_ctl_mutex); }"
"void normal_cmd( oparg_T*oap, inttoplevel UNUSED){ cmdarg_Tca;    intc; intctrl_w = FALSE;    intold_col = curwin->w_curswant; intneed_flushbuf = FALSE;    pos_Told_pos;    intmapped_len; static intold_mapped_len = 0; intidx; intset_prevcount = FALSE; intsave_did_cursorhold = did_cursorhold; CLEAR_FIELD(ca);    ca.oap = oap; ca.opcount = opcount; #ifdef CURSOR_SHAPE c = finish_op; #endif finish_op = (oap->op_type != OP_NOP); #ifdef CURSOR_SHAPE if (finish_op != c) { ui_cursor_shape();# ifdef FEAT_MOUSESHAPE update_mouseshape(-1); # endif } #endif may_trigger_modechanged(); if (!finish_op && !oap->regname) { ca.opcount = 0; #ifdef FEAT_EVAL set_prevcount = TRUE; #endif } if (oap->prev_opcount > 0 || oap->prev_count0 > 0) { ca.opcount = oap->prev_opcount; ca.count0 = oap->prev_count0; oap->prev_opcount = 0; oap->prev_count0 = 0; } mapped_len = typebuf_maplen(); State = MODE_NORMAL_BUSY; #ifdef USE_ON_FLY_SCROLL dont_scroll = FALSE;#endif #ifdef FEAT_EVAL if (toplevel && readbuf1_empty()) set_vcount_ca(&ca, &set_prevcount); #endif c = safe_vgetc(); LANGMAP_ADJUST(c, get_real_state() != MODE_SELECT); if (restart_edit == 0) old_mapped_len = 0; else if (old_mapped_len || (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0)) old_mapped_len = typebuf_maplen(); if (c == NUL) c = K_ZERO; if (VIsual_active && VIsual_select && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER)) { int len; len = ins_char_typebuf(vgetc_char, vgetc_mod_mask); if (KeyTyped) ungetchars(len); if (restart_edit != 0) c = 'd'; else c = 'c'; msg_nowait = TRUE;old_mapped_len = 0;    } if (KeyTyped && !KeyStuffed) win_ensure_size(); #ifdef FEAT_CMDL_INFO need_flushbuf = add_to_showcmd(c); #endif c = normal_cmd_get_count(&ca, c, toplevel, set_prevcount, &ctrl_w, &need_flushbuf); if (ctrl_w) { ca.nchar = c; ca.cmdchar = Ctrl_W; } else ca.cmdchar = c; idx = find_command(ca.cmdchar); if (idx < 0) { clearopbeep(oap); goto normal_end; } if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW)) { clearopbeep(oap); text_locked_msg(); goto normal_end; } if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked()) goto normal_end; if (VIsual_active) { if (km_stopsel && (nv_cmds[idx].cmd_flags & NV_STS) && !(mod_mask & MOD_MASK_SHIFT)) { end_visual_mode(); redraw_curbuf_later(INVERTED); } if (km_startsel) { if (nv_cmds[idx].cmd_flags & NV_SS) { unshift_special(&ca); idx = find_command(ca.cmdchar); if (idx < 0) { clearopbeep(oap); goto normal_end; } } else if ((nv_cmds[idx].cmd_flags & NV_SSS) && (mod_mask & MOD_MASK_SHIFT)) mod_mask &= ~MOD_MASK_SHIFT; } } #ifdef FEAT_RIGHTLEFT if (curwin->w_p_rl && KeyTyped && !KeyStuffed && (nv_cmds[idx].cmd_flags & NV_RL)) { switch (ca.cmdchar) { case 'l':    ca.cmdchar = 'h'; break; case K_RIGHT:   ca.cmdchar = K_LEFT; break; case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break; case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break; case 'h':    ca.cmdchar = 'l'; break; case K_LEFT:    ca.cmdchar = K_RIGHT; break; case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break; case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break; case '>':    ca.cmdchar = '<'; break; case '<':    ca.cmdchar = '>'; break; } idx = find_command(ca.cmdchar); } #endif if (normal_cmd_needs_more_chars(&ca, nv_cmds[idx].cmd_flags)) idx = normal_cmd_get_more_chars(idx, &ca, &need_flushbuf); #ifdef FEAT_CMDL_INFO if (need_flushbuf) out_flush(); #endif if (ca.cmdchar != K_IGNORE) { if (ex_normal_busy) did_cursorhold = save_did_cursorhold; else did_cursorhold = FALSE; } State = MODE_NORMAL; if (ca.nchar == ESC) { clearop(oap); if (restart_edit == 0 && goto_im()) restart_edit = 'a'; goto normal_end; } if (ca.cmdchar != K_IGNORE) { msg_didout = FALSE;    msg_col = 0; } old_pos = curwin->w_cursor; if (!VIsual_active && km_startsel) { if (nv_cmds[idx].cmd_flags & NV_SS) { start_selection(); unshift_special(&ca); idx = find_command(ca.cmdchar); } else if ((nv_cmds[idx].cmd_flags & NV_SSS) && (mod_mask & MOD_MASK_SHIFT)) { start_selection(); mod_mask &= ~MOD_MASK_SHIFT; } } ca.arg = nv_cmds[idx].cmd_arg; (nv_cmds[idx].cmd_func)(&ca); if (!finish_op && !oap->op_type && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG))) { clearop(oap); #ifdef FEAT_EVAL reset_reg_var(); #endif } if (old_mapped_len > 0) old_mapped_len = typebuf_maplen(); if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE) do_pending_operator(&ca, old_col, FALSE); if (normal_cmd_need_to_wait_for_msg(&ca, &old_pos)) normal_cmd_wait_for_msg(); normal_end: msg_nowait = FALSE; #ifdef FEAT_EVAL if (finish_op) reset_reg_var(); #endif #ifdef CURSOR_SHAPE c = finish_op; #endif finish_op = FALSE; may_trigger_modechanged(); #ifdef CURSOR_SHAPE if (c || ca.cmdchar == 'r') { ui_cursor_shape();# ifdef FEAT_MOUSESHAPE update_mouseshape(-1); # endif } #endif #ifdef FEAT_CMDL_INFO if (oap->op_type == OP_NOP && oap->regname == 0 && ca.cmdchar != K_CURSORHOLD) clear_showcmd(); #endif checkpcmark();    vim_free(ca.searchbuf); if (has_mbyte) mb_adjust_cursor(); if (curwin->w_p_scb && toplevel) { validate_cursor();do_check_scrollbind(TRUE); } if (curwin->w_p_crb && toplevel) { validate_cursor();do_check_cursorbind(); } #ifdef FEAT_TERMINAL if (term_job_running(curbuf->b_term)) restart_edit = 0; #endif if (       oap->op_type == OP_NOP && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0) || restart_VIsual_select == 1) && !(ca.retval & CA_COMMAND_BUSY) && stuff_empty() && oap->regname == 0) { if (restart_VIsual_select == 1) { VIsual_select = TRUE; may_trigger_modechanged(); showmode(); restart_VIsual_select = 0; VIsual_select_reg = 0; } if (restart_edit != 0 && !VIsual_active && old_mapped_len == 0) (void)edit(restart_edit, FALSE, 1L); } if (restart_VIsual_select == 2) restart_VIsual_select = 1; opcount = ca.opcount; }"
"static Image *ReadDJVUImage(const ImageInfo *image_info, ExceptionInfo *exception) { const char *url; ddjvu_message_t *message; Image *image, *images; int logging, use_cache; LoadContext *lc; MagickBooleanType status; register ssize_t i; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); logging = LogMagickEvent(CoderEvent,GetMagickModule(),""enter ReadDJVUImage()""); (void) logging; image = AcquireImage(image_info);  lc = (LoadContext *) NULL; status = OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) ThrowReaderException(FileOpenError,""UnableToOpenFile""); #if 0 count = ReadBlob(image,8,(unsigned char *) magic_number); if (memcmp(magic_number,""AT&TFORM"",8) != 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); #endif lc = (LoadContext *) AcquireMagickMemory(sizeof(*lc)); if (lc == NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) ResetMagickMemory(lc,0,sizeof(LoadContext)); lc->image = image; lc->pages = 0; lc->context = ddjvu_context_create(""ImageMagick djvu loader"");  ddjvu_cache_set_size(lc->context, 1);  use_cache = 0; url=""http:  lc->document = ddjvu_document_create(lc->context, url, use_cache);  ddjvu_document_set_user_data(lc->document, lc); message = ddjvu_message_wait(lc->context); if (message->m_any.tag != DDJVU_NEWSTREAM) { ddjvu_document_release(lc->document); ddjvu_context_release(lc->context); RelinquishMagickMemory(lc); ThrowReaderException(ResourceLimitError,""Djvu initial message: unexpected type""); return NULL;     }; lc->streamid = message->m_newstream.streamid; ddjvu_message_pop(lc->context); message = pump_data_until_message(lc,image); if (message) do { process_message(message); ddjvu_message_pop(lc->context); } while ((message = ddjvu_message_peek(lc->context))); while (lc->pages == 0) { message = ddjvu_message_wait(lc->context); process_message(message); ddjvu_message_pop(lc->context); } images=NewImageList(); i=0; if (image_info->number_scenes != 0) i=image_info->scene; for ( ; i < (ssize_t) lc->pages; i++) { image=ReadOneDJVUImage(lc,i,image_info,exception); if (image == (Image *) NULL) break; image->scene=i; AppendImageToList(&images,CloneImageList(image,exception)); images->extent=GetBlobSize(image); if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; } djvu_close_lc(lc); (void) CloseBlob(images); if (image != (Image *) NULL) image=DestroyImageList(image); #if 0 if ((image->page.width == 0) && (image->page.height == 0)) { image->page.width = image->columns+image->page.x; image->page.height = image->rows+image->page.y; } if (image->columns == 0 || image->rows == 0) { if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""exit ReadDJVUImage() with error.""); ThrowReaderException(CorruptImageError,""CorruptImage""); } if (logging != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(),""exit ReadDJVUImage()""); #endif return(GetFirstImageInList(images)); }"
"auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> { auto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false); return std::make_unique<ReferenceHandle>(value, inherit); }"
"static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) return AVERROR_INVALIDDATA; s->avctx->profile = bytestream2_get_be16u(&s->g);     s->width          = bytestream2_get_be32u(&s->g);     s->height         = bytestream2_get_be32u(&s->g);     s->image_offset_x = bytestream2_get_be32u(&s->g);     s->image_offset_y = bytestream2_get_be32u(&s->g);     s->tile_width     = bytestream2_get_be32u(&s->g);     s->tile_height    = bytestream2_get_be32u(&s->g);     s->tile_offset_x  = bytestream2_get_be32u(&s->g);     s->tile_offset_y  = bytestream2_get_be32u(&s->g);     ncomponents       = bytestream2_get_be16u(&s->g);  if (s->image_offset_x || s->image_offset_y) { avpriv_request_sample(s->avctx, ""Support for image offsets""); return AVERROR_PATCHWELCOME; } if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid number of components: %d\n"", s->ncomponents); return AVERROR_INVALIDDATA; } if (ncomponents > 4) { avpriv_request_sample(s->avctx, ""Support for %d components"", s->ncomponents); return AVERROR_PATCHWELCOME; } s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid tile dimension %dx%d.\n"", s->tile_width, s->tile_height); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) return AVERROR_INVALIDDATA; for (i = 0; i < s->ncomponents; i++) {         uint8_t x    = bytestream2_get_byteu(&s->g); s->cbps[i]   = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i]   = !!(x & 0x80); s->cdx[i]    = bytestream2_get_byteu(&s->g); s->cdy[i]    = bytestream2_get_byteu(&s->g); if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid sample separation %d/%d\n"", s->cdx[i], s->cdy[i]); return AVERROR_INVALIDDATA; } log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; } s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); } s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); } for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); } s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; } } for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; } } if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) { av_log(s->avctx, AV_LOG_ERROR, ""Unknown pix_fmt, profile: %d, colour_space: %d, "" ""components: %d, precision: %d, "" ""cdx[1]: %d, cdy[1]: %d, cdx[2]: %d, cdy[2]: %d\n"", s->avctx->profile, s->colour_space, ncomponents, s->precision, ncomponents > 2 ? s->cdx[1] : 0, ncomponents > 2 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0); } s->avctx->bits_per_raw_sample = s->precision; return 0; }"
"void pgm_print(netdissect_options *ndo, register const u_char *bp, register u_int length, register const u_char *bp2) { register const struct pgm_header *pgm; register const struct ip *ip; register char ch; uint16_t sport, dport; u_int nla_afnum; char nla_buf[INET6_ADDRSTRLEN]; register const struct ip6_hdr *ip6; uint8_t opt_type, opt_len; uint32_t seq, opts_len, len, offset; pgm = (const struct pgm_header *)bp; ip = (const struct ip *)bp2; if (IP_V(ip) == 6) ip6 = (const struct ip6_hdr *)bp2; else ip6 = NULL; ch = '\0'; if (!ND_TTEST(pgm->pgm_dport)) { if (ip6) { ND_PRINT((ndo, ""%s > %s: [|pgm]"", ip6addr_string(ndo, &ip6->ip6_src), ip6addr_string(ndo, &ip6->ip6_dst))); return; } else { ND_PRINT((ndo, ""%s > %s: [|pgm]"", ipaddr_string(ndo, &ip->ip_src), ipaddr_string(ndo, &ip->ip_dst))); return; } } sport = EXTRACT_16BITS(&pgm->pgm_sport); dport = EXTRACT_16BITS(&pgm->pgm_dport); if (ip6) { if (ip6->ip6_nxt == IPPROTO_PGM) { ND_PRINT((ndo, ""%s.%s > %s.%s: "", ip6addr_string(ndo, &ip6->ip6_src), tcpport_string(ndo, sport), ip6addr_string(ndo, &ip6->ip6_dst), tcpport_string(ndo, dport))); } else { ND_PRINT((ndo, ""%s > %s: "", tcpport_string(ndo, sport), tcpport_string(ndo, dport))); } } else { if (ip->ip_p == IPPROTO_PGM) { ND_PRINT((ndo, ""%s.%s > %s.%s: "", ipaddr_string(ndo, &ip->ip_src), tcpport_string(ndo, sport), ipaddr_string(ndo, &ip->ip_dst), tcpport_string(ndo, dport))); } else { ND_PRINT((ndo, ""%s > %s: "", tcpport_string(ndo, sport), tcpport_string(ndo, dport))); } } ND_TCHECK(*pgm); ND_PRINT((ndo, ""PGM, length %u"", EXTRACT_16BITS(&pgm->pgm_length))); if (!ndo->ndo_vflag) return; ND_PRINT((ndo, "" 0x%02x%02x%02x%02x%02x%02x "", pgm->pgm_gsid[0], pgm->pgm_gsid[1], pgm->pgm_gsid[2], pgm->pgm_gsid[3], pgm->pgm_gsid[4], pgm->pgm_gsid[5])); switch (pgm->pgm_type) { case PGM_SPM: { const struct pgm_spm *spm; spm = (const struct pgm_spm *)(pgm + 1); ND_TCHECK(*spm); bp = (const u_char *) (spm + 1); switch (EXTRACT_16BITS(&spm->pgms_nla_afi)) { case AFNUM_INET: ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in_addr); break; case AFNUM_INET6: ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in6_addr); break; default: goto trunc; break; } ND_PRINT((ndo, ""SPM seq %u trail %u lead %u nla %s"", EXTRACT_32BITS(&spm->pgms_seq), EXTRACT_32BITS(&spm->pgms_trailseq), EXTRACT_32BITS(&spm->pgms_leadseq), nla_buf)); break; } case PGM_POLL: { const struct pgm_poll *poll_msg; poll_msg = (const struct pgm_poll *)(pgm + 1); ND_TCHECK(*poll_msg); ND_PRINT((ndo, ""POLL seq %u round %u"", EXTRACT_32BITS(&poll_msg->pgmp_seq), EXTRACT_16BITS(&poll_msg->pgmp_round))); bp = (const u_char *) (poll_msg + 1); break; } case PGM_POLR: { const struct pgm_polr *polr; uint32_t ivl, rnd, mask; polr = (const struct pgm_polr *)(pgm + 1); ND_TCHECK(*polr); bp = (const u_char *) (polr + 1); switch (EXTRACT_16BITS(&polr->pgmp_nla_afi)) { case AFNUM_INET: ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in_addr); break; case AFNUM_INET6: ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in6_addr); break; default: goto trunc; break; } ND_TCHECK2(*bp, sizeof(uint32_t)); ivl = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_TCHECK2(*bp, sizeof(uint32_t)); rnd = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_TCHECK2(*bp, sizeof(uint32_t)); mask = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, ""POLR seq %u round %u nla %s ivl %u rnd 0x%08x "" ""mask 0x%08x"", EXTRACT_32BITS(&polr->pgmp_seq), EXTRACT_16BITS(&polr->pgmp_round), nla_buf, ivl, rnd, mask)); break; } case PGM_ODATA: { const struct pgm_data *odata; odata = (const struct pgm_data *)(pgm + 1); ND_TCHECK(*odata); ND_PRINT((ndo, ""ODATA trail %u seq %u"", EXTRACT_32BITS(&odata->pgmd_trailseq), EXTRACT_32BITS(&odata->pgmd_seq))); bp = (const u_char *) (odata + 1); break; } case PGM_RDATA: { const struct pgm_data *rdata; rdata = (const struct pgm_data *)(pgm + 1); ND_TCHECK(*rdata); ND_PRINT((ndo, ""RDATA trail %u seq %u"", EXTRACT_32BITS(&rdata->pgmd_trailseq), EXTRACT_32BITS(&rdata->pgmd_seq))); bp = (const u_char *) (rdata + 1); break; } case PGM_NAK: case PGM_NULLNAK: case PGM_NCF: { const struct pgm_nak *nak; char source_buf[INET6_ADDRSTRLEN], group_buf[INET6_ADDRSTRLEN]; nak = (const struct pgm_nak *)(pgm + 1); ND_TCHECK(*nak); bp = (const u_char *) (nak + 1); switch (EXTRACT_16BITS(&nak->pgmn_source_afi)) { case AFNUM_INET: ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, source_buf, sizeof(source_buf)); bp += sizeof(struct in_addr); break; case AFNUM_INET6: ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, source_buf, sizeof(source_buf)); bp += sizeof(struct in6_addr); break; default: goto trunc; break; } bp += (2 * sizeof(uint16_t)); switch (EXTRACT_16BITS(bp)) { case AFNUM_INET: ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, group_buf, sizeof(group_buf)); bp += sizeof(struct in_addr); break; case AFNUM_INET6: ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, group_buf, sizeof(group_buf)); bp += sizeof(struct in6_addr); break; default: goto trunc; break; } switch (pgm->pgm_type) { case PGM_NAK: ND_PRINT((ndo, ""NAK "")); break; case PGM_NULLNAK: ND_PRINT((ndo, ""NNAK "")); break; case PGM_NCF: ND_PRINT((ndo, ""NCF "")); break; default: break; } ND_PRINT((ndo, ""(%s -> %s), seq %u"", source_buf, group_buf, EXTRACT_32BITS(&nak->pgmn_seq))); break; } case PGM_ACK: { const struct pgm_ack *ack; ack = (const struct pgm_ack *)(pgm + 1); ND_TCHECK(*ack); ND_PRINT((ndo, ""ACK seq %u"", EXTRACT_32BITS(&ack->pgma_rx_max_seq))); bp = (const u_char *) (ack + 1); break; } case PGM_SPMR: ND_PRINT((ndo, ""SPMR"")); break; default: ND_PRINT((ndo, ""UNKNOWN type 0x%02x"", pgm->pgm_type)); break; } if (pgm->pgm_options & PGM_OPT_BIT_PRESENT) { if (!ND_TTEST2(*bp, PGM_MIN_OPT_LEN)) { ND_PRINT((ndo, ""[|OPT]"")); return; } opt_type = *bp++; if ((opt_type & PGM_OPT_MASK) != PGM_OPT_LENGTH) { ND_PRINT((ndo, ""[First option bad, should be PGM_OPT_LENGTH, is %u]"", opt_type & PGM_OPT_MASK)); return; } opt_len = *bp++; if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != 4]"", opt_len)); return; } opts_len = EXTRACT_16BITS(bp); if (opts_len < 4) { ND_PRINT((ndo, ""[Bad total option length %u < 4]"", opts_len)); return; } bp += sizeof(uint16_t); ND_PRINT((ndo, "" OPTS LEN %d"", opts_len)); opts_len -= 4; while (opts_len) { if (opts_len < PGM_MIN_OPT_LEN) { ND_PRINT((ndo, ""[Total option length leaves no room for final option]"")); return; } opt_type = *bp++; opt_len = *bp++; if (opt_len < PGM_MIN_OPT_LEN) { ND_PRINT((ndo, ""[Bad option, length %u < %u]"", opt_len, PGM_MIN_OPT_LEN)); break; } if (opts_len < opt_len) { ND_PRINT((ndo, ""[Total option length leaves no room for final option]"")); return; } if (!ND_TTEST2(*bp, opt_len - 2)) { ND_PRINT((ndo, "" [|OPT]"")); return; } switch (opt_type & PGM_OPT_MASK) { case PGM_OPT_LENGTH: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_LENGTH option, length %u != 4]"", opt_len)); return; } ND_PRINT((ndo, "" OPTS LEN (extra?) %d"", EXTRACT_16BITS(bp))); bp += sizeof(uint16_t); opts_len -= 4; break; case PGM_OPT_FRAGMENT: if (opt_len != 16) { ND_PRINT((ndo, ""[Bad OPT_FRAGMENT option, length %u != 16]"", opt_len)); return; } bp += 2; seq = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); offset = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); len = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" FRAG seq %u off %u len %u"", seq, offset, len)); opts_len -= 16; break; case PGM_OPT_NAK_LIST: bp += 2; opt_len -= sizeof(uint32_t); ND_PRINT((ndo, "" NAK LIST"")); while (opt_len) { if (opt_len < sizeof(uint32_t)) { ND_PRINT((ndo, ""[Option length not a multiple of 4]"")); return; } ND_TCHECK2(*bp, sizeof(uint32_t)); ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(bp))); bp += sizeof(uint32_t); opt_len -= sizeof(uint32_t); opts_len -= sizeof(uint32_t); } break; case PGM_OPT_JOIN: if (opt_len != 8) { ND_PRINT((ndo, ""[Bad OPT_JOIN option, length %u != 8]"", opt_len)); return; } bp += 2; seq = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" JOIN %u"", seq)); opts_len -= 8; break; case PGM_OPT_NAK_BO_IVL: if (opt_len != 12) { ND_PRINT((ndo, ""[Bad OPT_NAK_BO_IVL option, length %u != 12]"", opt_len)); return; } bp += 2; offset = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); seq = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" BACKOFF ivl %u ivlseq %u"", offset, seq)); opts_len -= 12; break; case PGM_OPT_NAK_BO_RNG: if (opt_len != 12) { ND_PRINT((ndo, ""[Bad OPT_NAK_BO_RNG option, length %u != 12]"", opt_len)); return; } bp += 2; offset = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); seq = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" BACKOFF max %u min %u"", offset, seq)); opts_len -= 12; break; case PGM_OPT_REDIRECT: bp += 2; nla_afnum = EXTRACT_16BITS(bp); bp += (2 * sizeof(uint16_t)); switch (nla_afnum) { case AFNUM_INET: if (opt_len != 4 + sizeof(struct in_addr)) { ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != 4 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in_addr); opts_len -= 4 + sizeof(struct in_addr); break; case AFNUM_INET6: if (opt_len != 4 + sizeof(struct in6_addr)) { ND_PRINT((ndo, ""[Bad OPT_REDIRECT option, length %u != 4 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in6_addr); opts_len -= 4 + sizeof(struct in6_addr); break; default: goto trunc; break; } ND_PRINT((ndo, "" REDIRECT %s"",  nla_buf)); break; case PGM_OPT_PARITY_PRM: if (opt_len != 8) { ND_PRINT((ndo, ""[Bad OPT_PARITY_PRM option, length %u != 8]"", opt_len)); return; } bp += 2; len = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" PARITY MAXTGS %u"", len)); opts_len -= 8; break; case PGM_OPT_PARITY_GRP: if (opt_len != 8) { ND_PRINT((ndo, ""[Bad OPT_PARITY_GRP option, length %u != 8]"", opt_len)); return; } bp += 2; seq = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" PARITY GROUP %u"", seq)); opts_len -= 8; break; case PGM_OPT_CURR_TGSIZE: if (opt_len != 8) { ND_PRINT((ndo, ""[Bad OPT_CURR_TGSIZE option, length %u != 8]"", opt_len)); return; } bp += 2; len = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); ND_PRINT((ndo, "" PARITY ATGS %u"", len)); opts_len -= 8; break; case PGM_OPT_NBR_UNREACH: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_NBR_UNREACH option, length %u != 4]"", opt_len)); return; } bp += 2; ND_PRINT((ndo, "" NBR_UNREACH"")); opts_len -= 4; break; case PGM_OPT_PATH_NLA: ND_PRINT((ndo, "" PATH_NLA [%d]"", opt_len)); bp += opt_len; opts_len -= opt_len; break; case PGM_OPT_SYN: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_SYN option, length %u != 4]"", opt_len)); return; } bp += 2; ND_PRINT((ndo, "" SYN"")); opts_len -= 4; break; case PGM_OPT_FIN: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_FIN option, length %u != 4]"", opt_len)); return; } bp += 2; ND_PRINT((ndo, "" FIN"")); opts_len -= 4; break; case PGM_OPT_RST: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_RST option, length %u != 4]"", opt_len)); return; } bp += 2; ND_PRINT((ndo, "" RST"")); opts_len -= 4; break; case PGM_OPT_CR: ND_PRINT((ndo, "" CR"")); bp += opt_len; opts_len -= opt_len; break; case PGM_OPT_CRQST: if (opt_len != 4) { ND_PRINT((ndo, ""[Bad OPT_CRQST option, length %u != 4]"", opt_len)); return; } bp += 2; ND_PRINT((ndo, "" CRQST"")); opts_len -= 4; break; case PGM_OPT_PGMCC_DATA: bp += 2; offset = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); nla_afnum = EXTRACT_16BITS(bp); bp += (2 * sizeof(uint16_t)); switch (nla_afnum) { case AFNUM_INET: if (opt_len != 12 + sizeof(struct in_addr)) { ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in_addr); opts_len -= 12 + sizeof(struct in_addr); break; case AFNUM_INET6: if (opt_len != 12 + sizeof(struct in6_addr)) { ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in6_addr); opts_len -= 12 + sizeof(struct in6_addr); break; default: goto trunc; break; } ND_PRINT((ndo, "" PGMCC DATA %u %s"", offset, nla_buf)); break; case PGM_OPT_PGMCC_FEEDBACK: bp += 2; offset = EXTRACT_32BITS(bp); bp += sizeof(uint32_t); nla_afnum = EXTRACT_16BITS(bp); bp += (2 * sizeof(uint16_t)); switch (nla_afnum) { case AFNUM_INET: if (opt_len != 12 + sizeof(struct in_addr)) { ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in_addr)); addrtostr(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in_addr); opts_len -= 12 + sizeof(struct in_addr); break; case AFNUM_INET6: if (opt_len != 12 + sizeof(struct in6_addr)) { ND_PRINT((ndo, ""[Bad OPT_PGMCC_DATA option, length %u != 12 + address size]"", opt_len)); return; } ND_TCHECK2(*bp, sizeof(struct in6_addr)); addrtostr6(bp, nla_buf, sizeof(nla_buf)); bp += sizeof(struct in6_addr); opts_len -= 12 + sizeof(struct in6_addr); break; default: goto trunc; break; } ND_PRINT((ndo, "" PGMCC FEEDBACK %u %s"", offset, nla_buf)); break; default: ND_PRINT((ndo, "" OPT_%02X [%d] "", opt_type, opt_len)); bp += opt_len; opts_len -= opt_len; break; } if (opt_type & PGM_OPT_END) break; } } ND_PRINT((ndo, "" [%u]"", length)); if (ndo->ndo_packettype == PT_PGM_ZMTP1 && (pgm->pgm_type == PGM_ODATA || pgm->pgm_type == PGM_RDATA)) zmtp1_print_datagram(ndo, bp, EXTRACT_16BITS(&pgm->pgm_length)); return; trunc: ND_PRINT((ndo, ""[|pgm]"")); if (ch != '\0') ND_PRINT((ndo, "">"")); }"
"static void io_req_drop_files(struct io_kiocb *req) { struct io_ring_ctx *ctx = req->ctx; unsigned long flags; spin_lock_irqsave(&ctx->inflight_lock, flags); list_del(&req->inflight_entry); if (waitqueue_active(&ctx->inflight_wait)) wake_up(&ctx->inflight_wait); spin_unlock_irqrestore(&ctx->inflight_lock, flags); req->flags &= ~REQ_F_INFLIGHT; req->work.files = NULL; }"
"static int php_stream_temp_set_option(php_stream *stream, int option, int value, void *ptrparam TSRMLS_DC)  { php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract; switch(option) { case PHP_STREAM_OPTION_META_DATA_API: if (ts->meta) { zend_hash_copy(Z_ARRVAL_P((zval*)ptrparam), Z_ARRVAL_P(ts->meta), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval*)); } return PHP_STREAM_OPTION_RETURN_OK; default: if (ts->innerstream) { return php_stream_set_option(ts->innerstream, option, value, ptrparam); } return PHP_STREAM_OPTION_RETURN_NOTIMPL; } }"
static int packet_get_(struct buf *b) { if (packet.flagkeys) { return sshcrypto_packet_get(b); } else { return packet_get_plain_(b); } }
"static ssize_t environ_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) { char *page; unsigned long src = *ppos; int ret = 0; struct mm_struct *mm = file->private_data; unsigned long env_start, env_end; if (!mm || !mm->env_end) return 0; page = (char *)__get_free_page(GFP_KERNEL); if (!page) return -ENOMEM; ret = 0; if (!mmget_not_zero(mm)) goto free; down_read(&mm->mmap_sem); env_start = mm->env_start; env_end = mm->env_end; up_read(&mm->mmap_sem); while (count > 0) { size_t this_len, max_len; int retval; if (src >= (env_end - env_start)) break; this_len = env_end - (env_start + src); max_len = min_t(size_t, PAGE_SIZE, count); this_len = min(max_len, this_len); retval = access_remote_vm(mm, (env_start + src), page, this_len, 0); if (retval <= 0) { ret = retval; break; } if (copy_to_user(buf, page, retval)) { ret = -EFAULT; break; } ret += retval; src += retval; buf += retval; count -= retval; } *ppos = src; mmput(mm); free: free_page((unsigned long) page); return ret; }"
"void Image::printIFDStructure(BasicIo& io, std::ostream& out, Exiv2::PrintStructureOption option,uint32_t start,bool bSwap,char c,int depth) { depth++; if ( depth == 1 ) visits.clear(); bool bFirst  = true  ; const size_t dirSize = 32; DataBuf  dir(dirSize); bool bPrint = option == kpsBasic || option == kpsRecursive; do { const int seekSuccess = !io.seek(start,BasicIo::beg); const long bytesRead = io.read(dir.pData_, 2); if (!seekSuccess || bytesRead == 0) { throw Error(kerCorruptedMetadata); } uint16_t   dirLength = byteSwap2(dir,0,bSwap); bool tooBig = dirLength > 500; if ( tooBig ) throw Error(kerTiffDirectoryTooLarge); if ( bFirst && bPrint ) { out << Internal::indent(depth) << Internal::stringFormat(""STRUCTURE OF TIFF FILE (%c%c): "",c,c) << io.path() << std::endl; if ( tooBig ) out << Internal::indent(depth) << ""dirLength = "" << dirLength << std::endl; } for ( int i = 0 ; i < dirLength ; i ++ ) { if ( visits.find(io.tell()) != visits.end()  ) {                     throw Error(kerCorruptedMetadata); } visits.insert(io.tell()); if ( bFirst && bPrint ) { out << Internal::indent(depth) << "" address |    tag                              |     "" << "" type |    count |    offset | value\n""; } bFirst = false; io.read(dir.pData_, 12); uint16_t tag    = byteSwap2(dir,0,bSwap); uint16_t type   = byteSwap2(dir,2,bSwap); uint32_t count  = byteSwap4(dir,4,bSwap); uint32_t offset = byteSwap4(dir,8,bSwap); if ( !typeValid(type) ) { std::cerr << ""invalid type in tiff structure"" << type << std::endl; start = 0;                     throw Error(kerInvalidTypeValue); } std::string sp  = """" ;  uint32_t kount  = isPrintXMP(tag,option) ? count                                 : isPrintICC(tag,option) ? count                                 : isStringType(type)     ? (count > 32 ? 32 : count)                                 : count > 5              ? 5 : count ; uint32_t pad    = isStringType(type) ? 1 : 0; uint32_t size   = isStringType(type) ? 1 : is2ByteType(type)  ? 2 : is4ByteType(type)  ? 4 : is8ByteType(type)  ? 8 : 1 ; long long allocate = (long long) size*count + pad+20; if ( allocate > (long long) io.size() ) { throw Error(kerInvalidMalloc); } DataBuf  buf((long)allocate);                  std::memset(buf.pData_, 0, buf.size_); std::memcpy(buf.pData_,dir.pData_+8,4);                  const bool bOffsetIsPointer = count*size > 4; if ( bOffsetIsPointer ) {                             size_t   restore = io.tell();                      io.seek(offset,BasicIo::beg);                      io.read(buf.pData_,count*size);                    io.seek(restore,BasicIo::beg);                 } if ( bPrint ) { const uint32_t address = start + 2 + i*12 ; const std::string offsetString = bOffsetIsPointer? Internal::stringFormat(""%10u"", offset): """"; out << Internal::indent(depth) << Internal::stringFormat(""%8u | %#06x %-28s |%10s |%9u |%10s | "" ,address,tag,tagName(tag).c_str(),typeName(type),count,offsetString.c_str()); if ( isShortType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap2(buf,k*size,bSwap); sp = "" ""; } } else if ( isLongType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { out << sp << byteSwap4(buf,k*size,bSwap); sp = "" ""; } } else if ( isRationalType(type) ){ for ( size_t k = 0 ; k < kount ; k++ ) { uint32_t a = byteSwap4(buf,k*size+0,bSwap); uint32_t b = byteSwap4(buf,k*size+4,bSwap); out << sp << a << ""/"" << b; sp = "" ""; } } else if ( isStringType(type) ) { out << sp << Internal::binaryToString(makeSlice(buf, 0, kount)); } sp = kount == count ? """" : "" ...""; out << sp << std::endl; if ( option == kpsRecursive && (tag == 0x8769  || tag == 0x014a  || type == tiffIfd) ) { for ( size_t k = 0 ; k < count ; k++ ) { size_t   restore = io.tell(); uint32_t offset = byteSwap4(buf,k*size,bSwap); printIFDStructure(io,out,option,offset,bSwap,c,depth); io.seek(restore,BasicIo::beg); } } else if ( option == kpsRecursive && tag == 0x83bb  ) { if (static_cast<size_t>(Safe::add(count, offset)) > io.size()) { throw Error(kerCorruptedMetadata); } const size_t restore = io.tell(); io.seek(offset, BasicIo::beg);                          std::vector<byte> bytes(count) ;                                                  const long read_bytes = io.read(&bytes[0], count); io.seek(restore, BasicIo::beg); IptcData::printStructure(out, makeSliceUntil(&bytes[0], read_bytes), depth); }  else if ( option == kpsRecursive && tag == 0x927c  && count > 10) { size_t   restore = io.tell();   uint32_t jump= 10           ; byte     bytes[20]          ; const char* chars = (const char*) &bytes[0] ; io.seek(offset,BasicIo::beg);                          io.read(bytes,jump    )     ;                          bytes[jump]=0               ; if ( ::strcmp(""Nikon"",chars) == 0 ) { byte* bytes=new byte[count-jump] ;                              io.read(bytes,count-jump)        ;                              MemIo memIo(bytes,count-jump)    ;                              printTiffStructure(memIo,out,option,depth); delete[] bytes                   ;                          } else { io.seek(0,BasicIo::beg);                              printIFDStructure(io,out,option,offset,bSwap,c,depth); } io.seek(restore,BasicIo::beg);                     } } if ( isPrintXMP(tag,option) ) { buf.pData_[count]=0; out << (char*) buf.pData_; } if ( isPrintICC(tag,option) ) { out.write((const char*)buf.pData_,count); } } if ( start ) { io.read(dir.pData_, 4); start = tooBig ? 0 : byteSwap4(dir,0,bSwap); } } while (start) ; if ( bPrint ) { out << Internal::indent(depth) << ""END "" << io.path() << std::endl; } out.flush(); depth--; }"
"btrfs_device *device_list_add(const char *path, struct btrfs_super_block *disk_super, bool *new_device_added) { struct btrfs_device *device; struct btrfs_fs_devices *fs_devices = NULL; struct rcu_string *name; u64 found_transid = btrfs_super_generation(disk_super); u64 devid = btrfs_stack_device_id(&disk_super->dev_item); bool has_metadata_uuid = (btrfs_super_incompat_flags(disk_super) & BTRFS_FEATURE_INCOMPAT_METADATA_UUID); bool fsid_change_in_progress = (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_CHANGING_FSID_V2); if (fsid_change_in_progress) { if (!has_metadata_uuid) { fs_devices = find_fsid_inprogress(disk_super); if (!fs_devices) fs_devices = find_fsid(disk_super->fsid, NULL); } else { fs_devices = find_fsid_changed(disk_super); } } else if (has_metadata_uuid) { fs_devices = find_fsid(disk_super->fsid, disk_super->metadata_uuid); } else { fs_devices = find_fsid(disk_super->fsid, NULL); } if (!fs_devices) { if (has_metadata_uuid) fs_devices = alloc_fs_devices(disk_super->fsid, disk_super->metadata_uuid); else fs_devices = alloc_fs_devices(disk_super->fsid, NULL); if (IS_ERR(fs_devices)) return ERR_CAST(fs_devices); fs_devices->fsid_change = fsid_change_in_progress; mutex_lock(&fs_devices->device_list_mutex); list_add(&fs_devices->fs_list, &fs_uuids); device = NULL; } else { mutex_lock(&fs_devices->device_list_mutex); device = find_device(fs_devices, devid, disk_super->dev_item.uuid); if (has_metadata_uuid && fs_devices->fsid_change && found_transid > fs_devices->latest_generation) { memcpy(fs_devices->fsid, disk_super->fsid, BTRFS_FSID_SIZE); memcpy(fs_devices->metadata_uuid, disk_super->metadata_uuid, BTRFS_FSID_SIZE); fs_devices->fsid_change = false; } } if (!device) { if (fs_devices->opened) { mutex_unlock(&fs_devices->device_list_mutex); return ERR_PTR(-EBUSY); } device = btrfs_alloc_device(NULL, &devid, disk_super->dev_item.uuid); if (IS_ERR(device)) { mutex_unlock(&fs_devices->device_list_mutex); return device; } name = rcu_string_strdup(path, GFP_NOFS); if (!name) { btrfs_free_device(device); mutex_unlock(&fs_devices->device_list_mutex); return ERR_PTR(-ENOMEM); } rcu_assign_pointer(device->name, name); list_add_rcu(&device->dev_list, &fs_devices->devices); fs_devices->num_devices++; device->fs_devices = fs_devices; *new_device_added = true; if (disk_super->label[0]) pr_info(""BTRFS: device label %s devid %llu transid %llu %s\n"", disk_super->label, devid, found_transid, path); else pr_info(""BTRFS: device fsid %pU devid %llu transid %llu %s\n"", disk_super->fsid, devid, found_transid, path); } else if (!device->name || strcmp(device->name->str, path)) { if (!fs_devices->opened && found_transid < device->generation) { mutex_unlock(&fs_devices->device_list_mutex); return ERR_PTR(-EEXIST); } if (device->bdev) { struct block_device *path_bdev; path_bdev = lookup_bdev(path); if (IS_ERR(path_bdev)) { mutex_unlock(&fs_devices->device_list_mutex); return ERR_CAST(path_bdev); } if (device->bdev != path_bdev) { bdput(path_bdev); mutex_unlock(&fs_devices->device_list_mutex); btrfs_warn_in_rcu(device->fs_info, ""duplicate device fsid:devid for %pU:%llu old:%s new:%s"", disk_super->fsid, devid, rcu_str_deref(device->name), path); return ERR_PTR(-EEXIST); } bdput(path_bdev); btrfs_info_in_rcu(device->fs_info, ""device fsid %pU devid %llu moved old:%s new:%s"", disk_super->fsid, devid, rcu_str_deref(device->name), path); } name = rcu_string_strdup(path, GFP_NOFS); if (!name) { mutex_unlock(&fs_devices->device_list_mutex); return ERR_PTR(-ENOMEM); } rcu_string_free(device->name); rcu_assign_pointer(device->name, name); if (test_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state)) { fs_devices->missing_devices--; clear_bit(BTRFS_DEV_STATE_MISSING, &device->dev_state); } } if (!fs_devices->opened) { device->generation = found_transid; fs_devices->latest_generation = max_t(u64, found_transid, fs_devices->latest_generation); } fs_devices->total_devices = btrfs_super_num_devices(disk_super); mutex_unlock(&fs_devices->device_list_mutex); return device; }"
"static int linear_write_system(struct x86_emulate_ctxt *ctxt, ulong linear, void *data, unsigned int size) { return ctxt->ops->write_std(ctxt, linear, data, size, &ctxt->exception); }"
"static int cardos_have_verifyrc_package(sc_card_t *card) { sc_apdu_t apdu; u8        rbuf[SC_MAX_APDU_BUFFER_SIZE]; int       r; const u8  *p = rbuf, *q; size_t    len, tlen = 0, ilen = 0; sc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xca, 0x01, 0x88); apdu.resp    = rbuf; apdu.resplen = sizeof(rbuf); apdu.lc = 0; apdu.le = 256; r = sc_transmit_apdu(card, &apdu); LOG_TEST_RET(card->ctx, r, ""APDU transmit failed""); if ((len = apdu.resplen) == 0) return 0; while (len != 0) { p = sc_asn1_find_tag(card->ctx, p, len, 0xe1, &tlen); if (p == NULL) return 0; if (card->type == SC_CARD_TYPE_CARDOS_M4_3){ q = sc_asn1_find_tag(card->ctx, p, tlen, 0x01, &ilen); if (q == NULL || ilen != 4) return 0; if (q[0] == 0x07) return 1; } else if (card->type == SC_CARD_TYPE_CARDOS_M4_4){ q = sc_asn1_find_tag(card->ctx, p, tlen, 0x03, &ilen); if (q == NULL || ilen != 4) return 0; if (q[0] == 0x02) return 1; } else{ return 0; } p   += tlen; len -= tlen + 2; } return 0; }"
"static guint dissect_amqp_1_0_list(tvbuff_t *tvb, packet_info *pinfo, int offset, int bound, proto_item *item, int hf_amqp_type, guint32 hf_amqp_subtype_count, const int **hf_amqp_subtypes, const char *name) { proto_item *list_tree; guint8      type; guint8      count_len; guint32     element_count; guint32     element_size; guint32     decoded_element_size; guint32     orig_offset; guint32     decoded_elements; int         hf_amqp_item; list_tree = 0; decoded_elements = 0; orig_offset = offset; if (proto_registrar_get_ftype(hf_amqp_type) != FT_NONE) { expert_add_info_format(pinfo, item, &ei_amqp_unknown_amqp_type, ""Unexpected list type at frame position %d of field \""%s\"""", offset, name ? name : proto_registrar_get_name(hf_amqp_type)); return bound-orig_offset; } type = tvb_get_guint8(tvb, offset); AMQP_INCREMENT(offset, 1, bound); switch (type) { case AMQP_1_0_TYPE_LIST0: count_len = 0; element_size = 0; element_count = 0; break; case AMQP_1_0_TYPE_LIST8: count_len = 1; element_size = tvb_get_guint8(tvb, offset); element_count = tvb_get_guint8(tvb, offset+count_len); break; case AMQP_1_0_TYPE_LIST32: count_len = 4; element_size = tvb_get_ntohl(tvb, offset); element_count = tvb_get_ntohl(tvb, offset+count_len); break; default: proto_tree_add_none_format(list_tree, hf_amqp_1_0_list, tvb, offset-1, 1, ""(unknown type %d)"", type); expert_add_info_format(pinfo, list_tree, &ei_amqp_unknown_amqp_type, ""Unknown AMQP list type %d"", type); return bound-orig_offset; } list_tree = proto_tree_add_none_format(item, hf_amqp_type, tvb, offset-1, element_size+1+count_len, ""%s"", name ? name : proto_registrar_get_name(hf_amqp_type)); AMQP_INCREMENT(offset, count_len*2, bound); if (element_count > 0) list_tree = proto_item_add_subtree(list_tree, ett_amqp_1_0_list); if (hf_amqp_subtype_count == 0) proto_item_append_text(list_tree, "" (list of %d element%s)"", element_count, element_suffix[element_count!=1]); if (element_count > element_size) { expert_add_info_format(pinfo, list_tree, &ei_amqp_invalid_number_of_params, ""Number of list elements (%d) bigger than list size (%d)"", element_count, element_size); return bound-orig_offset; } while ((element_count > 0) && (offset < bound)) { decoded_element_size = 0; if (decoded_elements<hf_amqp_subtype_count) hf_amqp_item = *(hf_amqp_subtypes[decoded_elements]); else hf_amqp_item = hf_amqp_1_0_list;  get_amqp_1_0_type_value_formatter(tvb, pinfo, offset, bound, hf_amqp_item, NULL, &decoded_element_size, list_tree); element_count -= 1; decoded_elements += 1; AMQP_INCREMENT(offset, decoded_element_size, bound); } if (element_count > 0) expert_add_info_format(pinfo, list_tree, &ei_amqp_invalid_number_of_params, ""Number of list elements (%d) not matching number of decoded elements (%d)"", element_count+decoded_elements, decoded_elements); return offset-orig_offset; }"
"static int writeImageSections(TIFF *in, TIFF *out, struct image_data *image, struct pagedef *page, struct pageseg *sections, struct dump_opts * dump, unsigned char *src_buff, unsigned char **sect_buff_ptr) { double  hres, vres; uint32_t  i, k, width, length, sectsize; unsigned char *sect_buff = *sect_buff_ptr; hres = page->hres; vres = page->vres; k = page->cols * page->rows; if ((k < 1) || (k > MAX_SECTIONS)) { TIFFError(""writeImageSections"", ""%""PRIu32"" Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections"", k); return (-1); } for (i = 0; i < k; i++) { width  = sections[i].x2 - sections[i].x1 + 1; length = sections[i].y2 - sections[i].y1 + 1; sectsize = (uint32_t) ceil((width * image->bps + 7) / (double)8) * image->spp * length; if (createImageSection(sectsize, sect_buff_ptr)) { TIFFError(""writeImageSections"", ""Unable to allocate section buffer""); exit(EXIT_FAILURE); } sect_buff = *sect_buff_ptr; if (extractImageSection (image, &sections[i], src_buff, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to extract image sections""); exit(EXIT_FAILURE); } if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to write image section""); exit(EXIT_FAILURE); } } return (0); }"
"bool_pdfioDictSetValue( pdfio_dict_t   *dict,    const char     *key,    _pdfio_value_t *value){ _pdfio_pair_t*pair; PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", dict, key, (void *)value); if (dict->num_pairs > 0) { _pdfio_pair_tpkey; pkey.key = key; if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL) { PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n""); if (pair->value.type == PDFIO_VALTYPE_BINARY) free(pair->value.value.binary.data); pair->value = *value; return (true); } } if (dict->num_pairs >= dict->alloc_pairs) { _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t)); if (!temp) { PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n""); return (false); } dict->pairs       = temp; dict->alloc_pairs += 8; } pair = dict->pairs + dict->num_pairs; dict->num_pairs ++; pair->key   = key; pair->value = *value; if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0) qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs); #ifdef DEBUG PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs); PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict); PDFIO_DEBUG_DICT(dict); PDFIO_DEBUG(""\n""); #endif  return (true); }"
"int ha_myisam::repair(THD *thd, MI_CHECK &param, bool do_optimize) { int error=0; uint local_testflag=param.testflag; bool optimize_done= !do_optimize, statistics_done=0; const char *old_proc_info=thd->proc_info; char fixed_name[FN_REFLEN]; MYISAM_SHARE* share = file->s; ha_rows rows= file->state->records; DBUG_ENTER(""ha_myisam::repair""); param.db_name=    table->s->db.str; param.table_name= table->alias; param.using_global_keycache = 1; param.thd= thd; param.tmpdir= &mysql_tmpdir_list; param.out_flag= 0; strmov(fixed_name,file->filename); ha_release_temporary_latches(thd); if (! thd->locked_tables_mode && mi_lock_database(file, table->s->tmp_table ? F_EXTRA_LCK : F_WRLCK)) { mi_check_print_error(&param,ER(ER_CANT_LOCK),my_errno); DBUG_RETURN(HA_ADMIN_FAILED); } if (!do_optimize || ((file->state->del || share->state.split != file->state->records) && (!(param.testflag & T_QUICK) || !(share->state.changed & STATE_NOT_OPTIMIZED_KEYS)))) { ulonglong key_map= ((local_testflag & T_CREATE_MISSING_KEYS) ? mi_get_mask_all_keys_active(share->base.keys) : share->state.key_map); uint testflag=param.testflag; #ifdef HAVE_MMAP bool remap= test(share->file_map); if (remap) mi_munmap_file(file); #endif if (mi_test_if_sort_rep(file,file->state->records,key_map,0) && (local_testflag & T_REP_BY_SORT)) { local_testflag|= T_STATISTICS; param.testflag|= T_STATISTICS;      statistics_done=1; if (THDVAR(thd, repair_threads)>1) { char buf[40]; my_snprintf(buf, 40, ""Repair with %d threads"", my_count_bits(key_map)); thd_proc_info(thd, buf); error = mi_repair_parallel(&param, file, fixed_name, param.testflag & T_QUICK); thd_proc_info(thd, ""Repair done"");                                             } else { thd_proc_info(thd, ""Repair by sorting""); error = mi_repair_by_sort(&param, file, fixed_name, param.testflag & T_QUICK); } } else { thd_proc_info(thd, ""Repair with keycache""); param.testflag &= ~T_REP_BY_SORT; error=  mi_repair(&param, file, fixed_name, param.testflag & T_QUICK); } #ifdef HAVE_MMAP if (remap) mi_dynmap_file(file, file->state->data_file_length); #endif param.testflag=testflag; optimize_done=1; } if (!error) { if ((local_testflag & T_SORT_INDEX) && (share->state.changed & STATE_NOT_SORTED_PAGES)) { optimize_done=1; thd_proc_info(thd, ""Sorting index""); error=mi_sort_index(&param,file,fixed_name); } if (!statistics_done && (local_testflag & T_STATISTICS)) { if (share->state.changed & STATE_NOT_ANALYZED) { optimize_done=1; thd_proc_info(thd, ""Analyzing""); error = chk_key(&param, file); } else local_testflag&= ~T_STATISTICS;    } } thd_proc_info(thd, ""Saving state""); if (!error) { if ((share->state.changed & STATE_CHANGED) || mi_is_crashed(file)) { share->state.changed&= ~(STATE_CHANGED | STATE_CRASHED | STATE_CRASHED_ON_REPAIR); file->update|=HA_STATE_CHANGED | HA_STATE_ROW_CHANGED; } if (file->state != &file->s->state.state) file->s->state.state = *file->state; if (file->s->base.auto_key) update_auto_increment_key(&param, file, 1); if (optimize_done) error = update_state_info(&param, file, UPDATE_TIME | UPDATE_OPEN_COUNT | (local_testflag & T_STATISTICS ? UPDATE_STAT : 0)); info(HA_STATUS_NO_LOCK | HA_STATUS_TIME | HA_STATUS_VARIABLE | HA_STATUS_CONST); if (rows != file->state->records && ! (param.testflag & T_VERY_SILENT)) { char llbuff[22],llbuff2[22]; mi_check_print_warning(&param,""Number of rows changed from %s to %s"", llstr(rows,llbuff), llstr(file->state->records,llbuff2)); } } else { mi_mark_crashed_on_repair(file); file->update |= HA_STATE_CHANGED | HA_STATE_ROW_CHANGED; update_state_info(&param, file, 0); } thd_proc_info(thd, old_proc_info); if (! thd->locked_tables_mode) mi_lock_database(file,F_UNLCK); DBUG_RETURN(error ? HA_ADMIN_FAILED : !optimize_done ? HA_ADMIN_ALREADY_DONE : HA_ADMIN_OK); }"
"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz) { for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) { unsigned const symnum = get_te64(&rela->r_info) >> 32; char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr; if (0==strcmp(symnam, ""__libc_start_main"")          ||  0==strcmp(symnam, ""__libc_init"")          ||  0==strcmp(symnam, ""__uClibc_main"") ||  0==strcmp(symnam, ""__uClibc_start_main"")) return true; } return false; }"
"static inline void i2ulaw_array (const int *ptr, int count, unsigned char *buffer) {while (--count >= 0) {if (ptr [count] >= 0) buffer [count] = ulaw_encode [ptr [count] >> (16 + 2)] ; else buffer [count] = 0x7F & ulaw_encode [-ptr [count] >> (16 + 2)] ; } ; }"
"int _gsasl_gssapi_server_step (Gsasl_session * sctx, void *mech_data, const char *input, size_t input_len, char **output, size_t *output_len) { _Gsasl_gssapi_server_state *state = mech_data; gss_buffer_desc bufdesc1, bufdesc2; OM_uint32 maj_stat, min_stat; gss_buffer_desc client_name; gss_OID mech_type; char tmp[4]; int res; *output = NULL; *output_len = 0; switch (state->step) { case 0: { gss_name_t server; const char *service; const char *hostname; if (input_len == 0) { res = GSASL_NEEDS_MORE; break; } service = gsasl_property_get (sctx, GSASL_SERVICE); if (!service) return GSASL_NO_SERVICE; hostname = gsasl_property_get (sctx, GSASL_HOSTNAME); if (!hostname) return GSASL_NO_HOSTNAME; bufdesc1.length = strlen (service) + strlen (""@"") + strlen (hostname) + 1; bufdesc1.value = malloc (bufdesc1.length); if (bufdesc1.value == NULL) return GSASL_MALLOC_ERROR; sprintf (bufdesc1.value, ""%s@%s"", service, hostname); maj_stat = gss_import_name (&min_stat, &bufdesc1, GSS_C_NT_HOSTBASED_SERVICE, &server); free (bufdesc1.value); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_IMPORT_NAME_ERROR; maj_stat = gss_acquire_cred (&min_stat, server, 0, GSS_C_NULL_OID_SET, GSS_C_ACCEPT, &state->cred, NULL, NULL); gss_release_name (&min_stat, &server); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_ACQUIRE_CRED_ERROR; } state->step++; case 1: bufdesc1.value = (void *) input; bufdesc1.length = input_len; if (state->client) { gss_release_name (&min_stat, &state->client); state->client = GSS_C_NO_NAME; } maj_stat = gss_accept_sec_context (&min_stat, &state->context, state->cred, &bufdesc1, GSS_C_NO_CHANNEL_BINDINGS, &state->client, &mech_type, &bufdesc2, NULL, NULL, NULL); if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED) return GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR; if (maj_stat == GSS_S_COMPLETE) state->step++; if (maj_stat == GSS_S_CONTINUE_NEEDED || bufdesc2.length > 0) { *output = malloc (bufdesc2.length); if (!*output) return GSASL_MALLOC_ERROR; memcpy (*output, bufdesc2.value, bufdesc2.length); *output_len = bufdesc2.length; } maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; if (maj_stat == GSS_S_CONTINUE_NEEDED || *output_len > 0) { res = GSASL_NEEDS_MORE; break; } case 2: memset (tmp, 0xFF, 4); tmp[0] = GSASL_QOP_AUTH; bufdesc1.length = 4; bufdesc1.value = tmp; maj_stat = gss_wrap (&min_stat, state->context, 0, GSS_C_QOP_DEFAULT, &bufdesc1, NULL, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_WRAP_ERROR; *output = malloc (bufdesc2.length); if (!*output) return GSASL_MALLOC_ERROR; memcpy (*output, bufdesc2.value, bufdesc2.length); *output_len = bufdesc2.length; maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; state->step++; res = GSASL_NEEDS_MORE; break; case 3: bufdesc1.value = (void *) input; bufdesc1.length = input_len; maj_stat = gss_unwrap (&min_stat, state->context, &bufdesc1, &bufdesc2, NULL, NULL); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_UNWRAP_ERROR; if ((((char *) bufdesc2.value)[0] & GSASL_QOP_AUTH) == 0) { maj_stat = gss_release_buffer (&min_stat, &bufdesc2); return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR; } gsasl_property_set_raw (sctx, GSASL_AUTHZID, (char *) bufdesc2.value + 4, bufdesc2.length - 4); maj_stat = gss_display_name (&min_stat, state->client, &client_name, &mech_type); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_DISPLAY_NAME_ERROR; gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME, client_name.value, client_name.length); maj_stat = gss_release_buffer (&min_stat, &client_name); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; maj_stat = gss_release_buffer (&min_stat, &bufdesc2); if (GSS_ERROR (maj_stat)) return GSASL_GSSAPI_RELEASE_BUFFER_ERROR; res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI); state->step++; break; default: res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES; break; } return res; }"
void rose_start_t1timer(struct sock *sk) { struct rose_sock *rose = rose_sk(sk); del_timer(&rose->timer); rose->timer.function = rose_timer_expiry; rose->timer.expires  = jiffies + rose->t1; add_timer(&rose->timer); }
"AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims) : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) { OP_REQUIRES_OK(ctx, ctx->GetAttr(""ksize"", &ksize_)); OP_REQUIRES(ctx, ksize_.size() == num_dims(), errors::InvalidArgument(""Sliding window ksize field must "" ""specify "", num_dims(), "" dimensions"")); OP_REQUIRES_OK(ctx, ctx->GetAttr(""strides"", &stride_)); OP_REQUIRES(ctx, stride_.size() == num_dims(), errors::InvalidArgument(""Sliding window strides field must "" ""specify "", num_dims(), "" dimensions"")); OP_REQUIRES_OK(ctx, ctx->GetAttr(""padding"", &padding_)); OP_REQUIRES(ctx, padding_ != EXPLICIT, errors::Unimplemented( ""XLA does not support avgpoolgrad with explicit padding."")); OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1, errors::Unimplemented( ""Pooling is not yet supported on the batch dimension."")); string data_format; OP_REQUIRES_OK(ctx, ctx->GetAttr(""data_format"", &data_format)); OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_), errors::InvalidArgument(""Invalid data format"")); }"
"static int on_frame_recv(nghttp2_session *session, const nghttp2_frame *frame, void *user_data) { int rv; ogs_sbi_session_t *sbi_sess = user_data; ogs_sbi_server_t *server = NULL; ogs_sbi_stream_t *stream = NULL; ogs_sbi_request_t *request = NULL; ogs_assert(sbi_sess); server = sbi_sess->server; ogs_assert(server); ogs_assert(server->cb); ogs_assert(session); ogs_assert(frame); stream = nghttp2_session_get_stream_user_data(session, frame->hd.stream_id); if (!stream) { if (frame->hd.type == NGHTTP2_SETTINGS) { sbi_sess->settings.max_concurrent_streams = nghttp2_session_get_remote_settings( session, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS); sbi_sess->settings.enable_push = nghttp2_session_get_remote_settings( session, NGHTTP2_SETTINGS_ENABLE_PUSH); ogs_debug(""MAX_CONCURRENT_STREAMS = %d"", sbi_sess->settings.max_concurrent_streams); ogs_debug(""ENABLE_PUSH = %s"", sbi_sess->settings.enable_push ? ""TRUE"" : ""false""); } else if (frame->hd.type == NGHTTP2_GOAWAY) { rv = nghttp2_submit_goaway( session, NGHTTP2_FLAG_NONE, sbi_sess->last_stream_id, NGHTTP2_NO_ERROR, NULL, 0); if (rv != 0) { ogs_error(""nghttp2_submit_goaway() failed (%d:%s)"", rv, nghttp2_strerror(rv)); return OGS_ERROR; } session_send(sbi_sess); } return 0; } request = stream->request; ogs_assert(request); switch (frame->hd.type) { case NGHTTP2_HEADERS: if (frame->headers.cat == NGHTTP2_HCAT_REQUEST) { const char *expect100 = ogs_sbi_header_get(request->http.headers, OGS_SBI_EXPECT); if (expect100 && ogs_strcasecmp(expect100, ""100-continue"") == 0) { nghttp2_nv nva; add_header(&nva, "":status"", status_string[100]); rv = nghttp2_submit_headers(session, NGHTTP2_FLAG_NONE, stream->stream_id, NULL, &nva, 1, NULL); if (rv != 0) { ogs_error(""nghttp2_submit_headers() failed (%d:%s)"", rv, nghttp2_strerror(rv)); nghttp2_submit_rst_stream( session, NGHTTP2_FLAG_NONE, stream->stream_id, rv); return 0; } } } OGS_GNUC_FALLTHROUGH; case NGHTTP2_DATA: if (frame->hd.flags & NGHTTP2_FLAG_END_STREAM) { ogs_debug(""[%s] %s"", request->h.method, request->h.uri); if (request->http.content_length && request->http.content) { ogs_debug(""RECEIVED: %d"", (int)request->http.content_length); ogs_debug(""%s"", request->http.content); } if (server->cb(request, stream) != OGS_OK) { ogs_warn(""server callback error""); ogs_assert(true == ogs_sbi_server_send_error(stream, OGS_SBI_HTTP_STATUS_INTERNAL_SERVER_ERROR, NULL, ""server callback error"", NULL)); return 0; } break; } default: break; } return 0; }"
"static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh, struct mschmd_header *chm, int entire) { unsigned int section, name_len, x, errors, num_chunks; unsigned char buf[0x54], *chunk = NULL, *name, *p, *end; struct mschmd_file *fi, *link = NULL; off_t offset, length; int num_entries; chm->files         = NULL; chm->sysfiles      = NULL; chm->chunk_cache   = NULL; chm->sec0.base.chm = chm; chm->sec0.base.id  = 0; chm->sec1.base.chm = chm; chm->sec1.base.id  = 1; chm->sec1.content  = NULL; chm->sec1.control  = NULL; chm->sec1.spaninfo = NULL; chm->sec1.rtable   = NULL; if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) { return MSPACK_ERR_READ; } if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) { return MSPACK_ERR_SIGNATURE; } if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) { D((""incorrect GUIDs"")) return MSPACK_ERR_SIGNATURE; } chm->version   = EndGetI32(&buf[chmhead_Version]); chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]); chm->language  = EndGetI32(&buf[chmhead_LanguageID]); if (chm->version > 3) { sys->message(fh, ""WARNING; CHM version > 3""); } if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) || read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) || read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) { return MSPACK_ERR_READ; } chm->dir_offset = sys->tell(fh); chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]); chm->density    = EndGetI32(&buf[chmhs1_Density]); chm->depth      = EndGetI32(&buf[chmhs1_Depth]); chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]); chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]); chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]); chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]); if (chm->version < 3) { chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks); } if (chm->sec0.offset > chm->length) { D((""content section begins after file has ended"")) return MSPACK_ERR_DATAFORMAT; } if (chm->chunk_size < (pmgl_Entries + 2)) { D((""chunk size not large enough"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks == 0) { D((""no chunks"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks > 100000) { D((""more than 100,000 chunks"")) return MSPACK_ERR_DATAFORMAT; }    if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) { D((""chunks larger than entire file"")) return MSPACK_ERR_DATAFORMAT; } if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) { sys->message(fh, ""WARNING; chunk size is not a power of two""); } if (chm->first_pmgl != 0) { sys->message(fh, ""WARNING; first PMGL chunk is not zero""); } if (chm->first_pmgl > chm->last_pmgl) { D((""first pmgl chunk is after last pmgl chunk"")) return MSPACK_ERR_DATAFORMAT; } if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) { D((""index_root outside valid range"")) return MSPACK_ERR_DATAFORMAT; } if (!entire) { return MSPACK_ERR_OK; } if ((x = chm->first_pmgl) != 0) { if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) { return MSPACK_ERR_SEEK; } } num_chunks = chm->last_pmgl - x + 1; if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) { return MSPACK_ERR_NOMEMORY; } errors = 0; while (num_chunks--) { if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) { sys->free(chunk); return MSPACK_ERR_READ; } if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue; if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) { sys->message(fh, ""WARNING; PMGL quickref area is too small""); } if (EndGetI32(&chunk[pmgl_QuickRefSize]) >  ((int)chm->chunk_size - pmgl_Entries)) { sys->message(fh, ""WARNING; PMGL quickref area is too large""); } p = &chunk[pmgl_Entries]; end = &chunk[chm->chunk_size - 2]; num_entries = EndGetI16(end); while (num_entries--) { READ_ENCINT(name_len); if (name_len > (unsigned int) (end - p)) goto chunk_end; name = p; p += name_len; READ_ENCINT(section); READ_ENCINT(offset); READ_ENCINT(length); if ((offset == 0) && (length == 0)) { if ((name_len > 0) && (name[name_len-1] == '/')) continue; } if (section > 1) { sys->message(fh, ""invalid section number '%u'."", section); continue; } if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) { sys->free(chunk); return MSPACK_ERR_NOMEMORY; } fi->next     = NULL; fi->filename = (char *) &fi[1]; fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0) : (struct mschmd_section *) (&chm->sec1)); fi->offset   = offset; fi->length   = length; sys->copy(name, fi->filename, (size_t) name_len); fi->filename[name_len] = '\0'; if (name[0] == ':' && name[1] == ':') { if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) { if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) { chm->sec1.content = fi; } else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) { chm->sec1.control = fi; } else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) { chm->sec1.spaninfo = fi; } else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) { chm->sec1.rtable = fi; } } fi->next = chm->sysfiles; chm->sysfiles = fi; } else { if (link) link->next = fi; else chm->files = fi; link = fi; } } chunk_end: if (num_entries >= 0) { D((""chunk ended before all entries could be read"")) errors++; } } sys->free(chunk); return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK; }"
"void CalculateOutputIndexRowSplit( const RowPartitionTensor& row_split, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { INDEX_TYPE row_split_size = row_split.size(); if (row_split_size > 0) { result->reserve(row_split(row_split_size - 1)); } for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) { INDEX_TYPE row_length = row_split(i + 1) - row_split(i); INDEX_TYPE real_length = std::min(output_size, row_length); INDEX_TYPE parent_output_index_current = parent_output_index[i]; if (parent_output_index_current == -1) { real_length = 0; } for (INDEX_TYPE j = 0; j < real_length; ++j) { result->push_back(parent_output_index_current); parent_output_index_current += output_index_multiplier; } for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) { result->push_back(-1); } } if (row_split_size > 0) { DCHECK_EQ(result->size(), row_split(row_split_size - 1)); } }"
"GF_Err ilst_item_box_read(GF_Box *s,GF_BitStream *bs) { GF_Err e; u32 sub_type; GF_Box *a = NULL; GF_ListItemBox *ptr = (GF_ListItemBox *)s; sub_type = gf_bs_peek_bits(bs, 32, 4); if (sub_type == GF_ISOM_BOX_TYPE_DATA ) { e = gf_isom_box_parse(&a, bs); if (!e && ptr->size < a->size) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[isom] not enough bytes in box %s: %d left, reading %d (file %s, line %d)\n"", gf_4cc_to_str(ptr->type), ptr->size, a->size, __FILE__, __LINE__ )); \ e = GF_ISOM_INVALID_FILE; } if (e) { if (a) gf_isom_box_del(a); return e; } ISOM_DECREASE_SIZE(ptr, a->size); if (a && ptr->data) gf_isom_box_del_parent(&ptr->child_boxes, (GF_Box *) ptr->data); if (a && a->size > 4 && a->type != GF_ISOM_BOX_TYPE_VOID) { ptr->data = (GF_DataBox *)a; if (!ptr->child_boxes) ptr->child_boxes = gf_list_new(); gf_list_add(ptr->child_boxes, ptr->data); } else { ptr->data = NULL; gf_isom_box_del(a); } } else { u64 pos = gf_bs_get_position(bs); u64 prev_size = s->size; e = gf_isom_box_array_read(s, bs, NULL); if (e==GF_OK) return GF_OK; gf_isom_box_array_del(s->child_boxes); s->child_boxes=NULL; gf_bs_seek(bs, pos); s->size = prev_size; ptr->data = (GF_DataBox *)gf_isom_box_new_parent(&ptr->child_boxes, GF_ISOM_BOX_TYPE_DATA); ptr->data->qt_style = GF_TRUE; ISOM_DECREASE_SIZE(ptr, 2); ptr->data->dataSize = gf_bs_read_u16(bs); gf_bs_read_u16(bs); ptr->data->data = (char *) gf_malloc(sizeof(char)*(ptr->data->dataSize + 1)); gf_bs_read_data(bs, ptr->data->data, ptr->data->dataSize); ptr->data->data[ptr->data->dataSize] = 0; ISOM_DECREASE_SIZE(ptr, ptr->data->dataSize); } return GF_OK; }"
"int Xasc(int modifier, char* label, char* mnemo, char* oper) { register char* s; register char r; register char delimiter; s = oper; delimiter = *s; if (delimiter != '\'' && delimiter != '\""') { error(""Bad operand syntax""); } while ((r = *++s) != delimiter) { if (r == '\\') { switch (*++s) { case 't': r = '\t'; break; case 'n': r = '\n'; break; case 'r': r = '\r'; break; case '0': r = 0; break; case '\'': case '\""': case '\\': r = *s; break; default: error(""Bad \\X character""); } } insert8(r); } if (*++s) { error(""syntax error""); } return 0; }"
static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg); s64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime; if (slack_runtime <= 0) return; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota != RUNTIME_INF && cfs_rq->runtime_expires == cfs_b->runtime_expires) { cfs_b->runtime += slack_runtime; if (cfs_b->runtime > sched_cfs_bandwidth_slice() && !list_empty(&cfs_b->throttled_cfs_rq)) start_cfs_slack_bandwidth(cfs_b); } raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining -= slack_runtime; }
"int SMB2_negotiate(const unsigned int xid, struct cifs_ses *ses) { struct smb_rqst rqst; struct smb2_negotiate_req *req; struct smb2_negotiate_rsp *rsp; struct kvec iov[1]; struct kvec rsp_iov; int rc = 0; int resp_buftype; struct TCP_Server_Info *server = ses->server; int blob_offset, blob_length; char *security_blob; int flags = CIFS_NEG_OP; unsigned int total_len; cifs_dbg(FYI, ""Negotiate protocol\n""); if (!server) { WARN(1, ""%s: server is NULL!\n"", __func__); return -EIO; } rc = smb2_plain_req_init(SMB2_NEGOTIATE, NULL, (void **) &req, &total_len); if (rc) return rc; req->sync_hdr.SessionId = 0; memset(server->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE); memset(ses->preauth_sha_hash, 0, SMB2_PREAUTH_HASH_SIZE); if (strcmp(ses->server->vals->version_string, SMB3ANY_VERSION_STRING) == 0) { req->Dialects[0] = cpu_to_le16(SMB30_PROT_ID); req->Dialects[1] = cpu_to_le16(SMB302_PROT_ID); req->DialectCount = cpu_to_le16(2); total_len += 4; } else if (strcmp(ses->server->vals->version_string, SMBDEFAULT_VERSION_STRING) == 0) { req->Dialects[0] = cpu_to_le16(SMB21_PROT_ID); req->Dialects[1] = cpu_to_le16(SMB30_PROT_ID); req->Dialects[2] = cpu_to_le16(SMB302_PROT_ID); req->Dialects[3] = cpu_to_le16(SMB311_PROT_ID); req->DialectCount = cpu_to_le16(4); total_len += 8; } else { req->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id); req->DialectCount = cpu_to_le16(1); total_len += 2; } if (ses->sign) req->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED); else if (global_secflags & CIFSSEC_MAY_SIGN) req->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED); else req->SecurityMode = 0; req->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities); if (ses->server->vals->protocol_id == SMB20_PROT_ID) memset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE); else { memcpy(req->ClientGUID, server->client_guid, SMB2_CLIENT_GUID_SIZE); if ((ses->server->vals->protocol_id == SMB311_PROT_ID) || (strcmp(ses->server->vals->version_string, SMBDEFAULT_VERSION_STRING) == 0)) assemble_neg_contexts(req, &total_len); } iov[0].iov_base = (char *)req; iov[0].iov_len = total_len; memset(&rqst, 0, sizeof(struct smb_rqst)); rqst.rq_iov = iov; rqst.rq_nvec = 1; rc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov); cifs_small_buf_release(req); rsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base; if (rc == -EOPNOTSUPP) { cifs_dbg(VFS, ""Dialect not supported by server. Consider "" ""specifying vers=1.0 or vers=2.0 on mount for accessing"" "" older servers\n""); goto neg_exit; } else if (rc != 0) goto neg_exit; if (strcmp(ses->server->vals->version_string, SMB3ANY_VERSION_STRING) == 0) { if (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) { cifs_dbg(VFS, ""SMB2 dialect returned but not requested\n""); return -EIO; } else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) { cifs_dbg(VFS, ""SMB2.1 dialect returned but not requested\n""); return -EIO; } } else if (strcmp(ses->server->vals->version_string, SMBDEFAULT_VERSION_STRING) == 0) { if (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) { cifs_dbg(VFS, ""SMB2 dialect returned but not requested\n""); return -EIO; } else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) { ses->server->ops = &smb21_operations; } else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) ses->server->ops = &smb311_operations; } else if (le16_to_cpu(rsp->DialectRevision) != ses->server->vals->protocol_id) { cifs_dbg(VFS, ""Illegal 0x%x dialect returned: not requested\n"", le16_to_cpu(rsp->DialectRevision)); return -EIO; } cifs_dbg(FYI, ""mode 0x%x\n"", rsp->SecurityMode); if (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID)) cifs_dbg(FYI, ""negotiated smb2.0 dialect\n""); else if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID)) cifs_dbg(FYI, ""negotiated smb2.1 dialect\n""); else if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID)) cifs_dbg(FYI, ""negotiated smb3.0 dialect\n""); else if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID)) cifs_dbg(FYI, ""negotiated smb3.02 dialect\n""); else if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) cifs_dbg(FYI, ""negotiated smb3.1.1 dialect\n""); else { cifs_dbg(VFS, ""Illegal dialect returned by server 0x%x\n"", le16_to_cpu(rsp->DialectRevision)); rc = -EIO; goto neg_exit; } server->dialect = le16_to_cpu(rsp->DialectRevision); memcpy(server->preauth_sha_hash, ses->preauth_sha_hash, SMB2_PREAUTH_HASH_SIZE); server->negflavor = CIFS_NEGFLAVOR_EXTENDED; server->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize), SMB2_MAX_BUFFER_SIZE); server->max_read = le32_to_cpu(rsp->MaxReadSize); server->max_write = le32_to_cpu(rsp->MaxWriteSize); server->sec_mode = le16_to_cpu(rsp->SecurityMode); if ((server->sec_mode & SMB2_SEC_MODE_FLAGS_ALL) != server->sec_mode) cifs_dbg(FYI, ""Server returned unexpected security mode 0x%x\n"", server->sec_mode); server->capabilities = le32_to_cpu(rsp->Capabilities); server->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES; security_blob = smb2_get_data_area_len(&blob_offset, &blob_length, (struct smb2_sync_hdr *)rsp); if (blob_length == 0) { cifs_dbg(FYI, ""missing security blob on negprot\n""); server->sec_ntlmssp = true; } rc = cifs_enable_signing(server, ses->sign); if (rc) goto neg_exit; if (blob_length) { rc = decode_negTokenInit(security_blob, blob_length, server); if (rc == 1) rc = 0; else if (rc == 0) rc = -EIO; } if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID)) { if (rsp->NegotiateContextCount) rc = smb311_decode_neg_context(rsp, server, rsp_iov.iov_len); else cifs_dbg(VFS, ""Missing expected negotiate contexts\n""); } neg_exit: free_rsp_buf(resp_buftype, rsp); return rc; }"
"MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) { MOBIIndexEntry e = indx->entries[i]; char *inflected = e.label; for (size_t j = 0; j < e.tags_count; j++) { MOBIIndexTag t = e.tags[j]; if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) { for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) { uint32_t len = t.tagvalues[k]; uint32_t offset = t.tagvalues[k + 1]; char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len); if (base == NULL) { return MOBI_MALLOC_FAILED; } MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected); free(base); if (ret != MOBI_SUCCESS) { return ret; } } } } return MOBI_SUCCESS; }"
"static bfd_boolean pe_print_idata (bfd * abfd, void * vfile) { FILE *file = (FILE *) vfile; bfd_byte *data; asection *section; bfd_signed_vma adj; #ifdef POWERPC_LE_PE asection *rel_section = bfd_get_section_by_name (abfd, "".reldata""); #endif bfd_size_type datasize = 0; bfd_size_type dataoff; bfd_size_type i; int onaline = 20; pe_data_type *pe = pe_data (abfd); struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr; bfd_vma addr; addr = extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress; if (addr == 0 && extra->DataDirectory[PE_IMPORT_TABLE].Size == 0) { section = bfd_get_section_by_name (abfd, "".idata""); if (section == NULL) return TRUE; addr = section->vma; datasize = section->size; if (datasize == 0) return TRUE; } else { addr += extra->ImageBase; for (section = abfd->sections; section != NULL; section = section->next) { datasize = section->size; if (addr >= section->vma && addr < section->vma + datasize) break; } if (section == NULL) { fprintf (file, _(""\nThere is an import table, but the section containing it could not be found\n"")); return TRUE; } else if (!(section->flags & SEC_HAS_CONTENTS)) { fprintf (file, _(""\nThere is an import table in %s, but that section has no contents\n""), section->name); return TRUE; } } fprintf (file, _(""\nThere is an import table in %s at 0x%lx\n""), section->name, (unsigned long) addr); dataoff = addr - section->vma; #ifdef POWERPC_LE_PE if (rel_section != 0 && rel_section->size != 0) { bfd_vma loadable_toc_address; bfd_vma toc_address; bfd_vma start_address; bfd_byte *data; bfd_vma offset; if (!bfd_malloc_and_get_section (abfd, rel_section, &data)) { if (data != NULL) free (data); return FALSE; } offset = abfd->start_address - rel_section->vma; if (offset >= rel_section->size || offset + 8 > rel_section->size) { if (data != NULL) free (data); return FALSE; } start_address = bfd_get_32 (abfd, data + offset); loadable_toc_address = bfd_get_32 (abfd, data + offset + 4); toc_address = loadable_toc_address - 32768; fprintf (file, _(""\nFunction descriptor located at the start address: %04lx\n""), (unsigned long int) (abfd->start_address)); fprintf (file, _(""\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n""), start_address, loadable_toc_address, toc_address); if (data != NULL) free (data); } else { fprintf (file, _(""\nNo reldata section! Function descriptor not decoded.\n"")); } #endif fprintf (file, _(""\nThe Import Tables (interpreted %s section contents)\n""), section->name); fprintf (file, _(""\ vma:            Hint    Time      Forward  DLL       First\n\ Table   Stamp     Chain    Name      Thunk\n"")); if (!bfd_malloc_and_get_section (abfd, section, &data)) { if (data != NULL) free (data); return FALSE; } adj = section->vma - extra->ImageBase; for (i = dataoff; i + onaline <= datasize; i += onaline) { bfd_vma hint_addr; bfd_vma time_stamp; bfd_vma forward_chain; bfd_vma dll_name; bfd_vma first_thunk; int idx = 0; bfd_size_type j; char *dll; fprintf (file, "" %08lx\t"", (unsigned long) (i + adj)); hint_addr = bfd_get_32 (abfd, data + i); time_stamp = bfd_get_32 (abfd, data + i + 4); forward_chain = bfd_get_32 (abfd, data + i + 8); dll_name = bfd_get_32 (abfd, data + i + 12); first_thunk = bfd_get_32 (abfd, data + i + 16); fprintf (file, ""%08lx %08lx %08lx %08lx %08lx\n"", (unsigned long) hint_addr, (unsigned long) time_stamp, (unsigned long) forward_chain, (unsigned long) dll_name, (unsigned long) first_thunk); if (hint_addr == 0 && first_thunk == 0) break; if (dll_name - adj >= section->size) break; dll = (char *) data + dll_name - adj; bfd_size_type maxlen = (char *)(data + datasize) - dll - 1; fprintf (file, _(""\n\tDLL Name: %.*s\n""), (int) maxlen, dll); if (hint_addr == 0) hint_addr = first_thunk; if (hint_addr != 0) { bfd_byte *ft_data; asection *ft_section; bfd_vma ft_addr; bfd_size_type ft_datasize; int ft_idx; int ft_allocated; fprintf (file, _(""\tvma:  Hint/Ord Member-Name Bound-To\n"")); idx = hint_addr - adj; ft_addr = first_thunk + extra->ImageBase; ft_idx = first_thunk - adj; ft_data = data + ft_idx; ft_datasize = datasize - ft_idx; ft_allocated = 0; if (first_thunk != hint_addr) { for (ft_section = abfd->sections; ft_section != NULL; ft_section = ft_section->next) { if (ft_addr >= ft_section->vma && ft_addr < ft_section->vma + ft_section->size) break; } if (ft_section == NULL) { fprintf (file, _(""\nThere is a first thunk, but the section containing it could not be found\n"")); continue; } if (ft_section != section) { ft_idx = first_thunk - (ft_section->vma - extra->ImageBase); ft_datasize = ft_section->size - ft_idx; ft_data = (bfd_byte *) bfd_malloc (ft_datasize); if (ft_data == NULL) continue; if (!bfd_get_section_contents (abfd, ft_section, ft_data, (bfd_vma) ft_idx, ft_datasize)) { free (ft_data); continue; } ft_allocated = 1; } } #ifdef COFF_WITH_pex64 for (j = 0; idx + j + 8 <= datasize; j += 8) { bfd_size_type amt; unsigned long member = bfd_get_32 (abfd, data + idx + j); unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4); if (!member && !member_high) break; amt = member - adj; if (HighBitSet (member_high)) fprintf (file, ""\t%lx%08lx\t %4lx%08lx  <none>"", member_high, member, WithoutHighBit (member_high), member); else if (amt + 2 >= datasize) fprintf (file, _(""\t<corrupt: 0x%04lx>""), member); else { int ordinal; char *member_name; ordinal = bfd_get_16 (abfd, data + amt); member_name = (char *) data + amt + 2; fprintf (file, ""\t%04lx\t %4d  %.*s"",member, ordinal, (int) (datasize - (amt + 2)), member_name); } if (time_stamp != 0 && first_thunk != 0 && first_thunk != hint_addr && j + 4 <= ft_datasize) fprintf (file, ""\t%04lx"", (unsigned long) bfd_get_32 (abfd, ft_data + j)); fprintf (file, ""\n""); } #else for (j = 0; idx + j + 4 <= datasize; j += 4) { bfd_size_type amt; unsigned long member = bfd_get_32 (abfd, data + idx + j); if (member == 0) break; amt = member - adj; if (HighBitSet (member)) fprintf (file, ""\t%04lx\t %4lu  <none>"", member, WithoutHighBit (member)); else if (amt + 2 >= datasize) fprintf (file, _(""\t<corrupt: 0x%04lx>""), member); else { int ordinal; char *member_name; ordinal = bfd_get_16 (abfd, data + amt); member_name = (char *) data + amt + 2; fprintf (file, ""\t%04lx\t %4d  %.*s"", member, ordinal, (int) (datasize - (amt + 2)), member_name); } if (time_stamp != 0 && first_thunk != 0 && first_thunk != hint_addr && j + 4 <= ft_datasize) fprintf (file, ""\t%04lx"", (unsigned long) bfd_get_32 (abfd, ft_data + j)); fprintf (file, ""\n""); } #endif if (ft_allocated) free (ft_data); } fprintf (file, ""\n""); } free (data); return TRUE; }"
"static int brcm_nvram_parse(struct brcm_nvram *priv) { struct device *dev = priv->dev; struct brcm_nvram_header header; uint8_t *data; size_t len; int err; memcpy_fromio(&header, priv->base, sizeof(header)); if (memcmp(header.magic, NVRAM_MAGIC, 4)) { dev_err(dev, ""Invalid NVRAM magic\n""); return -EINVAL; } len = le32_to_cpu(header.len); data = kzalloc(len, GFP_KERNEL); memcpy_fromio(data, priv->base, len); data[len - 1] = '\0'; err = brcm_nvram_add_cells(priv, data, len); if (err) { dev_err(dev, ""Failed to add cells: %d\n"", err); return err; } kfree(data); return 0; }"
"static void set_vterm_palette(VTerm *vterm, long_u *rgb) { intindex = 0; VTermState*state = vterm_obtain_state(vterm); for (; index < 16; index++) { VTermColorcolor; color.red = (unsigned)(rgb[index] >> 16); color.green = (unsigned)(rgb[index] >> 8) & 255; color.blue = (unsigned)rgb[index] & 255; vterm_state_set_palette_color(state, index, &color); } }"
"void ip4_datagram_release_cb(struct sock *sk) { const struct inet_sock *inet = inet_sk(sk); const struct ip_options_rcu *inet_opt; __be32 daddr = inet->inet_daddr; struct flowi4 fl4; struct rtable *rt; if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0)) return; rcu_read_lock(); inet_opt = rcu_dereference(inet->inet_opt); if (inet_opt && inet_opt->opt.srr) daddr = inet_opt->opt.faddr; rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr, inet->inet_saddr, inet->inet_dport, inet->inet_sport, sk->sk_protocol, RT_CONN_FLAGS(sk), sk->sk_bound_dev_if); if (!IS_ERR(rt)) __sk_dst_set(sk, &rt->dst); rcu_read_unlock(); }"
"static GF_Err xbl_parse_report(GF_XBL_Parser *parser, GF_Err e, char *format, ...) { #ifndef GPAC_DISABLE_LOG if (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) { char szMsg[2048]; va_list args; va_start(args, format); vsprintf(szMsg, format, args); va_end(args); GF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[XBL Parsing] line %d - %s\n"", gf_xml_sax_get_line(parser->sax_parser), szMsg)); } #endif if (e) parser->last_error = e; return e; }"
"static GsfInfileTar * tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last) { const char *s = name; while (1) { const char *s0 = s; char *dirname; while (1) { if (*s == 0) { if (last && s != s0) break; else return dir; } if (*s == '/') break; s++; } dirname = g_strndup (s0, s - s0); while (*s == '/') s++; if (strcmp (dirname, ""."") != 0) { GsfInput *subdir = gsf_infile_child_by_name (GSF_INFILE (dir), dirname); if (subdir) { g_object_unref (subdir); dir = GSF_INFILE_TAR (subdir); } else dir = tar_create_dir (dir, dirname); } g_free (dirname); } }"
"opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters) { FILE *f = NULL; int w, h, prec; unsigned long offset; int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0; OPJ_COLOR_SPACE color_space; opj_volume_cmptparm_t cmptparm;  opj_volume_t * volume = NULL; char endian1, endian2, sign; char signtmp[32]; char temp[32]; opj_volume_comp_t *comp = NULL; DIR *dirp; struct dirent *direntp; char *tmp = NULL, *tmp2 = NULL, *point = NULL, *pgx = NULL; char tmpdirpath[MAX_PATH]; char dirpath[MAX_PATH]; char pattern[MAX_PATH]; char pgxfiles[MAX_SLICES][MAX_PATH]; int pgxslicepos[MAX_SLICES]; char tmpno[3]; numcomps = 1; color_space = CLRSPC_GRAY; sliceno = 0; maxvalue = 0; memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char)); memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t)); if ((tmp = strrchr(relpath, '-')) == NULL) { sliceno = 1; maxslice = 1; strcpy(pgxfiles[0], relpath); } else { strcpy(tmpdirpath, relpath); if ((tmp = strrchr(tmpdirpath, '/')) != NULL) { tmp++; *tmp = '\0'; strcpy(dirpath, tmpdirpath); } else { strcpy(dirpath, ""./""); } if ((tmp = strrchr(relpath, '/')) != NULL) { tmp++; } else { tmp = relpath; } if ((tmp2 = strrchr(tmp, '-')) != NULL) { *tmp2 = '\0'; } else { fprintf(stdout, ""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s"", tmp, relpath); return NULL; } strcpy(pattern, tmp); dirp = opendir(dirpath); if (dirp == NULL) { fprintf(stdout, ""[ERROR] Infile must be a .pgx file or a directory that contain pgx files""); return NULL; } while ((direntp = readdir(dirp)) != NULL) { if (strcmp(""."", direntp->d_name) == 0 || strcmp("".."", direntp->d_name) == 0) { continue; } if (((pgx = strstr(direntp->d_name, pattern)) != NULL) && ((tmp2 = strstr(direntp->d_name, "".pgx"")) != NULL)) { strcpy(tmp, dirpath); tmp = strcat(tmp, direntp->d_name); if ((tmp2 = strpbrk(direntp->d_name, ""0123456789"")) == NULL) { continue; } i = 0; while (tmp2 != NULL) { tmpno[i++] = *tmp2; point = tmp2; tmp2 = strpbrk(tmp2 + 1, ""0123456789""); } tmpno[i] = '\0'; if ((point = strpbrk(point, ""."")) == NULL) { break; } slicepos = atoi(tmpno); pgxslicepos[sliceno] = slicepos - 1; sliceno++; if (slicepos > maxslice) { maxslice = slicepos; } strcpy(pgxfiles[slicepos - 1], tmp); } } } if (!sliceno) { fprintf(stdout, ""[ERROR] No slices with this pattern founded !! Please check input volume name\n""); return NULL; } for (s = 0; s < sliceno; s++) { int pos = maxslice == sliceno ? s : pgxslicepos[s]; f = fopen(pgxfiles[pos], ""rb""); if (!f) { fprintf(stdout, ""[ERROR] Failed to open %s for reading !\n"", pgxfiles[s]); return NULL; } fprintf(stdout, ""[INFO] Loading %s \n"", pgxfiles[pos]); fseek(f, 0, SEEK_SET); fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1, &endian2, signtmp, &prec, temp, &w, temp, &h); i = 0; sign = '+'; while (signtmp[i] != '\0') { if (signtmp[i] == '-') { sign = '-'; } i++; } fgetc(f); if (endian1 == 'M' && endian2 == 'L') { cmptparm.bigendian = 1; } else if (endian2 == 'M' && endian1 == 'L') { cmptparm.bigendian = 0; } else { fprintf(stdout, ""[ERROR] Bad pgx header, please check input file\n""); fclose(f); return NULL; } if (s == 0) { cmptparm.x0 = parameters->volume_offset_x0; cmptparm.y0 = parameters->volume_offset_y0; cmptparm.z0 = parameters->volume_offset_z0; cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 : cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1; cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 : cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1; cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 : cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1; if (sign == '-') { cmptparm.sgnd = 1; } else { cmptparm.sgnd = 0; } cmptparm.prec = prec; cmptparm.bpp = prec; cmptparm.dcoffset = parameters->dcoffset; cmptparm.dx = parameters->subsampling_dx; cmptparm.dy = parameters->subsampling_dy; cmptparm.dz = parameters->subsampling_dz; volume = opj_volume_create(numcomps, &cmptparm, color_space); if (!volume) { fclose(f); return NULL; } volume->x0 = cmptparm.x0; volume->y0 = cmptparm.y0; volume->z0 = cmptparm.z0; volume->x1 = cmptparm.w; volume->y1 = cmptparm.h; volume->z1 = cmptparm.l; comp = &volume->comps[0]; } offset = w * h * s; for (i = 0; i < w * h; i++) { int v; if (comp->prec <= 8) { if (!comp->sgnd) { v = readuchar(f); } else { v = (char) readuchar(f); } } else if (comp->prec <= 16) { if (!comp->sgnd) { v = readushort(f, cmptparm.bigendian); } else { v = (short) readushort(f, cmptparm.bigendian); } } else { if (!comp->sgnd) { v = readuint(f, cmptparm.bigendian); } else { v = (int) readuint(f, cmptparm.bigendian); } } if (v > maxvalue) { maxvalue = v; } comp->data[i + offset] = v; } fclose(f); }  comp->bpp = int_floorlog2(maxvalue) + 1; if (sliceno != 1) { closedir(dirp); } return volume; }"
"static void t42_parse_font_matrix( T42_Face    face, T42_Loader  loader ) { T42_Parser  parser = &loader->parser; FT_Matrix*  matrix = &face->type1.font_matrix; FT_Vector*  offset = &face->type1.font_offset; FT_Face     root   = (FT_Face)&face->root; FT_Fixed    temp[6]; FT_Fixed    temp_scale; (void)T1_ToFixedArray( parser, 6, temp, 3 ); temp_scale = FT_ABS( temp[3] ); root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale ); if ( temp_scale != 0x10000L ) { temp[0] = FT_DivFix( temp[0], temp_scale ); temp[1] = FT_DivFix( temp[1], temp_scale ); temp[2] = FT_DivFix( temp[2], temp_scale ); temp[4] = FT_DivFix( temp[4], temp_scale ); temp[5] = FT_DivFix( temp[5], temp_scale ); temp[3] = 0x10000L; } matrix->xx = temp[0]; matrix->yx = temp[1]; matrix->xy = temp[2]; matrix->yy = temp[3]; offset->x = temp[4] >> 16; offset->y = temp[5] >> 16; }"
"ssize_t cpu_show_spectre_v2(struct device *dev, struct device_attribute *attr, char *buf) { struct seq_buf s; bool bcs, ccd; seq_buf_init(&s, buf, PAGE_SIZE - 1); bcs = security_ftr_enabled(SEC_FTR_BCCTRL_SERIALISED); ccd = security_ftr_enabled(SEC_FTR_COUNT_CACHE_DISABLED); if (bcs || ccd) { seq_buf_printf(&s, ""Mitigation: ""); if (bcs) seq_buf_printf(&s, ""Indirect branch serialisation (kernel only)""); if (bcs && ccd) seq_buf_printf(&s, "", ""); if (ccd) seq_buf_printf(&s, ""Indirect branch cache disabled""); } else if (count_cache_flush_type != COUNT_CACHE_FLUSH_NONE) { seq_buf_printf(&s, ""Mitigation: Software count cache flush""); if (count_cache_flush_type == COUNT_CACHE_FLUSH_HW) seq_buf_printf(&s, "" (hardware accelerated)""); } else if (btb_flush_enabled) { seq_buf_printf(&s, ""Mitigation: Branch predictor state flush""); } else { seq_buf_printf(&s, ""Vulnerable""); } seq_buf_printf(&s, ""\n""); return s.len; }"
"void dcinit() { strsize=0; strmaxsize=DCSTRSIZE; dcstr=calloc(DCSTRSIZE,1); dcptr=dcstr; }"
"static int p54u_load_firmware(struct ieee80211_hw *dev, struct usb_interface *intf) { struct usb_device *udev = interface_to_usbdev(intf); struct p54u_priv *priv = dev->priv; struct device *device = &udev->dev; int err, i; BUILD_BUG_ON(ARRAY_SIZE(p54u_fwlist) != __NUM_P54U_HWTYPES); init_completion(&priv->fw_wait_load); i = p54_find_type(priv); if (i < 0) return i; dev_info(&priv->udev->dev, ""Loading firmware file %s\n"", p54u_fwlist[i].fw); usb_get_dev(udev); err = request_firmware_nowait(THIS_MODULE, 1, p54u_fwlist[i].fw, device, GFP_KERNEL, priv, p54u_load_firmware_cb); if (err) { dev_err(&priv->udev->dev, ""(p54usb) cannot load firmware %s "" ""(%d)!\n"", p54u_fwlist[i].fw, err); usb_put_dev(udev); } return err; }"
"void read_stats_from_file(char from_file[]) { struct file_magic file_magic; struct file_activity *file_actlst = NULL; char rec_hdr_tmp[MAX_RECORD_HEADER_SIZE]; int curr = 1, i, p; int ifd, rtype; int rows, eosaf = TRUE, reset = FALSE; long cnt = 1; off_t fpos; rows = get_win_height(); check_file_actlst(&ifd, from_file, act, &file_magic, &file_hdr, &file_actlst, id_seq, FALSE, &endian_mismatch, &arch_64); allocate_structures(act); print_report_hdr(flags, &rectime, &file_hdr); do { do { if (read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[0], &file_hdr, arch_64, endian_mismatch, UEOF_STOP)) { return; } rtype = record_hdr[0].record_type; if ((rtype == R_RESTART) || (rtype == R_COMMENT)) { print_special_record(&record_hdr[0], flags + S_F_LOCAL_TIME, &tm_start, &tm_end, rtype, ifd, &rectime, NULL, from_file, 0, &file_magic, &file_hdr, act, &sar_fmt, endian_mismatch, arch_64); } else { read_file_stat_bunch(act, 0, ifd, file_hdr.sa_act_nr, file_actlst, endian_mismatch, arch_64, from_file, &file_magic, UEOF_STOP); if (sa_get_record_timestamp_struct(flags + S_F_LOCAL_TIME, &record_hdr[0], &rectime, NULL)) continue; } } while ((rtype == R_RESTART) || (rtype == R_COMMENT) || (tm_start.use && (datecmp(&rectime, &tm_start) < 0)) || (tm_end.use && (datecmp(&rectime, &tm_end) >=0))); copy_structures(act, id_seq, record_hdr, 2, 0); reset = TRUE; if ((fpos = lseek(ifd, 0, SEEK_CUR)) < 0) { perror(""lseek""); exit(2); } for (i = 0; i < NR_ACT; i++) { if (!id_seq[i]) continue; p = get_activity_position(act, id_seq[i], EXIT_IF_NOT_FOUND); if (!IS_SELECTED(act[p]->options)) continue; if (!HAS_MULTIPLE_OUTPUTS(act[p]->options)) { handle_curr_act_stats(ifd, fpos, &curr, &cnt, &eosaf, rows, act[p]->id, &reset, file_actlst, from_file, &file_magic, rec_hdr_tmp, endian_mismatch, arch_64); } else { unsigned int optf, msk; optf = act[p]->opt_flags; for (msk = 1; msk < 0x100; msk <<= 1) { if ((act[p]->opt_flags & 0xff) & msk) { act[p]->opt_flags &= (0xffffff00 + msk); handle_curr_act_stats(ifd, fpos, &curr, &cnt, &eosaf, rows, act[p]->id, &reset, file_actlst, from_file, &file_magic, rec_hdr_tmp, endian_mismatch, arch_64); act[p]->opt_flags = optf; } } } } if (!cnt) { do { eosaf = read_record_hdr(ifd, rec_hdr_tmp, &record_hdr[curr], &file_hdr, arch_64, endian_mismatch, UEOF_STOP); rtype = record_hdr[curr].record_type; if (!eosaf && (rtype != R_RESTART) && (rtype != R_COMMENT)) { read_file_stat_bunch(act, curr, ifd, file_hdr.sa_act_nr, file_actlst, endian_mismatch, arch_64, from_file, &file_magic, UEOF_STOP); } else if (!eosaf && (rtype == R_COMMENT)) { print_special_record(&record_hdr[curr], flags + S_F_LOCAL_TIME, &tm_start, &tm_end, R_COMMENT, ifd, &rectime, NULL, from_file, 0, &file_magic, &file_hdr, act, &sar_fmt, endian_mismatch, arch_64); } } while (!eosaf && (rtype != R_RESTART)); } if (!eosaf && (record_hdr[curr].record_type == R_RESTART)) { print_special_record(&record_hdr[curr], flags + S_F_LOCAL_TIME, &tm_start, &tm_end, R_RESTART, ifd, &rectime, NULL, from_file, 0, &file_magic, &file_hdr, act, &sar_fmt, endian_mismatch, arch_64); } } while (!eosaf); close(ifd); free(file_actlst); }"
"static int __p2m_set_entry(struct p2m_domain *p2m, gfn_t sgfn, unsigned int page_order, mfn_t smfn, p2m_type_t t, p2m_access_t a) { unsigned int level = 0; unsigned int target = 3 - (page_order / LPAE_SHIFT); lpae_t *entry, *table, orig_pte; int rc; bool removing_mapping = mfn_eq(smfn, INVALID_MFN); DECLARE_OFFSETS(offsets, gfn_to_gaddr(sgfn)); ASSERT(p2m_is_write_locked(p2m)); ASSERT(target > 0 && target <= 3); table = p2m_get_root_pointer(p2m, sgfn); if ( !table ) return -EINVAL; for ( level = P2M_ROOT_LEVEL; level < target; level++ ) { rc = p2m_next_level(p2m, removing_mapping, level, &table, offsets[level]); if ( rc == GUEST_TABLE_MAP_FAILED ) { rc = removing_mapping ?  0 : -ENOENT; goto out; } else if ( rc != GUEST_TABLE_NORMAL_PAGE ) break; } entry = table + offsets[level]; if ( level < target ) { lpae_t split_pte = *entry; ASSERT(p2m_is_superpage(*entry, level)); if ( !p2m_split_superpage(p2m, &split_pte, level, target, offsets) ) { p2m->stats.mappings[level]++; p2m_free_entry(p2m, split_pte, level); rc = -ENOMEM; goto out; } p2m_remove_pte(entry, p2m->clean_pte); p2m_force_tlb_flush_sync(p2m); p2m_write_pte(entry, split_pte, p2m->clean_pte); for ( ; level < target; level++ ) { rc = p2m_next_level(p2m, true, level, &table, offsets[level]); ASSERT(rc == GUEST_TABLE_NORMAL_PAGE || (rc == GUEST_TABLE_SUPER_PAGE && target < 3)); } entry = table + offsets[level]; } ASSERT(level == target); orig_pte = *entry; ASSERT(!p2m->mem_access_enabled || page_order == 0 || p2m->domain->is_dying); ASSERT(!mfn_eq(INVALID_MFN, smfn) || (a == p2m_access_rwx)); rc = p2m_mem_access_radix_set(p2m, sgfn, a); if ( rc ) goto out; if ( lpae_is_valid(orig_pte) ) p2m_remove_pte(entry, p2m->clean_pte); if ( removing_mapping ) p2m->need_flush |= !!lpae_is_valid(orig_pte); else { lpae_t pte = mfn_to_p2m_entry(smfn, t, a); if ( level < 3 ) pte.p2m.table = 0;  if ( lpae_is_valid(orig_pte) ) { if ( likely(!p2m->mem_access_enabled) || P2M_CLEAR_PERM(pte) != P2M_CLEAR_PERM(orig_pte) ) p2m_force_tlb_flush_sync(p2m); else p2m->need_flush = true; } else if ( !p2m_is_valid(orig_pte) )  p2m->stats.mappings[level]++; p2m_write_pte(entry, pte, p2m->clean_pte); p2m->max_mapped_gfn = gfn_max(p2m->max_mapped_gfn, gfn_add(sgfn, 1 << page_order)); p2m->lowest_mapped_gfn = gfn_min(p2m->lowest_mapped_gfn, sgfn); } if ( is_iommu_enabled(p2m->domain) && (lpae_is_valid(orig_pte) || lpae_is_valid(*entry)) ) { unsigned int flush_flags = 0; if ( lpae_is_valid(orig_pte) ) flush_flags |= IOMMU_FLUSHF_modified; if ( lpae_is_valid(*entry) ) flush_flags |= IOMMU_FLUSHF_added; rc = iommu_iotlb_flush(p2m->domain, _dfn(gfn_x(sgfn)), 1UL << page_order, flush_flags); } else rc = 0; if ( p2m_is_valid(orig_pte) && !mfn_eq(lpae_get_mfn(*entry), lpae_get_mfn(orig_pte)) ) p2m_free_entry(p2m, orig_pte, level); out: unmap_domain_page(table); return rc; }"
"Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst, int input_index) { DataType src_out = src->output_type(output_index); DataType dst_in = dst->input_type(input_index); if (!TypesCompatible(dst_in, src_out)) { return errors::InvalidArgument( ""Input "", input_index, "" of node "", dst->name(), "" was passed "", DataTypeString(src_out), "" from "", src->name(), "":"", output_index, "" incompatible with expected "", DataTypeString(dst_in), "".""); } g_->AddEdge(src, output_index, dst, input_index); return Status::OK(); }"
"static gboolean canonify_unencrypted_header(guchar *buff, guint32 *offset, guint32 buffsize) { const TOP_ELEMENT_CONTROL *t = canonifyTable; guint32 len; for (t = canonifyTable; t->element != NULL; t++) { len = *(t->length); if (t->required && *(t->element) == NULL) return FALSE; if (*(t->element) != NULL) { if (t->addtag) { buff[(*offset)++] = t->tag; (*offset) += encode_ber_len(&buff[*offset], len, 4); } if (t->truncate) { len = 3+2*get_ber_len_size(len); } if (buffsize < *offset + len) { return FALSE; } memcpy(&buff[*offset], *(t->element), len); (*offset) += len; if (t->addtag) { *(t->element) = NULL; } } } return TRUE; }"
"void *Sys_LoadDll( const char *name, qboolean useSystemLib ) { void *dllhandle = NULL; if ( useSystemLib ) { Com_Printf( ""Trying to load \""%s\""...\n"", name ); dllhandle = Sys_LoadLibrary( name ); if ( dllhandle ) return dllhandle; Com_Printf( ""%s(%s) failed: \""%s\""\n"", __FUNCTION__, name, Sys_LibraryError() ); } const char *binarypath = Sys_BinaryPath(); const char *basepath = Cvar_VariableString( ""fs_basepath"" ); if ( !*binarypath ) binarypath = "".""; const char *searchPaths[] = { binarypath, basepath, }; const size_t numPaths = ARRAY_LEN( searchPaths ); for ( size_t i = 0; i < numPaths; i++ ) { const char *libDir = searchPaths[i]; if ( !libDir[0] ) continue; Com_Printf( ""Trying to load \""%s\"" from \""%s\""...\n"", name, libDir ); char *fn = va( ""%s%c%s"", libDir, PATH_SEP, name ); dllhandle = Sys_LoadLibrary( fn ); if ( dllhandle ) return dllhandle; Com_Printf( ""%s(%s) failed: \""%s\""\n"", __FUNCTION__, fn, Sys_LibraryError() ); } return NULL; }"
"static void naludmx_create_hevc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar, Bool *has_hevc_base) { #ifndef GPAC_DISABLE_HEVC u32 i, count; u8 layer_id; Bool first = GF_TRUE; Bool first_lhvc = GF_TRUE; GF_HEVCConfig *cfg; GF_HEVCConfig *hvcc; GF_HEVCConfig *lvcc; u32 max_w, max_h, max_ew, max_eh; *has_hevc_base = GF_FALSE; max_w = max_h = 0; max_ew = max_eh = 0; sar->num = sar->den = 0; hvcc = gf_odf_hevc_cfg_new(); lvcc = gf_odf_hevc_cfg_new(); hvcc->nal_unit_size = ctx->nal_length; lvcc->nal_unit_size = ctx->nal_length; lvcc->is_lhvc = GF_TRUE; count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) { *has_hevc_base = GF_TRUE; break; } } count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) { *has_hevc_base = GF_TRUE; break; } } count = gf_list_count(ctx->vps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->vps, i); HEVC_VPS *vps = &ctx->hevc_state->vps[sl->id]; if (!i) { hvcc->avgFrameRate = lvcc->avgFrameRate = vps->rates[0].avg_pic_rate; hvcc->constantFrameRate = lvcc->constantFrameRate = vps->rates[0].constant_pic_rate_idc; hvcc->numTemporalLayers = lvcc->numTemporalLayers = vps->max_sub_layers; hvcc->temporalIdNested = lvcc->temporalIdNested = vps->temporal_id_nesting; } if (!ctx->analyze) naludmx_add_param_nalu((ctx->explicit || ! (*has_hevc_base) ) ? lvcc->param_array : hvcc->param_array, sl, GF_HEVC_NALU_VID_PARAM); } count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { Bool is_lhvc = GF_FALSE; GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); HEVC_SPS *sps = &ctx->hevc_state->sps[sl->id]; layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) *has_hevc_base = GF_TRUE; if (ctx->explicit || layer_id) { cfg = lvcc; is_lhvc = GF_TRUE; } else { cfg = hvcc; } if (first || (is_lhvc && first_lhvc) ) { cfg->configurationVersion = 1; cfg->profile_space = sps->ptl.profile_space; cfg->tier_flag = sps->ptl.tier_flag; cfg->profile_idc = sps->ptl.profile_idc; cfg->general_profile_compatibility_flags = sps->ptl.profile_compatibility_flag; cfg->progressive_source_flag = sps->ptl.general_progressive_source_flag; cfg->interlaced_source_flag = sps->ptl.general_interlaced_source_flag; cfg->non_packed_constraint_flag = sps->ptl.general_non_packed_constraint_flag; cfg->frame_only_constraint_flag = sps->ptl.general_frame_only_constraint_flag; cfg->constraint_indicator_flags = sps->ptl.general_reserved_44bits; cfg->level_idc = sps->ptl.level_idc; cfg->chromaFormat = sps->chroma_format_idc; cfg->luma_bit_depth = sps->bit_depth_luma; cfg->chroma_bit_depth = sps->bit_depth_chroma; ctx->interlaced = cfg->interlaced_source_flag ? GF_TRUE : GF_FALSE; if (sps->aspect_ratio_info_present_flag && sps->sar_width && sps->sar_height) { sar->num = sps->sar_width; sar->den = sps->sar_height; } if (ctx->notime && first && (!ctx->fps.num || !ctx->fps.den) && sps->has_timing_info && (sps->time_scale <= 1000*sps->num_units_in_tick) ) { ctx->cur_fps.num = sps->time_scale; ctx->cur_fps.den = sps->num_units_in_tick; if (!ctx->fps.num && ctx->dts==ctx->fps.den) ctx->dts = ctx->cur_fps.den; } ctx->fps = ctx->cur_fps; } first = GF_FALSE; if (is_lhvc) { first_lhvc = GF_FALSE; if (sps->width > max_ew) max_ew = sps->width; if (sps->height > max_eh) max_eh = sps->height; } else { if (sps->width > max_w) max_w = sps->width; if (sps->height > max_h) max_h = sps->height; } if (!ctx->analyze) naludmx_add_param_nalu(cfg->param_array, sl, GF_HEVC_NALU_SEQ_PARAM); } cfg = ctx->explicit ? lvcc : hvcc; count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); layer_id = ((sl->data[0] & 0x1) << 5) | (sl->data[1] >> 3); if (!layer_id) *has_hevc_base = GF_TRUE; if (!ctx->analyze) naludmx_add_param_nalu(layer_id ? lvcc->param_array : cfg->param_array, sl, GF_HEVC_NALU_PIC_PARAM); } *dsi = *dsi_enh = NULL; *dsi_size = *dsi_enh_size = 0; if (ctx->explicit || ! (*has_hevc_base) ) { naludmx_hevc_set_parall_type(ctx, lvcc); gf_odf_hevc_cfg_write(lvcc, dsi, dsi_size); *max_width = *max_enh_width = max_ew; *max_height = *max_enh_height = max_eh; } else { naludmx_hevc_set_parall_type(ctx, hvcc); gf_odf_hevc_cfg_write(hvcc, dsi, dsi_size); if (gf_list_count(lvcc->param_array) ) { naludmx_hevc_set_parall_type(ctx, lvcc); gf_odf_hevc_cfg_write(lvcc, dsi_enh, dsi_enh_size); } *max_width = max_w; *max_height = max_h; *max_enh_width = max_ew; *max_enh_height = max_eh; } count = gf_list_count(hvcc->param_array); for (i=0; i<count; i++) { GF_NALUFFParamArray *pa = gf_list_get(hvcc->param_array, i); gf_list_reset(pa->nalus); } count = gf_list_count(lvcc->param_array); for (i=0; i<count; i++) { GF_NALUFFParamArray *pa = gf_list_get(lvcc->param_array, i); gf_list_reset(pa->nalus); } gf_odf_hevc_cfg_del(hvcc); gf_odf_hevc_cfg_del(lvcc); #endif }"
"void SoftAVC::onQueueFilled(OMX_U32 ) { if (mSignalledError || mOutputPortSettingsChange != NONE) { return; } if (mEOSStatus == OUTPUT_FRAMES_FLUSHED) { return; } List<BufferInfo *> &inQueue = getPortQueue(kInputPortIndex); List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex); if (mHeadersDecoded) { drainAllOutputBuffers(false ); } H264SwDecRet ret = H264SWDEC_PIC_RDY; bool portWillReset = false; while ((mEOSStatus != INPUT_DATA_AVAILABLE || !inQueue.empty()) && outQueue.size() == kNumOutputBuffers) { if (mEOSStatus == INPUT_EOS_SEEN) { drainAllOutputBuffers(true ); return; } BufferInfo *inInfo = *inQueue.begin(); OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader; ++mPicId; OMX_BUFFERHEADERTYPE *header = new OMX_BUFFERHEADERTYPE; memset(header, 0, sizeof(OMX_BUFFERHEADERTYPE)); header->nTimeStamp = inHeader->nTimeStamp; header->nFlags = inHeader->nFlags; if (header->nFlags & OMX_BUFFERFLAG_EOS) { mEOSStatus = INPUT_EOS_SEEN; } mPicToHeaderMap.add(mPicId, header); inQueue.erase(inQueue.begin()); H264SwDecInput inPicture; H264SwDecOutput outPicture; memset(&inPicture, 0, sizeof(inPicture)); inPicture.dataLen = inHeader->nFilledLen; inPicture.pStream = inHeader->pBuffer + inHeader->nOffset; inPicture.picId = mPicId; inPicture.intraConcealmentMethod = 1; H264SwDecPicture decodedPicture; while (inPicture.dataLen > 0) { ret = H264SwDecDecode(mHandle, &inPicture, &outPicture); if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY || ret == H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY) { inPicture.dataLen -= (u32)(outPicture.pStrmCurrPos - inPicture.pStream); inPicture.pStream = outPicture.pStrmCurrPos; if (ret == H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY) { mHeadersDecoded = true; H264SwDecInfo decoderInfo; CHECK(H264SwDecGetInfo(mHandle, &decoderInfo) == H264SWDEC_OK); SoftVideoDecoderOMXComponent::CropSettingsMode cropSettingsMode = handleCropParams(decoderInfo); handlePortSettingsChange( &portWillReset, decoderInfo.picWidth, decoderInfo.picHeight, cropSettingsMode); } } else { if (portWillReset) { if (H264SwDecNextPicture(mHandle, &decodedPicture, 0) == H264SWDEC_PIC_RDY) { saveFirstOutputBuffer( decodedPicture.picId, (uint8_t *)decodedPicture.pOutputPicture); } } inPicture.dataLen = 0; if (ret < 0) { ALOGE(""Decoder failed: %d"", ret); notify(OMX_EventError, OMX_ErrorUndefined, ERROR_MALFORMED, NULL); mSignalledError = true; return; } } } inInfo->mOwnedByUs = false; notifyEmptyBufferDone(inHeader); if (portWillReset) { return; } if (mFirstPicture && !outQueue.empty()) { drainOneOutputBuffer(mFirstPictureId, mFirstPicture); delete[] mFirstPicture; mFirstPicture = NULL; mFirstPictureId = -1; } drainAllOutputBuffers(false ); } }"
"static int asn1_template_noexp_d2i(ASN1_VALUE **val, const unsigned char **in, long len, const ASN1_TEMPLATE *tt, char opt, ASN1_TLC *ctx) { int flags, aclass; int ret; const unsigned char *p, *q; if (!val) return 0; flags = tt->flags; aclass = flags & ASN1_TFLG_TAG_CLASS; p = *in; q = p; if (flags & ASN1_TFLG_SK_MASK) { int sktag, skaclass; char sk_eoc; if (flags & ASN1_TFLG_IMPTAG) { sktag = tt->tag; skaclass = aclass; } else { skaclass = V_ASN1_UNIVERSAL; if (flags & ASN1_TFLG_SET_OF) sktag = V_ASN1_SET; else sktag = V_ASN1_SEQUENCE; } ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL, &p, len, sktag, skaclass, opt, ctx); if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR); return 0; } else if (ret == -1) return -1; if (!*val) *val = (ASN1_VALUE *)sk_new_null(); else { STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val; ASN1_VALUE *vtmp; while (sk_ASN1_VALUE_num(sktmp) > 0) { vtmp = sk_ASN1_VALUE_pop(sktmp); ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item)); } } if (!*val) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE); goto err; } while (len > 0) { ASN1_VALUE *skfield; q = p; if (asn1_check_eoc(&p, len)) { if (!sk_eoc) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_UNEXPECTED_EOC); goto err; } len -= p - q; sk_eoc = 0; break; } skfield = NULL; if (!ASN1_item_ex_d2i(&skfield, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR); goto err; } len -= p - q; if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE); goto err; } } if (sk_eoc) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC); goto err; } } else if (flags & ASN1_TFLG_IMPTAG) { ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt, ctx); if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR); goto err; } else if (ret == -1) return -1; } else { ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item), -1, 0, opt, ctx); if (!ret) { ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR); goto err; } else if (ret == -1) return -1; } *in = p; return 1; err: ASN1_template_free(val, tt); return 0; }"
"static int tc_new_tfilter(struct sk_buff *skb, struct nlmsghdr *n, struct netlink_ext_ack *extack) { struct net *net = sock_net(skb->sk); struct nlattr *tca[TCA_MAX + 1]; char name[IFNAMSIZ]; struct tcmsg *t; u32 protocol; u32 prio; bool prio_allocate; u32 parent; u32 chain_index; struct Qdisc *q = NULL; struct tcf_chain_info chain_info; struct tcf_chain *chain = NULL; struct tcf_block *block; struct tcf_proto *tp; unsigned long cl; void *fh; int err; int tp_created; bool rtnl_held = false; u32 flags; if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) return -EPERM; replay: tp_created = 0; err = nlmsg_parse_deprecated(n, sizeof(*t), tca, TCA_MAX, rtm_tca_policy, extack); if (err < 0) return err; t = nlmsg_data(n); protocol = TC_H_MIN(t->tcm_info); prio = TC_H_MAJ(t->tcm_info); prio_allocate = false; parent = t->tcm_parent; tp = NULL; cl = 0; block = NULL; flags = 0; if (prio == 0) { if (n->nlmsg_flags & NLM_F_CREATE) { prio = TC_H_MAKE(0x80000000U, 0U); prio_allocate = true; } else { NL_SET_ERR_MSG(extack, ""Invalid filter command with priority of zero""); return -ENOENT; } } err = __tcf_qdisc_find(net, &q, &parent, t->tcm_ifindex, false, extack); if (err) return err; if (tcf_proto_check_kind(tca[TCA_KIND], name)) { NL_SET_ERR_MSG(extack, ""Specified TC filter name too long""); err = -EINVAL; goto errout; } if (rtnl_held || (q && !(q->ops->cl_ops->flags & QDISC_CLASS_OPS_DOIT_UNLOCKED)) || !tcf_proto_is_unlocked(name)) { rtnl_held = true; rtnl_lock(); } err = __tcf_qdisc_cl_find(q, parent, &cl, t->tcm_ifindex, extack); if (err) goto errout; block = __tcf_block_find(net, q, cl, t->tcm_ifindex, t->tcm_block_index, extack); if (IS_ERR(block)) { err = PTR_ERR(block); goto errout; } block->classid = parent; chain_index = tca[TCA_CHAIN] ? nla_get_u32(tca[TCA_CHAIN]) : 0; if (chain_index > TC_ACT_EXT_VAL_MASK) { NL_SET_ERR_MSG(extack, ""Specified chain index exceeds upper limit""); err = -EINVAL; goto errout; } chain = tcf_chain_get(block, chain_index, true); if (!chain) { NL_SET_ERR_MSG(extack, ""Cannot create specified filter chain""); err = -ENOMEM; goto errout; } mutex_lock(&chain->filter_chain_lock); tp = tcf_chain_tp_find(chain, &chain_info, protocol, prio, prio_allocate); if (IS_ERR(tp)) { NL_SET_ERR_MSG(extack, ""Filter with specified priority/protocol not found""); err = PTR_ERR(tp); goto errout_locked; } if (tp == NULL) { struct tcf_proto *tp_new = NULL; if (chain->flushing) { err = -EAGAIN; goto errout_locked; } if (tca[TCA_KIND] == NULL || !protocol) { NL_SET_ERR_MSG(extack, ""Filter kind and protocol must be specified""); err = -EINVAL; goto errout_locked; } if (!(n->nlmsg_flags & NLM_F_CREATE)) { NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); err = -ENOENT; goto errout_locked; } if (prio_allocate) prio = tcf_auto_prio(tcf_chain_tp_prev(chain, &chain_info)); mutex_unlock(&chain->filter_chain_lock); tp_new = tcf_proto_create(name, protocol, prio, chain, rtnl_held, extack); if (IS_ERR(tp_new)) { err = PTR_ERR(tp_new); goto errout_tp; } tp_created = 1; tp = tcf_chain_tp_insert_unique(chain, tp_new, protocol, prio, rtnl_held); if (IS_ERR(tp)) { err = PTR_ERR(tp); goto errout_tp; } } else { mutex_unlock(&chain->filter_chain_lock); } if (tca[TCA_KIND] && nla_strcmp(tca[TCA_KIND], tp->ops->kind)) { NL_SET_ERR_MSG(extack, ""Specified filter kind does not match existing one""); err = -EINVAL; goto errout; } fh = tp->ops->get(tp, t->tcm_handle); if (!fh) { if (!(n->nlmsg_flags & NLM_F_CREATE)) { NL_SET_ERR_MSG(extack, ""Need both RTM_NEWTFILTER and NLM_F_CREATE to create a new filter""); err = -ENOENT; goto errout; } } else if (n->nlmsg_flags & NLM_F_EXCL) { tfilter_put(tp, fh); NL_SET_ERR_MSG(extack, ""Filter already exists""); err = -EEXIST; goto errout; } if (chain->tmplt_ops && chain->tmplt_ops != tp->ops) { NL_SET_ERR_MSG(extack, ""Chain template is set to a different filter kind""); err = -EINVAL; goto errout; } if (!(n->nlmsg_flags & NLM_F_CREATE)) flags |= TCA_ACT_FLAGS_REPLACE; if (!rtnl_held) flags |= TCA_ACT_FLAGS_NO_RTNL; err = tp->ops->change(net, skb, tp, cl, t->tcm_handle, tca, &fh, flags, extack); if (err == 0) { tfilter_notify(net, skb, n, tp, block, q, parent, fh, RTM_NEWTFILTER, false, rtnl_held); tfilter_put(tp, fh); if (q) q->flags &= ~TCQ_F_CAN_BYPASS; } errout: if (err && tp_created) tcf_chain_tp_delete_empty(chain, tp, rtnl_held, NULL); errout_tp: if (chain) { if (tp && !IS_ERR(tp)) tcf_proto_put(tp, rtnl_held, NULL); if (!tp_created) tcf_chain_put(chain); } tcf_block_release(q, block, rtnl_held); if (rtnl_held) rtnl_unlock(); if (err == -EAGAIN) { rtnl_held = true; goto replay; } return err; errout_locked: mutex_unlock(&chain->filter_chain_lock); goto errout; }"
"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli( const void *buf, pj_size_t length) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; PJ_ASSERT_RETURN(buf, PJ_EINVAL); PJ_ASSERT_RETURN(length >= 12, PJ_ETOOSMALL); if (hdr->pt != RTCP_PSFB || hdr->count != 1) return PJ_ENOTFOUND; return PJ_SUCCESS; }"
"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct ion_client *client = filp->private_data; struct ion_device *dev = client->dev; struct ion_handle *cleanup_handle = NULL; int ret = 0; unsigned int dir; union { struct ion_fd_data fd; struct ion_allocation_data allocation; struct ion_handle_data handle; struct ion_custom_data custom; } data; dir = ion_ioctl_dir(cmd); if (_IOC_SIZE(cmd) > sizeof(data)) return -EINVAL; if (dir & _IOC_WRITE) if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd))) return -EFAULT; switch (cmd) { case ION_IOC_ALLOC: { struct ion_handle *handle; handle = ion_alloc(client, data.allocation.len, data.allocation.align, data.allocation.heap_id_mask, data.allocation.flags); if (IS_ERR(handle)) return PTR_ERR(handle); data.allocation.handle = handle->id; cleanup_handle = handle; break; } case ION_IOC_FREE: { struct ion_handle *handle; handle = ion_handle_get_by_id(client, data.handle.handle); if (IS_ERR(handle)) return PTR_ERR(handle); ion_free(client, handle); ion_handle_put(handle); break; } case ION_IOC_SHARE: case ION_IOC_MAP: { struct ion_handle *handle; handle = ion_handle_get_by_id(client, data.handle.handle); if (IS_ERR(handle)) return PTR_ERR(handle); data.fd.fd = ion_share_dma_buf_fd(client, handle); ion_handle_put(handle); if (data.fd.fd < 0) ret = data.fd.fd; break; } case ION_IOC_IMPORT: { struct ion_handle *handle; handle = ion_import_dma_buf_fd(client, data.fd.fd); if (IS_ERR(handle)) ret = PTR_ERR(handle); else data.handle.handle = handle->id; break; } case ION_IOC_SYNC: { ret = ion_sync_for_device(client, data.fd.fd); break; } case ION_IOC_CUSTOM: { if (!dev->custom_ioctl) return -ENOTTY; ret = dev->custom_ioctl(client, data.custom.cmd, data.custom.arg); break; } default: return -ENOTTY; } if (dir & _IOC_READ) { if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) { if (cleanup_handle) ion_free(client, cleanup_handle); return -EFAULT; } } return ret; }"
"int WavpackSetConfiguration64 (WavpackContext *wpc, WavpackConfig *config, int64_t total_samples, const unsigned char *chan_ids) { uint32_t flags, bps = 0; uint32_t chan_mask = config->channel_mask; int num_chans = config->num_channels; int i; wpc->stream_version = (config->flags & CONFIG_COMPATIBLE_WRITE) ? CUR_STREAM_VERS : MAX_STREAM_VERS; if ((config->qmode & QMODE_DSD_AUDIO) && config->bytes_per_sample == 1 && config->bits_per_sample == 8) { #ifdef ENABLE_DSD wpc->dsd_multiplier = 1; flags = DSD_FLAG; for (i = 14; i >= 0; --i) if (config->sample_rate % sample_rates [i] == 0) { int divisor = config->sample_rate / sample_rates [i]; if (divisor && (divisor & (divisor - 1)) == 0) { config->sample_rate /= divisor; wpc->dsd_multiplier = divisor; break; } } if (config->flags & CONFIG_HYBRID_FLAG) { strcpy (wpc->error_message, ""hybrid mode not available for DSD!""); return FALSE; } config->flags &= (CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS); config->float_norm_exp = config->xmode = 0; #else strcpy (wpc->error_message, ""libwavpack not configured for DSD!""); return FALSE; #endif } else flags = config->bytes_per_sample - 1; wpc->total_samples = total_samples; wpc->config.sample_rate = config->sample_rate; wpc->config.num_channels = config->num_channels; wpc->config.channel_mask = config->channel_mask; wpc->config.bits_per_sample = config->bits_per_sample; wpc->config.bytes_per_sample = config->bytes_per_sample; wpc->config.block_samples = config->block_samples; wpc->config.flags = config->flags; wpc->config.qmode = config->qmode; if (config->flags & CONFIG_VERY_HIGH_FLAG) wpc->config.flags |= CONFIG_HIGH_FLAG; for (i = 0; i < 15; ++i) if (wpc->config.sample_rate == sample_rates [i]) break; flags |= i << SRATE_LSB; if (!(flags & DSD_FLAG)) { if (config->float_norm_exp) { wpc->config.float_norm_exp = config->float_norm_exp; wpc->config.flags |= CONFIG_FLOAT_DATA; flags |= FLOAT_DATA; } else flags |= ((config->bytes_per_sample * 8) - config->bits_per_sample) << SHIFT_LSB; if (config->flags & CONFIG_HYBRID_FLAG) { flags |= HYBRID_FLAG | HYBRID_BITRATE | HYBRID_BALANCE; if (!(wpc->config.flags & CONFIG_SHAPE_OVERRIDE)) { wpc->config.flags |= CONFIG_HYBRID_SHAPE | CONFIG_AUTO_SHAPING; flags |= HYBRID_SHAPE | NEW_SHAPING; } else if (wpc->config.flags & CONFIG_HYBRID_SHAPE) { wpc->config.shaping_weight = config->shaping_weight; flags |= HYBRID_SHAPE | NEW_SHAPING; } if (wpc->config.flags & (CONFIG_CROSS_DECORR | CONFIG_OPTIMIZE_WVC)) flags |= CROSS_DECORR; if (config->flags & CONFIG_BITRATE_KBPS) { bps = (uint32_t) floor (config->bitrate * 256000.0 / config->sample_rate / config->num_channels + 0.5); if (bps > (64 << 8)) bps = 64 << 8; } else bps = (uint32_t) floor (config->bitrate * 256.0 + 0.5); } else flags |= CROSS_DECORR; if (!(config->flags & CONFIG_JOINT_OVERRIDE) || (config->flags & CONFIG_JOINT_STEREO)) flags |= JOINT_STEREO; if (config->flags & CONFIG_CREATE_WVC) wpc->wvc_flag = TRUE; } if (chan_ids) { int lastchan = 0, mask_copy = chan_mask; if ((int) strlen ((char *) chan_ids) > num_chans) {                      strcpy (wpc->error_message, ""chan_ids longer than num channels!""); return FALSE; } while (*chan_ids) if (*chan_ids <= 32 && *chan_ids > lastchan && (mask_copy & (1 << (*chan_ids-1)))) { mask_copy &= ~(1 << (*chan_ids-1)); lastchan = *chan_ids++; } else break; for (i = 0; chan_ids [i]; i++) if (chan_ids [i] != 0xff) { wpc->channel_identities = (unsigned char *) strdup ((char *) chan_ids); break; } } for (wpc->current_stream = 0; num_chans; wpc->current_stream++) { WavpackStream *wps = malloc (sizeof (WavpackStream)); unsigned char left_chan_id = 0, right_chan_id = 0; int pos, chans = 1; wpc->streams = realloc (wpc->streams, (wpc->current_stream + 1) * sizeof (wpc->streams [0])); wpc->streams [wpc->current_stream] = wps; CLEAR (*wps); if (chan_mask) for (pos = 0; pos < 32; ++pos) if (chan_mask & (1 << pos)) { if (left_chan_id) { right_chan_id = pos + 1; break; } else { chan_mask &= ~(1 << pos); left_chan_id = pos + 1; } } while (!right_chan_id && chan_ids && *chan_ids) if (left_chan_id) right_chan_id = *chan_ids; else left_chan_id = *chan_ids++; if (!left_chan_id) left_chan_id = right_chan_id = 0xff; else if (!right_chan_id) right_chan_id = 0xff; if (num_chans >= 2) { if ((config->flags & CONFIG_PAIR_UNDEF_CHANS) && left_chan_id == 0xff && right_chan_id == 0xff) chans = 2; else for (i = 0; i < NUM_STEREO_PAIRS; ++i) if ((left_chan_id == stereo_pairs [i].a && right_chan_id == stereo_pairs [i].b) || (left_chan_id == stereo_pairs [i].b && right_chan_id == stereo_pairs [i].a)) { if (right_chan_id <= 32 && (chan_mask & (1 << (right_chan_id-1)))) chan_mask &= ~(1 << (right_chan_id-1)); else if (chan_ids && *chan_ids == right_chan_id) chan_ids++; chans = 2; break; } } num_chans -= chans; if (num_chans && wpc->current_stream == NEW_MAX_STREAMS - 1) break; memcpy (wps->wphdr.ckID, ""wvpk"", 4); wps->wphdr.ckSize = sizeof (WavpackHeader) - 8; SET_TOTAL_SAMPLES (wps->wphdr, wpc->total_samples); wps->wphdr.version = wpc->stream_version; wps->wphdr.flags = flags; wps->bits = bps; if (!wpc->current_stream) wps->wphdr.flags |= INITIAL_BLOCK; if (!num_chans) wps->wphdr.flags |= FINAL_BLOCK; if (chans == 1) { wps->wphdr.flags &= ~(JOINT_STEREO | CROSS_DECORR | HYBRID_BALANCE); wps->wphdr.flags |= MONO_FLAG; } } wpc->num_streams = wpc->current_stream; wpc->current_stream = 0; if (num_chans) { strcpy (wpc->error_message, ""too many channels!""); return FALSE; } if (config->flags & CONFIG_EXTRA_MODE) wpc->config.xmode = config->xmode ? config->xmode : 1; return TRUE; }"
"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) { char uint32_buffer[5]; Trackage track = {0}; AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0); if (mvhdAtom != NULL) { APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom); fprintf(stdout, ""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate "" ""(*=approximate)\n"", movie_info.seconds, secsTOtime(movie_info.seconds), movie_info.simple_bitrate_calc); if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""  Presentation Creation Date (UTC):     %s\n"", APar_extract_UTC(movie_info.creation_time)); fprintf(stdout, ""  Presentation Modification Date (UTC): %s\n"", APar_extract_UTC(movie_info.modified_time)); } } AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0); if (iodsAtom != NULL) { movie_info.contains_iods = true; APar_Extract_iods_Info(isofile, iodsAtom); } if (optional_output & SHOW_TRACK_INFO) { APar_TrackLevelInfo(&track, NULL);                                 fprintf( stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks); fprintf(stdout, ""Trk  Type  Handler                    Kind  Lang  Bytes\n""); if (track.total_tracks > 0) { while (track.total_tracks > track.track_num) { track.track_num += 1; TrackInfo track_info = {0}; APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info); uint16_t more_whitespace = purge_extraneous_characters(track_info.track_hdlr_name); if (strlen(track_info.track_hdlr_name) == 0) { memcpy(track_info.track_hdlr_name, ""[none listed]"", 13); } fprintf(stdout, ""%u    %s  %s"", track.track_num, uint32tochar4(track_info.track_type, uint32_buffer), track_info.track_hdlr_name); uint16_t handler_len = strlen(track_info.track_hdlr_name); if (handler_len < 25 + more_whitespace) { for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) { fprintf(stdout, "" ""); } } fprintf(stdout, ""  %s  %s   %"" PRIu64, uint32tochar4(track_info.track_codec, uint32_buffer), track_info.unpacked_lang, track_info.sample_aggregate); if (track_info.encoder_name[0] != 0 && track_info.contains_esds) { purge_extraneous_characters(track_info.encoder_name); fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name); } if (track_info.type_of_track & DRM_PROTECTED_TRACK) { fprintf(stdout, "" (protected %s)"", uint32tochar4(track_info.protected_codec, uint32_buffer)); } fprintf(stdout, ""\n""); if (track_info.type_of_track & VIDEO_TRACK || track_info.type_of_track & AUDIO_TRACK) { APar_Print_TrackDetails(&track_info); } if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""       Creation Date (UTC):     %s\n"", APar_extract_UTC(track_info.creation_time)); fprintf(stdout, ""       Modification Date (UTC): %s\n"", APar_extract_UTC(track_info.modified_time)); } } } } }"
"static ssize_t fuse_dev_splice_read(struct file *in, loff_t *ppos, struct pipe_inode_info *pipe, size_t len, unsigned int flags) { int ret; int page_nr = 0; int do_wakeup = 0; struct pipe_buffer *bufs; struct fuse_copy_state cs; struct fuse_conn *fc = fuse_get_conn(in); if (!fc) return -EPERM; bufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL); if (!bufs) return -ENOMEM; fuse_copy_init(&cs, 1, NULL); cs.pipebufs = bufs; cs.pipe = pipe; ret = fuse_dev_do_read(fc, in, &cs, len); if (ret < 0) goto out; ret = 0; pipe_lock(pipe); if (!pipe->readers) { send_sig(SIGPIPE, current, 0); if (!ret) ret = -EPIPE; goto out_unlock; } if (pipe->nrbufs + cs.nr_segs > pipe->buffers) { ret = -EIO; goto out_unlock; } while (page_nr < cs.nr_segs) { int newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1); struct pipe_buffer *buf = pipe->bufs + newbuf; buf->page = bufs[page_nr].page; buf->offset = bufs[page_nr].offset; buf->len = bufs[page_nr].len; buf->ops = &nosteal_pipe_buf_ops; pipe->nrbufs++; page_nr++; ret += buf->len; if (pipe->files) do_wakeup = 1; } out_unlock: pipe_unlock(pipe); if (do_wakeup) { smp_mb(); if (waitqueue_active(&pipe->wait)) wake_up_interruptible(&pipe->wait); kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN); } out: for (; page_nr < cs.nr_segs; page_nr++) page_cache_release(bufs[page_nr].page); kfree(bufs); return ret; }"
"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si) { s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if (pps_id > 255) return -1; si->pps = &avc->pps[pps_id]; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id]; if (!si->sps->log2_max_frame_num) return -2; avc->sps_active_idx = si->pps->sps_id; avc->pps_active_idx = pps_id; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; si->bottom_field_flag = 0; if (!si->sps->frame_mbs_only_flag) { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } if (si->slice_type % 5 == GF_AVC_TYPE_B) { gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag""); } num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1; num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1; if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) { Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag""); if (num_ref_idx_active_override_flag) { num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1""); if (si->slice_type % 5 == GF_AVC_TYPE_B) { num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1""); } } } if (si->nal_unit_type == 20 || si->nal_unit_type == 21) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n"")); assert(0); return -1; } else { ref_pic_list_modification(bs, si->slice_type); } if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP)) || (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) { pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1); } if (si->nal_ref_idc != 0) { dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE)); } if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) { gf_bs_read_ue_log(bs, ""cabac_init_idc""); } gf_bs_read_se(bs); if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) { if (si->slice_type % 5 == GF_AVC_TYPE_SP) { gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag""); } gf_bs_read_se_log(bs, ""slice_qs_delta""); } if (si->pps->deblocking_filter_control_present_flag) { if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) { gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2""); gf_bs_read_se_log(bs, ""slice_beta_offset_div2""); } } if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) { gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle""); } return 0; }"
"int ovl_setattr(struct dentry *dentry, struct iattr *attr) { int err; struct dentry *upperdentry; err = ovl_want_write(dentry); if (err) goto out; upperdentry = ovl_dentry_upper(dentry); if (upperdentry) { mutex_lock(&upperdentry->d_inode->i_mutex); err = notify_change(upperdentry, attr, NULL); mutex_unlock(&upperdentry->d_inode->i_mutex); } else { err = ovl_copy_up_last(dentry, attr, false); } ovl_drop_write(dentry); out: return err; }"
"static void suboption(struct Curl_easy *data) { struct curl_slist *v; unsigned char temp[2048]; ssize_t bytes_written; size_t len; int err; char varname[128] = """"; char varval[128] = """"; struct TELNET *tn = data->req.p.telnet; struct connectdata *conn = data->conn; printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn) + 2); switch(CURL_SB_GET(tn)) { case CURL_TELOPT_TTYPE: len = strlen(tn->subopt_ttype) + 4 + 2; msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c%s%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_TTYPE, CURL_TELQUAL_IS, tn->subopt_ttype, CURL_IAC, CURL_SE); bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; case CURL_TELOPT_XDISPLOC: len = strlen(tn->subopt_xdisploc) + 4 + 2; msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c%s%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_XDISPLOC, CURL_TELQUAL_IS, tn->subopt_xdisploc, CURL_IAC, CURL_SE); bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; case CURL_TELOPT_NEW_ENVIRON: msnprintf((char *)temp, sizeof(temp), ""%c%c%c%c"", CURL_IAC, CURL_SB, CURL_TELOPT_NEW_ENVIRON, CURL_TELQUAL_IS); len = 4; for(v = tn->telnet_vars; v; v = v->next) { size_t tmplen = (strlen(v->data) + 1); if(len + tmplen < (int)sizeof(temp)-6) { if(sscanf(v->data, ""%127[^,],%127s"", varname, varval)) { msnprintf((char *)&temp[len], sizeof(temp) - len, ""%c%s%c%s"", CURL_NEW_ENV_VAR, varname, CURL_NEW_ENV_VALUE, varval); len += tmplen; } } } msnprintf((char *)&temp[len], sizeof(temp) - len, ""%c%c"", CURL_IAC, CURL_SE); len += 2; bytes_written = swrite(conn->sock[FIRSTSOCKET], temp, len); if(bytes_written < 0) { err = SOCKERRNO; failf(data,""Sending data failed (%d)"",err); } printsub(data, '>', &temp[2], len-2); break; } return; }"
"void remap_struct(unsigned int gtypes_nr[], unsigned int ftypes_nr[], void *ps, unsigned int f_size, unsigned int g_size) { int d; if (MAP_SIZE(ftypes_nr) > f_size) return; d = gtypes_nr[0] - ftypes_nr[0]; if (d) { memmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH, ((char *) ps) + ftypes_nr[0] * ULL_ALIGNMENT_WIDTH, MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH, g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH)); if (d > 0) { memset(((char *) ps) + ftypes_nr[0] * ULL_ALIGNMENT_WIDTH, 0, d * ULL_ALIGNMENT_WIDTH); } } d = gtypes_nr[1] - ftypes_nr[1]; if (d) { memmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + gtypes_nr[1] * UL_ALIGNMENT_WIDTH, ((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + ftypes_nr[1] * UL_ALIGNMENT_WIDTH, MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH - ftypes_nr[1] * UL_ALIGNMENT_WIDTH, g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH - gtypes_nr[1] * UL_ALIGNMENT_WIDTH)); if (d > 0) { memset(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + ftypes_nr[1] * UL_ALIGNMENT_WIDTH, 0, d * UL_ALIGNMENT_WIDTH); } } d = gtypes_nr[2] - ftypes_nr[2]; if (d) { memmove(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + gtypes_nr[1] * UL_ALIGNMENT_WIDTH + gtypes_nr[2] * U_ALIGNMENT_WIDTH, ((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + gtypes_nr[1] * UL_ALIGNMENT_WIDTH + ftypes_nr[2] * U_ALIGNMENT_WIDTH, MINIMUM(f_size - ftypes_nr[0] * ULL_ALIGNMENT_WIDTH - ftypes_nr[1] * UL_ALIGNMENT_WIDTH - ftypes_nr[2] * U_ALIGNMENT_WIDTH, g_size - gtypes_nr[0] * ULL_ALIGNMENT_WIDTH - gtypes_nr[1] * UL_ALIGNMENT_WIDTH - gtypes_nr[2] * U_ALIGNMENT_WIDTH)); if (d > 0) { memset(((char *) ps) + gtypes_nr[0] * ULL_ALIGNMENT_WIDTH + gtypes_nr[1] * UL_ALIGNMENT_WIDTH + ftypes_nr[2] * U_ALIGNMENT_WIDTH, 0, d * U_ALIGNMENT_WIDTH); } } }"
"Function *ESTreeIRGen::genGeneratorFunction( Identifier originalName, Variable *lazyClosureAlias, ESTree::FunctionLikeNode *functionNode) { assert(functionNode && ""Function AST cannot be null""); auto *outerFn = Builder.createGeneratorFunction( originalName, Function::DefinitionKind::ES5Function, ESTree::isStrict(functionNode->strictness), nullptr); auto *innerFn = genES5Function( genAnonymousLabelName(originalName.isValid() ? originalName.str() : """"), lazyClosureAlias, functionNode, true); { FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()}; emitFunctionPrologue( functionNode, Builder.createBasicBlock(outerFn), InitES5CaptureState::Yes, DoEmitParameters::No); auto *gen = Builder.createCreateGeneratorInst(innerFn); if (!hasSimpleParams(functionNode)) { Value *next = Builder.createLoadPropertyInst(gen, ""next""); Builder.createCallInst(next, gen, {}); } emitFunctionEpilogue(gen); } return outerFn; }"
"static void nfs_printfh(netdissect_options *ndo, register const uint32_t *dp, const u_int len) { my_fsid fsid; uint32_t ino; const char *sfsname = NULL; char *spacep; if (ndo->ndo_uflag) { u_int i; char const *sep = """"; ND_PRINT((ndo, "" fh["")); for (i=0; i<len; i++) { ND_PRINT((ndo, ""%s%x"", sep, dp[i])); sep = "":""; } ND_PRINT((ndo, ""]"")); return; } Parse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0); if (sfsname) { static char temp[NFSX_V3FHMAX+1]; strncpy(temp, sfsname, NFSX_V3FHMAX); temp[sizeof(temp) - 1] = '\0'; spacep = strchr(temp, ' '); if (spacep) *spacep = '\0'; ND_PRINT((ndo, "" fh %s/"", temp)); } else { ND_PRINT((ndo, "" fh %d,%d/"", fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor)); } if(fsid.Fsid_dev.Minor == 257) ND_PRINT((ndo, ""%s"", fsid.Opaque_Handle)); else ND_PRINT((ndo, ""%ld"", (long) ino)); }"
"static bfd_boolean process_mips_specific (FILE * file) { Elf_Internal_Dyn * entry; Elf_Internal_Shdr *sect = NULL; size_t liblist_offset = 0; size_t liblistno = 0; size_t conflictsno = 0; size_t options_offset = 0; size_t conflicts_offset = 0; size_t pltrelsz = 0; size_t pltrel = 0; bfd_vma pltgot = 0; bfd_vma mips_pltgot = 0; bfd_vma jmprel = 0; bfd_vma local_gotno = 0; bfd_vma gotsym = 0; bfd_vma symtabno = 0; bfd_boolean res = TRUE; if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL, display_mips_gnu_attribute)) res = FALSE; sect = find_section ("".MIPS.abiflags""); if (sect != NULL) { Elf_External_ABIFlags_v0 *abiflags_ext; Elf_Internal_ABIFlags_v0 abiflags_in; if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size) { error (_(""Corrupt MIPS ABI Flags section.\n"")); res = FALSE; } else { abiflags_ext = get_data (NULL, file, sect->sh_offset, 1, sect->sh_size, _(""MIPS ABI Flags section"")); if (abiflags_ext) { abiflags_in.version = BYTE_GET (abiflags_ext->version); abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level); abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev); abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size); abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size); abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size); abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi); abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext); abiflags_in.ases = BYTE_GET (abiflags_ext->ases); abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1); abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2); printf (""\nMIPS ABI Flags Version: %d\n"", abiflags_in.version); printf (""\nISA: MIPS%d"", abiflags_in.isa_level); if (abiflags_in.isa_rev > 1) printf (""r%d"", abiflags_in.isa_rev); printf (""\nGPR size: %d"", get_mips_reg_size (abiflags_in.gpr_size)); printf (""\nCPR1 size: %d"", get_mips_reg_size (abiflags_in.cpr1_size)); printf (""\nCPR2 size: %d"", get_mips_reg_size (abiflags_in.cpr2_size)); fputs (""\nFP ABI: "", stdout); print_mips_fp_abi_value (abiflags_in.fp_abi); fputs (""ISA Extension: "", stdout); print_mips_isa_ext (abiflags_in.isa_ext); fputs (""\nASEs:"", stdout); print_mips_ases (abiflags_in.ases); printf (""\nFLAGS 1: %8.8lx"", abiflags_in.flags1); printf (""\nFLAGS 2: %8.8lx"", abiflags_in.flags2); fputc ('\n', stdout); free (abiflags_ext); } } } if (dynamic_section == NULL) return res; for (entry = dynamic_section; entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL; ++entry) switch (entry->d_tag) { case DT_MIPS_LIBLIST: liblist_offset = offset_from_vma (file, entry->d_un.d_val, liblistno * sizeof (Elf32_External_Lib)); break; case DT_MIPS_LIBLISTNO: liblistno = entry->d_un.d_val; break; case DT_MIPS_OPTIONS: options_offset = offset_from_vma (file, entry->d_un.d_val, 0); break; case DT_MIPS_CONFLICT: conflicts_offset = offset_from_vma (file, entry->d_un.d_val, conflictsno * sizeof (Elf32_External_Conflict)); break; case DT_MIPS_CONFLICTNO: conflictsno = entry->d_un.d_val; break; case DT_PLTGOT: pltgot = entry->d_un.d_ptr; break; case DT_MIPS_LOCAL_GOTNO: local_gotno = entry->d_un.d_val; break; case DT_MIPS_GOTSYM: gotsym = entry->d_un.d_val; break; case DT_MIPS_SYMTABNO: symtabno = entry->d_un.d_val; break; case DT_MIPS_PLTGOT: mips_pltgot = entry->d_un.d_ptr; break; case DT_PLTREL: pltrel = entry->d_un.d_val; break; case DT_PLTRELSZ: pltrelsz = entry->d_un.d_val; break; case DT_JMPREL: jmprel = entry->d_un.d_ptr; break; default: break; } if (liblist_offset != 0 && liblistno != 0 && do_dynamic) { Elf32_External_Lib * elib; size_t cnt; elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset, liblistno, sizeof (Elf32_External_Lib), _(""liblist section data"")); if (elib) { printf (_(""\nSection '.liblist' contains %lu entries:\n""), (unsigned long) liblistno); fputs (_(""     Library              Time Stamp          Checksum   Version Flags\n""), stdout); for (cnt = 0; cnt < liblistno; ++cnt) { Elf32_Lib liblist; time_t atime; char timebuf[128]; struct tm * tmp; liblist.l_name = BYTE_GET (elib[cnt].l_name); atime = BYTE_GET (elib[cnt].l_time_stamp); liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum); liblist.l_version = BYTE_GET (elib[cnt].l_version); liblist.l_flags = BYTE_GET (elib[cnt].l_flags); tmp = gmtime (&atime); snprintf (timebuf, sizeof (timebuf), ""%04u-%02u-%02uT%02u:%02u:%02u"", tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec); printf (""%3lu: "", (unsigned long) cnt); if (VALID_DYNAMIC_NAME (liblist.l_name)) print_symbol (20, GET_DYNAMIC_NAME (liblist.l_name)); else printf (_(""<corrupt: %9ld>""), liblist.l_name); printf ("" %s %#10lx %-7ld"", timebuf, liblist.l_checksum, liblist.l_version); if (liblist.l_flags == 0) puts (_("" NONE"")); else { static const struct { const char * name; int bit; } l_flags_vals[] = { { "" EXACT_MATCH"", LL_EXACT_MATCH }, { "" IGNORE_INT_VER"", LL_IGNORE_INT_VER }, { "" REQUIRE_MINOR"", LL_REQUIRE_MINOR }, { "" EXPORTS"", LL_EXPORTS }, { "" DELAY_LOAD"", LL_DELAY_LOAD }, { "" DELTA"", LL_DELTA } }; int flags = liblist.l_flags; size_t fcnt; for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt) if ((flags & l_flags_vals[fcnt].bit) != 0) { fputs (l_flags_vals[fcnt].name, stdout); flags ^= l_flags_vals[fcnt].bit; } if (flags != 0) printf ("" %#x"", (unsigned int) flags); puts (""""); } } free (elib); } else res = FALSE; } if (options_offset != 0) { Elf_External_Options * eopt; Elf_Internal_Options * iopt; Elf_Internal_Options * option; size_t offset; int cnt; sect = section_headers; sect = find_section_by_type (SHT_MIPS_OPTIONS); if (sect == NULL) { error (_(""No MIPS_OPTIONS header found\n"")); return FALSE; } eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1, sect->sh_size, _(""options"")); if (eopt) { iopt = (Elf_Internal_Options *) cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt)); if (iopt == NULL) { error (_(""Out of memory allocating space for MIPS options\n"")); return FALSE; } offset = cnt = 0; option = iopt; while (offset <= sect->sh_size - sizeof (* eopt)) { Elf_External_Options * eoption; eoption = (Elf_External_Options *) ((char *) eopt + offset); option->kind = BYTE_GET (eoption->kind); option->size = BYTE_GET (eoption->size); option->section = BYTE_GET (eoption->section); option->info = BYTE_GET (eoption->info); if (option->size < sizeof (* eopt) || offset + option->size > sect->sh_size) { error (_(""Invalid size (%u) for MIPS option\n""), option->size); return FALSE; } offset += option->size; ++option; ++cnt; } printf (_(""\nSection '%s' contains %d entries:\n""), printable_section_name (sect), cnt); option = iopt; offset = 0; while (cnt-- > 0) { size_t len; switch (option->kind) { case ODK_NULL: printf ("" NULL       %d %lx"", option->section, option->info); break; case ODK_REGINFO: printf ("" REGINFO    ""); if (elf_header.e_machine == EM_MIPS) { Elf32_External_RegInfo * ereg; Elf32_RegInfo reginfo; ereg = (Elf32_External_RegInfo *) (option + 1); reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x%lx\n"", reginfo.ri_gprmask, (unsigned long) reginfo.ri_gp_value); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } else { Elf64_External_RegInfo * ereg; Elf64_Internal_RegInfo reginfo; ereg = (Elf64_External_RegInfo *) (option + 1); reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x"", reginfo.ri_gprmask); printf_vma (reginfo.ri_gp_value); printf (""\n""); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } ++option; continue; case ODK_EXCEPTIONS: fputs ("" EXCEPTIONS fpe_min("", stdout); process_mips_fpe_exception (option->info & OEX_FPU_MIN); fputs ("") fpe_max("", stdout); process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8); fputs ("")"", stdout); if (option->info & OEX_PAGE0) fputs ("" PAGE0"", stdout); if (option->info & OEX_SMM) fputs ("" SMM"", stdout); if (option->info & OEX_FPDBUG) fputs ("" FPDBUG"", stdout); if (option->info & OEX_DISMISS) fputs ("" DISMISS"", stdout); break; case ODK_PAD: fputs ("" PAD       "", stdout); if (option->info & OPAD_PREFIX) fputs ("" PREFIX"", stdout); if (option->info & OPAD_POSTFIX) fputs ("" POSTFIX"", stdout); if (option->info & OPAD_SYMBOL) fputs ("" SYMBOL"", stdout); break; case ODK_HWPATCH: fputs ("" HWPATCH   "", stdout); if (option->info & OHW_R4KEOP) fputs ("" R4KEOP"", stdout); if (option->info & OHW_R8KPFETCH) fputs ("" R8KPFETCH"", stdout); if (option->info & OHW_R5KEOP) fputs ("" R5KEOP"", stdout); if (option->info & OHW_R5KCVTL) fputs ("" R5KCVTL"", stdout); break; case ODK_FILL: fputs ("" FILL       "", stdout); break; case ODK_TAGS: fputs ("" TAGS       "", stdout); break; case ODK_HWAND: fputs ("" HWAND     "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_HWOR: fputs ("" HWOR      "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_GP_GROUP: printf ("" GP_GROUP  %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; case ODK_IDENT: printf ("" IDENT     %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; default: printf ("" %3d ???     %d %lx"", option->kind, option->section, option->info); break; } len = sizeof (* eopt); while (len < option->size) { unsigned char datum = * ((unsigned char *) eopt + offset + len); if (ISPRINT (datum)) printf (""%c"", datum); else printf (""\\%03o"", datum); len ++; } fputs (""\n"", stdout); offset += option->size; ++option; } free (eopt); } else res = FALSE; } if (conflicts_offset != 0 && conflictsno != 0) { Elf32_Conflict * iconf; size_t cnt; if (dynamic_symbols == NULL) { error (_(""conflict list found without a dynamic symbol table\n"")); return FALSE; } iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf)); if (iconf == NULL) { error (_(""Out of memory allocating space for dynamic conflicts\n"")); return FALSE; } if (is_32bit_elf) { Elf32_External_Conflict * econf32; econf32 = (Elf32_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf32), _(""conflict"")); if (!econf32) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf32[cnt]); free (econf32); } else { Elf64_External_Conflict * econf64; econf64 = (Elf64_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf64), _(""conflict"")); if (!econf64) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf64[cnt]); free (econf64); } printf (_(""\nSection '.conflict' contains %lu entries:\n""), (unsigned long) conflictsno); puts (_(""  Num:    Index       Value  Name"")); for (cnt = 0; cnt < conflictsno; ++cnt) { printf (""%5lu: %8lu  "", (unsigned long) cnt, iconf[cnt]); if (iconf[cnt] >= num_dynamic_syms) printf (_(""<corrupt symbol index>"")); else { Elf_Internal_Sym * psym; psym = & dynamic_symbols[iconf[cnt]]; print_vma (psym->st_value, FULL_HEX); putchar (' '); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (25, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } putchar ('\n'); } free (iconf); } if (pltgot != 0 && local_gotno != 0) { bfd_vma ent, local_end, global_end; size_t i, offset; unsigned char * data; unsigned char * data_end; int addr_size; ent = pltgot; addr_size = (is_32bit_elf ? 4 : 8); local_end = pltgot + local_gotno * addr_size; if (symtabno < gotsym) { error (_(""The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n""), (unsigned long) gotsym, (unsigned long) symtabno); return FALSE; } global_end = local_end + (symtabno - gotsym) * addr_size; if (global_end < local_end) { error (_(""Too many GOT symbols: %lu\n""), (unsigned long) symtabno); return FALSE; } offset = offset_from_vma (file, pltgot, global_end - pltgot); data = (unsigned char *) get_data (NULL, file, offset, global_end - pltgot, 1, _(""Global Offset Table data"")); if (data == NULL) return FALSE; data_end = data + (global_end - pltgot); printf (_(""\nPrimary GOT:\n"")); printf (_("" Canonical gp value: "")); print_vma (pltgot + 0x7ff0, LONG_HEX); printf (""\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %10s %*s Purpose\n""), addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Lazy resolver\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; if (data) { if (data + ent - pltgot > data_end - addr_size) { error (_(""Invalid got entry - %#lx - overflows GOT table\n""), ent); goto got_print_fail; } if (byte_get (data + ent - pltgot, addr_size) >> (addr_size * 8 - 1) != 0) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Module pointer (GNU extension)\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; } } printf (""\n""); if (ent < local_end) { printf (_("" Local entries:\n"")); printf (""  %*s %10s %*s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); while (ent < local_end) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (""\n""); if (ent == (bfd_vma) -1) goto got_print_fail; } printf (""\n""); } if (gotsym < symtabno) { int sym_width; printf (_("" Global entries:\n"")); printf (""  %*s %10s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1; for (i = gotsym; i < symtabno; i++) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf ("" ""); if (dynamic_symbols == NULL) printf (_(""<no dynamic symbols>"")); else if (i < num_dynamic_syms) { Elf_Internal_Sym * psym = dynamic_symbols + i; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } else printf (_(""<symbol index %lu exceeds number of dynamic symbols>""), (unsigned long) i); printf (""\n""); if (ent == (bfd_vma) -1) break; } printf (""\n""); } got_print_fail: if (data) free (data); } if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0) { bfd_vma ent, end; size_t offset, rel_offset; unsigned long count, i; unsigned char * data; int addr_size, sym_width; Elf_Internal_Rela * rels; rel_offset = offset_from_vma (file, jmprel, pltrelsz); if (pltrel == DT_RELA) { if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } else { if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } ent = mips_pltgot; addr_size = (is_32bit_elf ? 4 : 8); end = mips_pltgot + (2 + count) * addr_size; offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot); data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot, 1, _(""Procedure Linkage Table data"")); if (data == NULL) return FALSE; printf (""\nPLT GOT:\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %*s Purpose\n""), addr_size * 2, _(""Address""), addr_size * 2, _(""Initial"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" PLT lazy resolver\n"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" Module pointer\n"")); printf (""\n""); printf (_("" Entries:\n"")); printf (""  %*s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1; for (i = 0; i < count; i++) { unsigned long idx = get_reloc_symindex (rels[i].r_info); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf ("" ""); if (idx >= num_dynamic_syms) printf (_(""<corrupt symbol index: %lu>""), idx); else { Elf_Internal_Sym * psym = dynamic_symbols + idx; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } printf (""\n""); } printf (""\n""); if (data) free (data); free (rels); } return res; }"
"static Image *ReadSFWImage(const ImageInfo *image_info,ExceptionInfo *exception) { static unsigned char HuffmanTable[] = { 0xFF, 0xC4, 0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01, 0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11, 0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77, 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0, 0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA }; FILE *file; Image *flipped_image, *jpeg_image, *image; ImageInfo *read_info; int unique_file; MagickBooleanType status; register unsigned char *header, *data; size_t extent; ssize_t count; unsigned char *buffer, *offset; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (GetBlobSize(image) != (size_t) GetBlobSize(image)) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); buffer=(unsigned char *) AcquireQuantumMemory((size_t) GetBlobSize(image), sizeof(*buffer)); if (buffer == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,(size_t) GetBlobSize(image),buffer); if ((count != (ssize_t) GetBlobSize(image)) || (LocaleNCompare((char *) buffer,""SFW"",3) != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); (void) CloseBlob(image); header=SFWScan(buffer,buffer+count-1,(const unsigned char *) ""\377\310\377\320"",4); if (header == (unsigned char *) NULL) { buffer=(unsigned char *) RelinquishMagickMemory(buffer); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } TranslateSFWMarker(header);   TranslateSFWMarker(header+2); (void) CopyMagickMemory(header+6,""JFIF\0\001\0"",7);   offset=header+2; offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2; for ( ; ; ) { if ((offset+4) > (buffer+count-1)) { buffer=(unsigned char *) RelinquishMagickMemory(buffer); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } TranslateSFWMarker(offset); if (offset[1] == 0xda) break; offset+=(((unsigned int) offset[2]) << 8)+offset[3]+2; } offset--; data=SFWScan(offset,buffer+count-1,(const unsigned char *) ""\377\311"",2); if (data == (unsigned char *) NULL) { buffer=(unsigned char *) RelinquishMagickMemory(buffer); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } TranslateSFWMarker(data++);   read_info=CloneImageInfo(image_info); SetImageInfoBlob(read_info,(void *) NULL,0); file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(read_info->filename); if (unique_file != -1) file=fopen_utf8(read_info->filename,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) { buffer=(unsigned char *) RelinquishMagickMemory(buffer); read_info=DestroyImageInfo(read_info); (void) CopyMagickString(image->filename,read_info->filename, MagickPathExtent); ThrowFileException(exception,FileOpenError,""UnableToCreateTemporaryFile"", image->filename); image=DestroyImageList(image); return((Image *) NULL); } extent=fwrite(header,(size_t) (offset-header+1),1,file); (void) extent; extent=fwrite(HuffmanTable,1,sizeof(HuffmanTable)/sizeof(*HuffmanTable),file); extent=fwrite(offset+1,(size_t) (data-offset),1,file); status=ferror(file) != 0 ? MagickFalse : MagickTrue; (void) fclose(file); (void) close(unique_file); buffer=(unsigned char *) RelinquishMagickMemory(buffer); if (status == MagickFalse) { char *message; (void) remove_utf8(read_info->filename); read_info=DestroyImageInfo(read_info); message=GetExceptionMessage(errno); (void) ThrowMagickException(exception,GetMagickModule(),FileOpenError, ""UnableToWriteFile"",""`%s': %s"",image->filename,message); message=DestroyString(message); image=DestroyImageList(image); return((Image *) NULL); } jpeg_image=ReadImage(read_info,exception); (void) RelinquishUniqueFileResource(read_info->filename); read_info=DestroyImageInfo(read_info); if (jpeg_image == (Image *) NULL) { image=DestroyImageList(image); return(jpeg_image); } (void) CopyMagickString(jpeg_image->filename,image->filename,MagickPathExtent); (void) CopyMagickString(jpeg_image->magick,image->magick,MagickPathExtent); image=DestroyImageList(image); image=jpeg_image; flipped_image=FlipImage(image,exception); if (flipped_image != (Image *) NULL) { DuplicateBlob(flipped_image,image); image=DestroyImage(image); image=flipped_image; } return(GetFirstImageInList(image)); }"
"int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user) { struct net_device *dev = skb->dev; int fhoff, nhoff, ret; struct frag_hdr *fhdr; struct frag_queue *fq; struct ipv6hdr *hdr; u8 prevhdr; if (ipv6_hdr(skb)->payload_len == 0) { pr_debug(""payload len = 0\n""); return -EINVAL; } if (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0) return -EINVAL; if (!pskb_may_pull(skb, fhoff + sizeof(*fhdr))) return -ENOMEM; skb_set_transport_header(skb, fhoff); hdr = ipv6_hdr(skb); fhdr = (struct frag_hdr *)skb_transport_header(skb); fq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr, skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr)); if (fq == NULL) { pr_debug(""Can't find and can't create new queue\n""); return -ENOMEM; } spin_lock_bh(&fq->q.lock); if (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) { ret = -EINVAL; goto out_unlock; } ret = -EINPROGRESS; if (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) && fq->q.meat == fq->q.len && nf_ct_frag6_reasm(fq, skb, dev)) ret = 0; out_unlock: spin_unlock_bh(&fq->q.lock); inet_frag_put(&fq->q, &nf_frags); return ret; }"
int64_t TensorByteSize(const TensorProto& t) { int64_t num_elems = TensorShape(t.tensor_shape()).num_elements(); return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype()); }
void put_busid_priv(struct bus_id_priv *bid) { spin_unlock(&bid->busid_lock); }
"void Compute(tensorflow::OpKernelContext* context) override { const tensorflow::Tensor* data; OP_REQUIRES_OK(context, context->input(""data"", &data)); const auto& input_data = data->flat<tstring>().data(); const tensorflow::Tensor* splits; OP_REQUIRES_OK(context, context->input(""data_splits"", &splits)); const auto& splits_vec = splits->flat<SPLITS_TYPE>(); const int input_data_size = data->flat<tstring>().size(); const int splits_vec_size = splits_vec.size(); if (splits_vec_size > 0) { int prev_split = splits_vec(0); OP_REQUIRES(context, prev_split == 0, errors::InvalidArgument(""First split value must be 0, got "", prev_split)); for (int i = 1; i < splits_vec_size; ++i) { bool valid_splits = splits_vec(i) >= prev_split; valid_splits = valid_splits && (splits_vec(i) <= input_data_size); OP_REQUIRES(context, valid_splits, errors::InvalidArgument( ""Invalid split value "", splits_vec(i), "", must be in ["", prev_split, "", "", input_data_size, ""]"")); prev_split = splits_vec(i); } OP_REQUIRES(context, prev_split == input_data_size, errors::InvalidArgument( ""Last split value must be data size. Expected "", input_data_size, "", got "", prev_split)); } int num_batch_items = splits_vec.size() - 1; tensorflow::Tensor* ngrams_splits; OP_REQUIRES_OK( context, context->allocate_output(1, splits->shape(), &ngrams_splits)); auto ngrams_splits_data = ngrams_splits->flat<SPLITS_TYPE>().data(); if (data->flat<tstring>().size() == 0 || splits_vec.size() == 0) { tensorflow::Tensor* empty; OP_REQUIRES_OK(context, context->allocate_output(0, data->shape(), &empty)); for (int i = 0; i <= num_batch_items; ++i) { ngrams_splits_data[i] = 0; } return; } ngrams_splits_data[0] = 0; for (int i = 1; i <= num_batch_items; ++i) { int length = splits_vec(i) - splits_vec(i - 1); int num_ngrams = 0; for (int ngram_width : ngram_widths_) num_ngrams += get_num_ngrams(length, ngram_width); if (preserve_short_ && length > 0 && num_ngrams == 0) { num_ngrams = 1; } ngrams_splits_data[i] = ngrams_splits_data[i - 1] + num_ngrams; } tensorflow::Tensor* ngrams; OP_REQUIRES_OK( context, context->allocate_output( 0, TensorShape({ngrams_splits_data[num_batch_items]}), &ngrams)); auto ngrams_data = ngrams->flat<tstring>().data(); for (int i = 0; i < num_batch_items; ++i) { auto data_start = &input_data[splits_vec(i)]; int output_start_idx = ngrams_splits_data[i]; for (int ngram_width : ngram_widths_) { auto output_start = &ngrams_data[output_start_idx]; int length = splits_vec(i + 1) - splits_vec(i); int num_ngrams = get_num_ngrams(length, ngram_width); CreateNgrams(data_start, output_start, num_ngrams, ngram_width); output_start_idx += num_ngrams; } if (preserve_short_ && output_start_idx == ngrams_splits_data[i]) { int data_length = splits_vec(i + 1) - splits_vec(i); if (data_length == 0) { continue; } int ngram_width = data_length + 2 * pad_width_; auto output_start = &ngrams_data[output_start_idx]; int num_ngrams = 1; CreateNgrams(data_start, output_start, num_ngrams, ngram_width); } } }"
"void proto_register_AllJoyn(void) { static hf_register_info hf[] = { {&hf_alljoyn_ns_header, {""Header"", ""alljoyn.header"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_sender_version, {""Sender Version"", ""alljoyn.header.sendversion"", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL} }, {&hf_alljoyn_ns_message_version, {""Message Version"", ""alljoyn.header.messageversion"", FT_UINT8, BASE_DEC, NULL, 0x0F, NULL, HFILL} }, {&hf_alljoyn_ns_questions, {""Questions"", ""alljoyn.header.questions"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_answers, {""Answers"", ""alljoyn.header.answers"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_timer, {""Timer"", ""alljoyn.header.timer"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_whohas, {""Who-Has Message"", ""alljoyn.whohas"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_whohas_t_flag, {""TCP"", ""alljoyn.whohas.T"", FT_BOOLEAN, 8, NULL, WHOHAS_T, NULL, HFILL} }, {&hf_alljoyn_ns_whohas_u_flag, {""UDP"", ""alljoyn.whohas.U"", FT_BOOLEAN, 8, NULL, WHOHAS_U, NULL, HFILL} }, {&hf_alljoyn_ns_whohas_s_flag, {""IPv6"", ""alljoyn.whohas.S"", FT_BOOLEAN, 8, NULL, WHOHAS_S, NULL, HFILL} }, {&hf_alljoyn_ns_whohas_f_flag, {""IPv4"", ""alljoyn.whohas.F"", FT_BOOLEAN, 8, NULL, WHOHAS_F, NULL, HFILL} }, {&hf_alljoyn_ns_whohas_count, {""Count"", ""alljoyn.whohas.count"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_answer, {""Is-At Message"", ""alljoyn.isat"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_isat_entry, {""Advertisement Entry"", ""alljoyn.isat_entry"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_isat_guid_string, {""GUID String"", ""alljoyn.isat_guid_string"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_g_flag, {""GUID"", ""alljoyn.isat.G"", FT_BOOLEAN, 8, NULL, ISAT_G, NULL, HFILL} }, {&hf_alljoyn_ns_isat_c_flag, {""Complete"", ""alljoyn.isat.C"", FT_BOOLEAN, 8, NULL, ISAT_C, NULL, HFILL} }, {&hf_alljoyn_ns_isat_count, {""Count"", ""alljoyn.isat.count"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_ipv6, {""IPv6 Address"", ""alljoyn.isat.ipv6"", FT_IPv6, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_ipv4, {""IPv4 Address"", ""alljoyn.isat.ipv4"", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_t_flag, {""TCP"", ""alljoyn.isat.T"", FT_BOOLEAN, 8, NULL, ISAT_T, NULL, HFILL} }, {&hf_alljoyn_ns_isat_u_flag, {""UDP"", ""alljoyn.isat.U"", FT_BOOLEAN, 8, NULL, ISAT_U, NULL, HFILL} }, {&hf_alljoyn_ns_isat_s_flag, {""IPv6"", ""alljoyn.isat.S"", FT_BOOLEAN, 8, NULL, ISAT_S, NULL, HFILL} }, {&hf_alljoyn_ns_isat_f_flag, {""IPv4"", ""alljoyn.isat.F"", FT_BOOLEAN, 8, NULL, ISAT_F, NULL, HFILL} }, {&hf_alljoyn_ns_isat_port, {""Port"", ""alljoyn.isat.port"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_u6_flag, {""IPv6 UDP"", ""alljoyn.isat.U6"", FT_BOOLEAN, 8, NULL, ISAT_U6, NULL, HFILL} }, {&hf_alljoyn_ns_isat_r6_flag, {""IPv6 TCP"", ""alljoyn.isat.R6"", FT_BOOLEAN, 8, NULL, ISAT_R6, NULL, HFILL} }, {&hf_alljoyn_ns_isat_u4_flag, {""IPv4 UDP"", ""alljoyn.isat.U4"", FT_BOOLEAN, 8, NULL, ISAT_U4, NULL, HFILL} }, {&hf_alljoyn_ns_isat_r4_flag, {""IPv4 TCP"", ""alljoyn.isat.R4"", FT_BOOLEAN, 8, NULL, ISAT_R4, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask, {""Transport Mask"", ""alljoyn.isat.TransportMask"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_local, {""Local Transport"", ""alljoyn.isat.TransportMask.Local"", FT_BOOLEAN, 16, NULL, TRANSPORT_LOCAL, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_bluetooth, {""Bluetooth Transport"", ""alljoyn.isat.TransportMask.Bluetooth"", FT_BOOLEAN, 16, NULL, TRANSPORT_BLUETOOTH, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_tcp, {""TCP Transport"", ""alljoyn.isat.TransportMask.TCP"", FT_BOOLEAN, 16, NULL, TRANSPORT_TCP, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_wwan, {""Wirelesss WAN Transport"", ""alljoyn.isat.TransportMask.WWAN"", FT_BOOLEAN, 16, NULL, TRANSPORT_WWAN, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_lan, {""Wired LAN Transport"", ""alljoyn.isat.TransportMask.LAN"", FT_BOOLEAN, 16, NULL, TRANSPORT_LAN, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_ice, {""ICE protocol Transport"", ""alljoyn.isat.TransportMask.ICE"", FT_BOOLEAN, 16, NULL, TRANSPORT_ICE, NULL, HFILL} }, {&hf_alljoyn_ns_isat_transport_mask_wfd, {""Wi-Fi Direct Transport"", ""alljoyn.isat.TransportMask.WFD"", FT_BOOLEAN, 16, NULL, TRANSPORT_WFD, NULL, HFILL} }, {&hf_alljoyn_connect_byte_value, {""Connect Initial Byte"", ""alljoyn.InitialByte"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_sasl_command, {""SASL command"", ""alljoyn.SASL.command"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_sasl_parameter, {""SASL parameter"", ""alljoyn.SASL.parameter"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_mess_header, {""Message Header"", ""alljoyn.mess_header"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_mess_header_endian, {""Endianness"", ""alljoyn.mess_header.endianess"", FT_UINT8, BASE_DEC, VALS(endian_encoding_vals), 0x0, NULL, HFILL} }, {&hf_alljoyn_mess_header_type, {""Message type"", ""alljoyn.mess_header.type"", FT_UINT8, BASE_DEC, VALS(message_header_encoding_vals), 0x0, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags, {""Flags"", ""alljoyn.mess_header.flags"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_no_reply, {""No reply expected"", ""alljoyn.mess_header.flags.noreply"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_NO_REPLY_EXPECTED, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_no_auto_start, {""No auto start"", ""alljoyn.mess_header.flags.noautostart"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_NO_AUTO_START, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_allow_remote_msg, {""Allow remote messages"", ""alljoyn.mess_header.flags.allowremotemessages"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_ALLOW_REMOTE_MSG, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_sessionless, {""Sessionless"", ""alljoyn.mess_header.flags.sessionless"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_SESSIONLESS, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_global_broadcast, {""Allow global broadcast"", ""alljoyn.mess_header.flags.globalbroadcast"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_GLOBAL_BROADCAST, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_compressed, {""Compressed"", ""alljoyn.mess_header.flags.compressed"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_COMPRESSED, NULL, HFILL} }, {&hf_alljoyn_mess_header_flags_encrypted, {""Encrypted"", ""alljoyn.mess_header.flags.encrypted"", FT_BOOLEAN, 8, NULL, MESSAGE_HEADER_FLAG_ENCRYPTED, NULL, HFILL} }, {&hf_alljoyn_mess_header_majorversion, {""Major version"", ""alljoyn.mess_header.majorversion"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_header_body_length, {""Body length"", ""alljoyn.mess_header.bodylength"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_header_serial, {""Serial number"", ""alljoyn.mess_header.serial"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_header_header_length, {""Header length"", ""alljoyn.mess_header.headerlength"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_header_fields, {""Header fields"", ""alljoyn.mess_header.fields"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_header_field, {""Header field"", ""alljoyn.mess_header.field"", FT_UINT8, BASE_HEX, VALS(mess_header_field_encoding_vals), 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_header_fieldcode, {""Field code"", ""alljoyn.message.fieldcode"", FT_UINT8, BASE_HEX, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_header_typeid, {""Type ID"", ""alljoyn.message.typeid"", FT_UINT8, BASE_CUSTOM, CF_FUNC(alljoyn_typeid), 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_parameters, {""Parameters"", ""alljoyn.parameters"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_array, {""Array"", ""alljoyn.array"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_structure, {""struct"", ""alljoyn.structure"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_dictionary_entry, {""dictionary entry"", ""alljoyn.dictionary_entry"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_variant, {""Variant '"", ""alljoyn.variant"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_signature_length, {""Signature length"", ""alljoyn.parameter.signature_length"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_mess_body_signature, {""Signature"", ""alljoyn.parameter.signature"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_boolean, {""Boolean"", ""alljoyn.boolean"", FT_BOOLEAN, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_uint8, {""Unsigned byte"", ""alljoyn.uint8"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_int16, {""Signed int16"", ""alljoyn.int16"", FT_INT16, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_uint16, {""Unsigned int16"", ""alljoyn.uint16"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_handle, {""Handle"", ""alljoyn.handle"", FT_UINT32, BASE_HEX, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_int32, {""Signed int32"", ""alljoyn.int32"", FT_INT32, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_uint32, {""Unsigned int32"", ""alljoyn.uint32"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_int64, {""Signed int64"", ""alljoyn.int64"", FT_INT64, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_uint64, {""Unsigned int64"", ""alljoyn.uint64"", FT_UINT64, BASE_DEC, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_double, {""Double"", ""alljoyn.double"", FT_DOUBLE, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_padding, {""Padding"", ""alljoyn.padding"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL} }, {&hf_alljoyn_string, {""Bus Name"", ""alljoyn.string"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_string_size_8bit, {""String Size 8-bit"", ""alljoyn.string.size8bit"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_string_size_32bit, {""String Size 32-bit"", ""alljoyn.string.size32bit"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL} }, {&hf_alljoyn_string_data, {""String Data"", ""alljoyn.string.data"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL} }, {&hf_ardp_syn_flag, {""SYN"", ""ardp.hdr.SYN"", FT_BOOLEAN, 8, NULL, ARDP_SYN, NULL, HFILL} }, {&hf_ardp_ack_flag, {""ACK"", ""ardp.hdr.ACK"", FT_BOOLEAN, 8, NULL, ARDP_ACK, NULL, HFILL}}, {&hf_ardp_eak_flag, {""EAK"", ""ardp.hdr.EAK"", FT_BOOLEAN, 8, NULL, ARDP_EAK, NULL, HFILL}}, {&hf_ardp_rst_flag, {""RST"", ""ardp.hdr.RST"", FT_BOOLEAN, 8, NULL, ARDP_RST, NULL, HFILL}}, {&hf_ardp_nul_flag, {""NUL"", ""ardp.hdr.NUL"", FT_BOOLEAN, 8, NULL, ARDP_NUL, NULL, HFILL}}, {&hf_ardp_unused_flag, {""UNUSED"", ""ardp.hdr.UNUSED"", FT_BOOLEAN, 8, NULL, ARDP_UNUSED, NULL, HFILL}}, {&hf_ardp_version_field, {""VER"", ""ardp.hdr.ver"", FT_UINT8, BASE_HEX, NULL, ARDP_VER, NULL, HFILL}}, {&hf_ardp_hlen, {""Header Length"", ""ardp.hdr.hlen"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_src, {""Source Port"", ""ardp.hdr.src"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_dst, {""Destination Port"", ""ardp.hdr.dst"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_dlen, {""Data Length"", ""ardp.hdr.dlen"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_seq, {""Sequence"", ""ardp.hdr.seq"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_ack, {""Acknowledge"", ""ardp.hdr.ack"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_ttl, {""Time to Live"", ""ardp.hdr.ttl"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_lcs, {""Last Consumed Sequence"", ""ardp.hdr.lcs"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_nsa, {""Next Sequence to ACK"", ""ardp.hdr.nsa"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_fss, {""Fragment Starting Sequence"", ""ardp.hdr.fss"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_fcnt, {""Fragment Count"", ""ardp.hdr.fcnt"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_bmp, {""EACK Bitmap"", ""ardp.hdr.bmp"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_segmax, {""Segment Max"", ""ardp.hdr.segmentmax"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_segbmax, {""Segment Buffer Max"", ""ardp.hdr.segmentbmax"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_dackt, {""Receiver's delayed ACK timeout"", ""ardp.hdr.dackt"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL}}, {&hf_ardp_options, {""Options"", ""ardp.hdr.options"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL}}, }; static gint *ett[] = { &ett_alljoyn_ns, &ett_alljoyn_ns_header, &ett_alljoyn_ns_answers, &ett_alljoyn_ns_guid_string, &ett_alljoyn_ns_isat_entry, &ett_alljoyn_ns_string, &ett_alljoyn_whohas, &ett_alljoyn_string, &ett_alljoyn_isat_entry, &ett_alljoyn_mess, &ett_alljoyn_header, &ett_alljoyn_header_flags, &ett_alljoyn_mess_header_field, &ett_alljoyn_mess_header, &ett_alljoyn_mess_body_parameters, &ett_alljoyn_ardp }; proto_AllJoyn_ns = proto_register_protocol(""AllJoyn Name Service Protocol"", ""AllJoyn NS"", ""ajns""); proto_AllJoyn_mess = proto_register_protocol(""AllJoyn Message Protocol"", ""AllJoyn"", ""aj""); proto_register_field_array(proto_AllJoyn_ns, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); proto_AllJoyn_ardp = proto_register_protocol(""AllJoyn Reliable Datagram Protocol"", ""AllJoyn ARDP"", ""ardp""); }"
"SIXELAPI SIXELSTATUS sixel_frame_resize( sixel_frame_t *frame, int width, int height, int method_for_resampling ) { SIXELSTATUS status = SIXEL_FALSE; size_t size; unsigned char *scaled_frame = NULL; sixel_frame_ref(frame); status = sixel_frame_convert_to_rgb888(frame); if (SIXEL_FAILED(status)) { goto end; } size = (size_t)(width * height * 3); scaled_frame = (unsigned char *)sixel_allocator_malloc(frame->allocator, size); if (scaled_frame == NULL) { sixel_helper_set_additional_message( ""sixel_frame_resize: sixel_allocator_malloc() failed.""); status = SIXEL_BAD_ALLOCATION; goto end; } status = sixel_helper_scale_image( scaled_frame, frame->pixels, frame->width, frame->height, 3, width, height, method_for_resampling, frame->allocator); if (SIXEL_FAILED(status)) { goto end; } sixel_allocator_free(frame->allocator, frame->pixels); frame->pixels = scaled_frame; frame->width = width; frame->height = height; status = SIXEL_OK; end: sixel_frame_unref(frame); return status; }"
DRWAV_API drwav_int16 drwav_bytes_to_s16(const drwav_uint8* data) { return (short)drwav_bytes_to_u16(data); }
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf64_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"mbfl_string * mbfl_strcut( mbfl_string *string, mbfl_string *result, int from, int length) { const mbfl_encoding *encoding; mbfl_memory_device device; if (string == NULL || string->val == NULL || result == NULL) { return NULL; } if (from < 0 || length < 0) { return NULL; } if (from >= string->len) { from = string->len; } encoding = mbfl_no2encoding(string->no_encoding); if (encoding == NULL) { return NULL; } mbfl_string_init(result); result->no_language = string->no_language; result->no_encoding = string->no_encoding; if ((encoding->flag & (MBFL_ENCTYPE_SBCS | MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE | MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE)) || encoding->mblen_table != NULL) { const unsigned char *start = NULL; const unsigned char *end = NULL; unsigned char *w; unsigned int sz; if (encoding->flag & (MBFL_ENCTYPE_WCS2BE | MBFL_ENCTYPE_WCS2LE)) { from &= -2; if (from + length >= string->len) { length = string->len - from; } start = string->val + from; end   = start + (length & -2); } else if (encoding->flag & (MBFL_ENCTYPE_WCS4BE | MBFL_ENCTYPE_WCS4LE)) { from &= -4; if (from + length >= string->len) { length = string->len - from; } start = string->val + from; end   = start + (length & -4); } else if ((encoding->flag & MBFL_ENCTYPE_SBCS)) { if (from + length >= string->len) { length = string->len - from; } start = string->val + from; end = start + length; } else if (encoding->mblen_table != NULL) { const unsigned char *mbtab = encoding->mblen_table; const unsigned char *p, *q; int m; for (m = 0, p = string->val, q = p + from; p < q; p += (m = mbtab[*p])); if (p > q) { p -= m; } start = p; if ((start - string->val) + length >= (int)string->len) { end = string->val + string->len; } else { for (q = p + length; p < q; p += (m = mbtab[*p])); if (p > q) { p -= m; } end = p; } } else { return NULL; } sz = end - start; if ((w = (unsigned char*)mbfl_calloc(sz + 8, sizeof(unsigned char))) == NULL) { return NULL; } memcpy(w, start, sz); w[sz] = '\0'; w[sz + 1] = '\0'; w[sz + 2] = '\0'; w[sz + 3] = '\0'; result->val = w; result->len = sz; } else { mbfl_convert_filter *encoder     = NULL; mbfl_convert_filter *decoder     = NULL; const unsigned char *p, *q, *r; struct { mbfl_convert_filter encoder; mbfl_convert_filter decoder; const unsigned char *p; int pos; } bk, _bk; if (!(decoder = mbfl_convert_filter_new( mbfl_no_encoding_wchar, string->no_encoding, mbfl_memory_device_output, 0, &device))) { return NULL; } if (!(encoder = mbfl_convert_filter_new( string->no_encoding, mbfl_no_encoding_wchar, mbfl_filter_output_null, NULL, NULL))) { mbfl_convert_filter_delete(decoder); return NULL; } mbfl_memory_device_init(&device, length + 8, 0); p = string->val; for (q = string->val + from; p < q; p++) { (*encoder->filter_function)(*p, encoder); } encoder->output_function = (int(*)(int,void *))decoder->filter_function; encoder->flush_function = (int(*)(void *))decoder->filter_flush; encoder->data = decoder; q = string->val + string->len; mbfl_convert_filter_copy(decoder, &_bk.decoder); mbfl_convert_filter_copy(encoder, &_bk.encoder); _bk.p = p; _bk.pos = device.pos; if (length > q - p) { length = q - p; } if (length >= 20) { for (r = p + length - 20; p < r; p++) { (*encoder->filter_function)(*p, encoder); } if (device.pos > length) { p = _bk.p; device.pos = _bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&_bk.decoder, decoder); mbfl_convert_filter_copy(&_bk.encoder, encoder); bk = _bk; } else { mbfl_convert_filter_copy(decoder, &bk.decoder); mbfl_convert_filter_copy(encoder, &bk.encoder); bk.p = p; bk.pos = device.pos; (*encoder->filter_flush)(encoder); if (device.pos > length) { bk.decoder.filter_dtor(&bk.decoder); bk.encoder.filter_dtor(&bk.encoder); p = _bk.p; device.pos = _bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&_bk.decoder, decoder); mbfl_convert_filter_copy(&_bk.encoder, encoder); bk = _bk; } else { _bk.decoder.filter_dtor(&_bk.decoder); _bk.encoder.filter_dtor(&_bk.encoder); p = bk.p; device.pos = bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&bk.decoder, decoder); mbfl_convert_filter_copy(&bk.encoder, encoder); } } } else { bk = _bk; } while (p < q) { (*encoder->filter_function)(*p, encoder); if (device.pos > length) { p = bk.p; device.pos = bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&bk.decoder, decoder); mbfl_convert_filter_copy(&bk.encoder, encoder); break; } p++; mbfl_convert_filter_copy(decoder, &_bk.decoder); mbfl_convert_filter_copy(encoder, &_bk.encoder); _bk.pos = device.pos; _bk.p = p; (*encoder->filter_flush)(encoder); if (device.pos > length) { _bk.decoder.filter_dtor(&_bk.decoder); _bk.encoder.filter_dtor(&_bk.encoder); p = bk.p; device.pos = bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&bk.decoder, decoder); mbfl_convert_filter_copy(&bk.encoder, encoder); break; } bk.decoder.filter_dtor(&bk.decoder); bk.encoder.filter_dtor(&bk.encoder); p = _bk.p; device.pos = _bk.pos; decoder->filter_dtor(decoder); encoder->filter_dtor(encoder); mbfl_convert_filter_copy(&_bk.decoder, decoder); mbfl_convert_filter_copy(&_bk.encoder, encoder); bk = _bk; } (*encoder->filter_flush)(encoder); bk.decoder.filter_dtor(&bk.decoder); bk.encoder.filter_dtor(&bk.encoder); result = mbfl_memory_device_result(&device, result); mbfl_convert_filter_delete(encoder); mbfl_convert_filter_delete(decoder); } return result; }"
"static gboolean accept_ice_connection (GIOChannel           *source, GIOCondition          condition, GsmIceConnectionData *data) { IceListenObj    listener; IceConn         ice_conn; IceAcceptStatus status; GsmClient      *client; GsmXsmpServer  *server; listener = data->listener; server = data->server; g_debug (""GsmXsmpServer: accept_ice_connection()""); ice_conn = IceAcceptConnection (listener, &status); if (status != IceAcceptSuccess) { g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status); return TRUE; } client = gsm_xsmp_client_new (ice_conn); ice_conn->context = client; gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client)); g_object_unref (client); return TRUE; }"
"void proto_register_bacapp(void) { static hf_register_info hf[] = { { &hf_bacapp_type, { ""APDU Type"",           ""bacapp.type"", FT_UINT8, BASE_DEC, VALS(BACnetTypeName), 0xf0, NULL, HFILL } }, { &hf_bacapp_pduflags, { ""PDU Flags"",          ""bacapp.pduflags"", FT_UINT8, BASE_HEX, NULL, 0x0f, NULL, HFILL } }, { &hf_bacapp_SEG, { ""Segmented Request"",           ""bacapp.segmented_request"", FT_BOOLEAN, 8, TFS(&segments_follow), 0x08, NULL, HFILL } }, { &hf_bacapp_MOR, { ""More Segments"",           ""bacapp.more_segments"", FT_BOOLEAN, 8, TFS(&more_follow), 0x04, ""More Segments Follow"", HFILL } }, { &hf_bacapp_SA, { ""SA"",           ""bacapp.SA"", FT_BOOLEAN, 8, TFS(&segmented_accept), 0x02, ""Segmented Response accepted"", HFILL } }, { &hf_bacapp_max_adpu_size, { ""Size of Maximum ADPU accepted"",           ""bacapp.max_adpu_size"", FT_UINT8, BASE_DEC, VALS(BACnetMaxAPDULengthAccepted), 0x0f, NULL, HFILL } }, { &hf_bacapp_response_segments, { ""Max Response Segments accepted"",           ""bacapp.response_segments"", FT_UINT8, BASE_DEC, VALS(BACnetMaxSegmentsAccepted), 0x70, NULL, HFILL } }, { &hf_bacapp_objectType, { ""Object Type"",           ""bacapp.objectType"", FT_UINT32, BASE_DEC, VALS(BACnetObjectType), 0xffc00000, NULL, HFILL } }, { &hf_bacapp_instanceNumber, { ""Instance Number"",           ""bacapp.instance_number"", FT_UINT32, BASE_DEC, NULL, 0x003fffff, NULL, HFILL } }, { &hf_BACnetPropertyIdentifier, { ""Property Identifier"", ""bacapp.property_identifier"", FT_UINT32, BASE_DEC, VALS(BACnetPropertyIdentifier), 0, NULL, HFILL } }, { &hf_BACnetVendorIdentifier, { ""Vendor Identifier"", ""bacapp.vendor_identifier"", FT_UINT16, BASE_DEC|BASE_EXT_STRING, &BACnetVendorIdentifiers_ext, 0, NULL, HFILL } }, { &hf_BACnetRestartReason, { ""Restart Reason"", ""bacapp.restart_reason"", FT_UINT8, BASE_DEC, VALS(BACnetRestartReason), 0, NULL, HFILL } }, { &hf_bacapp_invoke_id, { ""Invoke ID"",           ""bacapp.invoke_id"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_sequence_number, { ""Sequence Number"",           ""bacapp.sequence_number"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_window_size, { ""Proposed Window Size"",           ""bacapp.window_size"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_service, { ""Service Choice"",           ""bacapp.confirmed_service"", FT_UINT8, BASE_DEC, VALS(BACnetConfirmedServiceChoice), 0x00, NULL, HFILL } }, { &hf_bacapp_uservice, { ""Unconfirmed Service Choice"",           ""bacapp.unconfirmed_service"", FT_UINT8, BASE_DEC, VALS(BACnetUnconfirmedServiceChoice), 0x00, NULL, HFILL } }, { &hf_bacapp_NAK, { ""NAK"",           ""bacapp.NAK"", FT_BOOLEAN, 8, NULL, 0x02, ""negative ACK"", HFILL } }, { &hf_bacapp_SRV, { ""SRV"",           ""bacapp.SRV"", FT_BOOLEAN, 8, NULL, 0x01, ""Server"", HFILL } }, { &hf_Device_Instance_Range_Low_Limit, { ""Device Instance Range Low Limit"", ""bacapp.who_is.low_limit"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_Device_Instance_Range_High_Limit, { ""Device Instance Range High Limit"", ""bacapp.who_is.high_limit"", FT_UINT32, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetRejectReason, { ""Reject Reason"",           ""bacapp.reject_reason"", FT_UINT8, BASE_DEC, VALS(BACnetRejectReason), 0x00, NULL, HFILL } }, { &hf_BACnetAbortReason, { ""Abort Reason"",           ""bacapp.abort_reason"", FT_UINT8, BASE_DEC, VALS(BACnetAbortReason), 0x00, NULL, HFILL } }, { &hf_BACnetApplicationTagNumber, { ""Application Tag Number"", ""bacapp.application_tag_number"", FT_UINT8, BASE_DEC, VALS(BACnetApplicationTagNumber), 0xF0, NULL, HFILL } }, { &hf_BACnetContextTagNumber, { ""Context Tag Number"", ""bacapp.context_tag_number"", FT_UINT8, BASE_DEC, NULL, 0xF0, NULL, HFILL } }, { &hf_BACnetExtendedTagNumber, { ""Extended Tag Number"", ""bacapp.extended_tag_number"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetNamedTag, { ""Named Tag"", ""bacapp.named_tag"", FT_UINT8, BASE_DEC, VALS(BACnetTagNames), 0x07, NULL, HFILL } }, { &hf_BACnetCharacterSet, { ""String Character Set"", ""bacapp.string_character_set"", FT_UINT8, BASE_DEC, VALS(BACnetCharacterSet), 0, NULL, HFILL } }, { &hf_BACnetCodePage, { ""Code Page"", ""bacapp.code_page"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_BACnetTagClass, { ""Tag Class"",           ""bacapp.tag_class"", FT_BOOLEAN, 8, TFS(&BACnetTagClass), 0x08, NULL, HFILL } }, { &hf_bacapp_tag_lvt, { ""Length Value Type"", ""bacapp.LVT"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_tag_ProcessId, { ""ProcessIdentifier"",           ""bacapp.processId"", FT_UINT32, BASE_DEC, NULL, 0, ""Process Identifier"", HFILL } }, { &hf_bacapp_tag_IPV4, { ""IPV4"",           ""bacapp.IPV4"", FT_IPv4, BASE_NONE, NULL, 0, ""IP-Address"", HFILL } }, { &hf_bacapp_tag_IPV6, { ""IPV6"",           ""bacapp.IPV6"", FT_IPv6, BASE_NONE, NULL, 0, ""IP-Address"", HFILL } }, { &hf_bacapp_tag_PORT, { ""Port"",           ""bacapp.Port"", FT_UINT16, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_tag_mac_address_broadcast, { ""MAC-address: broadcast"",           ""bacapp.mac_address_broadcast"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_bacapp_reserved_ashrea, { ""reserved for ASHRAE"",           ""bacapp.reserved_ashrea"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_bacapp_unused_bits, { ""Unused bits"",           ""bacapp.unused_bits"", FT_UINT8, BASE_DEC, NULL, 0, NULL, HFILL } }, { &hf_bacapp_bit, { ""bit"",           ""bacapp.bit"", FT_BOOLEAN, 8, NULL, 0, NULL, HFILL } }, { &hf_bacapp_complete_bitstring, { ""Complete bitstring"",           ""bacapp.complete_bitstring"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, {&hf_msg_fragments, { ""Message fragments"", ""bacapp.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment, { ""Message fragment"", ""bacapp.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_overlap, { ""Message fragment overlap"", ""bacapp.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_overlap_conflicts, { ""Message fragment overlapping with conflicting data"", ""bacapp.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_multiple_tails, { ""Message has multiple tail fragments"", ""bacapp.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_too_long_fragment, { ""Message fragment too long"", ""bacapp.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_error, { ""Message defragmentation error"", ""bacapp.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_fragment_count, { ""Message fragment count"", ""bacapp.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, {&hf_msg_reassembled_in, { ""Reassembled in"", ""bacapp.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, {&hf_msg_reassembled_length, { ""Reassembled BACapp length"", ""bacapp.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } } }; static gint *ett[] = { &ett_bacapp, &ett_bacapp_control, &ett_bacapp_tag, &ett_bacapp_list, &ett_bacapp_value, &ett_msg_fragment, &ett_msg_fragments }; static ei_register_info ei[] = { { &ei_bacapp_bad_length, { ""bacapp.bad_length"", PI_MALFORMED, PI_ERROR, ""Wrong length indicated"", EXPFILL }}, { &ei_bacapp_bad_tag, { ""bacapp.bad_tag"", PI_MALFORMED, PI_ERROR, ""Wrong tag found"", EXPFILL }}, { &ei_bacapp_opening_tag, { ""bacapp.bad_opening_tag"", PI_MALFORMED, PI_ERROR, ""Expected Opening Tag!"", EXPFILL }}, }; expert_module_t* expert_bacapp; proto_bacapp = proto_register_protocol(""Building Automation and Control Network APDU"", ""BACapp"", ""bacapp""); proto_register_field_array(proto_bacapp, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_bacapp = expert_register_protocol(proto_bacapp); expert_register_field_array(expert_bacapp, ei, array_length(ei)); register_dissector(""bacapp"", dissect_bacapp, proto_bacapp); reassembly_table_register(&msg_reassembly_table, &addresses_reassembly_table_functions); bacapp_dissector_table = register_dissector_table(""bacapp.vendor_identifier"", ""BACapp Vendor Identifier"", proto_bacapp, FT_UINT8, BASE_HEX); register_bacapp_stat_trees(); bacapp_tap = register_tap(""bacapp"");  }"
"static void file_asynch_read (struct rw *rw, struct command *command, nbd_completion_callback cb) { int dummy = 0; file_synch_read (rw, slice_ptr (command->slice), command->slice.len, command->offset); if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } }"
"GF_Err gp_rtp_builder_do_avc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize) { u32 do_flush, bytesLeft, size, nal_type; char shdr[2]; char stap_hdr; do_flush = 0; if (!nalu) do_flush = 1; else if (builder->sl_header.accessUnitStartFlag) do_flush = 1; else if (builder->bytesInPacket + nalu_size >= builder->Path_MTU) do_flush = 2; else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2; if (builder->bytesInPacket && do_flush) { builder->rtp_header.Marker = (do_flush==1) ? 1 : 0; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } if (!nalu) return GF_OK; if (!builder->bytesInPacket) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.Marker = 0; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); builder->avc_non_idr = GF_TRUE; } nal_type = nalu[0] & 0x1F; switch (nal_type) { case GF_AVC_NALU_NON_IDR_SLICE: case GF_AVC_NALU_ACCESS_UNIT: case GF_AVC_NALU_END_OF_SEQ: case GF_AVC_NALU_END_OF_STREAM: case GF_AVC_NALU_FILLER_DATA: break; default: builder->avc_non_idr = GF_FALSE; break; } if (builder->bytesInPacket+nalu_size<builder->Path_MTU) { Bool use_stap = GF_TRUE; if (IsAUEnd && !builder->bytesInPacket) use_stap = GF_FALSE; if (use_stap) { if (!builder->bytesInPacket) { stap_hdr = (nalu[0] & 0xE0) | 24; builder->OnData(builder->cbk_obj, (char *) &stap_hdr, 1, GF_FALSE); builder->bytesInPacket = 1; } shdr[0] = nalu_size>>8; shdr[1] = nalu_size&0x00ff; builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE); builder->bytesInPacket += 2; } if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, nalu_size, 0); else builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE); builder->bytesInPacket += nalu_size; if (IsAUEnd) { builder->rtp_header.Marker = 1; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } } else { u32 offset; assert(nalu_size>=builder->Path_MTU); assert(!builder->bytesInPacket); bytesLeft = nalu_size - 1; offset = 1; while (bytesLeft) { if (2 + bytesLeft > builder->Path_MTU) { size = builder->Path_MTU - 2; } else { size = bytesLeft; } shdr[0] = (nalu[0] & 0xE0) | 28; shdr[1] = (nalu[0] & 0x1F); if (offset==1) shdr[1] |= 0x80; else if (size == bytesLeft) shdr[1] |= 0x40; builder->OnData(builder->cbk_obj, (char *)shdr, 2, GF_FALSE); if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, size, offset); else builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE); offset += size; bytesLeft -= size; builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; if (bytesLeft) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); } } } return GF_OK; }"
"static int find_exif_tag(const uint8_t* exif, int  size, uint16_t query_tag, bool* out_littleEndian) { if (size < 4) { return -1; } if ((exif[0] != 'I' && exif[0] != 'M') || (exif[1] != 'I' && exif[1] != 'M')) { return -1; } bool littleEndian = (exif[0] == 'I'); assert(out_littleEndian); *out_littleEndian = littleEndian; int offset = read32(exif, size, 4, littleEndian); if (offset < 0) { return -1; } int cnt = read16(exif, size, offset, littleEndian); if (cnt < 1) { return -1; } for (int i = 0; i < cnt; i++) { int tag = read16(exif, size, offset + 2 + i * 12, littleEndian); if (tag == query_tag) { return offset + 2 + i * 12; } } return -1; }"
"void bc_str2num (bc_num *num, char *str, int scale) { int digits, strscale; char *ptr, *nptr; char zero_int; bc_free_num (num); ptr = str; digits = 0; strscale = 0; zero_int = FALSE; if ( (*ptr == '+') || (*ptr == '-'))  ptr++;   while (*ptr == '0') ptr++; while (isdigit((int)*ptr)) ptr++, digits++; if (*ptr == '.') ptr++; while (isdigit((int)*ptr)) ptr++, strscale++; if ((*ptr != '\0') || (digits+strscale == 0)) { *num = bc_copy_num (BCG(_zero_)); return; } strscale = MIN(strscale, scale); if (digits == 0) { zero_int = TRUE; digits = 1; } *num = bc_new_num (digits, strscale); ptr = str; if (*ptr == '-') { (*num)->n_sign = MINUS; ptr++; } else { (*num)->n_sign = PLUS; if (*ptr == '+') ptr++; } while (*ptr == '0') ptr++; nptr = (*num)->n_value; if (zero_int) { *nptr++ = 0; digits = 0; } for (;digits > 0; digits--) *nptr++ = CH_VAL(*ptr++); if (strscale > 0) { ptr++;   for (;strscale > 0; strscale--) *nptr++ = CH_VAL(*ptr++); } if (bc_is_zero (*num)) (*num)->n_sign = PLUS; }"
"int parse_elf_object(int fd, const char *executable, bool fork_disable_dump, char **ret, JsonVariant **ret_package_metadata) { _cleanup_close_pair_ int error_pipe[2] = { -1, -1 }, return_pipe[2] = { -1, -1 }, json_pipe[2] = { -1, -1 }; _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL; _cleanup_free_ char *buf = NULL; int r; assert(fd >= 0); r = dlopen_dw(); if (r < 0) return r; r = dlopen_elf(); if (r < 0) return r; r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK)); if (r < 0) return r; if (ret) { r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC)); if (r < 0) return r; } if (ret_package_metadata) { r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC)); if (r < 0) return r; } r = safe_fork_full(""(sd-parse-elf)"", (int[]){ fd, error_pipe[1], return_pipe[1], json_pipe[1] }, 4, FORK_RESET_SIGNALS|FORK_CLOSE_ALL_FDS|FORK_NEW_MOUNTNS|FORK_MOUNTNS_SLAVE|FORK_NEW_USERNS|FORK_WAIT|FORK_REOPEN_LOG, NULL); if (r < 0) { if (r == -EPROTO) {  int e, k; k = read(error_pipe[0], &e, sizeof(e)); if (k < 0 && errno != EAGAIN)  return -errno; if (k == sizeof(e)) return e;  if (k != 0) return -EIO; } return r; } if (r == 0) { if (fork_disable_dump) { r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0)); if (r < 0) goto child_fail; } r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL); if (r < 0) goto child_fail; if (buf) { r = loop_write(return_pipe[1], buf, strlen(buf), false); if (r < 0) goto child_fail; return_pipe[1] = safe_close(return_pipe[1]); } if (package_metadata) { _cleanup_fclose_ FILE *json_out = NULL; json_out = take_fdopen(&json_pipe[1], ""w""); if (!json_out) { r = -errno; goto child_fail; } json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL); } _exit(EXIT_SUCCESS); child_fail: (void) write(error_pipe[1], &r, sizeof(r)); _exit(EXIT_FAILURE); } error_pipe[1] = safe_close(error_pipe[1]); return_pipe[1] = safe_close(return_pipe[1]); json_pipe[1] = safe_close(json_pipe[1]); if (ret) { _cleanup_fclose_ FILE *in = NULL; in = take_fdopen(&return_pipe[0], ""r""); if (!in) return -errno; r = read_full_stream(in, &buf, NULL); if (r < 0) return r; } if (ret_package_metadata) { _cleanup_fclose_ FILE *json_in = NULL; json_in = take_fdopen(&json_pipe[0], ""r""); if (!json_in) return -errno; r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL); if (r < 0 && r != -ENODATA)  return r; } if (ret) *ret = TAKE_PTR(buf); if (ret_package_metadata) *ret_package_metadata = TAKE_PTR(package_metadata); return 0; }"
"ecma_collection_t * ecma_op_object_get_property_names (ecma_object_t *obj_p,  uint32_t opts)  { JERRY_ASSERT (obj_p != NULL && !ecma_is_lexical_environment (obj_p)); #if ENABLED (JERRY_ES2015_BUILTIN_PROXY) if (ECMA_OBJECT_IS_PROXY (obj_p)) { return ecma_proxy_object_own_property_keys (obj_p); } #endif  if (ecma_op_object_is_fast_array (obj_p)) { return ecma_fast_array_get_property_names (obj_p, opts); } ecma_collection_t *ret_p = ecma_new_collection (); ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection (); const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0; const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0; const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0; #if ENABLED (JERRY_ES2015) const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0; const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0; #endif  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE; const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size; JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size); memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0])); while (true) { const ecma_object_type_t type = ecma_get_object_type (obj_p); const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p); ecma_length_t string_named_properties_count = 0; ecma_length_t array_index_named_properties_count = 0; #if ENABLED (JERRY_ES2015) ecma_length_t symbol_named_properties_count = 0; #endif  ecma_collection_t *prop_names_p = ecma_new_collection (); #if ENABLED (JERRY_ES2015) if (JERRY_LIKELY (!is_symbols_only)) { #endif  if (obj_is_builtin) { if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p)) { ecma_builtin_routine_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } else { ecma_builtin_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } } else { switch (type) { case ECMA_OBJECT_TYPE_PSEUDO_ARRAY: { #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) if (ecma_object_is_typedarray (obj_p)) { ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p); } #endif  break; } case ECMA_OBJECT_TYPE_FUNCTION: { if (!is_array_indices_only) { ecma_op_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION: { if (!is_array_indices_only) { ecma_op_external_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_BOUND_FUNCTION: { if (!is_array_indices_only) { ecma_op_bound_function_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_CLASS: { ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p; if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL) { ecma_op_string_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); } break; } case ECMA_OBJECT_TYPE_ARRAY: { ecma_op_array_list_lazy_property_names (obj_p, opts, prop_names_p, skipped_non_enumerable_p); break; } default: { JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL); break; } } } #if ENABLED (JERRY_ES2015) } #endif  ecma_value_t *buffer_p = prop_names_p->buffer_p; uint32_t lazy_prop_name_count = prop_names_p->item_count; const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size; JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size); memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0])); for (uint32_t i = 0; i < prop_names_p->item_count; i++) { ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]); if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX) { array_index_named_properties_count++; } #if ENABLED (JERRY_ES2015) else if (ecma_prop_name_is_symbol (name_p)) { symbol_named_properties_count++; } #endif  else { string_named_properties_count++; } #if ENABLED (JERRY_ES2015) JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p)); #endif  uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0) { own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); } } jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp; if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL) { ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p; uint32_t length = ext_obj_p->u.array.length; array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p); ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp); for (uint32_t i = 0; i < length; i++) { if (ecma_is_value_array_hole (values_p[i])) { continue; } ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i); uint8_t hash = (uint8_t) ecma_string_hash (index_str_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); bool is_add = true; if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0) { buffer_p = prop_names_p->buffer_p; for (uint32_t j = 0; j < prop_names_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (index_str_p, current_name_p)) { is_add = false; break; } } } if (is_add) { own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p)); } } } else { #if ENABLED (JERRY_PROPRETY_HASHMAP) if (prop_iter_cp != JMEM_CP_NULL) { ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp); if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP) { prop_iter_cp = prop_iter_p->next_property_cp; } } #endif  while (prop_iter_cp != JMEM_CP_NULL) { ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp); JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p)); for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++) { ecma_property_t *property_p = prop_iter_p->types + i; if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR) { ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p; if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT) { continue; } ecma_string_t *name_p = ecma_string_from_property_name (*property_p, prop_pair_p->names_cp[i]); if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p))) { #if ENABLED (JERRY_ES2015) bool is_symbol = ecma_prop_name_is_symbol (name_p); if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol)) { ecma_deref_ecma_string (name_p); continue; } #endif  uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); bool is_add = true; if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0) { buffer_p = prop_names_p->buffer_p; for (uint32_t j = 0; j < prop_names_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_add = false; break; } } } if (is_add) { if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX) { array_index_named_properties_count++; } else if (!is_array_indices_only) { #if ENABLED (JERRY_ES2015) if (ecma_prop_name_is_symbol (name_p)) { symbol_named_properties_count++; } else { #endif  string_named_properties_count++; #if ENABLED (JERRY_ES2015) } #endif  } else { ecma_deref_ecma_string (name_p); continue; } own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p)); } else { ecma_deref_ecma_string (name_p); } } else { JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p)); ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p)); } } } prop_iter_cp = prop_iter_p->next_property_cp; } } ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count; #if ENABLED (JERRY_ES2015) all_properties_count += symbol_named_properties_count; #endif  JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *); ecma_string_t **string_names_p = names_p + array_index_named_properties_count; #if ENABLED (JERRY_ES2015) ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count; #endif  uint32_t array_index_name_pos = 0; uint32_t string_name_pos = string_named_properties_count; uint32_t lazy_string_name_pos = 0; #if ENABLED (JERRY_ES2015) uint32_t symbol_name_pos = symbol_named_properties_count; #endif  buffer_p = prop_names_p->buffer_p; for (uint32_t i = 0; i < prop_names_p->item_count; i++) { ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]); ecma_ref_ecma_string (name_p); uint32_t index = ecma_string_get_array_index (name_p); if (index != ECMA_STRING_NOT_ARRAY_INDEX) { JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count); uint32_t insertion_pos = 0; while (insertion_pos < array_index_name_pos && index > ecma_string_get_array_index (names_p[insertion_pos])) { insertion_pos++; } if (insertion_pos == array_index_name_pos) { names_p[array_index_name_pos++] = name_p; } else { JERRY_ASSERT (insertion_pos < array_index_name_pos); JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos])); uint32_t move_pos = array_index_name_pos++; while (move_pos > insertion_pos) { names_p[move_pos] = names_p[move_pos - 1u]; move_pos--; } names_p[insertion_pos] = name_p; } } #if ENABLED (JERRY_ES2015) else if (ecma_prop_name_is_symbol (name_p)) { JERRY_ASSERT (symbol_name_pos > 0); JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count); symbol_names_p[--symbol_name_pos] = name_p; } #endif  else { JERRY_ASSERT (string_name_pos > 0); JERRY_ASSERT (string_name_pos <= string_named_properties_count); if (i < lazy_prop_name_count) { string_names_p[lazy_string_name_pos++] = name_p; } else { string_names_p[--string_name_pos] = name_p; } } } JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count); JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0); #if ENABLED (JERRY_ES2015) JERRY_ASSERT (symbol_name_pos == 0); #endif  ecma_collection_free (prop_names_p); for (uint32_t i = 0; i < all_properties_count; i++) { bool is_append = true; ecma_string_t *name_p = names_p[i]; uint8_t hash = (uint8_t) ecma_string_hash (name_p); uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size); uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size); if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0) { names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column); } else { buffer_p = ret_p->buffer_p; for (uint32_t j = 0; j < ret_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_append = false; break; } } } if (is_append) { buffer_p = skipped_non_enumerable_p->buffer_p; for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++) { ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]); if (ecma_compare_ecma_strings (name_p, current_name_p)) { is_append = false; break; } } } if (is_append) { JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0); ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p)); } else { ecma_deref_ecma_string (name_p); } } JMEM_FINALIZE_LOCAL_ARRAY (names_p); if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL) { break; } obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp); } ecma_collection_free (skipped_non_enumerable_p); return ret_p; }"
"void write_ptbase(struct vcpu *v) { struct cpu_info *cpu_info = get_cpu_info(); unsigned long new_cr4; new_cr4 = (is_pv_vcpu(v) && !is_idle_vcpu(v)) ? pv_guest_cr4_to_real_cr4(v) : ((read_cr4() & ~(X86_CR4_PCIDE | X86_CR4_TSD)) | X86_CR4_PGE); if ( is_pv_vcpu(v) && v->domain->arch.pv.xpti ) { cpu_info->root_pgt_changed = true; cpu_info->pv_cr3 = __pa(this_cpu(root_pgt)); if ( new_cr4 & X86_CR4_PCIDE ) cpu_info->pv_cr3 |= get_pcid_bits(v, true); switch_cr3_cr4(v->arch.cr3, new_cr4); } else { cpu_info->use_pv_cr3 = false; cpu_info->xen_cr3 = 0; switch_cr3_cr4(v->arch.cr3, new_cr4); cpu_info->pv_cr3 = 0; } ASSERT(is_pv_vcpu(v) || read_cr4() == mmu_cr4_features); }"
"static bool_t set_iommu_pde_present(u32 *pde, unsigned long next_mfn,  unsigned int next_level, bool_t iw, bool_t ir) { u64 addr_lo, addr_hi, maddr_old, maddr_next; u32 entry; bool_t need_flush = 0; maddr_next = (u64)next_mfn << PAGE_SHIFT; addr_hi = get_field_from_reg_u32(pde[1], IOMMU_PTE_ADDR_HIGH_MASK, IOMMU_PTE_ADDR_HIGH_SHIFT); addr_lo = get_field_from_reg_u32(pde[0], IOMMU_PTE_ADDR_LOW_MASK, IOMMU_PTE_ADDR_LOW_SHIFT); maddr_old = (addr_hi << 32) | (addr_lo << PAGE_SHIFT); if ( maddr_old != maddr_next ) need_flush = 1; addr_lo = maddr_next & DMA_32BIT_MASK; addr_hi = maddr_next >> 32; set_field_in_reg_u32((u32)addr_hi, 0, IOMMU_PDE_ADDR_HIGH_MASK, IOMMU_PDE_ADDR_HIGH_SHIFT, &entry); set_field_in_reg_u32(iw, entry, IOMMU_PDE_IO_WRITE_PERMISSION_MASK, IOMMU_PDE_IO_WRITE_PERMISSION_SHIFT, &entry); set_field_in_reg_u32(ir, entry, IOMMU_PDE_IO_READ_PERMISSION_MASK, IOMMU_PDE_IO_READ_PERMISSION_SHIFT, &entry); if ( next_level == 0 ) set_field_in_reg_u32(IOMMU_CONTROL_ENABLED, entry, IOMMU_PTE_FC_MASK, IOMMU_PTE_FC_SHIFT, &entry); pde[1] = entry; set_field_in_reg_u32((u32)addr_lo >> PAGE_SHIFT, 0, IOMMU_PDE_ADDR_LOW_MASK, IOMMU_PDE_ADDR_LOW_SHIFT, &entry); set_field_in_reg_u32(next_level, entry, IOMMU_PDE_NEXT_LEVEL_MASK, IOMMU_PDE_NEXT_LEVEL_SHIFT, &entry); set_field_in_reg_u32(IOMMU_CONTROL_ENABLED, entry, IOMMU_PDE_PRESENT_MASK, IOMMU_PDE_PRESENT_SHIFT, &entry); pde[0] = entry; return need_flush; }"
"static void swf_svg_print(SWFReader *read, const char *format, ...) { char line[2000]; u32 line_length; u32 new_size; va_list args; va_start(args, format); vsprintf(line, format, args); va_end(args); line_length = (u32)strlen(line); new_size = read->svg_data_size+line_length; read->svg_data = (char *)gf_realloc(read->svg_data, new_size+1); if (read->print_frame_header) { memmove(read->svg_data+read->frame_header_offset+line_length, read->svg_data+read->frame_header_offset, (read->svg_data_size-read->frame_header_offset)+1); memcpy(read->svg_data+read->frame_header_offset, line, line_length); read->frame_header_offset += line_length; } else { strcpy(read->svg_data+read->svg_data_size, line); } read->svg_data_size = new_size; }"
static RzList *symbols(RzBinFile *bf) { if (!bf) { return NULL; } LuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf); if (!bin_info_obj) { return NULL; } return bin_info_obj->symbol_list; }
"varnumber_T num_divide(varnumber_T n1, varnumber_T n2, int *failed) { varnumber_Tresult; if (n2 == 0) { if (in_vim9script()) { emsg(_(e_divide_by_zero)); if (failed != NULL) *failed = TRUE; } if (n1 == 0) result = VARNUM_MIN; else if (n1 < 0) result = -VARNUM_MAX; else result = VARNUM_MAX; } else result = n1 / n2; return result; }"
int64_t LineBasedFrameDecoder::findEndOfLine(IOBufQueue& buf) { Cursor c(buf.front()); for (uint32_t i = 0; i < maxLength_ && i < buf.chainLength(); i++) { auto b = c.read<char>(); if (b == '\n' && terminatorType_ != TerminatorType::CARRIAGENEWLINE) { return i; } else if (terminatorType_ != TerminatorType::NEWLINE && b == '\r' && !c.isAtEnd() && c.read<char>() == '\n') { return i; } } return -1; }
"static guint get_write_list_chunk_count(tvbuff_t *tvb, guint offset) { guint32 value_follows; guint num_chunks, chunk_size; num_chunks = 0; while (1) { value_follows = tvb_get_ntohl(tvb, offset); offset += 4; if (!value_follows) break; num_chunks++; chunk_size = get_write_chunk_size(tvb, offset); if ((offset + chunk_size) < offset) break; } return num_chunks; }"
"static int parseChars(FileInfo *nested, CharsString *result, CharsString *token) { int in = 0; int out = 0; int lastOutSize = 0; int lastIn; unsigned int ch = 0; int numBytes = 0; unsigned int utf32 = 0; int k; while (in < token->length) { ch = token->chars[in++] & 0xff; if (ch < 128) { if (ch == '\\') {  switch (ch = token->chars[in]) { case '\\': break; case 'e': ch = 0x1b; break; case 'f': ch = 12; break; case 'n': ch = 10; break; case 'r': ch = 13; break; case 's': ch = ' '; break; case 't': ch = 9; break; case 'v': ch = 11; break; case 'w': ch = ENDSEGMENT; break; case 34: ch = QUOTESUB; break; case 'X': case 'x': if (token->length - in > 4) { ch = hexValue(nested, &token->chars[in + 1], 4); in += 4; } break; case 'y': case 'Y': if (CHARSIZE == 2) { not32: compileError(nested, ""liblouis has not been compiled for 32-bit Unicode""); break; } if (token->length - in > 5) { ch = hexValue(nested, &token->chars[in + 1], 5); in += 5; } break; case 'z': case 'Z': if (CHARSIZE == 2) goto not32; if (token->length - in > 8) { ch = hexValue(nested, &token->chars[in + 1], 8); in += 8; } break; default: compileError(nested, ""invalid escape sequence '\\%c'"", ch); break; } in++; } result->chars[out++] = (widechar)ch; if (out >= MAXSTRING) { result->length = out; return 1; } continue; } lastOutSize = out; lastIn = in; for (numBytes = MAXBYTES - 1; numBytes > 0; numBytes--) if (ch >= first0Bit[numBytes]) break; utf32 = ch & (0XFF - first0Bit[numBytes]); for (k = 0; k < numBytes; k++) { if (in >= MAXSTRING) break; if (out >= MAXSTRING) { result->length = lastOutSize; return 1; } if (token->chars[in] < 128 || (token->chars[in] & 0x0040)) { compileWarning(nested, ""invalid UTF-8. Assuming Latin-1.""); result->chars[out++] = token->chars[lastIn]; in = lastIn + 1; continue; } utf32 = (utf32 << 6) + (token->chars[in++] & 0x3f); } if (out >= MAXSTRING) { result->length = lastOutSize; return 1; } if (CHARSIZE == 2 && utf32 > 0xffff) utf32 = 0xffff; result->chars[out++] = (widechar)utf32; } result->length = out; return 1; }"
"static int put_chars(u32 vtermno, const char *buf, int count) { struct port *port; struct scatterlist sg[1]; if (unlikely(early_put_chars)) return early_put_chars(vtermno, buf, count); port = find_port_by_vtermno(vtermno); if (!port) return -EPIPE; sg_init_one(sg, buf, count); return __send_to_port(port, sg, 1, count, (void *)buf, false); }"
"void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n, int offset) { CharCode oldLen, i; Unicode u; char uHex[5]; int j; if (code >= mapLen) { oldLen = mapLen; mapLen = (code + 256) & ~255; map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode)); for (i = oldLen; i < mapLen; ++i) { map[i] = 0; } } if (n <= 4) { if (sscanf(uStr, ""%x"", &u) != 1) { error(-1, ""Illegal entry in ToUnicode CMap""); return; } map[code] = u + offset; } else { if (sMapLen >= sMapSize) { sMapSize = sMapSize + 16; sMap = (CharCodeToUnicodeString *) greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString)); } map[code] = 0; sMap[sMapLen].c = code; sMap[sMapLen].len = n / 4; for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) { strncpy(uHex, uStr + j*4, 4); uHex[4] = '\0'; if (sscanf(uHex, ""%x"", &sMap[sMapLen].u[j]) != 1) { error(-1, ""Illegal entry in ToUnicode CMap""); } } sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset; ++sMapLen; } }"
"XDevice * XOpenDevice( register Display*dpy, register XID id) { register long rlen; xOpenDeviceReq *req; xOpenDeviceReply rep; XDevice *dev; XExtDisplayInfo *info = XInput_find_display(dpy); LockDisplay(dpy); if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1) return NULL; GetReq(OpenDevice, req); req->reqType = info->codes->major_opcode; req->ReqType = X_OpenDevice; req->deviceid = id; if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) { UnlockDisplay(dpy); SyncHandle(); return (XDevice *) NULL; } rlen = rep.length << 2; dev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes * sizeof(XInputClassInfo)); if (dev) { int dlen; dev->device_id = req->deviceid; dev->num_classes = rep.num_classes; dev->classes = (XInputClassInfo *) ((char *)dev + sizeof(XDevice)); dlen = rep.num_classes * sizeof(xInputClassInfo); _XRead(dpy, (char *)dev->classes, dlen); if (rlen - dlen > 0) _XEatData(dpy, (unsigned long)rlen - dlen); } else _XEatDataWords(dpy, rep.length); UnlockDisplay(dpy); SyncHandle(); return (dev); }"
"int ksmbd_conn_handler_loop(void *p) { struct ksmbd_conn *conn = (struct ksmbd_conn *)p; struct ksmbd_transport *t = conn->transport; unsigned int pdu_size, max_allowed_pdu_size; char hdr_buf[4] = {0,}; int size; mutex_init(&conn->srv_mutex); __module_get(THIS_MODULE); if (t->ops->prepare && t->ops->prepare(t)) goto out; conn->last_active = jiffies; while (ksmbd_conn_alive(conn)) { if (try_to_freeze()) continue; kvfree(conn->request_buf); conn->request_buf = NULL; size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1); if (size != sizeof(hdr_buf)) break; pdu_size = get_rfc1002_len(hdr_buf); ksmbd_debug(CONN, ""RFC1002 header %u bytes\n"", pdu_size); if (ksmbd_conn_good(conn)) max_allowed_pdu_size = SMB3_MAX_MSGSIZE + conn->vals->max_write_size; else max_allowed_pdu_size = SMB3_MAX_MSGSIZE; if (pdu_size > max_allowed_pdu_size) { pr_err_ratelimited(""PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\n"", pdu_size, max_allowed_pdu_size, READ_ONCE(conn->status)); break; } if (pdu_size > MAX_STREAM_PROT_LEN) break; size = pdu_size + 4 + 1; conn->request_buf = kvmalloc(size, GFP_KERNEL); if (!conn->request_buf) break; memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf)); if (!ksmbd_smb_request(conn)) break; size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2); if (size < 0) { pr_err(""sock_read failed: %d\n"", size); break; } if (size != pdu_size) { pr_err(""PDU error. Read: %d, Expected: %d\n"", size, pdu_size); continue; } if (!default_conn_ops.process_fn) { pr_err(""No connection request callback\n""); break; } if (default_conn_ops.process_fn(conn)) { pr_err(""Cannot handle request\n""); break; } } out: ksmbd_conn_set_releasing(conn); wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0); if (IS_ENABLED(CONFIG_UNICODE)) utf8_unload(conn->um); unload_nls(conn->local_nls); if (default_conn_ops.terminate_fn) default_conn_ops.terminate_fn(conn); t->ops->disconnect(t); module_put(THIS_MODULE); return 0; }"
"static void ip_printroute(netdissect_options *ndo, register const u_char *cp, u_int length) { register u_int ptr; register u_int len; if (length < 3) { ND_PRINT((ndo, "" [bad length %u]"", length)); return; } if ((length + 1) & 3) ND_PRINT((ndo, "" [bad length %u]"", length)); ptr = cp[2] - 1; if (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1) ND_PRINT((ndo, "" [bad ptr %u]"", cp[2])); for (len = 3; len < length; len += 4) { ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, &cp[len]))); if (ptr > len) ND_PRINT((ndo, "","")); } }"
"void APar_ExtractDetails(FILE *isofile, uint8_t optional_output) { char *uint32_buffer = (char *)malloc(sizeof(char) * 5); Trackage track = {0}; AtomicInfo *mvhdAtom = APar_FindAtom(""moov.mvhd"", false, VERSIONED_ATOM, 0); if (mvhdAtom != NULL) { APar_ExtractMovieDetails(uint32_buffer, isofile, mvhdAtom); fprintf(stdout, ""Movie duration: %.3lf seconds (%s) - %.2lf* kbp/sec bitrate "" ""(*=approximate)\n"", movie_info.seconds, secsTOtime(movie_info.seconds), movie_info.simple_bitrate_calc); if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""  Presentation Creation Date (UTC):     %s\n"", APar_extract_UTC(movie_info.creation_time)); fprintf(stdout, ""  Presentation Modification Date (UTC): %s\n"", APar_extract_UTC(movie_info.modified_time)); } } AtomicInfo *iodsAtom = APar_FindAtom(""moov.iods"", false, VERSIONED_ATOM, 0); if (iodsAtom != NULL) { movie_info.contains_iods = true; APar_Extract_iods_Info(isofile, iodsAtom); } if (optional_output & SHOW_TRACK_INFO) { APar_TrackLevelInfo(&track, NULL);                                 fprintf( stdout, ""Low-level details. Total tracks: %u\n"", track.total_tracks); fprintf(stdout, ""Trk  Type  Handler                    Kind  Lang  Bytes\n""); if (track.total_tracks > 0) { while (track.total_tracks > track.track_num) { track.track_num += 1; TrackInfo track_info = {0}; APar_ExtractTrackDetails(uint32_buffer, isofile, &track, &track_info); uint16_t more_whitespace = purge_extraneous_characters(track_info.track_hdlr_name); if (strlen(track_info.track_hdlr_name) == 0) { memcpy(track_info.track_hdlr_name, ""[none listed]"", 13); } fprintf(stdout, ""%u    %s  %s"", track.track_num, uint32tochar4(track_info.track_type, uint32_buffer), track_info.track_hdlr_name); uint16_t handler_len = strlen(track_info.track_hdlr_name); if (handler_len < 25 + more_whitespace) { for (uint16_t i = handler_len; i < 25 + more_whitespace; i++) { fprintf(stdout, "" ""); } } fprintf(stdout, ""  %s  %s   %"" PRIu64, uint32tochar4(track_info.track_codec, uint32_buffer), track_info.unpacked_lang, track_info.sample_aggregate); if (track_info.encoder_name[0] != 0 && track_info.contains_esds) { purge_extraneous_characters(track_info.encoder_name); fprintf(stdout, ""   Encoder: %s"", track_info.encoder_name); } if (track_info.type_of_track & DRM_PROTECTED_TRACK) { fprintf(stdout, "" (protected %s)"", uint32tochar4(track_info.protected_codec, uint32_buffer)); } fprintf(stdout, ""\n""); if (track_info.type_of_track & VIDEO_TRACK || track_info.type_of_track & AUDIO_TRACK) { APar_Print_TrackDetails(&track_info); } if (optional_output & SHOW_DATE_INFO) { fprintf(stdout, ""       Creation Date (UTC):     %s\n"", APar_extract_UTC(track_info.creation_time)); fprintf(stdout, ""       Modification Date (UTC): %s\n"", APar_extract_UTC(track_info.modified_time)); } } } } return; }"
"void RequestHandler::startRequest(const string& transactionId,  const string& httpMethod, const string& url, const string& body, bool verifyPeer) { RequestHandler::ConnInfo *conn; CURLMcode rc; if (0 == url.find(""tcp:      string json = ""{\""action\"": \""route\"", \""data\"": {\""uri\"": \""""; json.append(url.substr(6)); if (0 == url.find(""tcp:      else json.append("";transport=tls""); json.append(""\""}}""); DR_LOG(log_info) << ""RequestHandler::startRequest: no web callback required, sending directly to "" << url << "":"" << json.c_str() ; m_pController->httpCallRoutingComplete(transactionId, 200, json); return; } DR_LOG(log_info) << ""RequestHandler::startRequest: sending http "" << httpMethod << "": "" << url ; conn = m_pool.malloc() ; CURL* easy = NULL ; { if( m_cacheEasyHandles.empty() ) { m_cacheEasyHandles.push_back(createEasyHandle()) ; } easy = m_cacheEasyHandles.front() ; m_cacheEasyHandles.pop_front() ; DR_LOG(log_debug) << ""RequestHandler::makeRequestForRoute - after acquiring handle in thread "" <<  std::this_thread::get_id() << "" "" << dec << m_cacheEasyHandles.size() << "" handles remain in cache""; } conn->easy = easy; conn->global = &m_g; strncpy(conn->url, url.c_str(), URL_LEN) ; strncpy(conn->body, body.c_str(), HTTP_BODY_LEN); strncpy(conn->transactionId, transactionId.c_str(), TXNID_LEN); conn->hdr_list = NULL ; curl_easy_setopt(easy, CURLOPT_URL, conn->url); curl_easy_setopt(easy, CURLOPT_WRITEFUNCTION, write_cb); curl_easy_setopt(easy, CURLOPT_WRITEDATA, conn); curl_easy_setopt(easy, CURLOPT_ERRORBUFFER, conn->error); curl_easy_setopt(easy, CURLOPT_PRIVATE, conn); curl_easy_setopt(easy, CURLOPT_VERBOSE, 0L); curl_easy_setopt(easy, CURLOPT_NOPROGRESS, 1L); curl_easy_setopt(easy, CURLOPT_OPENSOCKETFUNCTION, opensocket); curl_easy_setopt(easy, CURLOPT_CLOSESOCKETFUNCTION, close_socket); if( 0 == url.find(""https:"") ) { curl_easy_setopt(easy, CURLOPT_SSL_VERIFYPEER, verifyPeer); } conn->hdr_list = curl_slist_append(conn->hdr_list, ""Accept: application/json""); if( 0 == httpMethod.compare(""POST"") ) { curl_easy_setopt(easy, CURLOPT_POSTFIELDS, conn->body); curl_easy_setopt(easy, CURLOPT_POSTFIELDSIZE, strlen(conn->body)); conn->hdr_list = curl_slist_append(conn->hdr_list, ""Content-Type: text/plain; charset=UTF-8""); } curl_easy_setopt(easy, CURLOPT_HTTPHEADER, conn->hdr_list); rc = curl_multi_add_handle(m_g.multi, conn->easy); mcode_test(""new_conn: curl_multi_add_handle"", rc); }"
"static void parse_sec_attr_44(sc_file_t *file, const u8 *buf, size_t len) { const int df_idx[8] = {  SC_AC_OP_DELETE, SC_AC_OP_CREATE, SC_AC_OP_CREATE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, SC_AC_OP_LOCK, SC_AC_OP_DELETE, -1}; const int ef_idx[8] = { SC_AC_OP_READ, SC_AC_OP_UPDATE, SC_AC_OP_WRITE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, -1, SC_AC_OP_ERASE, -1}; const int efi_idx[8] = {  SC_AC_OP_READ, SC_AC_OP_ERASE, SC_AC_OP_UPDATE, SC_AC_OP_INVALIDATE, SC_AC_OP_REHABILITATE, -1, SC_AC_OP_ERASE, -1}; u8bValue; inti; intiKeyRef = 0; intiMethod; intiPinCount; intiOffset = 0; intiOperation; const int*p_idx; while (len > 1) { size_t iACLen   = buf[iOffset] & 0x0F; if (iACLen > len) break; iMethod = SC_AC_NONE; if (buf[iOffset] & 0X80) {  size_tiParmLen = 1; size_tiKeyLen  = 0; if (buf[iOffset]   & 0x20) iKeyLen++; if (buf[iOffset+1] & 0x40) iParmLen++; if (buf[iOffset+1] & 0x20) iParmLen++; if (buf[iOffset+1] & 0x10) iParmLen++; if (buf[iOffset+1] & 0x08) iParmLen++; if(iKeyLen) { int iSC; if (len < 1+(size_t)iACLen) break; iSC = buf[iOffset+iACLen]; switch( (iSC>>5) & 0x03 ){ case 0: iMethod = SC_AC_TERM; break; case 1: iMethod = SC_AC_AUT; break; case 2: case 3: iMethod = SC_AC_PRO; break; } iKeyRef = iSC & 0x1F; } if (iACLen > (1+iParmLen+iKeyLen)) {   if (len < 1+1+1+(size_t)iParmLen) break; iKeyRef = buf[iOffset+1+1+iParmLen];   iMethod = SC_AC_CHV; } if (len < 1+2) break; switch(buf[iOffset+2]){ case 0x2A: iOperation = SC_AC_OP_CRYPTO; break; case 0x46: iOperation = SC_AC_OP_UPDATE; break; default: iOperation = SC_AC_OP_SELECT; break; } sc_file_add_acl_entry(file, iOperation, iMethod, iKeyRef); } else {  switch (file->type) { case SC_FILE_TYPE_DF:             p_idx = df_idx; break; case SC_FILE_TYPE_INTERNAL_EF:    p_idx = efi_idx; break; default:                          p_idx = ef_idx; break; } iPinCount = iACLen - 1; if (buf[iOffset] & 0x20) { int iSC; if (len < 1 + (size_t)iACLen) break; iSC = buf[iOffset + iACLen]; switch( (iSC>>5) & 0x03 ) { case 0: iMethod = SC_AC_TERM; break; case 1: iMethod = SC_AC_AUT; break; case 2: case 3: iMethod = SC_AC_PRO; break; } iKeyRef = iSC & 0x1F; iPinCount--; } if ( iPinCount > 0 ) { if (len < 1 + 2) break; iKeyRef = buf[iOffset + 2]; iMethod = SC_AC_CHV; } bValue = buf[iOffset + 1]; for (i = 0; i < 8; i++) { if((bValue & 1) && (p_idx[i] >= 0)) sc_file_add_acl_entry(file, p_idx[i], iMethod, iKeyRef); bValue >>= 1; } } iOffset += iACLen +1; len     -= iACLen +1; } }"
"static inline void d2ulaw_array (const double *ptr, int count, unsigned char *buffer, double normfact) {while (--count >= 0) {if (ptr [count] >= 0) buffer [count] = ulaw_encode [lrint (normfact * ptr [count])] ; else buffer [count] = 0x7F & ulaw_encode [- lrint (normfact * ptr [count])] ; } ; }"
"int dnn_execute_layer_conv2d(DnnOperand *operands, const int32_t *input_operand_indexes, int32_t output_operand_index, const void *parameters) { float *output; int32_t input_operand_index = input_operand_indexes[0]; int number = operands[input_operand_index].dims[0]; int height = operands[input_operand_index].dims[1]; int width = operands[input_operand_index].dims[2]; int channel = operands[input_operand_index].dims[3]; const float *input = operands[input_operand_index].data; const ConvolutionalParams *conv_params = (const ConvolutionalParams *)parameters; int radius = conv_params->kernel_size >> 1; int src_linesize = width * conv_params->input_num; int filter_linesize = conv_params->kernel_size * conv_params->input_num; int filter_size = conv_params->kernel_size * filter_linesize; int pad_size = (conv_params->padding_method == VALID) ? (conv_params->kernel_size - 1) / 2 * conv_params->dilation : 0; DnnOperand *output_operand = &operands[output_operand_index]; output_operand->dims[0] = number; output_operand->dims[1] = height - pad_size * 2; output_operand->dims[2] = width - pad_size * 2; output_operand->dims[3] = conv_params->output_num; output_operand->data_type = operands[input_operand_index].data_type; output_operand->length = calculate_operand_data_length(output_operand); output_operand->data = av_realloc(output_operand->data, output_operand->length); if (!output_operand->data) return -1; output = output_operand->data; av_assert0(channel == conv_params->input_num); for (int y = pad_size; y < height - pad_size; ++y) { for (int x = pad_size; x < width - pad_size; ++x) { for (int n_filter = 0; n_filter < conv_params->output_num; ++n_filter) { if (conv_params->has_bias) output[n_filter] = conv_params->biases[n_filter]; else output[n_filter] = 0.f; for (int ch = 0; ch < conv_params->input_num; ++ch) { for (int kernel_y = 0; kernel_y < conv_params->kernel_size; ++kernel_y) { for (int kernel_x = 0; kernel_x < conv_params->kernel_size; ++kernel_x) { float input_pel; if (conv_params->padding_method == SAME_CLAMP_TO_EDGE) { int y_pos = CLAMP_TO_EDGE(y + (kernel_y - radius) * conv_params->dilation, height); int x_pos = CLAMP_TO_EDGE(x + (kernel_x - radius) * conv_params->dilation, width); input_pel = input[y_pos * src_linesize + x_pos * conv_params->input_num + ch]; } else { int y_pos = y + (kernel_y - radius) * conv_params->dilation; int x_pos = x + (kernel_x - radius) * conv_params->dilation; input_pel = (x_pos < 0 || x_pos >= width || y_pos < 0 || y_pos >= height) ? 0.0 : input[y_pos * src_linesize + x_pos * conv_params->input_num + ch]; } output[n_filter] += input_pel * conv_params->kernel[n_filter * filter_size + kernel_y * filter_linesize + kernel_x * conv_params->input_num + ch]; } } } switch (conv_params->activation){ case RELU: output[n_filter] = FFMAX(output[n_filter], 0.0); break; case TANH: output[n_filter] = 2.0f  / (1.0f + exp(-2.0f * output[n_filter])) - 1.0f; break; case SIGMOID: output[n_filter] = 1.0f / (1.0f + exp(-output[n_filter])); break; case NONE: break; case LEAKY_RELU: output[n_filter] = FFMAX(output[n_filter], 0.0) + 0.2 * FFMIN(output[n_filter], 0.0); } } output += conv_params->output_num; } } return 0; }"
"static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) { st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR); r_buf_seek (b, addr, R_BUF_SET); module->base_of_image = r_buf_read_le64 (b); module->size_of_image = r_buf_read_le32 (b); module->check_sum = r_buf_read_le32 (b); module->time_date_stamp = r_buf_read_le32 (b); module->module_name_rva = r_buf_read_le32 (b); module->version_info.dw_signature = r_buf_read_le32 (b); module->version_info.dw_struc_version = r_buf_read_le32 (b); module->version_info.dw_file_version_ms = r_buf_read_le32 (b); module->version_info.dw_file_version_ls = r_buf_read_le32 (b); module->version_info.dw_product_version_ms = r_buf_read_le32 (b); module->version_info.dw_product_version_ls = r_buf_read_le32 (b); module->version_info.dw_file_flags_mask = r_buf_read_le32 (b); module->version_info.dw_file_flags = r_buf_read_le32 (b); module->version_info.dw_file_os = r_buf_read_le32 (b); module->version_info.dw_file_type = r_buf_read_le32 (b); module->version_info.dw_file_subtype = r_buf_read_le32 (b); module->version_info.dw_file_date_ms = r_buf_read_le32 (b); module->version_info.dw_file_date_ls = r_buf_read_le32 (b); module->cv_record.data_size = r_buf_read_le32 (b); module->cv_record.rva = r_buf_read_le32 (b); module->misc_record.data_size = r_buf_read_le32 (b); module->misc_record.rva = r_buf_read_le32 (b); module->reserved_0 = r_buf_read_le64 (b); module->reserved_1 = r_buf_read_le64 (b); r_buf_seek (b, o_addr, R_BUF_SET); }"
"int Equalizer_getParameter(EffectContext     *pContext, void              *pParam, uint32_t          *pValueSize, void              *pValue){ int status = 0; int bMute = 0; int32_t *pParamTemp = (int32_t *)pParam; int32_t param = *pParamTemp++; int32_t param2; char *name; switch (param) { case EQ_PARAM_NUM_BANDS: case EQ_PARAM_CUR_PRESET: case EQ_PARAM_GET_NUM_OF_PRESETS: case EQ_PARAM_BAND_LEVEL: case EQ_PARAM_GET_BAND: if (*pValueSize < sizeof(int16_t)) { ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize); return -EINVAL; } *pValueSize = sizeof(int16_t); break; case EQ_PARAM_LEVEL_RANGE: if (*pValueSize < 2 * sizeof(int16_t)) { ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 2  %d"", *pValueSize); return -EINVAL; } *pValueSize = 2 * sizeof(int16_t); break; case EQ_PARAM_BAND_FREQ_RANGE: if (*pValueSize < 2 * sizeof(int32_t)) { ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 3  %d"", *pValueSize); return -EINVAL; } *pValueSize = 2 * sizeof(int32_t); break; case EQ_PARAM_CENTER_FREQ: if (*pValueSize < sizeof(int32_t)) { ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 5  %d"", *pValueSize); return -EINVAL; } *pValueSize = sizeof(int32_t); break; case EQ_PARAM_GET_PRESET_NAME: break; case EQ_PARAM_PROPERTIES: if (*pValueSize < (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t)) { ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid pValueSize 1  %d"", *pValueSize); return -EINVAL; } *pValueSize = (2 + FIVEBAND_NUMBANDS) * sizeof(uint16_t); break; default: ALOGV(""\tLVM_ERROR : Equalizer_getParameter unknown param %d"", param); return -EINVAL; } switch (param) { case EQ_PARAM_NUM_BANDS: *(uint16_t *)pValue = (uint16_t)FIVEBAND_NUMBANDS; break; case EQ_PARAM_LEVEL_RANGE: *(int16_t *)pValue = -1500; *((int16_t *)pValue + 1) = 1500; break; case EQ_PARAM_BAND_LEVEL: param2 = *pParamTemp; if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) { status = -EINVAL; if (param2 < 0) { android_errorWriteLog(0x534e4554, ""32438598""); ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_LEVEL band %d"", param2); } break; } *(int16_t *)pValue = (int16_t)EqualizerGetBandLevel(pContext, param2); break; case EQ_PARAM_CENTER_FREQ: param2 = *pParamTemp; if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) { status = -EINVAL; if (param2 < 0) { android_errorWriteLog(0x534e4554, ""32436341""); ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_CENTER_FREQ band %d"", param2); } break; } *(int32_t *)pValue = EqualizerGetCentreFrequency(pContext, param2); break; case EQ_PARAM_BAND_FREQ_RANGE: param2 = *pParamTemp; if (param2 < 0 || param2 >= FIVEBAND_NUMBANDS) { status = -EINVAL; if (param2 < 0) { android_errorWriteLog(0x534e4554, ""32247948""); ALOGW(""\tERROR Equalizer_getParameter() EQ_PARAM_BAND_FREQ_RANGE band %d"", param2); } break; } EqualizerGetBandFreqRange(pContext, param2, (uint32_t *)pValue, ((uint32_t *)pValue + 1)); break; case EQ_PARAM_GET_BAND: param2 = *pParamTemp; *(uint16_t *)pValue = (uint16_t)EqualizerGetBand(pContext, param2); break; case EQ_PARAM_CUR_PRESET: *(uint16_t *)pValue = (uint16_t)EqualizerGetPreset(pContext); break; case EQ_PARAM_GET_NUM_OF_PRESETS: *(uint16_t *)pValue = (uint16_t)EqualizerGetNumPresets(); break; case EQ_PARAM_GET_PRESET_NAME: param2 = *pParamTemp; if (param2 >= EqualizerGetNumPresets()) { status = -EINVAL; break; } name = (char *)pValue; strncpy(name, EqualizerGetPresetName(param2), *pValueSize - 1); name[*pValueSize - 1] = 0; *pValueSize = strlen(name) + 1; break; case EQ_PARAM_PROPERTIES: { int16_t *p = (int16_t *)pValue; ALOGV(""\tEqualizer_getParameter() EQ_PARAM_PROPERTIES""); p[0] = (int16_t)EqualizerGetPreset(pContext); p[1] = (int16_t)FIVEBAND_NUMBANDS; for (int i = 0; i < FIVEBAND_NUMBANDS; i++) { p[2 + i] = (int16_t)EqualizerGetBandLevel(pContext, i); } } break; default: ALOGV(""\tLVM_ERROR : Equalizer_getParameter() invalid param %d"", param); status = -EINVAL; break; } return status; }"
"static int dissect_thrift_type(tvbuff_t* tvb, packet_info* pinfo _U_, proto_tree* tree, int type, int offset, int length) { switch (type){ case 2: proto_tree_add_item(tree, hf_thrift_bool, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; break; case 3: proto_tree_add_item(tree, hf_thrift_byte, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; break; case 4: proto_tree_add_item(tree, hf_thrift_double, tvb, offset, 8, ENC_BIG_ENDIAN); offset += 8; break; case 6: proto_tree_add_item(tree, hf_thrift_i16, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; break; case 8: proto_tree_add_item(tree, hf_thrift_i32, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; break; case 9: proto_tree_add_item(tree, hf_thrift_u64, tvb, offset, 8, ENC_BIG_ENDIAN); offset += 8; break; case 10: proto_tree_add_item(tree, hf_thrift_i64, tvb, offset, 8, ENC_BIG_ENDIAN); offset += 8; break; case 11: offset = dissect_thrift_utf7(tvb, pinfo, tree, offset, length); break; case 12: offset = dissect_thrift_struct(tvb, pinfo, tree, offset, length); break; case 13: offset = dissect_thrift_map(tvb, pinfo, tree, offset, length); break; case 15: offset = dissect_thrift_list(tvb, pinfo, tree, offset, length); break; default: return length; } return offset; }"
"static VALUE cState_space_set(VALUE self, VALUE space) { unsigned long len; GET_STATE(self); Check_Type(space, T_STRING); len = RSTRING_LEN(space); if (len == 0) { if (state->space) { ruby_xfree(state->space); state->space = NULL; state->space_len = 0; } } else { if (state->space) ruby_xfree(state->space); state->space = strdup(RSTRING_PTR(space)); state->space_len = len; } return Qnil; }"
"void xps_parse_brush(fz_context *ctx, xps_document *doc, const fz_matrix *ctm, const fz_rect *area, char *base_uri, xps_resource *dict, fz_xml *node) { if (doc->cookie && doc->cookie->abort) return; if (fz_xml_is_tag(node, ""ImageBrush"")) xps_parse_image_brush(ctx, doc, ctm, area, base_uri, dict, node); else if (fz_xml_is_tag(node, ""VisualBrush"")) xps_parse_visual_brush(ctx, doc, ctm, area, base_uri, dict, node); else if (fz_xml_is_tag(node, ""LinearGradientBrush"")) xps_parse_linear_gradient_brush(ctx, doc, ctm, area, base_uri, dict, node); else if (fz_xml_is_tag(node, ""RadialGradientBrush"")) xps_parse_radial_gradient_brush(ctx, doc, ctm, area, base_uri, dict, node); else fz_warn(ctx, ""unknown brush tag: %s"", fz_xml_tag(node)); }"
"int ccnl_ndntlv_varlenint(unsigned char **buf, int *len, int *val) { if (**buf < 253 && *len >= 1) { *val = **buf; *buf += 1; *len -= 1; } else if (**buf == 253 && *len >= 3) {          *val = ((*buf)[1] << 8) | ((*buf)[2] << 0); *buf += 3; *len -= 3; } else if (**buf == 254 && *len >= 5) {          *val = ((*buf)[1] << 24) | ((*buf)[2] << 16) | ((*buf)[3] <<  8) | ((*buf)[4] <<  0); *buf += 5; *len -= 5; } else { return -1; } return 0; }"
"int libxl__qmp_insert_cdrom(libxl__gc *gc, int domid, const libxl_device_disk *disk) { libxl__json_object *args = NULL; int dev_number = libxl__device_disk_dev_number(disk->vdev, NULL, NULL); QMP_PARAMETERS_SPRINTF(&args, ""device"", ""ide-%i"", dev_number); if (disk->format == LIBXL_DISK_FORMAT_EMPTY) { return qmp_run_command(gc, domid, ""eject"", args, NULL, NULL); } else { qmp_parameters_add_string(gc, &args, ""target"", disk->pdev_path); return qmp_run_command(gc, domid, ""change"", args, NULL, NULL); } }"
"struct nfs_client *nfs4_init_client(struct nfs_client *clp, const struct nfs_client_initdata *cl_init) { char buf[INET6_ADDRSTRLEN + 1]; const char *ip_addr = cl_init->ip_addr; struct nfs_client *old; int error; if (clp->cl_cons_state == NFS_CS_READY) return clp; clp->rpc_ops = &nfs_v4_clientops; if (clp->cl_minorversion != 0) __set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags); __set_bit(NFS_CS_DISCRTRY, &clp->cl_flags); __set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags); error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I); if (error == -EINVAL) error = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX); if (error < 0) goto error; if (ip_addr == NULL) { struct sockaddr_storage cb_addr; struct sockaddr *sap = (struct sockaddr *)&cb_addr; error = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr)); if (error < 0) goto error; error = rpc_ntop(sap, buf, sizeof(buf)); if (error < 0) goto error; ip_addr = (const char *)buf; } strlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr)); error = nfs_idmap_new(clp); if (error < 0) { dprintk(""%s: failed to create idmapper. Error = %d\n"", __func__, error); goto error; } __set_bit(NFS_CS_IDMAP, &clp->cl_res_state); error = nfs4_init_client_minor_version(clp); if (error < 0) goto error; error = nfs4_discover_server_trunking(clp, &old); if (error < 0) goto error; if (clp != old) { clp->cl_preserve_clid = true; nfs_mark_client_ready(clp, -EPERM); } clear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags); nfs_put_client(clp); return old; error: nfs_mark_client_ready(clp, error); nfs_put_client(clp); return ERR_PTR(error); }"
"char* parseValue( char* ptr, FileNode& node ) { if (!ptr) CV_PARSE_ERROR_CPP(""Invalid input""); FileNode new_elem; bool have_space = true; int value_type = node.type(); std::string key, key2, type_name; for(;;) { char c = *ptr, d; char* endptr; if( cv_isspace(c) || c == '\0' || (c == '<' && ptr[1] == '!' && ptr[2] == '-') ) { ptr = skipSpaces( ptr, 0 ); if (!ptr) CV_PARSE_ERROR_CPP(""Invalid input""); have_space = true; c = *ptr; } d = ptr[1];   if( c =='<' || c == '\0' ) { int tag_type = 0; int elem_type = FileNode::NONE; if( d == '/' || c == '\0' ) break; ptr = parseTag( ptr, key, type_name, tag_type ); if( tag_type == CV_XML_DIRECTIVE_TAG ) CV_PARSE_ERROR_CPP( ""Directive tags are not allowed here"" ); if( tag_type == CV_XML_EMPTY_TAG ) CV_PARSE_ERROR_CPP( ""Empty tags are not supported"" ); CV_Assert(tag_type == CV_XML_OPENING_TAG); bool binary_string = false; if( !type_name.empty() ) { const char* tn = type_name.c_str(); if( strcmp(tn, ""str"") == 0 ) elem_type = FileNode::STRING; else if( strcmp( tn, ""map"" ) == 0 ) elem_type = FileNode::MAP; else if( strcmp( tn, ""seq"" ) == 0 ) elem_type = FileNode::SEQ; else if( strcmp( tn, ""binary"") == 0) binary_string = true; } new_elem = fs->addNode(node, key, elem_type, 0); if (!binary_string) ptr = parseValue(ptr, new_elem); else { ptr = fs->parseBase64( ptr, 0, new_elem); ptr = skipSpaces( ptr, 0 ); if (!ptr) CV_PARSE_ERROR_CPP(""Invalid input""); } ptr = parseTag( ptr, key2, type_name, tag_type ); if( tag_type != CV_XML_CLOSING_TAG || key2 != key ) CV_PARSE_ERROR_CPP( ""Mismatched closing tag"" ); have_space = true; } else { if( !have_space ) CV_PARSE_ERROR_CPP( ""There should be space between literals"" ); FileNode* elem = &node; if( node.type() != FileNode::NONE ) { fs->convertToCollection( FileNode::SEQ, node ); new_elem = fs->addNode(node, std::string(), FileNode::NONE, 0); elem = &new_elem; } if( value_type != FileNode::STRING && (cv_isdigit(c) || ((c == '-' || c == '+') && (cv_isdigit(d) || d == '.')) || (c == '.' && cv_isalnum(d))) )                 { endptr = ptr + (c == '-' || c == '+'); while( cv_isdigit(*endptr) ) endptr++; if( *endptr == '.' || *endptr == 'e' ) { double fval = fs->strtod( ptr, &endptr ); elem->setValue(FileNode::REAL, &fval); } else { int ival = (int)strtol( ptr, &endptr, 0 ); elem->setValue(FileNode::INT, &ival); } if( endptr == ptr ) CV_PARSE_ERROR_CPP( ""Invalid numeric value (inconsistent explicit type specification?)"" ); ptr = endptr; CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP(); } else { int i = 0, len, is_quoted = 0; if( c == '\""' ) is_quoted = 1; else --ptr; strbuf[0] = '\0'; for( ;; ) { c = *++ptr; CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP(); if( !cv_isalnum(c) ) { if( c == '\""' ) { if( !is_quoted ) CV_PARSE_ERROR_CPP( ""Literal \"" is not allowed within a string. Use &quot;"" ); ++ptr; break; } else if( !cv_isprint(c) || c == '<' || (!is_quoted && cv_isspace(c))) { if( is_quoted ) CV_PARSE_ERROR_CPP( ""Closing \"" is expected"" ); break; } else if( c == '\'' || c == '>' ) { CV_PARSE_ERROR_CPP( ""Literal \' or > are not allowed. Use &apos; or &gt;"" ); } else if( c == '&' ) { if( *++ptr == '#' ) { int val, base = 10; ptr++; if( *ptr == 'x' ) { base = 16; ptr++; } val = (int)strtol( ptr, &endptr, base ); if( (unsigned)val > (unsigned)255 || !endptr || *endptr != ';' ) CV_PARSE_ERROR_CPP( ""Invalid numeric value in the string"" ); c = (char)val; } else { endptr = ptr; do c = *++endptr; while( cv_isalnum(c) ); if( c != ';' ) CV_PARSE_ERROR_CPP( ""Invalid character in the symbol entity name"" ); len = (int)(endptr - ptr); if( len == 2 && memcmp( ptr, ""lt"", len ) == 0 ) c = '<'; else if( len == 2 && memcmp( ptr, ""gt"", len ) == 0 ) c = '>'; else if( len == 3 && memcmp( ptr, ""amp"", len ) == 0 ) c = '&'; else if( len == 4 && memcmp( ptr, ""apos"", len ) == 0 ) c = '\''; else if( len == 4 && memcmp( ptr, ""quot"", len ) == 0 ) c = '\""'; else { memcpy( strbuf + i, ptr-1, len + 2 ); i += len + 2; } } ptr = endptr; CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP(); } } strbuf[i++] = c; if( i >= CV_FS_MAX_LEN ) CV_PARSE_ERROR_CPP( ""Too long string literal"" ); } elem->setValue(FileNode::STRING, strbuf, i); } if( value_type != FileNode::NONE && value_type != FileNode::SEQ && value_type != FileNode::MAP ) break; have_space = false; } } fs->finalizeCollection(node); return ptr; }"
"void jswrap_serial_unsetup(JsVar *parent) { IOEventFlags device = jsiGetDeviceFromClass(parent); JsVar *options = jsvObjectGetChild(parent, DEVICE_OPTIONS_NAME, 0); JsVar *baud = jsvObjectGetChild(parent, USART_BAUDRATE_NAME, 0); if (options) { JshUSARTInfo inf; jsserialPopulateUSARTInfo(&inf, baud, options); if (inf.pinCK!=PIN_UNDEFINED) jshPinSetState(inf.pinCK, JSHPINSTATE_UNDEFINED); if (inf.pinCTS!=PIN_UNDEFINED) jshPinSetState(inf.pinCTS, JSHPINSTATE_UNDEFINED); if (inf.pinRX!=PIN_UNDEFINED) jshPinSetState(inf.pinRX, JSHPINSTATE_UNDEFINED); if (inf.pinTX!=PIN_UNDEFINED) jshPinSetState(inf.pinTX, JSHPINSTATE_UNDEFINED); if (!DEVICE_IS_SERIAL(device)) jsserialEventCallbackKill(parent, &inf); } jsvUnLock2(options, baud); jsvObjectRemoveChild(parent, USART_BAUDRATE_NAME); jsvObjectRemoveChild(parent, DEVICE_OPTIONS_NAME); if (DEVICE_IS_SERIAL(device)) {     jshUSARTUnSetup(device); jshSetFlowControlEnabled(device, false, PIN_UNDEFINED); } }"
"void nvkm_vmm_node_insert(struct nvkm_vmm *vmm, struct nvkm_vma *vma) { struct rb_node **ptr = &vmm->root.rb_node; struct rb_node *parent = NULL; while (*ptr) { struct nvkm_vma *this = rb_entry(*ptr, typeof(*this), tree); parent = *ptr; if (vma->addr < this->addr) ptr = &parent->rb_left; else if (vma->addr > this->addr) ptr = &parent->rb_right; else BUG(); } rb_link_node(&vma->tree, parent, ptr); rb_insert_color(&vma->tree, &vmm->root); }"
"static bool ok_jpg_decode_scan(ok_jpg_decoder *decoder) { decoder->next_restart = 0; ok_jpg_decode_restart(decoder); if (decoder->restart_intervals_remaining > 0) { decoder->restart_intervals_remaining++; } if (decoder->progressive) { void (*decode_function)(ok_jpg_decoder *decoder, ok_jpg_component *c, int16_t *block); if (decoder->scan_prev_scale > 0) { decode_function = ok_jpg_decode_block_subsequent_scan; } else { decode_function = ok_jpg_decode_block_progressive; } if (decoder->num_scan_components == 1) { ok_jpg_component *c = decoder->components + decoder->scan_components[0]; c->next_block = 0; for (int data_unit_y = 0; data_unit_y < c->blocks_v; data_unit_y++) { int16_t *block = c->blocks + (c->next_block * 64); for (int data_unit_x = 0; data_unit_x < c->blocks_h; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); decode_function(decoder, c, block); block += 64; } if (decoder->eof_found || decoder->huffman_error) { return false; } c->next_block += (size_t)(c->H * decoder->data_units_x); } } else { for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; c->next_block = 0; } for (int data_unit_y = 0; data_unit_y < decoder->data_units_y; data_unit_y++) { for (int data_unit_x = 0; data_unit_x < decoder->data_units_x; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; size_t block_index = c->next_block; for (int y = 0; y < c->V; y++) { for (int x = 0; x < c->H; x++) { decode_function(decoder, c, c->blocks + (block_index * 64)); block_index++; } block_index += (size_t)(c->H * (decoder->data_units_x - 1)); } c->next_block += c->H; } } if (decoder->eof_found || decoder->huffman_error) { return false; } for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; c->next_block += (size_t)((c->V - 1) * c->H * decoder->data_units_x); } } } } else { int16_t block[64]; for (int data_unit_y = 0; data_unit_y < decoder->data_units_y; data_unit_y++) { for (int data_unit_x = 0; data_unit_x < decoder->data_units_x; data_unit_x++) { ok_jpg_decode_restart_if_needed(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; int offset_y = 0; for (int y = 0; y < c->V; y++) { int offset_x = 0; for (int x = 0; x < c->H; x++) { ok_jpg_decode_block(decoder, c, block); c->idct(block, c->output + offset_x + offset_y); offset_x += 8; } offset_y += C_WIDTH * 8; } } if (decoder->huffman_error) { return false; } ok_jpg_convert_data_unit(decoder, data_unit_x, data_unit_y); } if (decoder->eof_found) { return false; } } } ok_jpg_dump_bits(decoder); for (int i = 0; i < decoder->num_scan_components; i++) { ok_jpg_component *c = decoder->components + decoder->scan_components[i]; if (!c->complete) { c->complete = decoder->scan_end == 63 && decoder->scan_scale == 0; } } return true; }"
"static gboolean side_in_cb (GSocket *socket, GIOCondition condition, gpointer user_data) { ProxySide *side = user_data; FlatpakProxyClient *client = side->client; GError *error = NULL; Buffer *buffer; gboolean retval = G_SOURCE_CONTINUE; g_object_ref (client); while (!side->closed) { if (!side->got_first_byte) buffer = buffer_new (1, NULL); else if (!client->authenticated) buffer = buffer_new (64, NULL); else buffer = side->current_read_buffer; if (!buffer_read (side, buffer, socket)) { if (buffer != side->current_read_buffer) buffer_unref (buffer); break; } if (!client->authenticated) { if (buffer->pos > 0) { gboolean found_auth_end = FALSE; gsize extra_data; buffer->size = buffer->pos; if (!side->got_first_byte) { buffer->send_credentials = TRUE; side->got_first_byte = TRUE; } else if (side == &client->client_side) { gssize auth_end = find_auth_end (client, buffer); if (auth_end >= 0) { found_auth_end = TRUE; buffer->size = auth_end; extra_data = buffer->pos - buffer->size; if (extra_data > 0) side->extra_input_data = g_bytes_new (buffer->data + buffer->size, extra_data); } } got_buffer_from_side (side, buffer); if (found_auth_end) client->authenticated = TRUE; } else { buffer_unref (buffer); } } else if (buffer->pos == buffer->size) { if (buffer == &side->header_buffer) { gssize required; required = g_dbus_message_bytes_needed (buffer->data, buffer->size, &error); if (required < 0) { g_warning (""Invalid message header read""); side_closed (side); } else { side->current_read_buffer = buffer_new (required, buffer); } } else { got_buffer_from_side (side, buffer); side->header_buffer.pos = 0; side->current_read_buffer = &side->header_buffer; } } } if (side->closed) { side->in_source = NULL; retval = G_SOURCE_REMOVE; } g_object_unref (client); return retval; }"
"bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize) { unsigned CurRequestSize; Init(); CurRequestSize = aRequestSize; memcpy(CurRequest,aRequest,aRequestSize); char * ClientPortPtr; char * TmpPtr; char CP[128];     char * pCP; ClientPortPtr = strstr(CurRequest,""client_port""); if (ClientPortPtr != nullptr) { TmpPtr = strstr(ClientPortPtr,""\r\n""); if (TmpPtr != nullptr) { TmpPtr[0] = 0x00; strcpy(CP,ClientPortPtr); pCP = strstr(CP,""=""); if (pCP != nullptr) { pCP++; strcpy(CP,pCP); pCP = strstr(CP,""-""); if (pCP != nullptr) { pCP[0] = 0x00; m_ClientRTPPort  = atoi(CP); m_ClientRTCPPort = m_ClientRTPPort + 1; }; }; }; }; bool parseSucceeded = false; unsigned i; for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i) { char c = CurRequest[i]; if (c == ' ' || c == '\t') { parseSucceeded = true; break; } CmdName[i] = c; } CmdName[i] = '\0'; if (!parseSucceeded) { printf(""failed to parse RTSP\n""); return false; } printf(""RTSP received %s\n"", CmdName); if (strstr(CmdName,""OPTIONS"")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else if (strstr(CmdName,""DESCRIBE"")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else if (strstr(CmdName,""SETUP"")     != nullptr) m_RtspCmdType = RTSP_SETUP; else if (strstr(CmdName,""PLAY"")      != nullptr) m_RtspCmdType = RTSP_PLAY; else if (strstr(CmdName,""TEARDOWN"")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN; if (m_RtspCmdType == RTSP_SETUP) { TmpPtr = strstr(CurRequest,""RTP/AVP/TCP""); if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false; }; unsigned j = i+1; while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\t')) ++j;     for (; (int)j < (int)(CurRequestSize-8); ++j) { if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   && (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') && (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') && (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') && CurRequest[j+4] == ':' && CurRequest[j+5] == '/') { j += 6; if (CurRequest[j] == '/') {                   ++j; unsigned uidx = 0; while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1) {                       m_URLHostPort[uidx] = CurRequest[j]; uidx++; ++j; }; } else --j; i = j; break; } } parseSucceeded = false; for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k) { if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   && CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   && CurRequest[k+4] == '/') { while (--k >= i && CurRequest[k] == ' ') {} unsigned k1 = k; while (k1 > i && CurRequest[k1] != '/') --k1; if (k - k1 + 1 > sizeof(m_URLSuffix)) return false; unsigned n = 0, k2 = k1+1; while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++]; m_URLSuffix[n] = '\0'; if (k1 - i > sizeof(m_URLPreSuffix)) return false; n = 0; k2 = i + 1; while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++]; m_URLPreSuffix[n] = '\0'; i = k + 7; parseSucceeded = true; break; } } if (!parseSucceeded) return false; parseSucceeded = false; for (j = i; (int)j < (int)(CurRequestSize-5); ++j) { if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' && CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' && CurRequest[j+4] == ':') { j += 5; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned n; for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j) { char c = CurRequest[j]; if (c == '\r' || c == '\n') { parseSucceeded = true; break; } m_CSeq[n] = c; } m_CSeq[n] = '\0'; break; } } if (!parseSucceeded) return false; for (j = i; (int)j < (int)(CurRequestSize-15); ++j) { if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  && CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  && CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  && CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  && (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') && CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' && CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' && CurRequest[j+13] == 'h' && CurRequest[j+14] == ':') { j += 15; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned num; if (sscanf(&CurRequest[j], ""%u"", &num) == 1) m_ContentLength = num; } } return true; }"
"static int nsim_bpf_map_alloc(struct netdevsim *ns, struct bpf_offloaded_map *offmap) { struct nsim_bpf_bound_map *nmap; int i, err; if (WARN_ON(offmap->map.map_type != BPF_MAP_TYPE_ARRAY && offmap->map.map_type != BPF_MAP_TYPE_HASH)) return -EINVAL; if (offmap->map.max_entries > NSIM_BPF_MAX_KEYS) return -ENOMEM; if (offmap->map.map_flags) return -EINVAL; nmap = kzalloc(sizeof(*nmap), GFP_USER); if (!nmap) return -ENOMEM; offmap->dev_priv = nmap; nmap->ns = ns; nmap->map = offmap; mutex_init(&nmap->mutex); if (offmap->map.map_type == BPF_MAP_TYPE_ARRAY) { for (i = 0; i < ARRAY_SIZE(nmap->entry); i++) { u32 *key; err = nsim_map_alloc_elem(offmap, i); if (err) goto err_free; key = nmap->entry[i].key; *key = i; } } offmap->dev_ops = &nsim_bpf_map_ops; list_add_tail(&nmap->l, &ns->nsim_dev->bpf_bound_maps); return 0; err_free: while (--i >= 0) { kfree(nmap->entry[i].key); kfree(nmap->entry[i].value); } kfree(nmap); return err; }"
"int Protocol2PacketHandler::readRx(PortHandler *port, uint8_t id, uint16_t length, uint8_t *data, uint8_t *error) { int result                  = COMM_TX_FAIL; uint8_t *rxpacket           = (uint8_t *)malloc(length + 11 + (length / 3)); if (rxpacket == NULL) return result; do { result = rxPacket(port, rxpacket); } while (result == COMM_SUCCESS && rxpacket[PKT_ID] != id); if (result == COMM_SUCCESS && rxpacket[PKT_ID] == id) { if (error != 0) *error = (uint8_t)rxpacket[PKT_ERROR]; for (uint16_t s = 0; s < length; s++) { data[s] = rxpacket[PKT_PARAMETER0 + 1 + s]; } } free(rxpacket); return result; }"
"static int decompileCALLFUNCTION(int n, SWF_ACTION *actions, int maxn) { struct SWF_ACTIONPUSHPARAM *meth, *nparam; SanityCheck(SWF_CALLMETHOD, n > 0 && actions[n-1].SWF_ACTIONRECORD.ActionCode == SWFACTION_PUSH, ""CALLMETHOD not preceeded by PUSH"") meth=pop(); nparam=pop(); if (nparam->p.Integer>25) { INDENT println(""nparam->p.Integer); nparam->p.Integer=0; } push(newVar_N("""","""",getName(meth),""("", nparam->p.Integer,"")"")); if (OpCode(actions, n+1, maxn) == SWFACTION_POP) { INDENT puts(getName(pop())); println("";"" ); return 1; } return 0; }"
"void Con_Dump_f( void ) { int l, x, i; short   *line; fileHandle_t f; intbufferlen; char*buffer; charfilename[MAX_QPATH]; if ( Cmd_Argc() != 2 ) { Com_Printf( ""usage: condump <filename>\n"" ); return; } Q_strncpyz( filename, Cmd_Argv( 1 ), sizeof( filename ) ); COM_DefaultExtension( filename, sizeof( filename ), "".txt"" ); f = FS_FOpenFileWrite( filename ); if ( !f ) { Com_Printf (""ERROR: couldn't open %s.\n"", filename); return; } Com_Printf (""Dumped console text to %s.\n"", filename ); for ( l = con.current - con.totallines + 1 ; l <= con.current ; l++ ) { line = con.text + ( l % con.totallines ) * con.linewidth; for ( x = 0 ; x < con.linewidth ; x++ ) if ( ( line[x] & 0xff ) != ' ' ) { break; } if ( x != con.linewidth ) { break; } } #ifdef _WIN32 bufferlen = con.linewidth + 3 * sizeof ( char ); #else bufferlen = con.linewidth + 2 * sizeof ( char ); #endif buffer = Hunk_AllocateTempMemory( bufferlen ); buffer[bufferlen-1] = 0; for ( ; l <= con.current ; l++ ) { line = con.text + ( l % con.totallines ) * con.linewidth; for ( i = 0; i < con.linewidth; i++ ) buffer[i] = line[i] & 0xff; for ( x = con.linewidth - 1 ; x >= 0 ; x-- ) { if ( buffer[x] == ' ' ) { buffer[x] = 0; } else { break; } } #ifdef _WIN32 Q_strcat(buffer, bufferlen, ""\r\n""); #else Q_strcat(buffer, bufferlen, ""\n""); #endif FS_Write( buffer, strlen( buffer ), f ); } Hunk_FreeTempMemory( buffer ); FS_FCloseFile( f ); }"
"bool CairoRescaleBox::downScaleImage(unsigned orig_width, unsigned orig_height, signed scaled_width, signed scaled_height, unsigned short int start_column, unsigned short int start_row, unsigned short int width, unsigned short int height, cairo_surface_t *dest_surface) { int pixel_coverage_x, pixel_coverage_y; int dest_y; int src_y = 0; uint32_t *scanline; int *x_coverage = nullptr; int *y_coverage = nullptr; uint32_t *temp_buf = nullptr; bool retval = false; unsigned int *dest; int dst_stride; dest = reinterpret_cast<unsigned int *>(cairo_image_surface_get_data (dest_surface)); dst_stride = cairo_image_surface_get_stride (dest_surface); scanline = (uint32_t*)gmallocn (orig_width, sizeof(int)); x_coverage = (int *)gmallocn (orig_width, sizeof(int)); y_coverage = (int *)gmallocn (orig_height, sizeof(int)); temp_buf = (uint32_t *)gmallocn3 ((orig_height + scaled_height-1)/scaled_height+1, scaled_width, sizeof(uint32_t)); if (!x_coverage || !y_coverage || !scanline || !temp_buf) goto cleanup; pixel_coverage_x = compute_coverage (x_coverage, orig_width, scaled_width); pixel_coverage_y = compute_coverage (y_coverage, orig_height, scaled_height); assert (width + start_column <= scaled_width); for (dest_y = 0; dest_y < start_row; dest_y++) { int box = 1 << FIXED_SHIFT; int start_coverage_y = y_coverage[dest_y]; box -= start_coverage_y; src_y++; while (box >= pixel_coverage_y) { box -= pixel_coverage_y; src_y++; } } for (; dest_y < start_row + height; dest_y++) { int columns = 0; int box = 1 << FIXED_SHIFT; int start_coverage_y = y_coverage[dest_y]; getRow(src_y, scanline); downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x); columns++; src_y++; box -= start_coverage_y; while (box >= pixel_coverage_y) { getRow(src_y, scanline); downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x); columns++; src_y++; box -= pixel_coverage_y; } if (box > 0) { getRow(src_y, scanline); downsample_row_box_filter (start_column, width, scanline, temp_buf + width * columns, x_coverage, pixel_coverage_x); columns++; } downsample_columns_box_filter (width, start_coverage_y, pixel_coverage_y, temp_buf, dest); dest += dst_stride / 4; } retval = true; cleanup: free (x_coverage); free (y_coverage); free (temp_buf); free (scanline); return retval; }"
"void FrameLoader::load(const FrameLoadRequest& passedRequest, FrameLoadType frameLoadType, HistoryItem* historyItem, HistoryLoadType historyLoadType) { ASSERT(m_frame->document()); if (m_inStopAllLoaders) return; if (m_frame->page()->defersLoading() && isBackForwardLoadType(frameLoadType)) { m_deferredHistoryLoad = DeferredHistoryLoad::create(passedRequest.resourceRequest(), historyItem, frameLoadType, historyLoadType); return; } FrameLoadRequest request(passedRequest); request.resourceRequest().setHasUserGesture(UserGestureIndicator::processingUserGesture()); if (!prepareRequestForThisFrame(request)) return; Frame* targetFrame = request.form() ? nullptr : m_frame->findFrameForNavigation(AtomicString(request.frameName()), *m_frame); if (isBackForwardLoadType(frameLoadType)) { ASSERT(historyItem); m_provisionalItem = historyItem; } if (targetFrame && targetFrame != m_frame) { bool wasInSamePage = targetFrame->page() == m_frame->page(); request.setFrameName(""_self""); targetFrame->navigate(request); Page* page = targetFrame->page(); if (!wasInSamePage && page) page->chromeClient().focus(); return; } setReferrerForFrameRequest(request.resourceRequest(), request.getShouldSendReferrer(), request.originDocument()); FrameLoadType newLoadType = (frameLoadType == FrameLoadTypeStandard) ? determineFrameLoadType(request) : frameLoadType; NavigationPolicy policy = navigationPolicyForRequest(request); if (shouldOpenInNewWindow(targetFrame, request, policy)) { if (policy == NavigationPolicyDownload) { client()->loadURLExternally(request.resourceRequest(), NavigationPolicyDownload, String(), false); } else { request.resourceRequest().setFrameType(WebURLRequest::FrameTypeAuxiliary); createWindowForRequest(request, *m_frame, policy, request.getShouldSendReferrer(), request.getShouldSetOpener()); } return; } const KURL& url = request.resourceRequest().url(); bool sameDocumentHistoryNavigation = isBackForwardLoadType(newLoadType) && historyLoadType == HistorySameDocumentLoad; bool sameDocumentNavigation = policy == NavigationPolicyCurrentTab && shouldPerformFragmentNavigation( request.form(), request.resourceRequest().httpMethod(), newLoadType, url); if (sameDocumentHistoryNavigation || sameDocumentNavigation) { ASSERT(historyItem || !sameDocumentHistoryNavigation); RefPtr<SerializedScriptValue> stateObject = sameDocumentHistoryNavigation ? historyItem->stateObject() : nullptr; if (!sameDocumentHistoryNavigation) { m_documentLoader->setNavigationType(determineNavigationType( newLoadType, false, request.triggeringEvent())); if (shouldTreatURLAsSameAsCurrent(url)) newLoadType = FrameLoadTypeReplaceCurrentItem; } loadInSameDocument(url, stateObject, newLoadType, historyLoadType, request.clientRedirect()); return; } startLoad(request, newLoadType, policy); }"
"int sqlite3WindowRewrite(Parse *pParse, Select *p){ int rc = SQLITE_OK; if( p->pWin && p->pPrior==0 && (p->selFlags & SF_WinRewrite)==0 ){ Vdbe *v = sqlite3GetVdbe(pParse); sqlite3 *db = pParse->db; Select *pSub = 0;              SrcList *pSrc = p->pSrc; Expr *pWhere = p->pWhere; ExprList *pGroupBy = p->pGroupBy; Expr *pHaving = p->pHaving; ExprList *pSort = 0; ExprList *pSublist = 0;        Window *pMWin = p->pWin;       Window *pWin;                  Table *pTab; pTab = sqlite3DbMallocZero(db, sizeof(Table)); if( pTab==0 ){ return SQLITE_NOMEM; } p->pSrc = 0; p->pWhere = 0; p->pGroupBy = 0; p->pHaving = 0; p->selFlags &= ~SF_Aggregate; p->selFlags |= SF_WinRewrite; pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0); pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1); if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){ int nSave = pSort->nExpr; pSort->nExpr = p->pOrderBy->nExpr; if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){ sqlite3ExprListDelete(db, p->pOrderBy); p->pOrderBy = 0; } pSort->nExpr = nSave; } pMWin->iEphCsr = pParse->nTab++; pParse->nTab += 3; selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist); selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist); pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0); pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0); pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0); for(pWin=pMWin; pWin; pWin=pWin->pNextWin){ ExprList *pArgs = pWin->pOwner->x.pList; if( pWin->pFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){ selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist); pWin->iArgCol = (pSublist ? pSublist->nExpr : 0); pWin->bExprArgs = 1; }else{ pWin->iArgCol = (pSublist ? pSublist->nExpr : 0); pSublist = exprListAppendList(pParse, pSublist, pArgs, 0); } if( pWin->pFilter ){ Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0); pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter); } pWin->regAccum = ++pParse->nMem; pWin->regResult = ++pParse->nMem; sqlite3VdbeAddOp2(v, OP_Null, 0, pWin->regAccum); } if( pSublist==0 ){ pSublist = sqlite3ExprListAppend(pParse, 0,  sqlite3Expr(db, TK_INTEGER, ""0"") ); } pSub = sqlite3SelectNew( pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0 ); p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0); if( p->pSrc ){ Table *pTab2; p->pSrc->a[0].pSelect = pSub; sqlite3SrcListAssignCursors(pParse, p->pSrc); pSub->selFlags |= SF_Expanded; pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, SQLITE_AFF_NONE); if( pTab2==0 ){ rc = SQLITE_NOMEM; }else{ memcpy(pTab, pTab2, sizeof(Table)); pTab->tabFlags |= TF_Ephemeral; p->pSrc->a[0].pTab = pTab; pTab = pTab2; } sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pMWin->iEphCsr, pSublist->nExpr); sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+1, pMWin->iEphCsr); sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+2, pMWin->iEphCsr); sqlite3VdbeAddOp2(v, OP_OpenDup, pMWin->iEphCsr+3, pMWin->iEphCsr); }else{ sqlite3SelectDelete(db, pSub); } if( db->mallocFailed ) rc = SQLITE_NOMEM; sqlite3DbFree(db, pTab); } return rc; }"
"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kNGroupsOffset = 12; const size_t kFirstGroupOffset = 16; const size_t kGroupSize = 12; const size_t kStartCharCodeOffset = 0; const size_t kEndCharCodeOffset = 4; const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;          if (kFirstGroupOffset > size) { return false; } uint32_t nGroups = readU32(data, kNGroupsOffset); if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) { return false; } for (uint32_t i = 0; i < nGroups; i++) { uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize; uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset); uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset); addRange(coverage, start, end + 1);      } return true; }"
"static int vmx_msr_write_intercept(unsigned int msr, uint64_t msr_content) { struct vcpu *v = current; HVM_DBG_LOG(DBG_LEVEL_MSR, ""ecx=%#x, msr_value=%#""PRIx64, msr, msr_content); switch ( msr ) { case MSR_IA32_SYSENTER_CS: __vmwrite(GUEST_SYSENTER_CS, msr_content); break; case MSR_IA32_SYSENTER_ESP: if ( !is_canonical_address(msr_content) ) goto gp_fault; __vmwrite(GUEST_SYSENTER_ESP, msr_content); break; case MSR_IA32_SYSENTER_EIP: if ( !is_canonical_address(msr_content) ) goto gp_fault; __vmwrite(GUEST_SYSENTER_EIP, msr_content); break; case MSR_FS_BASE: case MSR_GS_BASE: case MSR_SHADOW_GS_BASE: if ( !is_canonical_address(msr_content) ) goto gp_fault; if ( msr == MSR_FS_BASE ) __vmwrite(GUEST_FS_BASE, msr_content); else if ( msr == MSR_GS_BASE ) __vmwrite(GUEST_GS_BASE, msr_content); else wrgsshadow(msr_content); break; case MSR_STAR: v->arch.hvm_vmx.star = msr_content; wrmsrl(MSR_STAR, msr_content); break; case MSR_LSTAR: if ( !is_canonical_address(msr_content) ) goto gp_fault; v->arch.hvm_vmx.lstar = msr_content; wrmsrl(MSR_LSTAR, msr_content); break; case MSR_CSTAR: if ( !is_canonical_address(msr_content) ) goto gp_fault; v->arch.hvm_vmx.cstar = msr_content; break; case MSR_SYSCALL_MASK: v->arch.hvm_vmx.sfmask = msr_content; wrmsrl(MSR_SYSCALL_MASK, msr_content); break; case MSR_IA32_DEBUGCTLMSR: { uint64_t supported = IA32_DEBUGCTLMSR_LBR | IA32_DEBUGCTLMSR_BTF; if ( boot_cpu_has(X86_FEATURE_RTM) ) supported |= IA32_DEBUGCTLMSR_RTM; if ( msr_content & ~supported ) { if ( vpmu_do_wrmsr(msr, msr_content, supported) ) break; } if ( !(v->arch.hvm_vmx.lbr_flags & LBR_MSRS_INSERTED) && (msr_content & IA32_DEBUGCTLMSR_LBR) ) { const struct lbr_info *lbr = last_branch_msr_get(); if ( unlikely(!lbr) ) { gprintk(XENLOG_ERR, ""Unknown Host LBR MSRs\n""); domain_crash(v->domain); return X86EMUL_OKAY; } for ( ; lbr->count; lbr++ ) { unsigned int i; for ( i = 0; i < lbr->count; i++ ) { int rc = vmx_add_guest_msr(v, lbr->base + i, 0); if ( unlikely(rc) ) { gprintk(XENLOG_ERR, ""Guest load/save list error %d\n"", rc); domain_crash(v->domain); return X86EMUL_OKAY; } vmx_clear_msr_intercept(v, lbr->base + i, VMX_MSR_RW); } } v->arch.hvm_vmx.lbr_flags |= LBR_MSRS_INSERTED; if ( lbr_tsx_fixup_needed ) v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_TSX; if ( bdw_erratum_bdf14_fixup_needed ) v->arch.hvm_vmx.lbr_flags |= LBR_FIXUP_BDF14; } __vmwrite(GUEST_IA32_DEBUGCTL, msr_content); break; } case MSR_IA32_FEATURE_CONTROL: case MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC: goto gp_fault; case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7): case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(7): case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2: case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL: case MSR_IA32_PEBS_ENABLE: case MSR_IA32_DS_AREA: if ( vpmu_do_wrmsr(msr, msr_content, 0) ) goto gp_fault; break; default: if ( passive_domain_do_wrmsr(msr, msr_content) ) return X86EMUL_OKAY; if ( wrmsr_viridian_regs(msr, msr_content) )  break; if ( vmx_write_guest_msr(v, msr, msr_content) == 0 || is_last_branch_msr(msr) ) break; switch ( wrmsr_hypervisor_regs(msr, msr_content) ) { case -ERESTART: return X86EMUL_RETRY; case 0: if ( rdmsr_safe(msr, msr_content) == 0 ) break; goto gp_fault; case 1: break; default: goto gp_fault; } break; } return X86EMUL_OKAY; gp_fault: return X86EMUL_EXCEPTION; }"
"static int do_add_counters(struct net *net, sockptr_t arg, unsigned int len) { unsigned int i; struct xt_counters_info tmp; struct xt_counters *paddc; struct xt_table *t; const struct xt_table_info *private; int ret = 0; struct ip6t_entry *iter; unsigned int addend; paddc = xt_copy_counters(arg, len, &tmp); if (IS_ERR(paddc)) return PTR_ERR(paddc); t = xt_find_table_lock(net, AF_INET6, tmp.name); if (IS_ERR(t)) { ret = PTR_ERR(t); goto free; } local_bh_disable(); private = t->private; if (private->number != tmp.num_counters) { ret = -EINVAL; goto unlock_up_free; } i = 0; addend = xt_write_recseq_begin(); xt_entry_foreach(iter, private->entries, private->size) { struct xt_counters *tmp; tmp = xt_get_this_cpu_counter(&iter->counters); ADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt); ++i; } xt_write_recseq_end(addend); unlock_up_free: local_bh_enable(); xt_table_unlock(t); module_put(t->me); free: vfree(paddc); return ret; }"
"Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr, const XlaPlatformInfo& platform_info, XlaCompilationCache** cache) { if (platform_info.xla_device_metadata()) { *cache = new XlaCompilationCache( platform_info.xla_device_metadata()->client(), platform_info.xla_device_metadata()->jit_device_type()); return Status::OK(); } auto platform = se::MultiPlatformManager::PlatformWithId(platform_info.platform_id()); if (!platform.ok()) { return platform.status(); } StatusOr<xla::Compiler*> compiler_for_platform = xla::Compiler::GetForPlatform(platform.ValueOrDie()); if (!compiler_for_platform.ok()) { const Status& status = compiler_for_platform.status(); if (status.code() == error::NOT_FOUND) { return errors::Unimplemented(""Could not find compiler for platform "", platform.ValueOrDie()->Name(), "": "", status.ToString()); } } xla::LocalClientOptions client_options; client_options.set_platform(platform.ValueOrDie()); client_options.set_intra_op_parallelism_threads( device->tensorflow_cpu_worker_threads()->num_threads); string allowed_gpus = flr->config_proto()->gpu_options().visible_device_list(); TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids, ParseVisibleDeviceList(allowed_gpus)); client_options.set_allowed_devices(gpu_ids); auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options); if (!client.ok()) { return client.status(); } const XlaOpRegistry::DeviceRegistration* registration; if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(), &registration)) { return errors::InvalidArgument(""No JIT device registered for "", platform_info.device_type().type()); } *cache = new XlaCompilationCache( client.ValueOrDie(), DeviceType(registration->compilation_device_name)); return Status::OK(); }"
"static void rs_input(void) { LOG_INFO(""Received RS from ""); LOG_INFO_6ADDR(&UIP_IP_BUF->srcipaddr); LOG_INFO_("" to ""); LOG_INFO_6ADDR(&UIP_IP_BUF->destipaddr); LOG_INFO_(""\n""); UIP_STAT(++uip_stat.nd6.recv); #if UIP_CONF_IPV6_CHECKS if((UIP_IP_BUF->ttl != UIP_ND6_HOP_LIMIT) || (UIP_ICMP_BUF->icode != 0)) { LOG_ERR(""RS received is bad\n""); goto discard; } #endif  nd6_opt_offset = UIP_ND6_RS_LEN; nd6_opt_llao = NULL; while(uip_l3_icmp_hdr_len + nd6_opt_offset < uip_len) { #if UIP_CONF_IPV6_CHECKS if(ND6_OPT_HDR_BUF(nd6_opt_offset)->len == 0) { LOG_ERR(""RS received is bad\n""); goto discard; } #endif  switch (ND6_OPT_HDR_BUF(nd6_opt_offset)->type) { case UIP_ND6_OPT_SLLAO: nd6_opt_llao = (uint8_t *)ND6_OPT_HDR_BUF(nd6_opt_offset); break; default: LOG_WARN(""ND option not supported in RS\n""); break; } nd6_opt_offset += (ND6_OPT_HDR_BUF(nd6_opt_offset)->len << 3); } if(nd6_opt_llao != NULL) { #if UIP_CONF_IPV6_CHECKS if(uip_is_addr_unspecified(&UIP_IP_BUF->srcipaddr)) { LOG_ERR(""RS received is bad\n""); goto discard; } else { #endif  uip_lladdr_t lladdr_aligned; extract_lladdr_from_llao_aligned(&lladdr_aligned); if((nbr = uip_ds6_nbr_lookup(&UIP_IP_BUF->srcipaddr)) == NULL) { uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned, 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL); } else { const uip_lladdr_t *lladdr = uip_ds6_nbr_get_ll(nbr); if(lladdr == NULL) { goto discard; } if(memcmp(&nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET], lladdr, UIP_LLADDR_LEN) != 0) { uip_ds6_nbr_t nbr_data; nbr_data = *nbr; uip_ds6_nbr_rm(nbr); nbr = uip_ds6_nbr_add(&UIP_IP_BUF->srcipaddr, &lladdr_aligned, 0, NBR_STALE, NBR_TABLE_REASON_IPV6_ND, NULL); nbr->reachable = nbr_data.reachable; nbr->sendns = nbr_data.sendns; nbr->nscount = nbr_data.nscount; } nbr->isrouter = 0; } #if UIP_CONF_IPV6_CHECKS } #endif  } uip_ds6_send_ra_sollicited(); discard: uipbuf_clear(); return; }"
"static void nfs_name_snoop_fh(packet_info *pinfo, proto_tree *tree, tvbuff_t *tvb, int fh_offset, int fh_length, gboolean hidden) { nfs_name_snoop_key_t  key; nfs_name_snoop_t     *nns = NULL; if (!pinfo->fd->flags.visited) { key.key = 0; key.fh_length = fh_length; key.fh = (const unsigned char *)tvb_get_ptr(tvb, fh_offset, fh_length); nns = (nfs_name_snoop_t *)g_hash_table_lookup(nfs_name_snoop_matched, &key); if (nns) { guint32 fhlen; guint32 *fhdata; wmem_tree_key_t fhkey[3]; fhlen = nns->fh_length; fhdata = (guint32 *)g_memdup(nns->fh, fhlen); fhkey[0].length = 1; fhkey[0].key= &fhlen; fhkey[1].length = fhlen/4; fhkey[1].key= fhdata; fhkey[2].length = 0; wmem_tree_insert32_array(nfs_name_snoop_known, &fhkey[0], nns); g_free(fhdata); if (nfs_file_name_full_snooping) { char *name = NULL, *pos = NULL; int len = 0; nfs_full_name_snoop(nns, &len, &name, &pos); if (name) { nns->full_name = name; nns->full_name_len = len; } } } } if (!nns) { guint32 fhlen; guint32 *fhdata; wmem_tree_key_t fhkey[3]; fhlen = fh_length; fhdata = (guint32 *)tvb_memdup(wmem_packet_scope(), tvb, fh_offset, fh_length); fhkey[0].length = 1; fhkey[0].key= &fhlen; fhkey[1].length = fhlen/4; fhkey[1].key= fhdata; fhkey[2].length = 0; nns = (nfs_name_snoop_t *)wmem_tree_lookup32_array(nfs_name_snoop_known, &fhkey[0]); } if (nns) { proto_item *fh_item = NULL; if (hidden) { fh_item = proto_tree_add_string(tree, hf_nfs_name, NULL, 0, 0, nns->name); PROTO_ITEM_SET_HIDDEN(fh_item); } else { fh_item = proto_tree_add_string(tree, hf_nfs_name, tvb, fh_offset, 0, nns->name); } PROTO_ITEM_SET_GENERATED(fh_item); if (nns->full_name) { if (hidden) { fh_item = proto_tree_add_string(tree, hf_nfs_full_name, NULL, 0, 0, nns->full_name); PROTO_ITEM_SET_HIDDEN(fh_item); } else { fh_item = proto_tree_add_string_format_value(tree, hf_nfs_full_name, tvb, fh_offset, 0, nns->full_name, ""%s"", nns->full_name); } PROTO_ITEM_SET_GENERATED(fh_item); } } }"
"static Uint8 * Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical) { Uint8 *map; int i; if (identical) { if (src->ncolors <= dst->ncolors) { if (src == dst || (SDL_memcmp (src->colors, dst->colors, src->ncolors * sizeof(SDL_Color)) == 0)) { *identical = 1; return (NULL); } } *identical = 0; } map = (Uint8 *) SDL_malloc(src->ncolors); if (map == NULL) { SDL_OutOfMemory(); return (NULL); } for (i = 0; i < src->ncolors; ++i) { map[i] = SDL_FindColor(dst, src->colors[i].r, src->colors[i].g, src->colors[i].b, src->colors[i].a); } return (map); }"
"int eval0_retarg( char_u*arg, typval_T*rettv, exarg_T*eap, evalarg_T*evalarg, char_u**retarg) { intret; char_u*p; char_u*expr_end; intdid_emsg_before = did_emsg; intcalled_emsg_before = called_emsg; intflags = evalarg == NULL ? 0 : evalarg->eval_flags; intcheck_for_end = retarg == NULL; intend_error = FALSE; p = skipwhite(arg); ret = eval1(&p, rettv, evalarg); expr_end = p; p = skipwhite(p); if (in_vim9script() && p > expr_end && retarg == NULL) while (*p == '#') { char_u *nl = vim_strchr(p, NL); if (nl == NULL) break; p = skipwhite(nl + 1); if (eap != NULL && *p != NUL) eap->nextcmd = p; check_for_end = FALSE; } if (ret != FAIL && check_for_end) end_error = !ends_excmd2(arg, p); if (ret == FAIL || end_error) { if (ret != FAIL) clear_tv(rettv); if (!aborting() && did_emsg == did_emsg_before && called_emsg == called_emsg_before && (flags & EVAL_CONSTANT) == 0 && (!in_vim9script() || !vim9_bad_comment(p))) { if (end_error) semsg(_(e_trailing_characters_str), p); else semsg(_(e_invalid_expression_str), arg); } if (eap != NULL && skipwhite(p)[0] == '|' && skipwhite(p)[1] != '|') eap->nextcmd = check_nextcmd(p); return FAIL; } if (retarg != NULL) *retarg = p; else if (check_for_end && eap != NULL) set_nextcmd(eap, p); return ret; }"
"int CLua::loadfile(lua_State *ls, const char *filename, bool trusted, bool die_on_fail) { if (!ls) return -1; if (!is_path_safe(filename, trusted)) { lua_pushstring( ls, make_stringf(""invalid filename: %s"", filename).c_str()); return -1; } string file = datafile_path(filename, die_on_fail); if (file.empty()) { lua_pushstring(ls, make_stringf(""Can't find \""%s\"""", filename).c_str()); return -1; } FileLineInput f(file.c_str()); string script; while (!f.eof()) script += f.get_line() + ""\n""; return luaL_loadbuffer(ls, &script[0], script.length(), (""@"" + file).c_str()); }"
"void xps_select_font_encoding(xps_font_t *font, int idx) { byte *cmapdata, *entry; int pid, eid; if (idx < 0 || idx >= font->cmapsubcount) return; cmapdata = font->data + font->cmaptable; entry = cmapdata + 4 + idx * 8; pid = u16(entry + 0); eid = u16(entry + 2); font->cmapsubtable = font->cmaptable + u32(entry + 4); font->usepua = (pid == 3 && eid == 0); }"
"static int loadImage(TIFF *in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr) { uint32_t i; float xres = 0.0, yres = 0.0; uint32_t nstrips = 0, ntiles = 0; uint16_t planar = 0; uint16_t bps = 0, spp = 0, res_unit = 0; uint16_t orientation = 0; uint16_t input_compression = 0, input_photometric = 0; uint16_t subsampling_horiz, subsampling_vert; uint32_t width = 0, length = 0; tmsize_t stsize = 0, tlsize = 0, buffsize = 0; tmsize_t scanlinesize = 0; uint32_t tw = 0, tl = 0;  tmsize_t tile_rowsize = 0; unsigned char *read_buff = NULL; unsigned char *new_buff = NULL; int readunit = 0; static tmsize_t prev_readsize = 0; TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp); TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar); TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation); if (!TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) TIFFError(""loadImage"", ""Image lacks Photometric interpretation tag""); if (!TIFFGetField(in, TIFFTAG_IMAGEWIDTH, &width)) TIFFError(""loadimage"", ""Image lacks image width tag""); if (!TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length)) TIFFError(""loadimage"", ""Image lacks image length tag""); TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres); TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres); if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit)) res_unit = RESUNIT_INCH; if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)) input_compression = COMPRESSION_NONE; #ifdef DEBUG2 char compressionid[16]; switch (input_compression) { case COMPRESSION_NONE:  strcpy(compressionid, ""None/dump""); break; case COMPRESSION_CCITTRLE:  strcpy(compressionid, ""Huffman RLE""); break; case COMPRESSION_CCITTFAX3:  strcpy(compressionid, ""Group3 Fax""); break; case COMPRESSION_CCITTFAX4:  strcpy(compressionid, ""Group4 Fax""); break; case COMPRESSION_LZW:  strcpy(compressionid, ""LZW""); break; case COMPRESSION_OJPEG:  strcpy(compressionid, ""Old Jpeg""); break; case COMPRESSION_JPEG:  strcpy(compressionid, ""New Jpeg""); break; case COMPRESSION_NEXT:  strcpy(compressionid, ""Next RLE""); break; case COMPRESSION_CCITTRLEW:  strcpy(compressionid, ""CITTRLEW""); break; case COMPRESSION_PACKBITS:  strcpy(compressionid, ""Mac Packbits""); break; case COMPRESSION_THUNDERSCAN:  strcpy(compressionid, ""Thunderscan""); break; case COMPRESSION_IT8CTPAD:  strcpy(compressionid, ""IT8 padded""); break; case COMPRESSION_IT8LW:  strcpy(compressionid, ""IT8 RLE""); break; case COMPRESSION_IT8MP:  strcpy(compressionid, ""IT8 mono""); break; case COMPRESSION_IT8BL:  strcpy(compressionid, ""IT8 lineart""); break; case COMPRESSION_PIXARFILM:  strcpy(compressionid, ""Pixar 10 bit""); break; case COMPRESSION_PIXARLOG:  strcpy(compressionid, ""Pixar 11bit""); break; case COMPRESSION_DEFLATE:  strcpy(compressionid, ""Deflate""); break; case COMPRESSION_ADOBE_DEFLATE:  strcpy(compressionid, ""Adobe deflate""); break; default: strcpy(compressionid, ""None/unknown""); break; } TIFFError(""loadImage"", ""Input compression %s"", compressionid); #endif scanlinesize = TIFFScanlineSize(in); image->bps = bps; image->spp = spp; image->planar = planar; image->width = width; image->length = length; image->xres = xres; image->yres = yres; image->res_unit = res_unit; image->compression = input_compression; image->photometric = input_photometric; #ifdef DEBUG2 char photometricid[12]; switch (input_photometric) { case PHOTOMETRIC_MINISWHITE: strcpy(photometricid, ""MinIsWhite""); break; case PHOTOMETRIC_MINISBLACK: strcpy(photometricid, ""MinIsBlack""); break; case PHOTOMETRIC_RGB: strcpy(photometricid, ""RGB""); break; case PHOTOMETRIC_PALETTE: strcpy(photometricid, ""Palette""); break; case PHOTOMETRIC_MASK: strcpy(photometricid, ""Mask""); break; case PHOTOMETRIC_SEPARATED: strcpy(photometricid, ""Separated""); break; case PHOTOMETRIC_YCBCR: strcpy(photometricid, ""YCBCR""); break; case PHOTOMETRIC_CIELAB: strcpy(photometricid, ""CIELab""); break; case PHOTOMETRIC_ICCLAB: strcpy(photometricid, ""ICCLab""); break; case PHOTOMETRIC_ITULAB: strcpy(photometricid, ""ITULab""); break; case PHOTOMETRIC_LOGL: strcpy(photometricid, ""LogL""); break; case PHOTOMETRIC_LOGLUV: strcpy(photometricid, ""LOGLuv""); break; default: strcpy(photometricid, ""Unknown""); break; } TIFFError(""loadImage"", ""Input photometric interpretation %s"", photometricid); #endif image->orientation = orientation; switch (orientation) { case 0: case ORIENTATION_TOPLEFT: image->adjustments = 0; break; case ORIENTATION_TOPRIGHT: image->adjustments = MIRROR_HORIZ; break; case ORIENTATION_BOTRIGHT: image->adjustments = ROTATECW_180; break; case ORIENTATION_BOTLEFT: image->adjustments = MIRROR_VERT; break; case ORIENTATION_LEFTTOP: image->adjustments = MIRROR_VERT | ROTATECW_90; break; case ORIENTATION_RIGHTTOP: image->adjustments = ROTATECW_90; break; case ORIENTATION_RIGHTBOT: image->adjustments = MIRROR_VERT | ROTATECW_270; break; case ORIENTATION_LEFTBOT: image->adjustments = ROTATECW_270; break; default: image->adjustments = 0; image->orientation = ORIENTATION_TOPLEFT; } if ((bps == 0) || (spp == 0)) { TIFFError(""loadImage"", ""Invalid samples per pixel (%"" PRIu16 "") or bits per sample (%"" PRIu16 "")"", spp, bps); return (-1); } if (TIFFIsTiled(in)) { readunit = TILE; tlsize = TIFFTileSize(in); ntiles = TIFFNumberOfTiles(in); TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(in, TIFFTAG_TILELENGTH, &tl); tile_rowsize = TIFFTileRowSize(in); if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0) { TIFFError(""loadImage"", ""File appears to be tiled, but the number of tiles, tile "" ""size, or tile rowsize is zero.""); exit(EXIT_FAILURE); } if (ntiles != 0 && tlsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / ntiles)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } buffsize = tlsize * ntiles; if (tl != 0 && ntiles != 0 && tile_rowsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / tl / ntiles)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } if (buffsize < (tmsize_t)(ntiles * tl * tile_rowsize)) { buffsize = ntiles * tl * tile_rowsize; #ifdef DEBUG2 TIFFError(""loadImage"", ""Tilesize %"" PRIu32 "" is too small, using ntiles * "" ""tilelength * tilerowsize %"" PRIu32, tlsize, buffsize); #endif } if (dump->infile != NULL) dump_info(dump->infile, dump->format, """", ""Tilesize: %"" TIFF_SSIZE_FORMAT "", Number of Tiles: %"" PRIu32 "", Tile row size: %"" TIFF_SSIZE_FORMAT, tlsize, ntiles, tile_rowsize); } else { tmsize_t buffsize_check; readunit = STRIP; TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); stsize = TIFFStripSize(in); nstrips = TIFFNumberOfStrips(in); if (nstrips == 0 || stsize == 0) { TIFFError(""loadImage"", ""File appears to be striped, but the number "" ""of stipes or stripe size is zero.""); exit(EXIT_FAILURE); } if (nstrips != 0 && stsize > (tmsize_t)(TIFF_TMSIZE_T_MAX / nstrips)) { TIFFError(""loadImage"", ""Integer overflow when calculating buffer size""); exit(EXIT_FAILURE); } buffsize = stsize * nstrips; if ((spp != 0 && bps != 0 && width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) || (width != 0 && spp != 0 && bps != 0 && length > (tmsize_t)(TIFF_TMSIZE_T_MAX / (uint32_t)(((width * spp * bps) + 7) / 8)))) { TIFFError(""loadImage"", ""Integer overflow detected.""); exit(EXIT_FAILURE); } buffsize_check = (tmsize_t)length * (uint32_t)(((width * spp * bps) + 7) / 8); if (buffsize < buffsize_check) { buffsize = buffsize_check; #ifdef DEBUG2 TIFFError(""loadImage"", ""Stripsize %"" PRIu32 "" is too small, using imagelength * "" ""width * spp * bps / 8 = %"" PRIu32, stsize, (unsigned long)buffsize); #endif } if (dump->infile != NULL) dump_info(dump->infile, dump->format, """", ""Stripsize: %"" TIFF_SSIZE_FORMAT "", Number of Strips: %"" PRIu32 "", Rows per Strip: %"" PRIu32 "", Scanline size: %"" TIFF_SSIZE_FORMAT, stsize, nstrips, rowsperstrip, scanlinesize); } if (input_compression == COMPRESSION_JPEG) {  jpegcolormode = JPEGCOLORMODE_RGB; TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB); } else {  if (input_photometric == PHOTOMETRIC_YCBCR) { TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsampling_horiz, &subsampling_vert); if (subsampling_horiz != 1 || subsampling_vert != 1) { TIFFError(""loadImage"", ""Can't copy/convert subsampled image with "" ""subsampling %"" PRIu16 "" horiz %"" PRIu16 "" vert"", subsampling_horiz, subsampling_vert); return (-1); } } } read_buff = *read_ptr; if (!read_buff) { if (buffsize > 0xFFFFFFFFU - 3) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } read_buff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES); } else { if (prev_readsize < buffsize) { if (buffsize > 0xFFFFFFFFU - 3) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } new_buff = _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES); if (!new_buff) { free(read_buff); read_buff = (unsigned char *)limitMalloc( buffsize + NUM_BUFF_OVERSIZE_BYTES); } else read_buff = new_buff; } } if (!read_buff) { TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer""); return (-1); } read_buff[buffsize] = 0; read_buff[buffsize + 1] = 0; read_buff[buffsize + 2] = 0; prev_readsize = buffsize; *read_ptr = read_buff; switch (readunit) { case STRIP: if (planar == PLANARCONFIG_CONTIG) { if (!(readContigStripsIntoBuffer(in, read_buff))) { TIFFError(""loadImage"", ""Unable to read contiguous strips into buffer""); return (-1); } } else { if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump))) { TIFFError(""loadImage"", ""Unable to read separate strips into buffer""); return (-1); } } break; case TILE: if (planar == PLANARCONFIG_CONTIG) { if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))) { TIFFError(""loadImage"", ""Unable to read contiguous tiles into buffer""); return (-1); } } else { if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps))) { TIFFError(""loadImage"", ""Unable to read separate tiles into buffer""); return (-1); } } break; default: TIFFError(""loadImage"", ""Unsupported image file format""); return (-1); break; } if ((dump->infile != NULL) && (dump->level == 2)) { dump_info(dump->infile, dump->format, ""loadImage"", ""Image width %"" PRIu32 "", length %"" PRIu32 "", Raw image data, %4"" TIFF_SSIZE_FORMAT "" bytes"", width, length, buffsize); dump_info(dump->infile, dump->format, """", ""Bits per sample %"" PRIu16 "", Samples per pixel %"" PRIu16, bps, spp); if ((uint64_t)scanlinesize > 0x0ffffffffULL) { dump_info( dump->infile, dump->format, ""loadImage"", ""Attention: scanlinesize %"" PRIu64 "" is larger than UINT32_MAX.\nFollowing dump might be wrong."", (uint64_t)scanlinesize); } for (i = 0; i < length; i++) dump_buffer(dump->infile, dump->format, 1, (uint32_t)scanlinesize, i, read_buff + (i * scanlinesize)); } return (0); }"
"BOOL transport_accept_nla(rdpTransport* transport) { freerdp* instance; rdpSettings* settings; if (transport->TlsIn == NULL) transport->TlsIn = tls_new(transport->settings); if (transport->TlsOut == NULL) transport->TlsOut = transport->TlsIn; transport->layer = TRANSPORT_LAYER_TLS; transport->TlsIn->sockfd = transport->TcpIn->sockfd; if (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE) return FALSE; if (transport->settings->Authentication != TRUE) return TRUE; settings = transport->settings; instance = (freerdp*) settings->instance; if (transport->credssp == NULL) transport->credssp = credssp_new(instance, transport, settings); if (credssp_authenticate(transport->credssp) < 0) { fprintf(stderr, ""client authentication failure\n""); credssp_free(transport->credssp); return FALSE; } return TRUE; }"
void * alloc_temp(size_t size) { temp_end = bottom + size; if (temp_end > top) { new_chunk(); temp_end = bottom + size; } return bottom; }
"static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info, ExceptionInfo *exception) { DDSColors colors; ssize_t j, y; MagickSizeType alpha_bits; PixelPacket *q; register ssize_t i, x; unsigned char a0, a1; size_t alpha, bits, code, alpha_code; unsigned short c0, c1; for (y = 0; y < (ssize_t) dds_info->height; y += 4) { for (x = 0; x < (ssize_t) dds_info->width; x += 4) { q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x), Min(4, dds_info->height - y),exception); if (q == (PixelPacket *) NULL) return MagickFalse; a0 = (unsigned char) ReadBlobByte(image); a1 = (unsigned char) ReadBlobByte(image); alpha_bits = (MagickSizeType)ReadBlobLSBLong(image); alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32); c0 = ReadBlobLSBShort(image); c1 = ReadBlobLSBShort(image); bits = ReadBlobLSBLong(image); CalculateColors(c0, c1, &colors, MagickTrue); for (j = 0; j < 4; j++) { for (i = 0; i < 4; i++) { if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height) { code = (bits >> ((4*j+i)*2)) & 0x3; SetPixelRed(q,ScaleCharToQuantum(colors.r[code])); SetPixelGreen(q,ScaleCharToQuantum(colors.g[code])); SetPixelBlue(q,ScaleCharToQuantum(colors.b[code])); alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7; if (alpha_code == 0) alpha = a0; else if (alpha_code == 1) alpha = a1; else if (a0 > a1) alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7; else if (alpha_code == 6) alpha = 0; else if (alpha_code == 7) alpha = 255; else alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5); SetPixelAlpha(q,ScaleCharToQuantum((unsigned char) alpha)); q++; } } } if (SyncAuthenticPixels(image,exception) == MagickFalse) return MagickFalse; } } SkipDXTMipmaps(image, dds_info, 16); return MagickTrue; }"
"static void fpm_child_init(struct fpm_worker_pool_s *wp)  { fpm_globals.max_requests = wp->config->pm_max_requests; if (0 > fpm_stdio_init_child(wp)  || 0 > fpm_log_init_child(wp)    || 0 > fpm_status_init_child(wp) || 0 > fpm_unix_init_child(wp)   || 0 > fpm_signals_init_child()  || 0 > fpm_env_init_child(wp)    || 0 > fpm_php_init_child(wp)) { zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name); exit(FPM_EXIT_SOFTWARE); } }"
"static int nbd_negotiate_handle_list(NBDClient *client, uint32_t length) { NBDExport *exp; if (length) { if (nbd_negotiate_drop_sync(client->ioc, length) < 0) { return -EIO; } return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, NBD_OPT_LIST, ""OPT_LIST should not have length""); } QTAILQ_FOREACH(exp, &exports, next) { if (nbd_negotiate_send_rep_list(client->ioc, exp)) { return -EINVAL; } } return nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, NBD_OPT_LIST); }"
"void CameraSource::signalBufferReturned(MediaBuffer *buffer) { ALOGV(""signalBufferReturned: %p"", buffer->data()); Mutex::Autolock autoLock(mLock); for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin(); it != mFramesBeingEncoded.end(); ++it) { if ((*it)->pointer() ==  buffer->data()) { releaseOneRecordingFrame((*it)); mFramesBeingEncoded.erase(it); ++mNumFramesEncoded; buffer->setObserver(0); buffer->release(); mFrameCompleteCondition.signal(); return; } } CHECK(!""signalBufferReturned: bogus buffer""); }"
"static void handle_method_call(GDBusConnection *connection, const gchar *caller, const gchar *object_path, const gchar *interface_name, const gchar *method_name, GVariant    *parameters, GDBusMethodInvocation *invocation, gpointer    user_data) { reset_timeout(); uid_t caller_uid; GVariant *response; caller_uid = get_caller_uid(connection, invocation, caller); log_notice(""caller_uid:%ld method:'%s'"", (long)caller_uid, method_name); if (caller_uid == (uid_t) -1) return; if (g_strcmp0(method_name, ""NewProblem"") == 0) { char *error = NULL; char *problem_id = handle_new_problem(g_variant_get_child_value(parameters, 0), caller_uid, &error); if (!problem_id) { g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); free(error); return; } response = g_variant_new(""(s)"", problem_id); g_dbus_method_invocation_return_value(invocation, response); free(problem_id); return; } if (g_strcmp0(method_name, ""GetProblems"") == 0) { GList *dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""GetAllProblems"") == 0) { if (caller_uid != 0) { if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes) caller_uid = 0; } GList * dirs = get_problem_dirs_for_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""GetForeignProblems"") == 0) { GList * dirs = get_problem_dirs_not_accessible_by_uid(caller_uid, g_settings_dump_location); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""ChownProblemDir"") == 0) { const gchar *problem_dir; g_variant_get(parameters, ""(&s)"", &problem_dir); log_notice(""problem_dir:'%s'"", problem_dir); if (!allowed_problem_dir(problem_dir)) { return_InvalidProblemDir_error(invocation, problem_dir); return; } int dir_fd = dd_openfd(problem_dir); if (dir_fd < 0) { perror_msg(""can't open problem directory '%s'"", problem_dir); return_InvalidProblemDir_error(invocation, problem_dir); return; } int ddstat = fdump_dir_stat_for_uid(dir_fd, caller_uid); if (ddstat < 0) { if (errno == ENOTDIR) { log_notice(""requested directory does not exist '%s'"", problem_dir); } else { perror_msg(""can't get stat of '%s'"", problem_dir); } return_InvalidProblemDir_error(invocation, problem_dir); close(dir_fd); return; } if (ddstat & DD_STAT_OWNED_BY_UID) {               log_notice(""caller has access to the requested directory %s"", problem_dir); g_dbus_method_invocation_return_value(invocation, NULL); close(dir_fd); return; } if ((ddstat & DD_STAT_ACCESSIBLE_BY_UID) == 0 && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) { log_notice(""not authorized""); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.AuthFailure"", _(""Not Authorized"")); close(dir_fd); return; } struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES); if (!dd) { return_InvalidProblemDir_error(invocation, problem_dir); return; } int chown_res = dd_chown(dd, caller_uid); if (chown_res != 0) g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.ChownError"", _(""Chowning directory failed. Check system logs for more details."")); else g_dbus_method_invocation_return_value(invocation, NULL); dd_close(dd); return; } if (g_strcmp0(method_name, ""GetInfo"") == 0) { const gchar *problem_dir; g_variant_get_child(parameters, 0, ""&s"", &problem_dir); log_notice(""problem_dir:'%s'"", problem_dir); if (!allowed_problem_dir(problem_dir)) { return_InvalidProblemDir_error(invocation, problem_dir); return; } int dir_fd = dd_openfd(problem_dir); if (dir_fd < 0) { perror_msg(""can't open problem directory '%s'"", problem_dir); return_InvalidProblemDir_error(invocation, problem_dir); return; } if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid)) { if (errno == ENOTDIR) { log_notice(""Requested directory does not exist '%s'"", problem_dir); return_InvalidProblemDir_error(invocation, problem_dir); close(dir_fd); return; } if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) { log_notice(""not authorized""); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.AuthFailure"", _(""Not Authorized"")); close(dir_fd); return; } } struct dump_dir *dd = dd_fdopendir(dir_fd, problem_dir, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES); if (!dd) { return_InvalidProblemDir_error(invocation, problem_dir); return; } GVariant *array = g_variant_get_child_value(parameters, 1); GList *elements = string_list_from_variant(array); g_variant_unref(array); GVariantBuilder *builder = NULL; for (GList *l = elements; l; l = l->next) { const char *element_name = (const char*)l->data; char *value = dd_load_text_ext(dd, element_name, 0 | DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT | DD_FAIL_QUIETLY_EACCES); log_notice(""element '%s' %s"", element_name, value ? ""fetched"" : ""not found""); if (value) { if (!builder) builder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); g_variant_builder_add(builder, ""{ss}"", element_name, value); free(value); } } list_free_with_free(elements); dd_close(dd); GVariant *response = g_variant_new(""(a{ss})"", builder); if (builder) g_variant_builder_unref(builder); log_info(""GetInfo: returning value for '%s'"", problem_dir); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""SetElement"") == 0) { const char *problem_id; const char *element; const char *value; g_variant_get(parameters, ""(&s&s&s)"", &problem_id, &element, &value); if (!str_is_correct_filename(element)) { log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id); char *error = xasprintf(_(""'%s' is not a valid element name""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.InvalidElement"", error); free(error); return; } struct dump_dir *dd = open_directory_for_modification_of_element( invocation, caller_uid, problem_id, element); if (!dd) return; const double max_dir_size = g_settings_nMaxCrashReportsSize * (1024 * 1024); const long item_size = dd_get_item_size(dd, element); if (item_size < 0) { log_notice(""Can't get size of '%s/%s'"", problem_id, element); char *error = xasprintf(_(""Can't get size of '%s'""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); return; } const double requested_size = (double)strlen(value) - item_size; if (requested_size > 0 && requested_size > (max_dir_size - get_dirsize(g_settings_dump_location))) { log_notice(""No problem space left in '%s' (requested Bytes %f)"", problem_id, requested_size); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", _(""No problem space left"")); } else { dd_save_text(dd, element, value); g_dbus_method_invocation_return_value(invocation, NULL); } dd_close(dd); return; } if (g_strcmp0(method_name, ""DeleteElement"") == 0) { const char *problem_id; const char *element; g_variant_get(parameters, ""(&s&s)"", &problem_id, &element); if (!str_is_correct_filename(element)) { log_notice(""'%s' is not a valid element name of '%s'"", element, problem_id); char *error = xasprintf(_(""'%s' is not a valid element name""), element); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.InvalidElement"", error); free(error); return; } struct dump_dir *dd = open_directory_for_modification_of_element( invocation, caller_uid, problem_id, element); if (!dd) return; const int res = dd_delete_item(dd, element); dd_close(dd); if (res != 0) { log_notice(""Can't delete the element '%s' from the problem directory '%s'"", element, problem_id); char *error = xasprintf(_(""Can't delete the element '%s' from the problem directory '%s'""), element, problem_id); g_dbus_method_invocation_return_dbus_error(invocation, ""org.freedesktop.problems.Failure"", error); free(error); return; } g_dbus_method_invocation_return_value(invocation, NULL); return; } if (g_strcmp0(method_name, ""DeleteProblem"") == 0) { GVariant *array = g_variant_get_child_value(parameters, 0); GList *problem_dirs = string_list_from_variant(array); g_variant_unref(array); for (GList *l = problem_dirs; l; l = l->next) { const char *dir_name = (const char*)l->data; log_notice(""dir_name:'%s'"", dir_name); if (!allowed_problem_dir(dir_name)) { return_InvalidProblemDir_error(invocation, dir_name); goto ret; } } for (GList *l = problem_dirs; l; l = l->next) { const char *dir_name = (const char*)l->data; int dir_fd = dd_openfd(dir_name); if (dir_fd < 0) { perror_msg(""can't open problem directory '%s'"", dir_name); return_InvalidProblemDir_error(invocation, dir_name); return; } if (!fdump_dir_accessible_by_uid(dir_fd, caller_uid)) { if (errno == ENOTDIR) { log_notice(""Requested directory does not exist '%s'"", dir_name); close(dir_fd); continue; } if (polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") != PolkitYes) {                     close(dir_fd); continue; } } struct dump_dir *dd = dd_fdopendir(dir_fd, dir_name,  0); if (dd) { if (dd_delete(dd) != 0) { error_msg(""Failed to delete problem directory '%s'"", dir_name); dd_close(dd); } } } g_dbus_method_invocation_return_value(invocation, NULL); ret: list_free_with_free(problem_dirs); return; } if (g_strcmp0(method_name, ""FindProblemByElementInTimeRange"") == 0) { const gchar *element; const gchar *value; glong timestamp_from; glong timestamp_to; gboolean all; g_variant_get_child(parameters, 0, ""&s"", &element); g_variant_get_child(parameters, 1, ""&s"", &value); g_variant_get_child(parameters, 2, ""x"", &timestamp_from); g_variant_get_child(parameters, 3, ""x"", &timestamp_to); g_variant_get_child(parameters, 4, ""b"", &all); if (all && polkit_check_authorization_dname(caller, ""org.freedesktop.problems.getall"") == PolkitYes) caller_uid = 0; GList *dirs = get_problem_dirs_for_element_in_time(caller_uid, element, value, timestamp_from, timestamp_to); response = variant_from_string_list(dirs); list_free_with_free(dirs); g_dbus_method_invocation_return_value(invocation, response); return; } if (g_strcmp0(method_name, ""Quit"") == 0) { g_dbus_method_invocation_return_value(invocation, NULL); g_main_loop_quit(loop); return; } }"
"static int virtio_gpu_object_shmem_init(struct virtio_gpu_device *vgdev, struct virtio_gpu_object *bo, struct virtio_gpu_mem_entry **ents, unsigned int *nents) { bool use_dma_api = !virtio_has_dma_quirk(vgdev->vdev); struct virtio_gpu_object_shmem *shmem = to_virtio_gpu_shmem(bo); struct scatterlist *sg; int si, ret; ret = drm_gem_shmem_pin(&bo->base); if (ret < 0) return -EINVAL; shmem->pages = drm_gem_shmem_get_sg_table(&bo->base); if (!shmem->pages) { drm_gem_shmem_unpin(&bo->base); return -EINVAL; } if (use_dma_api) { ret = dma_map_sgtable(vgdev->vdev->dev.parent, shmem->pages, DMA_TO_DEVICE, 0); if (ret) return ret; *nents = shmem->mapped = shmem->pages->nents; } else { *nents = shmem->pages->orig_nents; } *ents = kvmalloc_array(*nents, sizeof(struct virtio_gpu_mem_entry), GFP_KERNEL); if (!(*ents)) { DRM_ERROR(""failed to allocate ent list\n""); return -ENOMEM; } if (use_dma_api) { for_each_sgtable_dma_sg(shmem->pages, sg, si) { (*ents)[si].addr = cpu_to_le64(sg_dma_address(sg)); (*ents)[si].length = cpu_to_le32(sg_dma_len(sg)); (*ents)[si].padding = 0; } } else { for_each_sgtable_sg(shmem->pages, sg, si) { (*ents)[si].addr = cpu_to_le64(sg_phys(sg)); (*ents)[si].length = cpu_to_le32(sg->length); (*ents)[si].padding = 0; } } return 0; }"
"GF_EXPORT GF_VVCConfig *gf_odf_vvc_cfg_read_bs(GF_BitStream *bs) { u32 i, count; GF_VVCConfig *cfg = gf_odf_vvc_cfg_new(); gf_bs_read_int(bs, 5); cfg->nal_unit_size = 1 + gf_bs_read_int(bs, 2); cfg->ptl_present = gf_bs_read_int(bs, 1); if (cfg->ptl_present) { s32 j; cfg->ols_idx = gf_bs_read_int(bs, 9); cfg->numTemporalLayers = gf_bs_read_int(bs, 3); cfg->constantFrameRate = gf_bs_read_int(bs, 2); cfg->chroma_format = gf_bs_read_int(bs, 2); cfg->bit_depth = 8 + gf_bs_read_int(bs, 3); gf_bs_read_int(bs, 5); gf_bs_read_int(bs, 2); cfg->num_constraint_info = gf_bs_read_int(bs, 6); cfg->general_profile_idc = gf_bs_read_int(bs, 7); cfg->general_tier_flag = gf_bs_read_int(bs, 1); cfg->general_level_idc = gf_bs_read_u8(bs); cfg->ptl_frame_only_constraint = gf_bs_read_int(bs, 1); cfg->ptl_multilayer_enabled = gf_bs_read_int(bs, 1); if (cfg->num_constraint_info) { cfg->general_constraint_info = gf_malloc(sizeof(u8)*cfg->num_constraint_info); if (!cfg->general_constraint_info) { gf_free(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } gf_bs_read_data(bs, cfg->general_constraint_info, cfg->num_constraint_info - 1); cfg->general_constraint_info[cfg->num_constraint_info-1] =  gf_bs_read_int(bs, 6); } else { gf_bs_read_int(bs, 6); } cfg->ptl_sublayer_present_mask = 0; for (j=cfg->numTemporalLayers-2; j>=0; j--) { u32 val = gf_bs_read_int(bs, 1); cfg->ptl_sublayer_present_mask |= val << j; } for (j=cfg->numTemporalLayers; j<=8 && cfg->numTemporalLayers>1; j++) { gf_bs_read_int(bs, 1); } for (j=cfg->numTemporalLayers-2; j>=0; j--) { if (cfg->ptl_sublayer_present_mask & (1<<j)) { cfg->sublayer_level_idc[j] = gf_bs_read_u8(bs); } } cfg->num_sub_profiles = gf_bs_read_u8(bs); if (cfg->num_sub_profiles) { cfg->sub_profiles_idc = gf_malloc(sizeof(u32)*cfg->num_sub_profiles); if (!cfg->sub_profiles_idc) { gf_free(cfg->general_constraint_info); gf_free(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } } for (i=0; i<cfg->num_sub_profiles; i++) { cfg->sub_profiles_idc[i] = gf_bs_read_u32(bs); } cfg->maxPictureWidth = gf_bs_read_u16(bs); cfg->maxPictureHeight = gf_bs_read_u16(bs); cfg->avgFrameRate = gf_bs_read_u16(bs); } count = gf_bs_read_int(bs, 8); for (i=0; i<count; i++) { u32 nalucount, j; Bool valid = GF_FALSE; GF_NALUFFParamArray *ar; GF_SAFEALLOC(ar, GF_NALUFFParamArray); if (!ar) { gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } ar->array_completeness = gf_bs_read_int(bs, 1); gf_bs_read_int(bs, 2); ar->type = gf_bs_read_int(bs, 5); switch (ar->type) { case GF_VVC_NALU_DEC_PARAM: case GF_VVC_NALU_OPI: case GF_VVC_NALU_VID_PARAM: case GF_VVC_NALU_SEQ_PARAM: case GF_VVC_NALU_PIC_PARAM: case GF_VVC_NALU_SEI_PREFIX: case GF_VVC_NALU_SEI_SUFFIX: valid = GF_TRUE; ar->nalus = gf_list_new(); gf_list_add(cfg->param_array, ar); break; default: GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[VVC] Invalid NALU type in vvcC - ignoring\n"", ar->nalus)); gf_free(ar); break; } if ((ar->type != GF_VVC_NALU_DEC_PARAM) && (ar->type != GF_VVC_NALU_OPI)) nalucount = gf_bs_read_int(bs, 16); else nalucount = 1; for (j=0; j<nalucount; j++) { GF_NALUFFParam *sl; u32 size = gf_bs_read_int(bs, 16); if ((size>gf_bs_available(bs)) || (size<2)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] Wrong param set size %d\n"", size)); gf_odf_vvc_cfg_del(cfg); return NULL; } if (!valid) { gf_bs_skip_bytes(bs, size); continue; } GF_SAFEALLOC(sl, GF_NALUFFParam ); if (!sl) { gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } sl->size = size; sl->data = (char *)gf_malloc(sizeof(char) * sl->size); if (!sl->data) { gf_free(sl); gf_odf_vvc_cfg_del(cfg); GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] alloc failed while parsing vvc config\n"")); return NULL; } gf_bs_read_data(bs, sl->data, sl->size); gf_list_add(ar->nalus, sl); } } return cfg; }"
"void luaD_callnoyield (lua_State *L, StkId func, int nResults) { incXCcalls(L); if (getCcalls(L) <= CSTACKERR)   luaE_freeCI(L); luaD_call(L, func, nResults); decXCcalls(L); }"
"void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH) { int c; int x, y; int tox, toy; int ydest; int i; int colorMap[gdMaxColors]; int *stx, *sty; if (overflow2(sizeof(int), srcW)) { return; } if (overflow2(sizeof(int), srcH)) { return; } stx = (int *) gdMalloc (sizeof (int) * srcW); sty = (int *) gdMalloc (sizeof (int) * srcH); for (i = 0; (i < srcW); i++) { stx[i] = dstW * (i+1) / srcW - dstW * i / srcW ; } for (i = 0; (i < srcH); i++) { sty[i] = dstH * (i+1) / srcH - dstH * i / srcH ; } for (i = 0; (i < gdMaxColors); i++) { colorMap[i] = (-1); } toy = dstY; for (y = srcY; (y < (srcY + srcH)); y++) { for (ydest = 0; (ydest < sty[y - srcY]); ydest++) { tox = dstX; for (x = srcX; (x < (srcX + srcW)); x++) { int nc = 0; int mapTo; if (!stx[x - srcX]) { continue; } if (dst->trueColor) { if (!src->trueColor) { int tmp = gdImageGetPixel (src, x, y); mapTo = gdImageGetTrueColorPixel (src, x, y); if (gdImageGetTransparent (src) == tmp) { tox += stx[x - srcX]; continue; } } else { mapTo = gdImageGetTrueColorPixel (src, x, y); if (gdImageGetTransparent (src) == mapTo) { tox += stx[x - srcX]; continue; } } } else { c = gdImageGetPixel (src, x, y); if (gdImageGetTransparent (src) == c) { tox += stx[x - srcX]; continue; } if (src->trueColor) { mapTo = gdImageColorResolveAlpha(dst, gdTrueColorGetRed(c), gdTrueColorGetGreen(c), gdTrueColorGetBlue(c), gdTrueColorGetAlpha (c)); } else { if (colorMap[c] == (-1)) { if (dst == src) { nc = c; } else { nc = gdImageColorResolveAlpha(dst, gdImageRed(src, c), gdImageGreen(src, c), gdImageBlue(src, c), gdImageAlpha(src, c)); } colorMap[c] = nc; } mapTo = colorMap[c]; } } for (i = 0; (i < stx[x - srcX]); i++) { gdImageSetPixel (dst, tox, toy, mapTo); tox++; } } toy++; } } gdFree (stx); gdFree (sty); }"
"static char *__filterShell(const char *arg) { r_return_val_if_fail (arg, NULL); char *a = malloc (strlen (arg) + 1); if (!a) { return NULL; } char *b = a; while (*arg) { switch (*arg) { case '@': case '`': case '|': case ';': case '\n': break; default: *b++ = *arg; break; } arg++; } *b = 0; return a; }"
"static int emulator_write_std(struct x86_emulate_ctxt *ctxt, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception) { struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt); return kvm_write_guest_virt_helper(addr, val, bytes, vcpu, PFERR_WRITE_MASK, exception); }"
"static void parse_paragraph(tree_t *t, float  left, float  right, float  bottom, float  top, float  *x, float  *y, int    *page, int    needspace) { intwhitespace; tree_t*flat, *start, *end, *prev, *temp; floatwidth, height, offset, spacing, borderspace, temp_y, temp_width, temp_height; floatformat_width, image_y, image_left, image_right; intimage_page = *page; floatchar_spacing; intnum_chars; render_t*r; uchar*align, *hspace, *vspace, *link, *border; floatrgb[3]; ucharline[10240], *lineptr, *dataptr; tree_t*linetype; floatlinex, linewidth; intfirstline; DEBUG_printf((""parse_paragraph(t=%p, left=%.1f, right=%.1f, bottom=%.1f, top=%.1f, x=%.1f, y=%.1f, page=%d, needspace=%d\n"", (void *)t, left, right, bottom, top, *x, *y, *page, needspace)); flat        = flatten_tree(t->child); image_left  = left; image_right = right; image_y     = 0; if (flat == NULL) DEBUG_puts(""parse_paragraph: flat == NULL!""); if (*y < top && needspace) *y -= _htmlSpacings[SIZE_P]; for (temp = flat, prev = NULL; temp != NULL;) { if (temp->markup == MARKUP_IMG) update_image_size(temp); if (temp->markup == MARKUP_IMG && (align = htmlGetVariable(temp, (uchar *)""ALIGN""))) { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; if (strcasecmp((char *)align, ""LEFT"") == 0) { if ((vspace = htmlGetVariable(temp, (uchar *)""VSPACE"")) != NULL) *y -= atoi((char *)vspace); if (*y < (bottom + temp->height + 2 * borderspace)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } if (borderspace > 0.0f) { if (temp->link && PSLevel == 0) memcpy(rgb, link_color, sizeof(rgb)); else { rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } new_render(*page, RENDER_BOX, image_left, *y - borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, image_left, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_left + temp->width + borderspace, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_left, *y - temp->height - 2 * borderspace, temp->width + 2 * borderspace, borderspace, rgb); } *y -= borderspace; new_render(*page, RENDER_IMAGE, image_left + borderspace, *y - temp->height, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); if (temp->link && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, image_left + borderspace, *y - temp->height, temp->width, temp->height, link); } *y -= borderspace; if (vspace != NULL) *y -= atoi((char *)vspace); image_left += temp->width + 2 * borderspace; temp_y     = *y - temp->height; image_page = *page; if (temp_y < image_y || image_y == 0) image_y = temp_y; if ((hspace = htmlGetVariable(temp, (uchar *)""HSPACE"")) != NULL) image_left += atoi((char *)hspace); if (prev != NULL) prev->next = temp->next; else flat = temp->next; free(temp); temp = prev; } else if (strcasecmp((char *)align, ""RIGHT"") == 0) { if ((vspace = htmlGetVariable(temp, (uchar *)""VSPACE"")) != NULL) *y -= atoi((char *)vspace); if (*y < (bottom + temp->height + 2 * borderspace)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } image_right -= temp->width + 2 * borderspace; image_page = *page; if (borderspace > 0.0f) { if (temp->link && PSLevel == 0) memcpy(rgb, link_color, sizeof(rgb)); else { rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } new_render(*page, RENDER_BOX, image_right, *y - borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_right + temp->width + borderspace, *y - temp->height - 2 * borderspace, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, image_right, *y - temp->height - 2 * borderspace, temp->width + 2 * borderspace, borderspace, rgb); } *y -= borderspace; new_render(*page, RENDER_IMAGE, image_right + borderspace, *y - temp->height, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); if (temp->link && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, image_right + borderspace, *y - temp->height, temp->width, temp->height, link); } *y -= borderspace; if (vspace != NULL) *y -= atoi((char *)vspace); temp_y = *y - temp->height; if (temp_y < image_y || image_y == 0) image_y = temp_y; if ((hspace = htmlGetVariable(temp, (uchar *)""HSPACE"")) != NULL) image_right -= atoi((char *)hspace); if (prev != NULL) prev->next = temp->next; else flat = temp->next; free(temp); temp = prev; } } if (temp != NULL) { prev = temp; temp = temp->next; } else temp = flat; } format_width = image_right - image_left; firstline    = 1; DEBUG_printf((""format_width = %.1f\n"", format_width)); offset      = 0.0f; temp_width  = 0.0f; temp_height = 0.0f; lineptr     = NULL; linex       = 0.0f; linewidth   = 0.0f; while (flat != NULL) { start = flat; end   = flat; width = 0.0; while (flat != NULL) { temp_width = 0.0; temp       = flat; whitespace = 0; while (temp != NULL && !whitespace) { if (temp->markup == MARKUP_NONE && temp->data[0] == ' ') { if (temp == start) temp_width -= _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f; else if (temp_width > 0.0f) whitespace = 1; } else whitespace = 0; if (whitespace) break; if (temp->markup == MARKUP_IMG) { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_width += 2 * borderspace; } prev       = temp; temp       = temp->next; temp_width += prev->width; if ((temp_width >= format_width && prev->markup == MARKUP_IMG) || prev->markup == MARKUP_BR) { break; } else if (prev->markup == MARKUP_NONE) { intch = prev->data[strlen((char *)prev->data) - 1]; if (_htmlUTF8) ch = _htmlUnicode[ch]; if (ch == 173) break; } } if ((width + temp_width) <= format_width) { width += temp_width; end  = temp; flat = temp; if (prev->markup == MARKUP_BR) break; } else if (width == 0.0) { width += temp_width; end  = temp; flat = temp; break; } else break; } if (start == end) { end   = start->next; flat  = start->next; width = start->width; } for (height = 0.0, num_chars = 0, temp = prev = start; temp != end; temp = temp->next) { prev = temp; if (temp->markup == MARKUP_NONE) num_chars += strlen((char *)temp->data); if (temp->height > height) height = temp->height; } for (spacing = 0.0, temp = prev = start; temp != end; temp = temp->next) { prev = temp; if (temp->markup != MARKUP_IMG) temp_height = (float)(temp->height * _htmlSpacings[0] / _htmlSizes[0]); else { if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_height = temp->height + 2 * borderspace; } if (temp_height > spacing) spacing = temp_height; } if (firstline && end != NULL && *y < (bottom + height + _htmlSpacings[t->size])) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } firstline = 0; if (height == 0.0f) height = spacing; for (temp = start; temp != end; temp = temp->next) if (temp->markup != MARKUP_A) break; if (temp != NULL && temp->markup == MARKUP_NONE && temp->data[0] == ' ') { for (dataptr = temp->data; *dataptr; dataptr ++) *dataptr = dataptr[1]; *dataptr = '\0'; temp_width = _htmlWidths[temp->typeface][temp->style][' '] * _htmlSizes[temp->size] * 0.001f; temp->width -= temp_width; num_chars --; } if (end != NULL) temp = end->prev; else temp = NULL; DEBUG_printf((""    BEFORE page=%d, y=%.1f, height=%.1f, spacing=%.1f, bottom=%.1f\n"", *page, *y, height, spacing, bottom)); if (*y < (spacing + bottom)) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } *y -= height; DEBUG_printf((""    page=%d, y=%.1f, width=%.1f, height=%.1f\n"", *page, *y, width, height)); if (Verbosity) progress_update(100 - (int)(100 * (*y) / PagePrintLength)); char_spacing = 0.0f; whitespace   = 0; temp         = start; linetype     = NULL; rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; switch (t->halignment) { case ALIGN_LEFT : linex = image_left; break; case ALIGN_CENTER : linex = image_left + 0.5f * (format_width - width); break; case ALIGN_RIGHT : linex = image_right - width; break; case ALIGN_JUSTIFY : linex = image_left; if (flat != NULL && flat->prev->markup != MARKUP_BR && num_chars > 1) char_spacing = (format_width - width) / (num_chars - 1); break; } while (temp != end) { if (temp->link != NULL && PSLevel == 0 && Links && temp->markup == MARKUP_NONE) { temp->red   = (uchar)(link_color[0] * 255.0); temp->green = (uchar)(link_color[1] * 255.0); temp->blue  = (uchar)(link_color[2] * 255.0); } if (linetype != NULL && (temp->markup != MARKUP_NONE || temp->typeface != linetype->typeface || temp->style != linetype->style || temp->size != linetype->size || temp->superscript != linetype->superscript || temp->subscript != linetype->subscript || temp->red != linetype->red || temp->green != linetype->green || temp->blue != linetype->blue)) { r = new_render(*page, RENDER_TEXT, linex - linewidth, *y, linewidth, linetype->height, line); r->data.text.typeface = linetype->typeface; r->data.text.style    = linetype->style; r->data.text.size     = (float)_htmlSizes[linetype->size]; r->data.text.spacing  = char_spacing; memcpy(r->data.text.rgb, rgb, sizeof(rgb)); if (linetype->superscript) r->y += height - linetype->height; else if (linetype->subscript) r->y -= height - linetype->height; free(linetype); linetype = NULL; } if ((link = htmlGetVariable(temp, (uchar *)""ID"")) != NULL) { add_link(link, *page, (int)(*y + height)); } switch (temp->markup) { case MARKUP_A : if ((link = htmlGetVariable(temp, (uchar *)""NAME"")) != NULL) { add_link(link, *page, (int)(*y + height)); } default : temp_width = temp->width; break; case MARKUP_NONE : if (temp->data == NULL) break; if (((temp->width - right + left) > 0.001 || (temp->height - top + bottom) > 0.001)  && OverflowErrors) progress_error(HD_ERROR_CONTENT_TOO_LARGE, ""Text on page %d too large - "" ""truncation or overlapping may occur!"", *page + 1); if (linetype == NULL) { linetype  = temp; lineptr   = line; linewidth = 0.0; rgb[0] = temp->red / 255.0f; rgb[1] = temp->green / 255.0f; rgb[2] = temp->blue / 255.0f; } strlcpy((char *)lineptr, (char *)temp->data, sizeof(line) - (size_t)(lineptr - line)); temp_width = temp->width + char_spacing * strlen((char *)lineptr); if (temp->underline || (temp->link && LinkStyle && PSLevel == 0)) new_render(*page, RENDER_BOX, linex, *y - 1, temp_width, 0, rgb); if (temp->strikethrough) new_render(*page, RENDER_BOX, linex, *y + temp->height * 0.25f, temp_width, 0, rgb); linewidth  += temp_width; lineptr    += strlen((char *)lineptr); if (lineptr > line && lineptr[-1] == ' ') whitespace = 1; else whitespace = 0; break; case MARKUP_IMG : if (((temp->width - right + left) > 0.001 || (temp->height - top + bottom) > 0.001) && OverflowErrors) { DEBUG_printf((""IMAGE: %.3fx%.3f > %.3fx%.3f\n"", temp->width, temp->height, right - left, top - bottom)); progress_error(HD_ERROR_CONTENT_TOO_LARGE, ""Image on page %d too large - "" ""truncation or overlapping may occur!"", *page + 1); } if ((border = htmlGetVariable(temp, (uchar *)""BORDER"")) != NULL) borderspace = (float)atof((char *)border); else if (temp->link) borderspace = 1; else borderspace = 0; borderspace *= PagePrintWidth / _htmlBrowserWidth; temp_width += 2 * borderspace; switch (temp->valignment) { case ALIGN_TOP : offset = height - temp->height - 2 * borderspace; break; case ALIGN_MIDDLE : offset = 0.5f * (height - temp->height) - borderspace; break; case ALIGN_BOTTOM : offset = 0.0f; } if (borderspace > 0.0f) { new_render(*page, RENDER_BOX, linex, *y + offset + temp->height + borderspace, temp->width + 2 * borderspace, borderspace, rgb); new_render(*page, RENDER_BOX, linex, *y + offset, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, linex + temp->width + borderspace, *y + offset, borderspace, temp->height + 2 * borderspace, rgb); new_render(*page, RENDER_BOX, linex, *y + offset, temp->width + 2 * borderspace, borderspace, rgb); } new_render(*page, RENDER_IMAGE, linex + borderspace, *y + offset + borderspace, temp->width, temp->height, image_find((char *)htmlGetVariable(temp, (uchar *)""REALSRC""))); whitespace = 0; temp_width = temp->width + 2 * borderspace; break; } if (temp->link != NULL && (link = htmlGetVariable(temp->link, (uchar *)""_HD_FULL_HREF"")) != NULL) { new_render(*page, RENDER_LINK, linex, *y + offset, temp->width, temp->height, link); } linex += temp_width; prev = temp; temp = temp->next; if (prev != linetype) free(prev); } if (linetype != NULL) { r = new_render(*page, RENDER_TEXT, linex - linewidth, *y, linewidth, linetype->height, line); r->data.text.typeface = linetype->typeface; r->data.text.style    = linetype->style; r->data.text.spacing  = char_spacing; r->data.text.size     = (float)_htmlSizes[linetype->size]; memcpy(r->data.text.rgb, rgb, sizeof(rgb)); if (linetype->superscript) r->y += height - linetype->height; else if (linetype->subscript) r->y -= height - linetype->height; free(linetype); } *y -= spacing - height; DEBUG_printf((""    AFTER y=%.1f, bottom=%.1f\n"", *y, bottom)); if (*y < bottom) { (*page) ++; *y = top; if (Verbosity) progress_show(""Formatting page %d"", *page); } if (*y < image_y || *page > image_page) { image_y      = 0.0f; image_left   = left; image_right  = right; format_width = image_right - image_left; } } *x = left; if (*y > image_y && image_y > 0.0f && image_page == *page) *y = image_y; DEBUG_printf((""LEAVING parse_paragraph(), x = %.1f, y = %.1f, page = %d, image_y = %.1f\n"", *x, *y, *page, image_y)); }"
"static int handle_rst_stream_frame(h2o_http2_conn_t *conn, h2o_http2_frame_t *frame, const char **err_desc) { h2o_http2_rst_stream_payload_t payload; h2o_http2_stream_t *stream; int ret; if ((ret = h2o_http2_decode_rst_stream_payload(&payload, frame, err_desc)) != 0) return ret; if (is_idle_stream_id(conn, frame->stream_id)) { *err_desc = ""unexpected stream id in RST_STREAM frame""; return H2O_HTTP2_ERROR_PROTOCOL; } stream = h2o_http2_conn_get_stream(conn, frame->stream_id); if (stream != NULL) { h2o_http2_stream_reset(conn, stream); } return 0; }"
"ssize_t enc_untrusted_read(int fd, void *buf, size_t count) { return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall( asylo::system_call::kSYS_read, fd, buf, count)); }"
"static int ax25_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; ax25_cb *ax25; if (protocol < 0 || protocol > SK_PROTOCOL_MAX) return -EINVAL; if (!net_eq(net, &init_net)) return -EAFNOSUPPORT; switch (sock->type) { case SOCK_DGRAM: if (protocol == 0 || protocol == PF_AX25) protocol = AX25_P_TEXT; break; case SOCK_SEQPACKET: switch (protocol) { case 0: case PF_AX25: protocol = AX25_P_TEXT; break; case AX25_P_SEGMENT: #ifdef CONFIG_INET case AX25_P_ARP: case AX25_P_IP: #endif #ifdef CONFIG_NETROM case AX25_P_NETROM: #endif #ifdef CONFIG_ROSE case AX25_P_ROSE: #endif return -ESOCKTNOSUPPORT; #ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM: if (ax25_protocol_is_registered(AX25_P_NETROM)) return -ESOCKTNOSUPPORT; break; #endif #ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE: if (ax25_protocol_is_registered(AX25_P_ROSE)) return -ESOCKTNOSUPPORT; #endif default: break; } break; case SOCK_RAW: break; default: return -ESOCKTNOSUPPORT; } sk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto); if (sk == NULL) return -ENOMEM; ax25 = sk->sk_protinfo = ax25_create_cb(); if (!ax25) { sk_free(sk); return -ENOMEM; } sock_init_data(sock, sk); sk->sk_destruct = ax25_free_sock; sock->ops    = &ax25_proto_ops; sk->sk_protocol = protocol; ax25->sk    = sk; return 0; }"
inline long ValueType<URational>::toLong(long n) const { ok_ = (value_.at(n).second != 0 && value_.at(n).first < LARGE_INT); if (!ok_) return 0; return value_.at(n).first / value_.at(n).second; }
"static void free_charger_irq(struct wm8350 *wm8350) { wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_HOT, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_COLD, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_BAT_FAIL, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_TO, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_END, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_START, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_3P9, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_3P1, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_CHG_VBATT_LT_2P85, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_USB_FB, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_WALL_FB, wm8350); wm8350_free_irq(wm8350, WM8350_IRQ_EXT_BAT_FB, wm8350); }"
"inline void Request::set_header(const char *key, const char *val) { headers.emplace(key, val); }"
"static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses, volatile parse_context *ctx) { pj_str_t str; ctx->last_error = PJMEDIA_SDP_EINORIGIN; if (*(scanner->curptr+1) != '=') { on_scanner_error(scanner); return; } pj_scan_advance_n(scanner, 2, SKIP_WS); pj_scan_get_until_ch(scanner, ' ', &ses->origin.user); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &str); ses->origin.id = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &str); ses->origin.version = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type); pj_scan_get_char(scanner); pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type); pj_scan_get_char(scanner); pj_scan_get_until_chr(scanner, "" \t\r\n"", &ses->origin.addr); pj_scan_skip_line(scanner); }"
"static void desegment_tcp(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 seq, guint32 nxtseq, guint32 sport, guint32 dport, proto_tree *tree, proto_tree *tcp_tree, struct tcp_analysis *tcpd, struct tcpinfo *tcpinfo) { fragment_head *ipfd_head; int last_fragment_len; gboolean must_desegment; gboolean called_dissector; int another_pdu_follows; int deseg_offset; guint32 deseg_seq; gint nbytes; proto_item *item; struct tcp_multisegment_pdu *msp; gboolean cleared_writable = col_get_writable(pinfo->cinfo, COL_PROTOCOL); again: ipfd_head = NULL; last_fragment_len = 0; must_desegment = FALSE; called_dissector = FALSE; another_pdu_follows = 0; msp = NULL; pinfo->desegment_offset = 0; pinfo->desegment_len = 0; deseg_offset = offset; if (tcpd) { if ((msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32(tcpd->fwd->multisegment_pdus, seq))) { const char* str; if (msp->first_frame == pinfo->num) { str = """"; col_append_sep_str(pinfo->cinfo, COL_INFO, "" "", ""[TCP segment of a reassembled PDU]""); } else { str = ""Retransmitted ""; } ipfd_head = fragment_get(&tcp_reassembly_table, pinfo, pinfo->num, NULL); if (ipfd_head) { if (ipfd_head->reassembled_in != 0) { item = proto_tree_add_uint(tcp_tree, hf_tcp_reassembled_in, tvb, 0, 0, ipfd_head->reassembled_in); PROTO_ITEM_SET_GENERATED(item); } } nbytes = tvb_reported_length_remaining(tvb, offset); proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset, nbytes, NULL, ""%sTCP segment data (%u byte%s)"", str, nbytes, plurality(nbytes, """", ""s"")); return; } if((tcpd->ta) && ((tcpd->ta->flags&TCP_A_RETRANSMISSION) == TCP_A_RETRANSMISSION)){ const char* str = ""Retransmitted ""; nbytes = tvb_reported_length_remaining(tvb, offset); proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset, nbytes, NULL, ""%sTCP segment data (%u byte%s)"", str, nbytes, plurality(nbytes, """", ""s"")); return; } msp = (struct tcp_multisegment_pdu *)wmem_tree_lookup32_le(tcpd->fwd->multisegment_pdus, seq-1); } if (msp && msp->seq <= seq && msp->nxtpdu > seq) { int len; if (!PINFO_FD_VISITED(pinfo)) { msp->last_frame=pinfo->num; msp->last_frame_time=pinfo->abs_ts; } if (msp->flags&MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) { len = tvb_captured_length_remaining(tvb, offset); } else { len = MIN(nxtseq, msp->nxtpdu) - seq; } last_fragment_len = len; ipfd_head = fragment_add(&tcp_reassembly_table, tvb, offset, pinfo, msp->first_frame, NULL, seq - msp->seq, len, (LT_SEQ (nxtseq,msp->nxtpdu)) ); if (!PINFO_FD_VISITED(pinfo) && msp->flags & MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT) { msp->flags &= (~MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT); msp->nxtpdu = nxtseq; } if( (msp->nxtpdu < nxtseq) &&  (msp->nxtpdu >= seq) &&  (len > 0)) { another_pdu_follows=msp->nxtpdu - seq; } } else { tcpinfo->seq = seq; process_tcp_payload(tvb, offset, pinfo, tree, tcp_tree, sport, dport, 0, 0, FALSE, tcpd, tcpinfo); called_dissector = TRUE; if(pinfo->desegment_len) { if (!PINFO_FD_VISITED(pinfo)) must_desegment = TRUE; deseg_offset = offset + pinfo->desegment_offset; } ipfd_head = NULL; } if (ipfd_head) { if(ipfd_head->reassembled_in == pinfo->num) { tvbuff_t *next_tvb; int old_len; next_tvb = tvb_new_chain(tvb, ipfd_head->tvb_data); add_new_data_source(pinfo, next_tvb, ""Reassembled TCP""); tcpinfo->seq = msp->seq; tcpinfo->is_reassembled = TRUE; process_tcp_payload(next_tvb, 0, pinfo, tree, tcp_tree, sport, dport, 0, 0, FALSE, tcpd, tcpinfo); called_dissector = TRUE; old_len = (int)(tvb_reported_length(next_tvb) - last_fragment_len); if (pinfo->desegment_len && pinfo->desegment_offset<=old_len) { remove_last_data_source(pinfo); fragment_set_partial_reassembly(&tcp_reassembly_table, pinfo, msp->first_frame, NULL); if (pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) { msp->nxtpdu = seq + tvb_reported_length_remaining(tvb, offset) + 1; msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT; } else if (pinfo->desegment_len == DESEGMENT_UNTIL_FIN) { tcpd->fwd->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN; } else { msp->nxtpdu=seq + last_fragment_len + pinfo->desegment_len; } another_pdu_follows = 0; offset += last_fragment_len; seq += last_fragment_len; if (tvb_captured_length_remaining(tvb, offset) > 0) goto again; } else { nbytes = another_pdu_follows > 0 ? another_pdu_follows : tvb_reported_length_remaining(tvb, offset); proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, offset, nbytes, NULL, ""TCP segment data (%u byte%s)"", nbytes, plurality(nbytes, """", ""s"")); print_tcp_fragment_tree(ipfd_head, tree, tcp_tree, pinfo, next_tvb); if(pinfo->desegment_len) { if (!PINFO_FD_VISITED(pinfo)) must_desegment = TRUE; deseg_offset = ipfd_head->datalen - pinfo->desegment_offset; deseg_offset = tvb_reported_length(tvb) - deseg_offset; } } } } if (must_desegment) { if (tcpd && pinfo->desegment_len == DESEGMENT_UNTIL_FIN) { tcpd->fwd->flags |= TCP_FLOW_REASSEMBLE_UNTIL_FIN; } deseg_seq = seq + (deseg_offset - offset); if (tcpd && ((nxtseq - deseg_seq) <= 1024*1024) && (!PINFO_FD_VISITED(pinfo))) { if(pinfo->desegment_len == DESEGMENT_ONE_MORE_SEGMENT) { msp = pdu_store_sequencenumber_of_next_pdu(pinfo, deseg_seq, nxtseq+1, tcpd->fwd->multisegment_pdus); msp->flags |= MSP_FLAGS_REASSEMBLE_ENTIRE_SEGMENT; } else { msp = pdu_store_sequencenumber_of_next_pdu(pinfo, deseg_seq, nxtseq+pinfo->desegment_len, tcpd->fwd->multisegment_pdus); } fragment_add(&tcp_reassembly_table, tvb, deseg_offset, pinfo, msp->first_frame, NULL, 0, nxtseq - deseg_seq, LT_SEQ(nxtseq, msp->nxtpdu)); } } if (!called_dissector || pinfo->desegment_len != 0) { if (ipfd_head != NULL && ipfd_head->reassembled_in != 0 && !(ipfd_head->flags & FD_PARTIAL_REASSEMBLY)) { item = proto_tree_add_uint(tcp_tree, hf_tcp_reassembled_in, tvb, 0, 0, ipfd_head->reassembled_in); PROTO_ITEM_SET_GENERATED(item); } if (pinfo->desegment_offset == 0) { col_set_str(pinfo->cinfo, COL_PROTOCOL, ""TCP""); col_append_sep_str(pinfo->cinfo, COL_INFO, "" "", ""[TCP segment of a reassembled PDU]""); } nbytes = tvb_reported_length_remaining(tvb, deseg_offset); proto_tree_add_bytes_format(tcp_tree, hf_tcp_segment_data, tvb, deseg_offset, -1, NULL, ""TCP segment data (%u byte%s)"", nbytes, plurality(nbytes, """", ""s"")); } pinfo->can_desegment = 0; pinfo->desegment_offset = 0; pinfo->desegment_len = 0; if(another_pdu_follows) { pinfo->can_desegment = 2; col_set_fence(pinfo->cinfo, COL_INFO); cleared_writable |= col_get_writable(pinfo->cinfo, COL_PROTOCOL); col_set_writable(pinfo->cinfo, COL_PROTOCOL, FALSE); offset += another_pdu_follows; seq += another_pdu_follows; goto again; } else { if(cleared_writable) { col_set_writable(pinfo->cinfo, COL_PROTOCOL, TRUE); } } }"
"static int s_aes_process(stream_state * ss, stream_cursor_read * pr, stream_cursor_write * pw, bool last) { stream_aes_state *const state = (stream_aes_state *) ss; const unsigned char *limit; const long in_size = pr->limit - pr->ptr; const long out_size = pw->limit - pw->ptr; unsigned char temp[16]; int status = 0; if (in_size > out_size) { limit = pr->ptr + out_size; status = 1;  } else { limit = pr->limit; status = last ? EOFC : 0;  } if (state->ctx == NULL) { state->ctx = (aes_context *)gs_alloc_bytes_immovable(state->memory, sizeof(aes_context), ""aes context structure""); if (state->ctx == NULL) { gs_throw(gs_error_VMerror, ""could not allocate aes context""); return ERRC; } if (state->keylength < 1 || state->keylength > SAES_MAX_KEYLENGTH) { gs_throw1(gs_error_rangecheck, ""invalid aes key length (%d bytes)"", state->keylength); return ERRC; } aes_setkey_dec(state->ctx, state->key, state->keylength * 8); } if (!state->initialized) { if (in_size < 16) return 0;  memcpy(state->iv, pr->ptr + 1, 16); state->initialized = 1; pr->ptr += 16; } while (pr->ptr + 16 <= limit) { aes_crypt_cbc(state->ctx, AES_DECRYPT, 16, state->iv, pr->ptr + 1, temp); pr->ptr += 16; if (last && pr->ptr == pr->limit) { int pad; if (state->use_padding) { pad = temp[15]; if (pad < 1 || pad > 16) { gs_warn1(""invalid aes padding byte (0x%02x)"", (unsigned char)pad); pad = 0; } } else { pad = 0; } memcpy(pw->ptr + 1, temp, 16 - pad); pw->ptr +=  16 - pad; return EOFC; } memcpy(pw->ptr + 1, temp, 16); pw->ptr += 16; } if (status == EOFC) { gs_throw(gs_error_rangecheck, ""aes stream isn't a multiple of 16 bytes""); return 0; } return status; }"
"static int dwc3_qcom_acpi_register_core(struct platform_device *pdev) { struct dwc3_qcom*qcom = platform_get_drvdata(pdev); struct device*dev = &pdev->dev; struct resource*res, *child_res = NULL; struct platform_device*pdev_irq = qcom->urs_usb ? qcom->urs_usb : pdev; intirq; intret; qcom->dwc3 = platform_device_alloc(""dwc3"", PLATFORM_DEVID_AUTO); if (!qcom->dwc3) return -ENOMEM; qcom->dwc3->dev.parent = dev; qcom->dwc3->dev.type = dev->type; qcom->dwc3->dev.dma_mask = dev->dma_mask; qcom->dwc3->dev.dma_parms = dev->dma_parms; qcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask; child_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL); if (!child_res) return -ENOMEM; res = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!res) { dev_err(&pdev->dev, ""failed to get memory resource\n""); ret = -ENODEV; goto out; } child_res[0].flags = res->flags; child_res[0].start = res->start; child_res[0].end = child_res[0].start + qcom->acpi_pdata->dwc3_core_base_size; irq = platform_get_irq(pdev_irq, 0); if (irq < 0) { ret = irq; goto out; } child_res[1].flags = IORESOURCE_IRQ; child_res[1].start = child_res[1].end = irq; ret = platform_device_add_resources(qcom->dwc3, child_res, 2); if (ret) { dev_err(&pdev->dev, ""failed to add resources\n""); goto out; } ret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode); if (ret < 0) { dev_err(&pdev->dev, ""failed to add properties\n""); goto out; } ret = platform_device_add(qcom->dwc3); if (ret) { dev_err(&pdev->dev, ""failed to add device\n""); device_remove_software_node(&qcom->dwc3->dev); } out: kfree(child_res); return ret; }"
"void gfs2_clear_rgrpd(struct gfs2_sbd *sdp) { struct rb_node *n; struct gfs2_rgrpd *rgd; struct gfs2_glock *gl; while ((n = rb_first(&sdp->sd_rindex_tree))) { rgd = rb_entry(n, struct gfs2_rgrpd, rd_node); gl = rgd->rd_gl; rb_erase(n, &sdp->sd_rindex_tree); if (gl) { spin_lock(&gl->gl_lockref.lock); gl->gl_object = NULL; spin_unlock(&gl->gl_lockref.lock); gfs2_glock_add_to_lru(gl); gfs2_glock_put(gl); } gfs2_free_clones(rgd); kfree(rgd->rd_bits); return_all_reservations(rgd); kmem_cache_free(gfs2_rgrpd_cachep, rgd); } }"
"void impeg2d_dec_p_mb_params(dec_state_t *ps_dec) { stream_t *ps_stream = &ps_dec->s_bit_stream; UWORD16 u2_mb_addr_incr; UWORD16 u2_total_len; UWORD16 u2_len; UWORD16 u2_mb_type; UWORD32 u4_next_word; const dec_mb_params_t *ps_dec_mb_params; if(impeg2d_bit_stream_nxt(ps_stream,1) == 1) { impeg2d_bit_stream_flush(ps_stream,1); } else { u2_mb_addr_incr = impeg2d_get_mb_addr_incr(ps_stream); if(0 == ps_dec->u2_first_mb) { if(ps_dec->u2_is_mpeg2 && ((ps_dec->u2_mb_x + u2_mb_addr_incr) > ps_dec->u2_num_horiz_mb) ) { u2_mb_addr_incr    = ps_dec->u2_num_horiz_mb - ps_dec->u2_mb_x; } impeg2d_dec_skip_mbs(ps_dec, (UWORD16)(u2_mb_addr_incr - 1)); } } u4_next_word = (UWORD16)impeg2d_bit_stream_nxt(ps_stream,16); { u2_mb_type   = ps_dec->pu2_mb_type[BITS((UWORD16)u4_next_word,15,10)]; u2_len      = BITS(u2_mb_type,15,8); u2_total_len = u2_len; u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << u2_len); } { if((u2_mb_type & MB_FORW_OR_BACK) &&  ps_dec->u2_read_motion_type) { WORD32 i4_motion_type; ps_dec->u2_motion_type = BITS((UWORD16)u4_next_word,15,14); u2_total_len        += MB_MOTION_TYPE_LEN; u4_next_word        = (UWORD16)LSW((UWORD16)u4_next_word << MB_MOTION_TYPE_LEN); i4_motion_type     = ps_dec->u2_motion_type; if((i4_motion_type == 0) || (i4_motion_type == 4) || (i4_motion_type >  7)) { i4_motion_type = 1; } } } { if((u2_mb_type & MB_CODED) && ps_dec->u2_read_dct_type) { ps_dec->u2_field_dct = BIT((UWORD16)u4_next_word,15); u2_total_len += MB_DCT_TYPE_LEN; u4_next_word = (UWORD16)LSW((UWORD16)u4_next_word << MB_DCT_TYPE_LEN); } } if(u2_mb_type & MB_QUANT) { UWORD16 u2_quant_scale_code; u2_quant_scale_code = BITS((UWORD16)u4_next_word,15,11); ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ? gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1); u2_total_len += MB_QUANT_SCALE_CODE_LEN; } impeg2d_bit_stream_flush(ps_stream,u2_total_len); ps_dec->u2_coded_mb    = (UWORD16)(u2_mb_type & MB_CODED); if(u2_mb_type & MB_FORW_OR_BACK) { UWORD16 refPic      = !(u2_mb_type & MB_MV_FORW); UWORD16 index       = (ps_dec->u2_motion_type); ps_dec->u2_prev_intra_mb    = 0; ps_dec->e_mb_pred         = (e_pred_direction_t)refPic; ps_dec_mb_params = &ps_dec->ps_func_forw_or_back[index]; ps_dec->s_mb_type = ps_dec_mb_params->s_mb_type; ps_dec_mb_params->pf_func_mb_params(ps_dec); } else if(u2_mb_type & MB_TYPE_INTRA) { ps_dec->u2_prev_intra_mb    = 1; impeg2d_dec_intra_mb(ps_dec); } else { ps_dec->u2_prev_intra_mb    = 0; ps_dec->e_mb_pred = FORW; ps_dec->u2_motion_type = 0; impeg2d_dec_0mv_coded_mb(ps_dec); } if((u2_mb_type & MB_TYPE_INTRA)) { ps_dec->u2_cbp  = 0x3f; ps_dec->u2_prev_intra_mb    = 1; } else { ps_dec->u2_prev_intra_mb  = 0; ps_dec->u2_def_dc_pred[Y_LUMA] = 128 << ps_dec->u2_intra_dc_precision; ps_dec->u2_def_dc_pred[U_CHROMA] = 128 << ps_dec->u2_intra_dc_precision; ps_dec->u2_def_dc_pred[V_CHROMA] = 128 << ps_dec->u2_intra_dc_precision; if((ps_dec->u2_coded_mb)) { UWORD16 cbpValue; cbpValue  = gau2_impeg2d_cbp_code[impeg2d_bit_stream_nxt(ps_stream,MB_CBP_LEN)]; ps_dec->u2_cbp  = cbpValue & 0xFF; impeg2d_bit_stream_flush(ps_stream,(cbpValue >> 8) & 0x0FF); } else { ps_dec->u2_cbp  = 0; } } }"
long readSInt32(FILE *f) { long result = 0; result |= readUInt8(f); result |= readUInt8(f) << 8; result |= readUInt8(f) << 16; result |= readUInt8(f) << 24; return result; }
"GF_Err url_box_read(GF_Box *s, GF_BitStream *bs) { GF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s; if (ptr->size) { ptr->location = (char*)gf_malloc((u32) ptr->size); if (! ptr->location) return GF_OUT_OF_MEM; gf_bs_read_data(bs, ptr->location, (u32)ptr->size); } return GF_OK; }"
"void sctp_auth_get_cookie_params(struct sctp_tcb *stcb, struct mbuf *m, uint32_t offset, uint32_t length) { struct sctp_paramhdr *phdr, tmp_param; uint16_t plen, ptype; uint8_t random_store[SCTP_PARAM_BUFFER_SIZE]; struct sctp_auth_random *p_random = NULL; uint16_t random_len = 0; uint8_t hmacs_store[SCTP_PARAM_BUFFER_SIZE]; struct sctp_auth_hmac_algo *hmacs = NULL; uint16_t hmacs_len = 0; uint8_t chunks_store[SCTP_PARAM_BUFFER_SIZE]; struct sctp_auth_chunk_list *chunks = NULL; uint16_t num_chunks = 0; sctp_key_t *new_key; uint32_t keylen; length += offset; phdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr), (uint8_t *)&tmp_param); while (phdr != NULL) { ptype = ntohs(phdr->param_type); plen = ntohs(phdr->param_length); if ((plen == 0) || (offset + plen > length)) break; if (ptype == SCTP_RANDOM) { if (plen > sizeof(random_store)) break; phdr = sctp_get_next_param(m, offset, (struct sctp_paramhdr *)random_store, plen); if (phdr == NULL) return; p_random = (struct sctp_auth_random *)phdr; random_len = plen - sizeof(*p_random); } else if (ptype == SCTP_HMAC_LIST) { uint16_t num_hmacs; uint16_t i; if (plen > sizeof(hmacs_store)) break; phdr = sctp_get_next_param(m, offset, (struct sctp_paramhdr *)hmacs_store, plen); if (phdr == NULL) return; hmacs = (struct sctp_auth_hmac_algo *)phdr; hmacs_len = plen - sizeof(*hmacs); num_hmacs = hmacs_len / sizeof(hmacs->hmac_ids[0]); if (stcb->asoc.local_hmacs != NULL) sctp_free_hmaclist(stcb->asoc.local_hmacs); stcb->asoc.local_hmacs = sctp_alloc_hmaclist(num_hmacs); if (stcb->asoc.local_hmacs != NULL) { for (i = 0; i < num_hmacs; i++) { (void)sctp_auth_add_hmacid(stcb->asoc.local_hmacs, ntohs(hmacs->hmac_ids[i])); } } } else if (ptype == SCTP_CHUNK_LIST) { int i; if (plen > sizeof(chunks_store)) break; phdr = sctp_get_next_param(m, offset, (struct sctp_paramhdr *)chunks_store, plen); if (phdr == NULL) return; chunks = (struct sctp_auth_chunk_list *)phdr; num_chunks = plen - sizeof(*chunks); if (stcb->asoc.local_auth_chunks != NULL) sctp_clear_chunklist(stcb->asoc.local_auth_chunks); else stcb->asoc.local_auth_chunks = sctp_alloc_chunklist(); for (i = 0; i < num_chunks; i++) { (void)sctp_auth_add_chunk(chunks->chunk_types[i], stcb->asoc.local_auth_chunks); } } offset += SCTP_SIZE32(plen); if (offset + sizeof(struct sctp_paramhdr) > length) break; phdr = (struct sctp_paramhdr *)sctp_m_getptr(m, offset, sizeof(struct sctp_paramhdr), (uint8_t *)&tmp_param); } keylen = sizeof(*p_random) + random_len + sizeof(*hmacs) + hmacs_len; if (chunks != NULL) { keylen += sizeof(*chunks) + num_chunks; } new_key = sctp_alloc_key(keylen); if (new_key != NULL) { if (p_random != NULL) { keylen = sizeof(*p_random) + random_len; memcpy(new_key->key, p_random, keylen); } else { keylen = 0; } if (chunks != NULL) { memcpy(new_key->key + keylen, chunks, sizeof(*chunks) + num_chunks); keylen += sizeof(*chunks) + num_chunks; } if (hmacs != NULL) { memcpy(new_key->key + keylen, hmacs, sizeof(*hmacs) + hmacs_len); } } if (stcb->asoc.authinfo.random != NULL) sctp_free_key(stcb->asoc.authinfo.random); stcb->asoc.authinfo.random = new_key; stcb->asoc.authinfo.random_len = random_len; sctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.assoc_keyid); sctp_clear_cachedkeys(stcb, stcb->asoc.authinfo.recv_keyid); stcb->asoc.peer_hmac_id = sctp_negotiate_hmacid(stcb->asoc.peer_hmacs, stcb->asoc.local_hmacs); stcb->asoc.authinfo.active_keyid = stcb->sctp_ep->sctp_ep.default_keyid; (void)sctp_copy_skeylist(&stcb->sctp_ep->sctp_ep.shared_keys, &stcb->asoc.shared_keys); }"
"AP4_Result AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream) { AP4_Result result = AP4_SampleEntry::ReadFields(stream); if (result < 0) return result; stream.ReadUI16(m_Predefined1); stream.ReadUI16(m_Reserved2); stream.Read(m_Predefined2, sizeof(m_Predefined2)); stream.ReadUI16(m_Width); stream.ReadUI16(m_Height); stream.ReadUI32(m_HorizResolution); stream.ReadUI32(m_VertResolution); stream.ReadUI32(m_Reserved3); stream.ReadUI16(m_FrameCount); char compressor_name[33]; compressor_name[32] = 0; stream.Read(compressor_name, 32); int name_length = compressor_name[0]; if (name_length < 32) { compressor_name[name_length+1] = 0;         m_CompressorName = &compressor_name[1]; } stream.ReadUI16(m_Depth); stream.ReadUI16(m_Predefined3); return AP4_SUCCESS; }"
"static int io_file_bitmap_get(struct io_ring_ctx *ctx) { struct io_file_table *table = &ctx->file_table; unsigned long nr = ctx->file_alloc_end; int ret; do { ret = find_next_zero_bit(table->bitmap, nr, table->alloc_hint); if (ret != nr) return ret; if (table->alloc_hint == ctx->file_alloc_start) break; nr = table->alloc_hint; table->alloc_hint = ctx->file_alloc_start; } while (1); return -ENFILE; }"
"static int dvb_ca_en50221_io_release(struct inode *inode, struct file *file) { struct dvb_device *dvbdev = file->private_data; struct dvb_ca_private *ca = dvbdev->priv; int err; dprintk(""%s\n"", __func__); ca->open = 0; dvb_ca_en50221_thread_update_delay(ca); err = dvb_generic_release(inode, file); module_put(ca->pub->owner); dvb_ca_private_put(ca); return err; }"
"void * get_layer4_v6(const ipv6_hdr_t *ip6_hdr, const int l3len) { struct tcpr_ipv6_ext_hdr_base *next, *exthdr; bool done = false; uint32_t maxlen; uint8_t proto; int min_len; assert(ip6_hdr); min_len = TCPR_IPV6_H + sizeof(struct tcpr_ipv6_ext_hdr_base); if (l3len < min_len) return NULL; next = (struct tcpr_ipv6_ext_hdr_base *)((u_char *)ip6_hdr + TCPR_IPV6_H); proto = ip6_hdr->ip_nh; while (!done) { dbgx(3, ""Processing proto: 0x%hx"", (uint16_t)proto); switch (proto) { case TCPR_IPV6_NH_IPV6: dbg(3, ""recursing due to v6-in-v6""); next = get_layer4_v6((ipv6_hdr_t *)next, l3len - min_len); break; case TCPR_IPV6_NH_AH: case TCPR_IPV6_NH_ROUTING: case TCPR_IPV6_NH_DESTOPTS: case TCPR_IPV6_NH_HBH: dbgx(3, ""Going deeper due to extension header 0x%02X"", proto); maxlen = l3len - (int)((u_char *)ip6_hdr - (u_char *)next); exthdr = get_ipv6_next(next, maxlen); if (exthdr == NULL) { done = true; break; } proto = exthdr->ip_nh; next = exthdr; break; case TCPR_IPV6_NH_FRAGMENT: case TCPR_IPV6_NH_ESP: next = NULL; done = true; break; default: if (proto != ip6_hdr->ip_nh) { dbgx(3, ""Returning byte offset of this ext header: %u"",  IPV6_EXTLEN_TO_BYTES(next->ip_len)); next =  (void *)((u_char *)next + IPV6_EXTLEN_TO_BYTES(next->ip_len)); } else { dbgx(3, ""%s"", ""Returning end of IPv6 Header""); } done = true; }  }  if (!next || (u_char*)next > (u_char*)ip6_hdr + l3len) return NULL; return next; }"
"static void advance_to_end_of_signature(guint8 **signature, guint8  *signature_length) { gboolean done = FALSE; gint8 current_type; gint8 end_type = ARG_INVALID; while(*(++(*signature)) && --(*signature_length) > 0 && !done) { current_type = **signature; if(end_type != ARG_INVALID) { if(end_type == current_type) { done = TRUE;  } continue; } switch(current_type) { case ARG_ARRAY: advance_to_end_of_signature(signature, signature_length); break; case ARG_STRUCT: end_type = ')'; advance_to_end_of_signature(signature, signature_length); break; case ARG_DICT_ENTRY: end_type = '}'; advance_to_end_of_signature(signature, signature_length); break; case ARG_BYTE: case ARG_DOUBLE: case ARG_UINT64: case ARG_INT64: case ARG_SIGNATURE: case ARG_HANDLE: case ARG_INT32: case ARG_UINT32: case ARG_BOOLEAN: case ARG_INT16: case ARG_UINT16: case ARG_STRING: case ARG_VARIANT: case ARG_OBJ_PATH: done = TRUE; break; default:     done = TRUE; break; } } }"
"void sfe_apply_metadata_changes (const char * filenames [2], const METADATA_INFO * info) {SNDFILE *infile = NULL, *outfile = NULL ; SF_INFO sfinfo ; METADATA_INFO tmpinfo ; int error_code = 0 ; memset (&sfinfo, 0, sizeof (sfinfo)) ; memset (&tmpinfo, 0, sizeof (tmpinfo)) ; if (filenames [1] == NULL) infile = outfile = sf_open (filenames [0], SFM_RDWR, &sfinfo) ; else {infile = sf_open (filenames [0], SFM_READ, &sfinfo) ; sfinfo.format = SF_FORMAT_WAV | (SF_FORMAT_SUBMASK & sfinfo.format) ; outfile = sf_open (filenames [1], SFM_WRITE, &sfinfo) ; } ; if (infile == NULL) {printf (""Error : Not able to open input file '%s' : %s\n"", filenames [0], sf_strerror (infile)) ; error_code = 1 ; goto cleanup_exit ; } ; if (outfile == NULL) {printf (""Error : Not able to open output file '%s' : %s\n"", filenames [1], sf_strerror (outfile)) ; error_code = 1 ; goto cleanup_exit ; } ; if (info->has_bext_fields && merge_broadcast_info (infile, outfile, sfinfo.format, info)) {error_code = 1 ; goto cleanup_exit ; } ; if (infile != outfile) {int infileminor = SF_FORMAT_SUBMASK & sfinfo.format ; if ((infileminor == SF_FORMAT_DOUBLE) || (infileminor == SF_FORMAT_FLOAT)) sfe_copy_data_fp (outfile, infile, sfinfo.channels, SF_FALSE) ; else sfe_copy_data_int (outfile, infile, sfinfo.channels) ; } ; update_strings (outfile, info) ; cleanup_exit : if (outfile != NULL && outfile != infile) sf_close (outfile) ; if (infile != NULL) sf_close (infile) ; if (error_code) exit (error_code) ; return ; }"
"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx) { u32 pck_size; GF_FilterPacket *pck; u8 *output; gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc); if (!pck_size) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1Dmx] no frame OBU, skipping OBU\n"")); return GF_OK; } pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output); if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck); gf_filter_pck_set_cts(pck, ctx->cts); gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0); memcpy(output, ctx->state.frame_obus, pck_size); if (ctx->deps) { u8 flags = 0; flags = ( ctx->state.frame_state.key_frame) ? 2 : 1; flags <<= 2; flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2; flags <<= 2; gf_filter_pck_set_dependency_flags(pck, flags); } gf_filter_pck_send(pck); av1dmx_update_cts(ctx); gf_av1_reset_state(&ctx->state, GF_FALSE); return GF_OK; }"
"static const u_char * ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_, const struct isakmp_gen *ext, u_int item_len _U_, const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { struct isakmp_gen e; ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_SIG))); ND_TCHECK(*ext); UNALIGNED_MEMCPY(&e, ext, sizeof(e)); ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4)); if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) { ND_PRINT((ndo,"" "")); if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4)) goto trunc; } return (const u_char *)ext + ntohs(e.len); trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_SIG))); return NULL; }"
"static int iscsi_if_recv_msg(struct sk_buff *skb, struct nlmsghdr *nlh, uint32_t *group) { int err = 0; u32 portid; struct iscsi_uevent *ev = nlmsg_data(nlh); struct iscsi_transport *transport = NULL; struct iscsi_internal *priv; struct iscsi_cls_session *session; struct iscsi_cls_conn *conn; struct iscsi_endpoint *ep = NULL; if (nlh->nlmsg_type == ISCSI_UEVENT_PATH_UPDATE) *group = ISCSI_NL_GRP_UIP; else *group = ISCSI_NL_GRP_ISCSID; priv = iscsi_if_transport_lookup(iscsi_ptr(ev->transport_handle)); if (!priv) return -EINVAL; transport = priv->iscsi_transport; if (!try_module_get(transport->owner)) return -EINVAL; portid = NETLINK_CB(skb).portid; switch (nlh->nlmsg_type) { case ISCSI_UEVENT_CREATE_SESSION: err = iscsi_if_create_session(priv, ep, ev, portid, ev->u.c_session.initial_cmdsn, ev->u.c_session.cmds_max, ev->u.c_session.queue_depth); break; case ISCSI_UEVENT_CREATE_BOUND_SESSION: ep = iscsi_lookup_endpoint(ev->u.c_bound_session.ep_handle); if (!ep) { err = -EINVAL; break; } err = iscsi_if_create_session(priv, ep, ev, portid, ev->u.c_bound_session.initial_cmdsn, ev->u.c_bound_session.cmds_max, ev->u.c_bound_session.queue_depth); break; case ISCSI_UEVENT_DESTROY_SESSION: session = iscsi_session_lookup(ev->u.d_session.sid); if (!session) err = -EINVAL; else if (iscsi_session_has_conns(ev->u.d_session.sid)) err = -EBUSY; else transport->destroy_session(session); break; case ISCSI_UEVENT_DESTROY_SESSION_ASYNC: session = iscsi_session_lookup(ev->u.d_session.sid); if (!session) err = -EINVAL; else if (iscsi_session_has_conns(ev->u.d_session.sid)) err = -EBUSY; else { unsigned long flags; spin_lock_irqsave(&sesslock, flags); list_del_init(&session->sess_list); spin_unlock_irqrestore(&sesslock, flags); queue_work(iscsi_destroy_workq, &session->destroy_work); } break; case ISCSI_UEVENT_UNBIND_SESSION: session = iscsi_session_lookup(ev->u.d_session.sid); if (session) scsi_queue_work(iscsi_session_to_shost(session), &session->unbind_work); else err = -EINVAL; break; case ISCSI_UEVENT_CREATE_CONN: err = iscsi_if_create_conn(transport, ev); break; case ISCSI_UEVENT_DESTROY_CONN: err = iscsi_if_destroy_conn(transport, ev); break; case ISCSI_UEVENT_BIND_CONN: session = iscsi_session_lookup(ev->u.b_conn.sid); conn = iscsi_conn_lookup(ev->u.b_conn.sid, ev->u.b_conn.cid); if (conn && conn->ep) iscsi_if_ep_disconnect(transport, conn->ep->id); if (!session || !conn) { err = -EINVAL; break; } mutex_lock(&conn_mutex); ev->r.retcode =transport->bind_conn(session, conn, ev->u.b_conn.transport_eph, ev->u.b_conn.is_leading); mutex_unlock(&conn_mutex); if (ev->r.retcode || !transport->ep_connect) break; ep = iscsi_lookup_endpoint(ev->u.b_conn.transport_eph); if (ep) { ep->conn = conn; mutex_lock(&conn->ep_mutex); conn->ep = ep; mutex_unlock(&conn->ep_mutex); } else iscsi_cls_conn_printk(KERN_ERR, conn, ""Could not set ep conn "" ""binding\n""); break; case ISCSI_UEVENT_SET_PARAM: err = iscsi_set_param(transport, ev); break; case ISCSI_UEVENT_START_CONN: conn = iscsi_conn_lookup(ev->u.start_conn.sid, ev->u.start_conn.cid); if (conn) { mutex_lock(&conn_mutex); ev->r.retcode = transport->start_conn(conn); if (!ev->r.retcode) conn->state = ISCSI_CONN_UP; mutex_unlock(&conn_mutex); } else err = -EINVAL; break; case ISCSI_UEVENT_STOP_CONN: conn = iscsi_conn_lookup(ev->u.stop_conn.sid, ev->u.stop_conn.cid); if (conn) iscsi_if_stop_conn(conn, ev->u.stop_conn.flag); else err = -EINVAL; break; case ISCSI_UEVENT_SEND_PDU: conn = iscsi_conn_lookup(ev->u.send_pdu.sid, ev->u.send_pdu.cid); if (conn) { mutex_lock(&conn_mutex); ev->r.retcode =transport->send_pdu(conn, (struct iscsi_hdr*)((char*)ev + sizeof(*ev)), (char*)ev + sizeof(*ev) + ev->u.send_pdu.hdr_size, ev->u.send_pdu.data_size); mutex_unlock(&conn_mutex); } else err = -EINVAL; break; case ISCSI_UEVENT_GET_STATS: err = iscsi_if_get_stats(transport, nlh); break; case ISCSI_UEVENT_TRANSPORT_EP_CONNECT: case ISCSI_UEVENT_TRANSPORT_EP_POLL: case ISCSI_UEVENT_TRANSPORT_EP_DISCONNECT: case ISCSI_UEVENT_TRANSPORT_EP_CONNECT_THROUGH_HOST: err = iscsi_if_transport_ep(transport, ev, nlh->nlmsg_type); break; case ISCSI_UEVENT_TGT_DSCVR: err = iscsi_tgt_dscvr(transport, ev); break; case ISCSI_UEVENT_SET_HOST_PARAM: err = iscsi_set_host_param(transport, ev); break; case ISCSI_UEVENT_PATH_UPDATE: err = iscsi_set_path(transport, ev); break; case ISCSI_UEVENT_SET_IFACE_PARAMS: err = iscsi_set_iface_params(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_PING: err = iscsi_send_ping(transport, ev); break; case ISCSI_UEVENT_GET_CHAP: err = iscsi_get_chap(transport, nlh); break; case ISCSI_UEVENT_DELETE_CHAP: err = iscsi_delete_chap(transport, ev); break; case ISCSI_UEVENT_SET_FLASHNODE_PARAMS: err = iscsi_set_flashnode_param(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_NEW_FLASHNODE: err = iscsi_new_flashnode(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_DEL_FLASHNODE: err = iscsi_del_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGIN_FLASHNODE: err = iscsi_login_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGOUT_FLASHNODE: err = iscsi_logout_flashnode(transport, ev); break; case ISCSI_UEVENT_LOGOUT_FLASHNODE_SID: err = iscsi_logout_flashnode_sid(transport, ev); break; case ISCSI_UEVENT_SET_CHAP: err = iscsi_set_chap(transport, ev, nlmsg_attrlen(nlh, sizeof(*ev))); break; case ISCSI_UEVENT_GET_HOST_STATS: err = iscsi_get_host_stats(transport, nlh); break; default: err = -ENOSYS; break; } module_put(transport->owner); return err; }"
"static void free_nested(struct kvm_vcpu *vcpu) { struct vcpu_vmx *vmx = to_vmx(vcpu); if (!vmx->nested.vmxon && !vmx->nested.smm.vmxon) return; vmx->nested.vmxon = false; vmx->nested.smm.vmxon = false; free_vpid(vmx->nested.vpid02); vmx->nested.posted_intr_nv = -1; vmx->nested.current_vmptr = -1ull; if (enable_shadow_vmcs) { vmx_disable_shadow_vmcs(vmx); vmcs_clear(vmx->vmcs01.shadow_vmcs); free_vmcs(vmx->vmcs01.shadow_vmcs); vmx->vmcs01.shadow_vmcs = NULL; } kfree(vmx->nested.cached_vmcs12); kfree(vmx->nested.cached_shadow_vmcs12); if (vmx->nested.apic_access_page) { kvm_release_page_dirty(vmx->nested.apic_access_page); vmx->nested.apic_access_page = NULL; } if (vmx->nested.virtual_apic_page) { kvm_release_page_dirty(vmx->nested.virtual_apic_page); vmx->nested.virtual_apic_page = NULL; } if (vmx->nested.pi_desc_page) { kunmap(vmx->nested.pi_desc_page); kvm_release_page_dirty(vmx->nested.pi_desc_page); vmx->nested.pi_desc_page = NULL; vmx->nested.pi_desc = NULL; } kvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL); nested_release_evmcs(vcpu); free_loaded_vmcs(&vmx->nested.vmcs02); }"
"sds sdsMakeRoomFor(sds s, size_t addlen) { void *sh, *newsh; size_t avail = sdsavail(s); size_t len, newlen; char type, oldtype = s[-1] & SDS_TYPE_MASK; int hdrlen; if (avail >= addlen) return s; len = sdslen(s); sh = (char*)s-sdsHdrSize(oldtype); newlen = (len+addlen); if (newlen < SDS_MAX_PREALLOC) newlen *= 2; else newlen += SDS_MAX_PREALLOC; type = sdsReqType(newlen); if (type == SDS_TYPE_5) type = SDS_TYPE_8; hdrlen = sdsHdrSize(type); if (oldtype==type) { newsh = s_realloc(sh, hdrlen+newlen+1); if (newsh == NULL) return NULL; s = (char*)newsh+hdrlen; } else { newsh = s_malloc(hdrlen+newlen+1); if (newsh == NULL) return NULL; memcpy((char*)newsh+hdrlen, s, len+1); s_free(sh); s = (char*)newsh+hdrlen; s[-1] = type; sdssetlen(s, len); } sdssetalloc(s, newlen); return s; }"
"static void cstm(JF, js_Ast *stm) { js_Ast *target; int loop, cont, then, end; emitline(J, F, stm); switch (stm->type) { case AST_FUNDEC: break; case STM_BLOCK: cstmlist(J, F, stm->a); break; case STM_EMPTY: if (F->script) { emit(J, F, OP_POP); emit(J, F, OP_UNDEF); } break; case STM_VAR: cvarinit(J, F, stm->a); break; case STM_IF: if (stm->c) { cexp(J, F, stm->a); then = emitjump(J, F, OP_JTRUE); cstm(J, F, stm->c); end = emitjump(J, F, OP_JUMP); label(J, F, then); cstm(J, F, stm->b); label(J, F, end); } else { cexp(J, F, stm->a); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); label(J, F, end); } break; case STM_DO: loop = here(J, F); cstm(J, F, stm->a); cont = here(J, F); cexp(J, F, stm->b); emitjumpto(J, F, OP_JTRUE, loop); labeljumps(J, F, stm->jumps, here(J,F), cont); break; case STM_WHILE: loop = here(J, F); cexp(J, F, stm->a); end = emitjump(J, F, OP_JFALSE); cstm(J, F, stm->b); emitjumpto(J, F, OP_JUMP, loop); label(J, F, end); labeljumps(J, F, stm->jumps, here(J,F), loop); break; case STM_FOR: case STM_FOR_VAR: if (stm->type == STM_FOR_VAR) { cvarinit(J, F, stm->a); } else { if (stm->a) { cexp(J, F, stm->a); emit(J, F, OP_POP); } } loop = here(J, F); if (stm->b) { cexp(J, F, stm->b); end = emitjump(J, F, OP_JFALSE); } else { end = 0; } cstm(J, F, stm->d); cont = here(J, F); if (stm->c) { cexp(J, F, stm->c); emit(J, F, OP_POP); } emitjumpto(J, F, OP_JUMP, loop); if (end) label(J, F, end); labeljumps(J, F, stm->jumps, here(J,F), cont); break; case STM_FOR_IN: case STM_FOR_IN_VAR: cexp(J, F, stm->b); emit(J, F, OP_ITERATOR); loop = here(J, F); { emit(J, F, OP_NEXTITER); end = emitjump(J, F, OP_JFALSE); cassignforin(J, F, stm); if (F->script) { emit(J, F, OP_ROT2); cstm(J, F, stm->c); emit(J, F, OP_ROT2); } else { cstm(J, F, stm->c); } emitjumpto(J, F, OP_JUMP, loop); } label(J, F, end); labeljumps(J, F, stm->jumps, here(J,F), loop); break; case STM_SWITCH: cswitch(J, F, stm->a, stm->b); labeljumps(J, F, stm->jumps, here(J,F), 0); break; case STM_LABEL: cstm(J, F, stm->b); while (stm->type == STM_LABEL) stm = stm->b; if (!isloop(stm->type) && stm->type != STM_SWITCH) labeljumps(J, F, stm->jumps, here(J,F), 0); break; case STM_BREAK: if (stm->a) { target = breaktarget(J, F, stm, stm->a->string); if (!target) jsC_error(J, stm, ""break label '%s' not found"", stm->a->string); } else { target = breaktarget(J, F, stm, NULL); if (!target) jsC_error(J, stm, ""unlabelled break must be inside loop or switch""); } cexit(J, F, STM_BREAK, stm, target); addjump(J, F, STM_BREAK, target, emitjump(J, F, OP_JUMP)); break; case STM_CONTINUE: if (stm->a) { target = continuetarget(J, F, stm, stm->a->string); if (!target) jsC_error(J, stm, ""continue label '%s' not found"", stm->a->string); } else { target = continuetarget(J, F, stm, NULL); if (!target) jsC_error(J, stm, ""continue must be inside loop""); } cexit(J, F, STM_CONTINUE, stm, target); addjump(J, F, STM_CONTINUE, target, emitjump(J, F, OP_JUMP)); break; case STM_RETURN: if (stm->a) cexp(J, F, stm->a); else emit(J, F, OP_UNDEF); target = returntarget(J, F, stm); if (!target) jsC_error(J, stm, ""return not in function""); cexit(J, F, STM_RETURN, stm, target); emit(J, F, OP_RETURN); break; case STM_THROW: cexp(J, F, stm->a); emit(J, F, OP_THROW); break; case STM_WITH: cexp(J, F, stm->a); emit(J, F, OP_WITH); cstm(J, F, stm->b); emit(J, F, OP_ENDWITH); break; case STM_TRY: if (stm->b && stm->c) { if (stm->d) ctrycatchfinally(J, F, stm->a, stm->b, stm->c, stm->d); else ctrycatch(J, F, stm->a, stm->b, stm->c); } else { ctryfinally(J, F, stm->a, stm->d); } break; case STM_DEBUGGER: emit(J, F, OP_DEBUGGER); break; default: if (F->script) { emit(J, F, OP_POP); cexp(J, F, stm); } else { cexp(J, F, stm); emit(J, F, OP_POP); } break; } }"
"file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size) { bee_t *bee = ic->bee; bee_user_t *bu = bee_user_by_handle(bee, ic, handle); if (bee->ui->ft_in_start) { return bee->ui->ft_in_start(bee, bu, file_name, file_size); } else { return NULL; } }"
static int wddx_stack_destroy(wddx_stack *stack) { register int i; if (stack->elements) { for (i = 0; i < stack->top; i++) { if (((st_entry *)stack->elements[i])->data){ zval_ptr_dtor(&((st_entry *)stack->elements[i])->data); } if (((st_entry *)stack->elements[i])->varname) { efree(((st_entry *)stack->elements[i])->varname); } efree(stack->elements[i]); } efree(stack->elements); } return SUCCESS; }
"static int same_leader( linenr_T lnum, int    leader1_len, char_u  *leader1_flags, int    leader2_len, char_u  *leader2_flags) { int    idx1 = 0, idx2 = 0; char_u  *p; char_u  *line1; char_u  *line2; if (leader1_len == 0) return (leader2_len == 0); if (leader1_flags != NULL) { for (p = leader1_flags; *p && *p != ':'; ++p) { if (*p == COM_FIRST) return (leader2_len == 0); if (*p == COM_END) return FALSE; if (*p == COM_START) { if (*(ml_get(lnum) + leader1_len) == NUL) return FALSE; if (leader2_flags == NULL || leader2_len == 0) return FALSE; for (p = leader2_flags; *p && *p != ':'; ++p) if (*p == COM_MIDDLE) return TRUE; return FALSE; } } } line1 = vim_strsave(ml_get(lnum)); if (line1 != NULL) { for (idx1 = 0; VIM_ISWHITE(line1[idx1]); ++idx1) ; line2 = ml_get(lnum + 1); for (idx2 = 0; idx2 < leader2_len; ++idx2) { if (!VIM_ISWHITE(line2[idx2])) { if (line1[idx1++] != line2[idx2]) break; } else while (VIM_ISWHITE(line1[idx1])) ++idx1; } vim_free(line1); } return (idx2 == leader2_len && idx1 == leader1_len); }"
"static int dissect_gssapi_work(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gboolean is_verifier, gssapi_encrypt_info_t* encrypt_info) { proto_item *volatile item; proto_tree *volatile subtree; volatile int return_offset = 0; gssapi_conv_info_t *volatile gss_info; gssapi_oid_value *oidvalue; dissector_handle_t handle; conversation_t *conversation; tvbuff_t *oid_tvb; int len, start_offset, oid_start_offset; volatile int offset; gint8 appclass; gboolean pc, ind_field; gint32 tag; guint32 len1; const char *oid; fragment_head *fd_head=NULL; gssapi_frag_info_t *fi; tvbuff_t *volatile gss_tvb=NULL; asn1_ctx_t asn1_ctx; start_offset=0; offset=0; asn1_ctx_init(&asn1_ctx, ASN1_ENC_BER, TRUE, pinfo); encrypt_info->gssapi_data_encrypted = FALSE; conversation = find_or_create_conversation(pinfo); gss_info = (gssapi_conv_info_t *)conversation_get_proto_data(conversation, proto_gssapi); if (!gss_info) { gss_info = wmem_new(wmem_file_scope(), gssapi_conv_info_t); gss_info->oid=NULL; gss_info->do_reassembly=FALSE; gss_info->frags=wmem_tree_new(wmem_file_scope()); conversation_add_proto_data(conversation, proto_gssapi, gss_info); } item = proto_tree_add_item( tree, proto_gssapi, tvb, offset, -1, ENC_NA); subtree = proto_item_add_subtree(item, ett_gssapi); TRY { gss_tvb=tvb; if( (!pinfo->fd->flags.visited) &&  (gss_info->do_reassembly) &&  (gssapi_reassembly) ){ fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, gss_info->first_frame); if(!fi){ goto done; } wmem_tree_insert32(gss_info->frags, pinfo->num, fi); fd_head=fragment_add(&gssapi_reassembly_table, tvb, 0, pinfo, fi->first_frame, NULL, gss_info->frag_offset, tvb_captured_length(tvb), TRUE); gss_info->frag_offset+=tvb_captured_length(tvb); if(!fd_head){ goto done; } gss_info->do_reassembly=FALSE; fi->reassembled_in=pinfo->num; gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data); add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI""); } if( (pinfo->fd->flags.visited) &&  (gssapi_reassembly) ){ fi=(gssapi_frag_info_t *)wmem_tree_lookup32(gss_info->frags, pinfo->num); if(fi){ fd_head=fragment_get(&gssapi_reassembly_table, pinfo, fi->first_frame, NULL); if(fd_head && (fd_head->flags&FD_DEFRAGMENTED)){ if(pinfo->num==fi->reassembled_in){ proto_item *frag_tree_item; gss_tvb=tvb_new_chain(tvb, fd_head->tvb_data); add_new_data_source(pinfo, gss_tvb, ""Reassembled GSSAPI""); show_fragment_tree(fd_head, &gssapi_frag_items, tree, pinfo, tvb, &frag_tree_item); } else { proto_item *it; it=proto_tree_add_uint(tree, hf_gssapi_reassembled_in, tvb, 0, 0, fi->reassembled_in); PROTO_ITEM_SET_GENERATED(it); goto done; } } } } offset = get_ber_identifier(gss_tvb, offset, &appclass, &pc, &tag); offset = get_ber_length(gss_tvb, offset, &len1, &ind_field); if (!(appclass == BER_CLASS_APP && pc && tag == 0)) { if ((tvb_captured_length_remaining(gss_tvb, start_offset)>7) && (tvb_strneql(gss_tvb, start_offset, ""NTLMSSP"", 7) == 0)) { return_offset = call_dissector(ntlmssp_handle, tvb_new_subset_remaining(gss_tvb, start_offset), pinfo, subtree); goto done; } if ((tvb_captured_length_remaining(gss_tvb, start_offset)>16) && ((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) { return_offset = call_dissector(ntlmssp_payload_handle, tvb_new_subset_remaining(gss_tvb, start_offset), pinfo, subtree); encrypt_info->gssapi_data_encrypted = TRUE; goto done; } if ((tvb_captured_length_remaining(gss_tvb, start_offset)==16) && ((tvb_memeql(gss_tvb, start_offset, ""\x01\x00\x00\x00"", 4) == 0))) { if( is_verifier ) { return_offset = call_dissector(ntlmssp_verf_handle, tvb_new_subset_remaining(gss_tvb, start_offset), pinfo, subtree); } else if( encrypt_info->gssapi_encrypted_tvb ) { return_offset = call_dissector_with_data(ntlmssp_data_only_handle, tvb_new_subset_remaining(encrypt_info->gssapi_encrypted_tvb, 0), pinfo, subtree, &encrypt_info->gssapi_decrypted_tvb); encrypt_info->gssapi_data_encrypted = TRUE; } goto done; } if ((tvb_captured_length_remaining(gss_tvb, start_offset)>2) && ((tvb_memeql(gss_tvb, start_offset, ""\04\x04"", 2) == 0) || (tvb_memeql(gss_tvb, start_offset, ""\05\x04"", 2) == 0))) { return_offset = call_dissector_with_data(spnego_krb5_wrap_handle, tvb_new_subset_remaining(gss_tvb, start_offset), pinfo, subtree, encrypt_info); goto done; } oidvalue = (gssapi_oid_value *)p_get_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0); if (!oidvalue && !pinfo->fd->flags.visited) { oidvalue = gss_info->oid; if (gss_info->oid) p_add_proto_data(wmem_file_scope(), pinfo, proto_gssapi, 0, gss_info->oid); } if (!oidvalue) { proto_tree_add_expert_format(subtree, pinfo, &ei_gssapi_unknown_header, gss_tvb, start_offset, 0, ""Unknown header (class=%d, pc=%d, tag=%d)"", appclass, pc, tag); return_offset = tvb_captured_length(gss_tvb); goto done; } else { tvbuff_t *oid_tvb_local; oid_tvb_local = tvb_new_subset_remaining(gss_tvb, start_offset); if (is_verifier) handle = oidvalue->wrap_handle; else handle = oidvalue->handle; len = call_dissector_with_data(handle, oid_tvb_local, pinfo, subtree, encrypt_info); if (len == 0) return_offset = tvb_captured_length(gss_tvb); else return_offset = start_offset + len; goto done;  } } oid_start_offset=offset; offset=dissect_ber_object_identifier_str(FALSE, &asn1_ctx, subtree, gss_tvb, offset, hf_gssapi_oid, &oid); oidvalue = gssapi_lookup_oid_str(oid); if( (!pinfo->fd->flags.visited) &&  (oidvalue) &&  (tvb_captured_length(gss_tvb)==tvb_reported_length(gss_tvb)) &&  (len1>(guint32)tvb_captured_length_remaining(gss_tvb, oid_start_offset)) &&  (gssapi_reassembly) ){ fi=wmem_new(wmem_file_scope(), gssapi_frag_info_t); fi->first_frame=pinfo->num; fi->reassembled_in=0; wmem_tree_insert32(gss_info->frags, pinfo->num, fi); fragment_add(&gssapi_reassembly_table, gss_tvb, 0, pinfo, pinfo->num, NULL, 0, tvb_captured_length(gss_tvb), TRUE); fragment_set_tot_len(&gssapi_reassembly_table, pinfo, pinfo->num, NULL, len1+oid_start_offset); gss_info->do_reassembly=TRUE; gss_info->first_frame=pinfo->num; gss_info->frag_offset=tvb_captured_length(gss_tvb); goto done; } if ((oidvalue == NULL) || !proto_is_protocol_enabled(oidvalue->proto)) { proto_tree_add_item(subtree, hf_gssapi_token_object, gss_tvb, oid_start_offset, -1, ENC_NA); return_offset = tvb_captured_length(gss_tvb); goto done; } if(!gss_info->oid){ gss_info->oid=oidvalue; } if (is_verifier) { handle = oidvalue->wrap_handle; if (handle != NULL) { oid_tvb = tvb_new_subset_remaining(gss_tvb, offset); len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info); if (len == 0) return_offset = tvb_captured_length(gss_tvb); else return_offset = offset + len; } else { proto_tree_add_item(subtree, hf_gssapi_auth_verifier, gss_tvb, offset, -1, ENC_NA); return_offset = tvb_captured_length(gss_tvb); } } else { handle = oidvalue->handle; if (handle != NULL) { oid_tvb = tvb_new_subset_remaining(gss_tvb, offset); len = call_dissector_with_data(handle, oid_tvb, pinfo, subtree, encrypt_info); if (len == 0) return_offset = tvb_captured_length(gss_tvb); else return_offset = offset + len; } else { proto_tree_add_item(subtree, hf_gssapi_auth_credentials, gss_tvb, offset, -1, ENC_NA); return_offset = tvb_captured_length(gss_tvb); } } done: ; }"
"int tls1_process_ticket(SSL *s, unsigned char *session_id, int len, const unsigned char *limit, SSL_SESSION **ret) { const unsigned char *p = session_id + len; unsigned short i; *ret = NULL; s->tlsext_ticket_expected = 0; if (SSL_get_options(s) & SSL_OP_NO_TICKET) return 0; if ((s->version <= SSL3_VERSION) || !limit) return 0; if (p >= limit) return -1; if (SSL_IS_DTLS(s)) { i = *(p++); p += i; if (p >= limit) return -1; } n2s(p, i); p += i; if (p >= limit) return -1; i = *(p++); p += i; if (p > limit) return -1; if ((p + 2) >= limit) return 0; n2s(p, i); while ((p + 4) <= limit) { unsigned short type, size; n2s(p, type); n2s(p, size); if (p + size > limit) return 0; if (type == TLSEXT_TYPE_session_ticket) { int r; if (size == 0) { s->tlsext_ticket_expected = 1; return 1; } if (s->tls_session_secret_cb) { return 2; } r = tls_decrypt_ticket(s, p, size, session_id, len, ret); switch (r) { case 2:             s->tlsext_ticket_expected = 1; return 2; case 3:             return r; case 4:             s->tlsext_ticket_expected = 1; return 3; default:            return -1; } } p += size; } return 0; }"
"status_t OMXNodeInstance::allocateBufferWithBackup( OMX_U32 portIndex, const sp<IMemory> &params, OMX::buffer_id *buffer, OMX_U32 allottedSize) { Mutex::Autolock autoLock(mLock); if (allottedSize > params->size()) { return BAD_VALUE; } BufferMeta *buffer_meta = new BufferMeta(params, true); OMX_BUFFERHEADERTYPE *header; OMX_ERRORTYPE err = OMX_AllocateBuffer( mHandle, &header, portIndex, buffer_meta, allottedSize); if (err != OMX_ErrorNone) { CLOG_ERROR(allocateBufferWithBackup, err, SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer())); delete buffer_meta; buffer_meta = NULL; *buffer = 0; return StatusFromOMXError(err); } CHECK_EQ(header->pAppPrivate, buffer_meta); *buffer = makeBufferID(header); addActiveBuffer(portIndex, *buffer); sp<GraphicBufferSource> bufferSource(getGraphicBufferSource()); if (bufferSource != NULL && portIndex == kPortIndexInput) { bufferSource->addCodecBuffer(header); } CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"", params->size(), params->pointer(), allottedSize, header->pBuffer)); return OK; }"
"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl) { struct scm_fp_list *new_fpl; int i; if (!fpl) return NULL; new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]), GFP_KERNEL); if (new_fpl) { for (i = 0; i < fpl->count; i++) get_file(fpl->fp[i]); new_fpl->max = new_fpl->count; } return new_fpl; }"
"shared_ptr<SOARecordContent> loadRPZFromServer(const ComboAddress& master, const DNSName& zone, DNSFilterEngine& target, const std::string& polName, boost::optional<DNSFilterEngine::Policy> defpol, int place,  const TSIGTriplet& tt) { L<<Logger::Warning<<""Loading RPZ zone '""<<zone<<""' from ""<<master.toStringWithPort()<<endl; if(!tt.name.empty()) L<<Logger::Warning<<""With TSIG key '""<<tt.name<<""' of algorithm '""<<tt.algo<<""'""<<endl; ComboAddress local= master.sin4.sin_family == AF_INET ? ComboAddress(""0.0.0.0"") : ComboAddress(""::"");   AXFRRetriever axfr(master, zone, tt, &local); unsigned int nrecords=0; Resolver::res_t nop; vector<DNSRecord> chunk; time_t last=0; shared_ptr<SOARecordContent> sr; while(axfr.getChunk(nop, &chunk)) { for(auto& dr : chunk) { if(dr.d_type==QType::NS || dr.d_type==QType::TSIG) { continue; } dr.d_name.makeUsRelative(zone); if(dr.d_type==QType::SOA) { sr = getRR<SOARecordContent>(dr); continue; } RPZRecordToPolicy(dr, target, polName, true, defpol, place); nrecords++; }  if(last != time(0)) { L<<Logger::Info<<""Loaded & indexed ""<<nrecords<<"" policy records so far""<<endl; last=time(0); } } L<<Logger::Info<<""Done: ""<<nrecords<<"" policy records active, SOA: ""<<sr->getZoneRepresentation()<<endl; return sr; }"
"static bool warn_wrong_flags(const JournalFile *f, bool compatible) { const uint32_t any = compatible ? HEADER_COMPATIBLE_ANY : HEADER_INCOMPATIBLE_ANY, supported = compatible ? HEADER_COMPATIBLE_SUPPORTED : HEADER_INCOMPATIBLE_SUPPORTED; const char *type = compatible ? ""compatible"" : ""incompatible""; uint32_t flags; assert(f); assert(f->header); flags = le32toh(compatible ? f->header->compatible_flags : f->header->incompatible_flags); if (flags & ~supported) { if (flags & ~any) log_debug(""Journal file %s has unknown %s flags 0x%""PRIx32, f->path, type, flags & ~any); flags = (flags & any) & ~supported; if (flags) { const char* strv[6]; size_t n = 0; _cleanup_free_ char *t = NULL; if (compatible) { if (flags & HEADER_COMPATIBLE_SEALED) strv[n++] = ""sealed""; } else { if (flags & HEADER_INCOMPATIBLE_COMPRESSED_XZ) strv[n++] = ""xz-compressed""; if (flags & HEADER_INCOMPATIBLE_COMPRESSED_LZ4) strv[n++] = ""lz4-compressed""; if (flags & HEADER_INCOMPATIBLE_COMPRESSED_ZSTD) strv[n++] = ""zstd-compressed""; if (flags & HEADER_INCOMPATIBLE_KEYED_HASH) strv[n++] = ""keyed-hash""; if (flags & HEADER_INCOMPATIBLE_COMPACT) strv[n++] = ""compact""; } strv[n] = NULL; assert(n < ELEMENTSOF(strv)); t = strv_join((char**) strv, "", ""); log_debug(""Journal file %s uses %s %s %s disabled at compilation time."", f->path, type, n > 1 ? ""flags"" : ""flag"", strnull(t)); } return true; } return false; }"
"static void io_req_task_queue(struct io_kiocb *req) { int ret; init_task_work(&req->task_work, io_req_task_submit); ret = io_req_task_work_add(req, &req->task_work); if (unlikely(ret)) { struct task_struct *tsk; init_task_work(&req->task_work, io_req_task_cancel); tsk = io_wq_get_task(req->ctx->io_wq); task_work_add(tsk, &req->task_work, 0); wake_up_process(tsk); } }"
"static void module_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv)) { struct ly_ctx *ctx; struct lys_node *next, *iter; unsigned int i; assert(module->ctx); ctx = module->ctx; for (i = 0; i < module->imp_size; i++) { lydict_remove(ctx, module->imp[i].prefix); lydict_remove(ctx, module->imp[i].dsc); lydict_remove(ctx, module->imp[i].ref); lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor); } free(module->imp); if (!module->type) { LY_TREE_FOR_SAFE(module->data, next, iter) { lys_node_free(iter, private_destructor, 0); } } lydict_remove(ctx, module->dsc); lydict_remove(ctx, module->ref); lydict_remove(ctx, module->org); lydict_remove(ctx, module->contact); lydict_remove(ctx, module->filepath); for (i = 0; i < module->rev_size; i++) { lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor); lydict_remove(ctx, module->rev[i].dsc); lydict_remove(ctx, module->rev[i].ref); } free(module->rev); for (i = 0; i < module->ident_size; i++) { lys_ident_free(ctx, &module->ident[i], private_destructor); } module->ident_size = 0; free(module->ident); for (i = 0; i < module->tpdf_size; i++) { lys_tpdf_free(ctx, &module->tpdf[i], private_destructor); } free(module->tpdf); lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor); for (i = 0; i < module->augment_size; i++) { lys_augment_free(ctx, &module->augment[i], private_destructor); } free(module->augment); for (i = 0; i < module->features_size; i++) { lys_feature_free(ctx, &module->features[i], private_destructor); } free(module->features); for (i = 0; i < module->deviation_size; i++) { lys_deviation_free(module, &module->deviation[i], private_destructor); } free(module->deviation); for (i = 0; i < module->extensions_size; i++) { lys_extension_free(ctx, &module->extensions[i], private_destructor); } free(module->extensions); lydict_remove(ctx, module->name); lydict_remove(ctx, module->prefix); }"
"void xps_parse_glyphs(fz_context *ctx, xps_document *doc, const fz_matrix *ctm, char *base_uri, xps_resource *dict, fz_xml *root) { fz_device *dev = doc->dev; fz_xml *node; char *fill_uri; char *opacity_mask_uri; char *bidi_level_att; char *fill_att; char *font_size_att; char *font_uri_att; char *origin_x_att; char *origin_y_att; char *is_sideways_att; char *indices_att; char *unicode_att; char *style_att; char *transform_att; char *clip_att; char *opacity_att; char *opacity_mask_att; fz_xml *transform_tag = NULL; fz_xml *clip_tag = NULL; fz_xml *fill_tag = NULL; fz_xml *opacity_mask_tag = NULL; char *fill_opacity_att = NULL; fz_font *font; float font_size = 10; int is_sideways = 0; int bidi_level = 0; fz_text *text; fz_rect area; fz_matrix local_ctm; bidi_level_att = fz_xml_att(root, ""BidiLevel""); fill_att = fz_xml_att(root, ""Fill""); font_size_att = fz_xml_att(root, ""FontRenderingEmSize""); font_uri_att = fz_xml_att(root, ""FontUri""); origin_x_att = fz_xml_att(root, ""OriginX""); origin_y_att = fz_xml_att(root, ""OriginY""); is_sideways_att = fz_xml_att(root, ""IsSideways""); indices_att = fz_xml_att(root, ""Indices""); unicode_att = fz_xml_att(root, ""UnicodeString""); style_att = fz_xml_att(root, ""StyleSimulations""); transform_att = fz_xml_att(root, ""RenderTransform""); clip_att = fz_xml_att(root, ""Clip""); opacity_att = fz_xml_att(root, ""Opacity""); opacity_mask_att = fz_xml_att(root, ""OpacityMask""); for (node = fz_xml_down(root); node; node = fz_xml_next(node)) { if (fz_xml_is_tag(node, ""Glyphs.RenderTransform"")) transform_tag = fz_xml_down(node); if (fz_xml_is_tag(node, ""Glyphs.OpacityMask"")) opacity_mask_tag = fz_xml_down(node); if (fz_xml_is_tag(node, ""Glyphs.Clip"")) clip_tag = fz_xml_down(node); if (fz_xml_is_tag(node, ""Glyphs.Fill"")) fill_tag = fz_xml_down(node); } fill_uri = base_uri; opacity_mask_uri = base_uri; xps_resolve_resource_reference(ctx, doc, dict, &transform_att, &transform_tag, NULL); xps_resolve_resource_reference(ctx, doc, dict, &clip_att, &clip_tag, NULL); xps_resolve_resource_reference(ctx, doc, dict, &fill_att, &fill_tag, &fill_uri); xps_resolve_resource_reference(ctx, doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri); if (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att) { fz_warn(ctx, ""missing attributes in glyphs element""); return; } if (!indices_att && !unicode_att) return;  if (is_sideways_att) is_sideways = !strcmp(is_sideways_att, ""true""); if (bidi_level_att) bidi_level = atoi(bidi_level_att); font = xps_lookup_font(ctx, doc, base_uri, font_uri_att, style_att); if (!font) return;  xps_parse_transform(ctx, doc, transform_att, transform_tag, &local_ctm, ctm); if (clip_att || clip_tag) xps_clip(ctx, doc, &local_ctm, dict, clip_att, clip_tag); font_size = fz_atof(font_size_att); text = xps_parse_glyphs_imp(ctx, doc, &local_ctm, font, font_size, fz_atof(origin_x_att), fz_atof(origin_y_att), is_sideways, bidi_level, indices_att, unicode_att); fz_bound_text(ctx, text, NULL, &local_ctm, &area); xps_begin_opacity(ctx, doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag); if (fill_tag && !strcmp(fz_xml_tag(fill_tag), ""SolidColorBrush"")) { fill_opacity_att = fz_xml_att(fill_tag, ""Opacity""); fill_att = fz_xml_att(fill_tag, ""Color""); fill_tag = NULL; } if (fill_att) { float samples[FZ_MAX_COLORS]; fz_colorspace *colorspace; xps_parse_color(ctx, doc, base_uri, fill_att, &colorspace, samples); if (fill_opacity_att) samples[0] *= fz_atof(fill_opacity_att); xps_set_color(ctx, doc, colorspace, samples); fz_fill_text(ctx, dev, text, &local_ctm, doc->colorspace, doc->color, doc->alpha, NULL); } if (fill_tag) { fz_clip_text(ctx, dev, text, &local_ctm, &area); xps_parse_brush(ctx, doc, &local_ctm, &area, fill_uri, dict, fill_tag); fz_pop_clip(ctx, dev); } xps_end_opacity(ctx, doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag); fz_drop_text(ctx, text); if (clip_att || clip_tag) fz_pop_clip(ctx, dev); fz_drop_font(ctx, font); }"
"static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len) { struct sockaddr_rc *sa = (struct sockaddr_rc *) addr; struct sock *sk = sock->sk; int chan = sa->rc_channel; int err = 0; BT_DBG(""sk %p %pMR"", sk, &sa->rc_bdaddr); if (!addr || addr->sa_family != AF_BLUETOOTH) return -EINVAL; lock_sock(sk); if (sk->sk_state != BT_OPEN) { err = -EBADFD; goto done; } if (sk->sk_type != SOCK_STREAM) { err = -EINVAL; goto done; } write_lock(&rfcomm_sk_list.lock); if (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) { err = -EADDRINUSE; } else { bacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr); rfcomm_pi(sk)->channel = chan; sk->sk_state = BT_BOUND; } write_unlock(&rfcomm_sk_list.lock); done: release_sock(sk); return err; }"
static int on_message_complete(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->process_message(); return 0; }
"OMX_ERRORTYPE omx_video::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr) { unsigned int index = 0; OMX_U8 *temp_buff ; if (bufferHdr == NULL || m_inp_mem_ptr == NULL) { DEBUG_PRINT_ERROR(""ERROR: free_input: Invalid bufferHdr[%p] or m_inp_mem_ptr[%p]"", bufferHdr, m_inp_mem_ptr); return OMX_ErrorBadParameter; } index = bufferHdr - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr); #ifdef _ANDROID_ICS_ if (meta_mode_enable) { if (index < m_sInPortDef.nBufferCountActual) { memset(&meta_buffer_hdr[index], 0, sizeof(meta_buffer_hdr[index])); memset(&meta_buffers[index], 0, sizeof(meta_buffers[index])); } if (!mUseProxyColorFormat) return OMX_ErrorNone; else { c2d_conv.close(); opaque_buffer_hdr[index] = NULL; } } #endif if (index < m_sInPortDef.nBufferCountActual && !mUseProxyColorFormat && dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) { DEBUG_PRINT_LOW(""ERROR: dev_free_buf() Failed for i/p buf""); } if (index < m_sInPortDef.nBufferCountActual && m_pInput_pmem) { if (m_pInput_pmem[index].fd > 0 && input_use_buffer == false) { DEBUG_PRINT_LOW(""FreeBuffer:: i/p AllocateBuffer case""); if(!secure_session) { munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size); } else { free(m_pInput_pmem[index].buffer); } close (m_pInput_pmem[index].fd); #ifdef USE_ION free_ion_memory(&m_pInput_ion[index]); #endif m_pInput_pmem[index].fd = -1; } else if (m_pInput_pmem[index].fd > 0 && (input_use_buffer == true && m_use_input_pmem == OMX_FALSE)) { DEBUG_PRINT_LOW(""FreeBuffer:: i/p Heap UseBuffer case""); if (dev_free_buf(&m_pInput_pmem[index],PORT_INDEX_IN) != true) { DEBUG_PRINT_ERROR(""ERROR: dev_free_buf() Failed for i/p buf""); } if(!secure_session) { munmap (m_pInput_pmem[index].buffer,m_pInput_pmem[index].size); } close (m_pInput_pmem[index].fd); #ifdef USE_ION free_ion_memory(&m_pInput_ion[index]); #endif m_pInput_pmem[index].fd = -1; } else { DEBUG_PRINT_ERROR(""FreeBuffer:: fd is invalid or i/p PMEM UseBuffer case""); } } return OMX_ErrorNone; }"
"int af_get_page(AFFILE *af,int64_t pagenum,unsigned char *data,size_t *bytes) { uint32_t arg=0; size_t page_len=0; if (af_trace){ fprintf(af_trace,""af_get_page(%p,pagenum=%"" I64d "",buf=%p,bytes=%u)\n"",af,pagenum,data,(int)*bytes); } int r = af_get_page_raw(af,pagenum,&arg,0,&page_len); if(r){ if(data && (af->openmode & AF_BADBLOCK_FILL) && errno == ENOENT) { for(size_t i = 0;i <= af->image_pagesize - af->image_sectorsize; i+= af->image_sectorsize){ memcpy(data+i,af->badflag,af->image_sectorsize); af->bytes_memcpy += af->image_sectorsize; } r = 0; } return r;    } uint32_t pageflag = 0; if((arg & AF_PAGE_COMPRESSED)==0){ if(data==0){    if(bytes) *bytes = page_len;    return 0; } int ret = af_get_page_raw(af,pagenum,&pageflag,data,bytes); if(*bytes > page_len) *bytes = page_len; if(ret!=0) return ret;    } else { unsigned char *compressed_data = (unsigned char *)malloc(page_len); size_t compressed_data_len = page_len; if(compressed_data==0){ return -2;} if(af_get_page_raw(af,pagenum,&pageflag,compressed_data,&compressed_data_len)){ free(compressed_data); return -3;} int res = -1;bool free_data = false; if(data==0){ data = (unsigned char *)malloc(af->image_pagesize); free_data = true; *bytes = af->image_pagesize; } switch((pageflag & AF_PAGE_COMP_ALG_MASK)){ case AF_PAGE_COMP_ALG_ZERO: if(compressed_data_len != 4){ (*af->error_reporter)(""ALG_ZERO compressed data is %d bytes, expected 4."",compressed_data_len); break; } memset(data,0,af->image_pagesize); *bytes = ntohl(*(long *)compressed_data); res = 0;    break; case AF_PAGE_COMP_ALG_ZLIB: res = uncompress(data,(uLongf *)bytes,compressed_data,compressed_data_len); switch(res){ case Z_OK: break; case Z_ERRNO: (*af->error_reporter)(""Z_ERRNOR decompressing segment %"" I64d,pagenum); case Z_STREAM_ERROR: (*af->error_reporter)(""Z_STREAM_ERROR decompressing segment %"" I64d,pagenum); case Z_DATA_ERROR: (*af->error_reporter)(""Z_DATA_ERROR decompressing segment %"" I64d,pagenum); case Z_MEM_ERROR: (*af->error_reporter)(""Z_MEM_ERROR decompressing segment %"" I64d,pagenum); case Z_BUF_ERROR: (*af->error_reporter)(""Z_BUF_ERROR decompressing segment %"" I64d,pagenum); case Z_VERSION_ERROR: (*af->error_reporter)(""Z_VERSION_ERROR decompressing segment %"" I64d,pagenum); default: (*af->error_reporter)(""uncompress returned an invalid value in get_segment""); } break; #ifdef USE_LZMA case AF_PAGE_COMP_ALG_LZMA: res = lzma_uncompress(data,bytes,compressed_data,compressed_data_len); if (af_trace) fprintf(af_trace,""   LZMA decompressed page %"" I64d "". %d bytes => %u bytes\n"", pagenum,(int)compressed_data_len,(int)*bytes); switch(res){ case 0:break;    case 1:(*af->error_reporter)(""LZMA header error decompressing segment %"" I64d ""\n"",pagenum); break; case 2:(*af->error_reporter)(""LZMA memory error decompressing segment %"" I64d ""\n"",pagenum); break; } break; #endif default: (*af->error_reporter)(""Unknown compression algorithm 0x%d"", pageflag & AF_PAGE_COMP_ALG_MASK); break; } if(free_data){ free(data); data = 0;} free(compressed_data);af->pages_decompressed++; if(res!=Z_OK) return -1; } if(data && (af->image_pagesize > af->image_sectorsize)){ const int SECTOR_SIZE = af->image_sectorsize;size_t bytes_left_in_sector = (SECTOR_SIZE - (*bytes % SECTOR_SIZE)) % SECTOR_SIZE; for(size_t i=0;i<bytes_left_in_sector;i++){ data[*bytes + i] = 0; } size_t end_of_data = *bytes + bytes_left_in_sector; for(size_t i = end_of_data; i <= af->image_pagesize-SECTOR_SIZE; i+=SECTOR_SIZE){ memcpy(data+i,af->badflag,SECTOR_SIZE); af->bytes_memcpy += SECTOR_SIZE; } } return 0; }"
"int cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info) { struct member *m; int matched = UNSPEC; debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH); TAILQ_FOREACH_REVERSE(m, list, member_list, entries) { matched = cmnd_matches(parse_tree, m, runchroot, info); if (matched != UNSPEC) break; } debug_return_int(matched); }"
"ConnectionManagerImpl::ConnectionManagerImpl(ConnectionManagerConfig& config, const Network::DrainDecision& drain_close, Random::RandomGenerator& random_generator, Http::Context& http_context, Runtime::Loader& runtime, const LocalInfo::LocalInfo& local_info, Upstream::ClusterManager& cluster_manager, Server::OverloadManager& overload_manager, TimeSource& time_source) : config_(config), stats_(config_.stats()), conn_length_(new Stats::HistogramCompletableTimespanImpl( stats_.named_.downstream_cx_length_ms_, time_source)), drain_close_(drain_close), user_agent_(http_context.userAgentContext()), random_generator_(random_generator), runtime_(runtime), local_info_(local_info), cluster_manager_(cluster_manager), listener_stats_(config_.listenerStats()), overload_manager_(overload_manager), overload_state_(overload_manager.getThreadLocalOverloadState()), accept_new_http_stream_(overload_manager.getLoadShedPoint( ""envoy.load_shed_points.http_connection_manager_decode_headers"")), overload_stop_accepting_requests_ref_( overload_state_.getState(Server::OverloadActionNames::get().StopAcceptingRequests)), overload_disable_keepalive_ref_( overload_state_.getState(Server::OverloadActionNames::get().DisableHttpKeepAlive)), time_source_(time_source), proxy_name_(StreamInfo::ProxyStatusUtils::makeProxyName( local_info_.node().id(), config_.serverName(), config_.proxyStatusConfig())), refresh_rtt_after_request_( Runtime::runtimeFeatureEnabled(""envoy.reloadable_features.refresh_rtt_after_request"")) { ENVOY_LOG_ONCE_IF( trace, accept_new_http_stream_ == nullptr, ""LoadShedPoint envoy.load_shed_points.http_connection_manager_decode_headers is not "" ""found. Is it configured?""); }"
"void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page) { gnrc_netif_hdr_t *netif_hdr = pkt->data; gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr); gnrc_pktsnip_t *tmp; size_t orig_datagram_size = gnrc_pkt_len(pkt->next); ipv6_hdr_t *ipv6_hdr = pkt->next->data; ipv6_addr_t dst; if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) { dst = ipv6_hdr->dst;     } if ((tmp = _iphc_encode(pkt, pkt->data, netif))) { if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) && (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst, ctx) == 0)) { DEBUG(""6lo iphc minfwd: putting slack in first fragment\n""); return; } gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page); } else { gnrc_pktbuf_release(pkt); } }"
"static gboolean on_register_handler(TCMUService1HandlerManager1 *interface, GDBusMethodInvocation *invocation, gchar *subtype, gchar *cfg_desc, gpointer user_data) { struct tcmur_handler *handler; struct dbus_info *info; char *bus_name; bus_name = g_strdup_printf(""org.kernel.TCMUService1.HandlerManager1.%s"", subtype); handler               = g_new0(struct tcmur_handler, 1); handler->subtype      = g_strdup(subtype); handler->cfg_desc     = g_strdup(cfg_desc); handler->open         = dbus_handler_open; handler->close        = dbus_handler_close; handler->handle_cmd   = dbus_handler_handle_cmd; info = g_new0(struct dbus_info, 1); info->register_invocation = invocation; info->watcher_id = g_bus_watch_name(G_BUS_TYPE_SYSTEM, bus_name, G_BUS_NAME_WATCHER_FLAGS_NONE, on_handler_appeared, on_handler_vanished, handler, NULL); g_free(bus_name); handler->opaque = info; return TRUE; }"
"static int extract_lladdr_from_llao_aligned(uip_lladdr_t *dest) { if(dest != NULL && nd6_opt_llao != NULL) { memcpy(dest, &nd6_opt_llao[UIP_ND6_OPT_DATA_OFFSET], UIP_LLADDR_LEN); return 1; } return 0; }"
"IHEVCD_ERROR_T ihevcd_mv_buf_mgr_add_bufs(codec_t *ps_codec) { IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS; WORD32 i; WORD32 max_dpb_size; WORD32 mv_bank_size_allocated; WORD32 pic_mv_bank_size; sps_t *ps_sps; UWORD8 *pu1_buf; mv_buf_t *ps_mv_buf; ps_sps = ps_codec->s_parse.ps_sps; max_dpb_size = ps_sps->ai1_sps_max_dec_pic_buffering[ps_sps->i1_sps_max_sub_layers - 1]; max_dpb_size++; pu1_buf = (UWORD8 *)ps_codec->pv_mv_bank_buf_base; ps_mv_buf = (mv_buf_t *)pu1_buf; pu1_buf += max_dpb_size * sizeof(mv_buf_t); ps_codec->ps_mv_buf = ps_mv_buf; mv_bank_size_allocated = ps_codec->i4_total_mv_bank_size - max_dpb_size  * sizeof(mv_buf_t); pic_mv_bank_size = ihevcd_get_pic_mv_bank_size(ALIGN64(ps_sps->i2_pic_width_in_luma_samples) * ALIGN64(ps_sps->i2_pic_height_in_luma_samples)); for(i = 0; i < max_dpb_size; i++) { WORD32 buf_ret; WORD32 num_pu; WORD32 num_ctb; WORD32 pic_size; pic_size = ALIGN64(ps_sps->i2_pic_width_in_luma_samples) * ALIGN64(ps_sps->i2_pic_height_in_luma_samples); num_pu = pic_size / (MIN_PU_SIZE * MIN_PU_SIZE); num_ctb = pic_size / (MIN_CTB_SIZE * MIN_CTB_SIZE); mv_bank_size_allocated -= pic_mv_bank_size; if(mv_bank_size_allocated < 0) { ps_codec->s_parse.i4_error_code = IHEVCD_INSUFFICIENT_MEM_MVBANK; return IHEVCD_INSUFFICIENT_MEM_MVBANK; } ps_mv_buf->pu4_pic_pu_idx = (UWORD32 *)pu1_buf; pu1_buf += (num_ctb + 1) * sizeof(WORD32); ps_mv_buf->pu1_pic_pu_map = pu1_buf; pu1_buf += num_pu; ps_mv_buf->pu1_pic_slice_map = (UWORD16 *)pu1_buf; pu1_buf += ALIGN4(num_ctb * sizeof(UWORD16)); ps_mv_buf->ps_pic_pu = (pu_t *)pu1_buf; pu1_buf += num_pu * sizeof(pu_t); buf_ret = ihevc_buf_mgr_add((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, ps_mv_buf, i); if(0 != buf_ret) { ps_codec->s_parse.i4_error_code = IHEVCD_BUF_MGR_ERROR; return IHEVCD_BUF_MGR_ERROR; } ps_mv_buf++; } return ret; }"
"uint32_t skip(Protocol_& prot, TType arg_type) { switch (arg_type) { case T_BOOL: { bool boolv; return prot.readBool(boolv); } case T_BYTE: { int8_t bytev = 0; return prot.readByte(bytev); } case T_I16: { int16_t i16; return prot.readI16(i16); } case T_I32: { int32_t i32; return prot.readI32(i32); } case T_I64: { int64_t i64; return prot.readI64(i64); } case T_DOUBLE: { double dub; return prot.readDouble(dub); } case T_FLOAT: { float flt; return prot.readFloat(flt); } case T_STRING: { std::string str; return prot.readBinary(str); } case T_STRUCT: { uint32_t result = 0; std::string name; int16_t fid; TType ftype; result += prot.readStructBegin(name); while (true) { result += prot.readFieldBegin(name, ftype, fid); if (ftype == T_STOP) { break; } result += skip(prot, ftype); result += prot.readFieldEnd(); } result += prot.readStructEnd(); return result; } case T_MAP: { uint32_t result = 0; TType keyType; TType valType; uint32_t i, size; bool sizeUnknown; result += prot.readMapBegin(keyType, valType, size, sizeUnknown); if (!sizeUnknown) { for (i = 0; i < size; i++) { result += skip(prot, keyType); result += skip(prot, valType); } } else { while (prot.peekMap()) { result += skip(prot, keyType); result += skip(prot, valType); } } result += prot.readMapEnd(); return result; } case T_SET: { uint32_t result = 0; TType elemType; uint32_t i, size; bool sizeUnknown; result += prot.readSetBegin(elemType, size, sizeUnknown); if (!sizeUnknown) { for (i = 0; i < size; i++) { result += skip(prot, elemType); } } else { while (prot.peekSet()) { result += skip(prot, elemType); } } result += prot.readSetEnd(); return result; } case T_LIST: { uint32_t result = 0; TType elemType; uint32_t i, size; bool sizeUnknown; result += prot.readListBegin(elemType, size, sizeUnknown); if (!sizeUnknown) { for (i = 0; i < size; i++) { result += skip(prot, elemType); } } else { while (prot.peekList()) { result += skip(prot, elemType); } } result += prot.readListEnd(); return result; } default: return 0; } }"
"static gint process_body_part(proto_tree *tree, tvbuff_t *tvb, http_message_info_t *input_message_info, multipart_info_t *m_info, packet_info *pinfo, gint start, gint idx, gboolean *last_boundary) { proto_tree *subtree; proto_item *ti; gint offset = start, next_offset = 0; http_message_info_t message_info = { input_message_info->type, NULL }; gint body_start, boundary_start, boundary_line_len; gchar *content_type_str = NULL; gchar *content_encoding_str = NULL; char *filename = NULL; char *mimetypename = NULL; gboolean last_field = FALSE; gboolean is_raw_data = FALSE; const guint8 *boundary = (guint8 *)m_info->boundary; gint boundary_len = m_info->boundary_length; ti = proto_tree_add_item(tree, hf_multipart_part, tvb, start, 0, ENC_ASCII|ENC_NA); subtree = proto_item_add_subtree(ti, ett_multipart_body); boundary_start = find_next_boundary(tvb, offset, boundary, boundary_len, &boundary_line_len, last_boundary); if (boundary_start <= 0) { return -1; } while (!last_field) { gint colon_offset; char *hdr_str; char *header_str; next_offset = imf_find_field_end(tvb, offset, tvb_reported_length_remaining(tvb, offset)+offset, &last_field); if (last_field && (next_offset+2) <= boundary_start) { next_offset += 2; } else if((next_offset-2) == boundary_start) { last_field = TRUE; next_offset -= 2; } else if (next_offset > boundary_start) { next_offset = boundary_start; } hdr_str = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, next_offset - offset, ENC_ASCII); header_str = unfold_and_compact_mime_header(hdr_str, &colon_offset); if (colon_offset <= 0) { next_offset = offset; break; } else { gint hf_index; header_str[colon_offset] = '\0'; hf_index = is_known_multipart_header(header_str, colon_offset); if (hf_index == -1) { if(isprint_string(hdr_str)) { proto_tree_add_format_text(subtree, tvb, offset, next_offset - offset); } else { next_offset = offset; break; } } else { char *value_str = g_strdup(header_str + colon_offset + 1); proto_tree_add_string_format(subtree, hf_header_array[hf_index], tvb, offset, next_offset - offset, (const char *)value_str, ""%s"", tvb_format_text(tvb, offset, next_offset - offset)); switch (hf_index) { case POS_ORIGINALCONTENT: { char *semicolonp; char* type_str = ws_find_media_type_parameter(value_str, ""type""); if(type_str != NULL) { g_free(value_str); value_str = type_str; } semicolonp = strchr(value_str, ';'); if (semicolonp != NULL) { *semicolonp = '\0'; m_info->orig_parameters = wmem_strdup(wmem_packet_scope(), semicolonp + 1); } m_info->orig_content_type = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1); } break; case POS_CONTENT_TYPE: { char *semicolonp = strchr(value_str, ';'); if (semicolonp != NULL) { *semicolonp = '\0'; message_info.media_str = wmem_strdup(wmem_packet_scope(), semicolonp + 1); } else { message_info.media_str = NULL; } content_type_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1); proto_item_append_text(ti, "" (%s)"", content_type_str); mimetypename = ws_find_media_type_parameter(message_info.media_str, ""name""); if(strncmp(content_type_str, ""application/octet-stream"", sizeof(""application/octet-stream"")-1) == 0) { is_raw_data = TRUE; } if(m_info->protocol && idx == 0 && (is_raw_data || g_ascii_strncasecmp(content_type_str, m_info->protocol, strlen(m_info->protocol)) != 0)) { return -1; } } break; case POS_CONTENT_TRANSFER_ENCODING: { char *crp = strchr(value_str, '\r'); if (crp != NULL) { *crp = '\0'; } content_encoding_str = wmem_ascii_strdown(wmem_packet_scope(), value_str, -1); } break; case POS_CONTENT_DISPOSITION: { filename = ws_find_media_type_parameter(value_str, ""filename""); } break; default: break; } g_free(value_str); } } offset = next_offset; } body_start = next_offset; { gint body_len = boundary_start - body_start; tvbuff_t *tmp_tvb = tvb_new_subset_length(tvb, body_start, body_len); if(m_info->protocol && idx == 1 && is_raw_data) { gssapi_encrypt_info_t  encrypt; memset(&encrypt, 0, sizeof(encrypt)); encrypt.decrypt_gssapi_tvb=DECRYPT_GSSAPI_NORMAL; dissect_kerberos_encrypted_message(tmp_tvb, pinfo, subtree, &encrypt); if(encrypt.gssapi_decrypted_tvb){ tmp_tvb = encrypt.gssapi_decrypted_tvb; is_raw_data = FALSE; content_type_str = m_info->orig_content_type; message_info.media_str = m_info->orig_parameters; } else if(encrypt.gssapi_encrypted_tvb) { tmp_tvb = encrypt.gssapi_encrypted_tvb; proto_tree_add_expert(tree, pinfo, &ei_multipart_decryption_not_possible, tmp_tvb, 0, -1); } } if (!is_raw_data && content_type_str) { gboolean dissected; if(content_encoding_str && remove_base64_encoding) { if(!g_ascii_strncasecmp(content_encoding_str, ""base64"", 6)) tmp_tvb = base64_decode(pinfo, tmp_tvb, filename ? filename : (mimetypename ? mimetypename : content_type_str)); } dissected = dissector_try_string(multipart_media_subdissector_table, content_type_str, tmp_tvb, pinfo, subtree, &message_info); if (! dissected) { dissected = dissector_try_string(media_type_dissector_table, content_type_str, tmp_tvb, pinfo, subtree, &message_info); } if (! dissected) { const char *save_match_string = pinfo->match_string; pinfo->match_string = content_type_str; call_dissector_with_data(media_handle, tmp_tvb, pinfo, subtree, &message_info); pinfo->match_string = save_match_string; } message_info.media_str = NULL;  } else { call_data_dissector(tmp_tvb, pinfo, subtree); } proto_item_set_len(ti, boundary_start - start); if (*last_boundary == TRUE) { proto_tree_add_item(tree, hf_multipart_last_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII); } else { proto_tree_add_item(tree, hf_multipart_boundary, tvb, boundary_start, boundary_line_len, ENC_NA|ENC_ASCII); } g_free(filename); g_free(mimetypename); return boundary_start + boundary_line_len; } }"
"void cache_flush(const void *addr, unsigned int size) { unsigned int clflush_size = current_cpu_data.x86_clflush_size ?: 16; const void *end = addr + size; addr -= (unsigned long)addr & (clflush_size - 1); for ( ; addr < end; addr += clflush_size ) { alternative_io(""ds; clflush %[p]"", ""data16 clflush %[p]"",  X86_FEATURE_CLFLUSHOPT, , [p] ""m"" (*(const char *)(addr))); } alternative("""", ""sfence"", X86_FEATURE_CLFLUSHOPT); }"
"int imagetobmp(opj_image_t * image, const char *outfile) { int w, h; int i, pad; FILE *fdest = NULL; int adjustR, adjustG, adjustB; if (image->comps[0].prec < 8) { fprintf(stderr, ""Unsupported number of components: %d\n"", image->comps[0].prec); return 1; } if (image->numcomps >= 3 && image->comps[0].dx == image->comps[1].dx && image->comps[1].dx == image->comps[2].dx && image->comps[0].dy == image->comps[1].dy && image->comps[1].dy == image->comps[2].dy && image->comps[0].prec == image->comps[1].prec && image->comps[1].prec == image->comps[2].prec) { fdest = fopen(outfile, ""wb""); if (!fdest) { fprintf(stderr, ""ERROR -> failed to open %s for writing\n"", outfile); return 1; } w = (int)image->comps[0].w; h = (int)image->comps[0].h; fprintf(fdest, ""BM""); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)>> 8) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)>> 16) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2) + 54)>> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (40) & 0xff, ((40) >> 8) & 0xff,((40) >> 16) & 0xff, ((40) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) ((w) & 0xff), (OPJ_UINT8) ((w) >> 8) & 0xff, (OPJ_UINT8) ((w) >> 16) & 0xff, (OPJ_UINT8) ((w) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) ((h) & 0xff), (OPJ_UINT8) ((h) >> 8) & 0xff, (OPJ_UINT8) ((h) >> 16) & 0xff, (OPJ_UINT8) ((h) >> 24) & 0xff); fprintf(fdest, ""%c%c"", (1) & 0xff, ((1) >> 8) & 0xff); fprintf(fdest, ""%c%c"", (24) & 0xff, ((24) >> 8) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) (3 * h * w + 3 * h * (w % 2)) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff, (OPJ_UINT8) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (7834) & 0xff, ((7834) >> 8) & 0xff,((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); if (image->comps[0].prec > 8) { adjustR = (int)image->comps[0].prec - 8; printf(""BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n"", image->comps[0].prec); } else adjustR = 0; if (image->comps[1].prec > 8) { adjustG = (int)image->comps[1].prec - 8; printf(""BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n"", image->comps[1].prec); } else adjustG = 0; if (image->comps[2].prec > 8) { adjustB = (int)image->comps[2].prec - 8; printf(""BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n"", image->comps[2].prec); } else adjustB = 0; for (i = 0; i < w * h; i++) { OPJ_UINT8 rc, gc, bc; int r, g, b; r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0); r = ((r >> adjustR)+((r >> (adjustR-1))%2)); if(r > 255) r = 255; else if(r < 0) r = 0; rc = (OPJ_UINT8)r; g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0); g = ((g >> adjustG)+((g >> (adjustG-1))%2)); if(g > 255) g = 255; else if(g < 0) g = 0; gc = (OPJ_UINT8)g; b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0); b = ((b >> adjustB)+((b >> (adjustB-1))%2)); if(b > 255) b = 255; else if(b < 0) b = 0; bc = (OPJ_UINT8)b; fprintf(fdest, ""%c%c%c"", bc, gc, rc); if ((i + 1) % w == 0) { for (pad = ((3 * w) % 4) ? (4 - (3 * w) % 4) : 0; pad > 0; pad--) fprintf(fdest, ""%c"", 0); } } fclose(fdest); } else { fdest = fopen(outfile, ""wb""); if (!fdest) { fprintf(stderr, ""ERROR -> failed to open %s for writing\n"", outfile); return 1; } w = (int)image->comps[0].w; h = (int)image->comps[0].h; fprintf(fdest, ""BM""); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) (h * w + 54 + 1024 + h * (w % 2)) & 0xff, (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff, (OPJ_UINT8) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff, (OPJ_UINT8) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, ((54 + 1024) >> 16) & 0xff, ((54 + 1024) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (40) & 0xff, ((40) >> 8) & 0xff,((40) >> 16) & 0xff, ((40) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) ((w) & 0xff), (OPJ_UINT8) ((w) >> 8) & 0xff, (OPJ_UINT8) ((w) >> 16) & 0xff, (OPJ_UINT8) ((w) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) ((h) & 0xff), (OPJ_UINT8) ((h) >> 8) & 0xff, (OPJ_UINT8) ((h) >> 16) & 0xff, (OPJ_UINT8) ((h) >> 24) & 0xff); fprintf(fdest, ""%c%c"", (1) & 0xff, ((1) >> 8) & 0xff); fprintf(fdest, ""%c%c"", (8) & 0xff, ((8) >> 8) & 0xff); fprintf(fdest, ""%c%c%c%c"", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (OPJ_UINT8) (h * w + h * (w % 2)) & 0xff, (OPJ_UINT8) ((h * w + h * (w % 2)) >> 8) &0xff, (OPJ_UINT8) ((h * w + h * (w % 2)) >> 16) &0xff, (OPJ_UINT8) ((h * w + h * (w % 2)) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (7834) & 0xff, ((7834) >> 8) & 0xff,((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (7834) & 0xff, ((7834) >> 8) & 0xff,((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff); fprintf(fdest, ""%c%c%c%c"", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff); if (image->comps[0].prec > 8) { adjustR = (int)image->comps[0].prec - 8; printf(""BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n"", image->comps[0].prec); }else adjustR = 0; for (i = 0; i < 256; i++) { fprintf(fdest, ""%c%c%c%c"", i, i, i, 0); } for (i = 0; i < w * h; i++) { int r; r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0); r = ((r >> adjustR)+((r >> (adjustR-1))%2)); if(r > 255) r = 255; else if(r < 0) r = 0; fprintf(fdest, ""%c"", (OPJ_UINT8)r); if ((i + 1) % w == 0) { for (pad = (w % 4) ? (4 - w % 4) : 0; pad > 0; pad--) fprintf(fdest, ""%c"", 0); } } fclose(fdest); } return 0; }"
"static TEE_Result tee_svc_cipher_update_helper(unsigned long state, bool last_block, const void *src, size_t src_len, void *dst, uint64_t *dst_len) { TEE_Result res; struct tee_cryp_state *cs; struct tee_ta_session *sess; size_t dlen = 0; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs); if (res != TEE_SUCCESS) return res; res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx), TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)src, src_len); if (res != TEE_SUCCESS) return res; if (!dst_len) { dlen = 0; } else { res = get_user_u64_as_size_t(&dlen, dst_len); if (res != TEE_SUCCESS) return res; res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx), TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_WRITE | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)dst, dlen); if (res != TEE_SUCCESS) return res; } if (dlen < src_len) { res = TEE_ERROR_SHORT_BUFFER; goto out; } if (src_len > 0) { res = tee_do_cipher_update(cs->ctx, cs->algo, cs->mode, last_block, src, src_len, dst); } if (last_block && cs->ctx_finalize != NULL) { cs->ctx_finalize(cs->ctx, cs->algo); cs->ctx_finalize = NULL; } out: if ((res == TEE_SUCCESS || res == TEE_ERROR_SHORT_BUFFER) && dst_len != NULL) { TEE_Result res2; res2 = put_user_u64(dst_len, src_len); if (res2 != TEE_SUCCESS) res = res2; } return res; }"
"static XML_Bool storeRawNames(XML_Parser parser) { TAG *tag = parser->m_tagStack; while (tag) { int bufSize; int nameLen = sizeof(XML_Char) * (tag->name.strLen + 1); char *rawNameBuf = tag->buf + nameLen; if (tag->rawName == rawNameBuf) break; bufSize = nameLen + ROUND_UP(tag->rawNameLength, sizeof(XML_Char)); if (bufSize > tag->bufEnd - tag->buf) { char *temp = (char *)REALLOC(parser, tag->buf, bufSize); if (temp == NULL) return XML_FALSE; if (tag->name.str == (XML_Char *)tag->buf) tag->name.str = (XML_Char *)temp; if (tag->name.localPart) tag->name.localPart = (XML_Char *)temp + (tag->name.localPart - (XML_Char *)tag->buf); tag->buf = temp; tag->bufEnd = temp + bufSize; rawNameBuf = temp + nameLen; } memcpy(rawNameBuf, tag->rawName, tag->rawNameLength); tag->rawName = rawNameBuf; tag = tag->parent; } return XML_TRUE; }"
"static int count(struct cstate *g, Renode *node) { int min, max, n; if (!node) return 0; switch (node->type) { default: return 1; case P_CAT: return count(g, node->x) + count(g, node->y); case P_ALT: return count(g, node->x) + count(g, node->y) + 2; case P_REP: min = node->m; max = node->n; if (min == max) n = count(g, node->x) * min; else if (max < REPINF) n = count(g, node->x) * max + (max - min); else n = count(g, node->x) * (min + 1) + 2; if (n < 0 || n > REG_MAXPROG) die(g, ""program too large""); return n; case P_PAR: return count(g, node->x) + 2; case P_PLA: return count(g, node->x) + 2; case P_NLA: return count(g, node->x) + 2; } }"
"void subtract (const hb_bit_set_invertible_t &other) { if (likely (inverted == other.inverted)) { if (unlikely (inverted)) process (hb_bitwise_lt, other); else process (hb_bitwise_gt, other);  } else { if (unlikely (inverted)) process (hb_bitwise_or, other); else process (hb_bitwise_and, other); } inverted = inverted && !other.inverted; }"
"int my_csr_reader( const char*           i_csr_file_in, unsigned int**        o_row_idx, unsigned int**        o_column_idx, REALTYPE**            o_values, unsigned int*         o_row_count, unsigned int*         o_column_count, unsigned int*         o_element_count ) { FILE *l_csr_file_handle; const unsigned int l_line_length = 512; char l_line[512+1]; unsigned int l_header_read = 0; unsigned int* l_row_idx_id = NULL; unsigned int l_i = 0; l_csr_file_handle = fopen( i_csr_file_in, ""r"" ); if ( l_csr_file_handle == NULL ) { fprintf( stderr, ""cannot open CSR file!\n"" ); return -1; } while (fgets(l_line, l_line_length, l_csr_file_handle) != NULL) { if ( strlen(l_line) == l_line_length ) { fprintf( stderr, ""could not read file length!\n"" ); return -1; } if ( l_line[0] == '%' ) { continue; } else { if ( l_header_read == 0 ) { if ( sscanf(l_line, ""%u %u %u"", o_row_count, o_column_count, o_element_count) == 3 ) { *o_column_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_element_count)); *o_row_idx = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count + 1)); *o_values = (REALTYPE*) malloc(sizeof(double) * (*o_element_count)); l_row_idx_id = (unsigned int*) malloc(sizeof(unsigned int) * (*o_row_count)); if ( ( *o_row_idx == NULL )      || ( *o_column_idx == NULL )   || ( *o_values == NULL )       || ( l_row_idx_id == NULL ) ) { fprintf( stderr, ""could not allocate sp data!\n"" ); return -1; } memset(*o_row_idx, 0, sizeof(unsigned int)*(*o_row_count + 1)); memset(*o_column_idx, 0, sizeof(unsigned int)*(*o_element_count)); memset(*o_values, 0, sizeof(double)*(*o_element_count)); memset(l_row_idx_id, 0, sizeof(unsigned int)*(*o_row_count)); for ( l_i = 0; l_i < (*o_row_count + 1); l_i++) (*o_row_idx)[l_i] = (*o_element_count); (*o_row_idx)[0] = 0; l_i = 0; l_header_read = 1; } else { fprintf( stderr, ""could not csr description!\n"" ); return -1; } } else { unsigned int l_row, l_column; REALTYPE l_value; if ( sscanf(l_line, ""%u %u %lf"", &l_row, &l_column, &l_value) != 3 ) { fprintf( stderr, ""could not read element!\n"" ); return -1; } l_row--; l_column--; (*o_column_idx)[l_i] = l_column; (*o_values)[l_i] = l_value; l_i++; l_row_idx_id[l_row] = 1; (*o_row_idx)[l_row+1] = l_i; } } } fclose( l_csr_file_handle ); if ( l_i != (*o_element_count) ) { fprintf( stderr, ""we were not able to read all elements!\n"" ); return -1; } for ( l_i = 0; l_i < (*o_row_count); l_i++) { if ( l_row_idx_id[l_i] == 0 ) { (*o_row_idx)[l_i+1] = (*o_row_idx)[l_i]; } } if ( l_row_idx_id != NULL ) { free( l_row_idx_id ); } return 0; }"
"struct posix_acl *fuse_get_acl(struct inode *inode, int type) { struct fuse_conn *fc = get_fuse_conn(inode); int size; const char *name; void *value = NULL; struct posix_acl *acl; if (!fc->posix_acl || fc->no_getxattr) return NULL; if (type == ACL_TYPE_ACCESS) name = XATTR_NAME_POSIX_ACL_ACCESS; else if (type == ACL_TYPE_DEFAULT) name = XATTR_NAME_POSIX_ACL_DEFAULT; else return ERR_PTR(-EOPNOTSUPP); value = kmalloc(PAGE_SIZE, GFP_KERNEL); if (!value) return ERR_PTR(-ENOMEM); size = fuse_getxattr(inode, name, value, PAGE_SIZE); if (size > 0) acl = posix_acl_from_xattr(fc->user_ns, value, size); else if ((size == 0) || (size == -ENODATA) || (size == -EOPNOTSUPP && fc->no_getxattr)) acl = NULL; else if (size == -ERANGE) acl = ERR_PTR(-E2BIG); else acl = ERR_PTR(size); kfree(value); return acl; }"
"void extract_archive (void) { char typeflag; tar_extractor_t fun; fatal_exit_hook = extract_finish; set_next_block_after (current_header); if (!current_stat_info.file_name[0] || (interactive_option && !confirm (""extract"", current_stat_info.file_name))) { skip_member (); return; } if (verbose_option) print_header (&current_stat_info, current_header, -1); if (!delay_directory_restore_option) { int dir = chdir_current; apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0); chdir_do (dir); } if (backup_option) if (!maybe_backup_file (current_stat_info.file_name, 0)) { int e = errno; ERROR ((0, e, _(""%s: Was unable to backup this file""), quotearg_colon (current_stat_info.file_name))); skip_member (); return; } typeflag = sparse_member_p (&current_stat_info) ? GNUTYPE_SPARSE : current_header->header.typeflag; if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun)) { if (fun && (*fun) (current_stat_info.file_name, typeflag) && backup_option) undo_last_backup (); } else skip_member (); }"
"GF_Err stbl_AddChunkOffset(GF_MediaBox *mdia, u32 sampleNumber, u32 StreamDescIndex, u64 offset, u32 nb_pack_samples) { GF_SampleTableBox *stbl; GF_ChunkOffsetBox *stco; GF_SampleToChunkBox *stsc; GF_ChunkLargeOffsetBox *co64; GF_StscEntry *ent; u32 i, k, *newOff, new_chunk_idx=0; u64 *newLarge; s32 insert_idx = -1; stbl = mdia->information->sampleTable; stsc = stbl->SampleToChunk; if (!nb_pack_samples) nb_pack_samples = 1; if (!stsc->nb_entries || (stsc->nb_entries + 2 >= stsc->alloc_size)) { if (!stsc->alloc_size) stsc->alloc_size = 1; ALLOC_INC(stsc->alloc_size); stsc->entries = gf_realloc(stsc->entries, sizeof(GF_StscEntry)*stsc->alloc_size); if (!stsc->entries) return GF_OUT_OF_MEM; memset(&stsc->entries[stsc->nb_entries], 0, sizeof(GF_StscEntry)*(stsc->alloc_size-stsc->nb_entries) ); } if (sampleNumber == stsc->w_lastSampleNumber + 1) { ent = &stsc->entries[stsc->nb_entries]; stsc->w_lastChunkNumber ++; ent->firstChunk = stsc->w_lastChunkNumber; if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = stsc->w_lastChunkNumber; new_chunk_idx = stsc->w_lastChunkNumber; stsc->w_lastSampleNumber = sampleNumber + nb_pack_samples-1; stsc->nb_entries += 1; } else { u32 cur_samp = 1; u32 samples_in_next_entry = 0; u32 next_entry_first_chunk = 1; for (i=0; i<stsc->nb_entries; i++) { u32 nb_chunks = 1; ent = &stsc->entries[i]; if (i+1<stsc->nb_entries) nb_chunks = stsc->entries[i+1].firstChunk - ent->firstChunk; for (k=0; k<nb_chunks; k++) { if ((cur_samp <= sampleNumber) && (ent->samplesPerChunk + cur_samp > sampleNumber)) { insert_idx = i; if (sampleNumber>cur_samp) { samples_in_next_entry = ent->samplesPerChunk - (sampleNumber-cur_samp); ent->samplesPerChunk = sampleNumber-cur_samp; } break; } cur_samp += ent->samplesPerChunk; next_entry_first_chunk++; } if (insert_idx>=0) break; } if (samples_in_next_entry) { memmove(&stsc->entries[insert_idx+3], &stsc->entries[insert_idx+1], sizeof(GF_StscEntry)*(stsc->nb_entries - insert_idx - 1)); ent = &stsc->entries[insert_idx]; stsc->entries[insert_idx+2] = *ent; stsc->entries[insert_idx+2].samplesPerChunk = samples_in_next_entry; stsc->entries[insert_idx+2].firstChunk = next_entry_first_chunk + 1; ent = &stsc->entries[insert_idx+1]; ent->firstChunk = next_entry_first_chunk; stsc->nb_entries += 2; } else { if (insert_idx<0) { ent = &stsc->entries[stsc->nb_entries]; insert_idx = stsc->nb_entries; } else { memmove(&stsc->entries[insert_idx+1], &stsc->entries[insert_idx], sizeof(GF_StscEntry)*(stsc->nb_entries+1-insert_idx)); ent = &stsc->entries[insert_idx+1]; } ent->firstChunk = next_entry_first_chunk; stsc->nb_entries += 1; } new_chunk_idx = next_entry_first_chunk; } ent->isEdited = (Media_IsSelfContained(mdia, StreamDescIndex)) ? 1 : 0; ent->sampleDescriptionIndex = StreamDescIndex; ent->samplesPerChunk = nb_pack_samples; ent->nextChunk = ent->firstChunk+1; if (sampleNumber + nb_pack_samples - 1 == stsc->w_lastSampleNumber) { if (stsc->nb_entries) stsc->entries[stsc->nb_entries-1].nextChunk = ent->firstChunk; stbl->SampleToChunk->currentIndex = stsc->nb_entries-1; stbl->SampleToChunk->firstSampleInCurrentChunk = sampleNumber; stbl->SampleToChunk->currentChunk = stsc->w_lastChunkNumber; stbl->SampleToChunk->ghostNumber = 1; } else { for (i = insert_idx+1; i<stsc->nb_entries+1; i++) { stsc->entries[i].firstChunk++; if (i+1<stsc->nb_entries) stsc->entries[i-1].nextChunk = stsc->entries[i].firstChunk; } } if (stbl->ChunkOffset->type == GF_ISOM_BOX_TYPE_STCO) { stco = (GF_ChunkOffsetBox *)stbl->ChunkOffset; if (offset > 0xFFFFFFFF) { co64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new_parent(&stbl->child_boxes, GF_ISOM_BOX_TYPE_CO64); if (!co64) return GF_OUT_OF_MEM; co64->nb_entries = stco->nb_entries + 1; co64->alloc_size = co64->nb_entries; co64->offsets = (u64*)gf_malloc(sizeof(u64) * co64->nb_entries); if (!co64->offsets) return GF_OUT_OF_MEM; k = 0; for (i=0; i<stco->nb_entries; i++) { if (i + 1 == new_chunk_idx) { co64->offsets[i] = offset; k = 1; } co64->offsets[i+k] = (u64) stco->offsets[i]; } if (!k) co64->offsets[co64->nb_entries - 1] = offset; gf_isom_box_del_parent(&stbl->child_boxes, stbl->ChunkOffset); stbl->ChunkOffset = (GF_Box *) co64; } else { if (new_chunk_idx > stco->nb_entries) { if (!stco->alloc_size) stco->alloc_size = stco->nb_entries; if (stco->nb_entries == stco->alloc_size) { ALLOC_INC(stco->alloc_size); stco->offsets = (u32*)gf_realloc(stco->offsets, sizeof(u32) * stco->alloc_size); if (!stco->offsets) return GF_OUT_OF_MEM; memset(&stco->offsets[stco->nb_entries], 0, sizeof(u32) * (stco->alloc_size-stco->nb_entries) ); } stco->offsets[stco->nb_entries] = (u32) offset; stco->nb_entries += 1; } else { newOff = (u32*)gf_malloc(sizeof(u32) * (stco->nb_entries + 1)); if (!newOff) return GF_OUT_OF_MEM; k=0; for (i=0; i<stco->nb_entries; i++) { if (i+1 == new_chunk_idx) { newOff[i] = (u32) offset; k=1; } newOff[i+k] = stco->offsets[i]; } gf_free(stco->offsets); stco->offsets = newOff; stco->nb_entries ++; stco->alloc_size = stco->nb_entries; } } } else { co64 = (GF_ChunkLargeOffsetBox *)stbl->ChunkOffset; if (sampleNumber > co64->nb_entries) { if (!co64->alloc_size) co64->alloc_size = co64->nb_entries; if (co64->nb_entries == co64->alloc_size) { ALLOC_INC(co64->alloc_size); co64->offsets = (u64*)gf_realloc(co64->offsets, sizeof(u64) * co64->alloc_size); if (!co64->offsets) return GF_OUT_OF_MEM; memset(&co64->offsets[co64->nb_entries], 0, sizeof(u64) * (co64->alloc_size - co64->nb_entries) ); } co64->offsets[co64->nb_entries] = offset; co64->nb_entries += 1; } else { newLarge = (u64*)gf_malloc(sizeof(u64) * (co64->nb_entries + 1)); if (!newLarge) return GF_OUT_OF_MEM; k=0; for (i=0; i<co64->nb_entries; i++) { if (i+1 == new_chunk_idx) { newLarge[i] = offset; k=1; } newLarge[i+k] = co64->offsets[i]; } gf_free(co64->offsets); co64->offsets = newLarge; co64->nb_entries++; co64->alloc_size++; } } return GF_OK; }"
"static int formatIPTC(Image *ifile, Image *ofile) { char temp[MagickPathExtent]; unsigned int foundiptc, tagsfound; unsigned char recnum, dataset; unsigned char *readable, *str; ssize_t tagindx, taglen; int i, tagcount = (int) (sizeof(tags) / sizeof(tag_spec)); int c; foundiptc = 0;  tagsfound = 0;  c = ReadBlobByte(ifile); while (c != EOF) { if (c == 0x1c) foundiptc = 1; else { if (foundiptc) return(-1); else { c=0; continue; } } c = ReadBlobByte(ifile); if (c == EOF) return(-1); dataset = (unsigned char) c; c = ReadBlobByte(ifile); if (c == EOF) return(-1); recnum = (unsigned char) c; for (i=0; i< tagcount; i++) { if (tags[i].id == (short) recnum) break; } if (i < tagcount) readable = (unsigned char *) tags[i].name; else readable = (unsigned char *) """"; c=ReadBlobByte(ifile); if (c == EOF) return(-1); if (c & (unsigned char) 0x80) return(0); else { int c0; c0=ReadBlobByte(ifile); if (c0 == EOF) return(-1); taglen = (c << 8) | c0; } if (taglen < 0) return(-1); str=(unsigned char *) AcquireQuantumMemory((size_t) (taglen+MagickPathExtent), sizeof(*str)); if (str == (unsigned char *) NULL) return(0); for (tagindx=0; tagindx<taglen; tagindx++) { c=ReadBlobByte(ifile); if (c == EOF) { str=(unsigned char *) RelinquishMagickMemory(str); return(-1); } str[tagindx] = (unsigned char) c; } str[taglen] = 0; if (strlen((char *)readable) > 0) (void) FormatLocaleString(temp,MagickPathExtent,""%d#%d#%s="", (unsigned int) dataset, (unsigned int) recnum, readable); else (void) FormatLocaleString(temp,MagickPathExtent,""%d#%d="", (unsigned int) dataset,(unsigned int) recnum); (void) WriteBlobString(ofile,temp); formatString( ofile, (char *)str, taglen ); str=(unsigned char *) RelinquishMagickMemory(str); tagsfound++; c=ReadBlobByte(ifile); } return((int) tagsfound); }"
"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { EXRContext *s = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *picture = data; uint8_t *ptr; int i, y, ret, ymax; int planes; int out_line_size; int nb_blocks;    uint64_t start_offset_table; uint64_t start_next_scanline; PutByteContext offset_table_writer; bytestream2_init(&s->gb, avpkt->data, avpkt->size); if ((ret = decode_header(s, picture)) < 0) return ret; switch (s->pixel_type) { case EXR_FLOAT: case EXR_HALF: if (s->channel_offsets[3] >= 0) { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_GBRAPF32; } else { avctx->pix_fmt = AV_PIX_FMT_GBRAPF32; } } else { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_GBRPF32; } else { avctx->pix_fmt = AV_PIX_FMT_GRAYF32; } } break; case EXR_UINT: if (s->channel_offsets[3] >= 0) { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_RGBA64; } else { avctx->pix_fmt = AV_PIX_FMT_YA16; } } else { if (!s->is_luma) { avctx->pix_fmt = AV_PIX_FMT_RGB48; } else { avctx->pix_fmt = AV_PIX_FMT_GRAY16; } } break; default: av_log(avctx, AV_LOG_ERROR, ""Missing channel list.\n""); return AVERROR_INVALIDDATA; } if (s->apply_trc_type != AVCOL_TRC_UNSPECIFIED) avctx->color_trc = s->apply_trc_type; switch (s->compression) { case EXR_RAW: case EXR_RLE: case EXR_ZIP1: s->scan_lines_per_block = 1; break; case EXR_PXR24: case EXR_ZIP16: s->scan_lines_per_block = 16; break; case EXR_PIZ: case EXR_B44: case EXR_B44A: s->scan_lines_per_block = 32; break; default: avpriv_report_missing_feature(avctx, ""Compression %d"", s->compression); return AVERROR_PATCHWELCOME; } if (s->xmin > s->xmax  || s->ymin > s->ymax || s->ydelta == 0xFFFFFFFF || s->xdelta == 0xFFFFFFFF) { av_log(avctx, AV_LOG_ERROR, ""Wrong or missing size information.\n""); return AVERROR_INVALIDDATA; } if ((ret = ff_set_dimensions(avctx, s->w, s->h)) < 0) return ret; s->desc          = av_pix_fmt_desc_get(avctx->pix_fmt); if (!s->desc) return AVERROR_INVALIDDATA; if (s->desc->flags & AV_PIX_FMT_FLAG_FLOAT) { planes           = s->desc->nb_components; out_line_size    = avctx->width * 4; } else { planes           = 1; out_line_size    = avctx->width * 2 * s->desc->nb_components; } if (s->is_tile) { nb_blocks = ((s->xdelta + s->tile_attr.xSize - 1) / s->tile_attr.xSize) * ((s->ydelta + s->tile_attr.ySize - 1) / s->tile_attr.ySize); } else {  nb_blocks = (s->ydelta + s->scan_lines_per_block - 1) / s->scan_lines_per_block; } if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) return ret; if (bytestream2_get_bytes_left(&s->gb)/8 < nb_blocks) return AVERROR_INVALIDDATA; if (!s->is_tile && bytestream2_peek_le64(&s->gb) == 0) { av_log(s->avctx, AV_LOG_DEBUG, ""recreating invalid scanline offset table\n""); start_offset_table = bytestream2_tell(&s->gb); start_next_scanline = start_offset_table + nb_blocks * 8; bytestream2_init_writer(&offset_table_writer, &avpkt->data[start_offset_table], nb_blocks * 8); for (y = 0; y < nb_blocks; y++) { bytestream2_put_le64(&offset_table_writer, start_next_scanline); bytestream2_seek(&s->gb, start_next_scanline + 4, SEEK_SET); start_next_scanline += (bytestream2_get_le32(&s->gb) + 8); } bytestream2_seek(&s->gb, start_offset_table, SEEK_SET); } s->buf      = avpkt->data; s->buf_size = avpkt->size; for (i = 0; i < planes; i++) { ptr = picture->data[i]; for (y = 0; y < s->ymin; y++) { memset(ptr, 0, out_line_size); ptr += picture->linesize[i]; } } s->picture = picture; avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks); ymax = FFMAX(0, s->ymax + 1); for (i = 0; i < planes; i++) { ptr = picture->data[i] + (ymax * picture->linesize[i]); for (y = ymax; y < avctx->height; y++) { memset(ptr, 0, out_line_size); ptr += picture->linesize[i]; } } picture->pict_type = AV_PICTURE_TYPE_I; *got_frame = 1; return avpkt->size; }"
"static Image *ReadSGIImage(const ImageInfo *image_info,ExceptionInfo *exception) { Image *image; MagickBooleanType status; MagickSizeType number_pixels; MemoryInfo *pixel_info; register Quantum *q; register ssize_t i, x; register unsigned char *p; SGIInfo iris_info; size_t bytes_per_pixel, quantum; ssize_t count, y, z; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } iris_info.magic=ReadBlobMSBShort(image); do { if (iris_info.magic != 0x01DA) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.storage=(unsigned char) ReadBlobByte(image); switch (iris_info.storage) { case 0x00: image->compression=NoCompression; break; case 0x01: image->compression=RLECompression; break; default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } iris_info.bytes_per_pixel=(unsigned char) ReadBlobByte(image); if ((iris_info.bytes_per_pixel == 0) || (iris_info.bytes_per_pixel > 2)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.dimension=ReadBlobMSBShort(image); iris_info.columns=ReadBlobMSBShort(image); iris_info.rows=ReadBlobMSBShort(image); iris_info.depth=ReadBlobMSBShort(image); if ((iris_info.depth == 0) || (iris_info.depth > 4)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.minimum_value=ReadBlobMSBLong(image); iris_info.maximum_value=ReadBlobMSBLong(image); iris_info.sans=ReadBlobMSBLong(image); count=ReadBlob(image,sizeof(iris_info.name),(unsigned char *) iris_info.name); if ((size_t) count != sizeof(iris_info.name)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); iris_info.name[sizeof(iris_info.name)-1]='\0'; if (*iris_info.name != '\0') (void) SetImageProperty(image,""label"",iris_info.name,exception); iris_info.pixel_format=ReadBlobMSBLong(image); if (iris_info.pixel_format != 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); count=ReadBlob(image,sizeof(iris_info.filler),iris_info.filler); if ((size_t) count != sizeof(iris_info.filler)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); image->columns=iris_info.columns; image->rows=iris_info.rows; image->depth=(size_t) MagickMin(iris_info.depth,MAGICKCORE_QUANTUM_DEPTH); if (iris_info.pixel_format == 0) image->depth=(size_t) MagickMin((size_t) 8*iris_info.bytes_per_pixel, MAGICKCORE_QUANTUM_DEPTH); if (iris_info.depth < 3) { image->storage_class=PseudoClass; image->colors=(size_t) (iris_info.bytes_per_pixel > 1 ? 65535 : 256); } if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); bytes_per_pixel=(size_t) iris_info.bytes_per_pixel; number_pixels=(MagickSizeType) iris_info.columns*iris_info.rows; if ((4*bytes_per_pixel*number_pixels) != ((MagickSizeType) (size_t) (4*bytes_per_pixel*number_pixels))) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); pixel_info=AcquireVirtualMemory(iris_info.columns,iris_info.rows*4* bytes_per_pixel*sizeof(*pixels)); if (pixel_info == (MemoryInfo *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info); if ((int) iris_info.storage != 0x01) { unsigned char *scanline; scanline=(unsigned char *) AcquireQuantumMemory(iris_info.columns, bytes_per_pixel*sizeof(*scanline)); if (scanline == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (z=0; z < (ssize_t) iris_info.depth; z++) { p=pixels+bytes_per_pixel*z; for (y=0; y < (ssize_t) iris_info.rows; y++) { count=ReadBlob(image,bytes_per_pixel*iris_info.columns,scanline); if (EOFBlob(image) != MagickFalse) break; if (bytes_per_pixel == 2) for (x=0; x < (ssize_t) iris_info.columns; x++) { *p=scanline[2*x]; *(p+1)=scanline[2*x+1]; p+=8; } else for (x=0; x < (ssize_t) iris_info.columns; x++) { *p=scanline[x]; p+=4; } } } scanline=(unsigned char *) RelinquishMagickMemory(scanline); } else { MemoryInfo *packet_info; size_t *runlength; ssize_t offset, *offsets; unsigned char *packets; unsigned int data_order; offsets=(ssize_t *) AcquireQuantumMemory((size_t) iris_info.rows, iris_info.depth*sizeof(*offsets)); runlength=(size_t *) AcquireQuantumMemory(iris_info.rows, iris_info.depth*sizeof(*runlength)); packet_info=AcquireVirtualMemory((size_t) iris_info.columns+10UL,4UL* sizeof(*packets)); if ((offsets == (ssize_t *) NULL) || (runlength == (size_t *) NULL) || (packet_info == (MemoryInfo *) NULL)) { if (offsets == (ssize_t *) NULL) offsets=(ssize_t *) RelinquishMagickMemory(offsets); if (runlength == (size_t *) NULL) runlength=(size_t *) RelinquishMagickMemory(runlength); if (packet_info == (MemoryInfo *) NULL) packet_info=RelinquishVirtualMemory(packet_info); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } packets=(unsigned char *) GetVirtualMemoryBlob(packet_info); for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++) offsets[i]=(ssize_t) ReadBlobMSBSignedLong(image); for (i=0; i < (ssize_t) (iris_info.rows*iris_info.depth); i++) { runlength[i]=ReadBlobMSBLong(image); if (runlength[i] > (4*(size_t) iris_info.columns+10)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } offset=0; data_order=0; for (y=0; ((y < (ssize_t) iris_info.rows) && (data_order == 0)); y++) for (z=0; ((z < (ssize_t) iris_info.depth) && (data_order == 0)); z++) { if (offsets[y+z*iris_info.rows] < offset) data_order=1; offset=offsets[y+z*iris_info.rows]; } offset=(ssize_t) TellBlob(image); if (data_order == 1) { for (z=0; z < (ssize_t) iris_info.depth; z++) { p=pixels; for (y=0; y < (ssize_t) iris_info.rows; y++) { if (offset != offsets[y+z*iris_info.rows]) { offset=offsets[y+z*iris_info.rows]; offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset, SEEK_SET); } count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows], packets); if (EOFBlob(image) != MagickFalse) break; offset+=(ssize_t) runlength[y+z*iris_info.rows]; status=SGIDecode(bytes_per_pixel,(ssize_t) (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets, (ssize_t) iris_info.columns,p+bytes_per_pixel*z); if (status == MagickFalse) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); p+=(iris_info.columns*4*bytes_per_pixel); } } } else { MagickOffsetType position; position=TellBlob(image); p=pixels; for (y=0; y < (ssize_t) iris_info.rows; y++) { for (z=0; z < (ssize_t) iris_info.depth; z++) { if (offset != offsets[y+z*iris_info.rows]) { offset=offsets[y+z*iris_info.rows]; offset=(ssize_t) SeekBlob(image,(MagickOffsetType) offset, SEEK_SET); } count=ReadBlob(image,(size_t) runlength[y+z*iris_info.rows], packets); if (EOFBlob(image) != MagickFalse) break; offset+=(ssize_t) runlength[y+z*iris_info.rows]; status=SGIDecode(bytes_per_pixel,(ssize_t) (runlength[y+z*iris_info.rows]/bytes_per_pixel),packets, (ssize_t) iris_info.columns,p+bytes_per_pixel*z); if (status == MagickFalse) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } p+=(iris_info.columns*4*bytes_per_pixel); } offset=(ssize_t) SeekBlob(image,position,SEEK_SET); } packet_info=RelinquishVirtualMemory(packet_info); runlength=(size_t *) RelinquishMagickMemory(runlength); offsets=(ssize_t *) RelinquishMagickMemory(offsets); } image->alpha_trait=iris_info.depth == 4 ? BlendPixelTrait : UndefinedPixelTrait; image->columns=iris_info.columns; image->rows=iris_info.rows; if (image->storage_class == DirectClass) { if (bytes_per_pixel == 2) { for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*8*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleShortToQuantum((unsigned short) ((*(p+0) << 8) | (*(p+1)))),q); SetPixelGreen(image,ScaleShortToQuantum((unsigned short) ((*(p+2) << 8) | (*(p+3)))),q); SetPixelBlue(image,ScaleShortToQuantum((unsigned short) ((*(p+4) << 8) | (*(p+5)))),q); SetPixelAlpha(image,OpaqueAlpha,q); if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleShortToQuantum((unsigned short) ((*(p+6) << 8) | (*(p+7)))),q); p+=8; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows); if (status == MagickFalse) break; } } } else for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*4*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(image,ScaleCharToQuantum(*p),q); SetPixelGreen(image,ScaleCharToQuantum(*(p+1)),q); SetPixelBlue(image,ScaleCharToQuantum(*(p+2)),q); SetPixelAlpha(image,OpaqueAlpha,q); if (image->alpha_trait != UndefinedPixelTrait) SetPixelAlpha(image,ScaleCharToQuantum(*(p+3)),q); p+=4; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } } else { if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); if (bytes_per_pixel == 2) { for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*8*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { quantum=(*p << 8); quantum|=(*(p+1)); SetPixelIndex(image,(Quantum) quantum,q); p+=8; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,image->rows); if (status == MagickFalse) break; } } } else for (y=0; y < (ssize_t) image->rows; y++) { p=pixels+(image->rows-y-1)*4*image->columns; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelIndex(image,*p,q); p+=4; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } (void) SyncImage(image,exception); } pixel_info=RelinquishVirtualMemory(pixel_info); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; iris_info.magic=ReadBlobMSBShort(image); if (iris_info.magic == 0x01DA) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (iris_info.magic == 0x01DA); (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"IMPEG2D_ERROR_CODES_T impeg2d_init_video_state(dec_state_t *ps_dec, e_video_type_t e_video_type) { if(e_video_type == MPEG_1_VIDEO) { ps_dec->u2_is_mpeg2 = 0; ps_dec->u2_progressive_sequence         = 1; ps_dec->u2_intra_dc_precision           = 0; ps_dec->u2_picture_structure            = FRAME_PICTURE; ps_dec->u2_frame_pred_frame_dct         = 1; ps_dec->u2_concealment_motion_vectors   = 0; ps_dec->u2_q_scale_type                 = 0; ps_dec->u2_intra_vlc_format             = 0; ps_dec->u2_alternate_scan               = 0; ps_dec->u2_repeat_first_field           = 0; ps_dec->u2_progressive_frame            = 1; ps_dec->u2_frame_rate_extension_n       = 0; ps_dec->u2_frame_rate_extension_d       = 0; ps_dec->pf_vld_inv_quant                  = impeg2d_vld_inv_quant_mpeg1; } else { ps_dec->u2_is_mpeg2                  = 1; ps_dec->u2_full_pel_forw_vector   = 0; ps_dec->u2_forw_f_code            = 7; ps_dec->u2_full_pel_back_vector   = 0; ps_dec->u2_back_f_code            = 7; ps_dec->pf_vld_inv_quant       = impeg2d_vld_inv_quant_mpeg2; } impeg2d_init_function_ptr(ps_dec); ps_dec->u2_frame_height        = ALIGN16(ps_dec->u2_vertical_size); ps_dec->u2_frame_width         = ALIGN16(ps_dec->u2_horizontal_size); ps_dec->u2_num_horiz_mb         = (ps_dec->u2_horizontal_size + 15) >> 4; if (ps_dec->u2_frame_height > ps_dec->u2_create_max_height || ps_dec->u2_frame_width > ps_dec->u2_create_max_width) { return IMPEG2D_PIC_SIZE_NOT_SUPPORTED; } ps_dec->u2_num_flds_decoded = 0; { UWORD32 numer; UWORD32 denom; numer = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][1] * (UWORD32)(ps_dec->u2_frame_rate_extension_d + 1); denom = (UWORD32)gau2_impeg2_frm_rate_code[ps_dec->u2_frame_rate_code][0] * (UWORD32)(ps_dec->u2_frame_rate_extension_n + 1); ps_dec->u2_framePeriod =  (numer * 1000 * 100) / denom; } if(VERTICAL_SCAN == ps_dec->u2_alternate_scan) { ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_vertical; } else { ps_dec->pu1_inv_scan_matrix = (UWORD8 *)gau1_impeg2_inv_scan_zig_zag; } return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE; }"
"Http::FilterTrailersStatus Context::onResponseTrailers() { if (!wasm_->onResponseTrailers_) { return Http::FilterTrailersStatus::Continue; } if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) { return Http::FilterTrailersStatus::Continue; } return Http::FilterTrailersStatus::StopIteration; }"
"static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags) { BOOL rc = FALSE; rdpContext* context = update->context; rdpPrimaryUpdate* primary = update->primary; ORDER_INFO* orderInfo = &(primary->order_info); rdpSettings* settings = context->settings; const char* orderName; if (flags & ORDER_TYPE_CHANGE) { if (Stream_GetRemainingLength(s) < 1) { WLog_Print(update->log, WLOG_ERROR, ""Stream_GetRemainingLength(s) < 1""); return FALSE; } Stream_Read_UINT8(s, orderInfo->orderType);  } orderName = primary_order_string(orderInfo->orderType); if (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName)) return FALSE; if (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags, PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType])) { WLog_Print(update->log, WLOG_ERROR, ""update_read_field_flags() failed""); return FALSE; } if (flags & ORDER_BOUNDS) { if (!(flags & ORDER_ZERO_BOUNDS_DELTAS)) { if (!update_read_bounds(s, &orderInfo->bounds)) { WLog_Print(update->log, WLOG_ERROR, ""update_read_bounds() failed""); return FALSE; } } rc = IFCALLRESULT(FALSE, update->SetBounds, context, &orderInfo->bounds); if (!rc) return FALSE; } orderInfo->deltaCoordinates = (flags & ORDER_DELTA_COORDINATES) ? TRUE : FALSE; if (!read_primary_order(update->log, orderName, s, orderInfo, primary)) return FALSE; switch (orderInfo->orderType) { case ORDER_TYPE_DSTBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->dstblt.bRop), gdi_rop3_code(primary->dstblt.bRop)); rc = IFCALLRESULT(FALSE, primary->DstBlt, context, &primary->dstblt); } break; case ORDER_TYPE_PATBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->patblt.bRop), gdi_rop3_code(primary->patblt.bRop)); rc = IFCALLRESULT(FALSE, primary->PatBlt, context, &primary->patblt); } break; case ORDER_TYPE_SCRBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->scrblt.bRop), gdi_rop3_code(primary->scrblt.bRop)); rc = IFCALLRESULT(FALSE, primary->ScrBlt, context, &primary->scrblt); } break; case ORDER_TYPE_OPAQUE_RECT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->OpaqueRect, context, &primary->opaque_rect); } break; case ORDER_TYPE_DRAW_NINE_GRID: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->DrawNineGrid, context, &primary->draw_nine_grid); } break; case ORDER_TYPE_MULTI_DSTBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_dstblt.bRop), gdi_rop3_code(primary->multi_dstblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiDstBlt, context, &primary->multi_dstblt); } break; case ORDER_TYPE_MULTI_PATBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_patblt.bRop), gdi_rop3_code(primary->multi_patblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiPatBlt, context, &primary->multi_patblt); } break; case ORDER_TYPE_MULTI_SCRBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->multi_scrblt.bRop), gdi_rop3_code(primary->multi_scrblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MultiScrBlt, context, &primary->multi_scrblt); } break; case ORDER_TYPE_MULTI_OPAQUE_RECT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->MultiOpaqueRect, context, &primary->multi_opaque_rect); } break; case ORDER_TYPE_MULTI_DRAW_NINE_GRID: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->MultiDrawNineGrid, context, &primary->multi_draw_nine_grid); } break; case ORDER_TYPE_LINE_TO: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->LineTo, context, &primary->line_to); } break; case ORDER_TYPE_POLYLINE: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->Polyline, context, &primary->polyline); } break; case ORDER_TYPE_MEMBLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->memblt.bRop), gdi_rop3_code(primary->memblt.bRop)); rc = IFCALLRESULT(FALSE, primary->MemBlt, context, &primary->memblt); } break; case ORDER_TYPE_MEM3BLT: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s rop=%s [0x%08"" PRIx32 ""]"", orderName, gdi_rop3_code_string(primary->mem3blt.bRop), gdi_rop3_code(primary->mem3blt.bRop)); rc = IFCALLRESULT(FALSE, primary->Mem3Blt, context, &primary->mem3blt); } break; case ORDER_TYPE_SAVE_BITMAP: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->SaveBitmap, context, &primary->save_bitmap); } break; case ORDER_TYPE_GLYPH_INDEX: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->GlyphIndex, context, &primary->glyph_index); } break; case ORDER_TYPE_FAST_INDEX: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->FastIndex, context, &primary->fast_index); } break; case ORDER_TYPE_FAST_GLYPH: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->FastGlyph, context, &primary->fast_glyph); } break; case ORDER_TYPE_POLYGON_SC: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->PolygonSC, context, &primary->polygon_sc); } break; case ORDER_TYPE_POLYGON_CB: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->PolygonCB, context, &primary->polygon_cb); } break; case ORDER_TYPE_ELLIPSE_SC: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->EllipseSC, context, &primary->ellipse_sc); } break; case ORDER_TYPE_ELLIPSE_CB: { WLog_Print(update->log, WLOG_DEBUG, ""Primary Drawing Order %s"", orderName); rc = IFCALLRESULT(FALSE, primary->EllipseCB, context, &primary->ellipse_cb); } break; default: WLog_Print(update->log, WLOG_WARN, ""Primary Drawing Order %s not supported"", orderName); break; } if (!rc) { WLog_Print(update->log, WLOG_WARN, ""Primary Drawing Order %s failed"", orderName); return FALSE; } if (flags & ORDER_BOUNDS) { rc = IFCALLRESULT(FALSE, update->SetBounds, context, NULL); } return rc; }"
static void uv__rwlock_fallback_rdlock(uv_rwlock_t* rwlock) { uv_mutex_lock(&rwlock->fallback_.read_mutex_); if (++rwlock->fallback_.num_readers_ == 1) uv_mutex_lock(&rwlock->fallback_.write_mutex_); uv_mutex_unlock(&rwlock->fallback_.read_mutex_); }
"static size_t getBlockHistogramSize(Size block_size, Size cell_size, int nbins) { Size cells_per_block = Size(block_size.width / cell_size.width, block_size.height / cell_size.height); return (size_t)(nbins * cells_per_block.area()); }"
"bool PackLinuxElf32::canPack() { union { unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512) fi->seek(0, SEEK_SET); fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI]; Elf32_Phdr const *phdr = phdri; note_size = 0; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); unsigned const p_offset = get_te32(&phdr->p_offset); if (1!=exetype && PT_LOAD32 == p_type) {             exetype = 1; load_va = get_te32(&phdr->p_vaddr);   unsigned const off = ~page_mask & (unsigned)load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz)); } if (PT_NOTE32 == p_type) { unsigned const x = get_te32(&phdr->p_memsz); if ( sizeof(elfout.notes) < x              ||  (sizeof(elfout.notes) < (note_size += x)) ) { throwCantPack(""PT_NOTEs too big; try '--force-execve'""); return false; } if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) {                 struct { struct Elf32_Nhdr nhdr; char name[8]; unsigned body; } note; memset(&note, 0, sizeof(note)); fi->seek(p_offset, SEEK_SET); fi->readx(&note, sizeof(note)); fi->seek(0, SEEK_SET); if (4==get_te32(&note.nhdr.descsz) &&  1==get_te32(&note.nhdr.type) &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz) &&  0==strcmp(osabi_note, (char const *)&note.name[0]) ) { osabi0 = ei_osabi;                  } } } } if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0 ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) {         unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags); if (Elf32_Ehdr::EM_ARM==e_machine &&   (EF_ARM_EABI_VER5==arm_eabi ||  EF_ARM_EABI_VER4==arm_eabi ) ) { ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX; } else { osabi0 = opt->o_unix.osabi0;          } } if (osabi0!=ei_osabi) { return false; } if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr)); phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; unsigned const sh_offset = get_te32(&sec_strndx->sh_offset); if ((u32_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#x"", sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM); if (sec_dynsym) { unsigned const sh_link = get_te32(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#x"", sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf32_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD32==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB); dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL), (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ)) ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if ( elf_find_dynamic(upx_dt_init)) { if (this->e_machine!=Elf32_Ehdr::EM_386 &&  this->e_machine!=Elf32_Ehdr::EM_MIPS &&  this->e_machine!=Elf32_Ehdr::EM_ARM) goto abandon;              if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1))) { if (Elf32_Ehdr::EM_ARM == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf32_Shdr const *shdr = shdri; xct_va = ~0u; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te32(&shdr->sh_addr)); } if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te32(&shdr->sh_offset); if ((u32_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf32_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf32_Dyn::DT_REL]; int z_rsz = dt_table[Elf32_Dyn::DT_RELSZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te32(&dynseg[-1+ z_rel].d_val); Elf32_Rel *rp = (Elf32_Rel *)&file_image[rel_off]; unsigned relsz   = get_te32(&dynseg[-1+ z_rsz].d_val); Elf32_Rel *last = (Elf32_Rel *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te32(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te32(&rp->r_info); unsigned r_type = ELF32_R_TYPE(r_info); if (Elf32_Ehdr::EM_ARM == e_machine &&  R_ARM_RELATIVE == r_type) { user_init_va = get_te32(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te32(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf32_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn); Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)]; for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te32(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te32(&dynp->d_val);                              set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ); unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB); unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ); unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL); unsigned const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH); unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { unsigned const vaddr = get_te32(&phdr->p_vaddr); if (PT_NOTE32 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#x above stub"", vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"ID3::ID3(const uint8_t *data, size_t size, bool ignoreV1) : mIsValid(false), mData(NULL), mSize(0), mFirstFrameOffset(0), mVersion(ID3_UNKNOWN), mRawSize(0) { sp<MemorySource> source = new MemorySource(data, size); mIsValid = parseV2(source, 0); if (!mIsValid && !ignoreV1) { mIsValid = parseV1(source); } }"
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = nullptr; shstrtab = nullptr; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= (sizeof("".shstrtab"") + sh_name + (shstrtab - (const char *)&file_image[0])) || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrtab""); } } } Elf64_Phdr const *pload_x0(nullptr);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg, get_te64(&phdr->p_filesz)); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { upx_uint64_t sh_offset = get_te64(&shdr->sh_offset); upx_uint64_t sh_size = get_te64(&shdr->sh_size); if ((upx_uint64_t)file_size < sh_size ||  (upx_uint64_t)file_size < sh_offset || ((upx_uint64_t)file_size - sh_offset) < sh_size) { throwCantPack(""bad SHT_DYNAMIC""); } unsigned const n = sh_size / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[sh_offset]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else { throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); } abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"static int svm_cpu_init(int cpu) { struct svm_cpu_data *sd; int r; sd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL); if (!sd) return -ENOMEM; sd->cpu = cpu; r = -ENOMEM; sd->save_area = alloc_page(GFP_KERNEL); if (!sd->save_area) goto err_1; if (svm_sev_enabled()) { r = -ENOMEM; sd->sev_vmcbs = kmalloc_array(max_sev_asid + 1, sizeof(void *), GFP_KERNEL); if (!sd->sev_vmcbs) goto err_1; } per_cpu(svm_data, cpu) = sd; return 0; err_1: kfree(sd); return r; }"
"__poll_t psi_trigger_poll(void **trigger_ptr, struct file *file, poll_table *wait) { __poll_t ret = DEFAULT_POLLMASK; struct psi_trigger *t; if (static_branch_likely(&psi_disabled)) return DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI; rcu_read_lock(); t = rcu_dereference(*(void __rcu __force **)trigger_ptr); if (!t) { rcu_read_unlock(); return DEFAULT_POLLMASK | EPOLLERR | EPOLLPRI; } kref_get(&t->refcount); rcu_read_unlock(); poll_wait(file, &t->event_wait, wait); if (cmpxchg(&t->event, 1, 0) == 1) ret |= EPOLLPRI; kref_put(&t->refcount, psi_trigger_destroy); return ret; }"
"BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx) { int bitmap_caret = 0; oTga *tga = NULL; volatile gdImagePtr image = NULL; int x = 0; int y = 0; tga = (oTga *) gdMalloc(sizeof(oTga)); if (!tga) { return NULL; } tga->bitmap = NULL; tga->ident = NULL; if (read_header_tga(ctx, tga) < 0) { free_tga(tga); return NULL; } if (read_image_tga(ctx, tga) < 0) { free_tga(tga); return NULL; } image = gdImageCreateTrueColor((int)tga->width, (int)tga->height ); if (image == 0) { free_tga( tga ); return NULL; } if (tga->alphabits) { gdImageAlphaBlending(image, 0); gdImageSaveAlpha(image, 1); } for (y = 0; y < tga->height; y++) { register int *tpix = image->tpixels[y]; for ( x = 0; x < tga->width; x++, tpix++) { if (tga->bits == TGA_BPP_24) { *tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]); bitmap_caret += 3; } else if (tga->bits == TGA_BPP_32 || tga->alphabits) { register int a = tga->bitmap[bitmap_caret + 3]; *tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1)); bitmap_caret += 4; } } } if (tga->flipv && tga->fliph) { gdImageFlipBoth(image); } else if (tga->flipv) { gdImageFlipVertical(image); } else if (tga->fliph) { gdImageFlipHorizontal(image); } free_tga(tga); return image; }"
"static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len) { char *p = buf; char *end = buf+len; unsigned i; int printed; if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) { return -1; } *p++ = 'm';     *p++ = '='; pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen); p += m->desc.media.slen; *p++ = ' '; printed = pj_utoa(m->desc.port, p); p += printed; if (m->desc.port_count > 1) { *p++ = '/'; printed = pj_utoa(m->desc.port_count, p); p += printed; } *p++ = ' '; pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen); p += m->desc.transport.slen; for (i=0; i<m->desc.fmt_count; ++i) { *p++ = ' '; pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen); p += m->desc.fmt[i].slen; } *p++ = '\r'; *p++ = '\n'; if (m->conn) { printed = print_connection_info(m->conn, p, (int)(end-p)); if (printed < 0) { return -1; } p += printed; } for (i=0; i<m->bandw_count; ++i) { printed = (int)print_bandw(m->bandw[i], p, end-p); if (printed < 0) { return -1; } p += printed; } for (i=0; i<m->attr_count; ++i) { printed = (int)print_attr(m->attr[i], p, end-p); if (printed < 0) { return -1; } p += printed; } return (int)(p-buf); }"
void stbl_del(GF_Box *s) { GF_SampleTableBox *ptr = (GF_SampleTableBox *)s; if (ptr == NULL) return; if (ptr->ChunkOffset) gf_isom_box_del(ptr->ChunkOffset); if (ptr->CompositionOffset) gf_isom_box_del((GF_Box *) ptr->CompositionOffset); if (ptr->CompositionToDecode) gf_isom_box_del((GF_Box *) ptr->CompositionToDecode); if (ptr->DegradationPriority) gf_isom_box_del((GF_Box *) ptr->DegradationPriority); if (ptr->SampleDescription) gf_isom_box_del((GF_Box *) ptr->SampleDescription); if (ptr->SampleSize) gf_isom_box_del((GF_Box *) ptr->SampleSize); if (ptr->SampleToChunk) gf_isom_box_del((GF_Box *) ptr->SampleToChunk); if (ptr->ShadowSync) gf_isom_box_del((GF_Box *) ptr->ShadowSync); if (ptr->SyncSample) gf_isom_box_del((GF_Box *) ptr->SyncSample); if (ptr->TimeToSample) gf_isom_box_del((GF_Box *) ptr->TimeToSample); if (ptr->SampleDep) gf_isom_box_del((GF_Box *) ptr->SampleDep); if (ptr->PaddingBits) gf_isom_box_del((GF_Box *) ptr->PaddingBits); if (ptr->sub_samples) gf_isom_box_array_del(ptr->sub_samples); if (ptr->sampleGroups) gf_isom_box_array_del(ptr->sampleGroups); if (ptr->sampleGroupsDescription) gf_isom_box_array_del(ptr->sampleGroupsDescription); if (ptr->sai_sizes) gf_isom_box_array_del(ptr->sai_sizes); if (ptr->sai_offsets) gf_isom_box_array_del(ptr->sai_offsets); if (ptr->traf_map) { if (ptr->traf_map->sample_num) gf_free(ptr->traf_map->sample_num); gf_free(ptr->traf_map); } gf_free(ptr); }
"TfLiteStatus Prepare(KernelType kernel_type, TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); bool has_bias = node->inputs->size == 3; TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2); TF_LITE_ENSURE_EQ(context, node->outputs->size, 1); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output)); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input)); const TfLiteTensor* filter; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter)); TF_LITE_ENSURE_EQ(context, input->dims->size, 4); TF_LITE_ENSURE_EQ(context, filter->dims->size, 4); auto input_channel = input->dims->data[3]; auto filter_input_channel = filter->dims->data[3]; TF_LITE_ENSURE_EQ(context, input_channel % filter_input_channel, 0); data->groups = input_channel / filter_input_channel; TfLiteType input_type = input->type; TF_LITE_ENSURE(context, input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt16); TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type); if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0); TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0); } if (input_type == kTfLiteInt16 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); for (int i = 0; i < affine_quantization->zero_point->size; ++i) { TF_LITE_ENSURE_EQ(context, affine_quantization->zero_point->data[i], 0); } } const TfLiteTensor* bias = nullptr; TF_LITE_ENSURE(context, has_bias); if (has_bias) { TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &bias)); if (input_type == kTfLiteUInt8 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else if (input_type == kTfLiteInt16) { TF_LITE_ENSURE(context, (bias->type == kTfLiteInt32) || (bias->type == kTfLiteInt64)); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, input_type); } TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0)); } const bool is_hybrid = (input->type == kTfLiteFloat32 && (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)); if (is_hybrid && filter->type == kTfLiteInt8 && filter->quantization.type == kTfLiteAffineQuantization && filter->quantization.params && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale->size > 1) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); const float scale = affine_quantization->scale->data[0]; for (int i = 1; i < affine_quantization->scale->size; i++) { if (affine_quantization->scale->data[i] != scale) { data->is_hybrid_per_channel = true; break; } } } data->supports_multithreaded_kernel = (kernel_type == kMultithreadOptimized) && (context->recommended_num_threads != 1) && !is_hybrid && (params->dilation_width_factor == 1) && (params->dilation_height_factor == 1) && (filter->allocation_type != kTfLiteArenaRw) && !IsDynamicTensor(filter); int channels_in = filter->dims->data[3]; int channels_out = filter->dims->data[0]; int width = input->dims->data[2]; int height = input->dims->data[1]; int filter_width = filter->dims->data[2]; int filter_height = filter->dims->data[1]; int batches = input->dims->data[0]; auto padding = params->padding; int out_width, out_height; data->padding = ComputePaddingHeightWidth( params->stride_height, params->stride_width, params->dilation_height_factor, params->dilation_width_factor, height, width, filter_height, filter_width, padding, &out_height, &out_width); size_t im2col_type_size; TF_LITE_ENSURE_STATUS(GetSizeOfType(context, input->type, &im2col_type_size)); const size_t im2col_bytes = static_cast<size_t>(batches) * out_height * out_width * channels_in * filter_height * filter_width * im2col_type_size; TF_LITE_ENSURE_STATUS(AllocateTemporaryTensorsIfRequired( context, node, is_hybrid, data->is_hybrid_per_channel, kernel_type, im2col_bytes)); TF_LITE_ENSURE(context, has_bias); if (input_type != kTfLiteFloat32) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 || affine_quantization->scale->size == channels_out)); data->per_channel_output_multiplier.resize(channels_out); data->per_channel_output_shift.resize(channels_out); TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams( context, input, filter, bias, output, params->activation, &data->output_multiplier, &data->output_shift, &data->output_activation_min, &data->output_activation_max, data->per_channel_output_multiplier.data(), data->per_channel_output_shift.data(), channels_out)); } TfLiteIntArray* output_size = TfLiteIntArrayCreate(4); output_size->data[0] = batches; output_size->data[1] = out_height; output_size->data[2] = out_width; output_size->data[3] = channels_out; auto output_status = context->ResizeTensor(context, output, output_size); if (output_status != kTfLiteOk) return output_status; if (data->need_im2col) { node->temporaries->data[data->im2col_index] = data->im2col_id; TfLiteIntArray* im2col_size = TfLiteIntArrayCreate(4); auto filter_input_channel = filter->dims->data[3]; im2col_size->data[0] = output_size->data[0]; im2col_size->data[1] = output_size->data[1]; im2col_size->data[2] = output_size->data[2]; im2col_size->data[3] = filter_input_channel * filter_height * filter_width; TfLiteTensor* im2col = &context->tensors[node->temporaries->data[data->im2col_index]]; im2col->type = input->type; if (is_hybrid) { im2col->type = filter->type; } im2col->allocation_type = kTfLiteArenaRw; auto im2col_status = context->ResizeTensor(context, im2col, im2col_size); if (im2col_status != kTfLiteOk) return im2col_status; } if (data->need_hwcn_weights) { node->temporaries->data[data->hwcn_weights_index] = data->hwcn_weights_id; TfLiteIntArray* hwcn_weights_size = TfLiteIntArrayCreate(2); auto filter_input_channel = filter->dims->data[3]; hwcn_weights_size->data[0] = (filter_height * filter_width * filter_input_channel); hwcn_weights_size->data[1] = channels_out; TfLiteTensor* hwcn_weights = &context->tensors[node->temporaries->data[data->hwcn_weights_index]]; hwcn_weights->type = input_type; hwcn_weights->name = ""Conv_hwcn_weights""; hwcn_weights->allocation_type = kTfLiteArenaRwPersistent; auto hwcn_weights_status = context->ResizeTensor(context, hwcn_weights, hwcn_weights_size); if (hwcn_weights_status != kTfLiteOk) return hwcn_weights_status; data->have_weights_been_transposed = false; } if (is_hybrid) { node->temporaries->data[data->input_quantized_index] = data->input_quantized_id; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); input_quantized->type = kTfLiteInt8; input_quantized->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) { TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized, input_quantized_size)); } node->temporaries->data[data->scaling_factors_index] = data->scaling_factors_id; TfLiteTensor* scaling_factors; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors)); scaling_factors->type = kTfLiteFloat32; scaling_factors->allocation_type = kTfLiteArenaRw; TF_LITE_ENSURE(context, channels_in != 0); const int height = NumElements(input) / channels_in; int scaling_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) { TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1); scaling_factors_size->data[0] = height; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors, scaling_factors_size)); } node->temporaries->data[data->accum_scratch_index] = data->accum_scratch_id; TfLiteTensor* accum_scratch; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->accum_scratch_index, &accum_scratch)); accum_scratch->type = kTfLiteInt32; accum_scratch->allocation_type = kTfLiteArenaRw; const int scratch_width = batches * out_height * out_width; int accum_scratch_dims[2] = {channels_out, scratch_width}; if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2, accum_scratch_dims)) { TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2); accum_scratch_size->data[0] = channels_out; accum_scratch_size->data[1] = scratch_width; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch, accum_scratch_size)); } if (data->is_hybrid_per_channel) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE_EQ( context, affine_quantization->scale->size, filter->dims->data[affine_quantization->quantized_dimension]); node->temporaries->data[data->input_offset_index] = data->input_offset_id; TfLiteTensor* input_offsets; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_offset_index, &input_offsets)); input_offsets->type = kTfLiteInt32; input_offsets->allocation_type = kTfLiteArenaRw; TF_LITE_ENSURE(context, channels_in != 0); const int height = NumElements(input) / channels_in; const int input_offset_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, input_offset_dims)) { TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1); input_offsets_size->data[0] = input_offset_dims[0]; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets, input_offsets_size)); } node->temporaries->data[data->row_sums_index] = data->row_sums_id; TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); row_sums->type = kTfLiteInt32; row_sums->name = ""Conv_row_sums""; row_sums->allocation_type = kTfLiteArenaRwPersistent; const int row_sums_dims[1] = {channels_out}; if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) { TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1); row_sums_size->data[0] = row_sums_dims[0]; TF_LITE_ENSURE_OK( context, context->ResizeTensor(context, row_sums, row_sums_size)); } } } return kTfLiteOk; }"
bool gravity_iscore_class (gravity_class_t *c) { return ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) || (c == gravity_class_null) || (c == gravity_class_int) || (c == gravity_class_float) || (c == gravity_class_function) || (c == gravity_class_fiber) || (c == gravity_class_string) || (c == gravity_class_instance) || (c == gravity_class_list) || (c == gravity_class_map) || (c == gravity_class_range) || (c == gravity_class_system) || (c == gravity_class_closure) || (c == gravity_class_upvalue)); }
"static UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman, int transferDir) { UINT32 EndpointAddress, PipeHandle; UINT32 TransferFlags, OutputBufferSize; const BOOL noAck = (RequestField & 0x80000000U) != 0; const UINT32 RequestId = RequestField & 0x7FFFFFFF; if (!pdev || !callback || !s || !udevman) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 12) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, PipeHandle); Stream_Read_UINT32(s, TransferFlags);  Stream_Read_UINT32(s, OutputBufferSize); EndpointAddress = (PipeHandle & 0x000000ff); return pdev->bulk_or_interrupt_transfer( pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck, OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL, urb_bulk_transfer_cb, 10000); }"
"static uint8_t *extend_raw_data(LHAFileHeader **header, LHAInputStream *stream, size_t nbytes) { LHAFileHeader *new_header; size_t new_raw_len; uint8_t *result; new_raw_len = RAW_DATA_LEN(header) + nbytes; new_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len); if (new_header == NULL) { return NULL; } *header = new_header; new_header->raw_data = (uint8_t *) (new_header + 1); result = new_header->raw_data + new_header->raw_data_len; if (!lha_input_stream_read(stream, result, nbytes)) { return NULL; } new_header->raw_data_len = new_raw_len; return result; }"
"int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy) { char cmd[512]; char *inputline = NULL; char *proxy_auth = NULL; char debug_buff[512]; int remaining = sizeof(cmd) - 1; remaining -= snprintf(cmd, sizeof(cmd), ""CONNECT %s:%d HTTP/1.1\r\n"", host, port); if (proxy->username && proxy->username[0]) { proxy_auth = encode_proxy_auth_str(proxy); strncat(cmd, ""Proxy-Authorization: Basic "", remaining); remaining -= 27; strncat(cmd, proxy_auth, remaining); remaining -= strlen(proxy_auth); strncat(cmd, ""\r\n"", remaining); remaining -= 2; } strncat(cmd, ""\r\n"", remaining); #ifndef DEBUG snprintf(debug_buff, sizeof(debug_buff), ""<%s>\n"", cmd); debug_print(debug_buff); #endif if (send(sockfd, cmd, strlen(cmd), 0) < 0) return AY_CONNECTION_REFUSED; if (ay_recv_line(sockfd, &inputline) < 0) return AY_CONNECTION_REFUSED; #ifndef DEBUG snprintf(debug_buff, sizeof(debug_buff), ""<%s>\n"", inputline); debug_print(debug_buff); #endif if (!strstr(inputline, ""200"")) { if (strstr(inputline, ""407"")) { while (ay_recv_line(sockfd, &inputline) > 0) { free(inputline); } return AY_PROXY_AUTH_REQUIRED; } if (strstr(inputline, ""403"")) { while (ay_recv_line(sockfd, &inputline) > 0) { free(inputline); } return AY_PROXY_PERMISSION_DENIED; } free(inputline); return AY_CONNECTION_REFUSED; } while (strlen(inputline) > 1) { free(inputline); if (ay_recv_line(sockfd, &inputline) < 0) { return AY_CONNECTION_REFUSED; } #ifndef DEBUG snprintf(debug_buff, sizeof(debug_buff), ""<%s>\n"", inputline); debug_print(debug_buff); #endif } free(inputline); g_free(proxy_auth); return 0; }"
"static gchar* get_usage_page_item_string(wmem_allocator_t *pool, guint32 usage_page, guint32 id) { const char *str = NULL; switch (usage_page) { case GENERIC_DESKTOP_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_generic_desktop_controls_usage_page_vals); break; case SIMULATION_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_simulation_control_usage_page_vals); break; case VR_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_vr_controls_usage_page_vals); break; case SPORT_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_sport_controls_usage_page_vals); break; case GAME_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_game_controls_usage_page_vals); break; case GENERIC_DEVICE_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_generic_device_controls_usage_page_vals); break; case KEYBOARD_KEYPAD_PAGE: str = try_val_to_str(id, usb_hid_keyboard_keypad_usage_page_vals); break; case LED_PAGE: str = try_val_to_str(id, usb_hid_led_usage_page_vals); break; case BUTTON_PAGE: str = try_val_to_str(id, usb_hid_button_usage_page_vals); if (!str) str = ""Button %u""; break; case ORDINAL_PAGE: str = try_val_to_str(id, usb_hid_ordinal_usage_page_vals); break; case TELEPHONY_PAGE: str = try_val_to_str(id, usb_hid_telephony_device_usage_page_vals); break; case CONSUMER_PAGE: str = try_val_to_str(id, usb_hid_consumer_usage_page_vals); if (!str) str = ""Instance %u""; break; case DIGITIZER_PAGE: str = try_val_to_str(id, usb_hid_digitizers_usage_page_vals); break; case HAPTICS_PAGE: str = try_val_to_str(id, usb_hid_haptic_usage_page_vals); if (id >= 0x2001 && id <= 0x2FFF) str = ""Vendor Waveforms""; break; case PID_PAGE: str = try_val_to_str(id, usb_hid_physical_input_device_usage_page_vals); break; case UNICODE_PAGE: str = ""Character U+%04X""; break; case EYE_AND_HEAD_TRACKER_PAGE: str = try_val_to_str(id, usb_hid_eye_and_head_tracker_usage_page_vals); break; case ALPHANUMERIC_DISPLAY_PAGE: str = try_val_to_str(id, usb_hid_alphanumeric_display_usage_page_vals); break; case SENSOR_PAGE: str = try_val_to_str(id, usb_hid_sensor_usage_page_vals); if (!str) str = try_rval_to_str(id, usb_hid_sensor_usage_page_ranges); break; case MEDICAL_INSTRUMENTS_PAGE: str = try_val_to_str(id, usb_hid_medical_instrument_usage_page_vals); break; case BRAILLE_DISPLAY_PAGE: str = try_val_to_str(id, usb_hid_braille_dispaly_usage_page_vals); break; case LIGHTING_AND_ILLUMINATION_PAGE: str = try_val_to_str(id, usb_hid_lighting_and_illumination_usage_page_vals); break; case USB_MONITOR_PAGE: str = try_val_to_str(id, usb_hid_monitor_usage_page_vals); break; case USB_ENUMERATED_VALUES_PAGE: str = ""ENUM_%u""; break; case VESA_VIRTUAL_CONTROLS_PAGE: str = try_val_to_str(id, usb_hid_vesa_virtual_control_usage_page_vals); break; case POWER_DEVICE_PAGE: str = try_val_to_str(id, usb_hid_power_device_usage_page_vals); break; case BATTERY_SYSTEM_PAGE: str = try_val_to_str(id, usb_hid_battery_system_usage_page_vals); break; case BARCODE_SCANNER_PAGE: str = try_val_to_str(id, usb_hid_barcode_scanner_usage_page_vals); break; case WEIGHING_PAGE: str = try_val_to_str(id, usb_hid_weighing_devices_usage_page_vals); break; case MSR_PAGE: str = try_val_to_str(id, usb_hid_magnetic_stripe_reader_usage_page_vals); break; case CAMERA_CONTROL_PAGE: str = try_val_to_str(id, usb_hid_camera_control_usage_page_vals); break; case ARCADE_PAGE: str = try_val_to_str(id, usb_hid_arcade_usage_page_vals); break; case FIDO_ALLIANCE_PAGE: str = try_val_to_str(id, usb_hid_fido_alliance_usage_page_vals); break; default: if ((usage_page & VENDOR_PAGE_HBYTE) == VENDOR_PAGE_HBYTE) str = ""Vendor""; break; } if (!str) str = ""Reserved""; return wmem_strdup_printf(pool, str, id); }"
"static void php_imagettftext_common(INTERNAL_FUNCTION_PARAMETERS, int mode, int extended) { zval *IM, *EXT = NULL; gdImagePtr im=NULL; long col = -1, x = -1, y = -1; int str_len, fontname_len, i, brect[8]; double ptsize, angle; char *str = NULL, *fontname = NULL; char *error = NULL; int argc = ZEND_NUM_ARGS(); gdFTStringExtra strex = {0}; if (mode == TTFTEXT_BBOX) { if (argc < 4 || argc > ((extended) ? 5 : 4)) { ZEND_WRONG_PARAM_COUNT(); } else if (zend_parse_parameters(argc TSRMLS_CC, ""ddss|a"", &ptsize, &angle, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) { RETURN_FALSE; } } else { if (argc < 8 || argc > ((extended) ? 9 : 8)) { ZEND_WRONG_PARAM_COUNT(); } else if (zend_parse_parameters(argc TSRMLS_CC, ""rddlllss|a"", &IM, &ptsize, &angle, &x, &y, &col, &fontname, &fontname_len, &str, &str_len, &EXT) == FAILURE) { RETURN_FALSE; } ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd); } angle = angle * (M_PI/180); if (extended && EXT) { HashPosition pos; zend_hash_internal_pointer_reset_ex(HASH_OF(EXT), &pos); do { zval ** item; char * key; ulong num_key; if (zend_hash_get_current_key_ex(HASH_OF(EXT), &key, NULL, &num_key, 0, &pos) != HASH_KEY_IS_STRING) { continue; } if (zend_hash_get_current_data_ex(HASH_OF(EXT), (void **) &item, &pos) == FAILURE) { continue; } if (strcmp(""linespacing"", key) == 0) { convert_to_double_ex(item); strex.flags |= gdFTEX_LINESPACE; strex.linespacing = Z_DVAL_PP(item); } } while (zend_hash_move_forward_ex(HASH_OF(EXT), &pos) == SUCCESS); } #ifdef VIRTUAL_DIR { char tmp_font_path[MAXPATHLEN]; if (!VCWD_REALPATH(fontname, tmp_font_path)) { fontname = NULL; } } #endif  PHP_GD_CHECK_OPEN_BASEDIR(fontname, ""Invalid font filename""); #ifdef HAVE_GD_FREETYPE if (extended) { error = gdImageStringFTEx(im, brect, col, fontname, ptsize, angle, x, y, str, &strex); } else error = gdImageStringFT(im, brect, col, fontname, ptsize, angle, x, y, str); #endif  if (error) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""%s"", error); RETURN_FALSE; } array_init(return_value); for (i = 0; i < 8; i++) { add_next_index_long(return_value, brect[i]); } }"
"int relay_websocket_decode_frame (const unsigned char *buffer, unsigned long long buffer_length, unsigned char *decoded, unsigned long long *decoded_length) { unsigned long long i, index_buffer, length_frame_size, length_frame; unsigned char opcode; *decoded_length = 0; index_buffer = 0; while (index_buffer + 2 <= buffer_length) { opcode = buffer[index_buffer] & 15; if (!(buffer[index_buffer + 1] & 128)) return 0; length_frame_size = 1; length_frame = buffer[index_buffer + 1] & 127; index_buffer += 2; if ((length_frame == 126) || (length_frame == 127)) { length_frame_size = (length_frame == 126) ? 2 : 8; if (buffer_length < 1 + length_frame_size) return 0; length_frame = 0; for (i = 0; i < length_frame_size; i++) { length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8); } index_buffer += length_frame_size; } if (buffer_length < 1 + length_frame_size + 4 + length_frame) return 0; int masks[4]; for (i = 0; i < 4; i++) { masks[i] = (int)((unsigned char)buffer[index_buffer + i]); } index_buffer += 4; switch (opcode) { case WEBSOCKET_FRAME_OPCODE_PING: decoded[*decoded_length] = RELAY_CLIENT_MSG_PING; break; case WEBSOCKET_FRAME_OPCODE_CLOSE: decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE; break; default: decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD; break; } *decoded_length += 1; for (i = 0; i < length_frame; i++) { decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4]; } decoded[*decoded_length + length_frame] = '\0'; *decoded_length += length_frame + 1; index_buffer += length_frame; } return 1; }"
"static void on_gpac_log(void *cbk, GF_LOG_Level ll, GF_LOG_Tool lm, const char *fmt, va_list list) { FILE *logs = cbk ? cbk : stderr; if (rti_logs && (lm & GF_LOG_RTI)) { char szMsg[2048]; vsprintf(szMsg, fmt, list); UpdateRTInfo(szMsg + 6 ); } else { if (log_time_start) { u64 now = gf_sys_clock_high_res(); fprintf(logs, ""At ""LLD"" (diff %d) - "", now - log_time_start, (u32) (now - last_log_time) ); last_log_time = now; } if (log_utc_time) { u64 utc_clock = gf_net_get_utc() ; time_t secs = utc_clock/1000; struct tm t; t = *gmtime(&secs); fprintf(logs, ""UTC %d-%02d-%02dT%02d:%02d:%02dZ (TS ""LLU"") - "", 1900+t.tm_year, t.tm_mon+1, t.tm_mday, t.tm_hour, t.tm_min, t.tm_sec, utc_clock); } vfprintf(logs, fmt, list); fflush(logs); } }"
"void WasmBinaryBuilder::processFunctions() { for (auto* func : functions) { wasm.addFunction(func); } if (startIndex != static_cast<Index>(-1)) { wasm.start = getFunctionIndexName(startIndex); } for (auto* curr : exportOrder) { auto index = exportIndexes[curr]; switch (curr->kind) { case ExternalKind::Function: { curr->value = getFunctionIndexName(index); break; } case ExternalKind::Table: curr->value = Name::fromInt(0); break; case ExternalKind::Memory: curr->value = Name::fromInt(0); break; case ExternalKind::Global: curr->value = getGlobalName(index); break; default: throwError(""bad export kind""); } wasm.addExport(curr); } for (auto& iter : functionCalls) { size_t index = iter.first; auto& calls = iter.second; for (auto* call : calls) { call->target = getFunctionIndexName(index); } } for (auto& pair : functionTable) { auto i = pair.first; auto& indexes = pair.second; for (auto j : indexes) { wasm.table.segments[i].data.push_back(getFunctionIndexName(j)); } } wasm.updateMaps(); }"
"void init(int count = 0, int reserveCount = 0) { SkASSERT(count >= 0); SkASSERT(reserveCount >= 0); fCount = count; if (!count && !reserveCount) { fAllocCount = 0; fMemArray = nullptr; fOwnMemory = false; fReserved = false; } else { fAllocCount = SkTMax(count, SkTMax(kMinHeapAllocCount, reserveCount)); fMemArray = sk_malloc_throw(fAllocCount * sizeof(T)); fOwnMemory = true; fReserved = reserveCount > 0; } }"
"ut32 armass_assemble(const char *str, ut64 off, int thumb) { int i, j; char buf[128]; ArmOpcode aop = {.off = off}; for (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) { if (str[j] == '#') { i--; continue; } buf[i] = tolower ((const ut8)str[j]); } buf[i] = 0; arm_opcode_parse (&aop, buf); aop.off = off; if (thumb < 0 || thumb > 1) { return -1; } if (!assemble[thumb] (&aop, off, buf)) { return -1; } return aop.o; }"
"static int bgp_nlri_get_labels(struct peer *peer, uint8_t *pnt, uint8_t plen, mpls_label_t *label) { uint8_t *data = pnt; uint8_t *lim = pnt + plen; uint8_t llen = 0; uint8_t label_depth = 0; for (; data < lim; data += BGP_LABEL_BYTES) { memcpy(label, data, BGP_LABEL_BYTES); llen += BGP_LABEL_BYTES; bgp_set_valid_label(label); label_depth += 1; if (bgp_is_withdraw_label(label) || label_bos(label)) break; } if (label_depth > 1) zlog_info(""%pBP rcvd UPDATE with label stack %d deep"", peer, label_depth); if (!(bgp_is_withdraw_label(label) || label_bos(label))) flog_warn( EC_BGP_INVALID_LABEL_STACK, ""%pBP rcvd UPDATE with invalid label stack - no bottom of stack"", peer); return llen; }"
"static int exif_process_user_comment(image_info_type *ImageInfo, char **pszInfoPtr, char **pszEncoding, char *szValuePtr, int ByteCount TSRMLS_DC) { int   a; char  *decode; size_t len;; *pszEncoding = NULL; if (ByteCount>=8) { if (!memcmp(szValuePtr, ""UNICODE\0"", 8)) { *pszEncoding = estrdup((const char*)szValuePtr); szValuePtr = szValuePtr+8; ByteCount -= 8; if (!memcmp(szValuePtr, ""\xFE\xFF"", 2)) { decode = ""UCS-2BE""; szValuePtr = szValuePtr+2; ByteCount -= 2; } else if (!memcmp(szValuePtr, ""\xFF\xFE"", 2)) { decode = ""UCS-2LE""; szValuePtr = szValuePtr+2; ByteCount -= 2; } else if (ImageInfo->motorola_intel) { decode = ImageInfo->decode_unicode_be; } else { decode = ImageInfo->decode_unicode_le; } if (zend_multibyte_encoding_converter( (unsigned char**)pszInfoPtr, &len, (unsigned char*)szValuePtr, ByteCount, zend_multibyte_fetch_encoding(ImageInfo->encode_unicode TSRMLS_CC), zend_multibyte_fetch_encoding(decode TSRMLS_CC) TSRMLS_CC) == (size_t)-1) { len = exif_process_string_raw(pszInfoPtr, szValuePtr, ByteCount); } return len; } else if (!memcmp(szValuePtr, ""ASCII\0\0\0"", 8)) { *pszEncoding = estrdup((const char*)szValuePtr); szValuePtr = szValuePtr+8; ByteCount -= 8; } else if (!memcmp(szValuePtr, ""JIS\0\0\0\0\0"", 8)) { *pszEncoding = estrdup((const char*)szValuePtr); szValuePtr = szValuePtr+8; ByteCount -= 8; if (zend_multibyte_encoding_converter( (unsigned char**)pszInfoPtr, &len, (unsigned char*)szValuePtr, ByteCount, zend_multibyte_fetch_encoding(ImageInfo->encode_jis TSRMLS_CC), zend_multibyte_fetch_encoding(ImageInfo->motorola_intel ? ImageInfo->decode_jis_be : ImageInfo->decode_jis_le TSRMLS_CC) TSRMLS_CC) == (size_t)-1) { len = exif_process_string_raw(pszInfoPtr, szValuePtr, ByteCount); } return len; } else if (!memcmp(szValuePtr, ""\0\0\0\0\0\0\0\0"", 8)) { *pszEncoding = estrdup(""UNDEFINED""); szValuePtr = szValuePtr+8; ByteCount -= 8; } } if (ByteCount>0) { for (a=ByteCount-1;a && szValuePtr[a]==' ';a--) { (szValuePtr)[a] = '\0'; } } exif_process_string(pszInfoPtr, szValuePtr, ByteCount TSRMLS_CC); return strlen(*pszInfoPtr); }"
"bool minimask_equal(const struct minimask *a, const struct minimask *b) { return !memcmp(a, b, sizeof *a + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))); }"
"static int add_ballooned_pages(int nr_pages) { enum bp_state st; if (xen_hotplug_unpopulated) { st = reserve_additional_memory(); if (st != BP_ECANCELED) { mutex_unlock(&balloon_mutex); wait_event(balloon_wq, !list_empty(&ballooned_pages)); mutex_lock(&balloon_mutex); return 0; } } st = decrease_reservation(nr_pages, GFP_USER); if (st != BP_DONE) return -ENOMEM; return 0; }"
"static void nl_parse(int fd, struct nlconfig_t *config) { size_t len, size; struct nlmsghdr hdr; char *data, *current; len = read(fd, &hdr, NLMSG_HDRLEN); if (len != NLMSG_HDRLEN) bail(""invalid netlink header length %zu"", len); if (hdr.nlmsg_type == NLMSG_ERROR) bail(""failed to read netlink message""); if (hdr.nlmsg_type != INIT_MSG) bail(""unexpected msg type %d"", hdr.nlmsg_type); size = NLMSG_PAYLOAD(&hdr, 0); current = data = malloc(size); if (!data) bail(""failed to allocate %zu bytes of memory for nl_payload"", size); len = read(fd, data, size); if (len != size) bail(""failed to read netlink payload, %zu != %zu"", len, size); config->data = data; while (current < data + size) { struct nlattr *nlattr = (struct nlattr *)current; size_t payload_len = nlattr->nla_len - NLA_HDRLEN; current += NLA_HDRLEN; switch (nlattr->nla_type) { case CLONE_FLAGS_ATTR: config->cloneflags = readint32(current); break; case ROOTLESS_EUID_ATTR: config->is_rootless_euid = readint8(current); break; case OOM_SCORE_ADJ_ATTR: config->oom_score_adj = current; config->oom_score_adj_len = payload_len; break; case NS_PATHS_ATTR: config->namespaces = current; config->namespaces_len = payload_len; break; case UIDMAP_ATTR: config->uidmap = current; config->uidmap_len = payload_len; break; case GIDMAP_ATTR: config->gidmap = current; config->gidmap_len = payload_len; break; case UIDMAPPATH_ATTR: config->uidmappath = current; config->uidmappath_len = payload_len; break; case GIDMAPPATH_ATTR: config->gidmappath = current; config->gidmappath_len = payload_len; break; case SETGROUP_ATTR: config->is_setgroup = readint8(current); break; default: bail(""unknown netlink message type %d"", nlattr->nla_type); } current += NLA_ALIGN(payload_len); } }"
"static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg) { __u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr; struct kvm_regs *regs = vcpu_gp_regs(vcpu); int nr_regs = sizeof(*regs) / sizeof(__u32); __uint128_t tmp; void *valp = &tmp; u64 off; int err = 0; off = core_reg_offset_from_id(reg->id); if (off >= nr_regs || (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs) return -ENOENT; if (validate_core_offset(reg)) return -EINVAL; if (KVM_REG_SIZE(reg->id) > sizeof(tmp)) return -EINVAL; if (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) { err = -EFAULT; goto out; } if (off == KVM_REG_ARM_CORE_REG(regs.pstate)) { u32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK; switch (mode) { case PSR_AA32_MODE_USR: case PSR_AA32_MODE_FIQ: case PSR_AA32_MODE_IRQ: case PSR_AA32_MODE_SVC: case PSR_AA32_MODE_ABT: case PSR_AA32_MODE_UND: case PSR_MODE_EL0t: case PSR_MODE_EL1t: case PSR_MODE_EL1h: break; default: err = -EINVAL; goto out; } } memcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id)); out: return err; }"
"static int int_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode, const char *name, size_t namelen) { char *copy; if (name && memchr(name, '\0', namelen)) return 0; if (mode == SET_HOST && id->hosts) { string_stack_free(id->hosts); id->hosts = NULL; } if (name == NULL || namelen == 0) return 1; copy = strndup(name, namelen); if (copy == NULL) return 0; if (id->hosts == NULL && (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) { free(copy); return 0; } if (!sk_OPENSSL_STRING_push(id->hosts, copy)) { free(copy); if (sk_OPENSSL_STRING_num(id->hosts) == 0) { sk_OPENSSL_STRING_free(id->hosts); id->hosts = NULL; } return 0; } return 1; }"
"static const u_char * ikev2_ID_print(netdissect_options *ndo, u_char tpay, const struct isakmp_gen *ext, u_int item_len _U_, const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { struct ikev2_id id; int id_len, idtype_len, i; unsigned int dumpascii, dumphex; const unsigned char *typedata; ND_TCHECK(*ext); UNALIGNED_MEMCPY(&id, ext, sizeof(id)); ikev2_pay_print(ndo, NPSTR(tpay), id.h.critical); id_len = ntohs(id.h.len); ND_PRINT((ndo,"" len=%d"", id_len - 4)); if (2 < ndo->ndo_vflag && 4 < id_len) { ND_PRINT((ndo,"" "")); if (!rawprint(ndo, (const uint8_t *)(ext + 1), id_len - 4)) goto trunc; } idtype_len =id_len - sizeof(struct ikev2_id); dumpascii = 0; dumphex   = 0; typedata  = (const unsigned char *)(ext)+sizeof(struct ikev2_id); switch(id.type) { case ID_IPV4_ADDR: ND_PRINT((ndo, "" ipv4:"")); dumphex=1; break; case ID_FQDN: ND_PRINT((ndo, "" fqdn:"")); dumpascii=1; break; case ID_RFC822_ADDR: ND_PRINT((ndo, "" rfc822:"")); dumpascii=1; break; case ID_IPV6_ADDR: ND_PRINT((ndo, "" ipv6:"")); dumphex=1; break; case ID_DER_ASN1_DN: ND_PRINT((ndo, "" dn:"")); dumphex=1; break; case ID_DER_ASN1_GN: ND_PRINT((ndo, "" gn:"")); dumphex=1; break; case ID_KEY_ID: ND_PRINT((ndo, "" keyid:"")); dumphex=1; break; } if(dumpascii) { ND_TCHECK2(*typedata, idtype_len); for(i=0; i<idtype_len; i++) { if(ND_ISPRINT(typedata[i])) { ND_PRINT((ndo, ""%c"", typedata[i])); } else { ND_PRINT((ndo, ""."")); } } } if(dumphex) { if (!rawprint(ndo, (const uint8_t *)typedata, idtype_len)) goto trunc; } return (const u_char *)ext + id_len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay))); return NULL; }"
"int main(int argc, char** argv) { WinsockContext context; string tmpDir = GetTempDirectory(); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); LogHandler::setupStdoutLogger(); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); cxxopts::Options options(""et"", ""Remote shell for the busy and impatient""); try { options.allow_unrecognised_options(); options.positional_help(""""); options.custom_help( ""[OPTION...] [user@]host[:port]\n\n"" ""  Note that 'host' can be a hostname or ipv4 address with or without "" ""a port\n  or an ipv6 address. If the ipv6 address is abbreviated with "" "":: then it must\n  be specfied without a port (use -p,--port).""); options.add_options()                     (""h,help"", ""Print help"")              (""version"", ""Print version"")          (""u,username"", ""Username"")            (""host"", ""Remote host name"", cxxopts::value<std::string>())          (""p,port"", ""Remote machine etserver port"", cxxopts::value<int>()->default_value(""2022""))          (""c,command"", ""Run command on connect"", cxxopts::value<std::string>())          (""terminal-path"", ""Path to etterminal on server side. "" ""Use if etterminal is not on the system path."", cxxopts::value<std::string>())          (""t,tunnel"", ""Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. "" ""10080:80,10443:443, 10090-10092:8000-8002)"", cxxopts::value<std::string>())          (""r,reversetunnel"", ""Reverse Tunnel: Array of source:destination ports or "" ""srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges"", cxxopts::value<std::string>())          (""jumphost"", ""jumphost between localhost and destination"", cxxopts::value<std::string>())          (""jport"", ""Jumphost machine port"", cxxopts::value<int>()->default_value(""2022""))          (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")          (""macserver"", ""Set when connecting to an macOS server.  Sets "" ""--terminal-path=/usr/local/bin/etterminal"")          (""v,verbose"", ""Enable verbose logging"", cxxopts::value<int>()->default_value(""0""))          (""k,keepalive"", ""Client keepalive duration in seconds"", cxxopts::value<int>())                                      (""logtostdout"", ""Write log to stdout"")                       (""silent"", ""Disable logging"")                                (""N,no-terminal"", ""Do not create a terminal"")                (""f,forward-ssh-agent"", ""Forward ssh-agent socket"")          (""ssh-socket"", ""The ssh-agent socket to forward"", cxxopts::value<std::string>())          (""telemetry"", ""Allow et to anonymously send errors to guide future improvements"", cxxopts::value<bool>()->default_value(""true""))          (""serverfifo"", ""If set, communicate to etserver on the matching fifo name"", cxxopts::value<std::string>()->default_value(""""))          (""ssh-option"", ""Options to pass down to `ssh -o`"", cxxopts::value<std::vector<std::string>>()); options.parse_positional({""host""}); auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } if (result.count(""version"")) { CLOG(INFO, ""stdout"") << ""et version "" << ET_VERSION << endl; exit(0); } el::Loggers::setVerboseLevel(result[""verbose""].as<int>()); if (result.count(""silent"")) { defaultConf.setGlobally(el::ConfigurationType::Enabled, ""false""); } LogHandler::setupLogFiles(&defaultConf, tmpDir, ""etclient"", result.count(""logtostdout""), !result.count(""logtostdout"")); el::Loggers::reconfigureLogger(""default"", defaultConf); el::Helpers::setThreadName(""client-main""); el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler); GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); TelemetryService::create(result[""telemetry""].as<bool>(), tmpDir + ""/.sentry-native-et"", ""Client""); string username = """"; if (result.count(""username"")) { username = result[""username""].as<string>(); } int destinationPort = result[""port""].as<int>(); string destinationHost; if (!result.count(""host"")) { CLOG(INFO, ""stdout"") << ""Missing host to connect to"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } string host_arg = result[""host""].as<std::string>(); if (host_arg.find('@') != string::npos) { int i = host_arg.find('@'); username = host_arg.substr(0, i); host_arg = host_arg.substr(i + 1); } if (host_arg.find(':') != string::npos) { int colon_count = std::count(host_arg.begin(), host_arg.end(), ':'); if (colon_count == 1) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { if (host_arg.find(""::"") != string::npos) { } else { if (colon_count == 7) { } else if (colon_count == 8) { int port_colon_pos = host_arg.rfind(':'); destinationPort = stoi(host_arg.substr(port_colon_pos + 1)); host_arg = host_arg.substr(0, port_colon_pos); } else { CLOG(INFO, ""stdout"") << ""Invalid host positional arg: "" << result[""host""].as<std::string>() << endl; exit(1); } } } } destinationHost = host_arg; string host_alias = destinationHost; string jumphost = result.count(""jumphost"") ? result[""jumphost""].as<string>() : """"; int keepaliveDuration = result.count(""keepalive"") ? result[""keepalive""].as<int>() : MAX_CLIENT_KEEP_ALIVE_DURATION; if (keepaliveDuration < 1 || keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) { CLOG(INFO, ""stdout"") << ""Keep-alive duration must between 1 and "" << MAX_CLIENT_KEEP_ALIVE_DURATION << "" seconds"" << endl; CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } Options sshConfigOptions = { NULL,          NULL,          NULL,          NULL,          NULL,          NULL,          0,             0,             0,             0,             0,             NULL,          NULL,          0,             0,             NULL       }; char* home_dir = ssh_get_user_home_dir(); const char* host_from_command = destinationHost.c_str(); ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST, destinationHost.c_str()); parse_ssh_config_file(host_from_command, &sshConfigOptions, string(home_dir) + USER_SSH_CONFIG_PATH); parse_ssh_config_file(host_from_command, &sshConfigOptions, SYSTEM_SSH_CONFIG_PATH); LOG(INFO) << ""Parsed ssh config file, connecting to "" << sshConfigOptions.host; destinationHost = string(sshConfigOptions.host); if (username.empty()) { if (sshConfigOptions.username) { username = string(sshConfigOptions.username); } else { username = string(ssh_get_local_username()); } } if (sshConfigOptions.ProxyJump && jumphost.length() == 0) { string proxyjump = string(sshConfigOptions.ProxyJump); size_t colonIndex = proxyjump.find("":""); if (colonIndex != string::npos) { string userhostpair = proxyjump.substr(0, colonIndex); size_t atIndex = userhostpair.find(""@""); if (atIndex != string::npos) { jumphost = userhostpair.substr(atIndex + 1); } } else { jumphost = proxyjump; } LOG(INFO) << ""ProxyJump found for dst in ssh config: "" << proxyjump; } bool is_jumphost = false; SocketEndpoint socketEndpoint; if (!jumphost.empty()) { is_jumphost = true; LOG(INFO) << ""Setting port to jumphost port""; socketEndpoint.set_name(jumphost); socketEndpoint.set_port(result[""jport""].as<int>()); } else { socketEndpoint.set_name(destinationHost); socketEndpoint.set_port(destinationPort); } shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler()); shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler()); if (!ping(socketEndpoint, clientSocket)) { CLOG(INFO, ""stdout"") << ""Could not reach the ET server: "" << socketEndpoint.name() << "":"" << socketEndpoint.port() << endl; exit(1); } int jport = result[""jport""].as<int>(); string serverFifo = """"; if (result[""serverfifo""].as<string>() != """") { serverFifo = result[""serverfifo""].as<string>(); } std::vector<string> ssh_options; if (result.count(""ssh-option"")) { ssh_options = result[""ssh-option""].as<std::vector<string>>(); } string etterminal_path = """"; if (result.count(""macserver"") > 0) { etterminal_path = ""/usr/local/bin/etterminal""; } if (result.count(""etterminal_path"")) { etterminal_path = result[""terminal-path""].as<string>(); } string idpasskeypair = SshSetupHandler::SetupSsh( username, destinationHost, host_alias, destinationPort, jumphost, jport, result.count(""x"") > 0, result[""verbose""].as<int>(), etterminal_path, serverFifo, ssh_options); string id = """", passkey = """"; idpasskeypair.erase(idpasskeypair.find_last_not_of("" \n\r\t"") + 1); size_t slashIndex = idpasskeypair.find(""/""); if (slashIndex == string::npos) { STFATAL << ""Invalid idPasskey id/key pair: "" << idpasskeypair; } else { id = idpasskeypair.substr(0, slashIndex); passkey = idpasskeypair.substr(slashIndex + 1); } if (passkey.length() != 32) { STFATAL << ""Invalid/missing passkey: "" << passkey << "" "" << passkey.length(); } shared_ptr<Console> console; if (!result.count(""N"")) { console.reset(new PsuedoTerminalConsole()); } bool forwardAgent = result.count(""f"") > 0; string sshSocket = """"; #ifndef WIN32 if (sshConfigOptions.identity_agent) { sshSocket = string(sshConfigOptions.identity_agent); } forwardAgent |= sshConfigOptions.forward_agent; #endif if (result.count(""ssh-socket"")) { sshSocket = result[""ssh-socket""].as<string>(); } TelemetryService::get()->logToDatadog(""Session Started"", el::Level::Info, __FILE__, __LINE__); string tunnel_arg = result.count(""tunnel"") ? result[""tunnel""].as<string>() : """"; string r_tunnel_arg = result.count(""reversetunnel"") ? result[""reversetunnel""].as<string>() : """"; TerminalClient terminalClient(clientSocket, clientPipeSocket, socketEndpoint, id, passkey, console, is_jumphost, tunnel_arg, r_tunnel_arg, forwardAgent, sshSocket, keepaliveDuration); terminalClient.run(result.count(""command"") ? result[""command""].as<string>() : """"); } catch (TunnelParseException& tpe) { handleParseException(tpe, options); } catch (cxxopts::OptionException& oe) { handleParseException(oe, options); } #ifdef WIN32 WSACleanup(); #endif TelemetryService::get()->shutdown(); TelemetryService::destroy(); el::Helpers::uninstallPreRollOutCallback(); return 0; }"
"static void credential_write_item(FILE *fp, const char *key, const char *value) { if (!value) return; fprintf(fp, ""%s=%s\n"", key, value); }"
"j9object_t    resolveStringRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA cpIndex, UDATA resolveFlags) { J9UTF8 *utf8Wrapper; j9object_t stringRef; J9ROMStringRef *romStringRef; Trc_VM_resolveStringRef_Entry(vmStruct, cpIndex, ramCP); romStringRef = (J9ROMStringRef *)&ramCP->romConstantPool[cpIndex]; utf8Wrapper = J9ROMSTRINGREF_UTF8DATA(romStringRef); Trc_VM_resolveStringRef_utf8(vmStruct, &utf8Wrapper, J9UTF8_LENGTH(utf8Wrapper), J9UTF8_DATA(utf8Wrapper)); stringRef = vmStruct->javaVM->memoryManagerFunctions->j9gc_createJavaLangString(vmStruct, J9UTF8_DATA(utf8Wrapper), J9UTF8_LENGTH(utf8Wrapper), J9_STR_TENURE | J9_STR_INTERN); if (stringRef != NULL) { J9Class *clazz = J9_CLASS_FROM_CP(ramCP); J9RAMStringRef *ramStringRef = (J9RAMStringRef *)&ramCP[cpIndex]; j9object_t *stringObjectP = &ramStringRef->stringObject; J9STATIC_OBJECT_STORE(vmStruct, clazz, stringObjectP, stringRef); } Trc_VM_resolveStringRef_Exit(vmStruct, stringRef); return stringRef; }"
"static int lag_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; LagarithContext *l = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *const p  = data; uint8_t frametype = 0; uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9; uint32_t offs[4]; uint8_t *srcs[4], *dst; int i, j, planes = 3; p->key_frame = 1; frametype = buf[0]; offset_gu = AV_RL32(buf + 1); offset_bv = AV_RL32(buf + 5); switch (frametype) { case FRAME_SOLID_RGBA: avctx->pix_fmt = AV_PIX_FMT_RGB32; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } dst = p->data[0]; for (j = 0; j < avctx->height; j++) { for (i = 0; i < avctx->width; i++) AV_WN32(dst + i * 4, offset_gu); dst += p->linesize[0]; } break; case FRAME_ARITH_RGBA: avctx->pix_fmt = AV_PIX_FMT_RGB32; planes = 4; offset_ry += 4; offs[3] = AV_RL32(buf + 9); case FRAME_ARITH_RGB24: case FRAME_U_RGB24: if (frametype == FRAME_ARITH_RGB24 || frametype == FRAME_U_RGB24) avctx->pix_fmt = AV_PIX_FMT_RGB24; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } offs[0] = offset_bv; offs[1] = offset_gu; offs[2] = offset_ry; if (!l->rgb_planes) { l->rgb_stride = FFALIGN(avctx->width, 16); l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 1); if (!l->rgb_planes) { av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n""); return AVERROR(ENOMEM); } } for (i = 0; i < planes; i++) srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride; if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size || (planes == 4 && offs[3] >= buf_size)) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < planes; i++) lag_decode_arith_plane(l, srcs[i], avctx->width, avctx->height, -l->rgb_stride, buf + offs[i], buf_size - offs[i]); dst = p->data[0]; for (i = 0; i < planes; i++) srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height; for (j = 0; j < avctx->height; j++) { for (i = 0; i < avctx->width; i++) { uint8_t r, g, b, a; r = srcs[0][i]; g = srcs[1][i]; b = srcs[2][i]; r += g; b += g; if (frametype == FRAME_ARITH_RGBA) { a = srcs[3][i]; AV_WN32(dst + i * 4, MKBETAG(a, r, g, b)); } else { dst[i * 3 + 0] = r; dst[i * 3 + 1] = g; dst[i * 3 + 2] = b; } } dst += p->linesize[0]; for (i = 0; i < planes; i++) srcs[i] += l->rgb_stride; } break; case FRAME_ARITH_YUY2: avctx->pix_fmt = AV_PIX_FMT_YUV422P; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height, p->linesize[0], buf + offset_ry, buf_size - offset_ry); lag_decode_arith_plane(l, p->data[1], avctx->width / 2, avctx->height, p->linesize[1], buf + offset_gu, buf_size - offset_gu); lag_decode_arith_plane(l, p->data[2], avctx->width / 2, avctx->height, p->linesize[2], buf + offset_bv, buf_size - offset_bv); break; case FRAME_ARITH_YV12: avctx->pix_fmt = AV_PIX_FMT_YUV420P; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height, p->linesize[0], buf + offset_ry, buf_size - offset_ry); lag_decode_arith_plane(l, p->data[2], avctx->width / 2, avctx->height / 2, p->linesize[2], buf + offset_gu, buf_size - offset_gu); lag_decode_arith_plane(l, p->data[1], avctx->width / 2, avctx->height / 2, p->linesize[1], buf + offset_bv, buf_size - offset_bv); break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported Lagarith frame type: %#x\n"", frametype); return -1; } *got_frame = 1; return buf_size; }"
"static guint32 dissect_fb_zero_tag(tvbuff_t *tvb, packet_info *pinfo, proto_tree *fb_zero_tree, guint offset, guint32 tag_number){ guint32 tag_offset_start = offset + tag_number*4*2; guint32 tag_offset = 0, total_tag_len = 0; gint32 tag_len; while(tag_number){ proto_tree *tag_tree, *ti_len, *ti_tag, *ti_type; guint32 offset_end, tag; const guint8* tag_str; ti_tag = proto_tree_add_item(fb_zero_tree, hf_fb_zero_tags, tvb, offset, 8, ENC_NA); tag_tree = proto_item_add_subtree(ti_tag, ett_fb_zero_tag_value); ti_type = proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_type, tvb, offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); tag = tvb_get_ntohl(tvb, offset); proto_item_append_text(ti_type, "" (%s)"", val_to_str(tag, tag_vals, ""Unknown"")); proto_item_append_text(ti_tag, "": %s (%s)"", tag_str, val_to_str(tag, tag_vals, ""Unknown"")); offset += 4; proto_tree_add_item(tag_tree, hf_fb_zero_tag_offset_end, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset_end = tvb_get_letohl(tvb, offset); tag_len = offset_end - tag_offset; total_tag_len += tag_len; ti_len = proto_tree_add_uint(tag_tree, hf_fb_zero_tag_length, tvb, offset, 4, tag_len); proto_item_append_text(ti_tag, "" (l=%u)"", tag_len); proto_item_set_generated(ti_len); offset += 4; if( tag_len > tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset)){ tag_len = tvb_reported_length_remaining(tvb, tag_offset_start + tag_offset); offset_end = tag_offset + tag_len; expert_add_info(pinfo, ti_len, &ei_fb_zero_tag_length); } proto_tree_add_item(tag_tree, hf_fb_zero_tag_value, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); switch(tag){ case TAG_SNI: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_sni, tvb, tag_offset_start + tag_offset, tag_len, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += tag_len; break; case TAG_VERS: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_vers, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += 4; break; case TAG_SNO: proto_tree_add_item(tag_tree, hf_fb_zero_tag_sno, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); tag_offset += tag_len; break; case TAG_AEAD: while(offset_end - tag_offset >= 4){ proto_tree *ti_aead; ti_aead = proto_tree_add_item(tag_tree, hf_fb_zero_tag_aead, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA); proto_item_append_text(ti_aead, "" (%s)"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, ""Unknown"")); proto_item_append_text(ti_tag, "", %s"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_aead_vals, ""Unknown"")); tag_offset += 4; } break; case TAG_SCID: proto_tree_add_item(tag_tree, hf_fb_zero_tag_scid, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); tag_offset += tag_len; break; case TAG_TIME: proto_tree_add_item(tag_tree, hf_fb_zero_tag_time, tvb, tag_offset_start + tag_offset, 4, ENC_LITTLE_ENDIAN); proto_item_append_text(ti_tag, "": %u"", tvb_get_letohl(tvb, tag_offset_start + tag_offset)); tag_offset += 4; break; case TAG_ALPN: proto_tree_add_item_ret_string(tag_tree, hf_fb_zero_tag_alpn, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA, wmem_packet_scope(), &tag_str); proto_item_append_text(ti_tag, "": %s"", tag_str); tag_offset += 4; break; case TAG_PUBS: proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 2, ENC_LITTLE_ENDIAN); tag_offset += 2; while(offset_end - tag_offset >= 3){ proto_tree_add_item(tag_tree, hf_fb_zero_tag_pubs, tvb, tag_offset_start + tag_offset, 3, ENC_LITTLE_ENDIAN); tag_offset += 3; } break; case TAG_KEXS: while(offset_end - tag_offset >= 4){ proto_tree *ti_kexs; ti_kexs = proto_tree_add_item(tag_tree, hf_fb_zero_tag_kexs, tvb, tag_offset_start + tag_offset, 4, ENC_ASCII|ENC_NA); proto_item_append_text(ti_kexs, "" (%s)"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, ""Unknown"")); proto_item_append_text(ti_tag, "", %s"", val_to_str(tvb_get_ntohl(tvb, tag_offset_start + tag_offset), tag_kexs_vals, ""Unknown"")); tag_offset += 4; } break; case TAG_NONC: proto_tree_add_item(tag_tree, hf_fb_zero_tag_nonc, tvb, tag_offset_start + tag_offset, 32, ENC_NA); tag_offset += 32; break; default: proto_tree_add_item(tag_tree, hf_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, tag_len, ENC_NA); expert_add_info_format(pinfo, ti_tag, &ei_fb_zero_tag_undecoded, ""Dissector for FB Zero Tag"" "" %s (%s) code not implemented, Contact"" "" Wireshark developers if you want this supported"", tvb_get_string_enc(wmem_packet_scope(), tvb, offset-8, 4, ENC_ASCII|ENC_NA), val_to_str(tag, tag_vals, ""Unknown"")); tag_offset += tag_len; break; } if(tag_offset != offset_end){ proto_tree_add_expert(tag_tree, pinfo, &ei_fb_zero_tag_unknown, tvb, tag_offset_start + tag_offset, offset_end - tag_offset); tag_offset = offset_end; } tag_number--; } return offset + total_tag_len; }"
"int fit_config_verify_required_sigs(const void *fit, int conf_noffset, const void *sig_blob) { int noffset; int sig_node; int verified = 0; int reqd_sigs = 0; bool reqd_policy_all = true; const char *reqd_mode; sig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME); if (sig_node < 0) { debug(""%s: No signature node found: %s\n"", __func__, fdt_strerror(sig_node)); return 0; } reqd_mode = fdt_getprop(sig_blob, sig_node, ""required-mode"", NULL); if (reqd_mode && !strcmp(reqd_mode, ""any"")) reqd_policy_all = false; debug(""%s: required-mode policy set to '%s'\n"", __func__, reqd_policy_all ? ""all"" : ""any""); fdt_for_each_subnode(noffset, sig_blob, sig_node) { const char *required; int ret; required = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED, NULL); if (!required || strcmp(required, ""conf"")) continue; reqd_sigs++; ret = fit_config_verify_sig(fit, conf_noffset, sig_blob, noffset); if (ret) { if (reqd_policy_all) { printf(""Failed to verify required signature '%s'\n"", fit_get_name(sig_blob, noffset, NULL)); return ret; } } else { verified++; if (!reqd_policy_all) break; } } if (reqd_sigs && !verified) { printf(""Failed to verify 'any' of the required signature(s)\n""); return -EPERM; } return 0; }"
"static ssize_t module_gzip_decompress(struct load_info *info, const void *buf, size_t size) { struct z_stream_s s = { 0 }; size_t new_size = 0; size_t gzip_hdr_len; ssize_t retval; int rc; gzip_hdr_len = module_gzip_header_len(buf, size); if (!gzip_hdr_len) { pr_err(""not a gzip compressed module\n""); return -EINVAL; } s.next_in = buf + gzip_hdr_len; s.avail_in = size - gzip_hdr_len; s.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL); if (!s.workspace) return -ENOMEM; rc = zlib_inflateInit2(&s, -MAX_WBITS); if (rc != Z_OK) { pr_err(""failed to initialize decompressor: %d\n"", rc); retval = -EINVAL; goto out; } do { struct page *page = module_get_next_page(info); if (!page) { retval = -ENOMEM; goto out_inflate_end; } s.next_out = kmap_local_page(page); s.avail_out = PAGE_SIZE; rc = zlib_inflate(&s, 0); kunmap_local(s.next_out); new_size += PAGE_SIZE - s.avail_out; } while (rc == Z_OK); if (rc != Z_STREAM_END) { pr_err(""decompression failed with status %d\n"", rc); retval = -EINVAL; goto out_inflate_end; } retval = new_size; out_inflate_end: zlib_inflateEnd(&s); out: kfree(s.workspace); return retval; }"
"static njs_object_prop_t * njs_descriptor_prop(njs_vm_t *vm, const njs_value_t *name, const njs_value_t *desc) { njs_int_t           ret; njs_bool_t          data, accessor; njs_value_t         value; njs_function_t      *getter, *setter; njs_object_prop_t   *prop; njs_lvlhsh_query_t  lhq; static const njs_value_t  get_string = njs_string(""get""); if (!njs_is_object(desc)) { njs_type_error(vm, ""property descriptor must be an object""); return NULL; } prop = njs_object_prop_alloc(vm, name, &njs_value_invalid, NJS_ATTRIBUTE_UNSET); if (njs_slow_path(prop == NULL)) { return NULL; } data = 0; accessor = 0; getter = NJS_PROP_PTR_UNSET; setter = NJS_PROP_PTR_UNSET; njs_object_property_init(&lhq, &get_string, NJS_GET_HASH); ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { if (njs_is_defined(&value) && !njs_is_function(&value)) { njs_type_error(vm, ""Getter must be a function""); return NULL; } accessor = 1; getter = njs_is_function(&value) ? njs_function(&value) : NULL; } lhq.key = njs_str_value(""set""); lhq.key_hash = NJS_SET_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { if (njs_is_defined(&value) && !njs_is_function(&value)) { njs_type_error(vm, ""Setter must be a function""); return NULL; } accessor = 1; setter = njs_is_function(&value) ? njs_function(&value) : NULL; } lhq.key = njs_str_value(""value""); lhq.key_hash = NJS_VALUE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { data = 1; njs_value_assign(njs_prop_value(prop), &value); } lhq.key = njs_str_value(""writable""); lhq.key_hash = NJS_WRITABABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { data = 1; prop->writable = njs_is_true(&value); } if (accessor && data) { njs_type_error(vm, ""Cannot both specify accessors "" ""and a value or writable attribute""); return NULL; } lhq.key = njs_str_value(""enumerable""); lhq.key_hash = NJS_ENUMERABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { prop->enumerable = njs_is_true(&value); } lhq.key = njs_str_value(""configurable""); lhq.key_hash = NJS_CONFIGURABLE_HASH; ret = njs_object_property(vm, desc, &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return NULL; } if (ret == NJS_OK) { prop->configurable = njs_is_true(&value); } if (accessor) { prop->type = NJS_ACCESSOR; njs_prop_getter(prop) = getter; njs_prop_setter(prop) = setter; } return prop; }"
"int nbd_unlocked_opt_go (struct nbd_handle *h) { int err; nbd_completion_callback c = { .callback = go_complete, .user_data = &err }; int r = nbd_unlocked_aio_opt_go (h, &c); if (r == -1) return r; r = wait_for_option (h); if (r == 0 && err) { assert (nbd_internal_is_state_negotiating (get_next_state (h))); set_error (err, ""server replied with error to opt_go request""); return -1; } if (r == 0) assert (nbd_internal_is_state_ready (get_next_state (h))); return r; }"
"Status FrameDecoder::ProcessDCGlobal(BitReader* br) { PROFILER_FUNC; PassesSharedState& shared = dec_state_->shared_storage; if (shared.frame_header.flags & FrameHeader::kPatches) { bool uses_extra_channels = false; JXL_RETURN_IF_ERROR(shared.image_features.patches.Decode( br, frame_dim_.xsize_padded, frame_dim_.ysize_padded, &uses_extra_channels)); if (uses_extra_channels && frame_header_.upsampling != 1) { for (size_t ecups : frame_header_.extra_channel_upsampling) { if (ecups != frame_header_.upsampling) { return JXL_FAILURE( ""Cannot use extra channels in patches if color channels are "" ""subsampled differently from extra channels""); } } } } else { shared.image_features.patches.Clear(); } shared.image_features.splines.Clear(); if (shared.frame_header.flags & FrameHeader::kSplines) { JXL_RETURN_IF_ERROR(shared.image_features.splines.Decode( br, frame_dim_.xsize * frame_dim_.ysize)); } if (shared.frame_header.flags & FrameHeader::kNoise) { JXL_RETURN_IF_ERROR(DecodeNoise(br, &shared.image_features.noise_params)); } JXL_RETURN_IF_ERROR(dec_state_->shared_storage.matrices.DecodeDC(br)); if (frame_header_.encoding == FrameEncoding::kVarDCT) { JXL_RETURN_IF_ERROR( jxl::DecodeGlobalDCInfo(br, decoded_->IsJPEG(), dec_state_, pool_)); } if (shared.frame_header.flags & FrameHeader::kSplines) { JXL_RETURN_IF_ERROR(shared.image_features.splines.InitializeDrawCache( frame_dim_.xsize, frame_dim_.ysize, dec_state_->shared->cmap)); } Status dec_status = modular_frame_decoder_.DecodeGlobalInfo( br, frame_header_, allow_partial_dc_global_); if (dec_status.IsFatalError()) return dec_status; if (dec_status) { decoded_dc_global_ = true; } return dec_status; }"
"int TIFFInitJBIG(TIFF* tif, int scheme) { (void)scheme; assert(scheme == COMPRESSION_JBIG); tif->tif_flags |= TIFF_NOBITREV; tif->tif_flags &= ~TIFF_MAPPED; tif->tif_setupdecode = JBIGSetupDecode; tif->tif_decodestrip = JBIGDecode; tif->tif_setupencode = JBIGSetupEncode; tif->tif_encodestrip = JBIGEncode; return 1; }"
"int __nla_validate(const struct nlattr *head, int len, int maxtype, const struct nla_policy *policy, unsigned int validate, struct netlink_ext_ack *extack) { return __nla_validate_parse(head, len, maxtype, policy, validate, extack, NULL); }"
"static void reg_set_min_max_inv(struct bpf_reg_state *true_reg, struct bpf_reg_state *false_reg, u64 val, u8 opcode, bool is_jmp32) { s64 sval; if (__is_pointer_value(false, false_reg)) return; val = is_jmp32 ? (u32)val : val; sval = is_jmp32 ? (s64)(s32)val : (s64)val; switch (opcode) { case BPF_JEQ: case BPF_JNE: { struct bpf_reg_state *reg = opcode == BPF_JEQ ? true_reg : false_reg; if (is_jmp32) { u64 old_v = reg->var_off.value; u64 hi_mask = ~0xffffffffULL; reg->var_off.value = (old_v & hi_mask) | val; reg->var_off.mask &= hi_mask; } else { __mark_reg_known(reg, val); } break; } case BPF_JSET: false_reg->var_off = tnum_and(false_reg->var_off, tnum_const(~val)); if (is_power_of_2(val)) true_reg->var_off = tnum_or(true_reg->var_off, tnum_const(val)); break; case BPF_JGE: case BPF_JGT: { u64 false_umin = opcode == BPF_JGT ? val    : val + 1; u64 true_umax = opcode == BPF_JGT ? val - 1 : val; if (is_jmp32) { false_umin += gen_hi_min(false_reg->var_off); true_umax += gen_hi_max(true_reg->var_off); } false_reg->umin_value = max(false_reg->umin_value, false_umin); true_reg->umax_value = min(true_reg->umax_value, true_umax); break; } case BPF_JSGE: case BPF_JSGT: { s64 false_smin = opcode == BPF_JSGT ? sval    : sval + 1; s64 true_smax = opcode == BPF_JSGT ? sval - 1 : sval; if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg)) break; false_reg->smin_value = max(false_reg->smin_value, false_smin); true_reg->smax_value = min(true_reg->smax_value, true_smax); break; } case BPF_JLE: case BPF_JLT: { u64 false_umax = opcode == BPF_JLT ? val    : val - 1; u64 true_umin = opcode == BPF_JLT ? val + 1 : val; if (is_jmp32) { false_umax += gen_hi_max(false_reg->var_off); true_umin += gen_hi_min(true_reg->var_off); } false_reg->umax_value = min(false_reg->umax_value, false_umax); true_reg->umin_value = max(true_reg->umin_value, true_umin); break; } case BPF_JSLE: case BPF_JSLT: { s64 false_smax = opcode == BPF_JSLT ? sval    : sval - 1; s64 true_smin = opcode == BPF_JSLT ? sval + 1 : sval; if (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg)) break; false_reg->smax_value = min(false_reg->smax_value, false_smax); true_reg->smin_value = max(true_reg->smin_value, true_smin); break; } default: break; } __reg_deduce_bounds(false_reg); __reg_deduce_bounds(true_reg); __reg_bound_offset(false_reg); __reg_bound_offset(true_reg); if (is_jmp32) { __reg_bound_offset32(false_reg); __reg_bound_offset32(true_reg); } __update_reg_bounds(false_reg); __update_reg_bounds(true_reg); }"
"static void gfs2_evict_inode(struct inode *inode) { struct super_block *sb = inode->i_sb; struct gfs2_sbd *sdp = sb->s_fs_info; struct gfs2_inode *ip = GFS2_I(inode); struct gfs2_holder gh; int ret; if (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr) goto out; gfs2_holder_mark_uninitialized(&gh); ret = evict_should_delete(inode, &gh); if (ret == SHOULD_DEFER_EVICTION) goto out; if (ret == SHOULD_DELETE_DINODE) ret = evict_unlinked_inode(inode); else ret = evict_linked_inode(inode); if (gfs2_rs_active(&ip->i_res)) gfs2_rs_deltree(&ip->i_res); if (gfs2_holder_initialized(&gh)) gfs2_glock_dq_uninit(&gh); if (ret && ret != GLR_TRYFAILED && ret != -EROFS) fs_warn(sdp, ""gfs2_evict_inode: %d\n"", ret); out: truncate_inode_pages_final(&inode->i_data); if (ip->i_qadata) gfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0); gfs2_rs_deltree(&ip->i_res); gfs2_ordered_del_inode(ip); clear_inode(inode); gfs2_dir_hash_inval(ip); if (gfs2_holder_initialized(&ip->i_iopen_gh)) { struct gfs2_glock *gl = ip->i_iopen_gh.gh_gl; glock_clear_object(gl, ip); gfs2_glock_hold(gl); ip->i_iopen_gh.gh_flags |= GL_NOCACHE; gfs2_glock_dq_uninit(&ip->i_iopen_gh); gfs2_glock_put_eventually(gl); } if (ip->i_gl) { glock_clear_object(ip->i_gl, ip); wait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE); gfs2_glock_add_to_lru(ip->i_gl); gfs2_glock_put_eventually(ip->i_gl); ip->i_gl = NULL; } }"
"void PngImage::readMetadata() { #ifdef DEBUG std::cerr << ""Exiv2::PngImage::readMetadata: Reading PNG file "" << io_->path() << std::endl; #endif if (io_->open() != 0) { throw Error(kerDataSourceOpenFailed, io_->path(), strError()); } IoCloser closer(*io_); if (!isPngType(*io_, true)) { throw Error(kerNotAnImage, ""PNG""); } clearMetadata(); const long imgSize = (long)io_->size(); DataBuf cheaderBuf(8);   while (!io_->eof()) { std::memset(cheaderBuf.pData_, 0x0, cheaderBuf.size_); readChunk(cheaderBuf, *io_);   uint32_t chunkLength = Exiv2::getULong(cheaderBuf.pData_, Exiv2::bigEndian); long pos = io_->tell(); if (pos == -1 || chunkLength > uint32_t(0x7FFFFFFF) || static_cast<long>(chunkLength) > imgSize - pos) { throw Exiv2::Error(kerFailedToReadImageData); } std::string chunkType(reinterpret_cast<char*>(cheaderBuf.pData_) + 4, 4); #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: chunk type: "" << chunkType << "" length: "" << chunkLength << std::endl; #endif if (chunkType == ""IEND"" || chunkType == ""IHDR"" || chunkType == ""tEXt"" || chunkType == ""zTXt"" || chunkType == ""iTXt"" || chunkType == ""iCCP"") { DataBuf chunkData(chunkLength); readChunk(chunkData, *io_);   if (chunkType == ""IEND"") { return;                  } else if (chunkType == ""IHDR"" && chunkData.size_ >= 8) { Internal::PngImageHeader header; PngChunk::decodeIHDRChunk(chunkData, header); pixelWidth_ = header.width; pixelHeight_ = header.height; } else if (chunkType == ""tEXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::tEXt_Chunk); } else if (chunkType == ""zTXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::zTXt_Chunk); } else if (chunkType == ""iTXt"") { PngChunk::decodeTXTChunk(this, chunkData, PngChunk::iTXt_Chunk); } else if (chunkType == ""iCCP"") { uint32_t iccOffset = 0; while (iccOffset < 80 && iccOffset < chunkLength) { if (chunkData.pData_[iccOffset++] == 0x00) { break; } } profileName_ = std::string(reinterpret_cast<char*>(chunkData.pData_), iccOffset - 1); ++iccOffset;   zlibToDataBuf(chunkData.pData_ + iccOffset, chunkLength - iccOffset, iccProfile_); #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: profile name: "" << profileName_ << std::endl; std::cout << ""Exiv2::PngImage::readMetadata: iccProfile.size_ (uncompressed) : "" << iccProfile_.size_ << std::endl; #endif } chunkLength = 0; } #ifdef DEBUG std::cout << ""Exiv2::PngImage::readMetadata: Seek to offset: "" << chunkLength + 4 << std::endl; #endif io_->seek(chunkLength + 4, BasicIo::cur); if (io_->error() || io_->eof()) { throw Error(kerFailedToReadImageData); } } }"
"void declareArguments() { ::arg().set(""local-port"",""The port on which we listen"")=""53""; ::arg().setSwitch(""experimental-dnsupdate"",""Enable/Disable DNS update (RFC2136) support. Default is no."")=""no""; ::arg().set(""allow-dnsupdate-from"",""A global setting to allow DNS updates from these IP ranges."")=""127.0.0.0/8,::1""; ::arg().setSwitch(""forward-dnsupdate"",""A global setting to allow DNS update packages that are for a Slave domain, to be forwarded to the master."")=""yes""; ::arg().setSwitch(""log-dns-details"",""If PDNS should log DNS non-erroneous details"")=""no""; ::arg().setSwitch(""log-dns-queries"",""If PDNS should log all incoming DNS queries"")=""no""; ::arg().set(""local-address"",""Local IP addresses to which we bind"")=""0.0.0.0""; ::arg().setSwitch(""local-address-nonexist-fail"",""Fail to start if one or more of the local-address's do not exist on this server"")=""yes""; ::arg().set(""local-ipv6"",""Local IP address to which we bind"")=""""; ::arg().setSwitch(""reuseport"",""Enable higher performance on compliant kernels by using SO_REUSEPORT allowing each receiver thread to open its own socket"")=""no""; ::arg().setSwitch(""local-ipv6-nonexist-fail"",""Fail to start if one or more of the local-ipv6 addresses do not exist on this server"")=""yes""; ::arg().set(""query-local-address"",""Source IP address for sending queries"")=""0.0.0.0""; ::arg().set(""query-local-address6"",""Source IPv6 address for sending queries"")=""::""; ::arg().set(""overload-queue-length"",""Maximum queuelength moving to packetcache only"")=""0""; ::arg().set(""max-queue-length"",""Maximum queuelength before considering situation lost"")=""5000""; ::arg().set(""retrieval-threads"", ""Number of AXFR-retrieval threads for slave operation"")=""2""; ::arg().setSwitch(""experimental-json-interface"", ""If the webserver should serve JSON data"")=""no""; ::arg().setSwitch(""experimental-api-readonly"", ""If the JSON API should disallow data modification"")=""no""; ::arg().set(""experimental-api-key"", ""REST API Static authentication key (required for API use)"")=""""; ::arg().setSwitch(""experimental-dname-processing"", ""If we should support DNAME records"")=""no""; ::arg().setCmd(""help"",""Provide a helpful message""); ::arg().setCmd(""version"",""Output version and compilation date""); ::arg().setCmd(""config"",""Provide configuration file on standard output""); ::arg().setCmd(""list-modules"",""Lists all modules available""); ::arg().setCmd(""no-config"",""Don't parse configuration file""); ::arg().set(""version-string"",""PowerDNS version in packets - full, anonymous, powerdns or custom"")=""full"";  ::arg().set(""control-console"",""Debugging switch - don't use"")=""no"";   ::arg().set(""loglevel"",""Amount of logging. Higher is more. Do not set below 3"")=""4""; ::arg().set(""disable-syslog"",""Disable logging to syslog, useful when running inside a supervisor that logs stdout"")=""no""; ::arg().set(""default-soa-name"",""name to insert in the SOA record if none set in the backend"")=""a.misconfigured.powerdns.server""; ::arg().set(""default-soa-mail"",""mail address to insert in the SOA record if none set in the backend"")=""""; ::arg().set(""distributor-threads"",""Default number of Distributor (backend) threads to start"")=""3""; ::arg().set(""signing-threads"",""Default number of signer threads to start"")=""3""; ::arg().set(""receiver-threads"",""Default number of receiver threads to start"")=""1""; ::arg().set(""queue-limit"",""Maximum number of milliseconds to queue a query"")=""1500"";  ::arg().set(""recursor"",""If recursion is desired, IP address of a recursing nameserver"")=""no"";  ::arg().set(""allow-recursion"",""List of subnets that are allowed to recurse"")=""0.0.0.0/0""; ::arg().set(""pipebackend-abi-version"",""Version of the pipe backend ABI"")=""1""; ::arg().set(""udp-truncation-threshold"", ""Maximum UDP response size before we truncate"")=""1680""; ::arg().set(""disable-tcp"",""Do not listen to TCP queries"")=""no""; ::arg().set(""config-name"",""Name of this virtual configuration - will rename the binary image"")=""""; ::arg().set(""load-modules"",""Load this module - supply absolute or relative path"")=""""; ::arg().set(""launch"",""Which backends to launch and order to query them in"")=""""; ::arg().setSwitch(""disable-axfr"",""Disable zonetransfers but do allow TCP queries"")=""no""; ::arg().set(""allow-axfr-ips"",""Allow zonetransfers only to these subnets"")=""127.0.0.0/8,::1""; ::arg().set(""only-notify"", ""Only send AXFR NOTIFY to these IP addresses or netmasks"")=""0.0.0.0/0,::/0""; ::arg().set(""also-notify"", ""When notifying a domain, also notify these nameservers"")=""""; ::arg().set(""allow-notify-from"",""Allow AXFR NOTIFY from these IP ranges. If empty, drop all incoming notifies."")=""0.0.0.0/0,::/0""; ::arg().set(""slave-cycle-interval"",""Schedule slave freshness checks once every .. seconds"")=""60""; ::arg().set(""tcp-control-address"",""If set, PowerDNS can be controlled over TCP on this address"")=""""; ::arg().set(""tcp-control-port"",""If set, PowerDNS can be controlled over TCP on this address"")=""53000""; ::arg().set(""tcp-control-secret"",""If set, PowerDNS can be controlled over TCP after passing this secret"")=""""; ::arg().set(""tcp-control-range"",""If set, remote control of PowerDNS is possible over these networks only"")=""127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, ::1/128, fe80::/10""; ::arg().setSwitch(""slave"",""Act as a slave"")=""no""; ::arg().setSwitch(""master"",""Act as a master"")=""no""; ::arg().setSwitch(""disable-axfr-rectify"",""Disable the rectify step during an outgoing AXFR. Only required for regression testing."")=""no""; ::arg().setSwitch(""guardian"",""Run within a guardian process"")=""no""; ::arg().setSwitch(""send-root-referral"",""Send out old-fashioned root-referral instead of ServFail in case of no authority"")=""no""; ::arg().setSwitch(""prevent-self-notification"",""Don't send notifications to what we think is ourself"")=""yes""; ::arg().setSwitch(""webserver"",""Start a webserver for monitoring"")=""no"";  ::arg().setSwitch(""webserver-print-arguments"",""If the webserver should print arguments"")=""no"";  ::arg().setSwitch(""edns-subnet-processing"",""If we should act on EDNS Subnet options"")=""no"";  ::arg().setSwitch(""any-to-tcp"",""Answer ANY queries with tc=1, shunting to TCP"")=""no"";  ::arg().set(""webserver-address"",""IP Address of webserver to listen on"")=""127.0.0.1""; ::arg().set(""webserver-port"",""Port of webserver to listen on"")=""8081""; ::arg().set(""webserver-password"",""Password required for accessing the webserver"")=""""; ::arg().set(""webserver-allow-from"",""Webserver access is only allowed from these subnets"")=""0.0.0.0/0,::/0""; ::arg().setSwitch(""out-of-zone-additional-processing"",""Do out of zone additional processing"")=""yes""; ::arg().setSwitch(""do-ipv6-additional-processing"", ""Do AAAA additional processing"")=""yes""; ::arg().setSwitch(""query-logging"",""Hint backends that queries should be logged"")=""no""; ::arg().set(""carbon-ourname"", ""If set, overrides our reported hostname for carbon stats"")=""""; ::arg().set(""carbon-server"", ""If set, send metrics in carbon (graphite) format to this server"")=""""; ::arg().set(""carbon-interval"", ""Number of seconds between carbon (graphite) updates"")=""30""; ::arg().set(""cache-ttl"",""Seconds to store packets in the PacketCache"")=""20""; ::arg().set(""recursive-cache-ttl"",""Seconds to store packets for recursive queries in the PacketCache"")=""10""; ::arg().set(""negquery-cache-ttl"",""Seconds to store negative query results in the QueryCache"")=""60""; ::arg().set(""query-cache-ttl"",""Seconds to store query results in the QueryCache"")=""20""; ::arg().set(""soa-minimum-ttl"",""Default SOA minimum ttl"")=""3600""; ::arg().set(""server-id"", ""Returned when queried for 'server.id' TXT or NSID, defaults to hostname - disabled or custom"")=""""; ::arg().set(""soa-refresh-default"",""Default SOA refresh"")=""10800""; ::arg().set(""soa-retry-default"",""Default SOA retry"")=""3600""; ::arg().set(""soa-expire-default"",""Default SOA expire"")=""604800""; ::arg().set(""default-soa-edit"",""Default SOA-EDIT value"")=""""; ::arg().set(""default-soa-edit-signed"",""Default SOA-EDIT value for signed zones"")=""""; ::arg().set(""trusted-notification-proxy"", ""IP address of incoming notification proxy"")=""""; ::arg().set(""slave-renotify"", ""If we should send out notifications for slaved updates"")=""no""; ::arg().set(""default-ttl"",""Seconds a result is valid if not set otherwise"")=""3600""; ::arg().set(""max-tcp-connections"",""Maximum number of TCP connections"")=""10""; ::arg().setSwitch(""no-shuffle"",""Set this to prevent random shuffling of answers - for regression testing"")=""off""; ::arg().set(""experimental-logfile"", ""Filename of the log file for JSON parser"" )= ""/var/log/pdns.log""; ::arg().set(""setuid"",""If set, change user id to this uid for more security"")=""""; ::arg().set(""setgid"",""If set, change group id to this gid for more security"")=""""; ::arg().set(""max-cache-entries"", ""Maximum number of cache entries"")=""1000000""; ::arg().set(""max-signature-cache-entries"", ""Maximum number of signatures cache entries"")=""""; ::arg().set(""max-ent-entries"", ""Maximum number of empty non-terminals in a zone"")=""100000""; ::arg().set(""entropy-source"", ""If set, read entropy from this file"")=""/dev/urandom""; ::arg().set(""lua-prequery-script"", ""Lua script with prequery handler"")=""""; ::arg().setSwitch(""traceback-handler"",""Enable the traceback handler (Linux only)"")=""yes""; ::arg().setSwitch(""direct-dnskey"",""Fetch DNSKEY RRs from backend during DNSKEY synthesis"")=""no""; ::arg().set(""default-ksk-algorithms"",""Default KSK algorithms"")=""rsasha256""; ::arg().set(""default-ksk-size"",""Default KSK size (0 means default)"")=""0""; ::arg().set(""default-zsk-algorithms"",""Default ZSK algorithms"")=""rsasha256""; ::arg().set(""default-zsk-size"",""Default ZSK size (0 means default)"")=""0""; ::arg().set(""max-nsec3-iterations"",""Limit the number of NSEC3 hash iterations"")=""500"";  ::arg().set(""include-dir"",""Include *.conf files from this directory""); ::arg().set(""security-poll-suffix"",""Domain name from which to query security update notifications"")=""secpoll.powerdns.com.""; }"
"static void slc_bump(struct slcan *sl) { struct sk_buff *skb; struct can_frame cf; int i, tmp; u32 tmpid; char *cmd = sl->rbuff; cf.can_id = 0; switch (*cmd) { case 'r': cf.can_id = CAN_RTR_FLAG; case 't': cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1; break; case 'R': cf.can_id = CAN_RTR_FLAG; case 'T': cf.can_id |= CAN_EFF_FLAG; cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1; break; default: return; } if (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid)) return; cf.can_id |= tmpid; if (cf.can_dlc >= '0' && cf.can_dlc < '9') cf.can_dlc -= '0'; else return; *(u64 *) (&cf.data) = 0;  if (!(cf.can_id & CAN_RTR_FLAG)) { for (i = 0; i < cf.can_dlc; i++) { tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] = (tmp << 4); tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] |= tmp; } } skb = dev_alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv)); if (!skb) return; skb->dev = sl->dev; skb->protocol = htons(ETH_P_CAN); skb->pkt_type = PACKET_BROADCAST; skb->ip_summed = CHECKSUM_UNNECESSARY; can_skb_reserve(skb); can_skb_prv(skb)->ifindex = sl->dev->ifindex; memcpy(skb_put(skb, sizeof(struct can_frame)), &cf, sizeof(struct can_frame)); netif_rx_ni(skb); sl->dev->stats.rx_packets++; sl->dev->stats.rx_bytes += cf.can_dlc; }"
"static void rtps_util_add_coherent_set_general_cases_case( proto_tree *tree, tvbuff_t *tvb, guint64 coherent_seq_number, coherent_set_entity_info *coherent_set_entity_info_object) { coherent_set_entity_info *register_entry; proto_tree *marked_item_tree; coherent_set_info *coherent_set_info_entry; coherent_set_key coherent_set_info_key; coherent_set_entity_info_object->coherent_set_seq_number = coherent_seq_number; register_entry = (coherent_set_entity_info*)wmem_map_lookup(coherent_set_tracking.entities_using_map, &coherent_set_entity_info_object->guid); if (!register_entry) { register_entry = (coherent_set_entity_info*)wmem_memdup(wmem_file_scope(), coherent_set_entity_info_object, sizeof(coherent_set_entity_info)); wmem_map_insert( coherent_set_tracking.entities_using_map, &register_entry->guid, register_entry); } coherent_set_info_key.guid = coherent_set_entity_info_object->guid; coherent_set_info_key.coherent_set_seq_number = coherent_seq_number; coherent_set_info_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key); if (!coherent_set_info_entry) { coherent_set_info_entry = wmem_new0(wmem_file_scope(), coherent_set_info); coherent_set_info_entry->key = (coherent_set_key*)wmem_memdup(wmem_file_scope(), &coherent_set_info_key, sizeof(coherent_set_key)); coherent_set_info_entry->is_set = FALSE; wmem_map_insert( coherent_set_tracking.coherent_set_registry_map, coherent_set_info_entry->key, coherent_set_info_entry); } if (coherent_set_info_entry->writer_seq_number < coherent_set_entity_info_object->writer_seq_number) { coherent_set_info_entry->writer_seq_number = coherent_set_entity_info_object->writer_seq_number; } if (coherent_set_entity_info_object->coherent_set_seq_number == coherent_set_entity_info_object->writer_seq_number) { marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_start, tvb, 0, 0, coherent_seq_number); proto_item_set_generated(marked_item_tree); if (coherent_set_entity_info_object->coherent_set_seq_number > register_entry->coherent_set_seq_number && coherent_set_entity_info_object->writer_seq_number - 1 == register_entry->writer_seq_number) { coherent_set_info *previous_entry; marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, register_entry->coherent_set_seq_number); proto_item_set_generated(marked_item_tree); coherent_set_info_key.coherent_set_seq_number = register_entry->writer_seq_number; coherent_set_info_key.guid = register_entry->guid; previous_entry = (coherent_set_info*)wmem_map_lookup(coherent_set_tracking.coherent_set_registry_map, &coherent_set_info_key); if (previous_entry) { previous_entry->is_set = TRUE; } } } if (!coherent_set_info_entry->is_set) { coherent_set_info_key.coherent_set_seq_number = coherent_seq_number - 1; if (coherent_set_entity_info_object->coherent_set_seq_number == RTPS_SEQUENCENUMBER_UNKNOWN) { register_entry->coherent_set_seq_number = coherent_set_entity_info_object->coherent_set_seq_number; marked_item_tree = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number); proto_item_set_generated(marked_item_tree); coherent_set_info_entry->is_set = TRUE; } } else if (coherent_set_info_entry->writer_seq_number == coherent_set_entity_info_object->writer_seq_number) { proto_tree *ti; ti = proto_tree_add_uint64(tree, hf_rtps_coherent_set_end, tvb, 0, 0, coherent_set_info_entry->key->coherent_set_seq_number); proto_item_set_generated(ti); } coherent_set_entity_info_object->expected_coherent_set_end_writers_seq_number = coherent_set_entity_info_object->writer_seq_number + 1; *register_entry = *coherent_set_entity_info_object; }"
"static int netlbl_cipsov4_list(struct sk_buff *skb, struct genl_info *info) { int ret_val; struct sk_buff *ans_skb = NULL; u32 nlsze_mult = 1; void *data; u32 doi; struct nlattr *nla_a; struct nlattr *nla_b; struct cipso_v4_doi *doi_def; u32 iter; if (!info->attrs[NLBL_CIPSOV4_A_DOI]) { ret_val = -EINVAL; goto list_failure; } list_start: ans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE * nlsze_mult, GFP_KERNEL); if (ans_skb == NULL) { ret_val = -ENOMEM; goto list_failure; } data = genlmsg_put_reply(ans_skb, info, &netlbl_cipsov4_gnl_family, 0, NLBL_CIPSOV4_C_LIST); if (data == NULL) { ret_val = -ENOMEM; goto list_failure; } doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]); rcu_read_lock(); doi_def = cipso_v4_doi_getdef(doi); if (doi_def == NULL) { ret_val = -EINVAL; goto list_failure_lock; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MTYPE, doi_def->type); if (ret_val != 0) goto list_failure_lock; nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_TAGLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_failure_lock; } for (iter = 0; iter < CIPSO_V4_TAG_MAXCNT && doi_def->tags[iter] != CIPSO_V4_TAG_INVALID; iter++) { ret_val = nla_put_u8(ans_skb, NLBL_CIPSOV4_A_TAG, doi_def->tags[iter]); if (ret_val != 0) goto list_failure_lock; } nla_nest_end(ans_skb, nla_a); switch (doi_def->type) { case CIPSO_V4_MAP_TRANS: nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSLVLLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_failure_lock; } for (iter = 0; iter < doi_def->map.std->lvl.local_size; iter++) { if (doi_def->map.std->lvl.local[iter] == CIPSO_V4_INV_LVL) continue; nla_b = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSLVL); if (nla_b == NULL) { ret_val = -ENOMEM; goto list_retry; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSLVLLOC, iter); if (ret_val != 0) goto list_retry; ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSLVLREM, doi_def->map.std->lvl.local[iter]); if (ret_val != 0) goto list_retry; nla_nest_end(ans_skb, nla_b); } nla_nest_end(ans_skb, nla_a); nla_a = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSCATLST); if (nla_a == NULL) { ret_val = -ENOMEM; goto list_retry; } for (iter = 0; iter < doi_def->map.std->cat.local_size; iter++) { if (doi_def->map.std->cat.local[iter] == CIPSO_V4_INV_CAT) continue; nla_b = nla_nest_start_noflag(ans_skb, NLBL_CIPSOV4_A_MLSCAT); if (nla_b == NULL) { ret_val = -ENOMEM; goto list_retry; } ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSCATLOC, iter); if (ret_val != 0) goto list_retry; ret_val = nla_put_u32(ans_skb, NLBL_CIPSOV4_A_MLSCATREM, doi_def->map.std->cat.local[iter]); if (ret_val != 0) goto list_retry; nla_nest_end(ans_skb, nla_b); } nla_nest_end(ans_skb, nla_a); break; } rcu_read_unlock(); genlmsg_end(ans_skb, data); return genlmsg_reply(ans_skb, info); list_retry: if (nlsze_mult < 4) { rcu_read_unlock(); kfree_skb(ans_skb); nlsze_mult *= 2; goto list_start; } list_failure_lock: rcu_read_unlock(); list_failure: kfree_skb(ans_skb); return ret_val; }"
"struct expr_parse_ctx *expr__ctx_new(void) { struct expr_parse_ctx *ctx; ctx = malloc(sizeof(struct expr_parse_ctx)); if (!ctx) return NULL; ctx->ids = hashmap__new(key_hash, key_equal, NULL); ctx->runtime = 0; return ctx; }"
"void gf_bifs_dec_name(GF_BitStream *bs, char *name) { u32 i = 0; while (1) { name[i] = gf_bs_read_int(bs, 8); if (!name[i]) break; i++; } }"
"static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh, int ifindex) { struct bcm_op *op, *n; list_for_each_entry_safe(op, n, ops, list) { if ((op->can_id == mh->can_id) && (op->ifindex == ifindex) && (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) { if (op->ifindex) { if (op->rx_reg_dev) { struct net_device *dev; dev = dev_get_by_index(sock_net(op->sk), op->ifindex); if (dev) { bcm_rx_unreg(dev, op); dev_put(dev); } } } else can_rx_unregister(sock_net(op->sk), NULL, op->can_id, REGMASK(op->can_id), bcm_rx_handler, op); list_del(&op->list); bcm_remove_op(op); return 1;  } } return 0;  }"
void UserAppsModel::openAppUrl(const QUrl &url) { QDesktopServices::openUrl(url); }
"static bool ok_csv_circular_buffer_expand(ok_csv_circular_buffer *buffer) { size_t new_capacity = buffer->capacity * 2; uint8_t *new_data = malloc(new_capacity); if (!new_data) { return false; } else { const size_t readable1 = ok_csv_circular_buffer_readable(buffer); const size_t readable2 = buffer->length - readable1; memcpy(new_data, buffer->data + buffer->start, readable1); memcpy(new_data + readable1, buffer->data, readable2); free(buffer->data); buffer->data = new_data; buffer->capacity = new_capacity; buffer->start = 0; return true; } }"
"static future_t *init(void) { pthread_mutex_init(&lock, NULL); config = config_new(CONFIG_FILE_PATH); if (!config) { LOG_WARN(""%s unable to load config file; attempting to transcode legacy file."", __func__); config = btif_config_transcode(LEGACY_CONFIG_FILE_PATH); if (!config) { LOG_WARN(""%s unable to transcode legacy file, starting unconfigured."", __func__); config = config_new_empty(); if (!config) { LOG_ERROR(""%s unable to allocate a config object."", __func__); goto error; } } if (config_save(config, CONFIG_FILE_PATH)) unlink(LEGACY_CONFIG_FILE_PATH); } btif_config_remove_unpaired(config); alarm_timer = alarm_new(); if (!alarm_timer) { LOG_ERROR(""%s unable to create alarm."", __func__); goto error; } return future_new_immediate(FUTURE_SUCCESS); error:; alarm_free(alarm_timer); config_free(config); pthread_mutex_destroy(&lock); alarm_timer = NULL; config = NULL; return future_new_immediate(FUTURE_FAIL); }"
"static ssize_t smtcfb_read(struct fb_info *info, char __user *buf, size_t count, loff_t *ppos) { unsigned long p = *ppos; u32 *buffer, *dst; u32 __iomem *src; int c, i, cnt = 0, err = 0; unsigned long total_size; if (!info || !info->screen_base) return -ENODEV; if (info->state != FBINFO_STATE_RUNNING) return -EPERM; total_size = info->screen_size; if (total_size == 0) total_size = info->fix.smem_len; if (p >= total_size) return 0; if (count >= total_size) count = total_size; if (count + p > total_size) count = total_size - p; buffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL); if (!buffer) return -ENOMEM; src = (u32 __iomem *)(info->screen_base + p); if (info->fbops->fb_sync) info->fbops->fb_sync(info); while (count) { c = (count > PAGE_SIZE) ? PAGE_SIZE : count; dst = buffer; for (i = c >> 2; i--;) { *dst = fb_readl(src++); *dst = big_swap(*dst); dst++; } if (c & 3) { u8 *dst8 = (u8 *)dst; u8 __iomem *src8 = (u8 __iomem *)src; for (i = c & 3; i--;) { if (i & 1) { *dst8++ = fb_readb(++src8); } else { *dst8++ = fb_readb(--src8); src8 += 2; } } src = (u32 __iomem *)src8; } if (copy_to_user(buf, buffer, c)) { err = -EFAULT; break; } *ppos += c; buf += c; cnt += c; count -= c; } kfree(buffer); return (err) ? err : cnt; }"
"static void do_ssh2_kex(void) { char *myproposal[PROPOSAL_MAX] = { KEX_SERVER }; struct kex *kex; int r; myproposal[PROPOSAL_KEX_ALGS] = compat_kex_proposal( options.kex_algorithms); myproposal[PROPOSAL_ENC_ALGS_CTOS] = compat_cipher_proposal( options.ciphers); myproposal[PROPOSAL_ENC_ALGS_STOC] = compat_cipher_proposal( options.ciphers); myproposal[PROPOSAL_MAC_ALGS_CTOS] = myproposal[PROPOSAL_MAC_ALGS_STOC] = options.macs; if (options.compression == COMP_NONE) { myproposal[PROPOSAL_COMP_ALGS_CTOS] = myproposal[PROPOSAL_COMP_ALGS_STOC] = ""none""; } else if (options.compression == COMP_DELAYED) { myproposal[PROPOSAL_COMP_ALGS_CTOS] = myproposal[PROPOSAL_COMP_ALGS_STOC] = ""none,zlib@openssh.com""; } if (options.rekey_limit || options.rekey_interval) packet_set_rekey_limits(options.rekey_limit, (time_t)options.rekey_interval); myproposal[PROPOSAL_SERVER_HOST_KEY_ALGS] = compat_pkalg_proposal( list_hostkey_types()); if ((r = kex_setup(active_state, myproposal)) != 0) fatal(""kex_setup: %s"", ssh_err(r)); kex = active_state->kex; #ifdef WITH_OPENSSL kex->kex[KEX_DH_GRP1_SHA1] = kexdh_server; kex->kex[KEX_DH_GRP14_SHA1] = kexdh_server; kex->kex[KEX_DH_GRP14_SHA256] = kexdh_server; kex->kex[KEX_DH_GRP16_SHA512] = kexdh_server; kex->kex[KEX_DH_GRP18_SHA512] = kexdh_server; kex->kex[KEX_DH_GEX_SHA1] = kexgex_server; kex->kex[KEX_DH_GEX_SHA256] = kexgex_server; kex->kex[KEX_ECDH_SHA2] = kexecdh_server; #endif kex->kex[KEX_C25519_SHA256] = kexc25519_server; kex->server = 1; kex->client_version_string=client_version_string; kex->server_version_string=server_version_string; kex->load_host_public_key=&get_hostkey_public_by_type; kex->load_host_private_key=&get_hostkey_private_by_type; kex->host_key_index=&get_hostkey_index; kex->sign = sshd_hostkey_sign; dispatch_run(DISPATCH_BLOCK, &kex->done, active_state); session_id2 = kex->session_id; session_id2_len = kex->session_id_len; #ifdef DEBUG_KEXDH packet_start(SSH2_MSG_IGNORE); packet_put_cstring(""markus""); packet_send(); packet_write_wait(); #endif debug(""KEX done""); }"
"static int aes_gcm_ctrl(EVP_CIPHER_CTX *c, int type, int arg, void *ptr) { EVP_AES_GCM_CTX *gctx = EVP_C_DATA(EVP_AES_GCM_CTX,c); switch (type) { case EVP_CTRL_INIT: gctx->key_set = 0; gctx->iv_set = 0; gctx->ivlen = EVP_CIPHER_CTX_iv_length(c); gctx->iv = EVP_CIPHER_CTX_iv_noconst(c); gctx->taglen = -1; gctx->iv_gen = 0; gctx->tls_aad_len = -1; return 1; case EVP_CTRL_AEAD_SET_IVLEN: if (arg <= 0) return 0; if ((arg > EVP_MAX_IV_LENGTH) && (arg > gctx->ivlen)) { if (gctx->iv != EVP_CIPHER_CTX_iv_noconst(c)) OPENSSL_free(gctx->iv); gctx->iv = OPENSSL_malloc(arg); if (gctx->iv == NULL) return 0; } gctx->ivlen = arg; return 1; case EVP_CTRL_AEAD_SET_TAG: if (arg <= 0 || arg > 16 || EVP_CIPHER_CTX_encrypting(c)) return 0; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); gctx->taglen = arg; return 1; case EVP_CTRL_AEAD_GET_TAG: if (arg <= 0 || arg > 16 || !EVP_CIPHER_CTX_encrypting(c) || gctx->taglen < 0) return 0; memcpy(ptr, EVP_CIPHER_CTX_buf_noconst(c), arg); return 1; case EVP_CTRL_GCM_SET_IV_FIXED: if (arg == -1) { memcpy(gctx->iv, ptr, gctx->ivlen); gctx->iv_gen = 1; return 1; } if ((arg < 4) || (gctx->ivlen - arg) < 8) return 0; if (arg) memcpy(gctx->iv, ptr, arg); if (EVP_CIPHER_CTX_encrypting(c) && RAND_bytes(gctx->iv + arg, gctx->ivlen - arg) <= 0) return 0; gctx->iv_gen = 1; return 1; case EVP_CTRL_GCM_IV_GEN: if (gctx->iv_gen == 0 || gctx->key_set == 0) return 0; CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen); if (arg <= 0 || arg > gctx->ivlen) arg = gctx->ivlen; memcpy(ptr, gctx->iv + gctx->ivlen - arg, arg); ctr64_inc(gctx->iv + gctx->ivlen - 8); gctx->iv_set = 1; return 1; case EVP_CTRL_GCM_SET_IV_INV: if (gctx->iv_gen == 0 || gctx->key_set == 0 || EVP_CIPHER_CTX_encrypting(c)) return 0; memcpy(gctx->iv + gctx->ivlen - arg, ptr, arg); CRYPTO_gcm128_setiv(&gctx->gcm, gctx->iv, gctx->ivlen); gctx->iv_set = 1; return 1; case EVP_CTRL_AEAD_TLS1_AAD: if (arg != EVP_AEAD_TLS1_AAD_LEN) return 0; memcpy(EVP_CIPHER_CTX_buf_noconst(c), ptr, arg); gctx->tls_aad_len = arg; { unsigned int len = EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] << 8 | EVP_CIPHER_CTX_buf_noconst(c)[arg - 1]; len -= EVP_GCM_TLS_EXPLICIT_IV_LEN; if (!EVP_CIPHER_CTX_encrypting(c)) len -= EVP_GCM_TLS_TAG_LEN; EVP_CIPHER_CTX_buf_noconst(c)[arg - 2] = len >> 8; EVP_CIPHER_CTX_buf_noconst(c)[arg - 1] = len & 0xff; } return EVP_GCM_TLS_TAG_LEN; case EVP_CTRL_COPY: { EVP_CIPHER_CTX *out = ptr; EVP_AES_GCM_CTX *gctx_out = EVP_C_DATA(EVP_AES_GCM_CTX,out); if (gctx->gcm.key) { if (gctx->gcm.key != &gctx->ks) return 0; gctx_out->gcm.key = &gctx_out->ks; } if (gctx->iv == EVP_CIPHER_CTX_iv_noconst(c)) gctx_out->iv = EVP_CIPHER_CTX_iv_noconst(out); else { gctx_out->iv = OPENSSL_malloc(gctx->ivlen); if (gctx_out->iv == NULL) return 0; memcpy(gctx_out->iv, gctx->iv, gctx->ivlen); } return 1; } default: return -1; } }"
"static int io_close(struct io_kiocb *req, bool force_nonblock, struct io_comp_state *cs) { struct io_close *close = &req->close; int ret; if (!close->put_file) { ret = close_fd_get_file(close->fd, &close->put_file); if (ret < 0) return (ret == -ENOENT) ? -EBADF : ret; } if (close->put_file->f_op->flush && force_nonblock) { req->work.flags |= IO_WQ_WORK_NO_CANCEL; req->flags &= ~REQ_F_NOWAIT; req->flags |= REQ_F_NO_FILE_TABLE; return -EAGAIN; } ret = filp_close(close->put_file, req->work.identity->files); if (ret < 0) req_set_fail_links(req); fput(close->put_file); close->put_file = NULL; __io_req_complete(req, ret, 0, cs); return 0; }"
"void Compute(OpKernelContext* context) override { const Tensor& rhs = context->input(1); context->forward_ref_input_to_ref_output(0, 0); AllocatorAttributes attr; if (!relax_constraints_) { attr.set_gpu_compatible(true); attr.set_nic_compatible(true); } { mutex_lock l(*context->input_ref_mutex(0)); const Tensor& old_lhs = context->mutable_input(0,  true); const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape()); if (validate_shape_) { OP_REQUIRES(context, same_shape, errors::InvalidArgument( ""Assign requires shapes of both tensors to match. "" ""lhs shape= "", old_lhs.shape().DebugString(), "" rhs shape= "", rhs.shape().DebugString())); } if (old_lhs.IsInitialized() && old_lhs.shape().num_elements() == rhs.shape().num_elements()) { Tensor reshaped_old_lhs; if (same_shape) { reshaped_old_lhs = old_lhs; } else { CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape())); context->replace_ref_input(0, reshaped_old_lhs, true); } if (use_exclusive_lock_) { Copy(context, &reshaped_old_lhs, rhs); return; } } else { std::unique_ptr<Tensor> input_alias = context->forward_input( 1, OpKernelContext::Params::kNoReservation , rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr); if (input_alias != nullptr) { context->replace_ref_input(0, *input_alias,  true); return; } Tensor copy_tensor; OP_REQUIRES_OK(context, context->allocate_temp(old_lhs.dtype(), rhs.shape(), &copy_tensor, attr)); context->clear_recorded_memory(); context->replace_ref_input(0, copy_tensor,  true); if (use_exclusive_lock_) { Copy(context, &copy_tensor, rhs); return; } } } Tensor old_unlocked_lhs = context->mutable_input(0,  false); Copy(context, &old_unlocked_lhs, rhs); }"
"static void add_rr_to_tree(proto_tree  *rr_tree, tvbuff_t *tvb, int offset, const guchar *name, int namelen, int type, packet_info *pinfo, gboolean is_mdns) { proto_item *ttl_item; gchar      **srv_rr_info; if (type == T_SRV) { srv_rr_info = wmem_strsplit(wmem_packet_scope(), name, ""."", 3); proto_tree_add_string(rr_tree, hf_dns_srv_service, tvb, offset, namelen, srv_rr_info[0]); if (srv_rr_info[1]) { proto_tree_add_string(rr_tree, hf_dns_srv_proto, tvb, offset, namelen, srv_rr_info[1]); if (srv_rr_info[2]) { proto_tree_add_string(rr_tree, hf_dns_srv_name, tvb, offset, namelen, srv_rr_info[2]); } } } else { proto_tree_add_string(rr_tree, hf_dns_rr_name, tvb, offset, namelen, name); } offset += namelen; proto_tree_add_item(rr_tree, hf_dns_rr_type, tvb, offset, 2, ENC_BIG_ENDIAN); offset += 2; if (is_mdns) { proto_tree_add_item(rr_tree, hf_dns_rr_class_mdns, tvb, offset, 2, ENC_BIG_ENDIAN); proto_tree_add_item(rr_tree, hf_dns_rr_cache_flush, tvb, offset, 2, ENC_BIG_ENDIAN); } else { proto_tree_add_item(rr_tree, hf_dns_rr_class, tvb, offset, 2, ENC_BIG_ENDIAN); } offset += 2; ttl_item = proto_tree_add_item(rr_tree, hf_dns_rr_ttl, tvb, offset, 4, ENC_BIG_ENDIAN); if (tvb_get_ntohl(tvb, offset) & 0x80000000) { expert_add_info(pinfo, ttl_item, &ei_ttl_negative); } offset += 4; proto_tree_add_item(rr_tree, hf_dns_rr_len, tvb, offset, 2, ENC_BIG_ENDIAN); }"
"static void axfm(RCore *core) { RVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX); if (refs && !RVecAnalRef_empty (refs)) { RVecAnalRef_sort (refs, compare_ref); ut64 last_addr = UT64_MAX; RAnalRef *ref; R_VEC_FOREACH (refs, ref) { const bool is_first = ref->addr != last_addr; const char *name; if (is_first) { name = axtm_name (core, ref->addr); r_cons_printf (""0x%""PFMT64x"": %s\n"", ref->addr, name? name: ""?""); } name = axtm_name (core, ref->at); r_cons_printf (""  0x%""PFMT64x"": %s\n"", ref->at, name? name: ""?""); last_addr = ref->addr; } } RVecAnalRef_free (refs); }"
"PJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port( pjmedia_vid_conf *vid_conf, unsigned src_slot, unsigned sink_slot) { vconf_port *src_port, *dst_port; unsigned i, j; PJ_ASSERT_RETURN(vid_conf && src_slot<vid_conf->opt.max_slot_cnt &&  sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL); pj_mutex_lock(vid_conf->mutex); src_port = vid_conf->ports[src_slot]; dst_port = vid_conf->ports[sink_slot]; if (!src_port || !dst_port) { pj_mutex_unlock(vid_conf->mutex); return PJ_EINVAL; } for (i=0; i<src_port->listener_cnt; ++i) { if (src_port->listener_slots[i] == sink_slot) break; } for (j=0; j<dst_port->transmitter_cnt; ++j) { if (dst_port->transmitter_slots[j] == src_slot) break; } if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) { unsigned k; pj_assert(src_port->listener_cnt > 0 &&  src_port->listener_cnt < vid_conf->opt.max_slot_cnt); pj_assert(dst_port->transmitter_cnt > 0 &&  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt); for (k=0; k<dst_port->transmitter_cnt; ++k) cleanup_render_state(dst_port, k); pj_array_erase(src_port->listener_slots, sizeof(unsigned),  src_port->listener_cnt, i); pj_array_erase(dst_port->transmitter_slots, sizeof(unsigned),  dst_port->transmitter_cnt, j); --src_port->listener_cnt; --dst_port->transmitter_cnt; update_render_state(vid_conf, dst_port); --vid_conf->connect_cnt; if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) { pj_status_t status; status = pjmedia_clock_stop(vid_conf->clock); if (status != PJ_SUCCESS) { PJ_PERROR(4, (THIS_FILE, status, ""Failed to stop clock"")); return status; } } PJ_LOG(4,(THIS_FILE, ""Port %d (%.*s) stop transmitting to port %d (%.*s)"", src_slot, (int)src_port->name.slen, src_port->name.ptr, sink_slot, (int)dst_port->name.slen, dst_port->name.ptr)); } pj_mutex_unlock(vid_conf->mutex); return PJ_SUCCESS; }"
"static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt,  const pj_uint8_t *start, const pj_uint8_t *max, pj_str_t *name) { const pj_uint8_t *p; pj_status_t status; if (rec_counter > 10) { return PJLIB_UTIL_EDNSINNAMEPTR; } p = start; while (*p) { if ((*p & 0xc0) == 0xc0) { pj_uint16_t offset; pj_memcpy(&offset, p, 2); offset ^= pj_htons((pj_uint16_t)(0xc0 << 8)); offset = pj_ntohs(offset); if (offset >= max - pkt) return PJLIB_UTIL_EDNSINNAMEPTR; status = get_name(rec_counter+1, pkt, pkt + offset, max, name); if (status != PJ_SUCCESS) return status; return PJ_SUCCESS; } else { unsigned label_len = *p; if (pkt+label_len > max) return PJLIB_UTIL_EDNSINNAMEPTR; pj_memcpy(name->ptr + name->slen, p+1, label_len); name->slen += label_len; p += label_len + 1; if (*p != 0) { *(name->ptr + name->slen) = '.'; ++name->slen; } if (p >= max) return PJLIB_UTIL_EDNSINSIZE; } } return PJ_SUCCESS; }"
"static int dissect_ExpectedSubmoduleBlockReq_block(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, proto_item *item, guint8 *drep, guint8 u8BlockVersionHigh, guint8 u8BlockVersionLow) { guint16     u16NumberOfAPIs; guint32     u32Api; guint16     u16SlotNr; guint32     u32ModuleIdentNumber; guint16     u16ModuleProperties; guint16     u16NumberOfSubmodules; guint16     u16SubslotNr; guint32     u32SubmoduleIdentNumber; guint16     u16SubmoduleProperties; proto_item *api_item; proto_tree *api_tree; guint32     u32ApiStart; proto_item *sub_item; proto_tree *sub_tree; proto_item *submodule_item; proto_tree *submodule_tree; guint32     u32SubStart; const char vendorIdStr[] = ""VendorID=\""""; const char deviceIdStr[] = ""DeviceID=\""""; const char moduleStr[] = ""ModuleIdentNumber=\""""; const char subModuleStr[] = ""SubmoduleIdentNumber=\""""; const char profisafeStr[] = ""PROFIsafeSupported=\""true\""""; const char fParameterStr[] = ""<F_ParameterRecordDataItem""; const char fParameterIndexStr[] = ""Index=""; const char moduleNameInfo[] = ""<Name""; const char moduleValueInfo[] = ""Value=\""""; guint16  searchVendorID = 0; guint16  searchDeviceID = 0; gboolean vendorMatch; gboolean deviceMatch; conversation_t *conversation; stationInfo    *station_info = NULL; ioDataObject   *io_data_object = NULL;  guint32  read_vendor_id; guint32  read_device_id; guint32  read_module_id; guint32  read_submodule_id; gboolean gsdmlFoundFlag; gchar   tmp_moduletext[MAX_NAMELENGTH]; gchar   *convertStr;       gchar   *pch;              gchar   *puffer;           gchar   *temp;             gchar   *diropen = NULL;   GDir    *dir; FILE    *fp = NULL;        const gchar *filename;     convertStr = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_NAMELENGTH); convertStr[0] = '\0'; pch = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH); pch[0] = '\0'; puffer = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH); puffer[0] = '\0'; temp = (gchar*)wmem_alloc(wmem_packet_scope(), MAX_LINE_LENGTH); temp[0] = '\0'; io_data_object = wmem_new0(wmem_file_scope(), ioDataObject); io_data_object->profisafeSupported = FALSE; io_data_object->moduleNameStr = wmem_strdup(wmem_file_scope(), ""Unknown""); vendorMatch = FALSE; deviceMatch = FALSE; gsdmlFoundFlag = FALSE; if (u8BlockVersionHigh != 1 || u8BlockVersionLow != 0) { expert_add_info_format(pinfo, item, &ei_pn_io_block_version, ""Block version %u.%u not implemented yet!"", u8BlockVersionHigh, u8BlockVersionLow); return offset; } offset = dissect_dcerpc_uint16(tvb, offset, pinfo, tree, drep, hf_pn_io_number_of_apis, &u16NumberOfAPIs); proto_item_append_text(item, "": APIs:%u"", u16NumberOfAPIs); conversation = find_conversation(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0); if (conversation == NULL) { conversation = conversation_new(pinfo->num, &pinfo->dl_src, &pinfo->dl_dst, PT_NONE, 0, 0, 0); } station_info = (stationInfo*)conversation_get_proto_data(conversation, proto_pn_dcp); if (station_info != NULL) { station_info->gsdFound = FALSE; station_info->gsdPathLength = FALSE; searchVendorID = station_info->u16Vendor_id; searchDeviceID = station_info->u16Device_id; if(pnio_ps_networkpath[0] != '\0') {    station_info->gsdPathLength = TRUE; if ((dir = g_dir_open(pnio_ps_networkpath, 0, NULL)) != NULL) { while ((filename = g_dir_read_name(dir)) != NULL) { diropen = wmem_strdup_printf(wmem_packet_scope(), ""%s"" G_DIR_SEPARATOR_S ""%s"", pnio_ps_networkpath, filename); fp = ws_fopen(diropen, ""r""); if(fp != NULL) { while(fgets(puffer, MAX_LINE_LENGTH, fp) != NULL) { if((strstr(puffer, vendorIdStr)) != NULL) { memset (convertStr, 0, sizeof(*convertStr)); pch = strstr(puffer, vendorIdStr); if (sscanf(pch, ""VendorID=\""%[^\""]"", convertStr) == 1) { read_vendor_id = (guint32) strtoul (convertStr, NULL, 0); if(read_vendor_id == searchVendorID) { vendorMatch = TRUE;         } } } if((strstr(puffer, deviceIdStr)) != NULL) { memset(convertStr, 0, sizeof(*convertStr)); pch = strstr(puffer, deviceIdStr); if (sscanf(pch, ""DeviceID=\""%[^\""]"", convertStr) == 1) { read_device_id = (guint32)strtoul(convertStr, NULL, 0); if(read_device_id == searchDeviceID) { deviceMatch = TRUE;         } } } } fclose(fp); fp = NULL; if(vendorMatch && deviceMatch) { break;         } else { vendorMatch = FALSE; deviceMatch = FALSE; gsdmlFoundFlag = FALSE; diropen = """";            } } } g_dir_close(dir); } if(vendorMatch && deviceMatch) { gsdmlFoundFlag = TRUE; station_info->gsdFound = TRUE; station_info->gsdLocation = wmem_strdup(wmem_file_scope(), diropen); } else { station_info->gsdLocation = wmem_strdup_printf(wmem_file_scope(), ""%s"" G_DIR_SEPARATOR_S ""*.xml"", pnio_ps_networkpath); } } else { station_info->gsdPathLength = FALSE; } } while (u16NumberOfAPIs--) { api_item = proto_tree_add_item(tree, hf_pn_io_api_tree, tvb, offset, 0, ENC_NA); api_tree = proto_item_add_subtree(api_item, ett_pn_io_api); u32ApiStart = offset; offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep, hf_pn_io_api, &u32Api); offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep, hf_pn_io_slot_nr, &u16SlotNr); offset = dissect_dcerpc_uint32(tvb, offset, pinfo, api_tree, drep, hf_pn_io_module_ident_number, &u32ModuleIdentNumber); offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep, hf_pn_io_module_properties, &u16ModuleProperties); offset = dissect_dcerpc_uint16(tvb, offset, pinfo, api_tree, drep, hf_pn_io_number_of_submodules, &u16NumberOfSubmodules); proto_item_append_text(api_item, "": %u, Slot:0x%x, IdentNumber:0x%x Properties:0x%x Submodules:%u"", u32Api, u16SlotNr, u32ModuleIdentNumber, u16ModuleProperties, u16NumberOfSubmodules); proto_item_append_text(item, "", Submodules:%u"", u16NumberOfSubmodules); while (u16NumberOfSubmodules--) { sub_item = proto_tree_add_item(api_tree, hf_pn_io_submodule_tree, tvb, offset, 0, ENC_NA); sub_tree = proto_item_add_subtree(sub_item, ett_pn_io_submodule); u32SubStart = offset; offset = dissect_dcerpc_uint16(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_subslot_nr, &u16SubslotNr); offset = dissect_dcerpc_uint32(tvb, offset, pinfo, sub_tree, drep, hf_pn_io_submodule_ident_number, &u32SubmoduleIdentNumber); submodule_item = proto_tree_add_item(sub_tree, hf_pn_io_submodule_properties, tvb, offset, 2, ENC_BIG_ENDIAN); submodule_tree = proto_item_add_subtree(submodule_item, ett_pn_io_submodule_properties); dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_reserved, &u16SubmoduleProperties); dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_discard_ioxs, &u16SubmoduleProperties); dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_reduce_output_submodule_data_length, &u16SubmoduleProperties); dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_reduce_input_submodule_data_length, &u16SubmoduleProperties); dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_shared_input, &u16SubmoduleProperties); offset = dissect_dcerpc_uint16(tvb, offset, pinfo, submodule_tree, drep, hf_pn_io_submodule_properties_type, &u16SubmoduleProperties); io_data_object->slotNr = u16SlotNr; io_data_object->subSlotNr = u16SubslotNr; io_data_object->moduleIdentNr = u32ModuleIdentNumber; io_data_object->subModuleIdentNr = u32SubmoduleIdentNumber; io_data_object->discardIOXS = u16SubmoduleProperties & 0x0020; io_data_object->amountInGSDML = 0; io_data_object->fParameterIndexNr = 0; io_data_object->profisafeSupported = FALSE; if (diropen != NULL) { fp = ws_fopen(diropen, ""r""); } if(gsdmlFoundFlag && fp != NULL) { fseek(fp, 0, SEEK_SET); while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) { if((strstr(temp, fParameterStr)) != NULL) { memset (convertStr, 0, sizeof(*convertStr)); pch = strstr(temp, fParameterIndexStr); if (sscanf(pch, ""Index=\""%[^\""]"", convertStr) == 1) { io_data_object->fParameterIndexNr = (guint32)strtoul(convertStr, NULL, 0); } break;     } } memset (temp, 0, sizeof(*temp)); fseek(fp, 0, SEEK_SET);                 while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) { if((strstr(temp, moduleStr)) != NULL) {                          memset (convertStr, 0, sizeof(*convertStr)); pch = strstr(temp, moduleStr);                               if (sscanf(pch, ""ModuleIdentNumber=\""%[^\""]"", convertStr) == 1) {   read_module_id = (guint32)strtoul(convertStr, NULL, 0);      if (read_module_id == io_data_object->moduleIdentNr) { ++io_data_object->amountInGSDML;     while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) { if((strstr(temp, moduleNameInfo)) != NULL) {                     long filePosRecord; if (sscanf(temp, ""%*s TextId=\""%[^\""]"", tmp_moduletext) != 1)         break; filePosRecord = ftell(fp);             if (filePosRecord >= 0) { while (fgets(temp, MAX_LINE_LENGTH, fp) != NULL && io_data_object->amountInGSDML == 1) { if(((strstr(temp, tmp_moduletext)) != NULL) && ((strstr(temp, moduleValueInfo)) != NULL)) { pch = strstr(temp, moduleValueInfo); if (sscanf(pch, ""Value=\""%[^\""]"", io_data_object->moduleNameStr) == 1) break;     } } fseek(fp, filePosRecord, SEEK_SET);     } } if((strstr(temp, subModuleStr)) != NULL) { memset (convertStr, 0, sizeof(*convertStr)); pch = strstr(temp, subModuleStr); if (sscanf(pch, ""SubmoduleIdentNumber=\""%[^\""]"", convertStr) == 1) { read_submodule_id = (guint32) strtoul (convertStr, NULL, 0);     if(read_submodule_id == io_data_object->subModuleIdentNr) { if((strstr(temp, profisafeStr)) != NULL) { io_data_object->profisafeSupported = TRUE;    break; } else {     while(fgets(temp, MAX_LINE_LENGTH, fp) != NULL) { if((strstr(temp, profisafeStr)) != NULL) { io_data_object->profisafeSupported = TRUE; break;     } else if((strstr(temp, "">"")) != NULL) { break; } } } } break;     } } } } } } } fclose(fp); fp = NULL; } switch (u16SubmoduleProperties & 0x03) { case(0x00):  offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object); break; case(0x01):  offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object); break; case(0x02):  offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object); break; case(0x03):  offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object); offset = dissect_DataDescription(tvb, offset, pinfo, sub_tree, drep, io_data_object); break; } proto_item_append_text(sub_item, "": Subslot:0x%x, Ident:0x%x Properties:0x%x"", u16SubslotNr, u32SubmoduleIdentNumber, u16SubmoduleProperties); proto_item_set_len(sub_item, offset - u32SubStart); } proto_item_set_len(api_item, offset - u32ApiStart); } return offset; }"
"int nbd_client_co_flush(BlockDriverState *bs) { NBDClientSession *client = nbd_get_client_session(bs); NBDRequest request = { .type = NBD_CMD_FLUSH }; NBDReply reply; ssize_t ret; if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) { return 0; } request.from = 0; request.len = 0; nbd_coroutine_start(client, &request); ret = nbd_co_send_request(bs, &request, NULL); if (ret < 0) { reply.error = -ret; } else { nbd_co_receive_reply(client, &request, &reply, NULL); } nbd_coroutine_end(client, &request); return -reply.error; }"
"static int protmode_load_seg( enum x86_segment seg, uint16_t sel, bool_t is_ret, struct segment_register *sreg, struct x86_emulate_ctxt *ctxt, const struct x86_emulate_ops *ops) { struct segment_register desctab; struct { uint32_t a, b; } desc; uint8_t dpl, rpl; int cpl = get_cpl(ctxt, ops); uint32_t a_flag = 0x100; int rc, fault_type = EXC_GP; if ( cpl < 0 ) return X86EMUL_UNHANDLEABLE; if ( (sel & 0xfffc) == 0 ) { switch ( seg ) { case x86_seg_ss: if ( mode_64bit() && (cpl != 3) && (cpl == sel) ) default: break; case x86_seg_cs: case x86_seg_tr: goto raise_exn; } memset(sreg, 0, sizeof(*sreg)); sreg->sel = sel; return X86EMUL_OKAY; } if ( !is_x86_user_segment(seg) && (sel & 4) ) goto raise_exn; if ( (rc = ops->read_segment((sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab, ctxt)) ) return rc; if ( ((sel & 0xfff8) + 7) > desctab.limit ) goto raise_exn; if ( (rc = ops->read(x86_seg_none, desctab.base + (sel & 0xfff8), &desc, sizeof(desc), ctxt)) ) return rc; if ( !is_x86_user_segment(seg) ) { if ( desc.b & (1u << 12) ) goto raise_exn; if ( in_longmode(ctxt, ops) ) return X86EMUL_UNHANDLEABLE; } else if ( !(desc.b & (1u << 12)) ) goto raise_exn; dpl = (desc.b >> 13) & 3; rpl = sel & 3; switch ( seg ) { case x86_seg_cs: if ( !(desc.b & (1u<<11)) ) goto raise_exn; if ( is_ret ?  rpl != cpl || (desc.b & (1 << 10) ? dpl > rpl : dpl != rpl) : desc.b & (1 << 10) ? dpl > cpl : rpl > cpl || dpl != cpl ) goto raise_exn; if ( in_longmode(ctxt, ops) && (desc.b & (1 << 21)) && (desc.b & (1 << 22)) ) goto raise_exn; sel = (sel ^ rpl) | cpl; break; case x86_seg_ss: if ( (desc.b & (5u<<9)) != (1u<<9) ) goto raise_exn; if ( (dpl != cpl) || (dpl != rpl) ) goto raise_exn; break; case x86_seg_ldtr: if ( (desc.b & (15u<<8)) != (2u<<8) ) goto raise_exn; a_flag = 0; break; case x86_seg_tr: if ( (desc.b & (15u<<8)) != (9u<<8) ) goto raise_exn; a_flag = 0x200;  break; default: if ( (desc.b & (5u<<9)) == (4u<<9) ) goto raise_exn; if ( ((desc.b & (6u<<9)) != (6u<<9)) && ((dpl < cpl) || (dpl < rpl)) ) goto raise_exn; break; } if ( !(desc.b & (1 << 15)) ) { fault_type = seg != x86_seg_ss ? EXC_NP : EXC_SS; goto raise_exn; } if ( a_flag && !(desc.b & a_flag) ) { uint32_t new_desc_b = desc.b | a_flag; if ( (rc = ops->cmpxchg(x86_seg_none, desctab.base + (sel & 0xfff8) + 4, &desc.b, &new_desc_b, 4, ctxt)) != 0 ) return rc; desc.b = new_desc_b; } sreg->base = (((desc.b <<  0) & 0xff000000u) | ((desc.b << 16) & 0x00ff0000u) | ((desc.a >> 16) & 0x0000ffffu)); sreg->attr.bytes = (((desc.b >>  8) & 0x00ffu) | ((desc.b >> 12) & 0x0f00u)); sreg->limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu); if ( sreg->attr.fields.g ) sreg->limit = (sreg->limit << 12) | 0xfffu; sreg->sel = sel; return X86EMUL_OKAY; raise_exn: if ( ops->inject_hw_exception == NULL ) return X86EMUL_UNHANDLEABLE; if ( (rc = ops->inject_hw_exception(fault_type, sel & 0xfffc, ctxt)) ) return rc; return X86EMUL_EXCEPTION; }"
"static uint8_t exfatfs_get_alloc_bitmap(FATFS_INFO *a_fatfs) { const char *func_name = ""exfatfs_get_alloc_bitmap""; TSK_FS_INFO *fs = &(a_fatfs->fs_info); TSK_DADDR_T current_sector = 0; TSK_DADDR_T last_sector_of_data_area = 0; char *sector_buf = NULL; EXFATFS_ALLOC_BITMAP_DIR_ENTRY *dentry = NULL; uint64_t i = 0; uint64_t first_sector_of_alloc_bitmap = 0; uint64_t alloc_bitmap_length_in_bytes = 0; uint64_t last_sector_of_alloc_bitmap = 0; assert(a_fatfs != NULL); if ((sector_buf = (char*)tsk_malloc(a_fatfs->ssize)) == NULL) { return FATFS_FAIL; } current_sector = a_fatfs->rootsect; last_sector_of_data_area = a_fatfs->firstdatasect + (a_fatfs->clustcnt * a_fatfs->csize) - 1; while (current_sector < last_sector_of_data_area) { ssize_t bytes_read = 0; bytes_read = tsk_fs_read_block(fs, current_sector, sector_buf, a_fatfs->ssize); if (bytes_read != a_fatfs->ssize) { if (bytes_read >= 0) { tsk_error_reset(); tsk_error_set_errno(TSK_ERR_FS_READ); } tsk_error_set_errstr2(""%s: sector: %"" PRIuDADDR, func_name, current_sector); free(sector_buf); return FATFS_FAIL; } for (i = 0; i < a_fatfs->ssize; i += sizeof(FATFS_DENTRY)) { dentry = (EXFATFS_ALLOC_BITMAP_DIR_ENTRY*)&(sector_buf[i]);  if (exfatfs_get_enum_from_type(dentry->entry_type) == EXFATFS_DIR_ENTRY_TYPE_ALLOC_BITMAP) { if (!exfatfs_is_alloc_bitmap_dentry((FATFS_DENTRY*)dentry, FATFS_DATA_UNIT_ALLOC_STATUS_UNKNOWN, a_fatfs)) { continue; } if (~(dentry->flags & 0x01)) { first_sector_of_alloc_bitmap = FATFS_CLUST_2_SECT(a_fatfs, tsk_getu32(fs->endian, dentry->first_cluster_of_bitmap)); alloc_bitmap_length_in_bytes = tsk_getu64(fs->endian, dentry->length_of_alloc_bitmap_in_bytes); last_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap + (roundup(alloc_bitmap_length_in_bytes, a_fatfs->ssize) / a_fatfs->ssize) - 1; if ((first_sector_of_alloc_bitmap >= a_fatfs->firstdatasect) && (last_sector_of_alloc_bitmap <= last_sector_of_data_area) && (alloc_bitmap_length_in_bytes >= (a_fatfs->clustcnt + 7) / 8)) { a_fatfs->EXFATFS_INFO.first_sector_of_alloc_bitmap = first_sector_of_alloc_bitmap;  a_fatfs->EXFATFS_INFO.length_of_alloc_bitmap_in_bytes = alloc_bitmap_length_in_bytes; free(sector_buf); return FATFS_OK; } } } } } free(sector_buf); return FATFS_FAIL; }"
"void RGWFCGX::init_env(CephContext* const cct) { env.init(cct, (char **)fcgx->envp); }"
"static void naludmx_queue_param_set(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 ps_type, s32 ps_id) { GF_List *list = NULL, *alt_list = NULL; GF_NALUFFParam *sl; u32 i, count; u32 crc = gf_crc_32(data, size); if (ctx->codecid==GF_CODECID_HEVC) { switch (ps_type) { case GF_HEVC_NALU_VID_PARAM: if (!ctx->vps) ctx->vps = gf_list_new(); list = ctx->vps; break; case GF_HEVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_HEVC_NALU_PIC_PARAM: list = ctx->pps; break; default: assert(0); return; } } else if (ctx->codecid==GF_CODECID_VVC) { switch (ps_type) { case GF_VVC_NALU_VID_PARAM: if (!ctx->vps) ctx->vps = gf_list_new(); list = ctx->vps; break; case GF_VVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_VVC_NALU_PIC_PARAM: list = ctx->pps; break; case GF_VVC_NALU_DEC_PARAM: if (!ctx->vvc_dci) ctx->vvc_dci = gf_list_new(); list = ctx->vvc_dci; break; case GF_VVC_NALU_APS_PREFIX: if (!ctx->vvc_aps_pre) ctx->vvc_aps_pre = gf_list_new(); list = ctx->vvc_aps_pre; break; default: assert(0); return; } } else { switch (ps_type) { case GF_AVC_NALU_SVC_SUBSEQ_PARAM: case GF_AVC_NALU_SEQ_PARAM: list = ctx->sps; break; case GF_AVC_NALU_PIC_PARAM: list = ctx->pps; alt_list = ctx->pps_svc; break; case GF_AVC_NALU_SEQ_PARAM_EXT: if (!ctx->sps_ext) ctx->sps_ext = gf_list_new(); list = ctx->sps_ext; break; default: assert(0); return; } } sl = NULL; count = gf_list_count(list); for (i=0; i<count; i++) { sl = gf_list_get(list, i); if (sl->id != ps_id) { sl = NULL; continue; } if (sl->crc == crc) return; break; } if (!sl && alt_list) { count = gf_list_count(alt_list); for (i=0; i<count; i++) { sl = gf_list_get(alt_list, i); if (sl->id != ps_id) { sl = NULL; continue; } if (sl->crc == crc) return; break; } } if (sl) { sl->data = gf_realloc(sl->data, size); memcpy(sl->data, data, size); sl->size = size; sl->crc = crc; ctx->ps_modified = GF_TRUE; return; } GF_SAFEALLOC(sl, GF_NALUFFParam); if (!sl) return; sl->data = gf_malloc(sizeof(char) * size); if (!sl->data) { gf_free(sl); return; } memcpy(sl->data, data, size); sl->size = size; sl->id = ps_id; sl->crc = crc; ctx->ps_modified = GF_TRUE; gf_list_add(list, sl); }"
"void Gobby::GotoDialog::on_changed() { g_assert(m_current_view != NULL); GtkTextBuffer* buffer = GTK_TEXT_BUFFER( m_current_view->get_text_buffer()); m_entry_line->set_range(1, gtk_text_buffer_get_line_count(buffer)); }"
"GF_Err mpgviddmx_process(GF_Filter *filter) { GF_MPGVidDmxCtx *ctx = gf_filter_get_udta(filter); GF_FilterPacket *pck, *dst_pck; u64 byte_offset; s64 vosh_start = -1; s64 vosh_end = -1; GF_Err e; char *data; u8 *start; u32 pck_size; s32 remain; if (!ctx->duration.num) mpgviddmx_check_dur(filter, ctx); pck = gf_filter_pid_get_packet(ctx->ipid); if (!pck) { if (gf_filter_pid_is_eos(ctx->ipid)) { mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_TRUE); if (ctx->opid) gf_filter_pid_set_eos(ctx->opid); if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = NULL; return GF_EOS; } return GF_OK; } data = (char *) gf_filter_pck_get_data(pck, &pck_size); byte_offset = gf_filter_pck_get_byte_offset(pck); start = data; remain = pck_size; if (!ctx->resume_from && ctx->timescale) { if (!ctx->notime) { u64 ts = gf_filter_pck_get_cts(pck); if (ts != GF_FILTER_NO_TS) { if (!ctx->cts || !ctx->recompute_cts) ctx->cts = ts; } ts = gf_filter_pck_get_dts(pck); if (ts != GF_FILTER_NO_TS) { if (!ctx->dts || !ctx->recompute_cts) { ctx->dts = ts; } if (!ctx->prev_dts) ctx->prev_dts = ts; else if (ctx->prev_dts != ts) { u64 diff = ts; diff -= ctx->prev_dts; if (!ctx->cur_fps.den) ctx->cur_fps.den = (u32) diff; else if (ctx->cur_fps.den > diff) ctx->cur_fps.den = (u32) diff; ctx->prev_dts = ts; } } } gf_filter_pck_get_framing(pck, &ctx->input_is_au_start, &ctx->input_is_au_end); ctx->input_is_au_end = GF_FALSE; if (ctx->recompute_cts) ctx->input_is_au_start = GF_FALSE; if (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck); ctx->src_pck = pck; gf_filter_pck_ref_props(&ctx->src_pck); } if (!ctx->resume_from && ctx->hdr_store_size) { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size) { ctx->hdr_store_alloc = ctx->hdr_store_size + pck_size; ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memcpy(ctx->hdr_store + ctx->hdr_store_size, data, sizeof(char)*pck_size); if (byte_offset != GF_FILTER_NO_BO) { if (byte_offset >= ctx->hdr_store_size) byte_offset -= ctx->hdr_store_size; else byte_offset = GF_FILTER_NO_BO; } ctx->hdr_store_size += pck_size; start = data = ctx->hdr_store; remain = pck_size = ctx->hdr_store_size; } if (ctx->resume_from) { if (gf_filter_pid_would_block(ctx->opid)) return GF_OK; if (ctx->hdr_store_size) { assert(ctx->resume_from <= ctx->hdr_store_size); start = data = ctx->hdr_store + ctx->resume_from; remain = pck_size = ctx->hdr_store_size - ctx->resume_from; } else { assert(remain >= (s32) ctx->resume_from); start += ctx->resume_from; remain -= ctx->resume_from; } ctx->resume_from = 0; } if (!ctx->bs) { ctx->bs = gf_bs_new(start, remain, GF_BITSTREAM_READ); } else { gf_bs_reassign_buffer(ctx->bs, start, remain); } if (!ctx->vparser) { ctx->vparser = gf_m4v_parser_bs_new(ctx->bs, ctx->is_mpg12); } while (remain) { Bool full_frame; u8 *pck_data; s32 current; u8 sc_type, forced_sc_type=0; Bool sc_type_forced = GF_FALSE; Bool skip_pck = GF_FALSE; u8 ftype; u32 tinc; u64 size=0; u64 fstart=0; Bool is_coded; u32 bytes_from_store = 0; u32 hdr_offset = 0; Bool copy_last_bytes = GF_FALSE; if (remain<5) { memcpy(ctx->hdr_store, start, remain); ctx->bytes_in_header = remain; break; } current = -1; if (ctx->bytes_in_header) { memcpy(ctx->hdr_store + ctx->bytes_in_header, start, MIN_HDR_STORE - ctx->bytes_in_header); current = mpgviddmx_next_start_code(ctx->hdr_store, MIN_HDR_STORE); if ((current<0) || (current >= (s32) ctx->bytes_in_header) )  { if (ctx->opid) { dst_pck = gf_filter_pck_new_alloc(ctx->opid, ctx->bytes_in_header, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_NONE); memcpy(pck_data, ctx->hdr_store, ctx->bytes_in_header); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - ctx->bytes_in_header); } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } if (current<0) current = -1; else current -= ctx->bytes_in_header; ctx->bytes_in_header = 0; } else { hdr_offset = 4 - ctx->bytes_in_header + current; bytes_from_store = ctx->bytes_in_header; ctx->bytes_in_header = 0; if (!hdr_offset) { forced_sc_type = ctx->hdr_store[current+3]; } else { forced_sc_type = start[hdr_offset-1]; } sc_type_forced = GF_TRUE; } } if (current == -1) { current = mpgviddmx_next_start_code(start, remain); if (current<0) { u8 b3, b2, b1; if (! ctx->frame_started) { GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[MPGVid] no start code in block and no frame started, discarding data\n"" )); break; } size = remain; b3 = start[remain-3]; b2 = start[remain-2]; b1 = start[remain-1]; if (!b1 || !b2 || !b3) { copy_last_bytes = GF_TRUE; assert(size >= 3); size -= 3; ctx->bytes_in_header = 3; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(pck_data, start, (size_t) size); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); if (copy_last_bytes) { memcpy(ctx->hdr_store, start+remain-3, 3); } break; } } assert(current>=0); if ((vosh_start>=0) && current) { assert(remain>=current); start += current; remain -= current; current = 0; } if (!ctx->opid && current) { assert(remain>=current); start += current; remain -= current; current = 0; } if (current>0) { dst_pck = gf_filter_pck_new_alloc(ctx->opid, current, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); if (bytes_from_store) { if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); } assert(bytes_from_store>=(u32) current); bytes_from_store -= current; memcpy(pck_data, ctx->hdr_store, current); } else { if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); } memcpy(pck_data, start, current); assert(remain>=current); start += current; remain -= current; current = 0; } gf_filter_pck_set_carousel_version(dst_pck, 1); mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } ctx->trash_trailer = GF_FALSE; if (remain<5) { memcpy(ctx->hdr_store, start, remain); ctx->bytes_in_header = remain; break; } if (sc_type_forced) { gf_bs_reassign_buffer(ctx->bs, start + hdr_offset, remain - hdr_offset); sc_type = forced_sc_type; } else { gf_bs_reassign_buffer(ctx->bs, start, remain); gf_bs_read_int(ctx->bs, 24); sc_type = gf_bs_read_int(ctx->bs, 8); } if (ctx->is_mpg12) { switch (sc_type) { case M2V_SEQ_START_CODE: case M2V_EXT_START_CODE: gf_bs_reassign_buffer(ctx->bs, start, remain); e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); if (e==GF_EOS) { if (vosh_start<0) vosh_start = 0; if (data == ctx->hdr_store) { memmove(ctx->hdr_store, start, remain); ctx->hdr_store_size = remain; } else { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - vosh_start); ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); ctx->hdr_store_size += pck_size - (u32) vosh_start; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; } else if (e != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); } else if (ctx->dsi.width && ctx->dsi.height) { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); } break; case M2V_PIC_START_CODE: break; default: break; } } else { u8 PL; switch (sc_type) { case M4V_VOS_START_CODE: ctx->dsi.VideoPL = (u8) gf_bs_read_u8(ctx->bs); vosh_start = start - (u8 *)data; skip_pck = GF_TRUE; assert(remain>=5); start += 5; remain -= 5; break; case M4V_VOL_START_CODE: gf_bs_reassign_buffer(ctx->bs, start, remain); PL = ctx->dsi.VideoPL; e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); ctx->dsi.VideoPL = PL; if (e==GF_EOS) { if (vosh_start<0) vosh_start = 0; if (data == ctx->hdr_store) { memmove(ctx->hdr_store, start, remain); ctx->hdr_store_size = remain; } else { if (ctx->hdr_store_alloc < ctx->hdr_store_size + pck_size - vosh_start) { ctx->hdr_store_alloc = (u32) (ctx->hdr_store_size + pck_size - (u32) vosh_start); ctx->hdr_store = gf_realloc(ctx->hdr_store, sizeof(char)*ctx->hdr_store_alloc); } memmove(ctx->hdr_store + ctx->hdr_store_size, data + vosh_start, (size_t) (pck_size - vosh_start) ); ctx->hdr_store_size += pck_size - (u32) vosh_start; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; } else if (e != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[MPGVid] Failed to parse VOS header: %s\n"", gf_error_to_string(e) )); } else { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); skip_pck = GF_TRUE; assert(remain>=(s32) obj_size); start += obj_size; remain -= obj_size; } break; case M4V_VOP_START_CODE: case M4V_GOV_START_CODE: break; case M4V_VO_START_CODE: case M4V_VISOBJ_START_CODE: default: if (vosh_start>=0) { skip_pck = GF_TRUE; assert(remain>=4); start += 4; remain -= 4; } else if (!ctx->width) { gf_bs_reassign_buffer(ctx->bs, start, remain); PL = ctx->dsi.VideoPL; e = gf_m4v_parse_config(ctx->vparser, &ctx->dsi); if (ctx->dsi.width) { u32 obj_size = (u32) gf_m4v_get_object_start(ctx->vparser); if (vosh_start<0) vosh_start = 0; vosh_end = start - (u8 *)data + obj_size; vosh_end -= vosh_start; mpgviddmx_check_pid(filter, ctx,(u32)  vosh_end, data+vosh_start); skip_pck = GF_TRUE; assert(remain>=(s32) obj_size); start += obj_size; remain -= obj_size; } } break; } } if (skip_pck) { continue; } if (!ctx->opid) { assert(remain>=4); start += 4; remain -= 4; continue; } if (!ctx->is_playing) { ctx->resume_from = (u32) ((char *)start -  (char *)data); return GF_OK; } ctx->hdr_store_size = 0; if (ctx->in_seek) { u64 nb_frames_at_seek = (u64) (ctx->start_range * ctx->cur_fps.num); if (ctx->cts + ctx->cur_fps.den >= nb_frames_at_seek) { ctx->in_seek = GF_FALSE; } } if (remain<5) continue; gf_m4v_parser_reset(ctx->vparser, sc_type_forced ? forced_sc_type + 1 : 0); size = 0; e = gf_m4v_parse_frame(ctx->vparser, &ctx->dsi, &ftype, &tinc, &size, &fstart, &is_coded); if (ctx->is_mpg12 && fstart && (fstart<remain)) { if (sc_type_forced) { fstart += 4; size-=4; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) fstart, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); memcpy(pck_data, start, (size_t) fstart); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_set_cts(dst_pck, GF_FILTER_NO_TS); gf_filter_pck_set_dts(dst_pck, GF_FILTER_NO_TS); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset); byte_offset+=fstart; } mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); start += fstart; remain -= (s32) fstart; } else if (fstart && (fstart + size <= remain)) { if (sc_type_forced) { fstart += 4; size-=4; } size += fstart; } if (bytes_from_store) { size += bytes_from_store + hdr_offset; } if ((e == GF_EOS) && !ctx->input_is_au_end) { u8 b3 = start[remain-3]; u8 b2 = start[remain-2]; u8 b1 = start[remain-1]; if (!b1 || !b2 || !b3) { copy_last_bytes = GF_TRUE; assert(size >= 3); size -= 3; ctx->bytes_in_header = 3; } full_frame = GF_FALSE; } else { full_frame = GF_TRUE; } if (ftype) { if (!is_coded) { if ((ctx->forced_packed && ctx->b_frames) || ctx->vfr ) { if (ctx->vfr) { ctx->is_vfr = GF_TRUE; mpgviddmx_update_time(ctx); } else { ctx->is_packed = GF_TRUE; } if (bytes_from_store) size-= bytes_from_store + hdr_offset; assert(remain>=size); start += size; remain -= (s32) size; ctx->trash_trailer = full_frame ? GF_FALSE : GF_TRUE; continue; } } if (ftype==3) { ctx->b_frames++; ctx->nb_b++; } else { mpgviddmx_enqueue_or_dispatch(ctx, NULL, GF_TRUE, GF_FALSE); ctx->last_ref_cts = ctx->cts; if (ctx->max_b < ctx->b_frames) ctx->max_b = ctx->b_frames; ctx->b_frames = 0; if (ftype==2) ctx->nb_p++; else ctx->nb_i++; } ctx->nb_frames++; } else { full_frame = GF_FALSE; } dst_pck = gf_filter_pck_new_alloc(ctx->opid, (u32) size, &pck_data); if (!dst_pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, dst_pck); if (bytes_from_store) { memcpy(pck_data, ctx->hdr_store+current, bytes_from_store); assert(size >= bytes_from_store); size -= bytes_from_store; if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset - bytes_from_store); } memcpy(pck_data + bytes_from_store, start, (size_t) size); } else { memcpy(pck_data, start, (size_t) size); if (byte_offset != GF_FILTER_NO_BO) { gf_filter_pck_set_byte_offset(dst_pck, byte_offset + start - (u8 *) data); } } if (ftype) { assert(pck_data[0] == 0); assert(pck_data[1] == 0); assert(pck_data[2] == 1); gf_filter_pck_set_framing(dst_pck, GF_TRUE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE); gf_filter_pck_set_cts(dst_pck, ctx->cts); gf_filter_pck_set_dts(dst_pck, ctx->dts); if (ctx->input_is_au_start) { ctx->input_is_au_start = GF_FALSE; } else { gf_filter_pck_set_carousel_version(dst_pck, 1); } gf_filter_pck_set_sap(dst_pck, (ftype==1) ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE); if (ctx->cur_fps.den > 0) gf_filter_pck_set_duration(dst_pck, ctx->cur_fps.den); if (ctx->in_seek) gf_filter_pck_set_seek_flag(dst_pck, GF_TRUE); ctx->frame_started = GF_TRUE; mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); mpgviddmx_update_time(ctx); } else { gf_filter_pck_set_framing(dst_pck, GF_FALSE, (full_frame || ctx->input_is_au_end) ? GF_TRUE : GF_FALSE); mpgviddmx_enqueue_or_dispatch(ctx, dst_pck, GF_FALSE, GF_FALSE); } if (!full_frame) { if (copy_last_bytes) { memcpy(ctx->hdr_store, start+remain-3, 3); } break; } assert(remain>=size); start += size; remain -= (s32) size; } gf_filter_pid_drop_packet(ctx->ipid); return GF_OK; }"
"static Jsi_RC jsi_ArrayFindSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))  return Jsi_LogError(""expected array""); Jsi_Obj *obj; uint i; Jsi_RC rc = JSI_OK; Jsi_Value *func, *vpargs, *sthis = Jsi_ValueArrayIndex(interp, args, 1); func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func))  return Jsi_LogError(""expected function""); Jsi_Value *nthis = NULL; if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; Jsi_ObjListifyArray(interp, obj); int fval = 0; Jsi_Value *nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[3]; Jsi_Func *fptr = func->d.obj->d.fobj->func; int maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); if (rc != JSI_OK) break; fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if (op == 3) { if (!fval) break; } else if (fval) break; } if (rc == JSI_OK) { if (op == 1 && fval)             Jsi_ValueCopy(interp, *ret, obj->arr[i]);  else if (op == 2 || op == 3)             Jsi_ValueMakeBool(interp, ret, fval); else if (op == 4) Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)(fval?(int)i:-1)); } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); return rc; }"
"void SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill) { ShapeRecord record; int idx; if ( shape->isEnded || shape->isMorph ) return; if(fill == NOFILL) { record = addStyleRecord(shape); record.record.stateChange->leftFill = 0; record.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG; return; } idx = getFillIdx(shape, fill); if(idx == 0) { SWFFillStyle_addDependency(fill, (SWFCharacter)shape); if(addFillStyle(shape, fill) < 0) return; idx = getFillIdx(shape, fill); } record = addStyleRecord(shape); record.record.stateChange->leftFill = idx; record.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG; }"
"void setup_new_exec(struct linux_binprm * bprm) { bprm->secureexec |= bprm->cap_elevated; if (bprm->secureexec) { current->pdeath_signal = 0; if (bprm->rlim_stack.rlim_cur > _STK_LIM) bprm->rlim_stack.rlim_cur = _STK_LIM; } arch_pick_mmap_layout(current->mm, &bprm->rlim_stack); current->sas_ss_sp = current->sas_ss_size = 0; if (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP || !(uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))) set_dumpable(current->mm, suid_dumpable); else set_dumpable(current->mm, SUID_DUMP_USER); arch_setup_new_exec(); perf_event_exec(); __set_task_comm(current, kbasename(bprm->filename), true); current->mm->task_size = TASK_SIZE; current->self_exec_id++; flush_signal_handlers(current, 0); }"
"ShellLoginDialog::ShellLoginDialog( net::AuthChallengeInfo* auth_info, net::URLRequest* request) : auth_info_(auth_info), request_(request) { DCHECK_CURRENTLY_ON(BrowserThread::IO); BrowserThread::PostTask( BrowserThread::UI, FROM_HERE, base::Bind(&ShellLoginDialog::PrepDialog, this, base::ASCIIToUTF16(auth_info->challenger.ToString()), base::UTF8ToUTF16(auth_info->realm))); }"
"static void build_read_multi_rsp(tGATT_SR_CMD* p_cmd, uint16_t mtu) { uint16_t ii; size_t total_len, len; uint8_t* p; bool is_overflow = false; len = sizeof(BT_HDR) + L2CAP_MIN_OFFSET + mtu; BT_HDR* p_buf = (BT_HDR*)osi_calloc(len); p_buf->offset = L2CAP_MIN_OFFSET; p = (uint8_t*)(p_buf + 1) + p_buf->offset; if (p_cmd->multi_req.variable_len) *p++ = GATT_RSP_READ_MULTI_VAR; else *p++ = GATT_RSP_READ_MULTI; p_buf->len = 1; list_t* list = NULL; const list_node_t* node = NULL; if (!fixed_queue_is_empty(p_cmd->multi_rsp_q)) list = fixed_queue_get_list(p_cmd->multi_rsp_q); for (ii = 0; ii < p_cmd->multi_req.num_handles; ii++) { tGATTS_RSP* p_rsp = NULL; if (list != NULL) { if (ii == 0) node = list_begin(list); else node = list_next(node); if (node != list_end(list)) p_rsp = (tGATTS_RSP*)list_node(node); } if (p_rsp != NULL) { total_len = (p_buf->len + p_rsp->attr_value.len); if (p_cmd->multi_req.variable_len) { total_len += 2; } if (total_len > mtu) { len = p_rsp->attr_value.len - (total_len - mtu); is_overflow = true; VLOG(1) << StringPrintf( ""multi read overflow available len=%zu val_len=%d"", len, p_rsp->attr_value.len); } else { len = p_rsp->attr_value.len; } if (p_cmd->multi_req.variable_len) { UINT16_TO_STREAM(p, len); p_buf->len += 2; } if (p_rsp->attr_value.handle == p_cmd->multi_req.handles[ii]) { if (p_buf->len + len <= UINT16_MAX) { memcpy(p, p_rsp->attr_value.value, len); if (!is_overflow) p += len; p_buf->len += len; } else { p_cmd->status = GATT_NOT_FOUND; break; } } else { p_cmd->status = GATT_NOT_FOUND; break; } if (is_overflow) break; } else { p_cmd->status = GATT_NOT_FOUND; break; } }  if (p_buf->len == 0) { LOG(ERROR) << __func__ << "" nothing found!!""; p_cmd->status = GATT_NOT_FOUND; osi_free(p_buf); VLOG(1) << __func__ << ""osi_free(p_buf)""; } else if (p_cmd->p_rsp_msg != NULL) { osi_free(p_buf); } else { p_cmd->p_rsp_msg = p_buf; } }"
"gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor) { const int angle_rounded = (int)floor(angle * 100); if (bgcolor < 0) { return NULL; } if (src->trueColor == 0) { if (bgcolor >= 0) { bgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]); } gdImagePaletteToTrueColor(src); } switch (angle_rounded) { case -27000: case   9000: return gdImageRotate90(src, 0); case -18000: case  18000: return gdImageRotate180(src, 0); case -9000: case 27000: return gdImageRotate270(src, 0); } if (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) { return NULL; } switch (src->interpolation_id) { case GD_NEAREST_NEIGHBOUR: return gdImageRotateNearestNeighbour(src, angle, bgcolor); break; case GD_BILINEAR_FIXED: return gdImageRotateBilinear(src, angle, bgcolor); break; case GD_BICUBIC_FIXED: return gdImageRotateBicubicFixed(src, angle, bgcolor); break; default: return gdImageRotateGeneric(src, angle, bgcolor); } return NULL; }"
"static inline unsigned int xt_write_recseq_begin(void) { unsigned int addend; addend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1; __this_cpu_add(xt_recseq.sequence, addend); smp_wmb(); return addend; }"
"static int nfp_abm_u32_knode_replace(struct nfp_abm_link *alink, struct tc_cls_u32_knode *knode, __be16 proto, struct netlink_ext_ack *extack) { struct nfp_abm_u32_match *match = NULL, *iter; unsigned int tos_off; u8 mask, val; int err; if (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack)) { err = -EOPNOTSUPP; goto err_delete; } tos_off = proto == htons(ETH_P_IP) ? 16 : 20; val = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff; mask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff; list_for_each_entry(iter, &alink->dscp_map, list) { u32 cmask; if (iter->handle == knode->handle) { match = iter; continue; } cmask = iter->mask & mask; if ((iter->val & cmask) == (val & cmask) && iter->band != knode->res->classid) { NL_SET_ERR_MSG_MOD(extack, ""conflict with already offloaded filter""); err = -EOPNOTSUPP; goto err_delete; } } if (!match) { match = kzalloc(sizeof(*match), GFP_KERNEL); if (!match) { err = -ENOMEM; goto err_delete; } list_add(&match->list, &alink->dscp_map); } match->handle = knode->handle; match->band = knode->res->classid; match->mask = mask; match->val = val; err = nfp_abm_update_band_map(alink); if (err) goto err_delete; return 0; err_delete: nfp_abm_u32_knode_delete(alink, knode); return err; }"
"void Jp2Image::encodeJp2Header(const DataBuf& boxBuf,DataBuf& outBuf) { DataBuf output(boxBuf.size_ + iccProfile_.size_ + 100);         int     outlen = sizeof(Jp2BoxHeader) ;         int      inlen = sizeof(Jp2BoxHeader) ;         Jp2BoxHeader* pBox   = (Jp2BoxHeader*) boxBuf.pData_; int32_t       length = getLong((byte*)&pBox->length, bigEndian); int32_t       count  = sizeof (Jp2BoxHeader); char*         p      = (char*) boxBuf.pData_; bool          bWroteColor = false ; while ( count < length || !bWroteColor ) { Jp2BoxHeader* pSubBox = (Jp2BoxHeader*) (p+count) ; Jp2BoxHeader   subBox = *pSubBox ; Jp2BoxHeader   newBox =  subBox; if ( count < length ) { subBox.length = getLong((byte*)&subBox.length, bigEndian); subBox.type   = getLong((byte*)&subBox.type  , bigEndian); #ifdef DEBUG std::cout << ""Jp2Image::encodeJp2Header subbox: ""<< toAscii(subBox.type) << "" length = "" << subBox.length << std::endl; #endif count        += subBox.length; newBox.type   = subBox.type; } else { subBox.length=0; newBox.type = kJp2BoxTypeColorHeader; count = length; } int32_t newlen = subBox.length; if ( newBox.type == kJp2BoxTypeColorHeader ) { bWroteColor = true ; if ( ! iccProfileDefined() ) { const char* pad   = ""\x01\x00\x00\x00\x00\x00\x10\x00\x00\x05\x1cuuid""; uint32_t    psize = 15; ul2Data((byte*)&newBox.length,psize      ,bigEndian); ul2Data((byte*)&newBox.type  ,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)); ::memcpy(output.pData_+outlen+sizeof(newBox)      ,pad                ,psize         ); newlen = psize ; } else { const char* pad   = ""\0x02\x00\x00""; uint32_t    psize = 3; ul2Data((byte*)&newBox.length,psize+iccProfile_.size_,bigEndian); ul2Data((byte*)&newBox.type,newBox.type,bigEndian); ::memcpy(output.pData_+outlen                     ,&newBox            ,sizeof(newBox)  ); ::memcpy(output.pData_+outlen+sizeof(newBox)      , pad               ,psize           ); ::memcpy(output.pData_+outlen+sizeof(newBox)+psize,iccProfile_.pData_,iccProfile_.size_); newlen = psize + iccProfile_.size_; } } else { ::memcpy(output.pData_+outlen,boxBuf.pData_+inlen,subBox.length); } outlen += newlen; inlen  += subBox.length; } outBuf.alloc(outlen); ::memcpy(outBuf.pData_,output.pData_,outlen); pBox   = (Jp2BoxHeader*) outBuf.pData_; ul2Data((byte*)&pBox->type,kJp2BoxTypeJp2Header,bigEndian); ul2Data((byte*)&pBox->length,outlen,bigEndian); }"
"static void gvs_fixed_sized_maybe_serialise (GVariantSerialised        value, GVariantSerialisedFiller  gvs_filler, const gpointer           *children, gsize                     n_children) { if (n_children) { GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 }; gvs_filler (&child, children[0]); } }"
"void pjsua_init_tpselector(pjsua_transport_id tp_id, pjsip_tpselector *sel) { pjsua_transport_data *tpdata; unsigned flag; pj_bzero(sel, sizeof(*sel)); if (tp_id == PJSUA_INVALID_ID) return; pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata)); tpdata = &pjsua_var.tpdata[tp_id]; flag = pjsip_transport_get_flag_from_type(tpdata->type); if (flag & PJSIP_TRANSPORT_DATAGRAM) { sel->type = PJSIP_TPSELECTOR_TRANSPORT; sel->u.transport = tpdata->data.tp; } else { sel->type = PJSIP_TPSELECTOR_LISTENER; sel->u.listener = tpdata->data.factory; } }"
"static int get_info(struct net *net, void __user *user, const int *len) { char name[XT_TABLE_MAXNAMELEN]; struct xt_table *t; int ret; if (*len != sizeof(struct arpt_getinfo)) return -EINVAL; if (copy_from_user(name, user, sizeof(name)) != 0) return -EFAULT; name[XT_TABLE_MAXNAMELEN-1] = '\0'; #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_lock(NFPROTO_ARP); #endif t = xt_request_find_table_lock(net, NFPROTO_ARP, name); if (!IS_ERR(t)) { struct arpt_getinfo info; const struct xt_table_info *private = t->private; #ifdef CONFIG_COMPAT struct xt_table_info tmp; if (in_compat_syscall()) { ret = compat_table_info(private, &tmp); xt_compat_flush_offsets(NFPROTO_ARP); private = &tmp; } #endif memset(&info, 0, sizeof(info)); info.valid_hooks = t->valid_hooks; memcpy(info.hook_entry, private->hook_entry, sizeof(info.hook_entry)); memcpy(info.underflow, private->underflow, sizeof(info.underflow)); info.num_entries = private->number; info.size = private->size; strcpy(info.name, name); if (copy_to_user(user, &info, *len) != 0) ret = -EFAULT; else ret = 0; xt_table_unlock(t); module_put(t->me); } else ret = PTR_ERR(t); #ifdef CONFIG_COMPAT if (in_compat_syscall()) xt_compat_unlock(NFPROTO_ARP); #endif return ret; }"
"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { const auto* params = reinterpret_cast<const TfLiteGatherParams*>(node->builtin_data); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input)); const TfLiteTensor* positions; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputPositions, &positions)); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); if (positions->type == kTfLiteInt32) { switch (input->type) { case kTfLiteFloat32: return Gather<float, int32_t>(*params, input, positions, output); case kTfLiteUInt8: return Gather<uint8_t, int32_t>(*params, input, positions, output); case kTfLiteInt8: return Gather<int8_t, int32_t>(*params, input, positions, output); case kTfLiteInt16: return Gather<int16_t, int32_t>(*params, input, positions, output); case kTfLiteInt32: return Gather<int32_t, int32_t>(*params, input, positions, output); case kTfLiteInt64: return Gather<int64_t, int32_t>(*params, input, positions, output); case kTfLiteBool: return Gather<bool, int32_t>(*params, input, positions, output); case kTfLiteString: return GatherStrings<int32_t>(context, input, positions, output); default: context->ReportError(context, ""Type '%s' is not supported by gather."", TfLiteTypeGetName(input->type)); return kTfLiteError; } } if (positions->type == kTfLiteInt64) { switch (input->type) { case kTfLiteFloat32: return Gather<float, int64_t>(*params, input, positions, output); case kTfLiteUInt8: return Gather<uint8_t, int64_t>(*params, input, positions, output); case kTfLiteInt8: return Gather<int8_t, int64_t>(*params, input, positions, output); case kTfLiteInt16: return Gather<int16_t, int64_t>(*params, input, positions, output); case kTfLiteInt32: return Gather<int32_t, int64_t>(*params, input, positions, output); case kTfLiteInt64: return Gather<int64_t, int64_t>(*params, input, positions, output); case kTfLiteBool: return Gather<bool, int64_t>(*params, input, positions, output); case kTfLiteString: return GatherStrings<int64_t>(context, input, positions, output); default: context->ReportError(context, ""Type '%s' is not supported by gather."", TfLiteTypeGetName(input->type)); return kTfLiteError; } } context->ReportError(context, ""Positions of type '%s' are not supported by gather."", TfLiteTypeGetName(positions->type)); return kTfLiteError; }"
"int sc_pkcs15_decode_prkdf_entry(struct sc_pkcs15_card *p15card, struct sc_pkcs15_object *obj, const u8 ** buf, size_t *buflen) { sc_context_t *ctx = p15card->card->ctx; struct sc_pkcs15_prkey_info info; int r, i, gostr3410_params[3]; struct sc_pkcs15_keyinfo_gostparams *keyinfo_gostparams; size_t usage_len = sizeof(info.usage); size_t af_len = sizeof(info.access_flags); struct sc_asn1_entry asn1_com_key_attr[C_ASN1_COM_KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_com_prkey_attr[C_ASN1_COM_PRKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_rsakey_attr[C_ASN1_RSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_rsa_attr[C_ASN1_PRK_RSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_attr[C_ASN1_DSAKEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_dsa_attr[C_ASN1_PRK_DSA_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_i_p_attr[C_ASN1_DSAKEY_I_P_ATTR_SIZE]; struct sc_asn1_entry asn1_dsakey_value_attr[C_ASN1_DSAKEY_VALUE_ATTR_SIZE]; struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE]; struct sc_asn1_entry asn1_prk_gostr3410_attr[C_ASN1_PRK_GOSTR3410_ATTR_SIZE]; struct sc_asn1_entry asn1_ecckey_attr[C_ASN1_ECCKEY_ATTR]; struct sc_asn1_entry asn1_prk_ecc_attr[C_ASN1_PRK_ECC_ATTR]; struct sc_asn1_entry asn1_prkey[C_ASN1_PRKEY_SIZE]; struct sc_asn1_entry asn1_supported_algorithms[C_ASN1_SUPPORTED_ALGORITHMS_SIZE]; struct sc_asn1_pkcs15_object rsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_rsa_attr}; struct sc_asn1_pkcs15_object dsa_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_dsa_attr}; struct sc_asn1_pkcs15_object gostr3410_prkey_obj = {obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_gostr3410_attr}; struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj, asn1_com_key_attr, asn1_com_prkey_attr, asn1_prk_ecc_attr }; sc_copy_asn1_entry(c_asn1_prkey, asn1_prkey); sc_copy_asn1_entry(c_asn1_supported_algorithms, asn1_supported_algorithms); sc_copy_asn1_entry(c_asn1_prk_rsa_attr, asn1_prk_rsa_attr); sc_copy_asn1_entry(c_asn1_rsakey_attr, asn1_rsakey_attr); sc_copy_asn1_entry(c_asn1_prk_dsa_attr, asn1_prk_dsa_attr); sc_copy_asn1_entry(c_asn1_dsakey_attr, asn1_dsakey_attr); sc_copy_asn1_entry(c_asn1_dsakey_value_attr, asn1_dsakey_value_attr); sc_copy_asn1_entry(c_asn1_dsakey_i_p_attr, asn1_dsakey_i_p_attr); sc_copy_asn1_entry(c_asn1_prk_gostr3410_attr, asn1_prk_gostr3410_attr); sc_copy_asn1_entry(c_asn1_gostr3410key_attr, asn1_gostr3410key_attr); sc_copy_asn1_entry(c_asn1_prk_ecc_attr, asn1_prk_ecc_attr); sc_copy_asn1_entry(c_asn1_ecckey_attr, asn1_ecckey_attr); sc_copy_asn1_entry(c_asn1_com_prkey_attr, asn1_com_prkey_attr); sc_copy_asn1_entry(c_asn1_com_key_attr, asn1_com_key_attr); sc_format_asn1_entry(asn1_prkey + 0, &rsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 1, &ecc_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 2, &dsa_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prkey + 3, &gostr3410_prkey_obj, NULL, 0); sc_format_asn1_entry(asn1_prk_rsa_attr + 0, asn1_rsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_dsa_attr + 0, asn1_dsakey_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_gostr3410_attr + 0, asn1_gostr3410key_attr, NULL, 0); sc_format_asn1_entry(asn1_prk_ecc_attr + 0, asn1_ecckey_attr, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_rsakey_attr + 1, &info.modulus_length, NULL, 0); sc_format_asn1_entry(asn1_dsakey_attr + 0, asn1_dsakey_value_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_dsakey_value_attr + 1, asn1_dsakey_i_p_attr, NULL, 0); sc_format_asn1_entry(asn1_dsakey_i_p_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 1, &gostr3410_params[0], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 2, &gostr3410_params[1], NULL, 0); sc_format_asn1_entry(asn1_gostr3410key_attr + 3, &gostr3410_params[2], NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 0, &info.path, NULL, 0); sc_format_asn1_entry(asn1_ecckey_attr + 1, &info.field_length, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 0, &info.id, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 1, &info.usage, &usage_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 2, &info.native, NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 3, &info.access_flags, &af_len, 0); sc_format_asn1_entry(asn1_com_key_attr + 4, &info.key_reference, NULL, 0); for (i=0; i<SC_MAX_SUPPORTED_ALGORITHMS && (asn1_supported_algorithms + i)->name; i++) sc_format_asn1_entry(asn1_supported_algorithms + i, &info.algo_refs[i], NULL, 0); sc_format_asn1_entry(asn1_com_key_attr + 5, asn1_supported_algorithms, NULL, 0); sc_format_asn1_entry(asn1_com_prkey_attr + 0, &info.subject.value, &info.subject.len, 0); memset(&info, 0, sizeof(info)); info.key_reference = -1; info.native = 1; memset(gostr3410_params, 0, sizeof(gostr3410_params)); r = sc_asn1_decode_choice(ctx, asn1_prkey, *buf, *buflen, buf, buflen); if (r < 0) { if (asn1_com_prkey_attr->flags & SC_ASN1_PRESENT && asn1_com_prkey_attr[0].flags & SC_ASN1_PRESENT) { free(asn1_com_prkey_attr[0].parm); } } if (r == SC_ERROR_ASN1_END_OF_CONTENTS) return r; LOG_TEST_RET(ctx, r, ""PrKey DF ASN.1 decoding failed""); if (asn1_prkey[0].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_RSA; } else if (asn1_prkey[1].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_EC; } else if (asn1_prkey[2].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_DSA; if (asn1_dsakey_i_p_attr[0].flags & SC_ASN1_PRESENT) info.path.type = SC_PATH_TYPE_PATH_PROT; } else if (asn1_prkey[3].flags & SC_ASN1_PRESENT) { obj->type = SC_PKCS15_TYPE_PRKEY_GOSTR3410; assert(info.modulus_length == 0); info.modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE; assert(info.params.len == 0); info.params.len = sizeof(struct sc_pkcs15_keyinfo_gostparams); info.params.data = malloc(info.params.len); if (info.params.data == NULL) LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); assert(sizeof(*keyinfo_gostparams) == info.params.len); keyinfo_gostparams = info.params.data; keyinfo_gostparams->gostr3410 = gostr3410_params[0]; keyinfo_gostparams->gostr3411 = gostr3410_params[1]; keyinfo_gostparams->gost28147 = gostr3410_params[2]; } else { sc_log(ctx, ""Neither RSA or DSA or GOSTR3410 or ECC key in PrKDF entry.""); LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ASN1_OBJECT); } if (!p15card->app || !p15card->app->ddo.aid.len)   { r = sc_pkcs15_make_absolute_path(&p15card->file_app->path, &info.path); if (r < 0) { sc_pkcs15_free_key_params(&info.params); return r; } } else   { info.path.aid = p15card->app->ddo.aid; } sc_log(ctx, ""PrivKey path '%s'"", sc_print_path(&info.path)); if (info.key_reference < -1) info.key_reference += 256; if ((obj->flags & SC_PKCS15_CO_FLAG_PRIVATE) && (obj->auth_id.len == 0)) { sc_log(ctx, ""Private key %s has no auth ID - checking AccessControlRules"", sc_pkcs15_print_id(&info.id)); for (i = 0; i < SC_PKCS15_MAX_ACCESS_RULES; i++) { if (obj->access_rules[i].access_mode & (SC_PKCS15_ACCESS_RULE_MODE_EXECUTE | SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS | SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT | SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH)) { if (obj->access_rules[i].auth_id.len != 0) { obj->auth_id = obj->access_rules[i].auth_id; sc_log(ctx, ""Auth ID found - %s"", sc_pkcs15_print_id(&obj->auth_id)); break; } } } if (i == SC_PKCS15_MAX_ACCESS_RULES) sc_log(ctx, ""Warning: No auth ID found""); } obj->data = malloc(sizeof(info)); if (obj->data == NULL) { sc_pkcs15_free_key_params(&info.params); LOG_FUNC_RETURN(ctx, SC_ERROR_OUT_OF_MEMORY); } memcpy(obj->data, &info, sizeof(info)); sc_log(ctx, ""Key Subject %s"", sc_dump_hex(info.subject.value, info.subject.len)); sc_log(ctx, ""Key path %s"", sc_print_path(&info.path)); return 0; }"
"static int __io_async_wake(struct io_kiocb *req, struct io_poll_iocb *poll, __poll_t mask, task_work_func_t func) { int ret; if (mask && !(mask & poll->events)) return 0; trace_io_uring_task_add(req->ctx, req->opcode, req->user_data, mask); list_del_init(&poll->wait.entry); req->result = mask; init_task_work(&req->task_work, func); ret = io_req_task_work_add(req, &req->task_work); if (unlikely(ret)) { struct task_struct *tsk; WRITE_ONCE(poll->canceled, true); tsk = io_wq_get_task(req->ctx->io_wq); task_work_add(tsk, &req->task_work, 0); wake_up_process(tsk); } return 1; }"
"static int ovl_rename2(struct inode *olddir, struct dentry *old, struct inode *newdir, struct dentry *new, unsigned int flags) { int err; enum ovl_path_type old_type; enum ovl_path_type new_type; struct dentry *old_upperdir; struct dentry *new_upperdir; struct dentry *olddentry; struct dentry *newdentry; struct dentry *trap; bool old_opaque; bool new_opaque; bool new_create = false; bool cleanup_whiteout = false; bool overwrite = !(flags & RENAME_EXCHANGE); bool is_dir = d_is_dir(old); bool new_is_dir = false; struct dentry *opaquedir = NULL; const struct cred *old_cred = NULL; struct cred *override_cred = NULL; err = -EINVAL; if (flags & ~(RENAME_EXCHANGE | RENAME_NOREPLACE)) goto out; flags &= ~RENAME_NOREPLACE; err = ovl_check_sticky(old); if (err) goto out; old_type = ovl_path_type(old); err = -EXDEV; if (OVL_TYPE_MERGE_OR_LOWER(old_type) && is_dir) goto out; if (new->d_inode) { err = ovl_check_sticky(new); if (err) goto out; if (d_is_dir(new)) new_is_dir = true; new_type = ovl_path_type(new); err = -EXDEV; if (!overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) goto out; err = 0; if (!OVL_TYPE_UPPER(new_type) && !OVL_TYPE_UPPER(old_type)) { if (ovl_dentry_lower(old)->d_inode == ovl_dentry_lower(new)->d_inode) goto out; } if (OVL_TYPE_UPPER(new_type) && OVL_TYPE_UPPER(old_type)) { if (ovl_dentry_upper(old)->d_inode == ovl_dentry_upper(new)->d_inode) goto out; } } else { if (ovl_dentry_is_opaque(new)) new_type = __OVL_PATH_UPPER; else new_type = __OVL_PATH_UPPER | __OVL_PATH_PURE; } err = ovl_want_write(old); if (err) goto out; err = ovl_copy_up(old); if (err) goto out_drop_write; err = ovl_copy_up(new->d_parent); if (err) goto out_drop_write; if (!overwrite) { err = ovl_copy_up(new); if (err) goto out_drop_write; } old_opaque = !OVL_TYPE_PURE_UPPER(old_type); new_opaque = !OVL_TYPE_PURE_UPPER(new_type); if (old_opaque || new_opaque) { err = -ENOMEM; override_cred = prepare_creds(); if (!override_cred) goto out_drop_write; cap_raise(override_cred->cap_effective, CAP_SYS_ADMIN); cap_raise(override_cred->cap_effective, CAP_DAC_OVERRIDE); cap_raise(override_cred->cap_effective, CAP_FOWNER); cap_raise(override_cred->cap_effective, CAP_FSETID); cap_raise(override_cred->cap_effective, CAP_CHOWN); old_cred = override_creds(override_cred); } if (overwrite && OVL_TYPE_MERGE_OR_LOWER(new_type) && new_is_dir) { opaquedir = ovl_check_empty_and_clear(new); err = PTR_ERR(opaquedir); if (IS_ERR(opaquedir)) { opaquedir = NULL; goto out_revert_creds; } } if (overwrite) { if (old_opaque) { if (new->d_inode || !new_opaque) { flags |= RENAME_WHITEOUT; } else { flags |= RENAME_EXCHANGE; } } else if (is_dir && !new->d_inode && new_opaque) { flags |= RENAME_EXCHANGE; cleanup_whiteout = true; } } old_upperdir = ovl_dentry_upper(old->d_parent); new_upperdir = ovl_dentry_upper(new->d_parent); trap = lock_rename(new_upperdir, old_upperdir); olddentry = ovl_dentry_upper(old); newdentry = ovl_dentry_upper(new); if (newdentry) { if (opaquedir) { newdentry = opaquedir; opaquedir = NULL; } else { dget(newdentry); } } else { new_create = true; newdentry = lookup_one_len(new->d_name.name, new_upperdir, new->d_name.len); err = PTR_ERR(newdentry); if (IS_ERR(newdentry)) goto out_unlock; } err = -ESTALE; if (olddentry->d_parent != old_upperdir) goto out_dput; if (newdentry->d_parent != new_upperdir) goto out_dput; if (olddentry == trap) goto out_dput; if (newdentry == trap) goto out_dput; if (is_dir && !old_opaque && new_opaque) { err = ovl_set_opaque(olddentry); if (err) goto out_dput; } if (!overwrite && new_is_dir && old_opaque && !new_opaque) { err = ovl_set_opaque(newdentry); if (err) goto out_dput; } if (old_opaque || new_opaque) { err = ovl_do_rename(old_upperdir->d_inode, olddentry, new_upperdir->d_inode, newdentry, flags); } else { BUG_ON(flags & ~RENAME_EXCHANGE); err = vfs_rename(old_upperdir->d_inode, olddentry, new_upperdir->d_inode, newdentry, NULL, flags); } if (err) { if (is_dir && !old_opaque && new_opaque) ovl_remove_opaque(olddentry); if (!overwrite && new_is_dir && old_opaque && !new_opaque) ovl_remove_opaque(newdentry); goto out_dput; } if (is_dir && old_opaque && !new_opaque) ovl_remove_opaque(olddentry); if (!overwrite && new_is_dir && !old_opaque && new_opaque) ovl_remove_opaque(newdentry); if (old_opaque != new_opaque) { ovl_dentry_set_opaque(old, new_opaque); if (!overwrite) ovl_dentry_set_opaque(new, old_opaque); } if (cleanup_whiteout) ovl_cleanup(old_upperdir->d_inode, newdentry); ovl_dentry_version_inc(old->d_parent); ovl_dentry_version_inc(new->d_parent); out_dput: dput(newdentry); out_unlock: unlock_rename(new_upperdir, old_upperdir); out_revert_creds: if (old_opaque || new_opaque) { revert_creds(old_cred); put_cred(override_cred); } out_drop_write: ovl_drop_write(old); out: dput(opaquedir); return err; }"
"static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, netdev_features_t features) { struct sk_buff *segs = ERR_PTR(-EINVAL); unsigned int mss; unsigned int unfrag_ip6hlen, unfrag_len; struct frag_hdr *fptr; u8 *packet_start, *prevhdr; u8 nexthdr; u8 frag_hdr_sz = sizeof(struct frag_hdr); __wsum csum; int tnl_hlen; mss = skb_shinfo(skb)->gso_size; if (unlikely(skb->len <= mss)) goto out; if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) { skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss); if (!skb_shinfo(skb)->ip6_frag_id) ipv6_proxy_select_ident(dev_net(skb->dev), skb); segs = NULL; goto out; } if (skb->encapsulation && skb_shinfo(skb)->gso_type & (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM)) segs = skb_udp_tunnel_segment(skb, features, true); else { const struct ipv6hdr *ipv6h; struct udphdr *uh; if (!pskb_may_pull(skb, sizeof(struct udphdr))) goto out; uh = udp_hdr(skb); ipv6h = ipv6_hdr(skb); uh->check = 0; csum = skb_checksum(skb, 0, skb->len, 0); uh->check = udp_v6_check(skb->len, &ipv6h->saddr, &ipv6h->daddr, csum); if (uh->check == 0) uh->check = CSUM_MANGLED_0; skb->ip_summed = CHECKSUM_NONE; if (!skb->encap_hdr_csum) features |= NETIF_F_HW_CSUM; tnl_hlen = skb_tnl_header_len(skb); if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) { if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz)) goto out; } unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr); nexthdr = *prevhdr; *prevhdr = NEXTHDR_FRAGMENT; unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) + unfrag_ip6hlen + tnl_hlen; packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset; memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len); SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz; skb->mac_header -= frag_hdr_sz; skb->network_header -= frag_hdr_sz; fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen); fptr->nexthdr = nexthdr; fptr->reserved = 0; if (!skb_shinfo(skb)->ip6_frag_id) ipv6_proxy_select_ident(dev_net(skb->dev), skb); fptr->identification = skb_shinfo(skb)->ip6_frag_id; segs = skb_segment(skb, features); } out: return segs; }"
"void CL_InitRef( void ) { refimport_t ri; refexport_t *ret; #ifdef USE_RENDERER_DLOPEN GetRefAPI_tGetRefAPI; chardllName[MAX_OSPATH]; #endif Com_Printf( ""----- Initializing Renderer ----\n"" ); #ifdef USE_RENDERER_DLOPEN cl_renderer = Cvar_Get(""cl_renderer"", ""opengl1"", CVAR_ARCHIVE | CVAR_LATCH); Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_%s_"" ARCH_STRING DLL_EXT, cl_renderer->string); if(!(rendererLib = Sys_LoadDll(dllName, qfalse)) && strcmp(cl_renderer->string, cl_renderer->resetString)) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Cvar_ForceReset(""cl_renderer""); Com_sprintf(dllName, sizeof(dllName), ""renderer_mp_opengl1_"" ARCH_STRING DLL_EXT); rendererLib = Sys_LoadDll(dllName, qfalse); } if(!rendererLib) { Com_Printf(""failed:\n\""%s\""\n"", Sys_LibraryError()); Com_Error(ERR_FATAL, ""Failed to load renderer""); } GetRefAPI = Sys_LoadFunction(rendererLib, ""GetRefAPI""); if(!GetRefAPI) { Com_Error(ERR_FATAL, ""Can't load symbol GetRefAPI: '%s'"",  Sys_LibraryError()); } #endif ri.Cmd_AddCommand = Cmd_AddCommand; ri.Cmd_RemoveCommand = Cmd_RemoveCommand; ri.Cmd_Argc = Cmd_Argc; ri.Cmd_Argv = Cmd_Argv; ri.Cmd_ExecuteText = Cbuf_ExecuteText; ri.Printf = CL_RefPrintf; ri.Error = Com_Error; ri.Milliseconds = CL_ScaledMilliseconds; #ifdef ZONE_DEBUG ri.Z_MallocDebug = CL_RefMallocDebug; #else ri.Z_Malloc = CL_RefMalloc; #endif ri.Free = Z_Free; ri.Tag_Free = CL_RefTagFree; ri.Hunk_Clear = Hunk_ClearToMark; #ifdef HUNK_DEBUG ri.Hunk_AllocDebug = Hunk_AllocDebug; #else ri.Hunk_Alloc = Hunk_Alloc; #endif ri.Hunk_AllocateTempMemory = Hunk_AllocateTempMemory; ri.Hunk_FreeTempMemory = Hunk_FreeTempMemory; ri.CM_ClusterPVS = CM_ClusterPVS; ri.CM_DrawDebugSurface = CM_DrawDebugSurface; ri.FS_ReadFile = FS_ReadFile; ri.FS_FreeFile = FS_FreeFile; ri.FS_WriteFile = FS_WriteFile; ri.FS_FreeFileList = FS_FreeFileList; ri.FS_ListFiles = FS_ListFiles; ri.FS_FileIsInPAK = FS_FileIsInPAK; ri.FS_FileExists = FS_FileExists; ri.Cvar_Get = Cvar_Get; ri.Cvar_Set = Cvar_Set; ri.Cvar_SetValue = Cvar_SetValue; ri.Cvar_CheckRange = Cvar_CheckRange; ri.Cvar_VariableIntegerValue = Cvar_VariableIntegerValue; ri.CIN_UploadCinematic = CIN_UploadCinematic; ri.CIN_PlayCinematic = CIN_PlayCinematic; ri.CIN_RunCinematic = CIN_RunCinematic; ri.CL_WriteAVIVideoFrame = CL_WriteAVIVideoFrame; ri.IN_Init = IN_Init; ri.IN_Shutdown = IN_Shutdown; ri.IN_Restart = IN_Restart; ri.ftol = Q_ftol; ri.Sys_SetEnv = Sys_SetEnv; ri.Sys_GLimpSafeInit = Sys_GLimpSafeInit; ri.Sys_GLimpInit = Sys_GLimpInit; ri.Sys_LowPhysicalMemory = Sys_LowPhysicalMemory; ret = GetRefAPI( REF_API_VERSION, &ri ); if ( !ret ) { Com_Error( ERR_FATAL, ""Couldn't initialize refresh"" ); } re = *ret; Com_Printf( ""---- Renderer Initialization Complete ----\n"" ); Cvar_Set( ""cl_paused"", ""0"" ); }"
"static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus, uint8_t devfn) { const struct domain_iommu *hd = dom_iommu(d); struct pci_dev *pdev; struct domain *target; int ret = 0; if ( !is_iommu_enabled(d) ) return -EINVAL; ASSERT(pcidevs_locked()); pdev = pci_get_pdev_by_domain(d, seg, bus, devfn); if ( !pdev ) return -ENODEV; target = (pdev->quarantine && pdev->domain != dom_io) ? dom_io : hardware_domain; while ( pdev->phantom_stride ) { devfn += pdev->phantom_stride; if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) ) break; ret = hd->platform_ops->reassign_device(d, target, devfn, pci_to_dev(pdev)); if ( !ret ) continue; printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret); return ret; } devfn = pdev->devfn; ret = hd->platform_ops->reassign_device(d, target, devfn, pci_to_dev(pdev)); if ( ret ) { dprintk(XENLOG_G_ERR, ""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn)); return ret; } if ( pdev->domain == hardware_domain  ) pdev->quarantine = false; pdev->fault.count = 0; return ret; }"
"int button_open(Button *b) { char *p, name[256]; int r; assert(b); b->fd = safe_close(b->fd); p = strjoina(""/dev/input/"", b->name); b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK); if (b->fd < 0) return log_warning_errno(errno, ""Failed to open %s: %m"", p); r = button_suitable(b); if (r < 0) return log_warning_errno(r, ""Failed to determine whether input device is relevant to us: %m""); if (r == 0) return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL), ""Device %s does not expose keys or switches relevant to us, ignoring."", p); if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) { r = log_error_errno(errno, ""Failed to get input name: %m""); goto fail; } (void) button_set_mask(b); r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b); if (r < 0) { log_error_errno(r, ""Failed to add button event: %m""); goto fail; } log_info(""Watching system buttons on /dev/input/%s (%s)"", b->name, name); return 0; fail: b->fd = safe_close(b->fd); return r; }"
"std::string dirname(const std::string& path) { if (path == """") return "".""; std::string p = path; while (   p.length() > 1 && (p[p.length()-1] == '\\' || p[p.length()-1] == '/')) { p = p.substr(0, p.length()-1); } if (p == ""\\"" || p == ""/"") return p; if (p.length() == 2 && p[1] == ':') return p;         std::string::size_type idx = p.find_last_of(""\\/""); if (idx == std::string::npos) return "".""; if (idx == 1 && p[0] == '\\' && p[1] == '\\') return p;         p = p.substr(0, idx == 0 ? 1 : idx); while (   p.length() > 1 && (p[p.length()-1] == '\\' || p[p.length()-1] == '/')) { p = p.substr(0, p.length()-1); } return p; }"
"optional<ARN> ARN::parse(const string& s, bool wildcards) { static const char str_wild[] = ""arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)""; static const regex rx_wild(str_wild, sizeof(str_wild) - 1, ECMAScript | optimize); static const char str_no_wild[] = ""arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)""; static const regex rx_no_wild(str_no_wild, sizeof(str_no_wild) - 1, ECMAScript | optimize); smatch match; if ((s == ""*"") && wildcards) { return ARN(Partition::wildcard, Service::wildcard, ""*"", ""*"", ""*""); } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) { ceph_assert(match.size() == 6); ARN a; { auto p = to_partition(match[1], wildcards); if (!p) return none; a.partition = *p; } { auto s = to_service(match[2], wildcards); if (!s) { return none; } a.service = *s; } a.region = match[3]; a.account = match[4]; a.resource = match[5]; return a; } return none; }"
"int gnttab_map_frame(struct domain *d, unsigned long idx, gfn_t gfn, mfn_t *mfn) { int rc = 0; struct grant_table *gt = d->grant_table; grant_write_lock(gt); if ( gt->gt_version == 0 ) gt->gt_version = 1; if ( gt->gt_version == 2 && (idx & XENMAPIDX_grant_table_status) ) { idx &= ~XENMAPIDX_grant_table_status; if ( idx < nr_status_frames(gt) ) *mfn = _mfn(virt_to_mfn(gt->status[idx])); else rc = -EINVAL; } else { if ( (idx >= nr_grant_frames(gt)) && (idx < gt->max_grant_frames) ) gnttab_grow_table(d, idx + 1); if ( idx < nr_grant_frames(gt) ) *mfn = _mfn(virt_to_mfn(gt->shared_raw[idx])); else rc = -EINVAL; } if ( !rc ) gnttab_set_frame_gfn(gt, idx, gfn); grant_write_unlock(gt); return rc; }"
"void traverse_commit_list(struct rev_info *revs, show_commit_fn show_commit, show_object_fn show_object, void *data) { int i; struct commit *commit; struct strbuf base; strbuf_init(&base, PATH_MAX); while ((commit = get_revision(revs)) != NULL) { if (commit->tree) add_pending_tree(revs, commit->tree); show_commit(commit, data); } for (i = 0; i < revs->pending.nr; i++) { struct object_array_entry *pending = revs->pending.objects + i; struct object *obj = pending->item; const char *name = pending->name; const char *path = pending->path; if (obj->flags & (UNINTERESTING | SEEN)) continue; if (obj->type == OBJ_TAG) { obj->flags |= SEEN; show_object(obj, NULL, name, data); continue; } if (!path) path = """"; if (obj->type == OBJ_TREE) { process_tree(revs, (struct tree *)obj, show_object, &base, path, data); continue; } if (obj->type == OBJ_BLOB) { process_blob(revs, (struct blob *)obj, show_object, NULL, path, data); continue; } die(""unknown pending object %s (%s)"", oid_to_hex(&obj->oid), name); } object_array_clear(&revs->pending); strbuf_release(&base); }"
"SSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0), anon_cred(0), cert_cred(0), anon(_anon), fis(0), fos(0) { certfile = X509_CertFile.getData(); keyfile = X509_KeyFile.getData(); }"
"static guint32 check_offset_addition(guint32 offset, guint32 value, proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb) { if (offset > G_MAXUINT32 - value) { proto_tree_add_expert_format(tree, pinfo, &ei_rtps_value_too_large, tvb, 0, 0, ""Offset value too large: %u"", value); THROW(ReportedBoundsError); } return offset + value; }"
"void initSSL(struct SSLSupport *ssl) { ssl->enabled               = serverSupportsSSL(); ssl->sslContext            = NULL; ssl->sniCertificatePattern = NULL; ssl->generateMissing       = 0; ssl->renegotiationCount    = 0; initTrie(&ssl->sniContexts, sslDestroyCachedContext, ssl); }"
"static void php_snmp_error(zval *object, const char *docref, int type, const char *format, ...) { va_list args; php_snmp_object *snmp_object = NULL; if (object) { snmp_object = Z_SNMP_P(object); if (type == PHP_SNMP_ERRNO_NOERROR) { memset(snmp_object->snmp_errstr, 0, sizeof(snmp_object->snmp_errstr)); } else { va_start(args, format); vsnprintf(snmp_object->snmp_errstr, sizeof(snmp_object->snmp_errstr) - 1, format, args); va_end(args); } snmp_object->snmp_errno = type; } if (type == PHP_SNMP_ERRNO_NOERROR) { return; } if (object && (snmp_object->exceptions_enabled & type)) { zend_throw_exception_ex(php_snmp_exception_ce, type, snmp_object->snmp_errstr); } else { va_start(args, format); php_verror(docref, """", E_WARNING, format, args); va_end(args); } }"
"static int encrypted_update(struct key *key, struct key_preparsed_payload *prep) { struct encrypted_key_payload *epayload = key->payload.data[0]; struct encrypted_key_payload *new_epayload; char *buf; char *new_master_desc = NULL; const char *format = NULL; size_t datalen = prep->datalen; int ret = 0; if (test_bit(KEY_FLAG_NEGATIVE, &key->flags)) return -ENOKEY; if (datalen <= 0 || datalen > 32767 || !prep->data) return -EINVAL; buf = kmalloc(datalen + 1, GFP_KERNEL); if (!buf) return -ENOMEM; buf[datalen] = 0; memcpy(buf, prep->data, datalen); ret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL); if (ret < 0) goto out; ret = valid_master_desc(new_master_desc, epayload->master_desc); if (ret < 0) goto out; new_epayload = encrypted_key_alloc(key, epayload->format, new_master_desc, epayload->datalen); if (IS_ERR(new_epayload)) { ret = PTR_ERR(new_epayload); goto out; } __ekey_init(new_epayload, epayload->format, new_master_desc, epayload->datalen); memcpy(new_epayload->iv, epayload->iv, ivsize); memcpy(new_epayload->payload_data, epayload->payload_data, epayload->payload_datalen); rcu_assign_keypointer(key, new_epayload); call_rcu(&epayload->rcu, encrypted_rcu_free); out: kzfree(buf); return ret; }"
"static Image *ReadCAPTIONImage(const ImageInfo *image_info, ExceptionInfo *exception) { char *caption, geometry[MaxTextExtent], *property, *text; const char *gravity, *option; DrawInfo *draw_info; Image *image; MagickBooleanType split, status; register ssize_t i; size_t height, width; TypeMetric metrics; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); (void) ResetImagePage(image,""0x0+0+0""); option=GetImageOption(image_info,""filename""); if (option == (const char *) NULL) property=InterpretImageProperties(image_info,image,image_info->filename); else if (LocaleNCompare(option,""caption:"",8) == 0) property=InterpretImageProperties(image_info,image,option+8); else property=InterpretImageProperties(image_info,image,option); (void) SetImageProperty(image,""caption"",property); property=DestroyString(property); caption=ConstantString(GetImageProperty(image,""caption"")); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); (void) CloneString(&draw_info->text,caption); gravity=GetImageOption(image_info,""gravity""); if (gravity != (char *) NULL) draw_info->gravity=(GravityType) ParseCommandOption(MagickGravityOptions, MagickFalse,gravity); split=MagickFalse; status=MagickTrue; if (image->columns == 0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); image->columns=width; } if (image->rows == 0) { split=MagickTrue; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); image->rows=(size_t) ((i+1)*(metrics.ascent-metrics.descent+ draw_info->interline_spacing+draw_info->stroke_width)+0.5); } if (status != MagickFalse) status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) {  draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); InheritException(exception,&image->exception); image=DestroyImageList(image); return((Image *) NULL); } if ((fabs(image_info->pointsize) < MagickEpsilon) && (strlen(caption) > 0)) { double high, low; for ( ; ; draw_info->pointsize*=2.0) { text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics); (void) status; width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) && (height >= image->rows)) break; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } high=draw_info->pointsize; for (low=1.0; (high-low) > 0.5; ) { draw_info->pointsize=(low+high)/2.0; text=AcquireString(caption); i=FormatMagickCaption(image,draw_info,split,&metrics,&text); (void) CloneString(&draw_info->text,text); text=DestroyString(text); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); (void) GetMultilineTypeMetrics(image,draw_info,&metrics); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } draw_info->pointsize=floor((low+high)/2.0-0.5); } i=FormatMagickCaption(image,draw_info,split,&metrics,&caption); (void) CloneString(&draw_info->text,caption); (void) FormatLocaleString(geometry,MaxTextExtent,""%+g%+g"",MagickMax( draw_info->direction == RightToLeftDirection ? image->columns- metrics.bounds.x2 : -metrics.bounds.x1,0.0),draw_info->gravity == UndefinedGravity ? metrics.ascent : 0.0); (void) CloneString(&draw_info->geometry,geometry); status=AnnotateImage(image,draw_info); if (image_info->pointsize == 0.0) {  char pointsize[MaxTextExtent]; (void) FormatLocaleString(pointsize,MaxTextExtent,""%.20g"", draw_info->pointsize); (void) SetImageProperty(image,""caption:pointsize"",pointsize); } draw_info=DestroyDrawInfo(draw_info); caption=DestroyString(caption); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }"
static enum pkvm_page_state hyp_get_page_state(kvm_pte_t pte) { if (!kvm_pte_valid(pte)) return PKVM_NOPAGE; return pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte)); }
"static int xwd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { AVFrame *p = data; const uint8_t *buf = avpkt->data; int i, ret, buf_size = avpkt->size; uint32_t version, header_size, vclass, ncolors; uint32_t xoffset, be, bpp, lsize, rsize; uint32_t pixformat, pixdepth, bunit, bitorder, bpad; uint32_t rgb[3]; uint8_t *ptr; GetByteContext gb; if (buf_size < XWD_HEADER_SIZE) return AVERROR_INVALIDDATA; bytestream2_init(&gb, buf, buf_size); header_size = bytestream2_get_be32u(&gb); version = bytestream2_get_be32u(&gb); if (version != XWD_VERSION) { av_log(avctx, AV_LOG_ERROR, ""unsupported version\n""); return AVERROR_INVALIDDATA; } if (buf_size < header_size || header_size < XWD_HEADER_SIZE) { av_log(avctx, AV_LOG_ERROR, ""invalid header size\n""); return AVERROR_INVALIDDATA; } pixformat     = bytestream2_get_be32u(&gb); pixdepth      = bytestream2_get_be32u(&gb); avctx->width  = bytestream2_get_be32u(&gb); avctx->height = bytestream2_get_be32u(&gb); xoffset       = bytestream2_get_be32u(&gb); be            = bytestream2_get_be32u(&gb); bunit         = bytestream2_get_be32u(&gb); bitorder      = bytestream2_get_be32u(&gb); bpad          = bytestream2_get_be32u(&gb); bpp           = bytestream2_get_be32u(&gb); lsize         = bytestream2_get_be32u(&gb); vclass        = bytestream2_get_be32u(&gb); rgb[0]        = bytestream2_get_be32u(&gb); rgb[1]        = bytestream2_get_be32u(&gb); rgb[2]        = bytestream2_get_be32u(&gb); bytestream2_skipu(&gb, 8); ncolors       = bytestream2_get_be32u(&gb); bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20)); av_log(avctx, AV_LOG_DEBUG, ""pixformat %""PRIu32"", pixdepth %""PRIu32"", bunit %""PRIu32"", bitorder %""PRIu32"", bpad %""PRIu32""\n"", pixformat, pixdepth, bunit, bitorder, bpad); av_log(avctx, AV_LOG_DEBUG, ""vclass %""PRIu32"", ncolors %""PRIu32"", bpp %""PRIu32"", be %""PRIu32"", lsize %""PRIu32"", xoffset %""PRIu32""\n"", vclass, ncolors, bpp, be, lsize, xoffset); av_log(avctx, AV_LOG_DEBUG, ""red %0""PRIx32"", green %0""PRIx32"", blue %0""PRIx32""\n"", rgb[0], rgb[1], rgb[2]); if (pixformat > XWD_Z_PIXMAP) { av_log(avctx, AV_LOG_ERROR, ""invalid pixmap format\n""); return AVERROR_INVALIDDATA; } if (pixdepth == 0 || pixdepth > 32) { av_log(avctx, AV_LOG_ERROR, ""invalid pixmap depth\n""); return AVERROR_INVALIDDATA; } if (xoffset) { avpriv_request_sample(avctx, ""xoffset %""PRIu32"""", xoffset); return AVERROR_PATCHWELCOME; } if (be > 1) { av_log(avctx, AV_LOG_ERROR, ""invalid byte order\n""); return AVERROR_INVALIDDATA; } if (bitorder > 1) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap bit order\n""); return AVERROR_INVALIDDATA; } if (bunit != 8 && bunit != 16 && bunit != 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap unit\n""); return AVERROR_INVALIDDATA; } if (bpad != 8 && bpad != 16 && bpad != 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap scan-line pad\n""); return AVERROR_INVALIDDATA; } if (bpp == 0 || bpp > 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bits per pixel\n""); return AVERROR_INVALIDDATA; } if (ncolors > 256) { av_log(avctx, AV_LOG_ERROR, ""invalid number of entries in colormap\n""); return AVERROR_INVALIDDATA; } if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0) return ret; rsize = FFALIGN(avctx->width * bpp, bpad) / 8; if (lsize < rsize) { av_log(avctx, AV_LOG_ERROR, ""invalid bytes per scan-line\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) { av_log(avctx, AV_LOG_ERROR, ""input buffer too small\n""); return AVERROR_INVALIDDATA; } if (pixformat != XWD_Z_PIXMAP) { avpriv_report_missing_feature(avctx, ""Pixmap format %""PRIu32, pixformat); return AVERROR_PATCHWELCOME; } avctx->pix_fmt = AV_PIX_FMT_NONE; switch (vclass) { case XWD_STATIC_GRAY: case XWD_GRAY_SCALE: if (bpp != 1 && bpp != 8) return AVERROR_INVALIDDATA; if (pixdepth == 1) { avctx->pix_fmt = AV_PIX_FMT_MONOWHITE; } else if (pixdepth == 8) { avctx->pix_fmt = AV_PIX_FMT_GRAY8; } break; case XWD_STATIC_COLOR: case XWD_PSEUDO_COLOR: if (bpp == 8) avctx->pix_fmt = AV_PIX_FMT_PAL8; break; case XWD_TRUE_COLOR: case XWD_DIRECT_COLOR: if (bpp != 16 && bpp != 24 && bpp != 32) return AVERROR_INVALIDDATA; if (bpp == 16 && pixdepth == 15) { if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F) avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE; else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00) avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE; } else if (bpp == 16 && pixdepth == 16) { if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F) avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE; else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800) avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE; } else if (bpp == 24) { if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF) avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24; else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000) avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24; } else if (bpp == 32) { if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF) avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA; else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000) avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA; } bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE); break; default: av_log(avctx, AV_LOG_ERROR, ""invalid visual class\n""); return AVERROR_INVALIDDATA; } if (avctx->pix_fmt == AV_PIX_FMT_NONE) { avpriv_request_sample(avctx, ""Unknown file: bpp %""PRIu32"", pixdepth %""PRIu32"", vclass %""PRIu32"""", bpp, pixdepth, vclass); return AVERROR_PATCHWELCOME; } if ((ret = ff_get_buffer(avctx, p, 0)) < 0) return ret; p->key_frame = 1; p->pict_type = AV_PICTURE_TYPE_I; if (avctx->pix_fmt == AV_PIX_FMT_PAL8) { uint32_t *dst = (uint32_t *)p->data[1]; uint8_t red, green, blue; for (i = 0; i < ncolors; i++) { bytestream2_skipu(&gb, 4);             red    = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 1); green  = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 1); blue   = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 3);  dst[i] = red << 16 | green << 8 | blue; } } ptr = p->data[0]; for (i = 0; i < avctx->height; i++) { bytestream2_get_bufferu(&gb, ptr, rsize); bytestream2_skipu(&gb, lsize - rsize); ptr += p->linesize[0]; } *got_frame       = 1; return buf_size; }"
"void gdImageFill(gdImagePtr im, int x, int y, int nc) { int l, x1, x2, dy; int oc;    int wx2,wy2; int alphablending_bak; struct seg *stack = NULL; struct seg *sp; if (!im->trueColor && nc > (im->colorsTotal -1)) { return; } alphablending_bak = im->alphaBlendingFlag; im->alphaBlendingFlag = 0; if (nc==gdTiled){ _gdImageFillTiled(im,x,y,nc); im->alphaBlendingFlag = alphablending_bak; return; } wx2=im->sx;wy2=im->sy; oc = gdImageGetPixel(im, x, y); if (oc==nc || x<0 || x>wx2 || y<0 || y>wy2) { im->alphaBlendingFlag = alphablending_bak; return; } if (im->sx < 4) { int ix = x, iy = y, c; do { do { c = gdImageGetPixel(im, ix, iy); if (c != oc) { goto done; } gdImageSetPixel(im, ix, iy, nc); } while(ix++ < (im->sx -1)); ix = x; } while(iy++ < (im->sy -1)); goto done; } stack = (struct seg *)safe_emalloc(sizeof(struct seg), ((int)(im->sy*im->sx)/4), 1); sp = stack; FILL_PUSH(y,x,x,1); FILL_PUSH(y+1, x, x, -1); while (sp>stack) { FILL_POP(y, x1, x2, dy); for (x=x1; x>=0 && gdImageGetPixel(im,x, y)==oc; x--) { gdImageSetPixel(im,x, y, nc); } if (x>=x1) { goto skip; } l = x+1; if (l<x1) { FILL_PUSH(y, l, x1-1, -dy); } x = x1+1; do { for (; x<=wx2 && gdImageGetPixel(im,x, y)==oc; x++) { gdImageSetPixel(im, x, y, nc); } FILL_PUSH(y, l, x-1, dy); if (x>x2+1) { FILL_PUSH(y, x2+1, x-1, -dy); } skip:for (x++; x<=x2 && (gdImageGetPixel(im, x, y)!=oc); x++); l = x; } while (x<=x2); } efree(stack); done: im->alphaBlendingFlag = alphablending_bak; }"
"explicit ReverseSequenceOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""batch_dim"", &batch_dim_)); OP_REQUIRES_OK(context, context->GetAttr(""seq_dim"", &seq_dim_)); }"
"struct evalstring * scanstring(struct scanner *s, bool path) { struct evalstring *str; struct evalstringpart *parts = NULL, **end = &parts; buf.len = 0; for (;;) { switch (s->chr) { case '$': next(s); escape(s, &end); break; case ':': case '|': case ' ': if (path) goto out; default: bufadd(&buf, s->chr); next(s); break; case '\r': case '\n': case EOF: goto out; } } out: if (buf.len > 0) addstringpart(&end, 0); if (path) space(s); if (!parts) return NULL; str = xmalloc(sizeof(*str)); str->parts = parts; return str; }"
"int bm_printf(Bitmap *b, int x, int y, const char *fmt, ...) { char buffer[256]; va_list arg; if(!b->font || !b->font->puts) return 0; va_start(arg, fmt); vsnprintf(buffer, sizeof buffer, fmt, arg); va_end(arg); return bm_puts(b, x, y, buffer); }"
"int main(void) { FILE *f; char *tmpname; f = xfmkstemp(&tmpname, NULL); unlink(tmpname); free(tmpname); fclose(f); return EXIT_FAILURE; }"
"SampleTable::SampleTable(const sp<DataSource> &source) : mDataSource(source), mChunkOffsetOffset(-1), mChunkOffsetType(0), mNumChunkOffsets(0), mSampleToChunkOffset(-1), mNumSampleToChunkOffsets(0), mSampleSizeOffset(-1), mSampleSizeFieldSize(0), mDefaultSampleSize(0), mNumSampleSizes(0), mTimeToSampleCount(0), mTimeToSample(NULL), mSampleTimeEntries(NULL), mCompositionTimeDeltaEntries(NULL), mNumCompositionTimeDeltaEntries(0), mCompositionDeltaLookup(new CompositionDeltaLookup), mSyncSampleOffset(-1), mNumSyncSamples(0), mSyncSamples(NULL), mLastSyncSampleIndex(0), mSampleToChunkEntries(NULL) { mSampleIterator = new SampleIterator(this); }"
"static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode)  { zval *id; xmlDoc *docp = NULL, *newdoc; dom_object *intern; dom_doc_propsptr doc_prop; char *source; int source_len, refcount, ret; long options = 0; htmlParserCtxtPtr ctxt; id = getThis(); if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) { return; } if (!source_len) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input""); RETURN_FALSE; } if (mode == DOM_LOAD_FILE) { ctxt = htmlCreateFileParserCtxt(source, NULL); } else { source_len = xmlStrlen(source); ctxt = htmlCreateMemoryParserCtxt(source, source_len); } if (!ctxt) { RETURN_FALSE; } if (options) { htmlCtxtUseOptions(ctxt, options); } ctxt->vctxt.error = php_libxml_ctx_error; ctxt->vctxt.warning = php_libxml_ctx_warning; if (ctxt->sax != NULL) { ctxt->sax->error = php_libxml_ctx_error; ctxt->sax->warning = php_libxml_ctx_warning; } htmlParseDocument(ctxt); newdoc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); if (!newdoc) RETURN_FALSE; if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) { intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC); if (intern != NULL) { docp = (xmlDocPtr) dom_object_get_node(intern); doc_prop = NULL; if (docp != NULL) { php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC); doc_prop = intern->document->doc_props; intern->document->doc_props = NULL; refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC); if (refcount != 0) { docp->_private = NULL; } } intern->document = NULL; if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) { RETURN_FALSE; } intern->document->doc_props = doc_prop; } php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC); RETURN_TRUE; } else { DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL); } }"
"int arch_domain_create(struct domain *d, struct xen_domctl_createdomain *config, unsigned int flags) { bool paging_initialised = false; uint32_t emflags; int rc; INIT_PAGE_LIST_HEAD(&d->arch.relmem_list); spin_lock_init(&d->arch.e820_lock); if ( unlikely(is_idle_domain(d)) ) { static const struct arch_csw idle_csw = { .from = paravirt_ctxt_switch_from, .to   = paravirt_ctxt_switch_to, .tail = idle_loop, }; d->arch.ctxt_switch = &idle_csw; d->arch.cpuid = ZERO_BLOCK_PTR;  d->arch.msr = ZERO_BLOCK_PTR; return 0; } if ( !config ) { ASSERT_UNREACHABLE(); return -EINVAL; } if ( d->domain_id && cpu_has_amd_erratum(&boot_cpu_data, AMD_ERRATUM_121) ) { if ( !opt_allow_unsafe ) { printk(XENLOG_G_ERR ""Xen does not allow DomU creation on this CPU"" "" for security reasons.\n""); return -EPERM; } printk(XENLOG_G_WARNING ""Dom%d may compromise security on this CPU.\n"", d->domain_id); } emflags = config->arch.emulation_flags; if ( is_hardware_domain(d) && is_pv_domain(d) ) emflags |= XEN_X86_EMU_PIT; if ( emflags & ~XEN_X86_EMU_ALL ) { printk(XENLOG_G_ERR ""d%d: Invalid emulation bitmap: %#x\n"", d->domain_id, emflags); return -EINVAL; } if ( !emulation_flags_ok(d, emflags) ) { printk(XENLOG_G_ERR ""d%d: Xen does not allow %s domain creation "" ""with the current selection of emulators: %#x\n"", d->domain_id, is_hvm_domain(d) ? ""HVM"" : ""PV"", emflags); return -EOPNOTSUPP; } d->arch.emulation_flags = emflags; #ifdef CONFIG_PV32 HYPERVISOR_COMPAT_VIRT_START(d) = is_pv_domain(d) ? __HYPERVISOR_COMPAT_VIRT_START : ~0u; #endif if ( (rc = paging_domain_init(d)) != 0 ) goto fail; paging_initialised = true; if ( (rc = init_domain_cpuid_policy(d)) ) goto fail; if ( (rc = init_domain_msr_policy(d)) ) goto fail; d->arch.ioport_caps = rangeset_new(d, ""I/O Ports"", RANGESETF_prettyprint_hex); rc = -ENOMEM; if ( d->arch.ioport_caps == NULL ) goto fail; if ( (d->shared_info = alloc_xenheap_pages(0, MEMF_bits(32))) == NULL ) goto fail; clear_page(d->shared_info); share_xen_page_with_guest(virt_to_page(d->shared_info), d, SHARE_rw); if ( (rc = init_domain_irq_mapping(d)) != 0 ) goto fail; if ( (rc = iommu_domain_init(d, config->iommu_opts)) != 0 ) goto fail; psr_domain_init(d); if ( is_hvm_domain(d) ) { if ( (rc = hvm_domain_initialise(d)) != 0 ) goto fail; } else if ( is_pv_domain(d) ) { mapcache_domain_init(d); if ( (rc = pv_domain_initialise(d)) != 0 ) goto fail; } else ASSERT_UNREACHABLE();  if ( (rc = tsc_set_info(d, TSC_MODE_DEFAULT, 0, 0, 0)) != 0 ) { ASSERT_UNREACHABLE(); goto fail; } pit_init(d, cpu_khz); d->arch.x87_fip_width = cpu_has_fpu_sel ? 0 : 8; domain_cpu_policy_changed(d); d->arch.msr_relaxed = config->arch.misc_flags & XEN_X86_MSR_RELAXED; return 0; fail: d->is_dying = DOMDYING_dead; psr_domain_free(d); iommu_domain_destroy(d); cleanup_domain_irq_mapping(d); free_xenheap_page(d->shared_info); xfree(d->arch.cpuid); xfree(d->arch.msr); if ( paging_initialised ) paging_final_teardown(d); free_perdomain_mappings(d); return rc; }"
"static void mcf_fec_do_tx(mcf_fec_state *s) { uint32_t addr; mcf_fec_bd bd; int frame_size; int len; uint8_t frame[FEC_MAX_FRAME_SIZE]; uint8_t *ptr; DPRINTF(""do_tx\n""); ptr = frame; frame_size = 0; addr = s->tx_descriptor; while (1) { mcf_fec_read_bd(&bd, addr); DPRINTF(""tx_bd %x flags %04x len %d data %08x\n"", addr, bd.flags, bd.length, bd.data); if ((bd.flags & FEC_BD_R) == 0) { break; } len = bd.length; if (frame_size + len > FEC_MAX_FRAME_SIZE) { len = FEC_MAX_FRAME_SIZE - frame_size; s->eir |= FEC_INT_BABT; } cpu_physical_memory_read(bd.data, ptr, len); ptr += len; frame_size += len; if (bd.flags & FEC_BD_L) { DPRINTF(""Sending packet\n""); qemu_send_packet(qemu_get_queue(s->nic), frame, len); ptr = frame; frame_size = 0; s->eir |= FEC_INT_TXF; } s->eir |= FEC_INT_TXB; bd.flags &= ~FEC_BD_R; mcf_fec_write_bd(&bd, addr); if ((bd.flags & FEC_BD_W) != 0) { addr = s->etdsr; } else { addr += 8; } } s->tx_descriptor = addr; }"
"static char * getString(struct SWF_ACTIONPUSHPARAM *act) { char *t; #ifdef DEBUG printf(""*getString* type=%d\n"",act->Type); #endif switch( act->Type )  { case PUSH_STRING:  t=malloc(strlen(act->p.String)+3);  strcpy(t,""'""); strcat(t,act->p.String); strcat(t,""'""); return t; case PUSH_NULL:  return ""null""; case PUSH_UNDEF:  return ""undefined""; case PUSH_REGISTER:  if( regs[act->p.RegisterNumber] && regs[act->p.RegisterNumber]->Type != 4 && regs[act->p.RegisterNumber]->Type != 7 ) { return getName(regs[act->p.RegisterNumber]); } else { t=malloc(4);  sprintf(t,""R%d"", act->p.RegisterNumber ); return t; } case PUSH_BOOLEAN:  if( act->p.Boolean ) return ""true""; else return ""false""; case PUSH_DOUBLE:  t=malloc(10);  sprintf(t,""%g"", act->p.Double ); return t; case PUSH_INT:  t=malloc(10);  sprintf(t,""%ld"", act->p.Integer ); return t; case PUSH_CONSTANT:  t=malloc(strlenext(pool[act->p.Constant8])+3);  strcpy(t,""'""); strcatext(t,pool[act->p.Constant8]); strcat(t,""'""); return t; case PUSH_CONSTANT16:  t=malloc(strlenext(pool[act->p.Constant16])+3);  strcpy(t,""'""); strcatext(t,pool[act->p.Constant16]); strcat(t,""'""); return t; case 12: case 11:  case PUSH_VARIABLE:  return act->p.String; default:  fprintf (stderr,""  Can't get string for type: %d\n"", act->Type); break; } return """"; }"
"static GF_Err shift_chunk_offsets(GF_SampleToChunkBox *stsc, GF_MediaBox *mdia, GF_Box *_stco, u64 offset, Bool force_co64, GF_Box **new_stco) { u32 j, k, l, last; GF_StscEntry *ent; for (j=0; j<stsc->nb_entries; j++) { ent = &stsc->entries[j]; if (!Media_IsSelfContained(mdia, ent->sampleDescriptionIndex)) continue; if (_stco->type == GF_ISOM_BOX_TYPE_STCO) { GF_ChunkLargeOffsetBox *new_stco64 = NULL; GF_ChunkOffsetBox *stco = (GF_ChunkOffsetBox *) _stco; last = ent->nextChunk ? ent->nextChunk : stco->nb_entries + 1; for (k = ent->firstChunk; k < last; k++) { if (new_stco64 || force_co64 || (stco->offsets[k-1] + offset > 0xFFFFFFFF)) { if (!new_stco64) { new_stco64 = (GF_ChunkLargeOffsetBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_CO64); if (!new_stco64) return GF_OUT_OF_MEM; new_stco64->nb_entries = stco->nb_entries; new_stco64->offsets = (u64 *) gf_malloc(new_stco64->nb_entries * sizeof(u64)); if (!new_stco64->offsets) return GF_OUT_OF_MEM; for (l = 0; l < new_stco64->nb_entries; l++) { new_stco64->offsets[l] = (u64) stco->offsets[l]; } } new_stco64->offsets[k-1] += offset; } else { stco->offsets[k-1] += (u32) offset; } } if (new_stco64) { *new_stco = (GF_Box *) new_stco64; _stco = (GF_Box *) new_stco64; new_stco64 = NULL; } } else { GF_ChunkLargeOffsetBox *stco64 = (GF_ChunkLargeOffsetBox *) _stco; last = ent->nextChunk ? ent->nextChunk : stco64->nb_entries + 1; for (k = ent->firstChunk; k < last; k++) { stco64->offsets[k-1] += offset; } } } return GF_OK; }"
"static int usb_parse_configuration(struct usb_device *dev, int cfgidx, struct usb_host_config *config, unsigned char *buffer, int size) { struct device *ddev = &dev->dev; unsigned char *buffer0 = buffer; int cfgno; int nintf, nintf_orig; int i, j, n; struct usb_interface_cache *intfc; unsigned char *buffer2; int size2; struct usb_descriptor_header *header; int len, retval; u8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES]; unsigned iad_num = 0; memcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE); if (config->desc.bDescriptorType != USB_DT_CONFIG || config->desc.bLength < USB_DT_CONFIG_SIZE || config->desc.bLength > size) { dev_err(ddev, ""invalid descriptor for config index %d: "" ""type = 0x%X, length = %d\n"", cfgidx, config->desc.bDescriptorType, config->desc.bLength); return -EINVAL; } cfgno = config->desc.bConfigurationValue; buffer += config->desc.bLength; size -= config->desc.bLength; nintf = nintf_orig = config->desc.bNumInterfaces; if (nintf > USB_MAXINTERFACES) { dev_warn(ddev, ""config %d has too many interfaces: %d, "" ""using maximum allowed: %d\n"", cfgno, nintf, USB_MAXINTERFACES); nintf = USB_MAXINTERFACES; } n = 0; for ((buffer2 = buffer, size2 = size); size2 > 0; (buffer2 += header->bLength, size2 -= header->bLength)) { if (size2 < sizeof(struct usb_descriptor_header)) { dev_warn(ddev, ""config %d descriptor has %d excess "" ""byte%s, ignoring\n"", cfgno, size2, plural(size2)); break; } header = (struct usb_descriptor_header *) buffer2; if ((header->bLength > size2) || (header->bLength < 2)) { dev_warn(ddev, ""config %d has an invalid descriptor "" ""of length %d, skipping remainder of the config\n"", cfgno, header->bLength); break; } if (header->bDescriptorType == USB_DT_INTERFACE) { struct usb_interface_descriptor *d; int inum; d = (struct usb_interface_descriptor *) header; if (d->bLength < USB_DT_INTERFACE_SIZE) { dev_warn(ddev, ""config %d has an invalid "" ""interface descriptor of length %d, "" ""skipping\n"", cfgno, d->bLength); continue; } inum = d->bInterfaceNumber; if ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) && n >= nintf_orig) { dev_warn(ddev, ""config %d has more interface "" ""descriptors, than it declares in "" ""bNumInterfaces, ignoring interface "" ""number: %d\n"", cfgno, inum); continue; } if (inum >= nintf_orig) dev_warn(ddev, ""config %d has an invalid "" ""interface number: %d but max is %d\n"", cfgno, inum, nintf_orig - 1); for (i = 0; i < n; ++i) { if (inums[i] == inum) break; } if (i < n) { if (nalts[i] < 255) ++nalts[i]; } else if (n < USB_MAXINTERFACES) { inums[n] = inum; nalts[n] = 1; ++n; } } else if (header->bDescriptorType == USB_DT_INTERFACE_ASSOCIATION) { if (iad_num == USB_MAXIADS) { dev_warn(ddev, ""found more Interface "" ""Association Descriptors "" ""than allocated for in "" ""configuration %d\n"", cfgno); } else { config->intf_assoc[iad_num] = (struct usb_interface_assoc_descriptor *)header; iad_num++; } } else if (header->bDescriptorType == USB_DT_DEVICE || header->bDescriptorType == USB_DT_CONFIG) dev_warn(ddev, ""config %d contains an unexpected "" ""descriptor of type 0x%X, skipping\n"", cfgno, header->bDescriptorType); } size = buffer2 - buffer; config->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0); if (n != nintf) dev_warn(ddev, ""config %d has %d interface%s, different from "" ""the descriptor's value: %d\n"", cfgno, n, plural(n), nintf_orig); else if (n == 0) dev_warn(ddev, ""config %d has no interfaces?\n"", cfgno); config->desc.bNumInterfaces = nintf = n; for (i = 0; i < nintf; ++i) { for (j = 0; j < nintf; ++j) { if (inums[j] == i) break; } if (j >= nintf) dev_warn(ddev, ""config %d has no interface number "" ""%d\n"", cfgno, i); } for (i = 0; i < nintf; ++i) { j = nalts[i]; if (j > USB_MAXALTSETTING) { dev_warn(ddev, ""too many alternate settings for "" ""config %d interface %d: %d, "" ""using maximum allowed: %d\n"", cfgno, inums[i], j, USB_MAXALTSETTING); nalts[i] = j = USB_MAXALTSETTING; } len = sizeof(*intfc) + sizeof(struct usb_host_interface) * j; config->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL); if (!intfc) return -ENOMEM; kref_init(&intfc->ref); } config->extra = buffer; i = find_next_descriptor(buffer, size, USB_DT_INTERFACE, USB_DT_INTERFACE, &n); config->extralen = i; if (n > 0) dev_dbg(ddev, ""skipped %d descriptor%s after %s\n"", n, plural(n), ""configuration""); buffer += i; size -= i; while (size > 0) { retval = usb_parse_interface(ddev, cfgno, config, buffer, size, inums, nalts); if (retval < 0) return retval; buffer += retval; size -= retval; } for (i = 0; i < nintf; ++i) { intfc = config->intf_cache[i]; for (j = 0; j < intfc->num_altsetting; ++j) { for (n = 0; n < intfc->num_altsetting; ++n) { if (intfc->altsetting[n].desc. bAlternateSetting == j) break; } if (n >= intfc->num_altsetting) dev_warn(ddev, ""config %d interface %d has no "" ""altsetting %d\n"", cfgno, inums[i], j); } } return 0; }"
"GF_EXPORT GF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size) { #ifndef GPAC_DISABLE_AV_PARSERS AV1State state; u8 reserved; GF_AV1Config *cfg; if (!size) size = (u32) gf_bs_available(bs); if (!size) return NULL; cfg = gf_odf_av1_cfg_new(); gf_av1_init_state(&state); state.config = cfg; cfg->marker = gf_bs_read_int(bs, 1); cfg->version = gf_bs_read_int(bs, 7); cfg->seq_profile = gf_bs_read_int(bs, 3); cfg->seq_level_idx_0 = gf_bs_read_int(bs, 5); cfg->seq_tier_0 = gf_bs_read_int(bs, 1); cfg->high_bitdepth = gf_bs_read_int(bs, 1); cfg->twelve_bit = gf_bs_read_int(bs, 1); cfg->monochrome = gf_bs_read_int(bs, 1); cfg->chroma_subsampling_x = gf_bs_read_int(bs, 1); cfg->chroma_subsampling_y = gf_bs_read_int(bs, 1); cfg->chroma_sample_position = gf_bs_read_int(bs, 2); reserved = gf_bs_read_int(bs, 3); if (reserved != 0 || cfg->marker != 1 || cfg->version != 1) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\n"", reserved, cfg->marker, cfg->version)); gf_odf_av1_cfg_del(cfg); return NULL; } cfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1); if (cfg->initial_presentation_delay_present) { cfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4); } else { gf_bs_read_int(bs, 4); cfg->initial_presentation_delay_minus_one = 0; } size -= 4; while (size) { u64 pos, obu_size; ObuType obu_type; GF_AV1_OBUArrayEntry *a; pos = gf_bs_get_position(bs); obu_size = 0; if (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[AV1] could not parse AV1 OBU at position ""LLU"". Leaving parsing.\n"", pos)); break; } assert(obu_size == gf_bs_get_position(bs) - pos); GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] parsed AV1 OBU type=%u size=""LLU"" at position ""LLU"".\n"", obu_type, obu_size, pos)); if (!av1_is_obu_header(obu_type)) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[AV1] AV1 unexpected OBU type=%u size=""LLU"" found at position ""LLU"". Forwarding.\n"", pos)); } GF_SAFEALLOC(a, GF_AV1_OBUArrayEntry); if (!a) break; a->obu = gf_malloc((size_t)obu_size); if (!a->obu) { gf_free(a); break; } gf_bs_seek(bs, pos); gf_bs_read_data(bs, (char *) a->obu, (u32)obu_size); a->obu_length = obu_size; a->obu_type = obu_type; gf_list_add(cfg->obu_array, a); if (size<obu_size) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[AV1] AV1 config misses %d bytes to fit the entire OBU\n"", obu_size - size)); break; } size -= (u32) obu_size; } gf_av1_reset_state(& state, GF_TRUE); return cfg; #else return NULL; #endif }"
"void Filter::onDownstreamEvent(Network::ConnectionEvent event) { ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(), static_cast<int>(event), upstream_ == nullptr); if (upstream_) { Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event)); if (conn_data != nullptr && conn_data->connection().state() != Network::Connection::State::Closed) { config_->drainManager().add(config_->sharedConfig(), std::move(conn_data), std::move(upstream_callbacks_), std::move(idle_timer_), read_callbacks_->upstreamHost()); } if (event != Network::ConnectionEvent::Connected) { upstream_.reset(); disableIdleTimer(); } } if (generic_conn_pool_) { if (event == Network::ConnectionEvent::LocalClose || event == Network::ConnectionEvent::RemoteClose) { generic_conn_pool_.reset(); } } }"
"static guint32 s7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb, proto_tree *data_tree, guint8 type,                 guint8 subfunc,              guint16 dlength,             guint32 offset)              { gboolean know_data = FALSE; guint32 offset_old; guint32 len_item; guint8 item_count; guint8 i; switch (subfunc) { case S7COMM_UD_SUBF_CYCLIC_MEM: item_count = tvb_get_guint8(tvb, offset + 1);      proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count); offset += 2; if (type == S7COMM_UD_TYPE_REQ) {                    proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; for (i = 0; i < item_count; i++) { offset_old = offset; offset = s7comm_decode_param_item(tvb, offset, data_tree, i); len_item = offset - offset_old; if ((len_item % 2) && (i < item_count)) { offset += 1; } } } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {    offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset); } know_data = TRUE; break; } if (know_data == FALSE && dlength > 4) { proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA); offset += dlength; } return offset; }"
"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block) { if (!block) { return; } QLIST_SAFE_REMOVE(block, next); uc->ram_list.mru_block = NULL; reclaim_ramblock(uc, block); }"
"void SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) { List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex); BufferInfo *outInfo = *outQueue.begin(); outQueue.erase(outQueue.begin()); OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader; OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId); outHeader->nTimeStamp = header->nTimeStamp; outHeader->nFlags = header->nFlags; outHeader->nFilledLen = mWidth * mHeight * 3 / 2; uint8_t *dst = outHeader->pBuffer + outHeader->nOffset; const uint8_t *srcY = data; const uint8_t *srcU = srcY + mWidth * mHeight; const uint8_t *srcV = srcU + mWidth * mHeight / 4; size_t srcYStride = mWidth; size_t srcUStride = mWidth / 2; size_t srcVStride = srcUStride; copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride); mPicToHeaderMap.removeItem(picId); delete header; outInfo->mOwnedByUs = false; notifyFillBufferDone(outHeader); }"
"TokenPreloadScanner::TokenPreloadScanner(const KURL& documentURL, PassOwnPtr<CachedDocumentParameters> documentParameters, const MediaValuesCached::MediaValuesCachedData& mediaValuesCachedData) : m_documentURL(documentURL) , m_inStyle(false) , m_inPicture(false) , m_inScript(false) , m_isAppCacheEnabled(false) , m_isCSPEnabled(false) , m_templateCount(0) , m_documentParameters(std::move(documentParameters)) , m_mediaValues(MediaValuesCached::create(mediaValuesCachedData)) , m_didRewind(false) { ASSERT(m_documentParameters.get()); ASSERT(m_mediaValues.get()); }"
"static void *bpf_any_get(void *raw, enum bpf_type type) { switch (type) { case BPF_TYPE_PROG: atomic_inc(&((struct bpf_prog *)raw)->aux->refcnt); break; case BPF_TYPE_MAP: bpf_map_inc(raw, true); break; default: WARN_ON_ONCE(1); break; } return raw; }"
"static char * isis_print_id(const uint8_t *cp, int id_len) { int i; static char id[sizeof(""xxxx.xxxx.xxxx.yy-zz"")]; char *pos = id; for (i = 1; i <= SYSTEM_ID_LEN; i++) { snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++); pos += strlen(pos); if (i == 2 || i == 4) *pos++ = '.'; } if (id_len >= NODE_ID_LEN) { snprintf(pos, sizeof(id) - (pos - id), "".%02x"", *cp++); pos += strlen(pos); } if (id_len == LSP_ID_LEN) snprintf(pos, sizeof(id) - (pos - id), ""-%02x"", *cp); return (id); }"
"int ParseRiffHeaderConfig (FILE *infile, char *infilename, char *fourcc, WavpackContext *wpc, WavpackConfig *config) { int is_rf64 = !strncmp (fourcc, ""RF64"", 4), got_ds64 = 0; int64_t total_samples = 0, infilesize; RiffChunkHeader riff_chunk_header; ChunkHeader chunk_header; WaveHeader WaveHeader; DS64Chunk ds64_chunk; uint32_t bcount; CLEAR (WaveHeader); CLEAR (ds64_chunk); infilesize = DoGetFileSize (infile); if (!is_rf64 && infilesize >= 4294967296LL && !(config->qmode & QMODE_IGNORE_LENGTH)) { error_line (""can't handle .WAV files larger than 4 GB (non-standard)!""); return WAVPACK_SOFT_ERROR; } memcpy (&riff_chunk_header, fourcc, 4); if ((!DoReadFile (infile, ((char *) &riff_chunk_header) + 4, sizeof (RiffChunkHeader) - 4, &bcount) || bcount != sizeof (RiffChunkHeader) - 4 || strncmp (riff_chunk_header.formType, ""WAVE"", 4))) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &riff_chunk_header, sizeof (RiffChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } while (1) { if (!DoReadFile (infile, &chunk_header, sizeof (ChunkHeader), &bcount) || bcount != sizeof (ChunkHeader)) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &chunk_header, sizeof (ChunkHeader))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackLittleEndianToNative (&chunk_header, ChunkHeaderFormat); if (!strncmp (chunk_header.ckID, ""ds64"", 4)) { if (chunk_header.ckSize < sizeof (DS64Chunk) || !DoReadFile (infile, &ds64_chunk, chunk_header.ckSize, &bcount) || bcount != chunk_header.ckSize) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &ds64_chunk, chunk_header.ckSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } got_ds64 = 1; WavpackLittleEndianToNative (&ds64_chunk, DS64ChunkFormat); if (debug_logging_mode) error_line (""DS64: riffSize = %lld, dataSize = %lld, sampleCount = %lld, table_length = %d"", (long long) ds64_chunk.riffSize64, (long long) ds64_chunk.dataSize64, (long long) ds64_chunk.sampleCount64, ds64_chunk.tableLength); if (ds64_chunk.tableLength * sizeof (CS64Chunk) != chunk_header.ckSize - sizeof (DS64Chunk)) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } while (ds64_chunk.tableLength--) { CS64Chunk cs64_chunk; if (!DoReadFile (infile, &cs64_chunk, sizeof (CS64Chunk), &bcount) || bcount != sizeof (CS64Chunk) || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &cs64_chunk, sizeof (CS64Chunk)))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } } } else if (!strncmp (chunk_header.ckID, ""fmt "", 4)) {                 int supported = TRUE, format;                         if (chunk_header.ckSize < 16 || chunk_header.ckSize > sizeof (WaveHeader) || !DoReadFile (infile, &WaveHeader, chunk_header.ckSize, &bcount) || bcount != chunk_header.ckSize) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } else if (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, &WaveHeader, chunk_header.ckSize)) { error_line (""%s"", WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } WavpackLittleEndianToNative (&WaveHeader, WaveHeaderFormat); if (debug_logging_mode) { error_line (""format tag size = %d"", chunk_header.ckSize); error_line (""FormatTag = %x, NumChannels = %d, BitsPerSample = %d"", WaveHeader.FormatTag, WaveHeader.NumChannels, WaveHeader.BitsPerSample); error_line (""BlockAlign = %d, SampleRate = %d, BytesPerSecond = %d"", WaveHeader.BlockAlign, WaveHeader.SampleRate, WaveHeader.BytesPerSecond); if (chunk_header.ckSize > 16) error_line (""cbSize = %d, ValidBitsPerSample = %d"", WaveHeader.cbSize, WaveHeader.ValidBitsPerSample); if (chunk_header.ckSize > 20) error_line (""ChannelMask = %x, SubFormat = %d"", WaveHeader.ChannelMask, WaveHeader.SubFormat); } if (chunk_header.ckSize > 16 && WaveHeader.cbSize == 2) config->qmode |= QMODE_ADOBE_MODE; format = (WaveHeader.FormatTag == 0xfffe && chunk_header.ckSize == 40) ? WaveHeader.SubFormat : WaveHeader.FormatTag; config->bits_per_sample = (chunk_header.ckSize == 40 && WaveHeader.ValidBitsPerSample) ? WaveHeader.ValidBitsPerSample : WaveHeader.BitsPerSample; if (format != 1 && format != 3) supported = FALSE; if (format == 3 && config->bits_per_sample != 32) supported = FALSE; if (!WaveHeader.NumChannels || WaveHeader.NumChannels > 256 || WaveHeader.BlockAlign / WaveHeader.NumChannels < (config->bits_per_sample + 7) / 8 || WaveHeader.BlockAlign / WaveHeader.NumChannels > 4 || WaveHeader.BlockAlign % WaveHeader.NumChannels) supported = FALSE; if (config->bits_per_sample < 1 || config->bits_per_sample > 32) supported = FALSE; if (!supported) { error_line (""%s is an unsupported .WAV format!"", infilename); return WAVPACK_SOFT_ERROR; } if (chunk_header.ckSize < 40) { if (!config->channel_mask && !(config->qmode & QMODE_CHANS_UNASSIGNED)) { if (WaveHeader.NumChannels <= 2) config->channel_mask = 0x5 - WaveHeader.NumChannels; else if (WaveHeader.NumChannels <= 18) config->channel_mask = (1 << WaveHeader.NumChannels) - 1; else config->channel_mask = 0x3ffff; } } else if (WaveHeader.ChannelMask && (config->channel_mask || (config->qmode & QMODE_CHANS_UNASSIGNED))) { error_line (""this WAV file already has channel order information!""); return WAVPACK_SOFT_ERROR; } else if (WaveHeader.ChannelMask) config->channel_mask = WaveHeader.ChannelMask; if (format == 3) config->float_norm_exp = 127; else if ((config->qmode & QMODE_ADOBE_MODE) && WaveHeader.BlockAlign / WaveHeader.NumChannels == 4) { if (WaveHeader.BitsPerSample == 24) config->float_norm_exp = 127 + 23; else if (WaveHeader.BitsPerSample == 32) config->float_norm_exp = 127 + 15; } if (debug_logging_mode) { if (config->float_norm_exp == 127) error_line (""data format: normalized 32-bit floating point""); else if (config->float_norm_exp) error_line (""data format: 32-bit floating point (Audition %d:%d float type 1)"", config->float_norm_exp - 126, 150 - config->float_norm_exp); else error_line (""data format: %d-bit integers stored in %d byte(s)"", config->bits_per_sample, WaveHeader.BlockAlign / WaveHeader.NumChannels); } } else if (!strncmp (chunk_header.ckID, ""data"", 4)) {              int64_t data_chunk_size = (got_ds64 && chunk_header.ckSize == (uint32_t) -1) ? ds64_chunk.dataSize64 : chunk_header.ckSize; if (!WaveHeader.NumChannels || (is_rf64 && !got_ds64)) {                   error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } if (infilesize && !(config->qmode & QMODE_IGNORE_LENGTH) && infilesize - data_chunk_size > 16777216) { error_line (""this .WAV file has over 16 MB of extra RIFF data, probably is corrupt!""); return WAVPACK_SOFT_ERROR; } if (config->qmode & QMODE_IGNORE_LENGTH) { if (infilesize && DoGetFilePosition (infile) != -1) total_samples = (infilesize - DoGetFilePosition (infile)) / WaveHeader.BlockAlign; else total_samples = -1; } else { total_samples = data_chunk_size / WaveHeader.BlockAlign; if (got_ds64 && total_samples != ds64_chunk.sampleCount64) { error_line (""%s is not a valid .WAV file!"", infilename); return WAVPACK_SOFT_ERROR; } if (!total_samples) { error_line (""this .WAV file has no audio samples, probably is corrupt!""); return WAVPACK_SOFT_ERROR; } if (total_samples > MAX_WAVPACK_SAMPLES) { error_line (""%s has too many samples for WavPack!"", infilename); return WAVPACK_SOFT_ERROR; } } config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels; config->num_channels = WaveHeader.NumChannels; config->sample_rate = WaveHeader.SampleRate; break; } else {           int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L; char *buff = malloc (bytes_to_copy); if (debug_logging_mode) error_line (""extra unknown chunk \""%c%c%c%c\"" of %d bytes"", chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2], chunk_header.ckID [3], chunk_header.ckSize); if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) || bcount != bytes_to_copy || (!(config->qmode & QMODE_NO_STORE_WRAPPER) && !WavpackAddWrapper (wpc, buff, bytes_to_copy))) { error_line (""%s"", WavpackGetErrorMessage (wpc)); free (buff); return WAVPACK_SOFT_ERROR; } free (buff); } } if (!WavpackSetConfiguration64 (wpc, config, total_samples, NULL)) { error_line (""%s: %s"", infilename, WavpackGetErrorMessage (wpc)); return WAVPACK_SOFT_ERROR; } return WAVPACK_NO_ERROR; }"
"GF_EXPORT GF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->avc_config) return NULL; return AVC_DuplicateConfig(entry->avc_config->config); }"
"static void stored_display_free (StoredDisplay *stored_display) { char *id; gdm_display_get_id (stored_display->display, &id, NULL); g_signal_emit (G_OBJECT (stored_display->store), signals[DISPLAY_REMOVED], 0, id); g_free (id); g_debug (""GdmDisplayStore: Unreffing display: %p"", stored_display->display); g_object_unref (stored_display->display); g_slice_free (StoredDisplay, stored_display); }"
"OMX_ERRORTYPE omx_vdec::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr) { unsigned int index = 0; if (bufferHdr == NULL || m_inp_mem_ptr == NULL) { return OMX_ErrorBadParameter; } index = bufferHdr - m_inp_mem_ptr; DEBUG_PRINT_LOW(""Free Input Buffer index = %d"",index); if (index < drv_ctx.ip_buf.actualcount && drv_ctx.ptr_inputbuffer) { DEBUG_PRINT_LOW(""Free Input Buffer index = %d"",index); if (drv_ctx.ptr_inputbuffer[index].pmem_fd > 0) { struct vdec_setbuffer_cmd setbuffers; setbuffers.buffer_type = VDEC_BUFFER_TYPE_INPUT; memcpy (&setbuffers.buffer,&drv_ctx.ptr_inputbuffer[index], sizeof (vdec_bufferpayload)); if (!secure_mode) { DEBUG_PRINT_LOW(""unmap the input buffer fd=%d"", drv_ctx.ptr_inputbuffer[index].pmem_fd); DEBUG_PRINT_LOW(""unmap the input buffer size=%u  address = %p"", (unsigned int)drv_ctx.ptr_inputbuffer[index].mmaped_size, drv_ctx.ptr_inputbuffer[index].bufferaddr); munmap (drv_ctx.ptr_inputbuffer[index].bufferaddr, drv_ctx.ptr_inputbuffer[index].mmaped_size); } close (drv_ctx.ptr_inputbuffer[index].pmem_fd); drv_ctx.ptr_inputbuffer[index].pmem_fd = -1; if (m_desc_buffer_ptr && m_desc_buffer_ptr[index].buf_addr) { free(m_desc_buffer_ptr[index].buf_addr); m_desc_buffer_ptr[index].buf_addr = NULL; m_desc_buffer_ptr[index].desc_data_size = 0; } #ifdef USE_ION free_ion_memory(&drv_ctx.ip_buf_ion_info[index]); #endif } } return OMX_ErrorNone; }"
"xfs_failaddr_t xfs_dinode_verify( struct xfs_mount*mp, xfs_ino_tino, struct xfs_dinode*dip) { xfs_failaddr_tfa; uint16_tmode; uint16_tflags; uint64_tflags2; uint64_tdi_size; if (dip->di_magic != cpu_to_be16(XFS_DINODE_MAGIC)) return __this_address; if (dip->di_version >= 3) { if (!xfs_sb_version_hascrc(&mp->m_sb)) return __this_address; if (!xfs_verify_cksum((char *)dip, mp->m_sb.sb_inodesize, XFS_DINODE_CRC_OFF)) return __this_address; if (be64_to_cpu(dip->di_ino) != ino) return __this_address; if (!uuid_equal(&dip->di_uuid, &mp->m_sb.sb_meta_uuid)) return __this_address; } di_size = be64_to_cpu(dip->di_size); if (di_size & (1ULL << 63)) return __this_address; mode = be16_to_cpu(dip->di_mode); if (mode && xfs_mode_to_ftype(mode) == XFS_DIR3_FT_UNKNOWN) return __this_address; if ((S_ISLNK(mode) || S_ISDIR(mode)) && di_size == 0) return __this_address; if (mode && be32_to_cpu(dip->di_nextents) + be16_to_cpu(dip->di_anextents) > be64_to_cpu(dip->di_nblocks)) return __this_address; if (mode && XFS_DFORK_BOFF(dip) > mp->m_sb.sb_inodesize) return __this_address; flags = be16_to_cpu(dip->di_flags); if (mode && (flags & XFS_DIFLAG_REALTIME) && !mp->m_rtdev_targp) return __this_address; switch (mode & S_IFMT) { case S_IFIFO: case S_IFCHR: case S_IFBLK: case S_IFSOCK: if (dip->di_format != XFS_DINODE_FMT_DEV) return __this_address; break; case S_IFREG: case S_IFLNK: case S_IFDIR: switch (dip->di_format) { case XFS_DINODE_FMT_LOCAL: if (S_ISREG(mode)) return __this_address; if (di_size > XFS_DFORK_DSIZE(dip, mp)) return __this_address; if (dip->di_nextents) return __this_address; case XFS_DINODE_FMT_EXTENTS: case XFS_DINODE_FMT_BTREE: break; default: return __this_address; } break; case 0: break; default: return __this_address; } if (XFS_DFORK_Q(dip)) { switch (dip->di_aformat) { case XFS_DINODE_FMT_LOCAL: if (dip->di_anextents) return __this_address; case XFS_DINODE_FMT_EXTENTS: case XFS_DINODE_FMT_BTREE: break; default: return __this_address; } } else { switch (dip->di_aformat) { case 0: case XFS_DINODE_FMT_EXTENTS: break; default: return __this_address; } if (dip->di_anextents) return __this_address; } fa = xfs_inode_validate_extsize(mp, be32_to_cpu(dip->di_extsize), mode, flags); if (fa) return fa; if (dip->di_version < 3) return NULL; flags2 = be64_to_cpu(dip->di_flags2); if ((flags2 & (XFS_DIFLAG2_REFLINK | XFS_DIFLAG2_COWEXTSIZE)) && !xfs_sb_version_hasreflink(&mp->m_sb)) return __this_address; if ((flags2 & XFS_DIFLAG2_REFLINK) && (mode & S_IFMT) != S_IFREG) return __this_address; if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags & XFS_DIFLAG_REALTIME)) return __this_address; if ((flags2 & XFS_DIFLAG2_REFLINK) && (flags2 & XFS_DIFLAG2_DAX)) return __this_address; fa = xfs_inode_validate_cowextsize(mp, be32_to_cpu(dip->di_cowextsize), mode, flags, flags2); if (fa) return fa; return NULL; }"
"int install_process_keyring_to_cred(struct cred *new) { struct key *keyring; if (new->process_keyring) return -EEXIST; keyring = keyring_alloc(""_pid"", new->uid, new->gid, new, KEY_POS_ALL | KEY_USR_VIEW, KEY_ALLOC_QUOTA_OVERRUN, NULL, NULL); if (IS_ERR(keyring)) return PTR_ERR(keyring); new->process_keyring = keyring; return 0; }"
"static zend_long php_str_replace_in_subject(zval *search, zval *replace, zval *subject, zval *result, int case_sensitivity) { zval*search_entry, *replace_entry = NULL; zend_string*tmp_result, *replace_entry_str = NULL; char*replace_value = NULL; size_t replace_len = 0; zend_long replace_count = 0; zend_string*subject_str; zend_string *lc_subject_str = NULL; uint32_t     replace_idx; subject_str = zval_get_string(subject); if (ZSTR_LEN(subject_str) == 0) { zend_string_release(subject_str); ZVAL_EMPTY_STRING(result); return 0; } if (Z_TYPE_P(search) == IS_ARRAY) { ZVAL_STR_COPY(result, subject_str); if (Z_TYPE_P(replace) == IS_ARRAY) { replace_idx = 0; } else { replace_value = Z_STRVAL_P(replace); replace_len = Z_STRLEN_P(replace); } ZEND_HASH_FOREACH_VAL(Z_ARRVAL_P(search), search_entry) { ZVAL_DEREF(search_entry); SEPARATE_ZVAL_NOREF(search_entry); convert_to_string(search_entry); if (Z_STRLEN_P(search_entry) == 0) { if (Z_TYPE_P(replace) == IS_ARRAY) { replace_idx++; } continue; } if (Z_TYPE_P(replace) == IS_ARRAY) { while (replace_idx < Z_ARRVAL_P(replace)->nNumUsed) { replace_entry = &Z_ARRVAL_P(replace)->arData[replace_idx].val; if (Z_TYPE_P(replace_entry) != IS_UNDEF) { break; } replace_idx++; } if (replace_idx < Z_ARRVAL_P(replace)->nNumUsed) { replace_entry_str = zval_get_string(replace_entry); replace_value = ZSTR_VAL(replace_entry_str); replace_len = ZSTR_LEN(replace_entry_str); replace_idx++; } else { replace_value = """"; replace_len = 0; } } if (Z_STRLEN_P(search_entry) == 1) { zend_long old_replace_count = replace_count; tmp_result = php_char_to_str_ex(Z_STR_P(result), Z_STRVAL_P(search_entry)[0], replace_value, replace_len, case_sensitivity, &replace_count); if (lc_subject_str && replace_count != old_replace_count) { zend_string_release(lc_subject_str); lc_subject_str = NULL; } } else if (Z_STRLEN_P(search_entry) > 1) { if (case_sensitivity) { tmp_result = php_str_to_str_ex(Z_STR_P(result), Z_STRVAL_P(search_entry), Z_STRLEN_P(search_entry), replace_value, replace_len, &replace_count); } else { zend_long old_replace_count = replace_count; if (!lc_subject_str) { lc_subject_str = php_string_tolower(Z_STR_P(result)); } tmp_result = php_str_to_str_i_ex(Z_STR_P(result), ZSTR_VAL(lc_subject_str), Z_STR_P(search_entry), replace_value, replace_len, &replace_count); if (replace_count != old_replace_count) { zend_string_release(lc_subject_str); lc_subject_str = NULL; } } } if (replace_entry_str) { zend_string_release(replace_entry_str); replace_entry_str = NULL; } zend_string_release(Z_STR_P(result)); ZVAL_STR(result, tmp_result); if (Z_STRLEN_P(result) == 0) { if (lc_subject_str) { zend_string_release(lc_subject_str); } zend_string_release(subject_str); return replace_count; } } ZEND_HASH_FOREACH_END(); if (lc_subject_str) { zend_string_release(lc_subject_str); } } else { if (Z_STRLEN_P(search) == 1) { ZVAL_STR(result, php_char_to_str_ex(subject_str, Z_STRVAL_P(search)[0], Z_STRVAL_P(replace), Z_STRLEN_P(replace), case_sensitivity, &replace_count)); } else if (Z_STRLEN_P(search) > 1) { if (case_sensitivity) { ZVAL_STR(result, php_str_to_str_ex(subject_str, Z_STRVAL_P(search), Z_STRLEN_P(search), Z_STRVAL_P(replace), Z_STRLEN_P(replace), &replace_count)); } else { lc_subject_str = php_string_tolower(Z_STR_P(subject)); ZVAL_STR(result, php_str_to_str_i_ex(subject_str, ZSTR_VAL(lc_subject_str), Z_STR_P(search), Z_STRVAL_P(replace), Z_STRLEN_P(replace), &replace_count)); zend_string_release(lc_subject_str); } } else { ZVAL_STR_COPY(result, subject_str); } } zend_string_release(subject_str); return replace_count; }"
"static int RegenerateThumbnail(const char * FileName) { char ThumbnailGenCommand[PATH_MAX*2+50]; if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){ return FALSE; } sprintf(ThumbnailGenCommand, ""mogrify -thumbnail %dx%d -quality 80 \""%s\"""", RegenThumbnail, RegenThumbnail, FileName); if (system(ThumbnailGenCommand) == 0){ return ReplaceThumbnail(FileName); }else{ ErrFatal(""Unable to run 'mogrify' command""); return FALSE; } }"
"int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe) { int n; if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; } if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX; return -1; } if(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1; n = (u32) AVI->video_index[AVI->video_pos].len; *keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0; if (vidbuf == NULL) { AVI->video_pos++; return n; } gf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET); if (avi_read(AVI->fdes,vidbuf,n) != (u32) n) { AVI_errno = AVI_ERR_READ; return -1; } AVI->video_pos++; return n; }"
"static void un_pair(uint8_t *addr1,uint8_t *addr2,size_t addr12len,size_t *depth1,size_t *depth2,const uint8_t *addr,size_t addrlen,size_t depth){ for(size_t i=0;i<addrlen*8/2;i++){ if(iptreet<uint64_t,32>::bit(addr,i*2))   iptreet<uint64_t,32>::setbit(addr1,i); if(iptreet<uint64_t,32>::bit(addr,i*2+1)) iptreet<uint64_t,32>::setbit(addr2,i); } *depth1 = (depth+1)/2; *depth2 = (depth)/2; }"
"static int decode_command(tvbuff_t *tvb, packet_info* pinfo, int msglen, int offset, int dst, proto_tree *pt) { guint32         cmd; guint32         context, ioctl_command; proto_tree      *ft; proto_item      *hi; gryphon_pkt_info_t *pkt_info; hi = proto_tree_add_item_ret_uint(pt, hf_gryphon_cmd, tvb, offset, 1, ENC_BIG_ENDIAN, &cmd); proto_item_set_hidden(hi); if (cmd > 0x3F) cmd += dst * 256; if (!pinfo->fd->visited) { gryphon_conversation *conv_data = get_conversation_data(pinfo); pkt_info = wmem_new0(wmem_file_scope(), gryphon_pkt_info_t); pkt_info->cmd = cmd; pkt_info->req_frame_num = pinfo->num; pkt_info->req_time = pinfo->abs_ts; wmem_list_prepend(conv_data->request_frame_data, pkt_info); p_add_proto_data(wmem_file_scope(), pinfo, proto_gryphon, (guint32)tvb_raw_offset(tvb), pkt_info); } else { pkt_info = (gryphon_pkt_info_t*)p_get_proto_data(wmem_file_scope(), pinfo, proto_gryphon, (guint32)tvb_raw_offset(tvb)); } proto_tree_add_uint(pt, hf_gryphon_command, tvb, offset, 1, cmd); proto_tree_add_item_ret_uint(pt, hf_gryphon_cmd_context, tvb, offset + 1, 1, ENC_NA, &context); if (!pinfo->fd->visited) { pkt_info->cmd_context = context; } proto_tree_add_item(pt, hf_gryphon_reserved, tvb, offset + 2, 2, ENC_NA); if (pkt_info->rsp_frame_num > 0) { proto_item* it = proto_tree_add_uint(pt, hf_gryphon_response_in, tvb, 0, 0, pkt_info->rsp_frame_num); proto_item_set_generated(it); } offset += 4; msglen -= 4; if (msglen > 0) { ft = proto_tree_add_subtree_format(pt, tvb, offset, msglen, ett_gryphon_command_data, NULL, ""Data: (%d byte%s)"", msglen, plurality(msglen, """", ""s"")); switch (cmd) { case CMD_INIT: offset = cmd_init(tvb, offset, ft); break; case CMD_EVENT_ENABLE: case CMD_EVENT_DISABLE: offset = eventnum(tvb, offset, ft); break; case CMD_SET_TIME: offset = resp_time(tvb, offset, ft); break; case CMD_CARD_SET_SPEED: offset = speed(tvb, offset, ft); break; case CMD_CARD_SET_FILTER: offset = cmd_setfilt(tvb, offset, ft); break; case CMD_CARD_GET_FILTER: offset = resp_addfilt(tvb, offset, ft); break; case CMD_CARD_TX: offset = decode_data(tvb, offset, ft); break; case CMD_CARD_ADD_FILTER: offset = cmd_addfilt(tvb, offset, ft); break; case CMD_CARD_MODIFY_FILTER: offset = cmd_modfilt(tvb, offset, ft); break; case CMD_CARD_SET_DEFAULT_FILTER: offset = dfiltmode(tvb, offset, ft); break; case CMD_CARD_SET_FILTER_MODE: offset = filtmode(tvb, offset, ft); break; case CMD_SERVER_REG: offset = cmd_register(tvb, offset, ft); break; case CMD_SERVER_SET_SORT: offset = cmd_sort(tvb, offset, ft); break; case CMD_SERVER_SET_OPT: offset = cmd_optimize(tvb, offset, ft); break; case CMD_BLM_SET_MODE: offset = blm_mode(tvb, offset, ft); break; case CMD_LDF_LIST: offset = cmd_ldf_list(tvb, offset, ft); break; case CMD_LDF_DELETE: offset = cmd_ldf_delete(tvb, offset, ft); break; case CMD_LDF_DESC: offset = cmd_ldf_desc(tvb, offset, ft); break; case CMD_LDF_UPLOAD: offset = cmd_ldf_upload(tvb, offset, ft); break; case CMD_LDF_PARSE: offset = cmd_ldf_parse(tvb, offset, ft); break; case CMD_GET_NODE_SIGNALS: offset = cmd_ldf_get_node_signals(tvb, offset, ft); break; case CMD_GET_FRAMES: offset = cmd_ldf_get_frames(tvb, offset, ft); break; case CMD_GET_FRAME_INFO: offset = cmd_ldf_get_frame_info(tvb, pinfo, offset, ft); break; case CMD_GET_SIGNAL_INFO: offset = cmd_ldf_get_signal_info(tvb, offset, ft); break; case CMD_GET_SIGNAL_DETAIL: offset = cmd_ldf_get_signal_detail(tvb, offset, ft); break; case CMD_GET_ENCODING_INFO: offset = cmd_ldf_get_encoding_info(tvb, offset, ft); break; case CMD_SAVE_SESSION: offset = cmd_ldf_save_session(tvb, offset, ft); break; case CMD_EMULATE_NODES: offset = cmd_ldf_emulate_nodes(tvb, pinfo, offset, ft); break; case CMD_START_SCHEDULE: offset = cmd_ldf_start_schedule(tvb, offset, ft); break; case CMD_RESTORE_SESSION: offset = cmd_restore_session(tvb, offset, ft); break; case CMD_CNVT_GET_VALUES: offset = cmd_cnvt_get_values(tvb, offset, ft); break; case CMD_CNVT_GET_UNITS: offset = cmd_cnvt_get_units(tvb, offset, ft); break; case CMD_CNVT_SET_VALUES: offset = cmd_cnvt_set_values(tvb, offset, ft); break; case CMD_CNVT_SAVE_SESSION: offset = cmd_ldf_save_session(tvb, offset, ft); break; case CMD_CNVT_RESTORE_SESSION: offset = cmd_restore_session(tvb, offset, ft); break; case CMD_CNVT_DESTROY_SESSION: offset = cmd_cnvt_destroy_session(tvb, offset, ft); break; case CMD_CNVT_GET_NODE_SIGNALS: offset = cmd_ldf_get_node_signals(tvb, offset, ft); break; case CMD_MSGRESP_ADD: offset = cmd_addresp(tvb, offset, pinfo, ft); break; case CMD_MSGRESP_GET: offset = resp_addresp(tvb, offset, ft); break; case CMD_MSGRESP_MODIFY: offset = cmd_modresp(tvb, offset, ft); break; case CMD_PGM_DESC: offset = cmd_desc(tvb, offset, ft); break; case CMD_PGM_UPLOAD: offset = cmd_upload(tvb, offset, ft); break; case CMD_PGM_DELETE: offset = cmd_delete(tvb, offset, ft); break; case CMD_PGM_LIST: offset = cmd_list(tvb, offset, ft); break; case CMD_PGM_START: offset = cmd_start(tvb, pinfo, offset, ft); break; case CMD_PGM_STOP: offset = resp_start(tvb, offset, ft); break; case CMD_PGM_STATUS: offset = cmd_delete(tvb, offset, ft); break; case CMD_PGM_OPTIONS: offset = cmd_options(tvb, offset, ft); break; case CMD_PGM_FILES: offset = cmd_files(tvb, offset, ft); break; case CMD_SCHED_TX: offset = cmd_sched(tvb, offset, ft); break; case CMD_SCHED_KILL_TX: offset = resp_sched(tvb, offset, ft); break; case CMD_SCHED_MSG_REPLACE: offset = cmd_sched_rep(tvb, offset, ft); break; case CMD_USDT_REGISTER: offset = cmd_usdt(tvb, offset, ft); break; case CMD_USDT_SET_FUNCTIONAL: offset = cmd_usdt(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_MULT: offset = cmd_usdt_set_stmin_mul(tvb, offset, ft); break; case CMD_USDT_REGISTER_NON_LEGACY: offset = cmd_usdt_register_non_legacy(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_FC: offset = cmd_usdt_stmin_fc(tvb, offset, ft); break; case CMD_USDT_SET_BSMAX_FC: offset = cmd_usdt_bsmax_fc(tvb, offset, ft); break; case CMD_USDT_SET_STMIN_OVERRIDE: offset = cmd_usdt_stmin_override(tvb, offset, ft); break; case CMD_USDT_ACTIVATE_STMIN_OVERRIDE: offset = cmd_usdt_stmin_override_activate(tvb, offset, ft); break; case CMD_IOPWR_CLRLATCH: offset = cmd_bits_in(tvb, offset, ft); break; case CMD_IOPWR_SETOUT: case CMD_IOPWR_SETBIT: case CMD_IOPWR_CLRBIT: offset = cmd_bits_out(tvb, offset, ft); break; case CMD_UTIL_SET_INIT_STRATEGY: offset = cmd_init_strat(tvb, offset, ft); break; case CMD_CARD_IOCTL: ioctl_command = tvb_get_ntohl(tvb, offset); if (!pinfo->fd->visited) { pkt_info->ioctl_command = ioctl_command; } offset = cmd_ioctl(tvb, pinfo, offset, ft, ioctl_command); break; default: proto_tree_add_item(ft, hf_gryphon_data, tvb, offset, msglen, ENC_NA); offset += msglen; break; } } return offset; }"
"static gint dissect_prefixed_bytes(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_, proto_tree *tree) { guint32     plen; proto_tree *prefixed_bytes_tree; proto_item *ti; plen = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item(tree, hf_bzr_bytes, tvb, offset, 4 + plen, ENC_NA); prefixed_bytes_tree = proto_item_add_subtree(ti, ett_prefixed_bytes); if (prefixed_bytes_tree) { proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_length, tvb, offset, 4, ENC_BIG_ENDIAN); proto_tree_add_item(prefixed_bytes_tree, hf_bzr_bytes_data, tvb, offset+4, plen, ENC_NA); } return 4 + plen; }"
"bool PackLinuxElf64::canPack() { union { unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)]; } u; COMPILE_TIME_ASSERT(sizeof(u) <= 1024) fi->readx(u.buf, sizeof(u.buf)); fi->seek(0, SEEK_SET); Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf; if (checkEhdr(ehdr) != 0) return false; if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) { throwCantPack(""invalid Ehdr e_ehsize; try '--force-execve'""); return false; } if (e_phoff != sizeof(*ehdr)) {        throwCantPack(""non-contiguous Ehdr/Phdr; try '--force-execve'""); return false; } Elf64_Phdr const *phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (j >= 14) { throwCantPack(""too many ElfXX_Phdr; try '--force-execve'""); return false; } unsigned const p_type = get_te32(&phdr->p_type); if (1!=exetype && PT_LOAD64 == p_type) {             exetype = 1; load_va = get_te64(&phdr->p_vaddr);              upx_uint64_t const p_offset = get_te64(&phdr->p_offset); upx_uint64_t const off = ~page_mask & load_va; if (off && off == p_offset) {                 throwCantPack(""Go-language PT_LOAD: try hemfix.c, or try '--force-execve'""); return false; } if (0 != p_offset) {                 throwCantPack(""first PT_LOAD.p_offset != 0; try '--force-execve'""); return false; } hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz)); break; } } if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) { alloc_file_image(file_image, file_size); fi->seek(0, SEEK_SET); fi->readx(file_image, file_size); memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr)); phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);          shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);   sec_strndx = NULL; shstrtab = NULL; if (e_shnum) { unsigned const e_shstrndx = get_te16(&ehdr->e_shstrndx); if (e_shstrndx) { if (e_shnum <= e_shstrndx) { char msg[40]; snprintf(msg, sizeof(msg), ""bad e_shstrndx %#x >= e_shnum %d"", e_shstrndx, e_shnum); throwCantPack(msg); } sec_strndx = &shdri[e_shstrndx]; upx_uint64_t sh_offset = get_te64(&sec_strndx->sh_offset); if ((u64_t)file_size <= sh_offset) { char msg[50]; snprintf(msg, sizeof(msg), ""bad .e_shstrndx->sh_offset %#lx"", (long unsigned)sh_offset); throwCantPack(msg); } shstrtab = (char const *)(sh_offset + file_image); } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { upx_uint64_t const sh_link = get_te64(&sec_dynsym->sh_link); if (e_shnum <= sh_link) { char msg[50]; snprintf(msg, sizeof(msg), ""bad SHT_DYNSYM.sh_link %#lx"", (long unsigned)sh_link); } sec_dynstr = &shdri[sh_link]; } if (sec_strndx) { unsigned const sh_name = get_te32(&sec_strndx->sh_name); if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type) || (u32_t)file_size <= sh_name                  || (sh_name && 0!=strcmp((char const *)"".shstrtab"", &shstrtab[sh_name])) ) { throwCantPack(""bad e_shstrndx""); } } } Elf64_Phdr const *pload_x0(0);          phdr= phdri; for (int j= e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image); invert_pt_dynamic(dynseg); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { if (!pload_x0 &&  Elf32_Phdr::PF_X & get_te32(&phdr->p_flags) ) { pload_x0 = phdr; } check_pt_load(phdr); } dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); if (opt->o_unix.force_pie ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ)) ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL), (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) { is_pie = true; goto proceed;          } if (elf_find_dynamic(upx_dt_init)) { if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) { throwCantPack(""DT_TEXTREL found; re-compile with -fPIC""); goto abandon; } if (!(Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1))) { if (Elf64_Ehdr::EM_AARCH64 == e_machine                  &&  !opt->o_unix.android_shlib                  ) { opt->info_mode++; info(""note: use --android-shlib if appropriate""); opt->info_mode--; } } Elf64_Shdr const *shdr = shdri; xct_va = ~0ull; if (e_shnum) { for (int j= e_shnum; --j>=0; ++shdr) { unsigned const sh_type = get_te32(&shdr->sh_type); if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) { xct_va = umin(xct_va, get_te64(&shdr->sh_addr)); } if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type) ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) { unsigned user_init_ava = get_te32(&shdr->sh_addr); user_init_off = get_te64(&shdr->sh_offset); if ((u64_t)file_size <= user_init_off) { char msg[70]; snprintf(msg, sizeof(msg), ""bad Elf64_Shdr[%d].sh_offset %#x"", -1+ e_shnum - j, user_init_off); throwCantPack(msg); } int z_rel = dt_table[Elf64_Dyn::DT_RELA]; int z_rsz = dt_table[Elf64_Dyn::DT_RELASZ]; if (z_rel && z_rsz) { unsigned rel_off = get_te64(&dynseg[-1+ z_rel].d_val); Elf64_Rela *rp = (Elf64_Rela *)&file_image[rel_off]; unsigned relsz   = get_te64(&dynseg[-1+ z_rsz].d_val); Elf64_Rela *last = (Elf64_Rela *)(relsz + (char *)rp); for (; rp < last; ++rp) { unsigned r_va = get_te64(&rp->r_offset); if (r_va == user_init_ava) {                                     unsigned r_info = get_te64(&rp->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_RELATIVE == r_type) { user_init_va = get_te64(&rp->r_addend); } else if (Elf64_Ehdr::EM_AARCH64 == e_machine &&  R_AARCH64_ABS64 == r_type) { user_init_va = get_te64(&file_image[user_init_off]); } else { char msg[50]; snprintf(msg, sizeof(msg), ""bad relocation %#x DT_INIT_ARRAY[0]"", r_info); throwCantPack(msg); } break; } } } unsigned const p_filesz = get_te64(&pload_x0->p_filesz); if (!((user_init_va - xct_va) < p_filesz)) { if (0==user_init_va && opt->o_unix.android_shlib) { upx_dt_init = 0;                                                              } else { char msg[70]; snprintf(msg, sizeof(msg), ""bad init address %#x in Elf64_Shdr[%d].%#x\n"", (unsigned)user_init_va, -1+ e_shnum - j, user_init_off); throwCantPack(msg); } } } if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init) &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) { unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn); Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)]; for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) { if (upx_dt_init == get_te64(&dynp->d_tag)) { break;                              } } if ((1+ dynp) < (n+ dynseg)) {                             user_init_va = get_te64(&dynp->d_val);                              set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT); user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0]; } } } } else {                 upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ); upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB); upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ); upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL); upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init); if ((init == (relsz + rel   ) && rel    == (strsz + strtab)) ||  (init == (strsz + strtab) && strtab == (relsz + rel   )) ) { xct_va = init; user_init_va = init; user_init_off = elf_get_offset_from_address(init); } } upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH); upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH); unsigned y = 0; if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash)) ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)) ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)) ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)) ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)) ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)) ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)) ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)) ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) { static char const *which[] = { ""unknown"", ""DT_GNU_HASH"", ""DT_HASH"", ""DT_STRTAB"", ""DT_SYMTAB"", ""DT_REL"", ""DT_RELA"", ""DT_JMPREL"", ""DT_VERDEF"", ""DT_VERSYM"", ""DT_VERNEEDED"", }; char buf[30]; snprintf(buf, sizeof(buf), ""%s above stub"", which[y]); throwCantPack(buf); goto abandon; } if (!opt->o_unix.android_shlib) { phdr = phdri; for (unsigned j= 0; j < e_phnum; ++phdr, ++j) { upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr); if (PT_NOTE64 == get_te32(&phdr->p_type) && xct_va < vaddr) { char buf[40]; snprintf(buf, sizeof(buf), ""PT_NOTE %#lx above stub"", (unsigned long)vaddr); throwCantPack(buf); goto abandon; } } } xct_off = elf_get_offset_from_address(xct_va); if (opt->debug.debug_level) { fprintf(stderr, ""shlib canPack: xct_va=%#lx  xct_off=%#lx\n"", (long)xct_va, (long)xct_off); } goto proceed;          } else throwCantPack(""need DT_INIT; try \""void _init(void){}\""""); abandon: return false; proceed: ; } if (!super::canPack()) return false; assert(exetype == 1); exetype = 0; opt->o_unix.blocksize = blocksize = file_size; return true; }"
"static void arc_emac_tx_clean(struct net_device *ndev) { struct arc_emac_priv *priv = netdev_priv(ndev); struct net_device_stats *stats = &ndev->stats; unsigned int i; for (i = 0; i < TX_BD_NUM; i++) { unsigned int *txbd_dirty = &priv->txbd_dirty; struct arc_emac_bd *txbd = &priv->txbd[*txbd_dirty]; struct buffer_state *tx_buff = &priv->tx_buff[*txbd_dirty]; struct sk_buff *skb = tx_buff->skb; unsigned int info = le32_to_cpu(txbd->info); if ((info & FOR_EMAC) || !txbd->data) break; if (unlikely(info & (DROP | DEFR | LTCL | UFLO))) { stats->tx_errors++; stats->tx_dropped++; if (info & DEFR) stats->tx_carrier_errors++; if (info & LTCL) stats->collisions++; if (info & UFLO) stats->tx_fifo_errors++; } else if (likely(info & FIRST_OR_LAST_MASK)) { stats->tx_packets++; stats->tx_bytes += skb->len; } dma_unmap_single(&ndev->dev, dma_unmap_addr(tx_buff, addr), dma_unmap_len(tx_buff, len), DMA_TO_DEVICE); dev_kfree_skb_irq(skb); txbd->data = 0; txbd->info = 0; *txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM; } smp_mb(); if (netif_queue_stopped(ndev) && arc_emac_tx_avail(priv)) netif_wake_queue(ndev); }"
"static void gdCtxPrintf(gdIOCtx * out, const char *format, ...) { char buf[4096]; int len; va_list args; va_start(args, format); len = vsnprintf(buf, sizeof(buf)-1, format, args); va_end(args); out->putBuf(out, buf, len); }"
"int main() { WEBCC_LOG_INIT("""", webcc::LOG_CONSOLE); webcc::ClientSession session; webcc::ResponsePtr r; try { r = session.Send(webcc::RequestBuilder{}. Get(""http:                     Query(""name"", Utf16ToUtf8(L""顾春庭""), true) ()); assert(r->status() == webcc::Status::kOK); } catch (const webcc::Error& error) { std::cerr << error << std::endl; return 1; } return 0; }"
"void APar_ExtractTrackDetails(char *uint32_buffer, FILE *isofile, Trackage *track, TrackInfo *track_info) { uint64_t _offset = 0; APar_TrackLevelInfo(track, ""tkhd""); if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8) == 0) { if (APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 11) & 1) { track_info->track_enabled = true; } track_info->creation_time = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 12); track_info->modified_time = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 16); track_info->duration = APar_read32(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 28); } else { track_info->creation_time = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 12); track_info->modified_time = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 20); track_info->duration = APar_read64(uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 36); } APar_TrackLevelInfo(track, ""mdhd""); memset(uint32_buffer, 0, 5); uint16_t packed_language = APar_read16( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 28); memset(track_info->unpacked_lang, 0, 4); APar_UnpackLanguage( track_info->unpacked_lang, packed_language);  APar_TrackLevelInfo(track, ""hdlr""); memset(uint32_buffer, 0, 5); track_info->track_type = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 16); if (track_info->track_type == 0x736F756E) {     track_info->type_of_track = AUDIO_TRACK; } else if (track_info->track_type == 0x76696465) {     track_info->type_of_track = VIDEO_TRACK; } if (parsedAtoms[track->track_atom].AtomicLength > 34) { memset(track_info->track_hdlr_name, 0, 100); APar_readX(track_info->track_hdlr_name, isofile, parsedAtoms[track->track_atom].AtomicStart + 32, parsedAtoms[track->track_atom].AtomicLength - 32); } APar_TrackLevelInfo(track, ""stsd""); memset(uint32_buffer, 0, 5); track_info->track_codec = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 20); if (track_info->type_of_track & VIDEO_TRACK) {     track_info->video_width = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 32); track_info->video_height = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 34); track_info->macroblocks = (track_info->video_width / 16) * (track_info->video_height / 16); if (track_info->track_codec == 0x61766331 || track_info->track_codec == 0x64726D69) {       track_info->contains_esds = false; APar_TrackLevelInfo(track, ""avcC""); track_info->avc_version = APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 8); if (track_info->avc_version == 1) { track_info->profile = APar_read8(isofile, parsedAtoms[track->track_atom].AtomicStart + 9); track_info->level = APar_read8( isofile, parsedAtoms[track->track_atom].AtomicStart + 11); } } else if (track_info->track_codec == 0x73323633) {       APar_TrackLevelInfo(track, ""d263""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""d263"", 4) == 0) { APar_Extract_d263_Info( uint32_buffer, isofile, track->track_atom, track_info); } } else {       APar_TrackLevelInfo(track, ""esds""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""esds"", 4) == 0) { APar_Extract_esds_Info( uint32_buffer, isofile, track->track_atom - 1, track_info);                                } else if (track_info->track_codec == 0x73323633) {         track_info->type_of_track = VIDEO_TRACK; } else if (track_info->track_codec == 0x73616D72 || track_info->track_codec == 0x73617762 || track_info->track_codec == 0x73617770 || track_info->track_codec == 0x73766D72) {         track_info->type_of_track = AUDIO_TRACK; } else { track_info->type_of_track = OTHER_TRACK;                                                        } } } else if (track_info->type_of_track & AUDIO_TRACK) { if (track_info->track_codec == 0x73616D72 || track_info->track_codec == 0x73617762 || track_info->track_codec == 0x73617770 || track_info->track_codec == 0x73766D72) {       APar_Extract_AMR_Info( uint32_buffer, isofile, track->track_atom + 2, track_info); } else if (track_info->track_codec == 0x73657663) {       APar_TrackLevelInfo(track, ""devc""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""devc"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info); } } else if (track_info->track_codec == 0x73716370) {       APar_TrackLevelInfo(track, ""dqcp""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""dqcp"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info);       } } else if (track_info->track_codec == 0x73736D76) {       APar_TrackLevelInfo(track, ""dsmv""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""dsmv"", 4) == 0) { APar_Extract_devc_Info(isofile, track->track_atom, track_info);       } } else { APar_Extract_esds_Info( uint32_buffer, isofile, track->track_atom, track_info); } } if ((track_info->type_of_track & AUDIO_TRACK || track_info->type_of_track & VIDEO_TRACK) && track_info->avg_bitrate == 0) { if (track_info->track_codec == 0x616C6163) {       track_info->channels = APar_read16(uint32_buffer, isofile, parsedAtoms[track->track_atom + 1].AtomicStart + 24); } } APar_TrackLevelInfo(track, ""stsz""); if (memcmp(parsedAtoms[track->track_atom].AtomicName, ""stsz"", 4) == 0) { track_info->sample_aggregate = calcuate_sample_size(uint32_buffer, isofile, track->track_atom); } if (track_info->track_codec >= 0x64726D00 && track_info->track_codec <= 0x64726DFF) { track_info->type_of_track += DRM_PROTECTED_TRACK; APar_TrackLevelInfo(track, ""frma""); memset(uint32_buffer, 0, 5); track_info->protected_codec = APar_read32( uint32_buffer, isofile, parsedAtoms[track->track_atom].AtomicStart + 8); } if (track_info->contains_esds) { APar_TrackLevelInfo(track, ""esds""); _offset = APar_FindValueInAtom( uint32_buffer, isofile, track->track_atom, 24, 0x01B2); if (_offset > 0 && _offset < parsedAtoms[track->track_atom].AtomicLength) { _offset += 2; memset(track_info->encoder_name, 0, parsedAtoms[track->track_atom].AtomicLength - _offset); APar_readX(track_info->encoder_name, isofile, parsedAtoms[track->track_atom].AtomicStart + _offset, parsedAtoms[track->track_atom].AtomicLength - _offset); } } return; }"
"static int parseNormalModeParameters(IsoPresentation* self, uint8_t* buffer, int totalLength, int bufPos) { int endPos = bufPos + totalLength; self->calledPresentationSelector.size = 0; self->callingPresentationSelector.size = 0; bool hasUserData = false; while (bufPos < endPos) { uint8_t tag = buffer[bufPos++]; int len; if (bufPos == endPos) { if (DEBUG_PRES) printf(""PRES: invalid message\n""); return -1; } bufPos = BerDecoder_decodeLength(buffer, &len, bufPos, endPos); if (bufPos < 0) { if (DEBUG_PRES) printf(""PRES: wrong parameter length\n""); return -1; } switch (tag) { case 0x81:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: calling-presentation-sel too large\n""); } else { self->callingPresentationSelector.size = len; int i; for (i = 0; i < len; i++) self->callingPresentationSelector.value[i] = buffer[bufPos + i]; } bufPos += len; break; case 0x82:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: called-presentation-sel too large\n""); } else { self->calledPresentationSelector.size = len; int i; for (i = 0; i < len; i++) self->calledPresentationSelector.value[i] = buffer[bufPos + i]; } bufPos += len; break; case 0x83:  if (len > 16) { if (DEBUG_PRES) printf(""PRES: responding-presentation-sel too large\n""); } bufPos += len; break; case 0xa4:  if (DEBUG_PRES) printf(""PRES: pcd list\n""); bufPos = parsePresentationContextDefinitionList(self, buffer, len, bufPos); break; case 0xa5:  bufPos += len; break; case 0x61:  if (DEBUG_PRES) printf(""PRES: user-data\n""); bufPos = parseFullyEncodedData(self, buffer, len, bufPos); if (bufPos < 0) return -1; if (self->nextPayload.size > 0) hasUserData = true; break; case 0x00:  break; default: if (DEBUG_PRES) printf(""PRES: unknown tag in normal-mode\n""); bufPos += len; break; } } if (hasUserData == false) { if (DEBUG_PRES) printf(""PRES: user-data is missing\n""); return -1; } return bufPos; }"
"static void dissect_client_player_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, guint offset, guint length_remaining) { const guint8 *player_info; proto_tree_add_item(tree, hf_msmms_command_prefix1, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset += 4; proto_tree_add_item(tree, hf_msmms_command_prefix2, tvb, offset, 4, ENC_LITTLE_ENDIAN); offset += 4; offset += 4; proto_tree_add_item_ret_string(tree, hf_msmms_command_client_player_info, tvb, offset, length_remaining-12, ENC_UTF_16|ENC_LITTLE_ENDIAN, pinfo->pool, &player_info); col_append_fstr(pinfo->cinfo, COL_INFO, "" (%s)"", format_text(pinfo->pool, (const guchar*)player_info, strlen(player_info))); }"
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr, size_t *rot_buf_size) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, col_offset, pix_offset; tmsize_t buffsize; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; if ((spp != 0 && bps != 0 && width > (uint32_t)((UINT32_MAX - 7) / spp / bps)) || (spp != 0 && bps != 0 && length > (uint32_t)((UINT32_MAX - 7) / spp / bps))) { TIFFError(""rotateImage"", ""Integer overflow detected.""); return (-1); } rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) { if (((tmsize_t)colsize + 1) != 0 && (tmsize_t)width > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) / ((tmsize_t)colsize + 1))) { TIFFError(""rotateImage"", ""Integer overflow when calculating buffer size.""); return (-1); } buffsize = ((tmsize_t)colsize + 1) * width; } else { if (((tmsize_t)rowsize + 1) != 0 && (tmsize_t)length > ((TIFF_TMSIZE_T_MAX - NUM_BUFF_OVERSIZE_BYTES) / ((tmsize_t)rowsize + 1))) { TIFFError(""rotateImage"", ""Integer overflow when calculating buffer size.""); return (-1); } buffsize = (rowsize + 1) * length; } bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %"" TIFF_SSIZE_FORMAT "" bytes "", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); if (rot_buf_size != NULL) *rot_buf_size = buffsize; ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"static void process_COM (const uchar * Data, int length) { int ch; char Comment[MAX_COMMENT_SIZE+1]; int nch; int a; nch = 0; if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE;  for (a=2;a<length;a++){ ch = Data[a]; if (ch == '\r' && Data[a+1] == '\n') continue;  if (ch >= 32 || ch == '\n' || ch == '\t'){ Comment[nch++] = (char)ch; }else{ Comment[nch++] = '?'; } } Comment[nch] = '\0';  if (ShowTags){ printf(""COM marker comment: %s\n"",Comment); } strcpy(ImageInfo.Comments,Comment); }"
"void CClient::ProcessServerPacket(CNetChunk *pPacket) { CUnpacker Unpacker; Unpacker.Reset(pPacket->m_pData, pPacket->m_DataSize); int Msg = Unpacker.GetInt(); int Sys = Msg&1; Msg >>= 1; if(Unpacker.Error()) return; if(Sys) { if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_CHANGE) { const char *pMap = Unpacker.GetString(CUnpacker::SANITIZE_CC|CUnpacker::SKIP_START_WHITESPACES); int MapCrc = Unpacker.GetInt(); int MapSize = Unpacker.GetInt(); const char *pError = 0; if(Unpacker.Error()) return; if(!m_MapChecker.IsMapValid(pMap, MapCrc, MapSize)) pError = ""invalid standard map""; for(int i = 0; pMap[i]; i++) { if(pMap[i] == '/' || pMap[i] == '\\') pError = ""strange character in map name""; } if(MapSize < 0) pError = ""invalid map size""; if(pError) DisconnectWithReason(pError); else { pError = LoadMapSearch(pMap, MapCrc); if(!pError) { m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, ""client/network"", ""loading done""); SendReady(); } else { str_format(m_aMapdownloadFilename, sizeof(m_aMapdownloadFilename), ""downloadedmaps/%s_%08x.map"", pMap, MapCrc); char aBuf[256]; str_format(aBuf, sizeof(aBuf), ""starting to download map to '%s'"", m_aMapdownloadFilename); m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, ""client/network"", aBuf); m_MapdownloadChunk = 0; str_copy(m_aMapdownloadName, pMap, sizeof(m_aMapdownloadName)); if(m_MapdownloadFile) io_close(m_MapdownloadFile); m_MapdownloadFile = Storage()->OpenFile(m_aMapdownloadFilename, IOFLAG_WRITE, IStorage::TYPE_SAVE); m_MapdownloadCrc = MapCrc; m_MapdownloadTotalsize = MapSize; m_MapdownloadAmount = 0; CMsgPacker Msg(NETMSG_REQUEST_MAP_DATA); Msg.AddInt(m_MapdownloadChunk); SendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH); if(g_Config.m_Debug) { str_format(aBuf, sizeof(aBuf), ""requested chunk %d"", m_MapdownloadChunk); m_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, ""client/network"", aBuf); } } } } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_MAP_DATA) { int Last = Unpacker.GetInt(); int MapCRC = Unpacker.GetInt(); int Chunk = Unpacker.GetInt(); int Size = Unpacker.GetInt(); const unsigned char *pData = Unpacker.GetRaw(Size); if(Unpacker.Error() || Size <= 0 || MapCRC != m_MapdownloadCrc || Chunk != m_MapdownloadChunk || !m_MapdownloadFile) return; io_write(m_MapdownloadFile, pData, Size); m_MapdownloadAmount += Size; if(Last) { const char *pError; m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, ""client/network"", ""download complete, loading map""); if(m_MapdownloadFile) io_close(m_MapdownloadFile); m_MapdownloadFile = 0; m_MapdownloadAmount = 0; m_MapdownloadTotalsize = -1; pError = LoadMap(m_aMapdownloadName, m_aMapdownloadFilename, m_MapdownloadCrc); if(!pError) { m_pConsole->Print(IConsole::OUTPUT_LEVEL_ADDINFO, ""client/network"", ""loading done""); SendReady(); } else DisconnectWithReason(pError); } else { m_MapdownloadChunk++; CMsgPacker Msg(NETMSG_REQUEST_MAP_DATA); Msg.AddInt(m_MapdownloadChunk); SendMsgEx(&Msg, MSGFLAG_VITAL|MSGFLAG_FLUSH); if(g_Config.m_Debug) { char aBuf[256]; str_format(aBuf, sizeof(aBuf), ""requested chunk %d"", m_MapdownloadChunk); m_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, ""client/network"", aBuf); } } } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_CON_READY) { GameClient()->OnConnected(); } else if(Msg == NETMSG_PING) { CMsgPacker Msg(NETMSG_PING_REPLY); SendMsgEx(&Msg, 0); } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_ADD) { const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC); const char *pHelp = Unpacker.GetString(CUnpacker::SANITIZE_CC); const char *pParams = Unpacker.GetString(CUnpacker::SANITIZE_CC); if(Unpacker.Error() == 0) m_pConsole->RegisterTemp(pName, pParams, CFGFLAG_SERVER, pHelp); } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_CMD_REM) { const char *pName = Unpacker.GetString(CUnpacker::SANITIZE_CC); if(Unpacker.Error() == 0) m_pConsole->DeregisterTemp(pName); } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_AUTH_STATUS) { int Result = Unpacker.GetInt(); if(Unpacker.Error() == 0) m_RconAuthed = Result; int Old = m_UseTempRconCommands; m_UseTempRconCommands = Unpacker.GetInt(); if(Unpacker.Error() != 0) m_UseTempRconCommands = 0; if(Old != 0 && m_UseTempRconCommands == 0) m_pConsole->DeregisterTempAll(); } else if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0 && Msg == NETMSG_RCON_LINE) { const char *pLine = Unpacker.GetString(); if(Unpacker.Error() == 0) GameClient()->OnRconLine(pLine); } else if(Msg == NETMSG_PING_REPLY) { char aBuf[256]; str_format(aBuf, sizeof(aBuf), ""latency %.2f"", (time_get() - m_PingStartTime)*1000 / (float)time_freq()); m_pConsole->Print(IConsole::OUTPUT_LEVEL_STANDARD, ""client/network"", aBuf); } else if(Msg == NETMSG_INPUTTIMING) { int InputPredTick = Unpacker.GetInt(); int TimeLeft = Unpacker.GetInt(); int64 Target = 0; for(int k = 0; k < 200; k++) { if(m_aInputs[k].m_Tick == InputPredTick) { Target = m_aInputs[k].m_PredictedTime + (time_get() - m_aInputs[k].m_Time); Target = Target - (int64)(((TimeLeft-PREDICTION_MARGIN)/1000.0f)*time_freq()); break; } } if(Target) m_PredictedTime.Update(&m_InputtimeMarginGraph, Target, TimeLeft, 1); } else if(Msg == NETMSG_SNAP || Msg == NETMSG_SNAPSINGLE || Msg == NETMSG_SNAPEMPTY) { int NumParts = 1; int Part = 0; int GameTick = Unpacker.GetInt(); int DeltaTick = GameTick-Unpacker.GetInt(); int PartSize = 0; int Crc = 0; int CompleteSize = 0; const char *pData = 0; if(State() < IClient::STATE_LOADING) return; if(Msg == NETMSG_SNAP) { NumParts = Unpacker.GetInt(); Part = Unpacker.GetInt(); } if(Msg != NETMSG_SNAPEMPTY) { Crc = Unpacker.GetInt(); PartSize = Unpacker.GetInt(); } pData = (const char *)Unpacker.GetRaw(PartSize); if(Unpacker.Error()) return; if(GameTick >= m_CurrentRecvTick) { if(GameTick != m_CurrentRecvTick) { m_SnapshotParts = 0; m_CurrentRecvTick = GameTick; } mem_copy((char*)m_aSnapshotIncommingData + Part*MAX_SNAPSHOT_PACKSIZE, pData, PartSize); m_SnapshotParts |= 1<<Part; if(m_SnapshotParts == (unsigned)((1<<NumParts)-1)) { static CSnapshot Emptysnap; CSnapshot *pDeltaShot = &Emptysnap; int PurgeTick; void *pDeltaData; int DeltaSize; unsigned char aTmpBuffer2[CSnapshot::MAX_SIZE]; unsigned char aTmpBuffer3[CSnapshot::MAX_SIZE]; CSnapshot *pTmpBuffer3 = (CSnapshot*)aTmpBuffer3;int SnapSize; CompleteSize = (NumParts-1) * MAX_SNAPSHOT_PACKSIZE + PartSize; m_SnapshotParts = 0; Emptysnap.Clear(); if(DeltaTick >= 0) { int DeltashotSize = m_SnapshotStorage.Get(DeltaTick, 0, &pDeltaShot, 0); if(DeltashotSize < 0) { if(g_Config.m_Debug) { char aBuf[256]; str_format(aBuf, sizeof(aBuf), ""error, couldn't find the delta snapshot""); m_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, ""client"", aBuf); } m_AckGameTick = -1; return; } } pDeltaData = m_SnapshotDelta.EmptyDelta(); DeltaSize = sizeof(int)*3; if(CompleteSize) { int IntSize = CVariableInt::Decompress(m_aSnapshotIncommingData, CompleteSize, aTmpBuffer2); if(IntSize < 0) return; pDeltaData = aTmpBuffer2; DeltaSize = IntSize; } SnapSize = m_SnapshotDelta.UnpackDelta(pDeltaShot, pTmpBuffer3, pDeltaData, DeltaSize); if(SnapSize < 0) { m_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, ""client"", ""delta unpack failed!""); return; } if(Msg != NETMSG_SNAPEMPTY && pTmpBuffer3->Crc() != Crc) { if(g_Config.m_Debug) { char aBuf[256]; str_format(aBuf, sizeof(aBuf), ""snapshot crc error #%d - tick=%d wantedcrc=%d gotcrc=%d compressed_size=%d delta_tick=%d"", m_SnapCrcErrors, GameTick, Crc, pTmpBuffer3->Crc(), CompleteSize, DeltaTick); m_pConsole->Print(IConsole::OUTPUT_LEVEL_DEBUG, ""client"", aBuf); } m_SnapCrcErrors++; if(m_SnapCrcErrors > 10) { m_AckGameTick = -1; SendInput(); m_SnapCrcErrors = 0; } return; } else { if(m_SnapCrcErrors) m_SnapCrcErrors--; } PurgeTick = DeltaTick; if(m_aSnapshots[SNAP_PREV] && m_aSnapshots[SNAP_PREV]->m_Tick < PurgeTick) PurgeTick = m_aSnapshots[SNAP_PREV]->m_Tick; if(m_aSnapshots[SNAP_CURRENT] && m_aSnapshots[SNAP_CURRENT]->m_Tick < PurgeTick) PurgeTick = m_aSnapshots[SNAP_CURRENT]->m_Tick; m_SnapshotStorage.PurgeUntil(PurgeTick); m_SnapshotStorage.Add(GameTick, time_get(), SnapSize, pTmpBuffer3, 1); if(m_DemoRecorder.IsRecording()) { m_DemoRecorder.RecordSnapshot(GameTick, pTmpBuffer3, SnapSize); } m_RecivedSnapshots++; m_CurrentRecvTick = GameTick; if(m_RecivedSnapshots == 2) { m_PredictedTime.Init(GameTick*time_freq()/50); m_PredictedTime.SetAdjustSpeed(1, 1000.0f); m_GameTime.Init((GameTick-1)*time_freq()/50); m_aSnapshots[SNAP_PREV] = m_SnapshotStorage.m_pFirst; m_aSnapshots[SNAP_CURRENT] = m_SnapshotStorage.m_pLast; m_LocalStartTime = time_get(); SetState(IClient::STATE_ONLINE); DemoRecorder_HandleAutoStart(); } if(m_RecivedSnapshots > 2) { int64 Now = m_GameTime.Get(time_get()); int64 TickStart = GameTick*time_freq()/50; int64 TimeLeft = (TickStart-Now)*1000 / time_freq(); m_GameTime.Update(&m_GametimeMarginGraph, (GameTick-1)*time_freq()/50, TimeLeft, 0); } m_AckGameTick = GameTick; } } } } else { if((pPacket->m_Flags&NET_CHUNKFLAG_VITAL) != 0) { if(m_DemoRecorder.IsRecording()) m_DemoRecorder.RecordMessage(pPacket->m_pData, pPacket->m_DataSize); GameClient()->OnMessage(Msg, &Unpacker); } } }"
"static inline RandomInfo **AcquireRandomInfoThreadSet(void) { register ssize_t i; RandomInfo **random_info; size_t number_threads; number_threads=(size_t) GetMagickResourceLimit(ThreadResource); random_info=(RandomInfo **) AcquireAlignedMemory(number_threads, sizeof(*random_info)); if (random_info == (RandomInfo **) NULL) return((RandomInfo **) NULL); (void) ResetMagickMemory(random_info,0,number_threads*sizeof(*random_info)); for (i=0; i < (ssize_t) number_threads; i++) { random_info[i]=AcquireRandomInfo(); if (random_info[i] == (RandomInfo *) NULL) return(DestroyRandomInfoThreadSet(random_info)); } return(random_info); }"
"static FT_Error tt_size_select( FT_Size   size, FT_ULong  strike_index ) { TT_Face   ttface = (TT_Face)size->face; TT_Size   ttsize = (TT_Size)size; FT_Error  error  = FT_Err_Ok; ttsize->strike_index = strike_index; if ( FT_IS_SCALABLE( size->face ) ) { FT_Select_Metrics( size->face, strike_index ); tt_size_reset( ttsize, 0 );  } else { SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt; FT_Size_Metrics*  size_metrics = &size->metrics; error = sfnt->load_strike_metrics( ttface, strike_index, size_metrics ); if ( error ) ttsize->strike_index = 0xFFFFFFFFUL; } return error; }"
"tmsize_t TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size) { static const char module[] = ""TIFFReadEncodedStrip""; TIFFDirectory *td = &tif->tif_dir; uint32 rowsperstrip; uint32 stripsperplane; uint32 stripinplane; uint16 plane; uint32 rows; tmsize_t stripsize; if (!TIFFCheckRead(tif,0)) return((tmsize_t)(-1)); if (strip>=td->td_nstrips) { TIFFErrorExt(tif->tif_clientdata,module, ""%lu: Strip out of range, max %lu"",(unsigned long)strip, (unsigned long)td->td_nstrips); return((tmsize_t)(-1)); } rowsperstrip=td->td_rowsperstrip; if (rowsperstrip>td->td_imagelength) rowsperstrip=td->td_imagelength; stripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip); stripinplane=(strip%stripsperplane); plane=(uint16)(strip/stripsperplane); rows=td->td_imagelength-stripinplane*rowsperstrip; if (rows>rowsperstrip) rows=rowsperstrip; stripsize=TIFFVStripSize(tif,rows); if (stripsize==0) return((tmsize_t)(-1)); if( td->td_compression == COMPRESSION_NONE && size!=(tmsize_t)(-1) && size >= stripsize && !isMapped(tif) && ((tif->tif_flags&TIFF_NOREADRAW)==0) ) { if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize) return ((tmsize_t)(-1)); if (!isFillOrder(tif, td->td_fillorder) && (tif->tif_flags & TIFF_NOBITREV) == 0) TIFFReverseBits(buf,stripsize); (*tif->tif_postdecode)(tif,buf,stripsize); return (stripsize); } if ((size!=(tmsize_t)(-1))&&(size<stripsize)) stripsize=size; if (!TIFFFillStrip(tif,strip)) return((tmsize_t)(-1)); if ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0) return((tmsize_t)(-1)); (*tif->tif_postdecode)(tif,buf,stripsize); return(stripsize); }"
"static VALUE ossl_pkey_new_from_data(int argc, VALUE *argv, VALUE self) { EVP_PKEY *pkey; BIO *bio; VALUE data, pass; rb_scan_args(argc, argv, ""11"", &data, &pass); pass = ossl_pem_passwd_value(pass); bio = ossl_obj2bio(&data); if (!(pkey = d2i_PrivateKey_bio(bio, NULL))) { OSSL_BIO_reset(bio); if (!(pkey = PEM_read_bio_PrivateKey(bio, NULL, ossl_pem_passwd_cb, (void *)pass))) { OSSL_BIO_reset(bio); if (!(pkey = d2i_PUBKEY_bio(bio, NULL))) { OSSL_BIO_reset(bio); pkey = PEM_read_bio_PUBKEY(bio, NULL, ossl_pem_passwd_cb, (void *)pass); } } } BIO_free(bio); if (!pkey) ossl_raise(ePKeyError, ""Could not parse PKey""); return ossl_pkey_new(pkey); }"
"static GF_List *dasher_get_content_protection_desc(GF_DasherCtx *ctx, GF_DashStream *ds, GF_MPD_AdaptationSet *for_set) { char sCan[40]; u32 prot_scheme=0; u32 i, count; const GF_PropertyValue *p; GF_List *res = NULL; GF_BitStream *bs_r; count = gf_list_count(ctx->current_period->streams); bs_r = gf_bs_new((const char *) &count, 1, GF_BITSTREAM_READ); for (i=0; i<count; i++) { GF_MPD_Descriptor *desc; GF_DashStream *a_ds = gf_list_get(ctx->current_period->streams, i); if (!a_ds->is_encrypted) continue; if (for_set) { if (a_ds->set != for_set) continue; if (!a_ds->owns_set) continue; } else if ((a_ds != ds) && (a_ds->muxed_base != ds) ) { continue; } p = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE); if (p) prot_scheme = p->value.uint; if ((prot_scheme==GF_ISOM_CENC_SCHEME) || (prot_scheme==GF_ISOM_CBC_SCHEME) || (prot_scheme==GF_ISOM_CENS_SCHEME) || (prot_scheme==GF_ISOM_CBCS_SCHEME) ) { const GF_PropertyValue *ki; u32 j, nb_pssh; GF_XMLAttribute *att; char szVal[GF_MAX_PATH]; ctx->use_cenc = GF_TRUE; ki = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_KEY_INFO); if (!ki || !ki->value.data.ptr) { continue; } if (!res) res = gf_list_new(); desc = gf_mpd_descriptor_new(NULL, ""urn:mpeg:dash:mp4protection:2011"", gf_4cc_to_str(prot_scheme)); gf_list_add(res, desc); get_canon_urn(ki->value.data.ptr + 4, sCan); att = gf_xml_dom_create_attribute(""cenc:default_KID"", sCan); if (!desc->x_attributes) desc->x_attributes = gf_list_new(); gf_list_add(desc->x_attributes, att); if (ctx->pssh <= GF_DASH_PSSH_MOOF) { continue; } p = gf_filter_pid_get_property(a_ds->ipid, GF_PROP_PID_CENC_PSSH); if (!p) continue; gf_bs_reassign_buffer(bs_r, p->value.data.ptr, p->value.data.size); nb_pssh = gf_bs_read_u32(bs_r); for (j=0; j<nb_pssh; j++) { u32 pssh_idx; bin128 sysID; GF_XMLNode *node; u32 version, k_count; u8 *pssh_data=NULL; u32 pssh_len, size_64; GF_BitStream *bs_w = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE); gf_bs_write_u32(bs_w, 0); gf_bs_write_u32(bs_w, GF_ISOM_BOX_TYPE_PSSH); gf_bs_read_data(bs_r, sysID, 16); version = gf_bs_read_u32(bs_r); k_count = version ? gf_bs_read_u32(bs_r) : 0; gf_bs_write_u8(bs_w, version); gf_bs_write_u24(bs_w, 0); gf_bs_write_data(bs_w, sysID, 16); if (version) { gf_bs_write_u32(bs_w, k_count); for (j=0; j<k_count; j++) { bin128 keyID; gf_bs_read_data(bs_r, keyID, 16); gf_bs_write_data(bs_w, keyID, 16); } } k_count = gf_bs_read_u32(bs_r); gf_bs_write_u32(bs_w, k_count); for (pssh_idx=0; pssh_idx<k_count; pssh_idx++) { gf_bs_write_u8(bs_w, gf_bs_read_u8(bs_r) ); } pssh_len = (u32) gf_bs_get_position(bs_w); gf_bs_seek(bs_w, 0); gf_bs_write_u32(bs_w, pssh_len); gf_bs_seek(bs_w, pssh_len); gf_bs_get_content(bs_w, &pssh_data, &pssh_len); gf_bs_del(bs_w); get_canon_urn(sysID, sCan); desc = gf_mpd_descriptor_new(NULL, NULL, NULL); desc->x_children = gf_list_new(); sprintf(szVal, ""urn:uuid:%s"", sCan); desc->scheme_id_uri = gf_strdup(szVal); desc->value = gf_strdup(get_drm_kms_name(sCan)); gf_list_add(res, desc); GF_SAFEALLOC(node, GF_XMLNode); if (node) { GF_XMLNode *pnode; node->type = GF_XML_NODE_TYPE; node->name = gf_strdup(""cenc:pssh""); node->content = gf_list_new(); gf_list_add(desc->x_children, node); GF_SAFEALLOC(pnode, GF_XMLNode); if (pnode) { pnode->type = GF_XML_TEXT_TYPE; gf_list_add(node->content, pnode); size_64 = 2*pssh_len; pnode->name = gf_malloc(size_64); if (pnode->name) { size_64 = gf_base64_encode((const char *)pssh_data, pssh_len, (char *)pnode->name, size_64); pnode->name[size_64] = 0; } } } gf_free(pssh_data); } } else { if (ctx->do_mpd) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, (""[Dasher] Protection scheme %s has no official DASH mapping, using URI \""urn:gpac:dash:mp4protection:2018\""\n"", gf_4cc_to_str(prot_scheme))); } if (!res) res = gf_list_new(); desc = gf_mpd_descriptor_new(NULL, ""urn:gpac:dash:mp4protection:2018"", gf_4cc_to_str(prot_scheme)); gf_list_add(res, desc); } } gf_bs_del(bs_r); return res; }"
"int __close_fd_get_file(unsigned int fd, struct file **res) { struct files_struct *files = current->files; struct file *file; struct fdtable *fdt; spin_lock(&files->file_lock); fdt = files_fdtable(files); if (fd >= fdt->max_fds) goto out_unlock; file = fdt->fd[fd]; if (!file) goto out_unlock; rcu_assign_pointer(fdt->fd[fd], NULL); __put_unused_fd(files, fd); spin_unlock(&files->file_lock); get_file(file); *res = file; return filp_close(file, files); out_unlock: spin_unlock(&files->file_lock); *res = NULL; return -ENOENT; }"
"static UINT urbdrc_process_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 MessageId, IUDEVMAN* udevman) { UINT32 InterfaceId; UINT32 IoControlCode; UINT32 InputBufferSize; UINT32 OutputBufferSize; UINT32 RequestId; UINT32 usbd_status = USBD_STATUS_SUCCESS; wStream* out; int success = 0; URBDRC_PLUGIN* urbdrc; if (!callback || !s || !udevman || !pdev) return ERROR_INVALID_PARAMETER; urbdrc = (URBDRC_PLUGIN*)callback->plugin; if (!urbdrc) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 8) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, IoControlCode); Stream_Read_UINT32(s, InputBufferSize); if (!Stream_SafeSeek(s, InputBufferSize)) return ERROR_INVALID_DATA; if (Stream_GetRemainingLength(s) < 8ULL) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, OutputBufferSize); Stream_Read_UINT32(s, RequestId); InterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev)); out = urb_create_iocompletion(InterfaceId, MessageId, RequestId, OutputBufferSize + 4); if (!out) return ERROR_OUTOFMEMORY; switch (IoControlCode) { case IOCTL_INTERNAL_USB_SUBMIT_URB:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_SUBMIT_URB""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_SUBMIT_URB: Unchecked""); break; case IOCTL_INTERNAL_USB_RESET_PORT:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_RESET_PORT""); break; case IOCTL_INTERNAL_USB_GET_PORT_STATUS:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_GET_PORT_STATUS""); success = pdev->query_device_port_status(pdev, &usbd_status, &OutputBufferSize, Stream_Pointer(out)); if (success) { if (!Stream_SafeSeek(out, OutputBufferSize)) { Stream_Free(out, TRUE); return ERROR_INVALID_DATA; } if (pdev->isExist(pdev) == 0) Stream_Write_UINT32(out, 0); else usb_process_get_port_status(pdev, out); } break; case IOCTL_INTERNAL_USB_CYCLE_PORT:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_CYCLE_PORT""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_CYCLE_PORT: Unchecked""); break; case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:  WLog_Print(urbdrc->log, WLOG_DEBUG, ""ioctl: IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION""); WLog_Print(urbdrc->log, WLOG_ERROR, "" Function IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: Unchecked""); break; default: WLog_Print(urbdrc->log, WLOG_DEBUG, ""urbdrc_process_io_control: unknown IoControlCode 0x%"" PRIX32 """", IoControlCode); Stream_Free(out, TRUE); return ERROR_INVALID_OPERATION; } return stream_write_and_free(callback->plugin, callback->channel, out); }"
"static gint dissect_mp4_stsz_body(tvbuff_t *tvb, gint offset, gint len _U_, packet_info *pinfo _U_, proto_tree *tree) { gint offset_start; guint32  sample_size, sample_count, i; offset_start = offset; sample_size = tvb_get_ntohl(tvb, offset); proto_tree_add_item(tree, hf_mp4_stsz_sample_size, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; sample_count = tvb_get_ntohl(tvb, offset); proto_tree_add_item(tree, hf_mp4_stsz_sample_count, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; if (sample_size != 0) return offset - offset_start; for (i=0; i<sample_count; i++) { proto_tree_add_item(tree, hf_mp4_stsz_entry_size, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; } return offset - offset_start; }"
"void brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event) { struct brcmf_if *ifp; struct brcmf_bus *bus_if = dev_get_drvdata(dev); struct brcmf_pub *drvr = bus_if->drvr; brcmf_dbg(DATA, ""Enter: %s: rxp=%p\n"", dev_name(dev), skb); if (brcmf_rx_hdrpull(drvr, skb, &ifp)) return; if (brcmf_proto_is_reorder_skb(skb)) { brcmf_proto_rxreorder(ifp, skb); } else { if (handle_event) brcmf_fweh_process_skb(ifp->drvr, skb); brcmf_netif_rx(ifp, skb); } }"
"static int run_post_create(const char *dirname) { if (!dir_is_in_dump_location(dirname)) { error_msg(""Bad problem directory name '%s', should start with: '%s'"", dirname, g_settings_dump_location); return 400;  } if (!dir_has_correct_permissions(dirname)) { error_msg(""Problem directory '%s' isn't owned by root:abrt or others are not restricted from access"", dirname); return 400;  } if (g_settings_privatereports) { struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY); const bool complete = dd && problem_dump_dir_is_complete(dd); dd_close(dd); if (complete) { error_msg(""Problem directory '%s' has already been processed"", dirname); return 403; } } else if (!dump_dir_accessible_by_uid(dirname, client_uid)) { if (errno == ENOTDIR) { error_msg(""Path '%s' isn't problem directory"", dirname); return 404;  } error_msg(""Problem directory '%s' can't be accessed by user with uid %ld"", dirname, (long)client_uid); return 403;  } int child_stdout_fd; int child_pid = spawn_event_handler_child(dirname, ""post-create"", &child_stdout_fd); char *dup_of_dir = NULL; struct strbuf *cmd_output = strbuf_new(); bool child_is_post_create = 1;  read_child_output: for (;;) { char buf[250];  errno = 0; int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1); if (r <= 0) break; buf[r] = '\0'; char *raw = buf; char *newline; while ((newline = strchr(raw, '\n')) != NULL) { *newline = '\0'; strbuf_append_str(cmd_output, raw); char *msg = cmd_output->buf; log(""%s"", msg); if (child_is_post_create && prefixcmp(msg, ""DUP_OF_DIR: "") == 0 ) { free(dup_of_dir); dup_of_dir = xstrdup(msg + strlen(""DUP_OF_DIR: "")); } strbuf_clear(cmd_output); raw = newline + 1; } strbuf_append_str(cmd_output, raw); } int status = 0; if (safe_waitpid(child_pid, &status, 0) <= 0) perror_msg(""waitpid(%d)"", child_pid); if (!child_is_post_create) goto ret; if (status != 0) { if (WIFSIGNALED(status)) { log(""'post-create' on '%s' killed by signal %d"", dirname, WTERMSIG(status)); goto delete_bad_dir; } if (!dup_of_dir) { log(""'post-create' on '%s' exited with %d"", dirname, WEXITSTATUS(status)); goto delete_bad_dir; } } const char *work_dir = (dup_of_dir ? dup_of_dir : dirname); struct dump_dir *dd = dd_opendir(work_dir,  0); if (!dd) goto delete_bad_dir; char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT); unsigned long count = strtoul(count_str, NULL, 10); if ((status != 0 && dup_of_dir) || count == 0) { count++; char new_count_str[sizeof(long)*3 + 2]; sprintf(new_count_str, ""%lu"", count); dd_save_text(dd, FILENAME_COUNT, new_count_str); if (strcmp(dd->dd_dirname, dirname) != 0) { struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY); char *last_ocr = NULL; if (new_dd) { last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT); dd_close(new_dd); } else {    error_msg(""Can't read the last occurrence file from the new dump directory.""); } if (!last_ocr) {    log(""Using current time for the last occurrence file which may be incorrect.""); time_t t = time(NULL); last_ocr = xasprintf(""%lu"", (long)t); } dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr); free(last_ocr); } } dd_sanitize_mode_and_owner(dd); dd_close(dd); if (!dup_of_dir) log_notice(""New problem directory %s, processing"", work_dir); else { log_warning(""Deleting problem directory %s (dup of %s)"", strrchr(dirname, '/') + 1, strrchr(dup_of_dir, '/') + 1); delete_dump_dir(dirname); } int fd; child_pid = spawn_event_handler_child( work_dir, (dup_of_dir ? ""notify-dup"" : ""notify""), &fd ); xmove_fd(fd, child_stdout_fd); child_is_post_create = 0; strbuf_clear(cmd_output); free(dup_of_dir); dup_of_dir = NULL; goto read_child_output; delete_bad_dir: log_warning(""Deleting problem directory '%s'"", dirname); delete_dump_dir(dirname); ret: strbuf_free(cmd_output); free(dup_of_dir); close(child_stdout_fd); return 0; }"
"PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args) { DWORD accessmask, acerevision, aceflags; BOOL bAuditSuccess, bAuditFailure; PyObject *obSID; GUID ObjectTypeGuid, InheritedObjectTypeGuid; GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL; PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid; BOOL bsuccess; PSID psid; PACL psacl; PyACL *This = (PyACL *)self; psacl = This->GetACL(); PACL psacl_padded = NULL; if (addauditaccessobjectace == NULL) return PyErr_Format(PyExc_NotImplementedError, ""AddAuditAccessObjectAce not supported by this version of Windows""); if (!PyArg_ParseTuple(args, ""lllOOOii:AddAuditAccessObjectAce"", &acerevision, &aceflags, &accessmask, &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure)) return NULL; if (obObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid)) return NULL; pObjectTypeGuid = &ObjectTypeGuid; } if (obInheritedObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid)) return NULL; pInheritedObjectTypeGuid = &InheritedObjectTypeGuid; } if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (!bsuccess) { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err); unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid); psacl_padded = (ACL *)malloc(required_size); if (psacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"", required_size); ZeroMemory(psacl_padded, required_size); memcpy(psacl_padded, psacl, psacl->AclSize); psacl_padded->AclSize = required_size; bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (bsuccess) bsuccess = This->SetACL(psacl_padded); else PyWin_SetAPIError(""AddAuditAccessObjectAce""); } if (psacl_padded) free(psacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }"
"bool ParseState::do_string(CephContext* cct, const char* s, size_t l) { auto k = pp->tokens.lookup(s, l); Policy& p = pp->policy; bool is_action = false; bool is_validaction = false; Statement* t = p.statements.empty() ? nullptr : &(p.statements.back()); if ((w->id == TokenID::Version) && k && k->kind == TokenKind::version_key) { p.version = static_cast<Version>(k->specific); } else if (w->id == TokenID::Id) { p.id = string(s, l); } else if (w->id == TokenID::Sid) { t->sid.emplace(s, l); } else if ((w->id == TokenID::Effect) && k->kind == TokenKind::effect_key) { t->effect = static_cast<Effect>(k->specific); } else if (w->id == TokenID::Principal && s && *s == '*') { t->princ.emplace(Principal::wildcard()); } else if (w->id == TokenID::NotPrincipal && s && *s == '*') { t->noprinc.emplace(Principal::wildcard()); } else if ((w->id == TokenID::Action) || (w->id == TokenID::NotAction)) { is_action = true; for (auto& p : actpairs) { if (match_policy({s, l}, p.name, MATCH_POLICY_ACTION)) { is_validaction = true; (w->id == TokenID::Action ? t->action : t->notaction) |= p.bit; } } } else if (w->id == TokenID::Resource || w->id == TokenID::NotResource) { auto a = ARN::parse({s, l}, true); if (a && (a->account.empty() || a->account == pp->tenant || a->account == ""*"")) { if (a->account.empty() || a->account == ""*"") a->account = pp->tenant; (w->id == TokenID::Resource ? t->resource : t->notresource) .emplace(std::move(*a)); } else ldout(cct, 0) << ""Supplied resource is discarded: "" << string(s, l) << dendl; } else if (w->kind == TokenKind::cond_key) { auto& t = pp->policy.statements.back(); t.conditions.back().vals.emplace_back(s, l); } else if (w->kind == TokenKind::princ_type) { ceph_assert(pp->s.size() > 1); auto& pri = pp->s[pp->s.size() - 2].w->id == TokenID::Principal ? t->princ : t->noprinc; auto o = parse_principal(pp->cct, w->id, string(s, l)); if (o) pri.emplace(std::move(*o)); } else { return false; } if (!arraying) { pp->s.pop_back(); } if (is_action && !is_validaction){ return false; } return true; }"
"int cmnd_matches_all(const struct sudoers_parse_tree *parse_tree, const struct member *m, const char *runchroot, struct cmnd_info *info) { const bool negated = m->negated; struct sudo_command *c; int matched = UNSPEC; struct alias *a; debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH); switch (m->type) { case ALL: c = (struct sudo_command *)m->name; if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot, info, &c->digests)) matched = negated ? DENY : ALLOW; break; case ALIAS: a = alias_get(parse_tree, m->name, CMNDALIAS); if (a != NULL) { TAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) { matched = cmnd_matches_all(parse_tree, m, runchroot, info); if (matched != UNSPEC) { if (negated) matched = matched == ALLOW ? DENY : ALLOW; break; } } alias_put(a); } break; } debug_return_int(matched); }"
"int usbnet_probe (struct usb_interface *udev, const struct usb_device_id *prod) { struct usbnet*dev; struct net_device*net; struct usb_host_interface*interface; struct driver_info*info; struct usb_device*xdev; intstatus; const char*name; struct usb_driver *driver = to_usb_driver(udev->dev.driver); if (!driver->supports_autosuspend) { driver->supports_autosuspend = 1; pm_runtime_enable(&udev->dev); } name = udev->dev.driver->name; info = (struct driver_info *) prod->driver_info; if (!info) { dev_dbg (&udev->dev, ""blacklisted by %s\n"", name); return -ENODEV; } xdev = interface_to_usbdev (udev); interface = udev->cur_altsetting; status = -ENOMEM; net = alloc_etherdev(sizeof(*dev)); if (!net) goto out; SET_NETDEV_DEV(net, &udev->dev); dev = netdev_priv(net); dev->udev = xdev; dev->intf = udev; dev->driver_info = info; dev->driver_name = name; dev->msg_enable = netif_msg_init (msg_level, NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK); init_waitqueue_head(&dev->wait); skb_queue_head_init (&dev->rxq); skb_queue_head_init (&dev->txq); skb_queue_head_init (&dev->done); skb_queue_head_init(&dev->rxq_pause); dev->bh.func = usbnet_bh; dev->bh.data = (unsigned long) dev; INIT_WORK (&dev->kevent, usbnet_deferred_kevent); init_usb_anchor(&dev->deferred); dev->delay.function = usbnet_bh; dev->delay.data = (unsigned long) dev; init_timer (&dev->delay); mutex_init (&dev->phy_mutex); mutex_init(&dev->interrupt_mutex); dev->interrupt_count = 0; dev->net = net; strcpy (net->name, ""usb%d""); memcpy (net->dev_addr, node_id, sizeof node_id); dev->hard_mtu = net->mtu + net->hard_header_len; net->netdev_ops = &usbnet_netdev_ops; net->watchdog_timeo = TX_TIMEOUT_JIFFIES; net->ethtool_ops = &usbnet_ethtool_ops; if (info->bind) { status = info->bind (dev, udev); if (status < 0) goto out1; if ((dev->driver_info->flags & FLAG_ETHER) != 0 && ((dev->driver_info->flags & FLAG_POINTTOPOINT) == 0 || (net->dev_addr [0] & 0x02) == 0)) strcpy (net->name, ""eth%d""); if ((dev->driver_info->flags & FLAG_WLAN) != 0) strcpy(net->name, ""wlan%d""); if ((dev->driver_info->flags & FLAG_WWAN) != 0) strcpy(net->name, ""wwan%d""); if ((dev->driver_info->flags & FLAG_NOARP) != 0) net->flags |= IFF_NOARP; if (net->mtu > (dev->hard_mtu - net->hard_header_len)) net->mtu = dev->hard_mtu - net->hard_header_len; } else if (!info->in || !info->out) status = usbnet_get_endpoints (dev, udev); else { dev->in = usb_rcvbulkpipe (xdev, info->in); dev->out = usb_sndbulkpipe (xdev, info->out); if (!(info->flags & FLAG_NO_SETINT)) status = usb_set_interface (xdev, interface->desc.bInterfaceNumber, interface->desc.bAlternateSetting); else status = 0; } if (status >= 0 && dev->status) status = init_status (dev, udev); if (status < 0) goto out3; if (!dev->rx_urb_size) dev->rx_urb_size = dev->hard_mtu; dev->maxpacket = usb_maxpacket (dev->udev, dev->out, 1); if (ether_addr_equal(net->dev_addr, node_id)) net->addr_assign_type = NET_ADDR_RANDOM; if ((dev->driver_info->flags & FLAG_WLAN) != 0) SET_NETDEV_DEVTYPE(net, &wlan_type); if ((dev->driver_info->flags & FLAG_WWAN) != 0) SET_NETDEV_DEVTYPE(net, &wwan_type); usbnet_update_max_qlen(dev); if (dev->can_dma_sg && !(info->flags & FLAG_SEND_ZLP) && !(info->flags & FLAG_MULTI_PACKET)) { dev->padding_pkt = kzalloc(1, GFP_KERNEL); if (!dev->padding_pkt) { status = -ENOMEM; goto out4; } } status = register_netdev (net); if (status) goto out5; netif_info(dev, probe, dev->net, ""register '%s' at usb-%s-%s, %s, %pM\n"", udev->dev.driver->name, xdev->bus->bus_name, xdev->devpath, dev->driver_info->description, net->dev_addr); usb_set_intfdata (udev, dev); netif_device_attach (net); if (dev->driver_info->flags & FLAG_LINK_INTR) usbnet_link_change(dev, 0, 0); return 0; out5: kfree(dev->padding_pkt); out4: usb_free_urb(dev->interrupt); out3: if (info->unbind) info->unbind (dev, udev); out1: free_netdev(net); out: return status; }"
"bool WebContents::SendIPCMessageToFrame(bool internal, int32_t frame_id, const std::string& channel, v8::Local<v8::Value> args) { v8::Isolate* isolate = JavascriptEnvironment::GetIsolate(); blink::CloneableMessage message; if (!gin::ConvertFromV8(isolate, args, &message)) { isolate->ThrowException(v8::Exception::Error( gin::StringToV8(isolate, ""Failed to serialize arguments""))); return false; } auto frames = web_contents()->GetAllFrames(); auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) { return f->GetRoutingID() == frame_id; }); if (iter == frames.end()) return false; if (!(*iter)->IsRenderFrameLive()) return false; mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer; (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer); electron_renderer->Message(internal, channel, std::move(message), 0 ); return true; }"
"bool  XmlRpcUtil::findTag(const char* tag, std::string const& xml, int* offset) { if (*offset >= int(xml.length())) return false; size_t istart = xml.find(tag, *offset); if (istart == std::string::npos) return false; *offset = int(istart + strlen(tag)); return true; }"
"void install_local_socket(asocket* s) { adb_mutex_lock(&socket_list_lock); s->id = local_socket_next_id++; if (local_socket_next_id == 0) { local_socket_next_id = 1; } insert_local_socket(s, &local_socket_list); adb_mutex_unlock(&socket_list_lock); }"
static const char * markdown_anchor(const char *text) { char          *bufptr;                 static char   buffer[1024];            for (bufptr = buffer; *text && bufptr < (buffer + sizeof(buffer) - 1); text ++) { if ((*text >= '0' && *text <= '9') || (*text >= 'a' && *text <= 'z') || (*text >= 'A' && *text <= 'Z') || *text == '.' || *text == '-') *bufptr++ = (char)tolower(*text); else if (*text == ' ') *bufptr++ = '-'; } *bufptr = '\0'; return (buffer); }
"static void perf_group_detach(struct perf_event *event) { struct perf_event *leader = event->group_leader; struct perf_event *sibling, *tmp; struct perf_event_context *ctx = event->ctx; lockdep_assert_held(&ctx->lock); if (!(event->attach_state & PERF_ATTACH_GROUP)) return; event->attach_state &= ~PERF_ATTACH_GROUP; perf_put_aux_event(event); if (leader != event) { list_del_init(&event->sibling_list); event->group_leader->nr_siblings--; goto out; } list_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) { if (sibling->event_caps & PERF_EV_CAP_SIBLING) perf_remove_sibling_event(sibling); sibling->group_leader = sibling; list_del_init(&sibling->sibling_list); sibling->group_caps = event->group_caps; if (sibling->attach_state & PERF_ATTACH_CONTEXT) { add_event_to_groups(sibling, event->ctx); if (sibling->state == PERF_EVENT_STATE_ACTIVE) list_add_tail(&sibling->active_list, get_event_list(sibling)); } WARN_ON_ONCE(sibling->ctx != event->ctx); } out: for_each_sibling_event(tmp, leader) perf_event__header_size(tmp); perf_event__header_size(leader); }"
"bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const { if (!IsIdentity(node) && !IsIdentityN(node)) { return true; } if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) { return false; } if (!fetch_nodes_known_) { return false; } const NodeDef* input = node_map_->GetNode(NodeName(node.input(0))); CHECK(input != nullptr) << ""node = "" << node.name() << "" input = "" << node.input(0); if (IsVariable(*input) || IsRecv(*input)) { return false; } for (const auto& consumer : node_map_->GetOutputs(node.name())) { if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) { return false; } if (IsSwitch(*input)) { for (const string& consumer_input : consumer->input()) { if (consumer_input == AsControlDependency(node.name())) { return false; } } } } return true; }"
"static gboolean check_permission (GVfsBackendAdmin *self, GVfsJob *job) { GVfsJobDBus *dbus_job = G_VFS_JOB_DBUS (job); GError *error = NULL; GDBusMethodInvocation *invocation; GDBusConnection *connection; GCredentials *credentials; pid_t pid; uid_t uid; PolkitSubject *subject; PolkitAuthorizationResult *result; gboolean is_authorized; invocation = dbus_job->invocation; connection = g_dbus_method_invocation_get_connection (invocation); credentials = g_dbus_connection_get_peer_credentials (connection); pid = g_credentials_get_unix_pid (credentials, &error); if (error != NULL) { g_vfs_job_failed_from_error (job, error); g_error_free (error); return FALSE; } uid = g_credentials_get_unix_user (credentials, &error); if (error != NULL) { g_vfs_job_failed_from_error (job, error); g_error_free (error); return FALSE; } g_mutex_lock (&self->polkit_mutex); subject = polkit_unix_process_new_for_owner (pid, 0, uid); result = polkit_authority_check_authorization_sync (self->authority, subject, ""org.gtk.vfs.file-operations"", NULL, POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION, NULL, &error); g_object_unref (subject); g_mutex_unlock (&self->polkit_mutex); if (error != NULL) { g_vfs_job_failed_from_error (job, error); g_error_free (error); return FALSE; } is_authorized = polkit_authorization_result_get_is_authorized (result) || polkit_authorization_result_get_is_challenge (result); g_object_unref (result); if (!is_authorized) g_vfs_job_failed_literal (job, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED, _(""Permission denied"")); return is_authorized; }"
"MagickExport MagickBooleanType DrawPrimitive(Image *image, const DrawInfo *draw_info,const PrimitiveInfo *primitive_info, ExceptionInfo *exception) { CacheView *image_view; MagickStatusType status; register ssize_t i, x; ssize_t y; if (image->debug != MagickFalse) { (void) LogMagickEvent(DrawEvent,GetMagickModule(), ""  begin draw-primitive""); (void) LogMagickEvent(DrawEvent,GetMagickModule(), ""    affine: %g %g %g %g %g %g"",draw_info->affine.sx, draw_info->affine.rx,draw_info->affine.ry,draw_info->affine.sy, draw_info->affine.tx,draw_info->affine.ty); } if ((IsGrayColorspace(image->colorspace) != MagickFalse) && ((IsPixelInfoGray(&draw_info->fill) == MagickFalse) || (IsPixelInfoGray(&draw_info->stroke) == MagickFalse))) (void) SetImageColorspace(image,sRGBColorspace,exception); status=MagickTrue; x=(ssize_t) ceil(primitive_info->point.x-0.5); y=(ssize_t) ceil(primitive_info->point.y-0.5); image_view=AcquireAuthenticCacheView(image,exception); switch (primitive_info->primitive) { case AlphaPrimitive: { if (image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception); switch (primitive_info->method) { case PointMethod: default: { PixelInfo pixel; register Quantum *q; q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception); if (q == (Quantum *) NULL) break; GetFillColor(draw_info,x,y,&pixel,exception); SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q); (void) SyncCacheViewAuthenticPixels(image_view,exception); break; } case ReplaceMethod: { MagickBooleanType sync; PixelInfo pixel, target; (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target, exception); GetPixelInfo(image,&pixel); for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *magick_restrict q; q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1, exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { GetPixelInfoPixel(image,q,&pixel); if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse) { q+=GetPixelChannels(image); continue; } GetFillColor(draw_info,x,y,&pixel,exception); SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q); q+=GetPixelChannels(image); } sync=SyncCacheViewAuthenticPixels(image_view,exception); if (sync == MagickFalse) break; } break; } case FloodfillMethod: case FillToBorderMethod: { ChannelType channel_mask; PixelInfo target; (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y, &target,exception); if (primitive_info->method == FillToBorderMethod) { target.red=(double) draw_info->border_color.red; target.green=(double) draw_info->border_color.green; target.blue=(double) draw_info->border_color.blue; } channel_mask=SetImageChannelMask(image,AlphaChannel); status&=FloodfillPaintImage(image,draw_info,&target,x,y, primitive_info->method == FloodfillMethod ? MagickFalse : MagickTrue,exception); (void) SetImageChannelMask(image,channel_mask); break; } case ResetMethod: { MagickBooleanType sync; PixelInfo pixel; for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *magick_restrict q; q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1, exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { GetFillColor(draw_info,x,y,&pixel,exception); SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q); q+=GetPixelChannels(image); } sync=SyncCacheViewAuthenticPixels(image_view,exception); if (sync == MagickFalse) break; } break; } } break; } case ColorPrimitive: { switch (primitive_info->method) { case PointMethod: default: { PixelInfo pixel; register Quantum *q; q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception); if (q == (Quantum *) NULL) break; GetPixelInfo(image,&pixel); GetFillColor(draw_info,x,y,&pixel,exception); SetPixelViaPixelInfo(image,&pixel,q); (void) SyncCacheViewAuthenticPixels(image_view,exception); break; } case ReplaceMethod: { MagickBooleanType sync; PixelInfo pixel, target; (void) GetOneCacheViewVirtualPixelInfo(image_view,x,y,&target, exception); for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *magick_restrict q; q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1, exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { GetPixelInfoPixel(image,q,&pixel); if (IsFuzzyEquivalencePixelInfo(&pixel,&target) == MagickFalse) { q+=GetPixelChannels(image); continue; } GetFillColor(draw_info,x,y,&pixel,exception); SetPixelViaPixelInfo(image,&pixel,q); q+=GetPixelChannels(image); } sync=SyncCacheViewAuthenticPixels(image_view,exception); if (sync == MagickFalse) break; } break; } case FloodfillMethod: case FillToBorderMethod: { PixelInfo target; (void) GetOneVirtualPixelInfo(image,TileVirtualPixelMethod,x,y, &target,exception); if (primitive_info->method == FillToBorderMethod) { target.red=(double) draw_info->border_color.red; target.green=(double) draw_info->border_color.green; target.blue=(double) draw_info->border_color.blue; } status&=FloodfillPaintImage(image,draw_info,&target,x,y, primitive_info->method == FloodfillMethod ? MagickFalse : MagickTrue,exception); break; } case ResetMethod: { MagickBooleanType sync; PixelInfo pixel; GetPixelInfo(image,&pixel); for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *magick_restrict q; q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1, exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { GetFillColor(draw_info,x,y,&pixel,exception); SetPixelViaPixelInfo(image,&pixel,q); q+=GetPixelChannels(image); } sync=SyncCacheViewAuthenticPixels(image_view,exception); if (sync == MagickFalse) break; } break; } } break; } case ImagePrimitive: { AffineMatrix affine; char composite_geometry[MagickPathExtent]; Image *composite_image; ImageInfo *clone_info; RectangleInfo geometry; ssize_t x1, y1; if (primitive_info->text == (char *) NULL) break; clone_info=AcquireImageInfo(); if (LocaleNCompare(primitive_info->text,""data:"",5) == 0) composite_image=ReadInlineImage(clone_info,primitive_info->text, exception); else { (void) CopyMagickString(clone_info->filename,primitive_info->text, MagickPathExtent); composite_image=ReadImage(clone_info,exception); } clone_info=DestroyImageInfo(clone_info); if (composite_image == (Image *) NULL) break; (void) SetImageProgressMonitor(composite_image,(MagickProgressMonitor) NULL,(void *) NULL); x1=(ssize_t) ceil(primitive_info[1].point.x-0.5); y1=(ssize_t) ceil(primitive_info[1].point.y-0.5); if (((x1 != 0L) && (x1 != (ssize_t) composite_image->columns)) || ((y1 != 0L) && (y1 != (ssize_t) composite_image->rows))) { (void) FormatLocaleString(composite_geometry,MagickPathExtent, ""%gx%g!"",primitive_info[1].point.x,primitive_info[1].point.y); composite_image->filter=image->filter; (void) TransformImage(&composite_image,(char *) NULL, composite_geometry,exception); } if (composite_image->alpha_trait == UndefinedPixelTrait) (void) SetImageAlphaChannel(composite_image,OpaqueAlphaChannel, exception); if (draw_info->alpha != OpaqueAlpha) (void) SetImageAlpha(composite_image,draw_info->alpha,exception); SetGeometry(image,&geometry); image->gravity=draw_info->gravity; geometry.x=x; geometry.y=y; (void) FormatLocaleString(composite_geometry,MagickPathExtent, ""%.20gx%.20g%+.20g%+.20g"",(double) composite_image->columns,(double) composite_image->rows,(double) geometry.x,(double) geometry.y); (void) ParseGravityGeometry(image,composite_geometry,&geometry,exception); affine=draw_info->affine; affine.tx=(double) geometry.x; affine.ty=(double) geometry.y; composite_image->interpolate=image->interpolate; if (draw_info->compose == OverCompositeOp) (void) DrawAffineImage(image,composite_image,&affine,exception); else (void) CompositeImage(image,composite_image,draw_info->compose, MagickTrue,geometry.x,geometry.y,exception); composite_image=DestroyImage(composite_image); break; } case PointPrimitive: { PixelInfo fill_color; register Quantum *q; if ((y < 0) || (y >= (ssize_t) image->rows)) break; if ((x < 0) || (x >= (ssize_t) image->columns)) break; q=GetCacheViewAuthenticPixels(image_view,x,y,1,1,exception); if (q == (Quantum *) NULL) break; GetFillColor(draw_info,x,y,&fill_color,exception); CompositePixelOver(image,&fill_color,(double) fill_color.alpha,q, (double) GetPixelAlpha(image,q),q); (void) SyncCacheViewAuthenticPixels(image_view,exception); break; } case TextPrimitive: { char geometry[MagickPathExtent]; DrawInfo *clone_info; if (primitive_info->text == (char *) NULL) break; clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); (void) CloneString(&clone_info->text,primitive_info->text); (void) FormatLocaleString(geometry,MagickPathExtent,""%+f%+f"", primitive_info->point.x,primitive_info->point.y); (void) CloneString(&clone_info->geometry,geometry); status&=AnnotateImage(image,clone_info,exception); clone_info=DestroyDrawInfo(clone_info); break; } default: { double mid, scale; DrawInfo *clone_info; if (IsEventLogging() != MagickFalse) LogPrimitiveInfo(primitive_info); scale=ExpandAffine(&draw_info->affine); if ((draw_info->dash_pattern != (double *) NULL) && (draw_info->dash_pattern[0] != 0.0) && ((scale*draw_info->stroke_width) >= MagickEpsilon) && (draw_info->stroke.alpha != (Quantum) TransparentAlpha)) { clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); clone_info->stroke_width=0.0; clone_info->stroke.alpha=(Quantum) TransparentAlpha; status&=DrawPolygonPrimitive(image,clone_info,primitive_info, exception); clone_info=DestroyDrawInfo(clone_info); (void) DrawDashPolygon(draw_info,primitive_info,image,exception); break; } mid=ExpandAffine(&draw_info->affine)*draw_info->stroke_width/2.0; if ((mid > 1.0) && ((draw_info->stroke.alpha != (Quantum) TransparentAlpha) || (draw_info->stroke_pattern != (Image *) NULL))) { MagickBooleanType closed_path; for (i=0; primitive_info[i].primitive != UndefinedPrimitive; i++) ; closed_path= (primitive_info[i-1].point.x == primitive_info[0].point.x) && (primitive_info[i-1].point.y == primitive_info[0].point.y) ? MagickTrue : MagickFalse; i=(ssize_t) primitive_info[0].coordinates; if ((((draw_info->linecap == RoundCap) || (closed_path != MagickFalse)) && (draw_info->linejoin == RoundJoin)) || (primitive_info[i].primitive != UndefinedPrimitive)) { (void) DrawPolygonPrimitive(image,draw_info,primitive_info, exception); break; } clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); clone_info->stroke_width=0.0; clone_info->stroke.alpha=(Quantum) TransparentAlpha; status&=DrawPolygonPrimitive(image,clone_info,primitive_info, exception); clone_info=DestroyDrawInfo(clone_info); status&=DrawStrokePolygon(image,draw_info,primitive_info,exception); break; } status&=DrawPolygonPrimitive(image,draw_info,primitive_info,exception); break; } } image_view=DestroyCacheView(image_view); if (image->debug != MagickFalse) (void) LogMagickEvent(DrawEvent,GetMagickModule(),""  end draw-primitive""); return(status != 0 ? MagickTrue : MagickFalse); }"
"void operator()( const char* name )const { auto itr = _vo.find(name); if( itr != _vo.end() ) abi_from_variant::extract( itr->value(), this->obj.*member, _resolver ); }"
"static int lmp_print_data_link_subobjs(netdissect_options *ndo, const u_char *obj_tptr, int total_subobj_len, int offset) { int hexdump = FALSE; int subobj_type, subobj_len; union {  float f; uint32_t i; } bw; while (total_subobj_len > 0 && hexdump == FALSE ) { subobj_type = EXTRACT_8BITS(obj_tptr + offset); subobj_len  = EXTRACT_8BITS(obj_tptr + offset + 1); ND_PRINT((ndo, ""\n\t    Subobject, Type: %s (%u), Length: %u"", tok2str(lmp_data_link_subobj, ""Unknown"", subobj_type), subobj_type, subobj_len)); if (subobj_len < 4) { ND_PRINT((ndo, "" (too short)"")); break; } if ((subobj_len % 4) != 0) { ND_PRINT((ndo, "" (not a multiple of 4)"")); break; } if (total_subobj_len < subobj_len) { ND_PRINT((ndo, "" (goes past the end of the object)"")); break; } switch(subobj_type) { case INT_SWITCHING_TYPE_SUBOBJ: ND_PRINT((ndo, ""\n\t      Switching Type: %s (%u)"", tok2str(gmpls_switch_cap_values, ""Unknown"", EXTRACT_8BITS(obj_tptr + offset + 2)), EXTRACT_8BITS(obj_tptr + offset + 2))); ND_PRINT((ndo, ""\n\t      Encoding Type: %s (%u)"", tok2str(gmpls_encoding_values, ""Unknown"", EXTRACT_8BITS(obj_tptr + offset + 3)), EXTRACT_8BITS(obj_tptr + offset + 3))); ND_TCHECK_32BITS(obj_tptr + offset + 4); bw.i = EXTRACT_32BITS(obj_tptr+offset+4); ND_PRINT((ndo, ""\n\t      Min Reservable Bandwidth: %.3f Mbps"", bw.f*8/1000000)); bw.i = EXTRACT_32BITS(obj_tptr+offset+8); ND_PRINT((ndo, ""\n\t      Max Reservable Bandwidth: %.3f Mbps"", bw.f*8/1000000)); break; case WAVELENGTH_SUBOBJ: ND_PRINT((ndo, ""\n\t      Wavelength: %u"", EXTRACT_32BITS(obj_tptr+offset+4))); break; default: hexdump=TRUE; break; } total_subobj_len-=subobj_len; offset+=subobj_len; } return (hexdump); trunc: return -1; }"
"static int parse_user_name(char *user_input, char **ret_username) { register char *ptr; register int index = 0; char username[PAM_MAX_RESP_SIZE]; *ret_username = NULL; bzero((void *)username, PAM_MAX_RESP_SIZE); ptr = user_input; while ((*ptr == ' ') || (*ptr == '\t')) ptr++; if (*ptr == '\0') { return (PAM_BUF_ERR); } while (*ptr != '\0') { if ((*ptr == ' ') || (*ptr == '\t')) break; else { username[index] = *ptr; index++; ptr++; } } if ((*ret_username = malloc(index + 1)) == NULL) return (PAM_BUF_ERR); (void) strcpy(*ret_username, username); return (PAM_SUCCESS); }"
"void fx_ArrayBuffer_prototype_concat(txMachine* the) { txSlot* instance = fxCheckArrayBufferInstance(the, mxThis); txSlot* arrayBuffer = instance->next; txSlot* bufferInfo = arrayBuffer->next; txInteger length = bufferInfo->value.bufferInfo.length; txInteger c = mxArgc, i = 0; txByte* address; txSlot* slot; while (i < c) { arrayBuffer = C_NULL; bufferInfo = C_NULL; slot = mxArgv(i); if (slot->kind == XS_REFERENCE_KIND) { slot = slot->value.reference->next; if (slot && (slot->kind == XS_ARRAY_BUFFER_KIND)) arrayBuffer = slot; bufferInfo = slot->next; } if (arrayBuffer)  length = fxAddChunkSizes(the, length, bufferInfo->value.bufferInfo.length); else mxTypeError(""arguments[%ld] is no ArrayBuffer instance"", i); i++; } fxConstructArrayBufferResult(the, C_NULL, length); arrayBuffer = instance->next; bufferInfo = arrayBuffer->next; address = mxResult->value.reference->next->value.arrayBuffer.address; length = bufferInfo->value.bufferInfo.length; c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length); address += length; i = 0; while (i < c) { arrayBuffer = mxArgv(i)->value.reference->next; bufferInfo = arrayBuffer->next; length = bufferInfo->value.bufferInfo.length; c_memcpy(address, arrayBuffer->value.arrayBuffer.address, length); address += length; i++; } }"
"static bool TryParse(const char* inp, int length, TypedValue* buf, Variant& out, JSONContainerType container_type, bool is_tsimplejson) { SimpleParser parser(inp, length, buf, container_type, is_tsimplejson); bool ok = parser.parseValue(); parser.skipSpace(); if (!ok || parser.p != inp + length) { tvDecRefRange(buf, parser.top); return false; } out = Variant::attach(*--parser.top); return true; }"
"static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){ if( pExpr->op==TK_COLUMN ){ IdxExprTrans *pX = p->u.pIdxTrans; if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){ pExpr->iTable = pX->iIdxCur; pExpr->iColumn = pX->iIdxCol; pExpr->y.pTab = 0; } } return WRC_Continue; }"
"static inline void gnttab_set_map_op(struct gnttab_map_grant_ref *map, phys_addr_t addr, uint32_t flags, grant_ref_t ref, domid_t domid) { if (flags & GNTMAP_contains_pte) map->host_addr = addr; else if (xen_feature(XENFEAT_auto_translated_physmap)) map->host_addr = __pa(addr); else map->host_addr = addr; map->flags = flags; map->ref = ref; map->dom = domid; }"
"explicit FractionalMaxPoolOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(""pooling_ratio"", &pooling_ratio_)); OP_REQUIRES_OK(context, context->GetAttr(""pseudo_random"", &pseudo_random_)); OP_REQUIRES_OK(context, context->GetAttr(""overlapping"", &overlapping_)); OP_REQUIRES(context, pooling_ratio_.size() == 4, errors::InvalidArgument(""pooling_ratio field must "" ""specify 4 dimensions"")); OP_REQUIRES( context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1, errors::Unimplemented(""Fractional max pooling is not yet "" ""supported on the batch nor channel dimension."")); OP_REQUIRES_OK(context, context->GetAttr(""deterministic"", &deterministic_)); OP_REQUIRES_OK(context, context->GetAttr(""seed"", &seed_)); OP_REQUIRES_OK(context, context->GetAttr(""seed2"", &seed2_)); if (deterministic_) { if ((seed_ == 0) && (seed2_ == 0)) { seed_ = random::New64(); seed2_ = random::New64(); } } else { OP_REQUIRES( context, (seed_ == 0) && (seed2_ == 0), errors::InvalidArgument( ""Both seed and seed2 should be 0 if deterministic is false."")); } }"
"WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec, WORD32 i4_poc, pocstruct_t *ps_temp_poc, UWORD16 u2_frame_num, dec_pic_params_t *ps_pps) { pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc; pocstruct_t *ps_cur_poc = ps_temp_poc; pic_buffer_t *pic_buf; ivd_video_decode_op_t * ps_dec_output = (ivd_video_decode_op_t *)ps_dec->pv_dec_out; dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice; dec_seq_params_t *ps_seq = ps_pps->ps_sps; UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag; UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag; high_profile_tools_t s_high_profile; WORD32 ret; H264_MUTEX_LOCK(&ps_dec->process_disp_mutex); ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb; ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb; ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom; ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0]; ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1]; ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag; ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst; ps_prev_poc->u2_frame_num = u2_frame_num; ps_dec->i1_prev_mb_qp_delta = 0; ps_dec->i1_next_ctxt_idx = 0; ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores == 1) ps_dec->u4_nmb_deblk = 1; if(ps_seq->u1_mb_aff_flag == 1) { ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores > 2) ps_dec->u4_num_cores = 2; } ps_dec->u4_use_intrapred_line_copy = 0; if (ps_seq->u1_mb_aff_flag == 0) { ps_dec->u4_use_intrapred_line_copy = 1; } ps_dec->u4_app_disable_deblk_frm = 0; if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics) { WORD32 degrade_pic; ps_dec->i4_degrade_pic_cnt++; degrade_pic = 0; switch(ps_dec->i4_degrade_pics) { case 4: { degrade_pic = 1; break; } case 3: { if(ps_cur_slice->u1_slice_type != I_SLICE) degrade_pic = 1; break; } case 2: { if((ps_cur_slice->u1_slice_type != I_SLICE) && (ps_dec->i4_degrade_pic_cnt != ps_dec->i4_nondegrade_interval)) degrade_pic = 1; break; } case 1: { if(0 == ps_cur_slice->u1_nal_ref_idc) { degrade_pic = 1; } break; } } if(degrade_pic) { if(ps_dec->i4_degrade_type & 0x2) ps_dec->u4_app_disable_deblk_frm = 1; if(0 == ps_cur_slice->u1_nal_ref_idc) { if(ps_dec->i4_degrade_type & 0x4) ps_dec->i4_mv_frac_mask = 0; if(ps_dec->i4_degrade_type & 0x8) ps_dec->i4_mv_frac_mask = 0; } } else ps_dec->i4_degrade_pic_cnt = 0; } { dec_err_status_t * ps_err = ps_dec->ps_dec_err_status; if(ps_dec->u1_sl_typ_5_9 && ((ps_cur_slice->u1_slice_type == I_SLICE) || (ps_cur_slice->u1_slice_type == SI_SLICE))) ps_err->u1_cur_pic_type = PIC_TYPE_I; else ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN; if(ps_err->u1_pic_aud_i == PIC_TYPE_I) { ps_err->u1_cur_pic_type = PIC_TYPE_I; ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN; } if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL) { if(ps_err->u1_err_flag) ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr); ps_err->u1_err_flag = ACCEPT_ALL_PICS; } } if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending) { WORD32 j; for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->u1_second_field = 0; ps_dec->i4_cur_display_seq = 0; ps_dec->s_prev_seq_params.u1_eoseq_pending = 0; } ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps); if(ret != OK) return ret; ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data; ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data; ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info; if(ps_dec->u1_separate_parse) { UWORD16 pic_wd = ps_dec->u4_width_at_init; UWORD16 pic_ht = ps_dec->u4_height_at_init; UWORD32 num_mbs; if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid))) { pic_wd = ps_dec->u2_pic_wd; pic_ht = ps_dec->u2_pic_ht; } num_mbs = (pic_wd * pic_ht) >> 8; if(ps_dec->pu1_dec_mb_map) { memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs); } if(ps_dec->pu1_recon_mb_map) { memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs); } if(ps_dec->pu2_slice_num_map) { memset((void *)ps_dec->pu2_slice_num_map, 0, (num_mbs * sizeof(UWORD16))); } } ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->u2_cur_slice_num = 0; ps_dec->s_high_profile.u1_scaling_present = 0; ps_dec->s_high_profile.u1_transform8x8_present = 0; if(1 == ps_dec->u4_share_disp_buf) { UWORD32 i; for(i = 0; i < MAX_DISP_BUFS_NEW; i++) { if(0 == ps_dec->u4_disp_buf_to_be_freed[i]) continue; ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i, BUF_MGR_IO); ps_dec->u4_disp_buf_to_be_freed[i] = 0; ps_dec->u4_disp_buf_mapping[i] = 0; } } if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))     { pic_buffer_t *ps_cur_pic; WORD32 cur_pic_buf_id, cur_mv_buf_id; col_mv_buf_t *ps_col_mv; while(1) { ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id]) { break; } } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; { ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0]; *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic; *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic; } if(!ps_dec->ps_cur_pic) { WORD32 j; H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n""); for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->i4_cur_display_seq = 0; ps_dec->i4_prev_max_display_seq = 0; ps_dec->i4_max_poc = 0; ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; } ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag; ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE; H264_DEC_DEBUG_PRINT(""got a buffer\n""); } else { H264_DEC_DEBUG_PRINT(""did not get a buffer\n""); } ps_dec->u4_pic_buf_got = 1; ps_dec->ps_cur_pic->i4_poc = i4_poc; ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num; ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num; ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt; ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = ps_pps->i4_bottom_field_order_cnt; ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc; ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts; ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic); if(u1_field_pic_flag && u1_bottom_field_flag) { WORD32 i4_temp_poc; WORD32 i4_top_field_order_poc, i4_bot_field_order_poc; ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y; ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.ps_mv += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD; i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt; i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt; i4_temp_poc = MIN(i4_top_field_order_poc, i4_bot_field_order_poc); ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc; } ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag); ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag << 2); ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;     ps_dec->ps_cur_mb_row++;     ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row + ((ps_dec->u2_frm_wd_in_mbs + 1) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag)); ps_dec->ps_top_mb_row++;  ps_dec->pu1_y = ps_dec->pu1_y_scratch[0]; ps_dec->pu1_u = ps_dec->pu1_u_scratch[0]; ps_dec->pu1_v = ps_dec->pu1_v_scratch[0]; ps_dec->u1_yuv_scratch_idx = 0; ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0]; ps_dec->u1_mv_top_p = 0; ps_dec->u1_mb_idx = 0; ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv; ps_dec->pu1_yleft = 0; ps_dec->pu1_uleft = 0; ps_dec->pu1_vleft = 0; ps_dec->u1_not_wait_rec = 2; ps_dec->u2_total_mbs_coded = 0; ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE); ps_dec->u4_pred_info_idx = 0; ps_dec->u4_pred_info_pkd_idx = 0; ps_dec->u4_dma_buf_idx = 0; ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag; ps_dec->ps_part = ps_dec->ps_parse_part_params; ps_dec->i2_prev_slice_mbx = -1; ps_dec->i2_prev_slice_mby = 0; ps_dec->u2_mv_2mb[0] = 0; ps_dec->u2_mv_2mb[1] = 0; ps_dec->u1_last_pic_not_decoded = 0; ps_dec->u2_cur_slice_num_dec_thread = 0; ps_dec->u2_cur_slice_num_bs = 0; ps_dec->u4_intra_pred_line_ofst = 0; ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE); ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR; ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE; ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic; ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn; ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp; { if(ps_cur_slice->u1_mbaff_frame_flag) { ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff; ps_dec->pf_mvpred = ih264d_mvpred_mbaff; } else { ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff; ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag; } } { UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag; UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag; UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4) % (ps_dec->u1_recon_mb_grp >> u1_mbaff)); UWORD16 ui16_lastmbs_widthY = (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 4)); UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 3); ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1; ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2; ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3; ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y << u1_field_pic_flag; ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv << u1_field_pic_flag; if(u1_field_pic_flag) { ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y; ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv; } ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY + (PAD_LEN_Y_H << 1) + ps_dec->s_tran_addrecon.u2_frm_wd_y * ((15 << u1_mbaff) + u1_mbaff)); ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV + (PAD_LEN_UV_H << 2) + ps_dec->s_tran_addrecon.u2_frm_wd_uv * ((15 << u1_mbaff) + u1_mbaff)); ih264d_assign_pic_num(ps_dec); ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp << 2) - 1 - (u1_mbaff << 2); ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp >> u1_mbaff) - 1) << (4 + u1_mbaff); } if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC) { if((ps_seq->i4_seq_scaling_matrix_present_flag) || (ps_pps->i4_pic_scaling_matrix_present_flag)) { ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec); ps_dec->s_high_profile.u1_scaling_present = 1; } else { ih264d_form_default_scaling_matrix(ps_dec); } if(ps_pps->i4_transform_8x8_mode_flag) { ps_dec->s_high_profile.u1_transform8x8_present = 1; } } else { ih264d_form_default_scaling_matrix(ps_dec); } ps_dec->s_high_profile.u1_direct_8x8_inference_flag = ps_seq->u1_direct_8x8_inference_flag; ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt; ps_dec->i1_recon_in_thread3_flag = 1; ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon; if(ps_dec->u1_separate_parse) { memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag) { memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon; } } ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon), ps_dec->u2_frm_wd_in_mbs, 0); ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic; ps_dec->u4_cur_deblk_mb_num = 0; ps_dec->u4_deblk_mb_x = 0; ps_dec->u4_deblk_mb_y = 0; ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat; H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex); return OK; }"
"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) { RList *bins = r_list_newf ((RListFree)free_bin); if (!bins) { return NULL; } char *target_libs = NULL; RList *target_lib_names = NULL; int *deps = NULL; target_libs = r_sys_getenv (""R_DYLDCACHE_FILTER""); if (target_libs) { target_lib_names = r_str_split_list (target_libs, "":"", 0); if (!target_lib_names) { r_list_free (bins); return NULL; } deps = R_NEWS0 (int, cache->hdr->imagesCount); if (!deps) { r_list_free (bins); r_list_free (target_lib_names); return NULL; } } ut32 i; for (i = 0; i < cache->n_hdr; i++) { cache_hdr_t *hdr = &cache->hdr[i]; ut64 hdr_offset = cache->hdr_offset[i]; ut32 maps_index = cache->maps_index[i]; cache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset); if (!img) { goto next; } ut32 j; ut16 *depArray = NULL; cache_imgxtr_t *extras = NULL; if (target_libs) { HtPU *path_to_idx = NULL; if (cache->accel) { depArray = R_NEWS0 (ut16, cache->accel->depListCount); if (!depArray) { goto next; } if (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, ""s"", cache->accel->depListCount) != cache->accel->depListCount * 2) { goto next; } extras = read_cache_imgextra (cache->buf, hdr, cache->accel); if (!extras) { goto next; } } else { path_to_idx = create_path_to_index (cache->buf, img, hdr); } for (j = 0; j < hdr->imagesCount; j++) { bool printing = !deps[j]; char *lib_name = get_lib_name (cache->buf, &img[j]); if (!lib_name) { break; } if (strstr (lib_name, ""libobjc.A.dylib"")) { deps[j]++; } if (!r_list_find (target_lib_names, lib_name, string_contains)) { R_FREE (lib_name); continue; } if (printing) { eprintf (""FILTER: %s\n"", lib_name); } R_FREE (lib_name); deps[j]++; if (extras && depArray) { ut32 k; for (k = extras[j].dependentsStartArrayIndex; depArray[k] != 0xffff; k++) { ut16 dep_index = depArray[k] & 0x7fff; deps[dep_index]++; char *dep_name = get_lib_name (cache->buf, &img[dep_index]); if (!dep_name) { break; } if (printing) { eprintf (""-> %s\n"", dep_name); } free (dep_name); } } else if (path_to_idx) { carve_deps_at_address (cache, img, path_to_idx, img[j].address, deps, printing); } } ht_pu_free (path_to_idx); R_FREE (depArray); R_FREE (extras); } for (j = 0; j < hdr->imagesCount; j++) { if (deps && !deps[j]) { continue; } ut64 pa = va2pa (img[j].address, hdr->mappingCount, &cache->maps[maps_index], cache->buf, 0, NULL, NULL); if (pa == UT64_MAX) { continue; } ut8 magicbytes[4]; r_buf_read_at (cache->buf, pa, magicbytes, 4); int magic = r_read_le32 (magicbytes); switch (magic) { case MH_MAGIC_64: { char file[256]; RDyldBinImage *bin = R_NEW0 (RDyldBinImage); if (!bin) { goto next; } bin->header_at = pa; bin->hdr_offset = hdr_offset; bin->symbols_off = resolve_symbols_off (cache, pa); bin->va = img[j].address; if (r_buf_read_at (cache->buf, img[j].pathFileOffset, (ut8*) &file, sizeof (file)) == sizeof (file)) { file[255] = 0; char *last_slash = strrchr (file, '/'); if (last_slash && *last_slash) { if (last_slash > file) { char *scan = last_slash - 1; while (scan > file && *scan != '/') { scan--; } if (*scan == '/') { bin->file = strdup (scan + 1); } else { bin->file = strdup (last_slash + 1); } } else { bin->file = strdup (last_slash + 1); } } else { bin->file = strdup (file); } } r_list_append (bins, bin); break; } default: eprintf (""Unknown sub-bin\n""); break; } } next: R_FREE (depArray); R_FREE (extras); R_FREE (img); } if (r_list_empty (bins)) { r_list_free (bins); bins = NULL; } R_FREE (deps); R_FREE (target_libs); r_list_free (target_lib_names); return bins; }"
"sal_Bool ODbaseTable::UpdateBuffer(OValueRefVector& rRow, OValueRefRow pOrgRow,const Reference<XIndexAccess>& _xCols) { RTL_LOGFILE_CONTEXT_AUTHOR( aLogger, ""dbase"", ""Ocke.Janssen@sun.com"", ""ODbaseTable::UpdateBuffer"" ); OSL_ENSURE(m_pBuffer,""Buffer is NULL!""); if ( !m_pBuffer ) return sal_False; sal_Int32 nByteOffset  = 1; Reference<XPropertySet> xCol; Reference<XPropertySet> xIndex; sal_uInt16 i; ::rtl::OUString aColName; const sal_Int32 nColumnCount = m_pColumns->getCount(); ::std::vector< Reference<XPropertySet> > aIndexedCols(nColumnCount); ::comphelper::UStringMixEqual aCase(isCaseSensitive()); Reference<XIndexAccess> xColumns = m_pColumns; for (i = 0; i < nColumnCount; ++i) { sal_Int32 nPos = i; if(_xCols != xColumns) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; for(nPos = 0;nPos<_xCols->getCount();++nPos) { Reference<XPropertySet> xFindCol; ::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos)); OSL_ENSURE(xFindCol.is(),""ODbaseTable::UpdateBuffer column is null!""); if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName)) break; } if (nPos >= _xCols->getCount()) continue; } ++nPos; xIndex = isUniqueByColumnName(i); aIndexedCols[i] = xIndex; if (xIndex.is()) { if(pOrgRow.isValid() && (rRow.get()[nPos]->getValue().isNull() || rRow.get()[nPos] == (pOrgRow->get())[nPos])) continue; else { Reference<XUnoTunnel> xTunnel(xIndex,UNO_QUERY); OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!""); ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) ); OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!""); if (pIndex->Find(0,*rRow.get()[nPos])) { if ( !aColName.getLength() ) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; xCol.clear(); }                     const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_DUPLICATE_VALUE_IN_COLUMN ,""$columnname$"", aColName ) ); ::dbtools::throwGenericSQLException( sError, *this ); } } } } for (i = 0; i < nColumnCount && nByteOffset <= m_nBufferSize ; ++i) { OSL_ENSURE(i < m_aPrecisions.size(),""Illegal index!""); sal_Int32 nLen = 0; sal_Int32 nType = 0; sal_Int32 nScale = 0; if ( i < m_aPrecisions.size() ) { nLen= m_aPrecisions[i]; nType= m_aTypes[i]; nScale= m_aScales[i]; } else { m_pColumns->getByIndex(i) >>= xCol; if ( xCol.is() ) { xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_PRECISION))>>= nLen; xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_TYPE))>>= nType; xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_SCALE))>>= nScale; } } bool bSetZero = false; switch (nType) { case DataType::INTEGER: case DataType::DOUBLE: case DataType::TIMESTAMP: bSetZero = true; case DataType::LONGVARBINARY: case DataType::DATE: case DataType::BIT: case DataType::LONGVARCHAR: nLen = m_aRealFieldLengths[i];  break; case DataType::DECIMAL: nLen = SvDbaseConverter::ConvertPrecisionToDbase(nLen,nScale); break;default: break; }  sal_Int32 nPos = i; if(_xCols != xColumns) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; for(nPos = 0;nPos<_xCols->getCount();++nPos) { Reference<XPropertySet> xFindCol; ::cppu::extractInterface(xFindCol,_xCols->getByIndex(nPos)); if(aCase(getString(xFindCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME))),aColName)) break; } if (nPos >= _xCols->getCount()) { nByteOffset += nLen; continue; } } ++nPos; if ( !rRow.get()[nPos]->isBound() ) { nByteOffset += nLen; continue; } if (aIndexedCols[i].is()) { Reference<XUnoTunnel> xTunnel(aIndexedCols[i],UNO_QUERY); OSL_ENSURE(xTunnel.is(),""No TunnelImplementation!""); ODbaseIndex* pIndex = reinterpret_cast< ODbaseIndex* >( xTunnel->getSomething(ODbaseIndex::getUnoTunnelImplementationId()) ); OSL_ENSURE(pIndex,""ODbaseTable::UpdateBuffer: No Index returned!""); if (pOrgRow.isValid() && !rRow.get()[nPos]->getValue().isNull() )pIndex->Update(m_nFilePos,*(pOrgRow->get())[nPos],*rRow.get()[nPos]); else pIndex->Insert(m_nFilePos,*rRow.get()[nPos]); } char* pData = (char *)(m_pBuffer + nByteOffset); if (rRow.get()[nPos]->getValue().isNull()) { if ( bSetZero ) memset(pData,0,nLen);            else memset(pData,' ',nLen);nByteOffset += nLen; OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!""); continue; } sal_Bool bHadError = sal_False; try { switch (nType) { case DataType::TIMESTAMP: { sal_Int32 nJulianDate = 0, nJulianTime = 0; lcl_CalcJulDate(nJulianDate,nJulianTime,rRow.get()[nPos]->getValue()); memcpy(pData,&nJulianDate,4); memcpy(pData+4,&nJulianTime,4); } break; case DataType::DATE: { ::com::sun::star::util::Date aDate; if(rRow.get()[nPos]->getValue().getTypeKind() == DataType::DOUBLE) aDate = ::dbtools::DBTypeConversion::toDate(rRow.get()[nPos]->getValue().getDouble()); else aDate = rRow.get()[nPos]->getValue(); char s[9]; snprintf(s, sizeof(s), ""%04d%02d%02d"", (int)aDate.Year, (int)aDate.Month, (int)aDate.Day); strncpy(pData,s,sizeof s - 1); } break; case DataType::INTEGER: { sal_Int32 nValue = rRow.get()[nPos]->getValue(); memcpy(pData,&nValue,nLen); } break; case DataType::DOUBLE: { const double d = rRow.get()[nPos]->getValue(); m_pColumns->getByIndex(i) >>= xCol; if (getBOOL(xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_ISCURRENCY))))                         { sal_Int64 nValue = 0; if ( m_aScales[i] ) nValue = (sal_Int64)(d * pow(10.0,(int)m_aScales[i])); else nValue = (sal_Int64)(d); memcpy(pData,&nValue,nLen); }                         else memcpy(pData,&d,nLen); } break; case DataType::DECIMAL: { memset(pData,' ',nLen); const double n = rRow.get()[nPos]->getValue(); const ByteString aDefaultValue( ::rtl::math::doubleToString( n, rtl_math_StringFormat_F, nScale, '.', NULL, 0)); sal_Bool bValidLength  = aDefaultValue.Len() <= nLen; if ( bValidLength ) { strncpy(pData,aDefaultValue.GetBuffer(),nLen); *rRow.get()[nPos] = toDouble(aDefaultValue); } else { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE(xCol.is(),""ODbaseTable::UpdateBuffer column is null!""); xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; ::std::list< ::std::pair<const sal_Char* , ::rtl::OUString > > aStringToSubstitutes; aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$columnname$"", aColName)); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$precision$"", String::CreateFromInt32(nLen))); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$scale$"", String::CreateFromInt32(nScale))); aStringToSubstitutes.push_back(::std::pair<const sal_Char* , ::rtl::OUString >(""$value$"", ::rtl::OStringToOUString(aDefaultValue,RTL_TEXTENCODING_UTF8))); const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_INVALID_COLUMN_DECIMAL_VALUE ,aStringToSubstitutes ) ); ::dbtools::throwGenericSQLException( sError, *this ); } } break; case DataType::BIT: *pData = rRow.get()[nPos]->getValue().getBool() ? 'T' : 'F'; break; case DataType::LONGVARBINARY: case DataType::LONGVARCHAR: { char cNext = pData[nLen]; pData[nLen] = '\0';   sal_uIntPtr nBlockNo = strtol((const char *)pData,NULL,10); pData[nLen] = cNext; if (!m_pMemoStream || !WriteMemo(rRow.get()[nPos]->get(), nBlockNo)) break; ByteString aStr; ByteString aBlock(ByteString::CreateFromInt32(nBlockNo)); aStr.Expand(static_cast<sal_uInt16>(nLen - aBlock.Len()), '0' ); aStr += aBlock; memset(pData,' ',nLen);memcpy(pData, aStr.GetBuffer(), nLen); }break; default: { memset(pData,' ',nLen); ::rtl::OUString sStringToWrite( rRow.get()[nPos]->getValue().getString() ); ::rtl::OString sEncoded; DBTypeConversion::convertUnicodeStringToLength( sStringToWrite, sEncoded, nLen, m_eEncoding ); memcpy( pData, sEncoded.getStr(), sEncoded.getLength() ); } break; } } catch( SQLException&  ) { throw; } catch ( Exception& ) { bHadError = sal_True; } if ( bHadError ) { m_pColumns->getByIndex(i) >>= xCol; OSL_ENSURE( xCol.is(), ""ODbaseTable::UpdateBuffer column is null!"" ); if ( xCol.is() ) xCol->getPropertyValue(OMetaConnection::getPropMap().getNameByIndex(PROPERTY_ID_NAME)) >>= aColName; const ::rtl::OUString sError( getConnection()->getResources().getResourceStringWithSubstitution( STR_INVALID_COLUMN_VALUE, ""$columnname$"", aColName ) ); ::dbtools::throwGenericSQLException( sError, *this ); } nByteOffset += nLen; OSL_ENSURE( nByteOffset <= m_nBufferSize ,""ByteOffset > m_nBufferSize!""); } return sal_True; }"
"size_t compile_tree(struct filter_op **fop) { int i = 1; struct filter_op *array = NULL; struct unfold_elm *ue; BUG_IF(tree_root == NULL); fprintf(stdout, "" Unfolding the meta-tree ""); fflush(stdout); unfold_blk(&tree_root); fprintf(stdout, "" done.\n\n""); labels_to_offsets(); TAILQ_FOREACH(ue, &unfolded_tree, next) { if (ue->label == 0) { SAFE_REALLOC(array, i * sizeof(struct filter_op)); memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op)); i++; } } SAFE_REALLOC(array, i * sizeof(struct filter_op)); array[i - 1].opcode = FOP_EXIT; *fop = array; return (i); }"
"int romfs_dev_read(struct super_block *sb, unsigned long pos, void *buf, size_t buflen) { size_t limit; limit = romfs_maxsize(sb); if (pos >= limit) return -EIO; if (buflen > limit - pos) buflen = limit - pos; #ifdef CONFIG_ROMFS_ON_MTD if (sb->s_mtd) return romfs_mtd_read(sb, pos, buf, buflen); #endif #ifdef CONFIG_ROMFS_ON_BLOCK if (sb->s_bdev) return romfs_blk_read(sb, pos, buf, buflen); #endif return -EIO; }"
"int check_restricted(void) { if (restricted) { emsg(_(""E145: Shell commands not allowed in rvim"")); return TRUE; } return FALSE; }"
"int mailpop3_stls(mailpop3 * f) { char command[POP3_STRING_SIZE]; int r; char * response; snprintf(command, POP3_STRING_SIZE, ""STLS\r\n""); r = send_command(f, command); if (r == -1) return MAILPOP3_ERROR_STREAM; response = read_line(f); if (response == NULL) return MAILPOP3_ERROR_STREAM; r = parse_response(f, response); if (r != RESPONSE_OK) return MAILPOP3_ERROR_STLS_NOT_SUPPORTED; return MAILPOP3_NO_ERROR; }"
"void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data) { VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev); uint32_t val = data; if (addr > (vdev->config_len - sizeof(val))) return; stl_p(vdev->config + addr, val); if (k->set_config) { k->set_config(vdev, vdev->config); } }"
"void vcpu_restore_fpu_lazy(struct vcpu *v) { ASSERT(!is_idle_vcpu(v)); clts(); if ( v->fpu_dirtied ) return; if ( cpu_has_xsave ) fpu_xrstor(v, XSTATE_LAZY); else if ( v->fpu_initialised ) fpu_fxrstor(v); else fpu_init(); v->fpu_initialised = 1; v->fpu_dirtied = 1; }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"static MagickBooleanType WriteTXTImage(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { char buffer[MagickPathExtent], colorspace[MagickPathExtent], tuple[MagickPathExtent]; MagickBooleanType status; MagickOffsetType scene; PixelInfo pixel; register const Quantum *p; register ssize_t x; ssize_t y; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); status=OpenBlob(image_info,image,WriteBlobMode,exception); if (status == MagickFalse) return(status); scene=0; do { ComplianceType compliance; const char *value; (void) CopyMagickString(colorspace,CommandOptionToMnemonic( MagickColorspaceOptions,(ssize_t) image->colorspace),MagickPathExtent); LocaleLower(colorspace); image->depth=GetImageQuantumDepth(image,MagickTrue); if (image->alpha_trait != UndefinedPixelTrait) (void) ConcatenateMagickString(colorspace,""a"",MagickPathExtent); compliance=NoCompliance; value=GetImageOption(image_info,""txt:compliance""); if (value != (char *) NULL) compliance=(ComplianceType) ParseCommandOption(MagickComplianceOptions, MagickFalse,value); if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") != 0) { size_t depth; depth=compliance == SVGCompliance ? image->depth : MAGICKCORE_QUANTUM_DEPTH; (void) FormatLocaleString(buffer,MagickPathExtent, ""# ImageMagick pixel enumeration: %.20g,%.20g,%.20g,%s\n"",(double) image->columns,(double) image->rows,(double) ((MagickOffsetType) GetQuantumRange(depth)),colorspace); (void) WriteBlobString(image,buffer); } GetPixelInfo(image,&pixel); for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { GetPixelInfoPixel(image,p,&pixel); if (pixel.colorspace == LabColorspace) { pixel.green-=(QuantumRange+1)/2.0; pixel.blue-=(QuantumRange+1)/2.0; } if (LocaleCompare(image_info->magick,""SPARSE-COLOR"") == 0) { if (GetPixelAlpha(image,p) == (Quantum) OpaqueAlpha) { GetColorTuple(&pixel,MagickFalse,tuple); (void) FormatLocaleString(buffer,MagickPathExtent, ""%.20g,%.20g,"",(double) x,(double) y); (void) WriteBlobString(image,buffer); (void) WriteBlobString(image,tuple); (void) WriteBlobString(image,"" ""); } p+=GetPixelChannels(image); continue; } (void) FormatLocaleString(buffer,MagickPathExtent,""%.20g,%.20g: "", (double) x,(double) y); (void) WriteBlobString(image,buffer); (void) CopyMagickString(tuple,""("",MagickPathExtent); if (pixel.colorspace == GRAYColorspace) ConcatenateColorComponent(&pixel,GrayPixelChannel,compliance, tuple); else { ConcatenateColorComponent(&pixel,RedPixelChannel,compliance,tuple); (void) ConcatenateMagickString(tuple,"","",MagickPathExtent); ConcatenateColorComponent(&pixel,GreenPixelChannel,compliance, tuple); (void) ConcatenateMagickString(tuple,"","",MagickPathExtent); ConcatenateColorComponent(&pixel,BluePixelChannel,compliance,tuple); } if (pixel.colorspace == CMYKColorspace) { (void) ConcatenateMagickString(tuple,"","",MagickPathExtent); ConcatenateColorComponent(&pixel,BlackPixelChannel,compliance, tuple); } if (pixel.alpha_trait != UndefinedPixelTrait) { (void) ConcatenateMagickString(tuple,"","",MagickPathExtent); ConcatenateColorComponent(&pixel,AlphaPixelChannel,compliance, tuple); } (void) ConcatenateMagickString(tuple,"")"",MagickPathExtent); (void) WriteBlobString(image,tuple); (void) WriteBlobString(image,""  ""); GetColorTuple(&pixel,MagickTrue,tuple); (void) FormatLocaleString(buffer,MagickPathExtent,""%s"",tuple); (void) WriteBlobString(image,buffer); (void) WriteBlobString(image,""  ""); (void) QueryColorname(image,&pixel,SVGCompliance,tuple,exception); (void) WriteBlobString(image,tuple); (void) WriteBlobString(image,""\n""); p+=GetPixelChannels(image); } status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } if (GetNextImageInList(image) == (Image *) NULL) break; image=SyncNextImageInList(image); status=SetImageProgress(image,SaveImagesTag,scene++, GetImageListLength(image)); if (status == MagickFalse) break; } while (image_info->adjoin != MagickFalse); (void) CloseBlob(image); return(MagickTrue); }"
"char * did_set_spelllang(win_T *wp) { garray_Tga; char_u*splp; char_u*region; char_uregion_cp[3]; intfilename; intregion_mask; slang_T*slang; intc; char_ulang[MAXWLEN + 1]; char_uspf_name[MAXPATHL]; intlen; char_u*p; intround; char_u*spf; char_u*use_region = NULL; intdont_use_region = FALSE; intnobreak = FALSE; inti, j; langp_T*lp, *lp2; static intrecursive = FALSE; char*ret_msg = NULL; char_u*spl_copy; bufref_Tbufref; set_bufref(&bufref, wp->w_buffer); if (recursive) return NULL; recursive = TRUE; ga_init2(&ga, sizeof(langp_T), 2); clear_midword(wp); spl_copy = vim_strsave(wp->w_s->b_p_spl); if (spl_copy == NULL) goto theend; wp->w_s->b_cjk = 0; for (splp = spl_copy; *splp != NUL; ) { copy_option_part(&splp, lang, MAXWLEN, "",""); region = NULL; len = (int)STRLEN(lang); if (!valid_spelllang(lang)) continue; if (STRCMP(lang, ""cjk"") == 0) { wp->w_s->b_cjk = 1; continue; } if (len > 4 && fnamecmp(lang + len - 4, "".spl"") == 0) { filename = TRUE; p = vim_strchr(gettail(lang), '_'); if (p != NULL && ASCII_ISALPHA(p[1]) && ASCII_ISALPHA(p[2]) && !ASCII_ISALPHA(p[3])) { vim_strncpy(region_cp, p + 1, 2); mch_memmove(p, p + 3, len - (p - lang) - 2); region = region_cp; } else dont_use_region = TRUE; FOR_ALL_SPELL_LANGS(slang) if (fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME) break; } else { filename = FALSE; if (len > 3 && lang[len - 3] == '_') { region = lang + len - 2; len -= 3; lang[len] = NUL; } else dont_use_region = TRUE; FOR_ALL_SPELL_LANGS(slang) if (STRICMP(lang, slang->sl_name) == 0) break; } if (region != NULL) { if (use_region != NULL && STRCMP(region, use_region) != 0) dont_use_region = TRUE; use_region = region; } if (slang == NULL) { if (filename) (void)spell_load_file(lang, lang, NULL, FALSE); else { spell_load_lang(lang); if (!bufref_valid(&bufref)) { ret_msg = N_(e_spellfilemising_autocommand_deleted_buffer); goto theend; } } } FOR_ALL_SPELL_LANGS(slang) if (filename ? fullpathcmp(lang, slang->sl_fname, FALSE, TRUE) == FPC_SAME : STRICMP(lang, slang->sl_name) == 0) { region_mask = REGION_ALL; if (!filename && region != NULL) { c = find_region(slang->sl_regions, region); if (c == REGION_ALL) { if (slang->sl_add) { if (*slang->sl_regions != NUL) region_mask = 0; } else smsg(_(""Warning: region %s not supported""), region); } else region_mask = 1 << c; } if (region_mask != 0) { if (ga_grow(&ga, 1) == FAIL) { ga_clear(&ga); ret_msg = e_out_of_memory; goto theend; } LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang; LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask; ++ga.ga_len; use_midword(slang, wp); if (slang->sl_nobreak) nobreak = TRUE; } } } spf = curwin->w_s->b_p_spf; for (round = 0; round == 0 || *spf != NUL; ++round) { if (round == 0) { if (int_wordlist == NULL) continue; int_wordlist_spl(spf_name); } else { copy_option_part(&spf, spf_name, MAXPATHL - 5, "",""); STRCAT(spf_name, "".spl""); for (c = 0; c < ga.ga_len; ++c) { p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname; if (p != NULL && fullpathcmp(spf_name, p, FALSE, TRUE) == FPC_SAME) break; } if (c < ga.ga_len) continue; } FOR_ALL_SPELL_LANGS(slang) if (fullpathcmp(spf_name, slang->sl_fname, FALSE, TRUE) == FPC_SAME) break; if (slang == NULL) { if (round == 0) STRCPY(lang, ""internal wordlist""); else { vim_strncpy(lang, gettail(spf_name), MAXWLEN); p = vim_strchr(lang, '.'); if (p != NULL) *p = NUL;    } slang = spell_load_file(spf_name, lang, NULL, TRUE); if (slang != NULL && nobreak) slang->sl_nobreak = TRUE; } if (slang != NULL && ga_grow(&ga, 1) == OK) { region_mask = REGION_ALL; if (use_region != NULL && !dont_use_region) { c = find_region(slang->sl_regions, use_region); if (c != REGION_ALL) region_mask = 1 << c; else if (*slang->sl_regions != NUL) region_mask = 0; } if (region_mask != 0) { LANGP_ENTRY(ga, ga.ga_len)->lp_slang = slang; LANGP_ENTRY(ga, ga.ga_len)->lp_sallang = NULL; LANGP_ENTRY(ga, ga.ga_len)->lp_replang = NULL; LANGP_ENTRY(ga, ga.ga_len)->lp_region = region_mask; ++ga.ga_len; use_midword(slang, wp); } } } ga_clear(&wp->w_s->b_langp); wp->w_s->b_langp = ga; for (i = 0; i < ga.ga_len; ++i) { lp = LANGP_ENTRY(ga, i); if (lp->lp_slang->sl_sal.ga_len > 0) lp->lp_sallang = lp->lp_slang; else for (j = 0; j < ga.ga_len; ++j) { lp2 = LANGP_ENTRY(ga, j); if (lp2->lp_slang->sl_sal.ga_len > 0 && STRNCMP(lp->lp_slang->sl_name, lp2->lp_slang->sl_name, 2) == 0) { lp->lp_sallang = lp2->lp_slang; break; } } if (lp->lp_slang->sl_rep.ga_len > 0) lp->lp_replang = lp->lp_slang; else for (j = 0; j < ga.ga_len; ++j) { lp2 = LANGP_ENTRY(ga, j); if (lp2->lp_slang->sl_rep.ga_len > 0 && STRNCMP(lp->lp_slang->sl_name, lp2->lp_slang->sl_name, 2) == 0) { lp->lp_replang = lp2->lp_slang; break; } } } redraw_win_later(wp, UPD_NOT_VALID); theend: vim_free(spl_copy); recursive = FALSE; return ret_msg; }"
"CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t glyph_index, int dest_width) { if (!m_Face) { return NULL; } FXFT_Set_Pixel_Sizes(m_Face, 0, 64); FXFT_Matrix ft_matrix = {65536, 0, 0, 65536}; if (m_pSubstFont) { if (m_pSubstFont->m_ItalicAngle) { int skew = m_pSubstFont->m_ItalicAngle; skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE) ? -58 : -g_AngleSkew[-skew]; if (m_bVertical) ft_matrix.yx += ft_matrix.yy * skew / 100; else ft_matrix.xy += -ft_matrix.xx * skew / 100; } if (m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) { AdjustMMParams(glyph_index, dest_width, m_pSubstFont->m_Weight); } } ScopedFontTransform scoped_transform(m_Face, &ft_matrix); int load_flags = FXFT_LOAD_NO_BITMAP; if (!(m_Face->face_flags & FT_FACE_FLAG_SFNT) || !FT_IS_TRICKY(m_Face)) { load_flags |= FT_LOAD_NO_HINTING; } if (FXFT_Load_Glyph(m_Face, glyph_index, load_flags)) return NULL; if (m_pSubstFont && !(m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) && m_pSubstFont->m_Weight > 400) { uint32_t index = (m_pSubstFont->m_Weight - 400) / 10; if (index >= WEIGHTPOW_ARRAY_SIZE) index = WEIGHTPOW_ARRAY_SIZE - 1; int level = 0; if (m_pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET) level = g_WeightPow_SHIFTJIS[index] * 2 * 65536 / 36655; else level = g_WeightPow[index] * 2; FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level); } FXFT_Outline_Funcs funcs; funcs.move_to = _Outline_MoveTo; funcs.line_to = _Outline_LineTo; funcs.conic_to = _Outline_ConicTo; funcs.cubic_to = _Outline_CubicTo; funcs.shift = 0; funcs.delta = 0; OUTLINE_PARAMS params; params.m_bCount = TRUE; params.m_PointCount = 0; FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params); if (params.m_PointCount == 0) { return NULL; } CFX_PathData* pPath = new CFX_PathData; pPath->SetPointCount(params.m_PointCount); params.m_bCount = FALSE; params.m_PointCount = 0; params.m_pPoints = pPath->GetPoints(); params.m_CurX = params.m_CurY = 0; params.m_CoordUnit = 64 * 64.0; FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params); _Outline_CheckEmptyContour(&params); pPath->TrimPoints(params.m_PointCount); if (params.m_PointCount) { pPath->GetPoints()[params.m_PointCount - 1].m_Flag |= FXPT_CLOSEFIGURE; } return pPath; }"
"void proto_register_lwapp(void) { static hf_register_info hf[] = { { &hf_lwapp_version, { ""Version"", ""lwapp.version"", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }}, { &hf_lwapp_slotid, { ""slotId"",""lwapp.slotId"", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_flags, { ""Flags"", ""lwapp.flags"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_flags_type, { ""Type"", ""lwapp.flags.type"", FT_BOOLEAN, 8, TFS(&lwapp_flags_type), LWAPP_FLAGS_T, NULL, HFILL }}, { &hf_lwapp_flags_fragment, { ""Fragment"", ""lwapp.flags.fragment"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), LWAPP_FLAGS_F, NULL, HFILL }}, { &hf_lwapp_flags_fragment_type, { ""Fragment Type"", ""lwapp.flags.fragmentType"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), LWAPP_FLAGS_FT, NULL, HFILL }}, { &hf_lwapp_fragment_id, { ""Fragment Id"",""lwapp.fragmentId"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_length, { ""Length"",""lwapp.Length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_rssi, { ""RSSI"",""lwapp.rssi"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_snr, { ""SNR"",""lwapp.snr"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, #if 0 { &hf_lwapp_control, { ""Control Data (not dissected yet)"",""lwapp.control"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, #endif { &hf_lwapp_control_mac, { ""AP Identity"", ""lwapp.apid"", FT_ETHER, BASE_NONE, NULL, 0x0, ""Access Point Identity"", HFILL }}, { &hf_lwapp_control_type, { ""Control Type"", ""lwapp.control.type"", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &control_msg_vals_ext, 0x00, NULL, HFILL }}, { &hf_lwapp_control_seq_no, { ""Control Sequence Number"", ""lwapp.control.seqno"", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }}, { &hf_lwapp_control_length, { ""Control Length"",""lwapp.control.length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }}, }; static gint *ett[] = { &ett_lwapp_l3, &ett_lwapp, &ett_lwapp_control, &ett_lwapp_flags }; module_t *lwapp_module; proto_lwapp = proto_register_protocol (""LWAPP Encapsulated Packet"", ""LWAPP"", ""lwapp""); proto_lwapp_l3 = proto_register_protocol (""LWAPP Layer 3 Packet"", ""LWAPP-L3"", ""lwapp-l3""); proto_lwapp_control = proto_register_protocol (""LWAPP Control Message"", ""LWAPP-CNTL"", ""lwapp-cntl""); proto_register_field_array(proto_lwapp, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); lwapp_module = prefs_register_protocol(proto_lwapp, NULL); prefs_register_bool_preference(lwapp_module,""swap_fc"",""Swap Frame Control"", ""Swap frame control bytes (needed for some APs"", &swap_frame_control); }"
"static void polkit_unix_group_set_property (GObject      *object, guint         prop_id, const GValue *value, GParamSpec   *pspec) { PolkitUnixGroup *unix_group = POLKIT_UNIX_GROUP (object); switch (prop_id) { case PROP_GID: unix_group->gid = g_value_get_int (value); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec); break; } }"
"int SystemCmd::doExecute( const string& command ) { string shell = PRIMARY_SHELL; if ( access( shell.c_str(), X_OK ) != 0 ) { shell = ALTERNATE_SHELL; } _lastCmd = command; if ( _outputProc ) { _outputProc->reset(); } y2deb(""Cmd:"" << command); StopWatch stopwatch; _files[IDX_STDERR] = _files[IDX_STDOUT] = NULL; invalidate(); int sout[2]; int serr[2]; bool ok = true; if ( !_testmode && pipe(sout)<0 ) { SYSCALL_FAILED( ""pipe stdout creation failed"" ); ok = false; } if ( !_testmode && !_combineOutput && pipe(serr)<0 ) { SYSCALL_FAILED( ""pipe stderr creation failed"" ); ok = false; } if ( !_testmode && ok ) { _pfds[0].fd = sout[0]; if ( fcntl( _pfds[0].fd, F_SETFL, O_NONBLOCK )<0 ) { SYSCALL_FAILED( ""fcntl O_NONBLOCK failed for stdout"" ); } if ( !_combineOutput ) { _pfds[1].fd = serr[0]; if ( fcntl( _pfds[1].fd, F_SETFL, O_NONBLOCK )<0 ) { SYSCALL_FAILED( ""fcntl O_NONBLOCK failed for stderr"" ); } } y2deb(""sout:"" << _pfds[0].fd << "" serr:"" << (_combineOutput?-1:_pfds[1].fd)); switch( (_cmdPid=fork()) ) { case 0: setenv( ""LC_ALL"", ""C"", 1 ); setenv( ""LANGUAGE"", ""C"", 1 ); if ( dup2( sout[1], STDOUT_FILENO )<0 ) { SYSCALL_FAILED_NOTHROW( ""dup2 stdout failed in child process"" ); } if ( !_combineOutput && dup2( serr[1], STDERR_FILENO )<0 ) { SYSCALL_FAILED_NOTHROW( ""dup2 stderr failed in child process"" ); } if ( _combineOutput && dup2( STDOUT_FILENO, STDERR_FILENO )<0 ) { SYSCALL_FAILED_NOTHROW( ""dup2 stderr failed in child process"" ); } if ( close( sout[0] )<0 ) { SYSCALL_FAILED_NOTHROW( ""close( stdout ) failed in child process"" ); } if ( !_combineOutput && close( serr[0] )<0 ) { SYSCALL_FAILED_NOTHROW( ""close( stderr ) failed in child process"" ); } closeOpenFds(); _cmdRet = execl( shell.c_str(), shell.c_str(), ""-c"", command.c_str(), NULL ); y2err( ""execl() failed: THIS SHOULD NOT HAPPEN \"""" << shell << ""\"" Ret:"" << _cmdRet << "" errno: "" << errno ); y2err( ""Exiting child process"" ); exit(127);     break; case -1: _cmdRet = -1; SYSCALL_FAILED( ""fork() failed"" ); break; default: if ( close( sout[1] )<0 ) { SYSCALL_FAILED_NOTHROW( ""close( stdout ) in parent failed"" ); } if ( !_combineOutput && close( serr[1] )<0 ) { SYSCALL_FAILED_NOTHROW( ""close( stderr ) in parent failed"" ); } _cmdRet = 0; _files[IDX_STDOUT] = fdopen( sout[0], ""r"" ); if ( _files[IDX_STDOUT] == NULL ) { SYSCALL_FAILED_NOTHROW( ""fdopen( stdout ) failed"" ); } if ( !_combineOutput ) { _files[IDX_STDERR] = fdopen( serr[0], ""r"" ); if ( _files[IDX_STDERR] == NULL ) { SYSCALL_FAILED_NOTHROW( ""fdopen( stderr ) failed"" ); } } if ( !_execInBackground ) { doWait( true, _cmdRet ); y2mil(""stopwatch "" << stopwatch << "" for \"""" << cmd() << ""\""""); } break; } } else if ( !_testmode ) { _cmdRet = -1; } else { _cmdRet = 0; y2mil(""TESTMODE would execute \"""" << command << ""\""""); } if ( _cmdRet==-127 || _cmdRet==-1 ) { y2err(""system (\"""" << command << ""\"") = "" << _cmdRet); } if ( !_testmode ) checkOutput(); y2mil(""system() Returns:"" << _cmdRet); if ( _cmdRet!=0 ) logOutput(); return _cmdRet; }"
"void mrb_proc_copy(struct RProc *a, struct RProc *b) { if (a->body.irep) { return; } a->flags = b->flags; a->body = b->body; if (!MRB_PROC_CFUNC_P(a) && a->body.irep) { mrb_irep_incref(NULL, (mrb_irep*)a->body.irep); } a->upper = b->upper; a->e.env = b->e.env; }"
"static String HHVM_FUNCTION(bcpow, const String& left, const String& right, int64_t scale ) { if (scale < 0) scale = BCG(bc_precision); bc_num first, second, result; bc_init_num(&first); bc_init_num(&second); bc_init_num(&result); SCOPE_EXIT { bc_free_num(&first); bc_free_num(&second); bc_free_num(&result); }"
"static cairo_surface_t * rsvg_filter_primitive_image_render_in (RsvgFilterPrimitive * self, RsvgFilterContext * context) { RsvgDrawingCtx *ctx; RsvgFilterPrimitiveImage *upself; RsvgNode *drawable; ctx = context->ctx; upself = (RsvgFilterPrimitiveImage *) self; if (!upself->href) return NULL; drawable = rsvg_defs_lookup (ctx->defs, upself->href->str); if (!drawable) return NULL; rsvg_current_state (ctx)->affine = context->paffine; return rsvg_get_surface_of_node (ctx, drawable, context->width, context->height); }"
"void WebstoreStandaloneInstaller::ShowInstallUI() { scoped_refptr<const Extension> localized_extension = GetLocalizedExtensionForDisplay(); if (!localized_extension.get()) { CompleteInstall(webstore_install::INVALID_MANIFEST, kInvalidManifestError); return; } install_ui_ = CreateInstallUI(); install_ui_->ShowDialog( base::Bind(&WebstoreStandaloneInstaller::OnInstallPromptDone, this), localized_extension.get(), &icon_, std::move(install_prompt_), ExtensionInstallPrompt::GetDefaultShowDialogCallback()); }"
void DidCreateDocumentElement() override { CallbackAndDie(true); }
"static char *qemu_disk_ide_drive_string(libxl__gc *gc, const char *target_path, int unit, const char *format, const libxl_device_disk *disk, int colo_mode) { char *drive = NULL; const char *exportname = disk->colo_export; const char *active_disk = disk->active_disk; const char *hidden_disk = disk->hidden_disk; switch (colo_mode) { case LIBXL__COLO_NONE: drive = GCSPRINTF (""file=%s,if=ide,index=%d,media=disk,format=%s,cache=writeback"", target_path, unit, format); break; case LIBXL__COLO_PRIMARY: drive = GCSPRINTF( ""if=ide,index=%d,media=disk,cache=writeback,driver=quorum,"" ""id=%s,"" ""children.0.file.filename=%s,"" ""children.0.driver=%s,"" ""read-pattern=fifo,"" ""vote-threshold=1"", unit, exportname, target_path, format); break; case LIBXL__COLO_SECONDARY: drive = GCSPRINTF( ""if=ide,index=%d,id=top-colo,media=disk,cache=writeback,"" ""driver=replication,"" ""mode=secondary,"" ""top-id=top-colo,"" ""file.driver=qcow2,"" ""file.file.filename=%s,"" ""file.backing.driver=qcow2,"" ""file.backing.file.filename=%s,"" ""file.backing.backing=%s"", unit, active_disk, hidden_disk, exportname); break; default: abort(); } return drive; }"
"static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx) { u32 pck_size = 0; GF_FilterPacket *pck = NULL; u8 *output = NULL; if (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM; gf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc); if (!pck_size) { GF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (""[AV1Dmx] no frame OBU, skipping OBU\n"")); return GF_OK; } pck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output); if (!pck) return GF_OUT_OF_MEM; if (ctx->src_pck) gf_filter_pck_merge_properties(ctx->src_pck, pck); gf_filter_pck_set_cts(pck, ctx->cts); gf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0); memcpy(output, ctx->state.frame_obus, pck_size); if (ctx->deps) { u8 flags = 0; flags = ( ctx->state.frame_state.key_frame) ? 2 : 1; flags <<= 2; flags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2; flags <<= 2; gf_filter_pck_set_dependency_flags(pck, flags); } if (ctx->state.clli_valid) { u32 crc = gf_crc_32(ctx->state.clli_data, 4); if (crc != ctx->clli_crc) { gf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4)); } } if (ctx->state.mdcv_valid) { u32 crc = gf_crc_32(ctx->state.mdcv_data, 24); if (crc != ctx->mdcv_crc) { av1dmx_set_mdcv(ctx, NULL, pck); } } gf_filter_pck_send(pck); av1dmx_update_cts(ctx); gf_av1_reset_state(&ctx->state, GF_FALSE); return GF_OK; }"
"static void nhmldump_send_frame(GF_NHMLDumpCtx *ctx, char *data, u32 data_size, GF_FilterPacket *pck) { GF_FilterPacket *dst_pck; char nhml[1024]; const GF_PropertyValue *p; u32 size; u8 *output; GF_FilterSAPType sap = gf_filter_pck_get_sap(pck); u64 dts = gf_filter_pck_get_dts(pck); u64 cts = gf_filter_pck_get_cts(pck); if (dts==GF_FILTER_NO_TS) dts = cts; if (cts==GF_FILTER_NO_TS) cts = dts; ctx->pck_num++; sprintf(nhml, ""<NHNTSample number=\""%d\"" DTS=\""""LLU""\"" dataLength=\""%d\"" "", ctx->pck_num, dts, data_size); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if (ctx->pckp || (cts != dts) ) { sprintf(nhml, ""CTSOffset=\""%d\"" "", (s32) ((s64)cts - (s64)dts)); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } if (sap==GF_FILTER_SAP_1) { sprintf(nhml, ""isRAP=\""yes\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (sap) { sprintf(nhml, ""SAPType=\""%d\"" "", sap); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (ctx->pckp) { sprintf(nhml, ""isRAP=\""no\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if ((sap==GF_FILTER_SAP_4) || (sap==GF_FILTER_SAP_4_PROL)) { s32 roll = gf_filter_pck_get_roll_info(pck); sprintf(nhml, ""SAPType=\""4\"" %s=\""%d\"" "", (sap==GF_FILTER_SAP_4_PROL) ? ""prol"" : ""roll"", roll); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } if (ctx->pckp) { u64 bo; u32 duration, idx; sprintf(nhml, ""mediaOffset=\""""LLU""\"" "", ctx->mdia_pos); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); bo = gf_filter_pck_get_byte_offset(pck); if (bo!=GF_FILTER_NO_BO) { sprintf(nhml, ""sourceByteOffset=\""""LLU""\"" "", bo); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } duration = gf_filter_pck_get_duration(pck); if (duration) { sprintf(nhml, ""duration=\""%d\"" "", duration); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = gf_filter_pck_get_carousel_version(pck); if (idx) { sprintf(nhml, ""carouselVersion=\""%d\"" "", idx); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = 0; while (1) { u32 prop_4cc; const char *prop_name; p = gf_filter_pck_enum_properties(pck, &idx, &prop_4cc, &prop_name); if (!p) break; if (prop_4cc == GF_PROP_PCK_SUBS) continue; nhmldump_pck_property(ctx, prop_4cc, prop_name, p); } } if (ctx->chksum) { if (ctx->chksum==1) { u32 crc = gf_crc_32(data, data_size); sprintf(nhml, ""crc=\""%08X\"" "", crc); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 j; u8 hash[GF_SHA1_DIGEST_SIZE]; gf_sha1_csum(data, data_size, hash); sprintf(nhml, ""sha1=\""""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); for (j=0; j<20; j++) { sprintf(nhml, ""%02X"", hash[j]); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } sprintf(nhml, "">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); p = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS); if (p) { u32 offset_in_sample = 0; Bool first_subs = GF_TRUE; if (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ); else gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size); while (gf_bs_available(ctx->bs_r)) { u32 s_flags = gf_bs_read_u32(ctx->bs_r); u32 s_size = gf_bs_read_u32(ctx->bs_r); u32 s_res = gf_bs_read_u32(ctx->bs_r); u8 s_prio = gf_bs_read_u8(ctx->bs_r); u8 s_discard = gf_bs_read_u8(ctx->bs_r); if (offset_in_sample + s_size > data_size) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""Wrong subsample info: sample size %d vs subsample offset+size %dn"", data_size, offset_in_sample + s_size)); break; } if (ctx->is_stpp && ctx->nhmlonly) { if (first_subs) { sprintf(nhml, ""<NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, s_size); sprintf(nhml, ""</NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 d_size; if (ctx->b64_buffer_size<2*s_size) { ctx->b64_buffer_size = 2 * s_size; ctx->b64_buffer = gf_realloc(ctx->b64_buffer, ctx->b64_buffer_size); } d_size = gf_base64_encode(data + offset_in_sample, s_size, ctx->b64_buffer, ctx->b64_buffer_size); ctx->b64_buffer[d_size] = 0; sprintf(nhml, ""<NHNTSubSample data=\""data:application/octet-string;base64,""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, ctx->b64_buffer, d_size); sprintf(nhml, ""\"">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } else { sprintf(nhml, ""<NHNTSubSample size=\""%d\"" flags=\""%d\"" reserved=\""%d\"" priority=\""%d\"" discard=\""%d\"" />\n"", s_size, s_flags, s_res, s_prio, s_discard); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } first_subs = GF_FALSE; } } else if (ctx->is_stpp && ctx->nhmlonly) { sprintf(nhml, ""<NHNTSubSample><![CDATA[\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, data_size); sprintf(nhml, ""]]></NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""</NHNTSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size); if (ctx->filep) { gf_fwrite(ctx->nhml_buffer, size, ctx->filep); return; } dst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output); if (dst_pck) { memcpy(output, ctx->nhml_buffer, size); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_send(dst_pck); } ctx->mdia_pos += data_size; if (ctx->opid_mdia) { dst_pck = gf_filter_pck_new_ref(ctx->opid_mdia, 0, data_size, pck); if (!dst_pck) return; gf_filter_pck_merge_properties(pck, dst_pck); gf_filter_pck_set_framing(dst_pck, ctx->first, GF_FALSE); gf_filter_pck_send(dst_pck); } }"
"njs_int_t njs_object_property(njs_vm_t *vm, njs_object_t *object, njs_lvlhsh_query_t *lhq, njs_value_t *retval) { njs_int_t          ret; njs_value_t        value; njs_object_prop_t  *prop; do { ret = njs_lvlhsh_find(&object->hash, lhq); if (njs_fast_path(ret == NJS_OK)) { goto found; } ret = njs_lvlhsh_find(&object->shared_hash, lhq); if (njs_fast_path(ret == NJS_OK)) { goto found; } object = object->__proto__; } while (object != NULL); njs_set_undefined(retval); return NJS_DECLINED; found: prop = lhq->value; if (njs_is_data_descriptor(prop)) { njs_value_assign(retval, njs_prop_value(prop)); return NJS_OK; } if (njs_prop_getter(prop) == NULL) { njs_set_undefined(retval); return NJS_OK; } njs_set_object(&value, object); return njs_function_apply(vm, njs_prop_getter(prop), &value, 1, retval); }"
"bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  ) { m_serviceHandle = CreateService( m_serviceManager,WindowsCoreFunctions::toConstWCharArray( m_name ),WindowsCoreFunctions::toConstWCharArray( displayName ),SERVICE_ALL_ACCESS,SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START,SERVICE_ERROR_NORMAL,WindowsCoreFunctions::toConstWCharArray( filePath ),nullptr,nullptr,L""Tcpip\0RpcSs\0\0"",nullptr,nullptr ); if( m_serviceHandle == nullptr ) { const auto error = GetLastError(); if( error == ERROR_SERVICE_EXISTS ) { vCritical() << qUtf8Printable( tr( ""The service \""%1\"" is already installed."" ).arg( m_name ) ); } else { vCritical() << qUtf8Printable( tr( ""The service \""%1\"" could not be installed."" ).arg( m_name ) ); } return false; } SC_ACTION serviceActions; serviceActions.Delay = 10000; serviceActions.Type = SC_ACTION_RESTART; SERVICE_FAILURE_ACTIONS serviceFailureActions; serviceFailureActions.dwResetPeriod = 0; serviceFailureActions.lpRebootMsg = nullptr; serviceFailureActions.lpCommand = nullptr; serviceFailureActions.lpsaActions = &serviceActions; serviceFailureActions.cActions = 1; ChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions ); vInfo() << qUtf8Printable( tr( ""The service \""%1\"" has been installed successfully."" ).arg( m_name ) ); return true; }"
"char* skipSpaces( char* ptr ) { bool is_eof = false; bool is_completed = false; while ( is_eof == false && is_completed == false ) { switch ( *ptr ) { case '/' : { ptr++; if ( *ptr == '\0' ) { ptr = fs->gets(); if( !ptr || !*ptr ) { is_eof = true; break; } } if ( *ptr == '/' ) { while ( *ptr != '\n' && *ptr != '\r' ) { if ( *ptr == '\0' ) { ptr = fs->gets(); if( !ptr || !*ptr ) { is_eof = true; break; } } else { ptr++; } } } else if ( *ptr == '*' ) { ptr++; for (;;) { if ( *ptr == '\0' ) { ptr = fs->gets(); if( !ptr || !*ptr ) { is_eof = true; break; } } else if ( *ptr == '*' ) { ptr++; if ( *ptr == '\0' ) { ptr = fs->gets(); if( !ptr || !*ptr ) { is_eof = true; break; } } if ( *ptr == '/' ) { ptr++; break; } } else { ptr++; } } } else { CV_PARSE_ERROR_CPP( ""Not supported escape character"" ); } } break; case '\t': case ' ' : { ptr++; } break; case '\0': case '\n': case '\r': { ptr = fs->gets(); if( !ptr || !*ptr ) { is_eof = true; break; } } break; default: { if( !cv_isprint(*ptr) ) CV_PARSE_ERROR_CPP( ""Invalid character in the stream"" ); is_completed = true; } break; } } if ( is_eof || !is_completed ) { ptr = fs->bufferStart(); *ptr = '\0'; fs->setEof(); if( !is_completed ) CV_PARSE_ERROR_CPP( ""Abort at parse time"" ); } return ptr; }"
"void NuPlayer::GenericSource::notifyPreparedAndCleanup(status_t err) { if (err != OK) { mMetaDataSize = -1ll; mContentType = """"; mSniffedMIME = """"; { sp<DataSource> dataSource = mDataSource; sp<NuCachedSource2> cachedSource = mCachedSource; sp<DataSource> httpSource = mHttpSource; { Mutex::Autolock _l(mDisconnectLock); mDataSource.clear(); mCachedSource.clear(); mHttpSource.clear(); } } cancelPollBuffering(); } notifyPrepared(err); }"
inline int StringData::size() const { return m_len; }
"static int __get_page_type(struct page_info *page, unsigned long type, int preemptible) { unsigned long nx, x, y = page->u.inuse.type_info; int rc = 0, iommu_ret = 0; ASSERT(!(type & ~(PGT_type_mask | PGT_pae_xen_l2))); ASSERT(!in_irq()); for ( ; ; ) { x  = y; nx = x + 1; if ( unlikely((nx & PGT_count_mask) == 0) ) { gdprintk(XENLOG_WARNING, ""Type count overflow on mfn %""PRI_mfn""\n"", mfn_x(page_to_mfn(page))); return -EINVAL; } else if ( unlikely((x & PGT_count_mask) == 0) ) { struct domain *d = page_get_owner(page); if ( d && shadow_mode_enabled(d) && (page->count_info & PGC_page_table) && !((page->shadow_flags & (1u<<29)) && type == PGT_writable_page) ) shadow_remove_all_shadows(d, page_to_mfn(page)); ASSERT(!(x & PGT_pae_xen_l2)); if ( (x & PGT_type_mask) != type ) { cpumask_t *mask = this_cpu(scratch_cpumask); BUG_ON(in_irq()); cpumask_copy(mask, d->domain_dirty_cpumask); tlbflush_filter(mask, page->tlbflush_timestamp); if ( unlikely(!cpumask_empty(mask)) && (!shadow_mode_enabled(page_get_owner(page)) || ((nx & PGT_type_mask) == PGT_writable_page)) ) { perfc_incr(need_flush_tlb_flush); flush_tlb_mask(mask); } nx &= ~(PGT_type_mask | PGT_validated); nx |= type; if ( type == PGT_writable_page || type == PGT_shared_page ) nx |= PGT_validated; } } else if ( unlikely((x & (PGT_type_mask|PGT_pae_xen_l2)) != type) ) { if ( ((x & PGT_type_mask) == PGT_l2_page_table) && (type == PGT_l1_page_table) ) return -EINVAL; if ( ((x & PGT_type_mask) == PGT_l3_page_table) && (type == PGT_l2_page_table) ) return -EINVAL; if ( ((x & PGT_type_mask) == PGT_l4_page_table) && (type == PGT_l3_page_table) ) return -EINVAL; gdprintk(XENLOG_WARNING, ""Bad type (saw %"" PRtype_info "" != exp %"" PRtype_info "") "" ""for mfn %"" PRI_mfn "" (pfn %"" PRI_pfn "")\n"", x, type, mfn_x(page_to_mfn(page)), get_gpfn_from_mfn(mfn_x(page_to_mfn(page)))); return -EINVAL; } else if ( unlikely(!(x & PGT_validated)) ) { if ( !(x & PGT_partial) ) { while ( (y = page->u.inuse.type_info) == x ) { if ( preemptible && hypercall_preempt_check() ) return -EINTR; cpu_relax(); } continue; } ASSERT((x & PGT_count_mask) == 1); nx = x & ~PGT_partial; } if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) ) break; if ( preemptible && hypercall_preempt_check() ) return -EINTR; } if ( unlikely((x & PGT_type_mask) != type) ) { struct domain *d = page_get_owner(page); if ( d && is_pv_domain(d) && unlikely(need_iommu(d)) ) { gfn_t gfn = _gfn(mfn_to_gmfn(d, mfn_x(page_to_mfn(page)))); if ( (x & PGT_type_mask) == PGT_writable_page ) iommu_ret = iommu_unmap_page(d, gfn_x(gfn)); else if ( type == PGT_writable_page ) iommu_ret = iommu_map_page(d, gfn_x(gfn), mfn_x(page_to_mfn(page)), IOMMUF_readable|IOMMUF_writable); } } if ( unlikely(!(nx & PGT_validated)) ) { if ( !(x & PGT_partial) ) { page->nr_validated_ptes = 0; page->partial_pte = 0; } rc = alloc_page_type(page, type, preemptible); } if ( (x & PGT_partial) && !(nx & PGT_partial) ) put_page(page); if ( !rc ) rc = iommu_ret; return rc; }"
"int jas_stream_pad(jas_stream_t *stream, int n, int c) { int m; m = n; for (m = n; m > 0; --m) { if (jas_stream_putc(stream, c) == EOF) return n - m; } return n; }"
"void CalculateOutputIndexValueRowID( const RowPartitionTensor& value_rowids, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { const INDEX_TYPE index_size = value_rowids.size(); result->reserve(index_size); if (index_size == 0) { return; } INDEX_TYPE current_output_column = 0; INDEX_TYPE current_value_rowid = value_rowids(0); DCHECK_LT(current_value_rowid, parent_output_index.size()); INDEX_TYPE current_output_index = parent_output_index[current_value_rowid]; result->push_back(current_output_index); for (INDEX_TYPE i = 1; i < index_size; ++i) { INDEX_TYPE next_value_rowid = value_rowids(i); if (next_value_rowid == current_value_rowid) { if (current_output_index >= 0) { ++current_output_column; if (current_output_column < output_size) { current_output_index += output_index_multiplier; } else { current_output_index = -1; } } } else { current_output_column = 0; current_value_rowid = next_value_rowid; DCHECK_LT(next_value_rowid, parent_output_index.size()); current_output_index = parent_output_index[next_value_rowid]; } result->push_back(current_output_index); } DCHECK_EQ(result->size(), value_rowids.size()); }"
"SkAutoSTMalloc(size_t count) { if (count > kCount) { fPtr = (T*)sk_malloc_flags(count * sizeof(T), SK_MALLOC_THROW | SK_MALLOC_TEMP); } else if (count) { fPtr = fTStorage; } else { fPtr = nullptr; } }"
"void svhandler_flash_erase_sector(void) { uint32_t sector = _param_1; if ((sector == FLASH_BOOTSTRAP_SECTOR) || (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) { return; } flash_clear_status_flags(); flash_unlock(); flash_erase_sector(sector, FLASH_CR_PROGRAM_X32); _param_1 = !!flash_chk_status(); _param_2 = 0; _param_3 = 0; flash_wait_for_last_operation(); FLASH_CR &= ~FLASH_CR_PG; FLASH_CR |= FLASH_CR_LOCK; }"
"gboolean _g_file_remove_directory (GFile         *directory, GCancellable  *cancellable, GError       **error) { GFileEnumerator *enumerator; GFileInfo       *info; gboolean         error_occurred = FALSE; if (directory == NULL) return TRUE; enumerator = g_file_enumerate_children (directory, G_FILE_ATTRIBUTE_STANDARD_NAME "","" G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, cancellable, error); while (! error_occurred && (info = g_file_enumerator_next_file (enumerator, cancellable, error)) != NULL) { GFile *child; child = g_file_get_child (directory, g_file_info_get_name (info)); switch (g_file_info_get_file_type (info)) { case G_FILE_TYPE_DIRECTORY: if (! _g_file_remove_directory (child, cancellable, error)) error_occurred = TRUE; break; default: if (! g_file_delete (child, cancellable, error)) error_occurred = TRUE; break; } g_object_unref (child); g_object_unref (info); } if (! error_occurred && ! g_file_delete (directory, cancellable, error)) error_occurred = TRUE; g_object_unref (enumerator); return ! error_occurred; }"
"void load_system_tables(void) { unsigned int cpu = smp_processor_id(); unsigned long stack_bottom = get_stack_bottom(), stack_top = stack_bottom & ~(STACK_SIZE - 1); struct tss_struct *tss = &this_cpu(init_tss); struct desc_struct *gdt = this_cpu(gdt_table) - FIRST_RESERVED_GDT_ENTRY; struct desc_struct *compat_gdt = this_cpu(compat_gdt_table) - FIRST_RESERVED_GDT_ENTRY; const struct desc_ptr gdtr = { .base = (unsigned long)gdt, .limit = LAST_RESERVED_GDT_BYTE, }; const struct desc_ptr idtr = { .base = (unsigned long)idt_tables[cpu], .limit = (IDT_ENTRIES * sizeof(idt_entry_t)) - 1, }; *tss = (struct tss_struct){ .rsp0 = stack_bottom, .rsp1 = 0x8600111111111111ul, .rsp2 = 0x8600111111111111ul, .ist = { [IST_MCE - 1] = stack_top + IST_MCE * PAGE_SIZE, [IST_DF  - 1] = stack_top + IST_DF  * PAGE_SIZE, [IST_NMI - 1] = stack_top + IST_NMI * PAGE_SIZE, [IST_MAX ... ARRAY_SIZE(tss->ist) - 1] = 0x8600111111111111ul, }, .bitmap = IOBMP_INVALID_OFFSET, }; _set_tssldt_desc( gdt + TSS_ENTRY, (unsigned long)tss, offsetof(struct tss_struct, __cacheline_filler) - 1, SYS_DESC_tss_avail); _set_tssldt_desc( compat_gdt + TSS_ENTRY, (unsigned long)tss, offsetof(struct tss_struct, __cacheline_filler) - 1, SYS_DESC_tss_busy); asm volatile (""lgdt %0""  : : ""m""  (gdtr) ); asm volatile (""lidt %0""  : : ""m""  (idtr) ); asm volatile (""ltr  %w0"" : : ""rm"" (TSS_ENTRY << 3) ); asm volatile (""lldt %w0"" : : ""rm"" (0) ); BUILD_BUG_ON((sizeof(struct cpu_info) - offsetof(struct cpu_info, guest_cpu_user_regs.es)) & 0xf); BUG_ON(system_state != SYS_STATE_early_boot && (stack_bottom & 0xf)); }"
"M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags) { char                   *norm_path; char                   *join_path; M_fs_dir_entries_t     *entries; const M_fs_dir_entry_t *entry; M_fs_info_t            *info; M_fs_progress_t        *progress            = NULL; M_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE; M_fs_type_t             type; M_fs_error_t            res; M_fs_error_t            res2; size_t                  len; size_t                  i; M_uint64                total_size          = 0; M_uint64                total_size_progress = 0; M_uint64                entry_size; res = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO); if (res != M_FS_ERROR_SUCCESS) { M_free(norm_path); return res; } res = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC); if (res != M_FS_ERROR_SUCCESS) { M_free(norm_path); return res; } type = M_fs_info_get_type(info); if (type == M_FS_TYPE_UNKNOWN) { M_fs_info_destroy(info); M_free(norm_path); return M_FS_ERROR_GENERIC; } entries = M_fs_dir_entries_create(); if (type == M_FS_TYPE_DIR && remove_children) { if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) { filter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC; } M_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter)); } M_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC)); len = M_fs_dir_entries_len(entries); if (cb) { progress = M_fs_progress_create(); if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) { for (i=0; i<len; i++) { entry       = M_fs_dir_entries_at(entries, i); entry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry)); total_size += entry_size; } M_fs_progress_set_size_total(progress, total_size); } if (progress_flags & M_FS_PROGRESS_COUNT) { M_fs_progress_set_count_total(progress, len); } } res = M_FS_ERROR_SUCCESS; for (i=0; i<len; i++) { entry     = M_fs_dir_entries_at(entries, i); join_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO); if (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) { res2 = M_fs_delete_dir(join_path); } else { res2 = M_fs_delete_file(join_path); } if (res2 != M_FS_ERROR_SUCCESS) { res = M_FS_ERROR_GENERIC; } if (cb) { entry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry)); total_size_progress += entry_size; M_fs_progress_set_path(progress, join_path); M_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry)); M_fs_progress_set_result(progress, res2); if (progress_flags & M_FS_PROGRESS_COUNT) { M_fs_progress_set_count(progress, i+1); } if (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) { M_fs_progress_set_size_total_progess(progress, total_size_progress); } if (progress_flags & M_FS_PROGRESS_SIZE_CUR) { M_fs_progress_set_size_current(progress, entry_size); M_fs_progress_set_size_current_progress(progress, entry_size); } } M_free(join_path); if (cb && !cb(progress)) { res = M_FS_ERROR_CANCELED; break; } } M_fs_dir_entries_destroy(entries); M_fs_progress_destroy(progress); M_free(norm_path); return res; }"
"static int em_ret_far(struct x86_emulate_ctxt *ctxt) { int rc; unsigned long eip, cs; u16 old_cs; int cpl = ctxt->ops->cpl(ctxt); struct desc_struct old_desc, new_desc; const struct x86_emulate_ops *ops = ctxt->ops; if (ctxt->mode == X86EMUL_MODE_PROT64) ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS); rc = emulate_pop(ctxt, &eip, ctxt->op_bytes); if (rc != X86EMUL_CONTINUE) return rc; rc = emulate_pop(ctxt, &cs, ctxt->op_bytes); if (rc != X86EMUL_CONTINUE) return rc; if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl) return X86EMUL_UNHANDLEABLE; rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl, X86_TRANSFER_RET, &new_desc); if (rc != X86EMUL_CONTINUE) return rc; rc = assign_eip_far(ctxt, eip, &new_desc); if (rc != X86EMUL_CONTINUE) { WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64); ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS); } return rc; }"
"static char** parse_attributes(const char *line, s_accumulated_attributes *attributes) { int int_value, i; char **ret; char *end_ptr; if (line == NULL) return NULL; if (!safe_start_equals(""#EXT"", line)) return NULL; if (safe_start_equals(""#EXT-X-ENDLIST"", line)) { attributes->is_playlist_ended = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); return NULL; } attributes->type = MEDIA_TYPE_UNKNOWN; ret = extract_attributes(""#EXT-X-TARGETDURATION:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32) strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->target_duration_in_seconds = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-MEDIA-SEQUENCE:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->min_media_sequence = int_value; attributes->current_media_seq = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-VERSION:"", line, 1); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->version = int_value; } M3U8_COMPATIBILITY_VERSION(1); } return ret; } ret = extract_attributes(""#EXTINF:"", line, 2); if (ret) { M3U8_COMPATIBILITY_VERSION(1); attributes->is_media_segment = GF_TRUE; if (ret[0]) { double double_value = strtod(ret[0], &end_ptr); if (end_ptr != ret[0]) { attributes->duration_in_seconds = double_value; } if (strstr(ret[0], ""."") || (double_value > (int)double_value)) { M3U8_COMPATIBILITY_VERSION(3); } } if (ret[1]) { if (attributes->title) gf_free(attributes->title); attributes->title = gf_strdup(ret[1]); } return ret; } ret = extract_attributes(""#EXT-X-KEY:"", line, 4); if (ret) { const char *method = ""METHOD=""; const size_t method_len = strlen(method); if (safe_start_equals(method, ret[0])) { if (!strncmp(ret[0]+method_len, ""NONE"", 4)) { attributes->key_method = DRM_NONE; if (attributes->key_url) { gf_free(attributes->key_url); attributes->key_url = NULL; } } else if (!strncmp(ret[0]+method_len, ""AES-128"", 7)) { attributes->key_method = DRM_AES_128; } else if (!strncmp(ret[0]+method_len, ""SAMPLE-AES"", 10)) { attributes->key_method = DRM_CENC; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] EXT-X-KEY method not recognized.\n"")); } if (ret[1] != NULL && safe_start_equals(""URI=\"""", ret[1])) { int_value = (u32) strlen(ret[1]); if (ret[1][int_value-1] == '""') { if (attributes->key_url) gf_free(attributes->key_url); attributes->key_url = gf_strdup(&(ret[1][5])); if (attributes->key_url) { u32 klen = (u32) strlen(attributes->key_url); attributes->key_url[klen-1] = 0; } } } attributes->has_iv = GF_FALSE; if (ret[2] != NULL && safe_start_equals(""IV="", ret[2])) { char *IV = ret[2] + 3; if (!strncmp(IV, ""0x"", 2)) IV+=2; if (strlen(IV) != 32) { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] EXT-X-KEY wrong IV len\n"")); } else { for (i=0; i<16; i++) { char szV[3]; u32 v; szV[0] = IV[2*i]; szV[1] = IV[2*i + 1]; szV[2] = 0; sscanf(szV, ""%X"", &v); attributes->key_iv[i] = v; } } attributes->has_iv = GF_TRUE; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-PROGRAM-DATE-TIME:"", line, 1); if (ret) { if (ret[0]) attributes->playlist_utc_timestamp = gf_net_parse_date(ret[0]); M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-ALLOW-CACHE:"", line, 1); if (ret) { GF_LOG(GF_LOG_INFO, GF_LOG_DASH,(""[M3U8] EXT-X-ALLOW-CACHE not supported.\n"", line)); M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-PLAYLIST-TYPE"", line, 1); if (ret) { if (ret[0] && !strcmp(ret[0], ""VOD"")) attributes->is_playlist_ended = GF_TRUE; M3U8_COMPATIBILITY_VERSION(3); return ret; } ret = extract_attributes(""#EXT-X-MAP"", line, 4); if (ret) { i=0; while (ret[i] != NULL) { char *val = ret[i]; if (val[0]==':') val++; if (safe_start_equals(""URI=\"""", val)) { char *uri = val + 5; int_value = (u32) strlen(uri); if (int_value > 0 && uri[int_value-1] == '""') { if (attributes->init_url) gf_free(attributes->init_url); attributes->init_url = gf_strdup(uri); attributes->init_url[int_value-1]=0; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid URI (%s) in EXT-X-MAP\n"", val)); } } else if (safe_start_equals(""BYTERANGE=\"""", val)) { u64 begin, size; val+=10; if (sscanf(val, ""\""""LLU""@""LLU""\"""", &size, &begin) == 2) { if (size) { attributes->init_byte_range_start = begin; attributes->init_byte_range_end = begin + size - 1; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid byte range %s\n"", val)); } } } i++; } M3U8_COMPATIBILITY_VERSION(3); return ret; } ret = extract_attributes(""#EXT-X-STREAM-INF:"", line, 10); if (ret) { i = 0; attributes->is_master_playlist = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); while (ret[i] != NULL) { char *utility; if (safe_start_equals(""BANDWIDTH="", ret[i])) { utility = &(ret[i][10]); int_value = (s32) strtol(utility, &end_ptr, 10); if (end_ptr != utility) attributes->bandwidth = int_value; } else if (safe_start_equals(""PROGRAM-ID="", ret[i])) { utility = &(ret[i][11]); int_value = (s32) strtol(utility, &end_ptr, 10); if (end_ptr != utility) attributes->stream_id = int_value; } else if (safe_start_equals(""CODECS=\"""", ret[i])) { int_value = (u32) strlen(ret[i]); if (ret[i][int_value-1] == '""') { if (attributes->codecs) gf_free(attributes->codecs); attributes->codecs = gf_strdup(&(ret[i][7])); } } else if (safe_start_equals(""RESOLUTION="", ret[i])) { u32 w, h; utility = &(ret[i][11]); if ((sscanf(utility, ""%dx%d"", &w, &h)==2) || (sscanf(utility, ""%dx%d,"", &w, &h)==2)) { attributes->width = w; attributes->height = h; } M3U8_COMPATIBILITY_VERSION(2); } else if (safe_start_equals(""AUDIO="", ret[i])) { assert(attributes->type == MEDIA_TYPE_UNKNOWN); attributes->type = MEDIA_TYPE_AUDIO; if (attributes->group.audio) gf_free(attributes->group.audio); attributes->group.audio = gf_strdup(ret[i] + 6); M3U8_COMPATIBILITY_VERSION(4); } else if (safe_start_equals(""VIDEO="", ret[i])) { assert(attributes->type == MEDIA_TYPE_UNKNOWN); attributes->type = MEDIA_TYPE_VIDEO; if (attributes->group.video) gf_free(attributes->group.video); attributes->group.video = gf_strdup(ret[i] + 6); M3U8_COMPATIBILITY_VERSION(4); } i++; } if (!attributes->bandwidth) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-STREAM-INF: no BANDWIDTH found. Ignoring the line.\n"")); return NULL; } return ret; } ret = extract_attributes(""#EXT-X-DISCONTINUITY"", line, 0); if (ret) { attributes->discontinuity = 1; M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-DISCONTINUITY-SEQUENCE"", line, 0); if (ret) { if (ret[0]) { int_value = (s32)strtol(ret[0], &end_ptr, 10); if (end_ptr != ret[0]) { attributes->discontinuity = int_value; } } M3U8_COMPATIBILITY_VERSION(1); return ret; } ret = extract_attributes(""#EXT-X-BYTERANGE:"", line, 1); if (ret) { if (ret[0]) { u64 begin, size; if (sscanf(ret[0], LLU""@""LLU, &size, &begin) == 2) { if (size) { attributes->byte_range_start = begin; attributes->byte_range_end = begin + size - 1; } else { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid byte range %s\n"", ret[0])); } } } M3U8_COMPATIBILITY_VERSION(4); return ret; } ret = extract_attributes(""#EXT-X-MEDIA:"", line, 14); if (ret) { M3U8_COMPATIBILITY_VERSION(4); attributes->is_master_playlist = GF_TRUE; i = 0; while (ret[i] != NULL) { if (safe_start_equals(""TYPE="", ret[i])) { if (!strncmp(ret[i]+5, ""AUDIO"", 5)) { attributes->type = MEDIA_TYPE_AUDIO; } else if (!strncmp(ret[i]+5, ""VIDEO"", 5)) { attributes->type = MEDIA_TYPE_VIDEO; } else if (!strncmp(ret[i]+5, ""SUBTITLES"", 9)) { attributes->type = MEDIA_TYPE_SUBTITLES; } else if (!strncmp(ret[i]+5, ""CLOSED-CAPTIONS"", 15)) { attributes->type = MEDIA_TYPE_CLOSED_CAPTIONS; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Unsupported #EXT-X-MEDIA:TYPE=%s\n"", ret[i]+5)); } } else if (safe_start_equals(""URI=\"""", ret[i])) { size_t len; if (attributes->mediaURL) gf_free(attributes->mediaURL); attributes->mediaURL = gf_strdup(ret[i]+5); len = strlen(attributes->mediaURL); if (len && (attributes->mediaURL[len-1] == '""')) { attributes->mediaURL[len-1] = '\0'; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Misformed #EXT-X-MEDIA:URI=%s. Quotes are incorrect.\n"", ret[i]+5)); } } else if (safe_start_equals(""GROUP-ID="", ret[i])) { if (attributes->type == MEDIA_TYPE_AUDIO) { if (attributes->group.audio) gf_free(attributes->group.audio); attributes->group.audio = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(AUDIO, attributes->group.audio); } else if (attributes->type == MEDIA_TYPE_VIDEO) { if (attributes->group.video) gf_free(attributes->group.video); attributes->group.video = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(VIDEO, attributes->group.video); } else if (attributes->type == MEDIA_TYPE_SUBTITLES) { if (attributes->group.subtitle) gf_free(attributes->group.subtitle); attributes->group.subtitle = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(SUBTITLES, attributes->group.subtitle); } else if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS) { if (attributes->group.closed_captions) gf_free(attributes->group.closed_captions); attributes->group.closed_captions = gf_strdup(ret[i]+9); attributes->stream_id = GROUP_ID_TO_PROGRAM_ID(CLOSED_CAPTIONS, attributes->group.closed_captions); } else if (attributes->type == MEDIA_TYPE_UNKNOWN) { GF_LOG(GF_LOG_ERROR, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:GROUP-ID=%s. Ignoring the line.\n"", ret[i]+9)); return NULL; } } else if (safe_start_equals(""LANGUAGE=\"""", ret[i])) { size_t len; if (attributes->language) gf_free(attributes->language); attributes->language = gf_strdup(ret[i]+9); len = strlen(attributes->language); if (len && (attributes->language[len-1] == '""')) { attributes->language[len-1] = '\0'; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Misformed #EXT-X-MEDIA:LANGUAGE=%s. Quotes are incorrect.\n"", ret[i]+5)); } } else if (safe_start_equals(""NAME="", ret[i])) { if (attributes->name) gf_free(attributes->name); attributes->name = gf_strdup(ret[i]+5+1); u32 len = (u32) strlen(attributes->name); if (len) attributes->name[len-1]=0; } else if (safe_start_equals(""DEFAULT="", ret[i])) { if (!strncmp(ret[i]+8, ""YES"", 3)) { attributes->is_default = GF_TRUE; } else if (!strncmp(ret[i]+8, ""NO"", 2)) { attributes->is_default = GF_FALSE; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:DEFAULT=%s\n"", ret[i]+8)); } } else if (safe_start_equals(""AUTOSELECT="", ret[i])) { if (!strncmp(ret[i]+11, ""YES"", 3)) { attributes->is_autoselect = GF_TRUE; } else if (!strncmp(ret[i]+11, ""NO"", 2)) { attributes->is_autoselect = GF_TRUE; } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA:AUTOSELECT=%s\n"", ret[i]+11)); } } else if (safe_start_equals(""CHANNELS="", ret[i])) { sscanf(ret[i] + 9, ""\""%u\"""", &attributes->channels); } else { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Attribute %s not supported\n"", ret[i])); } i++; } if (attributes->type == MEDIA_TYPE_UNKNOWN) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: TYPE is missing. Ignoring the line.\n"")); return NULL; } if (attributes->type == MEDIA_TYPE_CLOSED_CAPTIONS && attributes->mediaURL) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: TYPE is CLOSED-CAPTIONS but URI is present. Ignoring the URI.\n"")); gf_free(attributes->mediaURL); attributes->mediaURL = NULL; } if ((attributes->type == MEDIA_TYPE_AUDIO && !attributes->group.audio) || (attributes->type == MEDIA_TYPE_VIDEO && !attributes->group.video)) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: missing GROUP-ID attribute. Ignoring the line.\n"")); return NULL; } if (!attributes->stream_id) { GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Invalid #EXT-X-MEDIA: no ID was computed. Check previous errors. Ignoring the line.\n"")); return NULL; } return ret; } if (!strncmp(line, ""#EXT-X-INDEPENDENT-SEGMENTS"", strlen(""#EXT-X-INDEPENDENT-SEGMENTS"") )) { attributes->independent_segments = GF_TRUE; M3U8_COMPATIBILITY_VERSION(1); return NULL; } if (!strncmp(line, ""#EXT-X-I-FRAME-STREAM-INF"", strlen(""#EXT-X-I-FRAME-STREAM-INF"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-PART-INF"", strlen(""#EXT-X-PART-INF"") )) { attributes->low_latency = GF_TRUE; return NULL; } if (!strncmp(line, ""#EXT-X-SERVER-CONTROL"", strlen(""#EXT-X-SERVER-CONTROL"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-PRELOAD-HINT"", strlen(""#EXT-X-PRELOAD-HINT"") )) { return NULL; } if (!strncmp(line, ""#EXT-X-RENDITION-REPORT"", strlen(""#EXT-X-RENDITION-REPORT"") )) { return NULL; } GF_LOG(GF_LOG_WARNING, GF_LOG_DASH,(""[M3U8] Unsupported directive %s\n"", line)); return NULL; }"
"int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded) { int channelCount = m_track->f.channelCount; for (int c=0; c<channelCount; c++) { adpcmState state; int predictor = (encoded[0] << 8) | (encoded[1] & 0x80); if (predictor & 0x8000) predictor -= 0x10000; state.previousValue = clamp(predictor, MIN_INT16, MAX_INT16); state.index = encoded[1] & 0x7f; encoded += 2; for (int n=0; n<m_framesPerPacket; n+=2) { uint8_t e = *encoded; decoded[n*channelCount + c] = decodeSample(state, e & 0xf); decoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4); encoded++; } } return m_framesPerPacket * channelCount * sizeof (int16_t); }"
"int xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc, xmlSAXHandlerPtr sax, void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst, int recover) { xmlParserCtxtPtr ctxt; xmlDocPtr newDoc; xmlSAXHandlerPtr oldsax = NULL; xmlNodePtr content, newRoot; int size; int ret = 0; if (depth > 40) { return(XML_ERR_ENTITY_LOOP); } if (lst != NULL) *lst = NULL; if (string == NULL) return(-1); size = xmlStrlen(string); ctxt = xmlCreateMemoryParserCtxt((char *) string, size); if (ctxt == NULL) return(-1); ctxt->userData = ctxt; if (sax != NULL) { oldsax = ctxt->sax; ctxt->sax = sax; if (user_data != NULL) ctxt->userData = user_data; } newDoc = xmlNewDoc(BAD_CAST ""1.0""); if (newDoc == NULL) { xmlFreeParserCtxt(ctxt); return(-1); } newDoc->properties = XML_DOC_INTERNAL; if ((doc != NULL) && (doc->dict != NULL)) { xmlDictFree(ctxt->dict); ctxt->dict = doc->dict; xmlDictReference(ctxt->dict); ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST ""xml"", 3); ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST ""xmlns"", 5); ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36); ctxt->dictNames = 1; } else { xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL); } if (doc != NULL) { newDoc->intSubset = doc->intSubset; newDoc->extSubset = doc->extSubset; } newRoot = xmlNewDocNode(newDoc, NULL, BAD_CAST ""pseudoroot"", NULL); if (newRoot == NULL) { if (sax != NULL) ctxt->sax = oldsax; xmlFreeParserCtxt(ctxt); newDoc->intSubset = NULL; newDoc->extSubset = NULL; xmlFreeDoc(newDoc); return(-1); } xmlAddChild((xmlNodePtr) newDoc, newRoot); nodePush(ctxt, newRoot); if (doc == NULL) { ctxt->myDoc = newDoc; } else { ctxt->myDoc = newDoc; newDoc->children->doc = doc; xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE); newDoc->oldNs = doc->oldNs; } ctxt->instate = XML_PARSER_CONTENT; ctxt->input_id = 2; ctxt->depth = depth; ctxt->validate = 0; ctxt->loadsubset = 0; xmlDetectSAX2(ctxt); if ( doc != NULL ){ content = doc->children; doc->children = NULL; xmlParseContent(ctxt); doc->children = content; } else { xmlParseContent(ctxt); } if ((RAW == '<') && (NXT(1) == '/')) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } else if (RAW != 0) { xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL); } if (ctxt->node != newDoc->children) { xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL); } if (!ctxt->wellFormed) { if (ctxt->errNo == 0) ret = 1; else ret = ctxt->errNo; } else { ret = 0; } if ((lst != NULL) && ((ret == 0) || (recover == 1))) { xmlNodePtr cur; cur = newDoc->children->children; *lst = cur; while (cur != NULL) { xmlSetTreeDoc(cur, doc); cur->parent = NULL; cur = cur->next; } newDoc->children->children = NULL; } if (sax != NULL) ctxt->sax = oldsax; xmlFreeParserCtxt(ctxt); newDoc->intSubset = NULL; newDoc->extSubset = NULL; newDoc->oldNs = NULL; xmlFreeDoc(newDoc); return(ret); }"
"static struct pending_op *pending_ccc_new(struct bt_att *att, struct gatt_db_attribute *attrib, uint16_t value, uint8_t link_type) { struct pending_op *op; struct btd_device *device; device = att_get_device(att); if (!device) { error(""Unable to find device object""); return NULL; } op = new0(struct pending_op, 1); op->data.iov_base = UINT_TO_PTR(value); op->data.iov_len = sizeof(value); op->device = device; op->attrib = attrib; op->link_type = link_type; return op; }"
"void naludmx_create_avc_decoder_config(GF_NALUDmxCtx *ctx, u8 **dsi, u32 *dsi_size, u8 **dsi_enh, u32 *dsi_enh_size, u32 *max_width, u32 *max_height, u32 *max_enh_width, u32 *max_enh_height, GF_Fraction *sar) { u32 i, count; Bool first = GF_TRUE; Bool first_svc = GF_TRUE; GF_AVCConfig *cfg; GF_AVCConfig *avcc; GF_AVCConfig *svcc; u32 max_w, max_h, max_ew, max_eh; max_w = max_h = max_ew = max_eh = 0; sar->num = sar->den = 0; avcc = gf_odf_avc_cfg_new(); svcc = gf_odf_avc_cfg_new(); avcc->nal_unit_size = ctx->nal_length; svcc->nal_unit_size = ctx->nal_length; ctx->is_mvc = GF_FALSE; count = gf_list_count(ctx->sps); for (i=0; i<count; i++) { Bool is_svc = GF_FALSE; GF_NALUFFParam *sl = gf_list_get(ctx->sps, i); AVC_SPS *sps = &ctx->avc_state->sps[sl->id]; u32 nal_type = sl->data[0] & 0x1F; if ((sps->profile_idc == 118) || (sps->profile_idc == 128)) { ctx->is_mvc = GF_TRUE; } if (ctx->explicit) { cfg = svcc; } else if (nal_type == GF_AVC_NALU_SVC_SUBSEQ_PARAM) { cfg = svcc; is_svc = GF_TRUE; } else { cfg = avcc; } if (first || (is_svc && first_svc) ) { cfg->configurationVersion = 1; cfg->profile_compatibility = sps->prof_compat; cfg->AVCProfileIndication = sps->profile_idc; cfg->AVCLevelIndication = sps->level_idc; cfg->chroma_format = sps->chroma_format; cfg->luma_bit_depth = 8 + sps->luma_bit_depth_m8; cfg->chroma_bit_depth = 8 + sps->chroma_bit_depth_m8; if (!gf_avcc_use_extensions(cfg->AVCProfileIndication) && ((cfg->chroma_format>1) || (cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) ) { if ((cfg->luma_bit_depth>8) || (cfg->chroma_bit_depth>8)) { cfg->AVCProfileIndication = 110; } else { cfg->AVCProfileIndication = (cfg->chroma_format==3) ? 244 : 122; } } if (sps->vui_parameters_present_flag && sps->vui.par_num && sps->vui.par_den) { sar->num = sps->vui.par_num; sar->den = sps->vui.par_den; } ctx->interlaced = sps->frame_mbs_only_flag ? GF_FALSE : GF_TRUE; if (first && (!ctx->fps.num || !ctx->fps.den) && sps->vui.timing_info_present_flag && (sps->vui.time_scale <= 1000*sps->vui.num_units_in_tick) ) { u8 DeltaTfiDivisorIdx; if (!sps->vui.pic_struct_present_flag) { DeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag); } else { if (!ctx->avc_state->sei.pic_timing.pic_struct) DeltaTfiDivisorIdx = 2; else if (ctx->avc_state->sei.pic_timing.pic_struct == 8) DeltaTfiDivisorIdx = 6; else DeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2; } if (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) { ctx->cur_fps.num = 2 * sps->vui.time_scale; ctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx; if (!ctx->fps.num && ctx->dts==ctx->fps.den) ctx->dts = ctx->cur_fps.den; } if (! sps->vui.fixed_frame_rate_flag) GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[%s] Possible Variable Frame Rate: VUI \""fixed_frame_rate_flag\"" absent\n"", ctx->log_name)); } ctx->fps = ctx->cur_fps; } first = GF_FALSE; if (is_svc) { first_svc = GF_FALSE; if (sps->width > max_ew) max_ew = sps->width; if (sps->height > max_eh) max_eh = sps->height; } else { if (sps->width > max_w) max_w = sps->width; if (sps->height > max_h) max_h = sps->height; } if (!ctx->analyze) gf_list_add(cfg->sequenceParameterSets, sl); } cfg = ctx->explicit ? svcc : avcc; count = gf_list_count(ctx->sps_ext); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->sps_ext, i); if (!cfg->sequenceParameterSetExtensions) cfg->sequenceParameterSetExtensions = gf_list_new(); if (!ctx->analyze) gf_list_add(cfg->sequenceParameterSetExtensions, sl); } cfg = ctx->explicit ? svcc : avcc; count = gf_list_count(ctx->pps); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps, i); if (!ctx->analyze) gf_list_add(cfg->pictureParameterSets, sl); } cfg = svcc; count = gf_list_count(ctx->pps_svc); for (i=0; i<count; i++) { GF_NALUFFParam *sl = gf_list_get(ctx->pps_svc, i); if (!ctx->analyze) gf_list_add(cfg->pictureParameterSets, sl); } *dsi = *dsi_enh = NULL; *dsi_size = *dsi_enh_size = 0; if (ctx->explicit) { gf_odf_avc_cfg_write(svcc, dsi, dsi_size); } else { gf_odf_avc_cfg_write(avcc, dsi, dsi_size); if (gf_list_count(svcc->sequenceParameterSets) || svcc->sequenceParameterSetExtensions) { gf_odf_avc_cfg_write(svcc, dsi_enh, dsi_enh_size); } } gf_list_reset(avcc->sequenceParameterSets); gf_list_reset(avcc->sequenceParameterSetExtensions); gf_list_reset(avcc->pictureParameterSets); gf_list_reset(svcc->sequenceParameterSets); gf_list_reset(svcc->sequenceParameterSetExtensions); gf_list_reset(svcc->pictureParameterSets); gf_odf_avc_cfg_del(avcc); gf_odf_avc_cfg_del(svcc); *max_width = max_w; *max_height = max_h; *max_enh_width = max_ew; *max_enh_height = max_eh; }"
"inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) { Eigen::IndexList<int, Eigen::type2index<1>> ret; ret.set(0, n); return ret; }"
"static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) { const char *algoname = NULL; unsigned int algolen; buffer* sigbuf = NULL; enum signkey_type keytype = signkey_type_from_signature(sigtype); TRACE((""enter send_msg_userauth_pubkey sigtype %d"", sigtype)) CHECKCLEARTOWRITE(); buf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST); buf_putstring(ses.writepayload, cli_opts.username, strlen(cli_opts.username)); buf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION, SSH_SERVICE_CONNECTION_LEN); buf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY, AUTH_METHOD_PUBKEY_LEN); buf_putbyte(ses.writepayload, realsign); algoname = signature_name_from_type(sigtype, &algolen); buf_putstring(ses.writepayload, algoname, algolen); buf_put_pub_key(ses.writepayload, key, keytype); if (realsign) { TRACE((""realsign"")) sigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len); buf_putbufstring(sigbuf, ses.session_id); buf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len); cli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf); buf_free(sigbuf);  } encrypt_packet(); TRACE((""leave send_msg_userauth_pubkey"")) }"
void tee_user_mem_free(void *buffer) { free(buffer); }
"static int createFromTiffRgba(TIFF * tif, gdImagePtr im) { int a; int x, y; int alphaBlendingFlag = 0; int color; int width = im->sx; int height = im->sy; uint32 *buffer; uint32 rgba; alphaBlendingFlag = im->alphaBlendingFlag; gdImageAlphaBlending(im, 0); buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height); if (!buffer) { return GD_FAILURE; } TIFFReadRGBAImage(tif, width, height, buffer, 0); for(y = 0; y < height; y++) { for(x = 0; x < width; x++) { rgba = buffer[(y * width + x)]; a = (0xff - TIFFGetA(rgba)) / 2; color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a); gdImageSetPixel(im, x, height - y - 1, color); } } gdFree(buffer); gdImageAlphaBlending(im, alphaBlendingFlag); return GD_SUCCESS; }"
"void bm_line(Bitmap *b, int x0, int y0, int x1, int y1) { int dx = x1 - x0; int dy = y1 - y0; int sx, sy; int err, e2; if(dx < 0) dx = -dx; if(dy < 0) dy = -dy; if(x0 < x1) sx = 1; else sx = -1; if(y0 < y1) sy = 1; else sy = -1; err = dx - dy; for(;;) { if(x0 >= b->clip.x0 && x0 < b->clip.x1 && y0 >= b->clip.y0 && y0 < b->clip.y1) BM_SET(b, x0, y0, b->color); if(x0 == x1 && y0 == y1) break; e2 = 2 * err; if(e2 > -dy) { err -= dy; x0 += sx; } if(e2 < dx) { err += dx; y0 += sy; } } }"
"TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node, const TfLiteTensor* axis, const TfLiteTensor* input, int num_splits) { int axis_value = GetTensorData<int>(axis)[0]; if (axis_value < 0) { axis_value += NumDimensions(input); } TF_LITE_ENSURE(context, axis_value >= 0); TF_LITE_ENSURE(context, axis_value < NumDimensions(input)); const int input_size = SizeOfDimension(input, axis_value); TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0, ""Not an even split""); const int slice_size = input_size / num_splits; for (int i = 0; i < NumOutputs(node); ++i) { TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims); output_dims->data[axis_value] = slice_size; TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output)); TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims)); } return kTfLiteOk; }"
"static int tree_add_unmatched(X509_POLICY_LEVEL *curr, const X509_POLICY_CACHE *cache, const ASN1_OBJECT *id, X509_POLICY_NODE *node, X509_POLICY_TREE *tree) { X509_POLICY_DATA *data; if (id == NULL) id = node->data->valid_policy; if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL) return 0; data->qualifier_set = cache->anyPolicy->qualifier_set; data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS; if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) { ossl_policy_data_free(data); return 0; } return 1; }"
"int main(int argc, char **argv) { if (!parse_args(argc, argv)) { usage(argv[0]); } if (bond && discoverable) { fprintf(stderr, ""Can only select either bond or discoverable, not both\n""); usage(argv[0]); } if (sco_listen && sco_connect) { fprintf(stderr, ""Can only select either sco_listen or sco_connect, not both\n""); usage(argv[0]); } if (!bond && !discover && !discoverable && !up && !get_name && !set_name && !sco_listen && !sco_connect) { fprintf(stderr, ""Must specify one command\n""); usage(argv[0]); } if (signal(SIGINT, sig_handler) == SIG_ERR) { fprintf(stderr, ""Will be unable to catch signals\n""); } fprintf(stdout, ""Bringing up bluetooth adapter\n""); if (!hal_open(callbacks_get_adapter_struct())) { fprintf(stderr, ""Unable to open Bluetooth HAL.\n""); return 1; } if (discover) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); fprintf(stdout, ""Starting to start discovery\n""); CALL_AND_WAIT(bt_interface->start_discovery(), discovery_state_changed); fprintf(stdout, ""Started discovery for %d seconds\n"", timeout_in_sec); sleep(timeout_in_sec); fprintf(stdout, ""Starting to cancel discovery\n""); CALL_AND_WAIT(bt_interface->cancel_discovery(), discovery_state_changed); fprintf(stdout, ""Cancelled discovery after %d seconds\n"", timeout_in_sec); } if (discoverable) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE); int rc = bt_interface->set_adapter_property(property); fprintf(stdout, ""Set rc:%d device as discoverable for %d seconds\n"", rc, timeout_in_sec); sleep(timeout_in_sec); property_free(property); } if (bond) { if (bdaddr_is_empty(&bt_remote_bdaddr)) { fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n""); exit(1); } CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); int rc = bt_interface->create_bond(&bt_remote_bdaddr, 0 ); fprintf(stdout, ""Started bonding:%d for %d seconds\n"", rc, timeout_in_sec); sleep(timeout_in_sec); } if (up) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); fprintf(stdout, ""Waiting for %d seconds\n"", timeout_in_sec); sleep(timeout_in_sec); } if (get_name) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); int error; CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to get adapter property\n""); exit(1); } bt_property_t *property = adapter_get_property(BT_PROPERTY_BDNAME); const bt_bdname_t *name = property_as_name(property); if (name) printf(""Queried bluetooth device name:%s\n"", name->name); else printf(""No name\n""); } if (set_name) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); bt_property_t *property = property_new_name(bd_name); printf(""Setting bluetooth device name to:%s\n"", bd_name); int error; CALL_AND_WAIT(error = bt_interface->set_adapter_property(property), adapter_properties); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to set adapter property\n""); exit(1); } CALL_AND_WAIT(error = bt_interface->get_adapter_property(BT_PROPERTY_BDNAME), adapter_properties); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to get adapter property\n""); exit(1); } property_free(property); sleep(timeout_in_sec); } if (sco_listen) { CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); bt_property_t *property = property_new_scan_mode(BT_SCAN_MODE_CONNECTABLE_DISCOVERABLE); CALL_AND_WAIT(bt_interface->set_adapter_property(property), adapter_properties); property_free(property); const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID); int rfcomm_fd = INVALID_FD; int error = sock->listen(BTSOCK_RFCOMM, ""meow"", (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to listen for incoming RFCOMM socket: %d\n"", error); exit(1); } int sock_fd = INVALID_FD; error = sock->listen(BTSOCK_SCO, NULL, NULL, 5, &sock_fd, 0); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to listen for incoming SCO sockets: %d\n"", error); exit(1); } fprintf(stdout, ""Waiting for incoming SCO connections...\n""); sleep(timeout_in_sec); } if (sco_connect) { if (bdaddr_is_empty(&bt_remote_bdaddr)) { fprintf(stderr, ""Must specify a remote device address [ --bdaddr=xx:yy:zz:aa:bb:cc ]\n""); exit(1); } CALL_AND_WAIT(bt_interface->enable(), adapter_state_changed); fprintf(stdout, ""BT adapter is up\n""); const btsock_interface_t *sock = bt_interface->get_profile_interface(BT_PROFILE_SOCKETS_ID); int rfcomm_fd = INVALID_FD; int error = sock->connect(&bt_remote_bdaddr, BTSOCK_RFCOMM, (const uint8_t *)&HFP_AG_UUID, 0, &rfcomm_fd, 0); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to connect to RFCOMM socket: %d.\n"", error); exit(1); } WAIT(acl_state_changed); fprintf(stdout, ""Establishing SCO connection...\n""); int sock_fd = INVALID_FD; error = sock->connect(&bt_remote_bdaddr, BTSOCK_SCO, NULL, 5, &sock_fd, 0); if (error != BT_STATUS_SUCCESS) { fprintf(stderr, ""Unable to connect to SCO socket: %d.\n"", error); exit(1); } sleep(timeout_in_sec); } CALL_AND_WAIT(bt_interface->disable(), adapter_state_changed); fprintf(stdout, ""BT adapter is down\n""); }"
"static void dump_relocs_in_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED) { arelent **relpp; long relcount; long relsize; if (   bfd_is_abs_section (section) || bfd_is_und_section (section) || bfd_is_com_section (section) || (! process_section_p (section)) || ((section->flags & SEC_RELOC) == 0)) return; relsize = bfd_get_reloc_upper_bound (abfd, section); if (relsize < 0) bfd_fatal (bfd_get_filename (abfd)); printf (""RELOCATION RECORDS FOR [%s]:"", section->name); if (relsize == 0) { printf ("" (none)\n\n""); return; } if ((bfd_get_file_flags (abfd) & (BFD_IN_MEMORY | BFD_LINKER_CREATED)) == 0 && (ufile_ptr) relsize > bfd_get_file_size (abfd)) { printf ("" (too many: 0x%x)\n"", section->reloc_count); bfd_set_error (bfd_error_file_truncated); bfd_fatal (bfd_get_filename (abfd)); } relpp = (arelent **) xmalloc (relsize); relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms); if (relcount < 0) { printf (""\n""); non_fatal (_(""failed to read relocs in: %s""), bfd_get_filename (abfd)); bfd_fatal (_(""error message was"")); } else if (relcount == 0) printf ("" (none)\n\n""); else { printf (""\n""); dump_reloc_set (abfd, section, relpp, relcount); printf (""\n\n""); } free (relpp); }"
"static int acp_hw_init(void *handle) { int r, i; uint64_t acp_base; u32 val = 0; u32 count = 0; struct device *dev; struct i2s_platform_data *i2s_pdata; struct amdgpu_device *adev = (struct amdgpu_device *)handle; const struct amdgpu_ip_block *ip_block = amdgpu_device_ip_get_ip_block(adev, AMD_IP_BLOCK_TYPE_ACP); if (!ip_block) return -EINVAL; r = amd_acp_hw_init(adev->acp.cgs_device, ip_block->version->major, ip_block->version->minor); if (r == -ENODEV) { amdgpu_dpm_set_powergating_by_smu(adev, AMD_IP_BLOCK_TYPE_ACP, true); return 0; } else if (r) { return r; } if (adev->rmmio_size == 0 || adev->rmmio_size < 0x5289) return -EINVAL; acp_base = adev->rmmio_base; adev->acp.acp_genpd = kzalloc(sizeof(struct acp_pm_domain), GFP_KERNEL); if (adev->acp.acp_genpd == NULL) return -ENOMEM; adev->acp.acp_genpd->gpd.name = ""ACP_AUDIO""; adev->acp.acp_genpd->gpd.power_off = acp_poweroff; adev->acp.acp_genpd->gpd.power_on = acp_poweron; adev->acp.acp_genpd->adev = adev; pm_genpd_init(&adev->acp.acp_genpd->gpd, NULL, false); adev->acp.acp_cell = kcalloc(ACP_DEVS, sizeof(struct mfd_cell), GFP_KERNEL); if (adev->acp.acp_cell == NULL) return -ENOMEM; adev->acp.acp_res = kcalloc(5, sizeof(struct resource), GFP_KERNEL); if (adev->acp.acp_res == NULL) { kfree(adev->acp.acp_cell); return -ENOMEM; } i2s_pdata = kcalloc(3, sizeof(struct i2s_platform_data), GFP_KERNEL); if (i2s_pdata == NULL) { kfree(adev->acp.acp_res); kfree(adev->acp.acp_cell); return -ENOMEM; } switch (adev->asic_type) { case CHIP_STONEY: i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE; break; default: i2s_pdata[0].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET; } i2s_pdata[0].cap = DWC_I2S_PLAY; i2s_pdata[0].snd_rates = SNDRV_PCM_RATE_8000_96000; i2s_pdata[0].i2s_reg_comp1 = ACP_I2S_COMP1_PLAY_REG_OFFSET; i2s_pdata[0].i2s_reg_comp2 = ACP_I2S_COMP2_PLAY_REG_OFFSET; switch (adev->asic_type) { case CHIP_STONEY: i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1 | DW_I2S_QUIRK_16BIT_IDX_OVERRIDE; break; default: i2s_pdata[1].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET | DW_I2S_QUIRK_COMP_PARAM1; } i2s_pdata[1].cap = DWC_I2S_RECORD; i2s_pdata[1].snd_rates = SNDRV_PCM_RATE_8000_96000; i2s_pdata[1].i2s_reg_comp1 = ACP_I2S_COMP1_CAP_REG_OFFSET; i2s_pdata[1].i2s_reg_comp2 = ACP_I2S_COMP2_CAP_REG_OFFSET; i2s_pdata[2].quirks = DW_I2S_QUIRK_COMP_REG_OFFSET; switch (adev->asic_type) { case CHIP_STONEY: i2s_pdata[2].quirks |= DW_I2S_QUIRK_16BIT_IDX_OVERRIDE; break; default: break; } i2s_pdata[2].cap = DWC_I2S_PLAY | DWC_I2S_RECORD; i2s_pdata[2].snd_rates = SNDRV_PCM_RATE_8000_96000; i2s_pdata[2].i2s_reg_comp1 = ACP_BT_COMP1_REG_OFFSET; i2s_pdata[2].i2s_reg_comp2 = ACP_BT_COMP2_REG_OFFSET; adev->acp.acp_res[0].name = ""acp2x_dma""; adev->acp.acp_res[0].flags = IORESOURCE_MEM; adev->acp.acp_res[0].start = acp_base; adev->acp.acp_res[0].end = acp_base + ACP_DMA_REGS_END; adev->acp.acp_res[1].name = ""acp2x_dw_i2s_play""; adev->acp.acp_res[1].flags = IORESOURCE_MEM; adev->acp.acp_res[1].start = acp_base + ACP_I2S_PLAY_REGS_START; adev->acp.acp_res[1].end = acp_base + ACP_I2S_PLAY_REGS_END; adev->acp.acp_res[2].name = ""acp2x_dw_i2s_cap""; adev->acp.acp_res[2].flags = IORESOURCE_MEM; adev->acp.acp_res[2].start = acp_base + ACP_I2S_CAP_REGS_START; adev->acp.acp_res[2].end = acp_base + ACP_I2S_CAP_REGS_END; adev->acp.acp_res[3].name = ""acp2x_dw_bt_i2s_play_cap""; adev->acp.acp_res[3].flags = IORESOURCE_MEM; adev->acp.acp_res[3].start = acp_base + ACP_BT_PLAY_REGS_START; adev->acp.acp_res[3].end = acp_base + ACP_BT_PLAY_REGS_END; adev->acp.acp_res[4].name = ""acp2x_dma_irq""; adev->acp.acp_res[4].flags = IORESOURCE_IRQ; adev->acp.acp_res[4].start = amdgpu_irq_create_mapping(adev, 162); adev->acp.acp_res[4].end = adev->acp.acp_res[4].start; adev->acp.acp_cell[0].name = ""acp_audio_dma""; adev->acp.acp_cell[0].num_resources = 5; adev->acp.acp_cell[0].resources = &adev->acp.acp_res[0]; adev->acp.acp_cell[0].platform_data = &adev->asic_type; adev->acp.acp_cell[0].pdata_size = sizeof(adev->asic_type); adev->acp.acp_cell[1].name = ""designware-i2s""; adev->acp.acp_cell[1].num_resources = 1; adev->acp.acp_cell[1].resources = &adev->acp.acp_res[1]; adev->acp.acp_cell[1].platform_data = &i2s_pdata[0]; adev->acp.acp_cell[1].pdata_size = sizeof(struct i2s_platform_data); adev->acp.acp_cell[2].name = ""designware-i2s""; adev->acp.acp_cell[2].num_resources = 1; adev->acp.acp_cell[2].resources = &adev->acp.acp_res[2]; adev->acp.acp_cell[2].platform_data = &i2s_pdata[1]; adev->acp.acp_cell[2].pdata_size = sizeof(struct i2s_platform_data); adev->acp.acp_cell[3].name = ""designware-i2s""; adev->acp.acp_cell[3].num_resources = 1; adev->acp.acp_cell[3].resources = &adev->acp.acp_res[3]; adev->acp.acp_cell[3].platform_data = &i2s_pdata[2]; adev->acp.acp_cell[3].pdata_size = sizeof(struct i2s_platform_data); r = mfd_add_hotplug_devices(adev->acp.parent, adev->acp.acp_cell, ACP_DEVS); if (r) return r; for (i = 0; i < ACP_DEVS ; i++) { dev = get_mfd_cell_dev(adev->acp.acp_cell[i].name, i); r = pm_genpd_add_device(&adev->acp.acp_genpd->gpd, dev); if (r) { dev_err(dev, ""Failed to add dev to genpd\n""); return r; } } val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET); val |= ACP_SOFT_RESET__SoftResetAud_MASK; cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val); count = ACP_SOFT_RESET_DONE_TIME_OUT_VALUE; while (true) { val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET); if (ACP_SOFT_RESET__SoftResetAudDone_MASK == (val & ACP_SOFT_RESET__SoftResetAudDone_MASK)) break; if (--count == 0) { dev_err(&adev->pdev->dev, ""Failed to reset ACP\n""); return -ETIMEDOUT; } udelay(100); } val = cgs_read_register(adev->acp.cgs_device, mmACP_CONTROL); val = val | ACP_CONTROL__ClkEn_MASK; cgs_write_register(adev->acp.cgs_device, mmACP_CONTROL, val); count = ACP_CLOCK_EN_TIME_OUT_VALUE; while (true) { val = cgs_read_register(adev->acp.cgs_device, mmACP_STATUS); if (val & (u32) 0x1) break; if (--count == 0) { dev_err(&adev->pdev->dev, ""Failed to reset ACP\n""); return -ETIMEDOUT; } udelay(100); } val = cgs_read_register(adev->acp.cgs_device, mmACP_SOFT_RESET); val &= ~ACP_SOFT_RESET__SoftResetAud_MASK; cgs_write_register(adev->acp.cgs_device, mmACP_SOFT_RESET, val); return 0; }"
"static guint append_header (GString *string, const gchar *name, const gchar *value) { if (value) { g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0); g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0); g_string_append_printf (string, ""%s: %s\r\n"", name, value); } if (g_ascii_strcasecmp (""Content-Type"", name) == 0) return HEADER_CONTENT_TYPE; if (g_ascii_strcasecmp (""Cache-Control"", name) == 0) return HEADER_CACHE_CONTROL; if (g_ascii_strcasecmp (""Vary"", name) == 0) return HEADER_VARY; if (g_ascii_strcasecmp (""Content-Encoding"", name) == 0) return HEADER_CONTENT_ENCODING; if (g_ascii_strcasecmp (""X-DNS-Prefetch-Control"", name) == 0) return HEADER_DNS_PREFETCH_CONTROL; if (g_ascii_strcasecmp (""Referrer-Policy"", name) == 0) return HEADER_REFERRER_POLICY; if (g_ascii_strcasecmp (""X-Content-Type-Options"", name) == 0) return HEADER_CONTENT_TYPE_OPTIONS; if (g_ascii_strcasecmp (""Cross-Origin-Resource-Policy"", name) == 0) return HEADER_CROSS_ORIGIN_RESOURCE_POLICY; if (g_ascii_strcasecmp (""Content-Length"", name) == 0 || g_ascii_strcasecmp (""Transfer-Encoding"", name) == 0 || g_ascii_strcasecmp (""Connection"", name) == 0) { g_critical (""Don't set %s header manually. This is a programmer error."", name); } return 0; }"
"void proto_register_tipc(void) { static hf_register_info hf[] = { { &hf_tipc_msg_fragments, { ""Message fragments"", ""tipc.msg.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment, { ""Message fragment"", ""tipc.msg.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment_overlap, { ""Message fragment overlap"", ""tipc.msg.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_overlap_conflicts, { ""Message fragment overlapping with conflicting data"", ""tipc.msg.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_multiple_tails, { ""Message has multiple tail fragments"", ""tipc.msg.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_too_long_fragment, { ""Message fragment too long"", ""tipc.msg.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_fragment_error, { ""Message defragmentation error"", ""tipc.msg.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_fragment_count, { ""Message fragment count"", ""tipc.msg.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_reassembled_in, { ""Reassembled in"", ""tipc.msg.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_msg_reassembled_length, { ""Reassembled TIPC length"", ""tipc.msg.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_tipc_ver, { ""Version"", ""tipc.ver"", FT_UINT32, BASE_DEC, NULL, 0xe0000000, ""TIPC protocol version"", HFILL } }, { &hf_tipc_usr, { ""User"", ""tipc.usr"", FT_UINT32, BASE_DEC, VALS(tipc_user_values), 0x1e000000, ""TIPC User"", HFILL } }, { &hf_tipcv2_usr, { ""User"", ""tipc.usr"", FT_UINT32, BASE_DEC, VALS(tipcv2_user_values), 0x1e000000, ""TIPC User"", HFILL } }, { &hf_tipc_hdr_size, { ""Header size"", ""tipc.hdr_size"", FT_UINT32, BASE_DEC, NULL, 0x01e00000, ""TIPC Header size"", HFILL } }, { &hf_tipc_nonsequenced, { ""Non-sequenced"", ""tipc.non_sequenced"", FT_UINT32, BASE_DEC, NULL, 0x00100000, ""Non-sequenced Bit"", HFILL } }, { &hf_tipc_destdrop, { ""Destination Droppable"", ""tipc.destdrop"", FT_UINT32, BASE_DEC, NULL, 0x00080000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipc_unused, { ""Unused"", ""tipc.hdr_unused"", FT_UINT32, BASE_DEC, NULL, 0x000e0000, ""TIPC Unused"", HFILL } }, { &hf_tipc_msg_size, { ""Message size"", ""tipc.msg_size"", FT_UINT32, BASE_DEC, NULL, 0x0001ffff, ""TIPC Message size"", HFILL } }, { &hf_tipc_ack_link_lev_seq, { ""Acknowledged link level sequence number"", ""tipc.ack_link_lev_seq"", FT_UINT32, BASE_DEC, NULL, 0xffff0000, ""TIPC Acknowledged link level sequence number"", HFILL } }, { &hf_tipc_link_lev_seq, { ""Link level sequence number"", ""tipc.link_lev_seq"", FT_UINT32, BASE_DEC, NULL, 0x0000ffff, ""TIPC Link level sequence number"", HFILL } }, { &hf_tipc_prev_proc, { ""Previous processor"", ""tipc.prev_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Previous processor"", HFILL } }, { &hf_tipc_org_port, { ""Originating port"", ""tipc.org_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Originating port"", HFILL } }, { &hf_tipc_dst_port, { ""Destination port"", ""tipc.dst_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Destination port"", HFILL } }, { &hf_tipc_data_msg_type, { ""Message type"", ""tipc.msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_err_code, { ""Error code"", ""tipc.err_code"", FT_UINT32, BASE_DEC, VALS(tipc_error_code_values), 0x0f000000, ""TIPC Error code"", HFILL } }, { &hf_tipc_reroute_cnt, { ""Reroute counter"", ""tipc.route_cnt"", FT_UINT32, BASE_DEC, NULL, 0x00f00000, ""TIPC Reroute counter"", HFILL } }, { &hf_tipc_act_id, { ""Activity identity"", ""tipc.act_id"", FT_UINT32, BASE_DEC, NULL, 0x000fffff, ""TIPC Activity identity"", HFILL } }, { &hf_tipc_org_proc, { ""Originating processor"", ""tipc.org_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Originating processor"", HFILL } }, { &hf_tipc_dst_proc, { ""Destination processor"", ""tipc.dst_proc"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Destination processor"", HFILL } }, { &hf_tipc_unused2, { ""Unused"", ""tipc.unused2"", FT_UINT32, BASE_DEC, NULL, 0xe0000000, ""TIPC Unused"", HFILL } }, { &hf_tipc_importance, { ""Importance"", ""tipc.importance"", FT_UINT32, BASE_DEC, NULL, 0x18000000, ""TIPC Importance"", HFILL } }, { &hf_tipc_link_selector, { ""Link selector"", ""tipc.link_selector"", FT_UINT32, BASE_DEC, NULL, 0x07000000, ""TIPC Link selector"", HFILL } }, { &hf_tipc_msg_cnt, { ""Message count"", ""tipc.imsg_cnt"", FT_UINT32, BASE_DEC, NULL, 0x00ffff00, ""TIPC Message count"", HFILL } }, { &hf_tipc_probe, { ""Probe"", ""tipc.probe"", FT_UINT32, BASE_DEC, NULL, 0x00000040, ""TIPC Probe"", HFILL } }, { &hf_tipc_bearer_id, { ""Bearer identity"", ""tipc.bearer_id"", FT_UINT32, BASE_DEC, NULL, 0x00000038, ""TIPC Bearer identity"", HFILL } }, { &hf_tipc_link_selector2, { ""Link selector"", ""tipc.link_selector"", FT_UINT32, BASE_DEC, NULL, 0x00000007, ""TIPC Link selector"", HFILL } }, { &hf_tipc_remote_addr, { ""Remote address"", ""tipc.remote_addr"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Remote address"", HFILL } }, { &hf_tipc_rm_msg_type, { ""Message type"", ""tipc.rm_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_routing_mgr_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_nd_msg_type, { ""Message type"", ""tipc.nd_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_name_dist_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_cm_msg_type, { ""Message type"", ""tipc.nd_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_cm_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_lp_msg_type, { ""Message type"", ""tipc.lp_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_link_prot_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_cng_prot_msg_type, { ""Message type"", ""tipc.cng_prot_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_cng_prot_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_sm_msg_type, { ""Message type"", ""tipc.sm_msg_type"", FT_UINT32, BASE_DEC, VALS(tipc_sm_msg_type_values), 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_unknown_msg_type, { ""Message type"", ""tipc.unknown_msg_type"", FT_UINT32, BASE_DEC, NULL, 0xf0000000, ""TIPC Message type"", HFILL } }, { &hf_tipc_seq_gap, { ""Sequence gap"", ""tipc.seq_gap"", FT_UINT32, BASE_DEC, NULL, 0x1fff0000, ""TIPC Sequence gap"", HFILL } }, { &hf_tipc_nxt_snt_pkg, { ""Next sent packet"", ""tipc.nxt_snt_pkg"", FT_UINT32, BASE_DEC, NULL, 0x0000ffff, ""TIPC Next sent packet"", HFILL } }, { &hf_tipc_unused_word, { ""Word Unused"", ""tipc.unused_word"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_bearer_name, { ""Bearer name"", ""tipc.bearer_name"", FT_STRINGZ, BASE_NONE, NULL, 0x0, ""TIPC Bearer name"", HFILL } }, { &hf_tipc_data, { ""Data"", ""tipc.data"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_msg_no_bundle, { ""Message no. in bundle"", ""tipc.msg_no_bundle"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_changeover_protocol, { ""TIPC_CHANGEOVER_PROTOCOL"", ""tipc.changeover_protocol"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_name_dist_type, { ""Published port name type"", ""tipc.name_dist_type"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Published port name type"", HFILL } }, { &hf_tipc_name_dist_lower, { ""Lower bound of published sequence"", ""tipc.name_dist_lower"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Lower bound of published sequence"", HFILL } }, { &hf_tipc_name_dist_upper, { ""Upper bound of published sequence"", ""tipc.name_dist_upper"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Upper bound of published sequence"", HFILL } }, { &hf_tipc_name_dist_port, { ""Random number part of port identity"", ""tipc.dist_port"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC Random number part of port identity"", HFILL } }, { &hf_tipc_name_dist_key, { ""Key (Use for verification at withdrawal)"", ""tipc.dist_key"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""TIPC key"", HFILL } }, { &hf_tipcv2_srcdrop, { ""Source Droppable"", ""tipc.srcdrop"", FT_UINT32, BASE_DEC, NULL, 0x00040000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipcv2_syn, { ""Connection request (SYN)"", ""tipc.syn"", FT_UINT32, BASE_DEC, NULL, 0x00020000, ""Destination Droppable Bit"", HFILL } }, { &hf_tipcv2_data_msg_type, { ""Message type"", ""tipc.data_type"", FT_UINT32, BASE_DEC, VALS(tipc_data_msg_type_values), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_bcast_mtype, { ""Message type"", ""tipcv2.bcast_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_bcast_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_bundler_mtype, { ""Message type"", ""tipcv2.bundler_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_bundler_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_link_mtype, { ""Message type"", ""tipcv2.link_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_link_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_connmgr_mtype, { ""Message type"", ""tipcv2.connmgr_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_connmgr_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_route_mtype_1_6, { ""Message type"", ""tipcv2.route_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_6), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_route_mtype_1_7, { ""Message type"", ""tipcv2.route_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_route_mtype_strings_1_7), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_changeover_mtype, { ""Message type"", ""tipcv2.changeover_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_changeover_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_naming_mtype, { ""Message type"", ""tipcv2.naming_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_naming_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_fragmenter_mtype, { ""Message type"", ""tipcv2.fragmenter_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_fragmenter_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_neighbour_mtype, { ""Message type"", ""tipcv2.data_msg_type"", FT_UINT32, BASE_DEC, VALS(tipcv2_neighbour_mtype_strings), 0xe0000000, ""TIPC Message type"", HFILL } }, { &hf_tipcv2_errorcode, { ""Error code"", ""tipcv2.errorcode"", FT_UINT32, BASE_DEC, VALS(tipcv2_error_code_strings), 0x1e000000, NULL, HFILL } }, { &hf_tipcv2_rer_cnt, { ""Reroute Counter"", ""tipcv2.rer_cnt"", FT_UINT32, BASE_DEC, NULL, 0x01e00000, NULL, HFILL } }, { &hf_tipcv2_lookup_scope, { ""Lookup Scope"", ""tipcv2.lookup_scope"", FT_UINT32, BASE_DEC, VALS(tipcv2_lookup_scope_strings), 0x00180000, NULL, HFILL } }, { &hf_tipcv2_opt_p, { ""Options Position"", ""tipcv2.opt_p"", FT_UINT32, BASE_DEC, NULL, 0x00070000, NULL, HFILL } }, { &hf_tipcv2_broadcast_ack_no, { ""Broadcast Acknowledge Number"", ""tipcv2.broadcast_ack_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_link_level_ack_no, { ""Link Level Acknowledge Number"", ""tipcv2.link_level_ack_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_link_level_seq_no, { ""Link Level Sequence Number"", ""tipcv2.link_level_seq_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, #if 0 { &hf_tipcv2_bcast_seq_no, { ""Broadcast Sequence Number"", ""tipcv2.bcast_seq_no"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, #endif { &hf_tipcv2_prev_node, { ""Previous Node"", ""tipcv2.prev_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Previous Node"", HFILL } }, { &hf_tipcv2_orig_node, { ""Originating Node"", ""tipcv2.orig_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Originating Node"", HFILL } }, { &hf_tipcv2_dest_node, { ""Destination Node"", ""tipcv2.dest_node"", FT_STRING, BASE_NONE, NULL, 0x0, ""TIPC Destination Node"", HFILL } }, { &hf_tipcv2_port_name_type, { ""Port name type"", ""tipcv2.port_name_type"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, NULL, HFILL } }, { &hf_tipcv2_port_name_instance, { ""Port name instance"", ""tipcv2.port_name_instance"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, NULL, HFILL } }, { &hf_tipcv2_multicast_lower, { ""Multicast lower bound"", ""tipcv2.multicast_lower"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""Multicast port name instance lower bound"", HFILL } }, { &hf_tipcv2_multicast_upper, { ""Multicast upper bound"", ""tipcv2.multicast_upper"", FT_UINT32, BASE_DEC, NULL, 0xffffffff, ""Multicast port name instance upper bound"", HFILL } }, { &hf_tipcv2_sequence_gap, { ""Sequence Gap"", ""tipcv2.seq_gap"", FT_UINT32, BASE_DEC, NULL, 0x1FFF0000, NULL, HFILL } }, { &hf_tipcv2_next_sent_broadcast, { ""Next Sent Broadcast"", ""tipcv2.next_sent_broadcast"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_fragment_number, { ""Fragment Number"", ""tipcv2.fragment_number"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_fragment_msg_number, { ""Fragment Message Number"", ""tipcv2.fragment_msg_number"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_next_sent_packet, { ""Next Sent Packet"", ""tipcv2.next_sent_packet"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_session_no, { ""Session Number"", ""tipcv2.session_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_link_prio, { ""Link Priority"", ""tipcv2.link_prio"", FT_UINT32, BASE_DEC, NULL, 0x000001F0, NULL, HFILL } }, { &hf_tipcv2_network_plane, { ""Network Plane"", ""tipcv2.network_plane"", FT_UINT32, BASE_DEC, VALS(tipcv2_networkplane_strings), 0x0000000E, NULL, HFILL } }, { &hf_tipcv2_probe, { ""Probe"", ""tipcv2.probe"", FT_UINT32, BASE_DEC, NULL, 0x00000001, NULL, HFILL } }, { &hf_tipcv2_link_tolerance, { ""Link Tolerance (ms)"", ""tipcv2.link_tolerance"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, ""Link Tolerance in ms"", HFILL } }, { &hf_tipcv2_bearer_instance, { ""Bearer Instance"", ""tipcv2.bearer_instance"", FT_STRINGZ, BASE_NONE, NULL, 0, ""Bearer instance used by the sender node for this link"", HFILL } }, { &hf_tipcv2_padding, { ""Padding"", ""tipcv2.padding"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_bearer_level_orig_addr, { ""Bearer Level Originating Address"", ""tipcv2.bearer_level_orig_addr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_cluster_address, { ""Cluster Address"", ""tipcv2.cluster_address"", FT_STRING, BASE_NONE, NULL, 0x0, ""The remote cluster concerned by the table"", HFILL } }, { &hf_tipcv2_bitmap, { ""Bitmap"", ""tipcv2.bitmap"", FT_BYTES, BASE_NONE, NULL, 0, ""Bitmap, indicating to which nodes within that cluster the sending node has direct links"", HFILL } }, { &hf_tipcv2_node_address, { ""Node Address"", ""tipcv2.node_address"", FT_STRING, BASE_NONE, NULL, 0x0, ""Which node the route addition/loss concern"", HFILL } }, { &hf_tipcv2_destination_domain, { ""Destination Domain"", ""tipcv2.destination_domain"", FT_STRING, BASE_NONE, NULL, 0x0, ""The domain to which the link request is directed"", HFILL } }, { &hf_tipcv2_network_id, { ""Network Identity"", ""tipcv2.network_id"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""The sender node's network identity"", HFILL } }, { &hf_tipcv2_bcast_tag, { ""Broadcast Tag"", ""tipcv2.bcast_tag"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_msg_count, { ""Message Count"", ""tipcv2.msg_count"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_max_packet, { ""Max Packet"", ""tipcv2.max_packet"", FT_UINT32, BASE_DEC, NULL, 0xFFFF0000, NULL, HFILL } }, { &hf_tipcv2_transport_seq_no, { ""Transport Sequence No"", ""tipcv2.tseq_no"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""Transport Level Sequence Number"", HFILL } }, { &hf_tipcv2_redundant_link, { ""Redundant Link"", ""tipcv2.redundant_link"", FT_UINT32, BASE_DEC, NULL, 0x00001000, NULL, HFILL } }, { &hf_tipcv2_bearer_id, { ""Bearer identity"", ""tipcv2.bearer_id"", FT_UINT32, BASE_DEC, NULL, 0x00000e00, NULL, HFILL } }, { &hf_tipcv2_conn_mgr_msg_ack,  { ""Number of Messages Acknowledged"", ""tipcv2.conn_mgr_msg_ack"", FT_UINT32, BASE_DEC, NULL, 0xffff0000, NULL, HFILL } }, { &hf_tipcv2_minor_pv, { ""Minor protocol version"", ""tipcv2.minor_pv"", FT_UINT32, BASE_DEC, NULL, 0x00ff0000, NULL, HFILL } }, { &hf_tipcv2_node_sig, { ""Node signature"", ""tipcv2.node_sig"", FT_UINT32, BASE_DEC, NULL, 0x0000FFFF, NULL, HFILL } }, { &hf_tipcv2_filler_mtu_discovery, { ""Filler for MTU discovery"", ""tipcv2.filler_mtu_discovery"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_vendor_specific_data, { ""Vendor specific data"", ""tipcv2.vendor_specific_data"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_options, { ""Options"", ""tipcv2.options"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_named_msg_hdr, { ""TIPC_NAMED_MSG Hdr"", ""tipc.named_msg_hdr"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_port_name_type, { ""Port name type / Connection level sequence number"", ""tipc.port_name_type"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_port_name_instance, { ""Port name instance"", ""tipc.port_name_instance"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_tipc_data_fragment, { ""Data fragment"", ""tipc.data_fragment"", FT_BYTES, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipc_message_bundle, { ""Message Bundle"", ""tipc.message_bundle"", FT_NONE, BASE_NONE, NULL, 0, NULL, HFILL } }, { &hf_tipcv2_timestamp, { ""Timestamp"", ""tipcv2.timestamp"", FT_UINT32, BASE_DEC, NULL, 0xFFFFFFFF, ""OS-dependent Timestamp"", HFILL } }, { &hf_tipcv2_item_size, { ""Item Size"", ""tipcv2.item_size"", FT_UINT32, BASE_DEC, NULL, 0xFF000000, NULL, HFILL } }, { &hf_tipcv2_network_region, { ""Network Region"", ""tipcv2.network_region"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_local_router, { ""Local Router"", ""tipcv2.local_router"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_remote_router, { ""Remote Router"", ""tipcv2.remote_router"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_dist_dist, { ""Route Distributor Dist"", ""tipcv2.dist_dist"", FT_UINT32, BASE_DEC, VALS(tipcv2_dist_dist_strings), 0x000000f0, NULL, HFILL } }, { &hf_tipcv2_dist_scope, { ""Route Distributor Scope"", ""tipcv2.dist_scope"", FT_UINT32, BASE_DEC, VALS(tipcv2_dist_scope_strings), 0x0000000f, NULL, HFILL } }, { &hf_tipcv2_name_dist_port_id_node, { ""Port Id Node"", ""tipcv2.port_id_node"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tipcv2_media_id, { ""Media Id"", ""tipcv2.media_id"", FT_UINT32, BASE_DEC, NULL, 0x000000ff, NULL, HFILL } } }; static gint *ett[] = { &ett_tipc, &ett_tipc_data, &ett_tipc_msg_fragment, &ett_tipc_msg_fragments }; static ei_register_info ei[] = { { &ei_tipc_field_not_specified, { ""tipc.field_not_specified"", PI_PROTOCOL, PI_WARN, ""This field is not specified in TIPC v7"", EXPFILL }}, { &ei_tipc_invalid_bundle_size, { ""tipc.invalid_bundle_size"", PI_PROTOCOL, PI_WARN, ""Invalid message bundle size"", EXPFILL }}, }; module_t *tipc_module; expert_module_t* expert_tipc; static const enum_val_t handle_v2_as_options[] = { { ""all"",          ""ALL"",          V2_AS_ALL }, { ""tipc l.5/1.6"", ""TIPC 1.5/1.6"", V2_AS_1_6 }, { ""tipc 1.7"",     ""TIPC 1.7"",     V2_AS_1_7 }, { NULL,           NULL,           0 } }; proto_tipc = proto_register_protocol(""Transparent Inter Process Communication(TIPC)"", ""TIPC"", ""tipc""); proto_register_field_array(proto_tipc, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); expert_tipc = expert_register_protocol(proto_tipc); expert_register_field_array(expert_tipc, ei, array_length(ei)); tipc_user_dissector = register_dissector_table(""tipc.usr"", ""TIPC user"", proto_tipc, FT_UINT8, BASE_DEC); tipc_type_dissector = register_dissector_table(""tipcv2.port_name_type"", ""TIPC port name type"", proto_tipc, FT_UINT32, BASE_DEC); tipc_heur_subdissector_list = register_heur_dissector_list(""tipc"", proto_tipc); tipc_handle = register_dissector(""tipc"", dissect_tipc, proto_tipc); reassembly_table_register(&tipc_msg_reassembly_table, &addresses_reassembly_table_functions); tipc_module = prefs_register_protocol(proto_tipc, NULL); tipc_address_type = address_type_dissector_register(""AT_TIPC"", ""TIPC Address Zone,Subnetwork,Processor"", tipc_addr_to_str_buf, tipc_addr_str_len, NULL, NULL, NULL, NULL, NULL); prefs_register_bool_preference(tipc_module, ""defragment"", ""Reassemble TIPCv1 SEGMENTATION_MANAGER datagrams"", ""Whether TIPCv1 SEGMENTATION_MANAGER datagrams should be reassembled"", &tipc_defragment); prefs_register_bool_preference(tipc_module, ""dissect_tipc_data"", ""Dissect TIPC data"", ""Whether to try to dissect TIPC data or not"", &dissect_tipc_data); prefs_register_bool_preference(tipc_module, ""try_heuristic_first"", ""Try heuristic sub-dissectors first"", ""Try to decode a TIPCv2 packet using an heuristic sub-dissector before using a registered sub-dissector"", &try_heuristic_first); prefs_register_enum_preference(tipc_module, ""handle_v2_as"", ""Handle version 2 as"", ""TIPC 1.7 removes/adds fields (not) available in TIPC 1.5/1.6 while keeping the version number 2 in the packages. \""ALL\"" shows all fields that were ever used in both versions."", &handle_v2_as, handle_v2_as_options, TRUE); prefs_register_bool_preference(tipc_module, ""desegment"", ""Reassemble TIPC-over-TCP messages spanning multiple TCP segments"", ""Whether the TIPC-over-TCP dissector should reassemble messages spanning multiple TCP segments. "" ""To use this option, you must also enable \""Allow subdissectors to reassemble TCP streams\"" in the TCP protocol settings."", &tipc_tcp_desegment); }"
"static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) { LClosure *f; StkId fi = index2addr(L, fidx); api_check(L, ttisLclosure(fi), ""Lua function expected""); f = clLvalue(fi); api_check(L, (1 <= n && n <= f->p->sizeupvalues), ""invalid upvalue index""); if (pf) *pf = f; return &f->upvals[n - 1];   }"
"int DH_check(const DH *dh, int *ret) { #ifdef FIPS_MODULE return DH_check_params(dh, ret); #else int ok = 0, r; BN_CTX *ctx = NULL; BIGNUM *t1 = NULL, *t2 = NULL; int nid = DH_get_nid((DH *)dh); *ret = 0; if (nid != NID_undef) return 1; if (!DH_check_params(dh, ret)) return 0; ctx = BN_CTX_new_ex(dh->libctx); if (ctx == NULL) goto err; BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); t2 = BN_CTX_get(ctx); if (t2 == NULL) goto err; if (dh->params.q != NULL) { if (BN_cmp(dh->params.g, BN_value_one()) <= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else if (BN_cmp(dh->params.g, dh->params.p) >= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else { if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx)) goto err; if (!BN_is_one(t1)) *ret |= DH_NOT_SUITABLE_GENERATOR; } r = BN_check_prime(dh->params.q, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_Q_NOT_PRIME; if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx)) goto err; if (!BN_is_one(t2)) *ret |= DH_CHECK_INVALID_Q_VALUE; if (dh->params.j != NULL && BN_cmp(dh->params.j, t1)) *ret |= DH_CHECK_INVALID_J_VALUE; } r = BN_check_prime(dh->params.p, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_PRIME; else if (dh->params.q == NULL) { if (!BN_rshift1(t1, dh->params.p)) goto err; r = BN_check_prime(t1, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_SAFE_PRIME; } ok = 1; err: BN_CTX_end(ctx); BN_CTX_free(ctx); return ok; #endif  }"
"int AVI_read_audio(avi_t *AVI, u8 *audbuf, int bytes, int *continuous) { int nr, todo; s64 pos; if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; } if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX; return -1; } nr = 0;  if (bytes==0) { AVI->track[AVI->aptr].audio_posc++; AVI->track[AVI->aptr].audio_posb = 0; } *continuous = 1; while(bytes>0) { s64 ret; int left = (int) (AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb); if(left==0) { if(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr; AVI->track[AVI->aptr].audio_posc++; AVI->track[AVI->aptr].audio_posb = 0; *continuous = 0; continue; } if(bytes<left) todo = bytes; else todo = left; pos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb; gf_fseek(AVI->fdes, pos, SEEK_SET); if ( (ret = avi_read(AVI->fdes,audbuf+nr,todo)) != todo) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[avilib] XXX pos = %""LLD"", ret = %""LLD"", todo = %ld\n"", pos, ret, todo)); AVI_errno = AVI_ERR_READ; return -1; } bytes -= todo; nr    += todo; AVI->track[AVI->aptr].audio_posb += todo; } return nr; }"
"static void BenchmarkOpenCLDevices(MagickCLEnv clEnv) { MagickCLDevice device; MagickCLEnv testEnv; size_t i, j; testEnv=AcquireMagickCLEnv(); testEnv->library=openCL_library; testEnv->devices=(MagickCLDevice *) AcquireMagickMemory( sizeof(MagickCLDevice)); testEnv->number_devices=1; testEnv->benchmark_thread_id=GetMagickThreadId(); testEnv->initialized=MagickTrue; for (i = 0; i < clEnv->number_devices; i++) clEnv->devices[i]->score=MAGICKCORE_OPENCL_UNDEFINED_SCORE; for (i = 0; i < clEnv->number_devices; i++) { device=clEnv->devices[i]; if (device->score == MAGICKCORE_OPENCL_UNDEFINED_SCORE) RunDeviceBenckmark(clEnv,testEnv,device); for (j = i+1; j < clEnv->number_devices; j++) { MagickCLDevice other_device; other_device=clEnv->devices[j]; if (IsSameOpenCLDevice(device,other_device)) other_device->score=device->score; } } testEnv->enabled=MagickFalse; default_CLEnv=testEnv; clEnv->cpu_score=RunOpenCLBenchmark(MagickTrue); default_CLEnv=clEnv; testEnv=RelinquishMagickCLEnv(testEnv); CacheOpenCLBenchmarks(clEnv); }"
"static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses, volatile parse_context *ctx) { pj_str_t str; ctx->last_error = PJMEDIA_SDP_EINTIME; if (*(scanner->curptr+1) != '=') { on_scanner_error(scanner); return; } pj_scan_advance_n(scanner, 2, SKIP_WS); pj_scan_get_until_ch(scanner, ' ', &str); ses->time.start = pj_strtoul(&str); pj_scan_get_char(scanner); pj_scan_get_until_chr(scanner, "" \t\r\n"", &str); ses->time.stop = pj_strtoul(&str); pj_scan_skip_line(scanner); }"
"GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; Bool zfound=GF_FALSE; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; zfound = GF_FALSE; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) { zfound = GF_TRUE; break; } j++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; zfound = GF_FALSE; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) { zfound = GF_TRUE; break; } j++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; zfound = GF_FALSE; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; zfound = GF_FALSE; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) { zfound = GF_TRUE; break; } i++; } if (!zfound) return GF_ISOM_INVALID_FILE; if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }"
"static void ImportCbYCrYQuantum(const Image *image,QuantumInfo *quantum_info, const MagickSizeType number_pixels,const unsigned char *magick_restrict p, Quantum *magick_restrict q,ExceptionInfo *exception) { QuantumAny range; register ssize_t x; unsigned int pixel; assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); switch (quantum_info->depth) { case 10: { Quantum cbcr[4]; pixel=0; if (quantum_info->pack == MagickFalse) { register ssize_t i; size_t quantum; ssize_t n; n=0; quantum=0; for (x=0; x < (ssize_t) number_pixels; x+=2) { for (i=0; i < 4; i++) { switch (n % 3) { case 0: { p=PushLongPixel(quantum_info->endian,p,&pixel); quantum=(size_t) (ScaleShortToQuantum((unsigned short) (((pixel >> 22) & 0x3ff) << 6))); break; } case 1: { quantum=(size_t) (ScaleShortToQuantum((unsigned short) (((pixel >> 12) & 0x3ff) << 6))); break; } case 2: { quantum=(size_t) (ScaleShortToQuantum((unsigned short) (((pixel >> 2) & 0x3ff) << 6))); break; } } cbcr[i]=(Quantum) (quantum); n++; } p+=quantum_info->pad; SetPixelRed(image,cbcr[1],q); SetPixelGreen(image,cbcr[0],q); SetPixelBlue(image,cbcr[2],q); q+=GetPixelChannels(image); SetPixelRed(image,cbcr[3],q); SetPixelGreen(image,cbcr[0],q); SetPixelBlue(image,cbcr[2],q); q+=GetPixelChannels(image); } break; } } default: { range=GetQuantumRange(quantum_info->depth); for (x=0; x < (ssize_t) number_pixels; x++) { p=PushQuantumPixel(quantum_info,p,&pixel); SetPixelRed(image,ScaleAnyToQuantum(pixel,range),q); p=PushQuantumPixel(quantum_info,p,&pixel); SetPixelGreen(image,ScaleAnyToQuantum(pixel,range),q); q+=GetPixelChannels(image); } break; } } }"
"void migrate_page_copy(struct page *newpage, struct page *page) { int cpupid; if (PageHuge(page) || PageTransHuge(page)) copy_huge_page(newpage, page); else copy_highpage(newpage, page); if (PageError(page)) SetPageError(newpage); if (PageReferenced(page)) SetPageReferenced(newpage); if (PageUptodate(page)) SetPageUptodate(newpage); if (TestClearPageActive(page)) { VM_BUG_ON_PAGE(PageUnevictable(page), page); SetPageActive(newpage); } else if (TestClearPageUnevictable(page)) SetPageUnevictable(newpage); if (PageChecked(page)) SetPageChecked(newpage); if (PageMappedToDisk(page)) SetPageMappedToDisk(newpage); if (PageDirty(page)) { clear_page_dirty_for_io(page); if (PageSwapBacked(page)) SetPageDirty(newpage); else __set_page_dirty_nobuffers(newpage); } if (page_is_young(page)) set_page_young(newpage); if (page_is_idle(page)) set_page_idle(newpage); cpupid = page_cpupid_xchg_last(page, -1); page_cpupid_xchg_last(newpage, cpupid); ksm_migrate_page(newpage, page); if (PageSwapCache(page)) ClearPageSwapCache(page); ClearPagePrivate(page); set_page_private(page, 0); if (PageWriteback(newpage)) end_page_writeback(newpage); }"
"Status GraphDefImporter::ConvertNodeDef(OpBuilder &builder, ConversionState &s, const NodeDef &node) { VLOG(4) << ""Importing: "" << node.name(); OperationState state(ConvertLocation(node), absl::StrCat(""tfg."", node.op())); const OpDef *op_def; const OpRegistrationData *op_reg_data = nullptr; if ((op_reg_data = registry_.LookUp(node.op()))) { op_def = &op_reg_data->op_def; } else { auto it = function_op_defs_.find(node.op()); if (it == function_op_defs_.end()) return InvalidArgument(""Unable to find OpDef for "", node.op()); op_def = it->second; } state.attributes.reserve(node.attr_size() + 3); if (!node.device().empty()) { state.addAttribute(dialect_->getDeviceAttrIdentifier(), b_.getStringAttr(node.device())); } if (!node.name().empty()) { state.addAttribute(dialect_->getNameAttrIdentifier(), b_.getStringAttr(node.name())); } const auto add_full_type = [&](const FullTypeDef &full_type_def) { TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr full_type, ConvertAttribute(full_type_def, b_, dialect_)); state.addAttribute(dialect_->getFullTypeAttrIdentifier(), full_type); return ::tensorflow::OkStatus(); }; if (node.has_experimental_type()) { TF_RETURN_IF_ERROR(add_full_type(node.experimental_type())); } else if (op_reg_data && op_reg_data->type_ctor) { FullTypeDef full_type_def; TF_RETURN_IF_ERROR( tensorflow::full_type::SpecializeType(node, *op_def, full_type_def)); TF_RETURN_IF_ERROR(add_full_type(full_type_def)); } for (auto &name_attr : node.attr()) { if (name_attr.first.empty()) return InvalidArgument(""Node "", node.name(), "" has an empty attr name""); TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(name_attr.second, b_, dialect_)); state.addAttribute(name_attr.first, attr); } for (const auto &attr_def : op_def->attr()) { if (attr_def.has_default_value() && !state.attributes.get(attr_def.name())) { TF_ASSIGN_OR_RETURN( Attribute attr, ConvertAttributeValue(attr_def.default_value(), b_, dialect_)); state.addAttribute(attr_def.name(), attr); } } SmallVector<std::pair<unsigned, unsigned>> result_segments; result_segments.reserve(op_def->output_arg_size()); state.types.reserve(op_def->output_arg_size() + 1); for (const OpDef::ArgDef &def : op_def->output_arg()) { unsigned index = state.types.size(); TF_ASSIGN_OR_RETURN(unsigned size, ArgNumType(state.attributes, def, state.types)); result_segments.emplace_back(index, size); } state.types.push_back(dialect_->getControlType()); state.operands.reserve(node.input_size()); SmallVector<Value> control_operands; struct BackedgeResolution { ResultInfo *info; size_t operand_index; ResultId id; }; SmallVector<BackedgeResolution> unresolved_data_operands, unresolved_control_operands; for (const std::string &input : node.input()) { TF_ASSIGN_OR_RETURN(Result result, GetResult(s, input)); if (result.control) { if (result.info) { unresolved_control_operands.push_back(BackedgeResolution{ result.info, control_operands.size(), result.id}); } control_operands.push_back(result.control); } else { if (result.info) { unresolved_data_operands.push_back( BackedgeResolution{result.info, state.operands.size(), result.id}); } state.operands.push_back(result.data); } } unsigned num_data_operands = state.operands.size(); state.addOperands(control_operands); Operation *op = builder.create(state); for (const BackedgeResolution &r : unresolved_data_operands) { r.info->backedges.push_back( Backedge{r.id, &op->getOpOperand(r.operand_index)}); } for (const BackedgeResolution &r : unresolved_control_operands) { r.info->backedges.push_back( Backedge{r.id, &op->getOpOperand(num_data_operands + r.operand_index)}); } std::unique_ptr<ResultInfo> &info = s[node.name()]; if (!info) { info = std::make_unique<ResultInfo>(); } info->resolved = true; info->control = *std::prev(op->result_end()); info->data = op->getResults().drop_back(); for (auto it : llvm::zip(result_segments, op_def->output_arg())) { const std::pair<unsigned, unsigned> &segment = std::get<0>(it); info->outputs.emplace(std::get<1>(it).name(), info->data.slice(segment.first, segment.second)); } for (const Backedge &backedge : info->backedges) { Value value; if (backedge.id.IsControl()) { value = info->control; } else { TF_ASSIGN_OR_RETURN(value, ResolveDataResult(backedge.id, info.get())); } backedge.operand->set(value); } info->backedges.clear(); return ::tensorflow::OkStatus(); }"
"void Curl_detach_connnection(struct Curl_easy *data) { struct connectdata *conn = data->conn; if(conn) Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL); data->conn = NULL; }"
"static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len) { int rlen, remain; dpIOCtxPtr dctx; dynamicPtr *dp; dctx = (dpIOCtxPtr) ctx; dp = dctx->dp; remain = dp->logicalSize - dp->pos; if (remain >= len) { rlen = len; } else { if (remain == 0) { return EOF; } rlen = remain; } memcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen); dp->pos += rlen; return rlen; }"
void cgroup_sk_alloc(struct sock_cgroup_data *skcd) { if (cgroup_sk_alloc_disabled) return; if (skcd->val) { cgroup_get(sock_cgroup_ptr(skcd)); return; } if (in_interrupt()) return; rcu_read_lock(); while (true) { struct css_set *cset; cset = task_css_set(current); if (likely(cgroup_tryget(cset->dfl_cgrp))) { skcd->val = (unsigned long)cset->dfl_cgrp; break; } cpu_relax(); } rcu_read_unlock(); }
"static void cpia2_usb_disconnect(struct usb_interface *intf) { struct camera_data *cam = usb_get_intfdata(intf); usb_set_intfdata(intf, NULL); DBG(""Stopping stream\n""); cpia2_usb_stream_stop(cam); mutex_lock(&cam->v4l2_lock); DBG(""Unregistering camera\n""); cpia2_unregister_camera(cam); v4l2_device_disconnect(&cam->v4l2_dev); mutex_unlock(&cam->v4l2_lock); v4l2_device_put(&cam->v4l2_dev); if(cam->buffers) { DBG(""Wakeup waiting processes\n""); cam->curbuff->status = FRAME_READY; cam->curbuff->length = 0; wake_up_interruptible(&cam->wq_stream); } LOG(""CPiA2 camera disconnected.\n""); }"
"int archive_acl_from_text_l(struct archive_acl *acl, const char *text, int want_type, struct archive_string_conv *sc) { struct { const char *start; const char *end; } field[6], name; const char *s, *st; int numfields, fields, n, r, sol, ret; int type, types, tag, permset, id; size_t len; char sep; switch (want_type) { case ARCHIVE_ENTRY_ACL_TYPE_POSIX1E: want_type = ARCHIVE_ENTRY_ACL_TYPE_ACCESS; __LA_FALLTHROUGH; case ARCHIVE_ENTRY_ACL_TYPE_ACCESS: case ARCHIVE_ENTRY_ACL_TYPE_DEFAULT: numfields = 5; break; case ARCHIVE_ENTRY_ACL_TYPE_NFS4: numfields = 6; break; default: return (ARCHIVE_FATAL); } ret = ARCHIVE_OK; types = 0; while (text != NULL &&  *text != '\0') { fields = 0; do { const char *start, *end; next_field(&text, &start, &end, &sep); if (fields < numfields) { field[fields].start = start; field[fields].end = end; } ++fields; } while (sep == ':'); for (n = fields; n < numfields; ++n) field[n].start = field[n].end = NULL; if (field[0].start != NULL && *(field[0].start) == '#') { continue; } n = 0; sol = 0; id = -1; permset = 0; name.start = name.end = NULL; if (want_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) { s = field[0].start; len = field[0].end - field[0].start; if (*s == 'd' && (len == 1 || (len >= 7 && memcmp((s + 1), ""efault"", 6) == 0))) { type = ARCHIVE_ENTRY_ACL_TYPE_DEFAULT; if (len > 7) field[0].start += 7; else n = 1; } else type = want_type; isint(field[n + 1].start, field[n + 1].end, &id); if (id == -1 && fields > (n + 3)) isint(field[n + 3].start, field[n + 3].end, &id); tag = 0; s = field[n].start; st = field[n].start + 1; len = field[n].end - field[n].start; switch (*s) { case 'u': if (len == 1 || (len == 4 && memcmp(st, ""ser"", 3) == 0)) tag = ARCHIVE_ENTRY_ACL_USER_OBJ; break; case 'g': if (len == 1 || (len == 5 && memcmp(st, ""roup"", 4) == 0)) tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ; break; case 'o': if (len == 1 || (len == 5 && memcmp(st, ""ther"", 4) == 0)) tag = ARCHIVE_ENTRY_ACL_OTHER; break; case 'm': if (len == 1 || (len == 4 && memcmp(st, ""ask"", 3) == 0)) tag = ARCHIVE_ENTRY_ACL_MASK; break; default: break; } switch (tag) { case ARCHIVE_ENTRY_ACL_OTHER: case ARCHIVE_ENTRY_ACL_MASK: if (fields == (n + 2) && field[n + 1].start < field[n + 1].end && ismode(field[n + 1].start, field[n + 1].end, &permset)) { sol = 1; } else if (fields == (n + 3) && field[n + 1].start < field[n + 1].end) { ret = ARCHIVE_WARN; continue; } break; case ARCHIVE_ENTRY_ACL_USER_OBJ: case ARCHIVE_ENTRY_ACL_GROUP_OBJ: if (id != -1 || field[n + 1].start < field[n + 1].end) { name = field[n + 1]; if (tag == ARCHIVE_ENTRY_ACL_USER_OBJ) tag = ARCHIVE_ENTRY_ACL_USER; else tag = ARCHIVE_ENTRY_ACL_GROUP; } break; default: ret = ARCHIVE_WARN; continue; } if (permset == 0 && !ismode(field[n + 2 - sol].start, field[n + 2 - sol].end, &permset)) { ret = ARCHIVE_WARN; continue; } } else { s = field[0].start; len = field[0].end - field[0].start; tag = 0; switch (len) { case 4: if (memcmp(s, ""user"", 4) == 0) tag = ARCHIVE_ENTRY_ACL_USER; break; case 5: if (memcmp(s, ""group"", 5) == 0) tag = ARCHIVE_ENTRY_ACL_GROUP; break; case 6: if (memcmp(s, ""owner@"", 6) == 0) tag = ARCHIVE_ENTRY_ACL_USER_OBJ; else if (memcmp(s, ""group@"", 6) == 0) tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ; break; case 9: if (memcmp(s, ""everyone@"", 9) == 0) tag = ARCHIVE_ENTRY_ACL_EVERYONE; break; default: break; } if (tag == 0) { ret = ARCHIVE_WARN; continue; } else if (tag == ARCHIVE_ENTRY_ACL_USER || tag == ARCHIVE_ENTRY_ACL_GROUP) { n = 1; name = field[1]; isint(name.start, name.end, &id); } else n = 0; if (!is_nfs4_perms(field[1 + n].start, field[1 + n].end, &permset)) { ret = ARCHIVE_WARN; continue; } if (!is_nfs4_flags(field[2 + n].start, field[2 + n].end, &permset)) { ret = ARCHIVE_WARN; continue; } s = field[3 + n].start; len = field[3 + n].end - field[3 + n].start; type = 0; if (len == 4) { if (memcmp(s, ""deny"", 4) == 0) type = ARCHIVE_ENTRY_ACL_TYPE_DENY; } else if (len == 5) { if (memcmp(s, ""allow"", 5) == 0) type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW; else if (memcmp(s, ""audit"", 5) == 0) type = ARCHIVE_ENTRY_ACL_TYPE_AUDIT; else if (memcmp(s, ""alarm"", 5) == 0) type = ARCHIVE_ENTRY_ACL_TYPE_ALARM; } if (type == 0) { ret = ARCHIVE_WARN; continue; } isint(field[4 + n].start, field[4 + n].end, &id); } r = archive_acl_add_entry_len_l(acl, type, permset, tag, id, name.start, name.end - name.start, sc); if (r < ARCHIVE_WARN) return (r); if (r != ARCHIVE_OK) ret = ARCHIVE_WARN; types |= type; } archive_acl_reset(acl, types); return (ret); }"
"static VALUE ossl_cipher_set_key(VALUE self, VALUE key) { EVP_CIPHER_CTX *ctx; int key_len; StringValue(key); GetCipher(self, ctx); key_len = EVP_CIPHER_CTX_key_length(ctx); if (RSTRING_LEN(key) != key_len) ossl_raise(rb_eArgError, ""key must be %d bytes"", key_len); if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1) ossl_raise(eCipherError, NULL); return key; }"
Result BinaryReaderIR::EndFunctionBody(Index index) { current_func_ = nullptr; return Result::Ok; }
"static int ip_frag_reasm(struct ipq *qp, struct sk_buff *skb, struct sk_buff *prev_tail, struct net_device *dev) { struct net *net = container_of(qp->q.net, struct net, ipv4.frags); struct iphdr *iph; struct sk_buff *fp, *head = skb_rb_first(&qp->q.rb_fragments); struct sk_buff **nextp;  struct rb_node *rbn; int len; int ihlen; int err; u8 ecn; ipq_kill(qp); ecn = ip_frag_ecn_table[qp->ecn]; if (unlikely(ecn == 0xff)) { err = -EINVAL; goto out_fail; } if (head != skb) { fp = skb_clone(skb, GFP_ATOMIC); if (!fp) goto out_nomem; FRAG_CB(fp)->next_frag = FRAG_CB(skb)->next_frag; if (RB_EMPTY_NODE(&skb->rbnode)) FRAG_CB(prev_tail)->next_frag = fp; else rb_replace_node(&skb->rbnode, &fp->rbnode, &qp->q.rb_fragments); if (qp->q.fragments_tail == skb) qp->q.fragments_tail = fp; skb_morph(skb, head); FRAG_CB(skb)->next_frag = FRAG_CB(head)->next_frag; rb_replace_node(&head->rbnode, &skb->rbnode, &qp->q.rb_fragments); consume_skb(head); head = skb; } WARN_ON(head->ip_defrag_offset != 0); ihlen = ip_hdrlen(head); len = ihlen + qp->q.len; err = -E2BIG; if (len > 65535) goto out_oversize; if (skb_unclone(head, GFP_ATOMIC)) goto out_nomem; if (skb_has_frag_list(head)) { struct sk_buff *clone; int i, plen = 0; clone = alloc_skb(0, GFP_ATOMIC); if (!clone) goto out_nomem; skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list; skb_frag_list_init(head); for (i = 0; i < skb_shinfo(head)->nr_frags; i++) plen += skb_frag_size(&skb_shinfo(head)->frags[i]); clone->len = clone->data_len = head->data_len - plen; head->truesize += clone->truesize; clone->csum = 0; clone->ip_summed = head->ip_summed; add_frag_mem_limit(qp->q.net, clone->truesize); skb_shinfo(head)->frag_list = clone; nextp = &clone->next; } else { nextp = &skb_shinfo(head)->frag_list; } skb_push(head, head->data - skb_network_header(head)); fp = FRAG_CB(head)->next_frag; rbn = rb_next(&head->rbnode); rb_erase(&head->rbnode, &qp->q.rb_fragments); while (rbn || fp) { while (fp) { *nextp = fp; nextp = &fp->next; fp->prev = NULL; memset(&fp->rbnode, 0, sizeof(fp->rbnode)); head->data_len += fp->len; head->len += fp->len; if (head->ip_summed != fp->ip_summed) head->ip_summed = CHECKSUM_NONE; else if (head->ip_summed == CHECKSUM_COMPLETE) head->csum = csum_add(head->csum, fp->csum); head->truesize += fp->truesize; fp = FRAG_CB(fp)->next_frag; } if (rbn) { struct rb_node *rbnext = rb_next(rbn); fp = rb_to_skb(rbn); rb_erase(rbn, &qp->q.rb_fragments); rbn = rbnext; } } sub_frag_mem_limit(qp->q.net, head->truesize); *nextp = NULL; head->next = NULL; head->prev = NULL; head->dev = dev; head->tstamp = qp->q.stamp; IPCB(head)->frag_max_size = max(qp->max_df_size, qp->q.max_size); iph = ip_hdr(head); iph->tot_len = htons(len); iph->tos |= ecn; if (qp->max_df_size == qp->q.max_size) { IPCB(head)->flags |= IPSKB_FRAG_PMTU; iph->frag_off = htons(IP_DF); } else { iph->frag_off = 0; } ip_send_check(iph); __IP_INC_STATS(net, IPSTATS_MIB_REASMOKS); qp->q.fragments = NULL; qp->q.rb_fragments = RB_ROOT; qp->q.fragments_tail = NULL; qp->q.last_run_head = NULL; return 0; out_nomem: net_dbg_ratelimited(""queue_glue: no memory for gluing queue %p\n"", qp); err = -ENOMEM; goto out_fail; out_oversize: net_info_ratelimited(""Oversized IP packet from %pI4\n"", &qp->q.key.v4.saddr); out_fail: __IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS); return err; }"
"int LoadEXR(float **out_rgba, int *width, int *height, const char *filename, const char **err) { if (out_rgba == NULL) { tinyexr::SetErrorMessage(""Invalid argument for LoadEXR()"", err); return TINYEXR_ERROR_INVALID_ARGUMENT; } EXRVersion exr_version; EXRImage exr_image; EXRHeader exr_header; InitEXRHeader(&exr_header); InitEXRImage(&exr_image); { int ret = ParseEXRVersionFromFile(&exr_version, filename); if (ret != TINYEXR_SUCCESS) { return ret; } if (exr_version.multipart || exr_version.non_image) { tinyexr::SetErrorMessage(""Loading multipart or DeepImage is not supported  in LoadEXR() API"", err); return TINYEXR_ERROR_INVALID_DATA;      } } { int ret = ParseEXRHeaderFromFile(&exr_header, &exr_version, filename, err); if (ret != TINYEXR_SUCCESS) { FreeEXRHeader(&exr_header); return ret; } } for (int i = 0; i < exr_header.num_channels; i++) { if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) { exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT; } } { int ret = LoadEXRImageFromFile(&exr_image, &exr_header, filename, err); if (ret != TINYEXR_SUCCESS) { return ret; } } int idxR = -1; int idxG = -1; int idxB = -1; int idxA = -1; for (int c = 0; c < exr_header.num_channels; c++) { if (strcmp(exr_header.channels[c].name, ""R"") == 0) { idxR = c; } else if (strcmp(exr_header.channels[c].name, ""G"") == 0) { idxG = c; } else if (strcmp(exr_header.channels[c].name, ""B"") == 0) { idxB = c; } else if (strcmp(exr_header.channels[c].name, ""A"") == 0) { idxA = c; } } if ((idxA == 0) && (idxR == -1) && (idxG == -1) && (idxB == -1)) { if (exr_header.tiled) { } (*out_rgba) = reinterpret_cast<float *>( malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) * static_cast<size_t>(exr_image.height))); for (int i = 0; i < exr_image.width * exr_image.height; i++) { const float val = reinterpret_cast<float **>(exr_image.images)[0][i]; (*out_rgba)[4 * i + 0] = val; (*out_rgba)[4 * i + 1] = val; (*out_rgba)[4 * i + 2] = val; (*out_rgba)[4 * i + 3] = val; } } else { if (idxR == -1) { tinyexr::SetErrorMessage(""R channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } if (idxG == -1) { tinyexr::SetErrorMessage(""G channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } if (idxB == -1) { tinyexr::SetErrorMessage(""B channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } (*out_rgba) = reinterpret_cast<float *>( malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) * static_cast<size_t>(exr_image.height))); if (exr_header.tiled) { for (int it = 0; it < exr_image.num_tiles; it++) { for (int j = 0; j < exr_header.tile_size_y; j++) for (int i = 0; i < exr_header.tile_size_x; i++) { const int ii = exr_image.tiles[it].offset_x * exr_header.tile_size_x + i; const int jj = exr_image.tiles[it].offset_y * exr_header.tile_size_y + j; const int idx = ii + jj * exr_image.width; if (ii >= exr_image.width) { continue; } if (jj >= exr_image.height) { continue; } const int srcIdx = i + j * exr_header.tile_size_x; unsigned char **src = exr_image.tiles[it].images; (*out_rgba)[4 * idx + 0] = reinterpret_cast<float **>(src)[idxR][srcIdx]; (*out_rgba)[4 * idx + 1] = reinterpret_cast<float **>(src)[idxG][srcIdx]; (*out_rgba)[4 * idx + 2] = reinterpret_cast<float **>(src)[idxB][srcIdx]; if (idxA != -1) { (*out_rgba)[4 * idx + 3] = reinterpret_cast<float **>(src)[idxA][srcIdx]; } else { (*out_rgba)[4 * idx + 3] = 1.0; } } } } else { for (int i = 0; i < exr_image.width * exr_image.height; i++) { (*out_rgba)[4 * i + 0] = reinterpret_cast<float **>(exr_image.images)[idxR][i]; (*out_rgba)[4 * i + 1] = reinterpret_cast<float **>(exr_image.images)[idxG][i]; (*out_rgba)[4 * i + 2] = reinterpret_cast<float **>(exr_image.images)[idxB][i]; if (idxA != -1) { (*out_rgba)[4 * i + 3] = reinterpret_cast<float **>(exr_image.images)[idxA][i]; } else { (*out_rgba)[4 * i + 3] = 1.0; } } } } (*width) = exr_image.width; (*height) = exr_image.height; FreeEXRHeader(&exr_header); FreeEXRImage(&exr_image); return TINYEXR_SUCCESS; }"
"void hrandfieldCommand(client *c) { long l; int withvalues = 0; robj *hash; listpackEntry ele; if (c->argc >= 3) { if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return; if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withvalues""))) { addReplyErrorObject(c,shared.syntaxerr); return; } else if (c->argc == 4) withvalues = 1; hrandfieldWithCountCommand(c, l, withvalues); return; } if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL || checkType(c,hash,OBJ_HASH)) { return; } hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL); hashReplyFromListpackEntry(c, &ele); }"
"static int handle_eac3(MOVMuxContext *mov, AVPacket *pkt, MOVTrack *track) { AC3HeaderInfo *hdr = NULL; struct eac3_info *info; int num_blocks, ret; if (!track->eac3_priv && !(track->eac3_priv = av_mallocz(sizeof(*info)))) return AVERROR(ENOMEM); info = track->eac3_priv; if (avpriv_ac3_parse_header(&hdr, pkt->data, pkt->size) < 0) { if (!track->entry) { av_log(mov, AV_LOG_WARNING, ""Dropping invalid packet from start of the stream\n""); ret = 0; } else ret = AVERROR_INVALIDDATA; goto end; } info->data_rate = FFMAX(info->data_rate, hdr->bit_rate / 1000); num_blocks = hdr->num_blocks; if (!info->ec3_done) { if (hdr->bitstream_id <= 10 && hdr->substreamid != 0) { ret = AVERROR(EINVAL); goto end; } if (hdr->frame_type == EAC3_FRAME_TYPE_INDEPENDENT) { if (hdr->substreamid > info->num_ind_sub + 1) { ret = AVERROR(EINVAL); goto end; } if (hdr->substreamid == info->num_ind_sub + 1) { avpriv_request_sample(track->par, ""Multiple independent substreams""); ret = AVERROR_PATCHWELCOME; goto end; } else if (hdr->substreamid < info->num_ind_sub || hdr->substreamid == 0 && info->substream[0].bsid) { info->ec3_done = 1; goto concatenate; } } info->substream[hdr->substreamid].fscod = hdr->sr_code; info->substream[hdr->substreamid].bsid  = hdr->bitstream_id; info->substream[hdr->substreamid].bsmod = hdr->bitstream_mode; info->substream[hdr->substreamid].acmod = hdr->channel_mode; info->substream[hdr->substreamid].lfeon = hdr->lfe_on; if (pkt->size != hdr->frame_size) { int cumul_size = hdr->frame_size; int parent = hdr->substreamid; while (cumul_size != pkt->size) { GetBitContext gbc; int i; ret = avpriv_ac3_parse_header(&hdr, pkt->data + cumul_size, pkt->size - cumul_size); if (ret < 0) goto end; if (hdr->frame_type != EAC3_FRAME_TYPE_DEPENDENT) { ret = AVERROR(EINVAL); goto end; } info->substream[parent].num_dep_sub++; ret /= 8; init_get_bits8(&gbc, pkt->data + cumul_size + ret, pkt->size - cumul_size - ret); skip_bits(&gbc, 5); for (i = 0; i < (hdr->channel_mode ? 1 : 2); i++) { skip_bits(&gbc, 5);                     if (get_bits1(&gbc)) { skip_bits(&gbc, 8);                     } } if (get_bits1(&gbc)) info->substream[parent].chan_loc |= (get_bits(&gbc, 16) >> 5) & 0x1f; else info->substream[parent].chan_loc |= hdr->channel_mode; cumul_size += hdr->frame_size; } } } concatenate: if (!info->num_blocks && num_blocks == 6) { ret = pkt->size; goto end; } else if (info->num_blocks + num_blocks > 6) { ret = AVERROR_INVALIDDATA; goto end; } if (!info->num_blocks) { ret = av_packet_ref(&info->pkt, pkt); if (!ret) info->num_blocks = num_blocks; goto end; } else { if ((ret = av_grow_packet(&info->pkt, pkt->size)) < 0) goto end; memcpy(info->pkt.data + info->pkt.size - pkt->size, pkt->data, pkt->size); info->num_blocks += num_blocks; info->pkt.duration += pkt->duration; if ((ret = av_copy_packet_side_data(&info->pkt, pkt)) < 0) goto end; if (info->num_blocks != 6) goto end; av_packet_unref(pkt); av_packet_move_ref(pkt, &info->pkt); info->num_blocks = 0; } ret = pkt->size; end: av_free(hdr); return ret; }"
"static nxt_int_t njs_module_read(njs_vm_t *vm, int fd, nxt_str_t *text) { u_char       *p; ssize_t      n; struct stat  sb; if (fstat(fd, &sb) == -1) { goto fail; } text->length = nxt_length(NJS_MODULE_START); if (S_ISREG(sb.st_mode) && sb.st_size) { text->length += sb.st_size; } text->length += nxt_length(NJS_MODULE_END); text->start = nxt_mp_alloc(vm->mem_pool, text->length); if (text->start == NULL) { goto fail; } p = nxt_cpymem(text->start, NJS_MODULE_START, nxt_length(NJS_MODULE_START)); n = read(fd, p, sb.st_size); if (n < 0) { goto fail; } if (n != sb.st_size) { goto fail; } p += n; memcpy(p, NJS_MODULE_END, nxt_length(NJS_MODULE_END)); return NXT_OK; fail: if (text->start != NULL) { nxt_mp_free(vm->mem_pool, text->start); } return NXT_ERROR; }"
"int JackClientSocket::Connect(const char* dir, const char* name, int which) { struct sockaddr_un addr; if ((fSocket = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) { jack_error(""Cannot create socket err = %s"", strerror(errno)); return -1; } addr.sun_family = AF_UNIX; BuildName(name, addr.sun_path, dir, which, sizeof(addr.sun_path), fPromiscuous); jack_log(""JackClientSocket::Connect : addr.sun_path %s"", addr.sun_path); if (connect(fSocket, (struct sockaddr*)&addr, sizeof(addr)) < 0) { jack_error(""Cannot connect to server socket err = %s"", strerror(errno)); close(fSocket); return -1; } #ifdef __APPLE__ int on = 1; if (setsockopt(fSocket, SOL_SOCKET, SO_NOSIGPIPE, (const char*)&on, sizeof(on)) < 0) { jack_log(""setsockopt SO_NOSIGPIPE fd = %ld err = %s"", fSocket, strerror(errno)); } #endif return 0; }"
"static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino) { return ino == EXT4_ROOT_INO || ino == EXT4_USR_QUOTA_INO || ino == EXT4_GRP_QUOTA_INO || ino == EXT4_BOOT_LOADER_INO || ino == EXT4_JOURNAL_INO || ino == EXT4_RESIZE_INO || (ino >= EXT4_FIRST_INO(sb) && ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count)); }"
"static gint dissect_wccp2_alternate_assignment_info(tvbuff_t *tvb, int offset, gint length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table) { guint16 assignment_type; guint16 assignment_length; proto_item *tf=NULL; guint32 n_routers; guint i; proto_tree *element_tree; gint new_length; if (length < ALT_ASSIGNMENT_INFO_MIN_LEN) return length - ALT_ASSIGNMENT_INFO_MIN_LEN; assignment_type = tvb_get_ntohs(tvb, offset); proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_type, tvb, offset, 2, ENC_BIG_ENDIAN); EAT_AND_CHECK(2,2); assignment_length = tvb_get_ntohs(tvb, offset); tf=proto_tree_add_item(info_tree, hf_alt_assignment_info_assignment_length, tvb, offset, 2, ENC_BIG_ENDIAN); EAT(2); if (length < assignment_length) expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad, ""Assignment length is %d but only %d remain in the packet. Ignoring this for now"", assignment_length, length); if (length > assignment_length)  { expert_add_info_format(pinfo, tf, &ei_wccp_assignment_length_bad, ""Assignment length is %d but %d remain in the packet. Assuming that the assignment length is wrong and setting it to %d."", assignment_length, length, length); } new_length=dissect_wccp2_assignment_key_element(tvb, offset, length, pinfo,  info_tree, addr_table); NOTE_EATEN_LENGTH(new_length); n_routers = tvb_get_ntohl(tvb, offset); proto_tree_add_uint(info_tree, hf_alt_assignment_info_num_routers, tvb, offset, 4, n_routers); EAT(4); for (i = 0; i < n_routers; i++) { if (length < 12) return length - 12*(n_routers-i); element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 12, ett_router_alt_assignment_element, NULL, ""Router %d Assignment Element: IP address %s"", i, decode_wccp_encoded_address(tvb, offset, pinfo, info_tree, addr_table)); dissect_wccp2_router_assignment_element(tvb, offset, length , pinfo, element_tree, addr_table); EAT(12); } switch (assignment_type) { case WCCP2_HASH_ASSIGNMENT_TYPE: return dissect_wccp2_hash_assignment_info(tvb, offset, length, pinfo, info_tree, addr_table); case WCCP2_MASK_ASSIGNMENT_TYPE: return dissect_wccp2_mask_value_set_list(tvb, offset, length, pinfo, info_tree, addr_table); case WCCP2r1_ALT_MASK_ASSIGNMENT_TYPE: return dissect_wccp2_alternate_mask_value_set_list(tvb, offset, length, pinfo, info_tree, addr_table); default: return length; } }"
"static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { AnsiContext *s = avctx->priv_data; uint8_t *buf = avpkt->data; int buf_size = avpkt->size; const uint8_t *buf_end   = buf+buf_size; int ret, i, count; if ((ret = ff_reget_buffer(avctx, s->frame)) < 0) return ret; if (!avctx->frame_number) { for (i=0; i<avctx->height; i++) memset(s->frame->data[0]+ i*s->frame->linesize[0], 0, avctx->width); memset(s->frame->data[1], 0, AVPALETTE_SIZE); } s->frame->pict_type           = AV_PICTURE_TYPE_I; s->frame->palette_has_changed = 1; set_palette((uint32_t *)s->frame->data[1]); if (!s->first_frame) { erase_screen(avctx); s->first_frame = 1; } while(buf < buf_end) { switch(s->state) { case STATE_NORMAL: switch (buf[0]) { case 0x00:             case 0x07:             case 0x1A:                  break; case 0x08:                 s->x = FFMAX(s->x - 1, 0); break; case 0x09:                 i = s->x / FONT_WIDTH; count = ((i + 8) & ~7) - i; for (i = 0; i < count; i++) draw_char(avctx, ' '); break; case 0x0A:                 hscroll(avctx); case 0x0D:                 s->x = 0; break; case 0x0C:                 erase_screen(avctx); break; case 0x1B:                 s->state = STATE_ESCAPE; break; default: draw_char(avctx, buf[0]); } break; case STATE_ESCAPE: if (buf[0] == '[') { s->state   = STATE_CODE; s->nb_args = 0; s->args[0] = -1; } else { s->state = STATE_NORMAL; draw_char(avctx, 0x1B); continue; } break; case STATE_CODE: switch(buf[0]) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (s->nb_args < MAX_NB_ARGS) s->args[s->nb_args] = FFMAX(s->args[s->nb_args], 0) * 10 + buf[0] - '0'; break; case ';': s->nb_args++; if (s->nb_args < MAX_NB_ARGS) s->args[s->nb_args] = 0; break; case 'M': s->state = STATE_MUSIC_PREAMBLE; break; case '=': case '?': break; default: if (s->nb_args > MAX_NB_ARGS) av_log(avctx, AV_LOG_WARNING, ""args overflow (%i)\n"", s->nb_args); if (s->nb_args < MAX_NB_ARGS && s->args[s->nb_args] >= 0) s->nb_args++; if ((ret = execute_code(avctx, buf[0])) < 0) return ret; s->state = STATE_NORMAL; } break; case STATE_MUSIC_PREAMBLE: if (buf[0] == 0x0E || buf[0] == 0x1B) s->state = STATE_NORMAL; break; } buf++; } *got_frame = 1; if ((ret = av_frame_ref(data, s->frame)) < 0) return ret; return buf_size; }"
"void *jas_malloc(size_t size) { void *result; JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size)); result = malloc(size); JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result)); return result; }"
"static int dissect_rtcp_rtpfb_transport_cc( tvbuff_t *tvb, int offset, proto_tree *rtcp_tree, int pkt_len) { proto_tree *fci_tree, *pkt_chunk_tree, *recv_delta_tree; proto_item *item       = NULL; guint8  *delta_array; guint16 *pkt_seq_array; guint32 i, pkt_base_seq, pkt_seq_num, pkt_count; gint fci_length        = pkt_len - RTCP_HEADER_LENGTH; int delta_index        = 0; int padding_length     = offset; fci_tree = proto_tree_add_subtree_format( rtcp_tree, tvb, offset, fci_length, ett_ssrc, NULL, ""Transport-cc"" ); proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_base_seq, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_base_seq ); offset += 2; pkt_seq_num = pkt_base_seq; proto_tree_add_item_ret_uint( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_stats_cnt, tvb, offset, 2, ENC_BIG_ENDIAN, &pkt_count ); offset += 2; delta_array   = wmem_alloc0_array( wmem_packet_scope(), gint8, pkt_count ); pkt_seq_array = wmem_alloc0_array( wmem_packet_scope(), gint16, pkt_count ); proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_ref_time, tvb, offset, 3, ENC_BIG_ENDIAN ); offset += 3; proto_tree_add_item( fci_tree, hf_rtcp_rtpfb_transport_cc_fci_fb_pkt_cnt, tvb, offset, 1, ENC_BIG_ENDIAN ); offset += 1; pkt_chunk_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Packet Chunks"" ); for (i = 0; i < pkt_count; ) { guint32 chunk = 0; item = proto_tree_add_item_ret_uint( pkt_chunk_tree, hf_rtcp_rtpfb_transport_cc_fci_pkt_chunk, tvb, offset, 2, ENC_BIG_ENDIAN, &chunk ); if ( !(chunk & 0x8000) ) { int length = chunk & 0x1FFF; if ( length <= 0 ) { delta_array = NULL; pkt_seq_array = NULL; offset += 2; return offset; } if ( !(chunk & 0x6000) ) { proto_item_append_text( item, "" [Run Length Chunk] Packet not received. Length : %d"", length); pkt_seq_num += length; } else if ( chunk & 0x2000 ) { proto_item_append_text( item, "" [Run Length Chunk] Small Delta. Length : %d"", length); for (int j = 0; j < length; j++) { delta_array[delta_index+j] = 1; pkt_seq_array[delta_index+j] = pkt_seq_num++; } delta_index += length; } else if ( chunk & 0x4000 ) { proto_item_append_text( item, "" [Run Length Chunk] Large or Negative Delta. Length : %d"", length); for (int j = 0; j < length; j++) { delta_array[delta_index+j] = 2; pkt_seq_array[delta_index+j] = pkt_seq_num++; } delta_index += length; } else { proto_item_append_text( item, "" [Run Length Chunk] [Reserved]. Length : %d"", length); pkt_seq_num += length; } i += length; } else { wmem_strbuf_t* status = wmem_strbuf_new(wmem_packet_scope(), ""|""); if ( !(chunk & 0x4000) ) { int data = chunk & 0x3FFF; int chunk_count = 14; for (int k = 0; k < chunk_count; k++) { if ( (data & (0x2000>>k)) == 0 ) { if ( i + k < pkt_count ) { wmem_strbuf_append(status, "" N |""); pkt_seq_num++; } else { wmem_strbuf_append(status, "" _ |""); } } else { wmem_strbuf_append(status, "" R |""); delta_array[delta_index] = 1; pkt_seq_array[delta_index] = pkt_seq_num++; delta_index++; } } proto_item_append_text( item, "" [1 bit Status Vector Chunk]: %s"", wmem_strbuf_get_str(status)); i += chunk_count; } else { int chunk_count = 7; int data = chunk & 0x3FFF; for (int k = 0; k < chunk_count; k++) { switch ( (data & (0x3000 >> (2*k))) >> ( 2 * (6-k) ) ) { case 0:  if ( i + k < pkt_count ) { wmem_strbuf_append(status, "" NR |""); pkt_seq_num++; } else { wmem_strbuf_append(status, "" __ |""); } break; case 1:  wmem_strbuf_append(status, "" SD |""); delta_array[delta_index] = 1; pkt_seq_array[delta_index] = pkt_seq_num++; delta_index++; break; case 2:  wmem_strbuf_append(status, "" LD |""); delta_array[delta_index] = 2; pkt_seq_array[delta_index] = pkt_seq_num++; delta_index++; break; case 3:  default: wmem_strbuf_append(status, "" WO |""); pkt_seq_num++; break; } } proto_item_append_text( item, "" [2 bits Status Vector Chunk]: %s"", wmem_strbuf_get_str(status)); i += chunk_count; } } offset += 2; } recv_delta_tree = proto_tree_add_subtree_format( fci_tree, tvb, offset, 0, ett_ssrc, NULL, ""Recv Delta"" ); for (i = 0; i < pkt_count; i++ ) { if ( delta_array[i] == 1 ) { guint32 delta; item = proto_tree_add_item_ret_uint( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_1_byte, tvb, offset, 1, ENC_BIG_ENDIAN, &delta ); proto_item_append_text( item, "" Small Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000); offset += 1; } else if ( delta_array[i] == 2 ) { gint16 delta; item = proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_2_bytes, tvb, offset, 2, ENC_BIG_ENDIAN); delta = tvb_get_ntohs(tvb, offset); if ( delta < 0 ) { proto_item_append_text( item, "" Negative Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 ); } else { proto_item_append_text( item, "" Large Delta: [seq: %d] %lf ms"", pkt_seq_array[i], delta*250.0/1000 ); } offset += 2; } else { break; } } padding_length = fci_length - (offset - padding_length); if ( padding_length > 0 ) { proto_tree_add_item( recv_delta_tree, hf_rtcp_rtpfb_transport_cc_fci_recv_delta_padding, tvb, offset, padding_length, ENC_BIG_ENDIAN ); offset += padding_length; } delta_array = NULL; pkt_seq_array = NULL; return offset; }"
"static void write_trailer(FILE  *out, int   num_file_pages, uchar *lang) { inti, j, k, type, offset, start; page_t*page; charprefix[64], *prefptr; static const char *modes[] = { ""UseNone"", ""UseOutlines"", ""FullScreen"" }; static const char *layouts[] = { ""SinglePage"", ""OneColumn"", ""TwoColumnLeft"", ""TwoColumnRight"" }; if (PSLevel > 0) { fputs(""%%Trailer\n"", out); if (num_file_pages > 0) fprintf(out, ""%%%%Pages: %d\n"", num_file_pages); fputs(""%%EOF\n"", out); } else { root_object = pdf_start_object(out); fputs(""/Type/Catalog"", out); fprintf(out, ""/Pages %d 0 R"", pages_object); if (PDFVersion >= 12) { if (names_object) fprintf(out, ""/Names %d 0 R"", names_object); fprintf(out, ""/PageLayout/%s"", layouts[PDFPageLayout]); } if (lang) fprintf(out, ""/Lang(%s)"", (char *)lang); if (outline_object > 0) fprintf(out, ""/Outlines %d 0 R"", outline_object); switch (PDFFirstPage) { case PDF_PAGE_1 : if (TitlePage) { fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 1); break; } break; case PDF_TOC : if (TocLevels > 0) { fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 2 * chapter_outstarts[0] + 1); break; } break; case PDF_CHAPTER_1 : fprintf(out, ""/OpenAction[%d 0 R/XYZ null null 0]"", pages_object + 2 * chapter_outstarts[1] + 1); break; } fprintf(out, ""/PageMode/%s"", modes[PDFPageMode]); if (PDFVersion > 12 && NumberUp == 1) { fputs(""/PageLabels<</Nums["", out); for (i = 0; i < chapter_starts[1]; i ++) { fprintf(out, ""%d<</P"", i); if (i & 1) write_string(out, (uchar *)""eltit"", 0); else write_string(out, (uchar *)""title"", 0); fputs("">>"", out); } if (TocLevels > 0 && OutputType == OUTPUT_BOOK) { type = 'r'; for (j = 0; j < 3; j ++) if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(1)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(1)""))) type = 'D'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(I)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(I)""))) type = 'R'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(a)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(a)""))) type = 'a'; else if ((TocHeader[j] && strstr(TocHeader[j], ""$PAGE(A)"")) || (TocFooter[j] && strstr(TocFooter[j], ""$PAGE(A)""))) type = 'A'; fprintf(out, ""%d<</S/%c>>"", i, type); i += chapter_ends[0] - chapter_starts[0] + 1; } for (j = 1; j <= TocDocCount; j ++) { page  = pages + chapter_starts[j]; start = chapter_starts[j] - chapter_starts[1] + 1; type  = 'D'; prefix[0] = '\0'; for (k = 0; k < 3; k ++) { if (page->header[k] && strstr((char *)page->header[k], ""PAGE"")) strlcpy(prefix, (char *)page->header[k], sizeof(prefix)); else if (page->footer[k] && strstr((char *)page->footer[k], ""PAGE"")) strlcpy(prefix, (char *)page->footer[k], sizeof(prefix)); if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(i)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(i)""))) type = 'r'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(I)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(I)""))) type = 'R'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(a)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(a)""))) type = 'a'; else if ((page->header[k] && strstr((char *)page->header[k], ""PAGE(A)"")) || (page->footer[k] && strstr((char *)page->footer[k], ""PAGE(A)""))) type = 'A'; if ((page->header[k] && strstr((char *)page->header[k], ""$CHAPTERPAGE"")) || (page->footer[k] && strstr((char *)page->footer[k], ""$CHAPTERPAGE""))) start = 1; } if ((prefptr = strstr(prefix, ""$PAGE"")) == NULL) prefptr = strstr(prefix, ""$CHAPTERPAGE""); fprintf(out, ""%d<</S/%c/St %d"", i, type, start); if (prefptr) { *prefptr = '\0'; fputs(""/P"", out); write_string(out, (uchar *)prefix, 0); } fputs("">>"", out); i += chapter_ends[j] - chapter_starts[j] + 1; } fputs(""]>>"", out); } pdf_end_object(out); offset = ftell(out); fputs(""xref\n"", out); fprintf(out, ""0 %d \n"", (int)num_objects + 1); fputs(""0000000000 65535 f \n"", out); for (i = 1; i <= (int)num_objects; i ++) fprintf(out, ""%010d 00000 n \n"", objects[i]); fputs(""trailer\n"", out); fputs(""<<"", out); fprintf(out, ""/Size %d"", (int)num_objects + 1); fprintf(out, ""/Root %d 0 R"", root_object); fprintf(out, ""/Info %d 0 R"", info_object); fputs(""/ID[<"", out); for (i = 0; i < 16; i ++) fprintf(out, ""%02x"", file_id[i]); fputs(""><"", out); for (i = 0; i < 16; i ++) fprintf(out, ""%02x"", file_id[i]); fputs("">]"", out); if (Encryption) fprintf(out, ""/Encrypt %d 0 R"", encrypt_object); fputs("">>\n"", out); fputs(""startxref\n"", out); fprintf(out, ""%d\n"", offset); fputs(""%%EOF\n"", out); } }"
"static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { struct squashfs_dir_header dirh; char buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); struct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer; long long start; long long bytes; int dir_count, size; struct dir_ent *new_dir; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: malloc failed!\n""); dir->dir_count = 0; dir->cur_entry = 0; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 3) return dir; start = sBlk.s.directory_table_start + (*i)->start; bytes = lookup_entry(directory_table_hash, start); if(bytes == -1) EXIT_UNSQUASH(""squashfs_opendir: directory block %lld not "" ""found!\n"", start); bytes += (*i)->offset; size = (*i)->data + bytes - 3; while(bytes < size) { SQUASHFS_SWAP_DIR_HEADER(directory_table + bytes, &dirh); dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { SQUASHFS_SWAP_DIR_ENTRY(directory_table + bytes, dire); bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } memcpy(dire->name, directory_table + bytes, dire->size + 1); dire->name[dire->size + 1] = '\0'; TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); if((dir->dir_count % DIR_ENT_SIZE) == 0) { new_dir = realloc(dir->dirs, (dir->dir_count + DIR_ENT_SIZE) * sizeof(struct dir_ent)); if(new_dir == NULL) EXIT_UNSQUASH(""squashfs_opendir: "" ""realloc failed!\n""); dir->dirs = new_dir; } strcpy(dir->dirs[dir->dir_count].name, dire->name); dir->dirs[dir->dir_count].start_block = dirh.start_block; dir->dirs[dir->dir_count].offset = dire->offset; dir->dirs[dir->dir_count].type = dire->type; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: free(dir->dirs); free(dir); return NULL; }"
"notrace do_int3(struct pt_regs *regs, long error_code) { #ifdef CONFIG_DYNAMIC_FTRACE if (unlikely(atomic_read(&modifying_ftrace_code)) && ftrace_int3_handler(regs)) return; #endif if (poke_int3_handler(regs)) return; ist_enter(regs); RCU_LOCKDEP_WARN(!rcu_is_watching(), ""entry code didn't wake RCU""); #ifdef CONFIG_KGDB_LOW_LEVEL_TRAP if (kgdb_ll_trap(DIE_INT3, ""int3"", regs, error_code, X86_TRAP_BP, SIGTRAP) == NOTIFY_STOP) goto exit; #endif  #ifdef CONFIG_KPROBES if (kprobe_int3_handler(regs)) goto exit; #endif if (notify_die(DIE_INT3, ""int3"", regs, error_code, X86_TRAP_BP, SIGTRAP) == NOTIFY_STOP) goto exit; debug_stack_usage_inc(); cond_local_irq_enable(regs); do_trap(X86_TRAP_BP, SIGTRAP, ""int3"", regs, error_code, NULL); cond_local_irq_disable(regs); debug_stack_usage_dec(); exit: ist_exit(regs); }"
"static int do_umount(struct mount *mnt, int flags) { struct super_block *sb = mnt->mnt.mnt_sb; int retval; retval = security_sb_umount(&mnt->mnt, flags); if (retval) return retval; if (flags & MNT_EXPIRE) { if (&mnt->mnt == current->fs->root.mnt || flags & (MNT_FORCE | MNT_DETACH)) return -EINVAL; lock_mount_hash(); if (mnt_get_count(mnt) != 2) { unlock_mount_hash(); return -EBUSY; } unlock_mount_hash(); if (!xchg(&mnt->mnt_expiry_mark, 1)) return -EAGAIN; } if (flags & MNT_FORCE && sb->s_op->umount_begin) { sb->s_op->umount_begin(sb); } if (&mnt->mnt == current->fs->root.mnt && !(flags & MNT_DETACH)) { down_write(&sb->s_umount); if (!(sb->s_flags & MS_RDONLY)) retval = do_remount_sb(sb, MS_RDONLY, NULL, 0); up_write(&sb->s_umount); return retval; } namespace_lock(); lock_mount_hash(); event++; if (flags & MNT_DETACH) { if (!list_empty(&mnt->mnt_list)) umount_tree(mnt, 2); retval = 0; } else { shrink_submounts(mnt); retval = -EBUSY; if (!propagate_mount_busy(mnt, 2)) { if (!list_empty(&mnt->mnt_list)) umount_tree(mnt, 1); retval = 0; } } unlock_mount_hash(); namespace_unlock(); return retval; }"
"static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image) { Image *msl_image; MagickBooleanType status; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); msl_image=CloneImage(image,0,0,MagickTrue,&image->exception); status=ProcessMSLScript(image_info,&msl_image,&image->exception); if (msl_image != (Image *) NULL) msl_image=DestroyImage(msl_image); return(status); }"
"static bool php_openssl_validate_iv( String piv, int iv_required_len, String& out, EVP_CIPHER_CTX* cipher_ctx, const php_openssl_cipher_mode* mode) { if (cipher_ctx == nullptr || mode == nullptr) { return false; } if (piv.size() == iv_required_len) { out = std::move(piv); return true; } if (mode->is_aead) { if (EVP_CIPHER_CTX_ctrl( cipher_ctx, mode->aead_ivlen_flag, piv.size(), nullptr) != 1) { raise_warning( ""Setting of IV length for AEAD mode failed, the expected length is "" ""%d bytes"", iv_required_len); return false; } out = std::move(piv); return true; } String s = String(iv_required_len, ReserveString); char* iv_new = s.mutableData(); memset(iv_new, 0, iv_required_len); if (piv.size() <= 0) { s.setSize(iv_required_len); out = std::move(s); return true; } if (piv.size() < iv_required_len) { raise_warning(""IV passed is only %d bytes long, cipher "" ""expects an IV of precisely %d bytes, padding with \\0"", piv.size(), iv_required_len); memcpy(iv_new, piv.data(), piv.size()); s.setSize(iv_required_len); out = std::move(s); return true; } raise_warning(""IV passed is %d bytes long which is longer than the %d "" ""expected by selected cipher, truncating"", piv.size(), iv_required_len); memcpy(iv_new, piv.data(), iv_required_len); s.setSize(iv_required_len); out = std::move(s); return true; }"
"xml_element* xml_elem_parse_buf(const char* in_buf, int len, XML_ELEM_INPUT_OPTIONS options, XML_ELEM_ERROR error) { xml_element* xReturn = NULL; char buf[100] = """"; static STRUCT_XML_ELEM_INPUT_OPTIONS default_opts = {encoding_utf_8}; if(!options) { options = &default_opts; } if(in_buf) { XML_Parser parser; xml_elem_data mydata = {0}; parser = XML_ParserCreate(NULL); mydata.root = xml_elem_new(); mydata.current = mydata.root; mydata.input_options = options; mydata.needs_enc_conversion = options->encoding && strcmp(options->encoding, encoding_utf_8); XML_SetElementHandler(parser, (XML_StartElementHandler)_xmlrpc_startElement, (XML_EndElementHandler)_xmlrpc_endElement); XML_SetCharacterDataHandler(parser, (XML_CharacterDataHandler)_xmlrpc_charHandler); XML_SetUserData(parser, (void*)&mydata); if(!len) { len = strlen(in_buf); } if(XML_Parse(parser, in_buf, len, 1) == 0) { enum XML_Error err_code = XML_GetErrorCode(parser); int line_num = XML_GetCurrentLineNumber(parser); int col_num = XML_GetCurrentColumnNumber(parser); long byte_idx = XML_GetCurrentByteIndex(parser); const char * error_str = XML_ErrorString(err_code); if(byte_idx >= 0) { snprintf(buf,  sizeof(buf), ""\n\tdata beginning %ld before byte index: %s\n"", byte_idx > 10  ? 10 : byte_idx, in_buf + (byte_idx > 10 ? byte_idx - 10 : byte_idx)); } if(error) { error->parser_code = (long)err_code; error->line = line_num; error->column = col_num; error->byte_index = byte_idx; error->parser_error = error_str; } } else { xReturn = (xml_element*)Q_Head(&mydata.root->children); xReturn->parent = NULL; } XML_ParserFree(parser); xml_elem_free_non_recurse(mydata.root); } return xReturn; }"
"void CSndUList::update(const CUDT* u, EReschedule reschedule) { CGuard listguard(m_ListLock); CSNode* n = u->m_pSNode; if (n->m_iHeapLoc >= 0) { if (!reschedule)          return; if (n->m_iHeapLoc == 0) { n->m_llTimeStamp_tk = 1; m_pTimer->interrupt(); return; } remove_(u); } insert_(1, u); }"
"static inline realpath_cache_bucket* realpath_cache_find(const char *path, int path_len, time_t t TSRMLS_DC)  { #ifdef PHP_WIN32 unsigned long key = realpath_cache_key(path, path_len TSRMLS_CC); #else unsigned long key = realpath_cache_key(path, path_len); #endif unsigned long n = key % (sizeof(CWDG(realpath_cache)) / sizeof(CWDG(realpath_cache)[0])); realpath_cache_bucket **bucket = &CWDG(realpath_cache)[n]; while (*bucket != NULL) { if (CWDG(realpath_cache_ttl) && (*bucket)->expires < t) { realpath_cache_bucket *r = *bucket; *bucket = (*bucket)->next; if(r->path == r->realpath) { CWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1; } else { CWDG(realpath_cache_size) -= sizeof(realpath_cache_bucket) + r->path_len + 1 + r->realpath_len + 1; } free(r); } else if (key == (*bucket)->key && path_len == (*bucket)->path_len && memcmp(path, (*bucket)->path, path_len) == 0) { return *bucket; } else { bucket = &(*bucket)->next; } } return NULL; }"
"static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb) { static u32 challenge_timestamp; static unsigned int challenge_count; struct tcp_sock *tp = tcp_sk(sk); u32 now; if (tcp_oow_rate_limited(sock_net(sk), skb, LINUX_MIB_TCPACKSKIPPEDCHALLENGE, &tp->last_oow_ack_time)) return; now = jiffies / HZ; if (now != challenge_timestamp) { challenge_timestamp = now; challenge_count = 0; } if (++challenge_count <= sysctl_tcp_challenge_ack_limit) { NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK); tcp_send_ack(sk); } }"
"GF_EXPORT GF_AVCConfig *gf_isom_mvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->mvc_config) return NULL; return AVC_DuplicateConfig(entry->mvc_config->config); }"
"static void RecalculateMasterButtons(DeviceIntPtr slave) { DeviceIntPtr dev, master; int maxbuttons = 0; if (!slave->button || IsMaster(slave)) return; master = GetMaster(slave, MASTER_POINTER); if (!master) return; for (dev = inputInfo.devices; dev; dev = dev->next) { if (IsMaster(dev) || GetMaster(dev, MASTER_ATTACHED) != master || !dev->button) continue; maxbuttons = max(maxbuttons, dev->button->numButtons); } if (master->button && master->button->numButtons != maxbuttons) { int i; DeviceChangedEvent event = { .header = ET_Internal, .type = ET_DeviceChanged, .time = GetTimeInMillis(), .deviceid = master->id, .flags = DEVCHANGE_POINTER_EVENT | DEVCHANGE_DEVICE_CHANGE, .buttons.num_buttons = maxbuttons }; master->button->numButtons = maxbuttons; memcpy(&event.buttons.names, master->button->labels, maxbuttons * sizeof(Atom)); if (master->valuator) { event.num_valuators = master->valuator->numAxes; for (i = 0; i < event.num_valuators; i++) { event.valuators[i].min = master->valuator->axes[i].min_value; event.valuators[i].max = master->valuator->axes[i].max_value; event.valuators[i].resolution = master->valuator->axes[i].resolution; event.valuators[i].mode = master->valuator->axes[i].mode; event.valuators[i].name = master->valuator->axes[i].label; } } if (master->key) { event.keys.min_keycode = master->key->xkbInfo->desc->min_key_code; event.keys.max_keycode = master->key->xkbInfo->desc->max_key_code; } XISendDeviceChangedEvent(master, &event); } }"
"METHODDEF(JDIMENSION) get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo) { ppm_source_ptr source = (ppm_source_ptr)sinfo; register JSAMPROW ptr; register U_CHAR *bufferptr; register JSAMPLE *rescale = source->rescale; JDIMENSION col; unsigned int maxval = source->maxval; if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width)) ERREXIT(cinfo, JERR_INPUT_EOF); ptr = source->pub.buffer[0]; bufferptr = source->iobuffer; for (col = cinfo->image_width; col > 0; col--) { register unsigned int temp; temp  = UCH(*bufferptr++) << 8; temp |= UCH(*bufferptr++); if (temp > maxval) ERREXIT(cinfo, JERR_PPM_TOOLARGE); *ptr++ = rescale[temp]; } return 1; }"
"void sock_release(struct socket *sock) { if (sock->ops) { struct module *owner = sock->ops->owner; sock->ops->release(sock); sock->ops = NULL; module_put(owner); } if (rcu_dereference_protected(sock->wq, 1)->fasync_list) pr_err(""%s: fasync list not empty!\n"", __func__); if (!sock->file) { iput(SOCK_INODE(sock)); return; } sock->file = NULL; }"
"static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct task_group *tg = cfs_rq->tg; struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg); u64 amount = 0, min_amount, expires; int expires_seq; min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota == RUNTIME_INF) amount = min_amount; else { start_cfs_bandwidth(cfs_b); if (cfs_b->runtime > 0) { amount = min(cfs_b->runtime, min_amount); cfs_b->runtime -= amount; cfs_b->idle = 0; } } expires_seq = cfs_b->expires_seq; expires = cfs_b->runtime_expires; raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining += amount; if (cfs_rq->expires_seq != expires_seq) { cfs_rq->expires_seq = expires_seq; cfs_rq->runtime_expires = expires; } return cfs_rq->runtime_remaining > 0; }"
"void escape(const std::string& in, std::string& out) { out.reserve(out.size() + in.size()); for (auto it = in.begin(); it != in.end(); ++it) { switch (*it) { case '&': out += ""&amp;""; break; case '<': out += ""&lt;""; break; case '>': out += ""&gt;""; break; case '""': out += ""&quot;""; break; case '\'': out += ""&#39;""; break; case '/': out += ""&#x2F;""; break; default: out += *it; break; } } }"
"static int wb_prep(netdissect_options *ndo, const struct pkt_prep *prep, u_int len) { int n; const struct pgstate *ps; const u_char *ep = ndo->ndo_snapend; ND_PRINT((ndo, "" wb-prep:"")); if (len < sizeof(*prep)) { return (-1); } n = EXTRACT_32BITS(&prep->pp_n); ps = (const struct pgstate *)(prep + 1); while (--n >= 0 && !ND_TTEST(*ps)) { const struct id_off *io, *ie; char c = '<'; ND_PRINT((ndo, "" %u/%s:%u"", EXTRACT_32BITS(&ps->slot), ipaddr_string(ndo, &ps->page.p_sid), EXTRACT_32BITS(&ps->page.p_uid))); io = (struct id_off *)(ps + 1); for (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) { ND_PRINT((ndo, ""%c%s:%u"", c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off))); c = ','; } ND_PRINT((ndo, "">"")); ps = (struct pgstate *)io; } return ((u_char *)ps <= ep? 0 : -1); }"
"static int check_entry_size_and_hooks(struct ipt_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 || (unsigned char *)e + sizeof(struct ipt_entry) >= limit || (unsigned char *)e + e->next_offset > limit) { duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } err = check_entry(e); if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_err(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }"
"struct resource_pool *dcn10_create_resource_pool( const struct dc_init_data *init_data, struct dc *dc) { struct dcn10_resource_pool *pool = kzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL); if (!pool) return NULL; if (construct(init_data->num_virtual_links, dc, pool)) return &pool->base; BREAK_TO_DEBUGGER(); return NULL; }"
"static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement TSRMLS_DC) { int de, i=0, section_index = SECTION_MAKERNOTE; int NumDirEntries, old_motorola_intel, offset_diff; const maker_note_type *maker_note; char *dir_start; for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) { if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) return FALSE; maker_note = maker_note_array+i; if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make))) continue; if (maker_note->model && (!ImageInfo->model || strcmp(maker_note->model, ImageInfo->model))) continue; if (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len)) continue; break; } dir_start = value_ptr + maker_note->offset; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement)); #endif ImageInfo->sections_found |= FOUND_MAKERNOTE; old_motorola_intel = ImageInfo->motorola_intel; switch (maker_note->byte_order) { case MN_ORDER_INTEL: ImageInfo->motorola_intel = 0; break; case MN_ORDER_MOTOROLA: ImageInfo->motorola_intel = 1; break; default: case MN_ORDER_NORMAL: break; } NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel); switch (maker_note->offset_mode) { case MN_OFFSET_MAKER: offset_base = value_ptr; break; case MN_OFFSET_GUESS: offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel); #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff); #endif offset_base = value_ptr + offset_diff; break; default: case MN_OFFSET_NORMAL: break; } if ((2+NumDirEntries*12) > value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + x%04X*12 = x%04X > x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len); return FALSE; } for (de=0;de<NumDirEntries;de++) { if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de, offset_base, IFDlength, displacement, section_index, 0, maker_note->tag_table TSRMLS_CC)) { return FALSE; } } ImageInfo->motorola_intel = old_motorola_intel; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE)); #endif return TRUE; }"
"bool Inflator::DecodeBody() { bool blockEnd = false; switch (m_blockType) { case 0:CRYPTOPP_ASSERT(m_reader.BitsBuffered() == 0); while (!m_inQueue.IsEmpty() && !blockEnd) { size_t size; const byte *block = m_inQueue.Spy(size); size = UnsignedMin(m_storedLen, size); CRYPTOPP_ASSERT(size <= 0xffff); OutputString(block, size); m_inQueue.Skip(size); m_storedLen = m_storedLen - (word16)size; if (m_storedLen == 0) blockEnd = true; } break; case 1:case 2:static const unsigned int lengthStarts[] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258}; static const unsigned int lengthExtraBits[] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0}; static const unsigned int distanceStarts[] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577}; static const unsigned int distanceExtraBits[] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13}; const HuffmanDecoder& literalDecoder = GetLiteralDecoder(); const HuffmanDecoder& distanceDecoder = GetDistanceDecoder(); switch (m_nextDecode) { case LITERAL: while (true) { if (!literalDecoder.Decode(m_reader, m_literal)) { m_nextDecode = LITERAL; break; } if (m_literal < 256) OutputByte((byte)m_literal); else if (m_literal == 256){ blockEnd = true; break; } else { if (m_literal > 285) throw BadBlockErr(); unsigned int bits; case LENGTH_BITS: bits = lengthExtraBits[m_literal-257]; if (!m_reader.FillBuffer(bits)) { m_nextDecode = LENGTH_BITS; break; } m_literal = m_reader.GetBits(bits) + lengthStarts[m_literal-257]; case DISTANCE: if (!distanceDecoder.Decode(m_reader, m_distance)) { m_nextDecode = DISTANCE; break; } case DISTANCE_BITS: CRYPTOPP_ASSERT(m_distance < COUNTOF(distanceExtraBits)); bits = (m_distance >= COUNTOF(distanceExtraBits)) ? distanceExtraBits[29] : distanceExtraBits[m_distance]; if (!m_reader.FillBuffer(bits)) { m_nextDecode = DISTANCE_BITS; break; } m_distance = m_reader.GetBits(bits) + distanceStarts[m_distance]; OutputPast(m_literal, m_distance); } } break; default: CRYPTOPP_ASSERT(0); } } if (blockEnd) { if (m_eof) { FlushOutput(); m_reader.SkipBits(m_reader.BitsBuffered()%8); if (m_reader.BitsBuffered()) { SecBlockWithHint<byte, 4> buffer(m_reader.BitsBuffered() / 8); for (unsigned int i=0; i<buffer.size(); i++) buffer[i] = (byte)m_reader.GetBits(8); m_inQueue.Unget(buffer, buffer.size()); } m_state = POST_STREAM; } else m_state = WAIT_HEADER; } return blockEnd; }"
"static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp) { struct hidp_connadd_req ca; struct hidp_conndel_req cd; struct hidp_connlist_req cl; struct hidp_conninfo ci; struct socket *csock; struct socket *isock; int err; BT_DBG(""cmd %x arg %p"", cmd, argp); switch (cmd) { case HIDPCONNADD: if (!capable(CAP_NET_ADMIN)) return -EPERM; if (copy_from_user(&ca, argp, sizeof(ca))) return -EFAULT; csock = sockfd_lookup(ca.ctrl_sock, &err); if (!csock) return err; isock = sockfd_lookup(ca.intr_sock, &err); if (!isock) { sockfd_put(csock); return err; } err = hidp_connection_add(&ca, csock, isock); if (!err && copy_to_user(argp, &ca, sizeof(ca))) err = -EFAULT; sockfd_put(csock); sockfd_put(isock); return err; case HIDPCONNDEL: if (!capable(CAP_NET_ADMIN)) return -EPERM; if (copy_from_user(&cd, argp, sizeof(cd))) return -EFAULT; return hidp_connection_del(&cd); case HIDPGETCONNLIST: if (copy_from_user(&cl, argp, sizeof(cl))) return -EFAULT; if (cl.cnum <= 0) return -EINVAL; err = hidp_get_connlist(&cl); if (!err && copy_to_user(argp, &cl, sizeof(cl))) return -EFAULT; return err; case HIDPGETCONNINFO: if (copy_from_user(&ci, argp, sizeof(ci))) return -EFAULT; err = hidp_get_conninfo(&ci); if (!err && copy_to_user(argp, &ci, sizeof(ci))) return -EFAULT; return err; } return -EINVAL; }"
"static void svm_range_evict_svm_bo_worker(struct work_struct *work) { struct svm_range_bo *svm_bo; struct mm_struct *mm; int r = 0; svm_bo = container_of(work, struct svm_range_bo, eviction_work); if (!svm_bo_ref_unless_zero(svm_bo)) return;  if (mmget_not_zero(svm_bo->eviction_fence->mm)) { mm = svm_bo->eviction_fence->mm; } else { svm_range_bo_unref(svm_bo); return; } mmap_read_lock(mm); spin_lock(&svm_bo->list_lock); while (!list_empty(&svm_bo->range_list) && !r) { struct svm_range *prange = list_first_entry(&svm_bo->range_list, struct svm_range, svm_bo_list); int retries = 3; list_del_init(&prange->svm_bo_list); spin_unlock(&svm_bo->list_lock); pr_debug(""svms 0x%p [0x%lx 0x%lx]\n"", prange->svms, prange->start, prange->last); mutex_lock(&prange->migrate_mutex); do { r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_TTM_EVICTION); } while (!r && prange->actual_loc && --retries); if (!r && prange->actual_loc) pr_info_once(""Migration failed during eviction""); if (!prange->actual_loc) { mutex_lock(&prange->lock); prange->svm_bo = NULL; mutex_unlock(&prange->lock); } mutex_unlock(&prange->migrate_mutex); spin_lock(&svm_bo->list_lock); } spin_unlock(&svm_bo->list_lock); mmap_read_unlock(mm); mmput(mm); dma_fence_signal(&svm_bo->eviction_fence->base); WARN_ONCE(!r && kref_read(&svm_bo->kref) != 1, ""This was not the last reference\n""); svm_range_bo_unref(svm_bo); }"
"void TabHelper::OnInlineWebstoreInstall(content::RenderFrameHost* host, int install_id, int return_route_id, const std::string& webstore_item_id, const GURL& requestor_url, int listeners_mask) { if ((listeners_mask & ~(api::webstore::INSTALL_STAGE_LISTENER | api::webstore::DOWNLOAD_PROGRESS_LISTENER)) != 0 || requestor_url.is_empty()) { NOTREACHED(); return; } ExtensionRegistry* registry = ExtensionRegistry::Get(profile_); if (registry->disabled_extensions().Contains(webstore_item_id) && (ExtensionPrefs::Get(profile_)->GetDisableReasons(webstore_item_id) & Extension::DISABLE_PERMISSIONS_INCREASE) != 0) { extension_reenabler_.reset(); extension_reenabler_ = ExtensionReenabler::PromptForReenable( registry->disabled_extensions().GetByID(webstore_item_id), profile_, web_contents(), requestor_url, base::Bind(&TabHelper::OnReenableComplete, weak_ptr_factory_.GetWeakPtr(), install_id, return_route_id)); } else { WebstoreAPI::Get(profile_)->OnInlineInstallStart( return_route_id, this, webstore_item_id, listeners_mask); WebstoreStandaloneInstaller::Callback callback = base::Bind(&TabHelper::OnInlineInstallComplete, base::Unretained(this), install_id, return_route_id); scoped_refptr<WebstoreInlineInstaller> installer( webstore_inline_installer_factory_->CreateInstaller( web_contents(), host, webstore_item_id, requestor_url, callback)); installer->BeginInstall(); } }"
"static Jsi_RC jsi_ArrayFilterCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) { if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); Jsi_RC rc = JSI_OK; int curlen, nsiz, i, fval, n = 0, maa = 0; Jsi_Obj *obj, *nobj; Jsi_Value *func, *vpargs, *nthis = NULL, *sthis, *nrPtr = NULL; Jsi_Func *fptr = NULL; func = Jsi_ValueArrayIndex(interp, args, 0); if (!Jsi_ValueIsFunction(interp, func))  return Jsi_LogError(""expected function""); sthis = Jsi_ValueArrayIndex(interp, args, 1); if (!sthis) sthis = nthis = Jsi_ValueNew1(interp); obj = _this->d.obj; curlen = Jsi_ObjGetLength(interp, obj);     if (curlen < 0) { Jsi_ObjSetLength(interp, obj, 0); } Jsi_ObjListifyArray(interp, obj); nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY); nsiz = obj->arrCnt; if (nsiz<=0) nsiz = 1; if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) { Jsi_LogError(""index too large: %d"", nsiz); rc = JSI_ERROR; goto bail; } Jsi_ValueMakeArrayObject(interp, ret, nobj); nrPtr = Jsi_ValueNew1(interp); Jsi_Value *vobjs[4]; fptr = func->d.obj->d.fobj->func; maa = (fptr->argnames?fptr->argnames->argCnt:0); if (maa>3) maa = 3; for (i = 0; i < curlen; i++) { if (!obj->arr[i]) continue; vobjs[0] = obj->arr[i]; vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL); vobjs[2] = _this; vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0)); Jsi_IncrRefCount(interp, vpargs); rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, sthis); Jsi_DecrRefCount(interp, vpargs); fval = Jsi_ValueIsTrue(interp, nrPtr); Jsi_ValueMakeUndef(interp, &nrPtr); if( JSI_OK!=rc ) { goto bail; } if (fval) { nobj->arr[n++] = obj->arr[i]; Jsi_IncrRefCount(interp, obj->arr[i]); } } if (nthis) Jsi_DecrRefCount(interp, nthis); Jsi_DecrRefCount(interp, nrPtr); Jsi_ObjSetLength(interp, nobj, n); return JSI_OK; bail: if (nthis) Jsi_DecrRefCount(interp, nthis); if (nrPtr) Jsi_DecrRefCount(interp, nrPtr); Jsi_ValueMakeNull(interp, ret); return rc; }"
"int ProcXSendExtensionEvent(ClientPtr client) { int ret; DeviceIntPtr dev; xEvent *first; XEventClass *list; struct tmask tmp[EMASKSIZE]; REQUEST(xSendExtensionEventReq); REQUEST_AT_LEAST_SIZE(xSendExtensionEventReq); if (stuff->length != bytes_to_int32(sizeof(xSendExtensionEventReq)) + stuff->count + (stuff->num_events * bytes_to_int32(sizeof(xEvent)))) return BadLength; ret = dixLookupDevice(&dev, stuff->deviceid, client, DixWriteAccess); if (ret != Success) return ret; if (stuff->num_events == 0) return ret; first = ((xEvent *) &stuff[1]); if (!((EXTENSION_EVENT_BASE <= first->u.u.type) && (first->u.u.type < lastEvent))) { client->errorValue = first->u.u.type; return BadValue; } list = (XEventClass *) (first + stuff->num_events); if ((ret = CreateMaskFromList(client, list, stuff->count, tmp, dev, X_SendExtensionEvent)) != Success) return ret; ret = (SendEvent(client, dev, stuff->destination, stuff->propagate, (xEvent *) &stuff[1], tmp[stuff->deviceid].mask, stuff->num_events)); return ret; }"
"void DoCompute(OpKernelContext* c) { core::RefCountPtr<Var> v; OP_REQUIRES_OK(c, LookupResource(c, HandleFromInput(c, 0), &v)); Tensor* params = v->tensor(); const Tensor& indices = c->input(1); const Tensor& updates = c->input(2); OP_REQUIRES(c, updates.dims() == 0 || updates.dims() == indices.dims() + params->dims() - 1, errors::InvalidArgument( ""Must have updates.shape = indices.shape + "" ""params.shape[1:] or updates.shape = [], got "", ""updates.shape "", updates.shape().DebugString(), "", indices.shape "", indices.shape().DebugString(), "", params.shape "", params->shape().DebugString())); const int64_t N_big = indices.NumElements(); OP_REQUIRES( c, N_big <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""indices has too many elements for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", N_big, "" > "", std::numeric_limits<Index>::max())); const Index N = static_cast<Index>(N_big); OP_REQUIRES( c, params->dim_size(0) <= std::numeric_limits<Index>::max(), errors::InvalidArgument(""params.shape[0] too large for "", DataTypeString(DataTypeToEnum<Index>::v()), "" indexing: "", params->dim_size(0), "" > "", std::numeric_limits<Index>::max())); if (N > 0) { auto indices_flat = indices.flat<Index>(); auto params_flat = params->flat_outer_dims<T>(); if (TensorShapeUtils::IsScalar(updates.shape())) { const auto update = updates.scalar<T>(); functor::ScatterScalarFunctor<Device, T, Index, op> functor; const Index bad_i = functor(c, c->template eigen_device<Device>(), params_flat, update, indices_flat); OP_REQUIRES(c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params->dim_size(0), "")"")); } else { int64_t num_updates = updates.NumElements(); OP_REQUIRES( c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()), errors::InvalidArgument( ""The shape of indices ("", indices.shape().DebugString(), "") must be a prefix of the shape of updates ("", updates.shape().DebugString(), "")"")); auto updates_flat = updates.shaped<T, 2>({N, num_updates / N}); functor::ScatterFunctor<Device, T, Index, op> functor; const Index bad_i = functor(c, c->template eigen_device<Device>(), params_flat, updates_flat, indices_flat); OP_REQUIRES(c, bad_i < 0, errors::InvalidArgument( ""indices"", SliceDebugString(indices.shape(), bad_i), "" = "", indices_flat(bad_i), "" is not in [0, "", params->dim_size(0), "")"")); } } }"
"sctp_disposition_t sctp_sf_ootb(struct net *net, const struct sctp_endpoint *ep, const struct sctp_association *asoc, const sctp_subtype_t type, void *arg, sctp_cmd_seq_t *commands) { struct sctp_chunk *chunk = arg; struct sk_buff *skb = chunk->skb; sctp_chunkhdr_t *ch; sctp_errhdr_t *err; __u8 *ch_end; int ootb_shut_ack = 0; int ootb_cookie_ack = 0; SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES); ch = (sctp_chunkhdr_t *) chunk->chunk_hdr; do { if (ntohs(ch->length) < sizeof(sctp_chunkhdr_t)) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); if (SCTP_CID_SHUTDOWN_ACK == ch->type) ootb_shut_ack = 1; if (SCTP_CID_ABORT == ch->type) return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); if (SCTP_CID_COOKIE_ACK == ch->type) ootb_cookie_ack = 1; if (SCTP_CID_ERROR == ch->type) { sctp_walk_errors(err, ch) { if (SCTP_ERROR_STALE_COOKIE == err->cause) { ootb_cookie_ack = 1; break; } } } ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length)); if (ch_end > skb_tail_pointer(skb)) return sctp_sf_violation_chunklen(net, ep, asoc, type, arg, commands); ch = (sctp_chunkhdr_t *) ch_end; } while (ch_end < skb_tail_pointer(skb)); if (ootb_shut_ack) return sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands); else if (ootb_cookie_ack) return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands); else return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands); }"
"static struct socket *get_raw_socket(int fd) { struct { struct sockaddr_ll sa; char  buf[MAX_ADDR_LEN]; } uaddr; int r; struct socket *sock = sockfd_lookup(fd, &r); if (!sock) return ERR_PTR(-ENOTSOCK); if (sock->sk->sk_type != SOCK_RAW) { r = -ESOCKTNOSUPPORT; goto err; } r = sock->ops->getname(sock, (struct sockaddr *)&uaddr.sa, 0); if (r < 0) goto err; if (uaddr.sa.sll_family != AF_PACKET) { r = -EPFNOSUPPORT; goto err; } return sock; err: sockfd_put(sock); return ERR_PTR(r); }"
"static void * extract_group_icon_cursor_resource(WinLibrary *fi, WinResource *wr, char *lang, int *ressize, bool is_icon) { Win32CursorIconDir *icondir; Win32CursorIconFileDir *fileicondir; char *memory; int c, size, offset, skipped; icondir = (Win32CursorIconDir *) get_resource_entry(fi, wr, &size); if (icondir == NULL) { return NULL; } RETURN_IF_BAD_POINTER(NULL, icondir->count); skipped = 0; for (c = 0 ; c < icondir->count ; c++) { int level; int iconsize; char name[14]; WinResource *fwr; RETURN_IF_BAD_POINTER(NULL, icondir->entries[c]); snprintf(name, sizeof(name)/sizeof(char), ""-%d"", icondir->entries[c].res_id); fwr = find_resource(fi, (is_icon ? ""-3"" : ""-1""), name, lang, &level); if (fwr == NULL) { warn(_(""%s: could not find `%s' in `%s' resource.""), fi->name, &name[1], (is_icon ? ""group_icon"" : ""group_cursor"")); return NULL; } if (get_resource_entry(fi, fwr, &iconsize) != NULL) { if (iconsize == 0) { warn(_(""%s: icon resource `%s' is empty, skipping""), fi->name, name); skipped++; continue; } if (iconsize != icondir->entries[c].bytes_in_res) { warn(_(""%s: mismatch of size in icon resource `%s' and group (%d vs %d)""), fi->name, name, iconsize, icondir->entries[c].bytes_in_res); } size += iconsize < icondir->entries[c].bytes_in_res ? icondir->entries[c].bytes_in_res : iconsize; if (!is_icon) size -= sizeof(uint16_t)*2; } } offset = sizeof(Win32CursorIconFileDir) + (icondir->count-skipped) * sizeof(Win32CursorIconFileDirEntry); size += offset; *ressize = size; memory = xmalloc(size); fileicondir = (Win32CursorIconFileDir *) memory; fileicondir->reserved = icondir->reserved; fileicondir->type = icondir->type; fileicondir->count = icondir->count - skipped; skipped = 0; for (c = 0 ; c < icondir->count ; c++) { int level; char name[14]; WinResource *fwr; char *data; snprintf(name, sizeof(name)/sizeof(char), ""-%d"", icondir->entries[c].res_id); fwr = find_resource(fi, (is_icon ? ""-3"" : ""-1""), name, lang, &level); if (fwr == NULL) { warn(_(""%s: could not find `%s' in `%s' resource.""), fi->name, &name[1], (is_icon ? ""group_icon"" : ""group_cursor"")); return NULL; } data = get_resource_entry(fi, fwr, &size); if (data == NULL) { return NULL; } if (size == 0) { skipped++; continue; } memcpy(&fileicondir->entries[c-skipped], &icondir->entries[c], sizeof(Win32CursorIconFileDirEntry)-sizeof(uint32_t)); if (!is_icon) { fileicondir->entries[c-skipped].width = icondir->entries[c].res_info.cursor.width; fileicondir->entries[c-skipped].height = icondir->entries[c].res_info.cursor.height / 2; fileicondir->entries[c-skipped].color_count = 0; fileicondir->entries[c-skipped].reserved = 0; } fileicondir->entries[c-skipped].dib_offset = offset; if (size > icondir->entries[c].bytes_in_res) size = icondir->entries[c].bytes_in_res; if (is_icon) { memcpy(&memory[offset], data, size); } else { fileicondir->entries[c-skipped].hotspot_x = ((uint16_t *) data)[0]; fileicondir->entries[c-skipped].hotspot_y = ((uint16_t *) data)[1]; memcpy(&memory[offset], data+sizeof(uint16_t)*2, size-sizeof(uint16_t)*2); offset -= sizeof(uint16_t)*2; } offset += icondir->entries[c].bytes_in_res; } return (void *) memory; }"
"static void dm1105_remove(struct pci_dev *pdev) { struct dm1105_dev *dev = pci_get_drvdata(pdev); struct dvb_adapter *dvb_adapter = &dev->dvb_adapter; struct dvb_demux *dvbdemux = &dev->demux; struct dmx_demux *dmx = &dvbdemux->dmx; dm1105_ir_exit(dev); dmx->close(dmx); dvb_net_release(&dev->dvbnet); if (dev->fe) dvb_unregister_frontend(dev->fe); dmx->disconnect_frontend(dmx); dmx->remove_frontend(dmx, &dev->mem_frontend); dmx->remove_frontend(dmx, &dev->hw_frontend); dvb_dmxdev_release(&dev->dmxdev); dvb_dmx_release(dvbdemux); dvb_unregister_adapter(dvb_adapter); i2c_del_adapter(&dev->i2c_adap); dm1105_hw_exit(dev); free_irq(pdev->irq, dev); pci_iounmap(pdev, dev->io_mem); pci_release_regions(pdev); pci_disable_device(pdev); dm1105_devcount--; kfree(dev); }"
"static Image *ReadPANGOImage(const ImageInfo *image_info, ExceptionInfo *exception) { cairo_font_options_t *font_options; cairo_surface_t *surface; char *caption, *property; cairo_t *cairo_image; const char *option; DrawInfo *draw_info; Image *image; MagickBooleanType status; MemoryInfo *pixel_info; PangoAlignment align; PangoContext *context; PangoFontDescription *description; PangoFontMap *fontmap; PangoGravity gravity; PangoLayout *layout; PangoRectangle extent; PixelInfo fill_color; RectangleInfo page; register unsigned char *p; size_t stride; ssize_t y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); (void) ResetImagePage(image,""0x0+0+0""); if ((image->columns != 0) && (image->rows != 0)) (void) SetImageBackgroundColor(image,exception); option=GetImageOption(image_info,""filename""); if (option == (const char *) NULL) property=InterpretImageProperties((ImageInfo *) image_info,image, image_info->filename,exception); else if (LocaleNCompare(option,""pango:"",6) == 0) property=InterpretImageProperties((ImageInfo *) image_info,image,option+6, exception); else property=InterpretImageProperties((ImageInfo *) image_info,image,option, exception); (void) SetImageProperty(image,""caption"",property,exception); property=DestroyString(property); caption=ConstantString(GetImageProperty(image,""caption"",exception)); fontmap=pango_cairo_font_map_new(); pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(fontmap), image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x); font_options=cairo_font_options_create(); option=GetImageOption(image_info,""pango:hinting""); if (option != (const char *) NULL) { if (LocaleCompare(option,""none"") != 0) cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_NONE); if (LocaleCompare(option,""full"") != 0) cairo_font_options_set_hint_style(font_options,CAIRO_HINT_STYLE_FULL); } context=pango_font_map_create_context(fontmap); pango_cairo_context_set_font_options(context,font_options); cairo_font_options_destroy(font_options); option=GetImageOption(image_info,""pango:language""); if (option != (const char *) NULL) pango_context_set_language(context,pango_language_from_string(option)); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); pango_context_set_base_dir(context,draw_info->direction == RightToLeftDirection ? PANGO_DIRECTION_RTL : PANGO_DIRECTION_LTR); switch (draw_info->gravity) { case NorthGravity: { gravity=PANGO_GRAVITY_NORTH; break; } case NorthWestGravity: case WestGravity: case SouthWestGravity: { gravity=PANGO_GRAVITY_WEST; break; } case NorthEastGravity: case EastGravity: case SouthEastGravity: { gravity=PANGO_GRAVITY_EAST; break; } case SouthGravity: { gravity=PANGO_GRAVITY_SOUTH; break; } default: { gravity=PANGO_GRAVITY_AUTO; break; } } pango_context_set_base_gravity(context,gravity); option=GetImageOption(image_info,""pango:gravity-hint""); if (option != (const char *) NULL) { if (LocaleCompare(option,""line"") == 0) pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_LINE); if (LocaleCompare(option,""natural"") == 0) pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_NATURAL); if (LocaleCompare(option,""strong"") == 0) pango_context_set_gravity_hint(context,PANGO_GRAVITY_HINT_STRONG); } layout=pango_layout_new(context); option=GetImageOption(image_info,""pango:auto-dir""); if (option != (const char *) NULL) pango_layout_set_auto_dir(layout,1); option=GetImageOption(image_info,""pango:ellipsize""); if (option != (const char *) NULL) { if (LocaleCompare(option,""end"") == 0) pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_END); if (LocaleCompare(option,""middle"") == 0) pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_MIDDLE); if (LocaleCompare(option,""none"") == 0) pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_NONE); if (LocaleCompare(option,""start"") == 0) pango_layout_set_ellipsize(layout,PANGO_ELLIPSIZE_START); } option=GetImageOption(image_info,""pango:justify""); if (IsStringTrue(option) != MagickFalse) pango_layout_set_justify(layout,1); option=GetImageOption(image_info,""pango:single-paragraph""); if (IsStringTrue(option) != MagickFalse) pango_layout_set_single_paragraph_mode(layout,1); option=GetImageOption(image_info,""pango:wrap""); if (option != (const char *) NULL) { if (LocaleCompare(option,""char"") == 0) pango_layout_set_wrap(layout,PANGO_WRAP_CHAR); if (LocaleCompare(option,""word"") == 0) pango_layout_set_wrap(layout,PANGO_WRAP_WORD); if (LocaleCompare(option,""word-char"") == 0) pango_layout_set_wrap(layout,PANGO_WRAP_WORD_CHAR); } option=GetImageOption(image_info,""pango:indent""); if (option != (const char *) NULL) pango_layout_set_indent(layout,(int) ((StringToLong(option)* (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)* PANGO_SCALE+DefaultSVGDensity/2)/DefaultSVGDensity+0.5)); switch (draw_info->align) { case CenterAlign: align=PANGO_ALIGN_CENTER; break; case RightAlign: align=PANGO_ALIGN_RIGHT; break; case LeftAlign: align=PANGO_ALIGN_LEFT; break; default: { if (draw_info->gravity == CenterGravity) { align=PANGO_ALIGN_CENTER; break; } align=PANGO_ALIGN_LEFT; break; } } if ((align != PANGO_ALIGN_CENTER) && (draw_info->direction == RightToLeftDirection)) align=(PangoAlignment) (PANGO_ALIGN_LEFT+PANGO_ALIGN_RIGHT-align); option=GetImageOption(image_info,""pango:align""); if (option != (const char *) NULL) { if (LocaleCompare(option,""center"") == 0) align=PANGO_ALIGN_CENTER; if (LocaleCompare(option,""left"") == 0) align=PANGO_ALIGN_LEFT; if (LocaleCompare(option,""right"") == 0) align=PANGO_ALIGN_RIGHT; } pango_layout_set_alignment(layout,align); if (draw_info->font == (char *) NULL) description=pango_font_description_new(); else description=pango_font_description_from_string(draw_info->font); pango_font_description_set_size(description,(int) (PANGO_SCALE* draw_info->pointsize+0.5)); pango_layout_set_font_description(layout,description); pango_font_description_free(description); option=GetImageOption(image_info,""pango:markup""); if ((option != (const char *) NULL) && (IsStringTrue(option) == MagickFalse)) pango_layout_set_text(layout,caption,-1); else { GError *error; error=(GError *) NULL; if (pango_parse_markup(caption,-1,0,NULL,NULL,NULL,&error) == 0) (void) ThrowMagickException(exception,GetMagickModule(),CoderError, error->message,""`%s'"",image_info->filename); pango_layout_set_markup(layout,caption,-1); } pango_layout_context_changed(layout); page.x=0; page.y=0; if (image_info->page != (char *) NULL) (void) ParseAbsoluteGeometry(image_info->page,&page); if (image->columns == 0) { pango_layout_get_extents(layout,NULL,&extent); image->columns=(extent.x+extent.width+PANGO_SCALE/2)/PANGO_SCALE+2*page.x; } else { image->columns-=2*page.x; pango_layout_set_width(layout,(int) ((PANGO_SCALE*image->columns* (image->resolution.x == 0.0 ? DefaultSVGDensity : image->resolution.x)+ DefaultSVGDensity/2)/DefaultSVGDensity+0.5)); } if (image->rows == 0) { pango_layout_get_extents(layout,NULL,&extent); image->rows=(extent.y+extent.height+PANGO_SCALE/2)/PANGO_SCALE+2*page.y; } else { image->rows-=2*page.y; pango_layout_set_height(layout,(int) ((PANGO_SCALE*image->rows* (image->resolution.y == 0.0 ? DefaultSVGDensity : image->resolution.y)+ DefaultSVGDensity/2)/DefaultSVGDensity+0.5)); } status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); stride=(size_t) cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, (int) image->columns); pixel_info=AcquireVirtualMemory(image->rows,stride*sizeof(*pixels)); if (pixel_info == (MemoryInfo *) NULL) { draw_info=DestroyDrawInfo(draw_info); caption=DestroyString(caption); ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info); surface=cairo_image_surface_create_for_data(pixels,CAIRO_FORMAT_ARGB32, (int) image->columns,(int) image->rows,(int) stride); cairo_image=cairo_create(surface); cairo_set_operator(cairo_image,CAIRO_OPERATOR_CLEAR); cairo_paint(cairo_image); cairo_set_operator(cairo_image,CAIRO_OPERATOR_OVER); cairo_translate(cairo_image,page.x,page.y); cairo_set_source_rgba(cairo_image,QuantumScale*draw_info->fill.red, QuantumScale*draw_info->fill.green,QuantumScale*draw_info->fill.blue, QuantumScale*draw_info->fill.alpha); pango_cairo_show_layout(cairo_image,layout); cairo_destroy(cairo_image); cairo_surface_destroy(surface); g_object_unref(layout); g_object_unref(fontmap); (void) SetImageBackgroundColor(image,exception); p=pixels; GetPixelInfo(image,&fill_color); for (y=0; y < (ssize_t) image->rows; y++) { register Quantum *q; register ssize_t x; q=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { double gamma; fill_color.blue=(double) ScaleCharToQuantum(*p++); fill_color.green=(double) ScaleCharToQuantum(*p++); fill_color.red=(double) ScaleCharToQuantum(*p++); fill_color.alpha=(double) ScaleCharToQuantum(*p++); gamma=QuantumScale*fill_color.alpha; gamma=PerceptibleReciprocal(gamma); fill_color.blue*=gamma; fill_color.green*=gamma; fill_color.red*=gamma; CompositePixelOver(image,&fill_color,fill_color.alpha,q,(double) GetPixelAlpha(image,q),q); q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } pixel_info=RelinquishVirtualMemory(pixel_info); draw_info=DestroyDrawInfo(draw_info); caption=DestroyString(caption); return(GetFirstImageInList(image)); }"
"static ssize_t ucma_write(struct file *filp, const char __user *buf, size_t len, loff_t *pos) { struct ucma_file *file = filp->private_data; struct rdma_ucm_cmd_hdr hdr; ssize_t ret; if (len < sizeof(hdr)) return -EINVAL; if (copy_from_user(&hdr, buf, sizeof(hdr))) return -EFAULT; if (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table)) return -EINVAL; if (hdr.in + sizeof(hdr) > len) return -EINVAL; if (!ucma_cmd_table[hdr.cmd]) return -ENOSYS; ret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out); if (!ret) ret = len; return ret; }"
"static int may_create_in_sticky(struct dentry * const dir, struct inode * const inode) { if ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) || (!sysctl_protected_regular && S_ISREG(inode->i_mode)) || likely(!(dir->d_inode->i_mode & S_ISVTX)) || uid_eq(inode->i_uid, dir->d_inode->i_uid) || uid_eq(current_fsuid(), inode->i_uid)) return 0; if (likely(dir->d_inode->i_mode & 0002) || (dir->d_inode->i_mode & 0020 && ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) || (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) { const char *operation = S_ISFIFO(inode->i_mode) ? ""sticky_create_fifo"" : ""sticky_create_regular""; audit_log_path_denied(AUDIT_ANOM_CREAT, operation); return -EACCES; } return 0; }"
"int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info, const char * name, int rep_quick) { int got_error; uint i; ulong length; ha_rows start_records; my_off_t new_header_length,del; File new_file; MI_SORT_PARAM sort_param; MYISAM_SHARE *share=info->s; HA_KEYSEG *keyseg; ulong   *rec_per_key_part; char llbuff[22]; SORT_INFO sort_info; ulonglong UNINIT_VAR(key_map); DBUG_ENTER(""mi_repair_by_sort""); start_records=info->state->records; got_error=1; new_file= -1; new_header_length=(param->testflag & T_UNPACK) ? 0 : share->pack.header_length; if (!(param->testflag & T_SILENT)) { printf(""- recovering (with sort) MyISAM-table '%s'\n"",name); printf(""Data records: %s\n"", llstr(start_records,llbuff)); } param->testflag|=T_REP;  if (info->s->options & (HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD)) param->testflag|=T_CALC_CHECKSUM; bzero((char*)&sort_info,sizeof(sort_info)); bzero((char *)&sort_param, sizeof(sort_param)); if (!(sort_info.key_block= alloc_key_blocks(param, (uint) param->sort_key_blocks, share->base.max_key_block_length)) || init_io_cache(&param->read_cache,info->dfile, (uint) param->read_buffer_length, READ_CACHE,share->pack.header_length,1,MYF(MY_WME)) || (! rep_quick && init_io_cache(&info->rec_cache,info->dfile, (uint) param->write_buffer_length, WRITE_CACHE,new_header_length,1, MYF(MY_WME | MY_WAIT_IF_FULL) & param->myf_rw))) goto err; sort_info.key_block_end=sort_info.key_block+param->sort_key_blocks; info->opt_flag|=WRITE_CACHE_USED; info->rec_cache.file=info->dfile; if (!mi_alloc_rec_buff(info, -1, &sort_param.record) || !mi_alloc_rec_buff(info, -1, &sort_param.rec_buff)) { mi_check_print_error(param, ""Not enough memory for extra record""); goto err; } if (!rep_quick) { if ((new_file= mysql_file_create(mi_key_file_datatmp, fn_format(param->temp_filename, share->data_file_name, """", DATA_TMP_EXT, 2+4), 0, param->tmpfile_createflag, MYF(0))) < 0) { mi_check_print_error(param,""Can't create new tempfile: '%s'"", param->temp_filename); goto err; } if (new_header_length && filecopy(param, new_file,info->dfile,0L,new_header_length, ""datafile-header"")) goto err; if (param->testflag & T_UNPACK) { share->options&= ~HA_OPTION_COMPRESS_RECORD; mi_int2store(share->state.header.options,share->options); } share->state.dellink= HA_OFFSET_ERROR; info->rec_cache.file=new_file; } info->update= (short) (HA_STATE_CHANGED | HA_STATE_ROW_CHANGED); mi_drop_all_indexes(param, info, FALSE); key_map= share->state.key_map; if (param->testflag & T_CREATE_MISSING_KEYS) { key_map= ~key_map; } sort_info.info=info; sort_info.param = param; set_data_file_type(&sort_info, share); sort_param.filepos=new_header_length; sort_info.dupp=0; sort_info.buff=0; param->read_cache.end_of_file=sort_info.filelength= mysql_file_seek(param->read_cache.file, 0L, MY_SEEK_END, MYF(0)); sort_param.wordlist=NULL; init_alloc_root(&sort_param.wordroot, FTPARSER_MEMROOT_ALLOC_SIZE, 0); if (share->data_file_type == DYNAMIC_RECORD) length=max(share->base.min_pack_length+1,share->base.min_block_length); else if (share->data_file_type == COMPRESSED_RECORD) length=share->base.min_block_length; else length=share->base.pack_reclength; sort_info.max_records= ((param->testflag & T_CREATE_MISSING_KEYS) ? info->state->records : (ha_rows) (sort_info.filelength/length+1)); sort_param.key_cmp=sort_key_cmp; sort_param.lock_in_memory=lock_memory; sort_param.tmpdir=param->tmpdir; sort_param.sort_info=&sort_info; sort_param.fix_datafile= (my_bool) (! rep_quick); sort_param.master =1; del=info->state->del; param->glob_crc=0; if (param->testflag & T_CALC_CHECKSUM) sort_param.calc_checksum= 1; rec_per_key_part= param->rec_per_key_part; for (sort_param.key=0 ; sort_param.key < share->base.keys ; rec_per_key_part+=sort_param.keyinfo->keysegs, sort_param.key++) { sort_param.read_cache=param->read_cache; sort_param.keyinfo=share->keyinfo+sort_param.key; sort_param.seg=sort_param.keyinfo->seg; if (! mi_is_key_active(key_map, sort_param.key)) { memcpy((char*) rec_per_key_part, (char*) (share->state.rec_per_key_part + (uint) (rec_per_key_part - param->rec_per_key_part)), sort_param.keyinfo->keysegs*sizeof(*rec_per_key_part)); DBUG_PRINT(""repair"", (""skipping seemingly disabled index #: %u"", sort_param.key)); continue; } if ((!(param->testflag & T_SILENT))) printf (""- Fixing index %d\n"",sort_param.key+1); sort_param.max_pos=sort_param.pos=share->pack.header_length; keyseg=sort_param.seg; bzero((char*) sort_param.unique,sizeof(sort_param.unique)); sort_param.key_length=share->rec_reflength; for (i=0 ; keyseg[i].type != HA_KEYTYPE_END; i++) { sort_param.key_length+=keyseg[i].length; if (keyseg[i].flag & HA_SPACE_PACK) sort_param.key_length+=get_pack_length(keyseg[i].length); if (keyseg[i].flag & (HA_BLOB_PART | HA_VAR_LENGTH_PART)) sort_param.key_length+=2 + test(keyseg[i].length >= 127); if (keyseg[i].flag & HA_NULL_PART) sort_param.key_length++; } info->state->records=info->state->del=share->state.split=0; info->state->empty=0; if (sort_param.keyinfo->flag & HA_FULLTEXT) { uint ft_max_word_len_for_sort=FT_MAX_WORD_LEN_FOR_SORT* sort_param.keyinfo->seg->charset->mbmaxlen; sort_param.key_length+=ft_max_word_len_for_sort-HA_FT_MAXBYTELEN; if (sort_param.keyinfo->parser == &ft_default_parser) { sort_info.max_records= (ha_rows) (sort_info.filelength/ft_min_word_len+1); } else { sort_info.max_records= 10 * max(param->sort_buffer_length, MIN_SORT_BUFFER) / sort_param.key_length; } sort_param.key_read=sort_ft_key_read; sort_param.key_write=sort_ft_key_write; } else { sort_param.key_read=sort_key_read; sort_param.key_write=sort_key_write; } if (_create_index_by_sort(&sort_param, (my_bool) (!(param->testflag & T_VERBOSE)), param->sort_buffer_length)) { param->retry_repair=1; goto err; } sort_param.calc_checksum= 0; free_root(&sort_param.wordroot, MYF(0)); sort_info.max_records= (ha_rows) info->state->records; if (param->testflag & T_STATISTICS) update_key_parts(sort_param.keyinfo, rec_per_key_part, sort_param.unique, param->stats_method == MI_STATS_METHOD_IGNORE_NULLS? sort_param.notnull: NULL, (ulonglong) info->state->records); mi_set_key_active(share->state.key_map, sort_param.key); DBUG_PRINT(""repair"", (""set enabled index #: %u"", sort_param.key)); if (sort_param.fix_datafile) { param->read_cache.end_of_file=sort_param.filepos; if (write_data_suffix(&sort_info,1) || end_io_cache(&info->rec_cache)) goto err; if (param->testflag & T_SAFE_REPAIR) { if (info->state->records+1 < start_records) { info->state->records=start_records; goto err; } } share->state.state.data_file_length = info->state->data_file_length= sort_param.filepos; share->state.version=(ulong) time((time_t*) 0); mysql_file_close(info->dfile, MYF(0)); info->dfile=new_file; share->data_file_type=sort_info.new_data_file_type; share->pack.header_length=(ulong) new_header_length; sort_param.fix_datafile=0; } else info->state->data_file_length=sort_param.max_pos; param->read_cache.file=info->dfile; reinit_io_cache(&param->read_cache,READ_CACHE,share->pack.header_length, 1,1); } if (param->testflag & T_WRITE_LOOP) { (void) fputs(""          \r"",stdout); (void) fflush(stdout); } if (rep_quick && del+sort_info.dupp != info->state->del) { mi_check_print_error(param,""Couldn't fix table with quick recovery: Found wrong number of deleted records""); mi_check_print_error(param,""Run recovery again without -q""); got_error=1; param->retry_repair=1; param->testflag|=T_RETRY_WITHOUT_QUICK; goto err; } if (rep_quick & T_FORCE_UNIQUENESS) { my_off_t skr=info->state->data_file_length+ (share->options & HA_OPTION_COMPRESS_RECORD ? MEMMAP_EXTRA_MARGIN : 0); #ifdef USE_RELOC if (share->data_file_type == STATIC_RECORD && skr < share->base.reloc*share->base.min_pack_length) skr=share->base.reloc*share->base.min_pack_length; #endif if (skr != sort_info.filelength) if (mysql_file_chsize(info->dfile, skr, 0, MYF(0))) mi_check_print_warning(param, ""Can't change size of datafile,  error: %d"", my_errno); } if (param->testflag & T_CALC_CHECKSUM) info->state->checksum=param->glob_crc; if (mysql_file_chsize(share->kfile, info->state->key_file_length, 0, MYF(0))) mi_check_print_warning(param, ""Can't change size of indexfile, error: %d"", my_errno); if (!(param->testflag & T_SILENT)) { if (start_records != info->state->records) printf(""Data records: %s\n"", llstr(info->state->records,llbuff)); if (sort_info.dupp) mi_check_print_warning(param, ""%s records have been removed"", llstr(sort_info.dupp,llbuff)); } got_error=0; if (&share->state.state != info->state) memcpy( &share->state.state, info->state, sizeof(*info->state)); err: got_error|= flush_blocks(param, share->key_cache, share->kfile); (void) end_io_cache(&info->rec_cache); if (!got_error) { if (new_file >= 0) { mysql_file_close(new_file, MYF(0)); info->dfile=new_file= -1; if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT, (param->testflag & T_BACKUP_DATA ? MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) || mi_open_datafile(info,share,name,-1)) got_error=1; } } if (got_error) { if (! param->error_printed) mi_check_print_error(param,""%d when fixing table"",my_errno); if (new_file >= 0) { (void) mysql_file_close(new_file, MYF(0)); (void) mysql_file_delete(mi_key_file_datatmp, param->temp_filename, MYF(MY_WME)); if (info->dfile == new_file)  if (unlikely(mi_open_datafile(info, share, name, -1))) param->retry_repair= 0;  } mi_mark_crashed_on_repair(info); } else if (key_map == share->state.key_map) share->state.changed&= ~STATE_NOT_OPTIMIZED_KEYS; share->state.changed|=STATE_NOT_SORTED_PAGES; my_free(mi_get_rec_buff_ptr(info, sort_param.rec_buff)); my_free(mi_get_rec_buff_ptr(info, sort_param.record)); my_free(sort_info.key_block); my_free(sort_info.ft_buf); my_free(sort_info.buff); (void) end_io_cache(&param->read_cache); info->opt_flag&= ~(READ_CACHE_USED | WRITE_CACHE_USED); if (!got_error && (param->testflag & T_UNPACK)) { share->state.header.options[0]&= (uchar) ~HA_OPTION_COMPRESS_RECORD; share->pack.header_length=0; } DBUG_RETURN(got_error); }"
"static int rotateImage(uint16_t rotation, struct image_data *image, uint32_t *img_width, uint32_t *img_length, unsigned char **ibuff_ptr, size_t *rot_buf_size) { int shift_width; uint32_t bytes_per_pixel, bytes_per_sample; uint32_t row, rowsize, src_offset, dst_offset; uint32_t i, col, width, length; uint32_t colsize, buffsize, col_offset, pix_offset; unsigned char *ibuff; unsigned char *src; unsigned char *dst; uint16_t spp, bps; float res_temp; unsigned char *rbuff = NULL; width = *img_width; length = *img_length; spp = image->spp; bps = image->bps; rowsize = ((bps * spp * width) + 7) / 8; colsize = ((bps * spp * length) + 7) / 8; if ((colsize * width) > (rowsize * length)) buffsize = (colsize + 1) * width; else buffsize = (rowsize + 1) * length; bytes_per_sample = (bps + 7) / 8; bytes_per_pixel = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; switch (rotation) { case 0: case 360: return (0); case 90: case 180: case 270: break; default: TIFFError(""rotateImage"", ""Invalid rotation angle %"" PRIu16, rotation); return (-1); } if (!(rbuff = (unsigned char *)limitMalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES))) { TIFFError(""rotateImage"", ""Unable to allocate rotation buffer of %1u bytes"", buffsize + NUM_BUFF_OVERSIZE_BYTES); return (-1); } _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES); if (rot_buf_size != NULL) *rot_buf_size = buffsize; ibuff = *ibuff_ptr; switch (rotation) { case 180: if ((bps % 8) == 0)  { src = ibuff; pix_offset = (spp * bps) / 8; for (row = 0; row < length; row++) { dst_offset = (length - row - 1) * rowsize; for (col = 0; col < width; col++) { col_offset = (width - col - 1) * pix_offset; dst = rbuff + dst_offset + col_offset; for (i = 0; i < bytes_per_pixel; i++) *dst++ = *src++; } } } else {  for (row = 0; row < length; row++) { src_offset = row * rowsize; dst_offset = (length - row - 1) * rowsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (reverseSamples8bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (reverseSamples16bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (reverseSamples24bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (reverseSamples32bits(spp, bps, width, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; break; case 90: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = ((length - 1) * rowsize) + (col * bytes_per_pixel); dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src -= rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = (length - 1) * rowsize; dst_offset = col * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; case 270: if ((bps % 8) == 0)  { for (col = 0; col < width; col++) { src_offset = col * bytes_per_pixel; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; for (row = length; row > 0; row--) { for (i = 0; i < bytes_per_pixel; i++) *dst++ = *(src + i); src += rowsize; } } } else {  for (col = 0; col < width; col++) { src_offset = 0; dst_offset = (width - col - 1) * colsize; src = ibuff + src_offset; dst = rbuff + dst_offset; switch (shift_width) { case 1: if (bps == 1) { if (rotateContigSamples8bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; } if (rotateContigSamples16bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; case 3: case 4: case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, length, col, src, dst)) { _TIFFfree(rbuff); return (-1); } break; default: TIFFError(""rotateImage"", ""Unsupported bit depth %"" PRIu16, bps); _TIFFfree(rbuff); return (-1); } } } _TIFFfree(ibuff); *(ibuff_ptr) = rbuff; *img_width = length; *img_length = width; image->width = length; image->length = width; res_temp = image->xres; image->xres = image->yres; image->yres = res_temp; break; default: break; } return (0); }"
"void Compute(OpKernelContext *ctx) override { const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t, *b_values_t, *b_shape_t; OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t)); OP_REQUIRES( ctx, TensorShapeUtils::IsMatrix(a_indices_t->shape()) && TensorShapeUtils::IsMatrix(b_indices_t->shape()), errors::InvalidArgument(""Inputs a_indices and b_indices should be "" ""matrices but received shapes: "", a_indices_t->shape().DebugString(), "", "", b_indices_t->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_values_t->shape()) && TensorShapeUtils::IsVector(b_values_t->shape()), errors::InvalidArgument( ""Inputs a_values and b_values should be vectors "" ""but received shapes: "", a_values_t->shape().DebugString(), "" and "", b_values_t->shape().DebugString())); const int64 a_nnz = a_indices_t->dim_size(0); const int64 b_nnz = b_indices_t->dim_size(0); const auto a_values = a_values_t->vec<T>(); const auto b_values = b_values_t->vec<T>(); OP_REQUIRES( ctx, a_values.size() == a_nnz && b_values.size() == b_nnz, errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz, "" non-empty input values, got "", a_values.size(), "" and "", b_values.size())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_shape_t->shape()) && TensorShapeUtils::IsVector(b_shape_t->shape()), errors::InvalidArgument( ""Input shapes should be a vector but received shapes "", a_shape_t->shape().DebugString(), "" and "", b_shape_t->shape().DebugString())); OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t), errors::InvalidArgument( ""Operands do not have the same ranks; got shapes: "", a_shape_t->SummarizeValue(10), "" and "", b_shape_t->SummarizeValue(10))); const auto a_shape = a_shape_t->flat<int64>(); const auto b_shape = b_shape_t->flat<int64>(); for (int i = 0; i < a_shape_t->NumElements(); ++i) { OP_REQUIRES(ctx, a_shape(i) == b_shape(i), errors::InvalidArgument(""Operands' shapes do not match: got "", a_shape(i), "" and "", b_shape(i), "" for dimension "", i)); } OP_REQUIRES( ctx, a_indices_t->dim_size(1) == b_indices_t->dim_size(1), errors::InvalidArgument( ""Indices' dimensions do not match: got "", a_indices_t->dim_size(1), "" and "", b_indices_t->dim_size(1), "" for the second dimension."")); const int num_dims = a_indices_t->dim_size(1); const auto a_indices_mat = a_indices_t->matrix<int64>(); const auto b_indices_mat = b_indices_t->matrix<int64>(); std::vector<T> a_augmented_values, b_augmented_values; std::vector<std::pair<bool, int64>> entries_to_copy;      UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat, b_values, b_nnz, num_dims, &a_augmented_values, &b_augmented_values, &entries_to_copy); const int64 sum_nnz = a_augmented_values.size(); Tensor *output_indices_t, *output_values_t; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}), &output_indices_t)); OP_REQUIRES_OK( ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t)); auto output_indices_mat = output_indices_t->matrix<int64>(); for (int64 i = 0; i < sum_nnz; ++i) { const bool from_a = entries_to_copy[i].first; const int64 idx = entries_to_copy[i].second; output_indices_mat.chip<0>(i) = from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx); } using UnalignedTensorMap = Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>, Eigen::Unaligned>; auto a_augmented_values_t = UnalignedTensorMap(a_augmented_values.data(), sum_nnz); auto b_augmented_values_t = UnalignedTensorMap(b_augmented_values.data(), sum_nnz); output_values_t->flat<T>().device(ctx->eigen_device<Device>()) = a_augmented_values_t.binaryExpr(b_augmented_values_t, typename Functor::func()); }"
"int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type, void *insn, int insn_len) { int r = EMULATION_OK; struct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt; init_emulate_ctxt(vcpu); if (!(emulation_type & EMULTYPE_SKIP) && kvm_vcpu_check_breakpoint(vcpu, &r)) return r; r = x86_decode_insn(ctxt, insn, insn_len, emulation_type); trace_kvm_emulate_insn_start(vcpu); ++vcpu->stat.insn_emulation; return r; }"
"int ip_ra_control(struct sock *sk, unsigned char on, void (*destructor)(struct sock *)) { struct ip_ra_chain *ra, *new_ra; struct ip_ra_chain __rcu **rap; struct net *net = sock_net(sk); if (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW) return -EINVAL; new_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL; mutex_lock(&net->ipv4.ra_mutex); for (rap = &net->ipv4.ra_chain; (ra = rcu_dereference_protected(*rap, lockdep_is_held(&net->ipv4.ra_mutex))) != NULL; rap = &ra->next) { if (ra->sk == sk) { if (on) { mutex_unlock(&net->ipv4.ra_mutex); kfree(new_ra); return -EADDRINUSE; } ra->sk = NULL; RCU_INIT_POINTER(*rap, ra->next); mutex_unlock(&net->ipv4.ra_mutex); if (ra->destructor) ra->destructor(sk); ra->saved_sk = sk; call_rcu(&ra->rcu, ip_ra_destroy_rcu); return 0; } } if (!new_ra) { mutex_unlock(&net->ipv4.ra_mutex); return -ENOBUFS; } new_ra->sk = sk; new_ra->destructor = destructor; RCU_INIT_POINTER(new_ra->next, ra); rcu_assign_pointer(*rap, new_ra); sock_hold(sk); mutex_unlock(&net->ipv4.ra_mutex); return 0; }"
"static void janus_voicemail_session_free(const janus_refcount *session_ref) { janus_voicemail_session *session = janus_refcount_containerof(session_ref, janus_voicemail_session, ref); janus_refcount_decrease(&session->handle->ref); g_free(session); }"
"static bool states_equal(struct bpf_verifier_env *env, struct bpf_verifier_state *old, struct bpf_verifier_state *cur) { int i; if (old->curframe != cur->curframe) return false; for (i = 0; i <= old->curframe; i++) { if (old->frame[i]->callsite != cur->frame[i]->callsite) return false; if (!func_states_equal(old->frame[i], cur->frame[i])) return false; } return true; }"
"static int winding_mono_cubic(const SkPoint pts[], SkScalar x, SkScalar y, int* onCurveCount) { SkScalar y0 = pts[0].fY; SkScalar y3 = pts[3].fY; int dir = 1; if (y0 > y3) { SkTSwap(y0, y3); dir = -1; } if (y < y0 || y > y3) { return 0; } if (checkOnCurve(x, y, pts[0], pts[3])) { *onCurveCount += 1; return 0; } if (y == y3) { return 0; } SkScalar min, max; find_minmax<4>(pts, &min, &max); if (x < min) { return 0; } if (x > max) { return dir; } SkScalar t; SkAssertResult(SkCubicClipper::ChopMonoAtY(pts, y, &t)); SkScalar xt = eval_cubic_pts(pts[0].fX, pts[1].fX, pts[2].fX, pts[3].fX, t); if (SkScalarNearlyEqual(xt, x)) { if (x != pts[3].fX || y != pts[3].fY) {              *onCurveCount += 1; return 0; } } return xt < x ? dir : 0; }"
"int sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen) { struct sock *sk = sock->sk; union { int val; struct linger ling; struct timeval tm; } v; int lv = sizeof(int); int len; if (get_user(len, optlen)) return -EFAULT; if (len < 0) return -EINVAL; memset(&v, 0, sizeof(v)); switch (optname) { case SO_DEBUG: v.val = sock_flag(sk, SOCK_DBG); break; case SO_DONTROUTE: v.val = sock_flag(sk, SOCK_LOCALROUTE); break; case SO_BROADCAST: v.val = !!sock_flag(sk, SOCK_BROADCAST); break; case SO_SNDBUF: v.val = sk->sk_sndbuf; break; case SO_RCVBUF: v.val = sk->sk_rcvbuf; break; case SO_REUSEADDR: v.val = sk->sk_reuse; break; case SO_KEEPALIVE: v.val = !!sock_flag(sk, SOCK_KEEPOPEN); break; case SO_TYPE: v.val = sk->sk_type; break; case SO_PROTOCOL: v.val = sk->sk_protocol; break; case SO_DOMAIN: v.val = sk->sk_family; break; case SO_ERROR: v.val = -sock_error(sk); if (v.val == 0) v.val = xchg(&sk->sk_err_soft, 0); break; case SO_OOBINLINE: v.val = !!sock_flag(sk, SOCK_URGINLINE); break; case SO_NO_CHECK: v.val = sk->sk_no_check; break; case SO_PRIORITY: v.val = sk->sk_priority; break; case SO_LINGER: lv= sizeof(v.ling); v.ling.l_onoff= !!sock_flag(sk, SOCK_LINGER); v.ling.l_linger= sk->sk_lingertime / HZ; break; case SO_BSDCOMPAT: sock_warn_obsolete_bsdism(""getsockopt""); break; case SO_TIMESTAMP: v.val = sock_flag(sk, SOCK_RCVTSTAMP) && !sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPNS: v.val = sock_flag(sk, SOCK_RCVTSTAMPNS); break; case SO_TIMESTAMPING: v.val = 0; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE)) v.val |= SOF_TIMESTAMPING_TX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_TX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_HARDWARE)) v.val |= SOF_TIMESTAMPING_RX_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RX_SOFTWARE)) v.val |= SOF_TIMESTAMPING_RX_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) v.val |= SOF_TIMESTAMPING_SOFTWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE)) v.val |= SOF_TIMESTAMPING_SYS_HARDWARE; if (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE)) v.val |= SOF_TIMESTAMPING_RAW_HARDWARE; break; case SO_RCVTIMEO: lv = sizeof(struct timeval); if (sk->sk_rcvtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_rcvtimeo / HZ; v.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ; } break; case SO_SNDTIMEO: lv = sizeof(struct timeval); if (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) { v.tm.tv_sec = 0; v.tm.tv_usec = 0; } else { v.tm.tv_sec = sk->sk_sndtimeo / HZ; v.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ; } break; case SO_RCVLOWAT: v.val = sk->sk_rcvlowat; break; case SO_SNDLOWAT: v.val = 1; break; case SO_PASSCRED: v.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0; break; case SO_PEERCRED: { struct ucred peercred; if (len > sizeof(peercred)) len = sizeof(peercred); cred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred); if (copy_to_user(optval, &peercred, len)) return -EFAULT; goto lenout; } case SO_PEERNAME: { char address[128]; if (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2)) return -ENOTCONN; if (lv < len) return -EINVAL; if (copy_to_user(optval, address, len)) return -EFAULT; goto lenout; } case SO_ACCEPTCONN: v.val = sk->sk_state == TCP_LISTEN; break; case SO_PASSSEC: v.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0; break; case SO_PEERSEC: return security_socket_getpeersec_stream(sock, optval, optlen, len); case SO_MARK: v.val = sk->sk_mark; break; case SO_RXQ_OVFL: v.val = !!sock_flag(sk, SOCK_RXQ_OVFL); break; case SO_WIFI_STATUS: v.val = !!sock_flag(sk, SOCK_WIFI_STATUS); break; case SO_PEEK_OFF: if (!sock->ops->set_peek_off) return -EOPNOTSUPP; v.val = sk->sk_peek_off; break; case SO_NOFCS: v.val = !!sock_flag(sk, SOCK_NOFCS); break; default: return -ENOPROTOOPT; } if (len > lv) len = lv; if (copy_to_user(optval, &v, len)) return -EFAULT; lenout: if (put_user(len, optlen)) return -EFAULT; return 0; }"
"static int hid_bigben_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect) { struct hid_device *hid = input_get_drvdata(dev); struct bigben_device *bigben = hid_get_drvdata(hid); u8 right_motor_on; u8 left_motor_force; if (!bigben) { hid_err(hid, ""no device data\n""); return 0; } if (effect->type != FF_RUMBLE) return 0; right_motor_on   = effect->u.rumble.weak_magnitude ? 1 : 0; left_motor_force = effect->u.rumble.strong_magnitude / 256; if (right_motor_on != bigben->right_motor_on || left_motor_force != bigben->left_motor_force) { bigben->right_motor_on   = right_motor_on; bigben->left_motor_force = left_motor_force; bigben->work_ff = true; schedule_work(&bigben->worker); } return 0; }"
"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc, UWORD32 u4_total_coeff_trail_one,  dec_bit_stream_t *ps_bitstrm) { UWORD32 u4_total_zeroes; WORD32 i; UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer; UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16; WORD16 i2_level_arr[16]; tu_sblk4x4_coeff_data_t *ps_tu_4x4; WORD16 *pi2_coeff_data; dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle; ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data; ps_tu_4x4->u2_sig_coeff_map = 0; pi2_coeff_data = &ps_tu_4x4->ai2_level[0]; i = u4_total_coeff - 1; if(u4_trailing_ones) { UWORD32 u4_signs, u4_cnt = u4_trailing_ones; WORD16 (*ppi2_trlone_lkup)[3] = (WORD16 (*)[3])gai2_ih264d_trailing_one_level; WORD16 *pi2_trlone_lkup; GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt); pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs]; while(u4_cnt--) i2_level_arr[i--] = *pi2_trlone_lkup++; } if(i >= 0) { UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size; WORD32 u2_lev_code, u2_abs_value; UWORD32 u4_lev_prefix; FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset, pu4_bitstrm_buf); u2_lev_code = MIN(15, u4_lev_prefix); u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2; if(14 == u4_lev_prefix) u4_lev_suffix_size = 4; else if(15 <= u4_lev_prefix) { u2_lev_code += 15; u4_lev_suffix_size = u4_lev_prefix - 3; } else u4_lev_suffix_size = 0; if(16 <= u4_lev_prefix) { u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096); } if(u4_lev_suffix_size) { GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf, u4_lev_suffix_size); u2_lev_code += u4_lev_suffix; } u2_abs_value = (u2_lev_code + 2) >> 1; i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value; u4_suffix_len = (u2_abs_value > 3) ? 2 : 1; while(i >= 0) { FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset, pu4_bitstrm_buf); u4_lev_suffix_size = (15 <= u4_lev_prefix) ? (u4_lev_prefix - 3) : u4_suffix_len; GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf, u4_lev_suffix_size); u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len) + u4_lev_suffix; if(16 <= u4_lev_prefix) { u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096); } u2_abs_value = (u2_lev_code + 2) >> 1; i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value; u4_suffix_len += (u4_suffix_len < 6) ? (u2_abs_value > (3 << (u4_suffix_len - 1))) : 0; } } { UWORD32 u4_index; const UWORD8 (*ppu1_total_zero_lkup)[64] = (const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10; NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6); u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index]; FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4)); u4_total_zeroes &= 0xf; } { const UWORD8 *pu1_table_runbefore; UWORD32 u4_run; WORD32 k; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc; WORD32 u4_zeroes_left = u4_total_zeroes; k = u4_total_coeff - 1; while((u4_zeroes_left > 6) && k) { UWORD32 u4_code; NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3); if(u4_code != 0) { FLUSHBITS(u4_bitstream_offset, 3); u4_run = (7 - u4_code); } else { FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 11); u4_run = (4 + u4_code); } SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos); *pi2_coeff_data++ = i2_level_arr[k--]; u4_zeroes_left -= u4_run; u4_scan_pos -= (u4_run + 1); } pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before; while((u4_zeroes_left > 0) && k) { UWORD32 u4_code; NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3); u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)]; u4_run = u4_code >> 2; FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03)); SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos); *pi2_coeff_data++ = i2_level_arr[k--]; u4_zeroes_left -= u4_run; u4_scan_pos -= (u4_run + 1); } if(u4_zeroes_left < 0) return -1; while(k >= 0) { SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos); *pi2_coeff_data++ = i2_level_arr[k--]; u4_scan_pos--; } } { WORD32 offset; offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4; offset = ALIGN4(offset); ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset); } ps_bitstrm->u4_ofst = u4_bitstream_offset; return 0; }"
"ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s) { int ws_pending, nl, in_group = 0; #ifdef EXACT_ADDRESS const char *begin; #endif const char *ps; char comment[LONG_STRING], phrase[LONG_STRING]; size_t phraselen = 0, commentlen = 0; ADDRESS *cur, *last = NULL; RFC822Error = 0; last = top; while (last && last->next) last = last->next; ws_pending = is_email_wsp (*s); if ((nl = mutt_strlen (s))) nl = s[nl - 1] == '\n'; s = skip_email_wsp(s); #ifdef EXACT_ADDRESS begin = s; #endif while (*s) { if (*s == ',') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif commentlen = 0; phraselen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == '(') { if (commentlen && commentlen < sizeof (comment) - 1) comment[commentlen++] = ' '; if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '""') { if (phraselen && phraselen < sizeof (phrase) - 1) phrase[phraselen++] = ' '; if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '[') { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if (phraselen < sizeof (phrase) - 1) phrase[phraselen++] = '['; if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == ':') { cur = rfc822_new_address (); terminate_buffer (phrase, phraselen); cur->mailbox = safe_strdup (phrase); cur->group = 1; in_group = 1; if (last) last->next = cur; else top = cur; last = cur; #ifdef EXACT_ADDRESS last->val = mutt_substrdup (begin, s); #endif phraselen = 0; commentlen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == ';') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif if (last && in_group) { last->next = rfc822_new_address (); last = last->next; } in_group = 0; phraselen = 0; commentlen = 0; #ifdef EXACT_ADDRESS begin = s; #endif s++; } else if (*s == '<') { terminate_buffer (phrase, phraselen); cur = rfc822_new_address (); if (phraselen) cur->personal = safe_strdup (phrase); if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL) { rfc822_free_address (&top); rfc822_free_address (&cur); return NULL; } if (last) last->next = cur; else top = cur; last = cur; phraselen = 0; commentlen = 0; s = ps; } else { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } ws_pending = is_email_wsp(*s); s = skip_email_wsp(s); } if (phraselen) { terminate_buffer (phrase, phraselen); terminate_buffer (comment, commentlen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl); #endif return top; }"
"void simplestring_addn(simplestring* target, const char* source, int add_len) { if(target && source) { if(!target->str) { simplestring_init_str(target); } if(target->len + add_len + 1 > target->size) { int newsize = target->len + add_len + 1; int incr = target->size * 2; newsize = newsize - (newsize % incr) + incr; target->str = (char*)realloc(target->str, newsize); target->size = target->str ? newsize : 0; } if(target->str) { if(add_len) { memcpy(target->str + target->len, source, add_len); } target->len += add_len; target->str[target->len] = 0;  } } }"
"static int unzzip_cat (int argc, char ** argv, int extract) { int done; int argn; ZZIP_MEM_DISK* disk; if (argc == 1) { printf (__FILE__"" version ""ZZIP_PACKAGE"" ""ZZIP_VERSION""\n""); return EXIT_OK;  } disk = zzip_mem_disk_open (argv[1]); if (! disk) { DBG3(""disk_open failed [%i] %s"", errno, strerror(errno)); perror(argv[1]); return exitcode(errno); } if (argc == 2) {   ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk); DBG2(""findfirst %p\n"", entry); for (; entry ; entry = zzip_mem_disk_findnext(disk, entry)) { char* name = zzip_mem_entry_to_name (entry); FILE* out = stdout; if (extract) out = create_fopen(name, ""wb"", 1); if (! out) { if (errno != EISDIR) done = EXIT_ERRORS; continue; } unzzip_mem_disk_cat_file (disk, name, out); if (extract) fclose(out); } return done; } if (argc == 3 && !extract) {   ZZIP_MEM_ENTRY* entry = 0; while ((entry = zzip_mem_disk_findmatch(disk, argv[2], entry, 0, 0))) { unzzip_mem_entry_fprint (disk, entry, stdout); } return 0; } for (argn=1; argn < argc; argn++) {    ZZIP_MEM_ENTRY* entry = zzip_mem_disk_findfirst(disk); for (; entry ; entry = zzip_mem_disk_findnext(disk, entry)) { char* name = zzip_mem_entry_to_name (entry); if (! _zzip_fnmatch (argv[argn], name,  _zzip_FNM_NOESCAPE|_zzip_FNM_PATHNAME|_zzip_FNM_PERIOD)) { FILE* out = stdout; if (extract) out = create_fopen(name, ""wb"", 1); if (! out) { if (errno != EISDIR) done = EXIT_ERRORS; continue; } unzzip_mem_disk_cat_file (disk, name, out); if (extract) fclose(out); break;  } } } return done; }"
"static guint32 s7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb, packet_info *pinfo, proto_tree *data_tree, guint8 type,                 guint8 subfunc,              guint32 offset)              { guint32 start_offset; guint32 asc_start_offset; guint32 msg_obj_start_offset; guint32 ev_id; proto_item *msg_item = NULL; proto_tree *msg_item_tree = NULL; proto_item *msg_obj_item = NULL; proto_tree *msg_obj_item_tree = NULL; proto_item *msg_work_item = NULL; proto_tree *msg_work_item_tree = NULL; guint8 nr_objects; guint8 i; guint8 syntax_id; guint8 nr_of_additional_values; guint8 signalstate; guint8 sig_nr; guint8 ret_val; guint8 querytype; guint8 varspec_length; start_offset = offset; msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA); msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message); if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) { msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA); msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp); offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE); } proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; nr_objects = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects); offset += 1; for (i = 1; i <= nr_objects; i++) { msg_obj_start_offset = offset; msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA); msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object); proto_item_append_text(msg_obj_item_tree, "" [%d]"", i); if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) { proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; varspec_length = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length); offset += 1; syntax_id = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id); offset += 1; switch (syntax_id) { case S7COMM_SYNTAXID_ALARM_LOCKFREESET: case S7COMM_SYNTAXID_ALARM_INDSET: case S7COMM_SYNTAXID_NOTIFY_INDSET: case S7COMM_SYNTAXID_ALARM_ACKSET: nr_of_additional_values = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values); offset += 1; ev_id = tvb_get_ntohl(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id); offset += 4; proto_item_append_text(msg_obj_item_tree, "": EventID=0x%08x"", ev_id); col_append_fstr(pinfo->cinfo, COL_INFO, "" EventID=0x%08x"", ev_id); if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { signalstate = tvb_get_guint8(tvb, offset); proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; if (signalstate > 0) { col_append_fstr(pinfo->cinfo, COL_INFO, "" On=[""); for (sig_nr = 0; sig_nr < 8; sig_nr++) { if (signalstate & 0x01) { signalstate >>= 1; if (signalstate == 0) { col_append_fstr(pinfo->cinfo, COL_INFO, ""SIG_%d"", sig_nr + 1); } else { col_append_fstr(pinfo->cinfo, COL_INFO, ""SIG_%d,"", sig_nr + 1); } } else { signalstate >>= 1; } } col_append_fstr(pinfo->cinfo, COL_INFO, ""]""); } proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { if (nr_of_additional_values > 0) { asc_start_offset = offset; msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA); msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value); offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset); proto_item_set_len(msg_work_item_tree, offset - asc_start_offset); } } break; case S7COMM_SYNTAXID_ALARM_QUERYREQSET: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; querytype = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype); offset += 1; proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; ev_id = tvb_get_ntohl(tvb, offset); switch (querytype) { case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN); col_append_fstr(pinfo->cinfo, COL_INFO, "" ByAlarmtype=%s"", val_to_str(ev_id, alarm_message_query_alarmtype_names, ""Unknown Alarmtype: %u"")); break; case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN); col_append_fstr(pinfo->cinfo, COL_INFO, "" ByEventID=0x%08x"", ev_id); break; default: break; } offset += 4; break; default: offset += (varspec_length - 1); break; } } else if (type == S7COMM_UD_TYPE_RES) { ret_val = tvb_get_guint8(tvb, offset); proto_item_append_text(msg_obj_item_tree, "": (%s)"", val_to_str(ret_val, s7comm_item_return_valuenames, ""Unknown code: 0x%02x"")); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val); offset += 1; } proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset); } proto_item_set_len(msg_item_tree, offset - start_offset); return offset; }"
"static bool unpack_file_for_central_directory_index(off_t central_directory_index, const MappedFile& file) { enum CentralFileDirectoryHeaderOffsets { CFDHCompressionMethodOffset = 10, CFDHLocalFileHeaderIndexOffset = 42, }; enum LocalFileHeaderOffsets { LFHCompressionMethodOffset = 8, LFHCompressedSizeOffset = 18, LFHFileNameLengthOffset = 26, LFHExtraFieldLengthOffset = 28, LFHFileNameBaseOffset = 30, }; enum CompressionMethod { None = 0, Shrunk = 1, Factor1 = 2, Factor2 = 3, Factor3 = 4, Factor4 = 5, Implode = 6, Deflate = 8, EnhancedDeflate = 9, PKWareDCLImplode = 10, BZIP2 = 12, LZMA = 14, TERSE = 18, LZ77 = 19, }; u8 buffer[4]; if (!seek_and_read(buffer, file, central_directory_index + CFDHLocalFileHeaderIndexOffset, 4)) return false; off_t local_file_header_index = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressionMethodOffset, 2)) return false; auto compression_method = buffer[1] << 8 | buffer[0]; VERIFY(compression_method == None); if (!seek_and_read(buffer, file, local_file_header_index + LFHCompressedSizeOffset, 4)) return false; off_t compressed_file_size = buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHFileNameLengthOffset, 2)) return false; off_t file_name_length = buffer[1] << 8 | buffer[0]; if (!seek_and_read(buffer, file, local_file_header_index + LFHExtraFieldLengthOffset, 2)) return false; off_t extra_field_length = buffer[1] << 8 | buffer[0]; char file_name[file_name_length + 1]; if (!seek_and_read((u8*)file_name, file, local_file_header_index + LFHFileNameBaseOffset, file_name_length)) return false; file_name[file_name_length] = '\0'; if (file_name[file_name_length - 1] == '/') { if (mkdir(file_name, 0755) < 0) { perror(""mkdir""); return false; } } else { auto new_file = Core::File::construct(String { file_name }); if (!new_file->open(Core::IODevice::WriteOnly)) { fprintf(stderr, ""Can't write file %s: %s\n"", file_name, new_file->error_string()); return false; } printf("" extracting: %s\n"", file_name); u8 raw_file_contents[compressed_file_size]; if (!seek_and_read(raw_file_contents, file, local_file_header_index + LFHFileNameBaseOffset + file_name_length + extra_field_length, compressed_file_size)) return false; if (!new_file->write(raw_file_contents, compressed_file_size)) { fprintf(stderr, ""Can't write file contents in %s: %s\n"", file_name, new_file->error_string()); return false; } if (!new_file->close()) { fprintf(stderr, ""Can't close file %s: %s\n"", file_name, new_file->error_string()); return false; } } return true; }"
"static void interface_release_resource(QXLInstance *sin, QXLReleaseInfoExt ext) { PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl); QXLReleaseRing *ring; uint64_t *item, id; if (ext.group_id == MEMSLOT_GROUP_HOST) { QXLCommandExt *cmdext = (void *)(intptr_t)(ext.info->id); SimpleSpiceUpdate *update; g_assert(cmdext->cmd.type == QXL_CMD_DRAW); update = container_of(cmdext, SimpleSpiceUpdate, ext); qemu_spice_destroy_update(&qxl->ssd, update); return; } ring = &qxl->ram->release_ring; SPICE_RING_PROD_ITEM(qxl, ring, item); if (!item) { return; } if (*item == 0) { id = ext.info->id; ext.info->next = 0; qxl_ram_set_dirty(qxl, &ext.info->next); *item = id; qxl_ring_set_dirty(qxl); } else { qxl->last_release->next = ext.info->id; qxl_ram_set_dirty(qxl, &qxl->last_release->next); ext.info->next = 0; qxl_ram_set_dirty(qxl, &ext.info->next); } qxl->last_release = ext.info; qxl->num_free_res++; trace_qxl_ring_res_put(qxl->id, qxl->num_free_res); qxl_push_free_res(qxl, 0); }"
"mp_err s_mp_mul_high_digs(const mp_int *a, const mp_int *b, mp_int *c, int digs) { mp_int   t; int      pa, pb, ix, iy; mp_err   err; mp_digit u; mp_word  r; mp_digit tmpx, *tmpt, *tmpy; if (MP_HAS(S_MP_MUL_HIGH_DIGS_FAST) && ((a->used + b->used + 1) < MP_WARRAY) && (MP_MIN(a->used, b->used) < MP_MAXFAST)) { return s_mp_mul_high_digs_fast(a, b, c, digs); } if ((err = mp_init_size(&t, a->used + b->used + 1)) != MP_OKAY) { return err; } t.used = a->used + b->used + 1; pa = a->used; pb = b->used; for (ix = 0; ix < pa; ix++) { u = 0; tmpx = a->dp[ix]; tmpt = &(t.dp[digs]); tmpy = b->dp + (digs - ix); for (iy = digs - ix; iy < pb; iy++) { r       = (mp_word)*tmpt + ((mp_word)tmpx * (mp_word)*tmpy++) + (mp_word)u; *tmpt++ = (mp_digit)(r & (mp_word)MP_MASK); u       = (mp_digit)(r >> (mp_word)MP_DIGIT_BIT); } *tmpt = u; } mp_clamp(&t); mp_exch(&t, c); mp_clear(&t); return MP_OKAY; }"
"struct key *find_keyring_by_name(const char *name, bool skip_perm_check) { struct key *keyring; int bucket; if (!name) return ERR_PTR(-EINVAL); bucket = keyring_hash(name); read_lock(&keyring_name_lock); if (keyring_name_hash[bucket].next) { list_for_each_entry(keyring, &keyring_name_hash[bucket], name_link ) { if (!kuid_has_mapping(current_user_ns(), keyring->user->uid)) continue; if (test_bit(KEY_FLAG_REVOKED, &keyring->flags)) continue; if (strcmp(keyring->description, name) != 0) continue; if (!skip_perm_check && key_permission(make_key_ref(keyring, 0), KEY_NEED_SEARCH) < 0) continue; if (!refcount_inc_not_zero(&keyring->usage)) continue; keyring->last_used_at = current_kernel_time().tv_sec; goto out; } } keyring = ERR_PTR(-ENOKEY); out: read_unlock(&keyring_name_lock); return keyring; }"
"void pdo_stmt_init(TSRMLS_D) { zend_class_entry ce; INIT_CLASS_ENTRY(ce, ""PDOStatement"", pdo_dbstmt_functions); pdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC); pdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get; pdo_dbstmt_ce->create_object = pdo_dbstmt_new; zend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable); zend_declare_property_null(pdo_dbstmt_ce, ""queryString"", sizeof(""queryString"")-1, ZEND_ACC_PUBLIC TSRMLS_CC); memcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers)); pdo_dbstmt_object_handlers.write_property = dbstmt_prop_write; pdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete; pdo_dbstmt_object_handlers.get_method = dbstmt_method_get; pdo_dbstmt_object_handlers.compare_objects = dbstmt_compare; pdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj; INIT_CLASS_ENTRY(ce, ""PDORow"", pdo_row_functions); pdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC); pdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS;  pdo_row_ce->create_object = pdo_row_new; pdo_row_ce->serialize = pdo_row_serialize; }"
"static int dissect_q931_ie_cs0(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_) { dissect_q931_IEs(tvb, pinfo, NULL, tree, FALSE, 0, 0); return tvb_captured_length(tvb); }"
"static double MakeDay(double y, double m, double date) { static const double firstDayOfMonth[2][12] = { {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334}, {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335} }; double yd, md; y += floor(m / 12); m = pmod(m, 12); yd = floor(TimeFromYear(y) / msPerDay); md = firstDayOfMonth[InLeapYear(y)][(int)m]; return yd + md + date - 1; }"
"static int llc_ui_bind(struct socket *sock, struct sockaddr *uaddr, int addrlen) { struct sockaddr_llc *addr = (struct sockaddr_llc *)uaddr; struct sock *sk = sock->sk; struct llc_sock *llc = llc_sk(sk); struct llc_sap *sap; int rc = -EINVAL; lock_sock(sk); if (unlikely(!sock_flag(sk, SOCK_ZAPPED) || addrlen != sizeof(*addr))) goto out; rc = -EAFNOSUPPORT; if (!addr->sllc_arphrd) addr->sllc_arphrd = ARPHRD_ETHER; if (unlikely(addr->sllc_family != AF_LLC || addr->sllc_arphrd != ARPHRD_ETHER)) goto out; dprintk(""%s: binding %02X\n"", __func__, addr->sllc_sap); rc = -ENODEV; rcu_read_lock(); if (sk->sk_bound_dev_if) { llc->dev = dev_get_by_index_rcu(&init_net, sk->sk_bound_dev_if); if (llc->dev) { if (is_zero_ether_addr(addr->sllc_mac)) memcpy(addr->sllc_mac, llc->dev->dev_addr, IFHWADDRLEN); if (addr->sllc_arphrd != llc->dev->type || !ether_addr_equal(addr->sllc_mac, llc->dev->dev_addr)) { rc = -EINVAL; llc->dev = NULL; } } } else llc->dev = dev_getbyhwaddr_rcu(&init_net, addr->sllc_arphrd, addr->sllc_mac); dev_hold_track(llc->dev, &llc->dev_tracker, GFP_ATOMIC); rcu_read_unlock(); if (!llc->dev) goto out; if (!addr->sllc_sap) { rc = -EUSERS; addr->sllc_sap = llc_ui_autoport(); if (!addr->sllc_sap) goto out; } sap = llc_sap_find(addr->sllc_sap); if (!sap) { sap = llc_sap_open(addr->sllc_sap, NULL); rc = -EBUSY;  if (!sap) goto out; } else { struct llc_addr laddr, daddr; struct sock *ask; memset(&laddr, 0, sizeof(laddr)); memset(&daddr, 0, sizeof(daddr)); memcpy(laddr.mac, addr->sllc_mac, IFHWADDRLEN); laddr.lsap = addr->sllc_sap; rc = -EADDRINUSE;  ask = llc_lookup_established(sap, &daddr, &laddr); if (ask) { sock_put(ask); goto out_put; } } llc->laddr.lsap = addr->sllc_sap; memcpy(llc->laddr.mac, addr->sllc_mac, IFHWADDRLEN); memcpy(&llc->addr, addr, sizeof(llc->addr)); llc_sap_add_socket(sap, sk); sock_reset_flag(sk, SOCK_ZAPPED); rc = 0; out_put: llc_sap_put(sap); out: release_sock(sk); return rc; }"
"static INT AirPDcapTDLSDeriveKey( PAIRPDCAP_SEC_ASSOCIATION sa, const guint8 *data, guint offset_rsne, guint offset_fte, guint offset_timeout, guint offset_link, guint8 action) { sha256_hmac_context sha_ctx; aes_cmac_ctx aes_ctx; const guint8 *snonce, *anonce, *initiator, *responder, *bssid; guint8 key_input[SHA256_DIGEST_LEN]; guint8 mic[16], iter[2], length[2], seq_num = action + 1; anonce = &data[offset_fte + 20]; snonce = &data[offset_fte + 52]; sha256_starts(&(sha_ctx.ctx)); if (memcmp(anonce, snonce, AIRPDCAP_WPA_NONCE_LEN) < 0) { sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN); sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN); } else { sha256_update(&(sha_ctx.ctx), snonce, AIRPDCAP_WPA_NONCE_LEN); sha256_update(&(sha_ctx.ctx), anonce, AIRPDCAP_WPA_NONCE_LEN); } sha256_finish(&(sha_ctx.ctx), key_input); bssid = &data[offset_link + 2]; initiator = &data[offset_link + 8]; responder = &data[offset_link + 14]; sha256_hmac_starts(&sha_ctx, key_input, SHA256_DIGEST_LEN); iter[0] = 1; iter[1] = 0; sha256_hmac_update(&sha_ctx, (const guint8 *)&iter, 2); sha256_hmac_update(&sha_ctx, ""TDLS PMK"", 8); if (memcmp(initiator, responder, AIRPDCAP_MAC_LEN) < 0) { sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN); sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN); } else { sha256_hmac_update(&sha_ctx, responder, AIRPDCAP_MAC_LEN); sha256_hmac_update(&sha_ctx, initiator, AIRPDCAP_MAC_LEN); } sha256_hmac_update(&sha_ctx, bssid, AIRPDCAP_MAC_LEN); length[0] = 256 & 0xff; length[1] = (256 >> 8) & 0xff; sha256_hmac_update(&sha_ctx, (const guint8 *)&length, 2); sha256_hmac_finish(&sha_ctx, key_input); aes_cmac_encrypt_starts(&aes_ctx, key_input, 16); aes_cmac_encrypt_update(&aes_ctx, initiator, AIRPDCAP_MAC_LEN); aes_cmac_encrypt_update(&aes_ctx, responder, AIRPDCAP_MAC_LEN); aes_cmac_encrypt_update(&aes_ctx, &seq_num, 1); aes_cmac_encrypt_update(&aes_ctx, &data[offset_link], data[offset_link + 1] + 2); aes_cmac_encrypt_update(&aes_ctx, &data[offset_rsne], data[offset_rsne + 1] + 2); aes_cmac_encrypt_update(&aes_ctx, &data[offset_timeout], data[offset_timeout + 1] + 2); aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte], 4); memset(mic, 0, 16); aes_cmac_encrypt_update(&aes_ctx, mic, 16); aes_cmac_encrypt_update(&aes_ctx, &data[offset_fte + 20], data[offset_fte + 1] + 2 - 20); aes_cmac_encrypt_finish(&aes_ctx, mic); if (memcmp(mic, &data[offset_fte + 4],16)) { AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapTDLSDeriveKey"", ""MIC verification failed"", AIRPDCAP_DEBUG_LEVEL_3); return AIRPDCAP_RET_UNSUCCESS; } memcpy(AIRPDCAP_GET_TK(sa->wpa.ptk), &key_input[16], 16); memcpy(sa->wpa.nonce, snonce, AIRPDCAP_WPA_NONCE_LEN); sa->validKey = TRUE; sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP; AIRPDCAP_DEBUG_PRINT_LINE(""AirPDcapTDLSDeriveKey"", ""MIC verified"", AIRPDCAP_DEBUG_LEVEL_3); return  AIRPDCAP_RET_SUCCESS; }"
"void sqlo_add_table_ref (sqlo_t * so, ST ** tree_ret, dk_set_t *res) { char tmp[10]; ST * tree = *tree_ret; switch (tree->type) { case TABLE_REF: { ST * prev = tree->_.table_ref.table; if (ST_P (prev, SELECT_STMT)) { tree->type = DERIVED_TABLE; sqlp_view_def (NULL, tree->_.table_ref.table, 0); sqlo_add_table_ref (so, tree_ret, res); return; } sqlo_add_table_ref (so, &tree->_.table_ref.table, res); if (prev != tree->_.table_ref.table) *tree_ret = tree->_.table_ref.table; break; } case TABLE_DOTTED: { ST * with_view = sqlo_with_decl (so, tree); dbe_table_t *tb = with_view ? NULL : sch_name_to_table (wi_inst.wi_schema, tree->_.table.name); ST * view; if (!tb && !with_view) sqlc_error (so->so_sc->sc_cc, ""S0002"", ""No table %s"", tree->_.table.name); if (inside_view) tree->_.table.name = t_box_copy (tb->tb_name); if (!with_view) { sqlc_table_used (so->so_sc, tb); view = (ST*) sch_view_def (wi_inst.wi_schema, tb->tb_name); } else view = with_view; if (!view || inside_view) { remote_table_t * rt = find_remote_table (tb->tb_name, 0); t_NEW_VARZ (op_table_t, ot); ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts); ot->ot_prefix = tree->_.table.prefix; snprintf (tmp, sizeof (tmp), ""t%d"", so->so_name_ctr++); ot->ot_new_prefix = t_box_string (tmp); tree->_.table.prefix = ot->ot_new_prefix; ot->ot_table = tb; ot->ot_rds = rt ? rt->rt_rds : NULL; ot->ot_u_id = (oid_t) unbox (tree->_.table.u_id); ot->ot_g_id = (oid_t) unbox (tree->_.table.g_id); if (ST_P (view, PROC_TABLE)) { ot->ot_dt = view; sqlo_proc_table_cols (so, ot); ot->ot_dt = NULL; ot->ot_is_proc_view = 1; } sqlo_rls_add_condition (so, ot, res, tb); t_set_push (&so->so_tables, (void*) ot); sco_add_table (so->so_scope, ot); } else { op_table_t * ot = NULL; if (!with_view && !sec_tb_check (tb, (oid_t) unbox (tree->_.table.g_id), (oid_t) unbox (tree->_.table.u_id), GR_SELECT)) sqlc_new_error (so->so_sc->sc_cc, ""42000"", ""SQ070:SECURITY"", ""Must have select privileges on view %s"", tb->tb_name); view = (ST*) t_box_copy_tree ((caddr_t) view); if (ST_P (view, UNION_ST) || ST_P (view, UNION_ALL_ST) || ST_P (view, EXCEPT_ST) || ST_P (view, EXCEPT_ALL_ST) || ST_P (view, INTERSECT_ST) || ST_P (view, INTERSECT_ALL_ST)) { view = sqlp_view_def (NULL, view, 1); view = sqlc_union_dt_wrap (view); } sqlo_scope (so, &view); if (ST_P (view, SELECT_STMT)) { ot = (op_table_t *) so->so_tables->data; ot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name; sco_add_table (so->so_scope, ot); } else { t_NEW_VARZ (op_table_t, ot2); memset (ot2, 0, sizeof (op_table_t)); ot = ot2; ot->ot_dt = view; ot->ot_prefix = tree->_.table.prefix ? tree->_.table.prefix :  tb->tb_name; ot->ot_new_prefix = sqlo_new_prefix (so); ot->ot_left_sel = sqlp_union_tree_select (view); if (ST_P (view, PROC_TABLE)) { sqlo_proc_table_cols (so, ot); ot->ot_opts = ST_OPT (tree, caddr_t *, _.table.opts); ot->ot_is_proc_view = 1; } sco_add_table (so->so_scope, ot); t_set_push (&so->so_tables, (void*) ot); } sqlo_rls_add_condition (so, ot, res, tb); *tree_ret = (ST*) t_list (3, DERIVED_TABLE, ot->ot_dt, ot->ot_new_prefix); } break; } case JOINED_TABLE: { sql_scope_t *old_sco = so->so_scope; TNEW (sql_scope_t, sco); op_table_t *right_ot, *left_ot; s_node_t *ptr; ST *j_right; dk_set_t res_jt = NULL; int is_jtc, is_natural = (tree->_.join.is_natural && (!tree->_.join.cond || tree->_.join.cond == (ST *) STAR)); memset (sco, 0, sizeof (sql_scope_t)); sco->sco_so = so; sco->sco_fun_refs_allowed = old_sco->sco_fun_refs_allowed; sco->sco_super = so->so_scope->sco_super; so->so_scope = sco; if (OJ_RIGHT == tree->_.join.type) { ST * tmp = tree->_.join.left; tree->_.join.left = tree->_.join.right; tree->_.join.right = tmp; tree->_.join.type = OJ_LEFT; } j_right = tree->_.join.left; while (ST_P (j_right, TABLE_REF)) j_right = j_right->_.table_ref.table; is_jtc = ST_P (j_right, JOINED_TABLE); if (tree->_.join.type == OJ_FULL) sco->sco_has_jt = 1; if (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL))) sco->sco_has_jt = 1; j_right = tree->_.join.right; while (ST_P (j_right, TABLE_REF)) j_right = j_right->_.table_ref.table; is_jtc = ST_P (j_right, JOINED_TABLE); if (is_jtc && (!is_natural || (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL))) sco->sco_has_jt = 1; sqlo_add_table_ref (so, &tree->_.join.left, res); left_ot = (op_table_t *) so->so_tables->data; sqlo_add_table_ref (so, &tree->_.join.right, is_jtc ? &res_jt : res); right_ot = (op_table_t *) so->so_tables->data; sqlo_natural_join_cond (so, left_ot, right_ot, tree); sqlo_scope (so, &(tree->_.join.cond)); if (J_INNER == tree->_.join.type && right_ot->ot_is_outer) t_st_and (&right_ot->ot_enclosing_where_cond, tree->_.join.cond);  else t_st_and (&right_ot->ot_join_cond, tree->_.join.cond);  sco_merge (old_sco, sco); so->so_scope = old_sco; if (tree->_.join.type == OJ_LEFT || tree->_.join.type == OJ_FULL) right_ot->ot_is_outer = 1; else if (!sco->sco_has_jt && tree->_.join.type == J_INNER && !ST_P (left_ot->ot_dt, PROC_TABLE) && !ST_P (right_ot->ot_dt, PROC_TABLE)) { t_set_push (res, tree); break; } break; } case DERIVED_TABLE: { op_table_t * ot; sqlo_scope (so, &(tree->_.table_ref.table)); if (ST_P (tree->_.table_ref.table, SELECT_STMT)) { ot = (op_table_t *) so->so_tables->data; ot->ot_prefix = tree->_.table_ref.range; tree->_.table_ref.range = ot->ot_new_prefix; sco_add_table (so->so_scope, ot); if (ot->ot_trans) sqlo_trans_cols (so, ot); } else { op_table_t *old_ot = so->so_tables ? (op_table_t *) so->so_tables->data : NULL; t_NEW_VARZ (op_table_t, ot); ot->ot_prefix = tree->_.table_ref.range; ot->ot_dt = tree->_.table_ref.table; ot->ot_new_prefix = sqlo_new_prefix (so); tree->_.table_ref.range = ot->ot_new_prefix; if (old_ot) ot->ot_left_sel = old_ot->ot_left_sel; else ot->ot_left_sel = sqlp_union_tree_select (tree->_.table_ref.table); if (ST_P (tree->_.table_ref.table, PROC_TABLE)) sqlo_proc_table_cols (so, ot); sco_add_table (so->so_scope, ot); t_set_push (&so->so_tables, (void*) ot); } break; } } }"
"TfLiteStatus Prepare(KernelType kernel_type, TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteConvParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); bool has_bias = node->inputs->size == 3; TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2); TF_LITE_ENSURE_EQ(context, node->outputs->size, 1); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output)); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input)); const TfLiteTensor* filter; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &filter)); TF_LITE_ENSURE_EQ(context, input->dims->size, 4); TF_LITE_ENSURE_EQ(context, filter->dims->size, 4); TF_LITE_ENSURE_EQ(context, input->dims->data[3], filter->dims->data[3]); TfLiteType input_type = input->type; TF_LITE_ENSURE(context, input_type == kTfLiteFloat32 || input_type == kTfLiteUInt8 || input_type == kTfLiteInt8 || input_type == kTfLiteInt16); TF_LITE_ENSURE_TYPES_EQ(context, output->type, input_type); if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0); TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0); } const TfLiteTensor* bias = nullptr; TF_LITE_ENSURE(context, has_bias); if (has_bias) { TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &bias)); if (input_type == kTfLiteUInt8 || input_type == kTfLiteInt8) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else if (input_type == kTfLiteInt16) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, input_type); } TF_LITE_ENSURE_EQ(context, NumElements(bias), SizeOfDimension(filter, 0)); } const bool is_hybrid = (input->type == kTfLiteFloat32 && (filter->type == kTfLiteUInt8 || filter->type == kTfLiteInt8)); if (is_hybrid && filter->type == kTfLiteInt8 && filter->quantization.type == kTfLiteAffineQuantization && filter->quantization.params && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale && reinterpret_cast<TfLiteAffineQuantization*>(filter->quantization.params) ->scale->size > 1) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); const float scale = affine_quantization->scale->data[0]; for (int i = 1; i < affine_quantization->scale->size; i++) { if (affine_quantization->scale->data[i] != scale) { data->is_hybrid_per_channel = true; break; } } } data->supports_multithreaded_kernel = (kernel_type == kMultithreadOptimized) && (context->recommended_num_threads != 1) && !is_hybrid && (params->dilation_width_factor == 1) && (params->dilation_height_factor == 1) && (filter->allocation_type != kTfLiteArenaRw) && !IsDynamicTensor(filter); int channels_in = filter->dims->data[3]; int channels_out = filter->dims->data[0]; int width = input->dims->data[2]; int height = input->dims->data[1]; int filter_width = filter->dims->data[2]; int filter_height = filter->dims->data[1]; int batches = input->dims->data[0]; auto padding = params->padding; int out_width, out_height; data->padding = ComputePaddingHeightWidth( params->stride_height, params->stride_width, params->dilation_height_factor, params->dilation_width_factor, height, width, filter_height, filter_width, padding, &out_height, &out_width); size_t im2col_type_size; TF_LITE_ENSURE_STATUS(GetSizeOfType(context, input->type, &im2col_type_size)); const size_t im2col_bytes = batches * out_height * out_width * channels_in * filter_height * filter_width * im2col_type_size; TF_LITE_ENSURE_STATUS(AllocateTemporaryTensorsIfRequired( context, node, is_hybrid, data->is_hybrid_per_channel, kernel_type, im2col_bytes)); TF_LITE_ENSURE(context, has_bias); if (input_type != kTfLiteFloat32) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 || affine_quantization->scale->size == channels_out)); data->per_channel_output_multiplier.resize(channels_out); data->per_channel_output_shift.resize(channels_out); TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams( context, input, filter, bias, output, params->activation, &data->output_multiplier, &data->output_shift, &data->output_activation_min, &data->output_activation_max, data->per_channel_output_multiplier.data(), data->per_channel_output_shift.data(), channels_out)); } TfLiteIntArray* output_size = TfLiteIntArrayCreate(4); output_size->data[0] = batches; output_size->data[1] = out_height; output_size->data[2] = out_width; output_size->data[3] = channels_out; auto output_status = context->ResizeTensor(context, output, output_size); if (output_status != kTfLiteOk) return output_status; if (data->need_im2col) { node->temporaries->data[data->im2col_index] = data->im2col_id; TfLiteIntArray* im2col_size = TfLiteIntArrayCreate(4); int input_depth = input->dims->data[3]; im2col_size->data[0] = output_size->data[0]; im2col_size->data[1] = output_size->data[1]; im2col_size->data[2] = output_size->data[2]; im2col_size->data[3] = input_depth * filter_height * filter_width; TfLiteTensor* im2col = &context->tensors[node->temporaries->data[data->im2col_index]]; im2col->type = input->type; if (is_hybrid) { im2col->type = filter->type; } im2col->allocation_type = kTfLiteArenaRw; auto im2col_status = context->ResizeTensor(context, im2col, im2col_size); if (im2col_status != kTfLiteOk) return im2col_status; } if (data->need_hwcn_weights) { node->temporaries->data[data->hwcn_weights_index] = data->hwcn_weights_id; TfLiteIntArray* hwcn_weights_size = TfLiteIntArrayCreate(2); int input_depth = input->dims->data[3]; hwcn_weights_size->data[0] = (filter_height * filter_width * input_depth); hwcn_weights_size->data[1] = channels_out; TfLiteTensor* hwcn_weights = &context->tensors[node->temporaries->data[data->hwcn_weights_index]]; hwcn_weights->type = input_type; hwcn_weights->allocation_type = kTfLiteArenaRwPersistent; auto hwcn_weights_status = context->ResizeTensor(context, hwcn_weights, hwcn_weights_size); if (hwcn_weights_status != kTfLiteOk) return hwcn_weights_status; data->have_weights_been_transposed = false; } if (is_hybrid) { node->temporaries->data[data->input_quantized_index] = data->input_quantized_id; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); input_quantized->type = kTfLiteInt8; input_quantized->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) { TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized, input_quantized_size)); } node->temporaries->data[data->scaling_factors_index] = data->scaling_factors_id; TfLiteTensor* scaling_factors; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors)); scaling_factors->type = kTfLiteFloat32; scaling_factors->allocation_type = kTfLiteArenaRw; const int height = NumElements(input) / channels_in; int scaling_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) { TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1); scaling_factors_size->data[0] = height; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors, scaling_factors_size)); } node->temporaries->data[data->accum_scratch_index] = data->accum_scratch_id; TfLiteTensor* accum_scratch; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->accum_scratch_index, &accum_scratch)); accum_scratch->type = kTfLiteInt32; accum_scratch->allocation_type = kTfLiteArenaRw; const int scratch_width = batches * out_height * out_width; int accum_scratch_dims[2] = {channels_out, scratch_width}; if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2, accum_scratch_dims)) { TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2); accum_scratch_size->data[0] = channels_out; accum_scratch_size->data[1] = scratch_width; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch, accum_scratch_size)); } if (data->is_hybrid_per_channel) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE_EQ( context, affine_quantization->scale->size, filter->dims->data[affine_quantization->quantized_dimension]); node->temporaries->data[data->input_offset_index] = data->input_offset_id; TfLiteTensor* input_offsets; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_offset_index, &input_offsets)); input_offsets->type = kTfLiteInt32; input_offsets->allocation_type = kTfLiteArenaRw; const int height = NumElements(input) / channels_in; const int input_offset_dims[1] = {height}; if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, input_offset_dims)) { TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1); input_offsets_size->data[0] = input_offset_dims[0]; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets, input_offsets_size)); } node->temporaries->data[data->row_sums_index] = data->row_sums_id; TfLiteTensor* row_sums; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->row_sums_index, &row_sums)); row_sums->type = kTfLiteInt32; row_sums->allocation_type = kTfLiteArenaRwPersistent; const int row_sums_dims[1] = {channels_out}; if (!TfLiteIntArrayEqualsArray(row_sums->dims, 1, row_sums_dims)) { TfLiteIntArray* row_sums_size = TfLiteIntArrayCreate(1); row_sums_size->data[0] = row_sums_dims[0]; TF_LITE_ENSURE_OK( context, context->ResizeTensor(context, row_sums, row_sums_size)); } } } return kTfLiteOk; }"
"void vrrp_print(netdissect_options *ndo, register const u_char *bp, register u_int len, register const u_char *bp2, int ttl) { int version, type, auth_type = VRRP_AUTH_NONE;  const char *type_s; ND_TCHECK(bp[0]); version = (bp[0] & 0xf0) >> 4; type = bp[0] & 0x0f; type_s = tok2str(type2str, ""unknown type (%u)"", type); ND_PRINT((ndo, ""VRRPv%u, %s"", version, type_s)); if (ttl != 255) ND_PRINT((ndo, "", (ttl %u)"", ttl)); if (version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT) return; ND_TCHECK(bp[2]); ND_PRINT((ndo, "", vrid %u, prio %u"", bp[1], bp[2])); ND_TCHECK(bp[5]); if (version == 2) { auth_type = bp[4]; ND_PRINT((ndo, "", authtype %s"", tok2str(auth2str, NULL, auth_type))); ND_PRINT((ndo, "", intvl %us, length %u"", bp[5], len)); } else {  uint16_t intvl = (bp[4] & 0x0f) << 8 | bp[5]; ND_PRINT((ndo, "", intvl %ucs, length %u"", intvl, len)); } if (ndo->ndo_vflag) { int naddrs = bp[3]; int i; char c; if (version == 2 && ND_TTEST2(bp[0], len)) { struct cksum_vec vec[1]; vec[0].ptr = bp; vec[0].len = len; if (in_cksum(vec, 1)) ND_PRINT((ndo, "", (bad vrrp cksum %x)"", EXTRACT_16BITS(&bp[6]))); } if (version == 3 && ND_TTEST2(bp[0], len)) { uint16_t cksum = nextproto4_cksum(ndo, (const struct ip *)bp2, bp, len, len, IPPROTO_VRRP); if (cksum) ND_PRINT((ndo, "", (bad vrrp cksum %x)"", EXTRACT_16BITS(&bp[6]))); } ND_PRINT((ndo, "", addrs"")); if (naddrs > 1) ND_PRINT((ndo, ""(%d)"", naddrs)); ND_PRINT((ndo, "":"")); c = ' '; bp += 8; for (i = 0; i < naddrs; i++) { ND_TCHECK(bp[3]); ND_PRINT((ndo, ""%c%s"", c, ipaddr_string(ndo, bp))); c = ','; bp += 4; } if (version == 2 && auth_type == VRRP_AUTH_SIMPLE) {  ND_TCHECK(bp[7]); ND_PRINT((ndo, "" auth \"""")); if (fn_printn(ndo, bp, 8, ndo->ndo_snapend)) { ND_PRINT((ndo, ""\"""")); goto trunc; } ND_PRINT((ndo, ""\"""")); } } return; trunc: ND_PRINT((ndo, ""[|vrrp]"")); }"
"void PluginDocumentParser::appendBytes(const char* data, size_t length) { if (!m_embedElement) createDocumentStructure(); if (!length) return; if (PluginView* view = pluginView()) view->didReceiveData(data, length); }"
"MOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) { MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size); if (buf == NULL) { debug_print(""%s\n"", ""Memory allocation failed""); return MOBI_MALLOC_FAILED; } char huff_magic[5]; mobi_buffer_getstring(huff_magic, buf, 4); const size_t header_length = mobi_buffer_get32(buf); if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) { debug_print(""HUFF wrong magic: %s\n"", huff_magic); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } const size_t data1_offset = mobi_buffer_get32(buf); const size_t data2_offset = mobi_buffer_get32(buf); mobi_buffer_setpos(buf, data1_offset); if (buf->offset + (256 * 4) > buf->maxlen) { debug_print(""%s"", ""HUFF data1 too short\n""); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } for (int i = 0; i < 256; i++) { huffcdic->table1[i] = mobi_buffer_get32(buf); } mobi_buffer_setpos(buf, data2_offset); if (buf->offset + (64 * 4) > buf->maxlen) { debug_print(""%s"", ""HUFF data2 too short\n""); mobi_buffer_free_null(buf); return MOBI_DATA_CORRUPT; } huffcdic->mincode_table[0] = 0; huffcdic->maxcode_table[0] = 0xFFFFFFFF; for (int i = 1; i < 33; i++) { const uint32_t mincode = mobi_buffer_get32(buf); const uint32_t maxcode = mobi_buffer_get32(buf); huffcdic->mincode_table[i] =  mincode << (32 - i); huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1; } mobi_buffer_free_null(buf); return MOBI_SUCCESS; }"
"bool parse( char* ptr ) { ptr = skipSpaces( ptr ); if ( !ptr || !*ptr ) return false; FileNode root_collection(fs->getFS(), 0, 0); if( *ptr == '{' ) { FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::MAP); parseMap( ptr, root_node ); } else if ( *ptr == '[' ) { FileNode root_node = fs->addNode(root_collection, std::string(), FileNode::SEQ); parseSeq( ptr, root_node ); } else { CV_PARSE_ERROR_CPP( ""left-brace of top level is missing"" ); } if( !ptr || !*ptr ) CV_PARSE_ERROR_CPP( ""Unexpected End-Of-File"" ); return true; }"
"static int dissect_kafka_bytes_new(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int hf_item, int offset, int *p_bytes_offset, int *p_bytes_length, gboolean *p_invalid) { gint64     val; guint      len; proto_item *pi; *p_invalid = FALSE; len = tvb_get_varint(tvb, offset, 5, &val, ENC_VARINT_ZIGZAG); if (len == 0) { pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_varint); len = 5; val = 0; } else if (val > 0) { proto_tree_add_item(tree, hf_item, tvb, offset+len, (gint)val, ENC_NA); } else if (val == 0) { proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<EMPTY>""); } else if (val == -1) { proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<NULL>""); val = 0; } else { pi = proto_tree_add_bytes_format_value(tree, hf_item, tvb, offset+len, 0, NULL, ""<INVALID>""); expert_add_info(pinfo, pi, &ei_kafka_bad_bytes_length); val = 0; *p_invalid = TRUE; } if (p_bytes_offset != NULL) { *p_bytes_offset = offset+len; } if (p_bytes_length != NULL) { *p_bytes_length = (gint)val; } return offset+len+(gint)val; }"
"void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) { COMPS_HSList *tmplist, *tmp_subnodes; COMPS_HSListItem *it, *it2; struct Pair { COMPS_HSList * subnodes; char * key; char added; } *pair, *parent_pair; pair = malloc(sizeof(struct Pair)); pair->subnodes = rt2->subnodes; pair->key = NULL; tmplist = comps_hslist_create(); comps_hslist_init(tmplist, NULL, NULL, &free); comps_hslist_append(tmplist, pair, 0); while (tmplist->first != NULL) { it = tmplist->first; comps_hslist_remove(tmplist, tmplist->first); tmp_subnodes = ((struct Pair*)it->data)->subnodes; parent_pair = (struct Pair*) it->data; free(it); pair->added = 0; for (it = tmp_subnodes->first; it != NULL; it=it->next) { pair = malloc(sizeof(struct Pair)); pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes; if (parent_pair->key != NULL) { pair->key = malloc(sizeof(char) * (strlen(((COMPS_MRTreeData*)it->data)->key) + strlen(parent_pair->key) + 1)); memcpy(pair->key, parent_pair->key, sizeof(char) * strlen(parent_pair->key)); memcpy(pair->key+strlen(parent_pair->key), ((COMPS_MRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1)); } else { pair->key = malloc(sizeof(char)* (strlen(((COMPS_MRTreeData*)it->data)->key) + 1)); memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key, sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1)); } if (((COMPS_MRTreeData*)it->data)->data->first != NULL) { for (it2 = ((COMPS_MRTreeData*)it->data)->data->first; it2 != NULL; it2 = it2->next) { comps_mrtree_set(rt1, pair->key, it2->data); } if (((COMPS_MRTreeData*)it->data)->subnodes->first) { comps_hslist_append(tmplist, pair, 0); } else { free(pair->key); free(pair); } } else { if (((COMPS_MRTreeData*)it->data)->subnodes->first) { comps_hslist_append(tmplist, pair, 0); } else { free(pair->key); free(pair); } } } free(parent_pair->key); free(parent_pair); } comps_hslist_destroy(&tmplist); }"
"void Compute(OpKernelContext* context) override { typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>> ConstEigenMatrixMap; typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> EigenDoubleMatrixMap; const Tensor& orig_input_tensor_shape = context->input(0); OP_REQUIRES(context, orig_input_tensor_shape.dims() == 1 && orig_input_tensor_shape.NumElements() == 4, errors::InvalidArgument(""original input tensor shape must be"" ""1-dimensional and 4 elements"")); const Tensor& out_backprop = context->input(1); const Tensor& row_seq_tensor = context->input(2); const Tensor& col_seq_tensor = context->input(3); const int64_t out_batch = out_backprop.dim_size(0); const int64_t out_rows = out_backprop.dim_size(1); const int64_t out_cols = out_backprop.dim_size(2); const int64_t out_depth = out_backprop.dim_size(3); OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", row_seq_tensor must have at least "", out_rows + 1, "" elements, but got "", row_seq_tensor.NumElements())); OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", col_seq_tensor must have at least "", out_cols + 1, "" elements, but got "", col_seq_tensor.NumElements())); auto row_seq_tensor_flat = row_seq_tensor.flat<int64_t>(); auto col_seq_tensor_flat = col_seq_tensor.flat<int64_t>(); auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64_t>(); const int64_t in_batch = orig_input_tensor_shape_flat(0); const int64_t in_rows = orig_input_tensor_shape_flat(1); const int64_t in_cols = orig_input_tensor_shape_flat(2); const int64_t in_depth = orig_input_tensor_shape_flat(3); OP_REQUIRES( context, in_batch != 0, errors::InvalidArgument(""Batch dimension of input must not be 0"")); OP_REQUIRES( context, in_rows != 0, errors::InvalidArgument(""Rows dimension of input must not be 0"")); OP_REQUIRES( context, in_cols != 0, errors::InvalidArgument(""Columns dimension of input must not be 0"")); OP_REQUIRES( context, in_depth != 0, errors::InvalidArgument(""Depth dimension of input must not be 0"")); constexpr int tensor_in_and_out_dims = 4; TensorShape in_shape; for (auto i = 0; i < tensor_in_and_out_dims; ++i) { in_shape.AddDim(orig_input_tensor_shape_flat(i)); } Tensor in_backprop_tensor_temp; OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp( {0}, DataTypeToEnum<double>::v(), in_shape, &in_backprop_tensor_temp)); in_backprop_tensor_temp.flat<double>().setZero(); EigenDoubleMatrixMap in_backprop_tensor_temp_mat( in_backprop_tensor_temp.flat<double>().data(), in_depth, in_cols * in_rows * in_batch); ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(), out_depth, out_cols * out_rows * out_batch); const int64_t in_max_row_index = in_rows - 1; const int64_t in_max_col_index = in_cols - 1; for (int64_t b = 0; b < out_batch; ++b) { for (int64_t r = 0; r < out_rows; ++r) { const int64_t in_row_start = row_seq_tensor_flat(r); int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1) : row_seq_tensor_flat(r + 1) - 1; in_row_end = std::min(in_row_end, in_max_row_index); for (int64_t c = 0; c < out_cols; ++c) { const int64_t in_col_start = col_seq_tensor_flat(c); int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1) : col_seq_tensor_flat(c + 1) - 1; in_col_end = std::min(in_col_end, in_max_col_index); const int64_t num_elements_in_pooling_cell = (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1); const int64_t out_index = (b * out_rows + r) * out_cols + c; for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) { for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) { const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c; for (int64_t d = 0; d < out_depth; ++d) { const double out_backprop_element = static_cast<double>( out_backprop_mat.coeffRef(d, out_index)); double& in_backprop_ref = in_backprop_tensor_temp_mat.coeffRef(d, in_index); in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell; } } } } } } Tensor* in_backprop_tensor = nullptr; OP_REQUIRES_OK(context, context->forward_input_or_allocate_output( {0}, 0, in_shape, &in_backprop_tensor)); auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>(); auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>(); for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) { in_backprop_tensor_flat(i) = static_cast<T>(in_backprop_tensor_temp_flat(i)); } }"
"static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order) { int err; #ifdef WOLFSSL_SMALL_STACK byte* buf; #else byte  buf[ECC_MAXSIZE_GEN]; #endif #ifdef WOLFSSL_SMALL_STACK buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER); if (buf == NULL) return MEMORY_E; #endif size += 8; err = wc_RNG_GenerateBlock(rng, buf, size); if (err == 0) err = mp_read_unsigned_bin(k, (byte*)buf, size); if (err == MP_OKAY) { if (mp_iszero(k) == MP_YES) err = MP_ZERO_E; } if (err == MP_OKAY) { if (mp_cmp(k, order) != MP_LT) { err = mp_mod(k, order, k); } } ForceZero(buf, ECC_MAXSIZE); #ifdef WOLFSSL_SMALL_STACK XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER); #endif return err; }"
"CharString *Formattable::internalGetCharString(UErrorCode &status) { if(fDecimalStr == NULL) { if (fDecimalQuantity == NULL) { LocalPointer<DecimalQuantity> dq(new DecimalQuantity(), status); if (U_FAILURE(status)) { return nullptr; } populateDecimalQuantity(*dq, status); if (U_FAILURE(status)) { return nullptr; } fDecimalQuantity = dq.orphan(); } fDecimalStr = new CharString(); if (fDecimalStr == NULL) { status = U_MEMORY_ALLOCATION_ERROR; return NULL; } if (fDecimalQuantity->isZero()) { fDecimalStr->append(""0"", -1, status); } else if (std::abs(fDecimalQuantity->getMagnitude()) < 5) { fDecimalStr->appendInvariantChars(fDecimalQuantity->toPlainString(), status); } else { fDecimalStr->appendInvariantChars(fDecimalQuantity->toScientificString(), status); } } return fDecimalStr; }"
"static SIXELSTATUS load_jpeg(unsigned char **result, unsigned char *data, size_t datasize, int *pwidth, int *pheight, int *ppixelformat, sixel_allocator_t *allocator) { SIXELSTATUS status = SIXEL_JPEG_ERROR; JDIMENSION row_stride; size_t size; JSAMPARRAY buffer; struct jpeg_decompress_struct cinfo; struct jpeg_error_mgr pub; cinfo.err = jpeg_std_error(&pub); jpeg_create_decompress(&cinfo); jpeg_mem_src(&cinfo, data, datasize); jpeg_read_header(&cinfo, TRUE); cinfo.quantize_colors = FALSE; cinfo.out_color_space = JCS_RGB; jpeg_start_decompress(&cinfo); if (cinfo.output_components != 3) { sixel_helper_set_additional_message( ""load_jpeg: unknown pixel format.""); status = SIXEL_BAD_INPUT; goto end; } *ppixelformat = SIXEL_PIXELFORMAT_RGB888; *pwidth = (int)cinfo.output_width; *pheight = (int)cinfo.output_height; size = (size_t)(*pwidth * *pheight * cinfo.output_components); *result = (unsigned char *)sixel_allocator_malloc(allocator, size); if (*result == NULL) { sixel_helper_set_additional_message( ""load_jpeg: sixel_allocator_malloc() failed.""); status = SIXEL_BAD_ALLOCATION; goto end; } row_stride = cinfo.output_width * (unsigned int)cinfo.output_components; buffer = (*cinfo.mem->alloc_sarray)((j_common_ptr)&cinfo, JPOOL_IMAGE, row_stride, 1); while (cinfo.output_scanline < cinfo.output_height) { jpeg_read_scanlines(&cinfo, buffer, 1); memcpy(*result + (cinfo.output_scanline - 1) * row_stride, buffer[0], row_stride); } status = SIXEL_OK; end: jpeg_finish_decompress(&cinfo); jpeg_destroy_decompress(&cinfo); return status; }"
"bool SDP_AddAttribute(uint32_t handle, uint16_t attr_id, uint8_t attr_type, uint32_t attr_len, uint8_t* p_val) { uint16_t xx, yy, zz; tSDP_RECORD* p_rec = &sdp_cb.server_db.record[0]; if (sdp_cb.trace_level >= BT_TRACE_LEVEL_DEBUG) { if ((attr_type == UINT_DESC_TYPE) || (attr_type == TWO_COMP_INT_DESC_TYPE) || (attr_type == UUID_DESC_TYPE) || (attr_type == DATA_ELE_SEQ_DESC_TYPE) || (attr_type == DATA_ELE_ALT_DESC_TYPE)) { uint8_t num_array[400]; uint32_t len = (attr_len > 200) ? 200 : attr_len; num_array[0] = '\0'; for (uint32_t i = 0; i < len; i++) { snprintf((char*)&num_array[i * 2], sizeof(num_array) - i * 2, ""%02X"", (uint8_t)(p_val[i])); } SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%s"", handle, attr_id, attr_type, attr_len, p_val, num_array); } else if (attr_type == BOOLEAN_DESC_TYPE) { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%d"", handle, attr_id, attr_type, attr_len, p_val, *p_val); } else if ((attr_type == TEXT_STR_DESC_TYPE) || (attr_type == URL_DESC_TYPE)) { if (p_val[attr_len - 1] == '\0') { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p, "" ""*p_val:%s"", handle, attr_id, attr_type, attr_len, p_val, (char*)p_val); } else { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p"", handle, attr_id, attr_type, attr_len, p_val); } } else { SDP_TRACE_DEBUG( ""SDP_AddAttribute: handle:%X, id:%04X, type:%d, len:%d, p_val:%p"", handle, attr_id, attr_type, attr_len, p_val); } } for (zz = 0; zz < sdp_cb.server_db.num_records; zz++, p_rec++) { if (p_rec->record_handle == handle) { tSDP_ATTRIBUTE* p_attr = &p_rec->attribute[0]; for (xx = 0; xx < p_rec->num_attributes; xx++, p_attr++) { if (p_attr->id == attr_id) { SDP_DeleteAttribute(handle, attr_id); break; } if (p_attr->id > attr_id) break; } if (p_rec->num_attributes == SDP_MAX_REC_ATTR) return (false); if (xx == p_rec->num_attributes) p_attr = &p_rec->attribute[p_rec->num_attributes]; else { for (yy = p_rec->num_attributes; yy > xx; yy--) p_rec->attribute[yy] = p_rec->attribute[yy - 1]; } p_attr->id = attr_id; p_attr->type = attr_type; p_attr->len = attr_len; if (p_rec->free_pad_ptr + attr_len >= SDP_MAX_PAD_LEN) { if (attr_type == TEXT_STR_DESC_TYPE) { SDP_TRACE_WARNING( ""SDP_AddAttribute: attr_len:%d too long. truncate to (%d)"", attr_len, SDP_MAX_PAD_LEN - p_rec->free_pad_ptr); attr_len = SDP_MAX_PAD_LEN - p_rec->free_pad_ptr; p_val[SDP_MAX_PAD_LEN - p_rec->free_pad_ptr - 1] = '\0'; } else attr_len = 0; } if ((attr_len > 0) && (p_val != 0)) { p_attr->len = attr_len; memcpy(&p_rec->attr_pad[p_rec->free_pad_ptr], p_val, (size_t)attr_len); p_attr->value_ptr = &p_rec->attr_pad[p_rec->free_pad_ptr]; p_rec->free_pad_ptr += attr_len; } else if ((attr_len == 0 && p_attr->len != 0) ||  p_val == 0) { SDP_TRACE_ERROR( ""SDP_AddAttribute fail, length exceed maximum: ID %d: attr_len:%d "", attr_id, attr_len); p_attr->id = p_attr->type = p_attr->len = 0; return (false); } p_rec->num_attributes++; return (true); } } return (false); }"
"void display_dollar(colnr_T col) { colnr_T save_col; if (!redrawing()) return; cursor_off(); save_col = curwin->w_cursor.col; curwin->w_cursor.col = col; if (has_mbyte) { char_u *p; p = ml_get_curline(); curwin->w_cursor.col -= (*mb_head_off)(p, p + col); } curs_columns(FALSE);        if (curwin->w_wcol < curwin->w_width) { edit_putchar('$', FALSE); dollar_vcol = curwin->w_virtcol; } curwin->w_cursor.col = save_col; }"
int uv_mutex_trylock(uv_mutex_t* mutex) { int r; r = pthread_mutex_trylock(mutex); if (r && r != EBUSY && r != EAGAIN) abort(); if (r) return -1; else return 0; }
"int install_thread_keyring_to_cred(struct cred *new) { struct key *keyring; keyring = keyring_alloc(""_tid"", new->uid, new->gid, new, KEY_POS_ALL | KEY_USR_VIEW, KEY_ALLOC_QUOTA_OVERRUN, NULL, NULL); if (IS_ERR(keyring)) return PTR_ERR(keyring); new->thread_keyring = keyring; return 0; }"
"packet_t * capture_packet_reasm_ip(capture_info_t *capinfo, const struct pcap_pkthdr *header, u_char *packet, uint32_t *size, uint32_t *caplen) { struct ip *ip4; #ifdef USE_IPV6 struct ip6_hdr *ip6; #endif uint32_t ip_ver; uint8_t ip_proto; uint32_t ip_hl = 0; uint16_t ip_off = 0; uint16_t ip_len = 0; uint16_t ip_frag = 0; uint32_t ip_id = 0; uint16_t ip_frag_off = 0; address_t src = { }; address_t dst = { }; vector_iter_t it; packet_t *pkt; frame_t *frame; uint32_t len_data = 0; uint16_t link_hl = capinfo->link_hl; #ifdef USE_IPV6 struct ip6_frag *ip6f; #endif if (capinfo->link == DLT_EN10MB) { struct ether_header *eth = (struct ether_header *) packet; if (ntohs(eth->ether_type) == ETHERTYPE_8021Q) { link_hl += 4; } } #ifdef SLL_HDR_LEN if (capinfo->link == DLT_LINUX_SLL) { struct sll_header *sll = (struct sll_header *) packet; if (ntohs(sll->sll_protocol) == ETHERTYPE_8021Q) { link_hl += 4; } } #endif if (capinfo->link == DLT_NFLOG) { while (link_hl + 8 <= *caplen) { nflog_tlv_t *tlv = (nflog_tlv_t *) (packet + link_hl); if (!tlv) break; if (tlv->tlv_type == NFULA_PAYLOAD) { link_hl += 4; break; } if (tlv->tlv_length >= 4) { link_hl += ((tlv->tlv_length + 3) & ~3);  } } } while (*size >= sizeof(struct ip)) { ip4 = (struct ip *) (packet + link_hl); #ifdef USE_IPV6 ip6 = (struct ip6_hdr *) (packet + link_hl); #endif ip_ver = ip4->ip_v; switch (ip_ver) { case 4: ip_hl = ip4->ip_hl * 4; ip_proto = ip4->ip_p; ip_off = ntohs(ip4->ip_off); ip_len = ntohs(ip4->ip_len); ip_frag = ip_off & (IP_MF | IP_OFFMASK); ip_frag_off = (ip_frag) ? (ip_off & IP_OFFMASK) * 8 : 0; ip_id = ntohs(ip4->ip_id); inet_ntop(AF_INET, &ip4->ip_src, src.ip, sizeof(src.ip)); inet_ntop(AF_INET, &ip4->ip_dst, dst.ip, sizeof(dst.ip)); break; #ifdef USE_IPV6 case 6: ip_hl = sizeof(struct ip6_hdr); ip_proto = ip6->ip6_nxt; ip_len = ntohs(ip6->ip6_ctlun.ip6_un1.ip6_un1_plen) + ip_hl; if (ip_proto == IPPROTO_FRAGMENT) { ip_frag = 1; ip6f = (struct ip6_frag *) (packet + link_hl + ip_hl); ip_frag_off = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK); ip_id = ntohl(ip6f->ip6f_ident); } inet_ntop(AF_INET6, &ip6->ip6_src, src.ip, sizeof(src.ip)); inet_ntop(AF_INET6, &ip6->ip6_dst, dst.ip, sizeof(dst.ip)); break; #endif default: return NULL; } *caplen = link_hl + ip_len; *size = *caplen - link_hl - ip_hl; if (ip_proto == IPPROTO_IPIP) { link_hl += ip_hl; } else { break; } } if (*caplen > MAX_CAPTURE_LEN) return NULL; if (ip_frag == 0) { pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id); packet_add_frame(pkt, header, packet); return pkt; } it = vector_iterator(capinfo->ip_reasm); while ((pkt = vector_iterator_next(&it))) { if (addressport_equals(pkt->src, src) && addressport_equals(pkt->dst, dst) && pkt->ip_id == ip_id) { break; } } if (pkt) { packet_add_frame(pkt, header, packet); } else { pkt = packet_create(ip_ver, ip_proto, src, dst, ip_id); packet_add_frame(pkt, header, packet); vector_append(capinfo->ip_reasm, pkt); } pkt->ip_cap_len += ip_len - ip_hl; #ifdef USE_IPV6 if (ip_ver == 6 && ip_frag) { pkt->ip_cap_len -= sizeof(struct ip6_frag); } #endif if (ip_ver == 4 && (ip_off & IP_MF) == 0) { pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl; } #ifdef USE_IPV6 if (ip_ver == 6 && ip_frag && (ip6f->ip6f_offlg & htons(0x01)) == 0) { pkt->ip_exp_len = ip_frag_off + ip_len - ip_hl - sizeof(struct ip6_frag); } #endif if (pkt->ip_cap_len == pkt->ip_exp_len) { it = vector_iterator(pkt->frames); while ((frame = vector_iterator_next(&it))) { switch (ip_ver) { case 4: { struct ip *frame_ip = (struct ip *) (frame->data + link_hl); len_data += ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4; break; } #ifdef USE_IPV6 case 6: { struct ip6_hdr *frame_ip6 = (struct ip6_hdr *) (frame->data + link_hl); len_data += ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen); break; } #endif default: break; } } if (len_data > MAX_CAPTURE_LEN) return NULL; memset(packet, 0, link_hl + ip_hl + len_data); it = vector_iterator(pkt->frames); while ((frame = vector_iterator_next(&it))) { switch (ip_ver) { case 4: { struct ip *frame_ip = (struct ip *) (frame->data + link_hl); memcpy(packet + link_hl + ip_hl + (ntohs(frame_ip->ip_off) & IP_OFFMASK) * 8, frame->data + link_hl + frame_ip->ip_hl * 4, ntohs(frame_ip->ip_len) - frame_ip->ip_hl * 4); } break; #ifdef USE_IPV6 case 6: { struct ip6_hdr *frame_ip6 = (struct ip6_hdr*)(frame->data + link_hl); struct ip6_frag *frame_ip6f = (struct ip6_frag *)(frame->data + link_hl + ip_hl); uint16_t frame_ip_frag_off = ntohs(frame_ip6f->ip6f_offlg & IP6F_OFF_MASK); memcpy(packet + link_hl + ip_hl + sizeof(struct ip6_frag) + frame_ip_frag_off, frame->data + link_hl + ip_hl + sizeof (struct ip6_frag), ntohs(frame_ip6->ip6_ctlun.ip6_un1.ip6_un1_plen)); pkt->proto = frame_ip6f->ip6f_nxt; } break; #endif default: break; } } *caplen = link_hl + ip_hl + len_data; #ifdef USE_IPV6 if (ip_ver == 6) { *caplen += sizeof(struct ip6_frag); } #endif *size = len_data; vector_remove(capinfo->ip_reasm, pkt); return pkt; } return NULL; }"
"int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals ) { struct yyguts_t dummy_yyguts; re_yyset_extra (yy_user_defined, &dummy_yyguts); if (ptr_yy_globals == NULL){ errno = EINVAL; return 1; } *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts ); if (*ptr_yy_globals == NULL){ errno = ENOMEM; return 1; } memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t)); re_yyset_extra (yy_user_defined, *ptr_yy_globals); return yy_init_globals ( *ptr_yy_globals ); }"
"static void setup_private_mount(const char *snap_name) { uid_t uid = getuid(); gid_t gid = getgid(); char tmpdir[MAX_BUF] = { 0 }; sc_must_snprintf(tmpdir, sizeof(tmpdir), ""/tmp/snap.%s_XXXXXX"", snap_name); if (mkdtemp(tmpdir) == NULL) { die(""cannot create temporary directory essential for private /tmp""); } mode_t old_mask = umask(0); char *d = sc_strdup(tmpdir); sc_must_snprintf(tmpdir, sizeof(tmpdir), ""%s/tmp"", d); free(d); if (mkdir(tmpdir, 01777) != 0) { die(""cannot create temporary directory for private /tmp""); } umask(old_mask); char *pwd = get_current_dir_name(); if (pwd == NULL) die(""cannot get current working directory""); if (chdir(""/"") != 0) die(""cannot change directory to '/'""); sc_do_mount(tmpdir, ""/tmp"", NULL, MS_BIND, NULL); sc_do_mount(""none"", ""/tmp"", NULL, MS_PRIVATE, NULL); if (chown(""/tmp/"", uid, gid) < 0) { die(""cannot change ownership of /tmp""); } if (chdir(pwd) != 0) die(""cannot change current working directory to the original directory""); free(pwd); }"
"int initializeControlStream(void) { stopping = 0; PltCreateEvent(&invalidateRefFramesEvent); LbqInitializeLinkedBlockingQueue(&invalidReferenceFrameTuples, 20); if (ServerMajorVersion == 3) { packetTypes = (short*)packetTypesGen3; payloadLengths = (short*)payloadLengthsGen3; preconstructedPayloads = (char**)preconstructedPayloadsGen3; } else if (ServerMajorVersion == 4) { packetTypes = (short*)packetTypesGen4; payloadLengths = (short*)payloadLengthsGen4; preconstructedPayloads = (char**)preconstructedPayloadsGen4; } else if (ServerMajorVersion == 5) { packetTypes = (short*)packetTypesGen5; payloadLengths = (short*)payloadLengthsGen5; preconstructedPayloads = (char**)preconstructedPayloadsGen5; } else { packetTypes = (short*)packetTypesGen7; payloadLengths = (short*)payloadLengthsGen7; preconstructedPayloads = (char**)preconstructedPayloadsGen7; } idrFrameRequired = 0; lastGoodFrame = 0; lastSeenFrame = 0; lossCountSinceLastReport = 0; return 0; }"
"virtual status_t configureVideoTunnelMode( node_id node, OMX_U32 portIndex, OMX_BOOL tunneled, OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) { Parcel data, reply; data.writeInterfaceToken(IOMX::getInterfaceDescriptor()); data.writeInt32((int32_t)node); data.writeInt32(portIndex); data.writeInt32((int32_t)tunneled); data.writeInt32(audioHwSync); remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply); status_t err = reply.readInt32(); if (sidebandHandle) { *sidebandHandle = (native_handle_t *)reply.readNativeHandle(); } return err; }"
"static std::string compute_O_value(std::string const& user_password, std::string const& owner_password, QPDF::EncryptionData const& data) { unsigned char O_key[OU_key_bytes_V4]; compute_O_rc4_key(user_password, owner_password, data, O_key); char upass[key_bytes]; pad_or_truncate_password_V4(user_password, upass); iterate_rc4(QUtil::unsigned_char_pointer(upass), key_bytes, O_key, data.getLengthBytes(), (data.getR() >= 3) ? 20 : 1, false); return std::string(upass, key_bytes); }"
"static void lsr_read_rare_full(GF_LASeRCodec *lsr, GF_Node *n) { GF_FieldInfo info; u32 i, nb_rare, field_rare; s32 field_tag; GF_LSR_READ_INT(lsr, nb_rare, 1, ""has_rare""); if (!nb_rare) return; GF_LSR_READ_INT(lsr, nb_rare, 6, ""nbOfAttributes""); for (i=0; i<nb_rare; i++) { GF_LSR_READ_INT(lsr, field_rare, 6, ""attributeRARE""); if (field_rare==49) { u32 extID, len, j; while (1) { GF_LSR_READ_INT(lsr, extID, lsr->info->cfg.extensionIDBits, ""extensionID""); len = lsr_read_vluimsbf5(lsr, ""len""); if (extID==2) { GF_LSR_READ_INT(lsr, len, 2, ""nbOfAttributes""); for (j=0; j<len; j++) { GF_LSR_READ_INT(lsr, extID, 3, ""attributeRARE""); switch (extID) { case 0: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_syncMaster, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""syncMaster""); break; case 1: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_focusHighlight, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_FocusHighlight *)info.far_ptr, 2, ""focusHighlight""); break; case 2: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_initialVisibility, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_InitialVisibility *)info.far_ptr, 2, ""initialVisibility""); break; case 3: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_fullscreen, GF_TRUE, GF_FALSE, &info); GF_LSR_READ_INT(lsr, *(SVG_Boolean *)info.far_ptr, 1, ""fullscreen""); break; case 4: lsr->last_error = gf_node_get_attribute_by_tag(n, TAG_SVG_ATT_requiredFonts, GF_TRUE, GF_FALSE, &info); lsr_read_byte_align_string_list(lsr, *(GF_List **)info.far_ptr, ""requiredFonts"", GF_FALSE, GF_TRUE); break; } } } else { gf_bs_read_int(lsr->bs, len); } GF_LSR_READ_INT(lsr, extID, 1, ""hasNextExtension""); if (!extID) break; } continue; } field_tag = gf_lsr_rare_type_to_attribute(field_rare); if (field_tag==-1) { return; } lsr->last_error = gf_node_get_attribute_by_tag(n, field_tag, GF_TRUE, GF_FALSE, &info); if (!info.far_ptr) lsr->last_error = GF_NOT_SUPPORTED; if (lsr->last_error) return; switch (field_tag) { case TAG_SVG_ATT__class: lsr_read_byte_align_string(lsr, info.far_ptr, ""class""); break; case TAG_SVG_ATT_audio_level: ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""audio-level""); break; case TAG_SVG_ATT_color: lsr_read_paint(lsr, (SVG_Paint *)info.far_ptr, ""color""); break; case TAG_SVG_ATT_color_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""color-rendering""); break; case TAG_SVG_ATT_display: GF_LSR_READ_INT(lsr, *(SVG_Display*)info.far_ptr, 5, ""display""); break; case TAG_SVG_ATT_display_align: GF_LSR_READ_INT(lsr, *(SVG_DisplayAlign*)info.far_ptr, 3, ""display-align""); break; case TAG_SVG_ATT_fill_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""fill-opacity""); break; case TAG_SVG_ATT_fill_rule: GF_LSR_READ_INT(lsr, *(SVG_FillRule*)info.far_ptr, 2, ""fill-rule""); break; case TAG_SVG_ATT_image_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 2, ""image-rendering""); break; case TAG_SVG_ATT_line_increment: lsr_read_line_increment_type(lsr, info.far_ptr, ""line-increment""); break; case TAG_SVG_ATT_pointer_events: GF_LSR_READ_INT(lsr, *(SVG_PointerEvents*)info.far_ptr, 4, ""pointer-events""); break; case TAG_SVG_ATT_shape_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""shape-rendering""); break; case TAG_SVG_ATT_solid_color: lsr_read_paint(lsr, info.far_ptr, ""solid-color""); break; case TAG_SVG_ATT_solid_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""solid-opacity""); break; case TAG_SVG_ATT_stop_color: lsr_read_paint(lsr, info.far_ptr, ""stop-color""); break; case TAG_SVG_ATT_stop_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stop-opacity""); break; case TAG_SVG_ATT_stroke_dasharray: { u32 j, flag; SVG_StrokeDashArray *da = (SVG_StrokeDashArray *)info.far_ptr; GF_LSR_READ_INT(lsr, flag, 1, ""dashArray""); if (flag) { da->type=SVG_STROKEDASHARRAY_INHERIT; } else { da->type=SVG_STROKEDASHARRAY_ARRAY; da->array.count = lsr_read_vluimsbf5(lsr, ""len""); da->array.vals = (Fixed*)gf_malloc(sizeof(Fixed)*da->array.count); da->array.units = (u8*)gf_malloc(sizeof(u8)*da->array.count); if (!da->array.vals || !da->array.units) { lsr->last_error = GF_OUT_OF_MEM; return; } for (j=0; j<da->array.count; j++) { da->array.vals[j] = lsr_read_fixed_16_8(lsr, ""dash""); da->array.units[j] = 0; if (lsr->last_error) return; } } } break; case TAG_SVG_ATT_stroke_dashoffset: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""dashOffset""); break; case TAG_SVG_ATT_stroke_linecap: GF_LSR_READ_INT(lsr, *(SVG_StrokeLineCap*)info.far_ptr, 2, ""stroke-linecap""); break; case TAG_SVG_ATT_stroke_linejoin: GF_LSR_READ_INT(lsr, *(SVG_StrokeLineJoin*)info.far_ptr, 2, ""stroke-linejoin""); break; case TAG_SVG_ATT_stroke_miterlimit: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""miterLimit""); break; case TAG_SVG_ATT_stroke_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""stroke-opacity""); break; case TAG_SVG_ATT_stroke_width: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""strokeWidth""); break; case TAG_SVG_ATT_text_anchor: GF_LSR_READ_INT(lsr, *(SVG_TextAnchor*)info.far_ptr, 2, ""text-achor""); break; case TAG_SVG_ATT_text_rendering: GF_LSR_READ_INT(lsr, *(SVG_RenderingHint*)info.far_ptr, 3, ""text-rendering""); break; case TAG_SVG_ATT_viewport_fill: lsr_read_paint(lsr, info.far_ptr, ""viewport-fill""); break; case TAG_SVG_ATT_viewport_fill_opacity: ((SVG_Number*)info.far_ptr)->type = SVG_NUMBER_VALUE; ((SVG_Number*)info.far_ptr)->value = lsr_read_fixed_clamp(lsr, ""viewport-fill-opacity""); break; case TAG_SVG_ATT_vector_effect: GF_LSR_READ_INT(lsr, *(SVG_VectorEffect*)info.far_ptr, 4, ""vector-effect""); break; case TAG_SVG_ATT_visibility: GF_LSR_READ_INT(lsr, *(SVG_Visibility*)info.far_ptr, 2, ""visibility""); break; case TAG_SVG_ATT_requiredExtensions: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredExtensions"", GF_TRUE, GF_FALSE); break; case TAG_SVG_ATT_requiredFormats: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""requiredFormats"", GF_FALSE, GF_FALSE); break; case TAG_SVG_ATT_requiredFeatures: { u32 j, fcount = lsr_read_vluimsbf5(lsr, ""count""); for (j=0; j<fcount; j++) { u32 fval; GF_LSR_READ_INT(lsr, fval, 6, ""feature""); if (lsr->last_error) return; } } break; case TAG_SVG_ATT_systemLanguage: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""systemLanguage"", GF_FALSE, GF_FALSE); break; case TAG_XML_ATT_base: lsr_read_byte_align_string(lsr, &((XMLRI*)info.far_ptr)->string, ""xml:base""); ((XMLRI*)info.far_ptr)->type = XMLRI_STRING; break; case TAG_XML_ATT_lang: lsr_read_byte_align_string(lsr, info.far_ptr, ""xml:lang""); break; case TAG_XML_ATT_space: GF_LSR_READ_INT(lsr, *(XML_Space*)info.far_ptr, 1, ""xml:space""); break; case TAG_SVG_ATT_nav_next: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNext""); break; case TAG_SVG_ATT_nav_up: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorth""); break; case TAG_SVG_ATT_nav_up_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthEast""); break; case TAG_SVG_ATT_nav_up_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusNorthWest""); break; case TAG_SVG_ATT_nav_prev: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusPrev""); break; case TAG_SVG_ATT_nav_down: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouth""); break; case TAG_SVG_ATT_nav_down_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthEast""); break; case TAG_SVG_ATT_nav_down_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusSouthWest""); break; case TAG_SVG_ATT_nav_left: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusEast""); break; case TAG_SVG_ATT_focusable: GF_LSR_READ_INT(lsr, *(SVG_Focusable*)info.far_ptr, 2, ""focusable""); break; case TAG_SVG_ATT_nav_right: lsr_read_focus(lsr, (SVG_Focus*)info.far_ptr, ""focusWest""); break; case TAG_SVG_ATT_transform: lsr_read_matrix(lsr, info.far_ptr); break; case TAG_SVG_ATT_text_decoration: lsr_read_byte_align_string_list(lsr, *(GF_List**)info.far_ptr, ""textDecoration"", GF_FALSE, GF_FALSE); break; case TAG_SVG_ATT_font_variant: GF_LSR_READ_INT(lsr, *(SVG_FontVariant*)info.far_ptr, 2, ""font-variant""); break; case TAG_SVG_ATT_font_family: { u32 flag; GF_LSR_READ_INT(lsr, flag, 1, ""isInherit""); if (flag) { ((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_INHERIT; } else { char *ft; ((SVG_FontFamily*)info.far_ptr)->type = SVG_FONTFAMILY_VALUE; GF_LSR_READ_INT(lsr, flag, lsr->fontIndexBits, ""fontIndex""); ft = (char*)gf_list_get(lsr->font_table, flag); if (ft) ((SVG_FontFamily*)info.far_ptr)->value = gf_strdup(ft); } } break; case TAG_SVG_ATT_font_size: lsr_read_fixed_16_8i(lsr, info.far_ptr, ""fontSize""); break; case TAG_SVG_ATT_font_style: GF_LSR_READ_INT(lsr, *(SVG_FontStyle*)info.far_ptr, 3, ""fontStyle""); break; case TAG_SVG_ATT_font_weight: GF_LSR_READ_INT(lsr, *(SVG_FontWeight*)info.far_ptr, 4, ""fontWeight""); break; case TAG_XLINK_ATT_title: lsr_read_byte_align_string(lsr, info.far_ptr, ""xlink:title""); break; case TAG_XLINK_ATT_type: GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:type""); break; case TAG_XLINK_ATT_role: lsr_read_any_uri(lsr, info.far_ptr, ""xlink:role""); break; case TAG_XLINK_ATT_arcrole: lsr_read_any_uri(lsr, info.far_ptr, ""xlink:arcrole""); break; case TAG_XLINK_ATT_actuate: GF_LSR_READ_INT(lsr, field_rare, 2, ""xlink:actuate""); break; case TAG_XLINK_ATT_show: GF_LSR_READ_INT(lsr, field_rare, 3, ""xlink:show""); break; case TAG_SVG_ATT_end: lsr_read_smil_times(lsr, NULL, 0, info.far_ptr, ""end"", 0); break; case TAG_SVG_ATT_max: lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0); break; case TAG_SVG_ATT_min: lsr_read_duration_ex(lsr, NULL, 0, info.far_ptr, ""min"", 0); break; } if (lsr->last_error) return; } }"
"void ZRLE_DECODE (const Rect& r, rdr::InStream* is, rdr::ZlibInStream* zis, const PixelFormat& pf, ModifiablePixelBuffer* pb) { int length = is->readU32(); zis->setUnderlying(is, length); Rect t; PIXEL_T buf[64 * 64]; for (t.tl.y = r.tl.y; t.tl.y < r.br.y; t.tl.y += 64) { t.br.y = __rfbmin(r.br.y, t.tl.y + 64); for (t.tl.x = r.tl.x; t.tl.x < r.br.x; t.tl.x += 64) { t.br.x = __rfbmin(r.br.x, t.tl.x + 64); int mode = zis->readU8(); bool rle = mode & 128; int palSize = mode & 127; PIXEL_T palette[128]; for (int i = 0; i < palSize; i++) { palette[i] = READ_PIXEL(zis); } if (palSize == 1) { PIXEL_T pix = palette[0]; pb->fillRect(pf, t, &pix); continue; } if (!rle) { if (palSize == 0) { #ifdef CPIXEL for (PIXEL_T* ptr = buf; ptr < buf+t.area(); ptr++) { *ptr = READ_PIXEL(zis); } #else zis->readBytes(buf, t.area() * (BPP / 8)); #endif } else { int bppp = ((palSize > 16) ? 8 : ((palSize > 4) ? 4 : ((palSize > 2) ? 2 : 1))); PIXEL_T* ptr = buf; for (int i = 0; i < t.height(); i++) { PIXEL_T* eol = ptr + t.width(); rdr::U8 byte = 0; rdr::U8 nbits = 0; while (ptr < eol) { if (nbits == 0) { byte = zis->readU8(); nbits = 8; } nbits -= bppp; rdr::U8 index = (byte >> nbits) & ((1 << bppp) - 1) & 127; *ptr++ = palette[index]; } } } } else { if (palSize == 0) { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { PIXEL_T pix = READ_PIXEL(zis); int len = 1; int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } while (len-- > 0) *ptr++ = pix; } } else { PIXEL_T* ptr = buf; PIXEL_T* end = ptr + t.area(); while (ptr < end) { int index = zis->readU8(); int len = 1; if (index & 128) { int b; do { b = zis->readU8(); len += b; } while (b == 255); if (end - ptr < len) { throw Exception (""ZRLE decode error""); } } index &= 127; PIXEL_T pix = palette[index]; while (len-- > 0) *ptr++ = pix; } } } pb->imageRect(pf, t, buf); } } zis->removeUnderlying(); }"
"static void dissect_rtmpt(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, rtmpt_packet_t *tp) { gint        offset         = 0; gchar      *sDesc          = NULL; gint        deschasopcode  = FALSE; gboolean    haveETS        = FALSE; guint32     iBodyOffset    = 0; guint32     iBodyRemain    = 0; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RTMP""); RTMPT_DEBUG(""Dissect: frame=%u visited=%d len=%d tree=%p\n"", pinfo->num, pinfo->fd->visited, tvb_reported_length_remaining(tvb, offset), tree); col_clear(pinfo->cinfo, COL_INFO); if (tvb_reported_length_remaining(tvb, offset) < 1) return; if (tp->id <= RTMPT_ID_MAX) { if (tp->fmt < 3 && tvb_reported_length_remaining(tvb, offset) >= tp->bhlen+3 && tvb_get_ntoh24(tvb, offset+tp->bhlen) == 0xffffff) { haveETS = TRUE; } iBodyOffset = offset + tp->bhlen + tp->mhlen; iBodyRemain = tvb_reported_length_remaining(tvb, iBodyOffset); if (tp->cmd == RTMPT_TYPE_CHUNK_SIZE && tp->len >= 4 && iBodyRemain >= 4) { guint32 newchunksize = tvb_get_ntohl(tvb, iBodyOffset); if (newchunksize < rtmpt_max_packet_size) { wmem_tree_insert32(rconv->chunksize[cdir], tp->lastseq, GINT_TO_POINTER(newchunksize)); } } if (!PINFO_FD_VISITED(pinfo)) { if (tp->cmd == RTMPT_TYPE_COMMAND_AMF0 || tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF0 || tp->cmd == RTMPT_TYPE_DATA_AMF3) { guint32 soff = 0; if (tp->cmd == RTMPT_TYPE_COMMAND_AMF3 || tp->cmd == RTMPT_TYPE_DATA_AMF3) { soff = 1; } tp->txid = rtmpt_get_amf_txid(tvb, iBodyOffset+soff); if (tp->txid != 0) { RTMPT_DEBUG(""got txid=%d\n"", tp->txid); wmem_tree_insert32(rconv->txids[cdir], tp->txid, GINT_TO_POINTER(pinfo->num)); } } } } if (tp->id <= RTMPT_ID_MAX) { sDesc = rtmpt_get_packet_desc(tvb, iBodyOffset, iBodyRemain, rconv, cdir, tp, &deschasopcode); } if (tp->id>RTMPT_ID_MAX) { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); col_set_fence(pinfo->cinfo, COL_INFO); } else if (sDesc) { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", sDesc); col_set_fence(pinfo->cinfo, COL_INFO); } else { col_append_sep_str(pinfo->cinfo, COL_INFO, ""|"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)"")); col_set_fence(pinfo->cinfo, COL_INFO); } if (tree) { proto_tree *rtmpt_tree     = NULL; proto_tree *rtmptroot_tree = NULL; proto_item *ti; ti = proto_tree_add_item(tree, proto_rtmpt, tvb, offset, -1, ENC_NA); if (tp->id > RTMPT_ID_MAX) { proto_item_append_text(ti, "" (%s)"", val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt); rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_handshake, NULL, val_to_str(tp->id, rtmpt_handshake_vals, ""Unknown (0x%01x)"")); if (tp->id == RTMPT_TYPE_HANDSHAKE_1) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c0, tvb, 0, 1, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c1, tvb, 1, 1536, ENC_NA); } else if (tp->id == RTMPT_TYPE_HANDSHAKE_2) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s0, tvb, 0, 1, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s1, tvb, 1, 1536, ENC_NA); proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_s2, tvb, 1537, 1536, ENC_NA); } else if (tp->id == RTMPT_TYPE_HANDSHAKE_3) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_handshake_c2, tvb, 0, 1536, ENC_NA); } return; } if (sDesc && deschasopcode) { proto_item_append_text(ti, "" (%s)"", sDesc); } else if (sDesc) { proto_item_append_text(ti, "" (%s %s)"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)""), sDesc); } else { proto_item_append_text(ti, "" (%s)"", val_to_str(tp->cmd, rtmpt_opcode_vals, ""Unknown (0x%01x)"")); } rtmptroot_tree = proto_item_add_subtree(ti, ett_rtmpt); if (tp->otherframe != 0) { proto_tree_add_uint(rtmptroot_tree, tp->isresponse ? hf_rtmpt_function_response : hf_rtmpt_function_call, tvb, offset, tp->bhlen+tp->mhlen+tp->len, tp->otherframe); } rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, tp->bhlen+tp->mhlen, ett_rtmpt_header, NULL, RTMPT_TEXT_RTMP_HEADER); if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_format, tvb, offset + 0, 1, ENC_BIG_ENDIAN); if (tp->fmt <= 3) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_csid, tvb, offset + 0, tp->bhlen, ENC_BIG_ENDIAN); if (tp->fmt <= 2) { if (tp->fmt > 0) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp_delta, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN); } else { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 3, ENC_BIG_ENDIAN); } if (haveETS) { proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_ets, tvb, offset + tp->bhlen + tp->mhlen - 4, 4, ENC_BIG_ENDIAN); } } if ((tp->fmt>0 && !haveETS) || tp->fmt == 3) { proto_tree_add_uint_format_value(rtmpt_tree, hf_rtmpt_header_timestamp, tvb, offset + tp->bhlen, 0, tp->ts, ""%d (calculated)"", tp->ts); } if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_body_size, tvb, offset + tp->bhlen + 3, 3, ENC_BIG_ENDIAN); if (tp->fmt <= 1) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_typeid, tvb, offset + tp->bhlen + 6, 1, ENC_BIG_ENDIAN); if (tp->fmt <= 0) proto_tree_add_item(rtmpt_tree, hf_rtmpt_header_streamid, tvb, offset + tp->bhlen + 7, 4, ENC_LITTLE_ENDIAN); if (tp->len == 0) return; offset = iBodyOffset; rtmpt_tree = proto_tree_add_subtree(rtmptroot_tree, tvb, offset, -1, ett_rtmpt_body, NULL, RTMPT_TEXT_RTMP_BODY); switch (tp->cmd) { case RTMPT_TYPE_CHUNK_SIZE: case RTMPT_TYPE_ABORT_MESSAGE: case RTMPT_TYPE_ACKNOWLEDGEMENT: case RTMPT_TYPE_UCM: case RTMPT_TYPE_WINDOW: case RTMPT_TYPE_PEER_BANDWIDTH: dissect_rtmpt_body_scm(tvb, offset, rtmpt_tree, tp->cmd); break; case RTMPT_TYPE_COMMAND_AMF0: case RTMPT_TYPE_DATA_AMF0: dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, FALSE); break; case RTMPT_TYPE_COMMAND_AMF3: case RTMPT_TYPE_DATA_AMF3: dissect_rtmpt_body_command(tvb, offset, rtmpt_tree, TRUE); break; case RTMPT_TYPE_AUDIO_DATA: dissect_rtmpt_body_audio(tvb, offset, rtmpt_tree); break; case RTMPT_TYPE_VIDEO_DATA: dissect_rtmpt_body_video(tvb, offset, rtmpt_tree); break; case RTMPT_TYPE_AGGREGATE: dissect_rtmpt_body_aggregate(tvb, offset, rtmpt_tree); break; } } }"
"static int includeFile(FileInfo *nested, CharsString *includedFile, CharacterClass **characterClasses, TranslationTableCharacterAttributes *characterClassAttribute, short opcodeLengths[], TranslationTableOffset *newRuleOffset, TranslationTableRule **newRule, RuleName **ruleNames, TranslationTableHeader **table) { int k; char includeThis[MAXSTRING]; char **tableFiles; int rv; for (k = 0; k < includedFile->length; k++) includeThis[k] = (char)includedFile->chars[k]; includeThis[k] = 0; tableFiles = _lou_resolveTable(includeThis, nested->fileName); if (tableFiles == NULL) { errorCount++; return 0; } if (tableFiles[1] != NULL) { errorCount++; free_tablefiles(tableFiles); _lou_logMessage(LOG_ERROR, ""Table list not supported in include statement: 'include %s'"", includeThis); return 0; } rv = compileFile(*tableFiles, characterClasses, characterClassAttribute, opcodeLengths, newRuleOffset, newRule, ruleNames, table); free_tablefiles(tableFiles); return rv; }"
"static ssize_t aio_setup_single_vector(struct kiocb *kiocb, int rw, char __user *buf, unsigned long *nr_segs, size_t len, struct iovec *iovec) { if (unlikely(!access_ok(!rw, buf, len))) return -EFAULT; iovec->iov_base = buf; iovec->iov_len = len; *nr_segs = 1; return 0; }"
"static ssize_t hfi1_file_write(struct file *fp, const char __user *data, size_t count, loff_t *offset) { const struct hfi1_cmd __user *ucmd; struct hfi1_filedata *fd = fp->private_data; struct hfi1_ctxtdata *uctxt = fd->uctxt; struct hfi1_cmd cmd; struct hfi1_user_info uinfo; struct hfi1_tid_info tinfo; unsigned long addr; ssize_t consumed = 0, copy = 0, ret = 0; void *dest = NULL; __u64 user_val = 0; int uctxt_required = 1; int must_be_root = 0; if (count < sizeof(cmd)) { ret = -EINVAL; goto bail; } ucmd = (const struct hfi1_cmd __user *)data; if (copy_from_user(&cmd, ucmd, sizeof(cmd))) { ret = -EFAULT; goto bail; } consumed = sizeof(cmd); switch (cmd.type) { case HFI1_CMD_ASSIGN_CTXT: uctxt_required = 0; copy = sizeof(uinfo); dest = &uinfo; break; case HFI1_CMD_SDMA_STATUS_UPD: case HFI1_CMD_CREDIT_UPD: copy = 0; break; case HFI1_CMD_TID_UPDATE: case HFI1_CMD_TID_FREE: case HFI1_CMD_TID_INVAL_READ: copy = sizeof(tinfo); dest = &tinfo; break; case HFI1_CMD_USER_INFO: case HFI1_CMD_RECV_CTRL: case HFI1_CMD_POLL_TYPE: case HFI1_CMD_ACK_EVENT: case HFI1_CMD_CTXT_INFO: case HFI1_CMD_SET_PKEY: case HFI1_CMD_CTXT_RESET: copy = 0; user_val = cmd.addr; break; case HFI1_CMD_EP_INFO: case HFI1_CMD_EP_ERASE_CHIP: case HFI1_CMD_EP_ERASE_RANGE: case HFI1_CMD_EP_READ_RANGE: case HFI1_CMD_EP_WRITE_RANGE: uctxt_required = 0; must_be_root = 1; copy = 0; break; default: ret = -EINVAL; goto bail; } if (copy) { if (copy_from_user(dest, (void __user *)cmd.addr, copy)) { ret = -EFAULT; goto bail; } consumed += copy; } if (uctxt_required && !uctxt) { ret = -EINVAL; goto bail; } if (must_be_root && !capable(CAP_SYS_ADMIN)) { ret = -EPERM; goto bail; } switch (cmd.type) { case HFI1_CMD_ASSIGN_CTXT: ret = assign_ctxt(fp, &uinfo); if (ret < 0) goto bail; ret = setup_ctxt(fp); if (ret) goto bail; ret = user_init(fp); break; case HFI1_CMD_CTXT_INFO: ret = get_ctxt_info(fp, (void __user *)(unsigned long) user_val, cmd.len); break; case HFI1_CMD_USER_INFO: ret = get_base_info(fp, (void __user *)(unsigned long) user_val, cmd.len); break; case HFI1_CMD_SDMA_STATUS_UPD: break; case HFI1_CMD_CREDIT_UPD: if (uctxt && uctxt->sc) sc_return_credits(uctxt->sc); break; case HFI1_CMD_TID_UPDATE: ret = hfi1_user_exp_rcv_setup(fp, &tinfo); if (!ret) { addr = (unsigned long)cmd.addr + offsetof(struct hfi1_tid_info, tidcnt); if (copy_to_user((void __user *)addr, &tinfo.tidcnt, sizeof(tinfo.tidcnt) + sizeof(tinfo.length))) ret = -EFAULT; } break; case HFI1_CMD_TID_INVAL_READ: ret = hfi1_user_exp_rcv_invalid(fp, &tinfo); if (ret) break; addr = (unsigned long)cmd.addr + offsetof(struct hfi1_tid_info, tidcnt); if (copy_to_user((void __user *)addr, &tinfo.tidcnt, sizeof(tinfo.tidcnt))) ret = -EFAULT; break; case HFI1_CMD_TID_FREE: ret = hfi1_user_exp_rcv_clear(fp, &tinfo); if (ret) break; addr = (unsigned long)cmd.addr + offsetof(struct hfi1_tid_info, tidcnt); if (copy_to_user((void __user *)addr, &tinfo.tidcnt, sizeof(tinfo.tidcnt))) ret = -EFAULT; break; case HFI1_CMD_RECV_CTRL: ret = manage_rcvq(uctxt, fd->subctxt, (int)user_val); break; case HFI1_CMD_POLL_TYPE: uctxt->poll_type = (typeof(uctxt->poll_type))user_val; break; case HFI1_CMD_ACK_EVENT: ret = user_event_ack(uctxt, fd->subctxt, user_val); break; case HFI1_CMD_SET_PKEY: if (HFI1_CAP_IS_USET(PKEY_CHECK)) ret = set_ctxt_pkey(uctxt, fd->subctxt, user_val); else ret = -EPERM; break; case HFI1_CMD_CTXT_RESET: { struct send_context *sc; struct hfi1_devdata *dd; if (!uctxt || !uctxt->dd || !uctxt->sc) { ret = -EINVAL; break; } dd = uctxt->dd; sc = uctxt->sc; wait_event_interruptible_timeout( sc->halt_wait, (sc->flags & SCF_HALTED), msecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT)); if (!(sc->flags & SCF_HALTED)) { ret = -ENOLCK; break; } if (sc->flags & SCF_FROZEN) { wait_event_interruptible_timeout( dd->event_queue, !(ACCESS_ONCE(dd->flags) & HFI1_FROZEN), msecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT)); if (dd->flags & HFI1_FROZEN) { ret = -ENOLCK; break; } if (dd->flags & HFI1_FORCED_FREEZE) { ret = -ENODEV; break; } sc_disable(sc); ret = sc_enable(sc); hfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_ENB, uctxt->ctxt); } else { ret = sc_restart(sc); } if (!ret) sc_return_credits(sc); break; } case HFI1_CMD_EP_INFO: case HFI1_CMD_EP_ERASE_CHIP: case HFI1_CMD_EP_ERASE_RANGE: case HFI1_CMD_EP_READ_RANGE: case HFI1_CMD_EP_WRITE_RANGE: ret = handle_eprom_command(fp, &cmd); break; } if (ret >= 0) ret = consumed; bail: return ret; }"
"static int str_lower_case_match(OnigEncoding enc, int case_fold_flag, const UChar* t, const UChar* tend, const UChar* p, const UChar* end) { int lowlen; UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN]; while (t < tend) { lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf); q = lowbuf; while (lowlen > 0) { if (*t++ != *q++) return 0; lowlen--; } } return 1; }"
"static int eval7( char_u**arg, typval_T*rettv, evalarg_T*evalarg, intwant_string){ intevaluate = evalarg != NULL && (evalarg->eval_flags & EVAL_EVALUATE); intlen; char_u*s; char_u*name_start = NULL; char_u*start_leader, *end_leader; intret = OK; char_u*alias; rettv->v_type = VAR_UNKNOWN; start_leader = *arg; if (eval_leader(arg, in_vim9script()) == FAIL) return FAIL; end_leader = *arg; if (**arg == '.' && (!isdigit(*(*arg + 1)) #ifdef FEAT_FLOAT || in_old_script(2) #endif )) { semsg(_(e_invalid_expression_str), *arg); ++*arg; return FAIL; } switch (**arg) { case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case '.':ret = eval_number(arg, rettv, evaluate, want_string); if (ret == OK && evaluate && end_leader > start_leader && rettv->v_type != VAR_BLOB) ret = eval7_leader(rettv, TRUE, start_leader, &end_leader); break; case '""':ret = eval_string(arg, rettv, evaluate); break; case '\'':ret = eval_lit_string(arg, rettv, evaluate); break; case '[':ret = eval_list(arg, rettv, evalarg, TRUE); break; case '#':if (in_vim9script()) { ret = vim9_bad_comment(*arg) ? FAIL : NOTDONE; } else if ((*arg)[1] == '{') { ++*arg; ret = eval_dict(arg, rettv, evalarg, TRUE); } else ret = NOTDONE; break; case '{':if (in_vim9script()) ret = NOTDONE; else ret = get_lambda_tv(arg, rettv, in_vim9script(), evalarg); if (ret == NOTDONE) ret = eval_dict(arg, rettv, evalarg, FALSE); break; case '&':ret = eval_option(arg, rettv, evaluate); break; case '$':ret = eval_env_var(arg, rettv, evaluate); break; case '@':++*arg; if (evaluate) { if (in_vim9script() && IS_WHITE_OR_NUL(**arg)) semsg(_(e_syntax_error_at_str), *arg); else if (in_vim9script() && !valid_yank_reg(**arg, FALSE)) emsg_invreg(**arg); else { rettv->v_type = VAR_STRING; rettv->vval.v_string = get_reg_contents(**arg, GREG_EXPR_SRC); } } if (**arg != NUL) ++*arg; break; case '(':ret = NOTDONE; if (in_vim9script()) { ret = get_lambda_tv(arg, rettv, TRUE, evalarg); if (ret == OK && evaluate) { ufunc_T *ufunc = rettv->vval.v_partial->pt_func; if (ufunc->uf_ret_type->tt_type == VAR_VOID) ufunc->uf_ret_type = &t_unknown; if (compile_def_function(ufunc, FALSE, COMPILE_TYPE(ufunc), NULL) == FAIL) { clear_tv(rettv); ret = FAIL; } } } if (ret == NOTDONE) { *arg = skipwhite_and_linebreak(*arg + 1, evalarg); ret = eval1(arg, rettv, evalarg); *arg = skipwhite_and_linebreak(*arg, evalarg); if (**arg == ')') ++*arg; else if (ret == OK) { emsg(_(e_missing_closing_paren)); clear_tv(rettv); ret = FAIL; } } break; default:ret = NOTDONE; break; } if (ret == NOTDONE) { s = *arg; len = get_name_len(arg, &alias, evaluate, TRUE); if (alias != NULL) s = alias; if (len <= 0) ret = FAIL; else { int    flags = evalarg == NULL ? 0 : evalarg->eval_flags; if (evaluate && in_vim9script() && len == 1 && *s == '_') { emsg(_(e_cannot_use_underscore_here)); ret = FAIL; } else if ((in_vim9script() ? **arg : *skipwhite(*arg)) == '(') { *arg = skipwhite(*arg); ret = eval_func(arg, evalarg, s, len, rettv, flags, NULL); } else if (flags & EVAL_CONSTANT) ret = FAIL; else if (evaluate) { if (len == 4 && in_vim9script() && STRNCMP(s, ""true"", 4) == 0) { rettv->v_type = VAR_BOOL; rettv->vval.v_number = VVAL_TRUE; ret = OK; } else if (len == 5 && in_vim9script() && STRNCMP(s, ""false"", 5) == 0) { rettv->v_type = VAR_BOOL; rettv->vval.v_number = VVAL_FALSE; ret = OK; } else if (len == 4 && in_vim9script() && STRNCMP(s, ""null"", 4) == 0) { rettv->v_type = VAR_SPECIAL; rettv->vval.v_number = VVAL_NULL; ret = OK; } else { name_start = s; ret = eval_variable(s, len, 0, rettv, NULL, EVAL_VAR_VERBOSE + EVAL_VAR_IMPORT); } } else { check_vars(s, len); ret = OK; } } vim_free(alias); } if (ret == OK) ret = handle_subscript(arg, name_start, rettv, evalarg, TRUE); if (ret == OK && evaluate && end_leader > start_leader) ret = eval7_leader(rettv, FALSE, start_leader, &end_leader); return ret; }"
"DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context) : ObjectBackedNativeHandler(context), weak_factory_(this) { RouteFunction(""StartSession"", base::Bind(&DisplaySourceCustomBindings::StartSession, weak_factory_.GetWeakPtr())); RouteFunction(""TerminateSession"", base::Bind(&DisplaySourceCustomBindings::TerminateSession, weak_factory_.GetWeakPtr())); }"
void* H264SwDecMalloc(u32 size) { return malloc(size); }
"bool ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr, const char **elem_rtrn, const char **field_rtrn, ExprDef **index_rtrn) { switch (expr->expr.op) { case EXPR_IDENT: *elem_rtrn = NULL; *field_rtrn = xkb_atom_text(ctx, expr->ident.ident); *index_rtrn = NULL; return (*field_rtrn != NULL); case EXPR_FIELD_REF: *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element); *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field); *index_rtrn = NULL; return true; case EXPR_ARRAY_REF: *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element); *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field); *index_rtrn = expr->array_ref.entry; return true; default: break; } log_wsgo(ctx, ""Unexpected operator %d in ResolveLhs\n"", expr->expr.op); return false; }"
"void CreateAudioBroadcast( bool is_public, const std::string& broadcast_name, const std::optional<bluetooth::le_audio::BroadcastCode>& broadcast_code, const std::vector<uint8_t>& public_metadata, const std::vector<uint8_t>& subgroup_quality, const std::vector<std::vector<uint8_t>>& subgroup_metadata) override { uint8_t public_features = 0; LeAudioLtvMap public_ltv; std::vector<LeAudioLtvMap> subgroup_ltvs; if (is_public) { bool is_metadata_valid; public_ltv = LeAudioLtvMap::Parse( public_metadata.data(), public_metadata.size(), is_metadata_valid); if (!is_metadata_valid) { LOG_ERROR(""Invalid metadata provided.""); return; } public_features = static_cast<uint8_t>(broadcast_code ? 1 : 0); } auto broadcast_id = available_broadcast_ids_.back(); available_broadcast_ids_.pop_back(); if (available_broadcast_ids_.size() == 0) GenerateBroadcastIds(); auto context_type = AudioContexts(LeAudioContextType::MEDIA); if (stack_config_get_interface() ->get_pts_force_le_audio_multiple_contexts_metadata()) { context_type = LeAudioContextType::MEDIA | LeAudioContextType::CONVERSATIONAL; } for (const uint8_t quality : subgroup_quality) { if (quality == bluetooth::le_audio::QUALITY_STANDARD) { public_features |= bluetooth::le_audio::kLeAudioQualityStandard; } else if (quality == bluetooth::le_audio::QUALITY_HIGH) { public_features |= bluetooth::le_audio::kLeAudioQualityHigh; } } for (const std::vector<uint8_t>& metadata : subgroup_metadata) { bool is_metadata_valid; auto ltv = LeAudioLtvMap::Parse(metadata.data(), metadata.size(), is_metadata_valid); if (!is_metadata_valid) { LOG_ERROR(""Invalid metadata provided.""); return; } if (stack_config_get_interface() ->get_pts_force_le_audio_multiple_contexts_metadata()) { auto stream_context_vec = ltv.Find( le_audio::types::kLeAudioMetadataTypeStreamingAudioContext); if (stream_context_vec) { auto pp = stream_context_vec.value().data(); UINT16_TO_STREAM(pp, context_type.value()); } } auto stream_context_vec = ltv.Find(le_audio::types::kLeAudioMetadataTypeStreamingAudioContext); if (stream_context_vec) { auto pp = stream_context_vec.value().data(); STREAM_TO_UINT16(context_type.value_ref(), pp); } auto ccid_vec = ContentControlIdKeeper::GetInstance()->GetAllCcids(context_type); if (!ccid_vec.empty()) { ltv.Add(le_audio::types::kLeAudioMetadataTypeCcidList, ccid_vec); } subgroup_ltvs.push_back(ltv); } if (CodecManager::GetInstance()->GetCodecLocation() == CodecLocation::ADSP) { auto offload_config = CodecManager::GetInstance()->GetBroadcastOffloadConfig(); if (offload_config == nullptr) { LOG_ERROR(""No valid broadcast offload config""); return; } BroadcastCodecWrapper codec_config( {.coding_format = le_audio::types::kLeAudioCodingFormatLC3, .vendor_company_id = le_audio::types::kLeAudioVendorCompanyIdUndefined, .vendor_codec_id = le_audio::types::kLeAudioVendorCodecIdUndefined}, {.num_channels = static_cast<uint8_t>(offload_config->stream_map.size()), .sample_rate = offload_config->sampling_rate, .bits_per_sample = offload_config->bits_per_sample, .data_interval_us = offload_config->frame_duration}, offload_config->codec_bitrate, offload_config->octets_per_frame); BroadcastQosConfig qos_config(offload_config->retransmission_number, offload_config->max_transport_latency); BroadcastStateMachineConfig msg = { .is_public = is_public, .broadcast_name = broadcast_name, .broadcast_id = broadcast_id, .streaming_phy = GetStreamingPhy(), .codec_wrapper = codec_config, .qos_config = qos_config, .announcement = prepareBasicAnnouncement(codec_config, subgroup_ltvs), .broadcast_code = std::move(broadcast_code)}; if (is_public) { msg.public_announcement = preparePublicAnnouncement(public_features, public_ltv); } pending_broadcasts_.push_back( std::move(BroadcastStateMachine::CreateInstance(std::move(msg)))); } else { auto codec_qos_pair = le_audio::broadcaster::getStreamConfigForContext(context_type); BroadcastStateMachineConfig msg = { .is_public = is_public, .broadcast_name = broadcast_name, .broadcast_id = broadcast_id, .streaming_phy = GetStreamingPhy(), .codec_wrapper = codec_qos_pair.first, .qos_config = codec_qos_pair.second, .announcement = prepareBasicAnnouncement(codec_qos_pair.first, subgroup_ltvs), .broadcast_code = std::move(broadcast_code)}; if (is_public) { msg.public_announcement = preparePublicAnnouncement(public_features, public_ltv); } pending_broadcasts_.push_back( std::move(BroadcastStateMachine::CreateInstance(std::move(msg)))); } LOG_INFO(""CreateAudioBroadcast""); if (!pending_broadcasts_.back()->Initialize()) { pending_broadcasts_.pop_back(); callbacks_->OnBroadcastCreated(bluetooth::le_audio::kBroadcastIdInvalid, false); } }"
"lyd_node * lyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name) { const struct lys_node *schema = NULL, *snode; if (!module || !name_template || !name) { LOGARG; return NULL; } schema = lyp_get_yang_data_template(module, name_template, strlen(name_template)); if (!schema) { LOGERR(module->ctx, LY_EINVAL, ""Failed to find yang-data template \""%s\""."", name_template); return NULL; } if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) { LOGERR(module->ctx, LY_EINVAL, ""Failed to find \""%s\"" as a container child of \""%s:%s\""."", name, module->name, schema->name); return NULL; } return _lyd_new(NULL, snode, 0); }"
"void qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line, const char *fmt, ...) { va_list va; struct va_format vaf; char nfunc[32]; memset(nfunc, 0, sizeof(nfunc)); memcpy(nfunc, func, sizeof(nfunc) - 1); va_start(va, fmt); vaf.fmt = fmt; vaf.va = &va; if (likely(qedi) && likely(qedi->pdev)) pr_err(""[%s]:[%s:%d]:%d: %pV"", dev_name(&qedi->pdev->dev), nfunc, line, qedi->host_no, &vaf); else pr_err(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf); va_end(va); }"
"static void wsdl_soap_binding_body(sdlCtx* ctx, xmlNodePtr node, char* wsdl_soap_namespace, sdlSoapBindingFunctionBody *binding, HashTable* params) { xmlNodePtr body, trav; xmlAttrPtr tmp; trav = node->children; while (trav != NULL) { if (node_is_equal_ex(trav, ""body"", wsdl_soap_namespace)) { body = trav; tmp = get_attribute(body->properties, ""use""); if (tmp && !strncmp((char*)tmp->children->content, ""literal"", sizeof(""literal""))) { binding->use = SOAP_LITERAL; } else { binding->use = SOAP_ENCODED; } tmp = get_attribute(body->properties, ""namespace""); if (tmp) { binding->ns = estrdup((char*)tmp->children->content); } tmp = get_attribute(body->properties, ""parts""); if (tmp) { HashTable    ht; char *parts = (char*)tmp->children->content; zend_hash_init(&ht, 0, NULL, delete_parameter, 0); while (*parts) { sdlParamPtr param; int found = 0; char *end; while (*parts == ' ') ++parts; if (*parts == '\0') break; end = strchr(parts, ' '); if (end) *end = '\0'; ZEND_HASH_FOREACH_PTR(params, param) { if (param->paramName && strcmp(parts, param->paramName) == 0) { sdlParamPtr x_param; x_param = emalloc(sizeof(sdlParam)); *x_param = *param; param->paramName = NULL; zend_hash_next_index_insert_ptr(&ht, x_param); found = 1; break; } } ZEND_HASH_FOREACH_END(); if (!found) { soap_error1(E_ERROR, ""Parsing WSDL: Missing part '%s' in <message>"", parts); } parts += strlen(parts); if (end) *end = ' '; } zend_hash_destroy(params); *params = ht; } if (binding->use == SOAP_ENCODED) { tmp = get_attribute(body->properties, ""encodingStyle""); if (tmp) { if (strncmp((char*)tmp->children->content, SOAP_1_1_ENC_NAMESPACE, sizeof(SOAP_1_1_ENC_NAMESPACE)) == 0) { binding->encodingStyle = SOAP_ENCODING_1_1; } else if (strncmp((char*)tmp->children->content, SOAP_1_2_ENC_NAMESPACE, sizeof(SOAP_1_2_ENC_NAMESPACE)) == 0) { binding->encodingStyle = SOAP_ENCODING_1_2; } else { soap_error1(E_ERROR, ""Parsing WSDL: Unknown encodingStyle '%s'"", tmp->children->content); } } else { soap_error0(E_ERROR, ""Parsing WSDL: Unspecified encodingStyle""); } } } else if (node_is_equal_ex(trav, ""header"", wsdl_soap_namespace)) { sdlSoapBindingFunctionHeaderPtr h = wsdl_soap_binding_header(ctx, trav, wsdl_soap_namespace, 0); smart_str key = {0}; if (binding->headers == NULL) { binding->headers = emalloc(sizeof(HashTable)); zend_hash_init(binding->headers, 0, NULL, delete_header, 0); } if (h->ns) { smart_str_appends(&key,h->ns); smart_str_appendc(&key,':'); } smart_str_appends(&key,h->name); smart_str_0(&key); if (zend_hash_add_ptr(binding->headers, key.s, h) == NULL) { delete_header_int(h); } smart_str_free(&key); } else if (is_wsdl_element(trav) && !node_is_equal(trav,""documentation"")) { soap_error1(E_ERROR, ""Parsing WSDL: Unexpected WSDL element <%s>"", trav->name); } trav = trav->next; } }"
"static void build_lswitch_destination_lookup_bmcast(struct ovn_datapath *od, struct hmap *lflows, struct ds *actions, const struct shash *meter_groups) { if (od->nbs) { ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110, ""eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)"", ""handle_svc_check(inport);""); struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw; if (mcast_sw_info->enabled) { ds_clear(actions); ds_put_cstr(actions, ""igmp;""); ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100, ""igmp"", ds_cstr(actions), copp_meter_get(COPP_IGMP, od->nbs->copp, meter_groups)); ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100, ""mldv1 || mldv2"", ds_cstr(actions), copp_meter_get(COPP_IGMP, od->nbs->copp, meter_groups)); ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85, ""ip4.mcast && ip4.dst == 224.0.0.0/24"", ""outport = \""""MC_FLOOD_L2""\""; output;""); ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85, ""ip6.mcast_flood"", ""outport = \""""MC_FLOOD""\""; output;""); if (!mcast_sw_info->flood_unregistered) { ds_clear(actions); if (mcast_sw_info->flood_relay) { ds_put_cstr(actions, ""clone { "" ""outport = \""""MC_MROUTER_FLOOD""\""; "" ""output; "" ""}; ""); } if (mcast_sw_info->flood_static) { ds_put_cstr(actions, ""outport =\""""MC_STATIC""\""; output;""); } if (!mcast_sw_info->flood_relay && !mcast_sw_info->flood_static) { ds_put_cstr(actions, debug_drop_action()); } ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80, ""ip4.mcast || ip6.mcast"", ds_cstr(actions)); } } ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, ""eth.mcast"", ""outport = \""""MC_FLOOD""\""; output;""); } }"
static void cil_reset_perm(struct cil_perm *perm) { cil_reset_classperms_list(perm->classperms); }
"static void tcp_internal_pacing(struct sock *sk, const struct sk_buff *skb) { u64 len_ns; u32 rate; if (!tcp_needs_internal_pacing(sk)) return; rate = sk->sk_pacing_rate; if (!rate || rate == ~0U) return; len_ns = (u64)skb->len * NSEC_PER_SEC; do_div(len_ns, rate); hrtimer_start(&tcp_sk(sk)->pacing_timer, ktime_add_ns(ktime_get(), len_ns), HRTIMER_MODE_ABS_PINNED_SOFT); sock_hold(sk); }"
"int proxy_authentication(zval* this_ptr, smart_str* soap_headers TSRMLS_DC) { zval **login, **password; if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_proxy_login"", sizeof(""_proxy_login""), (void **)&login) == SUCCESS) { unsigned char* buf; int len; smart_str auth = {0}; smart_str_appendl(&auth, Z_STRVAL_PP(login), Z_STRLEN_PP(login)); smart_str_appendc(&auth, ':'); if (zend_hash_find(Z_OBJPROP_P(this_ptr), ""_proxy_password"", sizeof(""_proxy_password""), (void **)&password) == SUCCESS) { smart_str_appendl(&auth, Z_STRVAL_PP(password), Z_STRLEN_PP(password)); } smart_str_0(&auth); buf = php_base64_encode((unsigned char*)auth.c, auth.len, &len); smart_str_append_const(soap_headers, ""Proxy-Authorization: Basic ""); smart_str_appendl(soap_headers, (char*)buf, len); smart_str_append_const(soap_headers, ""\r\n""); efree(buf); smart_str_free(&auth); return 1; } return 0; }"
"static MagickBooleanType load_tile(Image *image,Image *tile_image, XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length, ExceptionInfo *exception) { ssize_t y; register ssize_t x; register Quantum *q; ssize_t count; unsigned char *graydata; XCFPixelInfo *xcfdata, *xcfodata; xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata)); if (xcfdata == (XCFPixelInfo *) NULL) ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); xcfodata=xcfdata; graydata=(unsigned char *) xcfdata;   count=ReadBlob(image,data_length,(unsigned char *) xcfdata); if (count != (ssize_t) data_length) ThrowBinaryException(CorruptImageError,""NotEnoughPixelData"", image->filename); for (y=0; y < (ssize_t) tile_image->rows; y++) { q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception); if (q == (Quantum *) NULL) break; if (inDocInfo->image_type == GIMP_GRAY) { for (x=0; x < (ssize_t) tile_image->columns; x++) { SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q); SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q); graydata++; q+=GetPixelChannels(tile_image); } } else if (inDocInfo->image_type == GIMP_RGB) { for (x=0; x < (ssize_t) tile_image->columns; x++) { SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q); SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q); SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q); SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha : ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q); xcfdata++; q+=GetPixelChannels(tile_image); } } if (SyncAuthenticPixels(tile_image,exception) == MagickFalse) break; } xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata); return MagickTrue; }"
"int proc_pid_readdir(struct file * filp, void * dirent, filldir_t filldir) { unsigned int nr; struct task_struct *reaper; struct tgid_iter iter; struct pid_namespace *ns; if (filp->f_pos >= PID_MAX_LIMIT + TGID_OFFSET) goto out_no_task; nr = filp->f_pos - FIRST_PROCESS_ENTRY; reaper = get_proc_task(filp->f_path.dentry->d_inode); if (!reaper) goto out_no_task; for (; nr < ARRAY_SIZE(proc_base_stuff); filp->f_pos++, nr++) { const struct pid_entry *p = &proc_base_stuff[nr]; if (proc_base_fill_cache(filp, dirent, filldir, reaper, p) < 0) goto out; } ns = filp->f_dentry->d_sb->s_fs_info; iter.task = NULL; iter.tgid = filp->f_pos - TGID_OFFSET; for (iter = next_tgid(ns, iter); iter.task; iter.tgid += 1, iter = next_tgid(ns, iter)) { filp->f_pos = iter.tgid + TGID_OFFSET; if (proc_pid_fill_cache(filp, dirent, filldir, iter) < 0) { put_task_struct(iter.task); goto out; } } filp->f_pos = PID_MAX_LIMIT + TGID_OFFSET; out: put_task_struct(reaper); out_no_task: return 0; }"
"static void vgacon_restore_screen(struct vc_data *c) { c->vc_origin = c->vc_visible_origin; vgacon_scrollback_cur->save = 0; if (!vga_is_gfx && !vgacon_scrollback_cur->restore) { scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf, c->vc_screenbuf_size > vga_vram_size ? vga_vram_size : c->vc_screenbuf_size); vgacon_scrollback_cur->restore = 1; vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt; } }"
"static int vmx_check_intercept(struct kvm_vcpu *vcpu, struct x86_instruction_info *info, enum x86_intercept_stage stage) { struct vmcs12 *vmcs12 = get_vmcs12(vcpu); struct x86_emulate_ctxt *ctxt = &vcpu->arch.emulate_ctxt; if (info->intercept == x86_intercept_rdtscp && !nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) { ctxt->exception.vector = UD_VECTOR; ctxt->exception.error_code_valid = false; return X86EMUL_PROPAGATE_FAULT; } return X86EMUL_CONTINUE; }"
"static bool extractFileTo(zip* zip, const std::string &file, std::string& to, char* buf, size_t len) { auto sep = file.rfind('/'); if (sep != std::string::npos) { auto path = to + file.substr(0, sep); if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) { return false; } if (sep == file.length() - 1) { return true; } } to.append(file); struct zip_stat zipStat; if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) { return false; } auto zipFile = zip_fopen_index(zip, zipStat.index, 0); FAIL_IF_INVALID_PTR(zipFile); auto outFile = fopen(to.c_str(), ""wb""); if (outFile == nullptr) { zip_fclose(zipFile); return false; } for (auto n = zip_fread(zipFile, buf, len); n != 0; n = zip_fread(zipFile, buf, len)) { if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) { zip_fclose(zipFile); fclose(outFile); remove(to.c_str()); return false; } } zip_fclose(zipFile); if (fclose(outFile) != 0) { return false; } return true; }"
"static int jpc_dec_tiledecode(jpc_dec_t *dec, jpc_dec_tile_t *tile) { int i; int j; jpc_dec_tcomp_t *tcomp; jpc_dec_rlvl_t *rlvl; jpc_dec_band_t *band; int compno; int rlvlno; int bandno; int adjust; int v; jpc_dec_ccp_t *ccp; jpc_dec_cmpt_t *cmpt; if (jpc_dec_decodecblks(dec, tile)) { jas_eprintf(""jpc_dec_decodecblks failed\n""); return -1; } for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps; ++compno, ++tcomp) { ccp = &tile->cp->ccps[compno]; for (rlvlno = 0, rlvl = tcomp->rlvls; rlvlno < tcomp->numrlvls; ++rlvlno, ++rlvl) { if (!rlvl->bands) { continue; } for (bandno = 0, band = rlvl->bands; bandno < rlvl->numbands; ++bandno, ++band) { if (!band->data) { continue; } jpc_undo_roi(band->data, band->roishift, ccp->roishift - band->roishift, band->numbps); if (tile->realmode) { jas_matrix_asl(band->data, JPC_FIX_FRACBITS); jpc_dequantize(band->data, band->absstepsize); } } } } for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps; ++compno, ++tcomp) { ccp = &tile->cp->ccps[compno]; jpc_tsfb_synthesize(tcomp->tsfb, tcomp->data); } switch (tile->cp->mctid) { case JPC_MCT_RCT: if (dec->numcomps < 3) { jas_eprintf(""RCT requires at least three components\n""); return -1; } jpc_irct(tile->tcomps[0].data, tile->tcomps[1].data, tile->tcomps[2].data); break; case JPC_MCT_ICT: if (dec->numcomps < 3) { jas_eprintf(""ICT requires at least three components\n""); return -1; } jpc_iict(tile->tcomps[0].data, tile->tcomps[1].data, tile->tcomps[2].data); break; } if (tile->realmode) { for (compno = 0, tcomp = tile->tcomps; compno < dec->numcomps; ++compno, ++tcomp) { for (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) { for (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) { v = jas_matrix_get(tcomp->data, i, j); v = jpc_fix_round(v); jas_matrix_set(tcomp->data, i, j, jpc_fixtoint(v)); } } } } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { adjust = cmpt->sgnd ? 0 : (1 << (cmpt->prec - 1)); for (i = 0; i < jas_matrix_numrows(tcomp->data); ++i) { for (j = 0; j < jas_matrix_numcols(tcomp->data); ++j) { *jas_matrix_getref(tcomp->data, i, j) += adjust; } } } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { jpc_fix_t mn; jpc_fix_t mx; mn = cmpt->sgnd ? (-(1 << (cmpt->prec - 1))) : (0); mx = cmpt->sgnd ? ((1 << (cmpt->prec - 1)) - 1) : ((1 << cmpt->prec) - 1); jas_matrix_clip(tcomp->data, mn, mx); } for (compno = 0, tcomp = tile->tcomps, cmpt = dec->cmpts; compno < dec->numcomps; ++compno, ++tcomp, ++cmpt) { if (jas_image_writecmpt(dec->image, compno, tcomp->xstart - JPC_CEILDIV(dec->xstart, cmpt->hstep), tcomp->ystart - JPC_CEILDIV(dec->ystart, cmpt->vstep), jas_matrix_numcols( tcomp->data), jas_matrix_numrows(tcomp->data), tcomp->data)) { jas_eprintf(""write component failed\n""); return -1; } } return 0; }"
"static int encode_apng(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *got_packet) { PNGEncContext *s = avctx->priv_data; int ret; int enc_row_size; size_t max_packet_size; APNGFctlChunk fctl_chunk = {0}; if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) { uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t)); if (avctx->frame_number == 0) { s->palette_checksum = checksum; } else if (checksum != s->palette_checksum) { av_log(avctx, AV_LOG_ERROR, ""Input contains more than one unique palette. APNG does not support multiple palettes.\n""); return -1; } } enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3); max_packet_size = AV_INPUT_BUFFER_MIN_SIZE +         avctx->height * ( enc_row_size + (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE)         ); if (max_packet_size > INT_MAX) return AVERROR(ENOMEM); if (avctx->frame_number == 0) { if (!pict) return AVERROR(EINVAL); s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE); if (!avctx->extradata) return AVERROR(ENOMEM); ret = encode_headers(avctx, pict); if (ret < 0) return ret; avctx->extradata_size = s->bytestream - avctx->extradata; s->last_frame_packet = av_malloc(max_packet_size); if (!s->last_frame_packet) return AVERROR(ENOMEM); } else if (s->last_frame) { ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0); if (ret < 0) return ret; memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size); pkt->size = s->last_frame_packet_size; pkt->pts = pkt->dts = s->last_frame->pts; } if (pict) { s->bytestream_start = s->bytestream       = s->last_frame_packet; s->bytestream_end   = s->bytestream + max_packet_size; fctl_chunk.sequence_number = s->sequence_number; ++s->sequence_number; s->bytestream += 26 + 12; ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl); if (ret < 0) return ret; fctl_chunk.delay_num = 0;         fctl_chunk.delay_den = 0; } else { s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE; } if (s->last_frame) { uint8_t* last_fctl_chunk_start = pkt->data; uint8_t buf[26]; AV_WB32(buf + 0, s->last_frame_fctl.sequence_number); AV_WB32(buf + 4, s->last_frame_fctl.width); AV_WB32(buf + 8, s->last_frame_fctl.height); AV_WB32(buf + 12, s->last_frame_fctl.x_offset); AV_WB32(buf + 16, s->last_frame_fctl.y_offset); AV_WB16(buf + 20, s->last_frame_fctl.delay_num); AV_WB16(buf + 22, s->last_frame_fctl.delay_den); buf[24] = s->last_frame_fctl.dispose_op; buf[25] = s->last_frame_fctl.blend_op; png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26); *got_packet = 1; } if (pict) { if (!s->last_frame) { s->last_frame = av_frame_alloc(); if (!s->last_frame) return AVERROR(ENOMEM); } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) { if (!s->prev_frame) { s->prev_frame = av_frame_alloc(); if (!s->prev_frame) return AVERROR(ENOMEM); s->prev_frame->format = pict->format; s->prev_frame->width = pict->width; s->prev_frame->height = pict->height; if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0) return ret; } memcpy(s->prev_frame->data[0], s->last_frame->data[0], s->last_frame->linesize[0] * s->last_frame->height); if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) { uint32_t y; uint8_t bpp = (s->bits_per_pixel + 7) >> 3; for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) { size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset; memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width); } } } av_frame_unref(s->last_frame); ret = av_frame_ref(s->last_frame, (AVFrame*)pict); if (ret < 0) return ret; s->last_frame_fctl = fctl_chunk; s->last_frame_packet_size = s->bytestream - s->bytestream_start; } else { av_frame_free(&s->last_frame); } return 0; }"
"void mem_log_init(const char* prog_name, const char *banner) { size_t log_name_len; char *log_name; if (__test_bit(LOG_CONSOLE_BIT, &debug)) { log_op = stderr; return; } if (log_op) fclose(log_op); log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1; log_name = malloc(log_name_len); if (!log_name) { log_message(LOG_INFO, ""Unable to malloc log file name""); log_op = stderr; return; } snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid()); log_op = fopen(log_name, ""a""); if (log_op == NULL) { log_message(LOG_INFO, ""Unable to open %s for appending"", log_name); log_op = stderr; } else { int fd = fileno(log_op); fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC); setlinebuf(log_op); fprintf(log_op, ""\n""); } free(log_name); terminate_banner = banner; }"
"XModifierKeymap * XGetModifierMapping(register Display *dpy) { xGetModifierMappingReply rep; register xReq *req; unsigned long nbytes; XModifierKeymap *res; LockDisplay(dpy); GetEmptyReq(GetModifierMapping, req); (void) _XReply (dpy, (xReply *)&rep, 0, xFalse); if (rep.length < (INT_MAX >> 2)) { nbytes = (unsigned long)rep.length << 2; res = Xmalloc(sizeof (XModifierKeymap)); if (res) res->modifiermap = Xmalloc (nbytes); } else res = NULL; if ((! res) || (! res->modifiermap)) { Xfree(res); res = (XModifierKeymap *) NULL; _XEatDataWords(dpy, rep.length); } else { _XReadPad(dpy, (char *) res->modifiermap, (long) nbytes); res->max_keypermod = rep.numKeyPerModifier; } UnlockDisplay(dpy); SyncHandle(); return (res); }"
"static TEE_Result tee_svc_copy_param(struct tee_ta_session *sess, struct tee_ta_session *called_sess, struct utee_params *callee_params, struct tee_ta_param *param, void *tmp_buf_va[TEE_NUM_PARAMS], struct mobj **mobj_tmp) { size_t n; TEE_Result res; size_t req_mem = 0; size_t s; uint8_t *dst = 0; bool ta_private_memref[TEE_NUM_PARAMS]; struct user_ta_ctx *utc = to_user_ta_ctx(sess->ctx); void *va; size_t dst_offs; if (!callee_params) { memset(param, 0, sizeof(*param)); } else { res = tee_mmu_check_access_rights(utc, TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)callee_params, sizeof(struct utee_params)); if (res != TEE_SUCCESS) return res; utee_param_to_param(param, callee_params); } if (called_sess && is_pseudo_ta_ctx(called_sess->ctx)) { return TEE_SUCCESS; } for (n = 0; n < TEE_NUM_PARAMS; n++) { ta_private_memref[n] = false; switch (TEE_PARAM_TYPE_GET(param->types, n)) { case TEE_PARAM_TYPE_MEMREF_INPUT: case TEE_PARAM_TYPE_MEMREF_OUTPUT: case TEE_PARAM_TYPE_MEMREF_INOUT: va = (void *)param->u[n].mem.offs; s = param->u[n].mem.size; if (!va) { if (s) return TEE_ERROR_BAD_PARAMETERS; break; } if (tee_mmu_is_vbuf_inside_ta_private(utc, va, s)) { s = ROUNDUP(s, sizeof(uint32_t)); if (ADD_OVERFLOW(req_mem, s, &req_mem)) return TEE_ERROR_BAD_PARAMETERS; ta_private_memref[n] = true; break; } res = tee_mmu_vbuf_to_mobj_offs(utc, va, s, &param->u[n].mem.mobj, &param->u[n].mem.offs); if (res != TEE_SUCCESS) return res; break; default: break; } } if (req_mem == 0) return TEE_SUCCESS; res = alloc_temp_sec_mem(req_mem, mobj_tmp, &dst); if (res != TEE_SUCCESS) return res; dst_offs = 0; for (n = 0; n < TEE_NUM_PARAMS; n++) { if (!ta_private_memref[n]) continue; s = ROUNDUP(param->u[n].mem.size, sizeof(uint32_t)); switch (TEE_PARAM_TYPE_GET(param->types, n)) { case TEE_PARAM_TYPE_MEMREF_INPUT: case TEE_PARAM_TYPE_MEMREF_INOUT: va = (void *)param->u[n].mem.offs; if (va) { res = tee_svc_copy_from_user(dst, va, param->u[n].mem.size); if (res != TEE_SUCCESS) return res; param->u[n].mem.offs = dst_offs; param->u[n].mem.mobj = *mobj_tmp; tmp_buf_va[n] = dst; dst += s; dst_offs += s; } break; case TEE_PARAM_TYPE_MEMREF_OUTPUT: va = (void *)param->u[n].mem.offs; if (va) { param->u[n].mem.offs = dst_offs; param->u[n].mem.mobj = *mobj_tmp; tmp_buf_va[n] = dst; dst += s; dst_offs += s; } break; default: continue; } } return TEE_SUCCESS; }"
"static struct dentry *v9fs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data) { struct super_block *sb = NULL; struct inode *inode = NULL; struct dentry *root = NULL; struct v9fs_session_info *v9ses = NULL; umode_t mode = S_IRWXUGO | S_ISVTX; struct p9_fid *fid; int retval = 0; p9_debug(P9_DEBUG_VFS, ""\n""); v9ses = kzalloc(sizeof(struct v9fs_session_info), GFP_KERNEL); if (!v9ses) return ERR_PTR(-ENOMEM); fid = v9fs_session_init(v9ses, dev_name, data); if (IS_ERR(fid)) { retval = PTR_ERR(fid); goto free_session; } sb = sget(fs_type, NULL, v9fs_set_super, flags, v9ses); if (IS_ERR(sb)) { retval = PTR_ERR(sb); goto clunk_fid; } retval = v9fs_fill_super(sb, v9ses, flags, data); if (retval) goto release_sb; if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) sb->s_d_op = &v9fs_cached_dentry_operations; else sb->s_d_op = &v9fs_dentry_operations; inode = v9fs_get_inode(sb, S_IFDIR | mode, 0); if (IS_ERR(inode)) { retval = PTR_ERR(inode); goto release_sb; } root = d_make_root(inode); if (!root) { retval = -ENOMEM; goto release_sb; } sb->s_root = root; if (v9fs_proto_dotl(v9ses)) { struct p9_stat_dotl *st = NULL; st = p9_client_getattr_dotl(fid, P9_STATS_BASIC); if (IS_ERR(st)) { retval = PTR_ERR(st); goto release_sb; } d_inode(root)->i_ino = v9fs_qid2ino(&st->qid); v9fs_stat2inode_dotl(st, d_inode(root)); kfree(st); } else { struct p9_wstat *st = NULL; st = p9_client_stat(fid); if (IS_ERR(st)) { retval = PTR_ERR(st); goto release_sb; } d_inode(root)->i_ino = v9fs_qid2ino(&st->qid); v9fs_stat2inode(st, d_inode(root), sb); p9stat_free(st); kfree(st); } retval = v9fs_get_acl(inode, fid); if (retval) goto release_sb; v9fs_fid_add(root, fid); p9_debug(P9_DEBUG_VFS, "" simple set mount, return 0\n""); return dget(sb->s_root); clunk_fid: p9_client_clunk(fid); v9fs_session_close(v9ses); free_session: kfree(v9ses); return ERR_PTR(retval); release_sb: p9_client_clunk(fid); deactivate_locked_super(sb); return ERR_PTR(retval); }"
"GlyphCache::Loader::Loader(const Face & face, const bool dumb_font) : _head(face, Tag::head), _hhea(face, Tag::hhea), _hmtx(face, Tag::hmtx), _glyf(face, Tag::glyf), _loca(face, Tag::loca), _long_fmt(false), _has_boxes(false), _num_glyphs_graphics(0), _num_glyphs_attributes(0), _num_attrs(0) { if (!operator bool()) return; const Face::Table maxp = Face::Table(face, Tag::maxp); if (!maxp) { _head = Face::Table(); return; } _num_glyphs_graphics = TtfUtil::GlyphCount(maxp); if (_glyf && TtfUtil::LocaLookup(_num_glyphs_graphics-1, _loca, _loca.size(), _head) == size_t(-2)) { _head = Face::Table(); return; } if (!dumb_font) { if ((m_pGlat = Face::Table(face, Tag::Glat, 0x00030000)) == NULL || (m_pGloc = Face::Table(face, Tag::Gloc)) == NULL || m_pGloc.size() < 8) { _head = Face::Table(); return; } const byte    * p = m_pGloc; int       version = be::read<uint32>(p); const uint16    flags = be::read<uint16>(p); _num_attrs = be::read<uint16>(p); _long_fmt              = flags & 1; int tmpnumgattrs       = (m_pGloc.size() - (p - m_pGloc) - sizeof(uint16)*(flags & 0x2 ? _num_attrs : 0)) / (_long_fmt ? sizeof(uint32) : sizeof(uint16)) - 1; if (version >= 0x00020000 || tmpnumgattrs < 0 || tmpnumgattrs > 65535 || _num_attrs == 0 || _num_attrs > 0x3000              || _num_glyphs_graphics > tmpnumgattrs || m_pGlat.size() < 4) { _head = Face::Table(); return; } _num_glyphs_attributes = static_cast<unsigned short>(tmpnumgattrs); p = m_pGlat; version = be::read<uint32>(p); if (version >= 0x00040000 || (version >= 0x00030000 && m_pGlat.size() < 8))               { _head = Face::Table(); return; } else if (version >= 0x00030000) { unsigned int glatflags = be::read<uint32>(p); _has_boxes = glatflags & 1; _has_boxes = true; } } }"
"static void initOpensslLocks(void) { unsigned ii, nlocks; if (CRYPTO_get_locking_callback() != NULL) { return; } nlocks = CRYPTO_num_locks(); ossl_locks = hiredis_safe_malloc(sizeof(*ossl_locks) * nlocks); for (ii = 0; ii < nlocks; ii++) { sslLockInit(ossl_locks + ii); } CRYPTO_set_locking_callback(opensslDoLock); }"
"static int hugetlb_sysctl_handler_common(bool obey_mempolicy, struct ctl_table *table, int write, void *buffer, size_t *length, loff_t *ppos) { struct hstate *h = &default_hstate; unsigned long tmp = h->max_huge_pages; int ret; if (!hugepages_supported()) return -EOPNOTSUPP; table->data = &tmp; table->maxlen = sizeof(unsigned long); ret = proc_doulongvec_minmax(table, write, buffer, length, ppos); if (ret) goto out; if (write) ret = __nr_hugepages_store_common(obey_mempolicy, h, NUMA_NO_NODE, tmp, *length); out: return ret; }"
"ret_t cherokee_validator_parse_basic (cherokee_validator_t *validator, char *str, cuint_t str_len) { char              *colon; cherokee_buffer_t  auth = CHEROKEE_BUF_INIT; cherokee_buffer_add (&auth, str, str_len); cherokee_buffer_decode_base64 (&auth); colon = strchr (auth.buf, ':'); if (colon == NULL) goto error; cherokee_buffer_add (&validator->user, auth.buf, colon - auth.buf); cherokee_buffer_add (&validator->passwd, colon+1, auth.len  - ((colon+1) - auth.buf)); TRACE (ENTRIES, ""Parse basic auth got user=%s, passwd=%s\n"", validator->user.buf, validator->passwd.buf); cherokee_buffer_mrproper (&auth); return ret_ok; error: cherokee_buffer_mrproper (&auth); return ret_error; }"
"static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size) { struct l2cap_conf_rsp *rsp = data; void *ptr = rsp->data; void *endptr = data + data_size; void *req = chan->conf_req; int len = chan->conf_len; int type, hint, olen; unsigned long val; struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC }; struct l2cap_conf_efs efs; u8 remote_efs = 0; u16 mtu = L2CAP_DEFAULT_MTU; u16 result = L2CAP_CONF_SUCCESS; u16 size; BT_DBG(""chan %p"", chan); while (len >= L2CAP_CONF_OPT_SIZE) { len -= l2cap_get_conf_opt(&req, &type, &olen, &val); if (len < 0) break; hint  = type & L2CAP_CONF_HINT; type &= L2CAP_CONF_MASK; switch (type) { case L2CAP_CONF_MTU: if (olen != 2) break; mtu = val; break; case L2CAP_CONF_FLUSH_TO: if (olen != 2) break; chan->flush_to = val; break; case L2CAP_CONF_QOS: break; case L2CAP_CONF_RFC: if (olen != sizeof(rfc)) break; memcpy(&rfc, (void *) val, olen); break; case L2CAP_CONF_FCS: if (olen != 1) break; if (val == L2CAP_FCS_NONE) set_bit(CONF_RECV_NO_FCS, &chan->conf_state); break; case L2CAP_CONF_EFS: if (olen != sizeof(efs)) break; remote_efs = 1; memcpy(&efs, (void *) val, olen); break; case L2CAP_CONF_EWS: if (olen != 2) break; if (!(chan->conn->local_fixed_chan & L2CAP_FC_A2MP)) return -ECONNREFUSED; set_bit(FLAG_EXT_CTRL, &chan->flags); set_bit(CONF_EWS_RECV, &chan->conf_state); chan->tx_win_max = L2CAP_DEFAULT_EXT_WINDOW; chan->remote_tx_win = val; break; default: if (hint) break; result = L2CAP_CONF_UNKNOWN; l2cap_add_conf_opt(&ptr, (u8)type, sizeof(u8), type, endptr - ptr); break; } } if (chan->num_conf_rsp || chan->num_conf_req > 1) goto done; switch (chan->mode) { case L2CAP_MODE_STREAMING: case L2CAP_MODE_ERTM: if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) { chan->mode = l2cap_select_mode(rfc.mode, chan->conn->feat_mask); break; } if (remote_efs) { if (__l2cap_efs_supported(chan->conn)) set_bit(FLAG_EFS_ENABLE, &chan->flags); else return -ECONNREFUSED; } if (chan->mode != rfc.mode) return -ECONNREFUSED; break; } done: if (chan->mode != rfc.mode) { result = L2CAP_CONF_UNACCEPT; rfc.mode = chan->mode; if (chan->num_conf_rsp == 1) return -ECONNREFUSED; l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); } if (result == L2CAP_CONF_SUCCESS) { if (mtu < L2CAP_DEFAULT_MIN_MTU) result = L2CAP_CONF_UNACCEPT; else { chan->omtu = mtu; set_bit(CONF_MTU_DONE, &chan->conf_state); } l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, chan->omtu, endptr - ptr); if (remote_efs) { if (chan->local_stype != L2CAP_SERV_NOTRAFIC && efs.stype != L2CAP_SERV_NOTRAFIC && efs.stype != chan->local_stype) { result = L2CAP_CONF_UNACCEPT; if (chan->num_conf_req >= 1) return -ECONNREFUSED; l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs, endptr - ptr); } else { result = L2CAP_CONF_PENDING; set_bit(CONF_LOC_CONF_PEND, &chan->conf_state); } } switch (rfc.mode) { case L2CAP_MODE_BASIC: chan->fcs = L2CAP_FCS_NONE; set_bit(CONF_MODE_DONE, &chan->conf_state); break; case L2CAP_MODE_ERTM: if (!test_bit(CONF_EWS_RECV, &chan->conf_state)) chan->remote_tx_win = rfc.txwin_size; else rfc.txwin_size = L2CAP_DEFAULT_TX_WINDOW; chan->remote_max_tx = rfc.max_transmit; size = min_t(u16, le16_to_cpu(rfc.max_pdu_size), chan->conn->mtu - L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE); rfc.max_pdu_size = cpu_to_le16(size); chan->remote_mps = size; __l2cap_set_ertm_timeouts(chan, &rfc); set_bit(CONF_MODE_DONE, &chan->conf_state); l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); if (test_bit(FLAG_EFS_ENABLE, &chan->flags)) { chan->remote_id = efs.id; chan->remote_stype = efs.stype; chan->remote_msdu = le16_to_cpu(efs.msdu); chan->remote_flush_to = le32_to_cpu(efs.flush_to); chan->remote_acc_lat = le32_to_cpu(efs.acc_lat); chan->remote_sdu_itime = le32_to_cpu(efs.sdu_itime); l2cap_add_conf_opt(&ptr, L2CAP_CONF_EFS, sizeof(efs), (unsigned long) &efs, endptr - ptr); } break; case L2CAP_MODE_STREAMING: size = min_t(u16, le16_to_cpu(rfc.max_pdu_size), chan->conn->mtu - L2CAP_EXT_HDR_SIZE - L2CAP_SDULEN_SIZE - L2CAP_FCS_SIZE); rfc.max_pdu_size = cpu_to_le16(size); chan->remote_mps = size; set_bit(CONF_MODE_DONE, &chan->conf_state); l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC, sizeof(rfc), (unsigned long) &rfc, endptr - ptr); break; default: result = L2CAP_CONF_UNACCEPT; memset(&rfc, 0, sizeof(rfc)); rfc.mode = chan->mode; } if (result == L2CAP_CONF_SUCCESS) set_bit(CONF_OUTPUT_DONE, &chan->conf_state); } rsp->scid   = cpu_to_le16(chan->dcid); rsp->result = cpu_to_le16(result); rsp->flags  = cpu_to_le16(0); return ptr - data; }"
static void __local_bh_enable(unsigned int cnt) { lockdep_assert_irqs_disabled(); if (softirq_count() == (cnt & SOFTIRQ_MASK)) trace_softirqs_on(_RET_IP_); preempt_count_sub(cnt); }
"static int smb3_fs_context_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct fs_parse_result result; struct smb3_fs_context *ctx = smb3_fc2context(fc); int i, opt; bool is_smb3 = !strcmp(fc->fs_type->name, ""smb3""); bool skip_parsing = false; kuid_t uid; kgid_t gid; cifs_dbg(FYI, ""CIFS: parsing cifs mount option '%s'\n"", param->key); if (param->type == fs_value_is_string && param->string[0] == 0) { if (!strcmp(""pass"", param->key) || !strcmp(""password"", param->key)) { skip_parsing = true; opt = Opt_pass; } else if (!strcmp(""user"", param->key) || !strcmp(""username"", param->key)) { skip_parsing = true; opt = Opt_user; } } if (!skip_parsing) { opt = fs_parse(fc, smb3_fs_parameters, param, &result); if (opt < 0) return ctx->sloppy ? 1 : opt; } switch (opt) { case Opt_compress: ctx->compression = UNKNOWN_TYPE; cifs_dbg(VFS, ""SMB3 compression support is experimental\n""); break; case Opt_nodfs: ctx->nodfs = 1; break; case Opt_hard: if (result.negated) { if (ctx->retry == 1) cifs_dbg(VFS, ""conflicting hard vs. soft mount options\n""); ctx->retry = 0; } else ctx->retry = 1; break; case Opt_soft: if (result.negated) ctx->retry = 1; else { if (ctx->retry == 1) cifs_dbg(VFS, ""conflicting hard vs soft mount options\n""); ctx->retry = 0; } break; case Opt_mapposix: if (result.negated) ctx->remap = false; else { ctx->remap = true; ctx->sfu_remap = false;  } break; case Opt_mapchars: if (result.negated) ctx->sfu_remap = false; else { ctx->sfu_remap = true; ctx->remap = false;  } break; case Opt_user_xattr: if (result.negated) ctx->no_xattr = 1; else ctx->no_xattr = 0; break; case Opt_forceuid: if (result.negated) ctx->override_uid = 0; else ctx->override_uid = 1; break; case Opt_forcegid: if (result.negated) ctx->override_gid = 0; else ctx->override_gid = 1; break; case Opt_perm: if (result.negated) ctx->noperm = 1; else ctx->noperm = 0; break; case Opt_dynperm: if (result.negated) ctx->dynperm = 0; else ctx->dynperm = 1; break; case Opt_sfu: if (result.negated) ctx->sfu_emul = 0; else ctx->sfu_emul = 1; break; case Opt_noblocksend: ctx->noblocksnd = 1; break; case Opt_noautotune: ctx->noautotune = 1; break; case Opt_nolease: ctx->no_lease = 1; break; case Opt_nosparse: ctx->no_sparse = 1; break; case Opt_nodelete: ctx->nodelete = 1; break; case Opt_multichannel: if (result.negated) { ctx->multichannel = false; ctx->max_channels = 1; } else { ctx->multichannel = true; if (ctx->max_channels < 2) ctx->max_channels = 2; } break; case Opt_uid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->linux_uid = uid; ctx->uid_specified = true; break; case Opt_cruid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->cred_uid = uid; ctx->cruid_specified = true; break; case Opt_backupuid: uid = make_kuid(current_user_ns(), result.uint_32); if (!uid_valid(uid)) goto cifs_parse_mount_err; ctx->backupuid = uid; ctx->backupuid_specified = true; break; case Opt_backupgid: gid = make_kgid(current_user_ns(), result.uint_32); if (!gid_valid(gid)) goto cifs_parse_mount_err; ctx->backupgid = gid; ctx->backupgid_specified = true; break; case Opt_gid: gid = make_kgid(current_user_ns(), result.uint_32); if (!gid_valid(gid)) goto cifs_parse_mount_err; ctx->linux_gid = gid; ctx->gid_specified = true; break; case Opt_port: ctx->port = result.uint_32; break; case Opt_file_mode: ctx->file_mode = result.uint_32; break; case Opt_dirmode: ctx->dir_mode = result.uint_32; break; case Opt_min_enc_offload: ctx->min_offload = result.uint_32; break; case Opt_blocksize: if ((result.uint_32 < CIFS_MAX_MSGSIZE) || (result.uint_32 > (4 * SMB3_DEFAULT_IOSIZE))) { cifs_errorf(fc, ""%s: Invalid blocksize\n"", __func__); goto cifs_parse_mount_err; } ctx->bsize = result.uint_32; ctx->got_bsize = true; break; case Opt_rasize: if ((result.uint_32 > (8 * SMB3_DEFAULT_IOSIZE)) || (result.uint_32 < CIFS_DEFAULT_IOSIZE)) { cifs_errorf(fc, ""%s: Invalid rasize %d vs. %d\n"", __func__, result.uint_32, SMB3_DEFAULT_IOSIZE); goto cifs_parse_mount_err; } ctx->rasize = result.uint_32; break; case Opt_rsize: ctx->rsize = result.uint_32; ctx->got_rsize = true; break; case Opt_wsize: ctx->wsize = result.uint_32; ctx->got_wsize = true; break; case Opt_acregmax: ctx->acregmax = HZ * result.uint_32; if (ctx->acregmax > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""acregmax too large\n""); goto cifs_parse_mount_err; } break; case Opt_acdirmax: ctx->acdirmax = HZ * result.uint_32; if (ctx->acdirmax > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""acdirmax too large\n""); goto cifs_parse_mount_err; } break; case Opt_actimeo: if (HZ * result.uint_32 > CIFS_MAX_ACTIMEO) { cifs_errorf(fc, ""timeout too large\n""); goto cifs_parse_mount_err; } if ((ctx->acdirmax != CIFS_DEF_ACTIMEO) || (ctx->acregmax != CIFS_DEF_ACTIMEO)) { cifs_errorf(fc, ""actimeo ignored since acregmax or acdirmax specified\n""); break; } ctx->acdirmax = ctx->acregmax = HZ * result.uint_32; break; case Opt_closetimeo: ctx->closetimeo = HZ * result.uint_32; if (ctx->closetimeo > SMB3_MAX_DCLOSETIMEO) { cifs_errorf(fc, ""closetimeo too large\n""); goto cifs_parse_mount_err; } break; case Opt_echo_interval: ctx->echo_interval = result.uint_32; break; case Opt_snapshot: ctx->snapshot_time = result.uint_64; break; case Opt_max_credits: if (result.uint_32 < 20 || result.uint_32 > 60000) { cifs_errorf(fc, ""%s: Invalid max_credits value\n"", __func__); goto cifs_parse_mount_err; } ctx->max_credits = result.uint_32; break; case Opt_max_channels: if (result.uint_32 < 1 || result.uint_32 > CIFS_MAX_CHANNELS) { cifs_errorf(fc, ""%s: Invalid max_channels value, needs to be 1-%d\n"", __func__, CIFS_MAX_CHANNELS); goto cifs_parse_mount_err; } ctx->max_channels = result.uint_32; if (result.uint_32 > 1) ctx->multichannel = true; break; case Opt_max_cached_dirs: if (result.uint_32 < 1) { cifs_errorf(fc, ""%s: Invalid max_cached_dirs, needs to be 1 or more\n"", __func__); goto cifs_parse_mount_err; } ctx->max_cached_dirs = result.uint_32; break; case Opt_handletimeout: ctx->handle_timeout = result.uint_32; if (ctx->handle_timeout > SMB3_MAX_HANDLE_TIMEOUT) { cifs_errorf(fc, ""Invalid handle cache timeout, longer than 16 minutes\n""); goto cifs_parse_mount_err; } break; case Opt_source: kfree(ctx->UNC); ctx->UNC = NULL; switch (smb3_parse_devname(param->string, ctx)) { case 0: break; case -ENOMEM: cifs_errorf(fc, ""Unable to allocate memory for devname\n""); goto cifs_parse_mount_err; case -EINVAL: cifs_errorf(fc, ""Malformed UNC in devname\n""); goto cifs_parse_mount_err; default: cifs_errorf(fc, ""Unknown error parsing devname\n""); goto cifs_parse_mount_err; } ctx->source = smb3_fs_context_fullpath(ctx, '/'); if (IS_ERR(ctx->source)) { ctx->source = NULL; cifs_errorf(fc, ""OOM when copying UNC string\n""); goto cifs_parse_mount_err; } fc->source = kstrdup(ctx->source, GFP_KERNEL); if (fc->source == NULL) { cifs_errorf(fc, ""OOM when copying UNC string\n""); goto cifs_parse_mount_err; } break; case Opt_user: kfree(ctx->username); ctx->username = NULL; if (ctx->nullauth) break; if (strlen(param->string) == 0) { ctx->nullauth = 1; break; } if (strnlen(param->string, CIFS_MAX_USERNAME_LEN) > CIFS_MAX_USERNAME_LEN) { pr_warn(""username too long\n""); goto cifs_parse_mount_err; } ctx->username = kstrdup(param->string, GFP_KERNEL); if (ctx->username == NULL) { cifs_errorf(fc, ""OOM when copying username string\n""); goto cifs_parse_mount_err; } break; case Opt_pass: kfree_sensitive(ctx->password); ctx->password = NULL; if (strlen(param->string) == 0) break; ctx->password = kstrdup(param->string, GFP_KERNEL); if (ctx->password == NULL) { cifs_errorf(fc, ""OOM when copying password string\n""); goto cifs_parse_mount_err; } break; case Opt_ip: if (strlen(param->string) == 0) { ctx->got_ip = false; break; } if (!cifs_convert_address((struct sockaddr *)&ctx->dstaddr, param->string, strlen(param->string))) { pr_err(""bad ip= option (%s)\n"", param->string); goto cifs_parse_mount_err; } ctx->got_ip = true; break; case Opt_domain: if (strnlen(param->string, CIFS_MAX_DOMAINNAME_LEN) == CIFS_MAX_DOMAINNAME_LEN) { pr_warn(""domain name too long\n""); goto cifs_parse_mount_err; } kfree(ctx->domainname); ctx->domainname = kstrdup(param->string, GFP_KERNEL); if (ctx->domainname == NULL) { cifs_errorf(fc, ""OOM when copying domainname string\n""); goto cifs_parse_mount_err; } cifs_dbg(FYI, ""Domain name set\n""); break; case Opt_srcaddr: if (!cifs_convert_address( (struct sockaddr *)&ctx->srcaddr, param->string, strlen(param->string))) { pr_warn(""Could not parse srcaddr: %s\n"", param->string); goto cifs_parse_mount_err; } break; case Opt_iocharset: if (strnlen(param->string, 1024) >= 65) { pr_warn(""iocharset name too long\n""); goto cifs_parse_mount_err; } if (strncasecmp(param->string, ""default"", 7) != 0) { kfree(ctx->iocharset); ctx->iocharset = kstrdup(param->string, GFP_KERNEL); if (ctx->iocharset == NULL) { cifs_errorf(fc, ""OOM when copying iocharset string\n""); goto cifs_parse_mount_err; } } cifs_dbg(FYI, ""iocharset set to %s\n"", ctx->iocharset); break; case Opt_netbiosname: memset(ctx->source_rfc1001_name, 0x20, RFC1001_NAME_LEN); for (i = 0; i < RFC1001_NAME_LEN; i++) { if (param->string[i] == 0) break; ctx->source_rfc1001_name[i] = param->string[i]; } if (i == RFC1001_NAME_LEN && param->string[i] != 0) pr_warn(""netbiosname longer than 15 truncated\n""); break; case Opt_servern: memset(ctx->target_rfc1001_name, 0x20, RFC1001_NAME_LEN_WITH_NULL); for (i = 0; i < 15; i++) { if (param->string[i] == 0) break; ctx->target_rfc1001_name[i] = param->string[i]; } if (i == RFC1001_NAME_LEN && param->string[i] != 0) pr_warn(""server netbiosname longer than 15 truncated\n""); break; case Opt_ver: if (strncasecmp(param->string, ""1"", 1) == 0) { if (strlen(param->string) > 1) { pr_warn(""Bad mount helper ver=%s. Did you want SMB1 (CIFS) dialect and mean to type vers=1.0 instead?\n"", param->string); goto cifs_parse_mount_err; } break; } pr_warn(""Invalid mount helper version specified\n""); goto cifs_parse_mount_err; case Opt_vers: if (cifs_parse_smb_version(fc, param->string, ctx, is_smb3) != 0) goto cifs_parse_mount_err; ctx->got_version = true; break; case Opt_sec: if (cifs_parse_security_flavors(fc, param->string, ctx) != 0) goto cifs_parse_mount_err; break; case Opt_cache: if (cifs_parse_cache_flavor(fc, param->string, ctx) != 0) goto cifs_parse_mount_err; break; case Opt_witness: #ifndef CONFIG_CIFS_SWN_UPCALL cifs_errorf(fc, ""Witness support needs CONFIG_CIFS_SWN_UPCALL config option\n""); goto cifs_parse_mount_err; #endif ctx->witness = true; pr_warn_once(""Witness protocol support is experimental\n""); break; case Opt_rootfs: #ifndef CONFIG_CIFS_ROOT cifs_dbg(VFS, ""rootfs support requires CONFIG_CIFS_ROOT config option\n""); goto cifs_parse_mount_err; #endif ctx->rootfs = true; break; case Opt_posixpaths: if (result.negated) ctx->posix_paths = 0; else ctx->posix_paths = 1; break; case Opt_unix: if (result.negated) { if (ctx->linux_ext == 1) pr_warn_once(""conflicting posix mount options specified\n""); ctx->linux_ext = 0; ctx->no_linux_ext = 1; } else { if (ctx->no_linux_ext == 1) pr_warn_once(""conflicting posix mount options specified\n""); ctx->linux_ext = 1; ctx->no_linux_ext = 0; } break; case Opt_nocase: ctx->nocase = 1; break; case Opt_brl: if (result.negated) { if (ctx->file_mode == (S_IALLUGO & ~(S_ISUID | S_IXGRP))) ctx->file_mode = S_IALLUGO; ctx->nobrl =  1; } else ctx->nobrl =  0; break; case Opt_handlecache: if (result.negated) ctx->nohandlecache = 1; else ctx->nohandlecache = 0; break; case Opt_forcemandatorylock: ctx->mand_lock = 1; break; case Opt_setuids: ctx->setuids = result.negated; break; case Opt_intr: ctx->intr = !result.negated; break; case Opt_setuidfromacl: ctx->setuidfromacl = 1; break; case Opt_strictsync: ctx->nostrictsync = result.negated; break; case Opt_serverino: ctx->server_ino = !result.negated; break; case Opt_rwpidforward: ctx->rwpidforward = 1; break; case Opt_modesid: ctx->mode_ace = 1; break; case Opt_cifsacl: ctx->cifs_acl = !result.negated; break; case Opt_acl: ctx->no_psx_acl = result.negated; break; case Opt_locallease: ctx->local_lease = 1; break; case Opt_sign: ctx->sign = true; break; case Opt_ignore_signature: ctx->sign = true; ctx->ignore_signature = true; break; case Opt_seal: ctx->seal = 1; break; case Opt_noac: pr_warn(""Mount option noac not supported. Instead set /proc/fs/cifs/LookupCacheEnabled to 0\n""); break; case Opt_fsc: #ifndef CONFIG_CIFS_FSCACHE cifs_errorf(fc, ""FS-Cache support needs CONFIG_CIFS_FSCACHE kernel config option set\n""); goto cifs_parse_mount_err; #endif ctx->fsc = true; break; case Opt_mfsymlinks: ctx->mfsymlinks = true; break; case Opt_multiuser: ctx->multiuser = true; break; case Opt_sloppy: ctx->sloppy = true; break; case Opt_nosharesock: ctx->nosharesock = true; break; case Opt_persistent: if (result.negated) { ctx->nopersistent = true; if (ctx->persistent) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } else { ctx->persistent = true; if ((ctx->nopersistent) || (ctx->resilient)) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } break; case Opt_resilient: if (result.negated) { ctx->resilient = false;  } else { ctx->resilient = true; if (ctx->persistent) { cifs_errorf(fc, ""persistenthandles mount options conflict\n""); goto cifs_parse_mount_err; } } break; case Opt_tcp_nodelay: if (result.negated) ctx->sockopt_tcp_nodelay = false; else ctx->sockopt_tcp_nodelay = true; break; case Opt_domainauto: ctx->domainauto = true; break; case Opt_rdma: ctx->rdma = true; break; } return 0; cifs_parse_mount_err: kfree_sensitive(ctx->password); return -EINVAL; }"
"static void make_pub_auth(cachemgr_request * req) { static char buf[1024]; safe_free(req->pub_auth); debug(""cmgr: encoding for pub...\n""); if (!req->passwd || !strlen(req->passwd)) return; const int bufLen = snprintf(buf, sizeof(buf), ""%s|%d|%s|%s"", req->hostname, (int) now, req->user_name ? req->user_name : """", req->passwd); debug(""cmgr: pre-encoded for pub: %s\n"", buf); const int encodedLen = base64_encode_len(bufLen); req->pub_auth = (char *) xmalloc(encodedLen); struct base64_encode_ctx ctx; base64_encode_init(&ctx); size_t blen = base64_encode_update(&ctx, req->pub_auth, bufLen, reinterpret_cast<uint8_t*>(buf)); blen += base64_encode_final(&ctx, req->pub_auth + blen); req->pub_auth[blen] = '\0'; debug(""cmgr: encoded: '%s'\n"", req->pub_auth); }"
"static bfd_boolean parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit) { bfd_byte *xptr; if (stash->line_section == 0) { asection *msec; bfd_size_type size; msec = bfd_get_section_by_name (stash->abfd, "".line""); if (! msec) return FALSE; size = msec->rawsize ? msec->rawsize : msec->size; stash->line_section = bfd_simple_get_relocated_section_contents (stash->abfd, msec, NULL, stash->syms); if (! stash->line_section) return FALSE; stash->line_section_end = stash->line_section + size; } xptr = stash->line_section + aUnit->stmt_list_offset; if (xptr < stash->line_section_end) { unsigned long eachLine; bfd_byte *tblend; unsigned long base; bfd_size_type amt; tblend = bfd_get_32 (stash->abfd, (bfd_byte *) xptr) + xptr; xptr += 4; base = bfd_get_32 (stash->abfd, (bfd_byte *) xptr); xptr += 4; aUnit->line_count = (tblend - xptr) / 10; amt = sizeof (struct linenumber) * aUnit->line_count; aUnit->linenumber_table = (struct linenumber *) bfd_alloc (stash->abfd, amt); if (!aUnit->linenumber_table) return FALSE; for (eachLine = 0; eachLine < aUnit->line_count; eachLine++) { aUnit->linenumber_table[eachLine].linenumber = bfd_get_32 (stash->abfd, (bfd_byte *) xptr); xptr += 4; xptr += 2; aUnit->linenumber_table[eachLine].addr = base + bfd_get_32 (stash->abfd, (bfd_byte *) xptr); xptr += 4; } } return TRUE; }"
"void scanner_filter_arguments (parser_context_t *context_p,  scanner_context_t *scanner_context_p)  { scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p; scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p; parser_list_iterator_t literal_iterator; lexer_lit_location_t *literal_p; bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0; bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0; JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags)); if (can_eval) { if (prev_literal_pool_p != NULL) { prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL; } if (has_arguments) { literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS); } } literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL; parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while (true) { literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator); if (literal_p == NULL) { return; } if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)) { literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE; } uint8_t type = literal_p->type; const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG); if ((type & mask) != SCANNER_LITERAL_IS_ARG) { break; } } bool has_destructured_arg = false; scanner_literal_pool_t *new_literal_pool_p; new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t)); new_literal_pool_p->prev_p = literal_pool_p; scanner_context_p->active_literal_pool_p = new_literal_pool_p; *new_literal_pool_p = *literal_pool_p; parser_list_init (&new_literal_pool_p->literal_pool, sizeof (lexer_lit_location_t), (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t))); parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL) { uint8_t type = literal_p->type; if (type & SCANNER_LITERAL_IS_ARG) { if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)) { type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE; literal_p->type = type; } if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG)) { has_destructured_arg = true; if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG) { continue; } type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG; type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG; literal_p->type = type; continue; } lexer_lit_location_t *new_literal_p; new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool); *new_literal_p = *literal_p; } else if (has_arguments && scanner_literal_is_arguments (literal_p)) { new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS; if (type & SCANNER_LITERAL_NO_REG) { new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS; } } else if (prev_literal_pool_p != NULL) { lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p); type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED; literal_location_p->type |= type; } } if (has_destructured_arg) { parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator); while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL) { const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG; if ((literal_p->type & expected_flags) == expected_flags) { lexer_lit_location_t *new_literal_p; new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool); *new_literal_p = *literal_p; } } } new_literal_pool_p->prev_p = prev_literal_pool_p; parser_list_free (&literal_pool_p->literal_pool); scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t)); }"
"unsigned long move_page_tables(struct vm_area_struct *vma, unsigned long old_addr, struct vm_area_struct *new_vma, unsigned long new_addr, unsigned long len, bool need_rmap_locks) { unsigned long extent, old_end; struct mmu_notifier_range range; pmd_t *old_pmd, *new_pmd; pud_t *old_pud, *new_pud; old_end = old_addr + len; flush_cache_range(vma, old_addr, old_end); mmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm, old_addr, old_end); mmu_notifier_invalidate_range_start(&range); for (; old_addr < old_end; old_addr += extent, new_addr += extent) { cond_resched(); extent = get_extent(NORMAL_PUD, old_addr, old_end, new_addr); old_pud = get_old_pud(vma->vm_mm, old_addr); if (!old_pud) continue; new_pud = alloc_new_pud(vma->vm_mm, vma, new_addr); if (!new_pud) break; if (pud_trans_huge(*old_pud) || pud_devmap(*old_pud)) { if (extent == HPAGE_PUD_SIZE) { move_pgt_entry(HPAGE_PUD, vma, old_addr, new_addr, old_pud, new_pud, need_rmap_locks); continue; } } else if (IS_ENABLED(CONFIG_HAVE_MOVE_PUD) && extent == PUD_SIZE) { if (move_pgt_entry(NORMAL_PUD, vma, old_addr, new_addr, old_pud, new_pud, need_rmap_locks)) continue; } extent = get_extent(NORMAL_PMD, old_addr, old_end, new_addr); old_pmd = get_old_pmd(vma->vm_mm, old_addr); if (!old_pmd) continue; new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr); if (!new_pmd) break; if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) { if (extent == HPAGE_PMD_SIZE && move_pgt_entry(HPAGE_PMD, vma, old_addr, new_addr, old_pmd, new_pmd, need_rmap_locks)) continue; split_huge_pmd(vma, old_pmd, old_addr); if (pmd_trans_unstable(old_pmd)) continue; } else if (IS_ENABLED(CONFIG_HAVE_MOVE_PMD) && extent == PMD_SIZE) { if (move_pgt_entry(NORMAL_PMD, vma, old_addr, new_addr, old_pmd, new_pmd, need_rmap_locks)) continue; } if (pte_alloc(new_vma->vm_mm, new_pmd)) break; move_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma, new_pmd, new_addr, need_rmap_locks); } mmu_notifier_invalidate_range_end(&range); return len + old_addr - old_end; }"
"void inode_init_owner(struct inode *inode, const struct inode *dir, umode_t mode) { inode->i_uid = current_fsuid(); if (dir && dir->i_mode & S_ISGID) { inode->i_gid = dir->i_gid; if (S_ISDIR(mode)) mode |= S_ISGID; } else inode->i_gid = current_fsgid(); inode->i_mode = mode; }"
"void Compute(OpKernelContext* context) override { const Tensor& spectrogram = context->input(0); OP_REQUIRES(context, spectrogram.dims() == 3, errors::InvalidArgument(""spectrogram must be 3-dimensional"", spectrogram.shape().DebugString())); const Tensor& sample_rate_tensor = context->input(1); OP_REQUIRES(context, TensorShapeUtils::IsScalar(sample_rate_tensor.shape()), errors::InvalidArgument( ""Input sample_rate should be a scalar tensor, got "", sample_rate_tensor.shape().DebugString(), "" instead."")); const int32_t sample_rate = sample_rate_tensor.scalar<int32>()(); const int spectrogram_channels = spectrogram.dim_size(2); const int spectrogram_samples = spectrogram.dim_size(1); const int audio_channels = spectrogram.dim_size(0); Mfcc mfcc; mfcc.set_upper_frequency_limit(upper_frequency_limit_); mfcc.set_lower_frequency_limit(lower_frequency_limit_); mfcc.set_filterbank_channel_count(filterbank_channel_count_); mfcc.set_dct_coefficient_count(dct_coefficient_count_); OP_REQUIRES(context, mfcc.Initialize(spectrogram_channels, sample_rate), errors::InvalidArgument( ""Mfcc initialization failed for channel count "", spectrogram_channels, "" and sample rate "", sample_rate)); Tensor* output_tensor = nullptr; OP_REQUIRES_OK(context, context->allocate_output( 0, TensorShape({audio_channels, spectrogram_samples, dct_coefficient_count_}), &output_tensor)); const float* spectrogram_flat = spectrogram.flat<float>().data(); float* output_flat = output_tensor->flat<float>().data(); for (int audio_channel = 0; audio_channel < audio_channels; ++audio_channel) { for (int spectrogram_sample = 0; spectrogram_sample < spectrogram_samples; ++spectrogram_sample) { const float* sample_data = spectrogram_flat + (audio_channel * spectrogram_samples * spectrogram_channels) + (spectrogram_sample * spectrogram_channels); std::vector<double> mfcc_input(sample_data, sample_data + spectrogram_channels); std::vector<double> mfcc_output; mfcc.Compute(mfcc_input, &mfcc_output); DCHECK_EQ(dct_coefficient_count_, mfcc_output.size()); float* output_data = output_flat + (audio_channel * spectrogram_samples * dct_coefficient_count_) + (spectrogram_sample * dct_coefficient_count_); for (int i = 0; i < dct_coefficient_count_; ++i) { output_data[i] = mfcc_output[i]; } } } }"
static void __xen_evtchn_do_upcall(void) { struct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu); int cpu = smp_processor_id(); read_lock(&evtchn_rwlock); do { vcpu_info->evtchn_upcall_pending = 0; xen_evtchn_handle_events(cpu); BUG_ON(!irqs_disabled()); virt_rmb();  } while (vcpu_info->evtchn_upcall_pending); read_unlock(&evtchn_rwlock); }
"int base64url_encode(const void *data_in, size_t data_in_size, unsigned char *base64_out, size_t *base64_out_size) { return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true); }"
"int ssl3_read_bytes(SSL *s, int type, int *recvd_type, unsigned char *buf, int len, int peek) { int al, i, j, ret; unsigned int n, curr_rec, num_recs, read_bytes; SSL3_RECORD *rr; SSL3_BUFFER *rbuf; void (*cb) (const SSL *ssl, int type2, int val) = NULL; rbuf = &s->rlayer.rbuf; if (!SSL3_BUFFER_is_initialised(rbuf)) { if (!ssl3_setup_read_buffer(s)) return (-1); } if ((type && (type != SSL3_RT_APPLICATION_DATA) && (type != SSL3_RT_HANDSHAKE)) || (peek && (type != SSL3_RT_APPLICATION_DATA))) { SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR); return -1; } if ((type == SSL3_RT_HANDSHAKE) && (s->rlayer.handshake_fragment_len > 0)) { unsigned char *src = s->rlayer.handshake_fragment; unsigned char *dst = buf; unsigned int k; n = 0; while ((len > 0) && (s->rlayer.handshake_fragment_len > 0)) { *dst++ = *src++; len--; s->rlayer.handshake_fragment_len--; n++; } for (k = 0; k < s->rlayer.handshake_fragment_len; k++) s->rlayer.handshake_fragment[k] = *src++; if (recvd_type != NULL) *recvd_type = SSL3_RT_HANDSHAKE; return n; } if (!ossl_statem_get_in_handshake(s) && SSL_in_init(s)) { i = s->handshake_func(s); if (i < 0) return (i); if (i == 0) { SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE); return (-1); } } start: s->rwstate = SSL_NOTHING; rr = s->rlayer.rrec; num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer); do { if (num_recs == 0) { ret = ssl3_get_record(s); if (ret <= 0) return (ret); num_recs = RECORD_LAYER_get_numrpipes(&s->rlayer); if (num_recs == 0) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR); goto f_err; } } for (curr_rec = 0; curr_rec < num_recs && SSL3_RECORD_is_read(&rr[curr_rec]); curr_rec++) ; if (curr_rec == num_recs) { RECORD_LAYER_set_numrpipes(&s->rlayer, 0); num_recs = 0; curr_rec = 0; } } while (num_recs == 0); rr = &rr[curr_rec]; if (SSL3_RECORD_get_type(rr) != SSL3_RT_ALERT && SSL3_RECORD_get_length(rr) != 0) s->rlayer.alert_count = 0; if (s->s3->change_cipher_spec  && (SSL3_RECORD_get_type(rr) != SSL3_RT_HANDSHAKE)) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_DATA_BETWEEN_CCS_AND_FINISHED); goto f_err; } if (s->shutdown & SSL_RECEIVED_SHUTDOWN) { SSL3_RECORD_set_length(rr, 0); s->rwstate = SSL_NOTHING; return (0); } if (type == SSL3_RECORD_get_type(rr) || (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC && type == SSL3_RT_HANDSHAKE && recvd_type != NULL)) { if (SSL_in_init(s) && (type == SSL3_RT_APPLICATION_DATA) && (s->enc_read_ctx == NULL)) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_APP_DATA_IN_HANDSHAKE); goto f_err; } if (type == SSL3_RT_HANDSHAKE && SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC && s->rlayer.handshake_fragment_len > 0) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY); goto f_err; } if (recvd_type != NULL) *recvd_type = SSL3_RECORD_get_type(rr); if (len <= 0) return (len); read_bytes = 0; do { if ((unsigned int)len - read_bytes > SSL3_RECORD_get_length(rr)) n = SSL3_RECORD_get_length(rr); else n = (unsigned int)len - read_bytes; memcpy(buf, &(rr->data[rr->off]), n); buf += n; if (!peek) { SSL3_RECORD_sub_length(rr, n); SSL3_RECORD_add_off(rr, n); if (SSL3_RECORD_get_length(rr) == 0) { s->rlayer.rstate = SSL_ST_READ_HEADER; SSL3_RECORD_set_off(rr, 0); SSL3_RECORD_set_read(rr); } } if (SSL3_RECORD_get_length(rr) == 0 || (peek && n == SSL3_RECORD_get_length(rr))) { curr_rec++; rr++; } read_bytes += n; } while (type == SSL3_RT_APPLICATION_DATA && curr_rec < num_recs && read_bytes < (unsigned int)len); if (read_bytes == 0) { goto start; } if (!peek && curr_rec == num_recs && (s->mode & SSL_MODE_RELEASE_BUFFERS) && SSL3_BUFFER_get_left(rbuf) == 0) ssl3_release_read_buffer(s); return read_bytes; } if (rr->rec_version == SSL2_VERSION) { al = SSL_AD_INTERNAL_ERROR; SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR); goto f_err; } if (s->method->version == TLS_ANY_VERSION && (s->server || rr->type != SSL3_RT_ALERT)) { s->version = rr->rec_version; al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_MESSAGE); goto f_err; } { unsigned int dest_maxlen = 0; unsigned char *dest = NULL; unsigned int *dest_len = NULL; if (SSL3_RECORD_get_type(rr) == SSL3_RT_HANDSHAKE) { dest_maxlen = sizeof s->rlayer.handshake_fragment; dest = s->rlayer.handshake_fragment; dest_len = &s->rlayer.handshake_fragment_len; } else if (SSL3_RECORD_get_type(rr) == SSL3_RT_ALERT) { dest_maxlen = sizeof s->rlayer.alert_fragment; dest = s->rlayer.alert_fragment; dest_len = &s->rlayer.alert_fragment_len; } if (dest_maxlen > 0) { n = dest_maxlen - *dest_len;  if (SSL3_RECORD_get_length(rr) < n) n = SSL3_RECORD_get_length(rr);  while (n-- > 0) { dest[(*dest_len)++] = SSL3_RECORD_get_data(rr)[SSL3_RECORD_get_off(rr)]; SSL3_RECORD_add_off(rr, 1); SSL3_RECORD_add_length(rr, -1); } if (*dest_len < dest_maxlen) { SSL3_RECORD_set_read(rr); goto start;      } } } if ((!s->server) && (s->rlayer.handshake_fragment_len >= 4) && (s->rlayer.handshake_fragment[0] == SSL3_MT_HELLO_REQUEST) && (s->session != NULL) && (s->session->cipher != NULL)) { s->rlayer.handshake_fragment_len = 0; if ((s->rlayer.handshake_fragment[1] != 0) || (s->rlayer.handshake_fragment[2] != 0) || (s->rlayer.handshake_fragment[3] != 0)) { al = SSL_AD_DECODE_ERROR; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_BAD_HELLO_REQUEST); goto f_err; } if (s->msg_callback) s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->rlayer.handshake_fragment, 4, s, s->msg_callback_arg); if (SSL_is_init_finished(s) && !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS) && !s->s3->renegotiate) { ssl3_renegotiate(s); if (ssl3_renegotiate_check(s)) { i = s->handshake_func(s); if (i < 0) return (i); if (i == 0) { SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE); return (-1); } if (!(s->mode & SSL_MODE_AUTO_RETRY)) { if (SSL3_BUFFER_get_left(rbuf) == 0) { BIO *bio; s->rwstate = SSL_READING; bio = SSL_get_rbio(s); BIO_clear_retry_flags(bio); BIO_set_retry_read(bio); return (-1); } } } } goto start; } if (s->server && SSL_is_init_finished(s) && !s->s3->send_connection_binding && (s->version > SSL3_VERSION) && (s->rlayer.handshake_fragment_len >= 4) && (s->rlayer.handshake_fragment[0] == SSL3_MT_CLIENT_HELLO) && (s->session != NULL) && (s->session->cipher != NULL) && !(s->ctx->options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION)) { SSL3_RECORD_set_length(rr, 0); SSL3_RECORD_set_read(rr); ssl3_send_alert(s, SSL3_AL_WARNING, SSL_AD_NO_RENEGOTIATION); goto start; } if (s->rlayer.alert_fragment_len >= 2) { int alert_level = s->rlayer.alert_fragment[0]; int alert_descr = s->rlayer.alert_fragment[1]; s->rlayer.alert_fragment_len = 0; if (s->msg_callback) s->msg_callback(0, s->version, SSL3_RT_ALERT, s->rlayer.alert_fragment, 2, s, s->msg_callback_arg); if (s->info_callback != NULL) cb = s->info_callback; else if (s->ctx->info_callback != NULL) cb = s->ctx->info_callback; if (cb != NULL) { j = (alert_level << 8) | alert_descr; cb(s, SSL_CB_READ_ALERT, j); } if (alert_level == SSL3_AL_WARNING) { s->s3->warn_alert = alert_descr; SSL3_RECORD_set_read(rr); s->rlayer.alert_count++; if (s->rlayer.alert_count == MAX_WARN_ALERT_COUNT) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_TOO_MANY_WARN_ALERTS); goto f_err; } if (alert_descr == SSL_AD_CLOSE_NOTIFY) { s->shutdown |= SSL_RECEIVED_SHUTDOWN; return (0); } else if (alert_descr == SSL_AD_NO_RENEGOTIATION) { al = SSL_AD_HANDSHAKE_FAILURE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_NO_RENEGOTIATION); goto f_err; } #ifdef SSL_AD_MISSING_SRP_USERNAME else if (alert_descr == SSL_AD_MISSING_SRP_USERNAME) return (0); #endif } else if (alert_level == SSL3_AL_FATAL) { char tmp[16]; s->rwstate = SSL_NOTHING; s->s3->fatal_alert = alert_descr; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_AD_REASON_OFFSET + alert_descr); BIO_snprintf(tmp, sizeof tmp, ""%d"", alert_descr); ERR_add_error_data(2, ""SSL alert number "", tmp); s->shutdown |= SSL_RECEIVED_SHUTDOWN; SSL3_RECORD_set_read(rr); SSL_CTX_remove_session(s->session_ctx, s->session); return (0); } else { al = SSL_AD_ILLEGAL_PARAMETER; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNKNOWN_ALERT_TYPE); goto f_err; } goto start; } if (s->shutdown & SSL_SENT_SHUTDOWN) {  s->rwstate = SSL_NOTHING; SSL3_RECORD_set_length(rr, 0); SSL3_RECORD_set_read(rr); return (0); } if (SSL3_RECORD_get_type(rr) == SSL3_RT_CHANGE_CIPHER_SPEC) { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_CCS_RECEIVED_EARLY); goto f_err; } if ((s->rlayer.handshake_fragment_len >= 4) && !ossl_statem_get_in_handshake(s)) { if (SSL_is_init_finished(s) && !(s->s3->flags & SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS)) { ossl_statem_set_in_init(s, 1); s->renegotiate = 1; s->new_session = 1; } i = s->handshake_func(s); if (i < 0) return (i); if (i == 0) { SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_SSL_HANDSHAKE_FAILURE); return (-1); } if (!(s->mode & SSL_MODE_AUTO_RETRY)) { if (SSL3_BUFFER_get_left(rbuf) == 0) { BIO *bio; s->rwstate = SSL_READING; bio = SSL_get_rbio(s); BIO_clear_retry_flags(bio); BIO_set_retry_read(bio); return (-1); } } goto start; } switch (SSL3_RECORD_get_type(rr)) { default: if (s->version >= TLS1_VERSION && s->version <= TLS1_1_VERSION) { SSL3_RECORD_set_length(rr, 0); SSL3_RECORD_set_read(rr); goto start; } al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD); goto f_err; case SSL3_RT_CHANGE_CIPHER_SPEC: case SSL3_RT_ALERT: case SSL3_RT_HANDSHAKE: al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, ERR_R_INTERNAL_ERROR); goto f_err; case SSL3_RT_APPLICATION_DATA: if (ossl_statem_app_data_allowed(s)) { s->s3->in_read_app_data = 2; return (-1); } else { al = SSL_AD_UNEXPECTED_MESSAGE; SSLerr(SSL_F_SSL3_READ_BYTES, SSL_R_UNEXPECTED_RECORD); goto f_err; } } f_err: ssl3_send_alert(s, SSL3_AL_FATAL, al); return (-1); }"
"static void io_async_task_func(struct callback_head *cb) { struct io_kiocb *req = container_of(cb, struct io_kiocb, task_work); struct async_poll *apoll = req->apoll; struct io_ring_ctx *ctx = req->ctx; trace_io_uring_task_run(req->ctx, req->opcode, req->user_data); if (io_poll_rewait(req, &apoll->poll)) { spin_unlock_irq(&ctx->completion_lock); return; } if (hash_hashed(&req->hash_node)) hash_del(&req->hash_node); io_poll_remove_double(req, apoll->double_poll); spin_unlock_irq(&ctx->completion_lock); if (!READ_ONCE(apoll->poll.canceled)) __io_req_task_submit(req); else __io_req_task_cancel(req, -ECANCELED); kfree(apoll->double_poll); kfree(apoll); }"
static inline void io_uring_files_cancel(struct files_struct *files) { if (current->io_uring && !xa_empty(&current->io_uring->xa)) __io_uring_files_cancel(files); }
"static int btrfs_finish_sprout(struct btrfs_trans_handle *trans, struct btrfs_fs_info *fs_info) { struct btrfs_root *root = fs_info->chunk_root; struct btrfs_path *path; struct extent_buffer *leaf; struct btrfs_dev_item *dev_item; struct btrfs_device *device; struct btrfs_key key; u8 fs_uuid[BTRFS_FSID_SIZE]; u8 dev_uuid[BTRFS_UUID_SIZE]; u64 devid; int ret; path = btrfs_alloc_path(); if (!path) return -ENOMEM; key.objectid = BTRFS_DEV_ITEMS_OBJECTID; key.offset = 0; key.type = BTRFS_DEV_ITEM_KEY; while (1) { ret = btrfs_search_slot(trans, root, &key, path, 0, 1); if (ret < 0) goto error; leaf = path->nodes[0]; next_slot: if (path->slots[0] >= btrfs_header_nritems(leaf)) { ret = btrfs_next_leaf(root, path); if (ret > 0) break; if (ret < 0) goto error; leaf = path->nodes[0]; btrfs_item_key_to_cpu(leaf, &key, path->slots[0]); btrfs_release_path(path); continue; } btrfs_item_key_to_cpu(leaf, &key, path->slots[0]); if (key.objectid != BTRFS_DEV_ITEMS_OBJECTID || key.type != BTRFS_DEV_ITEM_KEY) break; dev_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dev_item); devid = btrfs_device_id(leaf, dev_item); read_extent_buffer(leaf, dev_uuid, btrfs_device_uuid(dev_item), BTRFS_UUID_SIZE); read_extent_buffer(leaf, fs_uuid, btrfs_device_fsid(dev_item), BTRFS_FSID_SIZE); device = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid, fs_uuid); BUG_ON(!device);  if (device->fs_devices->seeding) { btrfs_set_device_generation(leaf, dev_item, device->generation); btrfs_mark_buffer_dirty(leaf); } path->slots[0]++; goto next_slot; } ret = 0; error: btrfs_free_path(path); return ret; }"
"MDnsSdListener::Monitor::Monitor() { mHead = nullptr; mLiveCount = 0; mPollFds = nullptr; mPollRefs = nullptr; mPollSize = 10; socketpair(AF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, mCtrlSocketPair); const int rval = ::android::netdutils::threadLaunch(this); if (rval != 0) { ALOGW(""Error spawning monitor thread: %s (%d)"", strerror(-rval), -rval); } }"
"static size_t SizeClassInfo(xAnyClassPtr *any, int num_classes) { int size = 0; int j; for (j = 0; j < num_classes; j++) { switch ((*any)->class) { case KeyClass: size += pad_to_xid(sizeof(XKeyInfo)); break; case ButtonClass: size += pad_to_xid(sizeof(XButtonInfo)); break; case ValuatorClass: { xValuatorInfoPtr v; v = (xValuatorInfoPtr) *any; size += pad_to_xid(sizeof(XValuatorInfo) + (v->num_axes * sizeof(XAxisInfo))); break; } default: break; } *any = (xAnyClassPtr) ((char *)(*any) + (*any)->length); } return size; }"
"int server_partial_file_request(struct httpd *env, struct client *clt, char *path, struct stat *st, char *range_str) { struct server_config*srv_conf = clt->clt_srv_conf; struct http_descriptor*resp = clt->clt_descresp; struct http_descriptor*desc = clt->clt_descreq; struct media_type*media, multipart_media; struct range*range; struct evbuffer*evb = NULL; size_t content_length; int code = 500, fd = -1, i, nranges, ret; uint32_t boundary; char content_range[64]; const char*errstr = NULL; if (desc->http_method != HTTP_METHOD_GET) return server_file_request(env, clt, path, st); if ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) { code = 416; (void)snprintf(content_range, sizeof(content_range), ""bytes */%lld"", st->st_size); errstr = content_range; goto abort; } if ((fd = open(path, O_RDONLY)) == -1) goto abort; media = media_find_config(env, srv_conf, path); if ((evb = evbuffer_new()) == NULL) { errstr = ""failed to allocate file buffer""; goto abort; } if (nranges == 1) { (void)snprintf(content_range, sizeof(content_range), ""bytes %lld-%lld/%lld"", range->start, range->end, st->st_size); if (kv_add(&resp->http_headers, ""Content-Range"", content_range) == NULL) goto abort; content_length = range->end - range->start + 1; if (buffer_add_range(fd, evb, range) == 0) goto abort; } else { content_length = 0; boundary = arc4random(); while (nranges--) { if ((i = evbuffer_add_printf(evb, ""\r\n--%ud\r\n"", boundary)) == -1) goto abort; content_length += i; if ((i = evbuffer_add_printf(evb, ""Content-Type: %s/%s\r\n"", media->media_type, media->media_subtype)) == -1) goto abort; content_length += i; if ((i = evbuffer_add_printf(evb, ""Content-Range: bytes %lld-%lld/%lld\r\n\r\n"", range->start, range->end, st->st_size)) == -1) goto abort; content_length += i; if (buffer_add_range(fd, evb, range) == 0) goto abort; content_length += range->end - range->start + 1; range++; } if ((i = evbuffer_add_printf(evb, ""\r\n--%ud--\r\n"", boundary)) == -1) goto abort; content_length += i; (void)strlcpy(multipart_media.media_type, ""multipart"", sizeof(multipart_media.media_type)); (void)snprintf(multipart_media.media_subtype, sizeof(multipart_media.media_subtype), ""byteranges; boundary=%ud"", boundary); media = &multipart_media; } close(fd); fd = -1; ret = server_response_http(clt, 206, media, content_length, MINIMUM(time(NULL), st->st_mtim.tv_sec)); switch (ret) { case -1: goto fail; case 0: goto done; default: break; } if (server_bufferevent_write_buffer(clt, evb) == -1) goto fail; bufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE); if (clt->clt_persist) clt->clt_toread = TOREAD_HTTP_HEADER; else clt->clt_toread = TOREAD_HTTP_NONE; clt->clt_done = 0; done: evbuffer_free(evb); server_reset_http(clt); return (0); fail: bufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE); bufferevent_free(clt->clt_bev); clt->clt_bev = NULL; abort: if (evb != NULL) evbuffer_free(evb); if (fd != -1) close(fd); if (errstr == NULL) errstr = strerror(errno); server_abort_http(clt, code, errstr); return (-1); }"
"static int write_file(tree_t *t, FILE   *fp, int    col) { inti; uchar*ptr; while (t != NULL) { if (t->markup == MARKUP_NONE) { if (t->preformatted) { for (ptr = t->data; *ptr != '\0'; ptr ++) fputs((char *)iso8859(*ptr), fp); if (t->data[strlen((char *)t->data) - 1] == '\n') col = 0; else col += strlen((char *)t->data); } else { if ((col + (int)strlen((char *)t->data)) > 72 && col > 0) { putc('\n', fp); col = 0; } for (ptr = t->data; *ptr != '\0'; ptr ++) fputs((char *)iso8859(*ptr), fp); col += strlen((char *)t->data); if (col > 72) { putc('\n', fp); col = 0; } } } else if (t->markup == MARKUP_COMMENT) fprintf(fp, ""\n<!--%s-->\n"", t->data); else if (t->markup > 0) { switch (t->markup) { case MARKUP_AREA : case MARKUP_BR : case MARKUP_CENTER : case MARKUP_COMMENT : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_HEAD : case MARKUP_HR : case MARKUP_LI : case MARKUP_MAP : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TITLE : case MARKUP_TR : case MARKUP_UL : case MARKUP_DIR : case MARKUP_MENU : if (col > 0) { putc('\n', fp); col = 0; } default : break; } col += fprintf(fp, ""<%s"", _htmlMarkups[t->markup]); for (i = 0; i < t->nvars; i ++) { if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } if (col > 0) { putc(' ', fp); col ++; } if (t->vars[i].value == NULL) col += fprintf(fp, ""%s"", t->vars[i].name); else if (strchr((char *)t->vars[i].value, '\""') != NULL) col += fprintf(fp, ""%s=\'%s\'"", t->vars[i].name, t->vars[i].value); else col += fprintf(fp, ""%s=\""%s\"""", t->vars[i].name, t->vars[i].value); } putc('>', fp); col ++; if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } if (t->child != NULL) { col = write_file(t->child, fp, col); if (col > 72 && !t->preformatted) { putc('\n', fp); col = 0; } col += fprintf(fp, ""</%s>"", _htmlMarkups[t->markup]); switch (t->markup) { case MARKUP_AREA : case MARKUP_BR : case MARKUP_CENTER : case MARKUP_COMMENT : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_HEAD : case MARKUP_HR : case MARKUP_LI : case MARKUP_MAP : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TITLE : case MARKUP_TR : case MARKUP_UL : case MARKUP_DIR : case MARKUP_MENU : putc('\n', fp); col = 0; default : break; } } } t = t->next; } return (col); }"
"int nbd_client_co_pwrite_zeroes(BlockDriverState *bs, int64_t offset, int count, BdrvRequestFlags flags) { ssize_t ret; NBDClientSession *client = nbd_get_client_session(bs); NBDRequest request = { .type = NBD_CMD_WRITE_ZEROES, .from = offset, .len = count, }; NBDReply reply; if (!(client->nbdflags & NBD_FLAG_SEND_WRITE_ZEROES)) { return -ENOTSUP; } if (flags & BDRV_REQ_FUA) { assert(client->nbdflags & NBD_FLAG_SEND_FUA); request.flags |= NBD_CMD_FLAG_FUA; } if (!(flags & BDRV_REQ_MAY_UNMAP)) { request.flags |= NBD_CMD_FLAG_NO_HOLE; } nbd_coroutine_start(client, &request); ret = nbd_co_send_request(bs, &request, NULL); if (ret < 0) { reply.error = -ret; } else { nbd_co_receive_reply(client, &request, &reply, NULL); } nbd_coroutine_end(client, &request); return -reply.error; }"
"static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; if (shdr->sh_size < 1) { return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); for (cnt = 0, i = 0; i >= 0 && cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) vstart += verdef->vd_aux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } if ((st32)verdef->vd_next < 1) { eprintf (""Warning: Invalid vd_next in the ELF version\n""); break; } i += verdef->vd_next; }"
"gboolean g_markup_parse_context_end_parse (GMarkupParseContext  *context, GError              **error) { g_return_val_if_fail (context != NULL, FALSE); g_return_val_if_fail (!context->parsing, FALSE); g_return_val_if_fail (context->state != STATE_ERROR, FALSE); if (context->partial_chunk != NULL) { g_string_free (context->partial_chunk, TRUE); context->partial_chunk = NULL; } if (context->document_empty) { set_error_literal (context, error, G_MARKUP_ERROR_EMPTY, _(""Document was empty or contained only whitespace"")); return FALSE; } context->parsing = TRUE; switch (context->state) { case STATE_START: break; case STATE_AFTER_OPEN_ANGLE: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly just after an open angle bracket “<”"")); break; case STATE_AFTER_CLOSE_ANGLE: if (context->tag_stack != NULL) { set_error (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly with elements still open — "" ""“%s” was the last element opened""), current_element (context)); } break; case STATE_AFTER_ELISION_SLASH: set_error (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly, expected to see a close angle "" ""bracket ending the tag <%s/>""), current_element (context)); break; case STATE_INSIDE_OPEN_TAG_NAME: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly inside an element name"")); break; case STATE_INSIDE_ATTRIBUTE_NAME: case STATE_AFTER_ATTRIBUTE_NAME: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly inside an attribute name"")); break; case STATE_BETWEEN_ATTRIBUTES: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly inside an element-opening "" ""tag."")); break; case STATE_AFTER_ATTRIBUTE_EQUALS_SIGN: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly after the equals sign "" ""following an attribute name; no attribute value"")); break; case STATE_INSIDE_ATTRIBUTE_VALUE_SQ: case STATE_INSIDE_ATTRIBUTE_VALUE_DQ: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly while inside an attribute "" ""value"")); break; case STATE_INSIDE_TEXT: g_assert (context->tag_stack != NULL); set_error (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly with elements still open — "" ""“%s” was the last element opened""), current_element (context)); break; case STATE_AFTER_CLOSE_TAG_SLASH: case STATE_INSIDE_CLOSE_TAG_NAME: case STATE_AFTER_CLOSE_TAG_NAME: set_error (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly inside the close tag for "" ""element “%s”""), current_element (context)); break; case STATE_INSIDE_PASSTHROUGH: set_error_literal (context, error, G_MARKUP_ERROR_PARSE, _(""Document ended unexpectedly inside a comment or "" ""processing instruction"")); break; case STATE_ERROR: default: g_assert_not_reached (); break; } context->parsing = FALSE; return context->state != STATE_ERROR; }"
"void pushdup() { struct _stack *t; #ifdef DEBUG printf(""*pushdup*\n""); #endif if(Stack == NULL) { SWF_warn(""WARNING: pushdup on empty stack. This might be wrong!\n""); return; } t = calloc(1,sizeof(*Stack)); t->type = Stack->type; t->val =  Stack->val; t->next = Stack; Stack = t; }"
"int dissect_gquic_frame_type(tvbuff_t *tvb, packet_info *pinfo, proto_tree *gquic_tree, guint offset, guint8 len_pkn, gquic_info_data_t *gquic_info){ proto_item *ti, *ti_ft, *ti_ftflags ; proto_tree *ft_tree, *ftflags_tree; guint8 frame_type; guint8 num_ranges, num_revived, num_blocks = 0, num_timestamp; guint32 len_stream = 0, len_offset = 0, len_data = 0, len_largest_observed = 1, len_missing_packet = 1; ti_ft = proto_tree_add_item(gquic_tree, hf_gquic_frame, tvb, offset, 1, ENC_NA); ft_tree = proto_item_add_subtree(ti_ft, ett_gquic_ft); ti_ftflags = proto_tree_add_item(ft_tree, hf_gquic_frame_type, tvb, offset, 1, ENC_NA); frame_type = tvb_get_guint8(tvb, offset); proto_item_set_text(ti_ft, ""%s"", rval_to_str(frame_type, frame_type_vals, ""Unknown"")); if((frame_type & FTFLAGS_SPECIAL) == 0 && frame_type != FT_CRYPTO){  offset += 1; switch(frame_type){ case FT_PADDING:{ proto_item *ti_pad_len; guint32 pad_len = tvb_reported_length_remaining(tvb, offset); ti_pad_len = proto_tree_add_uint(ft_tree, hf_gquic_frame_type_padding_length, tvb, offset, 0, pad_len); proto_item_set_generated(ti_pad_len); proto_item_append_text(ti_ft, "" Length: %u"", pad_len); if(pad_len > 0)  proto_tree_add_item(ft_tree, hf_gquic_frame_type_padding, tvb, offset, -1, ENC_NA); offset += pad_len; } break; case FT_RST_STREAM:{ guint32 stream_id, error_code; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_rsts_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_rsts_byte_offset, tvb, offset, 8, gquic_info->encoding); offset += 8; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_rsts_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_item_append_text(ti_ft, "" Stream ID: %u, Error code: %s"", stream_id, val_to_str_ext(error_code, &rststream_error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""RST STREAM""); } break; case FT_CONNECTION_CLOSE:{ guint16 len_reason; guint32 error_code; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_cc_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_cc_reason_phrase_length, tvb, offset, 2, gquic_info->encoding); len_reason = tvb_get_guint16(tvb, offset, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_cc_reason_phrase, tvb, offset, len_reason, ENC_ASCII); offset += len_reason; proto_item_append_text(ti_ft, "" Error code: %s"", val_to_str_ext(error_code, &error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""Connection Close""); } break; case FT_GOAWAY:{ guint16 len_reason; guint32 error_code, last_good_stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_goaway_error_code, tvb, offset, 4, gquic_info->encoding, &error_code); offset += 4; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_goaway_last_good_stream_id, tvb, offset, 4, gquic_info->encoding, &last_good_stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_goaway_reason_phrase_length, tvb, offset, 2, gquic_info->encoding); len_reason = tvb_get_guint16(tvb, offset, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_goaway_reason_phrase, tvb, offset, len_reason, ENC_ASCII); offset += len_reason; proto_item_append_text(ti_ft, "" Stream ID: %u, Error code: %s"", last_good_stream_id, val_to_str_ext(error_code, &error_code_vals_ext, ""Unknown (%d)"")); col_set_str(pinfo->cinfo, COL_INFO, ""GOAWAY""); } break; case FT_WINDOW_UPDATE:{ guint32 stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_wu_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_tree_add_item(ft_tree, hf_gquic_frame_type_wu_byte_offset, tvb, offset, 8, gquic_info->encoding); offset += 8; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); } break; case FT_BLOCKED:{ guint32 stream_id; proto_tree_add_item_ret_uint(ft_tree, hf_gquic_frame_type_blocked_stream_id, tvb, offset, 4, gquic_info->encoding, &stream_id); offset += 4; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); } break; case FT_STOP_WAITING:{ guint8 send_entropy; if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ft_tree, hf_gquic_frame_type_sw_send_entropy, tvb, offset, 1, ENC_NA); send_entropy = tvb_get_guint8(tvb, offset); proto_item_append_text(ti_ft, "" Send Entropy: %u"", send_entropy); offset += 1; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_sw_least_unacked_delta, tvb, offset, len_pkn, gquic_info->encoding); offset += len_pkn; } break; case FT_PING:  default:  break; } } else {  guint32 stream_id, message_tag; const guint8* message_tag_str; proto_item *ti_stream; ftflags_tree = proto_item_add_subtree(ti_ftflags, ett_gquic_ftflags); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream , tvb, offset, 1, ENC_NA); if(frame_type == FT_CRYPTO) { guint64 crypto_offset, crypto_length; gint32 lenvar; DISSECTOR_ASSERT(gquic_info->version_valid && gquic_info->version >= 50); col_append_fstr(pinfo->cinfo, COL_INFO, "", CRYPTO""); offset += 1; proto_tree_add_item_ret_varint(ft_tree, hf_gquic_crypto_offset, tvb, offset, -1, ENC_VARINT_QUIC, &crypto_offset, &lenvar); offset += lenvar; proto_tree_add_item_ret_varint(ft_tree, hf_gquic_crypto_length, tvb, offset, -1, ENC_VARINT_QUIC, &crypto_length, &lenvar); offset += lenvar; proto_tree_add_item(ft_tree, hf_gquic_crypto_crypto_data, tvb, offset, (guint32)crypto_length, ENC_NA); if (gquic_info->version == 50) { message_tag = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item_ret_string(ft_tree, hf_gquic_tag, tvb, offset, 4, ENC_ASCII|ENC_NA, pinfo->pool, &message_tag_str); proto_item_append_text(ti, "" (%s)"", val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s"", val_to_str(message_tag, message_tag_vals, ""Unknown"")); offset += 4; offset = dissect_gquic_tags(tvb, pinfo, ft_tree, offset); } else {  tvbuff_t *next_tvb = tvb_new_subset_length(tvb, offset, (int)crypto_length); col_set_writable(pinfo->cinfo, -1, FALSE); call_dissector_with_data(tls13_handshake_handle, next_tvb, pinfo, ft_tree, GUINT_TO_POINTER(crypto_offset)); col_set_writable(pinfo->cinfo, -1, TRUE); offset += (guint32)crypto_length; } } else if(frame_type & FTFLAGS_STREAM){  proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_f, tvb, offset, 1, ENC_NA); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_d, tvb, offset, 1, ENC_NA); if(frame_type & FTFLAGS_STREAM_D){ len_data = 2; } proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_ooo, tvb, offset, 1, ENC_NA); len_offset = get_len_offset(frame_type); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_stream_ss, tvb, offset, 1, ENC_NA); len_stream = get_len_stream(frame_type); offset += 1; ti_stream = proto_tree_add_item_ret_uint(ft_tree, hf_gquic_stream_id, tvb, offset, len_stream, gquic_info->encoding, &stream_id); offset += len_stream; proto_item_append_text(ti_ft, "" Stream ID: %u"", stream_id); if(len_offset) { proto_tree_add_item(ft_tree, hf_gquic_offset, tvb, offset, len_offset, gquic_info->encoding); offset += len_offset; } if(len_data) { proto_tree_add_item(ft_tree, hf_gquic_data_len, tvb, offset, len_data, gquic_info->encoding); offset += len_data; } switch(stream_id) { case 1: {  message_tag = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item_ret_string(ft_tree, hf_gquic_tag, tvb, offset, 4, ENC_ASCII|ENC_NA, pinfo->pool, &message_tag_str); proto_item_append_text(ti_stream, "" (Reserved for (G)QUIC handshake, crypto, config updates...)""); proto_item_append_text(ti, "" (%s)"", val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); proto_item_append_text(ti_ft, "", Type: %s (%s)"", message_tag_str, val_to_str(message_tag, message_tag_vals, ""Unknown Tag"")); col_add_fstr(pinfo->cinfo, COL_INFO, ""%s"", val_to_str(message_tag, message_tag_vals, ""Unknown"")); offset += 4; offset = dissect_gquic_tags(tvb, pinfo, ft_tree, offset); break; } case 3: {  tvbuff_t* tvb_h2; proto_item_append_text(ti_stream, "" (Reserved for H2 HEADERS)""); col_add_str(pinfo->cinfo, COL_INFO, ""H2""); tvb_h2 = tvb_new_subset_remaining(tvb, offset); offset += dissect_http2_pdu(tvb_h2, pinfo, ft_tree, NULL); } break; default: {  int data_len = tvb_reported_length_remaining(tvb, offset); col_add_str(pinfo->cinfo, COL_INFO, ""DATA""); proto_tree_add_item(ft_tree, hf_gquic_stream_data, tvb, offset, data_len, ENC_NA); offset += data_len; } break; } } else if (frame_type & FTFLAGS_ACK) {      proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack, tvb, offset, 1, ENC_NA); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_n, tvb, offset, 1, ENC_NA); if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_t, tvb, offset, 1, ENC_NA); } else { proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_u, tvb, offset, 1, ENC_NA); } proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_ll, tvb, offset, 1, ENC_NA); len_largest_observed = get_len_largest_observed(frame_type); proto_tree_add_item(ftflags_tree, hf_gquic_frame_type_ack_mm, tvb, offset, 1, ENC_NA); len_missing_packet = get_len_missing_packet(frame_type); offset += 1; if(gquic_info->version_valid && gquic_info->version < 34){  proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_received_entropy, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_observed, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_ack_delay_time, tvb, offset, 2, gquic_info->encoding); offset += 2; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_timestamp, tvb, offset, 1, ENC_NA); num_timestamp = tvb_get_guint8(tvb, offset); offset += 1; if(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_observed, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_first_timestamp, tvb, offset, 4, gquic_info->encoding); offset += 4; num_timestamp -= 1; while(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_observed, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_previous_timestamp, tvb, offset, 2, gquic_info->encoding); offset += 2; num_timestamp--; } } if(frame_type & FTFLAGS_ACK_N){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_ranges, tvb, offset, 1, ENC_NA); num_ranges = tvb_get_guint8(tvb, offset); offset += 1; while(num_ranges){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_missing_packet, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_range_length, tvb, offset, 1, ENC_NA); offset += 1; num_ranges--; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_revived, tvb, offset, 1, ENC_NA); num_revived = tvb_get_guint8(tvb, offset); offset += 1; while(num_revived){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_revived_packet, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; num_revived--; } } } else { proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_acked, tvb, offset, len_largest_observed, gquic_info->encoding); offset += len_largest_observed; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_largest_acked_delta_time, tvb, offset, 2, gquic_info->encoding); offset += 2; if(frame_type & FTFLAGS_ACK_N){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_blocks, tvb, offset, 1, ENC_NA); num_blocks = tvb_get_guint8(tvb, offset); offset += 1; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_first_ack_block_length, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; while(num_blocks){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_gap_to_next_block, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_ack_block_length, tvb, offset, len_missing_packet, gquic_info->encoding); offset += len_missing_packet; num_blocks--; } proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_num_timestamp, tvb, offset, 1, ENC_NA); num_timestamp = tvb_get_guint8(tvb, offset); offset += 1; if(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_acked, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_largest_acked, tvb, offset, 4, gquic_info->encoding); offset += 4; num_timestamp -= 1; while(num_timestamp){ proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_delta_largest_acked, tvb, offset, 1, ENC_NA); offset += 1; proto_tree_add_item(ft_tree, hf_gquic_frame_type_ack_time_since_previous_timestamp, tvb, offset, 2, gquic_info->encoding); offset += 2; num_timestamp--; } } } } else {  offset += 1; } } return offset; }"
"void ex_function(exarg_T *eap) { (void)define_function(eap, NULL); }"
"unsigned int sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, int *cmnd_status, int pwflag) { struct defaults_list *defs = NULL; struct sudoers_parse_tree *parse_tree = NULL; struct cmndspec *cs = NULL; struct sudo_nss *nss; struct cmnd_info info; unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST; int m, match = UNSPEC; debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER); if (pwflag) { debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback, cb_data, pwflag)); } if (!set_perms(ctx, PERM_RUNAS)) debug_return_uint(validated); TAILQ_FOREACH(nss, snl, entries) { if (nss->query(ctx, nss, ctx->user.pw) == -1) { SET(validated, VALIDATE_ERROR); break; } m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback, cb_data, &cs, &defs); if (m != UNSPEC) { match = m; parse_tree = nss->parse_tree; } if (!sudo_nss_can_continue(nss, m)) break; } if (match != UNSPEC) { if (info.cmnd_path != NULL) { free(ctx->user.cmnd); ctx->user.cmnd = info.cmnd_path; if (ctx->user.cmnd_stat != NULL) *ctx->user.cmnd_stat = info.cmnd_stat; *cmnd_status = info.status; } if (defs != NULL) (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false); if (!apply_cmndspec(ctx, cs)) SET(validated, VALIDATE_ERROR); else if (match == ALLOW) SET(validated, VALIDATE_SUCCESS); else SET(validated, VALIDATE_FAILURE); } if (!restore_perms()) SET(validated, VALIDATE_ERROR); debug_return_uint(validated); }"
"static int sisusb_probe(struct usb_interface *intf, const struct usb_device_id *id) { struct usb_device *dev = interface_to_usbdev(intf); struct sisusb_usb_data *sisusb; int retval = 0, i; dev_info(&dev->dev, ""USB2VGA dongle found at address %d\n"", dev->devnum); sisusb = kzalloc(sizeof(*sisusb), GFP_KERNEL); if (!sisusb) return -ENOMEM; kref_init(&sisusb->kref); mutex_init(&(sisusb->lock)); retval = usb_register_dev(intf, &usb_sisusb_class); if (retval) { dev_err(&sisusb->sisusb_dev->dev, ""Failed to get a minor for device %d\n"", dev->devnum); retval = -ENODEV; goto error_1; } sisusb->sisusb_dev = dev; sisusb->minor      = intf->minor; sisusb->vrambase   = SISUSB_PCI_MEMBASE; sisusb->mmiobase   = SISUSB_PCI_MMIOBASE; sisusb->mmiosize   = SISUSB_PCI_MMIOSIZE; sisusb->ioportbase = SISUSB_PCI_IOPORTBASE; sisusb->ibufsize = SISUSB_IBUF_SIZE; sisusb->ibuf = kmalloc(SISUSB_IBUF_SIZE, GFP_KERNEL); if (!sisusb->ibuf) { retval = -ENOMEM; goto error_2; } sisusb->numobufs = 0; sisusb->obufsize = SISUSB_OBUF_SIZE; for (i = 0; i < NUMOBUFS; i++) { sisusb->obuf[i] = kmalloc(SISUSB_OBUF_SIZE, GFP_KERNEL); if (!sisusb->obuf[i]) { if (i == 0) { retval = -ENOMEM; goto error_3; } break; } sisusb->numobufs++; } sisusb->sisurbin = usb_alloc_urb(0, GFP_KERNEL); if (!sisusb->sisurbin) { retval = -ENOMEM; goto error_3; } sisusb->completein = 1; for (i = 0; i < sisusb->numobufs; i++) { sisusb->sisurbout[i] = usb_alloc_urb(0, GFP_KERNEL); if (!sisusb->sisurbout[i]) { retval = -ENOMEM; goto error_4; } sisusb->urbout_context[i].sisusb = (void *)sisusb; sisusb->urbout_context[i].urbindex = i; sisusb->urbstatus[i] = 0; } dev_info(&sisusb->sisusb_dev->dev, ""Allocated %d output buffers\n"", sisusb->numobufs); #ifdef CONFIG_USB_SISUSBVGA_CON sisusb->SiS_Pr = kmalloc(sizeof(struct SiS_Private), GFP_KERNEL); if (!sisusb->SiS_Pr) { retval = -ENOMEM; goto error_4; } #endif init_waitqueue_head(&sisusb->wait_q); usb_set_intfdata(intf, sisusb); usb_get_dev(sisusb->sisusb_dev); sisusb->present = 1; if (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) { int initscreen = 1; #ifdef CONFIG_USB_SISUSBVGA_CON if (sisusb_first_vc > 0 && sisusb_last_vc > 0 && sisusb_first_vc <= sisusb_last_vc && sisusb_last_vc <= MAX_NR_CONSOLES) initscreen = 0; #endif if (sisusb_init_gfxdevice(sisusb, initscreen)) dev_err(&sisusb->sisusb_dev->dev, ""Failed to early initialize device\n""); } else dev_info(&sisusb->sisusb_dev->dev, ""Not attached to USB 2.0 hub, deferring init\n""); sisusb->ready = 1; #ifdef SISUSBENDIANTEST dev_dbg(&sisusb->sisusb_dev->dev, ""*** RWTEST ***\n""); sisusb_testreadwrite(sisusb); dev_dbg(&sisusb->sisusb_dev->dev, ""*** RWTEST END ***\n""); #endif #ifdef CONFIG_USB_SISUSBVGA_CON sisusb_console_init(sisusb, sisusb_first_vc, sisusb_last_vc); #endif return 0; error_4: sisusb_free_urbs(sisusb); error_3: sisusb_free_buffers(sisusb); error_2: usb_deregister_dev(intf, &usb_sisusb_class); error_1: kfree(sisusb); return retval; }"
static inline int32_t unzigzag32(uint32_t v) { return (int32_t)((v >> 1) ^ (~(v & 1) + 1)); }
"static void ip_optprint(netdissect_options *ndo, register const u_char *cp, u_int length) { register u_int option_len; const char *sep = """"; for (; length > 0; cp += option_len, length -= option_len) { u_int option_code; ND_PRINT((ndo, ""%s"", sep)); sep = "",""; ND_TCHECK(*cp); option_code = *cp; ND_PRINT((ndo, ""%s"", tok2str(ip_option_values,""unknown %u"",option_code))); if (option_code == IPOPT_NOP || option_code == IPOPT_EOL) option_len = 1; else { ND_TCHECK(cp[1]); option_len = cp[1]; if (option_len < 2) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); return; } } if (option_len > length) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); return; } ND_TCHECK2(*cp, option_len); switch (option_code) { case IPOPT_EOL: return; case IPOPT_TS: ip_printts(ndo, cp, option_len); break; case IPOPT_RR:        case IPOPT_SSRR: case IPOPT_LSRR: if (ip_printroute(ndo, cp, option_len) == -1) goto trunc; break; case IPOPT_RA: if (option_len < 4) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); break; } ND_TCHECK(cp[3]); if (EXTRACT_16BITS(&cp[2]) != 0) ND_PRINT((ndo, "" value %u"", EXTRACT_16BITS(&cp[2]))); break; case IPOPT_NOP:        case IPOPT_SECURITY: default: break; } } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }"
"static inline void bss_ref_get(struct cfg80211_registered_device *rdev, struct cfg80211_internal_bss *bss) { lockdep_assert_held(&rdev->bss_lock); bss->refcount++; if (bss->pub.hidden_beacon_bss) { bss = container_of(bss->pub.hidden_beacon_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } if (bss->pub.transmitted_bss) { bss = container_of(bss->pub.transmitted_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } }"
"static int fuse_permission(struct inode *inode, int mask) { struct fuse_conn *fc = get_fuse_conn(inode); bool refreshed = false; int err = 0; if (!fuse_allow_current_process(fc)) return -EACCES; if (fc->default_permissions || ((mask & MAY_EXEC) && S_ISREG(inode->i_mode))) { struct fuse_inode *fi = get_fuse_inode(inode); u32 perm_mask = STATX_MODE | STATX_UID | STATX_GID; if (perm_mask & READ_ONCE(fi->inval_mask) || time_before64(fi->i_time, get_jiffies_64())) { refreshed = true; err = fuse_perm_getattr(inode, mask); if (err) return err; } } if (fc->default_permissions) { err = generic_permission(inode, mask); if (err == -EACCES && !refreshed) { err = fuse_perm_getattr(inode, mask); if (!err) err = generic_permission(inode, mask); } } else if (mask & (MAY_ACCESS | MAY_CHDIR)) { err = fuse_access(inode, mask); } else if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode)) { if (!(inode->i_mode & S_IXUGO)) { if (refreshed) return -EACCES; err = fuse_perm_getattr(inode, mask); if (!err && !(inode->i_mode & S_IXUGO)) return -EACCES; } } return err; }"
void virPCIVirtualFunctionListFree(virPCIVirtualFunctionList *list) { size_t i; if (!list) return; for (i = 0; i < list->nfunctions; i++) { g_free(list->functions[i].addr); g_free(list->functions[i].ifname); } g_free(list); }
"static int nf_tables_delrule(struct sk_buff *skb, const struct nfnl_info *info, const struct nlattr * const nla[]) { struct netlink_ext_ack *extack = info->extack; u8 genmask = nft_genmask_next(info->net); u8 family = info->nfmsg->nfgen_family; struct nft_chain *chain = NULL; struct net *net = info->net; struct nft_table *table; struct nft_rule *rule; struct nft_ctx ctx; int err = 0; table = nft_table_lookup(net, nla[NFTA_RULE_TABLE], family, genmask, NETLINK_CB(skb).portid); if (IS_ERR(table)) { NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_TABLE]); return PTR_ERR(table); } if (nla[NFTA_RULE_CHAIN]) { chain = nft_chain_lookup(net, table, nla[NFTA_RULE_CHAIN], genmask); if (IS_ERR(chain)) { if (PTR_ERR(chain) == -ENOENT && NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE) return 0; NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_CHAIN]); return PTR_ERR(chain); } if (nft_chain_is_bound(chain)) return -EOPNOTSUPP; } nft_ctx_init(&ctx, net, skb, info->nlh, family, table, chain, nla); if (chain) { if (nla[NFTA_RULE_HANDLE]) { rule = nft_rule_lookup(chain, nla[NFTA_RULE_HANDLE]); if (IS_ERR(rule)) { if (PTR_ERR(rule) == -ENOENT && NFNL_MSG_TYPE(info->nlh->nlmsg_type) == NFT_MSG_DESTROYRULE) return 0; NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_HANDLE]); return PTR_ERR(rule); } err = nft_delrule(&ctx, rule); } else if (nla[NFTA_RULE_ID]) { rule = nft_rule_lookup_byid(net, chain, nla[NFTA_RULE_ID]); if (IS_ERR(rule)) { NL_SET_BAD_ATTR(extack, nla[NFTA_RULE_ID]); return PTR_ERR(rule); } err = nft_delrule(&ctx, rule); } else { err = nft_delrule_by_chain(&ctx); } } else { list_for_each_entry(chain, &table->chains, list) { if (!nft_is_active_next(net, chain)) continue; ctx.chain = chain; err = nft_delrule_by_chain(&ctx); if (err < 0) break; } } return err; }"
"static int32_t pkg_createWithAssemblyCode(const char *targetDir, const char mode, const char *gencFilePath) { char tempObjectFile[SMALL_BUFFER_MAX_SIZE] = """"; char *cmd; int32_t result = 0; int32_t length = 0; uprv_strcpy(tempObjectFile, gencFilePath); tempObjectFile[uprv_strlen(tempObjectFile)-1] = 'o'; length = static_cast<int32_t>(uprv_strlen(pkgDataFlags[COMPILER]) + uprv_strlen(pkgDataFlags[LIBFLAGS]) + uprv_strlen(tempObjectFile) + uprv_strlen(gencFilePath) + BUFFER_PADDING_SIZE); cmd = (char *)uprv_malloc(sizeof(char) * length); if (cmd == NULL) { return -1; } sprintf(cmd, ""%s %s -o %s %s"", pkgDataFlags[COMPILER], pkgDataFlags[LIBFLAGS], tempObjectFile, gencFilePath); result = runCommand(cmd); uprv_free(cmd); if (result != 0) { fprintf(stderr, ""Error creating with assembly code. Failed command: %s\n"", cmd); return result; } return pkg_generateLibraryFile(targetDir, mode, tempObjectFile); }"
"static int nsv_parse_NSVf_header(AVFormatContext *s) { NSVContext *nsv = s->priv_data; AVIOContext *pb = s->pb; unsigned int av_unused file_size; unsigned int size; int64_t duration; int strings_size; int table_entries; int table_entries_used; nsv->state = NSV_UNSYNC;  size = avio_rl32(pb); if (size < 28) return -1; nsv->NSVf_end = size; file_size = (uint32_t)avio_rl32(pb); av_log(s, AV_LOG_TRACE, ""NSV NSVf chunk_size %u\n"", size); av_log(s, AV_LOG_TRACE, ""NSV NSVf file_size %u\n"", file_size); nsv->duration = duration = avio_rl32(pb);  av_log(s, AV_LOG_TRACE, ""NSV NSVf duration %""PRId64"" ms\n"", duration); strings_size = avio_rl32(pb); table_entries = avio_rl32(pb); table_entries_used = avio_rl32(pb); av_log(s, AV_LOG_TRACE, ""NSV NSVf info-strings size: %d, table entries: %d, bis %d\n"", strings_size, table_entries, table_entries_used); if (avio_feof(pb)) return -1; av_log(s, AV_LOG_TRACE, ""NSV got header; filepos %""PRId64""\n"", avio_tell(pb)); if (strings_size > 0) { char *strings;  char *p, *endp; char *token, *value; char quote; p = strings = av_mallocz((size_t)strings_size + 1); if (!p) return AVERROR(ENOMEM); endp = strings + strings_size; avio_read(pb, strings, strings_size); while (p < endp) { while (*p == ' ') p++;  if (p >= endp-2) break; token = p; p = strchr(p, '='); if (!p || p >= endp-2) break; *p++ = '\0'; quote = *p++; value = p; p = strchr(p, quote); if (!p || p >= endp) break; *p++ = '\0'; av_log(s, AV_LOG_TRACE, ""NSV NSVf INFO: %s='%s'\n"", token, value); av_dict_set(&s->metadata, token, value, 0); } av_free(strings); } if (avio_feof(pb)) return -1; av_log(s, AV_LOG_TRACE, ""NSV got infos; filepos %""PRId64""\n"", avio_tell(pb)); if (table_entries_used > 0) { int i; nsv->index_entries = table_entries_used; if((unsigned)table_entries_used >= UINT_MAX / sizeof(uint32_t)) return -1; nsv->nsvs_file_offset = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t)); if (!nsv->nsvs_file_offset) return AVERROR(ENOMEM); for(i=0;i<table_entries_used;i++) nsv->nsvs_file_offset[i] = avio_rl32(pb) + size; if(table_entries > table_entries_used && avio_rl32(pb) == MKTAG('T','O','C','2')) { nsv->nsvs_timestamps = av_malloc_array((unsigned)table_entries_used, sizeof(uint32_t)); if (!nsv->nsvs_timestamps) return AVERROR(ENOMEM); for(i=0;i<table_entries_used;i++) { nsv->nsvs_timestamps[i] = avio_rl32(pb); } } } av_log(s, AV_LOG_TRACE, ""NSV got index; filepos %""PRId64""\n"", avio_tell(pb)); avio_seek(pb, nsv->base_offset + size, SEEK_SET);  if (avio_feof(pb)) return -1; nsv->state = NSV_HAS_READ_NSVF; return 0; }"
"static Image *ReadPSDImage(const ImageInfo *image_info,ExceptionInfo *exception) { Image *image; MagickBooleanType has_merged_image, skip_layers; MagickOffsetType offset; MagickSizeType length; MagickBooleanType status; PSDInfo psd_info; register ssize_t i; ssize_t count; unsigned char *data; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } image->endian=MSBEndian; count=ReadBlob(image,4,(unsigned char *) psd_info.signature); psd_info.version=ReadBlobMSBShort(image); if ((count == 0) || (LocaleNCompare(psd_info.signature,""8BPS"",4) != 0) || ((psd_info.version != 1) && (psd_info.version != 2))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); (void) ReadBlob(image,6,psd_info.reserved); psd_info.channels=ReadBlobMSBShort(image); if (psd_info.channels > MaxPSDChannels) ThrowReaderException(CorruptImageError,""MaximumChannelsExceeded""); psd_info.rows=ReadBlobMSBLong(image); psd_info.columns=ReadBlobMSBLong(image); if ((psd_info.version == 1) && ((psd_info.rows > 30000) || (psd_info.columns > 30000))) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); psd_info.depth=ReadBlobMSBShort(image); if ((psd_info.depth != 1) && (psd_info.depth != 8) && (psd_info.depth != 16)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); psd_info.mode=ReadBlobMSBShort(image); if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Image is %.20g x %.20g with channels=%.20g, depth=%.20g, mode=%s"", (double) psd_info.columns,(double) psd_info.rows,(double) psd_info.channels,(double) psd_info.depth,ModeToString((PSDImageType) psd_info.mode)); image->depth=psd_info.depth; image->columns=psd_info.columns; image->rows=psd_info.rows; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); if (SetImageBackgroundColor(image,exception) == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (psd_info.mode == LabMode) SetImageColorspace(image,LabColorspace,exception); if (psd_info.mode == CMYKMode) { SetImageColorspace(image,CMYKColorspace,exception); image->alpha_trait=psd_info.channels > 4 ? BlendPixelTrait : UndefinedPixelTrait; } else if ((psd_info.mode == BitmapMode) || (psd_info.mode == GrayscaleMode) || (psd_info.mode == DuotoneMode)) { status=AcquireImageColormap(image,psd_info.depth != 16 ? 256 : 65536, exception); if (status == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  Image colormap allocated""); SetImageColorspace(image,GRAYColorspace,exception); image->alpha_trait=psd_info.channels > 1 ? BlendPixelTrait : UndefinedPixelTrait; } else image->alpha_trait=psd_info.channels > 3 ? BlendPixelTrait : UndefinedPixelTrait; length=ReadBlobMSBLong(image); if (length != 0) { if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  reading colormap""); if (psd_info.mode == DuotoneMode) { data=(unsigned char *) AcquireQuantumMemory((size_t) length, sizeof(*data)); if (data == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) ReadBlob(image,(size_t) length,data); data=(unsigned char *) RelinquishMagickMemory(data); } else { size_t number_colors; number_colors=length/3; if (number_colors > 65536) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (AcquireImageColormap(image,number_colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); for (i=0; i < (ssize_t) image->colors; i++) image->colormap[i].blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->alpha_trait=UndefinedPixelTrait; } } if ((image->depth == 1) && (image->storage_class != PseudoClass)) ThrowReaderException(CorruptImageError, ""ImproperImageHeader""); has_merged_image=MagickTrue; length=ReadBlobMSBLong(image); if (length != 0) { unsigned char *blocks; if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  reading image resource blocks - %.20g bytes"",(double) ((MagickOffsetType) length)); blocks=(unsigned char *) AcquireQuantumMemory((size_t) length, sizeof(*blocks)); if (blocks == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,(size_t) length,blocks); if ((count != (ssize_t) length) || (LocaleNCompare((char *) blocks,""8BIM"",4) != 0)) { blocks=(unsigned char *) RelinquishMagickMemory(blocks); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } ParseImageResourceBlocks(image,blocks,(size_t) length,&has_merged_image, exception); blocks=(unsigned char *) RelinquishMagickMemory(blocks); } length=GetPSDSize(&psd_info,image); if (length == 8) { length=ReadBlobMSBLong(image); length=ReadBlobMSBLong(image); } offset=TellBlob(image); skip_layers=MagickFalse; if ((image_info->number_scenes == 1) && (image_info->scene == 0) && (has_merged_image != MagickFalse)) { if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  read composite only""); skip_layers=MagickTrue; } if (length == 0) { if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  image has no layers""); } else { if (ReadPSDLayers(image,image_info,&psd_info,skip_layers,exception) != MagickTrue) { (void) CloseBlob(image); image=DestroyImageList(image); return((Image *) NULL); } SeekBlob(image,offset+length,SEEK_SET); } if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } if (image->debug != MagickFalse) (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  reading the precombined layer""); if ((has_merged_image != MagickFalse) || (GetImageListLength(image) == 1)) has_merged_image=(MagickBooleanType) ReadPSDMergedImage(image_info,image, &psd_info,exception); if ((has_merged_image == MagickFalse) && (GetImageListLength(image) == 1) && (length != 0)) { SeekBlob(image,offset,SEEK_SET); status=ReadPSDLayers(image,image_info,&psd_info,MagickFalse,exception); if (status != MagickTrue) { (void) CloseBlob(image); image=DestroyImageList(image); return((Image *) NULL); } } if ((has_merged_image == MagickFalse) && (GetImageListLength(image) > 1)) { Image *merged; SetImageAlphaChannel(image,TransparentAlphaChannel,exception); image->background_color.alpha=TransparentAlpha; image->background_color.alpha_trait=BlendPixelTrait; merged=MergeImageLayers(image,FlattenLayer,exception); ReplaceImageInList(&image,merged); } (void) CloseBlob(image); return(GetFirstImageInList(image)); }"
"int db__message_insert(struct mosquitto *context, uint16_t mid, enum mosquitto_msg_direction dir, uint8_t qos, bool retain, struct mosquitto_msg_store *stored, mosquitto_property *properties, bool update) { struct mosquitto_client_msg *msg; struct mosquitto_msg_data *msg_data; enum mosquitto_msg_state state = mosq_ms_invalid; int rc = 0; int i; char **dest_ids; assert(stored); if(!context) return MOSQ_ERR_INVAL; if(!context->id) return MOSQ_ERR_SUCCESS;  if(dir == mosq_md_out){ msg_data = &context->msgs_out; }else{ msg_data = &context->msgs_in; } if(context->protocol != mosq_p_mqtt5 && db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false && stored->dest_ids){ for(i=0; i<stored->dest_id_count; i++){ if(stored->dest_ids[i] && !strcmp(stored->dest_ids[i], context->id)){ mosquitto_property_free_all(&properties); return MOSQ_ERR_SUCCESS; } } } if(context->sock == INVALID_SOCKET){ if(qos == 0 && !db.config->queue_qos0_messages){ if(!context->bridge){ mosquitto_property_free_all(&properties); return 2; }else{ if(context->bridge->start_type != bst_lazy){ mosquitto_property_free_all(&properties); return 2; } } } if(context->bridge && context->bridge->clean_start_local == true){ mosquitto_property_free_all(&properties); return 2; } } if(context->sock != INVALID_SOCKET){ if(db__ready_for_flight(context, dir, qos)){ if(dir == mosq_md_out){ switch(qos){ case 0: state = mosq_ms_publish_qos0; break; case 1: state = mosq_ms_publish_qos1; break; case 2: state = mosq_ms_publish_qos2; break; } }else{ if(qos == 2){ state = mosq_ms_wait_for_pubrel; }else{ mosquitto_property_free_all(&properties); return 1; } } }else if(qos != 0 && db__ready_for_queue(context, qos, msg_data)){ state = mosq_ms_queued; rc = 2; }else{ if(context->is_dropping == false){ context->is_dropping = true; log__printf(NULL, MOSQ_LOG_NOTICE, ""Outgoing messages are being dropped for client %s."", context->id); } G_MSGS_DROPPED_INC(); mosquitto_property_free_all(&properties); return 2; } }else{ if (db__ready_for_queue(context, qos, msg_data)){ state = mosq_ms_queued; }else{ G_MSGS_DROPPED_INC(); if(context->is_dropping == false){ context->is_dropping = true; log__printf(NULL, MOSQ_LOG_NOTICE, ""Outgoing messages are being dropped for client %s."", context->id); } mosquitto_property_free_all(&properties); return 2; } } assert(state != mosq_ms_invalid); #ifdef WITH_PERSISTENCE if(state == mosq_ms_queued){ db.persistence_changes++; } #endif msg = mosquitto__malloc(sizeof(struct mosquitto_client_msg)); if(!msg) return MOSQ_ERR_NOMEM; msg->prev = NULL; msg->next = NULL; msg->store = stored; db__msg_store_ref_inc(msg->store); msg->mid = mid; msg->timestamp = db.now_s; msg->direction = dir; msg->state = state; msg->dup = false; if(qos > context->max_qos){ msg->qos = context->max_qos; }else{ msg->qos = qos; } msg->retain = retain; msg->properties = properties; if(state == mosq_ms_queued){ DL_APPEND(msg_data->queued, msg); db__msg_add_to_queued_stats(msg_data, msg); }else{ DL_APPEND(msg_data->inflight, msg); db__msg_add_to_inflight_stats(msg_data, msg); } if(db.config->allow_duplicate_messages == false && dir == mosq_md_out && retain == false){ dest_ids = mosquitto__realloc(stored->dest_ids, sizeof(char *)*(size_t)(stored->dest_id_count+1)); if(dest_ids){ stored->dest_ids = dest_ids; stored->dest_id_count++; stored->dest_ids[stored->dest_id_count-1] = mosquitto__strdup(context->id); if(!stored->dest_ids[stored->dest_id_count-1]){ return MOSQ_ERR_NOMEM; } }else{ return MOSQ_ERR_NOMEM; } } #ifdef WITH_BRIDGE if(context->bridge && context->bridge->start_type == bst_lazy && context->sock == INVALID_SOCKET && context->msgs_out.inflight_count + context->msgs_out.queued_count >= context->bridge->threshold){ context->bridge->lazy_reconnect = true; } #endif if(dir == mosq_md_out && msg->qos > 0 && state != mosq_ms_queued){ util__decrement_send_quota(context); } if(dir == mosq_md_out && update){ rc = db__message_write_inflight_out_latest(context); if(rc) return rc; rc = db__message_write_queued_out(context); if(rc) return rc; } return rc; }"
"static struct buffer_head * ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group) { struct ext4_group_desc *desc; struct buffer_head *bh = NULL; ext4_fsblk_t bitmap_blk; int err; desc = ext4_get_group_desc(sb, block_group, NULL); if (!desc) return ERR_PTR(-EFSCORRUPTED); bitmap_blk = ext4_inode_bitmap(sb, desc); bh = sb_getblk(sb, bitmap_blk); if (unlikely(!bh)) { ext4_error(sb, ""Cannot read inode bitmap - "" ""block_group = %u, inode_bitmap = %llu"", block_group, bitmap_blk); return ERR_PTR(-EIO); } if (bitmap_uptodate(bh)) goto verify; lock_buffer(bh); if (bitmap_uptodate(bh)) { unlock_buffer(bh); goto verify; } ext4_lock_group(sb, block_group); if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) { memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8); ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8, bh->b_data); set_bitmap_uptodate(bh); set_buffer_uptodate(bh); set_buffer_verified(bh); ext4_unlock_group(sb, block_group); unlock_buffer(bh); return bh; } ext4_unlock_group(sb, block_group); if (buffer_uptodate(bh)) { set_bitmap_uptodate(bh); unlock_buffer(bh); goto verify; } trace_ext4_load_inode_bitmap(sb, block_group); bh->b_end_io = ext4_end_bitmap_read; get_bh(bh); submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh); wait_on_buffer(bh); if (!buffer_uptodate(bh)) { put_bh(bh); ext4_error(sb, ""Cannot read inode bitmap - "" ""block_group = %u, inode_bitmap = %llu"", block_group, bitmap_blk); return ERR_PTR(-EIO); } verify: err = ext4_validate_inode_bitmap(sb, desc, block_group, bh); if (err) goto out; return bh; out: put_bh(bh); return ERR_PTR(err); }"
"int zend_accel_hash_unlink(zend_accel_hash *accel_hash, char *key, zend_uint key_length) { zend_ulong hash_value; zend_ulong index; zend_accel_hash_entry *entry, *last_entry=NULL; hash_value = zend_inline_hash_func(key, key_length); index = hash_value % accel_hash->max_num_entries; entry = accel_hash->hash_table[index]; while (entry) { if (entry->hash_value == hash_value && entry->key_length == key_length && !memcmp(entry->key, key, key_length)) { if (!entry->indirect) { accel_hash->num_direct_entries--; } if (last_entry) { last_entry->next = entry->next; } else { accel_hash->hash_table[index] = entry->next; } return SUCCESS; } last_entry = entry; entry = entry->next; } return FAILURE; }"
"static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s, UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman, int transferDir) { UINT32 EndpointAddress; UINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets; UINT32 ErrorCount, OutputBufferSize; BYTE* packetDescriptorData; const BOOL noAck = (RequestField & 0x80000000U) != 0; const UINT32 RequestId = RequestField & 0x7FFFFFFF; if (!pdev || !callback || !udevman) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(s) < 20) return ERROR_INVALID_DATA; Stream_Read_UINT32(s, PipeHandle); EndpointAddress = (PipeHandle & 0x000000ff); Stream_Read_UINT32(s, TransferFlags);    Stream_Read_UINT32(s, StartFrame);       Stream_Read_UINT32(s, NumberOfPackets);  Stream_Read_UINT32(s, ErrorCount);       if (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4) return ERROR_INVALID_DATA; packetDescriptorData = Stream_Pointer(s); Stream_Seek(s, NumberOfPackets * 12); Stream_Read_UINT32(s, OutputBufferSize); return pdev->isoch_transfer( pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame, ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL, urb_isoch_transfer_cb, 2000); }"
"static int con_install(struct tty_driver *driver, struct tty_struct *tty) { unsigned int currcons = tty->index; struct vc_data *vc; int ret; console_lock(); ret = vc_allocate(currcons); if (ret) goto unlock; vc = vc_cons[currcons].d; if (vc->port.tty) { ret = -ERESTARTSYS; goto unlock; } ret = tty_port_install(&vc->port, driver, tty); if (ret) goto unlock; tty->driver_data = vc; vc->port.tty = tty; if (!tty->winsize.ws_row && !tty->winsize.ws_col) { tty->winsize.ws_row = vc_cons[currcons].d->vc_rows; tty->winsize.ws_col = vc_cons[currcons].d->vc_cols; } if (vc->vc_utf) tty->termios.c_iflag |= IUTF8; else tty->termios.c_iflag &= ~IUTF8; unlock: console_unlock(); return ret; }"
"void fli_read_lc(FILE *f, s_fli_header *fli_header, unsigned char *old_framebuf, unsigned char *framebuf) { unsigned short yc, firstline, numline; unsigned char *pos; memcpy(framebuf, old_framebuf, fli_header->width * fli_header->height); firstline = fli_read_short(f); numline = fli_read_short(f); for (yc=0; yc < numline; yc++) { unsigned short xc, pc, pcnt; pc=fli_read_char(f); xc=0; pos=framebuf+(fli_header->width * (firstline+yc)); for (pcnt=pc; pcnt>0; pcnt--) { unsigned short ps,skip; skip=fli_read_char(f); ps=fli_read_char(f); xc+=skip; if (ps & 0x80) { unsigned char val; ps=-(signed char)ps; val=fli_read_char(f); memset(&(pos[xc]), val, ps); xc+=ps; } else { fread(&(pos[xc]), ps, 1, f); xc+=ps; } } } }"
"static int decompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset) { LZ4F_decompressionContext_t lz4_ctxt = NULL; LZ4F_frameInfo_t lz4_info; LZ4F_errorCode_t rc = 0; size_t src_offset = 0, src_size = 0, dst_size = 0; guchar *decompressed_buffer = NULL; tvbuff_t *composite_tvb = NULL; int ret = 0; guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length); if (length > 7) { guint32 hdr_end = 6; if (data[4] & 0x08) { hdr_end += 8; } if (hdr_end < length) { data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff; } } rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION); if (LZ4F_isError(rc)) { goto end; } src_offset = length; rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset); if (LZ4F_isError(rc)) { goto end; } switch (lz4_info.blockSizeID) { case LZ4F_max64KB: dst_size = 1 << 16; break; case LZ4F_max256KB: dst_size = 1 << 18; break; case LZ4F_max1MB: dst_size = 1 << 20; break; case LZ4F_max4MB: dst_size = 1 << 22; break; default: goto end; } if (lz4_info.contentSize && lz4_info.contentSize < dst_size) { dst_size = (size_t)lz4_info.contentSize; } do { src_size = length - src_offset;         if (src_size == 0) { goto end; } decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size); rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size, &data[src_offset], &src_size, NULL); if (LZ4F_isError(rc)) { goto end; } if (dst_size == 0) { goto end; } if (!composite_tvb) { composite_tvb = tvb_new_composite(); } tvb_composite_append(composite_tvb, tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size)); src_offset += src_size;     } while (rc > 0); ret = 1; end: if (composite_tvb) { tvb_composite_finalize(composite_tvb); } LZ4F_freeDecompressionContext(lz4_ctxt); if (ret == 1) { *decompressed_tvb = composite_tvb; *decompressed_offset = 0; } else { col_append_str(pinfo->cinfo, COL_INFO, "" [lz4 decompression failed]""); } return ret; }"
"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba) { struct ufs_mtk_host *host = ufshcd_get_variant(hba); host->reg_va09 = regulator_get(hba->dev, ""va09""); if (!host->reg_va09) dev_info(hba->dev, ""failed to get va09""); else host->caps |= UFS_MTK_CAP_VA09_PWR_CTRL; }"
"int cgroup1_parse_param(struct fs_context *fc, struct fs_parameter *param) { struct cgroup_fs_context *ctx = cgroup_fc2context(fc); struct cgroup_subsys *ss; struct fs_parse_result result; int opt, i; opt = fs_parse(fc, cgroup1_fs_parameters, param, &result); if (opt == -ENOPARAM) { int ret; ret = vfs_parse_fs_param_source(fc, param); if (ret != -ENOPARAM) return ret; for_each_subsys(ss, i) { if (strcmp(param->key, ss->legacy_name)) continue; if (!cgroup_ssid_enabled(i) || cgroup1_ssid_disabled(i)) return invalfc(fc, ""Disabled controller '%s'"", param->key); ctx->subsys_mask |= (1 << i); return 0; } return invalfc(fc, ""Unknown subsys name '%s'"", param->key); } if (opt < 0) return opt; switch (opt) { case Opt_none: ctx->none = true; break; case Opt_all: ctx->all_ss = true; break; case Opt_noprefix: ctx->flags |= CGRP_ROOT_NOPREFIX; break; case Opt_clone_children: ctx->cpuset_clone_children = true; break; case Opt_cpuset_v2_mode: ctx->flags |= CGRP_ROOT_CPUSET_V2_MODE; break; case Opt_xattr: ctx->flags |= CGRP_ROOT_XATTR; break; case Opt_release_agent: if (ctx->release_agent) return invalfc(fc, ""release_agent respecified""); ctx->release_agent = param->string; param->string = NULL; break; case Opt_name: if (cgroup_no_v1_named) return -ENOENT; if (!param->size) return invalfc(fc, ""Empty name""); if (param->size > MAX_CGROUP_ROOT_NAMELEN - 1) return invalfc(fc, ""Name too long""); for (i = 0; i < param->size; i++) { char c = param->string[i]; if (isalnum(c)) continue; if ((c == '.') || (c == '-') || (c == '_')) continue; return invalfc(fc, ""Invalid name""); } if (ctx->name) return invalfc(fc, ""name respecified""); ctx->name = param->string; param->string = NULL; break; } return 0; }"
"static UINT serial_process_irp_create(SERIAL_DEVICE* serial, IRP* irp) { DWORD DesiredAccess; DWORD SharedAccess; DWORD CreateDisposition; UINT32 PathLength; if (Stream_GetRemainingLength(irp->input) < 32) return ERROR_INVALID_DATA; Stream_Read_UINT32(irp->input, DesiredAccess);      Stream_Seek_UINT64(irp->input);                     Stream_Seek_UINT32(irp->input);                     Stream_Read_UINT32(irp->input, SharedAccess);       Stream_Read_UINT32(irp->input, CreateDisposition);  Stream_Seek_UINT32(irp->input);                     Stream_Read_UINT32(irp->input, PathLength);         if (Stream_GetRemainingLength(irp->input) < PathLength) return ERROR_INVALID_DATA; Stream_Seek(irp->input, PathLength);  assert(PathLength == 0);              #ifndef _WIN32 WLog_Print(serial->log, WLOG_DEBUG, ""DesiredAccess: 0x%"" PRIX32 "", SharedAccess: 0x%"" PRIX32 "", CreateDisposition: 0x%"" PRIX32 """", DesiredAccess, SharedAccess, CreateDisposition); DesiredAccess = GENERIC_READ | GENERIC_WRITE; SharedAccess = 0; CreateDisposition = OPEN_EXISTING; #endif serial->hComm = CreateFile(serial->device.name, DesiredAccess, SharedAccess, NULL,  CreateDisposition, 0,                                    NULL);                                                   if (!serial->hComm || (serial->hComm == INVALID_HANDLE_VALUE)) { WLog_Print(serial->log, WLOG_WARN, ""CreateFile failure: %s last-error: 0x%08"" PRIX32 """", serial->device.name, GetLastError()); irp->IoStatus = STATUS_UNSUCCESSFUL; goto error_handle; } _comm_setServerSerialDriver(serial->hComm, serial->ServerSerialDriverId); _comm_set_permissive(serial->hComm, serial->permissive); assert(irp->FileId == 0); irp->FileId = irp->devman->id_sequence++;  irp->IoStatus = STATUS_SUCCESS; WLog_Print(serial->log, WLOG_DEBUG, ""%s (DeviceId: %"" PRIu32 "", FileId: %"" PRIu32 "") created."", serial->device.name, irp->device->id, irp->FileId); error_handle: Stream_Write_UINT32(irp->output, irp->FileId);  Stream_Write_UINT8(irp->output, 0);             return CHANNEL_RC_OK; }"
"void p_ntp_time(netdissect_options *ndo, const struct l_fixedpt *lfp) { uint32_t i; uint32_t uf; uint32_t f; double ff; i = GET_BE_U_4(lfp->int_part); uf = GET_BE_U_4(lfp->fraction); ff = uf; if (ff < 0.0) ff += FMAXINT; ff = ff / FMAXINT; f = (uint32_t)(ff * 1000000000.0); ND_PRINT(""%u.%09u"", i, f); if (i) { int64_t seconds_64bit = (int64_t)i - JAN_1970; time_t seconds; struct tm *tm; char time_buf[128]; seconds = (time_t)seconds_64bit; if (seconds != seconds_64bit) { ND_PRINT("" (unrepresentable)""); } else { tm = gmtime(&seconds); if (tm == NULL) { ND_PRINT("" (unrepresentable)""); } else { strftime(time_buf, sizeof (time_buf), ""%Y-%m-%dT%H:%M:%SZ"", tm); ND_PRINT("" (%s)"", time_buf); } } } }"
"BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize, UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat, UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth, UINT32 nDstHeight, BOOL vFlip) { BOOL cs; BOOL rle; UINT32 cll; BOOL alpha; BOOL useAlpha = FALSE; INT32 status; const BYTE* srcp; UINT32 subSize; UINT32 subWidth; UINT32 subHeight; UINT32 planeSize; INT32 rleSizes[4] = { 0, 0, 0, 0 }; UINT32 rawSizes[4]; UINT32 rawWidths[4]; UINT32 rawHeights[4]; BYTE FormatHeader; const BYTE* planes[4] = { 0 }; const UINT32 w = MIN(nSrcWidth, nDstWidth); const UINT32 h = MIN(nSrcHeight, nDstHeight); const primitives_t* prims = primitives_get(); WINPR_ASSERT(planar); WINPR_ASSERT(prims); if (nDstStep <= 0) nDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat); srcp = pSrcData; if (!pSrcData) { WLog_ERR(TAG, ""Invalid argument pSrcData=NULL""); return FALSE; } if (!pDstData) { WLog_ERR(TAG, ""Invalid argument pDstData=NULL""); return FALSE; } FormatHeader = *srcp++; cll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK); cs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE; rle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE; alpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE; DstFormat = planar_invert_format(planar, alpha, DstFormat); if (alpha) useAlpha = FreeRDPColorHasAlpha(DstFormat); if (!cll && cs) { WLog_ERR(TAG, ""Chroma subsampling requires YCoCg and does not work with RGB data""); return FALSE;  } subWidth = (nSrcWidth / 2) + (nSrcWidth % 2); subHeight = (nSrcHeight / 2) + (nSrcHeight % 2); planeSize = nSrcWidth * nSrcHeight; subSize = subWidth * subHeight; if (!cs) { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } else  { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = subSize;  rawWidths[1] = subWidth; rawHeights[1] = subHeight; rawSizes[2] = subSize;  rawWidths[2] = subWidth; rawHeights[2] = subHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } if (!rle)  { UINT32 base = planeSize * 3; if (cs) base = planeSize + planeSize / 2; if (alpha) { if ((SrcSize - (srcp - pSrcData)) < (planeSize + base)) { WLog_ERR(TAG, ""Alpha plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), (planeSize + base)); return FALSE; } planes[3] = srcp;                     planes[0] = planes[3] + rawSizes[3];  planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } else { if ((SrcSize - (srcp - pSrcData)) < base) { WLog_ERR(TAG, ""plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), base); return FALSE; } planes[0] = srcp;                     planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } } else  { if (alpha) { planes[3] = srcp; rleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData), rawWidths[3], rawHeights[3]);  if (rleSizes[3] < 0) return FALSE; planes[0] = planes[3] + rleSizes[3]; } else planes[0] = srcp; rleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData), rawWidths[0], rawHeights[0]);  if (rleSizes[0] < 0) return FALSE; planes[1] = planes[0] + rleSizes[0]; rleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData), rawWidths[1], rawHeights[1]);  if (rleSizes[1] < 1) return FALSE; planes[2] = planes[1] + rleSizes[1]; rleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData), rawWidths[2], rawHeights[2]);  if (rleSizes[2] < 1) return FALSE; } if (!cll)  { UINT32 TempFormat; BYTE* pTempData = pDstData; UINT32 nTempStep = nDstStep; UINT32 nTotalHeight = nYDst + nDstHeight; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; TempFormat = planar_invert_format(planar, alpha, TempFormat); if ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight)) { pTempData = planar->pTempData; nTempStep = planar->nTempStep; nTotalHeight = planar->maxHeight; } if (!rle)  { if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } else  { status = planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 2, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 1, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 0, vFlip);  if (status < 0) return FALSE; srcp += rleSizes[0] + rleSizes[1] + rleSizes[2]; if (useAlpha) { status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip);  } else status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip); if (status < 0) return FALSE; if (alpha) srcp += rleSizes[3]; } if (pTempData != pDstData) { if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData, TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE)) { WLog_ERR(TAG, ""planar image copy failed""); return FALSE; } } } else  { UINT32 TempFormat; BYTE* pTempData = planar->pTempData; UINT32 nTempStep = planar->nTempStep; UINT32 nTotalHeight = planar->maxHeight; BYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep]; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; if (!pTempData) { return FALSE; } if (rle)  { BYTE* rleBuffer[4] = { 0 }; rleBuffer[3] = planar->rlePlanesBuffer;   rleBuffer[0] = rleBuffer[3] + planeSize;  rleBuffer[1] = rleBuffer[0] + planeSize;  rleBuffer[2] = rleBuffer[1] + planeSize;  if (useAlpha) { status = planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3], rawWidths[3], rawHeights[3]);  if (status < 0) return FALSE; } if (alpha) srcp += rleSizes[3]; status = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0], rawWidths[0], rawHeights[0]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1], rawHeights[1]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2], rawHeights[2]);  if (status < 0) return FALSE; planes[0] = rleBuffer[0]; planes[1] = rleBuffer[1]; planes[2] = rleBuffer[2]; planes[3] = rleBuffer[3]; } { if (cs) {  if (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight, rawWidths[1], rawHeights[1], planar->deltaPlanes[0])) return FALSE; planes[1] = planar->deltaPlanes[0]; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; if (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight, rawWidths[2], rawHeights[2], planar->deltaPlanes[1])) return FALSE; planes[2] = planar->deltaPlanes[1]; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; } if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } WINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R); int rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h, cll, useAlpha); if (rc != PRIMITIVES_SUCCESS) { WLog_ERR(TAG, ""YCoCgToRGB_8u_AC4R failed with %d"", rc); return FALSE; } } WINPR_UNUSED(srcp); return TRUE; }"
"unsigned paravirt_patch_call(void *insnbuf, const void *target, u16 tgt_clobbers, unsigned long addr, u16 site_clobbers, unsigned len) { struct branch *b = insnbuf; unsigned long delta = (unsigned long)target - (addr+5); if (tgt_clobbers & ~site_clobbers) return len; if (len < 5) return len; b->opcode = 0xe8;  b->delta = delta; BUILD_BUG_ON(sizeof(*b) != 5); return 5; }"
"static int mwifiex_usb_recv(struct mwifiex_adapter *adapter, struct sk_buff *skb, u8 ep) { u32 recv_type; __le32 tmp; int ret; if (adapter->hs_activated) mwifiex_process_hs_config(adapter); if (skb->len < INTF_HEADER_LEN) { mwifiex_dbg(adapter, ERROR, ""%s: invalid skb->len\n"", __func__); return -1; } switch (ep) { case MWIFIEX_USB_EP_CMD_EVENT: mwifiex_dbg(adapter, EVENT, ""%s: EP_CMD_EVENT\n"", __func__); skb_copy_from_linear_data(skb, &tmp, INTF_HEADER_LEN); recv_type = le32_to_cpu(tmp); skb_pull(skb, INTF_HEADER_LEN); switch (recv_type) { case MWIFIEX_USB_TYPE_CMD: if (skb->len > MWIFIEX_SIZE_OF_CMD_BUFFER) { mwifiex_dbg(adapter, ERROR, ""CMD: skb->len too large\n""); ret = -1; goto exit_restore_skb; } else if (!adapter->curr_cmd) { mwifiex_dbg(adapter, WARN, ""CMD: no curr_cmd\n""); if (adapter->ps_state == PS_STATE_SLEEP_CFM) { mwifiex_process_sleep_confirm_resp( adapter, skb->data, skb->len); ret = 0; goto exit_restore_skb; } ret = -1; goto exit_restore_skb; } adapter->curr_cmd->resp_skb = skb; adapter->cmd_resp_received = true; break; case MWIFIEX_USB_TYPE_EVENT: if (skb->len < sizeof(u32)) { mwifiex_dbg(adapter, ERROR, ""EVENT: skb->len too small\n""); ret = -1; goto exit_restore_skb; } skb_copy_from_linear_data(skb, &tmp, sizeof(u32)); adapter->event_cause = le32_to_cpu(tmp); mwifiex_dbg(adapter, EVENT, ""event_cause %#x\n"", adapter->event_cause); if (skb->len > MAX_EVENT_SIZE) { mwifiex_dbg(adapter, ERROR, ""EVENT: event body too large\n""); ret = -1; goto exit_restore_skb; } memcpy(adapter->event_body, skb->data + MWIFIEX_EVENT_HEADER_LEN, skb->len); adapter->event_received = true; adapter->event_skb = skb; break; default: mwifiex_dbg(adapter, ERROR, ""unknown recv_type %#x\n"", recv_type); return -1; } break; case MWIFIEX_USB_EP_DATA: mwifiex_dbg(adapter, DATA, ""%s: EP_DATA\n"", __func__); if (skb->len > MWIFIEX_RX_DATA_BUF_SIZE) { mwifiex_dbg(adapter, ERROR, ""DATA: skb->len too large\n""); return -1; } skb_queue_tail(&adapter->rx_data_q, skb); adapter->data_received = true; atomic_inc(&adapter->rx_pending); break; default: mwifiex_dbg(adapter, ERROR, ""%s: unknown endport %#x\n"", __func__, ep); return -1; } return -EINPROGRESS; exit_restore_skb: skb_push(skb, INTF_HEADER_LEN); return ret; }"
"static void parser_reparse_as_common_identifier (parser_context_t *context_p,  parser_line_counter_t start_line,  parser_line_counter_t start_column)  { context_p->source_p = context_p->token.lit_location.char_p; context_p->line = start_line; context_p->column = start_column; lexer_next_token (context_p); if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL) { parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED); } lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL); }"
"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { const TfLiteTensor* params; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params)); const TfLiteTensor* indices; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices)); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); switch (indices->type) { case kTfLiteInt32: return EvalGatherNd<int32_t>(context, params, indices, output); case kTfLiteInt64: return EvalGatherNd<int64_t>(context, params, indices, output); default: context->ReportError( context, ""Indices of type '%s' are not supported by gather_nd."", TfLiteTypeGetName(indices->type)); return kTfLiteError; } }"
"void hvm_task_switch( uint16_t tss_sel, enum hvm_task_switch_reason taskswitch_reason, int32_t errcode) { struct vcpu *v = current; struct cpu_user_regs *regs = guest_cpu_user_regs(); struct segment_register gdt, tr, prev_tr, segr; struct desc_struct *optss_desc = NULL, *nptss_desc = NULL, tss_desc; bool_t otd_writable, ntd_writable; unsigned long eflags; int exn_raised, rc; struct { u16 back_link,__blh; u32 esp0; u16 ss0, _0; u32 esp1; u16 ss1, _1; u32 esp2; u16 ss2, _2; u32 cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; u16 es, _3, cs, _4, ss, _5, ds, _6, fs, _7, gs, _8, ldt, _9; u16 trace, iomap; } tss = { 0 }; hvm_get_segment_register(v, x86_seg_gdtr, &gdt); hvm_get_segment_register(v, x86_seg_tr, &prev_tr); if ( ((tss_sel & 0xfff8) + 7) > gdt.limit ) { hvm_inject_hw_exception((taskswitch_reason == TSW_iret) ? TRAP_invalid_tss : TRAP_gp_fault, tss_sel & 0xfff8); goto out; } optss_desc = hvm_map_entry(gdt.base + (prev_tr.sel & 0xfff8), &otd_writable); if ( optss_desc == NULL ) goto out; nptss_desc = hvm_map_entry(gdt.base + (tss_sel & 0xfff8), &ntd_writable); if ( nptss_desc == NULL ) goto out; tss_desc = *nptss_desc; tr.sel = tss_sel; tr.base = (((tss_desc.b <<  0) & 0xff000000u) | ((tss_desc.b << 16) & 0x00ff0000u) | ((tss_desc.a >> 16) & 0x0000ffffu)); tr.attr.bytes = (((tss_desc.b >>  8) & 0x00ffu) | ((tss_desc.b >> 12) & 0x0f00u)); tr.limit = (tss_desc.b & 0x000f0000u) | (tss_desc.a & 0x0000ffffu); if ( tr.attr.fields.g ) tr.limit = (tr.limit << 12) | 0xfffu; if ( tr.attr.fields.type != ((taskswitch_reason == TSW_iret) ? 0xb : 0x9) ) { hvm_inject_hw_exception( (taskswitch_reason == TSW_iret) ? TRAP_invalid_tss : TRAP_gp_fault, tss_sel & 0xfff8); goto out; } if ( !tr.attr.fields.p ) { hvm_inject_hw_exception(TRAP_no_segment, tss_sel & 0xfff8); goto out; } if ( tr.limit < (sizeof(tss)-1) ) { hvm_inject_hw_exception(TRAP_invalid_tss, tss_sel & 0xfff8); goto out; } rc = hvm_copy_from_guest_virt( &tss, prev_tr.base, sizeof(tss), PFEC_page_present); if ( rc != HVMCOPY_okay ) goto out; eflags = regs->eflags; if ( taskswitch_reason == TSW_iret ) eflags &= ~X86_EFLAGS_NT; tss.cr3    = v->arch.hvm_vcpu.guest_cr[3]; tss.eip    = regs->eip; tss.eflags = eflags; tss.eax    = regs->eax; tss.ecx    = regs->ecx; tss.edx    = regs->edx; tss.ebx    = regs->ebx; tss.esp    = regs->esp; tss.ebp    = regs->ebp; tss.esi    = regs->esi; tss.edi    = regs->edi; hvm_get_segment_register(v, x86_seg_es, &segr); tss.es = segr.sel; hvm_get_segment_register(v, x86_seg_cs, &segr); tss.cs = segr.sel; hvm_get_segment_register(v, x86_seg_ss, &segr); tss.ss = segr.sel; hvm_get_segment_register(v, x86_seg_ds, &segr); tss.ds = segr.sel; hvm_get_segment_register(v, x86_seg_fs, &segr); tss.fs = segr.sel; hvm_get_segment_register(v, x86_seg_gs, &segr); tss.gs = segr.sel; hvm_get_segment_register(v, x86_seg_ldtr, &segr); tss.ldt = segr.sel; rc = hvm_copy_to_guest_virt( prev_tr.base, &tss, sizeof(tss), PFEC_page_present); if ( rc != HVMCOPY_okay ) goto out; rc = hvm_copy_from_guest_virt( &tss, tr.base, sizeof(tss), PFEC_page_present); if ( rc != HVMCOPY_okay ) goto out; if ( hvm_set_cr3(tss.cr3, 1) ) goto out; regs->eip    = tss.eip; regs->eflags = tss.eflags | 2; regs->eax    = tss.eax; regs->ecx    = tss.ecx; regs->edx    = tss.edx; regs->ebx    = tss.ebx; regs->esp    = tss.esp; regs->ebp    = tss.ebp; regs->esi    = tss.esi; regs->edi    = tss.edi; if ( (taskswitch_reason == TSW_call_or_int) ) { regs->eflags |= X86_EFLAGS_NT; tss.back_link = prev_tr.sel; } exn_raised = 0; if ( hvm_load_segment_selector(x86_seg_ldtr, tss.ldt) || hvm_load_segment_selector(x86_seg_es, tss.es) || hvm_load_segment_selector(x86_seg_cs, tss.cs) || hvm_load_segment_selector(x86_seg_ss, tss.ss) || hvm_load_segment_selector(x86_seg_ds, tss.ds) || hvm_load_segment_selector(x86_seg_fs, tss.fs) || hvm_load_segment_selector(x86_seg_gs, tss.gs) ) exn_raised = 1; rc = hvm_copy_to_guest_virt( tr.base, &tss, sizeof(tss), PFEC_page_present); if ( rc == HVMCOPY_bad_gva_to_gfn ) exn_raised = 1; else if ( rc != HVMCOPY_okay ) goto out; if ( (tss.trace & 1) && !exn_raised ) hvm_inject_hw_exception(TRAP_debug, HVM_DELIVER_NO_ERROR_CODE); tr.attr.fields.type = 0xb;  hvm_set_segment_register(v, x86_seg_tr, &tr); v->arch.hvm_vcpu.guest_cr[0] |= X86_CR0_TS; hvm_update_guest_cr(v, 0); if ( (taskswitch_reason == TSW_iret || taskswitch_reason == TSW_jmp) && otd_writable ) clear_bit(41, optss_desc);  if ( taskswitch_reason != TSW_iret && ntd_writable ) set_bit(41, nptss_desc);  if ( errcode >= 0 ) { struct segment_register reg; unsigned long linear_addr; regs->esp -= 4; hvm_get_segment_register(current, x86_seg_ss, &reg); if ( hvm_virtual_to_linear_addr(x86_seg_ss, &reg, regs->esp, 4, hvm_access_write, 32, &linear_addr) ) hvm_copy_to_guest_virt_nofault(linear_addr, &errcode, 4, 0); } out: hvm_unmap_entry(optss_desc); hvm_unmap_entry(nptss_desc); }"
"static int string_scan_range(RList *list, RBinFile *bf, int min, const ut64 from, const ut64 to, int type, int raw, RBinSection *section) { RBin *bin = bf->rbin; ut8 tmp[R_STRING_SCAN_BUFFER_SIZE]; ut64 str_start, needle = from; int count = 0, i, rc, runes; int str_type = R_STRING_TYPE_DETECT; r_return_val_if_fail (bf, -1); if (type == -1) { type = R_STRING_TYPE_DETECT; } if (from == to) { return 0; } if (from > to) { eprintf (""Invalid range to find strings 0x%""PFMT64x"" .. 0x%""PFMT64x""\n"", from, to); return -1; } st64 len = (st64)(to - from); if (len < 1 || len > ST32_MAX) { eprintf (""String scan range is invalid (%""PFMT64d"" bytes)\n"", len); return -1; } ut8 *buf = calloc (len, 1); if (!buf || !min) { free (buf); return -1; } st64 vdelta = 0, pdelta = 0; RBinSection *s = NULL; bool ascii_only = false; PJ *pj = NULL; if (bf->strmode == R_MODE_JSON && !list) { pj = pj_new (); if (pj) { pj_a (pj); } } r_buf_read_at (bf->buf, from, buf, len); char *charset = r_sys_getenv (""RABIN2_CHARSET""); if (!R_STR_ISEMPTY (charset)) { RCharset *ch = r_charset_new (); if (r_charset_use (ch, charset)) { int outlen = len * 4; ut8 *out = calloc (len, 4); if (out) { int res = r_charset_encode_str (ch, out, outlen, buf, len); int i; for (i = 0; i < res; i++) { if (out[i] == '?') { out[i] = 0; } } len = res; free (buf); buf = out; } else { eprintf (""Cannot allocate\n""); } } else { eprintf (""Invalid value for RABIN2_CHARSET.\n""); } r_charset_free (ch); } free (charset); RConsIsBreaked is_breaked = (bin && bin->consb.is_breaked)? bin->consb.is_breaked: NULL; while (needle < to) { if (is_breaked && is_breaked ()) { break; } if (needle + 4 < to) { ut32 n1 = r_read_le32 (buf + needle - from); if (!n1) { needle += 4; continue; } } rc = r_utf8_decode (buf + needle - from, to - needle, NULL); if (!rc) { needle++; continue; } bool addr_aligned = !(needle % 4); if (type == R_STRING_TYPE_DETECT) { char *w = (char *)buf + needle + rc - from; if (((to - needle) > 8 + rc)) { bool is_wide32le = (needle + rc + 2 < to) && (!w[0] && !w[1] && !w[2] && w[3] && !w[4]); if (is_wide32le) { if (!w[5] && !w[6] && w[7] && w[8]) { is_wide32le = false; } } if (!addr_aligned) { is_wide32le = false; } if (is_wide32le  && addr_aligned) { str_type = R_STRING_TYPE_WIDE32; } else { bool is_wide = needle + rc + 4 < to && !w[0] && w[1] && !w[2] && w[3] && !w[4]; str_type = is_wide? R_STRING_TYPE_WIDE: R_STRING_TYPE_ASCII; } } else { if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } else { str_type = R_STRING_TYPE_ASCII; } } } else if (type == R_STRING_TYPE_UTF8) { str_type = R_STRING_TYPE_ASCII; } else { str_type = type; } runes = 0; str_start = needle; for (i = 0; i < sizeof (tmp) - 4 && needle < to; i += rc) { RRune r = {0}; if (str_type == R_STRING_TYPE_WIDE32) { rc = r_utf32le_decode (buf + needle - from, to - needle, &r); if (rc) { rc = 4; } } else if (str_type == R_STRING_TYPE_WIDE) { rc = r_utf16le_decode (buf + needle - from, to - needle, &r); if (rc == 1) { rc = 2; } } else { rc = r_utf8_decode (buf + needle - from, to - needle, &r); if (rc > 1) { str_type = R_STRING_TYPE_UTF8; } } if (!rc || (ascii_only && r > 0x7f)) { needle++; break; } needle += rc; if (r_isprint (r) && r != '\\') { if (str_type == R_STRING_TYPE_WIDE32) { if (r == 0xff) { r = 0; } } rc = r_utf8_encode (tmp + i, r); runes++; } else if (r && r < 0x100 && strchr (""\b\v\f\n\r\t\a\033\\"", (char)r)) { if ((i + 32) < sizeof (tmp) && r < 93) { tmp[i + 0] = '\\'; tmp[i + 1] = ""       abtnvfr             e  "" ""                              "" ""                              "" ""  \\""[r]; } else { break; } rc = 2; runes++; } else { break; } } tmp[i++] = '\0'; if (runes < min && runes >= 2 && str_type == R_STRING_TYPE_ASCII && needle < to) { needle -= 2; } if (runes >= min) { int j, num_blocks, *block_list; int *freq_list = NULL, expected_ascii, actual_ascii, num_chars; if (str_type == R_STRING_TYPE_ASCII) { for (j = 0; j < i; j++) { char ch = tmp[j]; if (ch != '\n' && ch != '\r' && ch != '\t') { if (!IS_PRINTABLE (tmp[j])) { continue; } } } } switch (str_type) { case R_STRING_TYPE_UTF8: case R_STRING_TYPE_WIDE: case R_STRING_TYPE_WIDE32: num_blocks = 0; block_list = r_utf_block_list ((const ut8*)tmp, i - 1, str_type == R_STRING_TYPE_WIDE? &freq_list: NULL); if (block_list) { for (j = 0; block_list[j] != -1; j++) { num_blocks++; } } if (freq_list) { num_chars = 0; actual_ascii = 0; for (j = 0; freq_list[j] != -1; j++) { num_chars += freq_list[j]; if (!block_list[j]) { actual_ascii = freq_list[j]; } } free (freq_list); expected_ascii = num_blocks ? num_chars / num_blocks : 0; if (actual_ascii > expected_ascii) { ascii_only = true; needle = str_start; free (block_list); continue; } } free (block_list); if (num_blocks > R_STRING_MAX_UNI_BLOCKS) { needle++; continue; } } RBinString *bs = R_NEW0 (RBinString); if (!bs) { break; } bs->type = str_type; bs->length = runes; bs->size = needle - str_start; bs->ordinal = count++; switch (str_type) { case R_STRING_TYPE_WIDE: if (str_start - from > 1) { const ut8 *p = buf + str_start - 2 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 2; } } break; case R_STRING_TYPE_WIDE32: if (str_start - from > 3) { const ut8 *p = buf + str_start - 4 - from; if (p[0] == 0xff && p[1] == 0xfe) { str_start -= 4; } } break; } if (!s) { if (section) { s = section; } else if (bf->o) { s = r_bin_get_section_at (bf->o, str_start, false); } if (s) { vdelta = s->vaddr; pdelta = s->paddr; } } ut64 baddr = bf->loadaddr && bf->o? bf->o->baddr: bf->loadaddr; bs->paddr = str_start + baddr; bs->vaddr = str_start - pdelta + vdelta + baddr; bs->string = r_str_ndup ((const char *)tmp, i); if (list) { r_list_append (list, bs); if (bf->o) { ht_up_insert (bf->o->strings_db, bs->vaddr, bs); } } else { print_string (bf, bs, raw, pj); r_bin_string_free (bs); } if (from == 0 && to == bf->size) { s = NULL; } } ascii_only = false; } free (buf); if (pj) { pj_end (pj); if (bin) { RIO *io = bin->iob.io; if (io) { io->cb_printf (""%s"", pj_string (pj)); } } pj_free (pj); } return count; }"
"static int exif_scan_JPEG_header(image_info_type *ImageInfo) { int section, sn; int marker = 0, last_marker = M_PSEUDO, comment_correction=1; int ll, lh; unsigned char *Data; size_t fpos, size, got, itemlen; jpeg_sof_info  sof_info; for(section=0;;section++) { if (last_marker==M_COM && comment_correction) { comment_correction = 2; } do { if ((marker = ImageInfo->infile->getc()) == EOF) { raise_warning(""File structure corrupted""); return 0; } if (last_marker==M_COM && comment_correction>0) { if (marker!=0xFF) { marker = 0xff; comment_correction--; } else  { last_marker = M_PSEUDO;  } } } while (marker == 0xff); if (last_marker==M_COM && !comment_correction) { raise_notice(""Image has corrupt COM section: some software set "" ""wrong length information""); } if (last_marker==M_COM && comment_correction) return M_EOI;  fpos = ImageInfo->infile->tell(); if (marker == 0xff) { raise_warning(""To many padding bytes""); return 0; } if ((lh = ImageInfo->infile->getc()) == EOF) { raise_warning(""File structure corrupted""); return 0; } if ((ll = ImageInfo->infile->getc()) == EOF) { raise_warning(""File structure corrupted""); return 0; } itemlen = (lh << 8) | ll; if (itemlen < 2) { raise_warning(""File structure corrupted""); return 0; } sn = exif_file_sections_add(ImageInfo, marker, itemlen+1, nullptr); if (sn == -1) return 0; Data = ImageInfo->file.list[sn].data; Data[0] = (unsigned char)lh; Data[1] = (unsigned char)ll; String str = ImageInfo->infile->read(itemlen-2); got = str.length(); if (got != itemlen-2) { raise_warning(""Error reading from file: "" ""got=x%04lX(=%lu) != itemlen-2=x%04lX(=%lu)"", got, got, itemlen-2, itemlen-2); return 0; } memcpy(Data+2, str.c_str(), got); switch(marker) { case M_SOS:    if (ImageInfo->read_all) { fpos = ImageInfo->infile->tell(); size = ImageInfo->FileSize - fpos; sn = exif_file_sections_add(ImageInfo, M_PSEUDO, size, nullptr); if (sn == -1) return 0; Data = ImageInfo->file.list[sn].data; str = ImageInfo->infile->read(size); got = str.length(); if (got != size) { raise_warning(""Unexpected end of file reached""); return 0; } memcpy(Data, str.c_str(), got); } return 1; case M_EOI:    raise_warning(""No image in jpeg!""); return (ImageInfo->sections_found&(~FOUND_COMPUTED)) ? 1 : 0; case M_COM:  exif_process_COM(ImageInfo, (char *)Data, itemlen); break; case M_EXIF: if (!(ImageInfo->sections_found&FOUND_IFD0)) { exif_process_APP1(ImageInfo, (char *)Data, itemlen, fpos); } break; case M_APP12: exif_process_APP12(ImageInfo, (char *)Data, itemlen); break; case M_SOF0: case M_SOF1: case M_SOF2: case M_SOF3: case M_SOF5: case M_SOF6: case M_SOF7: case M_SOF9: case M_SOF10: case M_SOF11: case M_SOF13: case M_SOF14: case M_SOF15: exif_process_SOFn(Data, marker, &sof_info); ImageInfo->Width  = sof_info.width; ImageInfo->Height = sof_info.height; if (sof_info.num_components == 3) { ImageInfo->IsColor = 1; } else { ImageInfo->IsColor = 0; } break; default: break; } last_marker = marker; } return 1; }"
"void *calloc(size_t nmemb, size_t size) { return zalloc(nmemb * size); }"
int32_t calculate_operand_data_length(const DnnOperand* oprd) { return oprd->dims[0] * oprd->dims[1] * oprd->dims[2] * oprd->dims[3] * sizeof(float); }
"PyObject *addobjectace(addobjectacefunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access, PyObject *obObjectTypeGuid, PyObject *obInheritedObjectTypeGuid, PyObject *obSID) { BOOL bsuccess; PACL pdacl = This->GetACL(); PACL pdacl_padded = NULL; PSID psid; GUID ObjectTypeGuid, InheritedObjectTypeGuid; GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL; if (addfunc == NULL) return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname); if (obObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid)) return NULL; pObjectTypeGuid = &ObjectTypeGuid; } if (obInheritedObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid)) return NULL; pInheritedObjectTypeGuid = &InheritedObjectTypeGuid; } if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addfunc)(pdacl, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid); if (bsuccess) bsuccess = _ReorderACL(pdacl); else { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(funcname, err); unsigned short required_size = pdacl->AclSize + sizeof(ACCESS_ALLOWED_OBJECT_ACE) + (unsigned short)GetLengthSid(psid); pdacl_padded = (ACL *)malloc(required_size); if (pdacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size); ZeroMemory(pdacl_padded, required_size); memcpy(pdacl_padded, pdacl, pdacl->AclSize); pdacl_padded->AclSize = required_size; bsuccess = (*addfunc)(pdacl_padded, revision, aceflags, access, pObjectTypeGuid, pInheritedObjectTypeGuid, psid); if (bsuccess) { bsuccess = _ReorderACL(pdacl_padded); if (bsuccess) bsuccess = This->SetACL(pdacl_padded); } else PyWin_SetAPIError(funcname); } if (pdacl_padded) free(pdacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }"
"static int mqtt_read_message_chunk(struct mqtt_client *client, struct buf_ctx *buf, u32_t length) { int remaining; int len; remaining = length - (buf->end - buf->cur); if (remaining <= 0) { return 0; } if (buf->end + remaining > client->rx_buf + client->rx_buf_size) { MQTT_ERR(""[CID %p]: Buffer too small to receive the message"", client); return -ENOMEM; } len = mqtt_transport_read(client, buf->end, remaining, false); if (len < 0) { MQTT_TRC(""[CID %p]: Transport read error: %d"", client, len); return len; } if (len == 0) { MQTT_TRC(""[CID %p]: Connection closed."", client); return -ENOTCONN; } client->internal.rx_buf_datalen += len; buf->end += len; if (len < remaining) { MQTT_TRC(""[CID %p]: Message partially received."", client); return -EAGAIN; } return 0; }"
"static int db__message_reconnect_reset_incoming(struct mosquitto *context) { struct mosquitto_client_msg *msg, *tmp; context->msgs_in.inflight_bytes = 0; context->msgs_in.inflight_bytes12 = 0; context->msgs_in.inflight_count = 0; context->msgs_in.inflight_count12 = 0; context->msgs_in.queued_bytes = 0; context->msgs_in.queued_bytes12 = 0; context->msgs_in.queued_count = 0; context->msgs_in.queued_count12 = 0; context->msgs_in.inflight_quota = context->msgs_in.inflight_maximum; DL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){ db__msg_add_to_inflight_stats(&context->msgs_in, msg); if(msg->qos > 0){ util__decrement_receive_quota(context); } if(msg->qos != 2){ db__message_remove_from_inflight(&context->msgs_in, msg); }else{ } } DL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){ db__msg_add_to_queued_stats(&context->msgs_in, msg); if(db__ready_for_flight(context, mosq_md_in, msg->qos)){ switch(msg->qos){ case 0: msg->state = mosq_ms_publish_qos0; break; case 1: msg->state = mosq_ms_publish_qos1; break; case 2: msg->state = mosq_ms_publish_qos2; break; } db__message_dequeue_first(context, &context->msgs_in); } } return MOSQ_ERR_SUCCESS; }"
"njs_int_t njs_array_prototype_to_string(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_index_t unused) { njs_int_t           ret; njs_value_t         value; njs_lvlhsh_query_t  lhq; static const njs_value_t  join_string = njs_string(""join""); if (njs_is_object(&args[0])) { njs_object_property_init(&lhq, &join_string, NJS_JOIN_HASH); ret = njs_object_property(vm, &args[0], &lhq, &value); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } if (njs_is_function(&value)) { return njs_function_apply(vm, njs_function(&value), args, nargs, &vm->retval); } } return njs_object_prototype_to_string(vm, args, nargs, unused); }"
"GF_EXPORT GF_ISOMHEVCType gf_isom_get_hevc_lhvc_type(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { u32 type; GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return GF_ISOM_HEVCTYPE_NONE; if (!gf_isom_is_video_handler_type(trak->Media->handler->handlerType)) return GF_ISOM_HEVCTYPE_NONE; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return GF_ISOM_HEVCTYPE_NONE; type = entry->type; if (type == GF_ISOM_BOX_TYPE_ENCV) { GF_ProtectionSchemeInfoBox *sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (sinf && sinf->original_format) type = sinf->original_format->data_format; } else if (type == GF_ISOM_BOX_TYPE_RESV) { if (entry->rinf && entry->rinf->original_format) type = entry->rinf->original_format->data_format; } if (type == GF_ISOM_BOX_TYPE_DVHE) { type = GF_ISOM_BOX_TYPE_HEV1; } switch (type) { case GF_ISOM_BOX_TYPE_HVC1: case GF_ISOM_BOX_TYPE_HEV1: case GF_ISOM_BOX_TYPE_HVC2: case GF_ISOM_BOX_TYPE_HEV2: case GF_ISOM_BOX_TYPE_LHV1: case GF_ISOM_BOX_TYPE_LHE1: case GF_ISOM_BOX_TYPE_HVT1: break; default: return GF_ISOM_HEVCTYPE_NONE; } if (entry->hevc_config && !entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_ONLY; if (entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_HEVC_LHVC; if (!entry->hevc_config && entry->lhvc_config) return GF_ISOM_HEVCTYPE_LHVC_ONLY; return GF_ISOM_HEVCTYPE_NONE; }"
"void Parser::PatternRewriter::VisitAssignment(Assignment* node) { DCHECK_EQ(Token::ASSIGN, node->op()); auto initializer = node->value(); auto value = initializer; auto temp = CreateTempVar(current_value_); if (IsInitializerContext()) { Expression* is_undefined = factory()->NewCompareOperation( Token::EQ_STRICT, factory()->NewVariableProxy(temp), factory()->NewUndefinedLiteral(RelocInfo::kNoPosition), RelocInfo::kNoPosition); value = factory()->NewConditional(is_undefined, initializer, factory()->NewVariableProxy(temp), RelocInfo::kNoPosition); } if (IsBindingContext() && descriptor_->declaration_kind == DeclarationDescriptor::PARAMETER && scope()->is_arrow_scope()) { RewriteParameterInitializerScope(parser_->stack_limit(), initializer, scope()->outer_scope(), scope()); } PatternContext old_context = SetAssignmentContextIfNeeded(initializer); RecurseIntoSubpattern(node->target(), value); set_context(old_context); }"
"static int restore_page_device(i_ctx_t *i_ctx_p, const gs_gstate * pgs_old, const gs_gstate * pgs_new) { gx_device *dev_old = gs_currentdevice(pgs_old); gx_device *dev_new; gx_device *dev_t1; gx_device *dev_t2; bool samepagedevice = obj_eq(dev_old->memory, &gs_int_gstate(pgs_old)->pagedevice, &gs_int_gstate(pgs_new)->pagedevice); bool LockSafetyParams = dev_old->LockSafetyParams; if ((dev_t1 = (*dev_proc(dev_old, get_page_device)) (dev_old)) == 0) return 0; if (!samepagedevice) dev_old->LockSafetyParams = false; dev_new = gs_currentdevice(pgs_new); if (dev_old != dev_new) { if ((dev_t2 = (*dev_proc(dev_new, get_page_device)) (dev_new)) == 0) samepagedevice = true; else if (dev_t1 != dev_t2) samepagedevice = false; } if (LockSafetyParams && !samepagedevice) { os_ptr op = osp; const int max_ops = 512; if (max_ops > op - osbot) { if (max_ops >= ref_stack_count(&o_stack)) return_error(gs_error_stackoverflow); } } return samepagedevice ? 0 : 1; }"
"static int dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_, proto_tree *tree, guint8 *drep _U_, char **data, int hf_name) { gint len, remaining; char *text; if (offset % 2) offset += 2 - (offset % 2); remaining = tvb_captured_length_remaining(tvb, offset); if (remaining <= 0) { if (data) *data = g_strdup(""""); return offset; } text = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN); len = (int)strlen(text); proto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text); if (data) *data = text; else g_free(text); return offset + (len + 1) * 2; }"
"static void sess_free_buffer(struct sess_data *sess_data) { int i; for (i = 0; i < 3; i++) if (sess_data->iov[i].iov_base) memzero_explicit(sess_data->iov[i].iov_base, sess_data->iov[i].iov_len); free_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base); sess_data->buf0_type = CIFS_NO_BUFFER; kfree(sess_data->iov[2].iov_base); }"
"static intset *intsetResize(intset *is, uint32_t len) { uint32_t size = len*intrev32ifbe(is->encoding); is = zrealloc(is,sizeof(intset)+size); return is; }"
"static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns) { struct mnt_namespace *new_ns; struct ucounts *ucounts; int ret; ucounts = inc_mnt_namespaces(user_ns); if (!ucounts) return ERR_PTR(-ENOSPC); new_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL); if (!new_ns) { dec_mnt_namespaces(ucounts); return ERR_PTR(-ENOMEM); } ret = ns_alloc_inum(&new_ns->ns); if (ret) { kfree(new_ns); dec_mnt_namespaces(ucounts); return ERR_PTR(ret); } new_ns->ns.ops = &mntns_operations; new_ns->seq = atomic64_add_return(1, &mnt_ns_seq); atomic_set(&new_ns->count, 1); new_ns->root = NULL; INIT_LIST_HEAD(&new_ns->list); init_waitqueue_head(&new_ns->poll); new_ns->event = 0; new_ns->user_ns = get_user_ns(user_ns); new_ns->ucounts = ucounts; return new_ns; }"
"static int dissect_ippusb(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data) { gint offset = 0; gint ret = 0; guint first_linelen; const guchar *first_line; gint next_offset; guint8 last; guint8 status_code; const guchar *last_chunk = NULL; struct ippusb_analysis *ippusbd = NULL; conversation_t *conv = NULL; struct ippusb_multisegment_pdu *new_msp = NULL; struct ippusb_multisegment_pdu *current_msp = NULL; struct ippusb_multisegment_pdu *previous_msp = NULL; gint reported_length = tvb_reported_length(tvb); gint captured_length = tvb_captured_length(tvb); if((conv = find_conversation_pinfo(pinfo, 0)) != NULL) { if (pinfo->num > conv->last_frame) { conv->last_frame = pinfo->num; } } else { conv = conversation_new(pinfo->num, &pinfo->src, &pinfo->dst, ENDPOINT_TCP, pinfo->srcport, pinfo->destport, 0); } ippusbd = get_ippusb_conversation_data(conv, pinfo); first_linelen = tvb_find_line_end(tvb, offset, tvb_ensure_captured_length_remaining(tvb, offset), &next_offset, TRUE); first_line = tvb_get_ptr(tvb, offset, first_linelen); last = tvb_get_guint8(tvb, captured_length - 1); status_code = tvb_get_bits8(tvb, 3 * BITS_PER_BYTE, BITS_PER_BYTE); if(captured_length == CHUNK_LENGTH_MIN){ last_chunk = tvb_get_ptr(tvb, offset, captured_length); } if (is_http_header(first_linelen, first_line) && last == TAG_END_OF_ATTRIBUTES && status_code != PRINT_JOB && status_code != SEND_DOCUMENT) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); if (ippusb_last_pdu >= 0 && !pinfo->fd->visited) { ippusb_last_pdu = -1; } ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, tvb, pinfo, tree, TRUE, data); } else if (global_ippusb_reassemble) { if (!pinfo->fd->visited) { gboolean save_fragmented = pinfo->fragmented; pinfo->fragmented = TRUE; proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); if (is_http_header(first_linelen, first_line)) { new_msp = pdu_store(pinfo, ippusbd->multisegment_pdus, pinfo->num, TRUE, 0); new_msp->running_size = captured_length; fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), 0, captured_length, TRUE); ippusb_last_pdu = pinfo->num; } else { previous_msp = (struct ippusb_multisegment_pdu *)wmem_tree_lookup32_le(ippusbd->multisegment_pdus, ippusb_last_pdu); if (previous_msp) { previous_msp->nxtpdu = pinfo->num; new_msp = pdu_store(pinfo, ippusbd->multisegment_pdus, previous_msp->first_frame, previous_msp->is_ipp, previous_msp->document); new_msp->running_size = previous_msp->running_size + captured_length; if ((first_linelen >= strlen(""Content-Type: "") && strncmp(first_line, ""Content-Type: "", strlen(""Content-Type: "")) == 0) && (first_linelen < strlen(""Content-Type: application/ipp"") || strncmp(first_line, ""Content-Type: application/ipp"", strlen(""Content-Type: application/ipp"")) != 0)) { new_msp->is_ipp = FALSE; } if (status_code == PRINT_JOB || status_code == SEND_DOCUMENT) { new_msp->document |= MSP_HAS_DOCUMENT; } if(!(last_chunk && strncmp(last_chunk, CHUNKED_END, CHUNK_LENGTH_MIN) == 0)){ if (captured_length < reported_length && (new_msp->document & MSP_HAS_DOCUMENT)) { tvbuff_t *new_tvb = tvb_new_subset_length(tvb, 0, captured_length); fragment_add_check(&ippusb_reassembly_table, new_tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, TRUE); new_msp->document |= MSP_DOCUMENT_TRUNCATED; } else { fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, TRUE); } if (last != NEWLINE) { fragment_add_check(&ippusb_reassembly_table, return_newline_tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), new_msp->running_size, sizeof(RETURN_NEWLINE), TRUE); new_msp->running_size += sizeof(RETURN_NEWLINE); } ippusb_last_pdu = pinfo->num; } else { new_msp->finished = TRUE; ippusb_last_pdu = -1; fragment_head *head = fragment_add_check(&ippusb_reassembly_table, tvb, offset, pinfo, new_msp->first_frame, GUINT_TO_POINTER(new_msp->first_frame), previous_msp->running_size, captured_length, FALSE); tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, ""Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); new_msp->reassembled = TRUE; pinfo->can_desegment = 0; if(processed_tvb){ ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); col_append_fstr(pinfo->cinfo, COL_INFO, "" Reassembled Data""); } } } pinfo->fragmented = save_fragmented; } } else { gboolean save_fragmented = pinfo->fragmented; pinfo->fragmented = TRUE; current_msp = (struct ippusb_multisegment_pdu *)wmem_tree_lookup32_le(ippusbd->multisegment_pdus, pinfo->num); if(current_msp && !(current_msp->is_ipp)){ return captured_length; } if (current_msp && !current_msp->finished && current_msp->nxtpdu == 0) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); fragment_head *head; if (!current_msp->reassembled) { pinfo->fd->visited = FALSE; if (captured_length < reported_length && (current_msp->document & MSP_HAS_DOCUMENT)) { tvbuff_t *new_tvb = tvb_new_subset_length(tvb, 0, captured_length); head = fragment_add_check(&ippusb_reassembly_table, new_tvb, offset, pinfo, current_msp->first_frame, GUINT_TO_POINTER(current_msp->first_frame), current_msp->running_size - captured_length, captured_length, FALSE); current_msp->document |= MSP_DOCUMENT_TRUNCATED; } else { head = fragment_add_check(&ippusb_reassembly_table, tvb, 0, pinfo, current_msp->first_frame, GUINT_TO_POINTER(current_msp->first_frame), current_msp->running_size - captured_length, captured_length, FALSE); } pinfo->fd->visited = TRUE; current_msp->reassembled = TRUE; } else { head = fragment_get_reassembled_id(&ippusb_reassembly_table, pinfo, current_msp->first_frame); } tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, "" Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); if (processed_tvb) { pinfo->can_desegment = 0; ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); if (current_msp->document & MSP_DOCUMENT_TRUNCATED) { col_append_fstr(pinfo->cinfo, COL_INFO, "" Document Truncated""); } } } else if ((last_chunk && strncmp(last_chunk, CHUNKED_END, CHUNK_LENGTH_MIN) == 0)) { proto_tree_add_item(tree, proto_ippusb, tvb, offset, -1, 0); fragment_head *head = fragment_get_reassembled_id(&ippusb_reassembly_table, pinfo, current_msp->first_frame); tvbuff_t *processed_tvb = process_reassembled_data(tvb, offset, pinfo, "" Reassembled IPPUSB"", head, &ippusb_frag_items, NULL, tree); if (processed_tvb) { pinfo->can_desegment = 0; ret = dissector_try_uint_new(ippusb_dissector_table, HTTP, processed_tvb, pinfo, tree, TRUE, data); col_append_fstr(pinfo->cinfo, COL_INFO, "" Reassembled Data""); if (current_msp->document & MSP_DOCUMENT_TRUNCATED) { col_append_fstr(pinfo->cinfo, COL_INFO, "" Document Truncated""); } } } pinfo->fragmented = save_fragmented; } } if (ret) { return tvb_captured_length(tvb); } else { return 0; } }"
"static void ok_jpg_decode2(ok_jpg_decoder *decoder) { ok_jpg *jpg = decoder->jpg; uint8_t jpg_header[2]; if (!ok_read(decoder, jpg_header, 2)) { return; } if (jpg_header[0] != 0xFF || jpg_header[1] != 0xD8) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid signature (not a JPEG file)""); return; } while (!decoder->eoi_found) { uint8_t buffer[2]; int marker; if (decoder->next_marker != 0) { marker = decoder->next_marker; decoder->next_marker = 0; } else { if (!ok_read(decoder, buffer, 2)) { return; } if (buffer[0] == 0xFF) { marker = buffer[1]; } else if (buffer[0] == 0x00 && buffer[1] == 0xFF) { if (!ok_read(decoder, buffer, 1)) { return; } marker = buffer[0]; } else { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid JPEG marker""); return; } } bool success = true; if (marker == 0xC0 || marker == 0xC1 || marker == 0xC2) { decoder->progressive = (marker == 0xC2); success = ok_jpg_read_sof(decoder); if (success && decoder->info_only) { return; } } else if (marker == 0xC4) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dht(decoder); } else if (marker >= 0xD0 && marker <= 0xD7) { decoder->next_marker = marker; ok_jpg_decode_restart_if_needed(decoder); success = ok_jpg_scan_to_next_marker(decoder); } else if (marker == 0xD9) { decoder->eoi_found = true; if (!decoder->info_only && decoder->progressive) { ok_jpg_progressive_finish(decoder); } } else if (marker == 0xDA) { if (!decoder->info_only) { success = ok_jpg_read_sos(decoder); } else { success = ok_jpg_skip_segment(decoder); if (success) { success = ok_jpg_scan_to_next_marker(decoder); } } } else if (marker == 0xDB) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dqt(decoder); } else if (marker == 0xDD) { success = ok_jpg_read_dri(decoder); } else if (marker == 0xE1) { success = ok_jpg_read_exif(decoder); } else if ((marker >= 0xE0 && marker <= 0xEF) || marker == 0xFE) { success = ok_jpg_skip_segment(decoder); } else if (marker == 0xFF) { } else { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Unsupported or corrupt JPEG""); success = false; } if (!success) { return; } } if (decoder->num_components == 0) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""SOF not found""); } else { for (int i = 0; i < decoder->num_components; i++) { if (!decoder->components[i].complete) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Missing JPEG image data""); break; } } } }"
"size_t count_in_range(size_t start, size_t len, bool value) const { VERIFY(start < m_size); VERIFY(start + len <= m_size); if (len == 0) return 0; static const u8 bitmask_first_byte[8] = { 0xFF, 0xFE, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80 }; static const u8 bitmask_last_byte[8] = { 0x0, 0x1, 0x3, 0x7, 0xF, 0x1F, 0x3F, 0x7F }; size_t count; const u8* first = &m_data[start / 8]; const u8* last = &m_data[(start + len) / 8]; u8 byte = *first; byte &= bitmask_first_byte[start % 8]; if (first == last) { byte &= bitmask_last_byte[(start + len) % 8]; count = __builtin_popcount(byte); } else { count = __builtin_popcount(byte); byte = *last; byte &= bitmask_last_byte[(start + len) % 8]; count += __builtin_popcount(byte); if (++first < last) { const u32* ptr32 = (const u32*)(((FlatPtr)first + sizeof(u32) - 1) & ~(sizeof(u32) - 1)); if ((const u8*)ptr32 > last) ptr32 = (const u32*)last; while (first < (const u8*)ptr32) { count += __builtin_popcount(*first); first++; } const u32* last32 = (const u32*)((FlatPtr)last & ~(sizeof(u32) - 1)); while (ptr32 < last32) { count += __builtin_popcountl(*ptr32); ptr32++; } for (first = (const u8*)ptr32; first < last; first++) count += __builtin_popcount(*first); } } if (!value) count = len - count; return count; }"
